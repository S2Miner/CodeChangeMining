[{"original_method":"public MetaSearchPanel() {\n\n            final JLabel labelDomain, labelScope, labelResult;\n            final GridBagConstraints gb = new GridBagConstraints();\n            \n            optionsPanel = new OptionsPanel(new GridBagLayout()); // on MDSMGU\n            gb.fill = GridBagConstraints.HORIZONTAL;\n            gb.gridy = 0; // first row starts at 0\n\n            labelDomain = new JLabel(VueResources.getString(\"searchgui.maps\"), SwingConstants.RIGHT);            \n          //labelScope = new JLabel(VueResources.getString(\"searchgui.searchtype\"), SwingConstants.RIGHT); // too long\n            labelScope = new JLabel(VueResources.getString(\"searchgui.search\")+\":\", SwingConstants.RIGHT); // short & sweet\n            labelResult = new JLabel(GUI.ensureColon(VueResources.getString(\"searchgui.results\")), SwingConstants.RIGHT);\n            \n            choiceDomain = getChooser(SearchDomains, locationChoiceListener, \"locationTypes\");\n            choiceFields = getChooser(SearchScope, searchTypesListener, \"searchScope\");\n            choiceResult = getChooser(CurrentMapResultsTypes, resultsTypeListener, \"resultTypes\");\n            \n            if (DEBUG.TEST) {\n                addPair(gb, labelDomain, choiceDomain);\n                addPair(gb, labelScope, choiceFields);\n            } else {\n                addPair(gb, labelScope, choiceFields);\n                addPair(gb, labelDomain, choiceDomain);\n            }\n            addPair(gb, labelResult, choiceResult);\n\n\n            if (DEBUG.BOXES || DEBUG_LOCAL) optionsPanel.setBackground(Color.BLUE);\n\n            linePanel = new JPanel() {\n                protected void paintComponent(java.awt.Graphics g) {\n                    if (isOpaque()) {\n                    \tg.setColor(getBackground());\n                        g.fillRect(0, 0, getWidth(), getHeight());\n                    }\n\n                    g.setColor(java.awt.Color.DARK_GRAY);\n                    g.drawLine(HALF_GUTTER, getHeight() / 2, getWidth() - HALF_GUTTER - 1, getHeight() / 2);\n                }\n            };\n\n            searchHeaderTbl = new JTable(new SearchHeaderTableModel());\n            searchHeaderTbl.setOpaque(false);\n            searchHeaderTbl.setRowHeight(ROW_HEIGHT);\n            if (DEBUG.BOXES) {\n                searchHeaderTbl.setShowGrid(true);\n                searchHeaderTbl.setGridColor(Color.red);\n            } else\n                searchHeaderTbl.setShowGrid(false);\n                \n            searchHeaderTbl.setIntercellSpacing(new Dimension(GUTTER, GUTTER));\n\n            searchTermsTbl = new JTable(new SearchTermsTableModel());                \n            adjustColumnModel();\n            searchTermsTbl.setDefaultRenderer(java.lang.Object.class, new SearchTermsTableRenderer());\n            searchTermsTbl.setDefaultEditor(java.lang.Object.class, new SearchTermsTableEditor());\n            ((DefaultCellEditor) searchTermsTbl .getDefaultEditor(java.lang.Object.class)).setClickCountToStart(1);\n            searchTermsTbl.setRowHeight(ROW_HEIGHT);\n            searchTermsTbl.getTableHeader().setReorderingAllowed(false);\n            searchTermsTbl.setGridColor(new java.awt.Color(getBackground()\n                    .getRed(), getBackground().getBlue(), getBackground()\n                    .getGreen(), 0));\n            searchTermsTbl.setBackground(getBackground());        \n            searchTermsTbl.setIntercellSpacing(new Dimension(GUTTER, GUTTER));\n\n            searchTermsTbl.addMouseListener(new java.awt.event.MouseAdapter() {\n                public void mouseReleased(java.awt.event.MouseEvent evt) {\n                    if (evt.getX() > searchTermsTbl.getWidth() - BUTTON_COL_WIDTH) {\n                        // java.util.List<VueMetadataElement>\n                        // searchTermsList =\n                        // MetadataSearchMainGUI.this.searchTerms;\n                        int selectedRow = searchTermsTbl.getSelectedRow();\n\n                        if (searchTermsTbl.getSelectedColumn() == buttonColumn\n                                && searchTerms.size() > selectedRow) {                                    \n                            searchTerms.remove(selectedRow);\n                            searchTermsTbl.repaint();\n                            requestFocusInWindow();\n                        }\n                    }\n                }\n            });\n\n            tablePanel = new JPanel(new GridBagLayout());\n            final GridBagConstraints tablePanelGBC = new GridBagConstraints();\n            tablePanelGBC.fill = GridBagConstraints.HORIZONTAL;\n            tablePanelGBC.insets = new Insets(0, 0, 0, 0);\n            tablePanelGBC.weightx = 1.0;\n            tablePanelGBC.gridx = 0;\n            tablePanelGBC.gridy = 0;\n\n            if (macLeopardAndOr != null) {\n                tablePanel.add(new JLabel(\"HERE MY BUDDY\"), tablePanelGBC);\n                tablePanelGBC.fill = GridBagConstraints.REMAINDER;\n                tablePanelGBC.anchor = GridBagConstraints.EAST;\n                tablePanel.add(macLeopardAndOr, tablePanelGBC);\n                tablePanelGBC.gridy++;\n                tablePanelGBC.fill = GridBagConstraints.HORIZONTAL;\n            }\n            \n            tablePanel.add(searchHeaderTbl, tablePanelGBC);\n            tablePanelGBC.gridy++;\n\n            tablePanel.add(searchTermsTbl, tablePanelGBC);\n            tablePanelGBC.gridy++;\n\n            if (DEBUG_LOCAL || DEBUG.BOXES) {\n            \tsearchHeaderTbl.setOpaque(true);\n            \tsearchHeaderTbl.setBackground(Color.BLUE);\n            \tsearchTermsTbl.setOpaque(true);\n            \tsearchTermsTbl.setBackground(Color.BLUE);\n            \ttablePanel.setOpaque(true);\n            \ttablePanel.setBackground(Color.BLUE);\n            }\n\n            saveButton = new JButton(VueResources.getString(\"searchgui.save\"));\n            saveButton.setFont(tufts.vue.gui.GUI.LabelFace);\n            saveButton.addActionListener(new ActionListener() { // TODO: CHRIST: MORE REPEATED CODE???\n                    public void actionPerformed(ActionEvent e) {\n                        if (DEBUG.Enabled) Log.debug(\"saveButton action: \" + e);\n                        runSaveAction(e);\n                    }\n                });\n\n            resetButton = new JButton(VueResources.getString(\"searchgui.resetmap\"));\n            resetButton.setFont(tufts.vue.gui.GUI.LabelFace);\n            resetButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    SearchAction.revertGlobalSearchSelectionFromMSGUI();\n                    VUE.getActiveViewer().repaint();\n                }\n            });\n\n            searchButton = new JButton(VueResources.getString(\"searchgui.search\"));\n            searchButton.setFont(tufts.vue.gui.GUI.LabelFace);\n            searchButton.addActionListener(new ActionListener() {\n                    public void actionPerformed(ActionEvent e) {\n                        if (searchTermsTbl.isEditing())\n                            searchTermsTbl.getCellEditor().stopCellEditing();\n                        \n                        //final SearchType whichFieldsToSearch = (SearchType) getChosen(choiceFields);\n                        MetadataSearchMainGUI.this.searchType = (SearchType) getChosen(choiceFields);\n                        MetadataSearchMainGUI.this.termsAction = new SearchAction(searchTerms);\n                        \n                        termsAction.setParamsByType(searchType);\n                        termsAction.setResultAction(getChosen(choiceResult));\n                        \n                        if (ALL_MAPS_STRING.equals(getChosenString(choiceDomain)))\n                            termsAction.setLocationType(SearchAction.SEARCH_ALL_OPEN_MAPS);\n                        else\n                            termsAction.setLocationType(SearchAction.SEARCH_SELECTED_MAP);\n\n                        termsAction.setOperator(getSelectedOperator());\n\n                        //        if (SEARCH_LABELS_ONLY.equals(fields)) { searchType = LABEL;\n                        // } else if (SEARCH_ALL_KEYWORDS.equals(fields)) { searchType = KEYWORD;\n                        // } else if (SEARCH_CATEGORIES_AND_KEYWORDS.equals(fields)) { searchType = CATEGORY;\n                        // } else { // if (SEARCH_EVERYTHING.equals(fields)) searchType = EVERYTHING;\n                        // }\n\n                        termsAction.fire(this, \"searchFromPanelButton\");\n                    }\n                });\n\n            termsAction.setResultAction(SearchAction.RA_SELECT);\n            //setResultsTypeInActions(\"Select\");\n\n            searchPanel = new JPanel(new GridBagLayout());\n            GridBagConstraints searchPanelGBC = new GridBagConstraints();\n            searchPanelGBC.insets = new Insets(HALF_GUTTER, HALF_GUTTER, HALF_GUTTER, HALF_GUTTER);\n            searchPanelGBC.fill = GridBagConstraints.HORIZONTAL;\n            searchPanelGBC.weightx = 0.0;\n            searchPanelGBC.gridy = 0;\n\n            searchPanelGBC.gridx = 0;\n            searchPanel.add(saveButton, searchPanelGBC);\n\n            // An empty panel to take up the space between saveButton to the left and the other\n            // two buttons to the right.\n            searchPanelGBC.gridx = 1;\n            searchPanelGBC.weightx = 1.0;\n            searchPanel.add(new JPanel(), searchPanelGBC);\n\n            searchPanelGBC.gridx = 2;\n            searchPanelGBC.weightx = 0.0;\n            searchPanel.add(resetButton, searchPanelGBC);\n\n            searchPanelGBC.gridx = 3;\n            searchPanel.add(searchButton, searchPanelGBC);\n\n            searchPanel.setOpaque(true);\n            searchPanel.setBackground(getBackground());\n\n            if (DEBUG_LOCAL || DEBUG.BOXES) {\n                saveButton.setOpaque(true);\n                saveButton.setBackground(Color.YELLOW);\n                resetButton.setOpaque(true);\n                resetButton.setBackground(Color.YELLOW);\n                searchButton.setOpaque(true);\n                searchButton.setBackground(Color.YELLOW);\n                searchPanel.setBackground(Color.CYAN);\n            }\n\n            topPanel = new JPanel(new GridBagLayout());\n            GridBagConstraints topPanelGBC = new GridBagConstraints();\n            topPanelGBC.fill = GridBagConstraints.HORIZONTAL;\n            topPanelGBC.weightx = 1.0;\n            topPanelGBC.insets = new java.awt.Insets(HALF_GUTTER, HALF_GUTTER, 0, HALF_GUTTER);\n            topPanelGBC.gridx = 0;\n\n            topPanelGBC.gridy = 0;\n            topPanel.add(optionsPanel, topPanelGBC);\n\n            topPanelGBC.insets = new java.awt.Insets(0, HALF_GUTTER, 0, HALF_GUTTER);\n            topPanelGBC.gridy = 1;\n            topPanel.add(linePanel, topPanelGBC);\n\n            topPanelGBC.gridy = 2;\n            topPanel.add(tablePanel, topPanelGBC);\n\n            topPanelGBC.gridy = 3;\n            topPanelGBC.insets = new java.awt.Insets(0, HALF_GUTTER, HALF_GUTTER, HALF_GUTTER);\n            topPanel.add(searchPanel, topPanelGBC);\n\n            if (DEBUG_LOCAL || DEBUG.BOXES) {\n            \tlinePanel.setBackground(Color.CYAN);\n            \tlinePanel.setOpaque(true);\n            \ttopPanel.setBackground(Color.ORANGE);\n            }\n\n            setLayout(new BorderLayout());\n            add(topPanel);\n        }","id":23000,"modified_method":"public MetaSearchPanel() {\n\n            final JLabel labelScope, labelDomain, labelResult;\n            final GridBagConstraints gb = new GridBagConstraints();\n            \n            optionsPanel = new OptionsPanel(new GridBagLayout()); // on MDSMGU\n            gb.fill = GridBagConstraints.HORIZONTAL;\n            gb.gridy = 0; // first row starts at 0\n\n            labelScope = new JLabel(VueResources.local(\"searchgui.maps\"), SwingConstants.RIGHT);            \n          //labelDomain = new JLabel(VueResources.local(\"searchgui.searchtype\"), SwingConstants.RIGHT); // too long\n            labelDomain = new JLabel(VueResources.local(\"searchgui.search\")+\":\", SwingConstants.RIGHT); // short & sweet\n            labelResult = new JLabel(GUI.ensureColon(VueResources.local(\"searchgui.results\")), SwingConstants.RIGHT);\n            \n            choiceScope = getChooser(SearchScopes, locationChoiceListener, \"searchScope\");\n            choiceDomain = getChooser(SearchDomains, searchTypesListener, \"searchDomain\");\n            choiceResult = getChooser(ResultActions, resultsTypeListener, \"resultAction\");\n            \n            if (DEBUG.TEST) {\n                addPair(gb, labelScope, choiceScope);\n                addPair(gb, labelDomain, choiceDomain);\n            } else {\n                addPair(gb, labelDomain, choiceDomain);\n                addPair(gb, labelScope, choiceScope);\n            }\n            addPair(gb, labelResult, choiceResult);\n\n\n            if (DEBUG.BOXES || DEBUG_LOCAL) optionsPanel.setBackground(Color.BLUE);\n\n            linePanel = new JPanel() {\n                protected void paintComponent(java.awt.Graphics g) {\n                    if (isOpaque()) {\n                    \tg.setColor(getBackground());\n                        g.fillRect(0, 0, getWidth(), getHeight());\n                    }\n\n                    g.setColor(java.awt.Color.DARK_GRAY);\n                    g.drawLine(HALF_GUTTER, getHeight() / 2, getWidth() - HALF_GUTTER - 1, getHeight() / 2);\n                }\n            };\n\n            searchHeaderTbl = new JTable(new SearchHeaderTableModel());\n            searchHeaderTbl.setOpaque(false);\n            searchHeaderTbl.setRowHeight(ROW_HEIGHT);\n            if (DEBUG.BOXES) {\n                searchHeaderTbl.setShowGrid(true);\n                searchHeaderTbl.setGridColor(Color.red);\n            } else\n                searchHeaderTbl.setShowGrid(false);\n                \n            searchHeaderTbl.setIntercellSpacing(new Dimension(GUTTER, GUTTER));\n\n            searchTermsTbl = new JTable(new SearchTermsTableModel());                \n            adjustColumnModel();\n            searchTermsTbl.setDefaultRenderer(java.lang.Object.class, new SearchTermsTableRenderer());\n            searchTermsTbl.setDefaultEditor(java.lang.Object.class, new SearchTermsTableEditor());\n            ((DefaultCellEditor) searchTermsTbl .getDefaultEditor(java.lang.Object.class)).setClickCountToStart(1);\n            searchTermsTbl.setRowHeight(ROW_HEIGHT);\n            searchTermsTbl.getTableHeader().setReorderingAllowed(false);\n            searchTermsTbl.setGridColor(new java.awt.Color(getBackground()\n                    .getRed(), getBackground().getBlue(), getBackground()\n                    .getGreen(), 0));\n            searchTermsTbl.setBackground(getBackground());        \n            searchTermsTbl.setIntercellSpacing(new Dimension(GUTTER, GUTTER));\n\n            searchTermsTbl.addMouseListener(new java.awt.event.MouseAdapter() {\n                public void mouseReleased(java.awt.event.MouseEvent evt) {\n                    if (evt.getX() > searchTermsTbl.getWidth() - BUTTON_COL_WIDTH) {\n                        // java.util.List<VueMetadataElement>\n                        // searchTermsList =\n                        // MetadataSearchMainGUI.this.searchTerms;\n                        int selectedRow = searchTermsTbl.getSelectedRow();\n\n                        if (searchTermsTbl.getSelectedColumn() == buttonColumn\n                                && searchTerms.size() > selectedRow) {                                    \n                            searchTerms.remove(selectedRow);\n                            searchTermsTbl.repaint();\n                            requestFocusInWindow();\n                        }\n                    }\n                }\n            });\n\n            tablePanel = new JPanel(new GridBagLayout());\n            final GridBagConstraints tablePanelGBC = new GridBagConstraints();\n            tablePanelGBC.fill = GridBagConstraints.HORIZONTAL;\n            tablePanelGBC.insets = new Insets(0, 0, 0, 0);\n            tablePanelGBC.weightx = 1.0;\n            tablePanelGBC.gridx = 0;\n            tablePanelGBC.gridy = 0;\n\n            // if (macLeopardAndOr != null) {\n            //     tablePanel.add(new JLabel(\"HERE MY BUDDY\"), tablePanelGBC);\n            //     tablePanelGBC.fill = GridBagConstraints.REMAINDER;\n            //     tablePanelGBC.anchor = GridBagConstraints.EAST;\n            //     tablePanel.add(macLeopardAndOr, tablePanelGBC);\n            //     tablePanelGBC.gridy++;\n            //     tablePanelGBC.fill = GridBagConstraints.HORIZONTAL;\n            // }\n            \n            tablePanel.add(searchHeaderTbl, tablePanelGBC);\n            tablePanelGBC.gridy++;\n\n            tablePanel.add(searchTermsTbl, tablePanelGBC);\n            tablePanelGBC.gridy++;\n\n            if (DEBUG_LOCAL || DEBUG.BOXES) {\n            \tsearchHeaderTbl.setOpaque(true);\n            \tsearchHeaderTbl.setBackground(Color.BLUE);\n            \tsearchTermsTbl.setOpaque(true);\n            \tsearchTermsTbl.setBackground(Color.BLUE);\n            \ttablePanel.setOpaque(true);\n            \ttablePanel.setBackground(Color.BLUE);\n            }\n\n            saveButton = new JButton(VueResources.local(\"searchgui.save\"));\n            saveButton.setFont(tufts.vue.gui.GUI.LabelFace);\n            saveButton.addActionListener(new ActionListener() { // TODO: CHRIST: MORE REPEATED CODE???\n                    public void actionPerformed(ActionEvent e) {\n                        if (DEBUG.Enabled) Log.debug(\"saveButton action: \" + e);\n                        runSaveAction(e);\n                    }\n                });\n\n            resetButton = new JButton(VueResources.local(\"searchgui.resetmap\"));\n            resetButton.setFont(tufts.vue.gui.GUI.LabelFace);\n            resetButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    SearchAction.revertGlobalSearchSelectionFromMSGUI();\n                    updateEnabled();\n                    VUE.getActiveViewer().repaint();\n                }\n            });\n\n            searchButton = new JButton(VueResources.local(\"searchgui.search\"));\n            searchButton.setFont(tufts.vue.gui.GUI.LabelFace);\n            searchButton.addActionListener(new ActionListener() {\n                    public void actionPerformed(ActionEvent e) {\n                        if (searchTermsTbl.isEditing())\n                            searchTermsTbl.getCellEditor().stopCellEditing();\n                        \n                        MetadataSearchMainGUI.this.searchType = (SearchType) getChosen(choiceDomain);\n                        MetadataSearchMainGUI.this.termsAction = new SearchAction(searchTerms);\n                        \n                        termsAction.setLocationType(getChosen(choiceScope));\n                        termsAction.setOperator(getSelectedOperator());\n                        termsAction.setParamsByType(searchType);\n                        termsAction.setResultAction(getChosen(choiceResult));\n\n                        termsAction.fire(this, \"from.searchButton\");\n                        updateEnabled();\n                    }\n                });\n\n            termsAction.setResultAction(SearchAction.RA_SELECT);\n            //setResultsTypeInActions(\"Select\");\n\n            searchPanel = new JPanel(new GridBagLayout());\n            GridBagConstraints searchPanelGBC = new GridBagConstraints();\n            searchPanelGBC.insets = new Insets(HALF_GUTTER, HALF_GUTTER, HALF_GUTTER, HALF_GUTTER);\n            searchPanelGBC.fill = GridBagConstraints.HORIZONTAL;\n            searchPanelGBC.weightx = 0.0;\n            searchPanelGBC.gridy = 0;\n\n            searchPanelGBC.gridx = 0;\n            searchPanel.add(saveButton, searchPanelGBC);\n\n            // An empty panel to take up the space between saveButton to the left and the other\n            // two buttons to the right.\n            searchPanelGBC.gridx = 1;\n            searchPanelGBC.weightx = 1.0;\n            searchPanel.add(new JPanel(), searchPanelGBC);\n\n            searchPanelGBC.gridx = 2;\n            searchPanelGBC.weightx = 0.0;\n            searchPanel.add(resetButton, searchPanelGBC);\n\n            searchPanelGBC.gridx = 3;\n            searchPanel.add(searchButton, searchPanelGBC);\n\n            searchPanel.setOpaque(true);\n            searchPanel.setBackground(getBackground());\n\n            if (DEBUG_LOCAL || DEBUG.BOXES) {\n                saveButton.setOpaque(true);\n                saveButton.setBackground(Color.YELLOW);\n                resetButton.setOpaque(true);\n                resetButton.setBackground(Color.YELLOW);\n                searchButton.setOpaque(true);\n                searchButton.setBackground(Color.YELLOW);\n                searchPanel.setBackground(Color.CYAN);\n            }\n\n            topPanel = new JPanel(new GridBagLayout());\n            GridBagConstraints topPanelGBC = new GridBagConstraints();\n            topPanelGBC.fill = GridBagConstraints.HORIZONTAL;\n            topPanelGBC.weightx = 1.0;\n            topPanelGBC.insets = new java.awt.Insets(HALF_GUTTER, HALF_GUTTER, 0, HALF_GUTTER);\n            topPanelGBC.gridx = 0;\n\n            topPanelGBC.gridy = 0;\n            topPanel.add(optionsPanel, topPanelGBC);\n\n            topPanelGBC.insets = new java.awt.Insets(0, HALF_GUTTER, 0, HALF_GUTTER);\n            topPanelGBC.gridy = 1;\n            topPanel.add(linePanel, topPanelGBC);\n\n            topPanelGBC.gridy = 2;\n            topPanel.add(tablePanel, topPanelGBC);\n\n            topPanelGBC.gridy = 3;\n            topPanelGBC.insets = new java.awt.Insets(0, HALF_GUTTER, HALF_GUTTER, HALF_GUTTER);\n            topPanel.add(searchPanel, topPanelGBC);\n\n            if (DEBUG_LOCAL || DEBUG.BOXES) {\n            \tlinePanel.setBackground(Color.CYAN);\n            \tlinePanel.setOpaque(true);\n            \ttopPanel.setBackground(Color.ORANGE);\n            }\n\n            setLayout(new BorderLayout());\n            add(topPanel);\n        }","commit_id":"2f13a377b02b9e1469a9442d8cd058dd9b5d0676","url":"https://github.com/VUE/VUE"},{"original_method":"private void addPair(GridBagConstraints g, JComponent label, JComponent chooser)\n        {\n            label.setFont(tufts.vue.gui.GUI.LabelFace);\n            \n            g.gridx = 0;\n            g.insets = labelInsets;\n            //g.insets = GUI.EmptyInsets;\n            g.weightx = 0.0;\n            optionsPanel.add(label, g); // only member reference (enclosing class)\n\n            g.gridx = 1;\n            g.insets = textFieldInsets;\n            //g.insets = GUI.EmptyInsets;\n            g.weightx = 1.0;\n            optionsPanel.add(chooser, g);\n\n            g.gridy++;\n\n            if (DEBUG.BOXES) {\n                label.setBackground(Color.YELLOW);\n            \tlabel.setOpaque(true);\n                chooser.setBackground(Color.YELLOW);\n            \tchooser.setOpaque(true);\n            }\n        }","id":23001,"modified_method":"private void addPair(GridBagConstraints g, JComponent label, JComponent chooser)\n        {\n            label.setFont(tufts.vue.gui.GUI.LabelFace);\n            \n            if (DEBUG.TEST) {\n                ;\n            }  else {\n                g.gridx = 0;\n                g.insets = labelInsets;\n                //g.insets = GUI.EmptyInsets;\n                g.weightx = 0.0;\n                optionsPanel.add(label, g); // only member reference (enclosing class)\n            }\n\n            g.gridx = 1;\n            g.insets = textFieldInsets;\n            //g.insets = GUI.EmptyInsets;\n            g.weightx = 1.0;\n            optionsPanel.add(chooser, g);\n\n            g.gridy++;\n\n            if (DEBUG.BOXES) {\n                label.setBackground(Color.YELLOW);\n            \tlabel.setOpaque(true);\n                chooser.setBackground(Color.YELLOW);\n            \tchooser.setOpaque(true);\n            }\n        }","commit_id":"2f13a377b02b9e1469a9442d8cd058dd9b5d0676","url":"https://github.com/VUE/VUE"},{"original_method":"private String getSearchName(int rowCount){        \t\n        String inputValue = (String) VueUtil.input\n            (null, VueResources.getString(\"searchgui.entersearchname\"),\n             null, JOptionPane.PLAIN_MESSAGE, null,\n             (VueResources.getString(\"searchgui.search\") + \" \"+ (rowCount+1)));\n        \n        if (inputValue != null && inputValue.trim().length() == 0) {\n            inputValue = VueResources.getString(\"searchgui.search\") + \" \"+ (rowCount+1);\n        }\n        return inputValue;\n    }","id":23002,"modified_method":"private String getSearchName(int rowCount){        \t\n        String inputValue = (String) VueUtil.input\n            (null, VueResources.local(\"searchgui.entersearchname\"),\n             null, JOptionPane.PLAIN_MESSAGE, null,\n             (VueResources.local(\"searchgui.search\") + \" \"+ (rowCount+1)));\n        \n        if (inputValue != null && inputValue.trim().length() == 0) {\n            inputValue = VueResources.local(\"searchgui.search\") + \" \"+ (rowCount+1);\n        }\n        return inputValue;\n    }","commit_id":"2f13a377b02b9e1469a9442d8cd058dd9b5d0676","url":"https://github.com/VUE/VUE"},{"original_method":"/** Handle any click at the far right of the saved searches table (the _run_ \"button\") */\n    public void runSavedSearch()\n    {\n        final int selectedRow = searchResultTbl.getSelectedRow();\n        final SearchData data = searchResultModel.getSearchData(selectedRow);\n\n        if (DEBUG.SEARCH) Log.debug(\"runSavedSearch; selectedRow=\" + selectedRow + \"; data:\\n\" + Util.tags(data));\n\n        //searchTerms = data.getDataList();             \n        if (data.getDataList() != null) {\n            // What would be a saved search w/out a data-list, and what would\n            // the rest of this code go on to do if it didn't have one??\n            // It's re-using the old SearchAction...\n            termsAction = new SearchAction(data.getDataList());\n            // Does this mean if the saved search was somehow of just a type,\n            // but had no terms, we'd what -- just search with the saved OP???\n        }\n\n        termsAction.setOperator(data.logicalOp());\n        termsAction.setResultAction(data.resultOp());\n\n        // Christ: this means that all existing saved searches up till now (Summer 2012) have used the localized values\n        // for search action result type, and wont restore properly under different localizations.\n        \n        if (termsAction.getResultAction() == SearchAction.RA_SELECT) {\n            // Special case: if saved type was select, allow overriding of the saved action with\n            // the user selected action.  This is a cheap squirrely way of allowing a nice feature:\n            // using a different action with a saved search, which isn't something we have UI for,\n            // or are likely to.\n            termsAction.setResultAction(getChosen(choiceResult));\n        }\n\n        termsAction.setParamsByType(searchType);\n\n        termsAction.fire(this, \"runSavedSearch\");\n    }","id":23003,"modified_method":"/** Handle any click at the far right of the saved searches table (the _run_ \"button\") */\n    public void runSavedSearch()\n    {\n        final int selectedRow = searchResultTbl.getSelectedRow();\n        final SearchData data = searchResultModel.getSearchData(selectedRow);\n\n        if (DEBUG.SEARCH) Log.debug(\"runSavedSearch; selectedRow=\" + selectedRow + \"; data:\\n\" + Util.tags(data));\n\n        //searchTerms = data.getDataList();             \n        if (data.getDataList() != null) {\n            // What would be a saved search w/out a data-list, and what would\n            // the rest of this code go on to do if it didn't have one??\n            // It's re-using the old SearchAction...\n            termsAction = new SearchAction(data.getDataList());\n            // Does this mean if the saved search was somehow of just a type,\n            // but had no terms, we'd what -- just search with the saved OP???\n        }\n\n        termsAction.setOperator(data.logicalOp());\n        termsAction.setResultAction(data.resultOp());\n\n        // Christ: this means that all existing saved searches up till now (Summer 2012) have used the localized values\n        // for search action result type, and wont restore properly under different localizations.\n        \n        if (termsAction.getResultAction() == SearchAction.RA_SELECT) {\n            // Special case: if saved type was select, allow overriding of the saved action with\n            // the user selected action.  This is a cheap squirrely way of allowing a nice feature:\n            // using a different action with a saved search, which isn't something we have UI for,\n            // or are likely to.\n            termsAction.setResultAction(getChosen(choiceResult));\n        }\n\n        termsAction.setParamsByType(searchType);\n\n        termsAction.fire(this, \"from.runSavedSearch\");\n\n        updateEnabled();\n    }","commit_id":"2f13a377b02b9e1469a9442d8cd058dd9b5d0676","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed(ActionEvent e)\n\t{\n\t\tif (e.getSource().equals(addToNode))\n\t\t{\n\t\t\t//int index = this.locationToIndex(lastMouseClick);\n\t\t\t//this.setSelectedIndex(index);\n\t\t\t\n\t\t\t//LWComponent o = this.getSelectedComponent();\n\t\t\t\n\t\t\t//LWSelection sel = VUE.getActiveViewer().getSelection();\n\t\t\t//LWNode c = (LWNode)sel.only();\n                    \n                   //also need to check if there *is* a selected value\n                        \n                   Object type = getSelectedValue();\n                   if(type == null)\n                       return;\n                   if(type != null)\n                   {\n                       VueMetadataElement vme = new VueMetadataElement();\n                       vme.setObject(type);\n                       ((LWComponent)VUE.getActive(LWComponent.class)).getMetadataList().getMetadata().add(vme);\n                       \n                       VUE.getInspectorPane().ontologicalMetadataUpdated();\n                       \n                   }\n\t\t\t\n\t\t\t\n\t\t} if (e.getSource().equals(addToMap))\n\t\t{\n\t\t\n\t\t\tint index = this.locationToIndex(lastMouseClick);\n\t\t\tthis.setSelectedIndex(index);\n\t\t\t\n\t\t\tLWComponent o = this.getSelectedComponentCopy();\n\n\t\t\tif (o instanceof LWNode)\n\t\t\t\tVUE.getActiveMap().add((LWNode)o);\n\t\t\telse if (o instanceof LWLink)\n\t\t\t\tVUE.getActiveMap().add((LWLink)o);\n\t\t}\n\t}","id":23004,"modified_method":"public void actionPerformed(ActionEvent e)\n\t{\n\t\tif (e.getSource().equals(addToNode))\n\t\t{\n\t\t\t//int index = this.locationToIndex(lastMouseClick);\n\t\t\t//this.setSelectedIndex(index);\n\t\t\t\n\t\t\t//LWComponent o = this.getSelectedComponent();\n\t\t\t\n\t\t\t//LWSelection sel = VUE.getActiveViewer().getSelection();\n\t\t\t//LWNode c = (LWNode)sel.only();\n                    \n                   //also need to check if there *is* a selected value\n                        \n                   Object type = getSelectedValue();\n                   if(type == null)\n                       return;\n                   if(type != null)\n                   {\n                       VueMetadataElement vme = new VueMetadataElement();\n                       vme.setObject(type);\n                       ((LWComponent)VUE.getActive(LWComponent.class)).getMetadataList().getMetadata().add(vme);\n                       \n                       VUE.getInspectorPane().ontologicalMetadataUpdated();\n                       \n                   }\n\t\t\t\n\t\t\t\n\t\t} if (e.getSource().equals(addToMap))\n\t\t{\n\t\t\n\t\t\tint index = this.locationToIndex(lastMouseClick);\n\t\t\tthis.setSelectedIndex(index);\n\t\t\t\n\t\t\tLWComponent o = this.getSelectedComponentCopy();\n\n                        LWMap active = VUE.getActiveMap();\n                        \n\t\t\tif (o instanceof LWNode)\n\t\t\t\tactive.add((LWNode)o);\n\t\t\telse if (o instanceof LWLink)\n\t\t\t\tactive.add((LWLink)o);\n                        \n                        // should be outside ontology panel default location\n                        // but inside map\n                        \n                        MapViewer viewer = VUE.getActiveViewer();\n                        o.setLocation(viewer.getVisibleWidth()/2,viewer.getVisibleHeight()/2);\n\t\t}\n\t}","commit_id":"f5b4c35bbf72ac4d7f94abbcf9248399526b280e","url":"https://github.com/VUE/VUE"},{"original_method":"public void loadOntology(final URL ontologyURL,final URL cssURL,final org.osid.shared.Type ontType,\n                             final OntologyBrowser browser,final tufts.vue.gui.Widget widget)\n    {\n       Thread t = new Thread(){ \n        \n         public void run()\n         {\n           \n          JLabel loadingLabelText = new JLabel(\"loading...\"); \n          JLabel loadingLabelImage = new JLabel(tufts.vue.VueResources.getImageIcon(\"dsv.statuspanel.waitIcon\"));\n          JPanel loadingLabel = new JPanel();\n          loadingLabel.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT));;\n          loadingLabel.add(loadingLabelImage);\n          loadingLabel.add(loadingLabelText);\n          \n          //widget.removeAll();\n             \n          widget.add(loadingLabel,java.awt.BorderLayout.NORTH);\n          \n          try\n          {        \n            if(cssURL !=null)\n            {\n              ontology = OntManager.getOntManager().readOntologyWithStyle(ontologyURL,\n                                                      cssURL,\n                                                      ontType);\n            }\n            else\n            {\n              ontology = edu.tufts.vue.ontology.OntManager.getOntManager().readOntology(ontologyURL,ontType);\n            }\n          }\n          catch(Exception fnfe)\n          {\n              widget.remove(loadingLabel);\n              \n              System.out.println(\"load failure -- \" + ontologyURL);\n              \n              JLabel fileNotFound = new JLabel(\"File not found\");\n              if(!ontologyURL.toString().contains(\"file:\"))\n              {\n                  fileNotFound.setText(\"Location not found\");\n              }\n              fileNotFound.setBorder(javax.swing.BorderFactory.createEmptyBorder(10,5,10,0));\n              widget.add(fileNotFound);\n          }\n                    \n          setModel(new OntologyTypeListModel(ontology));\n          \n          widget.setName(widget.getName().substring(7,widget.getName().length()));\n          \n          widget.remove(loadingLabel);\n          //repaint();\n          //browser.addTypeList(TypeList.this,ontologyURL.getFile());\n          if(browser !=null && browser.getViewer() != null && browser.getViewer().getList() !=null && ontology != null)\n          {    \n            browser.getViewer().getList().setSelectedValue(ontology,true);\n          }\n          //clearSelection();\n          //setSelectedIndex(-1);\n          \n          try\n          {        \n            OntManager.getOntManager().getOntology(new URL(ontology.getBase())).setEnabled(true);\n          }\n          catch(java.net.MalformedURLException mue)\n          {\n              System.out.println(\"TypeList: malformed url exception attempting to enable ontology \" + mue);\n          }\n          \n          try\n          {\n           // browser.getViewer().getList().updateUI();\n           //   browser.getViewer().getList().repaint();\n              \n              \n              browser.getViewer().getList().refresh();\n              browser.getViewer().getList().repaint();\n          }\n          catch(Exception e)\n          {\n            System.out.println(\"TypeList: exception while updating ontology browser list ui -- \" + e);\n          }\n          //browser.getViewer().repaint();\n          //browser.revalidate();\n         // browser.repaint();\n          edu.tufts.vue.ontology.OntManager.getOntManager().save();\n         }\n         \n       };\n       \n       t.start();\n        \n    }","id":23005,"modified_method":"public void loadOntology(final URL ontologyURL,final URL cssURL,final org.osid.shared.Type ontType,\n                             final OntologyBrowser browser,final tufts.vue.gui.Widget widget)\n    {\n       Thread t = new Thread(){ \n        \n         public void run()\n         {\n           \n          JLabel loadingLabelText = new JLabel(\"loading...\"); \n          JLabel loadingLabelImage = new JLabel(tufts.vue.VueResources.getImageIcon(\"dsv.statuspanel.waitIcon\"));\n          JPanel loadingLabel = new JPanel();\n          loadingLabel.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT));;\n          loadingLabel.add(loadingLabelImage);\n          loadingLabel.add(loadingLabelText);\n          \n          //widget.removeAll();\n             \n          widget.add(loadingLabel,java.awt.BorderLayout.NORTH);\n          \n          try\n          {        \n            if(cssURL !=null)\n            {\n              ontology = OntManager.getOntManager().readOntologyWithStyle(ontologyURL,\n                                                      cssURL,\n                                                      ontType);\n            }\n            else\n            {\n              ontology = edu.tufts.vue.ontology.OntManager.getOntManager().readOntology(ontologyURL,ontType);\n            }\n          }\n          catch(Exception fnfe)\n          {\n              widget.remove(loadingLabel);\n              \n              System.out.println(\"load failure -- \" + ontologyURL);\n              \n              JLabel fileNotFound = new JLabel(\"File not found\");\n              if(!ontologyURL.toString().contains(\"file:\"))\n              {\n                  fileNotFound.setText(\"Location not found\");\n              }\n              fileNotFound.setBorder(javax.swing.BorderFactory.createEmptyBorder(10,5,10,0));\n              widget.add(fileNotFound);\n          }\n                    \n          setModel(new OntologyTypeListModel(ontology));\n          \n          widget.setName(widget.getName().substring(7,widget.getName().length()));\n          \n          widget.remove(loadingLabel);\n          //repaint();\n          //browser.addTypeList(TypeList.this,ontologyURL.getFile());\n          if(browser !=null && browser.getViewer() != null && browser.getViewer().getList() !=null && ontology != null)\n          {    \n            browser.getViewer().getList().setSelectedValue(ontology,true);\n          }\n          //clearSelection();\n          //setSelectedIndex(-1);\n          \n          try\n          {        \n            OntManager.getOntManager().getOntology(new URL(ontology.getBase())).setEnabled(true);\n          }\n          catch(java.net.MalformedURLException mue)\n          {\n              System.out.println(\"TypeList: malformed url exception attempting to enable ontology \" + mue);\n          }\n          catch(Exception npe)\n          {\n              System.out.println(\"TypeList: Exception, likely npe enabling ontology  -- \" + npe);\n          }\n          \n          try\n          {\n           // browser.getViewer().getList().updateUI();\n           //   browser.getViewer().getList().repaint();\n              \n              \n              browser.getViewer().getList().refresh();\n              browser.getViewer().getList().repaint();\n          }\n          catch(Exception e)\n          {\n            System.out.println(\"TypeList: exception while updating ontology browser list ui -- \" + e);\n          }\n          //browser.getViewer().repaint();\n          //browser.revalidate();\n         // browser.repaint();\n          edu.tufts.vue.ontology.OntManager.getOntManager().save();\n         }\n         \n       };\n       \n       t.start();\n        \n    }","commit_id":"f5b4c35bbf72ac4d7f94abbcf9248399526b280e","url":"https://github.com/VUE/VUE"},{"original_method":"@NotNull\n  private static TestDataDescriptor buildDescriptor(@NotNull ProjectFileIndex fileIndex,\n                                                    @NotNull Collection<String> testNames,\n                                                    @NotNull PsiClass psiClass)\n  {\n    GotoFileModel gotoModel = new GotoFileModel(psiClass.getProject());\n    List<Trinity<Matcher, String, String>> input = new ArrayList<Trinity<Matcher, String, String>>();\n    Set<String> testNamesLowerCase = new HashSet<String>();\n    for (String testName : testNames) {\n      String pattern = String.format(\"*%s*\", testName);\n      input.add(new Trinity<Matcher, String, String>(\n        NameUtil.buildMatcher(pattern, 0, true, true, pattern.toLowerCase().equals(pattern)), testName, pattern\n      ));\n      testNamesLowerCase.add(testName.toLowerCase());\n    }\n    Set<TestLocationDescriptor> descriptors = new HashSet<TestLocationDescriptor>();\n    MultiMap<String, Trinity<Matcher, String, String>> map = getAllFileNames(input, gotoModel);\n    for (String name : map.keySet()) {\n      ProgressManager.checkCanceled();\n      boolean currentNameProcessed = false;\n      for (Trinity<Matcher, String, String> trinity : map.get(name)) {\n        final Object[] elements = gotoModel.getElementsByName(name, false, trinity.third);\n        if (elements == null) {\n          continue;\n        }\n        for (Object element : elements) {\n          if (!(element instanceof PsiFile)) {\n            continue;\n          }\n          final VirtualFile file = ((PsiFile)element).getVirtualFile();\n          if (file == null || fileIndex.isInSource(file)) {\n            continue;\n          }\n\n\n          final String filePath = PathUtil.getFileName(file.getPath()).toLowerCase();\n          int i = filePath.indexOf(trinity.second.toLowerCase());\n          // Skip files that doesn't contain target test name and files that contain digit after target test name fragment.\n          // Example: there are tests with names 'testEnter()' and 'testEnter2()' and we don't want test data file 'testEnter2'\n          // to be matched to the test 'testEnter()'.\n          if (i < 0 || (i + trinity.second.length() < filePath.length())\n                       && Character.isDigit(filePath.charAt(i + trinity.second.length())))\n          {\n            continue;\n          }\n\n          TestLocationDescriptor current = new TestLocationDescriptor();\n          current.populate(trinity.second, file);\n          if (!current.isComplete()) {\n            continue;\n          }\n\n          // Handle situations like the one below:\n          //     *) test class has tests with names 'testAlignedParameters' and 'testNonAlignedParameters';\n          //     *) test data files with the following names present: 'AlignedParameters.java' and 'NonAlignedParameters.java';\n          //     *) we're processing the following (test; test data file) pair - ('testAlignedParameters'; 'NonAlignedParameters.java');\n          // We don't want to store descriptor with file prefix 'Non' here.\n          // The same is true for suffixes, e.g. tests like 'testLeaveValidCodeBlock()' and 'testLeaveValidCodeBlockWithEmptyLineAfterIt()'\n          String prefixPattern = current.filePrefix.toLowerCase();\n          boolean checkPrefix = !StringUtil.isEmpty(prefixPattern);\n          String suffixPattern = current.fileSuffix;\n          for (TestLocationDescriptor descriptor : descriptors) {\n            if (suffixPattern.endsWith(descriptor.fileSuffix)) {\n              suffixPattern = suffixPattern.substring(0, suffixPattern.length() - descriptor.fileSuffix.length());\n            }\n          }\n          suffixPattern = suffixPattern.toLowerCase();\n          boolean checkSuffix = !StringUtil.isEmpty(suffixPattern);\n          boolean skip = false;\n          for (String testName : testNamesLowerCase) {\n            if (testName.equals(trinity.second)) {\n              continue;\n            }\n            if ((checkPrefix && testName.startsWith(prefixPattern)) || (checkSuffix && testName.endsWith(suffixPattern))) {\n              skip = true;\n              break;\n            }\n          }\n          if (skip) {\n            continue;\n          }\n\n          currentNameProcessed = true;\n          if (descriptors.isEmpty() || (descriptors.iterator().next().dir.equals(current.dir) && !descriptors.contains(current))) {\n            descriptors.add(current);\n            continue;\n          }\n          if (moreRelevantPath(current, descriptors, psiClass)) {\n            descriptors.clear();\n            descriptors.add(current);\n          }\n        }\n        if (currentNameProcessed) {\n          break;\n        }\n      }\n    }\n    return new TestDataDescriptor(descriptors);\n  }","id":23006,"modified_method":"@NotNull\n  private static TestDataDescriptor buildDescriptor(@NotNull ProjectFileIndex fileIndex,\n                                                    @NotNull Collection<String> testNames,\n                                                    @NotNull PsiClass psiClass)\n  {\n    GotoFileModel gotoModel = new GotoFileModel(psiClass.getProject());\n    List<Trinity<Matcher, String, String>> input = new ArrayList<Trinity<Matcher, String, String>>();\n    Set<String> testNamesLowerCase = new HashSet<String>();\n    for (String testName : testNames) {\n      String pattern = String.format(\"*%s*\", testName);\n      input.add(new Trinity<Matcher, String, String>(\n        NameUtil.buildMatcher(pattern, 0, true, true, pattern.toLowerCase().equals(pattern)), testName, pattern\n      ));\n      testNamesLowerCase.add(testName.toLowerCase());\n    }\n    Set<TestLocationDescriptor> descriptors = new HashSet<TestLocationDescriptor>();\n    MultiMap<String, Trinity<Matcher, String, String>> map = getAllFileNames(input, gotoModel);\n    for (String name : map.keySet()) {\n      ProgressManager.checkCanceled();\n      boolean currentNameProcessed = false;\n      for (Trinity<Matcher, String, String> trinity : map.get(name)) {\n        final Object[] elements = gotoModel.getElementsByName(name, false, trinity.third);\n        if (elements == null) {\n          continue;\n        }\n        for (Object element : elements) {\n          if (!(element instanceof PsiFile)) {\n            continue;\n          }\n          final VirtualFile file = ((PsiFile)element).getVirtualFile();\n          if (file == null || fileIndex.isInSource(file) && !fileIndex.isUnderSourceRootOfType(file, JavaModuleSourceRootTypes.RESOURCES)) {\n            continue;\n          }\n\n\n          final String filePath = PathUtil.getFileName(file.getPath()).toLowerCase();\n          int i = filePath.indexOf(trinity.second.toLowerCase());\n          // Skip files that doesn't contain target test name and files that contain digit after target test name fragment.\n          // Example: there are tests with names 'testEnter()' and 'testEnter2()' and we don't want test data file 'testEnter2'\n          // to be matched to the test 'testEnter()'.\n          if (i < 0 || (i + trinity.second.length() < filePath.length())\n                       && Character.isDigit(filePath.charAt(i + trinity.second.length())))\n          {\n            continue;\n          }\n\n          TestLocationDescriptor current = new TestLocationDescriptor();\n          current.populate(trinity.second, file);\n          if (!current.isComplete()) {\n            continue;\n          }\n\n          // Handle situations like the one below:\n          //     *) test class has tests with names 'testAlignedParameters' and 'testNonAlignedParameters';\n          //     *) test data files with the following names present: 'AlignedParameters.java' and 'NonAlignedParameters.java';\n          //     *) we're processing the following (test; test data file) pair - ('testAlignedParameters'; 'NonAlignedParameters.java');\n          // We don't want to store descriptor with file prefix 'Non' here.\n          // The same is true for suffixes, e.g. tests like 'testLeaveValidCodeBlock()' and 'testLeaveValidCodeBlockWithEmptyLineAfterIt()'\n          String prefixPattern = current.filePrefix.toLowerCase();\n          boolean checkPrefix = !StringUtil.isEmpty(prefixPattern);\n          String suffixPattern = current.fileSuffix;\n          for (TestLocationDescriptor descriptor : descriptors) {\n            if (suffixPattern.endsWith(descriptor.fileSuffix)) {\n              suffixPattern = suffixPattern.substring(0, suffixPattern.length() - descriptor.fileSuffix.length());\n            }\n          }\n          suffixPattern = suffixPattern.toLowerCase();\n          boolean checkSuffix = !StringUtil.isEmpty(suffixPattern);\n          boolean skip = false;\n          for (String testName : testNamesLowerCase) {\n            if (testName.equals(trinity.second)) {\n              continue;\n            }\n            if ((checkPrefix && testName.startsWith(prefixPattern)) || (checkSuffix && testName.endsWith(suffixPattern))) {\n              skip = true;\n              break;\n            }\n          }\n          if (skip) {\n            continue;\n          }\n\n          currentNameProcessed = true;\n          if (descriptors.isEmpty() || (descriptors.iterator().next().dir.equals(current.dir) && !descriptors.contains(current))) {\n            descriptors.add(current);\n            continue;\n          }\n          if (moreRelevantPath(current, descriptors, psiClass)) {\n            descriptors.clear();\n            descriptors.add(current);\n          }\n        }\n        if (currentNameProcessed) {\n          break;\n        }\n      }\n    }\n    return new TestDataDescriptor(descriptors);\n  }","commit_id":"208f6002b353420af786df1269cf643537a3a6af","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void annotate(@NotNull PsiElement element, @NotNull final AnnotationHolder holder) {\n        if (!isDebugInfoEnabled() ||\n                !JetPluginUtil.isInSource(element) ||\n                JetPluginUtil.isKtFileInGradleProjectInWrongFolder(element)) {\n            return;\n        }\n\n        if (element instanceof JetFile) {\n            JetFile file = (JetFile) element;\n            try {\n                BindingContext bindingContext = ResolvePackage.getAnalysisResults(file).getBindingContext();\n                DebugInfoUtil.markDebugAnnotations(file, bindingContext, new DebugInfoUtil.DebugInfoReporter() {\n                    @Override\n                    public void reportElementWithErrorType(@NotNull JetReferenceExpression expression) {\n                        holder.createErrorAnnotation(expression, \"[DEBUG] Resolved to error element\")\n                                .setTextAttributes(JetHighlightingColors.RESOLVED_TO_ERROR);\n                    }\n\n                    @Override\n                    public void reportMissingUnresolved(@NotNull JetReferenceExpression expression) {\n                        holder.createErrorAnnotation(expression,\n                                                     \"[DEBUG] Reference is not resolved to anything, but is not marked unresolved\")\n                                .setTextAttributes(JetHighlightingColors.DEBUG_INFO);\n                    }\n\n                    @Override\n                    public void reportUnresolvedWithTarget(@NotNull JetReferenceExpression expression, @NotNull String target) {\n                        holder.createErrorAnnotation(expression, \"[DEBUG] Reference marked as unresolved is actually resolved to \" + target)\n                                .setTextAttributes(JetHighlightingColors.DEBUG_INFO);\n                    }\n                });\n            }\n            catch (ProcessCanceledException e) {\n                throw e;\n            }\n            catch (Throwable e) {\n                // TODO\n                holder.createErrorAnnotation(element, e.getClass().getCanonicalName() + \": \" + e.getMessage());\n                e.printStackTrace();\n            }\n        }\n    }","id":23007,"modified_method":"@Override\n    public void annotate(@NotNull PsiElement element, @NotNull final AnnotationHolder holder) {\n        if (!isDebugInfoEnabled() ||\n                !JetPluginUtil.isInSource(element) ||\n                JetPluginUtil.isKtFileInGradleProjectInWrongFolder(element)) {\n            return;\n        }\n\n        if (element instanceof JetFile && !(element instanceof JetCodeFragmentImpl)) {\n            JetFile file = (JetFile) element;\n            try {\n                BindingContext bindingContext = ResolvePackage.getAnalysisResults(file).getBindingContext();\n                DebugInfoUtil.markDebugAnnotations(file, bindingContext, new DebugInfoUtil.DebugInfoReporter() {\n                    @Override\n                    public void reportElementWithErrorType(@NotNull JetReferenceExpression expression) {\n                        holder.createErrorAnnotation(expression, \"[DEBUG] Resolved to error element\")\n                                .setTextAttributes(JetHighlightingColors.RESOLVED_TO_ERROR);\n                    }\n\n                    @Override\n                    public void reportMissingUnresolved(@NotNull JetReferenceExpression expression) {\n                        holder.createErrorAnnotation(expression,\n                                                     \"[DEBUG] Reference is not resolved to anything, but is not marked unresolved\")\n                                .setTextAttributes(JetHighlightingColors.DEBUG_INFO);\n                    }\n\n                    @Override\n                    public void reportUnresolvedWithTarget(@NotNull JetReferenceExpression expression, @NotNull String target) {\n                        holder.createErrorAnnotation(expression, \"[DEBUG] Reference marked as unresolved is actually resolved to \" + target)\n                                .setTextAttributes(JetHighlightingColors.DEBUG_INFO);\n                    }\n                });\n            }\n            catch (ProcessCanceledException e) {\n                throw e;\n            }\n            catch (Throwable e) {\n                // TODO\n                holder.createErrorAnnotation(element, e.getClass().getCanonicalName() + \": \" + e.getMessage());\n                e.printStackTrace();\n            }\n        }\n    }","commit_id":"931b628988db5a4581e34a6d69e13105ff4b108a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void writeImportToFile(@NotNull ImportPath importPath, @NotNull JetFile file) {\n        JetImportList importList = file.getImportList();\n        if (importList != null) {\n            JetImportDirective newDirective = JetPsiFactory.createImportDirective(file.getProject(), importPath);\n            importList.add(newDirective);\n        }\n        else {\n            JetImportList newDirective = JetPsiFactory.createImportDirectiveWithImportList(file.getProject(), importPath);\n            JetPackageDirective packageDirective = file.getPackageDirective();\n            if (packageDirective == null) {\n                throw new IllegalStateException(\"Scripts are not supported: \" + file.getName());\n            }\n\n            packageDirective.getParent().addAfter(newDirective, packageDirective);\n        }\n    }","id":23008,"modified_method":"public static void writeImportToFile(@NotNull ImportPath importPath, @NotNull JetFile file) {\n        if (file instanceof JetCodeFragmentImpl) {\n            // TODO Insert import doesn't work for codeFragments yet\n            return;\n        }\n        JetImportList importList = file.getImportList();\n        if (importList != null) {\n            JetImportDirective newDirective = JetPsiFactory.createImportDirective(file.getProject(), importPath);\n            importList.add(newDirective);\n        }\n        else {\n            JetImportList newDirective = JetPsiFactory.createImportDirectiveWithImportList(file.getProject(), importPath);\n            JetPackageDirective packageDirective = file.getPackageDirective();\n            if (packageDirective == null) {\n                throw new IllegalStateException(\"Scripts are not supported: \" + file.getName());\n            }\n\n            packageDirective.getParent().addAfter(newDirective, packageDirective);\n        }\n    }","commit_id":"931b628988db5a4581e34a6d69e13105ff4b108a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public JetCodeFragmentImpl(Project project, String name, CharSequence text, IElementType elementType, PsiElement context) {\n        super(((PsiManagerEx) PsiManager.getInstance(project)).getFileManager().createFileViewProvider(\n                new LightVirtualFile(name, JetFileType.INSTANCE, text), true), false);\n        ((SingleRootFileViewProvider)getViewProvider()).forceCachedPsi(this);\n        init(TokenType.CODE_FRAGMENT, elementType);\n        this.context = context;\n    }","id":23009,"modified_method":"public JetCodeFragmentImpl(Project project, String name, CharSequence text, IElementType elementType, PsiElement context) {\n        super(((PsiManagerEx) PsiManager.getInstance(project)).getFileManager().createFileViewProvider(\n                new LightVirtualFile(name, JetFileType.INSTANCE, text), true), false);\n        ((SingleRootFileViewProvider)getViewProvider()).forceCachedPsi(this);\n        init(TokenType.CODE_FRAGMENT, elementType);\n        this.project = project;\n        this.context = context;\n    }","commit_id":"931b628988db5a4581e34a6d69e13105ff4b108a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void doTest(String testPath) {\n        setUpFixture(testPath);\n\n        String fileText = myFixture.getFile().getText();\n\n        Integer invocationCount = ExpectedCompletionUtils.getInvocationCount(fileText);\n\n        myFixture.complete(completionType(), invocationCount == null ? 0 : invocationCount);\n\n        ExpectedCompletionUtils.assertDirectivesValid(fileText, getAdditionalDirectives());\n\n        ExpectedCompletionUtils.CompletionProposal[] expected = ExpectedCompletionUtils.itemsShouldExist(fileText, getPlatform());\n        ExpectedCompletionUtils.CompletionProposal[] unexpected = ExpectedCompletionUtils.itemsShouldAbsent(fileText, getPlatform());\n        Integer itemsNumber = ExpectedCompletionUtils.getExpectedNumber(fileText, getPlatform());\n\n        assertTrue(\"Should be some assertions about completion\",\n                   expected.length != 0 || unexpected.length != 0 || itemsNumber != null);\n\n        LookupElement[] items = myFixture.getLookupElements();\n\n        if (items == null) {\n            items = new LookupElement[0];\n        }\n\n        ExpectedCompletionUtils.assertContainsRenderedItems(expected, items, ExpectedCompletionUtils.isWithOrder(fileText));\n        ExpectedCompletionUtils.assertNotContainsRenderedItems(unexpected, items);\n\n        if (itemsNumber != null) {\n            assertEquals(\n                    String.format(\n                            \"Invalid number of completion items: %s\",\n                            ExpectedCompletionUtils.listToString(ExpectedCompletionUtils.getItemsInformation(items))),\n                    itemsNumber.intValue(), items.length);\n        }\n    }","id":23010,"modified_method":"public void doTest(String testPath) throws Exception {\n        setUpFixture(testPath);\n\n        String fileText = FileUtil.loadFile(new File(testPath), true);\n\n        Integer invocationCount = ExpectedCompletionUtils.getInvocationCount(fileText);\n\n        myFixture.complete(completionType(), invocationCount == null ? 0 : invocationCount);\n\n        ExpectedCompletionUtils.assertDirectivesValid(fileText, getAdditionalDirectives());\n\n        ExpectedCompletionUtils.CompletionProposal[] expected = ExpectedCompletionUtils.itemsShouldExist(fileText, getPlatform());\n        ExpectedCompletionUtils.CompletionProposal[] unexpected = ExpectedCompletionUtils.itemsShouldAbsent(fileText, getPlatform());\n        Integer itemsNumber = ExpectedCompletionUtils.getExpectedNumber(fileText, getPlatform());\n\n        assertTrue(\"Should be some assertions about completion\",\n                   expected.length != 0 || unexpected.length != 0 || itemsNumber != null);\n\n        LookupElement[] items = myFixture.getLookupElements();\n\n        if (items == null) {\n            items = new LookupElement[0];\n        }\n\n        ExpectedCompletionUtils.assertContainsRenderedItems(expected, items, ExpectedCompletionUtils.isWithOrder(fileText));\n        ExpectedCompletionUtils.assertNotContainsRenderedItems(unexpected, items);\n\n        if (itemsNumber != null) {\n            assertEquals(\n                    String.format(\n                            \"Invalid number of completion items: %s\",\n                            ExpectedCompletionUtils.listToString(ExpectedCompletionUtils.getItemsInformation(items))),\n                    itemsNumber.intValue(), items.length);\n        }\n    }","commit_id":"931b628988db5a4581e34a6d69e13105ff4b108a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void annotate(@NotNull PsiElement element, @NotNull AnnotationHolder holder) {\n        if (!JetPluginUtil.isInSource(element) || JetPluginUtil.isKtFileInGradleProjectInWrongFolder(element)) {\n            return;\n        }\n\n        for (HighlightingVisitor visitor : getBeforeAnalysisVisitors(holder)) {\n            element.accept(visitor);\n        }\n\n        JetFile file = (JetFile) element.getContainingFile();\n\n        AnalyzeExhaust analyzeExhaust = ResolvePackage.getAnalysisResults(file);\n        if (analyzeExhaust.isError()) {\n            HighlighterPackage.updateHighlightingResult(file, true);\n\n            throw new ProcessCanceledException(analyzeExhaust.getError());\n        }\n\n        BindingContext bindingContext = analyzeExhaust.getBindingContext();\n        for (HighlightingVisitor visitor : getAfterAnalysisVisitor(holder, bindingContext)) {\n            element.accept(visitor);\n        }\n\n        if (JetPluginUtil.isInSource(element, /* includeLibrarySources = */ false)) {\n            ElementAnnotator elementAnnotator = new ElementAnnotator(element, holder);\n            for (Diagnostic diagnostic : bindingContext.getDiagnostics().forElement(element)) {\n                elementAnnotator.registerDiagnosticAnnotations(diagnostic);\n            }\n        }\n\n        if (element instanceof JetFile) {\n            //noinspection StaticMethodReferencedViaSubclass\n            HighlighterPackage.updateHighlightingResult(file, false);\n        }\n    }","id":23011,"modified_method":"@Override\n    public void annotate(@NotNull PsiElement element, @NotNull AnnotationHolder holder) {\n        if (!(JetPluginUtil.isInSource(element) || element.getContainingFile() instanceof JetCodeFragmentImpl)\n                || JetPluginUtil.isKtFileInGradleProjectInWrongFolder(element)) {\n            return;\n        }\n\n        for (HighlightingVisitor visitor : getBeforeAnalysisVisitors(holder)) {\n            element.accept(visitor);\n        }\n\n        JetFile file = (JetFile) element.getContainingFile();\n\n        BindingContext bindingContext;\n        if (file instanceof JetCodeFragmentImpl) {\n            if (element instanceof JetElement) {\n                ResolveSessionForBodies resolveSession = ResolvePackage.getLazyResolveSession((JetElement) element);\n                bindingContext = resolveSession.resolveToElement((JetElement) element);\n            }\n            else {\n                return;\n            }\n        }\n        else {\n            AnalyzeExhaust analyzeExhaust = ResolvePackage.getAnalysisResults(file);\n            if (analyzeExhaust.isError()) {\n                HighlighterPackage.updateHighlightingResult(file, true);\n\n                throw new ProcessCanceledException(analyzeExhaust.getError());\n            }\n\n            bindingContext = analyzeExhaust.getBindingContext();\n        }\n\n        for (HighlightingVisitor visitor : getAfterAnalysisVisitor(holder, bindingContext)) {\n            element.accept(visitor);\n        }\n\n        if (JetPluginUtil.isInSource(element, /* includeLibrarySources = */ false) || file instanceof JetCodeFragmentImpl) {\n            ElementAnnotator elementAnnotator = new ElementAnnotator(element, holder);\n            for (Diagnostic diagnostic : bindingContext.getDiagnostics().forElement(element)) {\n                elementAnnotator.registerDiagnosticAnnotations(diagnostic);\n            }\n        }\n\n        if (element instanceof JetFile) {\n            //noinspection StaticMethodReferencedViaSubclass\n            HighlighterPackage.updateHighlightingResult(file, false);\n        }\n    }","commit_id":"931b628988db5a4581e34a6d69e13105ff4b108a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public final List<IntentionAction> createActions(Diagnostic diagnostic) {\n        List<IntentionAction> intentionActionList = new LinkedList<IntentionAction>();\n        IntentionAction intentionAction = createAction(diagnostic);\n        if (intentionAction != null) {\n            intentionActionList.add(intentionAction);\n        }\n        return intentionActionList;\n    }","id":23012,"modified_method":"@NotNull\n    @Override\n    public final List<IntentionAction> createActions(Diagnostic diagnostic) {\n        List<IntentionAction> intentionActionList = new LinkedList<IntentionAction>();\n\n        if (diagnostic.getPsiElement().getContainingFile() instanceof JetCodeFragmentImpl) {\n            return intentionActionList;\n        }\n\n        IntentionAction intentionAction = createAction(diagnostic);\n        if (intentionAction != null) {\n            intentionActionList.add(intentionAction);\n        }\n        return intentionActionList;\n    }","commit_id":"931b628988db5a4581e34a6d69e13105ff4b108a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public BindingContext resolveToElement(@NotNull JetElement jetElement) {\n        @SuppressWarnings(\"unchecked\") JetElement elementOfAdditionalResolve = (JetElement) JetPsiUtil.getTopmostParentOfTypes(\n                jetElement,\n                JetNamedFunction.class,\n                JetClassInitializer.class,\n                JetProperty.class,\n                JetParameter.class,\n                JetDelegationSpecifierList.class,\n                JetImportDirective.class,\n                JetAnnotationEntry.class,\n                JetTypeParameter.class,\n                JetTypeConstraint.class,\n                JetPackageDirective.class);\n\n        if (elementOfAdditionalResolve != null && !(elementOfAdditionalResolve instanceof JetParameter)) {\n            if (elementOfAdditionalResolve instanceof JetPackageDirective) {\n                elementOfAdditionalResolve = jetElement;\n            }\n\n            return additionalResolveCache.getValue().invoke(elementOfAdditionalResolve);\n        }\n\n        JetParameter parameter = (JetParameter) elementOfAdditionalResolve;\n        if (parameter != null) {\n            JetClass klass = PsiTreeUtil.getParentOfType(parameter, JetClass.class);\n            if (klass != null && parameter.getParent() == klass.getPrimaryConstructorParameterList()) {\n                return additionalResolveCache.getValue().invoke(klass);\n            }\n\n            // Parameters for function literal could be met inside other parameters. We can't make resolveToDescriptors for internal elements.\n            jetElement = parameter;\n        }\n\n        JetDeclaration declaration = PsiTreeUtil.getParentOfType(jetElement, JetDeclaration.class, false);\n        if (declaration != null) {\n            // Activate descriptor resolution\n            resolveSession.resolveToDescriptor(declaration);\n        }\n\n        return resolveSession.getBindingContext();\n    }","id":23013,"modified_method":"@NotNull\n    public BindingContext resolveToElement(@NotNull JetElement jetElement) {\n        @SuppressWarnings(\"unchecked\") JetElement elementOfAdditionalResolve = (JetElement) JetPsiUtil.getTopmostParentOfTypes(\n                jetElement,\n                JetNamedFunction.class,\n                JetClassInitializer.class,\n                JetProperty.class,\n                JetParameter.class,\n                JetDelegationSpecifierList.class,\n                JetImportDirective.class,\n                JetAnnotationEntry.class,\n                JetTypeParameter.class,\n                JetTypeConstraint.class,\n                JetPackageDirective.class,\n                JetExpressionCodeFragment.class);\n\n        if (elementOfAdditionalResolve != null && !(elementOfAdditionalResolve instanceof JetParameter)) {\n            if (elementOfAdditionalResolve instanceof JetPackageDirective) {\n                elementOfAdditionalResolve = jetElement;\n            }\n\n            return additionalResolveCache.getValue().invoke(elementOfAdditionalResolve);\n        }\n\n        JetParameter parameter = (JetParameter) elementOfAdditionalResolve;\n        if (parameter != null) {\n            JetClass klass = PsiTreeUtil.getParentOfType(parameter, JetClass.class);\n            if (klass != null && parameter.getParent() == klass.getPrimaryConstructorParameterList()) {\n                return additionalResolveCache.getValue().invoke(klass);\n            }\n\n            // Parameters for function literal could be met inside other parameters. We can't make resolveToDescriptors for internal elements.\n            jetElement = parameter;\n        }\n\n        JetDeclaration declaration = PsiTreeUtil.getParentOfType(jetElement, JetDeclaration.class, false);\n        if (declaration != null) {\n            // Activate descriptor resolution\n            resolveSession.resolveToDescriptor(declaration);\n        }\n\n        return resolveSession.getBindingContext();\n    }","commit_id":"931b628988db5a4581e34a6d69e13105ff4b108a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private BindingContext elementAdditionalResolve(@NotNull JetElement resolveElement) {\n        // All additional resolve should be done to separate trace\n        BindingTrace trace = resolveSession.getStorageManager().createSafeTrace(\n                new DelegatingBindingTrace(resolveSession.getBindingContext(), \"trace to resolve element\", resolveElement));\n\n        JetFile file = resolveElement.getContainingJetFile();\n\n        if (resolveElement instanceof JetNamedFunction) {\n            functionAdditionalResolve(resolveSession, (JetNamedFunction) resolveElement, trace, file);\n        }\n        else if (resolveElement instanceof JetClassInitializer) {\n            initializerAdditionalResolve(resolveSession, (JetClassInitializer) resolveElement, trace, file);\n        }\n        else if (resolveElement instanceof JetProperty) {\n            propertyAdditionalResolve(resolveSession, (JetProperty) resolveElement, trace, file);\n        }\n        else if (resolveElement instanceof JetDelegationSpecifierList) {\n            delegationSpecifierAdditionalResolve(resolveSession, (JetDelegationSpecifierList) resolveElement, trace, file);\n        }\n        else if (resolveElement instanceof JetImportDirective) {\n            JetImportDirective importDirective = (JetImportDirective) resolveElement;\n            LazyImportScope scope = resolveSession.getScopeProvider().getExplicitImportsScopeForFile(importDirective.getContainingJetFile());\n            scope.forceResolveAllContents();\n        }\n        else if (resolveElement instanceof JetAnnotationEntry) {\n            annotationAdditionalResolve(resolveSession, (JetAnnotationEntry) resolveElement);\n        }\n        else if (resolveElement instanceof JetClass) {\n            constructorAdditionalResolve(resolveSession, (JetClass) resolveElement, trace, file);\n        }\n        else if (resolveElement instanceof JetTypeParameter) {\n            typeParameterAdditionalResolve(resolveSession, (JetTypeParameter) resolveElement);\n        }\n        else if (resolveElement instanceof JetTypeConstraint) {\n            typeConstraintAdditionalResolve(resolveSession, (JetTypeConstraint) resolveElement);\n        }\n        else if (PsiTreeUtil.getParentOfType(resolveElement, JetPackageDirective.class) != null) {\n            packageRefAdditionalResolve(resolveSession, trace, resolveElement);\n        }\n        else {\n            assert false : \"Invalid type of the topmost parent\";\n        }\n\n        return trace.getBindingContext();\n    }","id":23014,"modified_method":"@NotNull\n    private BindingContext elementAdditionalResolve(@NotNull JetElement resolveElement) {\n        // All additional resolve should be done to separate trace\n        BindingTrace trace = resolveSession.getStorageManager().createSafeTrace(\n                new DelegatingBindingTrace(resolveSession.getBindingContext(), \"trace to resolve element\", resolveElement));\n\n        JetFile file = resolveElement.getContainingJetFile();\n\n        if (resolveElement instanceof JetNamedFunction) {\n            functionAdditionalResolve(resolveSession, (JetNamedFunction) resolveElement, trace, file);\n        }\n        else if (resolveElement instanceof JetClassInitializer) {\n            initializerAdditionalResolve(resolveSession, (JetClassInitializer) resolveElement, trace, file);\n        }\n        else if (resolveElement instanceof JetProperty) {\n            propertyAdditionalResolve(resolveSession, (JetProperty) resolveElement, trace, file);\n        }\n        else if (resolveElement instanceof JetDelegationSpecifierList) {\n            delegationSpecifierAdditionalResolve(resolveSession, (JetDelegationSpecifierList) resolveElement, trace, file);\n        }\n        else if (resolveElement instanceof JetImportDirective) {\n            JetImportDirective importDirective = (JetImportDirective) resolveElement;\n            LazyImportScope scope = resolveSession.getScopeProvider().getExplicitImportsScopeForFile(importDirective.getContainingJetFile());\n            scope.forceResolveAllContents();\n        }\n        else if (resolveElement instanceof JetAnnotationEntry) {\n            annotationAdditionalResolve(resolveSession, (JetAnnotationEntry) resolveElement);\n        }\n        else if (resolveElement instanceof JetClass) {\n            constructorAdditionalResolve(resolveSession, (JetClass) resolveElement, trace, file);\n        }\n        else if (resolveElement instanceof JetTypeParameter) {\n            typeParameterAdditionalResolve(resolveSession, (JetTypeParameter) resolveElement);\n        }\n        else if (resolveElement instanceof JetTypeConstraint) {\n            typeConstraintAdditionalResolve(resolveSession, (JetTypeConstraint) resolveElement);\n        }\n        else if (resolveElement instanceof JetExpressionCodeFragment) {\n            codeFragmentAdditionalResolve(resolveSession, (JetExpressionCodeFragment) resolveElement, trace);\n        }\n        else if (PsiTreeUtil.getParentOfType(resolveElement, JetPackageDirective.class) != null) {\n            packageRefAdditionalResolve(resolveSession, trace, resolveElement);\n        }\n        else {\n            assert false : \"Invalid type of the topmost parent\";\n        }\n\n        return trace.getBindingContext();\n    }","commit_id":"931b628988db5a4581e34a6d69e13105ff4b108a","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n  protected PsiFile createFile(@NotNull final Project project, @NotNull final VirtualFile vFile, @NotNull final FileType fileType) {\n    final FileIndexFacade fileIndex = ServiceManager.getService(project, FileIndexFacade.class);\n    if (fileIndex.isInLibraryClasses(vFile) || !fileIndex.isInSource(vFile)) {\n      String name = vFile.getName();\n\n      // skip inners & anonymous (todo: read actual class name from file)\n      int dotIndex = name.lastIndexOf('.');\n      if (dotIndex < 0) dotIndex = name.length();\n      int index = name.lastIndexOf('$', dotIndex);\n      if (index <= 0 || index == dotIndex - 1) {\n        return new ClsFileImpl((PsiManagerImpl)PsiManager.getInstance(project), this);\n      }\n    }\n\n    return null;\n  }","id":23015,"modified_method":"@Override\n  protected PsiFile createFile(@NotNull final Project project, @NotNull final VirtualFile vFile, @NotNull final FileType fileType) {\n    FileIndexFacade fileIndex = ServiceManager.getService(project, FileIndexFacade.class);\n    if (!fileIndex.isInLibraryClasses(vFile) && fileIndex.isInSource(vFile)) {\n      return null;\n    }\n\n    // skip inners & anonymous\n    String name = vFile.getNameWithoutExtension();\n    int index = name.lastIndexOf('$', name.length());\n    if (index > 0 && index < name.length() - 1) {\n      String supposedParentName = name.substring(0, index) + \".class\";\n      if (vFile.getParent().findChild(supposedParentName) != null) {\n        return null;\n      }\n    }\n\n    return new ClsFileImpl(PsiManager.getInstance(project), this);\n  }","commit_id":"4645f02b2b9b4d8aa8742eb259b3e99a29976074","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiFileStub buildFileStub(VirtualFile vFile, byte[] bytes) throws ClsFormatException {\n    final PsiJavaFileStubImpl file = new PsiJavaFileStubImpl(\"do.not.know.yet\", true);\n    try {\n      final ClassReader reader = new ClassReader(bytes);\n      final StubBuildingVisitor<VirtualFile> classVisitor =\n        new StubBuildingVisitor<VirtualFile>(vFile, VirtualFileInnerClassStrategy.INSTANCE, file, 0, null);\n      try {\n        reader.accept(classVisitor, ClassReader.SKIP_FRAMES);\n      }\n      catch (OutOfOrderInnerClassException e) {\n        return null;\n      }\n\n      @SuppressWarnings(\"unchecked\") final PsiClassStub<PsiClass> result = (PsiClassStub<PsiClass>)classVisitor.getResult();\n      if (result == null) return null;\n\n      file.setPackageName(getPackageName(result));\n      return file;\n    }\n    catch (Exception e) {\n      LOG.debug(vFile.getPath(), e);\n      throw new ClsFormatException();\n    }\n  }","id":23016,"modified_method":"@Override\n  public PsiFileStub buildFileStub(VirtualFile vFile, byte[] bytes) throws ClsFormatException {\n    final PsiJavaFileStubImpl file = new PsiJavaFileStubImpl(\"do.not.know.yet\", true);\n    try {\n      final ClassReader reader = new ClassReader(bytes);\n      final StubBuildingVisitor<VirtualFile> classVisitor =\n        new StubBuildingVisitor<VirtualFile>(vFile, VirtualFileInnerClassStrategy.INSTANCE, file, 0, vFile.getNameWithoutExtension());\n      try {\n        reader.accept(classVisitor, ClassReader.SKIP_FRAMES);\n      }\n      catch (OutOfOrderInnerClassException e) {\n        return null;\n      }\n\n      @SuppressWarnings(\"unchecked\") final PsiClassStub<PsiClass> result = (PsiClassStub<PsiClass>)classVisitor.getResult();\n      if (result == null) return null;\n\n      file.setPackageName(getPackageName(result));\n      return file;\n    }\n    catch (Exception e) {\n      LOG.debug(vFile.getPath(), e);\n      throw new ClsFormatException();\n    }\n  }","commit_id":"4645f02b2b9b4d8aa8742eb259b3e99a29976074","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n    String fqn = getClassName(name);\n    String shortName = myShortName != null ? myShortName : PsiNameHelper.getShortClassName(fqn);\n\n    int flags = myAccess == 0 ? access : myAccess;\n    boolean isDeprecated = (flags & Opcodes.ACC_DEPRECATED) != 0;\n    boolean isInterface = (flags & Opcodes.ACC_INTERFACE) != 0;\n    boolean isEnum = (flags & Opcodes.ACC_ENUM) != 0;\n    boolean isAnnotationType = (flags & Opcodes.ACC_ANNOTATION) != 0;\n\n    byte stubFlags = PsiClassStubImpl.packFlags(isDeprecated, isInterface, isEnum, false, false, isAnnotationType, false, false);\n    myResult = new PsiClassStubImpl(JavaStubElementTypes.CLASS, myParent, fqn, shortName, null, stubFlags);\n\n    LanguageLevel languageLevel = convertFromVersion(version);\n    ((PsiClassStubImpl)myResult).setLanguageLevel(languageLevel);\n\n    myModList = new PsiModifierListStubImpl(myResult, packClassFlags(flags));\n\n    CharacterIterator signatureIterator = signature != null ? new StringCharacterIterator(signature) : null;\n    if (signatureIterator != null) {\n      try {\n        SignatureParsing.parseTypeParametersDeclaration(signatureIterator, myResult);\n      }\n      catch (ClsFormatException e) {\n        signatureIterator = null;\n      }\n    } else {\n      new PsiTypeParameterListStubImpl(myResult);\n    }\n\n    String convertedSuper;\n    List<String> convertedInterfaces = new ArrayList<String>();\n    if (signatureIterator == null) {\n      convertedSuper = parseClassDescription(superName, interfaces, convertedInterfaces);\n    } else {\n      try {\n        convertedSuper = parseClassSignature(signatureIterator, convertedInterfaces);\n      }\n      catch (ClsFormatException e) {\n        new PsiTypeParameterListStubImpl(myResult);\n        convertedSuper = parseClassDescription(superName, interfaces, convertedInterfaces);\n      }\n    }\n\n    if (isInterface) {\n      if (isAnnotationType) {\n        convertedInterfaces.remove(JAVA_LANG_ANNOTATION_ANNOTATION);\n      }\n      newReferenceList(JavaStubElementTypes.EXTENDS_LIST, myResult, ArrayUtil.toStringArray(convertedInterfaces));\n      newReferenceList(JavaStubElementTypes.IMPLEMENTS_LIST, myResult);\n    }\n    else {\n      if (convertedSuper == null ||\n          JAVA_LANG_OBJECT.equals(convertedSuper) ||\n          isEnum && (JAVA_LANG_ENUM.equals(convertedSuper) || (JAVA_LANG_ENUM + \"<\" + fqn + \">\").equals(convertedSuper))) {\n        newReferenceList(JavaStubElementTypes.EXTENDS_LIST, myResult);\n      }\n      else {\n        newReferenceList(JavaStubElementTypes.EXTENDS_LIST, myResult, convertedSuper);\n      }\n      newReferenceList(JavaStubElementTypes.IMPLEMENTS_LIST, myResult, ArrayUtil.toStringArray(convertedInterfaces));\n    }\n  }","id":23017,"modified_method":"@Override\n  public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n    String fqn, shortName;\n    if (myShortName != null && name.endsWith(myShortName)) {\n      shortName = myShortName;\n      fqn = name.length() == shortName.length()\n            ? shortName : getClassName(name.substring(0, name.length() - shortName.length() - 1)) + \".\" + shortName;\n    }\n    else {\n      fqn = getClassName(name);\n      shortName = PsiNameHelper.getShortClassName(fqn);\n    }\n\n    int flags = myAccess == 0 ? access : myAccess;\n    boolean isDeprecated = (flags & Opcodes.ACC_DEPRECATED) != 0;\n    boolean isInterface = (flags & Opcodes.ACC_INTERFACE) != 0;\n    boolean isEnum = (flags & Opcodes.ACC_ENUM) != 0;\n    boolean isAnnotationType = (flags & Opcodes.ACC_ANNOTATION) != 0;\n\n    byte stubFlags = PsiClassStubImpl.packFlags(isDeprecated, isInterface, isEnum, false, false, isAnnotationType, false, false);\n    myResult = new PsiClassStubImpl(JavaStubElementTypes.CLASS, myParent, fqn, shortName, null, stubFlags);\n\n    LanguageLevel languageLevel = convertFromVersion(version);\n    ((PsiClassStubImpl)myResult).setLanguageLevel(languageLevel);\n\n    myModList = new PsiModifierListStubImpl(myResult, packClassFlags(flags));\n\n    CharacterIterator signatureIterator = signature != null ? new StringCharacterIterator(signature) : null;\n    if (signatureIterator != null) {\n      try {\n        SignatureParsing.parseTypeParametersDeclaration(signatureIterator, myResult);\n      }\n      catch (ClsFormatException e) {\n        signatureIterator = null;\n      }\n    } else {\n      new PsiTypeParameterListStubImpl(myResult);\n    }\n\n    String convertedSuper;\n    List<String> convertedInterfaces = new ArrayList<String>();\n    if (signatureIterator == null) {\n      convertedSuper = parseClassDescription(superName, interfaces, convertedInterfaces);\n    } else {\n      try {\n        convertedSuper = parseClassSignature(signatureIterator, convertedInterfaces);\n      }\n      catch (ClsFormatException e) {\n        new PsiTypeParameterListStubImpl(myResult);\n        convertedSuper = parseClassDescription(superName, interfaces, convertedInterfaces);\n      }\n    }\n\n    if (isInterface) {\n      if (isAnnotationType) {\n        convertedInterfaces.remove(JAVA_LANG_ANNOTATION_ANNOTATION);\n      }\n      newReferenceList(JavaStubElementTypes.EXTENDS_LIST, myResult, ArrayUtil.toStringArray(convertedInterfaces));\n      newReferenceList(JavaStubElementTypes.IMPLEMENTS_LIST, myResult);\n    }\n    else {\n      if (convertedSuper == null ||\n          JAVA_LANG_OBJECT.equals(convertedSuper) ||\n          isEnum && (JAVA_LANG_ENUM.equals(convertedSuper) || (JAVA_LANG_ENUM + \"<\" + fqn + \">\").equals(convertedSuper))) {\n        newReferenceList(JavaStubElementTypes.EXTENDS_LIST, myResult);\n      }\n      else {\n        newReferenceList(JavaStubElementTypes.EXTENDS_LIST, myResult, convertedSuper);\n      }\n      newReferenceList(JavaStubElementTypes.IMPLEMENTS_LIST, myResult, ArrayUtil.toStringArray(convertedInterfaces));\n    }\n  }","commit_id":"4645f02b2b9b4d8aa8742eb259b3e99a29976074","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n    if ((access & Opcodes.ACC_SYNTHETIC) != 0) return;\n    if (!isCorrectName(innerName) || outerName == null) return;\n\n    if ((getClassName(outerName) + \".\" + innerName).equals(myResult.getQualifiedName())) {\n      // our result is inner class\n      if (myParent instanceof PsiFileStub) {\n        throw new OutOfOrderInnerClassException();\n      }\n    }\n\n    if (!getClassName(outerName).equals(myResult.getQualifiedName())) return;\n\n    final T innerSource = myInnersStrategy.findInnerClass(innerName, mySource);\n    if (innerSource == null) return;\n\n    final ClassReader reader = myInnersStrategy.readerForInnerClass(innerSource);\n    if (reader == null) return;\n\n    final StubBuildingVisitor<T> classVisitor = new StubBuildingVisitor<T>(innerSource, myInnersStrategy, myResult, access, innerName);\n    reader.accept(classVisitor, ClassReader.SKIP_FRAMES);\n  }","id":23018,"modified_method":"@Override\n  public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\n    if ((access & Opcodes.ACC_SYNTHETIC) != 0) return;\n    if (!isCorrectName(innerName) || outerName == null) return;\n\n    if ((getClassName(outerName) + \".\" + innerName).equals(myResult.getQualifiedName())) {\n      // our result is inner class\n      if (myParent instanceof PsiFileStub) {\n        throw new OutOfOrderInnerClassException();\n      }\n    }\n\n    final T innerSource = myInnersStrategy.findInnerClass(innerName, mySource);\n    if (innerSource == null) return;\n\n    final ClassReader reader = myInnersStrategy.readerForInnerClass(innerSource);\n    if (reader == null) return;\n\n    final StubBuildingVisitor<T> classVisitor = new StubBuildingVisitor<T>(innerSource, myInnersStrategy, myResult, access, innerName);\n    reader.accept(classVisitor, ClassReader.SKIP_FRAMES);\n  }","commit_id":"4645f02b2b9b4d8aa8742eb259b3e99a29976074","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean elementHasSourceCode() {\n    VirtualFile[] files;\n    if (myElement instanceof PsiDirectory) {\n      final PsiPackage aPackage = JavaDirectoryService.getInstance().getPackage((PsiDirectory)myElement);\n      if (aPackage == null) return false;\n      files = PackageIndex.getInstance(myProject).getDirectoriesByPackageName(aPackage.getQualifiedName(), true);\n    }\n    else if (myElement instanceof PsiPackage) {\n      files = PackageIndex.getInstance(myProject).getDirectoriesByPackageName(((PsiPackage)myElement).getQualifiedName(), true);\n    }\n    else {\n      PsiFile containingFile = myElement.getNavigationElement().getContainingFile();\n      if (containingFile == null) return false;\n      VirtualFile virtualFile = containingFile.getVirtualFile();\n      if (virtualFile == null) return false;\n      files = new VirtualFile[] {virtualFile};\n    }\n    ProjectFileIndex projectFileIndex = ProjectFileIndex.SERVICE.getInstance(myProject);\n    for (VirtualFile file : files) {\n      if (projectFileIndex.isInSource(file)) return true;\n    }\n    return false;\n  }","id":23019,"modified_method":"private boolean elementHasSourceCode() {\n    PsiFileSystemItem[] items;\n    if (myElement instanceof PsiDirectory) {\n      final PsiPackage aPackage = JavaDirectoryService.getInstance().getPackage((PsiDirectory)myElement);\n      if (aPackage == null) return false;\n      items = aPackage.getDirectories(new EverythingGlobalScope(myProject));\n    }\n    else if (myElement instanceof PsiPackage) {\n      items = ((PsiPackage)myElement).getDirectories(new EverythingGlobalScope(myProject));\n    }\n    else {\n      PsiFile containingFile = myElement.getNavigationElement().getContainingFile();\n      if (containingFile == null) return false;\n      items = new PsiFileSystemItem[] {containingFile};\n    }\n    ProjectFileIndex projectFileIndex = ProjectFileIndex.SERVICE.getInstance(myProject);\n    for (PsiFileSystemItem item : items) {\n      VirtualFile file = item.getVirtualFile();\n      if (file != null && projectFileIndex.isInSource(file)) return true;\n    }\n    return false;\n  }","commit_id":"b31308065e7886482ea5ab6e965d1c9b7e195278","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void _executeGradle(\n\t\t\tFile projectDir, String taskPath, String... testTaskPaths)\n\t\tthrows IOException {\n\n\t\tif (Validator.isNotNull(_repositoryUrl)) {\n\t\t\tFile buildGradleFile = new File(projectDir, \"build.gradle\");\n\n\t\t\tPath buildGradlePath = buildGradleFile.toPath();\n\n\t\t\tString buildGradle = FileTestUtil.read(buildGradlePath);\n\n\t\t\tbuildGradle = buildGradle.replace(\n\t\t\t\t\"\\\"\" + _REPOSITORY_CDN_URL + \"\\\"\",\n\t\t\t\t\"\\\"\" + _repositoryUrl + \"\\\"\");\n\n\t\t\tFiles.write(\n\t\t\t\tbuildGradlePath, buildGradle.getBytes(StandardCharsets.UTF_8));\n\t\t}\n\n\t\tGradleRunner gradleRunner = GradleRunner.create();\n\n\t\tgradleRunner.withArguments(taskPath);\n\t\tgradleRunner.withGradleDistribution(_gradleDistribution);\n\t\tgradleRunner.withProjectDir(projectDir);\n\n\t\tBuildResult buildResult = gradleRunner.build();\n\n\t\tif (testTaskPaths.length == 0) {\n\t\t\ttestTaskPaths = new String[] {taskPath};\n\t\t}\n\n\t\tfor (String testTaskPath : testTaskPaths) {\n\t\t\tBuildTask buildTask = buildResult.task(testTaskPath);\n\n\t\t\tAssert.assertNotNull(\n\t\t\t\t\"Build task \\\"\" + testTaskPath + \"\\\" not found\", buildTask);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unexpected outcome for task \\\"\" + buildTask.getPath() + \"\\\"\",\n\t\t\t\tTaskOutcome.SUCCESS, buildTask.getOutcome());\n\t\t}\n\t}","id":23020,"modified_method":"private void _executeGradle(\n\t\t\tFile projectDir, String taskPath, String... testTaskPaths)\n\t\tthrows IOException {\n\n\t\tif (Validator.isNotNull(_repositoryUrl)) {\n\t\t\tFile buildGradleFile = new File(projectDir, \"build.gradle\");\n\n\t\t\tPath buildGradlePath = buildGradleFile.toPath();\n\n\t\t\tString buildGradle = FileTestUtil.read(buildGradlePath);\n\n\t\t\tbuildGradle = buildGradle.replace(\n\t\t\t\t\"\\\"\" + _REPOSITORY_CDN_URL + \"\\\"\",\n\t\t\t\t\"\\\"\" + _repositoryUrl + \"\\\"\");\n\n\t\t\tFiles.write(\n\t\t\t\tbuildGradlePath, buildGradle.getBytes(StandardCharsets.UTF_8));\n\t\t}\n\n\t\tGradleRunner gradleRunner = GradleRunner.create();\n\n\t\tif (Validator.isNotNull(_httpProxyHost) &&\n\t\t\tValidator.isNotNull(_httpProxyPort)) {\n\n\t\t\tgradleRunner.withArguments(\n\t\t\t\t\"-Dhttp.proxyHost=\" + _httpProxyHost,\n\t\t\t\t\"-Dhttp.proxyPort=\" + _httpProxyPort, taskPath);\n\t\t}\n\t\telse {\n\t\t\tgradleRunner.withArguments(taskPath);\n\t\t}\n\n\t\tgradleRunner.withGradleDistribution(_gradleDistribution);\n\t\tgradleRunner.withProjectDir(projectDir);\n\n\t\tBuildResult buildResult = gradleRunner.build();\n\n\t\tif (testTaskPaths.length == 0) {\n\t\t\ttestTaskPaths = new String[] {taskPath};\n\t\t}\n\n\t\tfor (String testTaskPath : testTaskPaths) {\n\t\t\tBuildTask buildTask = buildResult.task(testTaskPath);\n\n\t\t\tAssert.assertNotNull(\n\t\t\t\t\"Build task \\\"\" + testTaskPath + \"\\\" not found\", buildTask);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unexpected outcome for task \\\"\" + buildTask.getPath() + \"\\\"\",\n\t\t\t\tTaskOutcome.SUCCESS, buildTask.getOutcome());\n\t\t}\n\t}","commit_id":"cadf2757e11d6202a1d548b131a5789753beaa1b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@BeforeClass\n\tpublic static void setUpClass() throws IOException {\n\t\tProperties properties = FileTestUtil.readProperties(\n\t\t\t\"gradle-wrapper/gradle/wrapper/gradle-wrapper.properties\");\n\n\t\t_gradleDistribution = URI.create(\n\t\t\tproperties.getProperty(\"distributionUrl\"));\n\n\t\t_repositoryUrl = System.getProperty(\"repository.url\");\n\t}","id":23021,"modified_method":"@BeforeClass\n\tpublic static void setUpClass() throws IOException {\n\t\tProperties properties = FileTestUtil.readProperties(\n\t\t\t\"gradle-wrapper/gradle/wrapper/gradle-wrapper.properties\");\n\n\t\t_gradleDistribution = URI.create(\n\t\t\tproperties.getProperty(\"distributionUrl\"));\n\n\t\t_httpProxyHost = System.getProperty(\"http.proxyHost\");\n\t\t_httpProxyPort = System.getProperty(\"http.proxyPort\");\n\t\t_repositoryUrl = System.getProperty(\"repository.url\");\n\t}","commit_id":"cadf2757e11d6202a1d548b131a5789753beaa1b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void apply(DefaultGccPlatformToolChain gccToolChain) {\n            gccToolChain.compilerProbeArgs(\"-m32\");\n            Action<List<String>> m32args = new Action<List<String>>() {\n                public void execute(List<String> args) {\n                    args.add(\"-m32\");\n                }\n            };\n            gccToolChain.getCppCompiler().withArguments(m32args);\n            gccToolChain.getcCompiler().withArguments(m32args);\n            gccToolChain.getObjcCompiler().withArguments(m32args);\n            gccToolChain.getObjcppCompiler().withArguments(m32args);\n            gccToolChain.getLinker().withArguments(m32args);\n            gccToolChain.getAssembler().withArguments(new Action<List<String>>() {\n                public void execute(List<String> args) {\n                    // TODO - this should be 'if toolchain is XCode'\n                    if (operatingSystem.isMacOsX()) {\n                        args.addAll(asList(\"-arch\", \"i386\"));\n                    } else {\n                        args.add(\"--32\");\n                    }\n                }\n            });\n        }","id":23022,"modified_method":"public void apply(DefaultGccPlatformToolChain gccToolChain) {\n            gccToolChain.compilerProbeArgs(\"-m32\");\n            Action<List<String>> m32args = new Action<List<String>>() {\n                public void execute(List<String> args) {\n                    args.add(\"-m32\");\n                }\n            };\n            gccToolChain.getCppCompiler().withArguments(m32args);\n            gccToolChain.getcCompiler().withArguments(m32args);\n            gccToolChain.getObjcCompiler().withArguments(m32args);\n            gccToolChain.getObjcppCompiler().withArguments(m32args);\n            gccToolChain.getLinker().withArguments(m32args);\n            gccToolChain.getAssembler().withArguments(m32args);\n\n        }","commit_id":"f94d945922df4ecf183d880888c22dcdaeff6d92","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(DefaultGccPlatformToolChain gccToolChain) {\n            gccToolChain.compilerProbeArgs(\"-m64\");\n            Action<List<String>> m64args = new Action<List<String>>() {\n                public void execute(List<String> args) {\n                    args.add(\"-m64\");\n                }\n            };\n            gccToolChain.getCppCompiler().withArguments(m64args);\n            gccToolChain.getcCompiler().withArguments(m64args);\n            gccToolChain.getObjcCompiler().withArguments(m64args);\n            gccToolChain.getObjcppCompiler().withArguments(m64args);\n            gccToolChain.getLinker().withArguments(m64args);\n            gccToolChain.getAssembler().withArguments(new Action<List<String>>() {\n                public void execute(List<String> args) {\n                    // TODO - this should be 'if toolchain is XCode'\n                    if (operatingSystem.isMacOsX()) {\n                        args.addAll(asList(\"-arch\", \"x86_64\"));\n                    } else {\n                        args.add(\"--64\");\n                    }\n                }\n            });\n        }","id":23023,"modified_method":"public void apply(DefaultGccPlatformToolChain gccToolChain) {\n            gccToolChain.compilerProbeArgs(\"-m64\");\n            Action<List<String>> m64args = new Action<List<String>>() {\n                public void execute(List<String> args) {\n                    args.add(\"-m64\");\n                }\n            };\n            gccToolChain.getCppCompiler().withArguments(m64args);\n            gccToolChain.getcCompiler().withArguments(m64args);\n            gccToolChain.getObjcCompiler().withArguments(m64args);\n            gccToolChain.getObjcppCompiler().withArguments(m64args);\n            gccToolChain.getLinker().withArguments(m64args);\n            gccToolChain.getAssembler().withArguments(m64args);\n        }","commit_id":"f94d945922df4ecf183d880888c22dcdaeff6d92","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n  public void installLocalOnlyTypeProvider(final Iterable<URI> classPathRoots, final XtextResourceSet resourceSet) {\n    super.installLocalOnlyTypeProvider(classPathRoots, resourceSet);\n  }","id":23024,"modified_method":"@Override\n  public void installLocalOnlyTypeProvider(final Iterable<URI> classPathRoots, final XtextResourceSet resourceSet) {\n  }","commit_id":"25b9fba60f97bff6cecd4782de897158076ee668","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public void installTypeProvider(final Iterable<URI> classPathRoots, final XtextResourceSet resSet) {\n    super.installTypeProvider(classPathRoots, resSet);\n  }","id":23025,"modified_method":"@Override\n  public void installTypeProvider(final Iterable<URI> classPathRoots, final XtextResourceSet resSet) {\n  }","commit_id":"25b9fba60f97bff6cecd4782de897158076ee668","url":"https://github.com/eclipse/xtext"},{"original_method":"public IndexState build(final BuildRequest request, final Map<String, LanguageAccess> languages, final ClusteringConfig clusteringConfig) {\n    IResourceClusteringPolicy _xifexpression = null;\n    boolean _notEquals = (!Objects.equal(clusteringConfig, null));\n    if (_notEquals) {\n      DynamicResourceClusteringPolicy _xblockexpression = null;\n      {\n        IncrementalStandaloneBuilder.LOG.info(\"Clustering configured.\");\n        DynamicResourceClusteringPolicy _dynamicResourceClusteringPolicy = new DynamicResourceClusteringPolicy();\n        final Procedure1<DynamicResourceClusteringPolicy> _function = new Procedure1<DynamicResourceClusteringPolicy>() {\n          @Override\n          public void apply(final DynamicResourceClusteringPolicy it) {\n            long _minimumFreeMemory = clusteringConfig.getMinimumFreeMemory();\n            long _multiply = (_minimumFreeMemory * 1024);\n            long _multiply_1 = (_multiply * 1024);\n            it.setMinimumFreeMemory(_multiply_1);\n            int _minimumClusterSize = clusteringConfig.getMinimumClusterSize();\n            it.setMinimumClusterSize(_minimumClusterSize);\n            long _minimumPercentFreeMemory = clusteringConfig.getMinimumPercentFreeMemory();\n            it.setMinimumPercentFreeMemory(_minimumPercentFreeMemory);\n          }\n        };\n        _xblockexpression = ObjectExtensions.<DynamicResourceClusteringPolicy>operator_doubleArrow(_dynamicResourceClusteringPolicy, _function);\n      }\n      _xifexpression = _xblockexpression;\n    } else {\n      _xifexpression = new DisabledClusteringPolicy();\n    }\n    final IResourceClusteringPolicy strategy = _xifexpression;\n    URI _baseDir = request.getBaseDir();\n    File _asFile = FilesAndURIs.asFile(_baseDir);\n    final File tempDir = new File(_asFile, \"xtext-tmp\");\n    final XtextResourceSet resourceSet = this.resourceSetProvider.get();\n    resourceSet.addLoadOption(ResourceDescriptionsProvider.NAMED_BUILDER_SCOPE, Boolean.valueOf(true));\n    final BuildContext context = new BuildContext(languages, resourceSet, strategy, tempDir);\n    final IncrementalStandaloneBuilder.InternalStatefulIncrementalBuilder builder = this.provider.get();\n    builder.context = context;\n    builder.request = request;\n    return builder.launch();\n  }","id":23026,"modified_method":"public IndexState build(final BuildRequest request, final Map<String, LanguageAccess> languages, final ClusteringConfig clusteringConfig) {\n    IResourceClusteringPolicy _xifexpression = null;\n    boolean _notEquals = (!Objects.equal(clusteringConfig, null));\n    if (_notEquals) {\n      DynamicResourceClusteringPolicy _xblockexpression = null;\n      {\n        IncrementalStandaloneBuilder.LOG.info(\"Clustering configured.\");\n        DynamicResourceClusteringPolicy _dynamicResourceClusteringPolicy = new DynamicResourceClusteringPolicy();\n        final Procedure1<DynamicResourceClusteringPolicy> _function = new Procedure1<DynamicResourceClusteringPolicy>() {\n          @Override\n          public void apply(final DynamicResourceClusteringPolicy it) {\n            long _minimumFreeMemory = clusteringConfig.getMinimumFreeMemory();\n            long _multiply = (_minimumFreeMemory * 1024);\n            long _multiply_1 = (_multiply * 1024);\n            it.setMinimumFreeMemory(_multiply_1);\n            int _minimumClusterSize = clusteringConfig.getMinimumClusterSize();\n            it.setMinimumClusterSize(_minimumClusterSize);\n            long _minimumPercentFreeMemory = clusteringConfig.getMinimumPercentFreeMemory();\n            it.setMinimumPercentFreeMemory(_minimumPercentFreeMemory);\n          }\n        };\n        _xblockexpression = ObjectExtensions.<DynamicResourceClusteringPolicy>operator_doubleArrow(_dynamicResourceClusteringPolicy, _function);\n      }\n      _xifexpression = _xblockexpression;\n    } else {\n      _xifexpression = new DisabledClusteringPolicy();\n    }\n    final IResourceClusteringPolicy strategy = _xifexpression;\n    URI _baseDir = request.getBaseDir();\n    File _asFile = FilesAndURIs.asFile(_baseDir);\n    final File tempDir = new File(_asFile, \"xtext-tmp\");\n    final XtextResourceSet resourceSet = request.getResourceSet();\n    resourceSet.addLoadOption(ResourceDescriptionsProvider.NAMED_BUILDER_SCOPE, Boolean.valueOf(true));\n    final BuildContext context = new BuildContext(languages, resourceSet, strategy, tempDir);\n    final IncrementalStandaloneBuilder.InternalStatefulIncrementalBuilder builder = this.provider.get();\n    builder.context = context;\n    builder.request = request;\n    return builder.launch();\n  }","commit_id":"25b9fba60f97bff6cecd4782de897158076ee668","url":"https://github.com/eclipse/xtext"},{"original_method":"public Indexer.IndexResult computeAndIndexAffected(final BuildRequest request, @Extension final BuildContext context) {\n    final boolean fullBuild = request.isFullBuild();\n    if (fullBuild) {\n      Indexer.LOG.info(\"Performing full build\");\n    } else {\n      Indexer.LOG.info(\"Performing incremental build\");\n    }\n    Indexer.LOG.info(\"Creating new index\");\n    IndexState _previousState = request.getPreviousState();\n    final Source2GeneratedMapping fileMappings = _previousState.getFileMappings();\n    IndexState _previousState_1 = request.getPreviousState();\n    final ResourceDescriptionsData oldIndex = _previousState_1.getResourceDescriptions();\n    final ResourceDescriptionsData newIndex = oldIndex.copy();\n    XtextResourceSet _resourceSet = context.getResourceSet();\n    final IResourceDescriptions resourceDescriptions = this.installIndex(_resourceSet, newIndex);\n    Map<String, LanguageAccess> _languages = context.getLanguages();\n    Set<Map.Entry<String, LanguageAccess>> _entrySet = _languages.entrySet();\n    final Function1<Map.Entry<String, LanguageAccess>, Boolean> _function = new Function1<Map.Entry<String, LanguageAccess>, Boolean>() {\n      @Override\n      public Boolean apply(final Map.Entry<String, LanguageAccess> it) {\n        LanguageAccess _value = it.getValue();\n        return Boolean.valueOf(_value.isLinksAgainstJava());\n      }\n    };\n    final boolean isConsiderJava = IterableExtensions.<Map.Entry<String, LanguageAccess>>exists(_entrySet, _function);\n    final HashSet<URI> affectionCandidates = CollectionLiterals.<URI>newHashSet();\n    Set<URI> directlyAffected = null;\n    if (fullBuild) {\n      Iterable<URI> _collectAllResources = this.uriCollector.collectAllResources(request, context);\n      Set<URI> _set = IterableExtensions.<URI>toSet(_collectAllResources);\n      directlyAffected = _set;\n    } else {\n      List<URI> _dirtyFiles = request.getDirtyFiles();\n      List<URI> _deletedFiles = request.getDeletedFiles();\n      Iterable<URI> _plus = Iterables.<URI>concat(_dirtyFiles, _deletedFiles);\n      final Set<URI> allModified = IterableExtensions.<URI>toSet(_plus);\n      Set<URI> _allURIs = oldIndex.getAllURIs();\n      final Function1<URI, Boolean> _function_1 = new Function1<URI, Boolean>() {\n        @Override\n        public Boolean apply(final URI it) {\n          boolean _contains = allModified.contains(it);\n          return Boolean.valueOf((!_contains));\n        }\n      };\n      Iterable<URI> _filter = IterableExtensions.<URI>filter(_allURIs, _function_1);\n      Iterables.<URI>addAll(affectionCandidates, _filter);\n      List<URI> _dirtyFiles_1 = request.getDirtyFiles();\n      final Function1<URI, Iterable<URI>> _function_2 = new Function1<URI, Iterable<URI>>() {\n        @Override\n        public Iterable<URI> apply(final URI it) {\n          return Indexer.this.primarySources(it, fileMappings);\n        }\n      };\n      List<Iterable<URI>> _map = ListExtensions.<URI, Iterable<URI>>map(_dirtyFiles_1, _function_2);\n      Iterable<URI> _flatten = Iterables.<URI>concat(_map);\n      Set<URI> _set_1 = IterableExtensions.<URI>toSet(_flatten);\n      directlyAffected = _set_1;\n    }\n    final ArrayList<IResourceDescription.Delta> currentDeltas = CollectionLiterals.<IResourceDescription.Delta>newArrayList();\n    ArrayList<IResourceDescription.Delta> _removeDeletedFilesFromIndex = this.removeDeletedFilesFromIndex(request, oldIndex, newIndex);\n    Iterables.<IResourceDescription.Delta>addAll(currentDeltas, _removeDeletedFilesFromIndex);\n    if (isConsiderJava) {\n      List<URI> _sourceRoots = request.getSourceRoots();\n      List<URI> _outputs = request.getOutputs();\n      Iterable<URI> _plus_1 = Iterables.<URI>concat(_sourceRoots, _outputs);\n      List<URI> _classPath = request.getClassPath();\n      Iterable<URI> _plus_2 = Iterables.<URI>concat(_plus_1, _classPath);\n      XtextResourceSet _resourceSet_1 = context.getResourceSet();\n      this.javaSupport.installLocalOnlyTypeProvider(_plus_2, _resourceSet_1);\n    }\n    this.preIndexChangedResources(directlyAffected, oldIndex, newIndex, request, context);\n    if (isConsiderJava) {\n      final URI preCompiledClasses = this.javaSupport.preCompileJavaFiles(directlyAffected, newIndex, request, context);\n      List<URI> _sourceRoots_1 = request.getSourceRoots();\n      Iterable<URI> _plus_3 = Iterables.<URI>concat(Collections.<URI>unmodifiableList(CollectionLiterals.<URI>newArrayList(preCompiledClasses)), _sourceRoots_1);\n      List<URI> _outputs_1 = request.getOutputs();\n      Iterable<URI> _plus_4 = Iterables.<URI>concat(_plus_3, _outputs_1);\n      List<URI> _classPath_1 = request.getClassPath();\n      Iterable<URI> _plus_5 = Iterables.<URI>concat(_plus_4, _classPath_1);\n      XtextResourceSet _resourceSet_2 = context.getResourceSet();\n      this.javaSupport.installTypeProvider(_plus_5, _resourceSet_2);\n    }\n    Indexer.LOG.info(\"Indexing changed and added files\");\n    final HashSet<URI> allAffected = CollectionLiterals.<URI>newHashSet();\n    Iterables.<URI>addAll(allAffected, directlyAffected);\n    final HashSet<URI> toBeIndexed = CollectionLiterals.<URI>newHashSet();\n    toBeIndexed.addAll(directlyAffected);\n    final HashSet<IResourceDescription.Delta> allDeltas = CollectionLiterals.<IResourceDescription.Delta>newHashSet();\n    while ((!toBeIndexed.isEmpty())) {\n      {\n        boolean _and = false;\n        if (!isConsiderJava) {\n          _and = false;\n        } else {\n          _and = (!fullBuild);\n        }\n        if (_and) {\n          final Function1<URI, Iterable<URI>> _function_3 = new Function1<URI, Iterable<URI>>() {\n            @Override\n            public Iterable<URI> apply(final URI it) {\n              return fileMappings.getGenerated(it);\n            }\n          };\n          Iterable<Iterable<URI>> _map_1 = IterableExtensions.<URI, Iterable<URI>>map(toBeIndexed, _function_3);\n          Iterable<URI> _flatten_1 = Iterables.<URI>concat(_map_1);\n          Iterable<URI> _plus_6 = Iterables.<URI>concat(_flatten_1, toBeIndexed);\n          final Function1<URI, Boolean> _function_4 = new Function1<URI, Boolean>() {\n            @Override\n            public Boolean apply(final URI it) {\n              String _fileExtension = it.fileExtension();\n              return Boolean.valueOf(Objects.equal(_fileExtension, \"java\"));\n            }\n          };\n          Iterable<URI> _filter_1 = IterableExtensions.<URI>filter(_plus_6, _function_4);\n          final Set<URI> affectedJavaFiles = IterableExtensions.<URI>toSet(_filter_1);\n          List<URI> _deletedFiles_1 = request.getDeletedFiles();\n          final Function1<URI, Iterable<URI>> _function_5 = new Function1<URI, Iterable<URI>>() {\n            @Override\n            public Iterable<URI> apply(final URI it) {\n              return Indexer.this.primarySources(it, fileMappings);\n            }\n          };\n          List<Iterable<URI>> _map_2 = ListExtensions.<URI, Iterable<URI>>map(_deletedFiles_1, _function_5);\n          Iterable<URI> _flatten_2 = Iterables.<URI>concat(_map_2);\n          final Function1<URI, Boolean> _function_6 = new Function1<URI, Boolean>() {\n            @Override\n            public Boolean apply(final URI it) {\n              String _fileExtension = it.fileExtension();\n              return Boolean.valueOf(Objects.equal(_fileExtension, \"java\"));\n            }\n          };\n          final Iterable<URI> deletedPrimaryJavaFiles = IterableExtensions.<URI>filter(_flatten_2, _function_6);\n          final Iterable<? extends URI> dependentJavaFiles = this.javaDependencyFinder.getDependentJavaFiles(affectedJavaFiles, deletedPrimaryJavaFiles);\n          final Function1<URI, Iterable<URI>> _function_7 = new Function1<URI, Iterable<URI>>() {\n            @Override\n            public Iterable<URI> apply(final URI it) {\n              return Indexer.this.primarySources(it, fileMappings);\n            }\n          };\n          Iterable<Iterable<URI>> _map_3 = IterableExtensions.map(dependentJavaFiles, _function_7);\n          Iterable<URI> _flatten_3 = Iterables.<URI>concat(_map_3);\n          final Function1<URI, Boolean> _function_8 = new Function1<URI, Boolean>() {\n            @Override\n            public Boolean apply(final URI it) {\n              boolean _or = false;\n              String _fileExtension = it.fileExtension();\n              boolean _equals = Objects.equal(_fileExtension, \"java\");\n              if (_equals) {\n                _or = true;\n              } else {\n                boolean _contains = affectionCandidates.contains(it);\n                _or = _contains;\n              }\n              return Boolean.valueOf(_or);\n            }\n          };\n          Iterable<URI> _filter_2 = IterableExtensions.<URI>filter(_flatten_3, _function_8);\n          Iterables.<URI>addAll(toBeIndexed, _filter_2);\n        }\n        allAffected.addAll(toBeIndexed);\n        affectionCandidates.removeAll(toBeIndexed);\n        final Function1<Resource, Object> _function_9 = new Function1<Resource, Object>() {\n          @Override\n          public Object apply(final Resource resource) {\n            Object _xblockexpression = null;\n            {\n              URI _uRI = resource.getURI();\n              String _plus = (\"Indexing \" + _uRI);\n              Indexer.LOG.info(_plus);\n              DefaultResourceDescriptionDelta _addToIndex = Indexer.this.addToIndex(resource, false, oldIndex, newIndex, context);\n              currentDeltas.add(_addToIndex);\n              _xblockexpression = null;\n            }\n            return _xblockexpression;\n          }\n        };\n        context.<Object>executeClustered(toBeIndexed, _function_9);\n        final Function1<URI, Boolean> _function_10 = new Function1<URI, Boolean>() {\n          @Override\n          public Boolean apply(final URI it) {\n            String _fileExtension = it.fileExtension();\n            return Boolean.valueOf(Objects.equal(_fileExtension, \"java\"));\n          }\n        };\n        Iterable<URI> _filter_3 = IterableExtensions.<URI>filter(toBeIndexed, _function_10);\n        final Procedure1<URI> _function_11 = new Procedure1<URI>() {\n          @Override\n          public void apply(final URI it) {\n            URI _findSourceRootRelativeURI = FilesAndURIs.findSourceRootRelativeURI(it, request);\n            URI _trimFileExtension = _findSourceRootRelativeURI.trimFileExtension();\n            final String javaPath = _trimFileExtension.toString();\n            String _replace = javaPath.replace(\"/\", \".\");\n            final QualifiedName fqn = Indexer.this.qualifiedNameConverter.toQualifiedName(_replace);\n            TypeResourceDescription.ChangedDelta _changedDelta = new TypeResourceDescription.ChangedDelta(fqn);\n            currentDeltas.add(_changedDelta);\n          }\n        };\n        IterableExtensions.<URI>forEach(_filter_3, _function_11);\n        Iterables.<IResourceDescription.Delta>addAll(allDeltas, currentDeltas);\n        toBeIndexed.clear();\n        final Function1<URI, Boolean> _function_12 = new Function1<URI, Boolean>() {\n          @Override\n          public Boolean apply(final URI it) {\n            boolean _xblockexpression = false;\n            {\n              String _fileExtension = it.fileExtension();\n              boolean _equals = Objects.equal(_fileExtension, \"java\");\n              if (_equals) {\n                return Boolean.valueOf(false);\n              }\n              Map<String, LanguageAccess> _languages = context.getLanguages();\n              String _fileExtension_1 = it.fileExtension();\n              LanguageAccess _get = _languages.get(_fileExtension_1);\n              final IResourceDescription.Manager manager = _get.getResourceDescriptionManager();\n              final IResourceDescription resourceDescription = oldIndex.getResourceDescription(it);\n              _xblockexpression = Indexer.this.isAffected(resourceDescription, manager, currentDeltas, allDeltas, resourceDescriptions);\n            }\n            return Boolean.valueOf(_xblockexpression);\n          }\n        };\n        Iterable<URI> _filter_4 = IterableExtensions.<URI>filter(affectionCandidates, _function_12);\n        Iterables.<URI>addAll(toBeIndexed, _filter_4);\n        currentDeltas.clear();\n        boolean _isEmpty = toBeIndexed.isEmpty();\n        boolean _not = (!_isEmpty);\n        if (_not) {\n          Indexer.LOG.info(\"Indexing affected files\");\n        }\n      }\n    }\n    return new Indexer.IndexResult(allDeltas, allAffected, newIndex);\n  }","id":23027,"modified_method":"public Indexer.IndexResult computeAndIndexAffected(final BuildRequest request, @Extension final BuildContext context) {\n    final boolean fullBuild = request.isFullBuild();\n    if (fullBuild) {\n      Indexer.LOG.info(\"Performing full build\");\n    } else {\n      Indexer.LOG.info(\"Performing incremental build\");\n    }\n    Indexer.LOG.info(\"Creating new index\");\n    IndexState _previousState = request.getPreviousState();\n    final Source2GeneratedMapping fileMappings = _previousState.getFileMappings();\n    IndexState _previousState_1 = request.getPreviousState();\n    final ResourceDescriptionsData oldIndex = _previousState_1.getResourceDescriptions();\n    final ResourceDescriptionsData newIndex = oldIndex.copy();\n    XtextResourceSet _resourceSet = context.getResourceSet();\n    final IResourceDescriptions resourceDescriptions = this.installIndex(_resourceSet, newIndex);\n    Map<String, LanguageAccess> _languages = context.getLanguages();\n    Set<Map.Entry<String, LanguageAccess>> _entrySet = _languages.entrySet();\n    final Function1<Map.Entry<String, LanguageAccess>, Boolean> _function = new Function1<Map.Entry<String, LanguageAccess>, Boolean>() {\n      @Override\n      public Boolean apply(final Map.Entry<String, LanguageAccess> it) {\n        LanguageAccess _value = it.getValue();\n        return Boolean.valueOf(_value.isLinksAgainstJava());\n      }\n    };\n    final boolean isConsiderJava = IterableExtensions.<Map.Entry<String, LanguageAccess>>exists(_entrySet, _function);\n    final HashSet<URI> affectionCandidates = CollectionLiterals.<URI>newHashSet();\n    Set<URI> directlyAffected = null;\n    if (fullBuild) {\n      Iterable<URI> _collectAllResources = this.uriCollector.collectAllResources(request, context);\n      Set<URI> _set = IterableExtensions.<URI>toSet(_collectAllResources);\n      directlyAffected = _set;\n    } else {\n      List<URI> _dirtyFiles = request.getDirtyFiles();\n      List<URI> _deletedFiles = request.getDeletedFiles();\n      Iterable<URI> _plus = Iterables.<URI>concat(_dirtyFiles, _deletedFiles);\n      final Set<URI> allModified = IterableExtensions.<URI>toSet(_plus);\n      Set<URI> _allURIs = oldIndex.getAllURIs();\n      final Function1<URI, Boolean> _function_1 = new Function1<URI, Boolean>() {\n        @Override\n        public Boolean apply(final URI it) {\n          boolean _contains = allModified.contains(it);\n          return Boolean.valueOf((!_contains));\n        }\n      };\n      Iterable<URI> _filter = IterableExtensions.<URI>filter(_allURIs, _function_1);\n      Iterables.<URI>addAll(affectionCandidates, _filter);\n      List<URI> _dirtyFiles_1 = request.getDirtyFiles();\n      final Function1<URI, Iterable<URI>> _function_2 = new Function1<URI, Iterable<URI>>() {\n        @Override\n        public Iterable<URI> apply(final URI it) {\n          return Indexer.this.primarySources(it, fileMappings);\n        }\n      };\n      List<Iterable<URI>> _map = ListExtensions.<URI, Iterable<URI>>map(_dirtyFiles_1, _function_2);\n      Iterable<URI> _flatten = Iterables.<URI>concat(_map);\n      Set<URI> _set_1 = IterableExtensions.<URI>toSet(_flatten);\n      directlyAffected = _set_1;\n    }\n    final ArrayList<IResourceDescription.Delta> currentDeltas = CollectionLiterals.<IResourceDescription.Delta>newArrayList();\n    ArrayList<IResourceDescription.Delta> _removeDeletedFilesFromIndex = this.removeDeletedFilesFromIndex(request, oldIndex, newIndex);\n    Iterables.<IResourceDescription.Delta>addAll(currentDeltas, _removeDeletedFilesFromIndex);\n    this.preIndexChangedResources(directlyAffected, oldIndex, newIndex, request, context);\n    Indexer.LOG.info(\"Indexing changed and added files\");\n    final HashSet<URI> allAffected = CollectionLiterals.<URI>newHashSet();\n    Iterables.<URI>addAll(allAffected, directlyAffected);\n    final HashSet<URI> toBeIndexed = CollectionLiterals.<URI>newHashSet();\n    toBeIndexed.addAll(directlyAffected);\n    final HashSet<IResourceDescription.Delta> allDeltas = CollectionLiterals.<IResourceDescription.Delta>newHashSet();\n    while ((!toBeIndexed.isEmpty())) {\n      {\n        boolean _and = false;\n        if (!isConsiderJava) {\n          _and = false;\n        } else {\n          _and = (!fullBuild);\n        }\n        if (_and) {\n          final Function1<URI, Iterable<URI>> _function_3 = new Function1<URI, Iterable<URI>>() {\n            @Override\n            public Iterable<URI> apply(final URI it) {\n              return fileMappings.getGenerated(it);\n            }\n          };\n          Iterable<Iterable<URI>> _map_1 = IterableExtensions.<URI, Iterable<URI>>map(toBeIndexed, _function_3);\n          Iterable<URI> _flatten_1 = Iterables.<URI>concat(_map_1);\n          Iterable<URI> _plus_1 = Iterables.<URI>concat(_flatten_1, toBeIndexed);\n          final Function1<URI, Boolean> _function_4 = new Function1<URI, Boolean>() {\n            @Override\n            public Boolean apply(final URI it) {\n              String _fileExtension = it.fileExtension();\n              return Boolean.valueOf(Objects.equal(_fileExtension, \"java\"));\n            }\n          };\n          Iterable<URI> _filter_1 = IterableExtensions.<URI>filter(_plus_1, _function_4);\n          final Set<URI> affectedJavaFiles = IterableExtensions.<URI>toSet(_filter_1);\n          List<URI> _deletedFiles_1 = request.getDeletedFiles();\n          final Function1<URI, Iterable<URI>> _function_5 = new Function1<URI, Iterable<URI>>() {\n            @Override\n            public Iterable<URI> apply(final URI it) {\n              return Indexer.this.primarySources(it, fileMappings);\n            }\n          };\n          List<Iterable<URI>> _map_2 = ListExtensions.<URI, Iterable<URI>>map(_deletedFiles_1, _function_5);\n          Iterable<URI> _flatten_2 = Iterables.<URI>concat(_map_2);\n          final Function1<URI, Boolean> _function_6 = new Function1<URI, Boolean>() {\n            @Override\n            public Boolean apply(final URI it) {\n              String _fileExtension = it.fileExtension();\n              return Boolean.valueOf(Objects.equal(_fileExtension, \"java\"));\n            }\n          };\n          final Iterable<URI> deletedPrimaryJavaFiles = IterableExtensions.<URI>filter(_flatten_2, _function_6);\n          final Iterable<? extends URI> dependentJavaFiles = this.javaDependencyFinder.getDependentJavaFiles(affectedJavaFiles, deletedPrimaryJavaFiles);\n          final Function1<URI, Iterable<URI>> _function_7 = new Function1<URI, Iterable<URI>>() {\n            @Override\n            public Iterable<URI> apply(final URI it) {\n              return Indexer.this.primarySources(it, fileMappings);\n            }\n          };\n          Iterable<Iterable<URI>> _map_3 = IterableExtensions.map(dependentJavaFiles, _function_7);\n          Iterable<URI> _flatten_3 = Iterables.<URI>concat(_map_3);\n          final Function1<URI, Boolean> _function_8 = new Function1<URI, Boolean>() {\n            @Override\n            public Boolean apply(final URI it) {\n              boolean _or = false;\n              String _fileExtension = it.fileExtension();\n              boolean _equals = Objects.equal(_fileExtension, \"java\");\n              if (_equals) {\n                _or = true;\n              } else {\n                boolean _contains = affectionCandidates.contains(it);\n                _or = _contains;\n              }\n              return Boolean.valueOf(_or);\n            }\n          };\n          Iterable<URI> _filter_2 = IterableExtensions.<URI>filter(_flatten_3, _function_8);\n          Iterables.<URI>addAll(toBeIndexed, _filter_2);\n        }\n        allAffected.addAll(toBeIndexed);\n        affectionCandidates.removeAll(toBeIndexed);\n        final Function1<Resource, Object> _function_9 = new Function1<Resource, Object>() {\n          @Override\n          public Object apply(final Resource resource) {\n            Object _xblockexpression = null;\n            {\n              URI _uRI = resource.getURI();\n              String _plus = (\"Indexing \" + _uRI);\n              Indexer.LOG.info(_plus);\n              DefaultResourceDescriptionDelta _addToIndex = Indexer.this.addToIndex(resource, false, oldIndex, newIndex, context);\n              currentDeltas.add(_addToIndex);\n              _xblockexpression = null;\n            }\n            return _xblockexpression;\n          }\n        };\n        context.<Object>executeClustered(toBeIndexed, _function_9);\n        final Function1<URI, Boolean> _function_10 = new Function1<URI, Boolean>() {\n          @Override\n          public Boolean apply(final URI it) {\n            String _fileExtension = it.fileExtension();\n            return Boolean.valueOf(Objects.equal(_fileExtension, \"java\"));\n          }\n        };\n        Iterable<URI> _filter_3 = IterableExtensions.<URI>filter(toBeIndexed, _function_10);\n        final Procedure1<URI> _function_11 = new Procedure1<URI>() {\n          @Override\n          public void apply(final URI it) {\n            URI _findSourceRootRelativeURI = FilesAndURIs.findSourceRootRelativeURI(it, request);\n            URI _trimFileExtension = _findSourceRootRelativeURI.trimFileExtension();\n            final String javaPath = _trimFileExtension.toString();\n            String _replace = javaPath.replace(\"/\", \".\");\n            final QualifiedName fqn = Indexer.this.qualifiedNameConverter.toQualifiedName(_replace);\n            TypeResourceDescription.ChangedDelta _changedDelta = new TypeResourceDescription.ChangedDelta(fqn);\n            currentDeltas.add(_changedDelta);\n          }\n        };\n        IterableExtensions.<URI>forEach(_filter_3, _function_11);\n        Iterables.<IResourceDescription.Delta>addAll(allDeltas, currentDeltas);\n        toBeIndexed.clear();\n        final Function1<URI, Boolean> _function_12 = new Function1<URI, Boolean>() {\n          @Override\n          public Boolean apply(final URI it) {\n            boolean _xblockexpression = false;\n            {\n              String _fileExtension = it.fileExtension();\n              boolean _equals = Objects.equal(_fileExtension, \"java\");\n              if (_equals) {\n                return Boolean.valueOf(false);\n              }\n              Map<String, LanguageAccess> _languages = context.getLanguages();\n              String _fileExtension_1 = it.fileExtension();\n              LanguageAccess _get = _languages.get(_fileExtension_1);\n              final IResourceDescription.Manager manager = _get.getResourceDescriptionManager();\n              final IResourceDescription resourceDescription = oldIndex.getResourceDescription(it);\n              _xblockexpression = Indexer.this.isAffected(resourceDescription, manager, currentDeltas, allDeltas, resourceDescriptions);\n            }\n            return Boolean.valueOf(_xblockexpression);\n          }\n        };\n        Iterable<URI> _filter_4 = IterableExtensions.<URI>filter(affectionCandidates, _function_12);\n        Iterables.<URI>addAll(toBeIndexed, _filter_4);\n        currentDeltas.clear();\n        boolean _isEmpty = toBeIndexed.isEmpty();\n        boolean _not = (!_isEmpty);\n        if (_not) {\n          Indexer.LOG.info(\"Indexing affected files\");\n        }\n      }\n    }\n    return new Indexer.IndexResult(allDeltas, allAffected, newIndex);\n  }","commit_id":"25b9fba60f97bff6cecd4782de897158076ee668","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public ResourceSet get(final Object context) {\n    XtextResourceSet _xblockexpression = null;\n    {\n      final XtextResourceSet resourceSet = this.resourceSetProvider.get();\n      if ((context instanceof Project)) {\n        EList<Adapter> _eAdapters = resourceSet.eAdapters();\n        ProjectAdapter _projectAdapter = new ProjectAdapter(((Project)context));\n        _eAdapters.add(_projectAdapter);\n        GlobalSearchScope _allScope = GlobalSearchScope.allScope(((Project)context));\n        resourceSet.setClasspathURIContext(_allScope);\n      }\n      if ((context instanceof PsiFile)) {\n        EList<Adapter> _eAdapters_1 = resourceSet.eAdapters();\n        Project _project = ((PsiFile)context).getProject();\n        ProjectAdapter _projectAdapter_1 = new ProjectAdapter(_project);\n        _eAdapters_1.add(_projectAdapter_1);\n        GlobalSearchScope _resolveScope = ((PsiFile)context).getResolveScope();\n        resourceSet.setClasspathURIContext(_resolveScope);\n      }\n      _xblockexpression = resourceSet;\n    }\n    return _xblockexpression;\n  }","id":23028,"modified_method":"@Override\n  public ResourceSet get(final Object context) {\n    XtextResourceSet _xblockexpression = null;\n    {\n      final XtextResourceSet resourceSet = this.resourceSetProvider.get();\n      if ((context instanceof Project)) {\n        EList<Adapter> _eAdapters = resourceSet.eAdapters();\n        ProjectAdapter _projectAdapter = new ProjectAdapter(((Project)context));\n        _eAdapters.add(_projectAdapter);\n        GlobalSearchScope _allScope = GlobalSearchScope.allScope(((Project)context));\n        resourceSet.setClasspathURIContext(_allScope);\n      }\n      if ((context instanceof Module)) {\n        final Project project = ((Module)context).getProject();\n        EList<Adapter> _eAdapters_1 = resourceSet.eAdapters();\n        ProjectAdapter _projectAdapter_1 = new ProjectAdapter(project);\n        _eAdapters_1.add(_projectAdapter_1);\n        final IndexingAwareGlobalSearchScope indexingAwareGlobalSearchScope = this.globalSearchScopeProvider.get();\n        indexingAwareGlobalSearchScope.setResourceSet(resourceSet);\n        GlobalSearchScope _moduleScope = ((Module)context).getModuleScope();\n        indexingAwareGlobalSearchScope.setFilterScope(_moduleScope);\n        GlobalSearchScope _moduleWithDependenciesAndLibrariesScope = GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(((Module)context));\n        indexingAwareGlobalSearchScope.setSearchScope(_moduleWithDependenciesAndLibrariesScope);\n        resourceSet.setClasspathURIContext(indexingAwareGlobalSearchScope);\n      }\n      if ((context instanceof PsiFile)) {\n        final Project project_1 = ((PsiFile)context).getProject();\n        EList<Adapter> _eAdapters_2 = resourceSet.eAdapters();\n        ProjectAdapter _projectAdapter_2 = new ProjectAdapter(project_1);\n        _eAdapters_2.add(_projectAdapter_2);\n        final IndexingAwareGlobalSearchScope indexingAwareGlobalSearchScope_1 = this.globalSearchScopeProvider.get();\n        indexingAwareGlobalSearchScope_1.setResourceSet(resourceSet);\n        GlobalSearchScope _filterScope = this.getFilterScope(((PsiFile)context), project_1);\n        indexingAwareGlobalSearchScope_1.setFilterScope(_filterScope);\n        GlobalSearchScope _resolveScope = ((PsiFile)context).getResolveScope();\n        indexingAwareGlobalSearchScope_1.setSearchScope(_resolveScope);\n        resourceSet.setClasspathURIContext(indexingAwareGlobalSearchScope_1);\n      }\n      _xblockexpression = resourceSet;\n    }\n    return _xblockexpression;\n  }","commit_id":"25b9fba60f97bff6cecd4782de897158076ee668","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Boolean build() {\n    boolean _xblockexpression = false;\n    {\n      final ArrayList<BuildEvent> allEvents = CollectionLiterals.<BuildEvent>newArrayList();\n      this.queue.drainTo(allEvents);\n      boolean _xtrycatchfinallyexpression = false;\n      try {\n        final HashMultimap<Module, BuildEvent> module2event = HashMultimap.<Module, BuildEvent>create();\n        final ProjectFileIndex fileIndex = ProjectFileIndex.SERVICE.getInstance(this.project);\n        final Procedure1<BuildEvent> _function = new Procedure1<BuildEvent>() {\n          @Override\n          public void apply(final BuildEvent it) {\n            Map<String, LanguageAccess> _languageAccesses = XtextAutoBuilder.this.xtextLanguages.getLanguageAccesses();\n            VirtualFile _file = it.getFile();\n            String _extension = _file.getExtension();\n            LanguageAccess _get = _languageAccesses.get(_extension);\n            boolean _notEquals = (!Objects.equal(_get, null));\n            if (_notEquals) {\n              VirtualFile _file_1 = it.getFile();\n              final Module module = fileIndex.getModuleForFile(_file_1);\n              boolean _notEquals_1 = (!Objects.equal(module, null));\n              if (_notEquals_1) {\n                module2event.put(module, it);\n              }\n            }\n          }\n        };\n        IterableExtensions.<BuildEvent>forEach(allEvents, _function);\n        EncodingProjectManager _instance = EncodingProjectManager.getInstance(this.project);\n        final String projectEncoding = _instance.getDefaultCharsetName();\n        final ArrayList<URI> refreshFiles = CollectionLiterals.<URI>newArrayList();\n        Set<Module> _keySet = module2event.keySet();\n        for (final Module module : _keySet) {\n          {\n            final Set<BuildEvent> events = module2event.get(module);\n            final OrderEnumerator entries = OrderEnumerator.orderEntries(module);\n            BuildRequest _buildRequest = new BuildRequest();\n            final Procedure1<BuildRequest> _function_1 = new Procedure1<BuildRequest>() {\n              @Override\n              public void apply(final BuildRequest it) {\n                List<URI> _dirtyFiles = it.getDirtyFiles();\n                final Function1<BuildEvent, Boolean> _function = new Function1<BuildEvent, Boolean>() {\n                  @Override\n                  public Boolean apply(final BuildEvent it) {\n                    boolean _or = false;\n                    BuildEvent.Type _type = it.getType();\n                    boolean _equals = Objects.equal(_type, BuildEvent.Type.MODIFIED);\n                    if (_equals) {\n                      _or = true;\n                    } else {\n                      BuildEvent.Type _type_1 = it.getType();\n                      boolean _equals_1 = Objects.equal(_type_1, BuildEvent.Type.ADDED);\n                      _or = _equals_1;\n                    }\n                    return Boolean.valueOf(_or);\n                  }\n                };\n                Iterable<BuildEvent> _filter = IterableExtensions.<BuildEvent>filter(events, _function);\n                final Function1<BuildEvent, URI> _function_1 = new Function1<BuildEvent, URI>() {\n                  @Override\n                  public URI apply(final BuildEvent it) {\n                    VirtualFile _file = it.getFile();\n                    return XtextAutoBuilder.this.getURI(_file);\n                  }\n                };\n                Iterable<URI> _map = IterableExtensions.<BuildEvent, URI>map(_filter, _function_1);\n                Iterables.<URI>addAll(_dirtyFiles, _map);\n                List<URI> _deletedFiles = it.getDeletedFiles();\n                final Function1<BuildEvent, Boolean> _function_2 = new Function1<BuildEvent, Boolean>() {\n                  @Override\n                  public Boolean apply(final BuildEvent it) {\n                    BuildEvent.Type _type = it.getType();\n                    return Boolean.valueOf(Objects.equal(_type, BuildEvent.Type.DELETED));\n                  }\n                };\n                Iterable<BuildEvent> _filter_1 = IterableExtensions.<BuildEvent>filter(events, _function_2);\n                final Function1<BuildEvent, URI> _function_3 = new Function1<BuildEvent, URI>() {\n                  @Override\n                  public URI apply(final BuildEvent it) {\n                    VirtualFile _file = it.getFile();\n                    return XtextAutoBuilder.this.getURI(_file);\n                  }\n                };\n                Iterable<URI> _map_1 = IterableExtensions.<BuildEvent, URI>map(_filter_1, _function_3);\n                Iterables.<URI>addAll(_deletedFiles, _map_1);\n                List<URI> _classPath = it.getClassPath();\n                OrderEnumerator _withoutSdk = entries.withoutSdk();\n                OrderRootsEnumerator _classes = _withoutSdk.classes();\n                PathsList _pathsList = _classes.getPathsList();\n                List<VirtualFile> _virtualFiles = _pathsList.getVirtualFiles();\n                final Function1<VirtualFile, URI> _function_4 = new Function1<VirtualFile, URI>() {\n                  @Override\n                  public URI apply(final VirtualFile it) {\n                    return XtextAutoBuilder.this.getURI(it);\n                  }\n                };\n                List<URI> _map_2 = ListExtensions.<VirtualFile, URI>map(_virtualFiles, _function_4);\n                Iterables.<URI>addAll(_classPath, _map_2);\n                ModuleRootManager _instance = ModuleRootManager.getInstance(module);\n                VirtualFile[] _contentRoots = _instance.getContentRoots();\n                VirtualFile _head = IterableExtensions.<VirtualFile>head(((Iterable<VirtualFile>)Conversions.doWrapArray(_contentRoots)));\n                URI _uRI = XtextAutoBuilder.this.getURI(_head);\n                it.setBaseDir(_uRI);\n                it.setDefaultEncoding(projectEncoding);\n                List<URI> _sourceRoots = it.getSourceRoots();\n                OrderEnumerator _withoutSdk_1 = entries.withoutSdk();\n                OrderEnumerator _withoutLibraries = _withoutSdk_1.withoutLibraries();\n                OrderEnumerator _withoutDepModules = _withoutLibraries.withoutDepModules();\n                OrderRootsEnumerator _sources = _withoutDepModules.sources();\n                PathsList _pathsList_1 = _sources.getPathsList();\n                List<VirtualFile> _virtualFiles_1 = _pathsList_1.getVirtualFiles();\n                final Function1<VirtualFile, URI> _function_5 = new Function1<VirtualFile, URI>() {\n                  @Override\n                  public URI apply(final VirtualFile it) {\n                    return XtextAutoBuilder.this.getURI(it);\n                  }\n                };\n                List<URI> _map_3 = ListExtensions.<VirtualFile, URI>map(_virtualFiles_1, _function_5);\n                Iterables.<URI>addAll(_sourceRoots, _map_3);\n                it.setFailOnValidationError(false);\n                boolean _notEquals = (!Objects.equal(XtextAutoBuilder.this.indexState, null));\n                if (_notEquals) {\n                  it.setPreviousState(XtextAutoBuilder.this.indexState);\n                } else {\n                  it.setIsFullBuild(true);\n                }\n                IIssueHandler _issueHandler = it.getIssueHandler();\n                it.setIssueHandler(_issueHandler);\n                final Procedure2<URI, URI> _function_6 = new Procedure2<URI, URI>() {\n                  @Override\n                  public void apply(final URI $0, final URI $1) {\n                    refreshFiles.add($1);\n                  }\n                };\n                it.setAfterGenerateFile(_function_6);\n                final Procedure1<URI> _function_7 = new Procedure1<URI>() {\n                  @Override\n                  public void apply(final URI it) {\n                    refreshFiles.add(it);\n                  }\n                };\n                it.setAfterDeleteFile(_function_7);\n              }\n            };\n            final BuildRequest request = ObjectExtensions.<BuildRequest>operator_doubleArrow(_buildRequest, _function_1);\n            IncrementalStandaloneBuilder _get = this.builderProvider.get();\n            Map<String, LanguageAccess> _languageAccesses = this.xtextLanguages.getLanguageAccesses();\n            IndexState _build = _get.build(request, _languageAccesses);\n            this.indexState = _build;\n          }\n        }\n        final Function1<URI, File> _function_1 = new Function1<URI, File>() {\n          @Override\n          public File apply(final URI it) {\n            return FilesAndURIs.asFile(it);\n          }\n        };\n        List<File> _map = ListExtensions.<URI, File>map(refreshFiles, _function_1);\n        CompilerUtil.refreshIOFiles(_map);\n      } catch (final Throwable _t) {\n        if (_t instanceof ProcessCanceledException) {\n          final ProcessCanceledException exc = (ProcessCanceledException)_t;\n          _xtrycatchfinallyexpression = this.queue.addAll(allEvents);\n        } else {\n          throw Exceptions.sneakyThrow(_t);\n        }\n      }\n      _xblockexpression = _xtrycatchfinallyexpression;\n    }\n    return Boolean.valueOf(_xblockexpression);\n  }","id":23029,"modified_method":"protected void build() {\n    final ArrayList<BuildEvent> allEvents = CollectionLiterals.<BuildEvent>newArrayList();\n    this.queue.drainTo(allEvents);\n    try {\n      final HashMultimap<Module, BuildEvent> module2event = HashMultimap.<Module, BuildEvent>create();\n      final ProjectFileIndex fileIndex = ProjectFileIndex.SERVICE.getInstance(this.project);\n      final Procedure1<BuildEvent> _function = new Procedure1<BuildEvent>() {\n        @Override\n        public void apply(final BuildEvent it) {\n          Map<String, LanguageAccess> _languageAccesses = XtextAutoBuilder.this.xtextLanguages.getLanguageAccesses();\n          VirtualFile _file = it.getFile();\n          String _extension = _file.getExtension();\n          LanguageAccess _get = _languageAccesses.get(_extension);\n          boolean _notEquals = (!Objects.equal(_get, null));\n          if (_notEquals) {\n            VirtualFile _file_1 = it.getFile();\n            final Module module = fileIndex.getModuleForFile(_file_1);\n            boolean _notEquals_1 = (!Objects.equal(module, null));\n            if (_notEquals_1) {\n              module2event.put(module, it);\n            }\n          }\n        }\n      };\n      IterableExtensions.<BuildEvent>forEach(allEvents, _function);\n      EncodingProjectManager _instance = EncodingProjectManager.getInstance(this.project);\n      final String projectEncoding = _instance.getDefaultCharsetName();\n      final ArrayList<URI> refreshFiles = CollectionLiterals.<URI>newArrayList();\n      Set<Module> _keySet = module2event.keySet();\n      for (final Module module : _keySet) {\n        {\n          final Set<BuildEvent> events = module2event.get(module);\n          final OrderEnumerator entries = OrderEnumerator.orderEntries(module);\n          BuildRequest _buildRequest = new BuildRequest();\n          final Procedure1<BuildRequest> _function_1 = new Procedure1<BuildRequest>() {\n            @Override\n            public void apply(final BuildRequest it) {\n              ResourceSet _get = XtextAutoBuilder.this.resourceSetProvider.get(module);\n              it.setResourceSet(((XtextResourceSet) _get));\n              List<URI> _dirtyFiles = it.getDirtyFiles();\n              final Function1<BuildEvent, Boolean> _function = new Function1<BuildEvent, Boolean>() {\n                @Override\n                public Boolean apply(final BuildEvent it) {\n                  boolean _or = false;\n                  BuildEvent.Type _type = it.getType();\n                  boolean _equals = Objects.equal(_type, BuildEvent.Type.MODIFIED);\n                  if (_equals) {\n                    _or = true;\n                  } else {\n                    BuildEvent.Type _type_1 = it.getType();\n                    boolean _equals_1 = Objects.equal(_type_1, BuildEvent.Type.ADDED);\n                    _or = _equals_1;\n                  }\n                  return Boolean.valueOf(_or);\n                }\n              };\n              Iterable<BuildEvent> _filter = IterableExtensions.<BuildEvent>filter(events, _function);\n              final Function1<BuildEvent, URI> _function_1 = new Function1<BuildEvent, URI>() {\n                @Override\n                public URI apply(final BuildEvent it) {\n                  VirtualFile _file = it.getFile();\n                  return XtextAutoBuilder.this.getURI(_file);\n                }\n              };\n              Iterable<URI> _map = IterableExtensions.<BuildEvent, URI>map(_filter, _function_1);\n              Iterables.<URI>addAll(_dirtyFiles, _map);\n              List<URI> _deletedFiles = it.getDeletedFiles();\n              final Function1<BuildEvent, Boolean> _function_2 = new Function1<BuildEvent, Boolean>() {\n                @Override\n                public Boolean apply(final BuildEvent it) {\n                  BuildEvent.Type _type = it.getType();\n                  return Boolean.valueOf(Objects.equal(_type, BuildEvent.Type.DELETED));\n                }\n              };\n              Iterable<BuildEvent> _filter_1 = IterableExtensions.<BuildEvent>filter(events, _function_2);\n              final Function1<BuildEvent, URI> _function_3 = new Function1<BuildEvent, URI>() {\n                @Override\n                public URI apply(final BuildEvent it) {\n                  VirtualFile _file = it.getFile();\n                  return XtextAutoBuilder.this.getURI(_file);\n                }\n              };\n              Iterable<URI> _map_1 = IterableExtensions.<BuildEvent, URI>map(_filter_1, _function_3);\n              Iterables.<URI>addAll(_deletedFiles, _map_1);\n              List<URI> _classPath = it.getClassPath();\n              OrderEnumerator _withoutSdk = entries.withoutSdk();\n              OrderRootsEnumerator _classes = _withoutSdk.classes();\n              PathsList _pathsList = _classes.getPathsList();\n              List<VirtualFile> _virtualFiles = _pathsList.getVirtualFiles();\n              final Function1<VirtualFile, URI> _function_4 = new Function1<VirtualFile, URI>() {\n                @Override\n                public URI apply(final VirtualFile it) {\n                  return XtextAutoBuilder.this.getURI(it);\n                }\n              };\n              List<URI> _map_2 = ListExtensions.<VirtualFile, URI>map(_virtualFiles, _function_4);\n              Iterables.<URI>addAll(_classPath, _map_2);\n              ModuleRootManager _instance = ModuleRootManager.getInstance(module);\n              VirtualFile[] _contentRoots = _instance.getContentRoots();\n              VirtualFile _head = IterableExtensions.<VirtualFile>head(((Iterable<VirtualFile>)Conversions.doWrapArray(_contentRoots)));\n              URI _uRI = XtextAutoBuilder.this.getURI(_head);\n              it.setBaseDir(_uRI);\n              it.setDefaultEncoding(projectEncoding);\n              List<URI> _sourceRoots = it.getSourceRoots();\n              OrderEnumerator _withoutSdk_1 = entries.withoutSdk();\n              OrderEnumerator _withoutLibraries = _withoutSdk_1.withoutLibraries();\n              OrderEnumerator _withoutDepModules = _withoutLibraries.withoutDepModules();\n              OrderRootsEnumerator _sources = _withoutDepModules.sources();\n              PathsList _pathsList_1 = _sources.getPathsList();\n              List<VirtualFile> _virtualFiles_1 = _pathsList_1.getVirtualFiles();\n              final Function1<VirtualFile, URI> _function_5 = new Function1<VirtualFile, URI>() {\n                @Override\n                public URI apply(final VirtualFile it) {\n                  return XtextAutoBuilder.this.getURI(it);\n                }\n              };\n              List<URI> _map_3 = ListExtensions.<VirtualFile, URI>map(_virtualFiles_1, _function_5);\n              Iterables.<URI>addAll(_sourceRoots, _map_3);\n              it.setFailOnValidationError(false);\n              boolean _notEquals = (!Objects.equal(XtextAutoBuilder.this.indexState, null));\n              if (_notEquals) {\n                it.setPreviousState(XtextAutoBuilder.this.indexState);\n              } else {\n                it.setIsFullBuild(true);\n              }\n              IIssueHandler _issueHandler = it.getIssueHandler();\n              it.setIssueHandler(_issueHandler);\n              final Procedure2<URI, URI> _function_6 = new Procedure2<URI, URI>() {\n                @Override\n                public void apply(final URI $0, final URI $1) {\n                  refreshFiles.add($1);\n                }\n              };\n              it.setAfterGenerateFile(_function_6);\n              final Procedure1<URI> _function_7 = new Procedure1<URI>() {\n                @Override\n                public void apply(final URI it) {\n                  refreshFiles.add(it);\n                }\n              };\n              it.setAfterDeleteFile(_function_7);\n            }\n          };\n          final BuildRequest request = ObjectExtensions.<BuildRequest>operator_doubleArrow(_buildRequest, _function_1);\n          Application _application = ApplicationManager.getApplication();\n          final Computable<IndexState> _function_2 = new Computable<IndexState>() {\n            @Override\n            public IndexState compute() {\n              IncrementalStandaloneBuilder _get = XtextAutoBuilder.this.builderProvider.get();\n              Map<String, LanguageAccess> _languageAccesses = XtextAutoBuilder.this.xtextLanguages.getLanguageAccesses();\n              return _get.build(request, _languageAccesses);\n            }\n          };\n          IndexState _runReadAction = _application.<IndexState>runReadAction(_function_2);\n          this.indexState = _runReadAction;\n        }\n      }\n      final Function1<URI, File> _function_1 = new Function1<URI, File>() {\n        @Override\n        public File apply(final URI it) {\n          return FilesAndURIs.asFile(it);\n        }\n      };\n      List<File> _map = ListExtensions.<URI, File>map(refreshFiles, _function_1);\n      CompilerUtil.refreshIOFiles(_map);\n    } catch (final Throwable _t) {\n      if (_t instanceof ProcessCanceledException) {\n        final ProcessCanceledException exc = (ProcessCanceledException)_t;\n        this.queue.addAll(allEvents);\n      } else {\n        throw Exceptions.sneakyThrow(_t);\n      }\n    }\n  }","commit_id":"25b9fba60f97bff6cecd4782de897158076ee668","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void enqueue(final VirtualFile file, final BuildEvent.Type type) {\n    try {\n      BuildEvent _buildEvent = new BuildEvent(file, type);\n      this.queue.put(_buildEvent);\n      this.alarm.cancelAllRequests();\n      final Runnable _function = new Runnable() {\n        @Override\n        public void run() {\n          XtextAutoBuilder.this.build();\n        }\n      };\n      this.alarm.addRequest(_function, 200);\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":23030,"modified_method":"protected void enqueue(final VirtualFile file, final BuildEvent.Type type) {\n    try {\n      boolean _notEquals = (!Objects.equal(file, null));\n      if (_notEquals) {\n        BuildEvent _buildEvent = new BuildEvent(file, type);\n        this.queue.put(_buildEvent);\n        this.alarm.cancelAllRequests();\n        final Runnable _function = new Runnable() {\n          @Override\n          public void run() {\n            XtextAutoBuilder.this.build();\n          }\n        };\n        this.alarm.addRequest(_function, 200);\n      }\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"25b9fba60f97bff6cecd4782de897158076ee668","url":"https://github.com/eclipse/xtext"},{"original_method":"private URI getURI(final VirtualFile file) {\n    String _url = file.getUrl();\n    return URI.createURI(_url);\n  }","id":23031,"modified_method":"protected URI getURI(final VirtualFile file) {\n    URI _xblockexpression = null;\n    {\n      URI _xifexpression = null;\n      boolean _isInLocalFileSystem = file.isInLocalFileSystem();\n      if (_isInLocalFileSystem) {\n        String _path = file.getPath();\n        _xifexpression = URI.createFileURI(_path);\n      } else {\n        String _url = file.getUrl();\n        _xifexpression = URI.createURI(_url);\n      }\n      final URI uri = _xifexpression;\n      URI _xifexpression_1 = null;\n      boolean _isDirectory = file.isDirectory();\n      if (_isDirectory) {\n        _xifexpression_1 = uri.appendSegment(\"\");\n      } else {\n        _xifexpression_1 = uri;\n      }\n      _xblockexpression = _xifexpression_1;\n    }\n    return _xblockexpression;\n  }","commit_id":"25b9fba60f97bff6cecd4782de897158076ee668","url":"https://github.com/eclipse/xtext"},{"original_method":"public CmsAvailabilityDialog(I_CmsDialogContext dialogContext) {\n\n        super();\n        m_dialogContext = dialogContext;\n        CmsVaadinUtils.readAndLocalizeDesign(\n            (Component)this,\n            OpenCms.getWorkplaceManager().getMessages(A_CmsUI.get().getLocale()),\n            null);\n\n        List<CmsResource> resources = dialogContext.getResources();\n        if (resources.size() == 1) {\n            CmsResource onlyResource = resources.get(0);\n            if (onlyResource.getDateReleased() != CmsResource.DATE_RELEASED_DEFAULT) {\n                m_releasedField.setValue(new Date(onlyResource.getDateReleased()));\n            }\n            if (onlyResource.getDateExpired() != CmsResource.DATE_EXPIRED_DEFAULT) {\n                m_expiredField.setValue(new Date(onlyResource.getDateExpired()));\n            }\n        }\n        boolean hasFolders = false;\n        for (CmsResource resource : resources) {\n            if (resource.isFolder()) {\n                hasFolders = true;\n            }\n        }\n        m_subresourceModificationField.setVisible(hasFolders);\n        initResetCheckbox(m_resetReleased, m_releasedField);\n        initResetCheckbox(m_resetExpired, m_expiredField);\n\n        AbstractComponentContainer cont = new VerticalLayout();\n\n        m_okButton.addClickListener(new ClickListener() {\n\n            public void buttonClick(ClickEvent event) {\n\n                if (validate()) {\n                    try {\n\n                        changeAvailability();\n                        m_dialogContext.finish(null);\n                    } catch (Throwable t) {\n                        m_dialogContext.error(t);\n                    }\n                }\n            }\n\n        });\n\n        m_cancelButton.addClickListener(new ClickListener() {\n\n            public void buttonClick(ClickEvent event) {\n\n                m_dialogContext.finish(null);\n            }\n        });\n\n    }","id":23032,"modified_method":"public CmsAvailabilityDialog(I_CmsDialogContext dialogContext) {\n\n        super();\n        m_dialogContext = dialogContext;\n        CmsVaadinUtils.readAndLocalizeDesign(\n            this,\n            OpenCms.getWorkplaceManager().getMessages(A_CmsUI.get().getLocale()),\n            null);\n\n        List<CmsResource> resources = dialogContext.getResources();\n        if (resources.size() == 1) {\n            CmsResource onlyResource = resources.get(0);\n            if (onlyResource.getDateReleased() != CmsResource.DATE_RELEASED_DEFAULT) {\n                m_releasedField.setValue(new Date(onlyResource.getDateReleased()));\n            }\n            if (onlyResource.getDateExpired() != CmsResource.DATE_EXPIRED_DEFAULT) {\n                m_expiredField.setValue(new Date(onlyResource.getDateExpired()));\n            }\n        }\n        boolean hasFolders = false;\n        for (CmsResource resource : resources) {\n            if (resource.isFolder()) {\n                hasFolders = true;\n            }\n        }\n        m_subresourceModificationField.setVisible(hasFolders);\n        initResetCheckbox(m_resetReleased, m_releasedField);\n        initResetCheckbox(m_resetExpired, m_expiredField);\n\n        AbstractComponentContainer cont = new VerticalLayout();\n\n        m_okButton.addClickListener(new ClickListener() {\n\n            public void buttonClick(ClickEvent event) {\n\n                if (validate()) {\n                    try {\n\n                        changeAvailability();\n                        m_dialogContext.finish(null);\n                    } catch (Throwable t) {\n                        m_dialogContext.error(t);\n                    }\n                }\n            }\n\n        });\n\n        m_cancelButton.addClickListener(new ClickListener() {\n\n            public void buttonClick(ClickEvent event) {\n\n                m_dialogContext.finish(null);\n            }\n        });\n        displayResourceInfo(m_dialogContext.getResources());\n    }","commit_id":"3b1dbdd8757accb8c268488f0598c29eb6fbb438","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Sets the content.<p>\n     *\n     * @param content the content widget\n     */\n    public void setContent(Component content) {\n\n        m_content.removeAllComponents();\n        m_content.addComponent(content);\n\n    }","id":23033,"modified_method":"/**\n     * Sets the content.<p>\n     *\n     * @param content the content widget\n     */\n    public void setContent(Component content) {\n\n        m_contentPanel.setContent(content);\n        if (content instanceof Layout.MarginHandler) {\n            ((Layout.MarginHandler)content).setMargin(true);\n        }\n    }","commit_id":"3b1dbdd8757accb8c268488f0598c29eb6fbb438","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates new instance.<p>\n     */\n    public CmsBasicDialog() {\n        setSpacing(true);\n        setSizeFull();\n        m_contentPanel.setContent(m_content);\n        addComponent(m_contentPanel);\n        m_content.setMargin(true);\n        addComponent(m_buttonPanel);\n        setExpandRatio(m_contentPanel, 1);\n        m_contentPanel.setHeight(\"100%\");\n        m_buttonPanel.setSpacing(true);\n        setComponentAlignment(m_buttonPanel, Alignment.MIDDLE_RIGHT);\n        m_buttonPanel.addStyleName(\"o-dialog-button-bar\");\n    }","id":23034,"modified_method":"/**\n     * Creates new instance.<p>\n     */\n    public CmsBasicDialog() {\n        addStyleName(\"o-dialog\");\n        setMargin(true);\n        setSpacing(true);\n        setWidth(\"100%\");\n        Panel panel = new Panel();\n        panel.setContent(m_mainPanel);\n        m_mainPanel.addStyleName(\"o-dialog-content\");\n        m_mainPanel.setSpacing(true);\n        addComponent(panel);\n        m_contentPanel = new Panel();\n\n        m_mainPanel.addComponent(m_contentPanel);\n        m_mainPanel.setExpandRatio(m_contentPanel, 3);\n        addComponent(m_buttonPanel);\n        setExpandRatio(panel, 1);\n        // m_contentPanel.setHeight(\"100%\");\n        m_buttonPanel.setSpacing(true);\n        setComponentAlignment(m_buttonPanel, Alignment.MIDDLE_RIGHT);\n        m_buttonPanel.addStyleName(\"o-dialog-button-bar\");\n    }","commit_id":"3b1dbdd8757accb8c268488f0598c29eb6fbb438","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ui.I_CmsDialogContext#start(java.lang.String, com.vaadin.ui.Component)\n     */\n    public void start(String title, Component dialog) {\n\n        if (dialog != null) {\n            CmsContextMenuDialogPanel panel = new CmsContextMenuDialogPanel();\n            panel.setContent(dialog);\n            m_window = prepareWindow();\n            m_window.setCaption(title);\n            m_window.setContent(panel);\n            A_CmsUI.get().addWindow(m_window);\n            try {\n                for (CmsResource resource : m_resources) {\n                    CmsResourceUtil resUtil = new CmsResourceUtil(getCms(), resource);\n                    Locale locale = A_CmsUI.get().getLocale();\n                    panel.addResourceInfo(\n                        new CmsResourceInfo(\n                            resUtil.getGalleryTitle(locale),\n                            resUtil.getGalleryDescription(locale),\n                            resUtil.getBigIconPath()));\n                }\n\n            } catch (Exception e) {\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n\n        }\n    }","id":23035,"modified_method":"/**\n     * @see org.opencms.ui.I_CmsDialogContext#start(java.lang.String, com.vaadin.ui.Component)\n     */\n    public void start(String title, Component dialog) {\n\n        if (dialog != null) {\n            m_window = prepareWindow();\n            m_window.setCaption(title);\n            m_window.setContent(dialog);\n            A_CmsUI.get().addWindow(m_window);\n        }\n    }","commit_id":"3b1dbdd8757accb8c268488f0598c29eb6fbb438","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initializes the dialog window.<p>\n     *\n     * @return the window to be used by dialogs\n     */\n    protected Window prepareWindow() {\n\n        Window window = new Window();\n        window.setModal(true);\n        window.setClosable(false);\n        window.setWidth(\"800px\");\n        int height = Math.max(400, A_CmsUI.get().getPage().getBrowserWindowHeight() - 200);\n        window.setHeight(height + \"px\");\n        window.center();\n        return window;\n\n    }","id":23036,"modified_method":"/**\n     * Initializes the dialog window.<p>\n     *\n     * @return the window to be used by dialogs\n     */\n    protected Window prepareWindow() {\n\n        Window window = new Window();\n        window.setModal(true);\n        window.setClosable(true);\n        window.setWidth(\"600px\");\n        window.center();\n        return window;\n\n    }","commit_id":"3b1dbdd8757accb8c268488f0598c29eb6fbb438","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a new instance.<p>\n     *\n     * @param context the dialog context\n     */\n    public CmsSecureExportDialog(I_CmsDialogContext context) {\n        m_context = context;\n        CmsObject cms = context.getCms();\n\n        CmsVaadinUtils.readAndLocalizeDesign(\n            this,\n            OpenCms.getWorkplaceManager().getMessages(A_CmsUI.get().getLocale()),\n            null);\n        m_resource = m_context.getResources().get(0);\n\n        initComboBox(m_exportField);\n        initComboBox(m_secureField);\n        m_linkField.setValue(OpenCms.getLinkManager().getOnlineLink(cms, cms.getSitePath(m_resource)));\n\n        loadData();\n        CmsSite site = OpenCms.getSiteManager().getCurrentSite(context.getCms());\n        if ((site != null) && !site.hasSecureServer()) {\n            m_secureField.setEnabled(false);\n        }\n\n        m_internalField.addValueChangeListener(new ValueChangeListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void valueChange(ValueChangeEvent event) {\n\n                Boolean valueObj = (Boolean)(event.getProperty().getValue());\n                if (valueObj.booleanValue()) {\n                    m_secureField.setEnabled(false);\n                    m_exportField.setEnabled(false);\n                } else {\n                    m_secureField.setEnabled(true);\n                    m_exportField.setEnabled(true);\n                }\n\n            }\n        });\n\n        m_cancelButton.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                m_context.finish(null);\n            }\n\n        });\n\n        m_okButton.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                try {\n                    saveData();\n                    m_context.finish(null);\n                } catch (Exception e) {\n                    m_context.error(e);\n                }\n            }\n        });\n    }","id":23037,"modified_method":"/**\n     * Creates a new instance.<p>\n     *\n     * @param context the dialog context\n     */\n    public CmsSecureExportDialog(I_CmsDialogContext context) {\n        m_context = context;\n        CmsObject cms = context.getCms();\n\n        CmsVaadinUtils.readAndLocalizeDesign(\n            this,\n            OpenCms.getWorkplaceManager().getMessages(A_CmsUI.get().getLocale()),\n            null);\n        m_resource = m_context.getResources().get(0);\n\n        initComboBox(m_exportField);\n        initComboBox(m_secureField);\n        m_linkField.setValue(OpenCms.getLinkManager().getOnlineLink(cms, cms.getSitePath(m_resource)));\n\n        loadData();\n        CmsSite site = OpenCms.getSiteManager().getCurrentSite(context.getCms());\n        if ((site != null) && !site.hasSecureServer()) {\n            m_secureField.setEnabled(false);\n        }\n\n        m_internalField.addValueChangeListener(new ValueChangeListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void valueChange(ValueChangeEvent event) {\n\n                Boolean valueObj = (Boolean)(event.getProperty().getValue());\n                if (valueObj.booleanValue()) {\n                    m_secureField.setEnabled(false);\n                    m_exportField.setEnabled(false);\n                } else {\n                    m_secureField.setEnabled(true);\n                    m_exportField.setEnabled(true);\n                }\n\n            }\n        });\n\n        m_cancelButton.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                m_context.finish(null);\n            }\n\n        });\n\n        m_okButton.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                try {\n                    saveData();\n                    m_context.finish(null);\n                } catch (Exception e) {\n                    m_context.error(e);\n                }\n            }\n        });\n        displayResourceInfo(m_context.getResources());\n    }","commit_id":"3b1dbdd8757accb8c268488f0598c29eb6fbb438","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a new instance.<p>\n     *\n     * @param context the dialog context\n     */\n    public CmsTouchDialog(I_CmsDialogContext context) {\n        m_context = context;\n        boolean hasFolders = false;\n\n        for (CmsResource resource : context.getResources()) {\n            if (resource.isFolder()) {\n                hasFolders = true;\n                break;\n            }\n        }\n\n        CmsVaadinUtils.readAndLocalizeDesign(\n            this,\n            OpenCms.getWorkplaceManager().getMessages(A_CmsUI.get().getLocale()),\n            null);\n        m_modifySubresourcesField.setVisible(hasFolders);\n\n        m_cancelButton.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                m_context.finish(null);\n            }\n\n        });\n\n        m_okButton.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                try {\n                    touchFiles();\n                    m_context.finish(null);\n                } catch (Exception e) {\n                    m_context.error(e);\n                }\n            }\n        });\n        m_dateField.setValue(new Date());\n\n    }","id":23038,"modified_method":"/**\n     * Creates a new instance.<p>\n     *\n     * @param context the dialog context\n     */\n    public CmsTouchDialog(I_CmsDialogContext context) {\n        m_context = context;\n        boolean hasFolders = false;\n\n        for (CmsResource resource : context.getResources()) {\n            if (resource.isFolder()) {\n                hasFolders = true;\n                break;\n            }\n        }\n\n        CmsVaadinUtils.readAndLocalizeDesign(\n            this,\n            OpenCms.getWorkplaceManager().getMessages(A_CmsUI.get().getLocale()),\n            null);\n        m_modifySubresourcesField.setVisible(hasFolders);\n\n        m_cancelButton.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                m_context.finish(null);\n            }\n\n        });\n\n        m_okButton.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                try {\n                    touchFiles();\n                    m_context.finish(null);\n                } catch (Exception e) {\n                    m_context.error(e);\n                }\n            }\n        });\n        m_dateField.setValue(new Date());\n        displayResourceInfo(m_context.getResources());\n    }","commit_id":"3b1dbdd8757accb8c268488f0598c29eb6fbb438","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a new instance.<p>\n     *\n     * @param context the dialog context\n     */\n    public CmsUndoDialog(I_CmsDialogContext context) {\n        m_context = context;\n        CmsVaadinUtils.readAndLocalizeDesign(\n            this,\n            OpenCms.getWorkplaceManager().getMessages(A_CmsUI.get().getLocale()),\n            null);\n\n        boolean hasFolders = false;\n        for (CmsResource resource : context.getResources()) {\n            if (resource.isFolder()) {\n                hasFolders = true;\n                break;\n            }\n        }\n        m_modifySubresourcesField.setVisible(hasFolders);\n        m_cancelButton.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                m_context.finish(null);\n            }\n\n        });\n\n        m_okButton.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                try {\n                    undo();\n                    m_context.finish(null);\n                } catch (Exception e) {\n                    m_context.error(e);\n                }\n            }\n        });\n    }","id":23039,"modified_method":"/**\n     * Creates a new instance.<p>\n     *\n     * @param context the dialog context\n     */\n    public CmsUndoDialog(I_CmsDialogContext context) {\n        m_context = context;\n        CmsVaadinUtils.readAndLocalizeDesign(\n            this,\n            OpenCms.getWorkplaceManager().getMessages(A_CmsUI.get().getLocale()),\n            null);\n\n        boolean hasFolders = false;\n        for (CmsResource resource : context.getResources()) {\n            if (resource.isFolder()) {\n                hasFolders = true;\n                break;\n            }\n        }\n        m_modifySubresourcesField.setVisible(hasFolders);\n        m_cancelButton.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                m_context.finish(null);\n            }\n\n        });\n\n        m_okButton.addClickListener(new ClickListener() {\n\n            private static final long serialVersionUID = 1L;\n\n            public void buttonClick(ClickEvent event) {\n\n                try {\n                    undo();\n                    m_context.finish(null);\n                } catch (Exception e) {\n                    m_context.error(e);\n                }\n            }\n        });\n        displayResourceInfo(m_context.getResources());\n    }","commit_id":"3b1dbdd8757accb8c268488f0598c29eb6fbb438","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public void setResourceDao(ResourceDao resourceDao) {\n        this.m_resourceDao = resourceDao;\n    }","id":23040,"modified_method":"/**\n     * Method to set the resource dao.\n     *\n     * @param resourceDao the {@link org.opennms.netmgt.dao.api.ResourceDao} to be used\n     */\n    public void setResourceDao(ResourceDao resourceDao) {\n        this.m_resourceDao = resourceDao;\n    }","commit_id":"24f77cd42a284e9fd86e7f5aa65afef52a63de06","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setGraphDao(GraphDao graphDao) {\n        this.m_graphDao = graphDao;\n    }","id":23041,"modified_method":"/**\n     * Method to set the graph dao.\n     *\n     * @param graphDao the {@link org.opennms.netmgt.dao.api.GraphDao} to be used\n     */\n    public void setGraphDao(GraphDao graphDao) {\n        this.m_graphDao = graphDao;\n    }","commit_id":"24f77cd42a284e9fd86e7f5aa65afef52a63de06","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setNotificationDao(NotificationDao notificationDao) {\n        this.m_notificationDao = notificationDao;\n    }","id":23042,"modified_method":"/**\n     * Method to set the notification dao.\n     *\n     * @param notificationDao the {@link org.opennms.netmgt.dao.api.NotificationDao} to be used\n     */\n    public void setNotificationDao(NotificationDao notificationDao) {\n        this.m_notificationDao = notificationDao;\n    }","commit_id":"24f77cd42a284e9fd86e7f5aa65afef52a63de06","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setGroupDao(GroupDao groupDao) {\n        this.m_groupDao = groupDao;\n    }","id":23043,"modified_method":"/**\n     * Method to set the group dao.\n     *\n     * @param groupDao the {@link org.opennms.netmgt.config.GroupDao} to be used\n     */\n    public void setGroupDao(GroupDao groupDao) {\n        this.m_groupDao = groupDao;\n    }","commit_id":"24f77cd42a284e9fd86e7f5aa65afef52a63de06","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setCategoryDao(CategoryDao categoryDao) {\n        this.m_categoryDao = categoryDao;\n    }","id":23044,"modified_method":"/**\n     * Method to set the category dao.\n     *\n     * @param categoryDao the {@link org.opennms.netmgt.dao.api.CategoryDao} to be used\n     */\n    public void setCategoryDao(CategoryDao categoryDao) {\n        this.m_categoryDao = categoryDao;\n    }","commit_id":"24f77cd42a284e9fd86e7f5aa65afef52a63de06","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public List<OnmsCategory> getOnmsCategories() {\n        getRtcCategories();\n        return m_categoryDao.findAll();\n    }","id":23045,"modified_method":"/**\n     * Retrieves a list of OpenNMS categories from the DAO instance.\n     *\n     * @return the list of categories\n     */\n    @Override\n    public List<OnmsCategory> getOnmsCategories() {\n        return m_categoryDao.findAll();\n    }","commit_id":"24f77cd42a284e9fd86e7f5aa65afef52a63de06","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setAlarmDao(AlarmDao alarmDao) {\n        this.m_alarmDao = alarmDao;\n    }","id":23046,"modified_method":"/**\n     * Method to set the alarm dao.\n     *\n     * @param alarmDao the {@link org.opennms.netmgt.dao.api.AlarmDao} to be used\n     */\n    public void setAlarmDao(AlarmDao alarmDao) {\n        this.m_alarmDao = alarmDao;\n    }","commit_id":"24f77cd42a284e9fd86e7f5aa65afef52a63de06","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setSurveillanceViewConfigDao(SurveillanceViewConfigDao surveillanceViewConfigDao) {\n        this.m_surveillanceViewConfigDao = surveillanceViewConfigDao;\n    }","id":23047,"modified_method":"/**\n     * Method to set the surveillance view config  dao.\n     *\n     * @param surveillanceViewConfigDao the {@link org.opennms.netmgt.dao.api.SurveillanceViewConfigDao} to be used\n     */\n    public void setSurveillanceViewConfigDao(SurveillanceViewConfigDao surveillanceViewConfigDao) {\n        this.m_surveillanceViewConfigDao = surveillanceViewConfigDao;\n    }","commit_id":"24f77cd42a284e9fd86e7f5aa65afef52a63de06","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setOutageDao(OutageDao outageDao) {\n        this.m_outageDao = outageDao;\n    }","id":23048,"modified_method":"/**\n     * Method to set the outage dao.\n     *\n     * @param outageDao the {@link org.opennms.netmgt.dao.api.OutageDao} to be used\n     */\n    public void setOutageDao(OutageDao outageDao) {\n        this.m_outageDao = outageDao;\n    }","commit_id":"24f77cd42a284e9fd86e7f5aa65afef52a63de06","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setNodeDao(NodeDao nodeDao) {\n        this.m_nodeDao = nodeDao;\n    }","id":23049,"modified_method":"/**\n     * Method to set the node dao.\n     *\n     * @param nodeDao the {@link org.opennms.netmgt.dao.api.NodeDao} to be used\n     */\n    public void setNodeDao(NodeDao nodeDao) {\n        this.m_nodeDao = nodeDao;\n    }","commit_id":"24f77cd42a284e9fd86e7f5aa65afef52a63de06","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public List<String> getRtcCategories() {\n\n        CatFactory cFactory = null;\n\n        try {\n            CategoryFactory.init();\n            cFactory = CategoryFactory.getInstance();\n\n        } catch (IOException ex) {\n            LOG.error(\"Failed to load categories information\", ex);\n            throw new UndeclaredThrowableException(ex);\n        } catch (MarshalException ex) {\n            LOG.error(\"Failed to load categories information\", ex);\n            throw new UndeclaredThrowableException(ex);\n        } catch (ValidationException ex) {\n            LOG.error(\"Failed to load categories information\", ex);\n            throw new UndeclaredThrowableException(ex);\n        }\n\n        List<String> categories = new ArrayList<String>();\n\n        cFactory.getReadLock().lock();\n\n        try {\n            for (Categorygroup cg : cFactory.getConfig().getCategorygroupCollection()) {\n                for (final org.opennms.netmgt.config.categories.Category category : cg.getCategories().getCategoryCollection()) {\n                    categories.add(category.getLabel());\n                }\n            }\n        } finally {\n            cFactory.getReadLock().unlock();\n        }\n\n        return categories;\n    }","id":23050,"modified_method":"/**\n     * Returns a list of Rtc catgories.\n     *\n     * @return the list of Rtc categories.\n     */\n    public List<String> getRtcCategories() {\n\n        CatFactory cFactory = null;\n\n        try {\n            CategoryFactory.init();\n            cFactory = CategoryFactory.getInstance();\n\n        } catch (IOException ex) {\n            LOG.error(\"Failed to load categories information\", ex);\n            throw new UndeclaredThrowableException(ex);\n        } catch (MarshalException ex) {\n            LOG.error(\"Failed to load categories information\", ex);\n            throw new UndeclaredThrowableException(ex);\n        } catch (ValidationException ex) {\n            LOG.error(\"Failed to load categories information\", ex);\n            throw new UndeclaredThrowableException(ex);\n        }\n\n        List<String> categories = new ArrayList<String>();\n\n        cFactory.getReadLock().lock();\n\n        try {\n            for (Categorygroup cg : cFactory.getConfig().getCategorygroupCollection()) {\n                for (final org.opennms.netmgt.config.categories.Category category : cg.getCategories().getCategoryCollection()) {\n                    categories.add(category.getLabel());\n                }\n            }\n        } finally {\n            cFactory.getReadLock().unlock();\n        }\n\n        return categories;\n    }","commit_id":"24f77cd42a284e9fd86e7f5aa65afef52a63de06","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SurveillanceViewConfigurationCategoryWindow(final SurveillanceViewService surveillanceViewService, final Def def, final SaveActionListener saveActionListener) {\n        /**\n         * Setting the title\n         */\n        super(\"Window title\");\n        if (def instanceof RowDef) {\n            super.setCaption(\"Row definition\");\n        } else {\n            super.setCaption(\"Column definition\");\n        }\n\n        /**\n         * Setting the modal and size properties\n         */\n        setModal(true);\n        setClosable(false);\n        setResizable(false);\n        setWidth(30, Sizeable.Unit.PERCENTAGE);\n        setHeight(50, Sizeable.Unit.PERCENTAGE);\n\n        /**\n         * Title and refresh seconds\n         */\n        final TextField labelField = new TextField();\n        labelField.setValue(def.getLabel());\n        labelField.setImmediate(true);\n        labelField.setCaption(\"Label\");\n        labelField.setDescription(\"Label of this surveillance view\");\n        labelField.setWidth(100, Unit.PERCENTAGE);\n\n        labelField.addValidator(new AbstractStringValidator(\"Please use an unique name for the surveillance view\") {\n            @Override\n            protected boolean isValidValue(String s) {\n                return (!\"\".equals(s.trim()));\n            }\n        });\n\n        final NativeSelect nativeSelect = new NativeSelect();\n        nativeSelect.setImmediate(true);\n        nativeSelect.setCaption(\"Report category\");\n        nativeSelect.setDescription(\"Report category for this entry\");\n        nativeSelect.setWidth(100, Unit.PERCENTAGE);\n\n        for (String category : surveillanceViewService.getRtcCategories()) {\n            nativeSelect.addItem(category);\n        }\n\n        nativeSelect.select(def.getReportCategory());\n\n        /**\n         * Columns table\n         */\n        final Table categoriesTable = new Table();\n        categoriesTable.setCaption(\"Categories\");\n        categoriesTable.setSizeFull();\n        categoriesTable.setSortEnabled(true);\n        categoriesTable.addContainerProperty(\"name\", String.class, \"\");\n        categoriesTable.setColumnHeader(\"name\", \"Category\");\n        categoriesTable.setColumnExpandRatio(\"Category\", 1.0f);\n        categoriesTable.setSelectable(true);\n        categoriesTable.setMultiSelect(true);\n\n        List<OnmsCategory> categories = surveillanceViewService.getOnmsCategories();\n        final Map<Integer, OnmsCategory> categoriesMap = new HashMap<>();\n\n        for (OnmsCategory onmsCategory : categories) {\n            categoriesTable.addItem(new Object[]{onmsCategory.getName()}, onmsCategory.getId());\n            categoriesMap.put(onmsCategory.getId(), onmsCategory);\n            if (def.containsCategory(onmsCategory.getName())) {\n                categoriesTable.select(onmsCategory.getId());\n            }\n        }\n\n        /**\n         * Create form layouts...\n         */\n        FormLayout baseFormLayout = new FormLayout();\n        baseFormLayout.setSizeFull();\n        baseFormLayout.addComponent(labelField);\n        baseFormLayout.addComponent(nativeSelect);\n        baseFormLayout.addComponent(categoriesTable);\n\n        /**\n         * Adding the different {@link com.vaadin.ui.FormLayout} instances to a {@link com.vaadin.ui.GridLayout}\n         */\n        baseFormLayout.setMargin(true);\n        baseFormLayout.setSizeFull();\n\n        /**\n         * Creating the vertical layout...\n         */\n        VerticalLayout verticalLayout = new VerticalLayout();\n        verticalLayout.setSizeFull();\n        verticalLayout.addComponent(baseFormLayout);\n        verticalLayout.setExpandRatio(baseFormLayout, 1.0f);\n\n        /**\n         * Using an additional {@link com.vaadin.ui.HorizontalLayout} for layouting the buttons\n         */\n        HorizontalLayout horizontalLayout = new HorizontalLayout();\n\n        horizontalLayout.setMargin(true);\n        horizontalLayout.setSpacing(true);\n        horizontalLayout.setWidth(100, Unit.PERCENTAGE);\n\n        /**\n         * Adding the cancel button...\n         */\n        Button cancel = new Button(\"Cancel\");\n        cancel.setDescription(\"Cancel editing properties\");\n        cancel.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent event) {\n                close();\n            }\n        });\n\n        cancel.setClickShortcut(ShortcutAction.KeyCode.ESCAPE, null);\n        horizontalLayout.addComponent(cancel);\n        horizontalLayout.setExpandRatio(cancel, 1);\n        horizontalLayout.setComponentAlignment(cancel, Alignment.TOP_RIGHT);\n\n        /**\n         * ...and the OK button\n         */\n        Button ok = new Button(\"Save\");\n        ok.setDescription(\"Save properties and close\");\n\n        ok.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent event) {\n                Def finalDef = null;\n\n                if (def instanceof RowDef) {\n                    finalDef = new RowDef();\n                }\n                if (def instanceof ColumnDef) {\n                    finalDef = new ColumnDef();\n                }\n\n                Set<Object> categories = (Set<Object>) categoriesTable.getValue();\n\n                for (Object object : categories) {\n\n                    Category category = new Category();\n                    category.setName(categoriesMap.get((Integer) object).getName());\n                    finalDef.getCategories().add(category);\n                }\n\n                finalDef.setLabel(labelField.getValue());\n                finalDef.setReportCategory((String) nativeSelect.getValue());\n\n                saveActionListener.save(finalDef);\n\n                close();\n            }\n        });\n\n        ok.setClickShortcut(ShortcutAction.KeyCode.ENTER, null);\n        horizontalLayout.addComponent(ok);\n\n        verticalLayout.addComponent(horizontalLayout);\n\n        setContent(verticalLayout);\n    }","id":23051,"modified_method":"public SurveillanceViewConfigurationCategoryWindow(final SurveillanceViewService surveillanceViewService, final Def def, final SaveActionListener saveActionListener) {\n        /**\n         * Setting the title\n         */\n        super(\"Window title\");\n\n        /**\n         * Check whether this dialog is for a column or row and alter the window title\n         */\n        if (def instanceof RowDef) {\n            super.setCaption(\"Row definition\");\n        } else {\n            super.setCaption(\"Column definition\");\n        }\n\n        /**\n         * Setting the modal and size properties\n         */\n        setModal(true);\n        setClosable(false);\n        setResizable(false);\n        setWidth(30, Sizeable.Unit.PERCENTAGE);\n        setHeight(50, Sizeable.Unit.PERCENTAGE);\n\n        /**\n         * Title and refresh seconds\n         */\n        final TextField labelField = new TextField();\n        labelField.setValue(def.getLabel());\n        labelField.setImmediate(true);\n        labelField.setCaption(\"Label\");\n        labelField.setDescription(\"Label of this surveillance view\");\n        labelField.setWidth(100, Unit.PERCENTAGE);\n\n        /**\n         * Creating a simple validator for the title field\n         */\n        labelField.addValidator(new AbstractStringValidator(\"Please use an unique name for the surveillance view\") {\n            @Override\n            protected boolean isValidValue(String s) {\n                return (!\"\".equals(s.trim()));\n            }\n        });\n\n        /**\n         * Create selection box for the report category\n         */\n        final NativeSelect reportCategorySelect = new NativeSelect();\n        reportCategorySelect.setImmediate(true);\n        reportCategorySelect.setCaption(\"Report category\");\n        reportCategorySelect.setDescription(\"Report category for this entry\");\n        reportCategorySelect.setWidth(100, Unit.PERCENTAGE);\n\n        /**\n         * Add data to the selection box\n         */\n        for (String category : surveillanceViewService.getRtcCategories()) {\n            reportCategorySelect.addItem(category);\n        }\n\n        /**\n         * Preselect the right value\n         */\n        reportCategorySelect.select(def.getReportCategory());\n\n        /**\n         * Categories table\n         */\n        final Table categoriesTable = new Table();\n        categoriesTable.setCaption(\"Categories\");\n        categoriesTable.setSizeFull();\n        categoriesTable.setSortEnabled(true);\n        categoriesTable.addContainerProperty(\"name\", String.class, \"\");\n        categoriesTable.setColumnHeader(\"name\", \"Category\");\n        categoriesTable.setColumnExpandRatio(\"Category\", 1.0f);\n        categoriesTable.setSelectable(true);\n        categoriesTable.setMultiSelect(true);\n\n        List<OnmsCategory> categories = surveillanceViewService.getOnmsCategories();\n        final Map<Integer, OnmsCategory> categoriesMap = new HashMap<>();\n\n        for (OnmsCategory onmsCategory : categories) {\n            categoriesTable.addItem(new Object[]{onmsCategory.getName()}, onmsCategory.getId());\n            categoriesMap.put(onmsCategory.getId(), onmsCategory);\n            if (def.containsCategory(onmsCategory.getName())) {\n                categoriesTable.select(onmsCategory.getId());\n            }\n        }\n\n        /**\n         * Create form layouts...\n         */\n        FormLayout baseFormLayout = new FormLayout();\n        baseFormLayout.setSizeFull();\n        baseFormLayout.setMargin(true);\n        baseFormLayout.addComponent(labelField);\n        baseFormLayout.addComponent(reportCategorySelect);\n        baseFormLayout.addComponent(categoriesTable);\n\n        /**\n         * Creating the vertical layout...\n         */\n        VerticalLayout verticalLayout = new VerticalLayout();\n        verticalLayout.setSizeFull();\n        verticalLayout.addComponent(baseFormLayout);\n        verticalLayout.setExpandRatio(baseFormLayout, 1.0f);\n\n        /**\n         * Using an additional {@link com.vaadin.ui.HorizontalLayout} for layouting the buttons\n         */\n        HorizontalLayout horizontalLayout = new HorizontalLayout();\n\n        horizontalLayout.setMargin(true);\n        horizontalLayout.setSpacing(true);\n        horizontalLayout.setWidth(100, Unit.PERCENTAGE);\n\n        /**\n         * Adding the cancel button...\n         */\n        Button cancel = new Button(\"Cancel\");\n        cancel.setDescription(\"Cancel editing properties\");\n        cancel.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent event) {\n                close();\n            }\n        });\n\n        cancel.setClickShortcut(ShortcutAction.KeyCode.ESCAPE, null);\n        horizontalLayout.addComponent(cancel);\n        horizontalLayout.setExpandRatio(cancel, 1);\n        horizontalLayout.setComponentAlignment(cancel, Alignment.TOP_RIGHT);\n\n        /**\n         * ...and the OK button\n         */\n        Button ok = new Button(\"Save\");\n        ok.setDescription(\"Save properties and close\");\n\n        ok.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent event) {\n                Def finalDef = null;\n\n                if (def instanceof RowDef) {\n                    finalDef = new RowDef();\n                }\n                if (def instanceof ColumnDef) {\n                    finalDef = new ColumnDef();\n                }\n\n                Set<Object> categories = (Set<Object>) categoriesTable.getValue();\n\n                for (Object object : categories) {\n\n                    Category category = new Category();\n                    category.setName(categoriesMap.get((Integer) object).getName());\n                    finalDef.getCategories().add(category);\n                }\n\n                finalDef.setLabel(labelField.getValue());\n                finalDef.setReportCategory((String) reportCategorySelect.getValue());\n\n                saveActionListener.save(finalDef);\n\n                close();\n            }\n        });\n\n        ok.setClickShortcut(ShortcutAction.KeyCode.ENTER, null);\n        horizontalLayout.addComponent(ok);\n\n        verticalLayout.addComponent(horizontalLayout);\n\n        setContent(verticalLayout);\n    }","commit_id":"24f77cd42a284e9fd86e7f5aa65afef52a63de06","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SurveillanceViewConfigurationWindow(final SurveillanceViewService surveillanceViewService, final View view, final SaveActionListener saveActionListener) {\n        /**\n         * Setting the title\n         */\n        super(\"Surveillance view configuration\");\n\n        /**\n         * Setting the modal and size properties\n         */\n        setModal(true);\n        setClosable(false);\n        setResizable(false);\n        setWidth(70, Sizeable.Unit.PERCENTAGE);\n        setHeight(66, Sizeable.Unit.PERCENTAGE);\n\n        /**\n         * Title and refresh seconds\n         */\n        final TextField titleField = new TextField();\n        titleField.setValue(view.getName());\n        titleField.setImmediate(true);\n        titleField.setCaption(\"Title\");\n        titleField.setDescription(\"Title of this surveillance view\");\n        titleField.setWidth(25, Unit.PERCENTAGE);\n\n        titleField.addValidator(new AbstractStringValidator(\"Please use an unique name for the surveillance view\") {\n            @Override\n            protected boolean isValidValue(String s) {\n                return (!SurveillanceViewProvider.getInstance().containsView(s) || view.getName().equals(s));\n            }\n        });\n\n        /**\n         * Duration field setup, layout and adding listener and validator\n         */\n        final TextField refreshSecondsField = new TextField();\n        refreshSecondsField.setValue(String.valueOf(view.getRefreshSeconds()));\n        refreshSecondsField.setImmediate(true);\n        refreshSecondsField.setCaption(\"Refresh seconds\");\n        refreshSecondsField.setDescription(\"Refresh duration in seconds\");\n\n        refreshSecondsField.addValidator(new AbstractStringValidator(\"Only numbers allowed here\") {\n            @Override\n            protected boolean isValidValue(String s) {\n                try {\n                    Integer.parseInt(s);\n                } catch (NumberFormatException numberFormatException) {\n                    return false;\n                }\n                return true;\n            }\n        });\n\n        /**\n         * Columns table\n         */\n        final Table columnsTable = new Table();\n\n        columnsTable.setSortEnabled(false);\n        columnsTable.setWidth(25, Unit.PERCENTAGE);\n\n        final BeanItemContainer<ColumnDef> columns = new BeanItemContainer<ColumnDef>(ColumnDef.class, view.getColumns());\n\n        final Map<ColumnDef, Integer> columnOrder = new HashMap<>();\n\n        int c = 0;\n        for (ColumnDef columnDef : view.getColumns()) {\n            columnOrder.put(columnDef, c++);\n        }\n\n        columnsTable.setContainerDataSource(columns);\n\n        columnsTable.setVisibleColumns(\"label\");\n        columnsTable.setColumnHeader(\"label\", \"Columns\");\n        columnsTable.setColumnExpandRatio(\"label\", 1.0f);\n        columnsTable.setSelectable(true);\n        columnsTable.setMultiSelect(false);\n\n        columns.setItemSorter(new DefaultItemSorter() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                if (o1 == null) {\n                    if (o2 == null) {\n                        return 0;\n                    } else {\n                        return -1;\n                    }\n                }\n                if (o2 == null) {\n                    return 1;\n                }\n\n                if (columnOrder.get(o1).intValue() == columnOrder.get(o2).intValue()) {\n                    return 0;\n                } else {\n                    if (columnOrder.get(o1).intValue() > columnOrder.get(o2).intValue()) {\n                        return 1;\n                    } else {\n                        return -1;\n                    }\n                }\n            }\n        });\n\n        /**\n         * Adding the buttons...\n         */\n        final Button columnsAddButton = new Button(\"Add\");\n        columnsAddButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                getUI().addWindow(new SurveillanceViewConfigurationCategoryWindow(surveillanceViewService, new ColumnDef(), new SurveillanceViewConfigurationCategoryWindow.SaveActionListener() {\n                    @Override\n                    public void save(Def def) {\n                        columns.addItem((ColumnDef) def);\n                        columnOrder.put((ColumnDef) def, columnOrder.size());\n\n                        columns.sort(new Object[]{\"label\"}, new boolean[]{true});\n                        columnsTable.refreshRowCache();\n                    }\n                }));\n            }\n        });\n\n        columnsAddButton.setEnabled(true);\n        columnsAddButton.setStyleName(\"small\");\n        columnsAddButton.setDescription(\"Add column\");\n        columnsAddButton.setEnabled(true);\n\n        final Button columnsEditButton = new Button(\"Edit\");\n        columnsEditButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                getUI().addWindow(new SurveillanceViewConfigurationCategoryWindow(surveillanceViewService, (ColumnDef) columnsTable.getValue(), new SurveillanceViewConfigurationCategoryWindow.SaveActionListener() {\n                    @Override\n                    public void save(Def def) {\n                        ColumnDef columnToBeReplaced = (ColumnDef) columnsTable.getValue();\n                        int index = columnOrder.get(columnToBeReplaced);\n\n                        columns.removeItem(columnToBeReplaced);\n                        columnOrder.remove(columnToBeReplaced);\n\n                        columns.addItem((ColumnDef) def);\n                        columnOrder.put((ColumnDef) def, index);\n\n                        columns.sort(new Object[]{\"label\"}, new boolean[]{true});\n                        columnsTable.refreshRowCache();\n                    }\n                }));\n            }\n        });\n\n        columnsEditButton.setEnabled(true);\n        columnsEditButton.setStyleName(\"small\");\n        columnsEditButton.setDescription(\"Edit column\");\n        columnsEditButton.setEnabled(false);\n\n        final Button columnsRemoveButton = new Button(\"Remove\");\n        columnsRemoveButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                ColumnDef columnDef = (ColumnDef) columnsTable.getValue();\n                if (columnDef != null) {\n                    columnsTable.unselect(columnDef);\n                    columns.removeItem(columnDef);\n                }\n\n                columnsTable.refreshRowCache();\n            }\n        });\n\n        columnsRemoveButton.setEnabled(true);\n        columnsRemoveButton.setStyleName(\"small\");\n        columnsRemoveButton.setDescription(\"Remove column\");\n        columnsRemoveButton.setEnabled(false);\n\n        final Button columnUpButton = new Button();\n        columnUpButton.setStyleName(\"small\");\n        columnUpButton.setIcon(new ThemeResource(\"../runo/icons/16/arrow-up.png\"));\n        columnUpButton.setDescription(\"Move this a column entry one position up\");\n        columnUpButton.setEnabled(false);\n        columnUpButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                ColumnDef columnDef = (ColumnDef) columnsTable.getValue();\n                if (columnDef != null) {\n                    int columnDefIndex = columnOrder.get(columnDef);\n\n                    ColumnDef columnDefToSwap = null;\n\n                    for (Map.Entry<ColumnDef, Integer> entry : columnOrder.entrySet()) {\n                        if (entry.getValue().intValue() == columnDefIndex - 1) {\n                            columnDefToSwap = entry.getKey();\n                            break;\n                        }\n                    }\n\n                    if (columnDefToSwap != null) {\n                        columnsTable.unselect(columnDef);\n                        columnOrder.remove(columnDef);\n                        columnOrder.remove(columnDefToSwap);\n                        columnOrder.put(columnDef, columnDefIndex - 1);\n                        columnOrder.put(columnDefToSwap, columnDefIndex);\n\n                        columns.sort(new Object[]{\"label\"}, new boolean[]{true});\n                        columnsTable.refreshRowCache();\n                        columnsTable.select(columnDef);\n                    }\n\n                }\n            }\n        });\n\n        final Button columnDownButton = new Button();\n        columnDownButton.setStyleName(\"small\");\n        columnDownButton.setIcon(new ThemeResource(\"../runo/icons/16/arrow-down.png\"));\n        columnDownButton.setDescription(\"Move this a column entry one position down\");\n        columnDownButton.setEnabled(false);\n        columnDownButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                ColumnDef columnDef = (ColumnDef) columnsTable.getValue();\n                if (columnDef != null) {\n                    int columnDefIndex = columnOrder.get(columnDef);\n\n                    ColumnDef columnDefToSwap = null;\n\n                    for (Map.Entry<ColumnDef, Integer> entry : columnOrder.entrySet()) {\n                        if (entry.getValue().intValue() == columnDefIndex + 1) {\n                            columnDefToSwap = entry.getKey();\n                            break;\n                        }\n                    }\n\n                    if (columnDefToSwap != null) {\n                        columnsTable.unselect(columnDef);\n                        columnOrder.remove(columnDef);\n                        columnOrder.remove(columnDefToSwap);\n                        columnOrder.put(columnDef, columnDefIndex + 1);\n                        columnOrder.put(columnDefToSwap, columnDefIndex);\n\n                        columns.sort(new Object[]{\"label\"}, new boolean[]{true});\n                        columnsTable.refreshRowCache();\n                        columnsTable.select(columnDef);\n                    }\n                }\n            }\n        });\n\n        columnUpButton.setSizeFull();\n        columnDownButton.setSizeFull();\n        columnsAddButton.setSizeFull();\n        columnsEditButton.setSizeFull();\n        columnsRemoveButton.setSizeFull();\n\n        columnsTable.setImmediate(true);\n        columnsTable.addValueChangeListener(new Property.ValueChangeListener() {\n            @Override\n            public void valueChange(Property.ValueChangeEvent valueChangeEvent) {\n                boolean somethingSelected = (columnsTable.getValue() != null);\n                columnsRemoveButton.setEnabled(somethingSelected);\n                columnsEditButton.setEnabled(somethingSelected);\n                columnsAddButton.setEnabled(true);\n                columnUpButton.setEnabled(somethingSelected && columnOrder.get(columnsTable.getValue()).intValue() > 0);\n                columnDownButton.setEnabled(somethingSelected && columnOrder.get(columnsTable.getValue()).intValue() < columnOrder.size() - 1);\n            }\n        });\n\n        /**\n         * Rows table\n         */\n\n        final Table rowsTable = new Table();\n\n        rowsTable.setSortEnabled(false);\n        rowsTable.setWidth(25, Unit.PERCENTAGE);\n\n        final BeanItemContainer<RowDef> rows = new BeanItemContainer<RowDef>(RowDef.class, view.getRows());\n\n        final Map<RowDef, Integer> rowOrder = new HashMap<>();\n\n        int r = 0;\n        for (RowDef rowDef : view.getRows()) {\n            rowOrder.put(rowDef, r++);\n        }\n\n        rowsTable.setContainerDataSource(rows);\n\n        rowsTable.setVisibleColumns(\"label\");\n        rowsTable.setColumnHeader(\"label\", \"Rows\");\n        rowsTable.setColumnExpandRatio(\"label\", 1.0f);\n        rowsTable.setSelectable(true);\n        rowsTable.setMultiSelect(false);\n\n        rows.setItemSorter(new DefaultItemSorter() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                if (o1 == null) {\n                    if (o2 == null) {\n                        return 0;\n                    } else {\n                        return -1;\n                    }\n                }\n                if (o2 == null) {\n                    return 1;\n                }\n\n                if (rowOrder.get(o1).intValue() == rowOrder.get(o2).intValue()) {\n                    return 0;\n                } else {\n                    if (rowOrder.get(o1).intValue() > rowOrder.get(o2).intValue()) {\n                        return 1;\n                    } else {\n                        return -1;\n                    }\n                }\n            }\n        });\n\n        /**\n         * Adding the buttons...\n         */\n\n        final Button rowsAddButton = new Button(\"Add\");\n        rowsAddButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                getUI().addWindow(new SurveillanceViewConfigurationCategoryWindow(surveillanceViewService, new RowDef(), new SurveillanceViewConfigurationCategoryWindow.SaveActionListener() {\n                    @Override\n                    public void save(Def def) {\n                        rows.addItem((RowDef) def);\n                        rowOrder.put((RowDef) def, rowOrder.size());\n\n                        rows.sort(new Object[]{\"label\"}, new boolean[]{true});\n                        rowsTable.refreshRowCache();\n                    }\n                }));\n            }\n        });\n\n        rowsAddButton.setEnabled(true);\n        rowsAddButton.setStyleName(\"small\");\n        rowsAddButton.setDescription(\"Add row\");\n        rowsAddButton.setEnabled(true);\n\n        final Button rowsEditButton = new Button(\"Edit\");\n        rowsEditButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                getUI().addWindow(new SurveillanceViewConfigurationCategoryWindow(surveillanceViewService, (RowDef) rowsTable.getValue(), new SurveillanceViewConfigurationCategoryWindow.SaveActionListener() {\n                    @Override\n                    public void save(Def def) {\n                        RowDef rowToBeReplaced = (RowDef) rowsTable.getValue();\n                        int index = rowOrder.get(rowToBeReplaced);\n\n                        rows.removeItem(rowToBeReplaced);\n                        rowOrder.remove(rowToBeReplaced);\n\n                        rows.addItem((RowDef) def);\n                        rowOrder.put((RowDef) def, index);\n\n                        rows.sort(new Object[]{\"label\"}, new boolean[]{true});\n                        rowsTable.refreshRowCache();\n                    }\n                }));\n            }\n        });\n\n        rowsEditButton.setEnabled(true);\n        rowsEditButton.setStyleName(\"small\");\n        rowsEditButton.setDescription(\"Edit row\");\n        rowsEditButton.setEnabled(false);\n\n        final Button rowsRemoveButton = new Button(\"Remove\");\n        rowsRemoveButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                RowDef rowDef = (RowDef) rowsTable.getValue();\n                if (rowDef != null) {\n                    rowsTable.unselect(rowDef);\n                    rows.removeItem(rowDef);\n                }\n\n                rowsTable.refreshRowCache();\n            }\n        });\n\n        final Button rowUpButton = new Button();\n        rowUpButton.setStyleName(\"small\");\n        rowUpButton.setIcon(new ThemeResource(\"../runo/icons/16/arrow-up.png\"));\n        rowUpButton.setDescription(\"Move this a row entry one position up\");\n        rowUpButton.setEnabled(false);\n        rowUpButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                RowDef rowDef = (RowDef) rowsTable.getValue();\n                if (rowDef != null) {\n                    int rowDefIndex = rowOrder.get(rowDef);\n\n                    RowDef rowDefToSwap = null;\n\n                    for (Map.Entry<RowDef, Integer> entry : rowOrder.entrySet()) {\n                        if (entry.getValue().intValue() == rowDefIndex - 1) {\n                            rowDefToSwap = entry.getKey();\n                            break;\n                        }\n                    }\n\n                    if (rowDefToSwap != null) {\n                        rowsTable.unselect(rowDef);\n                        rowOrder.remove(rowDef);\n                        rowOrder.remove(rowDefToSwap);\n                        rowOrder.put(rowDef, rowDefIndex - 1);\n                        rowOrder.put(rowDefToSwap, rowDefIndex);\n\n                        rows.sort(new Object[]{\"label\"}, new boolean[]{true});\n                        rowsTable.refreshRowCache();\n                        rowsTable.select(rowDef);\n                    }\n                }\n            }\n        });\n\n        final Button rowDownButton = new Button();\n        rowDownButton.setStyleName(\"small\");\n        rowDownButton.setIcon(new ThemeResource(\"../runo/icons/16/arrow-down.png\"));\n        rowDownButton.setDescription(\"Move this a row entry one position down\");\n        rowDownButton.setEnabled(false);\n        rowDownButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                RowDef rowDef = (RowDef) rowsTable.getValue();\n                if (rowDef != null) {\n                    int rowDefIndex = rowOrder.get(rowDef);\n\n                    RowDef rowDefToSwap = null;\n\n                    for (Map.Entry<RowDef, Integer> entry : rowOrder.entrySet()) {\n                        if (entry.getValue().intValue() == rowDefIndex + 1) {\n                            rowDefToSwap = entry.getKey();\n                            break;\n                        }\n                    }\n\n                    if (rowDefToSwap != null) {\n                        rowsTable.unselect(rowDef);\n                        rowOrder.remove(rowDef);\n                        rowOrder.remove(rowDefToSwap);\n                        rowOrder.put(rowDef, rowDefIndex + 1);\n                        rowOrder.put(rowDefToSwap, rowDefIndex);\n\n                        rows.sort(new Object[]{\"label\"}, new boolean[]{true});\n                        rowsTable.refreshRowCache();\n                        rowsTable.select(rowDef);\n                    }\n                }\n            }\n        });\n\n        rowsTable.setSizeFull();\n        columnsTable.setSizeFull();\n\n        rowsRemoveButton.setEnabled(true);\n        rowsRemoveButton.setStyleName(\"small\");\n        rowsRemoveButton.setDescription(\"Remove row\");\n        rowsRemoveButton.setEnabled(false);\n\n        rowUpButton.setSizeFull();\n        rowDownButton.setSizeFull();\n        rowsAddButton.setSizeFull();\n        rowsEditButton.setSizeFull();\n        rowsRemoveButton.setSizeFull();\n\n        rowsTable.setImmediate(true);\n        rowsTable.addValueChangeListener(new Property.ValueChangeListener() {\n            @Override\n            public void valueChange(Property.ValueChangeEvent valueChangeEvent) {\n                boolean somethingSelected = (rowsTable.getValue() != null);\n                rowsRemoveButton.setEnabled(somethingSelected);\n                rowsEditButton.setEnabled(somethingSelected);\n                rowsAddButton.setEnabled(true);\n                rowUpButton.setEnabled(somethingSelected && rowOrder.get(rowsTable.getValue()).intValue() > 0);\n                rowDownButton.setEnabled(somethingSelected && rowOrder.get(rowsTable.getValue()).intValue() < rowOrder.size() - 1);\n            }\n        });\n\n        /**\n         * Create form layouts...\n         */\n        FormLayout baseFormLayout = new FormLayout();\n        baseFormLayout.addComponent(titleField);\n        baseFormLayout.addComponent(refreshSecondsField);\n\n        FormLayout columnTableFormLayout = new FormLayout();\n        columnTableFormLayout.addComponent(columnsAddButton);\n        columnTableFormLayout.addComponent(columnsEditButton);\n        columnTableFormLayout.addComponent(columnsRemoveButton);\n        columnTableFormLayout.addComponent(columnUpButton);\n        columnTableFormLayout.addComponent(columnDownButton);\n\n        FormLayout rowTableFormLayout = new FormLayout();\n        rowTableFormLayout.addComponent(rowsAddButton);\n        rowTableFormLayout.addComponent(rowsEditButton);\n        rowTableFormLayout.addComponent(rowsRemoveButton);\n        rowTableFormLayout.addComponent(rowUpButton);\n        rowTableFormLayout.addComponent(rowDownButton);\n\n        /**\n         * Adding the different {@link com.vaadin.ui.FormLayout} instances to a {@link com.vaadin.ui.GridLayout}\n         */\n        baseFormLayout.setMargin(true);\n        columnTableFormLayout.setMargin(true);\n        rowTableFormLayout.setMargin(true);\n\n        GridLayout gridLayout = new GridLayout();\n        gridLayout.setSizeFull();\n        gridLayout.setColumns(4);\n        gridLayout.setRows(1);\n        gridLayout.setMargin(true);\n\n        gridLayout.addComponent(rowsTable);\n        gridLayout.addComponent(rowTableFormLayout);\n        gridLayout.addComponent(columnsTable);\n        gridLayout.addComponent(columnTableFormLayout);\n\n        gridLayout.setColumnExpandRatio(1, 0.3f);\n        gridLayout.setColumnExpandRatio(2, 1.0f);\n        gridLayout.setColumnExpandRatio(3, 0.3f);\n        gridLayout.setColumnExpandRatio(4, 1.0f);\n\n        /**\n         * Creating the vertical layout...\n         */\n        VerticalLayout verticalLayout = new VerticalLayout();\n\n        verticalLayout.addComponent(baseFormLayout);\n        verticalLayout.addComponent(gridLayout);\n\n        /**\n         * Using an additional {@link com.vaadin.ui.HorizontalLayout} for layouting the buttons\n         */\n        HorizontalLayout horizontalLayout = new HorizontalLayout();\n\n        horizontalLayout.setMargin(true);\n        horizontalLayout.setSpacing(true);\n        horizontalLayout.setWidth(100, Unit.PERCENTAGE);\n\n        /**\n         * Adding the cancel button...\n         */\n        Button cancel = new Button(\"Cancel\");\n        cancel.setDescription(\"Cancel editing properties\");\n        cancel.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent event) {\n                close();\n            }\n        });\n\n        cancel.setClickShortcut(ShortcutAction.KeyCode.ESCAPE, null);\n        horizontalLayout.addComponent(cancel);\n        horizontalLayout.setExpandRatio(cancel, 1);\n        horizontalLayout.setComponentAlignment(cancel, Alignment.TOP_RIGHT);\n\n        /**\n         * ...and the OK button\n         */\n        Button ok = new Button(\"Save\");\n        ok.setDescription(\"Save properties and close\");\n\n        ok.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent event) {\n                if (titleField.isValid() && refreshSecondsField.isValid()) {\n                    View finalView = new View();\n\n                    for (ColumnDef columnDef : columns.getItemIds()) {\n                        finalView.getColumns().add(columnDef);\n                    }\n\n                    for (RowDef rowDef : rows.getItemIds()) {\n                        finalView.getRows().add(rowDef);\n                    }\n                    finalView.setName(titleField.getValue());\n                    finalView.setRefreshSeconds(Integer.parseInt(refreshSecondsField.getValue()));\n\n                    saveActionListener.save(finalView);\n                }\n\n                close();\n            }\n        });\n\n        ok.setClickShortcut(ShortcutAction.KeyCode.ENTER, null);\n        horizontalLayout.addComponent(ok);\n\n        verticalLayout.addComponent(horizontalLayout);\n\n        setContent(verticalLayout);\n    }","id":23052,"modified_method":"public SurveillanceViewConfigurationWindow(final SurveillanceViewService surveillanceViewService, final View view, final SaveActionListener saveActionListener) {\n        /**\n         * Setting the title\n         */\n        super(\"Surveillance view configuration\");\n\n        /**\n         * Setting the modal and size properties\n         */\n        setModal(true);\n        setClosable(false);\n        setResizable(false);\n        setWidth(70, Sizeable.Unit.PERCENTAGE);\n        setHeight(66, Sizeable.Unit.PERCENTAGE);\n\n        /**\n         * Title field\n         */\n        final TextField titleField = new TextField();\n        titleField.setValue(view.getName());\n        titleField.setImmediate(true);\n        titleField.setCaption(\"Title\");\n        titleField.setDescription(\"Title of this surveillance view\");\n        titleField.setWidth(25, Unit.PERCENTAGE);\n\n        /**\n         * Adding simple validator\n         */\n        titleField.addValidator(new AbstractStringValidator(\"Please use an unique name for the surveillance view\") {\n            @Override\n            protected boolean isValidValue(String s) {\n                return (!SurveillanceViewProvider.getInstance().containsView(s) || view.getName().equals(s));\n            }\n        });\n\n        /**\n         * Refresh seconds field setup and validator\n         */\n        final TextField refreshSecondsField = new TextField();\n        refreshSecondsField.setValue(String.valueOf(view.getRefreshSeconds()));\n        refreshSecondsField.setImmediate(true);\n        refreshSecondsField.setCaption(\"Refresh seconds\");\n        refreshSecondsField.setDescription(\"Refresh duration in seconds\");\n\n        refreshSecondsField.addValidator(new AbstractStringValidator(\"Only numbers allowed here\") {\n            @Override\n            protected boolean isValidValue(String s) {\n                try {\n                    Integer.parseInt(s);\n                } catch (NumberFormatException numberFormatException) {\n                    return false;\n                }\n                return true;\n            }\n        });\n\n        /**\n         * Columns table\n         */\n        final Table columnsTable = new Table();\n\n        columnsTable.setSortEnabled(false);\n        columnsTable.setWidth(25, Unit.PERCENTAGE);\n\n        final BeanItemContainer<ColumnDef> columns = new BeanItemContainer<ColumnDef>(ColumnDef.class, view.getColumns());\n\n        final Map<ColumnDef, Integer> columnOrder = new HashMap<>();\n\n        int c = 0;\n        for (ColumnDef columnDef : view.getColumns()) {\n            columnOrder.put(columnDef, c++);\n        }\n\n        columnsTable.setContainerDataSource(columns);\n\n        columnsTable.setVisibleColumns(\"label\");\n        columnsTable.setColumnHeader(\"label\", \"Columns\");\n        columnsTable.setColumnExpandRatio(\"label\", 1.0f);\n        columnsTable.setSelectable(true);\n        columnsTable.setMultiSelect(false);\n\n        /**\n         * Create custom sorter\n         */\n        columns.setItemSorter(new DefaultItemSorter() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                if (o1 == null) {\n                    if (o2 == null) {\n                        return 0;\n                    } else {\n                        return -1;\n                    }\n                }\n                if (o2 == null) {\n                    return 1;\n                }\n\n                if (columnOrder.get(o1).intValue() == columnOrder.get(o2).intValue()) {\n                    return 0;\n                } else {\n                    if (columnOrder.get(o1).intValue() > columnOrder.get(o2).intValue()) {\n                        return 1;\n                    } else {\n                        return -1;\n                    }\n                }\n            }\n        });\n\n        /**\n         * Adding the buttons...\n         */\n        final Button columnsAddButton = new Button(\"Add\");\n        columnsAddButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                getUI().addWindow(new SurveillanceViewConfigurationCategoryWindow(surveillanceViewService, new ColumnDef(), new SurveillanceViewConfigurationCategoryWindow.SaveActionListener() {\n                    @Override\n                    public void save(Def def) {\n                        columns.addItem((ColumnDef) def);\n                        columnOrder.put((ColumnDef) def, columnOrder.size());\n\n                        columns.sort(new Object[]{\"label\"}, new boolean[]{true});\n                        columnsTable.refreshRowCache();\n                    }\n                }));\n            }\n        });\n\n        columnsAddButton.setEnabled(true);\n        columnsAddButton.setStyleName(\"small\");\n        columnsAddButton.setDescription(\"Add column\");\n        columnsAddButton.setEnabled(true);\n\n        final Button columnsEditButton = new Button(\"Edit\");\n        columnsEditButton.setEnabled(true);\n        columnsEditButton.setStyleName(\"small\");\n        columnsEditButton.setDescription(\"Edit column\");\n        columnsEditButton.setEnabled(false);\n\n        columnsEditButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                getUI().addWindow(new SurveillanceViewConfigurationCategoryWindow(surveillanceViewService, (ColumnDef) columnsTable.getValue(), new SurveillanceViewConfigurationCategoryWindow.SaveActionListener() {\n                    @Override\n                    public void save(Def def) {\n                        ColumnDef columnToBeReplaced = (ColumnDef) columnsTable.getValue();\n                        int index = columnOrder.get(columnToBeReplaced);\n\n                        columns.removeItem(columnToBeReplaced);\n                        columnOrder.remove(columnToBeReplaced);\n\n                        columns.addItem((ColumnDef) def);\n                        columnOrder.put((ColumnDef) def, index);\n\n                        columns.sort(new Object[]{\"label\"}, new boolean[]{true});\n                        columnsTable.refreshRowCache();\n                    }\n                }));\n            }\n        });\n\n\n        final Button columnsRemoveButton = new Button(\"Remove\");\n        columnsRemoveButton.setEnabled(true);\n        columnsRemoveButton.setStyleName(\"small\");\n        columnsRemoveButton.setDescription(\"Remove column\");\n        columnsRemoveButton.setEnabled(false);\n\n        columnsRemoveButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                ColumnDef columnDef = (ColumnDef) columnsTable.getValue();\n                if (columnDef != null) {\n                    columnsTable.unselect(columnDef);\n                    columns.removeItem(columnDef);\n                }\n\n                columnsTable.refreshRowCache();\n            }\n        });\n\n\n        final Button columnUpButton = new Button();\n        columnUpButton.setStyleName(\"small\");\n        columnUpButton.setIcon(new ThemeResource(\"../runo/icons/16/arrow-up.png\"));\n        columnUpButton.setDescription(\"Move this a column entry one position up\");\n        columnUpButton.setEnabled(false);\n\n        columnUpButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                ColumnDef columnDef = (ColumnDef) columnsTable.getValue();\n                if (columnDef != null) {\n                    int columnDefIndex = columnOrder.get(columnDef);\n\n                    ColumnDef columnDefToSwap = null;\n\n                    for (Map.Entry<ColumnDef, Integer> entry : columnOrder.entrySet()) {\n                        if (entry.getValue().intValue() == columnDefIndex - 1) {\n                            columnDefToSwap = entry.getKey();\n                            break;\n                        }\n                    }\n\n                    if (columnDefToSwap != null) {\n                        columnsTable.unselect(columnDef);\n                        columnOrder.remove(columnDef);\n                        columnOrder.remove(columnDefToSwap);\n                        columnOrder.put(columnDef, columnDefIndex - 1);\n                        columnOrder.put(columnDefToSwap, columnDefIndex);\n\n                        columns.sort(new Object[]{\"label\"}, new boolean[]{true});\n                        columnsTable.refreshRowCache();\n                        columnsTable.select(columnDef);\n                    }\n\n                }\n            }\n        });\n\n        final Button columnDownButton = new Button();\n        columnDownButton.setStyleName(\"small\");\n        columnDownButton.setIcon(new ThemeResource(\"../runo/icons/16/arrow-down.png\"));\n        columnDownButton.setDescription(\"Move this a column entry one position down\");\n        columnDownButton.setEnabled(false);\n\n        columnDownButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                ColumnDef columnDef = (ColumnDef) columnsTable.getValue();\n                if (columnDef != null) {\n                    int columnDefIndex = columnOrder.get(columnDef);\n\n                    ColumnDef columnDefToSwap = null;\n\n                    for (Map.Entry<ColumnDef, Integer> entry : columnOrder.entrySet()) {\n                        if (entry.getValue().intValue() == columnDefIndex + 1) {\n                            columnDefToSwap = entry.getKey();\n                            break;\n                        }\n                    }\n\n                    if (columnDefToSwap != null) {\n                        columnsTable.unselect(columnDef);\n                        columnOrder.remove(columnDef);\n                        columnOrder.remove(columnDefToSwap);\n                        columnOrder.put(columnDef, columnDefIndex + 1);\n                        columnOrder.put(columnDefToSwap, columnDefIndex);\n\n                        columns.sort(new Object[]{\"label\"}, new boolean[]{true});\n                        columnsTable.refreshRowCache();\n                        columnsTable.select(columnDef);\n                    }\n                }\n            }\n        });\n\n        columnsTable.setSizeFull();\n\n        columnUpButton.setSizeFull();\n        columnDownButton.setSizeFull();\n        columnsAddButton.setSizeFull();\n        columnsEditButton.setSizeFull();\n        columnsRemoveButton.setSizeFull();\n\n        columnsTable.setImmediate(true);\n\n        /**\n         * ...and a listener\n         */\n        columnsTable.addValueChangeListener(new Property.ValueChangeListener() {\n            @Override\n            public void valueChange(Property.ValueChangeEvent valueChangeEvent) {\n                boolean somethingSelected = (columnsTable.getValue() != null);\n                columnsRemoveButton.setEnabled(somethingSelected);\n                columnsEditButton.setEnabled(somethingSelected);\n                columnsAddButton.setEnabled(true);\n                columnUpButton.setEnabled(somethingSelected && columnOrder.get(columnsTable.getValue()).intValue() > 0);\n                columnDownButton.setEnabled(somethingSelected && columnOrder.get(columnsTable.getValue()).intValue() < columnOrder.size() - 1);\n            }\n        });\n\n        /**\n         * Rows table\n         */\n        final Table rowsTable = new Table();\n\n        rowsTable.setSortEnabled(false);\n        rowsTable.setWidth(25, Unit.PERCENTAGE);\n\n        final BeanItemContainer<RowDef> rows = new BeanItemContainer<RowDef>(RowDef.class, view.getRows());\n\n        final Map<RowDef, Integer> rowOrder = new HashMap<>();\n\n        int r = 0;\n        for (RowDef rowDef : view.getRows()) {\n            rowOrder.put(rowDef, r++);\n        }\n\n        rowsTable.setContainerDataSource(rows);\n\n        rowsTable.setVisibleColumns(\"label\");\n        rowsTable.setColumnHeader(\"label\", \"Rows\");\n        rowsTable.setColumnExpandRatio(\"label\", 1.0f);\n        rowsTable.setSelectable(true);\n        rowsTable.setMultiSelect(false);\n\n        /**\n         * Create custom sorter\n         */\n        rows.setItemSorter(new DefaultItemSorter() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                if (o1 == null) {\n                    if (o2 == null) {\n                        return 0;\n                    } else {\n                        return -1;\n                    }\n                }\n                if (o2 == null) {\n                    return 1;\n                }\n\n                if (rowOrder.get(o1).intValue() == rowOrder.get(o2).intValue()) {\n                    return 0;\n                } else {\n                    if (rowOrder.get(o1).intValue() > rowOrder.get(o2).intValue()) {\n                        return 1;\n                    } else {\n                        return -1;\n                    }\n                }\n            }\n        });\n\n        /**\n         * Adding the buttons...\n         */\n        final Button rowsAddButton = new Button(\"Add\");\n        rowsAddButton.setEnabled(true);\n        rowsAddButton.setStyleName(\"small\");\n        rowsAddButton.setDescription(\"Add row\");\n        rowsAddButton.setEnabled(true);\n\n        rowsAddButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                getUI().addWindow(new SurveillanceViewConfigurationCategoryWindow(surveillanceViewService, new RowDef(), new SurveillanceViewConfigurationCategoryWindow.SaveActionListener() {\n                    @Override\n                    public void save(Def def) {\n                        rows.addItem((RowDef) def);\n                        rowOrder.put((RowDef) def, rowOrder.size());\n\n                        rows.sort(new Object[]{\"label\"}, new boolean[]{true});\n                        rowsTable.refreshRowCache();\n                    }\n                }));\n            }\n        });\n\n        final Button rowsEditButton = new Button(\"Edit\");\n        rowsEditButton.setEnabled(true);\n        rowsEditButton.setStyleName(\"small\");\n        rowsEditButton.setDescription(\"Edit row\");\n        rowsEditButton.setEnabled(false);\n\n        rowsEditButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                getUI().addWindow(new SurveillanceViewConfigurationCategoryWindow(surveillanceViewService, (RowDef) rowsTable.getValue(), new SurveillanceViewConfigurationCategoryWindow.SaveActionListener() {\n                    @Override\n                    public void save(Def def) {\n                        RowDef rowToBeReplaced = (RowDef) rowsTable.getValue();\n                        int index = rowOrder.get(rowToBeReplaced);\n\n                        rows.removeItem(rowToBeReplaced);\n                        rowOrder.remove(rowToBeReplaced);\n\n                        rows.addItem((RowDef) def);\n                        rowOrder.put((RowDef) def, index);\n\n                        rows.sort(new Object[]{\"label\"}, new boolean[]{true});\n                        rowsTable.refreshRowCache();\n                    }\n                }));\n            }\n        });\n\n\n        final Button rowsRemoveButton = new Button(\"Remove\");\n        rowsRemoveButton.setEnabled(true);\n        rowsRemoveButton.setStyleName(\"small\");\n        rowsRemoveButton.setDescription(\"Remove row\");\n        rowsRemoveButton.setEnabled(false);\n\n        rowsRemoveButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                RowDef rowDef = (RowDef) rowsTable.getValue();\n                if (rowDef != null) {\n                    rowsTable.unselect(rowDef);\n                    rows.removeItem(rowDef);\n                }\n\n                rowsTable.refreshRowCache();\n            }\n        });\n\n        final Button rowUpButton = new Button();\n        rowUpButton.setStyleName(\"small\");\n        rowUpButton.setIcon(new ThemeResource(\"../runo/icons/16/arrow-up.png\"));\n        rowUpButton.setDescription(\"Move this a row entry one position up\");\n        rowUpButton.setEnabled(false);\n\n        rowUpButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                RowDef rowDef = (RowDef) rowsTable.getValue();\n                if (rowDef != null) {\n                    int rowDefIndex = rowOrder.get(rowDef);\n\n                    RowDef rowDefToSwap = null;\n\n                    for (Map.Entry<RowDef, Integer> entry : rowOrder.entrySet()) {\n                        if (entry.getValue().intValue() == rowDefIndex - 1) {\n                            rowDefToSwap = entry.getKey();\n                            break;\n                        }\n                    }\n\n                    if (rowDefToSwap != null) {\n                        rowsTable.unselect(rowDef);\n                        rowOrder.remove(rowDef);\n                        rowOrder.remove(rowDefToSwap);\n                        rowOrder.put(rowDef, rowDefIndex - 1);\n                        rowOrder.put(rowDefToSwap, rowDefIndex);\n\n                        rows.sort(new Object[]{\"label\"}, new boolean[]{true});\n                        rowsTable.refreshRowCache();\n                        rowsTable.select(rowDef);\n                    }\n                }\n            }\n        });\n\n        final Button rowDownButton = new Button();\n        rowDownButton.setStyleName(\"small\");\n        rowDownButton.setIcon(new ThemeResource(\"../runo/icons/16/arrow-down.png\"));\n        rowDownButton.setDescription(\"Move this a row entry one position down\");\n        rowDownButton.setEnabled(false);\n\n        rowDownButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                RowDef rowDef = (RowDef) rowsTable.getValue();\n                if (rowDef != null) {\n                    int rowDefIndex = rowOrder.get(rowDef);\n\n                    RowDef rowDefToSwap = null;\n\n                    for (Map.Entry<RowDef, Integer> entry : rowOrder.entrySet()) {\n                        if (entry.getValue().intValue() == rowDefIndex + 1) {\n                            rowDefToSwap = entry.getKey();\n                            break;\n                        }\n                    }\n\n                    if (rowDefToSwap != null) {\n                        rowsTable.unselect(rowDef);\n                        rowOrder.remove(rowDef);\n                        rowOrder.remove(rowDefToSwap);\n                        rowOrder.put(rowDef, rowDefIndex + 1);\n                        rowOrder.put(rowDefToSwap, rowDefIndex);\n\n                        rows.sort(new Object[]{\"label\"}, new boolean[]{true});\n                        rowsTable.refreshRowCache();\n                        rowsTable.select(rowDef);\n                    }\n                }\n            }\n        });\n\n        rowsTable.setSizeFull();\n\n        rowUpButton.setSizeFull();\n        rowDownButton.setSizeFull();\n        rowsAddButton.setSizeFull();\n        rowsEditButton.setSizeFull();\n        rowsRemoveButton.setSizeFull();\n\n        rowsTable.setImmediate(true);\n\n        /**\n         * ...and a listener\n         */\n        rowsTable.addValueChangeListener(new Property.ValueChangeListener() {\n            @Override\n            public void valueChange(Property.ValueChangeEvent valueChangeEvent) {\n                boolean somethingSelected = (rowsTable.getValue() != null);\n                rowsRemoveButton.setEnabled(somethingSelected);\n                rowsEditButton.setEnabled(somethingSelected);\n                rowsAddButton.setEnabled(true);\n                rowUpButton.setEnabled(somethingSelected && rowOrder.get(rowsTable.getValue()).intValue() > 0);\n                rowDownButton.setEnabled(somethingSelected && rowOrder.get(rowsTable.getValue()).intValue() < rowOrder.size() - 1);\n            }\n        });\n\n        /**\n         * Create form layouts...\n         */\n        FormLayout baseFormLayout = new FormLayout();\n        baseFormLayout.addComponent(titleField);\n        baseFormLayout.addComponent(refreshSecondsField);\n\n        FormLayout columnTableFormLayout = new FormLayout();\n        columnTableFormLayout.addComponent(columnsAddButton);\n        columnTableFormLayout.addComponent(columnsEditButton);\n        columnTableFormLayout.addComponent(columnsRemoveButton);\n        columnTableFormLayout.addComponent(columnUpButton);\n        columnTableFormLayout.addComponent(columnDownButton);\n\n        FormLayout rowTableFormLayout = new FormLayout();\n        rowTableFormLayout.addComponent(rowsAddButton);\n        rowTableFormLayout.addComponent(rowsEditButton);\n        rowTableFormLayout.addComponent(rowsRemoveButton);\n        rowTableFormLayout.addComponent(rowUpButton);\n        rowTableFormLayout.addComponent(rowDownButton);\n\n        /**\n         * Adding the different {@link com.vaadin.ui.FormLayout} instances to a {@link com.vaadin.ui.GridLayout}\n         */\n        baseFormLayout.setMargin(true);\n        columnTableFormLayout.setMargin(true);\n        rowTableFormLayout.setMargin(true);\n\n        GridLayout gridLayout = new GridLayout();\n        gridLayout.setSizeFull();\n        gridLayout.setColumns(4);\n        gridLayout.setRows(1);\n        gridLayout.setMargin(true);\n\n        gridLayout.addComponent(rowsTable);\n        gridLayout.addComponent(rowTableFormLayout);\n        gridLayout.addComponent(columnsTable);\n        gridLayout.addComponent(columnTableFormLayout);\n\n        gridLayout.setColumnExpandRatio(1, 0.3f);\n        gridLayout.setColumnExpandRatio(2, 1.0f);\n        gridLayout.setColumnExpandRatio(3, 0.3f);\n        gridLayout.setColumnExpandRatio(4, 1.0f);\n\n        /**\n         * Creating the vertical layout...\n         */\n        VerticalLayout verticalLayout = new VerticalLayout();\n\n        verticalLayout.addComponent(baseFormLayout);\n        verticalLayout.addComponent(gridLayout);\n\n        /**\n         * Using an additional {@link com.vaadin.ui.HorizontalLayout} for layouting the buttons\n         */\n        HorizontalLayout horizontalLayout = new HorizontalLayout();\n\n        horizontalLayout.setMargin(true);\n        horizontalLayout.setSpacing(true);\n        horizontalLayout.setWidth(100, Unit.PERCENTAGE);\n\n        /**\n         * Adding the cancel button...\n         */\n        Button cancel = new Button(\"Cancel\");\n        cancel.setDescription(\"Cancel editing properties\");\n        cancel.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent event) {\n                close();\n            }\n        });\n\n        cancel.setClickShortcut(ShortcutAction.KeyCode.ESCAPE, null);\n        horizontalLayout.addComponent(cancel);\n        horizontalLayout.setExpandRatio(cancel, 1);\n        horizontalLayout.setComponentAlignment(cancel, Alignment.TOP_RIGHT);\n\n        /**\n         * ...and the OK button\n         */\n        Button ok = new Button(\"Save\");\n        ok.setDescription(\"Save properties and close\");\n\n        ok.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent event) {\n                if (titleField.isValid() && refreshSecondsField.isValid()) {\n                    View finalView = new View();\n\n                    for (ColumnDef columnDef : columns.getItemIds()) {\n                        finalView.getColumns().add(columnDef);\n                    }\n\n                    for (RowDef rowDef : rows.getItemIds()) {\n                        finalView.getRows().add(rowDef);\n                    }\n                    finalView.setName(titleField.getValue());\n                    finalView.setRefreshSeconds(Integer.parseInt(refreshSecondsField.getValue()));\n\n                    saveActionListener.save(finalView);\n                }\n\n                close();\n            }\n        });\n\n        ok.setClickShortcut(ShortcutAction.KeyCode.ENTER, null);\n        horizontalLayout.addComponent(ok);\n\n        verticalLayout.addComponent(horizontalLayout);\n\n        setContent(verticalLayout);\n    }","commit_id":"24f77cd42a284e9fd86e7f5aa65afef52a63de06","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SurveillanceViewConfiguration getSurveillanceViewConfiguration() {\n        return m_surveillanceViewConfiguration;\n    }","id":23053,"modified_method":"/**\n     * Returns the loaded {@link org.opennms.features.vaadin.surveillanceviews.model.SurveillanceViewConfiguration} instance\n     *\n     * @return the loaded config instance\n     */\n    public SurveillanceViewConfiguration getSurveillanceViewConfiguration() {\n        return m_surveillanceViewConfiguration;\n    }","commit_id":"24f77cd42a284e9fd86e7f5aa65afef52a63de06","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SurveillanceViewsConfigList(SurveillanceViewService surveillanceViewService) {\n        this.m_surveillanceViewService = surveillanceViewService;\n\n        /**\n         * Setting the member fields\n         */\n        m_beanItemContainer = SurveillanceViewProvider.getInstance().getBeanContainer();\n\n        /**\n         * Setting up the layout component\n         */\n        setSizeFull();\n        setMargin(true);\n        setSpacing(true);\n\n        Label label = new Label(\"Surveillance View Configurations\");\n        label.addStyleName(\"configuration-title\");\n\n        Button button = new Button(\"Help\");\n        button.setStyleName(\"small\");\n        button.setDescription(\"Display help and usage\");\n\n        //button.addClickListener(new HelpClickListener(this, m_wallboardConfigView.getDashletSelector()));\n\n        Button addButton = new Button(\"Add\");\n        addButton.setStyleName(\"small\");\n        addButton.setDescription(\"Add surveillance view configuration\");\n\n        addButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                String newName;\n                int i = 0;\n\n                do {\n                    i++;\n                    newName = \"Untitled #\" + i;\n                } while (SurveillanceViewProvider.getInstance().containsView(newName));\n\n                View view = new View();\n                view.setName(newName);\n\n                view.getColumns().add(new ColumnDef());\n                view.getRows().add(new RowDef());\n\n                getUI().addWindow(new SurveillanceViewConfigurationWindow(m_surveillanceViewService, view, new SurveillanceViewConfigurationWindow.SaveActionListener() {\n                    @Override\n                    public void save(View view) {\n                        m_beanItemContainer.addItem(view);\n                        m_surveillanceViewConfiguration.getViews().add(view);\n\n                        SurveillanceViewProvider.getInstance().save();\n                        ((SurveillanceViewsConfigUI) getUI()).notifyMessage(\"Data saved\", \"Surveillance View\");\n\n                        m_table.refreshRowCache();\n                        m_table.sort(new Object[]{\"name\"}, new boolean[]{true});\n                    }\n                }));\n            }\n        });\n\n        HorizontalLayout horizontalLayout = new HorizontalLayout();\n        horizontalLayout.addComponent(label);\n        horizontalLayout.addComponent(button);\n        horizontalLayout.setWidth(100, Unit.PERCENTAGE);\n\n        horizontalLayout.setComponentAlignment(label, Alignment.MIDDLE_LEFT);\n        horizontalLayout.setComponentAlignment(button, Alignment.MIDDLE_RIGHT);\n\n        addComponent(horizontalLayout);\n\n        addComponent(addButton);\n\n        /**\n         * Adding the table with the required {@link com.vaadin.ui.Table.ColumnGenerator} objects\n         */\n        m_table = new Table();\n\n        m_table.setContainerDataSource(m_beanItemContainer);\n        m_table.setSizeFull();\n        m_table.sort(new Object[]{\"name\"}, new boolean[]{true});\n\n        m_table.addGeneratedColumn(\"Edit\", new Table.ColumnGenerator()\n\n                {\n                    public Object generateCell(Table source, final Object itemId, Object columnId) {\n                        Button button = new Button(\"Edit\");\n                        button.setDescription(\"Edit this Ops Board configuration\");\n                        button.setStyleName(\"small\");\n                        button.addClickListener(new Button.ClickListener() {\n                            public void buttonClick(Button.ClickEvent clickEvent) {\n                                getUI().addWindow(new SurveillanceViewConfigurationWindow(m_surveillanceViewService, m_beanItemContainer.getItem(itemId).getBean(), new SurveillanceViewConfigurationWindow.SaveActionListener() {\n                                    @Override\n                                    public void save(View view) {\n                                        m_beanItemContainer.removeItem(itemId);\n                                        m_beanItemContainer.addItem(view);\n                                        m_surveillanceViewConfiguration.getViews().set(m_surveillanceViewConfiguration.getViews().indexOf(itemId), view);\n\n                                        SurveillanceViewProvider.getInstance().save();\n                                        ((SurveillanceViewsConfigUI) getUI()).notifyMessage(\"Data saved\", \"Surveillance view\");\n\n                                        m_table.refreshRowCache();\n                                        m_table.sort(new Object[]{\"name\"}, new boolean[]{true});\n                                    }\n                                }));\n                            }\n                        });\n                        return button;\n                    }\n                }\n\n        );\n\n        m_table.addGeneratedColumn(\"Remove\", new Table.ColumnGenerator()\n\n                {\n                    public Object generateCell(Table source, final Object itemId, Object columnId) {\n                        Button button = new Button(\"Remove\");\n                        button.setDescription(\"Delete this Ops Board configuration\");\n                        button.setStyleName(\"small\");\n                        button.addClickListener(new Button.ClickListener() {\n                            public void buttonClick(Button.ClickEvent clickEvent) {\n                                SurveillanceViewProvider.getInstance().removeView((View) itemId);\n                                m_beanItemContainer.removeItem(itemId);\n                            }\n                        });\n                        return button;\n                    }\n                }\n\n        );\n\n        m_table.addGeneratedColumn(\"Preview\", new Table.ColumnGenerator()\n\n                {\n                    public Object generateCell(Table source, final Object itemId, Object columnId) {\n                        Button button = new Button(\"Preview\");\n                        button.setDescription(\"Preview this Ops Board configuration\");\n                        button.setStyleName(\"small\");\n                        //button.addClickListener(new PreviewClickListener(WallboardOverview.this, (Wallboard) itemId));\n                        return button;\n                    }\n                }\n\n        );\n\n        m_table.addGeneratedColumn(\"Default\", new Table.ColumnGenerator()\n\n                {\n                    public Object generateCell(Table source, final Object itemId, Object columnId) {\n                        CheckBox checkBox = new CheckBox();\n                        checkBox.setImmediate(true);\n                        checkBox.setDescription(\"Make this Ops Board configuration the default\");\n\n                        final View view = m_beanItemContainer.getItem(itemId).getBean();\n\n                        checkBox.setValue(m_surveillanceViewConfiguration.getDefaultView().equals(view.getName()));\n\n                        checkBox.addValueChangeListener(new Property.ValueChangeListener() {\n                            @Override\n                            public void valueChange(Property.ValueChangeEvent valueChangeEvent) {\n                                boolean newValue = ((Boolean) valueChangeEvent.getProperty().getValue());\n\n\n                                if (newValue) {\n                                    m_surveillanceViewConfiguration.setDefaultView(view.getName());\n                                }\n\n                                m_table.refreshRowCache();\n\n                                SurveillanceViewProvider.getInstance().save();\n                                ((SurveillanceViewsConfigUI) getUI()).notifyMessage(\"Data saved\", \"Default surveillance view\");\n                            }\n                        });\n                        return checkBox;\n                    }\n                }\n\n        );\n\n        m_table.setVisibleColumns(new Object[]{\"name\", \"Edit\", \"Remove\", \"Preview\", \"Default\"});\n        m_table.setColumnHeader(\"name\", \"Name\");\n\n        /**\n         * Adding the table\n         */\n        addComponent(m_table);\n\n        setExpandRatio(m_table, 1.0f);\n    }","id":23054,"modified_method":"public SurveillanceViewsConfigList(SurveillanceViewService surveillanceViewService) {\n        this.m_surveillanceViewService = surveillanceViewService;\n\n        /**\n         * Loading the config\n         */\n\n        reloadSurveillanceViews();\n\n        /**\n         * Setting up the layout component\n         */\n        setSizeFull();\n        setMargin(true);\n        setSpacing(true);\n\n        Label label = new Label(\"Surveillance View Configurations\");\n        label.addStyleName(\"configuration-title\");\n\n        Button button = new Button(\"Help\");\n        button.setStyleName(\"small\");\n        button.setDescription(\"Display help and usage\");\n\n        /**\n         * button.addClickListener(new HelpClickListener(this, m_wallboardConfigView.getDashletSelector()));\n         */\n\n        Button addButton = new Button(\"Add\");\n        addButton.setStyleName(\"small\");\n        addButton.setDescription(\"Add surveillance view configuration\");\n\n        addButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(Button.ClickEvent clickEvent) {\n                String newName;\n                int i = 0;\n\n                do {\n                    i++;\n                    newName = \"Untitled #\" + i;\n                } while (SurveillanceViewProvider.getInstance().containsView(newName));\n\n                View view = new View();\n                view.setName(newName);\n\n                view.getColumns().add(new ColumnDef());\n                view.getRows().add(new RowDef());\n\n                getUI().addWindow(new SurveillanceViewConfigurationWindow(m_surveillanceViewService, view, new SurveillanceViewConfigurationWindow.SaveActionListener() {\n                    @Override\n                    public void save(View view) {\n                        m_beanItemContainer.addItem(view);\n\n                        SurveillanceViewProvider.getInstance().getSurveillanceViewConfiguration().getViews().add(view);\n                        SurveillanceViewProvider.getInstance().save();\n\n                        ((SurveillanceViewsConfigUI) getUI()).notifyMessage(\"Data saved\", \"Surveillance View\");\n\n                        m_table.refreshRowCache();\n                        m_table.sort(new Object[]{\"name\"}, new boolean[]{true});\n                    }\n                }));\n            }\n        });\n\n        HorizontalLayout horizontalLayout = new HorizontalLayout();\n        horizontalLayout.addComponent(label);\n        horizontalLayout.addComponent(button);\n        horizontalLayout.setWidth(100, Unit.PERCENTAGE);\n\n        horizontalLayout.setComponentAlignment(label, Alignment.MIDDLE_LEFT);\n        horizontalLayout.setComponentAlignment(button, Alignment.MIDDLE_RIGHT);\n\n        addComponent(horizontalLayout);\n\n        addComponent(addButton);\n\n        /**\n         * Adding the table with the required {@link com.vaadin.ui.Table.ColumnGenerator} objects\n         */\n        m_table = new Table();\n\n        m_table.setContainerDataSource(m_beanItemContainer);\n        m_table.setSizeFull();\n        m_table.sort(new Object[]{\"name\"}, new boolean[]{true});\n\n        m_table.addGeneratedColumn(\"Edit\", new Table.ColumnGenerator()\n\n                {\n                    public Object generateCell(Table source, final Object itemId, Object columnId) {\n                        Button button = new Button(\"Edit\");\n                        button.setDescription(\"Edit this Surveillance View configuration\");\n                        button.setStyleName(\"small\");\n                        button.addClickListener(new Button.ClickListener() {\n                            public void buttonClick(Button.ClickEvent clickEvent) {\n                                getUI().addWindow(new SurveillanceViewConfigurationWindow(m_surveillanceViewService, m_beanItemContainer.getItem(itemId).getBean(), new SurveillanceViewConfigurationWindow.SaveActionListener() {\n                                    @Override\n                                    public void save(View view) {\n                                        m_beanItemContainer.removeItem(itemId);\n                                        m_beanItemContainer.addItem(view);\n                                        SurveillanceViewProvider.getInstance().getSurveillanceViewConfiguration().getViews().set(SurveillanceViewProvider.getInstance().getSurveillanceViewConfiguration().getViews().indexOf(itemId), view);\n\n                                        SurveillanceViewProvider.getInstance().save();\n                                        ((SurveillanceViewsConfigUI) getUI()).notifyMessage(\"Data saved\", \"Surveillance view\");\n\n                                        m_table.refreshRowCache();\n                                        m_table.sort(new Object[]{\"name\"}, new boolean[]{true});\n                                    }\n                                }));\n                            }\n                        });\n                        return button;\n                    }\n                }\n\n        );\n\n        m_table.addGeneratedColumn(\"Remove\", new Table.ColumnGenerator()\n\n                {\n                    public Object generateCell(Table source, final Object itemId, Object columnId) {\n                        Button button = new Button(\"Remove\");\n                        button.setDescription(\"Delete this Surveillance View configuration\");\n                        button.setStyleName(\"small\");\n                        button.addClickListener(new Button.ClickListener() {\n                            public void buttonClick(Button.ClickEvent clickEvent) {\n                                SurveillanceViewProvider.getInstance().removeView((View) itemId);\n                                m_beanItemContainer.removeItem(itemId);\n                            }\n                        });\n                        return button;\n                    }\n                }\n\n        );\n\n        m_table.addGeneratedColumn(\"Preview\", new Table.ColumnGenerator()\n\n                {\n                    public Object generateCell(Table source, final Object itemId, Object columnId) {\n                        Button button = new Button(\"Preview\");\n                        button.setDescription(\"Preview this Surveillance View configuration\");\n                        button.setStyleName(\"small\");\n                        /**\n                         * button.addClickListener(new PreviewClickListener(WallboardOverview.this, (Wallboard) itemId));\n                         */\n                        return button;\n                    }\n                }\n\n        );\n\n        m_table.addGeneratedColumn(\"Default\", new Table.ColumnGenerator()\n\n                {\n                    public Object generateCell(Table source, final Object itemId, Object columnId) {\n                        CheckBox checkBox = new CheckBox();\n                        checkBox.setImmediate(true);\n                        checkBox.setDescription(\"Make this Surveillance View configuration the default\");\n\n                        final View view = m_beanItemContainer.getItem(itemId).getBean();\n\n                        checkBox.setValue(SurveillanceViewProvider.getInstance().getSurveillanceViewConfiguration().getDefaultView().equals(view.getName()));\n\n                        checkBox.addValueChangeListener(new Property.ValueChangeListener() {\n                            @Override\n                            public void valueChange(Property.ValueChangeEvent valueChangeEvent) {\n                                boolean newValue = ((Boolean) valueChangeEvent.getProperty().getValue());\n\n                                if (newValue) {\n                                    SurveillanceViewProvider.getInstance().getSurveillanceViewConfiguration().setDefaultView(view.getName());\n                                }\n\n                                m_table.refreshRowCache();\n\n                                SurveillanceViewProvider.getInstance().save();\n\n                                ((SurveillanceViewsConfigUI) getUI()).notifyMessage(\"Data saved\", \"Default surveillance view\");\n                            }\n                        });\n                        return checkBox;\n                    }\n                }\n\n        );\n\n        m_table.setVisibleColumns(new Object[]{\"name\", \"Edit\", \"Remove\", \"Preview\", \"Default\"});\n        m_table.setColumnHeader(\"name\", \"Name\");\n\n        /**\n         * Adding the table\n         */\n        addComponent(m_table);\n\n        setExpandRatio(m_table, 1.0f);\n    }","commit_id":"24f77cd42a284e9fd86e7f5aa65afef52a63de06","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setSurveillanceViewService(SurveillanceViewService surveillanceViewService) {\n        this.m_surveillanceViewService = surveillanceViewService;\n    }","id":23055,"modified_method":"/**\n     * Method for setting the {@link org.opennms.features.vaadin.surveillanceviews.service.SurveillanceViewService} instance to be used\n     *\n     * @param surveillanceViewService the instance to be used\n     */\n    public void setSurveillanceViewService(SurveillanceViewService surveillanceViewService) {\n        this.m_surveillanceViewService = surveillanceViewService;\n    }","commit_id":"24f77cd42a284e9fd86e7f5aa65afef52a63de06","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * The buildURL method takes the current values in the form and formats them into the\n\t * URL string that is used to redirect the results browser to the Ping page.\n\t * @return Web address for ping command with submitted parameters\n\t * @throws MalformedURLException\n\t */\n    protected URL buildURL() {\n        boolean validInput = false;\n        try {\n            validInput = validateInput();\n        } catch (NumberFormatException e) {\n            Notification.show(\"Inputs must be integers\", Notification.Type.WARNING_MESSAGE);\n            return null;\n        }\n        if (validInput) {\n            final StringBuilder options = new StringBuilder(pingUrl);\n            try {\n                URL baseUrl = getUI().getPage().getLocation().toURL();\n\n                options.append(pingUrl.contains(\"?\") ? \"&\" : \"?\");\n\n                options.append(\"address=\").append(ipDropdown.getValue())\n                    .append(\"&timeout=\").append(timeoutField.getValue())\n                    .append(\"&numberOfRequests=\").append(requestsField.getValue())\n                    .append(\"&packetSize=\").append(Integer.parseInt(packetSizeDropdown.getValue().toString()) - 8);\n                if (numericalDataCheckBox.getValue().equals(true)) {\n                    options.append(\"&numericOutput=true\");\n                }\n\n                return new URL(baseUrl, options.toString());\n            } catch (final MalformedURLException e) {\n                Notification.show(\"Could not build URL: \" + options.toString(), Notification.Type.WARNING_MESSAGE);\n                return null;\n            }\n        } else {\n            Notification.show(\"Inputs must be between 0 and 9999\", Notification.Type.WARNING_MESSAGE);\n            return null;\n        }\n    }","id":23056,"modified_method":"/**\n     * The buildURL method takes the current values in the form and formats them into the\n     * URL string that is used to redirect the results browser to the Ping page.\n     *\n     * @return Web address for ping command with submitted parameters\n     * @throws MalformedURLException\n     */\n    protected URL buildURL() {\n        boolean validInput = false;\n        try {\n            validInput = validateInput();\n        } catch (NumberFormatException e) {\n            Notification.show(\"Inputs must be integers\", Notification.Type.WARNING_MESSAGE);\n            return null;\n        }\n        if (validInput) {\n            final StringBuilder options = new StringBuilder(pingUrl);\n            try {\n                URL baseUrl = getUI().getPage().getLocation().toURL();\n\n                options.append(pingUrl.contains(\"?\") ? \"&\" : \"?\");\n\n                options.append(\"address=\").append(ipDropdown.getValue())\n                        .append(\"&timeout=\").append(timeoutField.getValue())\n                        .append(\"&numberOfRequest=\").append(requestsField.getValue())\n                        .append(\"&packetSize=\").append(Integer.parseInt(packetSizeDropdown.getValue().toString()) - 8);\n                if (numericalDataCheckBox.getValue().equals(true)) {\n                    options.append(\"&numericOutput=true\");\n                }\n\n                return new URL(baseUrl, options.toString());\n            } catch (final MalformedURLException e) {\n                Notification.show(\"Could not build URL: \" + options.toString(), Notification.Type.WARNING_MESSAGE);\n                return null;\n            }\n        } else {\n            Notification.show(\"Inputs must be between 0 and 9999\", Notification.Type.WARNING_MESSAGE);\n            return null;\n        }\n    }","commit_id":"d95c0afeae1be4b7d65f10e6fbbeaa894e105aa3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * The PingWindow method constructs a PingWindow component with a size proportionate to the \n\t * width and height of the main window.\n\t * @param node \n\t * @param width Width of Main window\n\t * @param height Height of Main window\n\t */\n\tpublic PingWindow(final Node node, final String pingUrl){\n\n\t\tthis.pingUrl = pingUrl;\n\n\t\tString label = \"\";\n\t\tString ipAddress = \"\";\n\t\tif (node != null) {\n\t\t\tlabel = node.getLabel();\n\t\t\tipAddress = node.getIPAddress();\n\t\t}\n\t\tString caption = \"\";\n\t\t/*Sets up window settings*/\n\t\tif (label == null || label.equals(\"\") || label.equalsIgnoreCase(noLabel)) {\n\t\t\tlabel = \"\";\n\t\t} \n\t\tif (!label.equals(\"\")) caption = \" - \" + label;\n\t\tsetCaption(\"Ping\" + caption);\n\t\tsetImmediate(true);\n\t\tsetResizable(false);\n        setSizeFull();\n\n\t\t/*Initialize the header of the Sub-window with the name of the selected Node*/\n\t\tString nodeName = \"<div style=\\\"text-align: center; font-size: 18pt; font-weight:bold;\\\">\" + label + \"<\/div>\";\n\t\tnodeLabel = new Label(nodeName);\n\t\tnodeLabel.setContentMode(ContentMode.HTML);\n\n\t\t/*Creating various layouts to encapsulate all of the components*/\n\t\tVerticalLayout mainLayout = new VerticalLayout();\n\t\tmainLayout.setSizeFull();\n\t\tvSplit = new VerticalSplitPanel();\n        vSplit.setWidth(800, Unit.PIXELS);\n        vSplit.setHeight(800, Unit.PIXELS);\n\n\t\ttopLayout = new VerticalLayout();\n\t\tbottomLayout = new VerticalLayout();\n\t\tVerticalLayout form = new VerticalLayout();\n\t\tGridLayout grid = new GridLayout(2,4);\n\t\tgrid.setWidth(\"420\");\n\t\tgrid.setHeight(\"120\");\n\n\t\t/*Sets up IP Address dropdown with the Name as default*/\n\t\tipDropdown = new NativeSelect();\n\t\tipDropdown.addItem(ipAddress);\n\t\tipDropdown.select(ipAddress);\n\n\t\t/*Sets up Packet Size dropdown with different values*/\n\t\tpacketSizeDropdown = new NativeSelect();\n\t\tpacketSizeDropdown.addItem(\"16\");\n\t\tpacketSizeDropdown.addItem(\"32\");\n\t\tpacketSizeDropdown.addItem(\"64\");\n\t\tpacketSizeDropdown.addItem(\"128\");\n\t\tpacketSizeDropdown.addItem(\"256\");\n\t\tpacketSizeDropdown.addItem(\"512\");\n\t\tpacketSizeDropdown.addItem(\"1024\");\n\t\tpacketSizeDropdown.select(\"16\");\n\n\t\t/*Creates the Numerical Output Check box and sets up the listener*/\n\t\tnumericalDataCheckBox = new CheckBox(\"Use Numerical Node Names\");\n\t\tnumericalDataCheckBox.setImmediate(true);\n\t\tnumericalDataCheckBox.setValue(false);\n\n\t\t/*Creates the form labels and text fields*/\n\t\tLabel ipLabel = new Label(\"IP Address: \");\n\t\tLabel requestsLabel = new Label(\"Number of Requests: \");\n\t\tLabel timeoutLabel = new Label(\"Time-Out (seconds): \");\n\t\tLabel packetLabel = new Label(\"Packet Size: \");\n\t\trequestsField = new TextField();\n\t\trequestsField.setMaxLength(4); //Max buffer of 4 to prevent buffer overflow\n\t\ttimeoutField = new TextField();\n\t\ttimeoutField.setMaxLength(4); //Max buffer of 4 to prevent buffer overflow\n\n\t\t/*Add all of the components to the GridLayout*/\n\t\tgrid.addComponent(ipLabel);\n\t\tgrid.setComponentAlignment(ipLabel, Alignment.MIDDLE_LEFT);\n\t\tgrid.addComponent(ipDropdown);\n\t\tgrid.setComponentAlignment(ipDropdown, Alignment.MIDDLE_LEFT);\n\t\tgrid.addComponent(requestsLabel);\n\t\tgrid.setComponentAlignment(requestsLabel, Alignment.MIDDLE_LEFT);\n\t\tgrid.addComponent(requestsField);\n\t\tgrid.setComponentAlignment(requestsField, Alignment.MIDDLE_LEFT);\n\t\tgrid.addComponent(timeoutLabel);\n\t\tgrid.setComponentAlignment(timeoutLabel, Alignment.MIDDLE_LEFT);\n\t\tgrid.addComponent(timeoutField);\n\t\tgrid.setComponentAlignment(timeoutField, Alignment.MIDDLE_LEFT);\n\t\tgrid.addComponent(packetLabel);\n\t\tgrid.setComponentAlignment(packetLabel, Alignment.MIDDLE_LEFT);\n\t\tgrid.addComponent(packetSizeDropdown);\n\t\tgrid.setComponentAlignment(packetSizeDropdown, Alignment.MIDDLE_LEFT);\n\n\t\t/*Creates the Ping button and sets up the listener*/\n\t\tpingButton = new Button(\"Ping\"); \n\t\tpingButton.addClickListener(new Button.ClickListener() {\n\t\t\t@Override\n\t\t\tpublic void buttonClick(ClickEvent event) {\n\t\t\t\tchangeBrowserURL(buildURL());\n\t\t\t}\n\t\t}); \n\n\t\t/*Adds components to the form and sets the width and spacing*/\n\t\tform.addComponent(grid);\n\t\tform.addComponent(numericalDataCheckBox);\n\t\tform.addComponent(pingButton);\n\t\tform.setWidth(\"100%\");\n\t\tform.setSpacing(true);\n\n\t\t/*Adds components to the Top Layout and sets the width and margins*/\n\t\ttopLayout.addComponent(nodeLabel);\n\t\ttopLayout.setComponentAlignment(nodeLabel, Alignment.MIDDLE_CENTER);\n\t\ttopLayout.addComponent(form);\n\t\ttopLayout.setSizeFull();\n\t\ttopLayout.setMargin(new MarginInfo(true, true, false, true));\n\n\t\t/*Sets attributes for bottom layout component*/\n\t\tbottomLayout.setSizeFull();\n\t\tbottomLayout.setMargin(true);\n\t\tbottomLayout.setImmediate(true);\n\n\t\tbuildEmbeddedBrowser();\n\n\t\t/*Setting first and second components for the split panel and setting the panel divider position*/\n\t\tvSplit.setFirstComponent(topLayout);\n\t\tvSplit.setSecondComponent(bottomLayout);\n\t\tvSplit.setSplitPosition(splitHeight, Unit.PIXELS);\n\t\tvSplit.setLocked(true);\n\n\t\t/*Adds split panel to the main layout and expands the split panel to 100% of the layout space*/\n\t\tmainLayout.addComponent(vSplit);\n\t\tmainLayout.setExpandRatio(vSplit, 1);\n\n\t\tsetContent(mainLayout);\n\t}","id":23057,"modified_method":"/**\n     * The PingWindow method constructs a PingWindow component with a size proportionate to the\n     * width and height of the main window.\n     *\n     * @param node\n     * @param pingUrl\n     */\n    public PingWindow(final Node node, final String pingUrl) {\n\n        this.pingUrl = pingUrl;\n\n        String label = \"\";\n        String ipAddress = \"\";\n        if (node != null) {\n            label = node.getLabel();\n            ipAddress = node.getIPAddress();\n        }\n        String caption = \"\";\n        /*Sets up window settings*/\n        if (label == null || label.equals(\"\") || label.equalsIgnoreCase(noLabel)) {\n            label = \"\";\n        }\n        if (!label.equals(\"\")) {\n            caption = \" - \" + label;\n        }\n        setCaption(\"Ping\" + caption);\n        setImmediate(true);\n        setResizable(false);\n        setSizeFull();\n\n\t\t/*Initialize the header of the Sub-window with the name of the selected Node*/\n        String nodeName = \"<div style=\\\"text-align: center; font-size: 18pt; font-weight:bold;\\\">\" + label + \"<\/div>\";\n        nodeLabel = new Label(nodeName);\n        nodeLabel.setContentMode(ContentMode.HTML);\n\n        VerticalLayout mainLayout = new VerticalLayout();\n        mainLayout.setSizeFull();\n        mainLayout.setSpacing(true);\n        mainLayout.setMargin(true);\n\n        VerticalLayout form = new VerticalLayout();\n        GridLayout grid = new GridLayout(2, 4);\n        grid.setWidth(\"420\");\n        grid.setHeight(\"120\");\n\n\t\t/*Sets up IP Address dropdown with the Name as default*/\n        ipDropdown = new NativeSelect();\n        ipDropdown.addItem(ipAddress);\n        ipDropdown.select(ipAddress);\n        ipDropdown.setNullSelectionAllowed(false);\n\n\t\t/*Sets up Packet Size dropdown with different values*/\n        packetSizeDropdown = new NativeSelect();\n        packetSizeDropdown.addItem(\"16\");\n        packetSizeDropdown.addItem(\"32\");\n        packetSizeDropdown.addItem(\"64\");\n        packetSizeDropdown.addItem(\"128\");\n        packetSizeDropdown.addItem(\"256\");\n        packetSizeDropdown.addItem(\"512\");\n        packetSizeDropdown.addItem(\"1024\");\n        packetSizeDropdown.select(\"16\");\n\n\t\t/*Creates the Numerical Output Check box and sets up the listener*/\n        numericalDataCheckBox = new CheckBox(\"Use Numerical Node Names\");\n        numericalDataCheckBox.setImmediate(true);\n        numericalDataCheckBox.setValue(false);\n\n\t\t/*Creates the form labels and text fields*/\n        Label ipLabel = new Label(\"IP Address: \");\n        Label requestsLabel = new Label(\"Number of Requests: \");\n        Label timeoutLabel = new Label(\"Time-Out (seconds): \");\n        Label packetLabel = new Label(\"Packet Size: \");\n        requestsField = new TextField();\n        requestsField.setMaxLength(4); //Max buffer of 4 to prevent buffer overflow\n        requestsField.setValue(\"4\");\n        timeoutField = new TextField();\n        timeoutField.setMaxLength(4); //Max buffer of 4 to prevent buffer overflow\n        timeoutField.setValue(\"1\");\n\n\t\t/*Add all of the components to the GridLayout*/\n        grid.addComponent(ipLabel);\n        grid.setComponentAlignment(ipLabel, Alignment.MIDDLE_LEFT);\n        grid.addComponent(ipDropdown);\n        grid.setComponentAlignment(ipDropdown, Alignment.MIDDLE_LEFT);\n        grid.addComponent(requestsLabel);\n        grid.setComponentAlignment(requestsLabel, Alignment.MIDDLE_LEFT);\n        grid.addComponent(requestsField);\n        grid.setComponentAlignment(requestsField, Alignment.MIDDLE_LEFT);\n        grid.addComponent(timeoutLabel);\n        grid.setComponentAlignment(timeoutLabel, Alignment.MIDDLE_LEFT);\n        grid.addComponent(timeoutField);\n        grid.setComponentAlignment(timeoutField, Alignment.MIDDLE_LEFT);\n        grid.addComponent(packetLabel);\n        grid.setComponentAlignment(packetLabel, Alignment.MIDDLE_LEFT);\n        grid.addComponent(packetSizeDropdown);\n        grid.setComponentAlignment(packetSizeDropdown, Alignment.MIDDLE_LEFT);\n\n\t\t/*Creates the Ping button and sets up the listener*/\n        pingButton = new Button(\"Ping\");\n        pingButton.addClickListener(new Button.ClickListener() {\n            @Override\n            public void buttonClick(ClickEvent event) {\n                changeBrowserURL(buildURL());\n            }\n        });\n\n\t\t/*Adds components to the form and sets the width and spacing*/\n        form.addComponent(grid);\n        form.addComponent(numericalDataCheckBox);\n        form.addComponent(pingButton);\n        form.setWidth(\"100%\");\n        form.setSpacing(true);\n\n\t\t/*Adds components to the Top Layout and sets the width and margins*/\n        mainLayout.addComponent(nodeLabel);\n        mainLayout.setComponentAlignment(nodeLabel, Alignment.MIDDLE_CENTER);\n        mainLayout.addComponent(form);\n\n        buildEmbeddedBrowser();\n\n        Panel panel = new Panel();\n        panel.setSizeFull();\n        panel.setCaption(\"Results\");\n        panel.setContent(resultsBrowser);\n\n        mainLayout.addComponent(panel);\n        mainLayout.setExpandRatio(panel, 1.0f);\n\n        setContent(mainLayout);\n    }","commit_id":"d95c0afeae1be4b7d65f10e6fbbeaa894e105aa3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * The validateInput method checks the timeout text field and the\n\t * number of requests field to make sure the input given by the\n\t * user was formatted correctly.\n\t * @return Whether input was correctly formatted\n\t */\n\tprotected boolean validateInput() throws NumberFormatException {\n\t\tint timeout = 0, requests = 0;\n\t\t\n\t\tif (\"\".equals(timeoutField.getValue().toString())) timeout = 1;\n\t\telse timeout = Integer.parseInt(timeoutField.getValue().toString());\n\t\tif (\"\".equals(requestsField.getValue().toString())) requests = 1;\n\t\telse requests = Integer.parseInt(requestsField.getValue().toString());\n\t\t\n\t\tif (timeout < 1 || timeout > 9999) return false;\n\t\tif (requests < 1 || requests > 9999) return false;\n\t\treturn true;\n\t}","id":23058,"modified_method":"/**\n     * The validateInput method checks the timeout text field and the\n     * number of requests field to make sure the input given by the\n     * user was formatted correctly.\n     *\n     * @return Whether input was correctly formatted\n     */\n    protected boolean validateInput() throws NumberFormatException {\n        int timeout = 0, requests = 0;\n\n        if (timeoutField.getValue() == null || \"\".equals(timeoutField.getValue().toString())) {\n            return false;\n        } else {\n            timeout = Integer.parseInt(timeoutField.getValue().toString());\n        }\n        if (requestsField.getValue() == null || \"\".equals(requestsField.getValue().toString())) {\n            return false;\n        } else {\n            requests = Integer.parseInt(requestsField.getValue().toString());\n        }\n\n        if (timeout < 1 || timeout > 9999) {\n            return false;\n        }\n        if (requests < 1 || requests > 9999) {\n            return false;\n        }\n        return true;\n    }","commit_id":"d95c0afeae1be4b7d65f10e6fbbeaa894e105aa3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * The buildEmbeddedBrowser method creates a new browser instance and adds it to the \n\t * bottom layout. The browser is set to invisible by default.\n\t */\n\tprivate void buildEmbeddedBrowser() {\n\t\tresultsBrowser = new Embedded();\n\t\tresultsBrowser.setType(Embedded.TYPE_BROWSER);\n\t\tresultsBrowser.setImmediate(true);\n\t\tresultsBrowser.setVisible(false);\n\t\tbottomLayout.addComponent(resultsBrowser);\n\t}","id":23059,"modified_method":"/**\n     * The buildEmbeddedBrowser method creates a new browser instance and adds it to the\n     * bottom layout. The browser is set to invisible by default.\n     */\n    private void buildEmbeddedBrowser() {\n        resultsBrowser = new Embedded();\n        resultsBrowser.setType(Embedded.TYPE_BROWSER);\n        resultsBrowser.setImmediate(true);\n        resultsBrowser.setVisible(true);\n    }","commit_id":"d95c0afeae1be4b7d65f10e6fbbeaa894e105aa3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void shouldStopIgnoringMessagesAfterErrorAck() throws Throwable\n    {\n        // Given\n        HTTP.Response rs = http.POST( \"/session/\" );\n        String sessionLocation = rs.location();\n\n        // When\n        rs = http.POST( sessionLocation, messages(\n                run(\"syntax error\" ),\n                discardAll(),\n                ackF(),\n                run( \"CREATE (n)\" ),\n                discardAll()\n        ));\n\n        // Then\n        assertThat( messages( rs ),  equalsMessages(\n                msgFailure( new Neo4jError(InvalidSyntax,\n                        \"Invalid input 'y': expected 't/T' or 'e/E' (line 1, column 2 (offset: 1))\\n\" +\n                        \"\\\"syntax error\\\"\\n\" +\n                        \"  ^\")),\n                msgIgnored(),\n                msgSuccess(),\n                msgSuccess(),\n                msgSuccess()\n        ) );\n    }","id":23060,"modified_method":"@Test\n    public void shouldStopIgnoringMessagesAfterErrorAck() throws Throwable\n    {\n        // Given\n        HTTP.Response rs = http.POST( \"/session/\" );\n        String sessionLocation = rs.location();\n\n        // When\n        rs = http.POST( sessionLocation, createHttpPayload( serialize(\n                run(\"syntax error\" ),\n                discardAll(),\n                ackF(),\n                run( \"CREATE (n)\" ),\n                discardAll()\n        )));\n\n        // Then\n        assertThat( messages( rs.rawContent() ),  equalsMessages(\n                msgFailure( new Neo4jError(InvalidSyntax,\n                        \"Invalid input 'y': expected 't/T' or 'e/E' (line 1, column 2 (offset: 1))\\n\" +\n                        \"\\\"syntax error\\\"\\n\" +\n                        \"  ^\")),\n                msgIgnored(),\n                msgSuccess(),\n                msgSuccess(),\n                msgSuccess()\n        ) );\n    }","commit_id":"9782d06d4ce3c23cf8bbc083662d83cb59ef8518","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldReturnFailureOnFailure() throws Throwable\n    {\n        // Given\n        HTTP.Response rs = http.POST( \"/session/\" );\n        String sessionLocation = rs.location();\n\n        // When\n        rs = http.POST( sessionLocation, messages(\n                run( \"syntax error\" ),\n                discardAll() ) );\n\n        // Then\n        assertThat( messages( rs ),  equalsMessages(\n                msgFailure( new Neo4jError(InvalidSyntax,\n                        \"Invalid input 'y': expected 't/T' or 'e/E' (line 1, column 2 (offset: 1))\\n\" +\n                         \"\\\"syntax error\\\"\\n\" +\n                         \"  ^\")),\n                msgIgnored()\n        ) );\n    }","id":23061,"modified_method":"@Test\n    public void shouldReturnFailureOnFailure() throws Throwable\n    {\n        // Given\n        HTTP.Response rs = http.POST( \"/session/\" );\n        String sessionLocation = rs.location();\n\n        // When\n        rs = http.POST( sessionLocation, createHttpPayload( serialize(\n                run( \"syntax error\" ),\n                discardAll() )));\n\n        // Then\n        assertThat( messages( rs.rawContent() ),  equalsMessages(\n                msgFailure( new Neo4jError(InvalidSyntax,\n                        \"Invalid input 'y': expected 't/T' or 'e/E' (line 1, column 2 (offset: 1))\\n\" +\n                         \"\\\"syntax error\\\"\\n\" +\n                         \"  ^\")),\n                msgIgnored()\n        ) );\n    }","commit_id":"9782d06d4ce3c23cf8bbc083662d83cb59ef8518","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldCloseSessionOnInvalidPayload() throws Throwable\n    {\n        // Given\n        HTTP.Response rs = http.POST( \"/session/\" );\n        String sessionLocation = rs.location();\n\n        byte[] payload = serialize(\n                run(\"CREATE (n)\", map( \"name\", \"Bob\" ) ),\n                discardAll()\n        );\n        payload = Arrays.copyOf(payload, payload.length / 2);\n\n        // When\n        rs = http.POST( sessionLocation, createHttpPayload( payload ) );\n\n        // Then\n        assertThat( rs.status(), equalTo(200) );\n        assertThat( messages( rs ),  equalsMessages(\n                msgFailure( new Neo4jError( Status.Request.Invalid,\n                        \"One or more malformed messages were received, please verify that your driver is of \" +\n                        \"the latest applicable version and if not, please file a bug report. The session will be \" +\n                        \"terminated.\"))\n        ) );\n        assertThat( http.POST( sessionLocation ).status(), equalTo(404) );\n    }","id":23062,"modified_method":"@Test\n    public void shouldCloseSessionOnInvalidPayload() throws Throwable\n    {\n        // Given\n        HTTP.Response rs = http.POST( \"/session/\" );\n        String sessionLocation = rs.location();\n\n        byte[] payload = serialize(\n                run(\"CREATE (n)\", map( \"name\", \"Bob\" ) ),\n                discardAll()\n        );\n        payload = Arrays.copyOf(payload, payload.length / 2);\n\n        // When\n        rs = http.POST( sessionLocation, createHttpPayload( payload ) );\n\n        // Then\n        assertThat( rs.status(), equalTo(200) );\n        assertThat( messages( rs.rawContent() ),  equalsMessages(\n                msgFailure( new Neo4jError( Status.Request.Invalid,\n                        \"One or more malformed messages were received, please verify that your driver is of \" +\n                        \"the latest applicable version and if not, please file a bug report. The session will be \" +\n                        \"terminated.\"))\n        ) );\n        assertThat( http.POST( sessionLocation ).status(), equalTo(404) );\n    }","commit_id":"9782d06d4ce3c23cf8bbc083662d83cb59ef8518","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldBeAbleToSubmitRunRequest() throws Throwable\n    {\n        // Given\n        HTTP.Response rs = http.POST( \"/session/\" );\n        String sessionLocation = rs.location();\n\n        // When\n        rs = http.POST( sessionLocation, messages(\n                run( \"UNWIND [1,2,3] AS a RETURN a, a * a AS a_squared\" ),\n                pullAll() ) );\n\n        // Then\n        assertThat( messages( rs ), equalTo( asList(\n                success( map( \"fields\", asList(\"a\", \"a_squared\") ) ),\n                Messages.record( record( 1l, 1l ) ),\n                Messages.record( record( 2l, 4l ) ),\n                Messages.record( record( 3l, 9l ) ),\n                success( map() )\n        ) ) );\n    }","id":23063,"modified_method":"@Test\n    public void shouldBeAbleToSubmitRunRequest() throws Throwable\n    {\n        // Given\n        HTTP.Response rs = http.POST( \"/session/\" );\n        String sessionLocation = rs.location();\n\n        // When\n        rs = http.POST( sessionLocation, createHttpPayload( serialize(\n                run( \"UNWIND [1,2,3] AS a RETURN a, a * a AS a_squared\" ),\n                pullAll() )));\n\n        // Then\n        assertThat( messages( rs.rawContent() ), equalTo( asList(\n                success( map( \"fields\", asList(\"a\", \"a_squared\") ) ),\n                Messages.record( record( 1l, 1l ) ),\n                Messages.record( record( 2l, 4l ) ),\n                Messages.record( record( 3l, 9l ) ),\n                success( map() )\n        ) ) );\n    }","commit_id":"9782d06d4ce3c23cf8bbc083662d83cb59ef8518","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldBeAbleToSendMultipleHttpRequests() throws Throwable\n    {\n        // Given\n        HTTP.Response rs = http.POST( \"/session/\" );\n        String sessionLocation = rs.location();\n\n        // Given I've sent one slew of messages\n        http.POST( sessionLocation, messages(\n                run( \"UNWIND [1,2,3] AS a RETURN a, a * a AS a_squared\" ),\n                pullAll() ) );\n\n        // When I send a second slew of messages\n        rs = http.POST( sessionLocation, messages(\n                run( \"UNWIND [1,2,3] AS a RETURN a, a * a AS a_squared\" ),\n                pullAll() ) );\n\n        // Then\n        assertThat( messages( rs ), equalTo( asList(\n                success( map( \"fields\", asList(\"a\", \"a_squared\") ) ),\n\n                Messages.record( record( 1l, 1l ) ),\n                Messages.record( record( 2l, 4l ) ),\n                Messages.record( record( 3l, 9l ) ),\n                success( map() )\n        ) ) );\n    }","id":23064,"modified_method":"@Test\n    public void shouldBeAbleToSendMultipleHttpRequests() throws Throwable\n    {\n        // Given\n        HTTP.Response rs = http.POST( \"/session/\" );\n        String sessionLocation = rs.location();\n\n        // Given I've sent one slew of messages\n        http.POST( sessionLocation,  createHttpPayload( serialize(\n                run( \"UNWIND [1,2,3] AS a RETURN a, a * a AS a_squared\" ),\n                pullAll() )));\n\n        // When I send a second slew of messages\n        rs = http.POST( sessionLocation, createHttpPayload( serialize(\n                run( \"UNWIND [1,2,3] AS a RETURN a, a * a AS a_squared\" ),\n                pullAll() )));\n\n        // Then\n        assertThat( messages( rs.rawContent() ), equalTo( asList(\n                success( map( \"fields\", asList(\"a\", \"a_squared\") ) ),\n\n                Messages.record( record( 1l, 1l ) ),\n                Messages.record( record( 2l, 4l ) ),\n                Messages.record( record( 3l, 9l ) ),\n                success( map() )\n        ) ) );\n    }","commit_id":"9782d06d4ce3c23cf8bbc083662d83cb59ef8518","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldBeAbleToSendStringArrayParameters() throws Throwable\n    {\n        // Given\n        HTTP.Response rs = http.POST( \"/session/\" );\n        String sessionLocation = rs.location();\n\n        // Given I've sent one slew of messages\n        String[] arrayValue = new String[]{\"Mjlnir\", \"Mjlnir\", \"Mjlnir\"};\n        rs = http.POST( sessionLocation, messages(\n                run(\"CREATE (a {value:{value}}) RETURN a.value\", map( \"value\", arrayValue ) ),\n                pullAll() ) );\n\n        // Then\n        assertThat( messages( rs ), equalsMessages(\n                msgSuccess(),\n\n                msgItem( StreamMatchers.record( equalTo(asList( arrayValue )) )),\n                msgSuccess()\n        ) );\n    }","id":23065,"modified_method":"@Test\n    public void shouldBeAbleToSendStringArrayParameters() throws Throwable\n    {\n        // Given\n        HTTP.Response rs = http.POST( \"/session/\" );\n        String sessionLocation = rs.location();\n\n        // Given I've sent one slew of messages\n        String[] arrayValue = new String[]{\"Mjlnir\", \"Mjlnir\", \"Mjlnir\"};\n        rs = http.POST( sessionLocation,  createHttpPayload( serialize(\n                run(\"CREATE (a {value:{value}}) RETURN a.value\", map( \"value\", arrayValue ) ),\n                pullAll() )));\n\n        // Then\n        assertThat( messages( rs.rawContent() ), equalsMessages(\n                msgSuccess(),\n\n                msgItem( StreamMatchers.record( equalTo(asList( arrayValue )) )),\n                msgSuccess()\n        ) );\n    }","commit_id":"9782d06d4ce3c23cf8bbc083662d83cb59ef8518","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void post( final HttpServerExchange exchange, String sessionKey )\n    {\n        SessionAcquisition acquisition = sessionRegistry.acquire( sessionKey );\n        if ( acquisition.success() )\n        {\n            exchange.setResponseCode( StatusCodes.OK );\n            exchange.getResponseHeaders().add( Headers.CONTENT_TYPE, PackStreamMessageFormatV1.CONTENT_TYPE );\n\n            processorForSession( exchange, acquisition.session() )\n                    .process( endExchangeCallback( exchange ) );\n        }\n        else if ( acquisition.sessionExists() )\n        {\n            exchange.setResponseCode( StatusCodes.CONFLICT );\n            exchange.endExchange();\n        }\n        else\n        {\n            exchange.setResponseCode( StatusCodes.NOT_FOUND );\n            exchange.endExchange();\n        }\n    }","id":23066,"modified_method":"private void post( final HttpServerExchange exchange, String sessionKey )\n    {\n        SessionAcquisition acquisition = sessionRegistry.acquire( sessionKey );\n        if ( acquisition.success() )\n        {\n            exchange.setResponseCode( StatusCodes.OK );\n            exchange.getResponseHeaders().add( Headers.CONTENT_TYPE, PackStreamMessageFormatV1.CONTENT_TYPE );\n\n            processorForSession( exchange, acquisition.session() )\n                    .process( onAllMessagesProcessed( exchange, acquisition.session() ) );\n        }\n        else if ( acquisition.sessionExists() )\n        {\n            exchange.setResponseCode( StatusCodes.CONFLICT );\n            exchange.endExchange();\n        }\n        else\n        {\n            exchange.setResponseCode( StatusCodes.NOT_FOUND );\n            exchange.endExchange();\n        }\n    }","commit_id":"9782d06d4ce3c23cf8bbc083662d83cb59ef8518","url":"https://github.com/neo4j/neo4j"},{"original_method":"private ChannelMessageProcessor processorForSession( HttpServerExchange exchange, Session session )\n    {\n        // TODO: move sessionRegistry to store processors instead\n        return new ChannelMessageProcessor(log, sessionRegistry)\n                .reset( exchange.getRequestChannel(), exchange.getResponseChannel(), session );\n    }","id":23067,"modified_method":"private ChannelMessageProcessor processorForSession( HttpServerExchange exchange, Session session )\n    {\n        return new ChannelMessageProcessor(log, new Consumer<Session>()\n        {\n            @Override\n            public void accept( Session session )\n            {\n                sessionRegistry.destroy( session.key() );\n            }\n        }).reset( exchange.getRequestChannel(), exchange.getResponseChannel(), session );\n    }","commit_id":"9782d06d4ce3c23cf8bbc083662d83cb59ef8518","url":"https://github.com/neo4j/neo4j"},{"original_method":"private WebXml getDefaultWebXmlFragment() {\n\n        // Host should never be null\n        Host host = (Host) context.getParent();\n\n        DefaultWebXmlCacheEntry entry = hostWebXmlCache.get(host);\n\n        InputSource globalWebXml = getGlobalWebXmlSource();\n        InputSource hostWebXml = getHostWebXmlSource();\n\n        long globalTimeStamp = 0;\n        long hostTimeStamp = 0;\n\n        if (globalWebXml != null) {\n            try {\n                URL url = new URL(globalWebXml.getSystemId());\n                globalTimeStamp = url.openConnection().getLastModified();\n            } catch (MalformedURLException e) {\n                globalTimeStamp = -1;\n            } catch (IOException e) {\n                globalTimeStamp = -1;\n            }\n        }\n\n        if (hostWebXml != null) {\n            try {\n                URL url = new URL(hostWebXml.getSystemId());\n                hostTimeStamp = url.openConnection().getLastModified();\n            } catch (MalformedURLException e) {\n                hostTimeStamp = -1;\n            } catch (IOException e) {\n                hostTimeStamp = -1;\n            }\n        }\n\n        if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp &&\n                entry.getHostTimeStamp() == hostTimeStamp) {\n            return entry.getWebXml();\n        }\n\n        // Parsing global web.xml is relatively expensive. Use a sync block to\n        // make sure it only happens once. Use the pipeline since a lock will\n        // already be held on the host by another thread\n        synchronized (host.getPipeline()) {\n            entry = hostWebXmlCache.get(host);\n            if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp &&\n                    entry.getHostTimeStamp() == hostTimeStamp) {\n                return entry.getWebXml();\n            }\n\n            WebXml webXmlDefaultFragment = createWebXml();\n            webXmlDefaultFragment.setOverridable(true);\n            // Set to distributable else every app will be prevented from being\n            // distributable when the default fragment is merged with the main\n            // web.xml\n            webXmlDefaultFragment.setDistributable(true);\n            // When merging, the default welcome files are only used if the app has\n            // not defined any welcomes files.\n            webXmlDefaultFragment.setAlwaysAddWelcomeFiles(false);\n\n            // Parse global web.xml if present\n            if (globalWebXml == null) {\n                // This is unusual enough to log\n                log.info(sm.getString(\"contextConfig.defaultMissing\"));\n            } else {\n                parseWebXml(globalWebXml, webXmlDefaultFragment, false);\n            }\n\n            // Parse host level web.xml if present\n            // Additive apart from welcome pages\n            webXmlDefaultFragment.setReplaceWelcomeFiles(true);\n\n            parseWebXml(hostWebXml, webXmlDefaultFragment, false);\n\n            // Don't update the cache if an error occurs\n            if (globalTimeStamp != -1 && hostTimeStamp != -1) {\n                entry = new DefaultWebXmlCacheEntry(webXmlDefaultFragment,\n                        globalTimeStamp, hostTimeStamp);\n                hostWebXmlCache.put(host, entry);\n            }\n\n            return webXmlDefaultFragment;\n        }\n    }","id":23068,"modified_method":"private WebXml getDefaultWebXmlFragment() {\n\n        // Host should never be null\n        Host host = (Host) context.getParent();\n\n        DefaultWebXmlCacheEntry entry = hostWebXmlCache.get(host);\n\n        InputSource globalWebXml = getGlobalWebXmlSource();\n        InputSource hostWebXml = getHostWebXmlSource();\n\n        long globalTimeStamp = 0;\n        long hostTimeStamp = 0;\n\n        if (globalWebXml != null) {\n            try {\n                URL url = new URL(globalWebXml.getSystemId());\n                globalTimeStamp = url.openConnection().getLastModified();\n            } catch (MalformedURLException e) {\n                globalTimeStamp = -1;\n            } catch (IOException e) {\n                globalTimeStamp = -1;\n            }\n        }\n\n        if (hostWebXml != null) {\n            try {\n                URL url = new URL(hostWebXml.getSystemId());\n                hostTimeStamp = url.openConnection().getLastModified();\n            } catch (MalformedURLException e) {\n                hostTimeStamp = -1;\n            } catch (IOException e) {\n                hostTimeStamp = -1;\n            }\n        }\n\n        if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp &&\n                entry.getHostTimeStamp() == hostTimeStamp) {\n            return entry.getWebXml();\n        }\n\n        // Parsing global web.xml is relatively expensive. Use a sync block to\n        // make sure it only happens once. Use the pipeline since a lock will\n        // already be held on the host by another thread\n        synchronized (host.getPipeline()) {\n            entry = hostWebXmlCache.get(host);\n            if (entry != null && entry.getGlobalTimeStamp() == globalTimeStamp &&\n                    entry.getHostTimeStamp() == hostTimeStamp) {\n                return entry.getWebXml();\n            }\n\n            WebXml webXmlDefaultFragment = createWebXml();\n            webXmlDefaultFragment.setOverridable(true);\n            // Set to distributable else every app will be prevented from being\n            // distributable when the default fragment is merged with the main\n            // web.xml\n            webXmlDefaultFragment.setDistributable(true);\n            // When merging, the default welcome files are only used if the app has\n            // not defined any welcomes files.\n            webXmlDefaultFragment.setAlwaysAddWelcomeFiles(false);\n\n            // Parse global web.xml if present\n            if (globalWebXml == null) {\n                // This is unusual enough to log\n                log.info(sm.getString(\"contextConfig.defaultMissing\"));\n            } else {\n                if (!webXmlParser.parseWebXml(\n                        globalWebXml, webXmlDefaultFragment, false)) {\n                    ok = false;\n                }\n            }\n\n            // Parse host level web.xml if present\n            // Additive apart from welcome pages\n            webXmlDefaultFragment.setReplaceWelcomeFiles(true);\n\n            if (!webXmlParser.parseWebXml(\n                    hostWebXml, webXmlDefaultFragment, false)) {\n                ok = false;\n            }\n\n            // Don't update the cache if an error occurs\n            if (globalTimeStamp != -1 && hostTimeStamp != -1) {\n                entry = new DefaultWebXmlCacheEntry(webXmlDefaultFragment,\n                        globalTimeStamp, hostTimeStamp);\n                hostWebXmlCache.put(host, entry);\n            }\n\n            return webXmlDefaultFragment;\n        }\n    }","commit_id":"e1db24b75a1c38307b31d0b32ca65ebb71c03c94","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        public void scan(File file, boolean isWebapp) throws IOException {\n\n            InputStream stream = null;\n            WebXml fragment = new WebXml();\n\n            try {\n                File fragmentFile = new File(file, FRAGMENT_LOCATION);\n                if (fragmentFile.isFile()) {\n                    stream = new FileInputStream(fragmentFile);\n                    InputSource source =\n                        new InputSource(fragmentFile.toURI().toURL().toString());\n                    source.setByteStream(stream);\n                    parseWebXml(source, fragment, true);\n                } else {\n                    // If there is no web.xml, normal folder no impact on\n                    // distributable\n                    fragment.setDistributable(true);\n                }\n            } finally {\n                fragment.setURL(file.toURI().toURL());\n                if (fragment.getName() == null) {\n                    fragment.setName(fragment.getURL().toString());\n                }\n                fragment.setJarName(file.getName());\n                fragments.put(fragment.getName(), fragment);\n            }\n        }","id":23069,"modified_method":"@Override\n        public void scan(File file, boolean isWebapp) throws IOException {\n\n            InputStream stream = null;\n            WebXml fragment = new WebXml();\n\n            try {\n                File fragmentFile = new File(file, FRAGMENT_LOCATION);\n                if (fragmentFile.isFile()) {\n                    stream = new FileInputStream(fragmentFile);\n                    InputSource source =\n                        new InputSource(fragmentFile.toURI().toURL().toString());\n                    source.setByteStream(stream);\n                    if (!webXmlParser.parseWebXml(source, fragment, true)) {\n                        ok = false;\n                    }\n                } else {\n                    // If there is no web.xml, normal folder no impact on\n                    // distributable\n                    fragment.setDistributable(true);\n                }\n            } finally {\n                fragment.setURL(file.toURI().toURL());\n                if (fragment.getName() == null) {\n                    fragment.setName(fragment.getURL().toString());\n                }\n                fragment.setJarName(file.getName());\n                fragments.put(fragment.getName(), fragment);\n            }\n        }","commit_id":"e1db24b75a1c38307b31d0b32ca65ebb71c03c94","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        public void scan(JarURLConnection jarConn, boolean isWebapp)\n                throws IOException {\n\n            URL url = jarConn.getURL();\n            URL resourceURL = jarConn.getJarFileURL();\n            Jar jar = null;\n            InputStream is = null;\n            WebXml fragment = new WebXml();\n\n            fragment.setWebappJar(isWebapp);\n            if (context instanceof StandardContext) {\n                fragment.setDelegate(((StandardContext) context).getDelegate());\n            }\n\n            try {\n                // Only web application JARs are checked for web-fragment.xml\n                // files\n                if (isWebapp) {\n                    jar = JarFactory.newInstance(url);\n                    is = jar.getInputStream(FRAGMENT_LOCATION);\n                }\n\n                if (is == null) {\n                    // If there is no web.xml, normal JAR no impact on\n                    // distributable\n                    fragment.setDistributable(true);\n                } else {\n                    InputSource source = new InputSource(\n                            resourceURL.toString() + \"!/\" + FRAGMENT_LOCATION);\n                    source.setByteStream(is);\n                    parseWebXml(source, fragment, true);\n                }\n            } finally {\n                if (jar != null) {\n                    jar.close();\n                }\n                fragment.setURL(url);\n                if (fragment.getName() == null) {\n                    fragment.setName(fragment.getURL().toString());\n                }\n                fragment.setJarName(extractJarFileName(url));\n                fragments.put(fragment.getName(), fragment);\n            }\n        }","id":23070,"modified_method":"@Override\n        public void scan(JarURLConnection jarConn, boolean isWebapp)\n                throws IOException {\n\n            URL url = jarConn.getURL();\n            URL resourceURL = jarConn.getJarFileURL();\n            Jar jar = null;\n            InputStream is = null;\n            WebXml fragment = new WebXml();\n\n            fragment.setWebappJar(isWebapp);\n            if (context instanceof StandardContext) {\n                fragment.setDelegate(((StandardContext) context).getDelegate());\n            }\n\n            try {\n                // Only web application JARs are checked for web-fragment.xml\n                // files\n                if (isWebapp) {\n                    jar = JarFactory.newInstance(url);\n                    is = jar.getInputStream(FRAGMENT_LOCATION);\n                }\n\n                if (is == null) {\n                    // If there is no web.xml, normal JAR no impact on\n                    // distributable\n                    fragment.setDistributable(true);\n                } else {\n                    InputSource source = new InputSource(\n                            resourceURL.toString() + \"!/\" + FRAGMENT_LOCATION);\n                    source.setByteStream(is);\n                    if (!webXmlParser.parseWebXml(source, fragment, true)) {\n                        ok = false;\n                    }\n                }\n            } finally {\n                if (jar != null) {\n                    jar.close();\n                }\n                fragment.setURL(url);\n                if (fragment.getName() == null) {\n                    fragment.setName(fragment.getURL().toString());\n                }\n                fragment.setJarName(extractJarFileName(url));\n                fragments.put(fragment.getName(), fragment);\n            }\n        }","commit_id":"e1db24b75a1c38307b31d0b32ca65ebb71c03c94","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Scan the web.xml files that apply to the web application and merge them\n     * using the rules defined in the spec. For the global web.xml files,\n     * where there is duplicate configuration, the most specific level wins. ie\n     * an application's web.xml takes precedence over the host level or global\n     * web.xml file.\n     */\n    protected void webConfig() {\n        /*\n         * Anything and everything can override the global and host defaults.\n         * This is implemented in two parts\n         * - Handle as a web fragment that gets added after everything else so\n         *   everything else takes priority\n         * - Mark Servlets as overridable so SCI configuration can replace\n         *   configuration from the defaults\n         */\n\n        /*\n         * The rules for annotation scanning are not as clear-cut as one might\n         * think. Tomcat implements the following process:\n         * - As per SRV.1.6.2, Tomcat will scan for annotations regardless of\n         *   which Servlet spec version is declared in web.xml. The EG has\n         *   confirmed this is the expected behaviour.\n         * - As per http://java.net/jira/browse/SERVLET_SPEC-36, if the main\n         *   web.xml is marked as metadata-complete, JARs are still processed\n         *   for SCIs.\n         * - If metadata-complete=true and an absolute ordering is specified,\n         *   JARs excluded from the ordering are also excluded from the SCI\n         *   processing.\n         * - If an SCI has a @HandlesType annotation then all classes (except\n         *   those in JARs excluded from an absolute ordering) need to be\n         *   scanned to check if they match.\n         */\n        Set<WebXml> defaults = new HashSet<>();\n        defaults.add(getDefaultWebXmlFragment());\n\n        WebXml webXml = createWebXml();\n\n        // Parse context level web.xml\n        InputSource contextWebXml = getContextWebXmlSource();\n        parseWebXml(contextWebXml, webXml, false);\n\n        ServletContext sContext = context.getServletContext();\n\n        // Ordering is important here\n\n        // Step 1. Identify all the JARs packaged with the application and those\n        // provided by the container. If any of the application JARs have a\n        // web-fragment.xml it will be parsed at this point. web-fragment.xml\n        // files are ignored for container provided JARs.\n        Map<String,WebXml> fragments = processJarsForWebFragments();\n\n        // Step 2. Order the fragments.\n        Set<WebXml> orderedFragments = null;\n        orderedFragments =\n                WebXml.orderWebFragments(webXml, fragments, sContext);\n\n        // Step 3. Look for ServletContainerInitializer implementations\n        if (ok) {\n            processServletContainerInitializers(orderedFragments);\n        }\n\n        if  (!webXml.isMetadataComplete() || typeInitializerMap.size() > 0) {\n            // Step 4. Process /WEB-INF/classes for annotations\n            if (ok) {\n                WebResource[] webResources =\n                        context.getResources().listResources(\"/WEB-INF/classes\");\n\n                for (WebResource webResource : webResources) {\n                    processAnnotationsWebResource(webResource, webXml,\n                            webXml.isMetadataComplete());\n                }\n            }\n\n            // Step 5. Process JARs for annotations - only need to process\n            // those fragments we are going to use\n            if (ok) {\n                processAnnotations(\n                        orderedFragments, webXml.isMetadataComplete());\n            }\n\n            // Cache, if used, is no longer required so clear it\n            javaClassCache.clear();\n        }\n\n        if (!webXml.isMetadataComplete()) {\n            // Step 6. Merge web-fragment.xml files into the main web.xml\n            // file.\n            if (ok) {\n                ok = webXml.merge(orderedFragments);\n            }\n\n            // Step 7. Apply global defaults\n            // Have to merge defaults before JSP conversion since defaults\n            // provide JSP servlet definition.\n            webXml.merge(defaults);\n\n            // Step 8. Convert explicitly mentioned jsps to servlets\n            if (ok) {\n                convertJsps(webXml);\n            }\n\n            // Step 9. Apply merged web.xml to Context\n            if (ok) {\n                configureContext(webXml);\n            }\n        } else {\n            webXml.merge(defaults);\n            convertJsps(webXml);\n            configureContext(webXml);\n        }\n\n        // Step 9a. Make the merged web.xml available to other\n        // components, specifically Jasper, to save those components\n        // from having to re-generate it.\n        // TODO Use a ServletContainerInitializer for Jasper\n        String mergedWebXml = webXml.toXml();\n        sContext.setAttribute(\n               org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML,\n               mergedWebXml);\n        if (context.getLogEffectiveWebXml()) {\n            log.info(\"web.xml:\\n\" + mergedWebXml);\n        }\n\n        // Always need to look for static resources\n        // Step 10. Look for static resources packaged in JARs\n        if (ok) {\n            // Spec does not define an order.\n            // Use ordered JARs followed by remaining JARs\n            Set<WebXml> resourceJars = new LinkedHashSet<>();\n            if (orderedFragments != null) {\n                for (WebXml fragment : orderedFragments) {\n                    resourceJars.add(fragment);\n                }\n            }\n            for (WebXml fragment : fragments.values()) {\n                if (!resourceJars.contains(fragment)) {\n                    resourceJars.add(fragment);\n                }\n            }\n            processResourceJARs(resourceJars);\n            // See also StandardContext.resourcesStart() for\n            // WEB-INF/classes/META-INF/resources configuration\n        }\n\n        // Step 11. Apply the ServletContainerInitializer config to the\n        // context\n        if (ok) {\n            for (Map.Entry<ServletContainerInitializer,\n                    Set<Class<?>>> entry :\n                        initializerClassMap.entrySet()) {\n                if (entry.getValue().isEmpty()) {\n                    context.addServletContainerInitializer(\n                            entry.getKey(), null);\n                } else {\n                    context.addServletContainerInitializer(\n                            entry.getKey(), entry.getValue());\n                }\n            }\n        }\n    }","id":23071,"modified_method":"/**\n     * Scan the web.xml files that apply to the web application and merge them\n     * using the rules defined in the spec. For the global web.xml files,\n     * where there is duplicate configuration, the most specific level wins. ie\n     * an application's web.xml takes precedence over the host level or global\n     * web.xml file.\n     */\n    protected void webConfig() {\n        /*\n         * Anything and everything can override the global and host defaults.\n         * This is implemented in two parts\n         * - Handle as a web fragment that gets added after everything else so\n         *   everything else takes priority\n         * - Mark Servlets as overridable so SCI configuration can replace\n         *   configuration from the defaults\n         */\n\n        /*\n         * The rules for annotation scanning are not as clear-cut as one might\n         * think. Tomcat implements the following process:\n         * - As per SRV.1.6.2, Tomcat will scan for annotations regardless of\n         *   which Servlet spec version is declared in web.xml. The EG has\n         *   confirmed this is the expected behaviour.\n         * - As per http://java.net/jira/browse/SERVLET_SPEC-36, if the main\n         *   web.xml is marked as metadata-complete, JARs are still processed\n         *   for SCIs.\n         * - If metadata-complete=true and an absolute ordering is specified,\n         *   JARs excluded from the ordering are also excluded from the SCI\n         *   processing.\n         * - If an SCI has a @HandlesType annotation then all classes (except\n         *   those in JARs excluded from an absolute ordering) need to be\n         *   scanned to check if they match.\n         */\n        Set<WebXml> defaults = new HashSet<>();\n        defaults.add(getDefaultWebXmlFragment());\n\n        WebXml webXml = createWebXml();\n\n        // Parse context level web.xml\n        InputSource contextWebXml = getContextWebXmlSource();\n        if (!webXmlParser.parseWebXml(contextWebXml, webXml, false)) {\n            ok = false;\n        }\n\n        ServletContext sContext = context.getServletContext();\n\n        // Ordering is important here\n\n        // Step 1. Identify all the JARs packaged with the application and those\n        // provided by the container. If any of the application JARs have a\n        // web-fragment.xml it will be parsed at this point. web-fragment.xml\n        // files are ignored for container provided JARs.\n        Map<String,WebXml> fragments = processJarsForWebFragments();\n\n        // Step 2. Order the fragments.\n        Set<WebXml> orderedFragments = null;\n        orderedFragments =\n                WebXml.orderWebFragments(webXml, fragments, sContext);\n\n        // Step 3. Look for ServletContainerInitializer implementations\n        if (ok) {\n            processServletContainerInitializers(orderedFragments);\n        }\n\n        if  (!webXml.isMetadataComplete() || typeInitializerMap.size() > 0) {\n            // Step 4. Process /WEB-INF/classes for annotations\n            if (ok) {\n                WebResource[] webResources =\n                        context.getResources().listResources(\"/WEB-INF/classes\");\n\n                for (WebResource webResource : webResources) {\n                    processAnnotationsWebResource(webResource, webXml,\n                            webXml.isMetadataComplete());\n                }\n            }\n\n            // Step 5. Process JARs for annotations - only need to process\n            // those fragments we are going to use\n            if (ok) {\n                processAnnotations(\n                        orderedFragments, webXml.isMetadataComplete());\n            }\n\n            // Cache, if used, is no longer required so clear it\n            javaClassCache.clear();\n        }\n\n        if (!webXml.isMetadataComplete()) {\n            // Step 6. Merge web-fragment.xml files into the main web.xml\n            // file.\n            if (ok) {\n                ok = webXml.merge(orderedFragments);\n            }\n\n            // Step 7. Apply global defaults\n            // Have to merge defaults before JSP conversion since defaults\n            // provide JSP servlet definition.\n            webXml.merge(defaults);\n\n            // Step 8. Convert explicitly mentioned jsps to servlets\n            if (ok) {\n                convertJsps(webXml);\n            }\n\n            // Step 9. Apply merged web.xml to Context\n            if (ok) {\n                configureContext(webXml);\n            }\n        } else {\n            webXml.merge(defaults);\n            convertJsps(webXml);\n            configureContext(webXml);\n        }\n\n        // Step 9a. Make the merged web.xml available to other\n        // components, specifically Jasper, to save those components\n        // from having to re-generate it.\n        // TODO Use a ServletContainerInitializer for Jasper\n        String mergedWebXml = webXml.toXml();\n        sContext.setAttribute(\n               org.apache.tomcat.util.scan.Constants.MERGED_WEB_XML,\n               mergedWebXml);\n        if (context.getLogEffectiveWebXml()) {\n            log.info(\"web.xml:\\n\" + mergedWebXml);\n        }\n\n        // Always need to look for static resources\n        // Step 10. Look for static resources packaged in JARs\n        if (ok) {\n            // Spec does not define an order.\n            // Use ordered JARs followed by remaining JARs\n            Set<WebXml> resourceJars = new LinkedHashSet<>();\n            if (orderedFragments != null) {\n                for (WebXml fragment : orderedFragments) {\n                    resourceJars.add(fragment);\n                }\n            }\n            for (WebXml fragment : fragments.values()) {\n                if (!resourceJars.contains(fragment)) {\n                    resourceJars.add(fragment);\n                }\n            }\n            processResourceJARs(resourceJars);\n            // See also StandardContext.resourcesStart() for\n            // WEB-INF/classes/META-INF/resources configuration\n        }\n\n        // Step 11. Apply the ServletContainerInitializer config to the\n        // context\n        if (ok) {\n            for (Map.Entry<ServletContainerInitializer,\n                    Set<Class<?>>> entry :\n                        initializerClassMap.entrySet()) {\n                if (entry.getValue().isEmpty()) {\n                    context.addServletContainerInitializer(\n                            entry.getKey(), null);\n                } else {\n                    context.addServletContainerInitializer(\n                            entry.getKey(), entry.getValue());\n                }\n            }\n        }\n    }","commit_id":"e1db24b75a1c38307b31d0b32ca65ebb71c03c94","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Process a \"init\" event for this Context.\n     */\n    protected void init() {\n        // Called from StandardContext.init()\n\n        Digester contextDigester = createContextDigester();\n        contextDigester.getParser();\n\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"contextConfig.init\"));\n        }\n        context.setConfigured(false);\n        ok = true;\n\n        contextConfig(contextDigester);\n\n        createWebXmlDigester(context.getXmlNamespaceAware(),\n                context.getXmlValidation());\n    }","id":23072,"modified_method":"/**\n     * Process a \"init\" event for this Context.\n     */\n    protected void init() {\n        // Called from StandardContext.init()\n\n        Digester contextDigester = createContextDigester();\n        contextDigester.getParser();\n\n        if (log.isDebugEnabled()) {\n            log.debug(sm.getString(\"contextConfig.init\"));\n        }\n        context.setConfigured(false);\n        ok = true;\n\n        contextConfig(contextDigester);\n\n        webXmlParser = new WebXmlParser(context.getXmlNamespaceAware(),\n                context.getXmlValidation());\n    }","commit_id":"e1db24b75a1c38307b31d0b32ca65ebb71c03c94","url":"https://github.com/apache/tomcat"},{"original_method":"protected NeoStore getNeoStore()\n    {\n        return neoStore;\n    }","id":23073,"modified_method":"protected NeoStore getNeoStore()\n    {\n        return neoStore.evaluate();\n    }","commit_id":"4b36b64a6f325f2c8d2634a285b2cbd97c52048d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public DatabasePrimitivesSampleableBase( NeoStore neoStore )\n    {\n        if( neoStore == null )\n        {\n            throw new RuntimeException( \"Database sampler needs a node manager to work, was given null.\" );\n        }\n        this.neoStore = neoStore;\n\n    }","id":23074,"modified_method":"public DatabasePrimitivesSampleableBase( NeoStoreProvider neoStore )\n    {\n        if( neoStore == null )\n        {\n            throw new RuntimeException( \"Database sampler needs a NeoStore to work, was given null.\" );\n        }\n        this.neoStore = neoStore;\n\n    }","commit_id":"4b36b64a6f325f2c8d2634a285b2cbd97c52048d","url":"https://github.com/neo4j/neo4j"},{"original_method":"private NeoStore neoStore( GraphDatabaseAPI db )\n    {\n        return db.getDependencyResolver().resolveDependency( NeoStoreProvider.class ).evaluate();\n    }","id":23075,"modified_method":"private NeoStoreProvider neoStore( GraphDatabaseAPI db )\n    {\n        return db.getDependencyResolver().resolveDependency( NeoStoreProvider.class );\n    }","commit_id":"4b36b64a6f325f2c8d2634a285b2cbd97c52048d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public NodeIdsInUseSampleable( NeoStore neoStore )\n    {\n        super( neoStore );\n    }","id":23076,"modified_method":"public NodeIdsInUseSampleable( NeoStoreProvider neoStore )\n    {\n        super( neoStore );\n    }","commit_id":"4b36b64a6f325f2c8d2634a285b2cbd97c52048d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setUp() throws Exception\n    {\n        db = (GraphDatabaseAPI) new TestGraphDatabaseFactory().newImpermanentDatabase();\n        DependencyResolver dependencyResolver = db.getDependencyResolver();\n        sampleable = new NodeIdsInUseSampleable( dependencyResolver.resolveDependency( NeoStoreProvider.class ).evaluate() );\n    }","id":23077,"modified_method":"@Before\n    public void setUp() throws Exception\n    {\n        db = (GraphDatabaseAPI) new TestGraphDatabaseFactory().newImpermanentDatabase();\n        DependencyResolver dependencyResolver = db.getDependencyResolver();\n        sampleable = new NodeIdsInUseSampleable( dependencyResolver.resolveDependency( NeoStoreProvider.class ) );\n    }","commit_id":"4b36b64a6f325f2c8d2634a285b2cbd97c52048d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public PropertyCountSampleable( NeoStore neoStore )\n    {\n        super( neoStore );\n    }","id":23078,"modified_method":"public PropertyCountSampleable( NeoStoreProvider neoStore )\n    {\n        super( neoStore );\n    }","commit_id":"4b36b64a6f325f2c8d2634a285b2cbd97c52048d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setupReferenceNode()\n    {\n        db = new WrappedDatabase( (InternalAbstractGraphDatabase) new TestGraphDatabaseFactory().newImpermanentDatabase() );\n        DependencyResolver dependencyResolver = db.getGraph().getDependencyResolver();\n        sampleable = new PropertyCountSampleable( dependencyResolver.resolveDependency( NeoStoreProvider.class ).evaluate() );\n\n        Transaction tx = db.getGraph().beginTx();\n        referenceNodeId = db.getGraph().createNode().getId();\n        tx.success();\n        tx.finish();\n    }","id":23079,"modified_method":"@Before\n    public void setupReferenceNode()\n    {\n        db = new WrappedDatabase( (InternalAbstractGraphDatabase) new TestGraphDatabaseFactory().newImpermanentDatabase() );\n        DependencyResolver dependencyResolver = db.getGraph().getDependencyResolver();\n        sampleable = new PropertyCountSampleable( dependencyResolver.resolveDependency( NeoStoreProvider.class ) );\n\n        Transaction tx = db.getGraph().beginTx();\n        referenceNodeId = db.getGraph().createNode().getId();\n        tx.success();\n        tx.finish();\n    }","commit_id":"4b36b64a6f325f2c8d2634a285b2cbd97c52048d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public RelationshipCountSampleable( NeoStore neoStore )\n    {\n        super( neoStore );\n    }","id":23080,"modified_method":"public RelationshipCountSampleable( NeoStoreProvider neoStore )\n    {\n        super( neoStore );\n    }","commit_id":"4b36b64a6f325f2c8d2634a285b2cbd97c52048d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setUp() throws Exception\n    {\n        db = (GraphDatabaseAPI)new TestGraphDatabaseFactory().newImpermanentDatabase();\n        sampleable = new RelationshipCountSampleable( db.getDependencyResolver().resolveDependency( NeoStoreProvider.class ).evaluate() );\n    }","id":23081,"modified_method":"@Before\n    public void setUp() throws Exception\n    {\n        db = (GraphDatabaseAPI)new TestGraphDatabaseFactory().newImpermanentDatabase();\n        sampleable = new RelationshipCountSampleable( db.getDependencyResolver().resolveDependency( NeoStoreProvider.class ) );\n    }","commit_id":"4b36b64a6f325f2c8d2634a285b2cbd97c52048d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public org.neo4j.server.database.RrdDbWrapper createRrdDbAndSampler( final Database db, JobScheduler scheduler ) throws IOException\n    {\n        NeoStore neoStore = db.getGraph().getDependencyResolver().resolveDependency( NeoStoreProvider.class ).evaluate();\n\n        Sampleable[] primitives = {\n                new NodeIdsInUseSampleable( neoStore ),\n                new PropertyCountSampleable( neoStore ),\n                new RelationshipCountSampleable( neoStore )\n        };\n\n        Sampleable[] usage = {};\n\n        File rrdFile = config.get( ServerSettings.rrdb_location );\n        if( rrdFile == null || !rrdFile.exists() )\n        {\n            Map<String, String> params = config.getParams();\n            params.put( ServerSettings.rrdb_location.name(), getDefaultRrdFile( db.getGraph() ) );\n            config.applyChanges( params );\n            rrdFile = config.get( ServerSettings.rrdb_location );\n        }\n        \n        final RrdDbWrapper rrdb = createRrdb( rrdFile, isEphemereal( db.getGraph() ), join( primitives, usage ) );\n\n        scheduler.scheduleAtFixedRate(\n                new RrdJob( new RrdSamplerImpl( rrdb.get(), primitives ) ),\n                RRD_THREAD_NAME + \"[primitives]\",\n                SECONDS.toMillis( 0 ),\n                SECONDS.toMillis( 3 )\n        );\n\n        return rrdb;\n    }","id":23082,"modified_method":"public org.neo4j.server.database.RrdDbWrapper createRrdDbAndSampler( final Database db, JobScheduler scheduler ) throws IOException\n    {\n        NeoStoreProvider neoStore = db.getGraph().getDependencyResolver().resolveDependency( NeoStoreProvider.class );\n\n        Sampleable[] primitives = {\n                new NodeIdsInUseSampleable( neoStore ),\n                new PropertyCountSampleable( neoStore ),\n                new RelationshipCountSampleable( neoStore )\n        };\n\n        Sampleable[] usage = {};\n\n        File rrdFile = config.get( ServerSettings.rrdb_location );\n        if( rrdFile == null || !rrdFile.exists() )\n        {\n            Map<String, String> params = config.getParams();\n            params.put( ServerSettings.rrdb_location.name(), getDefaultRrdFile( db.getGraph() ) );\n            config.applyChanges( params );\n            rrdFile = config.get( ServerSettings.rrdb_location );\n        }\n        \n        final RrdDbWrapper rrdb = createRrdb( rrdFile, isEphemereal( db.getGraph() ), join( primitives, usage ) );\n\n        scheduler.scheduleAtFixedRate(\n                new RrdJob( new RrdSamplerImpl( rrdb.get(), primitives ) ),\n                RRD_THREAD_NAME + \"[primitives]\",\n                SECONDS.toMillis( 0 ),\n                SECONDS.toMillis( 3 )\n        );\n\n        return rrdb;\n    }","commit_id":"4b36b64a6f325f2c8d2634a285b2cbd97c52048d","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected boolean addFolder(SyncWatchEvent syncWatchEvent)\n\t\tthrows Exception {\n\n\t\tPath targetFilePath = Paths.get(syncWatchEvent.getFilePathName());\n\n\t\tPath parentTargetFilePath = targetFilePath.getParent();\n\n\t\tSyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\tparentTargetFilePath.toString());\n\n\t\tif ((parentSyncFile == null) ||\n\t\t\t(parentSyncFile.getState() == SyncFile.STATE_ERROR)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!parentSyncFile.isSystem() && (parentSyncFile.getTypePK() == 0)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFileByFileKey(\n\t\t\tFileUtil.getFileKey(targetFilePath), _syncAccountId);\n\n\t\tif (syncFile == null) {\n\t\t\tSyncFileService.addFolderSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\n\t\t\treturn true;\n\t\t}\n\n\t\tPath sourceFilePath = Paths.get(syncFile.getFilePathName());\n\n\t\tif (targetFilePath.equals(sourceFilePath)) {\n\t\t}\n\t\telse if (Files.exists(sourceFilePath)) {\n\t\t\tSyncFileService.addFolderSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\n\t\t\treturn true;\n\t\t}\n\t\telse if (parentTargetFilePath.equals(sourceFilePath.getParent())) {\n\t\t\tif (isPendingTypePK(syncFile)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tSyncFileService.updateFolderSyncFile(\n\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t}\n\t\telse {\n\t\t\tif (isPendingTypePK(syncFile)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tSyncFileService.moveFolderSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(), _syncAccountId,\n\t\t\t\tsyncFile);\n\n\t\t\tPath sourceFileNameFilePath = sourceFilePath.getFileName();\n\n\t\t\tif (!sourceFileNameFilePath.equals(targetFilePath.getFileName())) {\n\t\t\t\tSyncFileService.updateFolderSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t_syncAccountId);\n\n\t\tif (syncAccount.getState() == SyncAccount.STATE_CONNECTED) {\n\t\t\tSyncWatchEvent relatedSyncWatchEvent =\n\t\t\t\tSyncWatchEventService.fetchSyncWatchEvent(\n\t\t\t\t\tSyncWatchEvent.EVENT_TYPE_DELETE,\n\t\t\t\t\tsyncWatchEvent.getFilePathName(),\n\t\t\t\t\tsyncWatchEvent.getTimestamp());\n\n\t\t\tif (relatedSyncWatchEvent != null) {\n\t\t\t\t_processedSyncWatchEventIds.add(\n\t\t\t\t\trelatedSyncWatchEvent.getSyncWatchEventId());\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}","id":23083,"modified_method":"protected boolean addFolder(SyncWatchEvent syncWatchEvent)\n\t\tthrows Exception {\n\n\t\tPath targetFilePath = Paths.get(syncWatchEvent.getFilePathName());\n\n\t\tif (isInErrorState(targetFilePath)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tPath parentTargetFilePath = targetFilePath.getParent();\n\n\t\tSyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\tparentTargetFilePath.toString());\n\n\t\tif ((parentSyncFile == null) ||\n\t\t\t(!parentSyncFile.isSystem() &&\n\t\t\t (parentSyncFile.getTypePK() == 0))) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFileByFileKey(\n\t\t\tFileUtil.getFileKey(targetFilePath), _syncAccountId);\n\n\t\tif (syncFile == null) {\n\t\t\tSyncFileService.addFolderSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\n\t\t\treturn true;\n\t\t}\n\n\t\tPath sourceFilePath = Paths.get(syncFile.getFilePathName());\n\n\t\tif (targetFilePath.equals(sourceFilePath)) {\n\t\t}\n\t\telse if (Files.exists(sourceFilePath)) {\n\t\t\tSyncFileService.addFolderSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\n\t\t\treturn true;\n\t\t}\n\t\telse if (parentTargetFilePath.equals(sourceFilePath.getParent())) {\n\t\t\tif (isPendingTypePK(syncFile)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tSyncFileService.updateFolderSyncFile(\n\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t}\n\t\telse {\n\t\t\tif (isPendingTypePK(syncFile)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tSyncFileService.moveFolderSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(), _syncAccountId,\n\t\t\t\tsyncFile);\n\n\t\t\tPath sourceFileNameFilePath = sourceFilePath.getFileName();\n\n\t\t\tif (!sourceFileNameFilePath.equals(targetFilePath.getFileName())) {\n\t\t\t\tSyncFileService.updateFolderSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t_syncAccountId);\n\n\t\tif (syncAccount.getState() == SyncAccount.STATE_CONNECTED) {\n\t\t\tSyncWatchEvent relatedSyncWatchEvent =\n\t\t\t\tSyncWatchEventService.fetchSyncWatchEvent(\n\t\t\t\t\tSyncWatchEvent.EVENT_TYPE_DELETE,\n\t\t\t\t\tsyncWatchEvent.getFilePathName(),\n\t\t\t\t\tsyncWatchEvent.getTimestamp());\n\n\t\t\tif (relatedSyncWatchEvent != null) {\n\t\t\t\t_processedSyncWatchEventIds.add(\n\t\t\t\t\trelatedSyncWatchEvent.getSyncWatchEventId());\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"d164817c937a059e9da32b28a8de006f4f235e36","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean addFile(SyncWatchEvent syncWatchEvent) throws Exception {\n\t\tfinal Path targetFilePath = Paths.get(syncWatchEvent.getFilePathName());\n\n\t\tif (Files.notExists(targetFilePath)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tPath parentTargetFilePath = targetFilePath.getParent();\n\n\t\tfinal SyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\tparentTargetFilePath.toString());\n\n\t\tif ((parentSyncFile == null) ||\n\t\t\t(parentSyncFile.getState() == SyncFile.STATE_ERROR)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!parentSyncFile.isSystem() && (parentSyncFile.getTypePK() == 0)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetFilePath.toString());\n\n\t\tif (syncFile == null) {\n\t\t\tsyncFile = SyncFileService.fetchSyncFileByFileKey(\n\t\t\t\tFileUtil.getFileKey(targetFilePath), _syncAccountId);\n\t\t}\n\n\t\tif (syncFile == null) {\n\t\t\tRunnable runnable = new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t_logger.trace(e.getMessage(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t_executorService.execute(runnable);\n\n\t\t\treturn true;\n\t\t}\n\n\t\tPath sourceFilePath = Paths.get(syncFile.getFilePathName());\n\n\t\tif (targetFilePath.equals(sourceFilePath)) {\n\t\t\tif (isPendingTypePK(syncFile)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (FileUtil.hasFileChanged(syncFile)) {\n\t\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\t\telse if (Files.exists(sourceFilePath)) {\n\t\t\ttry {\n\t\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t_logger.trace(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse if (parentTargetFilePath.equals(sourceFilePath.getParent())) {\n\t\t\tif (isPendingTypePK(syncFile)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t}\n\t\telse {\n\t\t\tif (isPendingTypePK(syncFile)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tSyncFileService.moveFileSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(), _syncAccountId,\n\t\t\t\tsyncFile);\n\n\t\t\tPath sourceFileNameFilePath = sourceFilePath.getFileName();\n\n\t\t\tif (!sourceFileNameFilePath.equals(targetFilePath.getFileName())) {\n\t\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t_syncAccountId);\n\n\t\tif (syncAccount.getState() == SyncAccount.STATE_CONNECTED) {\n\t\t\tSyncWatchEvent relatedSyncWatchEvent =\n\t\t\t\tSyncWatchEventService.fetchSyncWatchEvent(\n\t\t\t\t\tSyncWatchEvent.EVENT_TYPE_DELETE,\n\t\t\t\t\tsyncWatchEvent.getFilePathName(),\n\t\t\t\t\tsyncWatchEvent.getTimestamp());\n\n\t\t\tif (relatedSyncWatchEvent != null) {\n\t\t\t\t_processedSyncWatchEventIds.add(\n\t\t\t\t\trelatedSyncWatchEvent.getSyncWatchEventId());\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}","id":23084,"modified_method":"protected boolean addFile(SyncWatchEvent syncWatchEvent) throws Exception {\n\t\tfinal Path targetFilePath = Paths.get(syncWatchEvent.getFilePathName());\n\n\t\tif (Files.notExists(targetFilePath) || isInErrorState(targetFilePath)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tPath parentTargetFilePath = targetFilePath.getParent();\n\n\t\tfinal SyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\tparentTargetFilePath.toString());\n\n\t\tif ((parentSyncFile == null) ||\n\t\t\t(!parentSyncFile.isSystem() &&\n\t\t\t (parentSyncFile.getTypePK() == 0))) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetFilePath.toString());\n\n\t\tif (syncFile == null) {\n\t\t\tsyncFile = SyncFileService.fetchSyncFileByFileKey(\n\t\t\t\tFileUtil.getFileKey(targetFilePath), _syncAccountId);\n\t\t}\n\n\t\tif (syncFile == null) {\n\t\t\tRunnable runnable = new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t\t\t_logger.trace(e.getMessage(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t_executorService.execute(runnable);\n\n\t\t\treturn true;\n\t\t}\n\n\t\tPath sourceFilePath = Paths.get(syncFile.getFilePathName());\n\n\t\tif (targetFilePath.equals(sourceFilePath)) {\n\t\t\tif (isPendingTypePK(syncFile)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (FileUtil.hasFileChanged(syncFile)) {\n\t\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\t\telse if (Files.exists(sourceFilePath)) {\n\t\t\ttry {\n\t\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\t_logger.trace(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse if (parentTargetFilePath.equals(sourceFilePath.getParent())) {\n\t\t\tif (isPendingTypePK(syncFile)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t}\n\t\telse {\n\t\t\tif (isPendingTypePK(syncFile)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tSyncFileService.moveFileSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(), _syncAccountId,\n\t\t\t\tsyncFile);\n\n\t\t\tPath sourceFileNameFilePath = sourceFilePath.getFileName();\n\n\t\t\tif (!sourceFileNameFilePath.equals(targetFilePath.getFileName())) {\n\t\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t_syncAccountId);\n\n\t\tif (syncAccount.getState() == SyncAccount.STATE_CONNECTED) {\n\t\t\tSyncWatchEvent relatedSyncWatchEvent =\n\t\t\t\tSyncWatchEventService.fetchSyncWatchEvent(\n\t\t\t\t\tSyncWatchEvent.EVENT_TYPE_DELETE,\n\t\t\t\t\tsyncWatchEvent.getFilePathName(),\n\t\t\t\t\tsyncWatchEvent.getTimestamp());\n\n\t\t\tif (relatedSyncWatchEvent != null) {\n\t\t\t\t_processedSyncWatchEventIds.add(\n\t\t\t\t\trelatedSyncWatchEvent.getSyncWatchEventId());\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"d164817c937a059e9da32b28a8de006f4f235e36","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean processPathCallable(PathCallable pathCallable) {\n\t\tFileChannel fileChannel = null;\n\n\t\tFileLock fileLock = null;\n\n\t\ttry {\n\t\t\tPath filePath = pathCallable.getPath();\n\n\t\t\tif (Files.notExists(filePath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (Files.isDirectory(filePath)) {\n\t\t\t\tpathCallable.call();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfileChannel = FileChannel.open(\n\t\t\t\t\tfilePath, StandardOpenOption.READ,\n\t\t\t\t\tStandardOpenOption.WRITE);\n\n\t\t\t\tfileLock = FileUtil.getFileLock(fileChannel);\n\t\t\t}\n\n\t\t\tif (fileLock != null) {\n\t\t\t\tpathCallable.call();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.releaseFileLock(fileLock);\n\n\t\t\tStreamUtil.cleanUp(fileChannel);\n\t\t}\n\n\t\treturn false;\n\t}","id":23085,"modified_method":"public static boolean processPathCallable(PathCallable pathCallable) {\n\t\tFileChannel fileChannel = null;\n\n\t\tFileLock fileLock = null;\n\n\t\ttry {\n\t\t\tPath filePath = pathCallable.getPath();\n\n\t\t\tif ((filePath == null) || Files.notExists(filePath)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (Files.isDirectory(filePath)) {\n\t\t\t\tpathCallable.call();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfileChannel = FileChannel.open(\n\t\t\t\t\tfilePath, StandardOpenOption.READ,\n\t\t\t\t\tStandardOpenOption.WRITE);\n\n\t\t\t\tfileLock = FileUtil.getFileLock(fileChannel);\n\t\t\t}\n\n\t\t\tif (fileLock != null) {\n\t\t\t\tpathCallable.call();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.releaseFileLock(fileLock);\n\n\t\t\tStreamUtil.cleanUp(fileChannel);\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"22ec2e8b63cf80ae234e1fde4bf80bf325c0ddf1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addFile(SyncWatchEvent syncWatchEvent) throws Exception {\n\t\tfinal Path targetFilePath = Paths.get(syncWatchEvent.getFilePathName());\n\n\t\tif (Files.notExists(targetFilePath) ||\n\t\t\tsanitizeFileName(targetFilePath) ||\n\t\t\tisInErrorState(targetFilePath)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tPath parentTargetFilePath = targetFilePath.getParent();\n\n\t\tfinal SyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\tparentTargetFilePath.toString());\n\n\t\tif ((parentSyncFile == null) ||\n\t\t\t(!parentSyncFile.isSystem() && (parentSyncFile.getTypePK() == 0))) {\n\n\t\t\tqueueSyncWatchEvent(\n\t\t\t\tparentTargetFilePath.toString(), syncWatchEvent);\n\n\t\t\treturn;\n\t\t}\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetFilePath.toString());\n\n\t\tif (syncFile == null) {\n\t\t\tsyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\tFileKeyUtil.getFileKey(targetFilePath));\n\n\t\t\tif (!verifySite(syncFile, parentSyncFile)) {\n\t\t\t\tsyncFile = null;\n\t\t\t}\n\t\t}\n\n\t\tif (syncFile == null) {\n\t\t\tRunnable runnable = new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tSyncSite syncSite = SyncSiteService.fetchSyncSite(\n\t\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\n\t\t\t\t\t\tif ((syncSite == null) || !syncSite.isActive() ||\n\t\t\t\t\t\t\t!FileUtil.checkFilePath(targetFilePath)) {\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tThrowable throwable = e.getCause();\n\n\t\t\t\t\t\tString message = throwable.getMessage();\n\n\t\t\t\t\t\tif (!message.contains(\n\t\t\t\t\t\t\t\t\"Unique index or primary key violation\") &&\n\t\t\t\t\t\t\t_logger.isTraceEnabled()) {\n\n\t\t\t\t\t\t\t_logger.trace(e.getMessage(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t_executorService.execute(runnable);\n\n\t\t\treturn;\n\t\t}\n\n\t\tPath sourceFilePath = Paths.get(syncFile.getFilePathName());\n\n\t\tif (targetFilePath.equals(sourceFilePath)) {\n\t\t\tif (isPendingTypePK(syncFile) ||\n\t\t\t\t(syncFile.getState() == SyncFile.STATE_IN_PROGRESS)) {\n\n\t\t\t\tqueueSyncWatchEvent(syncFile.getFilePathName(), syncWatchEvent);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (FileUtil.isModified(syncFile)) {\n\t\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\t\telse if (Files.exists(sourceFilePath)) {\n\t\t\ttry {\n\t\t\t\tif ((Files.size(targetFilePath) == 0) ||\n\t\t\t\t\tFileUtil.isModified(syncFile, targetFilePath) ||\n\t\t\t\t\tisInErrorState(sourceFilePath)) {\n\n\t\t\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSyncFileService.copySyncFile(\n\t\t\t\t\t\tsyncFile, targetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_logger.isTraceEnabled()) {\n\t\t\t\t\tThrowable throwable = e.getCause();\n\n\t\t\t\t\tString message = throwable.getMessage();\n\n\t\t\t\t\tif (!message.contains(\n\t\t\t\t\t\t\t\"Unique index or primary key violation\")) {\n\n\t\t\t\t\t\t_logger.trace(e.getMessage(), e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t\telse if (parentTargetFilePath.equals(sourceFilePath.getParent())) {\n\t\t\tif (isPendingTypePK(syncFile) ||\n\t\t\t\t(syncFile.getState() == SyncFile.STATE_IN_PROGRESS)) {\n\n\t\t\t\tqueueSyncWatchEvent(syncFile.getFilePathName(), syncWatchEvent);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t}\n\t\telse {\n\t\t\tif (isPendingTypePK(syncFile) ||\n\t\t\t\t(syncFile.getState() == SyncFile.STATE_IN_PROGRESS)) {\n\n\t\t\t\tqueueSyncWatchEvent(syncFile.getFilePathName(), syncWatchEvent);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSyncFileService.moveFileSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(), _syncAccountId,\n\t\t\t\tsyncFile);\n\n\t\t\tPath sourceFileNameFilePath = sourceFilePath.getFileName();\n\n\t\t\tif (!sourceFileNameFilePath.equals(targetFilePath.getFileName())) {\n\t\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t_syncAccountId);\n\n\t\tif (syncAccount.getState() == SyncAccount.STATE_CONNECTED) {\n\t\t\tSyncWatchEvent relatedSyncWatchEvent =\n\t\t\t\tSyncWatchEventService.fetchSyncWatchEvent(\n\t\t\t\t\tSyncWatchEvent.EVENT_TYPE_DELETE,\n\t\t\t\t\tsyncWatchEvent.getFilePathName(),\n\t\t\t\t\tsyncWatchEvent.getTimestamp());\n\n\t\t\tif (relatedSyncWatchEvent != null) {\n\t\t\t\t_processedSyncWatchEventIds.add(\n\t\t\t\t\trelatedSyncWatchEvent.getSyncWatchEventId());\n\t\t\t}\n\t\t}\n\t}","id":23086,"modified_method":"protected void addFile(SyncWatchEvent syncWatchEvent) throws Exception {\n\t\tfinal Path targetFilePath = Paths.get(syncWatchEvent.getFilePathName());\n\n\t\tif (Files.notExists(targetFilePath) ||\n\t\t\tsanitizeFileName(targetFilePath) ||\n\t\t\tisInErrorState(targetFilePath)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tPath parentTargetFilePath = targetFilePath.getParent();\n\n\t\tfinal SyncFile parentSyncFile = SyncFileService.fetchSyncFile(\n\t\t\tparentTargetFilePath.toString());\n\n\t\tif ((parentSyncFile == null) ||\n\t\t\t(!parentSyncFile.isSystem() && (parentSyncFile.getTypePK() == 0))) {\n\n\t\t\tqueueSyncWatchEvent(\n\t\t\t\tparentTargetFilePath.toString(), syncWatchEvent);\n\n\t\t\treturn;\n\t\t}\n\n\t\tSyncFile syncFile = SyncFileService.fetchSyncFile(\n\t\t\ttargetFilePath.toString());\n\n\t\tif (syncFile == null) {\n\t\t\tsyncFile = SyncFileService.fetchSyncFile(\n\t\t\t\tFileKeyUtil.getFileKey(targetFilePath));\n\n\t\t\tif (!verifySite(syncFile, parentSyncFile)) {\n\t\t\t\tsyncFile = null;\n\t\t\t}\n\t\t}\n\n\t\tif (syncFile == null) {\n\t\t\tRunnable runnable = new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tSyncSite syncSite = SyncSiteService.fetchSyncSite(\n\t\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\n\t\t\t\t\t\tif ((syncSite == null) || !syncSite.isActive() ||\n\t\t\t\t\t\t\t!FileUtil.checkFilePath(targetFilePath)) {\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tif (SyncFileService.fetchSyncFile(\n\t\t\t\t\t\t\t\ttargetFilePath.toString()) == null) {\n\n\t\t\t\t\t\t\t_logger.error(e.getMessage(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t_executorService.execute(runnable);\n\n\t\t\treturn;\n\t\t}\n\n\t\tPath sourceFilePath = Paths.get(syncFile.getFilePathName());\n\n\t\tif (targetFilePath.equals(sourceFilePath)) {\n\t\t\tif (isPendingTypePK(syncFile) ||\n\t\t\t\t(syncFile.getState() == SyncFile.STATE_IN_PROGRESS)) {\n\n\t\t\t\tqueueSyncWatchEvent(syncFile.getFilePathName(), syncWatchEvent);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (FileUtil.isModified(syncFile)) {\n\t\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\t\telse if (Files.exists(sourceFilePath)) {\n\t\t\ttry {\n\t\t\t\tif ((Files.size(targetFilePath) == 0) ||\n\t\t\t\t\tFileUtil.isModified(syncFile, targetFilePath) ||\n\t\t\t\t\tisInErrorState(sourceFilePath)) {\n\n\t\t\t\t\tSyncFileService.addFileSyncFile(\n\t\t\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSyncFileService.copySyncFile(\n\t\t\t\t\t\tsyncFile, targetFilePath, parentSyncFile.getTypePK(),\n\t\t\t\t\t\tparentSyncFile.getRepositoryId(), _syncAccountId);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (SyncFileService.fetchSyncFile(\n\t\t\t\t\t\ttargetFilePath.toString()) == null) {\n\n\t\t\t\t\t_logger.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t\telse if (parentTargetFilePath.equals(sourceFilePath.getParent())) {\n\t\t\tif (isPendingTypePK(syncFile) ||\n\t\t\t\t(syncFile.getState() == SyncFile.STATE_IN_PROGRESS)) {\n\n\t\t\t\tqueueSyncWatchEvent(syncFile.getFilePathName(), syncWatchEvent);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t}\n\t\telse {\n\t\t\tif (isPendingTypePK(syncFile) ||\n\t\t\t\t(syncFile.getState() == SyncFile.STATE_IN_PROGRESS)) {\n\n\t\t\t\tqueueSyncWatchEvent(syncFile.getFilePathName(), syncWatchEvent);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSyncFileService.moveFileSyncFile(\n\t\t\t\ttargetFilePath, parentSyncFile.getTypePK(), _syncAccountId,\n\t\t\t\tsyncFile);\n\n\t\t\tPath sourceFileNameFilePath = sourceFilePath.getFileName();\n\n\t\t\tif (!sourceFileNameFilePath.equals(targetFilePath.getFileName())) {\n\t\t\t\tSyncFileService.updateFileSyncFile(\n\t\t\t\t\ttargetFilePath, _syncAccountId, syncFile);\n\t\t\t}\n\t\t}\n\n\t\tSyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\t_syncAccountId);\n\n\t\tif (syncAccount.getState() == SyncAccount.STATE_CONNECTED) {\n\t\t\tSyncWatchEvent relatedSyncWatchEvent =\n\t\t\t\tSyncWatchEventService.fetchSyncWatchEvent(\n\t\t\t\t\tSyncWatchEvent.EVENT_TYPE_DELETE,\n\t\t\t\t\tsyncWatchEvent.getFilePathName(),\n\t\t\t\t\tsyncWatchEvent.getTimestamp());\n\n\t\t\tif (relatedSyncWatchEvent != null) {\n\t\t\t\t_processedSyncWatchEventIds.add(\n\t\t\t\t\trelatedSyncWatchEvent.getSyncWatchEventId());\n\t\t\t}\n\t\t}\n\t}","commit_id":"22ec2e8b63cf80ae234e1fde4bf80bf325c0ddf1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateChecksumsFile(SyncFile syncFile) {\n\t\tPath syncFilePath = Paths.get(syncFile.getFilePathName());\n\n\t\tif (Files.notExists(syncFilePath)) {\n\t\t\treturn;\n\t\t}\n\n\t\tFileInputStream fileInputStream = null;\n\t\tFileChannel fileChannel = null;\n\t\tOutputStream outputStream = null;\n\t\tWritableByteChannel writableByteChannel = null;\n\n\t\ttry {\n\t\t\tfileInputStream = new FileInputStream(syncFile.getFilePathName());\n\n\t\t\tfileChannel = fileInputStream.getChannel();\n\n\t\t\tPath checksumsFilePath = Paths.get(\n\t\t\t\tPropsValues.SYNC_CONFIGURATION_DIRECTORY + \"/files/\" +\n\t\t\t\t\tsyncFile.getSyncFileId());\n\n\t\t\tif (Files.notExists(checksumsFilePath)) {\n\t\t\t\tFiles.createFile(checksumsFilePath);\n\t\t\t}\n\n\t\t\toutputStream = Files.newOutputStream(checksumsFilePath);\n\n\t\t\twritableByteChannel = Channels.newChannel(outputStream);\n\n\t\t\tByteChannelWriter byteChannelWriter = new ByteChannelWriter(\n\t\t\t\twritableByteChannel);\n\n\t\t\tDeltaUtil.checksums(fileChannel, byteChannelWriter);\n\n\t\t\tbyteChannelWriter.finish();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_logger.error(ioe.getMessage(), ioe);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(fileInputStream);\n\t\t\tStreamUtil.cleanUp(outputStream);\n\t\t\tStreamUtil.cleanUp(fileChannel);\n\t\t\tStreamUtil.cleanUp(writableByteChannel);\n\t\t}\n\t}","id":23087,"modified_method":"protected void updateChecksumsFile(SyncFile syncFile) {\n\t\tPath syncFilePath = Paths.get(syncFile.getFilePathName());\n\n\t\tif (Files.isDirectory(syncFilePath) || Files.notExists(syncFilePath)) {\n\t\t\treturn;\n\t\t}\n\n\t\tFileInputStream fileInputStream = null;\n\t\tFileChannel fileChannel = null;\n\t\tOutputStream outputStream = null;\n\t\tWritableByteChannel writableByteChannel = null;\n\n\t\ttry {\n\t\t\tfileInputStream = new FileInputStream(syncFile.getFilePathName());\n\n\t\t\tfileChannel = fileInputStream.getChannel();\n\n\t\t\tPath checksumsFilePath = Paths.get(\n\t\t\t\tPropsValues.SYNC_CONFIGURATION_DIRECTORY + \"/files/\" +\n\t\t\t\t\tsyncFile.getSyncFileId());\n\n\t\t\tif (Files.notExists(checksumsFilePath)) {\n\t\t\t\tFiles.createFile(checksumsFilePath);\n\t\t\t}\n\n\t\t\toutputStream = Files.newOutputStream(checksumsFilePath);\n\n\t\t\twritableByteChannel = Channels.newChannel(outputStream);\n\n\t\t\tByteChannelWriter byteChannelWriter = new ByteChannelWriter(\n\t\t\t\twritableByteChannel);\n\n\t\t\tDeltaUtil.checksums(fileChannel, byteChannelWriter);\n\n\t\t\tbyteChannelWriter.finish();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_logger.error(ioe.getMessage(), ioe);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(fileInputStream);\n\t\t\tStreamUtil.cleanUp(outputStream);\n\t\t\tStreamUtil.cleanUp(fileChannel);\n\t\t\tStreamUtil.cleanUp(writableByteChannel);\n\t\t}\n\t}","commit_id":"a6b973fc008e928edb461ded5cbdb37c4ccf1431","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void addToRequestsByClientRequest(ClientRequester clientRequest, SendableRequest req, ObjectContainer container) {\n\t\tif(clientRequest != null || persistent()) { // Client request null is only legal for transient requests\n\t\t\tif(persistent()) container.activate(clientRequest, 1); \n\t\t\tclientRequest.addToRequests(req, container);\n\t\t}\n\t}","id":23088,"modified_method":"protected void addToRequestsByClientRequest(ClientRequester clientRequest, SendableRequest req, ObjectContainer container) {\n\t\tif(clientRequest != null || persistent()) { // Client request null is only legal for transient requests\n\t\t\tboolean deactivate = false;\n\t\t\tif(persistent()) {\n\t\t\t\tdeactivate = container.ext().isActive(clientRequest);\n\t\t\t\tif(deactivate) container.activate(clientRequest, 1);\n\t\t\t}\n\t\t\tclientRequest.addToRequests(req, container);\n\t\t\tif(deactivate) container.deactivate(clientRequest, 1);\n\t\t}\n\t}","commit_id":"ab479ab17f325f0f022aeb12f985ea01fbfafed1","url":"https://github.com/freenet/fred"},{"original_method":"protected void addToRequestsByClientRequest(ClientRequester clientRequest, SendableRequest req, ObjectContainer container) {\n\t\tif(clientRequest != null || persistent()) // Client request null is only legal for transient requests\n\t\t\tclientRequest.addToRequests(req, container);\n\t}","id":23089,"modified_method":"protected void addToRequestsByClientRequest(ClientRequester clientRequest, SendableRequest req, ObjectContainer container) {\n\t\tif(clientRequest != null || persistent()) { // Client request null is only legal for transient requests\n\t\t\tif(persistent()) container.activate(clientRequest, 1); \n\t\t\tclientRequest.addToRequests(req, container);\n\t\t}\n\t}","commit_id":"cf41a830ec85f9ea1d02d3ec62260e7c17f01e89","url":"https://github.com/freenet/fred"},{"original_method":"protected SendableRequest[] getSendableRequests(ClientRequester request, ObjectContainer container) {\n\t\treturn request.getSendableRequests(container);\n\t}","id":23090,"modified_method":"protected SendableRequest[] getSendableRequests(ClientRequester request, ObjectContainer container) {\n\t\tif(request != null || persistent()) // Client request null is only legal for transient requests\n\t\t\treturn request.getSendableRequests(container);\n\t\telse return null;\n\t}","commit_id":"434d03ab6a59122f93ded54a80e4b2015d4418dd","url":"https://github.com/freenet/fred"},{"original_method":"void removeFromAllRequestsByClientRequest(SendableRequest req, ClientRequester cr, boolean dontComplain, ObjectContainer container) {\n\t\tcr.removeFromRequests(req, container, dontComplain);\n\t}","id":23091,"modified_method":"void removeFromAllRequestsByClientRequest(SendableRequest req, ClientRequester cr, boolean dontComplain, ObjectContainer container) {\n\t\tif(cr != null || persistent()) // Client request null is only legal for transient requests\n\t\t\tcr.removeFromRequests(req, container, dontComplain);\n\t}","commit_id":"434d03ab6a59122f93ded54a80e4b2015d4418dd","url":"https://github.com/freenet/fred"},{"original_method":"protected void addToRequestsByClientRequest(ClientRequester clientRequest, SendableRequest req, ObjectContainer container) {\n\t\tclientRequest.addToRequests(req, container);\n\t}","id":23092,"modified_method":"protected void addToRequestsByClientRequest(ClientRequester clientRequest, SendableRequest req, ObjectContainer container) {\n\t\tif(clientRequest != null || persistent()) // Client request null is only legal for transient requests\n\t\t\tclientRequest.addToRequests(req, container);\n\t}","commit_id":"434d03ab6a59122f93ded54a80e4b2015d4418dd","url":"https://github.com/freenet/fred"},{"original_method":"public void actionPerformed(final ActionEvent e) {\n      new DialogWrapper(myTargetEditor, true){\n        public void show() {\n          setTitle(myDialogTitle);\n          setModal(true);\n          init();\n          super.show();\n        }\n\n        public JComponent getPreferredFocusedComponent() {\n          return myEditor;\n        }\n\n        @Nullable\n        protected JComponent createCenterPanel() {\n          final JPanel panel = new JPanel(new BorderLayout());\n          myEditor = new DebuggerStatementEditor(myProject, myTargetEditor.getContext(), myTargetEditor.getRecentsId(), DefaultCodeFragmentFactory.getInstance());\n          myEditor.setPreferredSize(new Dimension(400, 150));\n          myEditor.setText(myTargetEditor.getText());\n          panel.add(myEditor, BorderLayout.CENTER);\n          return panel;\n        }\n\n        protected void doOKAction() {\n          myTargetEditor.setText(myEditor.getText());\n          super.doOKAction();\n        }\n      }.show();\n    }","id":23093,"modified_method":"@Override\n    public void actionPerformed(final ActionEvent e) {\n      new DialogWrapper(myTargetEditor, true){\n        @Override\n        public void show() {\n          setTitle(myDialogTitle);\n          setModal(true);\n          init();\n          super.show();\n        }\n\n        @Override\n        public JComponent getPreferredFocusedComponent() {\n          return myEditor;\n        }\n\n        @Override\n        @Nullable\n        protected JComponent createCenterPanel() {\n          final JPanel panel = new JPanel(new BorderLayout());\n          myEditor = new DebuggerStatementEditor(myProject, myTargetEditor.getContext(), myTargetEditor.getRecentsId(), DefaultCodeFragmentFactory.getInstance());\n          myEditor.setPreferredSize(new Dimension(400, 150));\n          myEditor.setText(myTargetEditor.getText());\n          panel.add(myEditor, BorderLayout.CENTER);\n          return panel;\n        }\n\n        @Override\n        protected void doOKAction() {\n          myTargetEditor.setText(myEditor.getText());\n          super.doOKAction();\n        }\n      }.show();\n    }","commit_id":"0b2d5f0dedf19f9c56f9d88931bf938f1282cdd3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected ClassFilter createClassConditionFilter() {\n    ClassFilter classFilter;\n    if(myBreakpointPsiClass != null) {\n      classFilter = new ClassFilter() {\n        public boolean isAccepted(PsiClass aClass) {\n          return myBreakpointPsiClass == aClass || aClass.isInheritor(myBreakpointPsiClass, true);\n        }\n      };\n    }\n    else {\n      classFilter = null;\n    }\n    return classFilter;\n  }","id":23094,"modified_method":"protected ClassFilter createClassConditionFilter() {\n    ClassFilter classFilter;\n    if(myBreakpointPsiClass != null) {\n      classFilter = new ClassFilter() {\n        @Override\n        public boolean isAccepted(PsiClass aClass) {\n          return myBreakpointPsiClass == aClass || aClass.isInheritor(myBreakpointPsiClass, true);\n        }\n      };\n    }\n    else {\n      classFilter = null;\n    }\n    return classFilter;\n  }","commit_id":"0b2d5f0dedf19f9c56f9d88931bf938f1282cdd3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Save values in the UI components to the breakpoint object\n   */\n  public void saveTo(Breakpoint breakpoint, @NotNull Runnable afterUpdate) {\n\n    saveMasterBreakpoint();\n    try {\n      String text = myPassCountField.getText().trim();\n      int count = !\"\".equals(text)? Integer.parseInt(text) : 0;\n      breakpoint.COUNT_FILTER = count;\n      if (breakpoint.COUNT_FILTER < 0) {\n        breakpoint.COUNT_FILTER = 0;\n      }\n    }\n    catch (Exception e) {\n    }\n    breakpoint.COUNT_FILTER_ENABLED = breakpoint.COUNT_FILTER > 0 && myPassCountCheckbox.isSelected();\n    breakpoint.setCondition(myConditionCombo.getText());\n    breakpoint.CONDITION_ENABLED = myConditionCheckbox.isSelected();\n    breakpoint.setLogMessage(myLogExpressionCombo.getText());\n    breakpoint.LOG_EXPRESSION_ENABLED = !breakpoint.getLogMessage().isEmpty() && myLogExpressionCheckBox.isSelected();\n    breakpoint.LOG_ENABLED = myLogMessageCheckBox.isSelected();\n    breakpoint.ENABLED = myEnabledCheckbox.isSelected();\n    breakpoint.REMOVE_AFTER_HIT = myTemporaryCheckBox.isSelected();\n    breakpoint.SUSPEND = myCbSuspend.isSelected();\n    breakpoint.SUSPEND_POLICY = getSelectedSuspendPolicy();\n    reloadInstanceFilters();\n    reloadClassFilters();\n    updateInstanceFilterEditor(true);\n    updateClassFilterEditor(true);\n\n    breakpoint.INSTANCE_FILTERS_ENABLED = myInstanceFiltersField.getText().length() > 0 && myInstanceFiltersCheckBox.isSelected();\n    breakpoint.CLASS_FILTERS_ENABLED = myClassFiltersField.getText().length() > 0 && myClassFiltersCheckBox.isSelected();\n    breakpoint.setClassFilters(myClassFilters);\n    breakpoint.setClassExclusionFilters(myClassExclusionFilters);\n    breakpoint.setInstanceFilters(myInstanceFilters);\n\n    myConditionCombo.addRecent(myConditionCombo.getText());\n    myLogExpressionCombo.addRecent(myLogExpressionCombo.getText());\n    breakpoint.updateUI(afterUpdate);\n  }","id":23095,"modified_method":"/**\n   * Save values in the UI components to the breakpoint object\n   */\n  public void saveTo(Breakpoint breakpoint, @NotNull Runnable afterUpdate) {\n\n    saveMasterBreakpoint();\n    try {\n      String text = myPassCountField.getText().trim();\n      breakpoint.COUNT_FILTER = !text.isEmpty() ? Integer.parseInt(text) : 0;\n      if (breakpoint.COUNT_FILTER < 0) {\n        breakpoint.COUNT_FILTER = 0;\n      }\n    }\n    catch (Exception ignored) {\n    }\n\n    breakpoint.COUNT_FILTER_ENABLED = breakpoint.COUNT_FILTER > 0 && myPassCountCheckbox.isSelected();\n    breakpoint.setCondition(myConditionCombo.getText());\n    breakpoint.CONDITION_ENABLED = myConditionCheckbox.isSelected();\n    breakpoint.setLogMessage(myLogExpressionCombo.getText());\n    breakpoint.LOG_EXPRESSION_ENABLED = !breakpoint.getLogMessage().isEmpty() && myLogExpressionCheckBox.isSelected();\n    breakpoint.LOG_ENABLED = myLogMessageCheckBox.isSelected();\n    breakpoint.ENABLED = myEnabledCheckbox.isSelected();\n    breakpoint.REMOVE_AFTER_HIT = myTemporaryCheckBox.isSelected();\n    breakpoint.SUSPEND = myCbSuspend.isSelected();\n    breakpoint.SUSPEND_POLICY = getSelectedSuspendPolicy();\n    reloadInstanceFilters();\n    reloadClassFilters();\n    updateInstanceFilterEditor(true);\n    updateClassFilterEditor(true);\n\n    breakpoint.INSTANCE_FILTERS_ENABLED = myInstanceFiltersField.getText().length() > 0 && myInstanceFiltersCheckBox.isSelected();\n    breakpoint.CLASS_FILTERS_ENABLED = myClassFiltersField.getText().length() > 0 && myClassFiltersCheckBox.isSelected();\n    breakpoint.setClassFilters(myClassFilters);\n    breakpoint.setClassExclusionFilters(myClassExclusionFilters);\n    breakpoint.setInstanceFilters(myInstanceFilters);\n\n    myConditionCombo.addRecent(myConditionCombo.getText());\n    myLogExpressionCombo.addRecent(myLogExpressionCombo.getText());\n    breakpoint.updateUI(afterUpdate);\n  }","commit_id":"0b2d5f0dedf19f9c56f9d88931bf938f1282cdd3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BreakpointPropertiesPanel(final Project project, final Key<? extends Breakpoint> breakpointCategory, boolean compact) {\n    myProject = project;\n    myBreakpointCategory = breakpointCategory;\n    myCompact = compact;\n\n    mySuspendPolicyGroup = new ButtonGroup();\n    mySuspendPolicyGroup.add(myRbSuspendAll);\n    mySuspendPolicyGroup.add(myRbSuspendThread);\n\n    updateSuspendPolicyRbFont();\n    final ItemListener suspendPolicyChangeListener = new ItemListener() {\n      public void itemStateChanged(final ItemEvent e) {\n        final BreakpointDefaults defaults = getBreakpointManager(myProject).getBreakpointDefaults(breakpointCategory);\n        myMakeDefaultButton.setEnabled(!defaults.getSuspendPolicy().equals(getSelectedSuspendPolicy()) || defaults.isConditionEnabled() != myConditionCheckbox.isSelected());\n      }\n    };\n\n    myCbSuspend.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent event) {\n        final boolean enabled = myCbSuspend.isSelected();\n        myRbSuspendAll.setEnabled(enabled);\n        myRbSuspendThread.setEnabled(enabled);\n      }\n    });\n\n\n    myRbSuspendAll.addItemListener(suspendPolicyChangeListener);\n    myRbSuspendThread.addItemListener(suspendPolicyChangeListener);\n    myConditionCheckbox.addItemListener(suspendPolicyChangeListener);\n\n    myMakeDefaultButton.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        final BreakpointManager breakpointManager = getBreakpointManager(myProject);\n        final String suspendPolicy = getSelectedSuspendPolicy();\n        breakpointManager.setBreakpointDefaults(breakpointCategory, new BreakpointDefaults(suspendPolicy, myConditionCheckbox.isSelected()));\n        updateSuspendPolicyRbFont();\n        if (DebuggerSettings.SUSPEND_THREAD.equals(suspendPolicy)) {\n          myRbSuspendThread.requestFocus();\n        }\n        else {\n          myRbSuspendAll.requestFocus();\n        }\n        myMakeDefaultButton.setEnabled(false);\n      }\n    });\n\n    myConditionCombo = new DebuggerExpressionComboBox(project, \"LineBreakpoint condition\");\n    myConditionCombo.addDocumentListener(new DocumentListener() {\n      @Override\n      public void beforeDocumentChange(DocumentEvent event) {\n        myConditionCheckbox.setSelected(true);\n      }\n\n      @Override\n      public void documentChanged(DocumentEvent event) {\n\n      }\n    });\n\n    myConditionCombo.getEditorComponent().addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent event) {\n        myConditionCombo.setEnabled(true);\n        myConditionCheckbox.setSelected(true);\n      }\n    });\n\n    if (myCompact) {\n      myPanel.addFocusListener(new FocusAdapter() {\n        @Override\n        public void focusGained(FocusEvent event) {\n          DebuggerExpressionComboBox focus;\n          if (myLogExpressionCheckBox.isSelected()) {\n            focus = myLogExpressionCombo;\n          } else {\n            focus = myConditionCombo;\n          }\n          IdeFocusManager.findInstance().requestFocus(focus, true);\n        }\n      });\n    }\n\n    myLogExpressionCombo = new DebuggerExpressionComboBox(project, \"LineBreakpoint logMessage\");\n\n    myInstanceFiltersField = new FieldPanel(new MyTextField(), \"\", null,\n     new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        reloadInstanceFilters();\n        EditInstanceFiltersDialog _dialog = new EditInstanceFiltersDialog(myProject);\n        _dialog.setFilters(myInstanceFilters);\n        _dialog.show();\n        if(_dialog.getExitCode() == DialogWrapper.OK_EXIT_CODE) {\n          myInstanceFilters = _dialog.getFilters();\n          updateInstanceFilterEditor(true);\n        }\n      }\n    },\n     null\n    );\n\n    myClassFiltersField = new FieldPanel(new MyTextField(), \"\", null,\n     new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        reloadClassFilters();\n\n        ClassFilter classFilter = createClassConditionFilter();\n\n        EditClassFiltersDialog _dialog = new EditClassFiltersDialog(myProject, classFilter);\n        _dialog.setFilters(myClassFilters, myClassExclusionFilters);\n        _dialog.show();\n        if (_dialog.getExitCode() == DialogWrapper.OK_EXIT_CODE) {\n          myClassFilters = _dialog.getFilters();\n          myClassExclusionFilters = _dialog.getExclusionFilters();\n          updateClassFilterEditor(true);\n        }\n      }\n    },\n     null\n    );\n    ToolTipManager.sharedInstance().registerComponent(myClassFiltersField.getTextField());\n    ToolTipManager.sharedInstance().registerComponent(myInstanceFiltersField.getTextField());\n\n    JComponent specialBox = createSpecialBox();\n    if(specialBox != null) {\n      insert(mySpecialBoxPanel, specialBox);\n    } \n    else {\n      mySpecialBoxPanel.setVisible(false);\n    }\n\n    final JPanel conditionPanel = new JPanel(new BorderLayout());\n    conditionPanel.add(myConditionCombo, BorderLayout.CENTER);\n    myConditionMagnifierButton = new FixedSizeButton(myConditionCombo);\n    conditionPanel.add(myConditionMagnifierButton, BorderLayout.EAST);\n    myConditionMagnifierButton.setFocusable(false);\n    myConditionMagnifierButton.addActionListener(new MagnifierButtonAction(project, myConditionCombo, \"Condition\"));\n\n    insert(myConditionComboPanel, conditionPanel);\n    insert(myLogExpressionComboPanel, myLogExpressionCombo);\n\n    insert(myInstanceFiltersFieldPanel, myInstanceFiltersField);\n    insert(myClassFiltersFieldPanel, myClassFiltersField);\n\n    DebuggerUIUtil.enableEditorOnCheck(myLogExpressionCheckBox, myLogExpressionCombo);\n    ActionListener updateListener = new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        updateCheckboxes();\n      }\n    };\n\n    myPassCountCheckbox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent event) {\n        if (myPassCountCheckbox.isSelected()) {\n          myConditionCheckbox.setSelected(false);\n        }\n        updateCheckboxes();\n      }\n    });\n    myInstanceFiltersCheckBox.addActionListener(updateListener);\n    myClassFiltersCheckBox.addActionListener(updateListener);\n    myConditionCheckbox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent event) {\n        if (myConditionCheckbox.isSelected()) {\n          myPassCountCheckbox.setSelected(false);\n        }\n        updateCheckboxes();\n      }\n    });\n    DebuggerUIUtil.focusEditorOnCheck(myPassCountCheckbox, myPassCountField);\n    DebuggerUIUtil.focusEditorOnCheck(myLogExpressionCheckBox, myLogExpressionCombo);\n    DebuggerUIUtil.focusEditorOnCheck(myInstanceFiltersCheckBox, myInstanceFiltersField.getTextField());\n    DebuggerUIUtil.focusEditorOnCheck(myClassFiltersCheckBox, myClassFiltersField.getTextField());\n    DebuggerUIUtil.focusEditorOnCheck(myConditionCheckbox, myConditionCombo);\n\n    IJSwingUtilities.adjustComponentsOnMac(myCbSuspend);\n    IJSwingUtilities.adjustComponentsOnMac(myLogExpressionCheckBox);\n    IJSwingUtilities.adjustComponentsOnMac(myLogMessageCheckBox);\n    IJSwingUtilities.adjustComponentsOnMac(myTemporaryCheckBox);\n    IJSwingUtilities.adjustComponentsOnMac(myEnabledCheckbox);\n  }","id":23096,"modified_method":"public BreakpointPropertiesPanel(final Project project, final Key<? extends Breakpoint> breakpointCategory, boolean compact) {\n    myProject = project;\n    myBreakpointCategory = breakpointCategory;\n    myCompact = compact;\n\n    mySuspendPolicyGroup = new ButtonGroup();\n    mySuspendPolicyGroup.add(myRbSuspendAll);\n    mySuspendPolicyGroup.add(myRbSuspendThread);\n\n    updateSuspendPolicyRbFont();\n    final ItemListener suspendPolicyChangeListener = new ItemListener() {\n      @Override\n      public void itemStateChanged(final ItemEvent e) {\n        final BreakpointDefaults defaults = getBreakpointManager(myProject).getBreakpointDefaults(breakpointCategory);\n        myMakeDefaultButton.setEnabled(!defaults.getSuspendPolicy().equals(getSelectedSuspendPolicy()) || defaults.isConditionEnabled() != myConditionCheckbox.isSelected());\n      }\n    };\n\n    myCbSuspend.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent event) {\n        final boolean enabled = myCbSuspend.isSelected();\n        myRbSuspendAll.setEnabled(enabled);\n        myRbSuspendThread.setEnabled(enabled);\n      }\n    });\n\n\n    myRbSuspendAll.addItemListener(suspendPolicyChangeListener);\n    myRbSuspendThread.addItemListener(suspendPolicyChangeListener);\n    myConditionCheckbox.addItemListener(suspendPolicyChangeListener);\n\n    myMakeDefaultButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(final ActionEvent e) {\n        final BreakpointManager breakpointManager = getBreakpointManager(myProject);\n        final String suspendPolicy = getSelectedSuspendPolicy();\n        breakpointManager.setBreakpointDefaults(breakpointCategory, new BreakpointDefaults(suspendPolicy, myConditionCheckbox.isSelected()));\n        updateSuspendPolicyRbFont();\n        if (DebuggerSettings.SUSPEND_THREAD.equals(suspendPolicy)) {\n          myRbSuspendThread.requestFocus();\n        }\n        else {\n          myRbSuspendAll.requestFocus();\n        }\n        myMakeDefaultButton.setEnabled(false);\n      }\n    });\n\n    myConditionCombo = new DebuggerExpressionComboBox(project, \"LineBreakpoint condition\");\n    myConditionCombo.addDocumentListener(new DocumentListener() {\n      @Override\n      public void beforeDocumentChange(DocumentEvent event) {\n        myConditionCheckbox.setSelected(true);\n      }\n\n      @Override\n      public void documentChanged(DocumentEvent event) {\n\n      }\n    });\n\n    myConditionCombo.getEditorComponent().addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent event) {\n        myConditionCombo.setEnabled(true);\n        myConditionCheckbox.setSelected(true);\n      }\n    });\n\n    if (myCompact) {\n      myPanel.addFocusListener(new FocusAdapter() {\n        @Override\n        public void focusGained(FocusEvent event) {\n          DebuggerExpressionComboBox focus;\n          if (myLogExpressionCheckBox.isSelected()) {\n            focus = myLogExpressionCombo;\n          } else {\n            focus = myConditionCombo;\n          }\n          IdeFocusManager.findInstance().requestFocus(focus, true);\n        }\n      });\n    }\n\n    myLogExpressionCombo = new DebuggerExpressionComboBox(project, \"LineBreakpoint logMessage\");\n\n    myInstanceFiltersField = new FieldPanel(new MyTextField(), \"\", null,\n     new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        reloadInstanceFilters();\n        EditInstanceFiltersDialog _dialog = new EditInstanceFiltersDialog(myProject);\n        _dialog.setFilters(myInstanceFilters);\n        _dialog.show();\n        if(_dialog.getExitCode() == DialogWrapper.OK_EXIT_CODE) {\n          myInstanceFilters = _dialog.getFilters();\n          updateInstanceFilterEditor(true);\n        }\n      }\n    },\n     null\n    );\n\n    myClassFiltersField = new FieldPanel(new MyTextField(), \"\", null,\n     new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        reloadClassFilters();\n\n        ClassFilter classFilter = createClassConditionFilter();\n\n        EditClassFiltersDialog _dialog = new EditClassFiltersDialog(myProject, classFilter);\n        _dialog.setFilters(myClassFilters, myClassExclusionFilters);\n        _dialog.show();\n        if (_dialog.getExitCode() == DialogWrapper.OK_EXIT_CODE) {\n          myClassFilters = _dialog.getFilters();\n          myClassExclusionFilters = _dialog.getExclusionFilters();\n          updateClassFilterEditor(true);\n        }\n      }\n    },\n     null\n    );\n    ToolTipManager.sharedInstance().registerComponent(myClassFiltersField.getTextField());\n    ToolTipManager.sharedInstance().registerComponent(myInstanceFiltersField.getTextField());\n\n    JComponent specialBox = createSpecialBox();\n    if(specialBox != null) {\n      insert(mySpecialBoxPanel, specialBox);\n    } \n    else {\n      mySpecialBoxPanel.setVisible(false);\n    }\n\n    final JPanel conditionPanel = new JPanel(new BorderLayout());\n    conditionPanel.add(myConditionCombo, BorderLayout.CENTER);\n    myConditionMagnifierButton = new FixedSizeButton(myConditionCombo);\n    conditionPanel.add(myConditionMagnifierButton, BorderLayout.EAST);\n    myConditionMagnifierButton.setFocusable(false);\n    myConditionMagnifierButton.addActionListener(new MagnifierButtonAction(project, myConditionCombo, \"Condition\"));\n\n    insert(myConditionComboPanel, conditionPanel);\n    insert(myLogExpressionComboPanel, myLogExpressionCombo);\n\n    insert(myInstanceFiltersFieldPanel, myInstanceFiltersField);\n    insert(myClassFiltersFieldPanel, myClassFiltersField);\n\n    DebuggerUIUtil.enableEditorOnCheck(myLogExpressionCheckBox, myLogExpressionCombo);\n    ActionListener updateListener = new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        updateCheckboxes();\n      }\n    };\n\n    myPassCountCheckbox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent event) {\n        if (myPassCountCheckbox.isSelected()) {\n          myConditionCheckbox.setSelected(false);\n        }\n        updateCheckboxes();\n      }\n    });\n    myInstanceFiltersCheckBox.addActionListener(updateListener);\n    myClassFiltersCheckBox.addActionListener(updateListener);\n    myConditionCheckbox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent event) {\n        if (myConditionCheckbox.isSelected()) {\n          myPassCountCheckbox.setSelected(false);\n        }\n        updateCheckboxes();\n      }\n    });\n    DebuggerUIUtil.focusEditorOnCheck(myPassCountCheckbox, myPassCountField);\n    DebuggerUIUtil.focusEditorOnCheck(myLogExpressionCheckBox, myLogExpressionCombo);\n    DebuggerUIUtil.focusEditorOnCheck(myInstanceFiltersCheckBox, myInstanceFiltersField.getTextField());\n    DebuggerUIUtil.focusEditorOnCheck(myClassFiltersCheckBox, myClassFiltersField.getTextField());\n    DebuggerUIUtil.focusEditorOnCheck(myConditionCheckbox, myConditionCombo);\n\n    IJSwingUtilities.adjustComponentsOnMac(myCbSuspend);\n    IJSwingUtilities.adjustComponentsOnMac(myLogExpressionCheckBox);\n    IJSwingUtilities.adjustComponentsOnMac(myLogMessageCheckBox);\n    IJSwingUtilities.adjustComponentsOnMac(myTemporaryCheckBox);\n    IJSwingUtilities.adjustComponentsOnMac(myEnabledCheckbox);\n  }","commit_id":"0b2d5f0dedf19f9c56f9d88931bf938f1282cdd3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void showXBreakpointEditorBalloon(final Project project,\n                                                  @Nullable final Point point,\n                                                  final JComponent component,\n                                                  final boolean showAllOptions,\n                                                  final XBreakpoint breakpoint) {\n    final XBreakpointManager breakpointManager = XDebuggerManager.getInstance(project).getBreakpointManager();\n    final XLightBreakpointPropertiesPanel<XBreakpoint<?>> propertiesPanel = new XLightBreakpointPropertiesPanel<XBreakpoint<?>>(project, breakpointManager, breakpoint, showAllOptions);\n\n    final Ref<Balloon> balloonRef = Ref.create(null);\n    final Ref<Boolean> isLoading = Ref.create(Boolean.FALSE);\n\n    propertiesPanel.setDelegate(new XLightBreakpointPropertiesPanel.Delegate() {\n      @Override\n      public void showMoreOptions() {\n        if (!isLoading.get()) {\n          propertiesPanel.saveProperties();\n        }\n        if (!balloonRef.isNull()) {\n          balloonRef.get().hide();\n        }\n        showXBreakpointEditorBalloon(project, point, component, true, breakpoint);\n      }\n    });\n\n    isLoading.set(Boolean.TRUE);\n    propertiesPanel.loadProperties();\n    isLoading.set(Boolean.FALSE);\n\n    Runnable viewBreakpoints = new Runnable() {\n      @Override\n      public void run() {\n        propertiesPanel.saveProperties();\n        BreakpointsDialogFactory.getInstance(project).showDialog(breakpoint);\n      }\n    };\n\n    final JComponent mainPanel = propertiesPanel.getMainPanel();\n    final Balloon balloon = showBreakpointEditor(project, mainPanel, point, component, viewBreakpoints, breakpoint);\n    balloonRef.set(balloon);\n\n    final XBreakpointListener<XBreakpoint<?>> breakpointListener = new XBreakpointAdapter<XBreakpoint<?>>() {\n      @Override\n      public void breakpointRemoved(@NotNull XBreakpoint<?> removedBreakpoint) {\n        if (removedBreakpoint.equals(breakpoint)) {\n          balloon.hide();\n        }\n      }\n    };\n\n    balloon.addListener(new JBPopupListener.Adapter() {\n      @Override\n      public void onClosed(LightweightWindowEvent event) {\n        propertiesPanel.saveProperties();\n        breakpointManager.removeBreakpointListener(breakpointListener);\n      }\n    });\n\n    if (point == null) {\n      balloon.showInCenterOf(component);\n    }\n    else {\n      balloon.show(new RelativePoint(component, point), Balloon.Position.atRight);\n    }\n\n    breakpointManager.addBreakpointListener(breakpointListener);\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        IdeFocusManager.findInstance().requestFocus(mainPanel, true);\n      }\n    });\n  }","id":23097,"modified_method":"public static void showXBreakpointEditorBalloon(final Project project,\n                                                  @Nullable final Point point,\n                                                  final JComponent component,\n                                                  final boolean showAllOptions,\n                                                  final XBreakpoint breakpoint) {\n    final XBreakpointManager breakpointManager = XDebuggerManager.getInstance(project).getBreakpointManager();\n    final XLightBreakpointPropertiesPanel<XBreakpoint<?>> propertiesPanel = new XLightBreakpointPropertiesPanel<XBreakpoint<?>>(project, breakpointManager, breakpoint, showAllOptions);\n\n    final Ref<Balloon> balloonRef = Ref.create(null);\n    final Ref<Boolean> isLoading = Ref.create(Boolean.FALSE);\n\n    propertiesPanel.setDelegate(new XLightBreakpointPropertiesPanel.Delegate() {\n      @Override\n      public void showMoreOptions() {\n        if (!isLoading.get()) {\n          propertiesPanel.saveProperties();\n        }\n        if (!balloonRef.isNull()) {\n          balloonRef.get().hide();\n        }\n        showXBreakpointEditorBalloon(project, point, component, true, breakpoint);\n      }\n    });\n\n    isLoading.set(Boolean.TRUE);\n    propertiesPanel.loadProperties();\n    isLoading.set(Boolean.FALSE);\n\n    Runnable showMoreOptions = new Runnable() {\n      @Override\n      public void run() {\n        propertiesPanel.saveProperties();\n        BreakpointsDialogFactory.getInstance(project).showDialog(breakpoint);\n      }\n    };\n\n    final JComponent mainPanel = propertiesPanel.getMainPanel();\n    final Balloon balloon = showBreakpointEditor(project, mainPanel, point, component, showMoreOptions, breakpoint);\n    balloonRef.set(balloon);\n\n    final XBreakpointListener<XBreakpoint<?>> breakpointListener = new XBreakpointAdapter<XBreakpoint<?>>() {\n      @Override\n      public void breakpointRemoved(@NotNull XBreakpoint<?> removedBreakpoint) {\n        if (removedBreakpoint.equals(breakpoint)) {\n          balloon.hide();\n        }\n      }\n    };\n\n    balloon.addListener(new JBPopupListener.Adapter() {\n      @Override\n      public void onClosed(LightweightWindowEvent event) {\n        propertiesPanel.saveProperties();\n        breakpointManager.removeBreakpointListener(breakpointListener);\n      }\n    });\n\n    if (point == null) {\n      balloon.showInCenterOf(component);\n    }\n    else {\n      balloon.show(new RelativePoint(component, point), Balloon.Position.atRight);\n    }\n\n    breakpointManager.addBreakpointListener(breakpointListener);\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        IdeFocusManager.findInstance().requestFocus(mainPanel, true);\n      }\n    });\n  }","commit_id":"0b2d5f0dedf19f9c56f9d88931bf938f1282cdd3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void doShowPopup(final Project project, final JComponent component, final Point whereToShow, final Object breakpoint) {\n    if (!(breakpoint instanceof BreakpointWithHighlighter)) return;\n\n    final BreakpointWithHighlighter javaBreakpoint = (BreakpointWithHighlighter)breakpoint;\n    Key<? extends BreakpointWithHighlighter> category = javaBreakpoint.getCategory();\n\n    final BreakpointFactory[] allFactories = ApplicationManager.getApplication().getExtensions(BreakpointFactory.EXTENSION_POINT_NAME);\n    BreakpointFactory breakpointFactory = null;\n    for (BreakpointFactory factory : allFactories) {\n      if (factory.getBreakpointCategory().equals(category)) {\n        breakpointFactory = factory;\n      }\n    }\n    assert breakpointFactory != null : \"can't find factory for breakpoint \" + javaBreakpoint;\n\n    final BreakpointPropertiesPanel propertiesPanel = breakpointFactory.createBreakpointPropertiesPanel(project, true);\n    assert propertiesPanel != null;\n    propertiesPanel.initFrom(javaBreakpoint, false);\n\n    final JComponent mainPanel = propertiesPanel.getPanel();\n    final String displayName = javaBreakpoint.getDisplayName();\n\n    final JBPopupListener saveOnClose = new JBPopupListener() {\n      @Override\n      public void beforeShown(LightweightWindowEvent event) {\n      }\n\n      @Override\n      public void onClosed(LightweightWindowEvent event) {\n        propertiesPanel.saveTo(javaBreakpoint, new Runnable() {\n          @Override\n          public void run() {\n          }\n        });\n      }\n    };\n\n    final Runnable showMoreOptions = new Runnable() {\n      @Override\n      public void run() {\n        UIUtil.invokeLaterIfNeeded(new Runnable() {\n          @Override\n          public void run() {\n            BreakpointsDialogFactory.getInstance(project).showDialog(javaBreakpoint);\n\n          }\n        });\n      }\n    };\n    final Balloon balloon = DebuggerUIUtil.showBreakpointEditor(project, mainPanel, whereToShow, component, showMoreOptions,\n                                                                breakpoint);\n    balloon.addListener(saveOnClose);\n\n    propertiesPanel.setDelegate(new BreakpointPropertiesPanel.Delegate() {\n      @Override\n      public void showActionsPanel() {\n        propertiesPanel.setActionsPanelVisible(true);\n        balloon.hide();\n        final Balloon newBalloon =\n          DebuggerUIUtil.showBreakpointEditor(project, mainPanel, whereToShow, component, showMoreOptions, breakpoint);\n        newBalloon.addListener(saveOnClose);\n      }\n    });\n\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        IdeFocusManager.findInstance().requestFocus(mainPanel, true);\n      }\n    });\n  }","id":23098,"modified_method":"@Override\n  protected void doShowPopup(final Project project, final JComponent component, final Point whereToShow, final Object breakpoint) {\n    if (!(breakpoint instanceof BreakpointWithHighlighter)) {\n      return;\n    }\n\n    final BreakpointWithHighlighter javaBreakpoint = (BreakpointWithHighlighter)breakpoint;\n    BreakpointFactory breakpointFactory = null;\n    for (BreakpointFactory factory : BreakpointFactory.EXTENSION_POINT_NAME.getExtensions()) {\n      if (factory.getBreakpointCategory().equals(javaBreakpoint.getCategory())) {\n        breakpointFactory = factory;\n      }\n    }\n    assert breakpointFactory != null : \"can't find factory for breakpoint \" + javaBreakpoint;\n\n    final BreakpointPropertiesPanel propertiesPanel = breakpointFactory.createBreakpointPropertiesPanel(project, true);\n    assert propertiesPanel != null;\n    propertiesPanel.initFrom(javaBreakpoint, false);\n\n    final JComponent mainPanel = propertiesPanel.getPanel();\n    final JBPopupListener saveOnClose = new JBPopupListener.Adapter() {\n      @Override\n      public void onClosed(LightweightWindowEvent event) {\n        propertiesPanel.saveTo(javaBreakpoint, EmptyRunnable.getInstance());\n      }\n    };\n\n    final Runnable showMoreOptions = new Runnable() {\n      @Override\n      public void run() {\n        UIUtil.invokeLaterIfNeeded(new Runnable() {\n          @Override\n          public void run() {\n            BreakpointsDialogFactory.getInstance(project).showDialog(javaBreakpoint);\n          }\n        });\n      }\n    };\n\n    final Balloon balloon = DebuggerUIUtil.showBreakpointEditor(project, mainPanel, whereToShow, component, showMoreOptions, breakpoint);\n    balloon.addListener(saveOnClose);\n\n    propertiesPanel.setDelegate(new BreakpointPropertiesPanel.Delegate() {\n      @Override\n      public void showActionsPanel() {\n        propertiesPanel.setActionsPanelVisible(true);\n        balloon.hide();\n        DebuggerUIUtil.showBreakpointEditor(project, mainPanel, whereToShow, component, showMoreOptions, breakpoint).addListener(saveOnClose);\n      }\n    });\n\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        IdeFocusManager.findInstance().requestFocus(mainPanel, true);\n      }\n    });\n  }","commit_id":"0b2d5f0dedf19f9c56f9d88931bf938f1282cdd3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Add messages to the dom4j tree.\n\t */\n\tpublic void execute() {\n\t\tIterator<Element> elementIter = document.selectNodes(\"/BugCollection/BugInstance\").iterator();\n\t\tIterator<BugInstance> bugInstanceIter = bugCollection.iterator();\n\n\t\tSet<String> bugTypeSet = new HashSet<String>();\n\n\t\t// Add short and long descriptions to BugInstance elements.\n\t\t// We rely on the Document and the BugCollection storing\n\t\t// the bug instances in the same order.\n\t\twhile (elementIter.hasNext() && bugInstanceIter.hasNext()) {\n\t\t\tElement element = elementIter.next();\n\t\t\tBugInstance bugInstance = bugInstanceIter.next();\n\n\t\t\tString bugType = bugInstance.getType();\n\t\t\tbugTypeSet.add(bugType);\n\n\t\t\tBugPattern bugPattern = bugInstance.getBugPattern();\n\n\t\t\telement.addElement(\"ShortMessage\").addText(\n\t\t\t\tbugPattern != null\n\t\t\t\t\t? bugPattern.getShortDescription()\n\t\t\t\t\t: bugInstance.toString());\n\t\t\telement.addElement(\"LongMessage\").addText(bugInstance.getMessage());\n\n\t\t\t// Add pre-formatted display strings in \"Message\"\n\t\t\t// elements for all bug annotations.\n\t\t\tIterator<Element> annElementIter = element.elements().iterator();\n\t\t\tIterator<BugAnnotation> annIter = bugInstance.annotationIterator();\n\t\t\twhile (annElementIter.hasNext() && annIter.hasNext()) {\n\t\t\t\tElement annElement = annElementIter.next();\n\t\t\t\tBugAnnotation ann = annIter.next();\n\t\t\t\tannElement.addElement(\"Message\").addText(ann.toString());\n\t\t\t}\n\t\t}\n\n\t\t// Add BugPattern elements for each referenced bug types.\n\t\tElement root = document.getRootElement();\n\t\tfor (Iterator<String> bugTypeIter = bugTypeSet.iterator(); bugTypeIter.hasNext(); ) {\n\t\t\tString bugType = bugTypeIter.next();\n\t\t\tBugPattern bugPattern = I18N.instance().lookupBugPattern(bugType);\n\t\t\tif (bugPattern == null)\n\t\t\t\tcontinue;\n\t\t\tElement details = root.addElement(\"BugPattern\");\n\t\t\tdetails\n\t\t\t\t.addAttribute(\"type\", bugType)\n\t\t\t\t.addAttribute(\"abbrev\", bugPattern.getAbbrev())\n\t\t\t\t.addAttribute(\"category\", bugPattern.getCategory());\n\t\t\tdetails\n\t\t\t\t.addElement(\"ShortDescription\")\n\t\t\t\t.addText(bugPattern.getShortDescription());\n\t\t\tdetails\n\t\t\t\t.addElement(\"Details\")\n\t\t\t\t.addCDATA(bugPattern.getDetailText());\n\t\t}\n\t}","id":23099,"modified_method":"/**\n\t * Add messages to the dom4j tree.\n\t */\n\tpublic void execute() {\n\t\tIterator<Element> elementIter = document.selectNodes(\"/BugCollection/BugInstance\").iterator();\n\t\tIterator<BugInstance> bugInstanceIter = bugCollection.iterator();\n\n\t\tSet<String> bugTypeSet = new HashSet<String>();\n\t\tSet<String> bugCategorySet = new HashSet<String>();\n\t\tSet<String> bugCodeSet = new HashSet<String>();\n\n\t\t// Add short and long descriptions to BugInstance elements.\n\t\t// We rely on the Document and the BugCollection storing\n\t\t// the bug instances in the same order.\n\t\twhile (elementIter.hasNext() && bugInstanceIter.hasNext()) {\n\t\t\tElement element = elementIter.next();\n\t\t\tBugInstance bugInstance = bugInstanceIter.next();\n\n\t\t\tString bugType = bugInstance.getType();\n\t\t\tbugTypeSet.add(bugType);\n\n\t\t\tBugPattern bugPattern = bugInstance.getBugPattern();\n\t\t\t\n\t\t\tbugCategorySet.add(bugPattern.getCategory());\n\t\t\tbugCodeSet.add(bugPattern.getAbbrev());\n\n\t\t\telement.addElement(\"ShortMessage\").addText(\n\t\t\t\tbugPattern != null\n\t\t\t\t\t? bugPattern.getShortDescription()\n\t\t\t\t\t: bugInstance.toString());\n\t\t\telement.addElement(\"LongMessage\").addText(bugInstance.getMessage());\n\n\t\t\t// Add pre-formatted display strings in \"Message\"\n\t\t\t// elements for all bug annotations.\n\t\t\tIterator<Element> annElementIter = element.elements().iterator();\n\t\t\tIterator<BugAnnotation> annIter = bugInstance.annotationIterator();\n\t\t\twhile (annElementIter.hasNext() && annIter.hasNext()) {\n\t\t\t\tElement annElement = annElementIter.next();\n\t\t\t\tBugAnnotation ann = annIter.next();\n\t\t\t\tannElement.addElement(\"Message\").addText(ann.toString());\n\t\t\t}\n\t\t}\n\n\t\t// Add BugPattern elements for each referenced bug types.\n\t\taddBugCategories(bugCategorySet);\n\t\taddBugPatterns(bugTypeSet);\n\t\taddBugCodes(bugCodeSet);\n\t}","commit_id":"4f3c2c41ef18c38073f27b7dffa8a495fa826366","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n  public BreakpointPropertiesPanel createBreakpointPropertiesPanel(Project project, boolean compact) {\n    return null;  //To change body of implemented methods use File | Settings | File Templates.\n  }","id":23100,"modified_method":"@Override\n  public BreakpointPropertiesPanel createBreakpointPropertiesPanel(Project project, boolean compact) {\n    return new ExceptionBreakpointPropertiesPanel(project, compact);\n  }","commit_id":"99454064dd1d169f3bfcd7e82adce8a448f2143c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public XBreakpointCategoryGroup getGroup(@NotNull B b, @NotNull Collection<XBreakpointCategoryGroup> groups) {\n    if (b instanceof Breakpoint) {\n      final Breakpoint breakpoint = (Breakpoint)b;\n      for (XBreakpointCategoryGroup group : groups) {\n        if (group.getCategory().equals(breakpoint.getCategory())) {\n          return group;\n        }\n      }\n      final BreakpointFactory factory = BreakpointFactory.getInstance(breakpoint.getCategory());\n      if (factory != null) {\n        return new XBreakpointCategoryGroup(factory);\n      }\n    }\n    return null;\n  }","id":23101,"modified_method":"@Override\n  public XBreakpointCategoryGroup getGroup(@NotNull B b, @NotNull Collection<XBreakpointCategoryGroup> groups) {\n    if (b instanceof Breakpoint) {\n      final Breakpoint breakpoint = (Breakpoint)b;\n      Key<? extends Breakpoint> category = breakpoint.getCategory();\n      if (category.equals(AnyExceptionBreakpoint.ANY_EXCEPTION_BREAKPOINT)) {\n        category = ExceptionBreakpoint.CATEGORY;\n      }\n      for (XBreakpointCategoryGroup group : groups) {\n        if (group.getCategory().equals(category)) {\n          return group;\n        }\n      }\n      final BreakpointFactory factory = BreakpointFactory.getInstance(category);\n      if (factory != null) {\n        return new XBreakpointCategoryGroup(factory);\n      }\n    }\n    return null;\n  }","commit_id":"99454064dd1d169f3bfcd7e82adce8a448f2143c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String valueOf(IdeaPluginDescriptor base) {\n    if (columnIdx == COLUMN_NAME) {\n      return base.getName();\n    }\n    else if (columnIdx == COLUMN_DOWNLOADS) {\n      //  Base class IdeaPluginDescriptor does not declare this field.\n      return (base instanceof PluginNode) ? ((PluginNode)base).getDownloads() : ((IdeaPluginDescriptorImpl)base).getDownloads();\n    }\n    if (columnIdx == COLUMN_DATE) {\n      //  Base class IdeaPluginDescriptor does not declare this field.\n      long date = (base instanceof PluginNode) ? ((PluginNode)base).getDate() : ((IdeaPluginDescriptorImpl)base).getDate();\n      if (date != 0) {\n        return DateFormat.getDateInstance(DateFormat.MEDIUM).format(new Date(date));\n      }\n      else {\n        return IdeBundle.message(\"plugin.info.not.available\");\n      }\n    }\n    else if (columnIdx == COLUMN_CATEGORY) {\n      return base instanceof PluginNode ? base.getCategory() : \"\";\n    }\n    else\n    // For COLUMN_STATUS - set of icons show the actual state of installed plugins.\n    {\n      return \"\";\n    }\n  }","id":23102,"modified_method":"public String valueOf(IdeaPluginDescriptor base) {\n    if (columnIdx == COLUMN_NAME) {\n      return base.getName();\n    }\n    else if (columnIdx == COLUMN_DOWNLOADS) {\n      //  Base class IdeaPluginDescriptor does not declare this field.\n      return (base instanceof PluginNode) ? ((PluginNode)base).getDownloads() : ((IdeaPluginDescriptorImpl)base).getDownloads();\n    }\n    if (columnIdx == COLUMN_DATE) {\n      //  Base class IdeaPluginDescriptor does not declare this field.\n      long date = (base instanceof PluginNode) ? ((PluginNode)base).getDate() : ((IdeaPluginDescriptorImpl)base).getDate();\n      if (date != 0) {\n        return DateFormat.getDateInstance(DateFormat.MEDIUM).format(new Date(date));\n      }\n      else {\n        return IdeBundle.message(\"plugin.info.not.available\");\n      }\n    }\n    else if (columnIdx == COLUMN_CATEGORY) {\n      return base.getCategory();\n    }\n    else\n    // For COLUMN_STATUS - set of icons show the actual state of installed plugins.\n    {\n      return \"\";\n    }\n  }","commit_id":"b5936b1a7a4aa78c89c4c4345f75bcbc13483145","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PluginManagerMain(final SortableProvider installedProvider, final SortableProvider availableProvider) {\n    myDescriptionTextArea.addHyperlinkListener(new MyHyperlinkListener());\n    myChangeNotesTextArea.addHyperlinkListener(new MyHyperlinkListener());\n\n    installedPluginsModel = new InstalledPluginsTableModel(installedProvider);\n    installedPluginTable = new PluginTable(installedPluginsModel);\n    JScrollPane installedScrollPane = ScrollPaneFactory.createScrollPane(installedPluginTable);\n    installedPluginTable.registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final int column = InstalledPluginsTableModel.getCheckboxColumn();\n        final int[] selectedRows = installedPluginTable.getSelectedRows();\n        boolean currentlyMarked = true;\n        for (final int selectedRow : selectedRows) {\n          if (selectedRow < 0 || !installedPluginTable.isCellEditable(selectedRow, column)) {\n            return;\n          }\n          currentlyMarked &= ((Boolean)installedPluginTable.getValueAt(selectedRow, column)).booleanValue();\n        }\n        for (int selectedRow : selectedRows) {\n          installedPluginTable.setValueAt(currentlyMarked ? Boolean.FALSE : Boolean.TRUE, selectedRow, column);\n        }\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0), JComponent.WHEN_FOCUSED);\n\n\n    availablePluginsModel = new AvailablePluginsTableModel(availableProvider);\n    availablePluginsTable = new PluginTable(availablePluginsModel);\n    JScrollPane availableScrollPane = ScrollPaneFactory.createScrollPane(availablePluginsTable);\n\n    installTableActions(installedPluginTable);\n    installTableActions(availablePluginsTable);\n\n    myHttpProxySettingsButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        HTTPProxySettingsDialog settingsDialog = new HTTPProxySettingsDialog();\n        settingsDialog.pack();\n        settingsDialog.show();\n        if ( settingsDialog.isOK() ) {\n          loadAvailablePlugins();\n        }\n      }\n    });\n\n    myReloadButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        loadAvailablePlugins();\n        myFilter.setFilter(\"\");\n      }\n    });\n\n    myTabbedPane = new TabbedPaneWrapper();\n    myTablePanel.add(myTabbedPane.getComponent(), BorderLayout.CENTER);\n    myTablePanel.setMinimumSize(new Dimension(400, -1));\n    myTabbedPane.addTab(IdeBundle.message(\"plugin.status.installed\"), installedScrollPane);\n    myTabbedPane.addTab(IdeBundle.message(\"plugin.status.available\"), availableScrollPane);\n    myTabbedPane.addChangeListener(new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        final PluginTable pluginTable = getPluginTable();\n        TableUtil.ensureSelectionExists(pluginTable);\n        pluginInfoUpdate(pluginTable.getSelectedObject());\n        myActionToolbar.updateActionsImmediately();\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            myFilter.filter();\n          }\n        });\n      }\n    });\n    GuiUtils.replaceJSplitPaneWithIDEASplitter(main);\n\n    myToolbarPanel.setLayout(new BorderLayout());\n    myActionToolbar = ActionManager.getInstance().createActionToolbar(\"PluginManaer\", getActionGroup(), true);\n    myToolbarPanel.add(myActionToolbar.getComponent(), BorderLayout.WEST);\n    myToolbarPanel.add(myFilter, BorderLayout.EAST);\n    myActionToolbar.updateActionsImmediately();\n  }","id":23103,"modified_method":"public PluginManagerMain(final SortableProvider installedProvider, final SortableProvider availableProvider) {\n    myDescriptionTextArea.addHyperlinkListener(new MyHyperlinkListener());\n    myChangeNotesTextArea.addHyperlinkListener(new MyHyperlinkListener());\n\n    installedPluginsModel = new InstalledPluginsTableModel(installedProvider);\n    installedPluginTable = new PluginTable(installedPluginsModel);\n    JScrollPane installedScrollPane = ScrollPaneFactory.createScrollPane(installedPluginTable);\n    installedPluginTable.registerKeyboardAction(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final int column = InstalledPluginsTableModel.getCheckboxColumn();\n        final int[] selectedRows = installedPluginTable.getSelectedRows();\n        boolean currentlyMarked = true;\n        for (final int selectedRow : selectedRows) {\n          if (selectedRow < 0 || !installedPluginTable.isCellEditable(selectedRow, column)) {\n            return;\n          }\n          currentlyMarked &= ((Boolean)installedPluginTable.getValueAt(selectedRow, column)).booleanValue();\n        }\n        for (int selectedRow : selectedRows) {\n          installedPluginTable.setValueAt(currentlyMarked ? Boolean.FALSE : Boolean.TRUE, selectedRow, column);\n        }\n      }\n    }, KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0), JComponent.WHEN_FOCUSED);\n\n\n    availablePluginsModel = new AvailablePluginsTableModel(availableProvider);\n    availablePluginsTable = new PluginTable(availablePluginsModel);\n    //  Downloads\n    availablePluginsTable.setColumnWidth(1, 70);\n    JScrollPane availableScrollPane = ScrollPaneFactory.createScrollPane(availablePluginsTable);\n\n    installTableActions(installedPluginTable);\n    installTableActions(availablePluginsTable);\n\n    myHttpProxySettingsButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        HTTPProxySettingsDialog settingsDialog = new HTTPProxySettingsDialog();\n        settingsDialog.pack();\n        settingsDialog.show();\n        if ( settingsDialog.isOK() ) {\n          loadAvailablePlugins();\n        }\n      }\n    });\n\n    myReloadButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        loadAvailablePlugins();\n        myFilter.setFilter(\"\");\n      }\n    });\n\n    myTabbedPane = new TabbedPaneWrapper();\n    myTablePanel.add(myTabbedPane.getComponent(), BorderLayout.CENTER);\n    myTablePanel.setMinimumSize(new Dimension(400, -1));\n    myTabbedPane.addTab(IdeBundle.message(\"plugin.status.installed\"), installedScrollPane);\n    myTabbedPane.addTab(IdeBundle.message(\"plugin.status.available\"), availableScrollPane);\n    myTabbedPane.addChangeListener(new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        final PluginTable pluginTable = getPluginTable();\n        TableUtil.ensureSelectionExists(pluginTable);\n        pluginInfoUpdate(pluginTable.getSelectedObject());\n        myActionToolbar.updateActionsImmediately();\n        SwingUtilities.invokeLater(new Runnable() {\n          public void run() {\n            myFilter.filter();\n          }\n        });\n      }\n    });\n    GuiUtils.replaceJSplitPaneWithIDEASplitter(main);\n\n    myToolbarPanel.setLayout(new BorderLayout());\n    myActionToolbar = ActionManager.getInstance().createActionToolbar(\"PluginManaer\", getActionGroup(), true);\n    myToolbarPanel.add(myActionToolbar.getComponent(), BorderLayout.WEST);\n    myToolbarPanel.add(myFilter, BorderLayout.EAST);\n    myActionToolbar.updateActionsImmediately();\n  }","commit_id":"b5936b1a7a4aa78c89c4c4345f75bcbc13483145","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PluginTable(final PluginTableModel model) {\n    super(model);\n\n    initializeHeader(model);\n\n    for (int i = 0; i < model.getColumnCount(); i++) {\n      TableColumn column = getColumnModel().getColumn(i);\n      final ColumnInfo columnInfo = model.getColumnInfos()[i];\n      column.setCellEditor(columnInfo.getEditor(null));\n      if (columnInfo.getColumnClass() == Boolean.class) {\n        String name = columnInfo.getName();\n        final int width;\n        final FontMetrics fontMetrics = getFontMetrics(getFont());\n        width = fontMetrics.stringWidth(\" \" + name + \" \") + 10;\n\n        column.setWidth(width);\n        column.setPreferredWidth(width);\n        column.setMaxWidth(width);\n        column.setMinWidth(width);\n      }\n    }\n\n    if (getColumnCount() > 2) {\n      //  Specify columns widths for particular columns:\n      //  Icon/Status\n      TableColumn column;/* = getColumnModel().getColumn(0);\n      column.setMinWidth(30);\n      column.setMaxWidth(30);*/\n\n      //  Downloads\n      column = getColumnModel().getColumn(1);\n      column.setMinWidth(70);\n      column.setMaxWidth(70);\n    }\n\n    setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n    setShowGrid(false);\n  }","id":23104,"modified_method":"public PluginTable(final PluginTableModel model) {\n    super(model);\n\n    initializeHeader(model);\n\n    for (int i = 0; i < model.getColumnCount(); i++) {\n      TableColumn column = getColumnModel().getColumn(i);\n      final ColumnInfo columnInfo = model.getColumnInfos()[i];\n      column.setCellEditor(columnInfo.getEditor(null));\n      if (columnInfo.getColumnClass() == Boolean.class) {\n        String name = columnInfo.getName();\n        final int width;\n        final FontMetrics fontMetrics = getFontMetrics(getFont());\n        width = fontMetrics.stringWidth(\" \" + name + \" \") + 10;\n\n        column.setWidth(width);\n        column.setPreferredWidth(width);\n        column.setMaxWidth(width);\n        column.setMinWidth(width);\n      }\n    }\n\n    setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n    setShowGrid(false);\n  }","commit_id":"b5936b1a7a4aa78c89c4c4345f75bcbc13483145","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void openMessageView() {\n    if (isHeadlessMode()) {\n      return;\n    }\n    if (myIndicator.isCanceled()) {\n      return;\n    }\n    final CompilerMessage[] deferred;\n    synchronized (myMessageViewLock) {\n      if (myErrorTreeView != null) {\n        return;\n      }\n      myErrorTreeView = new CompilerErrorTreeView(myProject);\n      myErrorTreeView.setProcessController(new NewErrorTreeViewPanel.ProcessController() {\n        public void stopProcess() {\n          cancel();\n        }\n\n        public boolean isProcessStopped() {\n          return !myIndicator.isRunning();\n        }\n      });\n      deferred = myDeferredMessages.toArray(new CompilerMessage[myDeferredMessages.size()]);\n      myDeferredMessages.clear();\n    }\n    \n    final Window window = getWindow();\n    final ModalityState modalityState = window != null ? ModalityState.stateForComponent(window) : ModalityState.NON_MODAL;\n    // the work with ToolWindowManager should be done in the Swing thread\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        final MessageView messageView = myProject.getComponent(MessageView.class);\n        final JComponent component;\n        synchronized (myMessageViewLock) {\n          component = myErrorTreeView.getComponent();\n        }\n        final Content content = PeerFactory.getInstance().getContentFactory().createContent(component, myContentName, true);\n        content.putUserData(CONTENT_ID_KEY, myContentId);\n        messageView.getContentManager().addContent(content);\n        new CloseListener(content, messageView.getContentManager());\n        removeAllContents(myProject, content);\n        messageView.getContentManager().setSelectedContent(content);\n        ToolWindow toolWindow = ToolWindowManager.getInstance(myProject).getToolWindow(ToolWindowId.MESSAGES_WINDOW);\n        if (toolWindow != null) {\n          if (CompilerWorkspaceConfiguration.getInstance(myProject).COMPILE_IN_BACKGROUND) {\n            toolWindow.activate(null);\n          }\n          else {\n            toolWindow.show(null);\n          }\n        }\n        updateProgressText();\n        for (CompilerMessage message : deferred) {\n          doAddMessage(message);\n        }\n      }\n    }, modalityState);\n  }","id":23105,"modified_method":"private void openMessageView() {\n    if (isHeadlessMode()) {\n      return;\n    }\n    if (myIndicator.isCanceled()) {\n      return;\n    }\n    final CompilerMessage[] deferred;\n    synchronized (myMessageViewLock) {\n      if (myErrorTreeView != null) {\n        return;\n      }\n      myErrorTreeView = new CompilerErrorTreeView(myProject);\n      myErrorTreeView.setProcessController(new NewErrorTreeViewPanel.ProcessController() {\n        public void stopProcess() {\n          cancel();\n        }\n\n        public boolean isProcessStopped() {\n          return !myIndicator.isRunning();\n        }\n      });\n    }\n    \n    final Window window = getWindow();\n    final ModalityState modalityState = window != null ? ModalityState.stateForComponent(window) : ModalityState.NON_MODAL;\n    // the work with ToolWindowManager should be done in the Swing thread\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        final MessageView messageView = myProject.getComponent(MessageView.class);\n        final JComponent component;\n        synchronized (myMessageViewLock) {\n          component = myErrorTreeView.getComponent();\n        }\n        final Content content = PeerFactory.getInstance().getContentFactory().createContent(component, myContentName, true);\n        content.putUserData(CONTENT_ID_KEY, myContentId);\n        messageView.getContentManager().addContent(content);\n        new CloseListener(content, messageView.getContentManager());\n        removeAllContents(myProject, content);\n        messageView.getContentManager().setSelectedContent(content);\n        updateProgressText();\n      }\n    }, modalityState);\n  }","commit_id":"a998988313052ec61c3822001d931a285ab55c13","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void closeUI() {\n    if (isHeadlessMode()) {\n      return;\n    }\n    Window window = getWindow();\n    ModalityState modalityState = window != null ? ModalityState.stateForComponent(window) : ModalityState.NON_MODAL;\n    final Application application = ApplicationManager.getApplication();\n    application.invokeLater(new Runnable() {\n      public void run() {\n        closeProgressDialog();\n        final boolean closeViewOnSuccess = CompilerWorkspaceConfiguration.getInstance(myProject).CLOSE_MESSAGE_VIEW_IF_SUCCESS;\n        synchronized (myMessageViewLock) {\n          if (myErrorTreeView != null) {\n            final boolean hasMessagesToRead = myErrorCount > 0 || (myWarningCount > 0 && !myErrorTreeView.isHideWarnings());\n            final boolean shouldRetainView = hasMessagesToRead || !closeViewOnSuccess;\n            if (shouldRetainView) {\n              addMessage(null, new CompilerMessageImpl(myProject, CompilerMessageCategory.STATISTICS,\n                                        CompilerBundle.message(\"statistics.error.count\", myErrorCount), null, -1, -1, null));\n              addMessage(null, new CompilerMessageImpl(myProject, CompilerMessageCategory.STATISTICS,\n                                        CompilerBundle.message(\"statistics.warnings.count\", myWarningCount), null, -1, -1, null));\n              activateMessageView();\n              myErrorTreeView.selectFirstMessage();\n            }\n            else {\n              removeAllContents(myProject, null);\n            }\n          }\n        }\n      }\n    }, modalityState);\n  }","id":23106,"modified_method":"private void closeUI() {\n    if (isHeadlessMode()) {\n      return;\n    }\n    Window window = getWindow();\n    ModalityState modalityState = window != null ? ModalityState.stateForComponent(window) : ModalityState.NON_MODAL;\n    final Application application = ApplicationManager.getApplication();\n    application.invokeLater(new Runnable() {\n      public void run() {\n        closeProgressDialog();\n        final boolean closeViewOnSuccess = CompilerWorkspaceConfiguration.getInstance(myProject).CLOSE_MESSAGE_VIEW_IF_SUCCESS;\n        synchronized (myMessageViewLock) {\n          if (myErrorTreeView != null) {\n            final boolean hasMessagesToRead = myErrorCount > 0 || (myWarningCount > 0 && !myErrorTreeView.isHideWarnings());\n            final boolean shouldRetainView = hasMessagesToRead || !closeViewOnSuccess;\n            if (shouldRetainView) {\n              addMessage(null, new CompilerMessageImpl(myProject, CompilerMessageCategory.STATISTICS,\n                                        CompilerBundle.message(\"statistics.error.count\", myErrorCount), null, -1, -1, null));\n              addMessage(null, new CompilerMessageImpl(myProject, CompilerMessageCategory.STATISTICS,\n                                        CompilerBundle.message(\"statistics.warnings.count\", myWarningCount), null, -1, -1, null));\n              //activateMessageView();\n              myErrorTreeView.selectFirstMessage();\n            }\n            else {\n              removeAllContents(myProject, null);\n            }\n          }\n        }\n      }\n    }, modalityState);\n  }","commit_id":"a998988313052ec61c3822001d931a285ab55c13","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addMessage(final CompileContext compileContext, final CompilerMessage message) {\n    prepareMessageView();\n\n    final CompilerMessageCategory messageCategory = message.getCategory();\n    if (CompilerMessageCategory.WARNING.equals(messageCategory)) {\n      myWarningCount += 1;\n    }\n    else if (CompilerMessageCategory.ERROR.equals(messageCategory)) {\n      myErrorCount += 1;\n      informWolf(message, compileContext);\n    }\n\n    synchronized (myMessageViewLock) {\n      if ( myErrorTreeView == null && (CompilerMessageCategory.INFORMATION.equals(messageCategory) || CompilerMessageCategory.STATISTICS.equals(messageCategory))) {\n        \n        myDeferredMessages.add(message);\n        return;\n      }\n    }\n\n    openMessageView();\n    if (ApplicationManager.getApplication().isDispatchThread()) {\n      doAddMessage(message);\n    }\n    else {\n      final Window window = getWindow();\n      final ModalityState modalityState = window != null ? ModalityState.stateForComponent(window) : ModalityState.NON_MODAL;\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          doAddMessage(message);\n        }\n      }, modalityState);\n    }\n  }","id":23107,"modified_method":"public void addMessage(final CompileContext compileContext, final CompilerMessage message) {\n    prepareMessageView();\n    openMessageView();\n\n    final CompilerMessageCategory messageCategory = message.getCategory();\n    if (CompilerMessageCategory.WARNING.equals(messageCategory)) {\n      myWarningCount += 1;\n    }\n    else if (CompilerMessageCategory.ERROR.equals(messageCategory)) {\n      myErrorCount += 1;\n      informWolf(message, compileContext);\n    }\n\n    if (ApplicationManager.getApplication().isDispatchThread()) {\n      doAddMessage(message);\n    }\n    else {\n      final Window window = getWindow();\n      final ModalityState modalityState = window != null ? ModalityState.stateForComponent(window) : ModalityState.NON_MODAL;\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        public void run() {\n          doAddMessage(message);\n        }\n      }, modalityState);\n    }\n  }","commit_id":"a998988313052ec61c3822001d931a285ab55c13","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doAddMessage(final CompilerMessage message) {\n    synchronized (myMessageViewLock) {\n      if (myErrorTreeView != null) {\n        final Navigatable navigatable = message.getNavigatable();\n        final VirtualFile file = message.getVirtualFile();\n        final int type = translateCategory(message.getCategory());\n        final String[] text = convertMessage(message);\n        if (navigatable != null) {\n          final String groupName = file != null? file.getPresentableUrl() : message.getCategory().getPresentableText();\n          myErrorTreeView.addMessage(type, text, groupName, navigatable, message.getExportTextPrefix(), message.getRenderTextPrefix(), null);\n        }\n        else {\n          myErrorTreeView.addMessage(type, text, file, -1, -1, null);\n        }\n      }\n    }\n  }","id":23108,"modified_method":"private void doAddMessage(final CompilerMessage message) {\n    synchronized (myMessageViewLock) {\n      if (myErrorTreeView != null) {\n        final Navigatable navigatable = message.getNavigatable();\n        final VirtualFile file = message.getVirtualFile();\n        final CompilerMessageCategory category = message.getCategory();\n        final int type = translateCategory(category);\n        final String[] text = convertMessage(message);\n        if (navigatable != null) {\n          final String groupName = file != null? file.getPresentableUrl() : category.getPresentableText();\n          myErrorTreeView.addMessage(type, text, groupName, navigatable, message.getExportTextPrefix(), message.getRenderTextPrefix(), null);\n        }\n        else {\n          myErrorTreeView.addMessage(type, text, file, -1, -1, null);\n        }\n        \n        final boolean shouldAutoActivate = !myMessagesAutoActivated && \n                                     (CompilerMessageCategory.ERROR.equals(category) || (CompilerMessageCategory.WARNING.equals(category) && !ErrorTreeViewConfiguration.getInstance(myProject).isHideWarnings()));\n        if (shouldAutoActivate) {\n          myMessagesAutoActivated = true;\n          activateMessageView();\n        }\n      }\n    }\n  }","commit_id":"a998988313052ec61c3822001d931a285ab55c13","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public int[] getSelectedIndices() {\n    return myList.getSelectedIndices();\n  }","id":23109,"modified_method":"@NotNull\n  public int[] getSelectedIndices() {\n    Object[] values = myList.getSelectedValues();\n    int[] result = new int[values.length];\n    for (int i = 0, length = values.length; i < length; i++) {\n      result[i] = ((Item)values[i]).index;\n    }\n    return result;\n  }","commit_id":"981126c9fcfc59ae8862260d6cccf617b456bbb2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected JComponent createCenterPanel() {\n    final int selectionMode = myAllowMultipleSelections ? ListSelectionModel.MULTIPLE_INTERVAL_SELECTION\n                                                        : ListSelectionModel.SINGLE_SELECTION;\n    myList.setSelectionMode(selectionMode);\n    if (myUseIdeaEditor) {\n      EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n      myList.setFont(scheme.getFont(EditorFontType.PLAIN));\n      Color fg = ObjectUtils.chooseNotNull(scheme.getDefaultForeground(), UIUtil.getListForeground());\n      Color bg = ObjectUtils.chooseNotNull(scheme.getDefaultBackground(), UIUtil.getListBackground());\n      myList.setForeground(fg);\n      myList.setBackground(bg);\n    }\n\n    rebuildListContent();\n\n    new DoubleClickListener() {\n      @Override\n      protected boolean onDoubleClick(MouseEvent e) {\n        close(OK_EXIT_CODE);\n        return true;\n      }\n    }.installOn(myList);\n\n\n    myList.setCellRenderer(new MyListCellRenderer());\n    myList.addKeyListener(new KeyAdapter() {\n      @Override\n      public void keyReleased(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_DELETE) {\n          int newSelectionIndex = -1;\n          for (int i : getSelectedIndices()) {\n            removeContentAt(myAllContents.get(i));\n            if (newSelectionIndex < 0) {\n              newSelectionIndex = i;\n            }\n          }\n          \n          rebuildListContent();\n          if (myAllContents.size() <= 0) {\n            close(CANCEL_EXIT_CODE);\n            return;\n          }\n          newSelectionIndex = Math.min(newSelectionIndex, myAllContents.size() - 1);\n          myList.setSelectedIndex(newSelectionIndex);\n        }\n        else if (e.getKeyCode() == KeyEvent.VK_ENTER) {\n          close(OK_EXIT_CODE);\n        }\n        else {\n          final char aChar = e.getKeyChar();\n          if (aChar >= '0' && aChar <= '9') {\n            int idx = aChar == '0' ? 9 : aChar - '1';\n            if (idx < myAllContents.size()) {\n              myList.setSelectedIndex(idx);\n            }\n          }\n        }\n      }\n    });\n\n    mySplitter.setFirstComponent(ScrollPaneFactory.createScrollPane(myList));\n    mySplitter.setSecondComponent(new JPanel());\n\n    ListScrollingUtil.installActions(myList);\n    ListScrollingUtil.ensureSelectionExists(myList);\n    updateViewerForSelection();\n    myList.addListSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        myUpdateAlarm.cancelAllRequests();\n        myUpdateAlarm.addRequest(new Runnable() {\n          @Override\n          public void run() {\n            updateViewerForSelection();\n          }\n        }, 100);\n      }\n    });\n\n    mySplitter.setPreferredSize(new Dimension(500, 500));\n\n    SplitterProportionsData d = new SplitterProportionsDataImpl();\n    d.externalizeToDimensionService(getClass().getName());\n    d.restoreSplitterProportions(mySplitter);\n\n    new ListSpeedSearch(myList);\n\n    return mySplitter;\n  }","id":23110,"modified_method":"@Override\n  protected JComponent createCenterPanel() {\n    final int selectionMode = myAllowMultipleSelections ? ListSelectionModel.MULTIPLE_INTERVAL_SELECTION\n                                                        : ListSelectionModel.SINGLE_SELECTION;\n    myList.setSelectionMode(selectionMode);\n    if (myUseIdeaEditor) {\n      EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n      myList.setFont(scheme.getFont(EditorFontType.PLAIN));\n      Color fg = ObjectUtils.chooseNotNull(scheme.getDefaultForeground(), UIUtil.getListForeground());\n      Color bg = ObjectUtils.chooseNotNull(scheme.getDefaultBackground(), UIUtil.getListBackground());\n      myList.setForeground(fg);\n      myList.setBackground(bg);\n    }\n\n    rebuildListContent();\n\n    new DoubleClickListener() {\n      @Override\n      protected boolean onDoubleClick(MouseEvent e) {\n        close(OK_EXIT_CODE);\n        return true;\n      }\n    }.installOn(myList);\n\n\n    myList.setCellRenderer(new MyListCellRenderer());\n    myList.addKeyListener(new KeyAdapter() {\n      @Override\n      public void keyReleased(KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_DELETE) {\n          int newSelectionIndex = -1;\n          for (Object o : myList.getSelectedValues()) {\n            int i = ((Item)o).index;\n            removeContentAt(myAllContents.get(i));\n            if (newSelectionIndex < 0) {\n              newSelectionIndex = i;\n            }\n          }\n          \n          rebuildListContent();\n          if (myAllContents.isEmpty()) {\n            close(CANCEL_EXIT_CODE);\n            return;\n          }\n          newSelectionIndex = Math.min(newSelectionIndex, myAllContents.size() - 1);\n          myList.setSelectedIndex(newSelectionIndex);\n        }\n        else if (e.getKeyCode() == KeyEvent.VK_ENTER) {\n          close(OK_EXIT_CODE);\n        }\n        else {\n          final char aChar = e.getKeyChar();\n          if (aChar >= '0' && aChar <= '9') {\n            int idx = aChar == '0' ? 9 : aChar - '1';\n            if (idx < myAllContents.size()) {\n              myList.setSelectedIndex(idx);\n            }\n          }\n        }\n      }\n    });\n\n    mySplitter.setFirstComponent(ListWithFilter.wrap(myList, ScrollPaneFactory.createScrollPane(myList), new Function<Object, String>() {\n      @Override\n      public String fun(Object o) {\n        return ((Item)o).longText;\n      }\n    }));\n    mySplitter.setSecondComponent(new JPanel());\n\n    ListScrollingUtil.installActions(myList);\n    ListScrollingUtil.ensureSelectionExists(myList);\n    updateViewerForSelection();\n    myList.addListSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        myUpdateAlarm.cancelAllRequests();\n        myUpdateAlarm.addRequest(new Runnable() {\n          @Override\n          public void run() {\n            updateViewerForSelection();\n          }\n        }, 100);\n      }\n    });\n\n    mySplitter.setPreferredSize(new Dimension(500, 500));\n\n    SplitterProportionsData d = new SplitterProportionsDataImpl();\n    d.externalizeToDimensionService(getClass().getName());\n    d.restoreSplitterProportions(mySplitter);\n\n    return mySplitter;\n  }","commit_id":"981126c9fcfc59ae8862260d6cccf617b456bbb2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void rebuildListContent() {\n    List<Data> allContents = new ArrayList<Data>(getContents());\n    ArrayList<String> shortened = new ArrayList<String>();\n    for (Data content : allContents) {\n      String fullString = getStringRepresentationFor(content);\n      if (fullString != null) {\n        fullString = StringUtil.convertLineSeparators(fullString);\n        int newLineIdx = fullString.indexOf('\\n');\n        if (newLineIdx == -1) {\n          shortened.add(fullString.trim());\n        }\n        else {\n          int lastLooked = 0;\n          do  {\n            int nextLineIdx = fullString.indexOf(\"\\n\", lastLooked);\n            if (nextLineIdx > lastLooked) {\n              shortened.add(fullString.substring(lastLooked, nextLineIdx).trim() + \" ...\");\n              break;\n            }\n            else if (nextLineIdx == -1) {\n              shortened.add(\" ...\");\n              break;\n            }\n            lastLooked = nextLineIdx + 1;\n          } while (true);\n        }\n      }\n    }\n\n    myAllContents = allContents;\n    myList.setListData(ArrayUtil.toStringArray(shortened));\n  }","id":23111,"modified_method":"private void rebuildListContent() {\n    ArrayList<Item> items = new ArrayList<Item>();\n    int i = 0;\n    List<Data> contents = new ArrayList<Data>(getContents());\n    for (Data content : contents) {\n      String fullString = getStringRepresentationFor(content);\n      if (fullString != null) {\n        String shortString;\n        fullString = StringUtil.convertLineSeparators(fullString);\n        int newLineIdx = fullString.indexOf('\\n');\n        if (newLineIdx == -1) {\n          shortString = fullString.trim(); \n        }\n        else {\n          int lastLooked = 0;\n          do  {\n            int nextLineIdx = fullString.indexOf(\"\\n\", lastLooked);\n            if (nextLineIdx > lastLooked) {\n              shortString = fullString.substring(lastLooked, nextLineIdx).trim() + \" ...\";\n              break;\n            }\n            else if (nextLineIdx == -1) {\n              shortString = \" ...\";\n              break;\n            }\n            lastLooked = nextLineIdx + 1;\n          } while (true);\n        }\n        items.add(new Item(i ++, shortString, fullString));\n      }\n    }\n    myAllContents = contents;\n    myList.setModel(new CollectionListModel<Item>(items));\n  }","commit_id":"981126c9fcfc59ae8862260d6cccf617b456bbb2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getSelectedText() {\n    String result = \"\";\n    for (int i : getSelectedIndices()) {\n      String s = getStringRepresentationFor(myAllContents.get(i));\n      result += StringUtil.convertLineSeparators(s);\n    }\n    return result;\n  }","id":23112,"modified_method":"@NotNull\n  public String getSelectedText() {\n    StringBuilder sb = new StringBuilder();\n    for (Object o : myList.getSelectedValues()) {\n      String s = ((Item)o).longText;\n      sb.append(StringUtil.convertLineSeparators(s));\n    }\n    return sb.toString();\n  }","commit_id":"981126c9fcfc59ae8862260d6cccf617b456bbb2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateViewerForSelection() {\n    if (myAllContents.size() == 0) return;\n    String fullString = \"\";\n    for (int i : getSelectedIndices()) {\n      String s = getStringRepresentationFor(myAllContents.get(i));\n      fullString += StringUtil.convertLineSeparators(s);\n    }\n\n    if (myViewer != null) {\n      EditorFactory.getInstance().releaseEditor(myViewer);\n    }\n\n    if (myUseIdeaEditor) {\n      myViewer = createIdeaEditor(fullString);\n      JComponent component = myViewer.getComponent();\n      component.setPreferredSize(new Dimension(300, 500));\n      mySplitter.setSecondComponent(component);\n    } else {\n      final JTextArea textArea = new JTextArea(fullString);\n      textArea.setRows(3);\n      textArea.setWrapStyleWord(true);\n      textArea.setLineWrap(true);\n      textArea.setSelectionStart(0);\n      textArea.setSelectionEnd(textArea.getText().length());\n      textArea.setEditable(false);\n      mySplitter.setSecondComponent(ScrollPaneFactory.createScrollPane(textArea));\n    }\n    mySplitter.revalidate();\n  }","id":23113,"modified_method":"private void updateViewerForSelection() {\n    if (myAllContents.isEmpty()) return;\n    String fullString = getSelectedText();\n\n    if (myViewer != null) {\n      EditorFactory.getInstance().releaseEditor(myViewer);\n    }\n\n    if (myUseIdeaEditor) {\n      myViewer = createIdeaEditor(fullString);\n      JComponent component = myViewer.getComponent();\n      component.setPreferredSize(new Dimension(300, 500));\n      mySplitter.setSecondComponent(component);\n    } else {\n      final JTextArea textArea = new JTextArea(fullString);\n      textArea.setRows(3);\n      textArea.setWrapStyleWord(true);\n      textArea.setLineWrap(true);\n      textArea.setSelectionStart(0);\n      textArea.setSelectionEnd(textArea.getText().length());\n      textArea.setEditable(false);\n      mySplitter.setSecondComponent(ScrollPaneFactory.createScrollPane(textArea));\n    }\n    mySplitter.revalidate();\n  }","commit_id":"981126c9fcfc59ae8862260d6cccf617b456bbb2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void customizeCellRenderer(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n      setIcon(myListEntryIcon);\n      if (myUseIdeaEditor) {\n        int max = list.getModel().getSize();\n        String indexString = String.valueOf(index + 1);\n        int count = String.valueOf(max).length() - indexString.length();\n        char[] spaces = new char[count];\n        Arrays.fill(spaces, ' ');\n        String prefix = indexString + new String(spaces) + \"  \";\n        append(prefix, SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      }\n      else if (UIUtil.isUnderGTKLookAndFeel()) {\n        // Fix GTK background\n        Color background = selected ? UIUtil.getListSelectionBackground() : UIUtil.getListBackground();\n        UIUtil.changeBackGround(this, background);\n      }\n      String text = (String)value;\n\n      FontMetrics metrics = list.getFontMetrics(list.getFont());\n      int charWidth = metrics.charWidth('m');\n      int maxLength = list.getParent().getParent().getWidth() * 3 / charWidth / 2;\n      text = StringUtil.first(text, maxLength, true); // do not paint long strings\n      append(text, SimpleTextAttributes.REGULAR_ATTRIBUTES);\n    }","id":23114,"modified_method":"@Override\n    protected void customizeCellRenderer(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n      setIcon(myListEntryIcon);\n      if (myUseIdeaEditor) {\n        int max = list.getModel().getSize();\n        String indexString = String.valueOf(index + 1);\n        int count = String.valueOf(max).length() - indexString.length();\n        char[] spaces = new char[count];\n        Arrays.fill(spaces, ' ');\n        String prefix = indexString + new String(spaces) + \"  \";\n        append(prefix, SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      }\n      else if (UIUtil.isUnderGTKLookAndFeel()) {\n        // Fix GTK background\n        Color background = selected ? UIUtil.getListSelectionBackground() : UIUtil.getListBackground();\n        UIUtil.changeBackGround(this, background);\n      }\n      String text = ((Item)value).shortText;\n\n      FontMetrics metrics = list.getFontMetrics(list.getFont());\n      int charWidth = metrics.charWidth('m');\n      int maxLength = list.getParent().getParent().getWidth() * 3 / charWidth / 2;\n      text = StringUtil.first(text, maxLength, true); // do not paint long strings\n      append(text, SimpleTextAttributes.REGULAR_ATTRIBUTES);\n    }","commit_id":"981126c9fcfc59ae8862260d6cccf617b456bbb2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getSelectedIndex() {\n    if (myList.getSelectedIndex() == -1) return 0;\n    return myList.getSelectedIndex();\n  }","id":23115,"modified_method":"public int getSelectedIndex() {\n    Object o = myList.getSelectedValue();\n    return o == null? 0 : ((Item)o).index;\n  }","commit_id":"981126c9fcfc59ae8862260d6cccf617b456bbb2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void onSpeedSearchPatternChanged() {\n    myModel.refilter();\n    if (myModel.getSize() > 0) {\n      int fullMatchIndex = myModel.getClosestMatchIndex();\n      if (fullMatchIndex != -1) {\n        myList.setSelectedIndex(fullMatchIndex);\n      }\n\n      if (myModel.getSize() <= myList.getSelectedIndex() || !myModel.contains((T)myList.getSelectedValue())) {\n        myList.setSelectedIndex(0);\n      }\n    }\n    else {\n      mySpeedSearchPatternField.setBackground(LightColors.RED);\n      revalidate();\n    }\n  }","id":23116,"modified_method":"protected void onSpeedSearchPatternChanged() {\n    T prevSelection = (T)myList.getSelectedValue(); // save to restore the selection on filter drop\n    myModel.refilter();\n    if (myModel.getSize() > 0) {\n      int fullMatchIndex = mySpeedSearch.isHoldingFilter() ? myModel.getClosestMatchIndex() : myModel.getElementIndex(prevSelection);\n      if (fullMatchIndex != -1) {\n        myList.setSelectedIndex(fullMatchIndex);\n      }\n\n      if (myModel.getSize() <= myList.getSelectedIndex() || !myModel.contains((T)myList.getSelectedValue())) {\n        myList.setSelectedIndex(0);\n      }\n    }\n    else {\n      mySpeedSearchPatternField.setBackground(LightColors.RED);\n      revalidate();\n    }\n  }","commit_id":"981126c9fcfc59ae8862260d6cccf617b456bbb2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static LogEntry formatForLog(@NotNull final Notification notification) {\n    DocumentImpl document = new DocumentImpl(true);\n    AtomicBoolean showMore = new AtomicBoolean(false);\n    Map<RangeMarker, HyperlinkInfo> links = new LinkedHashMap<RangeMarker, HyperlinkInfo>();\n    List<RangeMarker> lineSeparators = new ArrayList<RangeMarker>();\n\n    boolean hasHtml = parseHtmlContent(notification, document, showMore, links, lineSeparators);\n    removeJavaNewLines(document, lineSeparators, hasHtml);\n    insertNewLineSubstitutors(document, showMore, lineSeparators);\n\n    String status = document.getText();\n\n    ArrayList<Pair<TextRange, HyperlinkInfo>> list = new ArrayList<Pair<TextRange, HyperlinkInfo>>();\n    for (RangeMarker marker : links.keySet()) {\n      if (!marker.isValid()) {\n        showMore.set(true);\n        continue;\n      }\n      list.add(Pair.create(new TextRange(marker.getStartOffset(), marker.getEndOffset()), links.get(marker)));\n    }\n\n    if (showMore.get()) {\n      String sb = \"show balloon\";\n      appendText(document, \" (\" + sb + \")\");\n      list.add(new Pair<TextRange, HyperlinkInfo>(TextRange.from(document.getTextLength() - 1 - sb.length(), sb.length()),\n                                                  new ShowBalloon(notification)));\n    }\n\n    return new LogEntry(document.getText(), status, list);\n  }","id":23117,"modified_method":"public static LogEntry formatForLog(@NotNull final Notification notification) {\n    DocumentImpl logDoc = new DocumentImpl(true);\n    AtomicBoolean showMore = new AtomicBoolean(false);\n    Map<RangeMarker, HyperlinkInfo> links = new LinkedHashMap<RangeMarker, HyperlinkInfo>();\n    List<RangeMarker> lineSeparators = new ArrayList<RangeMarker>();\n\n    String title = notification.getTitle();\n    String content = notification.getContent();\n    RangeMarker afterTitle = null;\n    boolean hasHtml = parseHtmlContent(title, notification, logDoc, showMore, links, lineSeparators);\n    if (StringUtil.isNotEmpty(title)) {\n      if (StringUtil.isNotEmpty(content)) {\n        appendText(logDoc, \": \");\n        afterTitle = logDoc.createRangeMarker(logDoc.getTextLength() - 2, logDoc.getTextLength());\n      }\n    }\n    hasHtml |= parseHtmlContent(content, notification, logDoc, showMore, links, lineSeparators);\n\n    String status = getStatusText(logDoc, showMore, lineSeparators, hasHtml);\n\n    indentNewLines(logDoc, lineSeparators, afterTitle, hasHtml);\n\n    ArrayList<Pair<TextRange, HyperlinkInfo>> list = new ArrayList<Pair<TextRange, HyperlinkInfo>>();\n    for (RangeMarker marker : links.keySet()) {\n      if (!marker.isValid()) {\n        showMore.set(true);\n        continue;\n      }\n      list.add(Pair.create(new TextRange(marker.getStartOffset(), marker.getEndOffset()), links.get(marker)));\n    }\n\n    if (showMore.get()) {\n      String sb = \"show balloon\";\n      if (!logDoc.getText().endsWith(\" \")) {\n        appendText(logDoc, \" \");\n      }\n      appendText(logDoc, \"(\" + sb + \")\");\n      list.add(new Pair<TextRange, HyperlinkInfo>(TextRange.from(logDoc.getTextLength() - 1 - sb.length(), sb.length()),\n                                                  new ShowBalloon(notification)));\n    }\n\n    return new LogEntry(logDoc.getText(), status, list);\n  }","commit_id":"b1f5cbc4f5a4455075af51596098b2693f6e20f4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean parseHtmlContent(Notification notification,\n                                          Document document,\n                                          AtomicBoolean showMore,\n                                          Map<RangeMarker, HyperlinkInfo> links, List<RangeMarker> lineSeparators) {\n    String content = notification.getContent();\n    String title = notification.getTitle();\n    if (StringUtil.isNotEmpty(title)) {\n      content = title + (StringUtil.isNotEmpty(content) ? \": \" + content : \"\");\n    }\n\n    content = StringUtil.convertLineSeparators(content);\n    boolean hasHtml = false;\n    while (true) {\n      Matcher tagMatcher = TAG_PATTERN.matcher(content);\n      if (!tagMatcher.find()) {\n        appendText(document, content);\n        break;\n      }\n      \n      String tagStart = tagMatcher.group();\n      appendText(document, content.substring(0, tagMatcher.start()));\n      Matcher aMatcher = A_PATTERN.matcher(tagStart);\n      if (aMatcher.matches()) {\n        final String href = aMatcher.group(2);\n        int linkEnd = content.indexOf(A_CLOSING, tagMatcher.end());\n        if (linkEnd > 0) {\n          String linkText = content.substring(tagMatcher.end(), linkEnd).replaceAll(TAG_PATTERN.pattern(), \"\");\n          appendText(document, linkText);\n          links.put(document.createRangeMarker(new TextRange(document.getTextLength() - linkText.length(), document.getTextLength())),\n                    new NotificationHyperlinkInfo(notification, href));\n          content = content.substring(linkEnd + A_CLOSING.length());\n          continue;\n        }\n      }\n\n      hasHtml = true;\n      if (NEW_LINES.contains(tagStart)) {\n        lineSeparators.add(document.createRangeMarker(TextRange.from(document.getTextLength(), 0)));\n      }\n      else if (!\"<html>\".equals(tagStart) && !\"<\/html>\".equals(tagStart) && !\"<body>\".equals(tagStart) && !\"<\/body>\".equals(tagStart)) {\n        showMore.set(true);\n      }\n      content = content.substring(tagMatcher.end());\n    }\n    return hasHtml;\n  }","id":23118,"modified_method":"private static boolean parseHtmlContent(String text, Notification notification,\n                                          Document document,\n                                          AtomicBoolean showMore,\n                                          Map<RangeMarker, HyperlinkInfo> links, List<RangeMarker> lineSeparators) {\n    String content = StringUtil.convertLineSeparators(text);\n\n    int initialLen = document.getTextLength();\n    boolean hasHtml = false;\n    while (true) {\n      Matcher tagMatcher = TAG_PATTERN.matcher(content);\n      if (!tagMatcher.find()) {\n        appendText(document, content);\n        break;\n      }\n      \n      String tagStart = tagMatcher.group();\n      appendText(document, content.substring(0, tagMatcher.start()));\n      Matcher aMatcher = A_PATTERN.matcher(tagStart);\n      if (aMatcher.matches()) {\n        final String href = aMatcher.group(2);\n        int linkEnd = content.indexOf(A_CLOSING, tagMatcher.end());\n        if (linkEnd > 0) {\n          String linkText = content.substring(tagMatcher.end(), linkEnd).replaceAll(TAG_PATTERN.pattern(), \"\");\n          appendText(document, linkText);\n          links.put(document.createRangeMarker(new TextRange(document.getTextLength() - linkText.length(), document.getTextLength())),\n                    new NotificationHyperlinkInfo(notification, href));\n          content = content.substring(linkEnd + A_CLOSING.length());\n          continue;\n        }\n      }\n\n      hasHtml = true;\n      if (NEW_LINES.contains(tagStart)) {\n        if (initialLen != document.getTextLength()) {\n          lineSeparators.add(document.createRangeMarker(TextRange.from(document.getTextLength(), 0)));\n        }\n      }\n      else if (!\"<html>\".equals(tagStart) && !\"<\/html>\".equals(tagStart) && !\"<body>\".equals(tagStart) && !\"<\/body>\".equals(tagStart)) {\n        showMore.set(true);\n      }\n      content = content.substring(tagMatcher.end());\n    }\n    for (Iterator<RangeMarker> iterator = lineSeparators.iterator(); iterator.hasNext(); ) {\n      RangeMarker next = iterator.next();\n      if (next.getEndOffset() == document.getTextLength()) {\n        iterator.remove();\n      }\n    }\n    return hasHtml;\n  }","commit_id":"b1f5cbc4f5a4455075af51596098b2693f6e20f4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void insertNewLineSubstitutors(Document document, AtomicBoolean showMore, List<RangeMarker> lineSeparators) {\n    for (int j = lineSeparators.size() - 1; j >= 0; j--) {\n      RangeMarker marker = lineSeparators.get(j);\n      if (!marker.isValid()) {\n        showMore.set(true);\n        continue;\n      }\n      \n      int offset = marker.getStartOffset();\n      if (offset == 0 || offset == document.getTextLength()) {\n        continue;\n      }\n      boolean spaceBefore = offset > 0 && Character.isWhitespace(document.getCharsSequence().charAt(offset - 1));\n      if (offset < document.getTextLength()) {\n        boolean spaceAfter = Character.isWhitespace(document.getCharsSequence().charAt(offset));\n        int next = CharArrayUtil.shiftForward(document.getCharsSequence(), offset, \" \\t\");\n        if (next < document.getTextLength() && !Character.isLowerCase(document.getCharsSequence().charAt(next))) {\n          document.insertString(offset, (spaceBefore ? \"\" : \" \") + \"//\" + (spaceAfter ? \"\" : \" \"));\n          continue;\n        }\n        if (spaceAfter) {\n          continue;\n        }\n      }\n      if (spaceBefore) {\n        continue;\n      }\n\n      document.insertString(offset, \" \");\n    }\n  }","id":23119,"modified_method":"private static void insertNewLineSubstitutors(Document document, AtomicBoolean showMore, List<RangeMarker> lineSeparators) {\n    for (RangeMarker marker : lineSeparators) {\n      if (!marker.isValid()) {\n        showMore.set(true);\n        continue;\n      }\n      \n      int offset = marker.getStartOffset();\n      if (offset == 0 || offset == document.getTextLength()) {\n        continue;\n      }\n      boolean spaceBefore = offset > 0 && Character.isWhitespace(document.getCharsSequence().charAt(offset - 1));\n      if (offset < document.getTextLength()) {\n        boolean spaceAfter = Character.isWhitespace(document.getCharsSequence().charAt(offset));\n        int next = CharArrayUtil.shiftForward(document.getCharsSequence(), offset, \" \\t\");\n        if (next < document.getTextLength() && !Character.isLowerCase(document.getCharsSequence().charAt(next))) {\n          document.insertString(offset, (spaceBefore ? \"\" : \" \") + \"//\" + (spaceAfter ? \"\" : \" \"));\n          continue;\n        }\n        if (spaceAfter) {\n          continue;\n        }\n      }\n      if (spaceBefore) {\n        continue;\n      }\n\n      document.insertString(offset, \" \");\n    }\n  }","commit_id":"b1f5cbc4f5a4455075af51596098b2693f6e20f4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Converts all line separators in the specified string to the the platform's line separator.\n     */\n    public static String toPlatformLineSeparators(String str) {\n        return convertLineSeparators(str, getPlatformLineSeparator());\n    }","id":23120,"modified_method":"/**\n     * Converts all line separators in the specified string to the the platform's line separator.\n     */\n    public static String toPlatformLineSeparators(String str) {\n        return str == null ? null : convertLineSeparators(str, getPlatformLineSeparator());\n    }","commit_id":"f3507e7f5ed20ce835249b8b877726dabfdca9cc","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * <p>Escapes the toString() representation of {@code obj} for use in a literal string.<\/p>\n     * \n     * <p>This is useful for interpolating variables into script strings, as well as in other situations.<\/p>\n     */\n    public static String escapeString(Object obj) {\n        return StringEscapeUtils.escapeJava(obj.toString());\n    }","id":23121,"modified_method":"/**\n     * <p>Escapes the toString() representation of {@code obj} for use in a literal string.<\/p>\n     *\n     * <p>This is useful for interpolating variables into script strings, as well as in other situations.<\/p>\n     */\n    public static String escapeString(Object obj) {\n        return obj == null ? null : StringEscapeUtils.escapeJava(obj.toString());\n    }","commit_id":"f3507e7f5ed20ce835249b8b877726dabfdca9cc","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Converts all line separators in the specified string to the specified line separator.\n     */\n    public static String convertLineSeparators(String str, String sep) {\n        return str.replaceAll(\"\\r\\n|\\r|\\n\", sep);\n    }","id":23122,"modified_method":"/**\n     * Converts all line separators in the specified string to the specified line separator.\n     */\n    public static String convertLineSeparators(String str, String sep) {\n        return str == null ? null : str.replaceAll(\"\\r\\n|\\r|\\n\", sep);\n    }","commit_id":"f3507e7f5ed20ce835249b8b877726dabfdca9cc","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n  public void setText(@Nullable String text) {\n    super.setText(text != null ? StringUtil.convertLineSeparators(text) : null);\n  }","id":23123,"modified_method":"@Override\n  public void setText(@Nullable String text) {\n    if (text != null && !needSlashRSupport(text, isViewer())) {\n      text = StringUtil.convertLineSeparators(text);\n    }\n    super.setText(text);\n  }","commit_id":"8e37cda74c9ff652594791ac6c99b7e23fadcc1e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TextViewer(@NotNull String initialText, @NotNull Project project, boolean viewer) {\n    this(createDocument(initialText), project, true, viewer);\n  }","id":23124,"modified_method":"public TextViewer(@NotNull String initialText, @NotNull Project project, boolean viewer) {\n    this(createDocument(initialText, viewer), project, true, viewer);\n  }","commit_id":"8e37cda74c9ff652594791ac6c99b7e23fadcc1e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Document createDocument(@NotNull String initialText) {\n    final Document document = EditorFactory.getInstance().createDocument(StringUtil.convertLineSeparators(initialText));\n    //if (document instanceof DocumentImpl) {\n    //  ((DocumentImpl)document).setAcceptSlashR(true);\n    //}\n    return document;\n  }","id":23125,"modified_method":"private static Document createDocument(@NotNull String initialText, boolean viewer) {\n    if (needSlashRSupport(initialText, viewer)){\n      return ((EditorFactoryImpl)EditorFactory.getInstance()).createDocument(initialText, true, false);\n    }\n    else {\n      return EditorFactory.getInstance().createDocument(StringUtil.convertLineSeparators(initialText));\n    }\n  }","commit_id":"8e37cda74c9ff652594791ac6c99b7e23fadcc1e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int getEstimatedTasks()\n    {\n        long tasks = 0;\n        long[] estimated = new long[generations.length];\n\n        for (int i = generations.length - 1; i >= 0; i--)\n        {\n            List<SSTableReader> sstables = generations[i];\n            estimated[i] = Math.max(0L, SSTableReader.getTotalBytes(sstables) - maxBytesForLevel(i)) / maxSSTableSizeInBytes;\n            tasks += estimated[i];\n        }\n\n        logger.debug(\"Estimating {} compactions to do for {}.{}\",\n                     Arrays.toString(estimated), cfs.keyspace.getName(), cfs.name);\n        return Ints.checkedCast(tasks);\n    }","id":23126,"modified_method":"public synchronized int getEstimatedTasks()\n    {\n        long tasks = 0;\n        long[] estimated = new long[generations.length];\n\n        for (int i = generations.length - 1; i >= 0; i--)\n        {\n            List<SSTableReader> sstables = generations[i];\n\t    // If there is 1 byte over TBL - (MBL * 1.001), there is still a task left, so we need to round up.\n\t    estimated[i] = (long)Math.ceil((double)Math.max(0L, SSTableReader.getTotalBytes(sstables) - (long)(maxBytesForLevel(i) * 1.001)) / (double)maxSSTableSizeInBytes);\n            tasks += estimated[i];\n        }\n\n        logger.debug(\"Estimating {} compactions to do for {}.{}\",\n                     Arrays.toString(estimated), cfs.keyspace.getName(), cfs.name);\n        return Ints.checkedCast(tasks);\n    }","commit_id":"08147376aa16570c07a4522931cc8fa330519d3e","url":"https://github.com/apache/cassandra"},{"original_method":"public synchronized Collection<SSTableReader> getCompactionCandidates()\n    {\n        // LevelDB gives each level a score of how much data it contains vs its ideal amount, and\n        // compacts the level with the highest score. But this falls apart spectacularly once you\n        // get behind.  Consider this set of levels:\n        // L0: 988 [ideal: 4]\n        // L1: 117 [ideal: 10]\n        // L2: 12  [ideal: 100]\n        //\n        // The problem is that L0 has a much higher score (almost 250) than L1 (11), so what we'll\n        // do is compact a batch of MAX_COMPACTING_L0 sstables with all 117 L1 sstables, and put the\n        // result (say, 120 sstables) in L1. Then we'll compact the next batch of MAX_COMPACTING_L0,\n        // and so forth.  So we spend most of our i/o rewriting the L1 data with each batch.\n        //\n        // If we could just do *all* L0 a single time with L1, that would be ideal.  But we can't\n        // -- see the javadoc for MAX_COMPACTING_L0.\n        //\n        // LevelDB's way around this is to simply block writes if L0 compaction falls behind.\n        // We don't have that luxury.\n        //\n        // So instead, we force compacting higher levels first.  This may not minimize the number\n        // of reads done as quickly in the short term, but it minimizes the i/o needed to compact\n        // optimially which gives us a long term win.\n        for (int i = generations.length - 1; i >= 0; i--)\n        {\n            List<SSTableReader> sstables = generations[i];\n            if (sstables.isEmpty())\n                continue; // mostly this just avoids polluting the debug log with zero scores\n            double score = SSTableReader.getTotalBytes(sstables) / maxBytesForLevel(i);\n            logger.debug(\"Compaction score for level {} is {}\", i, score);\n\n            // L0 gets a special case that if we don't have anything more important to do,\n            // we'll go ahead and compact even just one sstable\n            if (score > 1.001 || i == 0)\n            {\n                Collection<SSTableReader> candidates = getCandidatesFor(i);\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Compaction candidates for L{} are {}\", i, toString(candidates));\n                return candidates;\n            }\n        }\n\n        return Collections.emptyList();\n    }","id":23127,"modified_method":"public synchronized Collection<SSTableReader> getCompactionCandidates()\n    {\n        // LevelDB gives each level a score of how much data it contains vs its ideal amount, and\n        // compacts the level with the highest score. But this falls apart spectacularly once you\n        // get behind.  Consider this set of levels:\n        // L0: 988 [ideal: 4]\n        // L1: 117 [ideal: 10]\n        // L2: 12  [ideal: 100]\n        //\n        // The problem is that L0 has a much higher score (almost 250) than L1 (11), so what we'll\n        // do is compact a batch of MAX_COMPACTING_L0 sstables with all 117 L1 sstables, and put the\n        // result (say, 120 sstables) in L1. Then we'll compact the next batch of MAX_COMPACTING_L0,\n        // and so forth.  So we spend most of our i/o rewriting the L1 data with each batch.\n        //\n        // If we could just do *all* L0 a single time with L1, that would be ideal.  But we can't\n        // -- see the javadoc for MAX_COMPACTING_L0.\n        //\n        // LevelDB's way around this is to simply block writes if L0 compaction falls behind.\n        // We don't have that luxury.\n        //\n        // So instead, we force compacting higher levels first.  This may not minimize the number\n        // of reads done as quickly in the short term, but it minimizes the i/o needed to compact\n        // optimially which gives us a long term win.\n        for (int i = generations.length - 1; i >= 0; i--)\n        {\n            List<SSTableReader> sstables = generations[i];\n            if (sstables.isEmpty())\n                continue; // mostly this just avoids polluting the debug log with zero scores\n            double score = (double)SSTableReader.getTotalBytes(sstables) / (double)maxBytesForLevel(i);\n            logger.debug(\"Compaction score for level {} is {}\", i, score);\n\n            // L0 gets a special case that if we don't have anything more important to do,\n            // we'll go ahead and compact even just one sstable\n            if (score > 1.001 || i == 0)\n            {\n                Collection<SSTableReader> candidates = getCandidatesFor(i);\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Compaction candidates for L{} are {}\", i, toString(candidates));\n                return candidates;\n            }\n        }\n\n        return Collections.emptyList();\n    }","commit_id":"b663210576a2ca9534d17d2c757e87a8726a8d0c","url":"https://github.com/apache/cassandra"},{"original_method":"public synchronized Collection<SSTableReader> getCompactionCandidates()\n    {\n        // LevelDB gives each level a score of how much data it contains vs its ideal amount, and\n        // compacts the level with the highest score. But this falls apart spectacularly once you\n        // get behind.  Consider this set of levels:\n        // L0: 988 [ideal: 4]\n        // L1: 117 [ideal: 10]\n        // L2: 12  [ideal: 100]\n        //\n        // The problem is that L0 has a much higher score (almost 250) than L1 (11), so what we'll\n        // do is compact a batch of MAX_COMPACTING_L0 sstables with all 117 L1 sstables, and put the\n        // result (say, 120 sstables) in L1. Then we'll compact the next batch of MAX_COMPACTING_L0,\n        // and so forth.  So we spend most of our i/o rewriting the L1 data with each batch.\n        //\n        // If we could just do *all* L0 a single time with L1, that would be ideal.  But we can't\n        // -- see the javadoc for MAX_COMPACTING_L0.\n        //\n        // LevelDB's way around this is to simply block writes if L0 compaction falls behind.\n        // We don't have that luxury.\n        //\n        // So instead, we force compacting higher levels first.  This may not minimize the number\n        // of reads done as quickly in the short term, but it minimizes the i/o needed to compact\n        // optimially which gives us a long term win.\n        for (int i = generations.length - 1; i >= 0; i--)\n        {\n            List<SSTableReader> sstables = generations[i];\n            if (sstables.isEmpty())\n                continue; // mostly this just avoids polluting the debug log with zero scores\n            double score = SSTableReader.getTotalBytes(sstables) / maxBytesForLevel(i);\n            logger.debug(\"Compaction score for level {} is {}\", i, score);\n\n            // L0 gets a special case that if we don't have anything more important to do,\n            // we'll go ahead and compact even just one sstable\n            if (score > 1.001 || i == 0)\n            {\n                Collection<SSTableReader> candidates = getCandidatesFor(i);\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Compaction candidates for L{} are {}\", i, toString(candidates));\n                return candidates;\n            }\n        }\n\n        return Collections.emptyList();\n    }","id":23128,"modified_method":"public synchronized Collection<SSTableReader> getCompactionCandidates()\n    {\n        // LevelDB gives each level a score of how much data it contains vs its ideal amount, and\n        // compacts the level with the highest score. But this falls apart spectacularly once you\n        // get behind.  Consider this set of levels:\n        // L0: 988 [ideal: 4]\n        // L1: 117 [ideal: 10]\n        // L2: 12  [ideal: 100]\n        //\n        // The problem is that L0 has a much higher score (almost 250) than L1 (11), so what we'll\n        // do is compact a batch of MAX_COMPACTING_L0 sstables with all 117 L1 sstables, and put the\n        // result (say, 120 sstables) in L1. Then we'll compact the next batch of MAX_COMPACTING_L0,\n        // and so forth.  So we spend most of our i/o rewriting the L1 data with each batch.\n        //\n        // If we could just do *all* L0 a single time with L1, that would be ideal.  But we can't\n        // -- see the javadoc for MAX_COMPACTING_L0.\n        //\n        // LevelDB's way around this is to simply block writes if L0 compaction falls behind.\n        // We don't have that luxury.\n        //\n        // So instead, we force compacting higher levels first.  This may not minimize the number\n        // of reads done as quickly in the short term, but it minimizes the i/o needed to compact\n        // optimially which gives us a long term win.\n        for (int i = generations.length - 1; i >= 0; i--)\n        {\n            List<SSTableReader> sstables = generations[i];\n            if (sstables.isEmpty())\n                continue; // mostly this just avoids polluting the debug log with zero scores\n            double score = (double)SSTableReader.getTotalBytes(sstables) / (double)maxBytesForLevel(i);\n            logger.debug(\"Compaction score for level {} is {}\", i, score);\n\n            // L0 gets a special case that if we don't have anything more important to do,\n            // we'll go ahead and compact even just one sstable\n            if (score > 1.001 || i == 0)\n            {\n                Collection<SSTableReader> candidates = getCandidatesFor(i);\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Compaction candidates for L{} are {}\", i, toString(candidates));\n                return candidates;\n            }\n        }\n\n        return Collections.emptyList();\n    }","commit_id":"26083f71f1fa39b74fbc6ffbad1a0abfb60fdd9b","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Constructor.<p>\n     * \n     * @param buttonData the tool-bar button data\n     * @param handler the container-page handler\n     */\n    public A_CmsToolbarMenu(I_CmsButton.ButtonData buttonData, CmsContainerpageHandler handler) {\n\n        super(buttonData.getTitle(), buttonData.getIconClass());\n        setToolbarMode(true);\n        setOpenRight(true);\n        m_handler = handler;\n        setTitle(buttonData.getTitle());\n        m_iconClass = buttonData.getIconClass();\n    }","id":23129,"modified_method":"/**\n     * Constructor.<p>\n     * \n     * @param buttonData the tool-bar button data\n     * @param handler the container-page handler\n     */\n    public A_CmsToolbarMenu(I_CmsButton.ButtonData buttonData, CmsContainerpageHandler handler) {\n\n        super(null, buttonData.getIconClass());\n        setToolbarMode(true);\n        setOpenRight(true);\n        m_handler = handler;\n        setTitle(buttonData.getTitle());\n        m_iconClass = buttonData.getIconClass();\n    }","commit_id":"9e98d12d19930e643b9578ec2ff067dfa4e468e4","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see com.google.gwt.core.client.EntryPoint#onModuleLoad()\n     */\n    @Override\n    public void onModuleLoad() {\n\n        super.onModuleLoad();\n\n        I_CmsLayoutBundle.INSTANCE.containerpageCss().ensureInjected();\n        I_CmsLayoutBundle.INSTANCE.dragdropCss().ensureInjected();\n        I_CmsLayoutBundle.INSTANCE.groupcontainerCss().ensureInjected();\n\n        CmsContainerpageController controller = new CmsContainerpageController();\n        final CmsContainerpageHandler containerpageHandler = new CmsContainerpageHandler(controller, this);\n        CmsContentEditorHandler contentEditorHandler = new CmsContentEditorHandler(containerpageHandler);\n        CmsContainerpageDNDController dndController = new CmsContainerpageDNDController(controller);\n        CmsDNDHandler dndHandler = new CmsDNDHandler(dndController);\n\n        ClickHandler clickHandler = new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent event) {\n\n                I_CmsToolbarButton source = (I_CmsToolbarButton)event.getSource();\n                source.onToolbarClick();\n            }\n        };\n\n        //        m_bodyMarginTop = CmsDomUtil.getCurrentStyleInt(Document.get().getBody(), Style.marginTop);\n        m_toolbar = new CmsToolbar();\n\n        CmsPushButton toggleToolbarButton = new CmsPushButton();\n        toggleToolbarButton.setImageClass(I_CmsImageBundle.INSTANCE.style().opencmsSymbol());\n        RootPanel root = RootPanel.get();\n        root.add(toggleToolbarButton);\n        toggleToolbarButton.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent event) {\n\n                containerpageHandler.toggleToolbar();\n            }\n\n        });\n\n        // TODO: use CSS for these properties\n        toggleToolbarButton.getElement().getStyle().setPosition(Position.FIXED);\n        toggleToolbarButton.getElement().getStyle().setTop(-3, Unit.PX);\n        toggleToolbarButton.getElement().getStyle().setLeft(97, Unit.PCT);\n        toggleToolbarButton.getElement().getStyle().setZIndex(10010);\n\n        m_publish = new CmsToolbarPublishButton(containerpageHandler);\n        m_publish.addClickHandler(clickHandler);\n        m_toolbar.addLeft(m_publish);\n\n        m_save = new CmsToolbarSaveButton(containerpageHandler);\n        m_save.addClickHandler(clickHandler);\n        m_toolbar.addLeft(m_save);\n\n        m_selection = new CmsToolbarSelectionButton(containerpageHandler);\n        m_selection.addClickHandler(clickHandler);\n        m_toolbar.addLeft(m_selection);\n\n        m_move = new CmsToolbarMoveButton(containerpageHandler, dndHandler);\n        m_move.addClickHandler(clickHandler);\n        m_toolbar.addLeft(m_move);\n\n        m_edit = new CmsToolbarEditButton(containerpageHandler);\n        m_edit.addClickHandler(clickHandler);\n        m_toolbar.addLeft(m_edit);\n\n        m_addToFavorites = new CmsAddToFavoritesButton(containerpageHandler);\n\n        m_remove = new CmsToolbarRemoveButton(containerpageHandler);\n        m_remove.addClickHandler(clickHandler);\n        m_toolbar.addLeft(m_remove);\n\n        m_properties = new CmsToolbarPropertiesButton(containerpageHandler);\n        m_properties.addClickHandler(clickHandler);\n        m_toolbar.addLeft(m_properties);\n\n        m_add = new CmsToolbarGalleryMenu(containerpageHandler, dndHandler);\n        m_add.addClickHandler(clickHandler);\n        m_toolbar.addLeft(m_add);\n\n        m_clipboard = new CmsToolbarClipboardMenu(containerpageHandler);\n        m_clipboard.addClickHandler(clickHandler);\n        m_toolbar.addLeft(m_clipboard);\n\n        m_sitemap = new CmsToolbarSitemapButton(containerpageHandler);\n        m_sitemap.addClickHandler(clickHandler);\n        m_toolbar.addRight(m_sitemap);\n\n        if (controller.getData().getSitemapUri().equals(\"\")) {\n            m_sitemap.setEnabled(false);\n        }\n\n        m_context = new CmsToolbarContextButton(containerpageHandler);\n        m_context.addClickHandler(clickHandler);\n        m_toolbar.addRight(m_context);\n\n        m_reset = new CmsToolbarResetButton(containerpageHandler);\n        m_reset.addClickHandler(clickHandler);\n        m_toolbar.addRight(m_reset);\n\n        containerpageHandler.enableSaveReset(false);\n        m_toolbarVisibility = new CmsStyleVariable(root);\n        m_toolbarVisibility.setValue(org.opencms.gwt.client.ui.css.I_CmsLayoutBundle.INSTANCE.toolbarCss().toolbarHide());\n        root.add(m_toolbar);\n        if (controller.getData().isToolbarVisible()) {\n            showToolbar(true);\n            containerpageHandler.activateSelection();\n        }\n\n        CmsContainerpageUtil containerpageUtil = new CmsContainerpageUtil(\n            controller,\n            m_selection,\n            m_move,\n            m_edit,\n            m_remove,\n            m_properties,\n            m_addToFavorites);\n        controller.init(containerpageHandler, dndHandler, contentEditorHandler, containerpageUtil);\n\n    }","id":23130,"modified_method":"/**\n     * @see com.google.gwt.core.client.EntryPoint#onModuleLoad()\n     */\n    @Override\n    public void onModuleLoad() {\n\n        super.onModuleLoad();\n\n        I_CmsLayoutBundle.INSTANCE.containerpageCss().ensureInjected();\n        I_CmsLayoutBundle.INSTANCE.dragdropCss().ensureInjected();\n        I_CmsLayoutBundle.INSTANCE.groupcontainerCss().ensureInjected();\n\n        CmsContainerpageController controller = new CmsContainerpageController();\n        final CmsContainerpageHandler containerpageHandler = new CmsContainerpageHandler(controller, this);\n        CmsContentEditorHandler contentEditorHandler = new CmsContentEditorHandler(containerpageHandler);\n        CmsContainerpageDNDController dndController = new CmsContainerpageDNDController(controller);\n        CmsDNDHandler dndHandler = new CmsDNDHandler(dndController);\n\n        ClickHandler clickHandler = new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent event) {\n\n                I_CmsToolbarButton source = (I_CmsToolbarButton)event.getSource();\n                source.onToolbarClick();\n            }\n        };\n\n        //        m_bodyMarginTop = CmsDomUtil.getCurrentStyleInt(Document.get().getBody(), Style.marginTop);\n        m_toolbar = new CmsToolbar();\n\n        CmsPushButton toggleToolbarButton = new CmsPushButton();\n        toggleToolbarButton.setImageClass(I_CmsImageBundle.INSTANCE.style().opencmsSymbol());\n        RootPanel root = RootPanel.get();\n        root.add(toggleToolbarButton);\n        toggleToolbarButton.addClickHandler(new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent event) {\n\n                containerpageHandler.toggleToolbar();\n            }\n\n        });\n\n        // TODO: use CSS for these properties\n        toggleToolbarButton.getElement().getStyle().setPosition(Position.FIXED);\n        toggleToolbarButton.getElement().getStyle().setTop(-3, Unit.PX);\n        toggleToolbarButton.getElement().getStyle().setLeft(97, Unit.PCT);\n        toggleToolbarButton.getElement().getStyle().setZIndex(10010);\n\n        m_publish = new CmsToolbarPublishButton(containerpageHandler);\n        m_publish.addClickHandler(clickHandler);\n        m_toolbar.addLeft(m_publish);\n\n        m_save = new CmsToolbarSaveButton(containerpageHandler);\n        m_save.addClickHandler(clickHandler);\n        m_toolbar.addLeft(m_save);\n\n        m_move = new CmsToolbarMoveButton(containerpageHandler, dndHandler);\n\n        m_edit = new CmsToolbarEditButton(containerpageHandler);\n\n        m_addToFavorites = new CmsAddToFavoritesButton(containerpageHandler);\n\n        m_remove = new CmsToolbarRemoveButton(containerpageHandler);\n\n        m_properties = new CmsToolbarPropertiesButton(containerpageHandler);\n\n        m_clipboard = new CmsToolbarClipboardMenu(containerpageHandler);\n        m_clipboard.addClickHandler(clickHandler);\n        m_toolbar.addLeft(m_clipboard);\n\n        m_add = new CmsToolbarGalleryMenu(containerpageHandler, dndHandler);\n        m_add.addClickHandler(clickHandler);\n        m_toolbar.addLeft(m_add);\n\n        m_selection = new CmsToolbarSelectionButton(containerpageHandler);\n        m_selection.addClickHandler(clickHandler);\n        m_toolbar.addLeft(m_selection);\n\n        m_context = new CmsToolbarContextButton(containerpageHandler);\n        m_context.addClickHandler(clickHandler);\n        m_toolbar.addRight(m_context);\n\n        m_sitemap = new CmsToolbarSitemapButton(containerpageHandler);\n        m_sitemap.addClickHandler(clickHandler);\n        m_toolbar.addRight(m_sitemap);\n\n        if (controller.getData().getSitemapUri().equals(\"\")) {\n            m_sitemap.setEnabled(false);\n        }\n\n        m_reset = new CmsToolbarResetButton(containerpageHandler);\n        m_reset.addClickHandler(clickHandler);\n        m_toolbar.addRight(m_reset);\n\n        containerpageHandler.enableSaveReset(false);\n        m_toolbarVisibility = new CmsStyleVariable(root);\n        m_toolbarVisibility.setValue(org.opencms.gwt.client.ui.css.I_CmsLayoutBundle.INSTANCE.toolbarCss().toolbarHide());\n        root.add(m_toolbar);\n        if (controller.getData().isToolbarVisible()) {\n            showToolbar(true);\n            containerpageHandler.activateSelection();\n        }\n\n        CmsContainerpageUtil containerpageUtil = new CmsContainerpageUtil(\n            controller,\n            m_selection,\n            m_move,\n            m_edit,\n            m_remove,\n            m_properties,\n            m_addToFavorites);\n        controller.init(containerpageHandler, dndHandler, contentEditorHandler, containerpageUtil);\n\n    }","commit_id":"9e98d12d19930e643b9578ec2ff067dfa4e468e4","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Transforms a list of context menu entry beans to a list of context menu entries.<p>\n     * \n     * @param menuBeans the list of context menu entry beans\n     * @param structureId the id of the resource for which to transform the context menu entries \n     * \n     * @return a list of context menu entries \n     */\n    public List<I_CmsContextMenuEntry> transformEntries(\n        List<CmsContextMenuEntryBean> menuBeans,\n        final CmsUUID structureId) {\n\n        List<I_CmsContextMenuEntry> menuEntries = new ArrayList<I_CmsContextMenuEntry>();\n        for (CmsContextMenuEntryBean bean : menuBeans) {\n            String name = bean.getName();\n            I_CmsContextMenuCommand command = null;\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(name)) {\n                command = getContextMenuCommands().get(name);\n            }\n            CmsContextMenuEntry entry = new CmsContextMenuEntry(this, structureId, command);\n            entry.setBean(bean);\n            if (bean.hasSubMenu()) {\n                entry.setSubMenu(transformEntries(bean.getSubMenu(), structureId));\n            }\n            menuEntries.add(entry);\n        }\n        return menuEntries;\n    }","id":23131,"modified_method":"/**\n     * Transforms a list of context menu entry beans to a list of context menu entries.<p>\n     * \n     * @param menuBeans the list of context menu entry beans\n     * @param structureId the id of the resource for which to transform the context menu entries \n     * \n     * @return a list of context menu entries \n     */\n    public List<I_CmsContextMenuEntry> transformEntries(\n        List<CmsContextMenuEntryBean> menuBeans,\n        final CmsUUID structureId) {\n\n        List<I_CmsContextMenuEntry> menuEntries = new ArrayList<I_CmsContextMenuEntry>();\n        for (CmsContextMenuEntryBean bean : menuBeans) {\n            String name = bean.getName();\n            I_CmsContextMenuCommand command = null;\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(name)) {\n                command = getContextMenuCommands().get(name);\n            }\n            if (command == null) {\n                continue;\n            }\n            CmsContextMenuEntry entry = new CmsContextMenuEntry(this, structureId, command);\n            entry.setBean(bean);\n            if (bean.hasSubMenu()) {\n                entry.setSubMenu(transformEntries(bean.getSubMenu(), structureId));\n            }\n            menuEntries.add(entry);\n        }\n        return menuEntries;\n    }","commit_id":"4c141e50b687066ce3d2acfa6a053e746cdcddc8","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * @see org.opencms.gwt.client.ui.contextmenu.I_CmsContextMenuCommand#getCommandIconClass()\r\n     */\r\n    public String getCommandIconClass() {\r\n\r\n        //TODO: use a better icon \r\n        return org.opencms.gwt.client.ui.css.I_CmsImageBundle.INSTANCE.contextMenuIcons().move();\r\n    }","id":23132,"modified_method":"/**\r\n     * @see org.opencms.gwt.client.ui.contextmenu.I_CmsContextMenuCommand#getCommandIconClass()\r\n     */\r\n    public String getCommandIconClass() {\r\n\r\n        //TODO: use a better icon \r\n        return org.opencms.gwt.client.ui.css.I_CmsImageBundle.INSTANCE.contextMenuIcons().rename();\r\n    }","commit_id":"4c141e50b687066ce3d2acfa6a053e746cdcddc8","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a new result list item with a main widget.<p>\n     * \n     * @param resultItem the result item\n     * @param hasPreview if the item has a preview option\n     * @param dndHandler the drag and drop handler\n     */\n    public CmsResultListItem(CmsResultItemBean resultItem, boolean hasPreview, CmsDNDHandler dndHandler) {\n\n        resultItem.addAdditionalInfo(Messages.get().key(Messages.GUI_PREVIEW_LABEL_PATH_0), resultItem.getPath());\n        CmsResultItemWidget resultItemWidget = new CmsResultItemWidget(resultItem);\n        resultItemWidget.setUnselectable();\n        initContent(resultItemWidget);\n        if (dndHandler != null) {\n            setId(resultItem.getClientId());\n            if (resultItem.getTitle() != null) {\n                setName(resultItem.getTitle().toLowerCase().replace(\"/\", \"-\").replace(\" \", \"_\"));\n            } else {\n                setName(resultItem.getClientId());\n            }\n            initMoveHandle(dndHandler);\n        } else {\n            if (resultItemWidget.hasTileView()) {\n                addStyleName(I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().tilingItem());\n            }\n        }\n        // add  preview button\n        if (hasPreview) {\n            m_previewButton = createButton(\n                I_CmsImageBundle.INSTANCE.style().searchIcon(),\n                Messages.get().key(Messages.GUI_PREVIEW_BUTTON_SHOW_0));\n            resultItemWidget.addButton(m_previewButton);\n        }\n        m_selectButton = createButton(\n            I_CmsImageBundle.INSTANCE.style().addIcon(),\n            Messages.get().key(Messages.GUI_PREVIEW_BUTTON_SELECT_0));\n        m_selectButton.setVisible(false);\n        resultItemWidget.addButton(m_selectButton);\n\n        // add file icon\n        resultItemWidget.setIcon(CmsIconUtil.getResourceIconClasses(resultItem.getType(), resultItem.getPath(), false));\n        if (!resultItem.isReleasedAndNotExpired()) {\n            addStyleName(I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().expired());\n        }\n    }","id":23133,"modified_method":"/**\n     * Creates a new result list item with a main widget.<p>\n     * \n     * @param resultItem the result item\n     * @param hasPreview if the item has a preview option\n     * @param dndHandler the drag and drop handler\n     */\n    public CmsResultListItem(CmsResultItemBean resultItem, boolean hasPreview, CmsDNDHandler dndHandler) {\n\n        resultItem.addAdditionalInfo(Messages.get().key(Messages.GUI_PREVIEW_LABEL_PATH_0), resultItem.getPath());\n        CmsResultItemWidget resultItemWidget = new CmsResultItemWidget(resultItem);\n        resultItemWidget.setUnselectable();\n        initContent(resultItemWidget);\n        if (dndHandler != null) {\n            setId(resultItem.getClientId());\n            if (resultItem.getTitle() != null) {\n                setName(resultItem.getTitle().toLowerCase().replace(\"/\", \"-\").replace(\" \", \"_\"));\n            } else {\n                setName(resultItem.getClientId());\n            }\n            initMoveHandle(dndHandler);\n        } else {\n            if (resultItemWidget.hasTileView()) {\n                addStyleName(I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().tilingItem());\n            }\n        }\n        // add  preview button\n        if (hasPreview) {\n            m_previewButton = createButton(\n                I_CmsImageBundle.INSTANCE.style().previewIcon(),\n                Messages.get().key(Messages.GUI_PREVIEW_BUTTON_SHOW_0));\n            resultItemWidget.addButton(m_previewButton);\n        }\n        m_selectButton = createButton(\n            I_CmsImageBundle.INSTANCE.style().checkIcon(),\n            Messages.get().key(Messages.GUI_PREVIEW_BUTTON_SELECT_0));\n        m_selectButton.setVisible(false);\n        resultItemWidget.addButton(m_selectButton);\n\n        // add file icon\n        resultItemWidget.setIcon(CmsIconUtil.getResourceIconClasses(resultItem.getType(), resultItem.getPath(), false));\n        if (!resultItem.isReleasedAndNotExpired()) {\n            addStyleName(I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().expired());\n        }\n    }","commit_id":"4c141e50b687066ce3d2acfa6a053e746cdcddc8","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Constructor.<p>\n     * \n     * @param controller the sitemap controller \n     */\n    public CmsSitemapToolbar(CmsSitemapController controller) {\n\n        addLeft(new CmsToolbarPublishButton(this, controller));\n        m_newMenuButton = new CmsToolbarNewButton(this, controller);\n        if (controller.isEditable() && (controller.getData().getDefaultNewElementInfo() != null)) {\n            addLeft(m_newMenuButton);\n            addLeft(new CmsToolbarClipboardButton(this, controller));\n        }\n        addLeft(new CmsToolbarShowNonNavigationButton());\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(controller.getData().getParentSitemap())) {\n            addRight(new CmsToolbarGoToParentButton(this, controller));\n        }\n        addRight(new CmsToolbarRefreshButton(this, controller));\n        addRight(new CmsToolbarGoBackButton(this, controller));\n        ClickHandler clickHandler = new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent event) {\n\n                I_CmsToolbarButton source = (I_CmsToolbarButton)event.getSource();\n                source.onToolbarClick();\n            }\n        };\n        m_contextMenuButton = new CmsToolbarContextButton(new CmsSitemapToolbarHandler(\n            controller.getData().getContextMenuEntries()));\n        m_contextMenuButton.addClickHandler(clickHandler);\n        addRight(m_contextMenuButton);\n    }","id":23134,"modified_method":"/**\n     * Constructor.<p>\n     * \n     * @param controller the sitemap controller \n     */\n    public CmsSitemapToolbar(CmsSitemapController controller) {\n\n        addLeft(new CmsToolbarPublishButton(this, controller));\n        m_newMenuButton = new CmsToolbarNewButton(this, controller);\n        if (controller.isEditable() && (controller.getData().getDefaultNewElementInfo() != null)) {\n            addLeft(new CmsToolbarClipboardButton(this, controller));\n            addLeft(m_newMenuButton);\n        }\n        addLeft(new CmsToolbarShowNonNavigationButton());\n        ClickHandler clickHandler = new ClickHandler() {\n\n            /**\n             * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n             */\n            public void onClick(ClickEvent event) {\n\n                I_CmsToolbarButton source = (I_CmsToolbarButton)event.getSource();\n                source.onToolbarClick();\n            }\n        };\n        m_contextMenuButton = new CmsToolbarContextButton(new CmsSitemapToolbarHandler(\n            controller.getData().getContextMenuEntries()));\n        m_contextMenuButton.addClickHandler(clickHandler);\n        addRight(m_contextMenuButton);\n        addRight(new CmsToolbarGoBackButton(this, controller));\n    }","commit_id":"4c141e50b687066ce3d2acfa6a053e746cdcddc8","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * @see org.opencms.gwt.client.ui.A_CmsToolbarHandler#transformEntries(java.util.List, org.opencms.util.CmsUUID)\r\n     */\r\n    @Override\r\n    public List<I_CmsContextMenuEntry> transformEntries(List<CmsContextMenuEntryBean> menuBeans, CmsUUID structureId) {\r\n\r\n        // TODO: do this with server side rules!!\r\n        List<I_CmsContextMenuEntry> result = super.transformEntries(menuBeans, structureId);\r\n        if (!CmsSitemapView.getInstance().getController().getData().canEditAliases()) {\r\n            Iterator<I_CmsContextMenuEntry> it = result.iterator();\r\n            while (it.hasNext()) {\r\n                I_CmsContextMenuEntry entry = it.next();\r\n                if (entry.getName().equals(CmsAliasDialog.class.getName())) {\r\n                    it.remove();\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }","id":23135,"modified_method":"/**\r\n     * @see org.opencms.gwt.client.ui.A_CmsToolbarHandler#transformEntries(java.util.List, org.opencms.util.CmsUUID)\r\n     */\r\n    @Override\r\n    public List<I_CmsContextMenuEntry> transformEntries(List<CmsContextMenuEntryBean> menuBeans, CmsUUID structureId) {\r\n\r\n        List<I_CmsContextMenuEntry> result = super.transformEntries(menuBeans, structureId);\r\n        return result;\r\n    }","commit_id":"4c141e50b687066ce3d2acfa6a053e746cdcddc8","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * @see org.opencms.gwt.client.ui.contextmenu.I_CmsContextMenuHandler#getContextMenuCommands()\r\n     */\r\n    public Map<String, I_CmsContextMenuCommand> getContextMenuCommands() {\r\n\r\n        if (m_contextMenuCommands == null) {\r\n            I_CmsContextMenuCommandInitializer initializer = GWT.create(I_CmsContextMenuCommandInitializer.class);\r\n            m_contextMenuCommands = initializer.initCommands();\r\n        }\r\n        return m_contextMenuCommands;\r\n    }","id":23136,"modified_method":"/**\r\n     * @see org.opencms.gwt.client.ui.contextmenu.I_CmsContextMenuHandler#getContextMenuCommands()\r\n     */\r\n    public Map<String, I_CmsContextMenuCommand> getContextMenuCommands() {\r\n\r\n        if (m_contextMenuCommands == null) {\r\n            I_CmsContextMenuCommandInitializer initializer = GWT.create(I_CmsContextMenuCommandInitializer.class);\r\n            m_contextMenuCommands = initializer.initCommands();\r\n            List<String> toRemove = new ArrayList<String>();\r\n            for (Map.Entry<String, I_CmsContextMenuCommand> entry : m_contextMenuCommands.entrySet()) {\r\n                I_CmsContextMenuCommand command = entry.getValue();\r\n                if ((command != null)\r\n                    && (command instanceof I_CmsDisableable)\r\n                    && ((I_CmsDisableable)command).isDisabled()) {\r\n                    toRemove.add(entry.getKey());\r\n                }\r\n            }\r\n            for (String removeKey : toRemove) {\r\n                m_contextMenuCommands.remove(removeKey);\r\n            }\r\n        }\r\n        return m_contextMenuCommands;\r\n    }","commit_id":"4c141e50b687066ce3d2acfa6a053e746cdcddc8","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Constructor.<p>\n     * \n     * @param toolbar the toolbar instance\n     * @param controller the sitemap controller \n     */\n    public CmsToolbarNewButton(CmsSitemapToolbar toolbar, CmsSitemapController controller) {\n\n        super(\n            Messages.get().key(Messages.GUI_TOOLBAR_NEW_BUTTON_TITLE_0),\n            I_CmsButton.ButtonData.NEW.getIconClass(),\n            toolbar,\n            controller);\n    }","id":23137,"modified_method":"/**\n     * Constructor.<p>\n     * \n     * @param toolbar the toolbar instance\n     * @param controller the sitemap controller \n     */\n    public CmsToolbarNewButton(CmsSitemapToolbar toolbar, CmsSitemapController controller) {\n\n        super(\n            Messages.get().key(Messages.GUI_TOOLBAR_NEW_BUTTON_TITLE_0),\n            I_CmsToolbarButtonLayoutBundle.INSTANCE.toolbarButtonCss().toolbarAdd(),\n            toolbar,\n            controller);\n    }","commit_id":"4c141e50b687066ce3d2acfa6a053e746cdcddc8","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private static void setTextValue(@Nullable String val, String filter, JEditorPane pane) {\n    if (val != null) {\n      pane.setText(SearchUtil.markup(TEXT_PREFIX + val + TEXT_SUFIX, filter).trim());\n      pane.setCaretPosition(0);\n    }\n    else {\n      pane.setText(TEXT_PREFIX + TEXT_SUFIX);\n    }\n  }","id":23138,"modified_method":"private static void setTextValue(@Nullable StringBuilder text, @Nullable String filter, JEditorPane pane) {\n    if (text != null) {\n      text.insert(0, TEXT_PREFIX);\n      text.append(TEXT_SUFIX);\n      pane.setText(SearchUtil.markup(text.toString(), filter).trim());\n      pane.setCaretPosition(0);\n    }\n    else {\n      pane.setText(TEXT_PREFIX + TEXT_SUFIX);\n    }\n  }","commit_id":"1dce6476a3aae911832eb9c4049cac2ea8ac87bd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void pluginInfoUpdate(Object plugin, @Nullable final String filter, final JEditorPane descriptionTextArea) {\n    if (plugin instanceof IdeaPluginDescriptor) {\n      IdeaPluginDescriptor pluginDescriptor = (IdeaPluginDescriptor)plugin;\n\n      String description = pluginDescriptor.getDescription();\n      String changeNotes = pluginDescriptor.getChangeNotes();\n      if (!StringUtil.isEmpty(changeNotes)) {\n        description += \"<h4>Change Notes<\/h4>\";\n        description += changeNotes;\n      }\n\n      if (!pluginDescriptor.isBundled()) {\n        description += \"<h4>Vendor<\/h4>\";\n        String vendor = pluginDescriptor.getVendor();\n        if (!StringUtil.isEmpty(vendor)) {\n          description += vendor;\n        }\n\n        String vendorEmail = pluginDescriptor.getVendorEmail();\n        if (!StringUtil.isEmpty(vendorEmail)) {\n          description += \"<br>\";\n          description += composeHref(\"mailto:\" + vendorEmail);\n        }\n\n        String vendorUrl = pluginDescriptor.getVendorUrl();\n        if (!StringUtil.isEmpty(vendorUrl)) {\n          description += \"<br>\" + composeHref(vendorUrl);\n        }\n\n\n        String pluginDescriptorUrl = pluginDescriptor.getUrl();\n        if (!StringUtil.isEmpty(pluginDescriptorUrl)) {\n          description += \"<br><h4>Plugin homepage<\/h4>\" + composeHref(pluginDescriptorUrl);\n        }\n\n        String version = pluginDescriptor.getVersion();\n        if (!StringUtil.isEmpty(version)) {\n          description += \"<h4>Version<\/h4>\" + version;\n        }\n\n        String size = plugin instanceof PluginNode ? ((PluginNode)plugin).getSize() : null;\n        if (!StringUtil.isEmpty(size)) {\n          description += \"<br>Size: \" + PluginManagerColumnInfo.getFormattedSize(size);\n        }\n      }\n\n      setTextValue(description, filter, descriptionTextArea);\n    }\n    else {\n      setTextValue(null, filter, descriptionTextArea);\n    }\n  }","id":23139,"modified_method":"public static void pluginInfoUpdate(Object plugin, @Nullable String filter, @NotNull JEditorPane descriptionTextArea) {\n    if (plugin instanceof IdeaPluginDescriptor) {\n      IdeaPluginDescriptor pluginDescriptor = (IdeaPluginDescriptor)plugin;\n      StringBuilder sb = new StringBuilder();\n\n      String description = pluginDescriptor.getDescription();\n      if (!isEmptyOrSpaces(description)) {\n        sb.append(description);\n      }\n\n      String changeNotes = pluginDescriptor.getChangeNotes();\n      if (!isEmptyOrSpaces(changeNotes)) {\n        sb.append(\"<h4>Change Notes<\/h4>\");\n        sb.append(changeNotes);\n      }\n\n      if (!pluginDescriptor.isBundled()) {\n        String vendor = pluginDescriptor.getVendor();\n        String vendorEmail = pluginDescriptor.getVendorEmail();\n        String vendorUrl = pluginDescriptor.getVendorUrl();\n        if (!isEmptyOrSpaces(vendor) || !isEmptyOrSpaces(vendorEmail) || !isEmptyOrSpaces(vendorUrl)) {\n          sb.append(\"<h4>Vendor<\/h4>\");\n\n          if (!isEmptyOrSpaces(vendor)) {\n            sb.append(vendor);\n          }\n          if (!isEmptyOrSpaces(vendorUrl)) {\n            sb.append(\"<br>\").append(composeHref(vendorUrl));\n          }\n          if (!isEmptyOrSpaces(vendorEmail)) {\n            sb.append(\"<br>\").append(composeHref(\"mailto:\" + vendorEmail));\n          }\n        }\n\n        String pluginDescriptorUrl = pluginDescriptor.getUrl();\n        if (!isEmptyOrSpaces(pluginDescriptorUrl)) {\n          sb.append(\"<h4>Plugin homepage<\/h4>\").append(composeHref(pluginDescriptorUrl));\n        }\n\n        String version = pluginDescriptor.getVersion();\n        if (!isEmptyOrSpaces(version)) {\n          sb.append(\"<h4>Version<\/h4>\").append(version);\n        }\n\n        String size = plugin instanceof PluginNode ? ((PluginNode)plugin).getSize() : null;\n        if (!isEmptyOrSpaces(size)) {\n          sb.append(\"<h4>Size<\/h4>\").append(PluginManagerColumnInfo.getFormattedSize(size));\n        }\n      }\n\n      setTextValue(sb, filter, descriptionTextArea);\n    }\n    else {\n      setTextValue(null, filter, descriptionTextArea);\n    }\n  }","commit_id":"1dce6476a3aae911832eb9c4049cac2ea8ac87bd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized boolean isRemote(int classId) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      return view.isRemote();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23140,"modified_method":"public boolean isRemote(int classId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        return view.isRemote();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int[] getClassReferencers(int classDeclarationId) throws CacheCorruptedException {\n    try {\n      final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n      return view.getReferencers();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23141,"modified_method":"public int[] getClassReferencers(int classDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassDeclarationsLock()) {\n        final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n        return view.getReferencers();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int importClassInfo(ClassFileReader reader, SymbolTable symbolTable) throws ClsFormatException, CacheCorruptedException {\n    final int qName = symbolTable.getId(reader.getQualifiedName());\n\n    try {\n      final ClassInfoView classInfoView = myViewPool.getClassInfoView(getClassId(qName));\n      final int id = classInfoView.getRecordId();\n\n      classInfoView.setQualifiedName(qName);\n\n      final String signature = reader.getGenericSignature();\n      final int genericSignature = signature != null? symbolTable.getId(signature) : -1;\n      classInfoView.setGenericSignature(genericSignature);\n\n      classInfoView.setPath(reader.getPath());\n\n      final String superClass = reader.getSuperClass();\n      final int superQName = \"\".equals(superClass)? UNKNOWN : symbolTable.getId(superClass);\n\n      LOG.assertTrue(superQName != qName);\n\n      classInfoView.setSuperQualifiedName(superQName);\n\n      final String[] superInterfaces = reader.getSuperInterfaces();\n      final int[] interfaceNames = new int[superInterfaces.length];\n      for (int idx = 0; idx < superInterfaces.length; idx++) {\n        interfaceNames[idx] = symbolTable.getId(superInterfaces[idx]);\n      }\n      classInfoView.setSuperInterfaces(interfaceNames);\n\n      final String sourceFileName = reader.getSourceFileName();\n      if (sourceFileName != null) {\n        classInfoView.setSourceFileName(sourceFileName);\n      }\n\n      classInfoView.setFlags(reader.getAccessFlags());\n\n      classInfoView.setRuntimeVisibleAnnotations(reader.getRuntimeVisibleAnnotations());\n\n      classInfoView.setRuntimeInvisibleAnnotations(reader.getRuntimeInvisibleAnnotations());\n\n      classInfoView.setReferences(reader.getReferences());\n\n      final FieldInfo[] fields = reader.getFields();\n      final MethodInfo[] methods = reader.getMethods();\n      MemberInfo[] members = ArrayUtil.mergeArrays(fields, methods, MemberInfo.class);\n      updateMemberDeclarations(qName, members);\n\n      registerClassId(qName, id);\n    }\n    catch (ClsFormatException e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n    return qName;\n  }","id":23142,"modified_method":"public int importClassInfo(ClassFileReader reader, SymbolTable symbolTable) throws ClsFormatException, CacheCorruptedException {\n    final int qName = symbolTable.getId(reader.getQualifiedName());\n\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView classInfoView = myViewPool.getClassInfoView(getClassId(qName));\n        final int id = classInfoView.getRecordId();\n\n        classInfoView.setQualifiedName(qName);\n\n        final String signature = reader.getGenericSignature();\n        final int genericSignature = signature != null? symbolTable.getId(signature) : -1;\n        classInfoView.setGenericSignature(genericSignature);\n\n        classInfoView.setPath(reader.getPath());\n\n        final String superClass = reader.getSuperClass();\n        final int superQName = \"\".equals(superClass)? UNKNOWN : symbolTable.getId(superClass);\n\n        LOG.assertTrue(superQName != qName);\n\n        classInfoView.setSuperQualifiedName(superQName);\n\n        final String[] superInterfaces = reader.getSuperInterfaces();\n        final int[] interfaceNames = new int[superInterfaces.length];\n        for (int idx = 0; idx < superInterfaces.length; idx++) {\n          interfaceNames[idx] = symbolTable.getId(superInterfaces[idx]);\n        }\n        classInfoView.setSuperInterfaces(interfaceNames);\n\n        final String sourceFileName = reader.getSourceFileName();\n        if (sourceFileName != null) {\n          classInfoView.setSourceFileName(sourceFileName);\n        }\n\n        classInfoView.setFlags(reader.getAccessFlags());\n\n        classInfoView.setRuntimeVisibleAnnotations(reader.getRuntimeVisibleAnnotations());\n\n        classInfoView.setRuntimeInvisibleAnnotations(reader.getRuntimeInvisibleAnnotations());\n\n        classInfoView.setReferences(reader.getReferences());\n\n        getQNameToClassInfoIdMap().put(qName, id);\n      }\n\n      final FieldInfo[] fields = reader.getFields();\n      final MethodInfo[] methods = reader.getMethods();\n      MemberInfo[] members = ArrayUtil.mergeArrays(fields, methods, MemberInfo.class);\n      updateMemberDeclarations(qName, members);\n\n    }\n    catch (ClsFormatException e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n    return qName;\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void removeMethodDeclaration(int classDeclarationId, int methodId) throws IOException, CacheCorruptedException {\n    final ClassDeclarationView classDeclarationView = myViewPool.getClassDeclarationView(classDeclarationId);\n    classDeclarationView.removeMethodId(methodId);\n    myViewPool.removeMethodDeclarationRecord(myViewPool.getMethodDeclarationView(methodId));\n  }","id":23143,"modified_method":"private void removeMethodDeclaration(int classDeclarationId, int methodId) throws IOException, CacheCorruptedException {\n    synchronized (myViewPool.getClassDeclarationsLock()) {\n      final ClassDeclarationView classDeclarationView = myViewPool.getClassDeclarationView(classDeclarationId);\n      classDeclarationView.removeMethodId(methodId);\n    }\n    synchronized (myViewPool.getMethodDeclarationsLock()) {\n      myViewPool.removeMethodDeclarationRecord(myViewPool.getMethodDeclarationView(methodId));\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int getFieldDescriptor(int fieldDeclarationId) throws CacheCorruptedException {\n    try {\n      final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldDeclarationId);\n      return view.getDescriptor();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23144,"modified_method":"public int getFieldDescriptor(int fieldDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getFieldDeclarationsLock()) {\n        final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldDeclarationId);\n        return view.getDescriptor();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized AnnotationConstantValue[][] getMethodRuntimeVisibleParamAnnotations(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n      return view.getRuntimeVisibleParamAnnotations();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23145,"modified_method":"public AnnotationConstantValue[][] getMethodRuntimeVisibleParamAnnotations(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getMethodDeclarationsLock()) {\n        final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n        return view.getRuntimeVisibleParamAnnotations();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int[] findMethodsByName(final int classDeclarationId, final int name) throws CacheCorruptedException{\n    try {\n      final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n      final int[] ids = view.getMethodIds();\n      final TIntArrayList list = new TIntArrayList();\n      for (final int id : ids) {\n        final NameDescriptorPair pair = view.getMethodNameAndDescriptor(id);\n        if (pair != null && pair.name == name) {\n          list.add(id);\n        }\n      }\n      return list.toNativeArray();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23146,"modified_method":"public int[] findMethodsByName(final int classDeclarationId, final int name) throws CacheCorruptedException{\n    try {\n      final TIntArrayList list;\n      synchronized (myViewPool.getClassDeclarationsLock()) {\n        final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n        final int[] ids = view.getMethodIds();\n        list = new TIntArrayList();\n        for (final int id : ids) {\n          final NameDescriptorPair pair = view.getMethodNameAndDescriptor(id);\n          if (pair != null && pair.name == name) {\n            list.add(id);\n          }\n        }\n      }\n      return list.toNativeArray();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized AnnotationConstantValue[] getMethodRuntimeVisibleAnnotations(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n      return view.getRuntimeVisibleAnnotations();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23147,"modified_method":"public AnnotationConstantValue[] getMethodRuntimeVisibleAnnotations(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getMethodDeclarationsLock()) {\n        final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n        return view.getRuntimeVisibleAnnotations();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized Collection<ReferenceInfo> getReferences(int classId) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      return view.getReferences();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23148,"modified_method":"public Collection<ReferenceInfo> getReferences(int classId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        return view.getReferences();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized String getSourceFileName(int classId) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      return view.getSourceFileName();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23149,"modified_method":"public String getSourceFileName(int classId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        return view.getSourceFileName();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void setSourceFileName(int classId, String name) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      view.setSourceFileName(name);\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23150,"modified_method":"public void setSourceFileName(int classId, String name) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        view.setSourceFileName(name);\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int[] getMethodReferencers(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n      return view.getReferencers();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23151,"modified_method":"public int[] getMethodReferencers(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getMethodDeclarationsLock()) {\n        final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n        return view.getReferencers();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int getSuperQualifiedName(int classId) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      return view.getSuperQualifiedName();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23152,"modified_method":"public int getSuperQualifiedName(int classId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        return view.getSuperQualifiedName();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int[] getSuperInterfaces(int classId) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      return view.getSuperInterfaces();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23153,"modified_method":"public int[] getSuperInterfaces(int classId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        return view.getSuperInterfaces();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int[] getReferencedClassQNames(int classId) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      return view.getReferencedClasses();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23154,"modified_method":"public int[] getReferencedClassQNames(int classId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        return view.getReferencedClasses();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int getMethodDescriptor(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n      return view.getDescriptor();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23155,"modified_method":"public int getMethodDescriptor(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getMethodDeclarationsLock()) {\n        final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n        return view.getDescriptor();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int[] getAllClassNames() throws CacheCorruptedException {\n    try {\n      return getQNameToClassInfoIdMap().keys();\n    }\n    catch (IOException e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23156,"modified_method":"public int[] getAllClassNames() throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        return getQNameToClassInfoIdMap().keys();\n      }\n    }\n    catch (IOException e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateMemberDeclarations(int classQName, MemberInfo[] classMembers) throws CacheCorruptedException{\n    try {\n      final int classDeclarationId = getClassDeclarationId(classQName);\n\n      final int[] fieldIds = getFieldIds(classDeclarationId);\n      final int[] methodIds = getMethodIds(classDeclarationId);\n      TObjectIntHashMap<MemberInfo> currentMembers = new TObjectIntHashMap<MemberInfo>();\n      for (final int fieldId : fieldIds) {\n        currentMembers.put(createFieldInfo(fieldId), fieldId);\n      }\n      for (final int methodId : methodIds) {\n        currentMembers.put(createMethodInfo(methodId), methodId);\n      }\n\n      final TIntHashSet fieldsToRemove = new TIntHashSet(fieldIds);\n      final TIntHashSet methodsToRemove = new TIntHashSet(methodIds);\n\n      for (final MemberInfo classMember : classMembers) {\n        if (currentMembers.containsKey(classMember)) { // changed\n          final int memberId = currentMembers.get(classMember);\n          if (classMember instanceof FieldInfo) {\n            fieldsToRemove.remove(memberId);\n          }\n          else if (classMember instanceof MethodInfo) {\n            methodsToRemove.remove(memberId);\n          }\n          putMember(classDeclarationId, memberId, classMember);\n        }\n        else { // added\n          putMember(classDeclarationId, UNKNOWN, classMember);\n        }\n      }\n\n      if (!fieldsToRemove.isEmpty()) {\n        final int[] fieldsArray = fieldsToRemove.toArray();\n        for (int aFieldsArray : fieldsArray) {\n          removeFieldDeclaration(classDeclarationId, aFieldsArray);\n        }\n      }\n\n      if (!methodsToRemove.isEmpty()) {\n        final int[] methodsArray = methodsToRemove.toArray();\n        for (int aMethodsArray : methodsArray) {\n          removeMethodDeclaration(classDeclarationId, aMethodsArray);\n        }\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23157,"modified_method":"private void updateMemberDeclarations(int classQName, MemberInfo[] classMembers) throws CacheCorruptedException{\n    try {\n      final int classDeclarationId = getClassDeclarationId(classQName);\n\n      final int[] fieldIds = getFieldIds(classDeclarationId);\n      final int[] methodIds = getMethodIds(classDeclarationId);\n      final TObjectIntHashMap<MemberInfo> currentMembers = new TObjectIntHashMap<MemberInfo>();\n      for (final int fieldId : fieldIds) {\n        currentMembers.put(createFieldInfo(fieldId), fieldId);\n      }\n      for (final int methodId : methodIds) {\n        currentMembers.put(createMethodInfo(methodId), methodId);\n      }\n\n      final TIntHashSet fieldsToRemove = new TIntHashSet(fieldIds);\n      final TIntHashSet methodsToRemove = new TIntHashSet(methodIds);\n\n      for (final MemberInfo classMember : classMembers) {\n        if (currentMembers.containsKey(classMember)) { // changed\n          final int memberId = currentMembers.get(classMember);\n          if (classMember instanceof FieldInfo) {\n            fieldsToRemove.remove(memberId);\n          }\n          else if (classMember instanceof MethodInfo) {\n            methodsToRemove.remove(memberId);\n          }\n          putMember(classDeclarationId, memberId, classMember);\n        }\n        else { // added\n          putMember(classDeclarationId, UNKNOWN, classMember);\n        }\n      }\n\n      if (!fieldsToRemove.isEmpty()) {\n        final int[] fieldsArray = fieldsToRemove.toArray();\n        for (int aFieldsArray : fieldsArray) {\n          removeFieldDeclaration(classDeclarationId, aFieldsArray);\n        }\n      }\n\n      if (!methodsToRemove.isEmpty()) {\n        final int[] methodsArray = methodsToRemove.toArray();\n        for (int aMethodsArray : methodsArray) {\n          removeMethodDeclaration(classDeclarationId, aMethodsArray);\n        }\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized AnnotationConstantValue[][] getMethodRuntimeInvisibleParamAnnotations(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n      return view.getRuntimeInvisibleParamAnnotations();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23158,"modified_method":"public AnnotationConstantValue[][] getMethodRuntimeInvisibleParamAnnotations(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getMethodDeclarationsLock()) {\n        final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n        return view.getRuntimeInvisibleParamAnnotations();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int getGenericSignature(int classId) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      return view.getGenericSignature();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23159,"modified_method":"public int getGenericSignature(int classId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        return view.getGenericSignature();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int putMember(final int classDeclarationId, int memberId, final MemberInfo classMember) throws CacheCorruptedException {\n    try {\n      if (classMember instanceof FieldInfo) {\n        FieldInfo fieldInfo = (FieldInfo)classMember;\n        if (memberId == UNKNOWN) {\n          memberId = myViewPool.getFieldDeclarationView(memberId).getRecordId();\n          myViewPool.getClassDeclarationView(classDeclarationId).addFieldId(memberId, fieldInfo.getName(), fieldInfo.getDescriptor());\n        }\n        final FieldDeclarationView view = myViewPool.getFieldDeclarationView(memberId);\n        view.setName(fieldInfo.getName());\n        view.setDescriptor(fieldInfo.getDescriptor());\n        view.setGenericSignature(fieldInfo.getGenericSignature());\n        view.setFlags(fieldInfo.getFlags());\n        view.setConstantValue(fieldInfo.getConstantValue());\n        view.setRuntimeVisibleAnnotations(fieldInfo.getRuntimeVisibleAnnotations());\n        view.setRuntimeInvisibleAnnotations(fieldInfo.getRuntimeInvisibleAnnotations());\n      }\n      else if (classMember instanceof MethodInfo) {\n        MethodInfo methodInfo = (MethodInfo)classMember;\n        if (memberId == UNKNOWN) {\n          memberId = myViewPool.getMethodDeclarationView(memberId).getRecordId();\n          myViewPool.getClassDeclarationView(classDeclarationId).addMethodId(memberId, methodInfo.getName(), methodInfo.getDescriptor());\n        }\n        final MethodDeclarationView view = myViewPool.getMethodDeclarationView(memberId);\n        view.setName(methodInfo.getName());\n        view.setDescriptor(methodInfo.getDescriptor());\n        view.setGenericSignature(methodInfo.getGenericSignature());\n        view.setFlags(methodInfo.getFlags());\n        view.setIsConstructor(methodInfo.isConstructor());\n        view.setThrownExceptions(methodInfo.getThrownExceptions());\n        view.setRuntimeVisibleAnnotations(methodInfo.getRuntimeVisibleAnnotations());\n        view.setRuntimeInvisibleAnnotations(methodInfo.getRuntimeInvisibleAnnotations());\n        view.setRuntimeVisibleParamAnnotations(methodInfo.getRuntimeVisibleParameterAnnotations());\n        view.setRuntimeInvisibleParamAnnotations(methodInfo.getRuntimeInvisibleParameterAnnotations());\n        view.setAnnotationDefault(methodInfo.getAnnotationDefault());\n      }\n      else {\n        LOG.assertTrue(false, \"Unknown member info: \"+ classMember.getClass().getName());\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n    return memberId;\n  }","id":23160,"modified_method":"public int putMember(final int classDeclarationId, int memberId, final MemberInfo classMember) throws CacheCorruptedException {\n    try {\n      if (classMember instanceof FieldInfo) {\n        final FieldInfo fieldInfo = (FieldInfo)classMember;\n        if (memberId == UNKNOWN) {\n          synchronized (myViewPool.getFieldDeclarationsLock()) {\n            memberId = myViewPool.getFieldDeclarationView(memberId).getRecordId();\n          }\n          synchronized (myViewPool.getClassDeclarationsLock()) {\n            myViewPool.getClassDeclarationView(classDeclarationId).addFieldId(memberId, fieldInfo.getName(), fieldInfo.getDescriptor());\n          }\n        }\n        synchronized (myViewPool.getFieldDeclarationsLock()) {\n          final FieldDeclarationView view = myViewPool.getFieldDeclarationView(memberId);\n          view.setName(fieldInfo.getName());\n          view.setDescriptor(fieldInfo.getDescriptor());\n          view.setGenericSignature(fieldInfo.getGenericSignature());\n          view.setFlags(fieldInfo.getFlags());\n          view.setConstantValue(fieldInfo.getConstantValue());\n          view.setRuntimeVisibleAnnotations(fieldInfo.getRuntimeVisibleAnnotations());\n          view.setRuntimeInvisibleAnnotations(fieldInfo.getRuntimeInvisibleAnnotations());\n        }\n      }\n      else if (classMember instanceof MethodInfo) {\n        final MethodInfo methodInfo = (MethodInfo)classMember;\n        if (memberId == UNKNOWN) {\n          synchronized (myViewPool.getMethodDeclarationsLock()) {\n            memberId = myViewPool.getMethodDeclarationView(memberId).getRecordId();\n          }\n          synchronized (myViewPool.getClassDeclarationsLock()) {\n            myViewPool.getClassDeclarationView(classDeclarationId).addMethodId(memberId, methodInfo.getName(), methodInfo.getDescriptor());\n          }\n        }\n        synchronized (myViewPool.getMethodDeclarationsLock()) {\n          final MethodDeclarationView view = myViewPool.getMethodDeclarationView(memberId);\n          view.setName(methodInfo.getName());\n          view.setDescriptor(methodInfo.getDescriptor());\n          view.setGenericSignature(methodInfo.getGenericSignature());\n          view.setFlags(methodInfo.getFlags());\n          view.setIsConstructor(methodInfo.isConstructor());\n          view.setThrownExceptions(methodInfo.getThrownExceptions());\n          view.setRuntimeVisibleAnnotations(methodInfo.getRuntimeVisibleAnnotations());\n          view.setRuntimeInvisibleAnnotations(methodInfo.getRuntimeInvisibleAnnotations());\n          view.setRuntimeVisibleParamAnnotations(methodInfo.getRuntimeVisibleParameterAnnotations());\n          view.setRuntimeInvisibleParamAnnotations(methodInfo.getRuntimeInvisibleParameterAnnotations());\n          view.setAnnotationDefault(methodInfo.getAnnotationDefault());\n        }\n      }\n      else {\n        LOG.assertTrue(false, \"Unknown member info: \"+ classMember.getClass().getName());\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n    return memberId;\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized AnnotationConstantValue[] getRuntimeInvisibleAnnotations(int classId) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      return view.getRuntimeInvisibleAnnotations();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23161,"modified_method":"public AnnotationConstantValue[] getRuntimeInvisibleAnnotations(int classId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        return view.getRuntimeInvisibleAnnotations();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void addReferencedClass(int classId, int referencedClassName) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      view.addReferencedClass(referencedClassName);\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23162,"modified_method":"public void addReferencedClass(int classId, int referencedClassName) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        view.addReferencedClass(referencedClassName);\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int getFieldName(int fieldDeclarationId) throws CacheCorruptedException {\n    try {\n      final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldDeclarationId);\n      return view.getName();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23163,"modified_method":"public int getFieldName(int fieldDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getFieldDeclarationsLock()) {\n        final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldDeclarationId);\n        return view.getName();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int getFieldFlags(int fieldDeclarationId) throws CacheCorruptedException {\n    try {\n      final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldDeclarationId);\n      return view.getFlags();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23164,"modified_method":"public int getFieldFlags(int fieldDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getFieldDeclarationsLock()) {\n        final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldDeclarationId);\n        return view.getFlags();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized ConstantValue getAnnotationDefault(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n      return view.getAnnotationDefault();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23165,"modified_method":"public ConstantValue getAnnotationDefault(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getMethodDeclarationsLock()) {\n        final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n        return view.getAnnotationDefault();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void setPath(int classId, String path) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      view.setPath(path);\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23166,"modified_method":"public void setPath(int classId, String path) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        view.setPath(path);\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized FieldInfo createFieldInfo(final int fieldId) throws CacheCorruptedException {\n    try {\n      final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldId);\n      return new FieldInfo(\n        view.getName(),\n        view.getDescriptor(),\n        view.getGenericSignature(),\n        view.getFlags(),\n        view.getConstantValue(),\n        view.getRuntimeVisibleAnnotations(),\n        view.getRuntimeInvisibleAnnotations()\n      );\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23167,"modified_method":"public FieldInfo createFieldInfo(final int fieldId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getFieldDeclarationsLock()) {\n        final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldId);\n        return new FieldInfo(\n          view.getName(),\n          view.getDescriptor(),\n          view.getGenericSignature(),\n          view.getFlags(),\n          view.getConstantValue(),\n          view.getRuntimeVisibleAnnotations(),\n          view.getRuntimeInvisibleAnnotations()\n        );\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int getClassDeclarationId(int qName) throws CacheCorruptedException {\n    try {\n      final TIntIntHashMap declarationsMap = getQNameToClassDeclarationIdMap();\n      if (declarationsMap.containsKey(qName)) {\n        return declarationsMap.get(qName);\n      }\n      final ClassDeclarationView view = myViewPool.getClassDeclarationView(UNKNOWN);\n      final int id = view.getRecordId();\n      declarationsMap.put(qName, id);\n      return id;\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23168,"modified_method":"public int getClassDeclarationId(final int qName) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassDeclarationsLock()) {\n        final TIntIntHashMap declarationsMap = getQNameToClassDeclarationIdMap();\n        if (declarationsMap.containsKey(qName)) {\n          return declarationsMap.get(qName);\n        }\n        final ClassDeclarationView view = myViewPool.getClassDeclarationView(UNKNOWN);\n        final int id = view.getRecordId();\n        declarationsMap.put(qName, id);\n        return id;\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void importClassInfo(Cache fromCache, final int qName) throws CacheCorruptedException {\n    try {\n      final int fromClassId = fromCache.getClassId(qName);\n\n      LOG.assertTrue(fromClassId != UNKNOWN);\n\n      final ClassInfoView view = myViewPool.getClassInfoView(getClassId(qName));\n      final int id = view.getRecordId();\n\n      final ClassInfoView classInfoView = myViewPool.getClassInfoView(id);\n      classInfoView.setQualifiedName(qName);\n      classInfoView.setGenericSignature(fromCache.getGenericSignature(fromClassId));\n      classInfoView.setPath(fromCache.getPath(fromClassId));\n\n      final int superQualifiedName = fromCache.getSuperQualifiedName(fromClassId);\n      LOG.assertTrue(qName != superQualifiedName);\n      classInfoView.setSuperQualifiedName(superQualifiedName);\n\n      classInfoView.setSuperInterfaces(fromCache.getSuperInterfaces(fromClassId));\n\n      classInfoView.setSourceFileName(fromCache.getSourceFileName(fromClassId));\n\n      classInfoView.setFlags(fromCache.getFlags(fromClassId));\n\n      classInfoView.setRuntimeVisibleAnnotations(fromCache.getRuntimeVisibleAnnotations(fromClassId));\n\n      classInfoView.setRuntimeInvisibleAnnotations(fromCache.getRuntimeInvisibleAnnotations(fromClassId));\n\n      final int fromClassDeclarationId = fromCache.getClassDeclarationId(qName);\n      final int[] fromFieldIds = fromCache.getFieldIds(fromClassDeclarationId);\n      final int[] fromMethodIds = fromCache.getMethodIds(fromClassDeclarationId);\n      final MemberInfo[] members = new MemberInfo[fromFieldIds.length + fromMethodIds.length];\n      int currentMemberIndex = 0;\n      for (int fromFieldId : fromFieldIds) {\n        members[currentMemberIndex++] = fromCache.createFieldInfo(fromFieldId);\n      }\n      for (final int methodId : fromMethodIds) {\n        members[currentMemberIndex++] = fromCache.createMethodInfo(methodId);\n      }\n      updateMemberDeclarations(qName, members);\n\n      registerClassId(qName, id);\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23169,"modified_method":"public void importClassInfo(Cache fromCache, final int qName) throws CacheCorruptedException {\n    try {\n      final int fromClassId = fromCache.getClassId(qName);\n\n      LOG.assertTrue(fromClassId != UNKNOWN);\n\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView classInfoView = myViewPool.getClassInfoView(getClassId(qName));\n        classInfoView.setQualifiedName(qName);\n        classInfoView.setGenericSignature(fromCache.getGenericSignature(fromClassId));\n        classInfoView.setPath(fromCache.getPath(fromClassId));\n\n        final int superQualifiedName = fromCache.getSuperQualifiedName(fromClassId);\n        LOG.assertTrue(qName != superQualifiedName);\n        classInfoView.setSuperQualifiedName(superQualifiedName);\n\n        classInfoView.setSuperInterfaces(fromCache.getSuperInterfaces(fromClassId));\n\n        classInfoView.setSourceFileName(fromCache.getSourceFileName(fromClassId));\n\n        classInfoView.setFlags(fromCache.getFlags(fromClassId));\n\n        classInfoView.setRuntimeVisibleAnnotations(fromCache.getRuntimeVisibleAnnotations(fromClassId));\n\n        classInfoView.setRuntimeInvisibleAnnotations(fromCache.getRuntimeInvisibleAnnotations(fromClassId));\n\n        getQNameToClassInfoIdMap().put(qName, classInfoView.getRecordId());\n      }\n\n      final int fromClassDeclarationId = fromCache.getClassDeclarationId(qName);\n      final int[] fromFieldIds = fromCache.getFieldIds(fromClassDeclarationId);\n      final int[] fromMethodIds = fromCache.getMethodIds(fromClassDeclarationId);\n      final MemberInfo[] members = new MemberInfo[fromFieldIds.length + fromMethodIds.length];\n      int currentMemberIndex = 0;\n      for (int fromFieldId : fromFieldIds) {\n        members[currentMemberIndex++] = fromCache.createFieldInfo(fromFieldId);\n      }\n      for (final int methodId : fromMethodIds) {\n        members[currentMemberIndex++] = fromCache.createMethodInfo(methodId);\n      }\n      updateMemberDeclarations(qName, members);\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized AnnotationConstantValue[] getMethodRuntimeInvisibleAnnotations(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n      return view.getRuntimeInvisibleAnnotations();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23170,"modified_method":"public AnnotationConstantValue[] getMethodRuntimeInvisibleAnnotations(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getMethodDeclarationsLock()) {\n        final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n        return view.getRuntimeInvisibleAnnotations();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int getClassId(int qName) throws CacheCorruptedException {\n    try {\n      final TIntIntHashMap classInfoMap = getQNameToClassInfoIdMap();\n      if (classInfoMap.containsKey(qName)) {\n        return classInfoMap.get(qName);\n      }\n      return UNKNOWN;\n    }\n    catch (IOException e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23171,"modified_method":"public int getClassId(int qName) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final TIntIntHashMap classInfoMap = getQNameToClassInfoIdMap();\n        if (classInfoMap.containsKey(qName)) {\n          return classInfoMap.get(qName);\n        }\n      }\n      return UNKNOWN;\n    }\n    catch (IOException e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int getFieldGenericSignature(int fieldDeclarationId) throws CacheCorruptedException {\n    try {\n      final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldDeclarationId);\n      return view.getGenericSignature();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23172,"modified_method":"public int getFieldGenericSignature(int fieldDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getFieldDeclarationsLock()) {\n        final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldDeclarationId);\n        return view.getGenericSignature();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int getMethodName(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n      return view.getName();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23173,"modified_method":"public int getMethodName(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getMethodDeclarationsLock()) {\n        final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n        return view.getName();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized boolean isConstructor(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n      return view.isConstructor();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23174,"modified_method":"public boolean isConstructor(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getMethodDeclarationsLock()) {\n        final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n        return view.isConstructor();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int[] getMethodIds(int classDeclarationId) throws CacheCorruptedException{\n    try {\n      final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n      return view.getMethodIds();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23175,"modified_method":"public int[] getMethodIds(int classDeclarationId) throws CacheCorruptedException{\n    try {\n      synchronized (myViewPool.getClassDeclarationsLock()) {\n        final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n        return view.getMethodIds();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized AnnotationConstantValue[] getFieldRuntimeVisibleAnnotations(int fieldDeclarationId) throws CacheCorruptedException {\n    try {\n      final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldDeclarationId);\n      return view.getRuntimeVisibleAnnotations();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23176,"modified_method":"public AnnotationConstantValue[] getFieldRuntimeVisibleAnnotations(int fieldDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getFieldDeclarationsLock()) {\n        final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldDeclarationId);\n        return view.getRuntimeVisibleAnnotations();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void wipe() throws CacheCorruptedException {\n    myViewPool.wipe();\n    myQNameToClassDeclarationIdMap = null;\n    myQNameToClassInfoIdMap = null;\n    myClassInfosIndexFile.delete();\n    myDeclarationsIndexFile.delete();\n  }","id":23177,"modified_method":"public void wipe() throws CacheCorruptedException {\n    synchronized (myViewPool) {\n      myViewPool.wipe();\n    }\n    synchronized (myViewPool.getClassDeclarationsLock()) {\n      myQNameToClassDeclarationIdMap = null;\n    }\n    synchronized (myViewPool.getClassInfosLock()) {\n      myQNameToClassInfoIdMap = null;\n    }\n    myClassInfosIndexFile.delete();\n    myDeclarationsIndexFile.delete();\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int getFlags(int classId) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      return view.getFlags();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23178,"modified_method":"public int getFlags(int classId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        return view.getFlags();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void addSubclass(int classId, int subclassQName) throws CacheCorruptedException {\n    try {\n      final ClassInfoView reader = myViewPool.getClassInfoView(classId);\n      reader.addSubclass(subclassQName);\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23179,"modified_method":"public void addSubclass(int classId, int subclassQName) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView reader = myViewPool.getClassInfoView(classId);\n        reader.addSubclass(subclassQName);\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int getMethodGenericSignature(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n      return view.getGenericSignature();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23180,"modified_method":"public int getMethodGenericSignature(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getMethodDeclarationsLock()) {\n        final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n        return view.getGenericSignature();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int findMethod(final int classDeclarationId, final int name, final int descriptor) throws CacheCorruptedException{\n    try {\n      final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n      final int[] ids = view.getMethodIds();\n      for (final int id : ids) {\n        final NameDescriptorPair pair = view.getMethodNameAndDescriptor(id);\n        if (pair != null && pair.name == name && pair.descriptor == descriptor) {\n          return id;\n        }\n      }\n      return UNKNOWN;\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23181,"modified_method":"public int findMethod(final int classDeclarationId, final int name, final int descriptor) throws CacheCorruptedException{\n    try {\n      synchronized (myViewPool.getClassDeclarationsLock()) {\n        final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n        final int[] ids = view.getMethodIds();\n        for (final int id : ids) {\n          final NameDescriptorPair pair = view.getMethodNameAndDescriptor(id);\n          if (pair != null && pair.name == name && pair.descriptor == descriptor) {\n            return id;\n          }\n        }\n      }\n      return UNKNOWN;\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void setRemote(int classId, boolean remote) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      view.setRemote(remote);\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23182,"modified_method":"public void setRemote(int classId, boolean remote) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        view.setRemote(remote);\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void addFieldReferencer(int fieldId, int referencerQName) throws CacheCorruptedException {\n    try {\n      final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldId);\n      view.addReferencer(referencerQName);\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23183,"modified_method":"public void addFieldReferencer(int fieldId, int referencerQName) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getFieldDeclarationsLock()) {\n        final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldId);\n        view.addReferencer(referencerQName);\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int findMethodsBySignature(final int classDeclarationId, final String signature, SymbolTable symbolTable) throws CacheCorruptedException{\n    try {\n      final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n      final int[] ids = view.getMethodIds();\n      for (int methodId : ids) {\n        final NameDescriptorPair pair = view.getMethodNameAndDescriptor(methodId);\n        if (pair != null && signature.equals(CacheUtils.getMethodSignature(symbolTable.getSymbol(pair.name), symbolTable.getSymbol(pair.descriptor)))) {\n          return methodId;\n        }\n      }\n      return UNKNOWN;\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23184,"modified_method":"public int findMethodsBySignature(final int classDeclarationId, final String signature, SymbolTable symbolTable) throws CacheCorruptedException{\n    try {\n      synchronized (myViewPool.getClassDeclarationsLock()) {\n        final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n        final int[] ids = view.getMethodIds();\n        for (int methodId : ids) {\n          final NameDescriptorPair pair = view.getMethodNameAndDescriptor(methodId);\n          if (pair != null && signature.equals(CacheUtils.getMethodSignature(symbolTable.getSymbol(pair.name), symbolTable.getSymbol(pair.descriptor)))) {\n            return methodId;\n          }\n        }\n      }\n      return UNKNOWN;\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void removeClass(final int qName) throws CacheCorruptedException {\n    try {\n      final int classDeclarationId = getClassDeclarationId(qName);\n      if (classDeclarationId != UNKNOWN) {\n        final int[] fieldIds = getFieldIds(classDeclarationId);\n        for (int fieldId : fieldIds) {\n          final FieldDeclarationView fieldDeclarationView = myViewPool.getFieldDeclarationView(fieldId);\n          myViewPool.removeFieldDeclarationRecord(fieldDeclarationView);\n        }\n        final int[] methodIds = getMethodIds(classDeclarationId);\n        for (int methodId : methodIds) {\n          final MethodDeclarationView methodDeclarationView = myViewPool.getMethodDeclarationView(methodId);\n          myViewPool.removeMethodDeclarationRecord(methodDeclarationView);\n        }\n\n        myViewPool.removeClassDeclarationRecord(myViewPool.getClassDeclarationView(classDeclarationId));\n        getQNameToClassDeclarationIdMap().remove(qName);\n      }\n\n      final int classId = getClassId(qName);\n      if (classId != UNKNOWN) {\n        final ClassInfoView classInfoView = myViewPool.getClassInfoView(classId);\n        //classInfoView.removeRecord();\n        myViewPool.removeClassInfoRecord(classInfoView);\n        getQNameToClassInfoIdMap().remove(qName);\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23185,"modified_method":"public void removeClass(final int qName) throws CacheCorruptedException {\n    try {\n      final int classDeclarationId = getClassDeclarationId(qName);\n      if (classDeclarationId != UNKNOWN) {\n        final int[] fieldIds = getFieldIds(classDeclarationId);\n        synchronized (myViewPool.getFieldDeclarationsLock()) {\n          for (int fieldId : fieldIds) {\n            final FieldDeclarationView fieldDeclarationView = myViewPool.getFieldDeclarationView(fieldId);\n            myViewPool.removeFieldDeclarationRecord(fieldDeclarationView);\n          }\n        }\n        final int[] methodIds = getMethodIds(classDeclarationId);\n        synchronized (myViewPool.getMethodDeclarationsLock()) {\n          for (int methodId : methodIds) {\n            final MethodDeclarationView methodDeclarationView = myViewPool.getMethodDeclarationView(methodId);\n            myViewPool.removeMethodDeclarationRecord(methodDeclarationView);\n          }\n        }\n\n        synchronized (myViewPool.getClassDeclarationsLock()) {\n          myViewPool.removeClassDeclarationRecord(myViewPool.getClassDeclarationView(classDeclarationId));\n          getQNameToClassDeclarationIdMap().remove(qName);\n        }\n      }\n\n      final int classId = getClassId(qName);\n      if (classId != UNKNOWN) {\n        synchronized (myViewPool.getClassInfosLock()) {\n          final ClassInfoView classInfoView = myViewPool.getClassInfoView(classId);\n          //classInfoView.removeRecord();\n          myViewPool.removeClassInfoRecord(classInfoView);\n          getQNameToClassInfoIdMap().remove(qName);\n        }\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized ConstantValue getFieldConstantValue(int fieldDeclarationId) throws CacheCorruptedException {\n    try {\n      final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldDeclarationId);\n      return view.getConstantValue();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23186,"modified_method":"public ConstantValue getFieldConstantValue(int fieldDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getFieldDeclarationsLock()) {\n        final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldDeclarationId);\n        return view.getConstantValue();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void removeMethodReferencer(int methodDeclarationId, int referencerQName) throws CacheCorruptedException {\n    try {\n      final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n      view.removeReferencer(referencerQName);\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23187,"modified_method":"public void removeMethodReferencer(int methodDeclarationId, int referencerQName) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getMethodDeclarationsLock()) {\n        final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n        view.removeReferencer(referencerQName);\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void removeFieldReferencer(int fieldId, int referencerQName) throws CacheCorruptedException {\n    try {\n      final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldId);\n      view.removeReferencer(referencerQName);\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23188,"modified_method":"public void removeFieldReferencer(int fieldId, int referencerQName) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getFieldDeclarationsLock()) {\n        final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldId);\n        view.removeReferencer(referencerQName);\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void removeSubclass(int classId, int subclassQName) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      view.removeSubclass(subclassQName);\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23189,"modified_method":"public void removeSubclass(int classId, int subclassQName) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        view.removeSubclass(subclassQName);\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int getMethodFlags(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n      return view.getFlags();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23190,"modified_method":"public int getMethodFlags(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getMethodDeclarationsLock()) {\n        final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n        return view.getFlags();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void removeFieldDeclaration(int classDeclarationId, int fieldId) throws IOException, CacheCorruptedException {\n    final ClassDeclarationView classDeclarationView = myViewPool.getClassDeclarationView(classDeclarationId);\n    classDeclarationView.removeFieldId(fieldId);\n    final FieldDeclarationView fieldDeclarationView = myViewPool.getFieldDeclarationView(fieldId);\n    myViewPool.removeFieldDeclarationRecord(fieldDeclarationView);\n  }","id":23191,"modified_method":"private void removeFieldDeclaration(int classDeclarationId, int fieldId) throws IOException, CacheCorruptedException {\n    synchronized (myViewPool.getClassDeclarationsLock()) {\n      final ClassDeclarationView classDeclarationView = myViewPool.getClassDeclarationView(classDeclarationId);\n      classDeclarationView.removeFieldId(fieldId);\n    }\n    synchronized (myViewPool.getFieldDeclarationsLock()) {\n      myViewPool.removeFieldDeclarationRecord(myViewPool.getFieldDeclarationView(fieldId));\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int[] getSubclasses(int classId) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      return view.getSubclasses();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23192,"modified_method":"public int[] getSubclasses(int classId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        return view.getSubclasses();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int findField(final int classDeclarationId, final int name, final int descriptor) throws CacheCorruptedException{\n    try {\n      final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n      final int[] ids = view.getFieldIds();\n      for (final int id : ids) {\n        final NameDescriptorPair pair = view.getFieldNameAndDescriptor(id);\n        if (pair != null && pair.name == name && pair.descriptor == descriptor) {\n          return id;\n        }\n      }\n      return UNKNOWN;\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23193,"modified_method":"public int findField(final int classDeclarationId, final int name, final int descriptor) throws CacheCorruptedException{\n    try {\n      synchronized (myViewPool.getClassDeclarationsLock()) {\n        final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n        final int[] ids = view.getFieldIds();\n        for (final int id : ids) {\n          final NameDescriptorPair pair = view.getFieldNameAndDescriptor(id);\n          if (pair != null && pair.name == name && pair.descriptor == descriptor) {\n            return id;\n          }\n        }\n      }\n      return UNKNOWN;\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void addClassReferencer(int classDeclarationId, int referencerQName) throws CacheCorruptedException {\n    try {\n      final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n      view.addReferencer(referencerQName);\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23194,"modified_method":"public void addClassReferencer(int classDeclarationId, int referencerQName) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassDeclarationsLock()) {\n        final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n        view.addReferencer(referencerQName);\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void dispose() throws CacheCorruptedException {\n    myViewPool.dispose(true);\n    try {\n      if (myQNameToClassDeclarationIdMap != null) {\n        writeIndexMap(myQNameToClassDeclarationIdMap, myDeclarationsIndexFile);\n        myQNameToClassDeclarationIdMap = null;\n      }\n      if (myQNameToClassInfoIdMap != null) {\n        writeIndexMap(myQNameToClassInfoIdMap, myClassInfosIndexFile);\n        myQNameToClassInfoIdMap = null;\n      }\n    }\n    catch (IOException e) {\n      myDeclarationsIndexFile.delete();\n      myClassInfosIndexFile.delete();\n      LOG.info(e);\n    }\n  }","id":23195,"modified_method":"public void dispose() throws CacheCorruptedException {\n    synchronized (myViewPool) {\n      myViewPool.dispose(true);\n    }\n    try {\n      synchronized (myViewPool.getClassDeclarationsLock()) {\n        if (myQNameToClassDeclarationIdMap != null) {\n          writeIndexMap(myQNameToClassDeclarationIdMap, myDeclarationsIndexFile);\n          myQNameToClassDeclarationIdMap = null;\n        }\n      }\n      synchronized (myViewPool.getClassInfosLock()) {\n        if (myQNameToClassInfoIdMap != null) {\n          writeIndexMap(myQNameToClassInfoIdMap, myClassInfosIndexFile);\n          myQNameToClassInfoIdMap = null;\n        }\n      }\n    }\n    catch (IOException e) {\n      myDeclarationsIndexFile.delete();\n      myClassInfosIndexFile.delete();\n      LOG.info(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int[] getFieldReferencers(int fieldDeclarationId) throws CacheCorruptedException {\n    try {\n      final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldDeclarationId);\n      return view.getReferencers();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23196,"modified_method":"public int[] getFieldReferencers(int fieldDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getFieldDeclarationsLock()) {\n        final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldDeclarationId);\n        return view.getReferencers();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void addMethodReferencer(int methodDeclarationId, int referencerQName) throws CacheCorruptedException {\n    try {\n      final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n      view.addReferencer(referencerQName);\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23197,"modified_method":"public void addMethodReferencer(int methodDeclarationId, int referencerQName) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getMethodDeclarationsLock()) {\n        final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n        view.addReferencer(referencerQName);\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int[] getMethodThrownExceptions(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n      return view.getThrownExceptions();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23198,"modified_method":"public int[] getMethodThrownExceptions(int methodDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getMethodDeclarationsLock()) {\n        final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodDeclarationId);\n        return view.getThrownExceptions();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int[] getFieldIds(int classDeclarationId) throws CacheCorruptedException{\n    try {\n      final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n      return view.getFieldIds();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23199,"modified_method":"public int[] getFieldIds(int classDeclarationId) throws CacheCorruptedException{\n    try {\n      synchronized (myViewPool.getClassDeclarationsLock()) {\n        final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n        return view.getFieldIds();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized String getPath(int classId) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      return view.getPath();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23200,"modified_method":"public String getPath(int classId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        return view.getPath();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void removeClassReferencer(int classDeclarationId, int referencerQName) throws CacheCorruptedException {\n    try {\n      final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n      view.removeReferencer(referencerQName);\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23201,"modified_method":"public void removeClassReferencer(int classDeclarationId, int referencerQName) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassDeclarationsLock()) {\n        final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n        view.removeReferencer(referencerQName);\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized AnnotationConstantValue[] getFieldRuntimeInvisibleAnnotations(int fieldDeclarationId) throws CacheCorruptedException {\n    try {\n      final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldDeclarationId);\n      return view.getRuntimeInvisibleAnnotations();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23202,"modified_method":"public AnnotationConstantValue[] getFieldRuntimeInvisibleAnnotations(int fieldDeclarationId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getFieldDeclarationsLock()) {\n        final FieldDeclarationView view = myViewPool.getFieldDeclarationView(fieldDeclarationId);\n        return view.getRuntimeInvisibleAnnotations();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized Dependency[] getBackDependencies(int classQName) throws CacheCorruptedException{\n    final int classDeclarationId = getClassDeclarationId(classQName);\n    if (classDeclarationId == UNKNOWN) {\n      return null;\n    }\n    try {\n      final TIntObjectHashMap<Dependency> dependencies = new TIntObjectHashMap<Dependency>();\n      final int[] classReferencers = myViewPool.getClassDeclarationView(classDeclarationId).getReferencers();\n      for (final int referencer : classReferencers) {\n        if (referencer != classQName) { // skip self-dependencies\n          addDependency(dependencies, referencer);\n        }\n      }\n\n      final int[] fieldIds = myViewPool.getClassDeclarationView(classDeclarationId).getFieldIds();\n      for (final int fieldId : fieldIds) {\n        final FieldDeclarationView fieldDeclarationView = myViewPool.getFieldDeclarationView(fieldId);\n        final int[] fieldReferencers = fieldDeclarationView.getReferencers();\n        for (int referencer : fieldReferencers) {\n          if (referencer != classQName) { // skip self-dependencies\n            final Dependency dependency = addDependency(dependencies, referencer);\n            dependency.addMemberInfo(createFieldInfo(fieldId));\n          }\n        }\n      }\n\n      final int[] methodIds = myViewPool.getClassDeclarationView(classDeclarationId).getMethodIds();\n      for (final int methodId : methodIds) {\n        final int[] methodReferencers = myViewPool.getMethodDeclarationView(methodId).getReferencers();\n        for (int referencer : methodReferencers) {\n          if (referencer != classQName) {\n            final Dependency dependency = addDependency(dependencies, referencer);\n            dependency.addMemberInfo(createMethodInfo(methodId));\n          }\n        }\n      }\n\n      final Dependency[] dependencyArray = new Dependency[dependencies.size()];\n      dependencies.forEachValue(new TObjectProcedure<Dependency>() {\n        private int index = 0;\n        public boolean execute(Dependency object) {\n          dependencyArray[index++] = object;\n          return true;\n        }\n      });\n      return dependencyArray;\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23203,"modified_method":"public Dependency[] getBackDependencies(final int classQName) throws CacheCorruptedException{\n    final int classDeclarationId = getClassDeclarationId(classQName);\n    if (classDeclarationId == UNKNOWN) {\n      return null;\n    }\n    try {\n      final TIntObjectHashMap<Dependency> dependencies = new TIntObjectHashMap<Dependency>();\n      final int[] classReferencers = getClassReferencers(classDeclarationId);\n      for (final int referencer : classReferencers) {\n        if (referencer != classQName) { // skip self-dependencies\n          addDependency(dependencies, referencer);\n        }\n      }\n\n      final int[] fieldIds = getFieldIds(classDeclarationId);\n      for (final int fieldId : fieldIds) {\n        final int[] fieldReferencers = getFieldReferencers(fieldId);\n        for (int referencer : fieldReferencers) {\n          if (referencer != classQName) { // skip self-dependencies\n            final Dependency dependency = addDependency(dependencies, referencer);\n            dependency.addMemberInfo(createFieldInfo(fieldId));\n          }\n        }\n      }\n\n      final int[] methodIds = getMethodIds(classDeclarationId);\n      for (final int methodId : methodIds) {\n        final int[] methodReferencers = getMethodReferencers(methodId);\n        for (int referencer : methodReferencers) {\n          if (referencer != classQName) {\n            final Dependency dependency = addDependency(dependencies, referencer);\n            dependency.addMemberInfo(createMethodInfo(methodId));\n          }\n        }\n      }\n\n      final Dependency[] dependencyArray = new Dependency[dependencies.size()];\n      dependencies.forEachValue(new TObjectProcedure<Dependency>() {\n        private int index = 0;\n        public boolean execute(Dependency object) {\n          dependencyArray[index++] = object;\n          return true;\n        }\n      });\n      return dependencyArray;\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized int findFieldByName(final int classDeclarationId, final int name) throws CacheCorruptedException{\n    try {\n      final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n      final int[] ids = view.getFieldIds();\n      for (final int id : ids) {\n        final NameDescriptorPair pair = view.getFieldNameAndDescriptor(id);\n        if (pair != null && pair.name == name) {\n          return id;\n        }\n      }\n      return UNKNOWN;\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23204,"modified_method":"public int findFieldByName(final int classDeclarationId, final int name) throws CacheCorruptedException{\n    try {\n      synchronized (myViewPool.getClassDeclarationsLock()) {\n        final ClassDeclarationView view = myViewPool.getClassDeclarationView(classDeclarationId);\n        final int[] ids = view.getFieldIds();\n        for (final int id : ids) {\n          final NameDescriptorPair pair = view.getFieldNameAndDescriptor(id);\n          if (pair != null && pair.name == name) {\n            return id;\n          }\n        }\n      }\n      return UNKNOWN;\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized MethodInfo createMethodInfo(final int methodId) throws CacheCorruptedException {\n    try {\n      final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodId);\n      return new MethodInfo(\n        view.getName(),\n        view.getDescriptor(),\n        view.getGenericSignature(),\n        view.getFlags(),\n        view.getThrownExceptions(),\n        view.isConstructor(),\n        view.getRuntimeVisibleAnnotations(),\n        view.getRuntimeInvisibleAnnotations(),\n        view.getRuntimeVisibleParamAnnotations(),\n        view.getRuntimeInvisibleParamAnnotations(),\n        view.getAnnotationDefault()\n      );\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23205,"modified_method":"public MethodInfo createMethodInfo(final int methodId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getMethodDeclarationsLock()) {\n        final MethodDeclarationView view = myViewPool.getMethodDeclarationView(methodId);\n        return new MethodInfo(\n          view.getName(),\n          view.getDescriptor(),\n          view.getGenericSignature(),\n          view.getFlags(),\n          view.getThrownExceptions(),\n          view.isConstructor(),\n          view.getRuntimeVisibleAnnotations(),\n          view.getRuntimeInvisibleAnnotations(),\n          view.getRuntimeVisibleParamAnnotations(),\n          view.getRuntimeInvisibleParamAnnotations(),\n          view.getAnnotationDefault()\n        );\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized AnnotationConstantValue[] getRuntimeVisibleAnnotations(int classId) throws CacheCorruptedException {\n    try {\n      final ClassInfoView view = myViewPool.getClassInfoView(classId);\n      return view.getRuntimeVisibleAnnotations();\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","id":23206,"modified_method":"public AnnotationConstantValue[] getRuntimeVisibleAnnotations(int classId) throws CacheCorruptedException {\n    try {\n      synchronized (myViewPool.getClassInfosLock()) {\n        final ClassInfoView view = myViewPool.getClassInfoView(classId);\n        return view.getRuntimeVisibleAnnotations();\n      }\n    }\n    catch (Throwable e) {\n      throw new CacheCorruptedException(e);\n    }\n  }","commit_id":"f62e7b91ee5ae3b6153644f59866db0c13a097c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Return required control from the Control[] array\n     * if exists.\n     *\n     * @param controlType the control we are interested in.\n     * @return the object that implements the control, or null if not found\n     */\n    public Object getControl(String controlType)\n    {\n        try\n        {\n            Class<?> controlClass = Class.forName(controlType);\n\n            for(Object control : getControls())\n            {\n                if (controlClass.isInstance(control))\n                {\n                    return control;\n                }\n            }\n        }\n        catch (ClassNotFoundException cnfex)\n        {\n            logger.warn(\"Failed to load class of requested controlType \"\n                        + controlType, cnfex);\n        }\n        return null;\n    }","id":23207,"modified_method":"/**\n     * Return required control from the Control[] array\n     * if exists.\n     *\n     * @param controlType the control we are interested in.\n     * @return the object that implements the control, or null if not found\n     */\n    public Object getControl(String controlType)\n    {\n        return AbstractControls.getControl(this, controlType);\n    }","commit_id":"c68665d4323aabdd7f68d873e44e78cf840c57a6","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * Get current format used.\n         *\n         * @return the <tt>Format<\/tt> of this <tt>DataSource<\/tt>\n         */\n        public Format getFormat()\n        {\n            return currentFormat;\n        }","id":23208,"modified_method":"/**\n         * Get current format used.\n         *\n         * @return the <tt>Format<\/tt> of this <tt>DataSource<\/tt>\n         */\n        public Format getFormat()\n        {\n            return format;\n        }","commit_id":"c68665d4323aabdd7f68d873e44e78cf840c57a6","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Get the <CaptureDeviceInfo<\/tt> associated\n     * with this datasource.\n     *\n     * @return <tt>CaptureDeviceInfo<\/tt> associated\n     */\n    public CaptureDeviceInfo getCaptureDeviceInfo()\n    {\n        return new CaptureDeviceInfo(getLocator().getRemainder(), getLocator(), getFormatControls()[0].getSupportedFormats());\n    }","id":23209,"modified_method":"/**\n     * Get the <tt>CaptureDeviceInfo<\/tt> associated\n     * with this datasource.\n     *\n     * @return <tt>CaptureDeviceInfo<\/tt> associated\n     */\n    public CaptureDeviceInfo getCaptureDeviceInfo()\n    {\n        MediaLocator locator = getLocator();\n\n        return\n            new CaptureDeviceInfo(\n                    locator.getRemainder(),\n                    locator,\n                    getFormatControls()[0].getSupportedFormats());\n    }","commit_id":"c68665d4323aabdd7f68d873e44e78cf840c57a6","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * Set the format used.\n         *\n         * @param format format to use\n         * @return format used or null if format is not supported\n         */\n        public Format setFormat(Format format)\n        {\n            Format f = AbstractFormatControl.setFormat(this, format);\n\n            if(f != null)\n            {\n                currentFormat = f;\n            }\n\n            return f;\n        }","id":23210,"modified_method":"/**\n         * Set the format used.\n         *\n         * @param format format to use\n         * @return format used or null if format is not supported\n         */\n        @Override\n        public Format setFormat(Format format)\n        {\n            Format f = AbstractFormatControl.setFormat(this, format);\n\n            if(f != null)\n                this.format = f;\n            return f;\n        }","commit_id":"c68665d4323aabdd7f68d873e44e78cf840c57a6","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Get supported <tt>FormatControl<\/tt>.\n     *\n     * @return array of supported <tt>FormatControl<\/tt>\n     */\n    public FormatControl[] getFormatControls()\n    {\n        java.util.List<FormatControl> formatControls = new ArrayList<FormatControl>();\n\n        for(Object control : getControls())\n        {\n            if(control instanceof FormatControl)\n            {\n                formatControls.add((FormatControl)control);\n            }\n        }\n\n        return formatControls.toArray(new FormatControl[formatControls.size()]);\n    }","id":23211,"modified_method":"/**\n     * Get supported <tt>FormatControl<\/tt>.\n     *\n     * @return array of supported <tt>FormatControl<\/tt>\n     */\n    public FormatControl[] getFormatControls()\n    {\n        return AbstractFormatControl.getFormatControls(this);\n    }","commit_id":"c68665d4323aabdd7f68d873e44e78cf840c57a6","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Gets an array of <tt>FormatControl<\/tt> instances each one of which can\n     * be used before {@link #connect()} to get and set the capture\n     * <tt>Format<\/tt> of each one of the capture streams.\n     *\n     * @return an array of <tt>FormatControl<\/tt> instances each one of which\n     * can be used before {@link #connect()} to get and set the capture\n     * <tt>Format<\/tt> of each one of the capture streams\n     */\n    public FormatControl[] getFormatControls()\n    {\n        List<FormatControl> formatControls = new ArrayList<FormatControl>();\n\n        for (Object control : getControls())\n            if (control instanceof FormatControl)\n                formatControls.add((FormatControl) control);\n        return formatControls.toArray(new FormatControl[formatControls.size()]);\n    }","id":23212,"modified_method":"/**\n     * Gets an array of <tt>FormatControl<\/tt> instances each one of which can\n     * be used before {@link #connect()} to get and set the capture\n     * <tt>Format<\/tt> of each one of the capture streams.\n     *\n     * @return an array of <tt>FormatControl<\/tt> instances each one of which\n     * can be used before {@link #connect()} to get and set the capture\n     * <tt>Format<\/tt> of each one of the capture streams\n     */\n    public FormatControl[] getFormatControls()\n    {\n        return AbstractFormatControl.getFormatControls(this);\n    }","commit_id":"c68665d4323aabdd7f68d873e44e78cf840c57a6","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Thread entry point.\n     */\n    public void run()\n    {\n        final Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();\n        final RGBFormat format = (RGBFormat)currentFormat;\n        final int width = (int)format.getSize().getWidth();\n        final int height = (int)format.getSize().getHeight();\n        Buffer buffer = new Buffer();\n\n        if(desktopInteract == null)\n        {\n            try\n            {\n                desktopInteract = new DesktopInteractImpl();\n            }\n            catch(Exception e)\n            {\n                logger.warn(\"Cannot create DesktopInteract object!\");\n                started = false;\n                return;\n            }\n        }\n\n        while(started)\n        {\n            byte data[] = null;\n            BufferedImage scaledScreen = null;\n            BufferedImage screen = null;\n            \n            /*\n            long t = System.nanoTime();\n            */\n\n            /* get desktop screen and resize it */\n            screen = desktopInteract.captureScreen();\n            scaledScreen = ImageStreamingUtils.getScaledImage(screen, \n                    width, height, BufferedImage.TYPE_INT_ARGB);\n\n            /* get raw bytes */\n            data = ImageStreamingUtils.getImageByte(scaledScreen);\n\n            /* notify JMF that new data is available */\n            buffer.setData(data);\n            buffer.setOffset(0);\n            buffer.setLength(data.length);\n            buffer.setFormat(currentFormat);\n            buffer.setHeader(null);\n            buffer.setTimeStamp(System.nanoTime());\n            buffer.setSequenceNumber(seqNo);\n            buffer.setFlags(Buffer.FLAG_LIVE_DATA | Buffer.FLAG_SYSTEM_TIME);\n            seqNo++;\n\n            synchronized(syncBuf)\n            {\n                buf = buffer;\n            }\n\n            /* pass to JMF handler */\n            if(transferHandler != null)\n            {\n                transferHandler.transferData(this);\n                Thread.yield();\n            }\n            /*\n            t = System.nanoTime() - t;\n            logger.info(\"Desktop capture processing time: \" + t);\n            */\n\n            /* cleanup */\n            screen = null;\n            scaledScreen = null;\n            data = null;\n\n            try\n            {\n                /* 100 ms */\n                Thread.sleep(100);\n            }\n            catch(InterruptedException e)\n            {\n                /* do nothing */\n            }\n        }\n\n        buffer = null;\n    }","id":23213,"modified_method":"/**\n     * Thread entry point.\n     */\n    public void run()\n    {\n        final RGBFormat format = (RGBFormat)currentFormat;\n        Dimension formatSize = format.getSize();\n        final int width = (int)formatSize.getWidth();\n        final int height = (int)formatSize.getHeight();\n\n        if(desktopInteract == null)\n        {\n            try\n            {\n                desktopInteract = new DesktopInteractImpl();\n            }\n            catch(Exception e)\n            {\n                logger.warn(\"Cannot create DesktopInteract object!\");\n                started = false;\n                return;\n            }\n        }\n\n        while(started)\n        {\n            byte data[] = null;\n            BufferedImage scaledScreen = null;\n            BufferedImage screen = null;\n\n            /* get desktop screen and resize it */\n            screen = desktopInteract.captureScreen();\n            scaledScreen = ImageStreamingUtils.getScaledImage(screen, \n                    width, height, BufferedImage.TYPE_INT_ARGB);\n\n            /* get raw bytes */\n            data = ImageStreamingUtils.getImageByte(scaledScreen);\n\n            /* notify JMF that new data is available */\n            synchronized (buf)\n            {\n                buf.setData(data);\n                buf.setOffset(0);\n                buf.setLength(data.length);\n                buf.setFormat(currentFormat);\n                buf.setHeader(null);\n                buf.setTimeStamp(System.nanoTime());\n                buf.setSequenceNumber(seqNo++);\n                buf.setFlags(Buffer.FLAG_LIVE_DATA | Buffer.FLAG_SYSTEM_TIME);\n            }\n\n            /* pass to JMF handler */\n            BufferTransferHandler transferHandler = this.transferHandler;\n\n            if(transferHandler != null)\n            {\n                transferHandler.transferData(this);\n                Thread.yield();\n            }\n\n            /* cleanup */\n            screen = null;\n            scaledScreen = null;\n            data = null;\n\n            try\n            {\n                /* 100 ms */\n                Thread.sleep(100);\n            }\n            catch(InterruptedException e)\n            {\n                /* do nothing */\n            }\n        }\n    }","commit_id":"c68665d4323aabdd7f68d873e44e78cf840c57a6","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Block and read a buffer from the stream.\n     *\n     * @param buffer the <tt>Buffer<\/tt> to read captured media into\n     * @throws IOException if an error occurs while reading.\n     */\n    public void read(Buffer buffer) throws IOException\n    {\n        try\n        {\n            synchronized(syncBuf)\n            {\n                if(buf != null)\n                {\n\n                    buffer.setData(buf.getData());\n                    buffer.setOffset(0);\n                    buffer.setLength(buf.getLength());\n                    buffer.setFormat(buf.getFormat());\n                    buffer.setHeader(null);\n                    buffer.setTimeStamp(buf.getTimeStamp());\n                    buffer.setSequenceNumber(buf.getSequenceNumber());\n                    buffer.setFlags(buf.getFlags());\n    \n                    /* clear buf so JMF will not get twice the same image */\n                    buf = null;\n                }\n            }\n        }\n        catch(Exception e)\n        {\n        }\n    }","id":23214,"modified_method":"/**\n     * Block and read a buffer from the stream.\n     *\n     * @param buffer the <tt>Buffer<\/tt> to read captured media into\n     * @throws IOException if an error occurs while reading.\n     */\n    public void read(Buffer buffer)\n        throws IOException\n    {\n        synchronized(buf)\n        {\n            try\n            {\n                Object bufData = buf.getData();\n                int bufLength = buf.getLength();\n\n                if ((bufData != null) || (bufLength != 0))\n                {\n                    buffer.setData(bufData);\n                    buffer.setOffset(0);\n                    buffer.setLength(bufLength);\n                    buffer.setFormat(buf.getFormat());\n                    buffer.setHeader(null);\n                    buffer.setTimeStamp(buf.getTimeStamp());\n                    buffer.setSequenceNumber(buf.getSequenceNumber());\n                    buffer.setFlags(buf.getFlags());\n\n                    /* clear buf so JMF will not get twice the same image */\n                    buf.setData(null);\n                    buf.setLength(0);\n                }\n            }\n            catch (Exception e)\n            {\n            }\n        }\n    }","commit_id":"c68665d4323aabdd7f68d873e44e78cf840c57a6","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates <tt>JavaSoundAuto<\/tt> and checks is javasound supported\n     * on current operating system.\n     */\n    @SuppressWarnings(\"unchecked\") //legacy JMF code.\n    public JavaSoundAuto()\n    {\n        boolean supported = false;\n        \n        try\n        {\n            DataLine.Info info = new DataLine.Info(TargetDataLine.class,\n                    null,\n                    AudioSystem.NOT_SPECIFIED);\n            supported = AudioSystem.isLineSupported(info);\n        } catch (Throwable thr)\n        {\n            supported = false;\n            logger.error(\"Failed detecting java sound audio\", thr);\n        }\n\n        logger.info(\"JavaSound Capture Supported = \" + supported);\n\n        if (supported)\n        {\n            // It's there, start to register JavaSound with CaptureDeviceManager\n            Vector<CaptureDeviceInfo> devices\n                = (Vector) CaptureDeviceManager.getDeviceList(null).clone();\n\n            // remove the old javasound capturers\n            String name;\n            Enumeration<CaptureDeviceInfo> enumeration = devices.elements();\n            while (enumeration.hasMoreElements())\n            {\n                CaptureDeviceInfo cdi = enumeration.nextElement();\n                name = cdi.getName();\n                if (name.startsWith(\"JavaSound\"))\n                    CaptureDeviceManager.removeDevice(cdi);\n            }\n\n            // collect javasound capture device info from JavaSoundSourceStream\n            // and register them with CaptureDeviceManager\n            CaptureDeviceInfo[] cdi\n                =  com.sun.media.protocol.javasound.JavaSoundSourceStream\n                    .listCaptureDeviceInfo();\n            if ( cdi != null )\n            {\n                for (int i = 0; i < cdi.length; i++)\n                    CaptureDeviceManager.addDevice(cdi[i]);\n\n                try\n                {\n                    CaptureDeviceManager.commit();\n                    logger.info(\"JavaSoundAuto: Committed ok\");\n                } catch (java.io.IOException ioe)\n                {\n                    logger.error(\"JavaSoundAuto: error committing cdm\");\n                }\n            }\n\n            // now add it as available audio system to DeviceConfiguration\n            DeviceConfiguration.addAudioSystem(\n                DeviceConfiguration.AUDIO_SYSTEM_JAVASOUND);\n        }\n    }","id":23215,"modified_method":"/**\n     * Creates <tt>JavaSoundAuto<\/tt> and checks is javasound supported\n     * on current operating system.\n     */\n    @SuppressWarnings(\"unchecked\") // legacy JMF code.\n    public JavaSoundAuto()\n    {\n        boolean supported = false;\n        \n        try\n        {\n            DataLine.Info info = new DataLine.Info(TargetDataLine.class,\n                    null,\n                    AudioSystem.NOT_SPECIFIED);\n            supported = AudioSystem.isLineSupported(info);\n        }\n        catch (Throwable thr)\n        {\n            supported = false;\n            logger.error(\"Failed detecting java sound audio\", thr);\n        }\n\n        logger.info(\"JavaSound Capture Supported = \" + supported);\n\n        if (supported)\n        {\n            // It's there, start to register JavaSound with CaptureDeviceManager\n            Vector<CaptureDeviceInfo> devices\n                = CaptureDeviceManager.getDeviceList(null);\n            devices = (Vector<CaptureDeviceInfo>) devices.clone();\n\n            // remove the old javasound capturers\n            String name;\n            Enumeration<CaptureDeviceInfo> enumeration = devices.elements();\n            while (enumeration.hasMoreElements())\n            {\n                CaptureDeviceInfo cdi = enumeration.nextElement();\n                name = cdi.getName();\n                if (name.startsWith(\"JavaSound\"))\n                    CaptureDeviceManager.removeDevice(cdi);\n            }\n\n            // collect javasound capture device info from JavaSoundSourceStream\n            // and register them with CaptureDeviceManager\n            CaptureDeviceInfo[] cdis\n                =  com.sun.media.protocol.javasound.JavaSoundSourceStream\n                    .listCaptureDeviceInfo();\n            if ( cdis != null )\n            {\n                for (CaptureDeviceInfo cdi : cdis)\n                    CaptureDeviceManager.addDevice(cdi);\n\n                try\n                {\n                    CaptureDeviceManager.commit();\n                    logger.info(\"JavaSoundAuto: Committed ok\");\n                }\n                catch (IOException ioex)\n                {\n                    logger.error(\"JavaSoundAuto: error committing cdm\", ioex);\n                }\n            }\n\n            // now add it as available audio system to DeviceConfiguration\n            DeviceConfiguration.addAudioSystem(\n                DeviceConfiguration.AUDIO_SYSTEM_JAVASOUND);\n        }\n    }","commit_id":"c68665d4323aabdd7f68d873e44e78cf840c57a6","url":"https://github.com/jitsi/jitsi"},{"original_method":"PortAudioAuto() throws Exception\n    {\n        // if PortAudio has a problem initializing like missing native\n        // components it will trow exception here and PortAudio rendering will\n        // not be inited.\n        PortAudioManager.getInstance();\n\n        // enable jmf logging, so we can track codec chains and formats\n        if(Logger.getLogger(PortAudioAuto.class).isDebugEnabled())\n            Registry.set(\"allowLogging\", true);\n\n        int deviceCount = PortAudio.Pa_GetDeviceCount();\n        int deviceIndex = 0;\n\n        int defaultInputDeviceIx = PortAudio.Pa_GetDefaultInputDevice();\n        int defaultOutputDeviceIx = PortAudio.Pa_GetDefaultOutputDevice();\n\n        Vector<CaptureDeviceInfo> playbackDevVector =\n            new Vector<CaptureDeviceInfo>();\n\n        for (; deviceIndex < deviceCount; deviceIndex++)\n        {\n            long deviceInfo = PortAudio.Pa_GetDeviceInfo(deviceIndex);\n            int maxInputChannels =\n                PortAudio.PaDeviceInfo_getMaxInputChannels(deviceInfo);\n            int maxOutputChannels =\n                PortAudio.PaDeviceInfo_getMaxOutputChannels(deviceInfo);\n\n            CaptureDeviceInfo jmfInfo =\n                    new CaptureDeviceInfo(\n                        PortAudio.PaDeviceInfo_getName(deviceInfo),\n                        new MediaLocator(\n                            PortAudioUtils.LOCATOR_PREFIX + deviceIndex),\n                        new Format[]{DataSource.getCaptureFormat()});\n\n            if(maxInputChannels > 0)\n            {\n                CaptureDeviceManager.addDevice(jmfInfo);\n            }\n\n            if(maxOutputChannels > 0)\n            {\n                playbackDevVector.add(jmfInfo);\n            }\n\n            if(deviceIndex == defaultInputDeviceIx)\n                defaultCaptureDevice = jmfInfo;\n\n            if(deviceIndex == defaultOutputDeviceIx)\n                defaultPlaybackDevice = jmfInfo;\n        }\n\n        playbackDevices = playbackDevVector.toArray(new CaptureDeviceInfo[0]);\n\n        CaptureDeviceManager.commit();\n\n        // now add it as available audio system to DeviceConfiguration\n        DeviceConfiguration.addAudioSystem(\n            DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO);\n    }","id":23216,"modified_method":"/**\n     * Initializes a new <tt>PortAudioAuto<\/tt> instance which creates PortAudio\n     * capture devices by enumerating all host devices with input channels.\n     *\n     * @throws Exception if anything wrong happens while creating the PortAudio\n     * capture devices\n     */\n    PortAudioAuto()\n        throws Exception\n    {\n        // if PortAudio has a problem initializing like missing native\n        // components it will trow exception here and PortAudio rendering will\n        // not be inited.\n        PortAudioManager.getInstance();\n\n        // enable jmf logging, so we can track codec chains and formats\n        if(Logger.getLogger(PortAudioAuto.class).isDebugEnabled())\n            Registry.set(\"allowLogging\", true);\n\n        int deviceCount = PortAudio.Pa_GetDeviceCount();\n\n        int defaultInputDeviceIx = PortAudio.Pa_GetDefaultInputDevice();\n        int defaultOutputDeviceIx = PortAudio.Pa_GetDefaultOutputDevice();\n\n        Vector<CaptureDeviceInfo> playbackDevVector =\n            new Vector<CaptureDeviceInfo>();\n\n        for (int deviceIndex = 0; deviceIndex < deviceCount; deviceIndex++)\n        {\n            long deviceInfo = PortAudio.Pa_GetDeviceInfo(deviceIndex);\n            int maxInputChannels =\n                PortAudio.PaDeviceInfo_getMaxInputChannels(deviceInfo);\n            int maxOutputChannels =\n                PortAudio.PaDeviceInfo_getMaxOutputChannels(deviceInfo);\n\n            CaptureDeviceInfo jmfInfo =\n                    new CaptureDeviceInfo(\n                        PortAudio.PaDeviceInfo_getName(deviceInfo),\n                        new MediaLocator(\n                            PortAudioUtils.LOCATOR_PREFIX + deviceIndex),\n                        new Format[]{DataSource.getCaptureFormat()});\n\n            if(maxInputChannels > 0)\n            {\n                CaptureDeviceManager.addDevice(jmfInfo);\n            }\n\n            if(maxOutputChannels > 0)\n            {\n                playbackDevVector.add(jmfInfo);\n            }\n\n            if(deviceIndex == defaultInputDeviceIx)\n                defaultCaptureDevice = jmfInfo;\n\n            if(deviceIndex == defaultOutputDeviceIx)\n                defaultPlaybackDevice = jmfInfo;\n        }\n\n        playbackDevices = playbackDevVector.toArray(new CaptureDeviceInfo[0]);\n\n        CaptureDeviceManager.commit();\n\n        // now add it as available audio system to DeviceConfiguration\n        DeviceConfiguration.addAudioSystem(\n            DeviceConfiguration.AUDIO_SYSTEM_PORTAUDIO);\n    }","commit_id":"c68665d4323aabdd7f68d873e44e78cf840c57a6","url":"https://github.com/jitsi/jitsi"},{"original_method":"public String outerMethod() {\n            log(\"**** outerMethod() received, calling innerMethod() on all members\");\n            MethodCall call = new MethodCall(\"innerMethod\", new Object[0], new Class[0]);\n            // RspList rspList = disp.callRemoteMethods(null, call, GroupRequest.GET_ALL, 5000);\n            RspList rspList = disp.callRemoteMethods(null, call, GroupRequest.GET_ALL, 0, false, true);\n            Vector results = rspList.getResults();\n            log(\"results of calling innerMethod():\\n\" + rspList);\n            StringBuilder sb=new StringBuilder(\"outerMethod[\");\n            for(Enumeration e = results.elements(); e.hasMoreElements(); ) {\n                String s = (String)e.nextElement();\n                sb.append(s);\n                if (e.hasMoreElements()) {\n                    sb.append(\";\");\n                }\n            }\n            sb.append(\"]\");\n            return sb.toString();\n        }","id":23217,"modified_method":"public String outerMethod() {\n            log(\"**** outerMethod() received, calling innerMethod() on all members\");\n            MethodCall call = new MethodCall(\"innerMethod\", new Object[0], new Class[0]);\n            // RspList rspList = disp.callRemoteMethods(null, call, GroupRequest.GET_ALL, 5000);\n            RequestOptions opts=new RequestOptions(GroupRequest.GET_ALL, 0, false, null, (byte)0);\n            opts.setFlags(Message.OOB);\n            RspList rspList = disp.callRemoteMethods(null, call, opts);\n            Vector results = rspList.getResults();\n            log(\"results of calling innerMethod():\\n\" + rspList);\n            StringBuilder sb=new StringBuilder(\"outerMethod[\");\n            for(Enumeration e = results.elements(); e.hasMoreElements(); ) {\n                String s = (String)e.nextElement();\n                sb.append(s);\n                if (e.hasMoreElements()) {\n                    sb.append(\";\");\n                }\n            }\n            sb.append(\"]\");\n            return sb.toString();\n        }","commit_id":"e0838d46a6a29e9a963b919cf4e9341ef334c59e","url":"https://github.com/belaban/JGroups"},{"original_method":"private void cast_call(Method method, boolean oob) {\n\t\tMethodCall call=new MethodCall(method);\n        disp.callRemoteMethods(null, call, GroupRequest.GET_ALL, 0, false, oob);\n\t}","id":23218,"modified_method":"private void cast_call(Method method, boolean oob) {\n        MethodCall call=new MethodCall(method);\n        RequestOptions options=new RequestOptions(GroupRequest.GET_ALL, 0, false, null, (byte)0);\n        if(oob)\n            options.setFlags(Message.OOB);\n        disp.callRemoteMethods(null, call, options);\n\t}","commit_id":"e0838d46a6a29e9a963b919cf4e9341ef334c59e","url":"https://github.com/belaban/JGroups"},{"original_method":"public void start() {\n\t\ttry {\n\t\t    channel = new JChannel();\n\t\t    disp = new RpcDispatcher(channel, null, null, this);\n\t\t    channel.connect(name);\n\t\t}\n        catch(ChannelClosedException ex) { ex.printStackTrace(); }\n        catch(ChannelException ex) { ex.printStackTrace(); }\n\n\t\t// Call foo() which in turn calls bar()\n\t\tcast_call(FOO, false);\n\t\tchannel.close();\n\t\tSystem.out.println(\"Disconnected\");\n\t}","id":23219,"modified_method":"public void start() {\n\t\ttry {\n\t\t    channel = new JChannel();\n\t\t    disp = new RpcDispatcher(channel, null, null, this);\n\t\t    channel.connect(name);\n\t\t}\n        catch(ChannelClosedException ex) { ex.printStackTrace(); }\n        catch(ChannelException ex) { ex.printStackTrace(); }\n\n\t\t// Call foo() which in turn calls bar()\n\t\tcast_call(FOO, false);\n\t\tchannel.close();\n\t}","commit_id":"e0838d46a6a29e9a963b919cf4e9341ef334c59e","url":"https://github.com/belaban/JGroups"},{"original_method":"private void invokeRpcs() throws Exception {\n        Method method=MethodCall.findMethod(ScaleTest.class, \"getAddress\", null);\n        MethodCall call=new MethodCall(method);\n        call.setRequestMode(GroupRequest.GET_ALL);\n        call.setTimeout(5000);\n        call.setFlags(Message.DONT_BUNDLE);\n        int num_msgs=Util.readIntFromStdin(\"Number of RPCs: \");\n        int print=num_msgs / 10;\n        System.out.println(\"Invoking \" + num_msgs + \" RPCs:\");\n        long start=System.currentTimeMillis();\n        for(int i=0; i < num_msgs; i++) {\n            disp.callRemoteMethods(null, call);\n            if(print > 0 && i % print == 0)\n                System.out.println(\"invoking RPC #\" + i);\n        }\n        long diff=System.currentTimeMillis() - start;\n        double rpcs_per_sec=num_msgs / (diff / 1000.0);\n        System.out.println(\"Invoked \" + num_msgs + \" in \" + diff + \" ms: \" + f.format(rpcs_per_sec) + \" RPCs / sec\");\n    }","id":23220,"modified_method":"private void invokeRpcs() throws Exception {\n        Method method=MethodCall.findMethod(ScaleTest.class, \"getAddress\", null);\n        MethodCall call=new MethodCall(method);\n        RequestOptions opts=new RequestOptions().setMode(GroupRequest.GET_ALL)\n                .setTimeout(5000).setFlags(Message.DONT_BUNDLE);\n        int num_msgs=Util.readIntFromStdin(\"Number of RPCs: \");\n        int print=num_msgs / 10;\n        System.out.println(\"Invoking \" + num_msgs + \" RPCs:\");\n        long start=System.currentTimeMillis();\n        for(int i=0; i < num_msgs; i++) {\n            disp.callRemoteMethods(null, call, opts);\n            if(print > 0 && i % print == 0)\n                System.out.println(\"invoking RPC #\" + i);\n        }\n        long diff=System.currentTimeMillis() - start;\n        double rpcs_per_sec=num_msgs / (diff / 1000.0);\n        System.out.println(\"Invoked \" + num_msgs + \" in \" + diff + \" ms: \" + f.format(rpcs_per_sec) + \" RPCs / sec\");\n    }","commit_id":"e0838d46a6a29e9a963b919cf4e9341ef334c59e","url":"https://github.com/belaban/JGroups"},{"original_method":"public String outerMethod() {\n            log(\"**** outerMethod() received, calling innerMethod() on all members\");\n            MethodCall call = new MethodCall(\"innerMethod\", new Object[0], new Class[0]);\n            // RspList rspList = disp.callRemoteMethods(null, call, GroupRequest.GET_ALL, 5000);\n            RspList rspList = disp.callRemoteMethods(null, call, GroupRequest.GET_ALL, 0, false, true);\n            Vector results = rspList.getResults();\n            log(\"results of calling innerMethod():\\n\" + rspList);\n            StringBuilder sb=new StringBuilder(\"outerMethod[\");\n            for(Enumeration e = results.elements(); e.hasMoreElements(); ) {\n                String s = (String)e.nextElement();\n                sb.append(s);\n                if (e.hasMoreElements()) {\n                    sb.append(\";\");\n                }\n            }\n            sb.append(\"]\");\n            return sb.toString();\n        }","id":23221,"modified_method":"public String outerMethod() {\n            log(\"**** outerMethod() received, calling innerMethod() on all members\");\n            MethodCall call = new MethodCall(\"innerMethod\", new Object[0], new Class[0]);\n            // RspList rspList = disp.callRemoteMethods(null, call, GroupRequest.GET_ALL, 5000);\n            RequestOptions opts=new RequestOptions(GroupRequest.GET_ALL, 0, false, null, (byte)0);\n            opts.setFlags(Message.OOB);\n            RspList rspList = disp.callRemoteMethods(null, call, opts);\n            Vector results = rspList.getResults();\n            log(\"results of calling innerMethod():\\n\" + rspList);\n            StringBuilder sb=new StringBuilder(\"outerMethod[\");\n            for(Enumeration e = results.elements(); e.hasMoreElements(); ) {\n                String s = (String)e.nextElement();\n                sb.append(s);\n                if (e.hasMoreElements()) {\n                    sb.append(\";\");\n                }\n            }\n            sb.append(\"]\");\n            return sb.toString();\n        }","commit_id":"ab65253d4dfeb8b5cbb6d1e2b407e780db268fab","url":"https://github.com/belaban/JGroups"},{"original_method":"private void cast_call(Method method, boolean oob) {\n\t\tMethodCall call=new MethodCall(method);\n        disp.callRemoteMethods(null, call, GroupRequest.GET_ALL, 0, false, oob);\n\t}","id":23222,"modified_method":"private void cast_call(Method method, boolean oob) {\n        MethodCall call=new MethodCall(method);\n        RequestOptions options=new RequestOptions(GroupRequest.GET_ALL, 0, false, null, (byte)0);\n        if(oob)\n            options.setFlags(Message.OOB);\n        disp.callRemoteMethods(null, call, options);\n\t}","commit_id":"ab65253d4dfeb8b5cbb6d1e2b407e780db268fab","url":"https://github.com/belaban/JGroups"},{"original_method":"public void start() {\n\t\ttry {\n\t\t    channel = new JChannel();\n\t\t    disp = new RpcDispatcher(channel, null, null, this);\n\t\t    channel.connect(name);\n\t\t}\n        catch(ChannelClosedException ex) { ex.printStackTrace(); }\n        catch(ChannelException ex) { ex.printStackTrace(); }\n\n\t\t// Call foo() which in turn calls bar()\n\t\tcast_call(FOO, false);\n\t\tchannel.close();\n\t\tSystem.out.println(\"Disconnected\");\n\t}","id":23223,"modified_method":"public void start() {\n\t\ttry {\n\t\t    channel = new JChannel();\n\t\t    disp = new RpcDispatcher(channel, null, null, this);\n\t\t    channel.connect(name);\n\t\t}\n        catch(ChannelClosedException ex) { ex.printStackTrace(); }\n        catch(ChannelException ex) { ex.printStackTrace(); }\n\n\t\t// Call foo() which in turn calls bar()\n\t\tcast_call(FOO, false);\n\t\tchannel.close();\n\t}","commit_id":"ab65253d4dfeb8b5cbb6d1e2b407e780db268fab","url":"https://github.com/belaban/JGroups"},{"original_method":"private void invokeRpcs() throws Exception {\n        Method method=MethodCall.findMethod(ScaleTest.class, \"getAddress\", null);\n        MethodCall call=new MethodCall(method);\n        call.setRequestMode(GroupRequest.GET_ALL);\n        call.setTimeout(5000);\n        call.setFlags(Message.DONT_BUNDLE);\n        int num_msgs=Util.readIntFromStdin(\"Number of RPCs: \");\n        int print=num_msgs / 10;\n        System.out.println(\"Invoking \" + num_msgs + \" RPCs:\");\n        long start=System.currentTimeMillis();\n        for(int i=0; i < num_msgs; i++) {\n            disp.callRemoteMethods(null, call);\n            if(print > 0 && i % print == 0)\n                System.out.println(\"invoking RPC #\" + i);\n        }\n        long diff=System.currentTimeMillis() - start;\n        double rpcs_per_sec=num_msgs / (diff / 1000.0);\n        System.out.println(\"Invoked \" + num_msgs + \" in \" + diff + \" ms: \" + f.format(rpcs_per_sec) + \" RPCs / sec\");\n    }","id":23224,"modified_method":"private void invokeRpcs() throws Exception {\n        Method method=MethodCall.findMethod(ScaleTest.class, \"getAddress\", null);\n        MethodCall call=new MethodCall(method);\n        RequestOptions opts=new RequestOptions().setMode(GroupRequest.GET_ALL)\n                .setTimeout(5000).setFlags(Message.DONT_BUNDLE);\n        int num_msgs=Util.readIntFromStdin(\"Number of RPCs: \");\n        int print=num_msgs / 10;\n        System.out.println(\"Invoking \" + num_msgs + \" RPCs:\");\n        long start=System.currentTimeMillis();\n        for(int i=0; i < num_msgs; i++) {\n            disp.callRemoteMethods(null, call, opts);\n            if(print > 0 && i % print == 0)\n                System.out.println(\"invoking RPC #\" + i);\n        }\n        long diff=System.currentTimeMillis() - start;\n        double rpcs_per_sec=num_msgs / (diff / 1000.0);\n        System.out.println(\"Invoked \" + num_msgs + \" in \" + diff + \" ms: \" + f.format(rpcs_per_sec) + \" RPCs / sec\");\n    }","commit_id":"ab65253d4dfeb8b5cbb6d1e2b407e780db268fab","url":"https://github.com/belaban/JGroups"},{"original_method":"public void testReadExportedModules() throws Exception\n    {\n        File osgiBundleFile = getTestBundle();\n\n        assertTrue( osgiBundleFile.exists() );\n\n        MavenProject project = getMavenProjectStub();\n\n        //        PackageVersionAnalyzer analyzer = new PackageVersionAnalyzer();\n        Builder analyzer = new Builder();\n        Jar jar = new Jar( \"name\", osgiBundleFile );\n        analyzer.setJar( jar );\n        analyzer.setClasspath( new Jar[]\n            { jar } );\n\n        analyzer.setProperty( Analyzer.EXPORT_PACKAGE, \"*\" );\n        analyzer.calcManifest();\n\n        assertEquals( 3, analyzer.getExports().size() );\n\n        analyzer.close();\n    }","id":23225,"modified_method":"public void testReadExportedModules() throws Exception\n    {\n        File osgiBundleFile = getTestBundle();\n\n        assertTrue( osgiBundleFile.exists() );\n\n        MavenProject project = getMavenProjectStub();\n\n        //        PackageVersionAnalyzer analyzer = new PackageVersionAnalyzer();\n        Builder analyzer = new Builder();\n        Jar jar = new Jar( \"name\", osgiBundleFile );\n        analyzer.setJar( jar );\n        analyzer.setClasspath( new Jar[]\n            { jar } );\n\n        analyzer.setProperty( Analyzer.EXPORT_PACKAGE, \"*\" );\n        analyzer.getJar().setManifest( analyzer.calcManifest() );\n\n        assertEquals( 3, analyzer.getExports().size() );\n\n        analyzer.close();\n    }","commit_id":"fa00e22fc723e71341746307db44750abcd7a363","url":"https://github.com/apache/felix"},{"original_method":"protected Analyzer getAnalyzer( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws IOException, MojoExecutionException, Exception\n    {\n        if ( rebuildBundle && supportedProjectTypes.contains( project.getArtifact().getType() ) )\n        {\n            return buildOSGiBundle( project, instructions, properties, classpath );\n        }\n\n        File file = project.getArtifact().getFile();\n        if ( file == null )\n        {\n            file = getOutputDirectory();\n        }\n\n        if ( !file.exists() )\n        {\n            throw new FileNotFoundException( file.getPath() );\n        }\n\n        Builder analyzer = getOSGiBuilder( project, instructions, properties, classpath );\n\n        analyzer.setJar( file );\n\n        // calculateExportsFromContents when we have no explicit instructions defining\n        // the contents of the bundle *and* we are not analyzing the output directory,\n        // otherwise fall-back to addMavenInstructions approach\n\n        boolean isOutputDirectory = file.equals( getOutputDirectory() );\n\n        if ( analyzer.getProperty( Analyzer.EXPORT_PACKAGE ) == null\n            && analyzer.getProperty( Analyzer.EXPORT_CONTENTS ) == null\n            && analyzer.getProperty( Analyzer.PRIVATE_PACKAGE ) == null && !isOutputDirectory )\n        {\n            String export = calculateExportsFromContents( analyzer.getJar() );\n            analyzer.setProperty( Analyzer.EXPORT_PACKAGE, export );\n        }\n\n        addMavenInstructions( project, analyzer );\n\n        // if we spot Embed-Dependency and the bundle is \"target/classes\", assume we need to rebuild\n        if ( analyzer.getProperty( DependencyEmbedder.EMBED_DEPENDENCY ) != null && isOutputDirectory )\n        {\n            analyzer.build();\n        }\n        else\n        {\n            analyzer.mergeManifest( analyzer.getJar().getManifest() );\n            analyzer.calcManifest();\n        }\n\n        mergeMavenManifest( project, analyzer );\n\n        return analyzer;\n    }","id":23226,"modified_method":"protected Analyzer getAnalyzer( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws IOException, MojoExecutionException, Exception\n    {\n        if ( rebuildBundle && supportedProjectTypes.contains( project.getArtifact().getType() ) )\n        {\n            return buildOSGiBundle( project, instructions, properties, classpath );\n        }\n\n        File file = project.getArtifact().getFile();\n        if ( file == null )\n        {\n            file = getOutputDirectory();\n        }\n\n        if ( !file.exists() )\n        {\n            if ( file.equals( getOutputDirectory() ) )\n            {\n                file.mkdirs();\n            }\n            else\n            {\n                throw new FileNotFoundException( file.getPath() );\n            }\n        }\n\n        Builder analyzer = getOSGiBuilder( project, instructions, properties, classpath );\n\n        analyzer.setJar( file );\n\n        // calculateExportsFromContents when we have no explicit instructions defining\n        // the contents of the bundle *and* we are not analyzing the output directory,\n        // otherwise fall-back to addMavenInstructions approach\n\n        boolean isOutputDirectory = file.equals( getOutputDirectory() );\n\n        if ( analyzer.getProperty( Analyzer.EXPORT_PACKAGE ) == null\n            && analyzer.getProperty( Analyzer.EXPORT_CONTENTS ) == null\n            && analyzer.getProperty( Analyzer.PRIVATE_PACKAGE ) == null && !isOutputDirectory )\n        {\n            String export = calculateExportsFromContents( analyzer.getJar() );\n            analyzer.setProperty( Analyzer.EXPORT_PACKAGE, export );\n        }\n\n        addMavenInstructions( project, analyzer );\n\n        // if we spot Embed-Dependency and the bundle is \"target/classes\", assume we need to rebuild\n        if ( analyzer.getProperty( DependencyEmbedder.EMBED_DEPENDENCY ) != null && isOutputDirectory )\n        {\n            analyzer.build();\n        }\n        else\n        {\n            analyzer.mergeManifest( analyzer.getJar().getManifest() );\n            analyzer.getJar().setManifest( analyzer.calcManifest() );\n        }\n\n        mergeMavenManifest( project, analyzer );\n\n        return analyzer;\n    }","commit_id":"2ae5d3dcc7220b534d0d524dd1c8967b21bb21f6","url":"https://github.com/apache/felix"},{"original_method":"protected void processBundleVersion(Analyzer analyzer) {\n\t\t_bundleVersion = MapUtil.getString(\n\t\t\t_parameters, Constants.BUNDLE_VERSION);\n\n\t\tif (Validator.isNull(_bundleVersion)) {\n\t\t\tif (_pluginPackage != null) {\n\t\t\t\t_bundleVersion = _pluginPackage.getVersion();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_bundleVersion = \"1.0.0\";\n\t\t\t}\n\t\t}\n\n\t\tif (!Version.isVersion(_bundleVersion)) {\n\n\t\t\t// Convert from the Maven format to the OSGi format\n\n\t\t\tMatcher matcher = _versionMavenPattern.matcher(_bundleVersion);\n\n\t\t\tif (matcher.matches()) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\t\tsb.append(matcher.group(1));\n\t\t\t\tsb.append(\".\");\n\t\t\t\tsb.append(matcher.group(3));\n\t\t\t\tsb.append(\".\");\n\t\t\t\tsb.append(matcher.group(5));\n\t\t\t\tsb.append(\".\");\n\t\t\t\tsb.append(matcher.group(7));\n\n\t\t\t\t_bundleVersion = sb.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_bundleVersion = \"0.0.0.\" + _bundleVersion;\n\t\t\t}\n\t\t}\n\n\t\tanalyzer.setProperty(Constants.BUNDLE_VERSION, _bundleVersion);\n\t}","id":23227,"modified_method":"protected void processBundleVersion(Analyzer analyzer) {\n\t\t_bundleVersion = MapUtil.getString(\n\t\t\t_parameters, Constants.BUNDLE_VERSION);\n\n\t\tif (Validator.isNull(_bundleVersion)) {\n\t\t\tif (_pluginPackage != null) {\n\t\t\t\t_bundleVersion = _pluginPackage.getVersion();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_bundleVersion = \"1.0.0\";\n\t\t\t}\n\t\t}\n\n\t\tif (!Version.isVersion(_bundleVersion)) {\n\n\t\t\t// Convert from the Maven format to the OSGi format\n\n\t\t\tMatcher matcher = _versionMavenPattern.matcher(_bundleVersion);\n\n\t\t\tif (matcher.matches()) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\t\tsb.append(matcher.group(1));\n\t\t\t\tsb.append(\".\");\n\t\t\t\tsb.append(matcher.group(3));\n\t\t\t\tsb.append(\".\");\n\t\t\t\tsb.append(matcher.group(5));\n\t\t\t\tsb.append(\".\");\n\t\t\t\tsb.append(matcher.group(7));\n\n\t\t\t\t_bundleVersion = sb.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_bundleVersion = \"0.0.0.\" + _bundleVersion.replace(\".\", \"_\");\n\t\t\t}\n\t\t}\n\n\t\tanalyzer.setProperty(Constants.BUNDLE_VERSION, _bundleVersion);\n\t}","commit_id":"d415d9987e0847b993642f8ff3bd78f5e25e3e2f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void processImportPackageNames(Analyzer analyzer) {\n\t\tString packageName = MapUtil.getString(\n\t\t\t_parameters, Constants.IMPORT_PACKAGE);\n\n\t\tif (Validator.isNotNull(packageName)) {\n\t\t\tanalyzer.setProperty(Constants.IMPORT_PACKAGE, packageName);\n\t\t}\n\t\telse {\n\t\t\tStringBundler sb = new StringBundler(\n\t\t\t\t(_importPackageNames.size() * 3) + 1);\n\n\t\t\tfor (String importPackageName : _importPackageNames) {\n\t\t\t\tif (Validator.isNull(importPackageName)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsb.append(importPackageName);\n\t\t\t\tsb.append(\";resolution:=\\\"optional\\\"\");\n\t\t\t\tsb.append(StringPool.COMMA);\n\t\t\t}\n\n\t\t\tsb.append(\"*;resolution:=\\\"optional\\\"\");\n\n\t\t\tanalyzer.setProperty(Constants.IMPORT_PACKAGE, sb.toString());\n\t\t}\n\t}","id":23228,"modified_method":"protected void processImportPackageNames(Analyzer analyzer) {\n\t\tString packageName = MapUtil.getString(\n\t\t\t_parameters, Constants.IMPORT_PACKAGE);\n\n\t\tif (Validator.isNotNull(packageName)) {\n\t\t\tanalyzer.setProperty(Constants.IMPORT_PACKAGE, packageName);\n\t\t}\n\t\telse {\n\t\t\tStringBundler sb = new StringBundler(\n\t\t\t\t(_importPackageNames.size() * 3) + 1);\n\n\t\t\tfor (String importPackageName : _importPackageNames) {\n\t\t\t\tif (Validator.isNull(importPackageName)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tboolean containedInClassPath = false;\n\n\t\t\t\tfor (Jar jar : analyzer.getClasspath()) {\n\t\t\t\t\tList<String> packages = jar.getPackages();\n\n\t\t\t\t\tif (packages.contains(importPackageName)) {\n\t\t\t\t\t\tcontainedInClassPath = true;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (containedInClassPath) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsb.append(importPackageName);\n\t\t\t\tsb.append(\";resolution:=\\\"optional\\\"\");\n\t\t\t\tsb.append(StringPool.COMMA);\n\t\t\t}\n\n\t\t\tsb.append(\"*;resolution:=\\\"optional\\\"\");\n\n\t\t\tanalyzer.setProperty(Constants.IMPORT_PACKAGE, sb.toString());\n\t\t}\n\t}","commit_id":"d415d9987e0847b993642f8ff3bd78f5e25e3e2f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void processBundleClasspath(\n\t\t\tAnalyzer analyzer, Properties pluginPackageProperties)\n\t\tthrows IOException {\n\n\t\t// Class path order is critical\n\n\t\tMap<String, File> classPath = new LinkedHashMap<>();\n\n\t\tclassPath.put(\n\t\t\t\"ext/WEB-INF/classes\", new File(_pluginDir, \"ext/WEB-INF/classes\"));\n\t\tclassPath.put(\n\t\t\t\"WEB-INF/classes\", new File(_pluginDir, \"WEB-INF/classes\"));\n\n\t\tString[] portalDependencyJars = new String[0];\n\n\t\tif (pluginPackageProperties != null) {\n\t\t\tportalDependencyJars = StringUtil.split(\n\t\t\t\tpluginPackageProperties.getProperty(\n\t\t\t\t\t\"portal-dependency-jars\", StringPool.BLANK));\n\t\t}\n\n\t\tprocessFiles(\n\t\t\t_pluginDir, _pluginDir.toURI(), classPath, portalDependencyJars);\n\n\t\tanalyzer.setProperty(\n\t\t\tConstants.BUNDLE_CLASSPATH, StringUtil.merge(classPath.keySet()));\n\n\t\tCollection<File> files = classPath.values();\n\n\t\tanalyzer.setClasspath(files.toArray(new File[classPath.size()]));\n\t}","id":23229,"modified_method":"protected void processBundleClasspath(\n\t\t\tAnalyzer analyzer, Properties pluginPackageProperties)\n\t\tthrows IOException {\n\n\t\t// Class path order is critical\n\n\t\tMap<String, File> classPath = new LinkedHashMap<>();\n\n\t\tclassPath.put(\n\t\t\t\"ext/WEB-INF/classes\", new File(_pluginDir, \"ext/WEB-INF/classes\"));\n\t\tclassPath.put(\n\t\t\t\"WEB-INF/classes\", new File(_pluginDir, \"WEB-INF/classes\"));\n\n\t\tString[] portalDependencyJars = new String[0];\n\n\t\tif (pluginPackageProperties != null) {\n\t\t\tportalDependencyJars = StringUtil.split(\n\t\t\t\tpluginPackageProperties.getProperty(\n\t\t\t\t\t\"portal-dependency-jars\", StringPool.BLANK));\n\t\t}\n\n\t\tprocessFiles(\n\t\t\t_pluginDir, _pluginDir.toURI(), classPath, portalDependencyJars);\n\n\t\tJar wab = analyzer.getJar();\n\n\t\tfor (Entry<String, File> entry : classPath.entrySet()) {\n\t\t\tappendProperty(\n\t\t\t\tanalyzer, Constants.BUNDLE_CLASSPATH, entry.getKey());\n\n\t\t\taddWabLib(analyzer, wab, entry.getValue());\n\t\t}\n\n\t\tCollection<File> files = classPath.values();\n\n\t\tanalyzer.setClasspath(files.toArray(new File[classPath.size()]));\n\t}","commit_id":"d415d9987e0847b993642f8ff3bd78f5e25e3e2f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void processExtraHeaders(Analyzer analyzer) {\n\t\tString bundleSymbolicName = analyzer.getProperty(\n\t\t\tConstants.BUNDLE_SYMBOLICNAME);\n\n\t\tProperties properties = PropsUtil.getProperties(\n\t\t\tPropsKeys.MODULE_FRAMEWORK_WEB_GENERATOR_HEADERS, true);\n\n\t\tEnumeration<Object> keys = properties.keys();\n\n\t\twhile (keys.hasMoreElements()) {\n\t\t\tString key = (String)keys.nextElement();\n\n\t\t\tString value = properties.getProperty(key);\n\n\t\t\tString processedKey = key;\n\n\t\t\tif (processedKey.endsWith(StringPool.CLOSE_BRACKET)) {\n\t\t\t\tString filterString =\n\t\t\t\t\tStringPool.OPEN_BRACKET + bundleSymbolicName +\n\t\t\t\t\t\tStringPool.CLOSE_BRACKET;\n\n\t\t\t\tif (!processedKey.endsWith(filterString)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tprocessedKey = processedKey.substring(\n\t\t\t\t\t0, processedKey.indexOf(StringPool.OPEN_BRACKET));\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(value)) {\n\t\t\t\tif (processedKey.equals(Constants.EXPORT_PACKAGE)) {\n\t\t\t\t\tCollections.addAll(\n\t\t\t\t\t\t_exportPackageNames, StringUtil.split(value));\n\t\t\t\t}\n\t\t\t\telse if (processedKey.equals(Constants.IMPORT_PACKAGE)) {\n\t\t\t\t\tCollections.addAll(\n\t\t\t\t\t\t_importPackageNames, StringUtil.split(value));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tanalyzer.setProperty(processedKey, value);\n\t\t}\n\t}","id":23230,"modified_method":"protected void processExtraHeaders(Analyzer analyzer) {\n\t\tString bundleSymbolicName = analyzer.getProperty(\n\t\t\tConstants.BUNDLE_SYMBOLICNAME);\n\n\t\tProperties properties = PropsUtil.getProperties(\n\t\t\tPropsKeys.MODULE_FRAMEWORK_WEB_GENERATOR_HEADERS, true);\n\n\t\tEnumeration<Object> keys = properties.keys();\n\n\t\twhile (keys.hasMoreElements()) {\n\t\t\tString key = (String)keys.nextElement();\n\n\t\t\tString value = properties.getProperty(key);\n\n\t\t\tString processedKey = key;\n\n\t\t\tif (processedKey.endsWith(StringPool.CLOSE_BRACKET)) {\n\t\t\t\tString filterString =\n\t\t\t\t\tStringPool.OPEN_BRACKET + bundleSymbolicName +\n\t\t\t\t\t\tStringPool.CLOSE_BRACKET;\n\n\t\t\t\tif (!processedKey.endsWith(filterString)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tprocessedKey = processedKey.substring(\n\t\t\t\t\t0, processedKey.indexOf(StringPool.OPEN_BRACKET));\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(value)) {\n\t\t\t\tif (processedKey.equals(Constants.EXPORT_PACKAGE)) {\n\t\t\t\t\tCollections.addAll(\n\t\t\t\t\t\t_exportPackageNames, StringUtil.split(value));\n\t\t\t\t}\n\t\t\t\telse if (processedKey.equals(Constants.IMPORT_PACKAGE)) {\n\t\t\t\t\tCollections.addAll(\n\t\t\t\t\t\t_importPackageNames, StringUtil.split(value));\n\t\t\t\t}\n\n\t\t\t\tanalyzer.setProperty(processedKey, value);\n\t\t\t}\n\t\t}\n\t}","commit_id":"d415d9987e0847b993642f8ff3bd78f5e25e3e2f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void transformToOSGiBundle() throws IOException {\n\t\tAnalyzer analyzer = new Analyzer();\n\n\t\tanalyzer.setBase(_pluginDir);\n\t\tanalyzer.setJar(_pluginDir);\n\t\tanalyzer.setProperty(\"-jsp\", \"*.jsp,*.jspf\");\n\t\tanalyzer.setProperty(\n\t\t\t\"-plugin\", \"com.liferay.ant.bnd.jsp.JspAnalyzerPlugin\");\n\n\t\tprocessBundleVersion(analyzer);\n\n\t\tProperties pluginPackageProperties = getPluginPackageProperties();\n\n\t\tprocessBundleClasspath(analyzer, pluginPackageProperties);\n\t\tprocessBundleSymbolicName(analyzer);\n\t\tprocessExtraHeaders(analyzer);\n\t\tprocessPluginPackagePropertiesExportImportPackages(\n\t\t\tpluginPackageProperties);\n\n\t\tprocessBundleManifestVersion(analyzer);\n\n\t\tprocessLiferayPortletXML();\n\t\tprocessWebXML(\"WEB-INF/web.xml\");\n\t\tprocessWebXML(\"WEB-INF/liferay-web.xml\");\n\n\t\tprocessDeclarativeReferences();\n\n\t\tprocessPackageNames(analyzer);\n\n\t\tprocessRequiredDeploymentContexts(analyzer);\n\n\t\tprocessExcludedJSPs(analyzer);\n\n\t\tManifest manifest = null;\n\n\t\ttry {\n\t\t\tmanifest = analyzer.calcManifest();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new IOException(\"Unable to calculate the manifest\", e);\n\t\t}\n\t\tfinally {\n\t\t\tanalyzer.close();\n\t\t}\n\n\t\tprocessManifestVersion(manifest);\n\t\tprocessWebContextPath(manifest);\n\n\t\twriteManifest(manifest);\n\t}","id":23231,"modified_method":"protected void transformToOSGiBundle() throws IOException {\n\t\tAnalyzer analyzer = new Analyzer();\n\n\t\tanalyzer.setBase(_pluginDir);\n\t\tanalyzer.setJar(_pluginDir);\n\t\tanalyzer.setProperty(\"-jsp\", \"*.jsp,*.jspf\");\n\t\tanalyzer.setProperty(\n\t\t\t\"-plugin\", \"com.liferay.ant.bnd.jsp.JspAnalyzerPlugin\");\n\t\tanalyzer.setProperty(\"Web-ContextPath\", getWebContextPath());\n\n\t\tSet<Object> plugins = analyzer.getPlugins();\n\n\t\t// Do not reorder\n\n\t\tplugins.add(_dsAnnotations);\n\t\tplugins.add(_metatypePlugin);\n\t\tplugins.add(_metatypeAnnotations);\n\n\t\tProperties pluginPackageProperties = getPluginPackageProperties();\n\n\t\tprocessBundleVersion(analyzer);\n\t\tprocessBundleClasspath(analyzer, pluginPackageProperties);\n\t\tprocessBundleSymbolicName(analyzer);\n\t\tprocessExtraHeaders(analyzer);\n\t\tprocessPluginPackagePropertiesExportImportPackages(\n\t\t\tpluginPackageProperties);\n\n\t\tprocessBundleManifestVersion(analyzer);\n\n\t\tprocessLiferayPortletXML();\n\t\tprocessWebXML(\"WEB-INF/web.xml\");\n\t\tprocessWebXML(\"WEB-INF/liferay-web.xml\");\n\n\t\tprocessDeclarativeReferences();\n\n\t\tprocessPackageNames(analyzer);\n\n\t\tprocessRequiredDeploymentContexts(analyzer);\n\n\t\tprocessExcludedJSPs(analyzer);\n\n\t\tanalyzer.setProperties(pluginPackageProperties);\n\n\t\ttry {\n\t\t\twriteManifest(analyzer.calcManifest());\n\n\t\t\tcopyOSGI_INFToWab(analyzer);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new IOException(\"Unable to calculate the manifest\", e);\n\t\t}\n\t\tfinally {\n\t\t\tanalyzer.close();\n\t\t}\n\t}","commit_id":"d415d9987e0847b993642f8ff3bd78f5e25e3e2f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Analyzer getAnalyzer( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws IOException, MojoExecutionException, Exception\n    {\n        if ( rebuildBundle && supportedProjectTypes.contains( project.getArtifact().getType() ) )\n        {\n            return buildOSGiBundle( project, instructions, properties, classpath );\n        }\n\n        File file = project.getArtifact().getFile();\n        if ( file == null )\n        {\n            file = getOutputDirectory();\n        }\n\n        if ( !file.exists() )\n        {\n            throw new FileNotFoundException( file.getPath() );\n        }\n\n        Builder analyzer = getOSGiBuilder( project, instructions, properties, classpath );\n\n        analyzer.setJar( file );\n\n        // calculateExportsFromContents when we have no explicit instructions defining\n        // the contents of the bundle *and* we are not analyzing the output directory,\n        // otherwise fall-back to addMavenInstructions approach\n\n        if ( analyzer.getProperty( Analyzer.EXPORT_PACKAGE ) == null\n            && analyzer.getProperty( Analyzer.EXPORT_CONTENTS ) == null\n            && analyzer.getProperty( Analyzer.PRIVATE_PACKAGE ) == null\n            && !file.equals( getOutputDirectory() ) )\n        {\n            String export = calculateExportsFromContents( analyzer.getJar() );\n            analyzer.setProperty( Analyzer.EXPORT_PACKAGE, export );\n        }\n\n        addMavenInstructions( project, analyzer );\n\n        analyzer.mergeManifest( analyzer.getJar().getManifest() );\n        analyzer.calcManifest();\n\n        mergeMavenManifest( project, analyzer );\n\n        return analyzer;\n    }","id":23232,"modified_method":"protected Analyzer getAnalyzer( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws IOException, MojoExecutionException, Exception\n    {\n        if ( rebuildBundle && supportedProjectTypes.contains( project.getArtifact().getType() ) )\n        {\n            return buildOSGiBundle( project, instructions, properties, classpath );\n        }\n\n        File file = project.getArtifact().getFile();\n        if ( file == null )\n        {\n            file = getOutputDirectory();\n        }\n\n        if ( !file.exists() )\n        {\n            throw new FileNotFoundException( file.getPath() );\n        }\n\n        Builder analyzer = getOSGiBuilder( project, instructions, properties, classpath );\n\n        analyzer.setJar( file );\n\n        // calculateExportsFromContents when we have no explicit instructions defining\n        // the contents of the bundle *and* we are not analyzing the output directory,\n        // otherwise fall-back to addMavenInstructions approach\n\n        boolean isOutputDirectory = file.equals( getOutputDirectory() );\n\n        if ( analyzer.getProperty( Analyzer.EXPORT_PACKAGE ) == null\n            && analyzer.getProperty( Analyzer.EXPORT_CONTENTS ) == null\n            && analyzer.getProperty( Analyzer.PRIVATE_PACKAGE ) == null && !isOutputDirectory )\n        {\n            String export = calculateExportsFromContents( analyzer.getJar() );\n            analyzer.setProperty( Analyzer.EXPORT_PACKAGE, export );\n        }\n\n        addMavenInstructions( project, analyzer );\n\n        // if we spot Embed-Dependency and the bundle is \"target/classes\", assume we need to rebuild\n        if ( analyzer.getProperty( DependencyEmbedder.EMBED_DEPENDENCY ) != null && isOutputDirectory )\n        {\n            analyzer.build();\n        }\n        else\n        {\n            analyzer.mergeManifest( analyzer.getJar().getManifest() );\n            analyzer.calcManifest();\n        }\n\n        mergeMavenManifest( project, analyzer );\n\n        return analyzer;\n    }","commit_id":"417fe9029c13972404289b89167aad446abb912f","url":"https://github.com/apache/felix"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, JournalArticle article)\n\t\tthrows Exception {\n\n\t\tElement articleElement = portletDataContext.getExportDataElement(\n\t\t\tarticle);\n\n\t\tarticleElement.addAttribute(\n\t\t\t\"article-resource-uuid\", article.getArticleResourceUuid());\n\n\t\tif (article.getFolderId() !=\n\t\t\t\tJournalFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, article, article.getFolder(),\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_PARENT);\n\t\t}\n\n\t\tDDMStructure ddmStructure = _ddmStructureLocalService.getStructure(\n\t\t\tarticle.getGroupId(),\n\t\t\tPortalUtil.getClassNameId(JournalArticle.class),\n\t\t\tarticle.getDDMStructureKey(), true);\n\n\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\tportletDataContext, article, ddmStructure,\n\t\t\tPortletDataContext.REFERENCE_TYPE_STRONG);\n\n\t\tif (article.getClassNameId() !=\n\t\t\t\tPortalUtil.getClassNameId(DDMStructure.class)) {\n\n\t\t\tDDMTemplate ddmTemplate = _ddmTemplateLocalService.getTemplate(\n\t\t\t\tarticle.getGroupId(),\n\t\t\t\tPortalUtil.getClassNameId(DDMStructure.class),\n\t\t\t\tarticle.getDDMTemplateKey(), true);\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, article, ddmTemplate,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_STRONG);\n\t\t}\n\n\t\tLayout layout = article.getLayout();\n\n\t\tif (layout != null) {\n\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\tarticle, articleElement, layout,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_DEPENDENCY, true);\n\t\t}\n\n\t\tif (article.isSmallImage()) {\n\t\t\tif (Validator.isNotNull(article.getSmallImageURL())) {\n\t\t\t\tString smallImageURL =\n\t\t\t\t\t_journalArticleExportImportContentProcessor.\n\t\t\t\t\t\treplaceExportContentReferences(\n\t\t\t\t\t\t\tportletDataContext, article,\n\t\t\t\t\t\t\tarticle.getSmallImageURL() + StringPool.SPACE, true,\n\t\t\t\t\t\t\tfalse);\n\n\t\t\t\tarticle.setSmallImageURL(smallImageURL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tImage smallImage = _imageLocalService.fetchImage(\n\t\t\t\t\tarticle.getSmallImageId());\n\n\t\t\t\tif ((smallImage != null) && (smallImage.getTextObj() != null)) {\n\t\t\t\t\tString smallImagePath = ExportImportPathUtil.getModelPath(\n\t\t\t\t\t\tarticle,\n\t\t\t\t\t\tsmallImage.getImageId() + StringPool.PERIOD +\n\t\t\t\t\t\t\tsmallImage.getType());\n\n\t\t\t\t\tarticleElement.addAttribute(\n\t\t\t\t\t\t\"small-image-path\", smallImagePath);\n\n\t\t\t\t\tarticle.setSmallImageType(smallImage.getType());\n\n\t\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\t\tsmallImagePath, smallImage.getTextObj());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tarticle.setSmallImage(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tList<JournalArticleImage> articleImages =\n\t\t\t_journalArticleImageLocalService.getArticleImages(\n\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\tarticle.getVersion());\n\n\t\tfor (JournalArticleImage articleImage : articleImages) {\n\t\t\texportArticleImage(\n\t\t\t\tportletDataContext, articleImage, article, articleElement);\n\t\t}\n\n\t\tarticle.setStatusByUserUuid(article.getStatusByUserUuid());\n\n\t\tString content =\n\t\t\t_journalArticleExportImportContentProcessor.\n\t\t\t\treplaceExportContentReferences(\n\t\t\t\t\tportletDataContext, article, article.getContent(),\n\t\t\t\t\tportletDataContext.getBooleanParameter(\n\t\t\t\t\t\t\"journal\", \"referenced-content\"),\n\t\t\t\t\tfalse);\n\n\t\tarticle.setContent(content);\n\n\t\tlong defaultUserId = _userLocalService.getDefaultUserId(\n\t\t\tarticle.getCompanyId());\n\n\t\tif (defaultUserId == article.getUserId()) {\n\t\t\tarticleElement.addAttribute(\"preloaded\", \"true\");\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tarticleElement, ExportImportPathUtil.getModelPath(article),\n\t\t\tarticle);\n\t}","id":23233,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, JournalArticle article)\n\t\tthrows Exception {\n\n\t\tElement articleElement = portletDataContext.getExportDataElement(\n\t\t\tarticle);\n\n\t\tarticleElement.addAttribute(\n\t\t\t\"article-resource-uuid\", article.getArticleResourceUuid());\n\n\t\tif (article.getFolderId() !=\n\t\t\t\tJournalFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, article, article.getFolder(),\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_PARENT);\n\t\t}\n\n\t\tDDMStructure ddmStructure = _ddmStructureLocalService.getStructure(\n\t\t\tarticle.getGroupId(),\n\t\t\tPortalUtil.getClassNameId(JournalArticle.class),\n\t\t\tarticle.getDDMStructureKey(), true);\n\n\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\tportletDataContext, article, ddmStructure,\n\t\t\tPortletDataContext.REFERENCE_TYPE_STRONG);\n\n\t\tif (article.getClassNameId() !=\n\t\t\t\tPortalUtil.getClassNameId(DDMStructure.class)) {\n\n\t\t\tDDMTemplate ddmTemplate = _ddmTemplateLocalService.getTemplate(\n\t\t\t\tarticle.getGroupId(),\n\t\t\t\tPortalUtil.getClassNameId(DDMStructure.class),\n\t\t\t\tarticle.getDDMTemplateKey(), true);\n\n\t\t\tStagedModelDataHandlerUtil.exportReferenceStagedModel(\n\t\t\t\tportletDataContext, article, ddmTemplate,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_STRONG);\n\t\t}\n\n\t\tLayout layout = article.getLayout();\n\n\t\tif (layout != null) {\n\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\tarticle, articleElement, layout,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_DEPENDENCY, true);\n\t\t}\n\n\t\tif (article.isSmallImage()) {\n\t\t\tif (Validator.isNotNull(article.getSmallImageURL())) {\n\t\t\t\tString smallImageURL =\n\t\t\t\t\t_journalArticleExportImportContentProcessor.\n\t\t\t\t\t\treplaceExportContentReferences(\n\t\t\t\t\t\t\tportletDataContext, article,\n\t\t\t\t\t\t\tarticle.getSmallImageURL() + StringPool.SPACE, true,\n\t\t\t\t\t\t\tfalse);\n\n\t\t\t\tarticle.setSmallImageURL(smallImageURL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tImage smallImage = _imageLocalService.fetchImage(\n\t\t\t\t\tarticle.getSmallImageId());\n\n\t\t\t\tif ((smallImage != null) && (smallImage.getTextObj() != null)) {\n\t\t\t\t\tString smallImagePath = ExportImportPathUtil.getModelPath(\n\t\t\t\t\t\tarticle,\n\t\t\t\t\t\tsmallImage.getImageId() + StringPool.PERIOD +\n\t\t\t\t\t\t\tsmallImage.getType());\n\n\t\t\t\t\tarticleElement.addAttribute(\n\t\t\t\t\t\t\"small-image-path\", smallImagePath);\n\n\t\t\t\t\tarticle.setSmallImageType(smallImage.getType());\n\n\t\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\t\tsmallImagePath, smallImage.getTextObj());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\t\t\t\tsb.append(\"Unable to export small image with id \");\n\t\t\t\t\t\tsb.append(article.getSmallImageId());\n\t\t\t\t\t\tsb.append(\" to article \");\n\t\t\t\t\t\tsb.append(article.getArticleId());\n\n\t\t\t\t\t\t_log.warn(sb.toString());\n\t\t\t\t\t}\n\n\t\t\t\t\tarticle.setSmallImage(false);\n\t\t\t\t\tarticle.setSmallImageId(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tList<JournalArticleImage> articleImages =\n\t\t\t_journalArticleImageLocalService.getArticleImages(\n\t\t\t\tarticle.getGroupId(), article.getArticleId(),\n\t\t\t\tarticle.getVersion());\n\n\t\tfor (JournalArticleImage articleImage : articleImages) {\n\t\t\texportArticleImage(\n\t\t\t\tportletDataContext, articleImage, article, articleElement);\n\t\t}\n\n\t\tarticle.setStatusByUserUuid(article.getStatusByUserUuid());\n\n\t\tString content =\n\t\t\t_journalArticleExportImportContentProcessor.\n\t\t\t\treplaceExportContentReferences(\n\t\t\t\t\tportletDataContext, article, article.getContent(),\n\t\t\t\t\tportletDataContext.getBooleanParameter(\n\t\t\t\t\t\t\"journal\", \"referenced-content\"),\n\t\t\t\t\tfalse);\n\n\t\tarticle.setContent(content);\n\n\t\tlong defaultUserId = _userLocalService.getDefaultUserId(\n\t\t\tarticle.getCompanyId());\n\n\t\tif (defaultUserId == article.getUserId()) {\n\t\t\tarticleElement.addAttribute(\"preloaded\", \"true\");\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tarticleElement, ExportImportPathUtil.getModelPath(article),\n\t\t\tarticle);\n\t}","commit_id":"5c51807d10dc1e0012861a905e7bb2c05628de64","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BlogsEntry updateEntry(\n\t\t\tlong userId, long entryId, String title, String subtitle,\n\t\t\tString description, String content, Date displayDate,\n\t\t\tboolean allowPingbacks, boolean allowTrackbacks,\n\t\t\tString[] trackbacks, ImageSelector coverImageImageSelector,\n\t\t\tImageSelector smallImageImageSelector,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tBlogsEntry entry = blogsEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tlong coverImageFileEntryId = entry.getCoverImageFileEntryId();\n\t\tString coverImageURL = entry.getCoverImageURL();\n\n\t\tif (coverImageImageSelector != null) {\n\t\t\tcoverImageFileEntryId = coverImageImageSelector.getImageId();\n\t\t\tcoverImageURL = coverImageImageSelector.getImageURL();\n\n\t\t\tif (coverImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getCoverImageFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (coverImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getCoverImageFileEntryId()) {\n\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getCoverImageFileEntryId());\n\t\t\t\t}\n\n\t\t\t\tif (coverImageImageSelector.getImageId() != 0) {\n\t\t\t\t\tcoverImageFileEntryId = addCoverImage(\n\t\t\t\t\t\tuserId, entry.getGroupId(), entryId,\n\t\t\t\t\t\tcoverImageImageSelector);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean smallImage = entry.isSmallImage();\n\t\tlong smallImageFileEntryId = entry.getSmallImageFileEntryId();\n\t\tString smallImageURL = entry.getSmallImageURL();\n\n\t\tif (smallImageImageSelector != null) {\n\t\t\tsmallImage = !smallImageImageSelector.isRemoveSmallImage();\n\t\t\tsmallImageFileEntryId = smallImageImageSelector.getImageId();\n\t\t\tsmallImageURL = smallImageImageSelector.getImageURL();\n\n\t\t\tif (smallImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getSmallImageFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (smallImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getSmallImageFileEntryId()) {\n\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getSmallImageFileEntryId());\n\t\t\t\t}\n\n\t\t\t\tFileEntry tempFileEntry =\n\t\t\t\t\tPortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\t\t\t\tsmallImageImageSelector.getImageId());\n\n\t\t\t\tsmallImageFileEntryId = addSmallImageFileEntry(\n\t\t\t\t\tuserId, entry.getGroupId(), entry.getEntryId(),\n\t\t\t\t\ttempFileEntry.getMimeType(), tempFileEntry.getTitle(),\n\t\t\t\t\ttempFileEntry.getContentStream());\n\n\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\ttempFileEntry.getFileEntryId());\n\t\t\t}\n\t\t}\n\n\t\tvalidate(title, content, smallImageFileEntryId);\n\n\t\tString oldUrlTitle = entry.getUrlTitle();\n\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tentry.setTitle(title);\n\t\tentry.setSubtitle(subtitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, oldUrlTitle, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\t\tentry.setCoverImageFileEntryId(coverImageFileEntryId);\n\t\tentry.setCoverImageURL(coverImageURL);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageFileEntryId(smallImageFileEntryId);\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tif (entry.isPending() || entry.isDraft()) {\n\t\t}\n\t\telse {\n\t\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getGroupPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Workflow\n\n\t\tboolean pingOldTrackbacks = false;\n\n\t\tif (!oldUrlTitle.equals(entry.getUrlTitle())) {\n\t\t\tpingOldTrackbacks = true;\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"pingOldTrackbacks\", String.valueOf(pingOldTrackbacks));\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\treturn startWorkflowInstance(userId, entry, serviceContext);\n\t}","id":23234,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BlogsEntry updateEntry(\n\t\t\tlong userId, long entryId, String title, String subtitle,\n\t\t\tString description, String content, Date displayDate,\n\t\t\tboolean allowPingbacks, boolean allowTrackbacks,\n\t\t\tString[] trackbacks, ImageSelector coverImageImageSelector,\n\t\t\tImageSelector smallImageImageSelector,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tBlogsEntry entry = blogsEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tvalidate(title, content);\n\n\t\tString oldUrlTitle = entry.getUrlTitle();\n\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tentry.setTitle(title);\n\t\tentry.setSubtitle(subtitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, oldUrlTitle, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\n\t\tif (entry.isPending() || entry.isDraft()) {\n\t\t}\n\t\telse {\n\t\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getGroupPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Images\n\n\t\tlong coverImageFileEntryId = entry.getCoverImageFileEntryId();\n\t\tString coverImageURL = entry.getCoverImageURL();\n\n\t\tif (coverImageImageSelector != null) {\n\t\t\tcoverImageFileEntryId = coverImageImageSelector.getImageId();\n\t\t\tcoverImageURL = coverImageImageSelector.getImageURL();\n\n\t\t\tif (coverImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getCoverImageFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (coverImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getCoverImageFileEntryId()) {\n\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getCoverImageFileEntryId());\n\t\t\t\t}\n\n\t\t\t\tif (coverImageImageSelector.getImageId() != 0) {\n\t\t\t\t\tcoverImageFileEntryId = addCoverImage(\n\t\t\t\t\t\tuserId, entry.getGroupId(), entryId,\n\t\t\t\t\t\tcoverImageImageSelector);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean smallImage = entry.isSmallImage();\n\t\tlong smallImageFileEntryId = entry.getSmallImageFileEntryId();\n\t\tString smallImageURL = entry.getSmallImageURL();\n\n\t\tif (smallImageImageSelector != null) {\n\t\t\tsmallImage = !smallImageImageSelector.isRemoveSmallImage();\n\t\t\tsmallImageFileEntryId = smallImageImageSelector.getImageId();\n\t\t\tsmallImageURL = smallImageImageSelector.getImageURL();\n\n\t\t\tif (smallImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getSmallImageFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (smallImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getSmallImageFileEntryId()) {\n\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getSmallImageFileEntryId());\n\t\t\t\t}\n\n\t\t\t\tFileEntry tempFileEntry =\n\t\t\t\t\tPortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\t\t\t\tsmallImageImageSelector.getImageId());\n\n\t\t\t\tsmallImageFileEntryId = addSmallImageFileEntry(\n\t\t\t\t\tuserId, entry.getGroupId(), entry.getEntryId(),\n\t\t\t\t\ttempFileEntry.getMimeType(), tempFileEntry.getTitle(),\n\t\t\t\t\ttempFileEntry.getContentStream());\n\n\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\ttempFileEntry.getFileEntryId());\n\t\t\t}\n\t\t}\n\n\t\tvalidate(smallImageFileEntryId);\n\n\t\tentry.setCoverImageFileEntryId(coverImageFileEntryId);\n\t\tentry.setCoverImageURL(coverImageURL);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageFileEntryId(smallImageFileEntryId);\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Workflow\n\n\t\tboolean pingOldTrackbacks = false;\n\n\t\tif (!oldUrlTitle.equals(entry.getUrlTitle())) {\n\t\t\tpingOldTrackbacks = true;\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"pingOldTrackbacks\", String.valueOf(pingOldTrackbacks));\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\treturn startWorkflowInstance(userId, entry, serviceContext);\n\t}","commit_id":"a07652998c452786c522e7e0d79594d30a995fd6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void validate(\n\t\t\tString title, String content, long smallImageFileEntryId)\n\t\tthrows PortalException {\n\n\t\tif (Validator.isNull(title)) {\n\t\t\tthrow new EntryTitleException();\n\t\t}\n\t\telse if (Validator.isNull(content)) {\n\t\t\tthrow new EntryContentException();\n\t\t}\n\n\t\tString[] imageExtensions = PrefsPropsUtil.getStringArray(\n\t\t\tPropsKeys.BLOGS_IMAGE_EXTENSIONS, StringPool.COMMA);\n\n\t\tif (smallImageFileEntryId != 0) {\n\t\t\tFileEntry fileEntry = PortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\t\tsmallImageFileEntryId);\n\n\t\t\tboolean validSmallImageExtension = false;\n\n\t\t\tfor (String _imageExtension : imageExtensions) {\n\t\t\t\tif (StringPool.STAR.equals(_imageExtension) ||\n\t\t\t\t\t_imageExtension.equals(\n\t\t\t\t\t\tStringPool.PERIOD + fileEntry.getExtension())) {\n\n\t\t\t\t\tvalidSmallImageExtension = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!validSmallImageExtension) {\n\t\t\t\tthrow new EntrySmallImageNameException(\n\t\t\t\t\t\"Invalid small image for file entry \" +\n\t\t\t\t\t\tsmallImageFileEntryId);\n\t\t\t}\n\n\t\t\tlong smallImageMaxSize = PrefsPropsUtil.getLong(\n\t\t\t\tPropsKeys.BLOGS_IMAGE_SMALL_MAX_SIZE);\n\n\t\t\tif ((smallImageMaxSize > 0) &&\n\t\t\t\t(fileEntry.getSize() > smallImageMaxSize)) {\n\n\t\t\t\tthrow new EntrySmallImageSizeException();\n\t\t\t}\n\t\t}\n\t}","id":23235,"modified_method":"protected void validate(String title, String content)\n\t\tthrows PortalException {\n\n\t\tif (Validator.isNull(title)) {\n\t\t\tthrow new EntryTitleException();\n\t\t}\n\t\telse if (Validator.isNull(content)) {\n\t\t\tthrow new EntryContentException();\n\t\t}\n\t}","commit_id":"a07652998c452786c522e7e0d79594d30a995fd6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BlogsEntry addEntry(\n\t\t\tlong userId, String title, String subtitle, String description,\n\t\t\tString content, Date displayDate, boolean allowPingbacks,\n\t\t\tboolean allowTrackbacks, String[] trackbacks,\n\t\t\tImageSelector coverImageImageSelector,\n\t\t\tImageSelector smallImageImageSelector,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\n\t\tlong entryId = counterLocalService.increment();\n\n\t\tlong coverImageFileEntryId = 0;\n\t\tString coverImageURL = null;\n\n\t\tif (coverImageImageSelector != null) {\n\t\t\tcoverImageFileEntryId = coverImageImageSelector.getImageId();\n\t\t\tcoverImageURL = coverImageImageSelector.getImageURL();\n\t\t}\n\n\t\tif (coverImageFileEntryId != 0) {\n\t\t\tcoverImageFileEntryId = addCoverImage(\n\t\t\t\tuserId, groupId, entryId, coverImageImageSelector);\n\t\t}\n\n\t\tboolean smallImage = false;\n\t\tlong smallImageFileEntryId = 0;\n\t\tString smallImageURL = null;\n\n\t\tif (smallImageImageSelector != null) {\n\t\t\tsmallImage = !smallImageImageSelector.isRemoveSmallImage();\n\t\t\tsmallImageFileEntryId = smallImageImageSelector.getImageId();\n\t\t\tsmallImageURL = smallImageImageSelector.getImageURL();\n\t\t}\n\n\t\tif (smallImageFileEntryId != 0) {\n\t\t\tFileEntry tempFileEntry =\n\t\t\t\tPortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\t\t\tsmallImageFileEntryId);\n\n\t\t\tsmallImageFileEntryId = addSmallImageFileEntry(\n\t\t\t\tuserId, groupId, entryId, tempFileEntry.getMimeType(),\n\t\t\t\ttempFileEntry.getTitle(), tempFileEntry.getContentStream());\n\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\ttempFileEntry.getFileEntryId());\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(title, content, smallImageFileEntryId);\n\n\t\tBlogsEntry entry = blogsEntryPersistence.create(entryId);\n\n\t\tentry.setUuid(serviceContext.getUuid());\n\t\tentry.setGroupId(groupId);\n\t\tentry.setCompanyId(user.getCompanyId());\n\t\tentry.setUserId(user.getUserId());\n\t\tentry.setUserName(user.getFullName());\n\t\tentry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tentry.setTitle(title);\n\t\tentry.setSubtitle(subtitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, null, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\t\tentry.setCoverImageFileEntryId(coverImageFileEntryId);\n\t\tentry.setCoverImageURL(coverImageURL);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageFileEntryId(smallImageFileEntryId);\n\t\tentry.setSmallImageURL(smallImageURL);\n\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tentry.setStatusByUserId(userId);\n\t\tentry.setStatusDate(serviceContext.getModifiedDate(now));\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif (serviceContext.isAddGroupPermissions() ||\n\t\t\tserviceContext.isAddGuestPermissions()) {\n\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.isAddGroupPermissions(),\n\t\t\t\tserviceContext.isAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Comments\n\n\t\taddDiscussion(entry, userId, groupId);\n\n\t\t// Workflow\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\treturn startWorkflowInstance(userId, entry, serviceContext);\n\t}","id":23236,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BlogsEntry addEntry(\n\t\t\tlong userId, String title, String subtitle, String description,\n\t\t\tString content, Date displayDate, boolean allowPingbacks,\n\t\t\tboolean allowTrackbacks, String[] trackbacks,\n\t\t\tImageSelector coverImageImageSelector,\n\t\t\tImageSelector smallImageImageSelector,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\n\t\tlong entryId = counterLocalService.increment();\n\n\t\tDate now = new Date();\n\n\t\tvalidate(title, content);\n\n\t\tBlogsEntry entry = blogsEntryPersistence.create(entryId);\n\n\t\tentry.setUuid(serviceContext.getUuid());\n\t\tentry.setGroupId(groupId);\n\t\tentry.setCompanyId(user.getCompanyId());\n\t\tentry.setUserId(user.getUserId());\n\t\tentry.setUserName(user.getFullName());\n\t\tentry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tentry.setTitle(title);\n\t\tentry.setSubtitle(subtitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, null, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tentry.setStatusByUserId(userId);\n\t\tentry.setStatusDate(serviceContext.getModifiedDate(now));\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif (serviceContext.isAddGroupPermissions() ||\n\t\t\tserviceContext.isAddGuestPermissions()) {\n\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.isAddGroupPermissions(),\n\t\t\t\tserviceContext.isAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Comments\n\n\t\taddDiscussion(entry, userId, groupId);\n\n\t\t// Images\n\n\t\tlong coverImageFileEntryId = 0;\n\t\tString coverImageURL = null;\n\n\t\tif (coverImageImageSelector != null) {\n\t\t\tcoverImageFileEntryId = coverImageImageSelector.getImageId();\n\t\t\tcoverImageURL = coverImageImageSelector.getImageURL();\n\t\t}\n\n\t\tif (coverImageFileEntryId != 0) {\n\t\t\tcoverImageFileEntryId = addCoverImage(\n\t\t\t\tuserId, groupId, entryId, coverImageImageSelector);\n\t\t}\n\n\t\tboolean smallImage = false;\n\t\tlong smallImageFileEntryId = 0;\n\t\tString smallImageURL = null;\n\n\t\tif (smallImageImageSelector != null) {\n\t\t\tsmallImage = !smallImageImageSelector.isRemoveSmallImage();\n\t\t\tsmallImageFileEntryId = smallImageImageSelector.getImageId();\n\t\t\tsmallImageURL = smallImageImageSelector.getImageURL();\n\t\t}\n\n\t\tif (smallImageFileEntryId != 0) {\n\t\t\tFileEntry tempFileEntry =\n\t\t\t\tPortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\t\t\tsmallImageFileEntryId);\n\n\t\t\tsmallImageFileEntryId = addSmallImageFileEntry(\n\t\t\t\tuserId, groupId, entryId, tempFileEntry.getMimeType(),\n\t\t\t\ttempFileEntry.getTitle(), tempFileEntry.getContentStream());\n\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\ttempFileEntry.getFileEntryId());\n\t\t}\n\n\t\tvalidate(smallImageFileEntryId);\n\n\t\tentry.setCoverImageFileEntryId(coverImageFileEntryId);\n\t\tentry.setCoverImageURL(coverImageURL);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageFileEntryId(smallImageFileEntryId);\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Workflow\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\treturn startWorkflowInstance(userId, entry, serviceContext);\n\t}","commit_id":"a07652998c452786c522e7e0d79594d30a995fd6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected long addSmallImageFileEntry(\n\t\t\tlong userId, long groupId, long entryId,\n\t\t\tImageSelector imageSelector)\n\t\tthrows PortalException {\n\n\t\tFileEntry fileEntry = PortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\timageSelector.getImageId());\n\n\t\taddOriginalImageFileEntry(userId, groupId, entryId, fileEntry);\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tImageBag imageBag = ImageToolUtil.read(\n\t\t\t\tfileEntry.getContentStream());\n\n\t\t\tRenderedImage renderedImage = imageBag.getRenderedImage();\n\n\t\t\tBlogsGroupServiceSettings blogsGroupServiceSettings =\n\t\t\t\tBlogsGroupServiceSettings.getInstance(groupId);\n\n\t\t\trenderedImage = ImageToolUtil.scale(\n\t\t\t\trenderedImage, blogsGroupServiceSettings.getSmallImageWidth());\n\n\t\t\tbyte[] bytes = ImageToolUtil.getBytes(\n\t\t\t\trenderedImage, imageBag.getType());\n\n\t\t\tif (bytes == null) {\n\t\t\t\tthrow new EntrySmallImageScaleException();\n\t\t\t}\n\n\t\t\tfile = FileUtil.createTempFile(bytes);\n\n\t\t\tFolder folder = addSmallImageFolder(userId, groupId);\n\n\t\t\treturn addProcessedImageFileEntry(\n\t\t\t\tuserId, groupId, entryId, folder.getFolderId(), imageSelector,\n\t\t\t\tfile);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new EntrySmallImageScaleException();\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\t\t}\n\t}","id":23237,"modified_method":"protected long addSmallImageFileEntry(\n\t\t\tlong userId, long groupId, long entryId,\n\t\t\tImageSelector imageSelector)\n\t\tthrows PortalException {\n\n\t\tbyte[] imageBytes = imageSelector.getImageBytes();\n\n\t\tif (imageBytes == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\ttry {\n\t\t\tImageBag imageBag = ImageToolUtil.read(imageBytes);\n\n\t\t\tRenderedImage renderedImage = imageBag.getRenderedImage();\n\n\t\t\tBlogsGroupServiceSettings blogsGroupServiceSettings =\n\t\t\t\tBlogsGroupServiceSettings.getInstance(groupId);\n\n\t\t\trenderedImage = ImageToolUtil.scale(\n\t\t\t\trenderedImage, blogsGroupServiceSettings.getSmallImageWidth());\n\n\t\t\timageBytes = ImageToolUtil.getBytes(\n\t\t\t\trenderedImage, imageBag.getType());\n\n\t\t\tif (imageBytes == null) {\n\t\t\t\tthrow new EntrySmallImageScaleException();\n\t\t\t}\n\n\t\t\tFolder folder = addSmallImageFolder(userId, groupId);\n\n\t\t\treturn addProcessedImageFileEntry(\n\t\t\t\tuserId, groupId, entryId, folder.getFolderId(),\n\t\t\t\timageSelector.getImageTitle(), imageSelector.getImageMimeType(),\n\t\t\t\timageBytes);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new EntrySmallImageScaleException();\n\t\t}\n\t}","commit_id":"60b3631d45e25e7e46babc50f4fcd04f8b8a69aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * @deprecated As of 7.0.0, replaced by {@link #updateEntry(long, long,\n\t *             String, String, String, String, int, int, int, int, int,\n\t *             boolean, boolean, String[], String, ImageSelector,\n\t *             ImageSelector, ServiceContext)}\n\t */\n\t@Deprecated\n\t@Override\n\tpublic BlogsEntry updateEntry(\n\t\t\tlong userId, long entryId, String title, String description,\n\t\t\tString content, int displayDateMonth, int displayDateDay,\n\t\t\tint displayDateYear, int displayDateHour, int displayDateMinute,\n\t\t\tboolean allowPingbacks, boolean allowTrackbacks,\n\t\t\tString[] trackbacks, boolean smallImage, String smallImageURL,\n\t\t\tString smallImageFileName, InputStream smallImageInputStream,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tImageSelector coverImageImageSelector = null;\n\t\tImageSelector smallImageImageSelector = null;\n\n\t\tif (smallImage) {\n\t\t\tif (Validator.isNotNull(smallImageFileName) &&\n\t\t\t\t(smallImageInputStream != null)) {\n\n\t\t\t\tFileEntry tempFileEntry = TempFileEntryUtil.addTempFileEntry(\n\t\t\t\t\tserviceContext.getScopeGroupId(), userId,\n\t\t\t\t\tBlogsEntry.class.getName(), smallImageFileName,\n\t\t\t\t\tsmallImageInputStream,\n\t\t\t\t\tMimeTypesUtil.getContentType(smallImageFileName));\n\n\t\t\t\tsmallImageImageSelector = new ImageSelector(\n\t\t\t\t\ttempFileEntry.getFileEntryId(), smallImageURL, null);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsmallImageImageSelector = new ImageSelector(0);\n\t\t}\n\n\t\treturn updateEntry(\n\t\t\tuserId, entryId, title, StringPool.BLANK, description, content,\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear, displayDateHour,\n\t\t\tdisplayDateMinute, allowPingbacks, allowTrackbacks, trackbacks,\n\t\t\tStringPool.BLANK, coverImageImageSelector, smallImageImageSelector,\n\t\t\tserviceContext);\n\t}","id":23238,"modified_method":"/**\n\t * @deprecated As of 7.0.0, replaced by {@link #updateEntry(long, long,\n\t *             String, String, String, String, int, int, int, int, int,\n\t *             boolean, boolean, String[], String, ImageSelector,\n\t *             ImageSelector, ServiceContext)}\n\t */\n\t@Deprecated\n\t@Override\n\tpublic BlogsEntry updateEntry(\n\t\t\tlong userId, long entryId, String title, String description,\n\t\t\tString content, int displayDateMonth, int displayDateDay,\n\t\t\tint displayDateYear, int displayDateHour, int displayDateMinute,\n\t\t\tboolean allowPingbacks, boolean allowTrackbacks,\n\t\t\tString[] trackbacks, boolean smallImage, String smallImageURL,\n\t\t\tString smallImageFileName, InputStream smallImageInputStream,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tImageSelector coverImageImageSelector = null;\n\t\tImageSelector smallImageImageSelector = null;\n\n\t\tif (smallImage && Validator.isNotNull(smallImageFileName) &&\n\t\t\t(smallImageInputStream != null)) {\n\n\t\t\ttry {\n\t\t\t\tbyte[] bytes = FileUtil.getBytes(smallImageInputStream);\n\n\t\t\t\tsmallImageImageSelector = new ImageSelector(\n\t\t\t\t\tbytes, smallImageFileName,\n\t\t\t\t\tMimeTypesUtil.getContentType(smallImageFileName), null);\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t_log.error(\"Could not create the imageSelector\", ioe);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (smallImage && Validator.isNotNull(smallImageURL)) {\n\t\t\tsmallImageImageSelector = new ImageSelector(smallImageURL);\n\t\t}\n\n\t\treturn updateEntry(\n\t\t\tuserId, entryId, title, StringPool.BLANK, description, content,\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear, displayDateHour,\n\t\t\tdisplayDateMinute, allowPingbacks, allowTrackbacks, trackbacks,\n\t\t\tStringPool.BLANK, coverImageImageSelector, smallImageImageSelector,\n\t\t\tserviceContext);\n\t}","commit_id":"60b3631d45e25e7e46babc50f4fcd04f8b8a69aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BlogsEntry updateEntry(\n\t\t\tlong userId, long entryId, String title, String subtitle,\n\t\t\tString description, String content, Date displayDate,\n\t\t\tboolean allowPingbacks, boolean allowTrackbacks,\n\t\t\tString[] trackbacks, String coverImageCaption,\n\t\t\tImageSelector coverImageImageSelector,\n\t\t\tImageSelector smallImageImageSelector,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tBlogsEntry entry = blogsEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tvalidate(title, content);\n\n\t\tString oldUrlTitle = entry.getUrlTitle();\n\n\t\tentry.setTitle(title);\n\t\tentry.setSubtitle(subtitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, oldUrlTitle, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\n\t\tif (entry.isPending() || entry.isDraft()) {\n\t\t}\n\t\telse {\n\t\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getGroupPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateEntryResources(entry, serviceContext.getModelPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Images\n\n\t\tlong coverImageFileEntryId = entry.getCoverImageFileEntryId();\n\t\tString coverImageURL = entry.getCoverImageURL();\n\n\t\tlong deletePreviousCoverImageFileEntryId = 0;\n\n\t\tif (coverImageImageSelector != null) {\n\t\t\tcoverImageFileEntryId = coverImageImageSelector.getImageId();\n\t\t\tcoverImageURL = coverImageImageSelector.getImageURL();\n\n\t\t\tif (coverImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tdeletePreviousCoverImageFileEntryId =\n\t\t\t\t\t\tentry.getCoverImageFileEntryId();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (coverImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getCoverImageFileEntryId()) {\n\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tdeletePreviousCoverImageFileEntryId =\n\t\t\t\t\t\tentry.getCoverImageFileEntryId();\n\t\t\t\t}\n\n\t\t\t\tif (coverImageImageSelector.getImageId() != 0) {\n\t\t\t\t\tcoverImageFileEntryId = addCoverImageFileEntry(\n\t\t\t\t\t\tuserId, entry.getGroupId(), entryId,\n\t\t\t\t\t\tcoverImageImageSelector);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean smallImage = entry.isSmallImage();\n\t\tlong smallImageFileEntryId = entry.getSmallImageFileEntryId();\n\t\tString smallImageURL = entry.getSmallImageURL();\n\n\t\tlong deletePreviousSmallImageFileEntryId = 0;\n\n\t\tif (smallImageImageSelector != null) {\n\t\t\tsmallImage = !smallImageImageSelector.isRemoveSmallImage();\n\t\t\tsmallImageFileEntryId = smallImageImageSelector.getImageId();\n\t\t\tsmallImageURL = smallImageImageSelector.getImageURL();\n\n\t\t\tif (smallImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tdeletePreviousSmallImageFileEntryId =\n\t\t\t\t\t\tentry.getSmallImageFileEntryId();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (smallImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getSmallImageFileEntryId()) {\n\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tdeletePreviousSmallImageFileEntryId =\n\t\t\t\t\t\tentry.getSmallImageFileEntryId();\n\t\t\t\t}\n\n\t\t\t\tif (smallImageImageSelector.getImageId() != 0) {\n\t\t\t\t\tsmallImageFileEntryId = addSmallImageFileEntry(\n\t\t\t\t\t\tuserId, entry.getGroupId(), entry.getEntryId(),\n\t\t\t\t\t\tsmallImageImageSelector);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvalidate(smallImageFileEntryId);\n\n\t\tentry.setCoverImageCaption(coverImageCaption);\n\t\tentry.setCoverImageFileEntryId(coverImageFileEntryId);\n\t\tentry.setCoverImageURL(coverImageURL);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageFileEntryId(smallImageFileEntryId);\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Workflow\n\n\t\tboolean pingOldTrackbacks = false;\n\n\t\tif (!oldUrlTitle.equals(entry.getUrlTitle())) {\n\t\t\tpingOldTrackbacks = true;\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"pingOldTrackbacks\", String.valueOf(pingOldTrackbacks));\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tentry = startWorkflowInstance(userId, entry, serviceContext);\n\n\t\tif (deletePreviousCoverImageFileEntryId != 0) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tdeletePreviousCoverImageFileEntryId);\n\t\t}\n\n\t\tif (deletePreviousSmallImageFileEntryId != 0) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tdeletePreviousSmallImageFileEntryId);\n\t\t}\n\n\t\tif ((coverImageImageSelector != null) &&\n\t\t\t(coverImageImageSelector.getImageId() !=\n\t\t\t\tentry.getCoverImageFileEntryId())) {\n\n\t\t\tdeleteTempImageSelectorImage(coverImageImageSelector);\n\t\t}\n\n\t\tif ((smallImageImageSelector != null) &&\n\t\t\t(smallImageImageSelector.getImageId() !=\n\t\t\t\tentry.getCoverImageFileEntryId())) {\n\n\t\t\tdeleteTempImageSelectorImage(smallImageImageSelector);\n\t\t}\n\n\t\treturn entry;\n\t}","id":23239,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BlogsEntry updateEntry(\n\t\t\tlong userId, long entryId, String title, String subtitle,\n\t\t\tString description, String content, Date displayDate,\n\t\t\tboolean allowPingbacks, boolean allowTrackbacks,\n\t\t\tString[] trackbacks, String coverImageCaption,\n\t\t\tImageSelector coverImageImageSelector,\n\t\t\tImageSelector smallImageImageSelector,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tBlogsEntry entry = blogsEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tvalidate(title, content);\n\n\t\tString oldUrlTitle = entry.getUrlTitle();\n\n\t\tentry.setTitle(title);\n\t\tentry.setSubtitle(subtitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, oldUrlTitle, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\n\t\tif (entry.isPending() || entry.isDraft()) {\n\t\t}\n\t\telse {\n\t\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getGroupPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateEntryResources(entry, serviceContext.getModelPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Images\n\n\t\tlong coverImageFileEntryId = entry.getCoverImageFileEntryId();\n\t\tString coverImageURL = entry.getCoverImageURL();\n\n\t\tlong deletePreviousCoverImageFileEntryId = 0;\n\n\t\tif (coverImageImageSelector != null) {\n\t\t\tcoverImageURL = coverImageImageSelector.getImageURL();\n\n\t\t\tif (coverImageImageSelector.getImageBytes() != null) {\n\t\t\t\tcoverImageFileEntryId = addCoverImageFileEntry(\n\t\t\t\t\tuserId, entry.getGroupId(), entryId,\n\t\t\t\t\tcoverImageImageSelector);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcoverImageFileEntryId = 0;\n\t\t\t}\n\n\t\t\tdeletePreviousCoverImageFileEntryId =\n\t\t\t\tentry.getCoverImageFileEntryId();\n\t\t}\n\n\t\tlong smallImageFileEntryId = entry.getSmallImageFileEntryId();\n\t\tString smallImageURL = entry.getSmallImageURL();\n\n\t\tlong deletePreviousSmallImageFileEntryId = 0;\n\n\t\tif (smallImageImageSelector != null) {\n\t\t\tsmallImageURL = smallImageImageSelector.getImageURL();\n\n\t\t\tif (smallImageImageSelector.getImageBytes() != null) {\n\t\t\t\tsmallImageFileEntryId = addSmallImageFileEntry(\n\t\t\t\t\tuserId, entry.getGroupId(), entry.getEntryId(),\n\t\t\t\t\tsmallImageImageSelector);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsmallImageFileEntryId = 0;\n\t\t\t}\n\n\t\t\tdeletePreviousSmallImageFileEntryId =\n\t\t\t\tentry.getSmallImageFileEntryId();\n\t\t}\n\n\t\tvalidate(smallImageFileEntryId);\n\n\t\tentry.setCoverImageCaption(coverImageCaption);\n\t\tentry.setCoverImageFileEntryId(coverImageFileEntryId);\n\t\tentry.setCoverImageURL(coverImageURL);\n\n\t\tif ((smallImageFileEntryId != 0 )||\n\t\t\tValidator.isNotNull(smallImageURL)) {\n\n\t\t\tentry.setSmallImage(true);\n\t\t}\n\n\t\tentry.setSmallImageFileEntryId(smallImageFileEntryId);\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Workflow\n\n\t\tboolean pingOldTrackbacks = false;\n\n\t\tif (!oldUrlTitle.equals(entry.getUrlTitle())) {\n\t\t\tpingOldTrackbacks = true;\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"pingOldTrackbacks\", String.valueOf(pingOldTrackbacks));\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tentry = startWorkflowInstance(userId, entry, serviceContext);\n\n\t\tif (deletePreviousCoverImageFileEntryId != 0) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tdeletePreviousCoverImageFileEntryId);\n\t\t}\n\n\t\tif (deletePreviousSmallImageFileEntryId != 0) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tdeletePreviousSmallImageFileEntryId);\n\t\t}\n\n\t\treturn entry;\n\t}","commit_id":"60b3631d45e25e7e46babc50f4fcd04f8b8a69aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected long addOriginalImageFileEntry(\n\t\t\tlong userId, long groupId, long entryId, FileEntry fileEntry)\n\t\tthrows PortalException {\n\n\t\tif (!fileEntry.isRepositoryCapabilityProvided(\n\t\t\t\tTemporaryFileEntriesCapability.class)) {\n\n\t\t\treturn fileEntry.getFileEntryId();\n\t\t}\n\n\t\tBlogsEntryAttachmentFileEntryHelper\n\t\t\tblogsEntryAttachmentFileEntryHelper =\n\t\t\t\tnew BlogsEntryAttachmentFileEntryHelper();\n\n\t\tFolder folder = addAttachmentsFolder(userId, groupId);\n\n\t\tFileEntry originalFileEntry =\n\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\taddBlogsEntryAttachmentFileEntry(\n\t\t\t\t\tgroupId, userId, entryId, folder.getFolderId(),\n\t\t\t\t\tfileEntry.getTitle(), fileEntry.getMimeType(),\n\t\t\t\t\tfileEntry.getContentStream());\n\n\t\treturn originalFileEntry.getFileEntryId();\n\t}","id":23240,"modified_method":"@Override\n\tpublic long addOriginalImageFileEntry(\n\t\t\tlong userId, long groupId, long entryId,\n\t\t\tImageSelector imageSelector)\n\t\tthrows PortalException {\n\n\t\tbyte[] imageBytes = imageSelector.getImageBytes();\n\n\t\tif (imageBytes != null) {\n\t\t\tBlogsEntryAttachmentFileEntryHelper\n\t\t\t\tblogsEntryAttachmentFileEntryHelper =\n\t\t\t\t\tnew BlogsEntryAttachmentFileEntryHelper();\n\n\t\t\tFolder folder = addAttachmentsFolder(userId, groupId);\n\n\t\t\tFileEntry originalFileEntry =\n\t\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\t\taddBlogsEntryAttachmentFileEntry(\n\t\t\t\t\t\tgroupId, userId, entryId, folder.getFolderId(),\n\t\t\t\t\t\timageSelector.getImageTitle(),\n\t\t\t\t\t\timageSelector.getImageMimeType(),\n\t\t\t\t\t\timageSelector.getImageBytes());\n\n\t\t\treturn originalFileEntry.getFileEntryId();\n\t\t}\n\n\t\treturn 0;\n\t}","commit_id":"60b3631d45e25e7e46babc50f4fcd04f8b8a69aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected long addCoverImageFileEntry(\n\t\t\tlong userId, long groupId, long entryId,\n\t\t\tImageSelector imageSelector)\n\t\tthrows PortalException {\n\n\t\tFileEntry fileEntry = PortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\timageSelector.getImageId());\n\n\t\taddOriginalImageFileEntry(userId, groupId, entryId, fileEntry);\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tbyte[] bytes = imageSelector.getCroppedImageBytes();\n\n\t\t\tif (bytes == null) {\n\t\t\t\tthrow new EntryCoverImageCropException();\n\t\t\t}\n\n\t\t\tfile = FileUtil.createTempFile(bytes);\n\n\t\t\tFolder folder = addCoverImageFolder(userId, groupId);\n\n\t\t\treturn addProcessedImageFileEntry(\n\t\t\t\tuserId, groupId, entryId, folder.getFolderId(), imageSelector,\n\t\t\t\tfile);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new EntryCoverImageCropException();\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\t\t}\n\t}","id":23241,"modified_method":"protected long addCoverImageFileEntry(\n\t\t\tlong userId, long groupId, long entryId,\n\t\t\tImageSelector imageSelector)\n\t\tthrows PortalException {\n\n\t\tbyte[] imageBytes = imageSelector.getImageBytes();\n\n\t\tif (imageBytes == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\ttry {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject(\n\t\t\t\timageSelector.getImageCropRegion());\n\n\t\t\tint height = jsonObject.getInt(\"height\");\n\t\t\tint width = jsonObject.getInt(\"width\");\n\t\t\tint x = jsonObject.getInt(\"x\");\n\t\t\tint y = jsonObject.getInt(\"y\");\n\n\t\t\tif ((x > 0) || (y > 0) || (width > 0) || (height > 0)) {\n\t\t\t\tImageBag imageBag = ImageToolUtil.read(imageBytes);\n\n\t\t\t\tRenderedImage renderedImage = imageBag.getRenderedImage();\n\n\t\t\t\trenderedImage = ImageToolUtil.crop(\n\t\t\t\t\trenderedImage, height, width, x, y);\n\n\t\t\t\timageBytes = ImageToolUtil.getBytes(\n\t\t\t\t\trenderedImage, imageBag.getType());\n\t\t\t}\n\n\t\t\tif (imageBytes == null) {\n\t\t\t\tthrow new EntryCoverImageCropException();\n\t\t\t}\n\n\t\t\tFolder folder = addCoverImageFolder(userId, groupId);\n\n\t\t\treturn addProcessedImageFileEntry(\n\t\t\t\tuserId, groupId, entryId, folder.getFolderId(),\n\t\t\t\timageSelector.getImageTitle(), imageSelector.getImageMimeType(),\n\t\t\t\timageBytes);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new EntryCoverImageCropException();\n\t\t}\n\t}","commit_id":"60b3631d45e25e7e46babc50f4fcd04f8b8a69aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * @deprecated As of 7.0.0, replaced by {@link #addEntry(long, String,\n\t *             String, String, String, int, int, int, int, int, boolean,\n\t *             boolean, String[], String, ImageSelector, ImageSelector,\n\t *             ServiceContext)}\n\t */\n\t@Deprecated\n\t@Override\n\tpublic BlogsEntry addEntry(\n\t\t\tlong userId, String title, String description, String content,\n\t\t\tint displayDateMonth, int displayDateDay, int displayDateYear,\n\t\t\tint displayDateHour, int displayDateMinute, boolean allowPingbacks,\n\t\t\tboolean allowTrackbacks, String[] trackbacks, boolean smallImage,\n\t\t\tString smallImageURL, String smallImageFileName,\n\t\t\tInputStream smallImageInputStream, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tImageSelector coverImageImageSelector = null;\n\t\tImageSelector smallImageImageSelector = null;\n\n\t\tif (smallImage && Validator.isNotNull(smallImageFileName) &&\n\t\t\t(smallImageInputStream != null)) {\n\n\t\t\tFileEntry tempFileEntry = TempFileEntryUtil.addTempFileEntry(\n\t\t\t\tserviceContext.getScopeGroupId(), userId,\n\t\t\t\tBlogsEntry.class.getName(), smallImageFileName,\n\t\t\t\tsmallImageInputStream,\n\t\t\t\tMimeTypesUtil.getContentType(smallImageFileName));\n\n\t\t\tsmallImageImageSelector = new ImageSelector(\n\t\t\t\ttempFileEntry.getFileEntryId(), smallImageURL, null);\n\t\t}\n\n\t\treturn addEntry(\n\t\t\tuserId, title, StringPool.BLANK, description, content,\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear, displayDateHour,\n\t\t\tdisplayDateMinute, allowPingbacks, allowTrackbacks, trackbacks,\n\t\t\tStringPool.BLANK, coverImageImageSelector, smallImageImageSelector,\n\t\t\tserviceContext);\n\t}","id":23242,"modified_method":"/**\n\t * @deprecated As of 7.0.0, replaced by {@link #addEntry(long, String,\n\t *             String, String, String, int, int, int, int, int, boolean,\n\t *             boolean, String[], String, ImageSelector, ImageSelector,\n\t *             ServiceContext)}\n\t */\n\t@Deprecated\n\t@Override\n\tpublic BlogsEntry addEntry(\n\t\t\tlong userId, String title, String description, String content,\n\t\t\tint displayDateMonth, int displayDateDay, int displayDateYear,\n\t\t\tint displayDateHour, int displayDateMinute, boolean allowPingbacks,\n\t\t\tboolean allowTrackbacks, String[] trackbacks, boolean smallImage,\n\t\t\tString smallImageURL, String smallImageFileName,\n\t\t\tInputStream smallImageInputStream, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tImageSelector coverImageImageSelector = null;\n\t\tImageSelector smallImageImageSelector = null;\n\n\t\tif (smallImage && Validator.isNotNull(smallImageFileName) &&\n\t\t\t(smallImageInputStream != null)) {\n\n\t\t\ttry {\n\t\t\t\tbyte[] bytes = FileUtil.getBytes(smallImageInputStream);\n\n\t\t\t\tsmallImageImageSelector = new ImageSelector(\n\t\t\t\t\tbytes, smallImageFileName,\n\t\t\t\t\tMimeTypesUtil.getContentType(smallImageFileName), null);\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t_log.error(\"Could not create the imageSelector\", ioe);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (smallImage && Validator.isNotNull(smallImageURL)) {\n\t\t\tsmallImageImageSelector = new ImageSelector(smallImageURL);\n\t\t}\n\n\t\treturn addEntry(\n\t\t\tuserId, title, StringPool.BLANK, description, content,\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear, displayDateHour,\n\t\t\tdisplayDateMinute, allowPingbacks, allowTrackbacks, trackbacks,\n\t\t\tStringPool.BLANK, coverImageImageSelector, smallImageImageSelector,\n\t\t\tserviceContext);\n\t}","commit_id":"60b3631d45e25e7e46babc50f4fcd04f8b8a69aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BlogsEntry addEntry(\n\t\t\tlong userId, String title, String subtitle, String description,\n\t\t\tString content, Date displayDate, boolean allowPingbacks,\n\t\t\tboolean allowTrackbacks, String[] trackbacks,\n\t\t\tString coverImageCaption, ImageSelector coverImageImageSelector,\n\t\t\tImageSelector smallImageImageSelector,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\n\t\tlong entryId = counterLocalService.increment();\n\n\t\tvalidate(title, content);\n\n\t\tBlogsEntry entry = blogsEntryPersistence.create(entryId);\n\n\t\tentry.setUuid(serviceContext.getUuid());\n\t\tentry.setGroupId(groupId);\n\t\tentry.setCompanyId(user.getCompanyId());\n\t\tentry.setUserId(user.getUserId());\n\t\tentry.setUserName(user.getFullName());\n\t\tentry.setTitle(title);\n\t\tentry.setSubtitle(subtitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, null, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tentry.setStatusByUserId(userId);\n\t\tentry.setStatusDate(serviceContext.getModifiedDate(null));\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif (serviceContext.isAddGroupPermissions() ||\n\t\t\tserviceContext.isAddGuestPermissions()) {\n\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.isAddGroupPermissions(),\n\t\t\t\tserviceContext.isAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddEntryResources(entry, serviceContext.getModelPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Comment\n\n\t\taddDiscussion(entry, userId, groupId);\n\n\t\t// Images\n\n\t\tlong coverImageFileEntryId = 0;\n\t\tString coverImageURL = null;\n\n\t\tif (coverImageImageSelector != null) {\n\t\t\tcoverImageFileEntryId = coverImageImageSelector.getImageId();\n\t\t\tcoverImageURL = coverImageImageSelector.getImageURL();\n\t\t}\n\n\t\tif (coverImageFileEntryId != 0) {\n\t\t\tcoverImageFileEntryId = addCoverImageFileEntry(\n\t\t\t\tuserId, groupId, entryId, coverImageImageSelector);\n\t\t}\n\n\t\tboolean smallImage = false;\n\t\tlong smallImageFileEntryId = 0;\n\t\tString smallImageURL = null;\n\n\t\tif (smallImageImageSelector != null) {\n\t\t\tsmallImage = !smallImageImageSelector.isRemoveSmallImage();\n\t\t\tsmallImageFileEntryId = smallImageImageSelector.getImageId();\n\t\t\tsmallImageURL = smallImageImageSelector.getImageURL();\n\t\t}\n\n\t\tif (smallImageFileEntryId != 0) {\n\t\t\tsmallImageFileEntryId = addSmallImageFileEntry(\n\t\t\t\tuserId, groupId, entryId, smallImageImageSelector);\n\t\t}\n\n\t\tvalidate(smallImageFileEntryId);\n\n\t\tentry.setCoverImageCaption(coverImageCaption);\n\t\tentry.setCoverImageFileEntryId(coverImageFileEntryId);\n\t\tentry.setCoverImageURL(coverImageURL);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageFileEntryId(smallImageFileEntryId);\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Workflow\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tentry = startWorkflowInstance(userId, entry, serviceContext);\n\n\t\tdeleteTempImageSelectorImage(coverImageImageSelector);\n\n\t\tdeleteTempImageSelectorImage(smallImageImageSelector);\n\n\t\treturn entry;\n\t}","id":23243,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BlogsEntry addEntry(\n\t\t\tlong userId, String title, String subtitle, String description,\n\t\t\tString content, Date displayDate, boolean allowPingbacks,\n\t\t\tboolean allowTrackbacks, String[] trackbacks,\n\t\t\tString coverImageCaption, ImageSelector coverImageImageSelector,\n\t\t\tImageSelector smallImageImageSelector,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\n\t\tlong entryId = counterLocalService.increment();\n\n\t\tvalidate(title, content);\n\n\t\tBlogsEntry entry = blogsEntryPersistence.create(entryId);\n\n\t\tentry.setUuid(serviceContext.getUuid());\n\t\tentry.setGroupId(groupId);\n\t\tentry.setCompanyId(user.getCompanyId());\n\t\tentry.setUserId(user.getUserId());\n\t\tentry.setUserName(user.getFullName());\n\t\tentry.setTitle(title);\n\t\tentry.setSubtitle(subtitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, null, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tentry.setStatusByUserId(userId);\n\t\tentry.setStatusDate(serviceContext.getModifiedDate(null));\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif (serviceContext.isAddGroupPermissions() ||\n\t\t\tserviceContext.isAddGuestPermissions()) {\n\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.isAddGroupPermissions(),\n\t\t\t\tserviceContext.isAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddEntryResources(entry, serviceContext.getModelPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Comment\n\n\t\taddDiscussion(entry, userId, groupId);\n\n\t\t// Images\n\n\t\tlong coverImageFileEntryId = entry.getCoverImageFileEntryId();\n\t\tString coverImageURL = entry.getCoverImageURL();\n\n\t\tif (coverImageImageSelector != null) {\n\t\t\tcoverImageURL = coverImageImageSelector.getImageURL();\n\n\t\t\tif (coverImageImageSelector.getImageBytes() != null) {\n\t\t\t\tcoverImageFileEntryId = addCoverImageFileEntry(\n\t\t\t\t\tuserId, groupId, entryId, coverImageImageSelector);\n\t\t\t}\n\t\t}\n\n\t\tlong smallImageFileEntryId = entry.getSmallImageFileEntryId();\n\t\tString smallImageURL = entry.getSmallImageURL();\n\n\t\tif (smallImageImageSelector != null) {\n\t\t\tsmallImageURL = smallImageImageSelector.getImageURL();\n\n\t\t\tif (smallImageImageSelector.getImageBytes() != null) {\n\t\t\t\tsmallImageFileEntryId = addSmallImageFileEntry(\n\t\t\t\t\tuserId, groupId, entryId, smallImageImageSelector);\n\t\t\t}\n\t\t}\n\n\t\tvalidate(smallImageFileEntryId);\n\n\t\tentry.setCoverImageCaption(coverImageCaption);\n\t\tentry.setCoverImageFileEntryId(coverImageFileEntryId);\n\t\tentry.setCoverImageURL(coverImageURL);\n\n\t\tif ((smallImageFileEntryId != 0) ||\n\t\t\tValidator.isNotNull(smallImageURL)) {\n\n\t\t\tentry.setSmallImage(true);\n\t\t}\n\n\t\tentry.setSmallImageFileEntryId(smallImageFileEntryId);\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Workflow\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\treturn startWorkflowInstance(userId, entry, serviceContext);\n\t}","commit_id":"60b3631d45e25e7e46babc50f4fcd04f8b8a69aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected long addProcessedImageFileEntry(\n\t\t\tlong userId, long groupId, long entryId, long folderId,\n\t\t\tImageSelector imageSelector, File file)\n\t\tthrows PortalException {\n\n\t\tString title = imageSelector.getTitle();\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = StringUtil.randomString() + \"_processedImage_\" + entryId;\n\t\t}\n\n\t\tBlogsEntryAttachmentFileEntryHelper\n\t\t\tblogsEntryAttachmentFileEntryHelper =\n\t\t\t\tnew BlogsEntryAttachmentFileEntryHelper();\n\n\t\tFileEntry processedImageFileEntry =\n\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\taddBlogsEntryAttachmentFileEntry(\n\t\t\t\t\tgroupId, userId, entryId, folderId, title,\n\t\t\t\t\timageSelector.getMimeType(), file);\n\n\t\treturn processedImageFileEntry.getFileEntryId();\n\t}","id":23244,"modified_method":"protected long addProcessedImageFileEntry(\n\t\t\tlong userId, long groupId, long entryId, long folderId,\n\t\t\tString title, String mimeType, byte[] bytes)\n\t\tthrows PortalException {\n\n\t\tif (Validator.isNull(title)) {\n\t\t\ttitle = StringUtil.randomString() + \"_processedImage_\" + entryId;\n\t\t}\n\n\t\tBlogsEntryAttachmentFileEntryHelper\n\t\t\tblogsEntryAttachmentFileEntryHelper =\n\t\t\t\tnew BlogsEntryAttachmentFileEntryHelper();\n\n\t\tFileEntry processedImageFileEntry =\n\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\taddBlogsEntryAttachmentFileEntry(\n\t\t\t\t\tgroupId, userId, entryId, folderId, title, mimeType, bytes);\n\n\t\treturn processedImageFileEntry.getFileEntryId();\n\t}","commit_id":"60b3631d45e25e7e46babc50f4fcd04f8b8a69aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean downloadFile(final String fileName, final File fileToDownload, final File fileToUnZip, final boolean unzipToDir,\n\t\t\tIProgress progress, Long dateModified, int parts, List<File> toReIndex, String indexOfAllFiles, \n\t\t\tDownloadFileShowWarning showWarningCallback) throws InterruptedException {\n\t\tFileOutputStream out = null;\n\t\ttry {\n\n\t\t\tout = new FileOutputStream(fileToDownload);\n\t\t\t\n\t\t\ttry {\n\t\t\t\tif(parts == 1){\n\t\t\t\t\tURL url = new URL(\"http://download.osmand.net/download?file=\"+fileName);  //$NON-NLS-1$\n\t\t\t\t\tdownloadFile(fileName, out, url, null, indexOfAllFiles, progress);\n\t\t\t\t} else {\n\t\t\t\t\tfor(int i=1; i<=parts; i++){\n\t\t\t\t\t\tURL url = new URL(\"http://download.osmand.net/download?file=\"+fileName+\"-\"+i);  //$NON-NLS-1$\n\t\t\t\t\t\tdownloadFile(fileName, out, url, \" [\"+i+\"/\"+parts+\"]\", indexOfAllFiles, progress);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tout.close();\n\t\t\t\tout = null;\n\t\t\t}\n\n\t\t\tFile toIndex = fileToDownload;\n\t\t\tif (fileToDownload.getName().endsWith(\".zip\")) { //$NON-NLS-1$\n\t\t\t\tprogress.startTask(ctx.getString(R.string.unzipping_file), -1);\n\t\t\t\tif (!unzipToDir) {\n\t\t\t\t\ttoIndex = fileToUnZip;\n\t\t\t\t} else {\n\t\t\t\t\tfileToUnZip.mkdirs();\n\t\t\t\t}\n\t\t\t\tZipInputStream zipIn = new ZipInputStream(new FileInputStream(fileToDownload));\n\t\t\t\tZipEntry entry = null;\n\t\t\t\tboolean first = true;\n\t\t\t\twhile ((entry = zipIn.getNextEntry()) != null) {\n\t\t\t\t\tFile fs;\n\t\t\t\t\tif (!unzipToDir) {\n\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\tfs = toIndex;\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString name = entry.getName();\n\t\t\t\t\t\t\t// small simplification\n\t\t\t\t\t\t\tint ind = name.lastIndexOf('_');\n\t\t\t\t\t\t\tif (ind > 0) {\n\t\t\t\t\t\t\t\t// cut version\n\t\t\t\t\t\t\t\tint i = name.indexOf('.', ind);\n\t\t\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\t\t\tname = name.substring(0, ind) + name.substring(i, name.length());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfs = new File(fileToUnZip.getParent(), name);\n\t\t\t\t\t\t\ttoIndex = fs;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfs = new File(fileToUnZip, entry.getName());\n\t\t\t\t\t}\n\t\t\t\t\tout = new FileOutputStream(fs);\n\t\t\t\t\tint read;\n\t\t\t\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\t\t\t\twhile ((read = zipIn.read(buffer)) != -1) {\n\t\t\t\t\t\tout.write(buffer, 0, read);\n\t\t\t\t\t}\n\t\t\t\t\tout.close();\n\t\t\t\t}\n\t\t\t\tzipIn.close();\n\t\t\t\tfileToDownload.delete(); // zip is no needed more\n\t\t\t}\n\n\t\t\tArrayList<String> warnings = new ArrayList<String>();\n\t\t\tResourceManager manager = ((OsmandApplication) ctx.getApplicationContext()).getResourceManager();\n\t\t\tif(dateModified != null){\n\t\t\t\ttoIndex.setLastModified(dateModified);\n\t\t\t}\n\t\t\tif (toIndex.getName().endsWith(IndexConstants.POI_INDEX_EXT)) {\n\t\t\t\t// update poi index immediately\n\t\t\t\tmanager.indexingPoi(progress, warnings, toIndex);\n\t\t\t}\n\t\t\tif(dateModified != null){\n\t\t\t\ttoIndex.setLastModified(dateModified);\n\t\t\t\tmanager.updateIndexLastDateModified(toIndex);\n\t\t\t}\n\t\t\ttoReIndex.add(toIndex);\n\t\t\tif (warnings.isEmpty()) {\n\t\t\t\t\n\t\t\t\tshowWarningCallback.showWarning(ctx.getString(R.string.download_index_success));\n\t\t\t} else {\n\t\t\t\tshowWarningCallback.showWarning(warnings.get(0));\n\t\t\t}\n\t\t\treturn true;\n\t\t} catch (IOException e) {\n\t\t\tlog.error(\"Exception ocurred\", e); //$NON-NLS-1$\n\t\t\tshowWarningCallback.showWarning(ctx.getString(R.string.error_io_error));\n\t\t\tif(out != null){\n\t\t\t\ttry {\n\t\t\t\t\tout.close();\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Possibly file is corrupted\n\t\t\tfileToDownload.delete();\n\t\t\treturn false;\n\t\t} catch (InterruptedException e) {\n\t\t\t// Possibly file is corrupted\n\t\t\tfileToDownload.delete();\n\t\t\tthrow e;\n\t\t}\n\t}","id":23245,"modified_method":"protected boolean downloadFile(final String fileName, final File fileToDownload, final File fileToUnZip, final boolean unzipToDir,\n\t\t\tIProgress progress, Long dateModified, int parts, List<File> toReIndex, String indexOfAllFiles, \n\t\t\tDownloadFileShowWarning showWarningCallback) throws InterruptedException {\n\t\tFileOutputStream out = null;\n\t\ttry {\n\n\t\t\tout = new FileOutputStream(fileToDownload);\n\t\t\t\n\t\t\ttry {\n\t\t\t\tif(parts == 1){\n\t\t\t\t\tURL url = new URL(\"http://download.osmand.net/download?file=\"+fileName);  //$NON-NLS-1$\n\t\t\t\t\tdownloadFile(fileName, out, url, null, indexOfAllFiles, progress);\n\t\t\t\t} else {\n\t\t\t\t\tfor(int i=1; i<=parts; i++){\n\t\t\t\t\t\tURL url = new URL(\"http://download.osmand.net/download?file=\"+fileName+\"-\"+i);  //$NON-NLS-1$\n\t\t\t\t\t\tdownloadFile(fileName, out, url, \" [\"+i+\"/\"+parts+\"]\", indexOfAllFiles, progress);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tout.close();\n\t\t\t\tout = null;\n\t\t\t}\n\n\t\t\tFile toIndex = fileToDownload;\n\t\t\tif (fileToDownload.getName().endsWith(\".zip\")) { //$NON-NLS-1$\n\t\t\t\tif (!unzipToDir) {\n\t\t\t\t\ttoIndex = fileToUnZip;\n\t\t\t\t} else {\n\t\t\t\t\tfileToUnZip.mkdirs();\n\t\t\t\t}\n\t\t\t\tZipInputStream zipIn = new ZipInputStream(new FileInputStream(fileToDownload));\n\t\t\t\tZipEntry entry = null;\n\t\t\t\tboolean first = true;\n\t\t\t\twhile ((entry = zipIn.getNextEntry()) != null) {\n\t\t\t\t\tint size = (int)entry.getSize();\n\t\t\t\t\tprogress.startTask(ctx.getString(R.string.unzipping_file), size);\n\t\t\t\t\tFile fs;\n\t\t\t\t\tif (!unzipToDir) {\n\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\tfs = toIndex;\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString name = entry.getName();\n\t\t\t\t\t\t\t// small simplification\n\t\t\t\t\t\t\tint ind = name.lastIndexOf('_');\n\t\t\t\t\t\t\tif (ind > 0) {\n\t\t\t\t\t\t\t\t// cut version\n\t\t\t\t\t\t\t\tint i = name.indexOf('.', ind);\n\t\t\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\t\t\tname = name.substring(0, ind) + name.substring(i, name.length());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfs = new File(fileToUnZip.getParent(), name);\n\t\t\t\t\t\t\ttoIndex = fs;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfs = new File(fileToUnZip, entry.getName());\n\t\t\t\t\t}\n\t\t\t\t\tout = new FileOutputStream(fs);\n\t\t\t\t\tint read;\n\t\t\t\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\t\t\t\tint prg = 0;\n\t\t\t\t\twhile ((read = zipIn.read(buffer)) != -1) {\n\t\t\t\t\t\tout.write(buffer, 0, read);\n\t\t\t\t\t\tif (size > -1) {\n\t\t\t\t\t\t\tprg += read;\n\t\t\t\t\t\t\tif (prg > size/100) {\n\t\t\t\t\t\t\t\tprogress.progress(prg);\n\t\t\t\t\t\t\t\tprg = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (prg > 0) {\n\t\t\t\t\t\tprogress.progress(prg);\n\t\t\t\t\t}\n\t\t\t\t\tout.close();\n\t\t\t\t}\n\t\t\t\tzipIn.close();\n\t\t\t\tfileToDownload.delete(); // zip is no needed more\n\t\t\t}\n\n\t\t\tArrayList<String> warnings = new ArrayList<String>();\n\t\t\tResourceManager manager = ((OsmandApplication) ctx.getApplicationContext()).getResourceManager();\n\t\t\tif(dateModified != null){\n\t\t\t\ttoIndex.setLastModified(dateModified);\n\t\t\t}\n\t\t\tif (toIndex.getName().endsWith(IndexConstants.POI_INDEX_EXT)) {\n\t\t\t\t// update poi index immediately\n\t\t\t\tmanager.indexingPoi(progress, warnings, toIndex);\n\t\t\t}\n\t\t\tif(dateModified != null){\n\t\t\t\ttoIndex.setLastModified(dateModified);\n\t\t\t\tmanager.updateIndexLastDateModified(toIndex);\n\t\t\t}\n\t\t\ttoReIndex.add(toIndex);\n\t\t\tif (warnings.isEmpty()) {\n\t\t\t\t\n\t\t\t\tshowWarningCallback.showWarning(ctx.getString(R.string.download_index_success));\n\t\t\t} else {\n\t\t\t\tshowWarningCallback.showWarning(warnings.get(0));\n\t\t\t}\n\t\t\treturn true;\n\t\t} catch (IOException e) {\n\t\t\tlog.error(\"Exception ocurred\", e); //$NON-NLS-1$\n\t\t\tshowWarningCallback.showWarning(ctx.getString(R.string.error_io_error));\n\t\t\tif(out != null){\n\t\t\t\ttry {\n\t\t\t\t\tout.close();\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Possibly file is corrupted\n\t\t\tfileToDownload.delete();\n\t\t\treturn false;\n\t\t} catch (InterruptedException e) {\n\t\t\t// Possibly file is corrupted\n\t\t\tfileToDownload.delete();\n\t\t\tthrow e;\n\t\t}\n\t}","commit_id":"e8733b886c2f4afdb2648e7ba46464e4d6e8c222","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected void downloadFile(String fileName, FileOutputStream out, URL url, String part, String indexOfAllFiles, \n\t\t\tIProgress progress) throws IOException, InterruptedException {\n\t\tInputStream is = null;\n\t\t\n\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\tint read = 0;\n\t\tint length = 0;\n\t\tint fileread = 0;\n\t\tint triesDownload = TRIES_TO_DOWNLOAD;\n\t\tboolean first = true;\n\t\ttry {\n\t\t\twhile (triesDownload > 0) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!first) {\n\t\t\t\t\t\tlog.info(\"Reconnecting\"); //$NON-NLS-1$\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(TIMEOUT_BETWEEN_DOWNLOADS);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\t\t\t\t\tconn.setReadTimeout(30000);\n\t\t\t\t\tif (fileread > 0) {\n\t\t\t\t\t\tString range = \"bytes=\"+fileread + \"-\" + (length -1); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\tconn.setRequestProperty(\"Range\", range);  //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t\tconn.setConnectTimeout(30000);\n\t\t\t\t\tlog.info(conn.getResponseMessage() + \" \" + conn.getResponseCode()); //$NON-NLS-1$\n\t\t\t\t\tif (conn.getResponseCode() != HttpURLConnection.HTTP_PARTIAL  && \n\t\t\t\t\t\t\tconn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n\t\t\t\t\t\tconn.disconnect();\n\t\t\t\t\t\ttriesDownload--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tis = conn.getInputStream();\n//\t\t\t\t\tlong skipped = 0;\n//\t\t\t\t\twhile (skipped < fileread) {\n//\t\t\t\t\t\tskipped += is.skip(fileread - skipped);\n//\t\t\t\t\t}\n\t\t\t\t\tif (first) {\n\t\t\t\t\t\tlength = conn.getContentLength();\n\t\t\t\t\t\tString taskName = ctx.getString(R.string.downloading_file) + indexOfAllFiles +\" \" + fileName;\n\t\t\t\t\t\tif(part != null){\n\t\t\t\t\t\t\ttaskName += part;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprogress.startTask(taskName, length); //$NON-NLS-1$\n\t\t\t\t\t}\n\n\t\t\t\t\tfirst = false;\n\t\t\t\t\twhile ((read = is.read(buffer)) != -1) {\n\t\t\t\t\t\t if(interruptDownloading){\n\t\t\t\t\t\t \tthrow new InterruptedException();\n\t\t\t\t\t\t }\n\t\t\t\t\t\tout.write(buffer, 0, read);\n\t\t\t\t\t\tprogress.progress(read);\n\t\t\t\t\t\tfileread += read;\n\t\t\t\t\t}\n\t\t\t\t\tif(length <= fileread){\n\t\t\t\t\t\ttriesDownload = 0;\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tlog.error(\"IOException\", e); //$NON-NLS-1$\n\t\t\t\t\ttriesDownload--;\n\t\t\t\t}\n\n\t\t\t}\n\t\t} finally {\n\t\t\tif (is != null) {\n\t\t\t\tis.close();\n\t\t\t}\n\t\t}\n\t\tif(length != fileread || length == 0){\n\t\t\tthrow new IOException(\"File was not fully read\"); //$NON-NLS-1$\n\t\t}\n\t\t\n\t}","id":23246,"modified_method":"protected void downloadFile(String fileName, FileOutputStream out, URL url, String part, String indexOfAllFiles, \n\t\t\tIProgress progress) throws IOException, InterruptedException {\n\t\tInputStream is = null;\n\t\t\n\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\tint read = 0;\n\t\tint length = 0;\n\t\tint fileread = 0;\n\t\tint triesDownload = TRIES_TO_DOWNLOAD;\n\t\tboolean first = true;\n\t\ttry {\n\t\t\twhile (triesDownload > 0) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!first) {\n\t\t\t\t\t\tlog.info(\"Reconnecting\"); //$NON-NLS-1$\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(TIMEOUT_BETWEEN_DOWNLOADS);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\t\t\t\t\tconn.setReadTimeout(30000);\n\t\t\t\t\tif (fileread > 0) {\n\t\t\t\t\t\tString range = \"bytes=\"+fileread + \"-\" + (length -1); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\tconn.setRequestProperty(\"Range\", range);  //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t\tconn.setConnectTimeout(30000);\n\t\t\t\t\tlog.info(conn.getResponseMessage() + \" \" + conn.getResponseCode()); //$NON-NLS-1$\n\t\t\t\t\tif (conn.getResponseCode() != HttpURLConnection.HTTP_PARTIAL  && \n\t\t\t\t\t\t\tconn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n\t\t\t\t\t\tconn.disconnect();\n\t\t\t\t\t\ttriesDownload--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tis = conn.getInputStream();\n//\t\t\t\t\tlong skipped = 0;\n//\t\t\t\t\twhile (skipped < fileread) {\n//\t\t\t\t\t\tskipped += is.skip(fileread - skipped);\n//\t\t\t\t\t}\n\t\t\t\t\tif (first) {\n\t\t\t\t\t\tlength = conn.getContentLength();\n\t\t\t\t\t\tString taskName = ctx.getString(R.string.downloading_file) + indexOfAllFiles +\" \" + fileName;\n\t\t\t\t\t\tif(part != null){\n\t\t\t\t\t\t\ttaskName += part;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprogress.startTask(taskName, length); //$NON-NLS-1$\n\t\t\t\t\t}\n\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tint prg = 0;\n\t\t\t\t\twhile ((read = is.read(buffer)) != -1) {\n\t\t\t\t\t\t if(interruptDownloading){\n\t\t\t\t\t\t \tthrow new InterruptedException();\n\t\t\t\t\t\t }\n\t\t\t\t\t\tout.write(buffer, 0, read);\n\t\t\t\t\t\tif (length > -1) {\n\t\t\t\t\t\t\tprg += read;\n\t\t\t\t\t\t\tif (prg > length / 100) {\n\t\t\t\t\t\t\t\tprogress.progress(prg);\n\t\t\t\t\t\t\t\tprg = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfileread += read;\n\t\t\t\t\t}\n\t\t\t\t\tif (prg > 0) {\n\t\t\t\t\t\tprogress.progress(prg);\n\t\t\t\t\t}\n\t\t\t\t\tif(length <= fileread){\n\t\t\t\t\t\ttriesDownload = 0;\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tlog.error(\"IOException\", e); //$NON-NLS-1$\n\t\t\t\t\ttriesDownload--;\n\t\t\t\t}\n\n\t\t\t}\n\t\t} finally {\n\t\t\tif (is != null) {\n\t\t\t\tis.close();\n\t\t\t}\n\t\t}\n\t\tif(length != fileread || length == 0){\n\t\t\tthrow new IOException(\"File was not fully read\"); //$NON-NLS-1$\n\t\t}\n\t\t\n\t}","commit_id":"e8733b886c2f4afdb2648e7ba46464e4d6e8c222","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public ProgressDialogImplementation(Context ctx, ProgressDialog dlg, boolean cancelable){\n\t\tthis.cancelable = cancelable;\n\t\tcontext = ctx;\n\t\tsetDialog(dlg);\n\t\t\n\t\tmViewUpdateHandler = new Handler(){\n\t\t\t@Override\n\t\t\tpublic void handleMessage(Message msg) {\n\t\t\t\tsuper.handleMessage(msg);\n\t\t\t\tif(dialog != null){\n\t\t\t\t\tdialog.setMessage(message);\n\t\t\t\t\tif (isIndeterminate()) {\n\t\t\t\t\t\tdialog.setMax(0);\n\t\t\t\t\t\tdialog.setIndeterminate(true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdialog.setIndeterminate(false);\n\t\t\t\t\t\tdialog.setMax(work);\n\t\t\t\t\t}\n\t\t\t\t\tdialog.show();\n\t\t\t\t}\n\t\t\t}\n\t\t};\t\n\t}","id":23247,"modified_method":"public ProgressDialogImplementation(Context ctx, ProgressDialog dlg, boolean cancelable){\n\t\tthis.cancelable = cancelable;\n\t\tcontext = ctx;\n\t\tif (context instanceof Activity) {\n\t\t\tactivity = (Activity)context;\n\t\t} else if (ctx instanceof ContextWrapper && ((ContextWrapper)ctx).getBaseContext() instanceof Activity) {\n\t\t\tactivity = (Activity)((ContextWrapper)ctx).getBaseContext();\n\t\t}\n\t\tsetDialog(dlg);\n\t\t\n\t\tmViewUpdateHandler = new Handler(){\n\t\t\t@Override\n\t\t\tpublic void handleMessage(Message msg) {\n\t\t\t\tsuper.handleMessage(msg);\n\t\t\t\tif(dialog != null){\n\t\t\t\t\tdialog.setMessage(message);\n\t\t\t\t\tif (isIndeterminate()) {\n\t\t\t\t\t\tdialog.setMax(1);\n\t\t\t\t\t\tdialog.setIndeterminate(true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdialog.setIndeterminate(false);\n\t\t\t\t\t\tdialog.setMax(work);\n\t\t\t\t\t}\n\t\t\t\t\tdialog.show();\n\t\t\t\t}\n\t\t\t}\n\t\t};\t\n\t}","commit_id":"e8733b886c2f4afdb2648e7ba46464e4d6e8c222","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void progress(int deltaWork) {\n\t\tthis.progress += deltaWork;\n\t\tif (!isIndeterminate() && dialog != null) {\n\t\t\tdialog.setProgress(this.progress);\n\t\t}\n\t}","id":23248,"modified_method":"@Override\n\tpublic void progress(int deltaWork) {\n\t\tthis.progress += deltaWork;\n\t\tfinal int prg = progress;\n\t\tif (!isIndeterminate() && dialog != null) {\n\t\t\tif (activity != null) {\n\t\t\t\tactivity.runOnUiThread(new Runnable() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tdialog.setProgress(prg);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tdialog.setProgress(prg);\n\t\t\t}\n\t\t}\n\t}","commit_id":"e8733b886c2f4afdb2648e7ba46464e4d6e8c222","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected boolean downloadFile(final String fileName, final File fileToDownload, final File fileToUnZip, final boolean unzipToDir,\n\t\t\tIProgress progress, Long dateModified, int parts, List<File> toReIndex, String indexOfAllFiles, \n\t\t\tDownloadFileShowWarning showWarningCallback, boolean forceWifi ) throws InterruptedException {\n\t\tFileOutputStream out = null;\n\t\ttry {\n\n\t\t\tout = new FileOutputStream(fileToDownload);\n\t\t\ttry {\n\t\t\t\tif(parts == 1){\n\t\t\t\t\tURL url = new URL(\"http://download.osmand.net/download?event=2&file=\"+fileName + \"&\" + Version.getVersionAsURLParam(ctx));  //$NON-NLS-1$\n\t\t\t\t\tdownloadFile(fileName, out, url, null, indexOfAllFiles, progress, forceWifi);\n\t\t\t\t} else {\n\t\t\t\t\tfor(int i=1; i<=parts; i++){\n\t\t\t\t\t\tURL url = new URL(\"http://download.osmand.net/download?event=2&file=\"+fileName+\"-\"+i + \"&\" + Version.getVersionAsURLParam(ctx));  //$NON-NLS-1$\n\t\t\t\t\t\tdownloadFile(fileName, out, url, \" [\"+i+\"/\"+parts+\"]\", indexOfAllFiles, progress, forceWifi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tout.close();\n\t\t\t\tout = null;\n\t\t\t}\n\n\t\t\tif (fileToDownload.getName().endsWith(\".zip\")) { //$NON-NLS-1$\n\t\t\t\tif (unzipToDir) {\n\t\t\t\t\tfileToUnZip.mkdirs();\n\t\t\t\t}\n\t\t\t\tZipInputStream zipIn = new ZipInputStream(new FileInputStream(fileToDownload));\n\t\t\t\tZipEntry entry = null;\n\t\t\t\tboolean first = true;\n\t\t\t\twhile ((entry = zipIn.getNextEntry()) != null) {\n\t\t\t\t\tint size = (int)entry.getSize();\n\t\t\t\t\tprogress.startTask(ctx.getString(R.string.unzipping_file), size);\n\t\t\t\t\tif(entry.isDirectory() || entry.getName().endsWith(IndexConstants.GEN_LOG_EXT)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tFile fs;\n\t\t\t\t\tif (!unzipToDir) {\n\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\tfs = fileToUnZip;\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString name = entry.getName();\n\t\t\t\t\t\t\t// small simplification\n\t\t\t\t\t\t\tint ind = name.lastIndexOf('_');\n\t\t\t\t\t\t\tif (ind > 0) {\n\t\t\t\t\t\t\t\t// cut version\n\t\t\t\t\t\t\t\tint i = name.indexOf('.', ind);\n\t\t\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\t\t\tname = name.substring(0, ind) + name.substring(i, name.length());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfs = new File(fileToUnZip.getParent(), name);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfs = new File(fileToUnZip, entry.getName());\n\t\t\t\t\t}\n\t\t\t\t\tout = new FileOutputStream(fs);\n\t\t\t\t\tint read;\n\t\t\t\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\t\t\t\twhile ((read = zipIn.read(buffer)) != -1) {\n\t\t\t\t\t\tout.write(buffer, 0, read);\n\t\t\t\t\t\tprogress.progress(read);\n\t\t\t\t\t}\n\t\t\t\t\tout.close();\n\t\t\t\t\t\n\t\t\t\t\tif(dateModified != null){\n\t\t\t\t\t\tfs.setLastModified(dateModified);\n\t\t\t\t\t}\n\t\t\t\t\ttoReIndex.add(fs);\n\t\t\t\t}\n\t\t\t\tzipIn.close();\n\t\t\t\tfileToDownload.delete(); // zip is no needed more\n\t\t\t}\n\n\t\t\tshowWarningCallback.showWarning(ctx.getString(R.string.download_index_success));\n\t\t\treturn true;\n\t\t} catch (IOException e) {\n\t\t\tlog.error(\"Exception ocurred\", e); //$NON-NLS-1$\n\t\t\tshowWarningCallback.showWarning(ctx.getString(R.string.error_io_error));\n\t\t\tif(out != null){\n\t\t\t\ttry {\n\t\t\t\t\tout.close();\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Possibly file is corrupted\n\t\t\tfileToDownload.delete();\n\t\t\treturn false;\n\t\t} catch (InterruptedException e) {\n\t\t\t// Possibly file is corrupted\n\t\t\tfileToDownload.delete();\n\t\t\tthrow e;\n\t\t}\n\t}","id":23249,"modified_method":"protected boolean downloadFile(final String fileName, final File fileToDownload, final File fileToUnZip, final boolean unzipToDir,\n\t\t\tIProgress progress, Long dateModified, int parts, List<File> toReIndex, String indexOfAllFiles, \n\t\t\tDownloadFileShowWarning showWarningCallback, boolean forceWifi ) throws InterruptedException {\n\t\tFileOutputStream out = null;\n\t\ttry {\n\n\t\t\tout = new FileOutputStream(fileToDownload);\n\t\t\ttry {\n\t\t\t\tif(parts == 1){\n\t\t\t\t\tURL url = new URL(\"http://download.osmand.net/download?event=2&file=\"+fileName + \"&\" + Version.getVersionAsURLParam(ctx));  //$NON-NLS-1$\n\t\t\t\t\tdownloadFile(fileName, out, url, null, indexOfAllFiles, progress, forceWifi);\n\t\t\t\t} else {\n\t\t\t\t\tfor(int i=1; i<=parts; i++){\n\t\t\t\t\t\tURL url = new URL(\"http://download.osmand.net/download?event=2&file=\"+fileName+\"-\"+i + \"&\" + Version.getVersionAsURLParam(ctx));  //$NON-NLS-1$\n\t\t\t\t\t\tdownloadFile(fileName, out, url, \" [\"+i+\"/\"+parts+\"]\", indexOfAllFiles, progress, forceWifi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tout.close();\n\t\t\t\tout = null;\n\t\t\t}\n\n\t\t\tif (fileToDownload.getName().endsWith(\".zip\")) { //$NON-NLS-1$\n\t\t\t\tif (unzipToDir) {\n\t\t\t\t\tfileToUnZip.mkdirs();\n\t\t\t\t}\n\t\t\t\tFileInputStream fin = new FileInputStream(fileToDownload);\n\t\t\t\tZipInputStream zipIn = new ZipInputStream(fin);\n\t\t\t\tZipEntry entry = null;\n\t\t\t\tboolean first = true;\n\t\t\t\tint len = (int) fileToDownload.length();\n\t\t\t\tprogress.startTask(ctx.getString(R.string.unzipping_file), len);\n\t\t\t\twhile ((entry = zipIn.getNextEntry()) != null) {\n\t\t\t\t\tif(entry.isDirectory() || entry.getName().endsWith(IndexConstants.GEN_LOG_EXT)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tFile fs;\n\t\t\t\t\tif (!unzipToDir) {\n\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\tfs = fileToUnZip;\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString name = entry.getName();\n\t\t\t\t\t\t\t// small simplification\n\t\t\t\t\t\t\tint ind = name.lastIndexOf('_');\n\t\t\t\t\t\t\tif (ind > 0) {\n\t\t\t\t\t\t\t\t// cut version\n\t\t\t\t\t\t\t\tint i = name.indexOf('.', ind);\n\t\t\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\t\t\tname = name.substring(0, ind) + name.substring(i, name.length());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfs = new File(fileToUnZip.getParent(), name);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfs = new File(fileToUnZip, entry.getName());\n\t\t\t\t\t}\n\t\t\t\t\tout = new FileOutputStream(fs);\n\t\t\t\t\tint read;\n\t\t\t\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\t\t\t\twhile ((read = zipIn.read(buffer)) != -1) {\n\t\t\t\t\t\tout.write(buffer, 0, read);\n\t\t\t\t\t\tprogress.remaining(fin.available());\n\t\t\t\t\t}\n\t\t\t\t\tout.close();\n\t\t\t\t\t\n\t\t\t\t\tif(dateModified != null){\n\t\t\t\t\t\tfs.setLastModified(dateModified);\n\t\t\t\t\t}\n\t\t\t\t\ttoReIndex.add(fs);\n\t\t\t\t}\n\t\t\t\tzipIn.close();\n\t\t\t\tfileToDownload.delete(); // zip is no needed more\n\t\t\t}\n\n\t\t\tshowWarningCallback.showWarning(ctx.getString(R.string.download_index_success));\n\t\t\treturn true;\n\t\t} catch (IOException e) {\n\t\t\tlog.error(\"Exception ocurred\", e); //$NON-NLS-1$\n\t\t\tshowWarningCallback.showWarning(ctx.getString(R.string.error_io_error));\n\t\t\tif(out != null){\n\t\t\t\ttry {\n\t\t\t\t\tout.close();\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Possibly file is corrupted\n\t\t\tfileToDownload.delete();\n\t\t\treturn false;\n\t\t} catch (InterruptedException e) {\n\t\t\t// Possibly file is corrupted\n\t\t\tfileToDownload.delete();\n\t\t\tthrow e;\n\t\t}\n\t}","commit_id":"f45bbfe70dec4c0cdbb3133394c512e7e3f67db4","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static void main(String[] args) throws IOException, SAXException, SQLException, InterruptedException {\n\t\tlong time = System.currentTimeMillis();\n\t\tIndexCreator creator = new IndexCreator(new File(\"/home/victor/projects/OsmAnd/data/osm-gen/\")); //$NON-NLS-1$\n\t\tcreator.setIndexMap(true);\n\t\tcreator.setIndexAddress(true);\n\t\tcreator.setIndexPOI(true);\n\t\tcreator.setIndexTransport(true);\n\t\tcreator.setIndexRouting(true);\n\n//\t\tcreator.deleteDatabaseIndexes = false;\n//\t\tcreator.recreateOnlyBinaryFile = true;\n//\t\tcreator.deleteOsmDB = false;\n\t\t\t\t\n\t\tcreator.setZoomWaySmothness(2);\n\t\tMapRenderingTypes rt = MapRenderingTypes.getDefault();\n\t\tMapZooms zooms = MapZooms.getDefault(); // MapZooms.parseZooms(\"15-\");\n//\t\tcreator.setNodesDBFile(new File(\"/home/victor/projects/OsmAnd/data/osm-gen/nodes.tmp.odb\"));\n//\t\tcreator.generateIndexes(new File(\"/home/victor/projects/OsmAnd/temp/map.osm\"),\n\t\tcreator.generateIndexes(new File(\"/home/victor/projects/OsmAnd/data/osm-maps/RU-SPE.osm.bz2\"),\n\t\t\t\tnew ConsoleProgressImplementation(1), null, zooms, rt, log);\n\t\t\n\t\t\n\t\t// BASEMAP generation\n//\t\tzooms = MapZooms.parseZooms(\"1-2;3;4-5;6-7;8-9;10-\");\n//\t\tcreator.setMapFileName(\"basemap_2.obf\");\n//\t\tFile basemapParent = new File(\"/home/victor/projects/OsmAnd/data/basemap/ready/\");\n//\t\tcreator.generateBasemapIndex(new ConsoleProgressImplementation(1), null, zooms, rt, log, \"basemap\", \n//\t\t\t\tnew File(basemapParent, \"10m_coastline_out.osm\"),\n//\t\t\t\tnew File(basemapParent, \"10m_admin_level.osm\"),\n//\t\t\t\tnew File(basemapParent, \"10m_rivers.osm\"),\n//\t\t\t\tnew File(basemapParent, \"10m_lakes.osm\"),\n//\t\t\t\tnew File(basemapParent, \"10m_populated_places.osm\")\n//\t\t);\n\t\t\n\n\t\tlog.info(\"WHOLE GENERATION TIME :  \" + (System.currentTimeMillis() - time)); //$NON-NLS-1$\n\t\tlog.info(\"COORDINATES_SIZE \" + BinaryMapIndexWriter.COORDINATES_SIZE + \" count \" + BinaryMapIndexWriter.COORDINATES_COUNT); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tlog.info(\"TYPES_SIZE \" + BinaryMapIndexWriter.TYPES_SIZE); //$NON-NLS-1$\n\t\tlog.info(\"ID_SIZE \" + BinaryMapIndexWriter.ID_SIZE); //$NON-NLS-1$\n\t\tlog.info(\"- COORD_TYPES_ID SIZE \" + (BinaryMapIndexWriter.COORDINATES_SIZE + BinaryMapIndexWriter.TYPES_SIZE + BinaryMapIndexWriter.ID_SIZE)); //$NON-NLS-1$\n\t\tlog.info(\"- MAP_DATA_SIZE \" + BinaryMapIndexWriter.MAP_DATA_SIZE); //$NON-NLS-1$\n\t\tlog.info(\"- STRING_TABLE_SIZE \" + BinaryMapIndexWriter.STRING_TABLE_SIZE); //$NON-NLS-1$\n\t\tlog.info(\"-- MAP_DATA_AND_STRINGS SIZE \" + (BinaryMapIndexWriter.MAP_DATA_SIZE + BinaryMapIndexWriter.STRING_TABLE_SIZE)); //$NON-NLS-1$\n\n\t}","id":23250,"modified_method":"public static void main(String[] args) throws IOException, SAXException, SQLException, InterruptedException {\n\t\tlong time = System.currentTimeMillis();\n\t\tIndexCreator creator = new IndexCreator(new File(\"/home/victor/projects/OsmAnd/data/osm-gen/\")); //$NON-NLS-1$\n\t\tcreator.setIndexMap(true);\n\t\tcreator.setIndexAddress(true);\n\t\tcreator.setIndexPOI(true);\n\t\tcreator.setIndexTransport(true);\n\t\tcreator.setIndexRouting(true);\n\n//\t\tcreator.deleteDatabaseIndexes = false;\n//\t\tcreator.recreateOnlyBinaryFile = true;\n//\t\tcreator.deleteOsmDB = false;\n\t\t\t\t\n\t\tcreator.setZoomWaySmothness(2);\n\t\tMapRenderingTypes rt = MapRenderingTypes.getDefault();\n\t\tMapZooms zooms = MapZooms.getDefault(); // MapZooms.parseZooms(\"15-\");\n//\t\tcreator.setNodesDBFile(new File(\"/home/victor/projects/OsmAnd/data/osm-gen/nodes.tmp.odb\"));\n\t\tcreator.generateIndexes(new File(\"/home/victor/projects/OsmAnd/temp/map.osm\"),\n\t\t\t\tnew ConsoleProgressImplementation(1), null, zooms, rt, log);\n\t\t\n\t\t\n\t\t// BASEMAP generation\n//\t\tzooms = MapZooms.parseZooms(\"1-2;3;4-5;6-7;8-9;10-\");\n//\t\tcreator.setMapFileName(\"basemap_2.obf\");\n//\t\tFile basemapParent = new File(\"/home/victor/projects/OsmAnd/data/basemap/ready/\");\n//\t\tcreator.generateBasemapIndex(new ConsoleProgressImplementation(1), null, zooms, rt, log, \"basemap\", \n//\t\t\t\tnew File(basemapParent, \"10m_coastline_out.osm\"),\n//\t\t\t\tnew File(basemapParent, \"10m_admin_level.osm\"),\n//\t\t\t\tnew File(basemapParent, \"10m_rivers.osm\"),\n//\t\t\t\tnew File(basemapParent, \"10m_lakes.osm\"),\n//\t\t\t\tnew File(basemapParent, \"10m_populated_places.osm\")\n//\t\t);\n\t\t\n\n\t\tlog.info(\"WHOLE GENERATION TIME :  \" + (System.currentTimeMillis() - time)); //$NON-NLS-1$\n\t\tlog.info(\"COORDINATES_SIZE \" + BinaryMapIndexWriter.COORDINATES_SIZE + \" count \" + BinaryMapIndexWriter.COORDINATES_COUNT); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tlog.info(\"TYPES_SIZE \" + BinaryMapIndexWriter.TYPES_SIZE); //$NON-NLS-1$\n\t\tlog.info(\"ID_SIZE \" + BinaryMapIndexWriter.ID_SIZE); //$NON-NLS-1$\n\t\tlog.info(\"- COORD_TYPES_ID SIZE \" + (BinaryMapIndexWriter.COORDINATES_SIZE + BinaryMapIndexWriter.TYPES_SIZE + BinaryMapIndexWriter.ID_SIZE)); //$NON-NLS-1$\n\t\tlog.info(\"- MAP_DATA_SIZE \" + BinaryMapIndexWriter.MAP_DATA_SIZE); //$NON-NLS-1$\n\t\tlog.info(\"- STRING_TABLE_SIZE \" + BinaryMapIndexWriter.STRING_TABLE_SIZE); //$NON-NLS-1$\n\t\tlog.info(\"-- MAP_DATA_AND_STRINGS SIZE \" + (BinaryMapIndexWriter.MAP_DATA_SIZE + BinaryMapIndexWriter.STRING_TABLE_SIZE)); //$NON-NLS-1$\n\n\t}","commit_id":"f45bbfe70dec4c0cdbb3133394c512e7e3f67db4","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public int iterateOverEntities(IProgress progress, EntityType type, OsmDbVisitor visitor) throws SQLException, InterruptedException {\n\t\tStatement statement = dbConn.createStatement();\n\t\tPreparedStatement select;\n\t\tint count = 0;\n\t\t\n\t\tcomputeRealCounts(statement);\n\t\tstatement.close();\n\t\t\n\t\tBlockingQueue<Entity> toProcess = new ArrayBlockingQueue<Entity>(100000);\n\t\tAbstractProducer entityProducer = null;\n\t\tif (type == EntityType.NODE) {\n\t\t\t// filter out all nodes without tags\n\t\t\tselect = iterateNodes;\n\t\t\tcount = allNodes;\n\t\t} else if (type == EntityType.WAY) {\n\t\t\tselect = iterateWays;\n\t\t\tcount = allWays;\n\t\t} else if (type == EntityType.WAY_BOUNDARY) {\n\t\t\tselect = iterateWayBoundaries;\n\t\t\tcount = allBoundaries;\n\t\t} else {\n\t\t\tselect = iterateRelations;\n\t\t\tcount = allRelations;\n\t\t}\n\t\tentityProducer = new EntityProducer(toProcess, type, select);\n\t\tprogress.startWork(count);\n\t\t\n\t\t//produce\n\t\tentityProducer.start();\n\t\ttry {\n\t\t\t// wait a little before starting taking entities from queue\n\t\t\tThread.sleep(1000);\n\t\t} catch (InterruptedException e) {\n\t\t}\n\t\t\n\t\tEntity entityToProcess = null;\n\t\tEntity endEntity = entityProducer.getEndingEntity();\n\t\twhile ((entityToProcess = toProcess.take())  != endEntity) {\n\t\t\tif (progress != null) {\n\t\t\t\tprogress.progress(1);\n\t\t\t}\n\t\t\tvisitor.iterateEntity(entityToProcess, this);\n\t\t}\n\t\treturn count;\n\t}","id":23251,"modified_method":"public int iterateOverEntities(IProgress progress, EntityType type, OsmDbVisitor visitor) throws SQLException, InterruptedException {\n\t\tStatement statement = dbConn.createStatement();\n\t\tPreparedStatement select;\n\t\tint count = 0;\n\t\t\n\t\tcomputeRealCounts(statement);\n\t\tstatement.close();\n\t\t\n\t\tBlockingQueue<Entity> toProcess = new ArrayBlockingQueue<Entity>(100000);\n\t\tAbstractProducer entityProducer = null;\n\t\tif (type == EntityType.NODE) {\n\t\t\t// filter out all nodes without tags\n\t\t\tselect = iterateNodes;\n\t\t\tcount = allNodes;\n\t\t} else if (type == EntityType.WAY) {\n\t\t\tselect = iterateWays;\n\t\t\tcount = allWays;\n\t\t} else if (type == EntityType.WAY_BOUNDARY) {\n\t\t\tselect = iterateWayBoundaries;\n\t\t\tcount = allBoundaries;\n\t\t} else {\n\t\t\tselect = iterateRelations;\n\t\t\tcount = allRelations;\n\t\t}\n\t\tentityProducer = new EntityProducer(toProcess, type, select);\n\t\tprogress.startWork(count);\n\t\t\n\t\t//produce\n\t\tentityProducer.start();\n\t\ttry {\n\t\t\t// wait a little before starting taking entities from queue\n\t\t\tThread.sleep(150);\n\t\t} catch (InterruptedException e) {\n\t\t}\n\t\t\n\t\tEntity entityToProcess = null;\n\t\tEntity endEntity = entityProducer.getEndingEntity();\n\t\twhile ((entityToProcess = toProcess.take())  != endEntity) {\n\t\t\tif (progress != null) {\n\t\t\t\tprogress.progress(1);\n\t\t\t}\n\t\t\tvisitor.iterateEntity(entityToProcess, this);\n\t\t}\n\t\treturn count;\n\t}","commit_id":"f45bbfe70dec4c0cdbb3133394c512e7e3f67db4","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void createGeneralSection(JPanel root) {\n\t\tJPanel panel = new JPanel();\n\t\tint gridY = 0;\n//\t\tpanel.setLayout(new GridLayout(3, 1, 5, 5));\n\t\tGridBagLayout l = new GridBagLayout();\n\t\tpanel.setLayout(l);\n\t\tpanel.setBorder(BorderFactory.createTitledBorder(Messages.getString(\"OsmExtractionPreferencesDialog.GENERAL\"))); //$NON-NLS-1$\n\t\troot.add(panel);\n\t\t\n\t\tuseInternet = new JCheckBox();\n\t\tuseInternet.setText(Messages.getString(\"OsmExtractionPreferencesDialog.INTERNET.TO.DOWNLOAD.FILES\")); //$NON-NLS-1$\n\t\tuseInternet.setSelected(DataExtractionSettings.getSettings().useInternetToLoadImages());\n\t\tpanel.add(useInternet);\n\t\tGridBagConstraints constr = new GridBagConstraints();\n\t\tconstr.ipadx = 5;\n\t\tconstr.gridx = 0;\n\t\tconstr.gridy = gridY++;\n\t\tconstr.gridwidth = 2;\n\t\tconstr.anchor = GridBagConstraints.WEST;\n\t\tl.setConstraints(useInternet, constr);\n\t\t\n\t\tanimateRouting = new JCheckBox();\n\t\tanimateRouting.setText(\"Animate routing\"); //$NON-NLS-1$\n\t\tanimateRouting.setSelected(DataExtractionSettings.getSettings().isAnimateRouting());\n\t\tpanel.add(animateRouting);\n\t\tconstr = new GridBagConstraints();\n\t\tconstr.ipadx = 5;\n\t\tconstr.gridx = 0;\n\t\tconstr.gridy = gridY++;\n\t\tconstr.gridwidth = 2;\n\t\tconstr.anchor = GridBagConstraints.WEST;\n\t\tl.setConstraints(animateRouting, constr);\n\t\t\n\t\tJLabel label = new JLabel(\"Directory with obf binary files (routing, rendering): \");\n\t\tpanel.add(label);\n\t\tconstr = new GridBagConstraints();\n\t\tconstr.ipadx = 5;\n\t\tconstr.gridx = 0;\n\t\tconstr.gridy = gridY;\n\t\tconstr.anchor = GridBagConstraints.WEST;\n\t\tl.setConstraints(label, constr);\n\t\t\n\t\tnativeFilesDirectory = new JTextField();\n\t\t\n\t\tnativeFilesDirectory.setText(DataExtractionSettings.getSettings().getBinaryFilesDir());\n\t\tpanel.add(nativeFilesDirectory);\n\t\tconstr = new GridBagConstraints();\n\t\tconstr.weightx = 1;\n\t\tconstr.fill = GridBagConstraints.HORIZONTAL;\n\t\tconstr.ipadx = 5;\n\t\tconstr.gridx = 1;\n\t\tconstr.gridy = gridY++;\n\t\tl.setConstraints(nativeFilesDirectory, constr);\n\t\t\n\t\tlabel = new JLabel(\"Routing mode (car/bicycle/pedestrian) : \");\n        panel.add(label);\n        constr = new GridBagConstraints();\n        constr.ipadx = 5;\n        constr.gridx = 0;\n        constr.gridy = gridY;\n        constr.anchor = GridBagConstraints.WEST;\n        l.setConstraints(label, constr);\n        \n        routingMode = new JTextField();\n        \n        routingMode.setText(DataExtractionSettings.getSettings().getRouteMode() +\"\");\n        panel.add(routingMode);\n        constr = new GridBagConstraints();\n        constr.weightx = 1;\n        constr.fill = GridBagConstraints.HORIZONTAL;\n        constr.ipadx = 5;\n        constr.gridx = 1;\n        constr.gridy = gridY++;\n        l.setConstraints(routingMode, constr);\n\t\t\n\t\tlabel = new JLabel(\"Direction to plan route (1/0/-1 forw/both/back) :\");\n        panel.add(label);\n        constr = new GridBagConstraints();\n        constr.ipadx = 5;\n        constr.gridx = 0;\n        constr.gridy = gridY;\n        constr.anchor = GridBagConstraints.WEST;\n        l.setConstraints(label, constr);\n        \n        \n        label = new JLabel(\"Routing config file (path : \");\n        panel.add(label);\n        constr = new GridBagConstraints();\n        constr.ipadx = 5;\n        constr.gridx = 0;\n        constr.gridy = gridY;\n        constr.anchor = GridBagConstraints.WEST;\n        l.setConstraints(label, constr);\n        \n        routingConfigFile = new JTextField();\n        routingConfigFile.setText(DataExtractionSettings.getSettings().getRoutingXmlPath());\n        panel.add(routingConfigFile);\n        constr = new GridBagConstraints();\n        constr.weightx = 1;\n        constr.fill = GridBagConstraints.HORIZONTAL;\n        constr.ipadx = 5;\n        constr.gridx = 1;\n        constr.gridy = gridY++;\n        l.setConstraints(routingConfigFile, constr);\n\t\t\n        \n        label = new JLabel(\"Rendering style file (path) : \");\n        panel.add(label);\n        constr = new GridBagConstraints();\n        constr.ipadx = 5;\n        constr.gridx = 0;\n        constr.gridy = gridY;\n        constr.anchor = GridBagConstraints.WEST;\n        l.setConstraints(label, constr);\n        \n        renderingStyleFile = new JTextField();\n        renderingStyleFile.setText(DataExtractionSettings.getSettings().getRenderXmlPath());\n        panel.add(renderingStyleFile);\n        constr = new GridBagConstraints();\n        constr.weightx = 1;\n        constr.fill = GridBagConstraints.HORIZONTAL;\n        constr.ipadx = 5;\n        constr.gridx = 1;\n        constr.gridy = gridY++;\n        l.setConstraints(renderingStyleFile, constr);\n        \n        label = new JLabel(\"Native lib file (osmand.lib): \");\n        panel.add(label);\n        constr = new GridBagConstraints();\n        constr.ipadx = 5;\n        constr.gridx = 0;\n        constr.gridy = gridY;\n        constr.anchor = GridBagConstraints.WEST;\n        l.setConstraints(label, constr);\n        \n        nativeLibFile = new JTextField();\n        nativeLibFile.setText(DataExtractionSettings.getSettings().getNativeLibFile());\n        panel.add(nativeLibFile);\n        constr = new GridBagConstraints();\n        constr.weightx = 1;\n        constr.fill = GridBagConstraints.HORIZONTAL;\n        constr.ipadx = 5;\n        constr.gridx = 1;\n        constr.gridy = gridY++;\n        l.setConstraints(nativeLibFile, constr);\n\t\t\n\t\tpanel.setMaximumSize(new Dimension(Short.MAX_VALUE, panel.getPreferredSize().height));\n\t\t\n\t}","id":23252,"modified_method":"private void createGeneralSection(JPanel root) {\n\t\tJPanel panel = new JPanel();\n\t\tint gridY = 0;\n//\t\tpanel.setLayout(new GridLayout(3, 1, 5, 5));\n\t\tGridBagLayout l = new GridBagLayout();\n\t\tpanel.setLayout(l);\n\t\tpanel.setBorder(BorderFactory.createTitledBorder(Messages.getString(\"OsmExtractionPreferencesDialog.GENERAL\"))); //$NON-NLS-1$\n\t\troot.add(panel);\n\t\t\n\t\tuseInternet = new JCheckBox();\n\t\tuseInternet.setText(Messages.getString(\"OsmExtractionPreferencesDialog.INTERNET.TO.DOWNLOAD.FILES\")); //$NON-NLS-1$\n\t\tuseInternet.setSelected(DataExtractionSettings.getSettings().useInternetToLoadImages());\n\t\tpanel.add(useInternet);\n\t\tGridBagConstraints constr = new GridBagConstraints();\n\t\tconstr.ipadx = 5;\n\t\tconstr.gridx = 0;\n\t\tconstr.gridy = gridY++;\n\t\tconstr.gridwidth = 2;\n\t\tconstr.anchor = GridBagConstraints.WEST;\n\t\tl.setConstraints(useInternet, constr);\n\t\t\n\t\tanimateRouting = new JCheckBox();\n\t\tanimateRouting.setText(\"Animate routing\"); //$NON-NLS-1$\n\t\tanimateRouting.setSelected(DataExtractionSettings.getSettings().isAnimateRouting());\n\t\tpanel.add(animateRouting);\n\t\tconstr = new GridBagConstraints();\n\t\tconstr.ipadx = 5;\n\t\tconstr.gridx = 0;\n\t\tconstr.gridy = gridY++;\n\t\tconstr.gridwidth = 2;\n\t\tconstr.anchor = GridBagConstraints.WEST;\n\t\tl.setConstraints(animateRouting, constr);\n\t\t\n\t\tJLabel label = new JLabel(\"Directory with obf binary files (routing, rendering): \");\n\t\tpanel.add(label);\n\t\tconstr = new GridBagConstraints();\n\t\tconstr.ipadx = 5;\n\t\tconstr.gridx = 0;\n\t\tconstr.gridy = gridY;\n\t\tconstr.anchor = GridBagConstraints.WEST;\n\t\tl.setConstraints(label, constr);\n\t\t\n\t\tnativeFilesDirectory = new JTextField();\n\t\t\n\t\tnativeFilesDirectory.setText(DataExtractionSettings.getSettings().getBinaryFilesDir());\n\t\tpanel.add(nativeFilesDirectory);\n\t\tconstr = new GridBagConstraints();\n\t\tconstr.weightx = 1;\n\t\tconstr.fill = GridBagConstraints.HORIZONTAL;\n\t\tconstr.ipadx = 5;\n\t\tconstr.gridx = 1;\n\t\tconstr.gridy = gridY++;\n\t\tl.setConstraints(nativeFilesDirectory, constr);\n\t\t\n\t\tlabel = new JLabel(\"Routing mode (car/bicycle/pedestrian) : \");\n        panel.add(label);\n        constr = new GridBagConstraints();\n        constr.ipadx = 5;\n        constr.gridx = 0;\n        constr.gridy = gridY;\n        constr.anchor = GridBagConstraints.WEST;\n        l.setConstraints(label, constr);\n        \n        routingMode = new JTextField();\n        \n        routingMode.setText(DataExtractionSettings.getSettings().getRouteMode() +\"\");\n        panel.add(routingMode);\n        constr = new GridBagConstraints();\n        constr.weightx = 1;\n        constr.fill = GridBagConstraints.HORIZONTAL;\n        constr.ipadx = 5;\n        constr.gridx = 1;\n        constr.gridy = gridY++;\n        l.setConstraints(routingMode, constr);\n\t\t\n        label = new JLabel(\"Routing config file (path : \");\n        panel.add(label);\n        constr = new GridBagConstraints();\n        constr.ipadx = 5;\n        constr.gridx = 0;\n        constr.gridy = gridY;\n        constr.anchor = GridBagConstraints.WEST;\n        l.setConstraints(label, constr);\n        \n        routingConfigFile = new JTextField();\n        routingConfigFile.setText(DataExtractionSettings.getSettings().getRoutingXmlPath());\n        panel.add(routingConfigFile);\n        constr = new GridBagConstraints();\n        constr.weightx = 1;\n        constr.fill = GridBagConstraints.HORIZONTAL;\n        constr.ipadx = 5;\n        constr.gridx = 1;\n        constr.gridy = gridY++;\n        l.setConstraints(routingConfigFile, constr);\n\t\t\n        \n        label = new JLabel(\"Rendering style file (path) : \");\n        panel.add(label);\n        constr = new GridBagConstraints();\n        constr.ipadx = 5;\n        constr.gridx = 0;\n        constr.gridy = gridY;\n        constr.anchor = GridBagConstraints.WEST;\n        l.setConstraints(label, constr);\n        \n        renderingStyleFile = new JTextField();\n        renderingStyleFile.setText(DataExtractionSettings.getSettings().getRenderXmlPath());\n        panel.add(renderingStyleFile);\n        constr = new GridBagConstraints();\n        constr.weightx = 1;\n        constr.fill = GridBagConstraints.HORIZONTAL;\n        constr.ipadx = 5;\n        constr.gridx = 1;\n        constr.gridy = gridY++;\n        l.setConstraints(renderingStyleFile, constr);\n        \n        label = new JLabel(\"Native lib file (osmand.lib): \");\n        panel.add(label);\n        constr = new GridBagConstraints();\n        constr.ipadx = 5;\n        constr.gridx = 0;\n        constr.gridy = gridY;\n        constr.anchor = GridBagConstraints.WEST;\n        l.setConstraints(label, constr);\n        \n        nativeLibFile = new JTextField();\n        nativeLibFile.setText(DataExtractionSettings.getSettings().getNativeLibFile());\n        panel.add(nativeLibFile);\n        constr = new GridBagConstraints();\n        constr.weightx = 1;\n        constr.fill = GridBagConstraints.HORIZONTAL;\n        constr.ipadx = 5;\n        constr.gridx = 1;\n        constr.gridy = gridY++;\n        l.setConstraints(nativeLibFile, constr);\n\t\t\n\t\tpanel.setMaximumSize(new Dimension(Short.MAX_VALUE, panel.getPreferredSize().height));\n\t\t\n\t}","commit_id":"f45bbfe70dec4c0cdbb3133394c512e7e3f67db4","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Test\n    public void taskReturnsValue() throws Exception {\n        // Given an expected return value\n        final String expectedRetVal = \"EXPECTED\";\n\n        // Start an asynchronous process\n        AsyncTaskHandle<String> handle =\n                taskExecutor.startTask(new SimpleAsyncTask<String>(\"taskReturnsValue\") {\n                    @Override\n                    public String call() throws Exception {\n                        return expectedRetVal;\n                    }\n                });\n\n        // Wait for it to finish and get the result\n        String comp = handle.get();\n\n        // Must be the same as the component that was inserted outside of the\n        // task\n        assertThat(comp, equalTo(expectedRetVal));\n    }","id":23253,"modified_method":"@Test\n    public void taskReturnsValue() throws Exception {\n        // Given an expected return value\n        final String expectedRetVal = \"EXPECTED\";\n\n        // Start an asynchronous process\n        AsyncTaskHandle<String> handle =\n                taskExecutor.startTask(new SimpleAsyncTask<String>(\"taskReturnsValue\") {\n                    @Override\n                    public String call() throws Exception {\n                        return expectedRetVal;\n                    }\n                }, onComplete);\n\n        // Wait for it to finish and get the result\n        String comp = handle.get();\n\n        // Must be the same as the component that was inserted outside of the\n        // task\n        assertThat(comp, equalTo(expectedRetVal));\n    }","commit_id":"0495ae121fec6aaa6799a1a3197a5039cbe4ee45","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(expected = ExecutionException.class)\n    public void executionError() throws Exception {\n        // Start an asynchronous process that throws an exception\n        AsyncTaskHandle<String> handle =\n                taskExecutor.startTask(new SimpleAsyncTask<String>(\"executionError\") {\n                    @Override\n                    public String call() throws Exception {\n                        throw new RuntimeException(\"Expected Exception\");\n                    }\n                });\n\n        // Wait for it to finish and get the result\n        waitUntilTaskIsDone(handle);\n        assertThat(handle.isDone(), is(true));\n        handle.get(); // Should throw an exception\n    }","id":23254,"modified_method":"@Test(expected = ExecutionException.class)\n    public void executionError() throws Exception {\n        // Start an asynchronous process that throws an exception\n        AsyncTaskHandle<String> handle =\n                taskExecutor.startTask(new SimpleAsyncTask<String>(\"executionError\") {\n                    @Override\n                    public String call() throws Exception {\n                        throw new RuntimeException(\"Expected Exception\");\n                    }\n                }, onComplete);\n\n        // Wait for it to finish and get the result\n        waitUntilTaskIsDone(handle);\n        assertThat(handle.isDone(), is(true));\n        handle.get(); // Should throw an exception\n    }","commit_id":"0495ae121fec6aaa6799a1a3197a5039cbe4ee45","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n    public void progressUpdates() throws Exception {\n        final List<Integer> progressUpdates = Lists.newArrayList();\n        // \"Mock\" the task handle so that progress updates are recorded\n        final AsyncTaskHandle<Void> taskHandle = new AsyncTaskHandle<Void>(\"progressUpdates\") {\n            @Override\n            public void setCurrentProgress(int progress) {\n                super.setCurrentProgress(progress);\n                progressUpdates.add(progress);\n            }\n        };\n\n        // Start an asynchronous process that updates its progress\n        AsyncTaskHandle<Void> handle =\n                taskExecutor\n                        .startTask(new AsyncTask<Void, AsyncTaskHandle<Void>>() {\n                            @Override\n                            public AsyncTaskHandle<Void> getHandle() {\n                                return taskHandle;\n                            }\n\n                            @Override\n                            public Void call() throws Exception {\n                                getHandle().setCurrentProgress(25);\n                                getHandle().setCurrentProgress(50);\n                                getHandle().setCurrentProgress(75);\n                                getHandle().setCurrentProgress(100);\n                                return null;\n                            }\n                        });\n\n        // Wait for it to finish and get the result\n        waitUntilTaskIsDone(handle);\n\n        // Progress update calls should match the task's internal updates\n        assertThat(handle.getCurrentProgress(), is(100));\n        assertThat(progressUpdates.size(), is(4));\n        assertThat(progressUpdates, contains(25, 50, 75, 100));\n    }","id":23255,"modified_method":"@Test\n    public void progressUpdates() throws Exception {\n        final List<Integer> progressUpdates = Lists.newArrayList();\n        // \"Mock\" the task handle so that progress updates are recorded\n        final AsyncTaskHandle<Void> taskHandle = new AsyncTaskHandle<Void>(\"progressUpdates\") {\n            @Override\n            public void setCurrentProgress(int progress) {\n                super.setCurrentProgress(progress);\n                progressUpdates.add(progress);\n            }\n        };\n\n        // Start an asynchronous process that updates its progress\n        AsyncTaskHandle<Void> handle =\n                taskExecutor\n                        .startTask(new AsyncTask<Void, AsyncTaskHandle<Void>>() {\n                            @Override\n                            public AsyncTaskHandle<Void> getHandle() {\n                                return taskHandle;\n                            }\n\n                            @Override\n                            public Void call() throws Exception {\n                                getHandle().setCurrentProgress(25);\n                                getHandle().setCurrentProgress(50);\n                                getHandle().setCurrentProgress(75);\n                                getHandle().setCurrentProgress(100);\n                                return null;\n                            }\n                        }, onComplete);\n\n        // Wait for it to finish and get the result\n        waitUntilTaskIsDone(handle);\n\n        // Progress update calls should match the task's internal updates\n        assertThat(handle.getCurrentProgress(), is(100));\n        assertThat(progressUpdates.size(), is(4));\n        assertThat(progressUpdates, contains(25, 50, 75, 100));\n    }","commit_id":"0495ae121fec6aaa6799a1a3197a5039cbe4ee45","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n    public <V, H extends AsyncTaskHandle<V>> void startTask(\n            AsyncTask<V, H> task, Serializable key) {\n        String taskId = startTask(task);\n        handlesByKey.put(key, getHandle(taskId));\n    }","id":23256,"modified_method":"/**\n     * Starts a task, using the specified task key\n     * @param task\n     *            The asynchronous task to run.\n     * @param key\n     * @param <V>\n     * @param <H>\n     */\n    @Override\n    public <V, H extends AsyncTaskHandle<V>> void startTask(\n            AsyncTask<V, H> task, final Serializable key) {\n        TaskExecutor taskExecutor =\n                (TaskExecutor) Component.getInstance(TaskExecutor.class);\n        AsyncTaskHandle<V> handle = taskExecutor.startTask(task,\n                new Runnable() {\n                    @Override\n                    public void run() {\n                        taskFinished(key);\n                    }\n                });\n        AsyncTaskHandle oldHandle = handlesByKey.put(key, handle);\n        if (oldHandle != null) {\n            log.error(\"Key {} has a duplicate: old handle is {}; new handle is {}\",\n                    key, oldHandle, handle);\n        }\n    }","commit_id":"0495ae121fec6aaa6799a1a3197a5039cbe4ee45","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n    public <V, H extends AsyncTaskHandle<V>> String startTask(\n            AsyncTask<V, H> task) {\n        TaskExecutor taskExecutor =\n                (TaskExecutor) Component.getInstance(TaskExecutor.class);\n        AsyncTaskHandle<V> handle = taskExecutor.startTask(task);\n        Long taskKey;\n        taskKey = generateNextAvailableKey();\n        handlesById.put(taskKey, handle);\n        return taskKey.toString();\n    }","id":23257,"modified_method":"/**\n     * Starts a task, using a generated task key\n     * @param task\n     *            The asynchronous task to run.\n     * @param <V>\n     * @param <H>\n     * @return\n     */\n    @Override\n    public <V, H extends AsyncTaskHandle<V>> String startTask(\n            AsyncTask<V, H> task) {\n        Long taskKey = generateNextAvailableKey();\n        startTask(task, taskKey);\n        return taskKey.toString();\n    }","commit_id":"0495ae121fec6aaa6799a1a3197a5039cbe4ee45","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n    public AsyncTaskHandle getHandleByKey(Serializable key) {\n        return handlesByKey.get(key);\n    }","id":23258,"modified_method":"/**\n     * Gets the handle for a task which was started with a specified key\n     * @param key\n     *            The task id as provided to\n     *            {@link AsyncTaskManagerService#startTask(org.zanata.async.AsyncTask, java.io.Serializable)}\n     * @return\n     */\n    @Override\n    public AsyncTaskHandle getHandleByKey(Serializable key) {\n        return handlesByKey.get(key);\n    }","commit_id":"0495ae121fec6aaa6799a1a3197a5039cbe4ee45","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n    public AsyncTaskHandle getHandle(String taskId) {\n        try {\n            Long taskKey = Long.parseLong(taskId);\n            AsyncTaskHandle handle = handlesById.getIfPresent(taskKey);\n            return handle;\n        } catch (NumberFormatException e) {\n            return null; // Non-number keys are not allowed in this\n                         // implementation\n        }\n    }","id":23259,"modified_method":"/**\n     * Gets the handle for a generated task key\n     * @param taskId\n     *            The task Id (as returned by\n     *            {@link AsyncTaskManagerService#startTask(org.zanata.async.AsyncTask)}\n     *            )\n     * @return\n     */\n    @Override\n    public AsyncTaskHandle getHandle(String taskId) {\n        try {\n            Long taskKey = Long.parseLong(taskId);\n            return getHandleByKey(taskKey);\n        } catch (NumberFormatException e) {\n            return null; // Non-number keys are not allowed in this\n                         // implementation\n        }\n    }","commit_id":"0495ae121fec6aaa6799a1a3197a5039cbe4ee45","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n    public Collection<AsyncTaskHandle> getAllHandles() {\n        return handlesById.asMap().values();\n    }","id":23260,"modified_method":"@Override\n    public Collection<AsyncTaskHandle> getAllHandles() {\n        Collection<AsyncTaskHandle> handles = Lists.newArrayList();\n        handles.addAll(handlesByKey.values());\n        handles.addAll(finishedTasks.asMap().values());\n        return handles;\n    }","commit_id":"0495ae121fec6aaa6799a1a3197a5039cbe4ee45","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Runs the provided task asynchronously with the given security\n     * constraints.\n     *\n     * @param task Task to run asynchronously.\n     * @param runAsPpal Security Principal to tun the task.\n     * @param runAsSubject Security Subject to run the task.\n     * @param username The username to run the task.\n     */\n    @Asynchronous\n    public <V, H extends AsyncTaskHandle<V>> void runAsynchronously(\n            final AsyncTask<V, H> task, final Principal runAsPpal,\n            final Subject runAsSubject, final String username) {\n        AsyncUtils.outject(task.getHandle(), ScopeType.EVENT);\n\n        RunAsOperation runAsOp = new RunAsOperation() {\n            @Override\n            public void execute() {\n                try {\n                    prepareSecurityContext(username);\n                    V returnValue = task.call();\n                    task.getHandle().set(returnValue);\n                } catch (Exception t) {\n                    task.getHandle().setException(t);\n                    log.error(\n                        \"Exception when executing an asynchronous task.\", t);\n                }\n            }\n\n            @Override\n            public Principal getPrincipal() {\n                return runAsPpal;\n            }\n\n            @Override\n            public Subject getSubject() {\n                return runAsSubject;\n            }\n        };\n\n        runAsOp.run();\n    }","id":23261,"modified_method":"/**\n     * Runs the provided task asynchronously with the given security\n     * constraints.\n     *\n     * @param task Task to run asynchronously.\n     * @param runAsPpal Security Principal to tun the task.\n     * @param runAsSubject Security Subject to run the task.\n     * @param username The username to run the task.\n     */\n    @Asynchronous\n    public <V, H extends AsyncTaskHandle<V>> void runAsynchronously(\n            final AsyncTask<V, H> task, final Runnable onComplete,\n            final Principal runAsPpal,\n            final Subject runAsSubject, final String username) {\n        AsyncUtils.outject(task.getHandle(), ScopeType.EVENT);\n\n        RunAsOperation runAsOp = new RunAsOperation() {\n            @Override\n            public void execute() {\n                try {\n                    prepareSecurityContext(username);\n                    V returnValue = task.call();\n                    task.getHandle().set(returnValue);\n                } catch (Throwable t) {\n                    task.getHandle().setException(t);\n                    log.error(\n                        \"Exception when executing an asynchronous task.\", t);\n                }\n            }\n\n            @Override\n            public Principal getPrincipal() {\n                return runAsPpal;\n            }\n\n            @Override\n            public Subject getSubject() {\n                return runAsSubject;\n            }\n        };\n        task.getHandle().addListener(onComplete,\n                MoreExecutors.sameThreadExecutor());\n        runAsOp.run();\n    }","commit_id":"0495ae121fec6aaa6799a1a3197a5039cbe4ee45","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Executes an asynchronous task in the background.\n     *\n     * @param task\n     *            The task to execute.\n     * @return The task handle to keep track of the executed task.\n     * @throws RuntimeException\n     *             If the provided task value is null.\n     */\n    public <V, H extends AsyncTaskHandle<V>> AsyncTaskHandle<V> startTask(\n            AsyncTask<V, H> task) {\n        H handle = task.getHandle();\n        if (handle == null) {\n            throw new RuntimeException(\n                    \"An Asynchronous task should always return a non-null handle\");\n        }\n\n        Identity identity = Identity.instance();\n        asynchronousTaskExecutor.runAsynchronously(task, identity\n                .getPrincipal(), identity.getSubject(),\n                identity.getCredentials().getUsername());\n        return handle;\n    }","id":23262,"modified_method":"/**\n     * Executes an asynchronous task in the background.\n     *\n     * @param task\n     *            The task to execute.\n     * @param onComplete\n     * @return The task handle to keep track of the executed task.\n     * @throws RuntimeException\n     *             If the provided task value is null.\n     */\n    public <V, H extends AsyncTaskHandle<V>> AsyncTaskHandle<V> startTask(\n            AsyncTask<V, H> task, Runnable onComplete) {\n        H handle = task.getHandle();\n        if (handle == null) {\n            throw new RuntimeException(\n                    \"An Asynchronous task should always return a non-null handle\");\n        }\n\n        Identity identity = Identity.instance();\n        asynchronousTaskExecutor.runAsynchronously(task, onComplete, identity\n                .getPrincipal(), identity.getSubject(),\n                identity.getCredentials().getUsername());\n        return handle;\n    }","commit_id":"0495ae121fec6aaa6799a1a3197a5039cbe4ee45","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n    final Editor editor = (Editor)dataContext.getData(DataConstants.EDITOR);\n    final FileEditor fileEditor = (FileEditor)dataContext.getData(DataConstants.FILE_EDITOR);\n    if (editor == null) return;\n    if (fileEditor == null) return;\n\n\n\n    PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    if (psiFile == null) return;\n\n    PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.popup.file.structure\");\n\n    DialogWrapper dialog;\n    dialog = createDialog(psiFile, fileEditor.getStructureViewModel(), editor, project, (Navigatable)dataContext.getData(DataConstants.NAVIGATABLE));\n    dialog.setTitle(psiFile.getVirtualFile().getPresentableUrl());\n    dialog.show();\n  }","id":23263,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    DataContext dataContext = e.getDataContext();\n    Project project = (Project)dataContext.getData(DataConstants.PROJECT);\n    final Editor editor = (Editor)dataContext.getData(DataConstants.EDITOR);\n    final FileEditor fileEditor = (FileEditor)dataContext.getData(DataConstants.FILE_EDITOR);\n    if (editor == null) return;\n    if (fileEditor == null) return;\n\n\n\n    PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    if (psiFile == null) return;\n\n    PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.popup.file.structure\");\n\n    final StructureViewModel structureViewModel = AntFileStructureList.canShowFor(psiFile) ? null : fileEditor.getStructureViewModel();\n\n    DialogWrapper dialog = createDialog(psiFile, structureViewModel, editor, project, (Navigatable)dataContext.getData(DataConstants.NAVIGATABLE));\n    dialog.setTitle(psiFile.getVirtualFile().getPresentableUrl());\n    dialog.show();\n  }","commit_id":"7d2c890f4033d3622b8e8863282f47ce6d114f1b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BlameDialog(Frame mainFrame) {\n    super(mainFrame, CAPTION);\n    init();\n  }","id":23264,"modified_method":"public BlameDialog(Project project, Frame mainFrame) {\n    super(mainFrame, CAPTION);\n    myProject = project;\n    init();\n  }","commit_id":"b2dd4b20df64dc8684f69e7d1e3d40262eb20eaa","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void init() {\n    setModal(true);\n\n    myAnonymousRadio.addChangeListener(new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        boolean enabled = !myAnonymousRadio.getModel().isSelected();\n        myUsername.setEnabled(enabled);\n        myPassword.setEnabled(enabled);\n        myTestLoginButton.setEnabled(enabled);\n      }\n    });\n\n    myTestLoginButton.setAction(new AbstractAction(\"Test Login\") {\n      public void actionPerformed(ActionEvent e) {\n        Project project = MPSDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext());\n        Poster poster = new Poster(project);\n        Query query = createQuery();\n\n        Response response = poster.test(query);\n        if (response.isSuccess()) {\n          JOptionPane.showMessageDialog(BlameDialog.this, response.getMessage(), \"Info\", JOptionPane.INFORMATION_MESSAGE);\n        } else {\n          JOptionPane.showMessageDialog(BlameDialog.this, response.getMessage(), \"Error\", JOptionPane.ERROR_MESSAGE);\n          LOG.error(\"Submit failed: \" + response.getMessage() + \":\" + response.getResponseString(), response.getThrowable());\n        }\n      }\n    });\n  }","id":23265,"modified_method":"private void init() {\n    setModal(true);\n\n    myAnonymousRadio.addChangeListener(new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        boolean enabled = !myAnonymousRadio.getModel().isSelected();\n        myUsername.setEnabled(enabled);\n        myPassword.setEnabled(enabled);\n        myTestLoginButton.setEnabled(enabled);\n      }\n    });\n\n    myTestLoginButton.setAction(new AbstractAction(\"Test Login\") {\n      public void actionPerformed(ActionEvent e) {\n        Poster poster = new Poster(myProject);\n        Query query = createQuery();\n\n        Response response = poster.test(query);\n        if (response.isSuccess()) {\n          JOptionPane.showMessageDialog(BlameDialog.this, response.getMessage(), \"Info\", JOptionPane.INFORMATION_MESSAGE);\n        } else {\n          JOptionPane.showMessageDialog(BlameDialog.this, response.getMessage(), \"Error\", JOptionPane.ERROR_MESSAGE);\n          LOG.error(\"Submit failed: \" + response.getMessage() + \":\" + response.getResponseString(), response.getThrowable());\n        }\n      }\n    });\n  }","commit_id":"b2dd4b20df64dc8684f69e7d1e3d40262eb20eaa","url":"https://github.com/JetBrains/MPS"},{"original_method":"public BlameDialog(Dialog dialog) {\n    super(dialog, CAPTION);\n    init();\n  }","id":23266,"modified_method":"public BlameDialog(Project project, Dialog dialog) {\n    super(dialog, CAPTION);\n    myProject = project;\n    init();\n  }","commit_id":"b2dd4b20df64dc8684f69e7d1e3d40262eb20eaa","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Button(position = 0, name = \"Send\", mnemonic = 'S')\n  public void onSend() {\n    String title = getBuildString() + myTitleField.getText();\n\n    StringBuilder description = new StringBuilder(1000);\n    if (myTitleField.getText().trim().length() != 0) {\n      description.append(myTitleField.getText());\n      description.append(\"\\n\\n\");\n    }\n\n    description.append(myDescription.getText());\n    if (description.length() != 0) {\n      description.append(\"\\n\\n\");\n    }\n\n    description.append(getAdditionalInfo());\n    description.append(\"\\n\\n\\n\");\n\n    for (Throwable ex : myEx) {\n      description.append(ex2str(ex)).append(\"\\n\\n\");\n    }\n\n    Project project = MPSDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext());\n    Poster poster = new Poster(project);\n    Query query = createQuery();\n    query.setIssue(title);\n    query.setDescription(description.toString());\n    myResult = poster.send(query);\n\n    if (!myResult.isSuccess()) {\n      String message = \"Was unable to post the issue: \\n\" + myResult.getMessage();\n      String response = myResult.getResponseString();\n      if (response != null && !response.equals(\"\")) {\n        message += \"\\n\" + response;\n      }\n      JOptionPane.showMessageDialog(BlameDialog.this, message, \"Error\", JOptionPane.ERROR_MESSAGE);\n      return;\n    }\n\n    openIssueInBrowser();\n\n    myIsCancelled = false;\n    BlameDialogComponent.getInstance().loadState(getState());\n    dispose();\n  }","id":23267,"modified_method":"@Button(position = 0, name = \"Send\", mnemonic = 'S')\n  public void onSend() {\n    String title = getBuildString() + myTitleField.getText();\n\n    StringBuilder description = new StringBuilder(1000);\n    if (myTitleField.getText().trim().length() != 0) {\n      description.append(myTitleField.getText());\n      description.append(\"\\n\\n\");\n    }\n\n    description.append(myDescription.getText());\n    if (description.length() != 0) {\n      description.append(\"\\n\\n\");\n    }\n\n    description.append(getAdditionalInfo());\n    description.append(\"\\n\\n\\n\");\n\n    for (Throwable ex : myEx) {\n      description.append(ex2str(ex)).append(\"\\n\\n\");\n    }\n\n    Poster poster = new Poster(myProject);\n    Query query = createQuery();\n    query.setIssue(title);\n    query.setDescription(description.toString());\n    myResult = poster.send(query);\n\n    if (!myResult.isSuccess()) {\n      String message = \"Was unable to post the issue: \\n\" + myResult.getMessage();\n      String response = myResult.getResponseString();\n      if (response != null && !response.equals(\"\")) {\n        message += \"\\n\" + response;\n      }\n      JOptionPane.showMessageDialog(BlameDialog.this, message, \"Error\", JOptionPane.ERROR_MESSAGE);\n      return;\n    }\n\n    openIssueInBrowser();\n\n    myIsCancelled = false;\n    BlameDialogComponent.getInstance().loadState(getState());\n    dispose();\n  }","commit_id":"b2dd4b20df64dc8684f69e7d1e3d40262eb20eaa","url":"https://github.com/JetBrains/MPS"},{"original_method":"public BlameDialog createDialog(Component component) {\n    component = SwingUtilities.getRoot(component);\n\n    BlameDialog result;\n    if (component instanceof Dialog) {\n      result = new BlameDialog((Dialog) component);\n    } else if (component instanceof Frame) {\n      result = new BlameDialog((Frame) component);\n    } else {\n      throw new IllegalArgumentException(\"Can't show on \" + component);\n    }\n\n    result.loadState(myDialogState);\n    return result;\n  }","id":23268,"modified_method":"public BlameDialog createDialog(Project project, Component component) {\n    component = SwingUtilities.getRoot(component);\n\n    BlameDialog result;\n    if (component instanceof Dialog) {\n      result = new BlameDialog(project, (Dialog) component);\n    } else if (component instanceof Frame) {\n      result = new BlameDialog(project, (Frame) component);\n    } else {\n      throw new IllegalArgumentException(\"Can't show on \" + component);\n    }\n\n    result.loadState(myDialogState);\n    return result;\n  }","commit_id":"b2dd4b20df64dc8684f69e7d1e3d40262eb20eaa","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SubmittedReportInfo submit(IdeaLoggingEvent[] events, final Component parentComponent) {\n    assert ThreadUtils.isEventDispatchThread();\n\n    if (events.length == 0) {\n      return new SubmittedReportInfo(null, null, SubmissionStatus.FAILED);\n    }\n\n    BlameDialog blameDialog = BlameDialogComponent.getInstance().createDialog(parentComponent);\n    blameDialog.addEx(events[0].getThrowable());\n    blameDialog.setIssueTitle(events[0].getMessage());\n\n    blameDialog.showDialog();\n\n    if (blameDialog.isCancelled()) {\n      return new SubmittedReportInfo(null, \"Cancelled issue submit\", SubmissionStatus.FAILED);\n    } else {\n      Response response = blameDialog.getResult();\n      assert response != null : \"Response must not be null\";\n      assert response.isSuccess() : \"Response is not 'cancelled' or 'success'\";\n      return new SubmittedReportInfo(null, \"\", SubmissionStatus.NEW_ISSUE);\n    }\n  }","id":23269,"modified_method":"public SubmittedReportInfo submit(IdeaLoggingEvent[] events, final Component parentComponent) {\n    assert ThreadUtils.isEventDispatchThread();\n\n    if (events.length == 0) {\n      return new SubmittedReportInfo(null, null, SubmissionStatus.FAILED);\n    }\n\n    Project project = MPSDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext());\n    BlameDialog blameDialog = BlameDialogComponent.getInstance().createDialog(project, parentComponent);\n    blameDialog.addEx(events[0].getThrowable());\n    blameDialog.setIssueTitle(events[0].getMessage());\n\n    blameDialog.showDialog();\n\n    if (blameDialog.isCancelled()) {\n      return new SubmittedReportInfo(null, \"Cancelled issue submit\", SubmissionStatus.FAILED);\n    } else {\n      Response response = blameDialog.getResult();\n      assert response != null : \"Response must not be null\";\n      assert response.isSuccess() : \"Response is not 'cancelled' or 'success'\";\n      return new SubmittedReportInfo(null, \"\", SubmissionStatus.NEW_ISSUE);\n    }\n  }","commit_id":"b2dd4b20df64dc8684f69e7d1e3d40262eb20eaa","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void submitToTracker(Object[] msgs) {\n    BlameDialog dialog = BlameDialogComponent.getInstance().createDialog(WindowManager.getInstance().getFrame(getProject()));\n    StringBuilder issueTitle = new StringBuilder();\n    for (Object msg : msgs) {\n      if (!(msg instanceof Message)) continue;\n      Message message = (Message) msg;\n      issueTitle.append(message.getText()).append(' ');\n      dialog.addEx(message.getException());\n    }\n    dialog.setIssueTitle(issueTitle.toString());\n    dialog.showDialog();\n\n    if (!dialog.isCancelled()) {\n      Response response = dialog.getResult();\n      String message = response.getMessage();\n      if (response.isSuccess()) {\n        JOptionPane.showMessageDialog(null, message, \"Submit OK\", JOptionPane.INFORMATION_MESSAGE);\n      } else {\n        JOptionPane.showMessageDialog(null, message, \"Submit Failed\", JOptionPane.ERROR_MESSAGE);\n        LOG.error(\"Submit failed: \" + response.getMessage(), response.getThrowable());\n      }\n    }\n  }","id":23270,"modified_method":"private void submitToTracker(Object[] msgs) {\n    JFrame frame = WindowManager.getInstance().getFrame(getProject());\n    BlameDialog dialog = BlameDialogComponent.getInstance().createDialog(getProject(), frame);\n    StringBuilder issueTitle = new StringBuilder();\n    for (Object msg : msgs) {\n      if (!(msg instanceof Message)) continue;\n      Message message = (Message) msg;\n      issueTitle.append(message.getText()).append(' ');\n      dialog.addEx(message.getException());\n    }\n    dialog.setIssueTitle(issueTitle.toString());\n    dialog.showDialog();\n\n    if (!dialog.isCancelled()) {\n      Response response = dialog.getResult();\n      String message = response.getMessage();\n      if (response.isSuccess()) {\n        JOptionPane.showMessageDialog(null, message, \"Submit OK\", JOptionPane.INFORMATION_MESSAGE);\n      } else {\n        JOptionPane.showMessageDialog(null, message, \"Submit Failed\", JOptionPane.ERROR_MESSAGE);\n        LOG.error(\"Submit failed: \" + response.getMessage(), response.getThrowable());\n      }\n    }\n  }","commit_id":"b2dd4b20df64dc8684f69e7d1e3d40262eb20eaa","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public void setEnabled(boolean value) {\n        super.setEnabled(value);\n        toolbarButton.setEnabled(value);\n    }","id":23271,"modified_method":"/**\n     * Set this action to be enabled/disabled\n     *\n     * @param value whether to enable this action or not\n     */\n    @Override\n    public void setEnabled(boolean value) {\n        super.setEnabled(value);\n        toolbarButton.setEnabled(value);\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public Component getToolbarPresenter() {\n        ImageIcon icon = new ImageIcon(getClass().getResource(\"btn_icon_add_image.png\")); //NON-NLS\n        toolbarButton.setIcon(icon);\n        toolbarButton.setText(this.getName());\n        return toolbarButton;\n    }","id":23272,"modified_method":"/**\n     * Returns the toolbar component of this action\n     *\n     * @return component the toolbar button\n     */\n    @Override\n    public Component getToolbarPresenter() {\n        ImageIcon icon = new ImageIcon(getClass().getResource(\"btn_icon_add_image.png\")); //NON-NLS\n        toolbarButton.setIcon(icon);\n        toolbarButton.setText(this.getName());\n        return toolbarButton;\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public void stateChanged(ChangeEvent e) {\n            /*\n             * actionPerformed fires this event after the add data source wizard\n             * is closed.\n             */\n            try {\n                cleanup();\n            } catch (Exception ex) {\n                logger.log(Level.SEVERE, \"Error cleaning in add data source wizard clean up task\", ex); //NON-NLS\n            } finally {\n                /*\n                 * Clean up tasks should only be done exactly once.\n                 */\n                disable();\n            }\n        }","id":23273,"modified_method":"@Override\n        public void stateChanged(ChangeEvent e) {\n            // fired by AddImageAction.runCleanupTasks() after the wizard closes \n            try {\n                cleanup();\n            } catch (Exception ex) {\n                Logger logger = Logger.getLogger(this.getClass().getName());\n                logger.log(Level.WARNING, \"Error cleaning up from wizard.\", ex); //NON-NLS\n            } finally {\n                disable(); // cleanup tasks should only run once.\n            }\n        }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public String getName() {\n        return NbBundle.getMessage(AddImageAction.class, \"CTL_AddImageButton\");\n    }","id":23274,"modified_method":"/**\n     * Gets the name of this action. This may be presented as an item in a menu.\n     *\n     * @return actionName\n     */\n    @Override\n    public String getName() {\n        return NbBundle.getMessage(AddImageAction.class, \"CTL_AddImageButton\");\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Does nothing, do not use.\n     *\n     * @deprecated Classes in this package may call requestFocusForWizardButton\n     * instead.\n     */\n    @Deprecated\n    public void requestFocusButton(String buttonText) {\n    }","id":23275,"modified_method":"/**\n     * Set the focus to the button of the given name on this wizard dialog.\n     *\n     * Note: the name of the buttons that available are \"Next >\", \"< Back\",\n     * \"Cancel\", and \"Finish\". If you change the name of any of those buttons,\n     * use the latest name instead.\n     *\n     * @param buttonText the text of the button\n     */\n    public void requestFocusButton(String buttonText) {\n        // get all buttons on this wizard panel\n        Object[] wizardButtons = wizardDescriptor.getOptions();\n        for (int i = 0; i < wizardButtons.length; i++) {\n            JButton tempButton = (JButton) wizardButtons[i];\n            if (tempButton.getText().equals(buttonText)) {\n                tempButton.setDefaultCapable(true);\n                tempButton.requestFocus();\n            }\n        }\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * Removes this task from the list of tasks to be done when the wizard\n         * closes.\n         */\n        void disable() {\n            cleanupSupport.removeChangeListener(this);\n        }","id":23276,"modified_method":"/**\n         * Remove task from the enabled list.\n         */\n        public void disable() {\n            cleanupSupport.removeChangeListener(this);\n        }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public void performAction() {\n        actionPerformed(null);\n    }","id":23277,"modified_method":"/**\n     * This method does nothing. Use the \"actionPerformed(ActionEvent e)\"\n     * instead of this method.\n     */\n    @Override\n    public void performAction() {\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public HelpCtx getHelpCtx() {\n        return HelpCtx.DEFAULT_HELP;\n    }","id":23278,"modified_method":"/**\n     * Gets the HelpCtx associated with implementing object\n     *\n     * @return HelpCtx or HelpCtx.DEFAULT_HELP\n     */\n    @Override\n    public HelpCtx getHelpCtx() {\n        return HelpCtx.DEFAULT_HELP;\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Displays the first panel of the add data source wizard.\n     *\n     * @param notUsed An action event, may be null.\n     */\n    @Override\n    public void actionPerformed(ActionEvent notUsed) {\n        /*\n         * If ingest is running, confirm that the user wants to add another data\n         * source at this time, instead of waiting for the current ingest job to\n         * complete.\n         */\n        if (IngestManager.getInstance().isIngestRunning()) {\n            if (JOptionPane.showConfirmDialog(null,\n                    NbBundle.getMessage(this.getClass(), \"AddImageAction.ingestConfig.ongoingIngest.msg\"),\n                    NbBundle.getMessage(this.getClass(), \"AddImageAction.ingestConfig.ongoingIngest.title\"),\n                    JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE) == JOptionPane.NO_OPTION) {\n                return;\n            }\n        }\n\n        /*\n         * Construct and display the wizard.\n         */\n        iterator = new AddImageWizardIterator();\n        wizardDescriptor = new WizardDescriptor(iterator);\n        wizardDescriptor.setTitle(NbBundle.getMessage(this.getClass(), \"AddImageAction.wizard.title\"));\n        Dialog dialog = DialogDisplayer.getDefault().createDialog(wizardDescriptor);\n        dialog.setVisible(true);\n        dialog.toFront();\n\n        /*\n         * Run any registered cleanup tasks by firing a change event. This will\n         * cause the stateChanged method of any implementations of the inner,\n         * abstract CleanupTask class to call their cleanup methods (assuming\n         * they have not done an override of stateChanged), after which the\n         * CleanupTasks are unregistered.\n         *\n         * RC: This is a convoluted and error-prone way to implement clean up.\n         * Fortunately, it is confined to this package.\n         */\n        cleanupSupport.fireChange();\n    }","id":23279,"modified_method":"/**\n     * Pop-up the \"Add Image\" wizard panel.\n     *\n     * @param e\n     */\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        if (IngestManager.getInstance().isIngestRunning()) {\n            final String msg = NbBundle.getMessage(this.getClass(), \"AddImageAction.ingestConfig.ongoingIngest.msg\");\n            if (JOptionPane.showConfirmDialog(null, msg,\n                    NbBundle.getMessage(this.getClass(),\n                            \"AddImageAction.ingestConfig.ongoingIngest.title\"),\n                    JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE) == JOptionPane.NO_OPTION) {\n                return;\n            }\n        }\n\n        iterator = new AddImageWizardIterator(this);\n        wizardDescriptor = new WizardDescriptor(iterator);\n        wizardDescriptor.setTitle(NbBundle.getMessage(this.getClass(), \"AddImageAction.wizard.title\"));\n        wizardDescriptor.putProperty(NAME, e);\n\n        if (dialog != null) {\n            dialog.setVisible(false); // hide the old one\n        }\n        dialog = DialogDisplayer.getDefault().createDialog(wizardDescriptor);\n        dialog.setVisible(true);\n        dialog.toFront();\n\n        // Do any cleanup that needs to happen (potentially: stopping the\n        //add-image process, reverting an image)\n        runCleanupTasks();\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Constructs an action that adds a data source to the current case.\n     */\n    public AddImageAction() {\n        cleanupSupport = new ChangeSupport(this);\n        putValue(Action.NAME, NbBundle.getMessage(AddImageAction.class, \"CTL_AddImage\"));\n        toolbarButton = new JButton();\n        toolbarButton.addActionListener(AddImageAction.this::actionPerformed);\n        setEnabled(false);\n    }","id":23280,"modified_method":"/**\n     * The constructor for AddImageAction class\n     */\n    public AddImageAction() {\n        putValue(Action.NAME, NbBundle.getMessage(AddImageAction.class, \"CTL_AddImage\")); // set the action Name\n\n        // set the action for the toolbar button\n        toolbarButton.addActionListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                AddImageAction.this.actionPerformed(e);\n            }\n        });\n\n        this.setEnabled(false); // disable this action class\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * Adds this task to the list of tasks to be done when the wizard\n         * closes.\n         */\n        void enable() {\n            cleanupSupport.addChangeListener(this);\n        }","id":23281,"modified_method":"/**\n         * Add task to the enabled list to run when the wizard closes.\n         */\n        public void enable() {\n            cleanupSupport.addChangeListener(this);\n        }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc5\n     */\n    @Override\n    public final void addChangeListener(ChangeListener listener) {\n        changeSupport.addChangeListener(listener);\n    }","id":23282,"modified_method":"/**\n     * Adds a listener to changes of the panel's validity.\n     *\n     * @param l the change listener to add\n     */\n    @Override\n    public final void addChangeListener(ChangeListener l) {\n        synchronized (listeners) {\n            listeners.add(l);\n        }\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public void setProgress(final int progress) {\n            // update the progress bar asynchronously\n            EventQueue.invokeLater(() -> {\n                getComponent().getProgressBar().setValue(progress);\n            });\n        }","id":23283,"modified_method":"@Override\n        public void setProgress(final int progress) {\n            // update the progress bar asynchronously\n            EventQueue.invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                    getComponent().getProgressBar().setValue(progress);\n                }\n            });\n        }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Gets the data source progress monitor. Allows the previous panel to hand\n     * off the progress monitor to the data source processor.\n     */\n    DSPProgressMonitorImpl getDSPProgressMonitor() {\n        return dspProgressMonitor;\n    }","id":23284,"modified_method":"public DSPProgressMonitorImpl getDSPProgressMonitorImpl() {\n        return dspProgressMonitorImpl;\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public void setIndeterminate(final boolean indeterminate) {\n            EventQueue.invokeLater(() -> {\n                getComponent().getProgressBar().setIndeterminate(indeterminate);\n            });\n        }","id":23285,"modified_method":"@Override\n        public void setIndeterminate(final boolean indeterminate) {\n            // update the progress bar asynchronously\n            EventQueue.invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                    getComponent().getProgressBar().setIndeterminate(indeterminate);\n                }\n            });\n        }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public void setProgressText(final String text) {\n            // update the progress UI asynchronously\n            EventQueue.invokeLater(() -> {\n                getComponent().setProgressMsgText(text);\n            });\n        }","id":23286,"modified_method":"@Override\n        public void setProgressText(final String text) {\n            // update the progress UI asynchronously\n            EventQueue.invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                    getComponent().setProgressMsgText(text);\n                }\n            });\n        }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Gets the visual component for the panel. In this template, the component\n     * is kept separate. This can be more efficient: if the wizard is created\n     * but never displayed, or not all panels are displayed, it is better to\n     * create only those which really need to be visible.\n     *\n     * @return The UI component of this wizard panel.\n     */\n    @Override\n    public AddImageWizardAddingProgressVisual getComponent() {\n        if (null == component) {\n            component = new AddImageWizardAddingProgressVisual();\n        }\n        return component;\n    }","id":23287,"modified_method":"/**\n     * Get the visual component for the panel. In this template, the component\n     * is kept separate. This can be more efficient: if the wizard is created\n     * but never displayed, or not all panels are displayed, it is better to\n     * create only those which really need to be visible.\n     *\n     * It also separates the view from the control - jm\n     *\n     * @return component the UI component of this wizard panel\n     */\n    @Override\n    public AddImageWizardAddingProgressVisual getComponent() {\n        if (component == null) {\n            component = new AddImageWizardAddingProgressVisual();\n        }\n        return component;\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Makes the progress bar of the visual component of this panel indicate\n     * that the data source processor is not running.\n     */\n    void setStateFinished() {\n        dataSourceAdded = true;\n        getComponent().setStateFinished();\n        fireChangeEvent();\n    }","id":23288,"modified_method":"/**\n     * Updates the UI to display the add image process is over.\n     */\n    void setStateFinished() {\n        imgAdded = true;\n        getComponent().setStateFinished();\n        fireChangeEvent();\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public boolean isFinishPanel() {\n        return true;\n    }","id":23289,"modified_method":"@Override\n    public boolean isFinishPanel() {\n        return true;\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Tests whether the panel is finished and it is safe to proceed to the next\n     * one. If the panel is valid, the \"Next\" button will be enabled.\n     *\n     * @return boolean true if can proceed to the next one, false otherwise\n     */\n    @Override\n    public boolean isValid() {\n        return dataSourceAdded;\n    }","id":23290,"modified_method":"/**\n     * Tests whether the panel is finished and it is safe to proceed to the next\n     * one. If the panel is valid, the \"Next\" button will be enabled.\n     *\n     * @return boolean true if can proceed to the next one, false otherwise\n     */\n    @Override\n    public boolean isValid() {\n        // set the focus to the next button of the wizard dialog if it's enabled\n        if (imgAdded) {\n            Lookup.getDefault().lookup(AddImageAction.class).requestFocusButton(\n                    NbBundle.getMessage(this.getClass(), \"AddImageWizardAddingProgressPanel.isValid.focusNext\"));\n        }\n\n        return imgAdded;\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Provides the wizard panel with the current data--either the default data\n     * or already-modified settings, if the user used the previous and/or next\n     * buttons. This method can be called multiple times on one instance of\n     * WizardDescriptor.Panel.\n     *\n     * @param settings The settings.\n     */\n    @Override\n    public void readSettings(WizardDescriptor settings) {\n        settings.setOptions(new Object[]{WizardDescriptor.PREVIOUS_OPTION, WizardDescriptor.NEXT_OPTION, WizardDescriptor.FINISH_OPTION, WizardDescriptor.CANCEL_OPTION});\n        if (dataSourceAdded) {\n            getComponent().setStateFinished();\n        }\n    }","id":23291,"modified_method":"/**\n     * Load the image locations from the WizardDescriptor settings object, and\n     * the\n     *\n     * @param settings the setting to be read from\n     */\n    @Override\n    public void readSettings(WizardDescriptor settings) {\n        settings.setOptions(new Object[]{WizardDescriptor.PREVIOUS_OPTION, WizardDescriptor.NEXT_OPTION, WizardDescriptor.FINISH_OPTION, WizardDescriptor.CANCEL_OPTION});\n        if (imgAdded) {\n            getComponent().setStateFinished();\n        }\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    protected final void fireChangeEvent() {\n        changeSupport.fireChange();\n    }","id":23292,"modified_method":"/**\n     * This method is auto-generated. It seems that this method is used to\n     * listen to any change in this wizard panel.\n     */\n    protected final void fireChangeEvent() {\n        Iterator<ChangeListener> it;\n        synchronized (listeners) {\n            it = new HashSet<ChangeListener>(listeners).iterator();\n        }\n        ChangeEvent ev = new ChangeEvent(this);\n        while (it.hasNext()) {\n            it.next().stateChanged(ev);\n        }\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public final void removeChangeListener(ChangeListener listener) {\n        changeSupport.removeChangeListener(listener);\n    }","id":23293,"modified_method":"/**\n     * Removes a listener to changes of the panel's validity.\n     *\n     * @param l the change listener to move\n     */\n    @Override\n    public final void removeChangeListener(ChangeListener l) {\n        synchronized (listeners) {\n            listeners.remove(l);\n        }\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Constructs an instance of the first panel of the add data source wizard.\n     */\n    AddImageWizardChooseDataSourcePanel() {\n        changeSupport = new ChangeSupport(this);\n    }","id":23294,"modified_method":"AddImageWizardChooseDataSourcePanel(AddImageWizardAddingProgressPanel proPanel) {\n\n        this.progressPanel = proPanel;\n\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Moves the keyboard focus to the next button of the wizard.\n     */\n    void moveFocusToNext() {\n        if (nextButtonIsEnabled) {\n            CallableSystemAction.get(AddImageAction.class).requestFocusForWizardButton(\n                    NbBundle.getMessage(this.getClass(), \"AddImageWizardChooseDataSourcePanel.moveFocusNext\"));\n        }\n    }","id":23295,"modified_method":"/**\n     * Move the keyboard focus to the next button\n     */\n    void moveFocusToNext() {\n        // set the focus to the next button of the wizard dialog if it's enabled\n        if (isNextEnable) {\n            Lookup.getDefault().lookup(AddImageAction.class).requestFocusButton(\n                    NbBundle.getMessage(this.getClass(), \"AddImageWizardChooseDataSourcePanel.moveFocusNext\"));\n        }\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     *\n     * Tests whether or not the panel is finished. If the panel is valid, the\n     * \"Finish\" button will be enabled.\n     *\n     * @return True or false.\n     */\n    @Override\n    public boolean isValid() {\n        // If it is always OK to press Next or Finish, then:\n        // return true;\n        // If it depends on some condition (form filled out...), then:\n        // return someCondition();\n        // and when this condition changes (last form field filled in...) then:\n        // fireChangeEvent();\n        /*\n         * When it is valid, the visual component calls enableNextButton to set\n         * this flag.\n         */\n        return nextButtonIsEnabled;\n    }","id":23296,"modified_method":"/**\n     * Tests whether the panel is finished and it is safe to proceed to the next\n     * one. If the panel is valid, the \"Next\" button will be enabled.\n     *\n     * @return boolean true if all the fields are correctly filled, false\n     *         otherwise\n     */\n    @Override\n    public boolean isValid() {\n        return isNextEnable;\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public final void removeChangeListener(ChangeListener listener) {\n        changeSupport.removeChangeListener(listener);\n    }","id":23297,"modified_method":"/**\n     * Removes a listener to changes of the panel's validity.\n     *\n     * @param l the change listener to move\n     */\n    @Override\n    public final void removeChangeListener(ChangeListener l) {\n        synchronized (listeners) {\n            listeners.remove(l);\n        }\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public void propertyChange(PropertyChangeEvent evt) {\n        fireChangeEvent();\n    }","id":23298,"modified_method":"/**\n     * The \"listener\" for any property change in this panel. Any property\n     * changes will invoke the \"fireChangeEvent()\" method.\n     *\n     * @param evt the property change event\n     */\n    @Override\n    public void propertyChange(PropertyChangeEvent evt) {\n        fireChangeEvent();\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Provides the wizard panel with the current data--either the default data\n     * or already-modified settings, if the user used the previous and/or next\n     * buttons. This method can be called multiple times on one instance of\n     * WizardDescriptor.Panel.\n     *\n     * @param settings The settings.\n     */\n    @Override\n    public void readSettings(WizardDescriptor settings) {\n    }","id":23299,"modified_method":"/**\n     * Provides the wizard panel with the current data--either the default data\n     * or already-modified settings, if the user used the previous and/or next\n     * buttons. This method can be called multiple times on one instance of\n     * WizardDescriptor.Panel. s\n     *\n     * @param settings the setting to be read from\n     */\n    @Override\n    public void readSettings(WizardDescriptor settings) {\n\n        //reset settings if supports it\n        //getComponent().reset();\n        // Prepopulate the image directory from the properties file\n        try {\n\n            // Load hash database settings, enable or disable the checkbox\n            this.NSRLPath = null;\n            this.knownBadPath = null;\n            //JCheckBox lookupFilesCheckbox = component.getLookupFilesCheckbox();\n            //lookupFilesCheckbox.setSelected(false);\n            //lookupFilesCheckbox.setEnabled(this.NSRLPath != null || this.knownBadPath != null);\n\n            // If there is a process object in the settings, revert it and remove it from the settings\n            AddImageAction.CleanupTask cleanupTask = (AddImageAction.CleanupTask) settings.getProperty(AddImageAction.IMAGECLEANUPTASK_PROP);\n            if (cleanupTask != null) {\n                try {\n                    cleanupTask.cleanup();\n                } catch (Exception ex) {\n                    Logger logger = Logger.getLogger(AddImageWizardChooseDataSourcePanel.class.getName());\n                    logger.log(Level.WARNING, \"Error cleaning up image task\", ex); //NON-NLS\n                } finally {\n                    cleanupTask.disable();\n                }\n            }\n        } catch (Exception e) {\n        }\n\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public final void addChangeListener(ChangeListener listener) {\n        changeSupport.addChangeListener(listener);\n    }","id":23300,"modified_method":"/**\n     * Adds a listener to changes of the panel's validity.\n     *\n     * @param l the change listener to add\n     */\n    @Override\n    public final void addChangeListener(ChangeListener l) {\n        synchronized (listeners) {\n            listeners.add(l);\n        }\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public void storeSettings(WizardDescriptor settings) {\n    }","id":23301,"modified_method":"/**\n     * Provides the wizard panel with the opportunity to update the settings\n     * with its current customized state. Rather than updating its settings with\n     * every change in the GUI, it should collect them, and then only save them\n     * when requested to by this method. This method can be called multiple\n     * times on one instance of WizardDescriptor.Panel.\n     *\n     * @param settings the setting to be stored to\n     */\n    @Override\n    public void storeSettings(WizardDescriptor settings) {\n\n        return;\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    protected final void fireChangeEvent() {\n        changeSupport.fireChange();\n    }","id":23302,"modified_method":"/**\n     * This method is auto-generated. It seems that this method is used to\n     * listen to any change in this wizard panel.\n     */\n    protected final void fireChangeEvent() {\n        Iterator<ChangeListener> it;\n        synchronized (listeners) {\n            it = new HashSet<ChangeListener>(listeners).iterator();\n        }\n        ChangeEvent ev = new ChangeEvent(this);\n        while (it.hasNext()) {\n            it.next().stateChanged(ev);\n        }\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Enables the \"Next\" button and fires a change event to update the UI.\n     *\n     * @param isEnabled True if next button should be enabled, false otherwise.\n     */\n    void enableNextButton(boolean isEnabled) {\n        nextButtonIsEnabled = isEnabled;\n        fireChangeEvent();\n    }","id":23303,"modified_method":"/**\n     * Enable the \"Next\" button and fireChangeEvent to update the GUI\n     *\n     * @param isEnabled true if next button can be enabled, false otherwise\n     */\n    public void enableNextButton(boolean isEnabled) {\n        isNextEnable = isEnabled;\n        fireChangeEvent();\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Gets the visual component for the panel. The component is kept separate.\n     * This can be more efficient: if the wizard is created but never displayed,\n     * or not all panels are displayed, it is better to create only those which\n     * really need to be visible.\n     *\n     * @return The UI component of this wizard panel.\n     */\n    @Override\n    public AddImageWizardChooseDataSourceVisual getComponent() {\n        if (null == component) {\n            WindowManager.getDefault().getMainWindow().setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\n            component = new AddImageWizardChooseDataSourceVisual(this);\n        }\n        component.addPropertyChangeListener(this);\n        return component;\n    }","id":23304,"modified_method":"/**\n     * Get the visual component for the panel. In this template, the component\n     * is kept separate. This can be more efficient: if the wizard is created\n     * but never displayed, or not all panels are displayed, it is better to\n     * create only those which really need to be visible.\n     *\n     * @return component the UI component of this wizard panel\n     */\n    @Override\n    public AddImageWizardChooseDataSourceVisual getComponent() {\n        if (component == null) {\n            WindowManager.getDefault().getMainWindow().setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\n            component = new AddImageWizardChooseDataSourceVisual(this);\n        }\n        component.addPropertyChangeListener(this);\n        return component;\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public final void removeChangeListener(ChangeListener listener) {\n        changeSupport.removeChangeListener(listener);\n    }","id":23305,"modified_method":"/**\n     * Removes a listener to changes of the panel's validity.\n     *\n     * @param l the change listener to move\n     */\n    @Override\n    public final void removeChangeListener(ChangeListener l) {\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Provides the wizard panel with the opportunity to update the settings\n     * with its current customized state. Rather than updating its settings with\n     * every change in the GUI, it should collect them, and then only save them\n     * when requested to by this method. This method can be called multiple\n     * times on one instance of WizardDescriptor.Panel.\n     *\n     * @param settings the setting to be stored to\n     */\n    @Override\n    public void storeSettings(WizardDescriptor settings) {\n        /*\n         * The user has pushed the next button on this panel. Save the ingest\n         * job settings for the add data source wizard context and try to start\n         * the ingest job. It is ok to do this now because the back button is\n         * disabled for this wizard - the user cannot go back to choose a\n         * different data source. However, the job will not be started if either\n         * the data source processor has not finished yet, or it finished but\n         * did not produce any Content objects for the data source.\n         */\n        IngestJobSettings ingestJobSettings = this.ingestJobSettingsPanel.getSettings();\n        ingestJobSettings.save();\n        showIngestModuleConfigurationWarnings(ingestJobSettings);\n        ingestModulesConfigured = true;\n        tryStartIngestJob();\n    }","id":23306,"modified_method":"/**\n     * Provides the wizard panel with the opportunity to update the settings\n     * with its current customized state. Rather than updating its settings with\n     * every change in the GUI, it should collect them, and then only save them\n     * when requested to by this method. This method can be called multiple\n     * times on one instance of WizardDescriptor.Panel.\n     *\n     * @param settings the setting to be stored to\n     */\n    @Override\n    public void storeSettings(WizardDescriptor settings) {\n        IngestJobSettings ingestJobSettings = this.ingestJobSettingsPanel.getSettings();\n        ingestJobSettings.save();\n        showWarnings(ingestJobSettings);\n\n        // Start ingest if it hasn't already been started\n        readyToIngest = true;\n        startIngest();\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void dataSourceProcessorDone(UUID addDataSourceEventId, DataSourceProcessorCallback.DataSourceProcessorResult result, List<String> errList, List<Content> contents) {\n        /*\n         * Disable the clean up task.\n         */\n        cleanupTask.disable();\n\n        /*\n         * Get the user's attention.\n         *\n         * RC: Is this really necessary?\n         */\n        java.awt.Toolkit.getDefaultToolkit().beep();\n        AddImageWizardAddingProgressVisual panel = progressPanel.getComponent();\n        if (panel != null) {\n            Window w = SwingUtilities.getWindowAncestor(panel);\n            if (w != null) {\n                w.toFront();\n            }\n        }\n\n        /*\n         * Notify the progress panel that the data source processor has finished\n         * its work and display the processing results on the progress panel.\n         */\n        progressPanel.setStateFinished();\n        if (result == DataSourceProcessorCallback.DataSourceProcessorResult.NO_ERRORS) {\n            progressPanel.getComponent().setProgressBarTextAndColor(\n                    NbBundle.getMessage(this.getClass(), \"AddImageWizardIngestConfigPanel.dsProcDone.noErrs.text\"), 100, Color.black);\n        } else {\n            progressPanel.getComponent().setProgressBarTextAndColor(\n                    NbBundle.getMessage(this.getClass(), \"AddImageWizardIngestConfigPanel.dsProcDone.errs.text\"), 100, Color.red);\n        }\n        boolean critErr = false;\n        if (result == DataSourceProcessorCallback.DataSourceProcessorResult.CRITICAL_ERRORS) {\n            critErr = true;\n        }\n        for (String err : errList) {\n            progressPanel.displayDataSourceProcessorError(err, critErr);\n        }\n\n        /*\n         * Save the Content objects returned by the data source processor.\n         */\n        newContents.clear();\n        newContents.addAll(contents);\n        new Thread(() -> {\n            if (!newContents.isEmpty()) {\n                Case.getCurrentCase().notifyDataSourceAdded(newContents.get(0), addDataSourceEventId);\n            } else {\n                Case.getCurrentCase().notifyFailedAddingDataSource(addDataSourceEventId);\n            }\n        }).start();\n\n        /*\n         * Try starting the ingest job for this data source. If the data source\n         * processor finished before the user finished configuring the ingest\n         * modules, the job will not be started yet.\n         */\n        tryStartIngestJob();\n    }","id":23307,"modified_method":"private void dataSourceProcessorDone(UUID dataSourceId, DataSourceProcessorCallback.DataSourceProcessorResult result, List<String> errList, List<Content> contents) {\n        // disable the cleanup task\n        cleanupTask.disable();\n\n        // Get attention for the process finish\n        java.awt.Toolkit.getDefaultToolkit().beep(); //BEEP!\n        AddImageWizardAddingProgressVisual panel = progressPanel.getComponent();\n        if (panel != null) {\n            Window w = SwingUtilities.getWindowAncestor(panel);\n            if (w != null) {\n                w.toFront();\n            }\n        }\n        // Tell the panel we're done\n        progressPanel.setStateFinished();\n\n        //check the result and display to user\n        if (result == DataSourceProcessorCallback.DataSourceProcessorResult.NO_ERRORS) {\n            progressPanel.getComponent().setProgressBarTextAndColor(\n                    NbBundle.getMessage(this.getClass(), \"AddImageWizardIngestConfigPanel.dsProcDone.noErrs.text\"), 100, Color.black);\n        } else {\n            progressPanel.getComponent().setProgressBarTextAndColor(\n                    NbBundle.getMessage(this.getClass(), \"AddImageWizardIngestConfigPanel.dsProcDone.errs.text\"), 100, Color.red);\n        }\n\n        //if errors, display them on the progress panel\n        boolean critErr = false;\n        if (result == DataSourceProcessorCallback.DataSourceProcessorResult.CRITICAL_ERRORS) {\n            critErr = true;\n        }\n        for (String err : errList) {\n            //  TBD: there probably should be an error level for each error\n            progressPanel.addErrors(err, critErr);\n        }\n\n        newContents.clear();\n        newContents.addAll(contents);\n\n        //notify the UI of the new content added to the case\n        new Thread(() -> {\n            if (!newContents.isEmpty()) {\n                Case.getCurrentCase().notifyDataSourceAdded(newContents.get(0), dataSourceId);\n            } else {\n                Case.getCurrentCase().notifyFailedAddingDataSource(dataSourceId);\n            }\n        }).start();\n\n        // Start ingest if we can\n        progressPanel.setStateStarted();\n        startIngest();\n\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Constructs an instance of The second panel of the add data source wizard.\n     * The visual component of this panel allows a user to configure the ingest\n     * modules for the ingest job for the data source.\n     *\n     * @param selectDataSourcePanel The second panel of the add data source\n     *                              wizard.\n     * @param progressPanel         The third panel of the data source wizard.\n     */\n    AddImageWizardIngestConfigPanel(AddImageWizardChooseDataSourcePanel selectDataSourcePanel, AddImageWizardAddingProgressPanel progressPanel) {\n        this.selectDataSourcePanel = selectDataSourcePanel;\n        this.progressPanel = progressPanel;\n        changeSupport = new ChangeSupport(this);\n\n        /*\n         * Create a collection to receive the Content objects returned by the\n         * data source processor.\n         */\n        newContents = Collections.synchronizedList(new ArrayList<Content>());\n\n        /*\n         * Get the ingest job settings for the add data source wizard context\n         * and use them to create an ingest module configuration panel.\n         */\n        IngestJobSettings ingestJobSettings = new IngestJobSettings(AddImageWizardIngestConfigPanel.class.getCanonicalName());\n        showIngestModuleConfigurationWarnings(ingestJobSettings);\n        ingestJobSettingsPanel = new IngestJobSettingsPanel(ingestJobSettings);\n\n        /*\n         * This flag is used to stop the data source processing thread from\n         * starting the ingest job before the user has finished configuring the\n         * ingest modules. It is only set in the EDT.\n         */\n        ingestModulesConfigured = false;\n\n        /*\n         * This flag is required because because the storeSettings method is\n         * currently called twice during the course of executing the add data\n         * source wizard, whether invoked from the new case wizard or\n         * independently. This means that the tryStartDataSourceIngestJob method\n         * gets called three times: once when the data source processor\n         * completes, and twice when the two storeSettings calls are made.\n         *\n         * TODO (AUT-1864): Figure out whether storeSettings is always called\n         * twice by NetBeans, or the extra call is due to an Autopsy bug.\n         */\n        ingestJobStarted = false;\n    }","id":23308,"modified_method":"AddImageWizardIngestConfigPanel(AddImageWizardChooseDataSourcePanel dsPanel, AddImageAction action, AddImageWizardAddingProgressPanel proPanel) {\n        this.addImageAction = action;\n        this.progressPanel = proPanel;\n        this.dataSourcePanel = dsPanel;\n\n        IngestJobSettings ingestJobSettings = new IngestJobSettings(AddImageWizardIngestConfigPanel.class.getCanonicalName());\n        showWarnings(ingestJobSettings);\n        this.ingestJobSettingsPanel = new IngestJobSettingsPanel(ingestJobSettings);\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Gets the visual component for the panel. In this template, the component\n     * is kept separate. This can be more efficient: if the wizard is created\n     * but never displayed, or not all panels are displayed, it is better to\n     * create only those which really need to be visible.\n     *\n     * @return The UI component of this wizard panel.\n     */\n    @Override\n    public Component getComponent() {\n        if (null == component) {\n            component = new AddImageWizardIngestConfigVisual(this.ingestJobSettingsPanel);\n        }\n        return component;\n    }","id":23309,"modified_method":"/**\n     * Get the visual component for the panel. In this template, the component\n     * is kept separate. This can be more efficient: if the wizard is created\n     * but never displayed, or not all panels are displayed, it is better to\n     * create only those which really need to be visible.\n     *\n     * @return component the UI component of this wizard panel\n     */\n    @Override\n    public Component getComponent() {\n        if (component == null) {\n            component = new AddImageWizardIngestConfigVisual(this.ingestJobSettingsPanel);\n        }\n        return component;\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Starts an ingest job for the data source, but only if the data source\n     * processor has been run and has produced content, and the ingest modules\n     * are configured.\n     */\n    synchronized private void tryStartIngestJob() {\n        if (!newContents.isEmpty() && ingestModulesConfigured && !ingestJobStarted) {\n            ingestJobStarted = true; // See contructor for comment on this flag.\n            IngestManager.getInstance().queueIngestJob(newContents, ingestJobSettingsPanel.getSettings());\n        }\n    }","id":23310,"modified_method":"/**\n     * Start ingest after verifying we have a new image, we are ready to ingest,\n     * and we haven't already ingested.\n     */\n    private void startIngest() {\n        if (!newContents.isEmpty() && readyToIngest && !ingested) {\n            ingested = true;\n            IngestManager.getInstance().queueIngestJob(newContents, ingestJobSettingsPanel.getSettings());\n            progressPanel.setStateFinished();\n        }\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Provides the wizard panel with the current data--either the default data\n     * or already-modified settings, if the user used the previous and/or next\n     * buttons. This method can be called multiple times on one instance of\n     * WizardDescriptor.Panel.\n     *\n     * @param settings The settings.\n     */\n    @Override\n    public void readSettings(WizardDescriptor settings) {\n        /*\n         * The user has pushed the next button on the previous panel of the add\n         * data source wizard. Start the data source processor so it can run\n         * while the user is doing the ingest module configuration. It is ok to\n         * do this now because the back button is disabled for this wizard - the\n         * user cannot go back to choose a different data source.\n         *\n         * RC: Not sure why the cancel button is disabled.\n         */\n        JButton cancel = new JButton(NbBundle.getMessage(this.getClass(), \"AddImageWizardIngestConfigPanel.CANCEL_BUTTON.text\"));\n        cancel.setEnabled(false);\n        settings.setOptions(new Object[]{WizardDescriptor.PREVIOUS_OPTION, WizardDescriptor.NEXT_OPTION, WizardDescriptor.FINISH_OPTION, cancel});\n        startDataSourceProcessing(settings);\n    }","id":23311,"modified_method":"/**\n     * Provides the wizard panel with the current data--either the default data\n     * or already-modified settings, if the user used the previous and/or next\n     * buttons. This method can be called multiple times on one instance of\n     * WizardDescriptor.Panel.\n     *\n     * @param settings the setting to be read from\n     */\n    @Override\n    public void readSettings(WizardDescriptor settings) {\n        JButton cancel = new JButton(\n                NbBundle.getMessage(this.getClass(), \"AddImageWizardIngestConfigPanel.CANCEL_BUTTON.text\"));\n        cancel.setEnabled(false);\n        settings.setOptions(new Object[]{WizardDescriptor.PREVIOUS_OPTION, WizardDescriptor.NEXT_OPTION, WizardDescriptor.FINISH_OPTION, cancel});\n        cleanupTask = null;\n        readyToIngest = false;\n\n        newContents.clear();\n\n        // Start processing the data source by handing it off to the selected DSP, \n        // so it gets going in the background while the user is still picking the Ingest modules\n        startDataSourceProcessing(settings);\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Displays any warnings returned form operations on the ingest job settings\n     * for the add data source wizard context.\n     *\n     * @param ingestJobSettings The ingest job settings.\n     */\n    private static void showIngestModuleConfigurationWarnings(IngestJobSettings ingestJobSettings) {\n        List<String> warnings = ingestJobSettings.getWarnings();\n        if (warnings.isEmpty() == false) {\n            StringBuilder warningMessage = new StringBuilder();\n            for (String warning : warnings) {\n                warningMessage.append(warning).append(\"\\n\");\n            }\n            JOptionPane.showMessageDialog(null, warningMessage.toString());\n        }\n    }","id":23312,"modified_method":"private static void showWarnings(IngestJobSettings ingestJobSettings) {\n        List<String> warnings = ingestJobSettings.getWarnings();\n        if (warnings.isEmpty() == false) {\n            StringBuilder warningMessage = new StringBuilder();\n            for (String warning : warnings) {\n                warningMessage.append(warning).append(\"\\n\");\n            }\n            JOptionPane.showMessageDialog(null, warningMessage.toString());\n        }\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public final void addChangeListener(ChangeListener listener) {\n        changeSupport.addChangeListener(listener);\n    }","id":23313,"modified_method":"/**\n     * Adds a listener to changes of the panel's validity.\n     *\n     * @param l the change listener to add\n     */\n    @Override\n    public final void addChangeListener(ChangeListener l) {\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Starts the data source processor selected by the user when the previous\n     * panel was displayed.\n     */\n    private void startDataSourceProcessing(WizardDescriptor settings) {\n        /*\n         * Create a unique id to use to synch up the data source events that are\n         * published for the data source being added.\n         */\n        final UUID addDataSourceEventId = UUID.randomUUID();\n\n        /*\n         * Register a clean up task with the action that invokes the add data\n         * source wizard. This action takes responsibility for doing cleanup\n         * after the wizard is closed (see the definition of the AddImageAction\n         * class).\n         */\n        cleanupTask = CallableSystemAction.get(AddImageAction.class).new CleanupTask() {\n            @Override\n            void cleanup() throws Exception {\n                new Thread(() -> {\n                    /*\n                     * Publish a failed adding data source event, using the\n                     * event id associated with the adding data source event.\n                     */\n                    Case.getCurrentCase().notifyFailedAddingDataSource(addDataSourceEventId);\n                }).start();\n                dsProcessor.cancel();\n            }\n        };\n        cleanupTask.enable();\n\n        /*\n         * Publish an adding data source event.\n         */\n        new Thread(() -> {\n            Case.getCurrentCase().notifyAddingDataSource(addDataSourceEventId);\n        }).start();\n\n        /*\n         * Notify the progress panel for this wizard that data source processing\n         * is starting.\n         */\n        progressPanel.setStateStarted();\n\n        /*\n         * Get the data source processor the user selected and start it.\n         */\n        dsProcessor = selectDataSourcePanel.getComponent().getCurrentDSProcessor();\n        DataSourceProcessorCallback callback = new DataSourceProcessorCallback() {\n            @Override\n            public void doneEDT(DataSourceProcessorCallback.DataSourceProcessorResult result, List<String> errList, List<Content> contents) {\n                dataSourceProcessorDone(addDataSourceEventId, result, errList, contents);\n            }\n        };\n        dsProcessor.run(progressPanel.getDSPProgressMonitor(), callback);\n    }","id":23314,"modified_method":"/**\n     * Starts the Data source processing by kicking off the selected\n     * DataSourceProcessor\n     */\n    private void startDataSourceProcessing(WizardDescriptor settings) {\n        final UUID dataSourceId = UUID.randomUUID();\n\n        // Add a cleanup task to interrupt the background process if the\n        // wizard exits while the background process is running.\n        cleanupTask = addImageAction.new CleanupTask() {\n            @Override\n            void cleanup() throws Exception {\n                cancelDataSourceProcessing(dataSourceId);\n            }\n        };\n\n        cleanupTask.enable();\n\n        // get the selected DSProcessor\n        dsProcessor = dataSourcePanel.getComponent().getCurrentDSProcessor();\n\n        new Thread(() -> {\n            Case.getCurrentCase().notifyAddingDataSource(dataSourceId);\n        }).start();\n        DataSourceProcessorCallback cbObj = new DataSourceProcessorCallback() {\n            @Override\n            public void doneEDT(DataSourceProcessorCallback.DataSourceProcessorResult result, List<String> errList, List<Content> contents) {\n                dataSourceProcessorDone(dataSourceId, result, errList, contents);\n            }\n\n        };\n\n        progressPanel.setStateStarted();\n\n        // Kick off the DSProcessor \n        dsProcessor.run(progressPanel.getDSPProgressMonitorImpl(), cbObj);\n\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public void addChangeListener(ChangeListener l) {\n    }","id":23315,"modified_method":"@Override\n    public void addChangeListener(ChangeListener l) {\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public void removeChangeListener(ChangeListener l) {\n    }","id":23316,"modified_method":"@Override\n    public void removeChangeListener(ChangeListener l) {\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Lazily create the panels for the add data source wizard.\n     */\n    private List<WizardDescriptor.Panel<WizardDescriptor>> getPanels() {\n        if (null == panels) {\n            panels = new ArrayList<>();\n\n            /*\n             * Create the wizard panels. The first panel is used to select a\n             * data source. The second panel is used to configure the ingest\n             * modules. The third panel has a progress bar that tracks progress\n             * as the Sleuthkit layer adds the data source to the case database.\n             */\n            AddImageWizardChooseDataSourcePanel dsPanel = new AddImageWizardChooseDataSourcePanel();\n            AddImageWizardAddingProgressPanel progressPanel = new AddImageWizardAddingProgressPanel();\n            AddImageWizardIngestConfigPanel ingestConfigPanel = new AddImageWizardIngestConfigPanel(dsPanel, progressPanel);\n            panels.add(dsPanel);\n            panels.add(ingestConfigPanel);\n            panels.add(progressPanel);\n\n            /*\n             * Set the appearance of the visual components of the panels.\n             */\n            String[] steps = new String[panels.size()];\n            for (int i = 0; i < panels.size(); i++) {\n                Component visualComponent = panels.get(i).getComponent();\n                // Default step name to component name.\n                steps[i] = visualComponent.getName();\n                if (visualComponent instanceof JComponent) {\n                    JComponent jc = (JComponent) visualComponent;\n                    // Set step number.\n                    jc.putClientProperty(\"WizardPanel_contentSelectedIndex\", i);\n                    // Sets step name.\n                    jc.putClientProperty(\"WizardPanel_contentData\", steps);\n                    // Turn on subtitle creation.\n                    jc.putClientProperty(\"WizardPanel_autoWizardStyle\", Boolean.TRUE);\n                    // Show steps on the left side, with image in the background.\n                    jc.putClientProperty(\"WizardPanel_contentDisplayed\", Boolean.TRUE);\n                    // Turn on step numbering.\n                    jc.putClientProperty(\"WizardPanel_contentNumbered\", Boolean.TRUE);\n                }\n            }\n        }\n        return panels;\n    }","id":23317,"modified_method":"/**\n     * Initialize panels representing individual wizard's steps and sets various\n     * properties for them influencing wizard appearance.\n     */\n    private List<WizardDescriptor.Panel<WizardDescriptor>> getPanels() {\n        if (panels == null) {\n            panels = new ArrayList<WizardDescriptor.Panel<WizardDescriptor>>();\n\n            AddImageWizardAddingProgressPanel progressPanel = new AddImageWizardAddingProgressPanel();\n\n            AddImageWizardChooseDataSourcePanel dsPanel = new AddImageWizardChooseDataSourcePanel(progressPanel);\n            AddImageWizardIngestConfigPanel ingestConfigPanel = new AddImageWizardIngestConfigPanel(dsPanel, action, progressPanel);\n\n            panels.add(dsPanel);\n            panels.add(ingestConfigPanel);\n            panels.add(progressPanel);\n\n            String[] steps = new String[panels.size()];\n            for (int i = 0; i < panels.size(); i++) {\n                Component c = panels.get(i).getComponent();\n                // Default step name to component name of panel.\n                steps[i] = c.getName();\n                if (c instanceof JComponent) { // assume Swing components\n                    JComponent jc = (JComponent) c;\n                    // Sets step number of a component\n                    jc.putClientProperty(\"WizardPanel_contentSelectedIndex\", new Integer(i));\n                    // Sets steps names for a panel\n                    jc.putClientProperty(\"WizardPanel_contentData\", steps);\n                    // Turn on subtitle creation on each step\n                    jc.putClientProperty(\"WizardPanel_autoWizardStyle\", Boolean.TRUE);\n                    // Show steps on the left side with the image on the background\n                    jc.putClientProperty(\"WizardPanel_contentDisplayed\", Boolean.TRUE);\n                    // Turn on numbering of all steps\n                    jc.putClientProperty(\"WizardPanel_contentNumbered\", Boolean.TRUE);\n                }\n            }\n        }\n        return panels;\n    }","commit_id":"eda180e34fb0caeb70447d2d3ffed5223fc224ec","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public DialogWrapperPeerImpl(final DialogWrapper wrapper, final boolean canBeParent, final boolean tryToolkitModal) {\n    myWrapper = wrapper;\n    myWindowManager = null;\n    Application application = ApplicationManager.getApplication();\n    if (application != null && application.hasComponent(WindowManager.class)) {\n      myWindowManager = (WindowManagerEx)WindowManager.getInstance();\n    }\n    createDialog(null, canBeParent);\n    if (tryToolkitModal) {\n      UIUtil.setToolkitModal(myDialog);\n    }\n  }","id":23318,"modified_method":"public DialogWrapperPeerImpl(final DialogWrapper wrapper, final boolean canBeParent, final boolean tryToolkitModal) {\n    myWrapper = wrapper;\n    myWindowManager = null;\n    Application application = ApplicationManager.getApplication();\n    if (application != null && application.hasComponent(WindowManager.class)) {\n      myWindowManager = (WindowManagerEx)WindowManager.getInstance();\n    }\n    if (isJdk6()) {\n      createDialog(null, canBeParent);\n      if (tryToolkitModal) {\n        UIUtil.setToolkitModal(myDialog);\n      }\n    }\n    else {\n      createDialog(JOptionPane.getRootFrame(), canBeParent);\n    }\n  }","commit_id":"abfd764955c52a7a5b3a57fcae4d5c8138839f7b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void servicePre(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tHttpSession session = request.getSession();\n\n\t\t// Company\n\n\t\tCompany company = PortalUtil.getCompany(request);\n\n\t\tlong companyId = company.getCompanyId();\n\n\t\t// CDN host\n\n\t\tString cdnHost = null;\n\n\t\tif (request.isSecure()) {\n\t\t\tcdnHost = PortalUtil.getCDNHostHttps();\n\t\t}\n\t\telse {\n\t\t\tcdnHost = PortalUtil.getCDNHostHttp();\n\t\t}\n\n\t\tcdnHost = ParamUtil.getString(request, \"cdn_host\", cdnHost);\n\n\t\t// Portal URL\n\n\t\tString portalURL = PortalUtil.getPortalURL(request);\n\n\t\t// Paths\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\t\tString friendlyURLPrivateGroupPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateGroup();\n\t\tString friendlyURLPrivateUserPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateUser();\n\t\tString friendlyURLPublicPath = PortalUtil.getPathFriendlyURLPublic();\n\t\tString imagePath = cdnHost.concat(PortalUtil.getPathImage());\n\t\tString mainPath = PortalUtil.getPathMain();\n\n\t\tString i18nPath = (String)request.getAttribute(WebKeys.I18N_PATH);\n\n\t\tif (Validator.isNotNull(i18nPath)) {\n\t\t\tif (Validator.isNotNull(contextPath)) {\n\t\t\t\tString i18nContextPath = contextPath.concat(i18nPath);\n\n\t\t\t\tfriendlyURLPrivateGroupPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateGroupPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPrivateUserPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateUserPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPublicPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPublicPath, contextPath, i18nContextPath);\n\t\t\t\tmainPath = StringUtil.replaceFirst(\n\t\t\t\t\tmainPath, contextPath, i18nContextPath);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfriendlyURLPrivateGroupPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateGroupPath);\n\t\t\t\tfriendlyURLPrivateUserPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateUserPath);\n\t\t\t\tfriendlyURLPublicPath = i18nPath.concat(friendlyURLPublicPath);\n\t\t\t\tmainPath = i18nPath.concat(mainPath);\n\t\t\t}\n\t\t}\n\n\t\t// Company logo\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(imagePath);\n\t\tsb.append(\"/company_logo?img_id=\");\n\t\tsb.append(company.getLogoId());\n\t\tsb.append(\"&t=\");\n\t\tsb.append(ImageServletTokenUtil.getToken(company.getLogoId()));\n\n\t\tString companyLogo = sb.toString();\n\n\t\tint companyLogoHeight = 0;\n\t\tint companyLogoWidth = 0;\n\n\t\tImage companyLogoImage = ImageLocalServiceUtil.getCompanyLogo(\n\t\t\tcompany.getLogoId());\n\n\t\tif (companyLogoImage != null) {\n\t\t\tcompanyLogoHeight = companyLogoImage.getHeight();\n\t\t\tcompanyLogoWidth = companyLogoImage.getWidth();\n\t\t}\n\n\t\tString realCompanyLogo = companyLogo;\n\t\tint realCompanyLogoHeight = companyLogoHeight;\n\t\tint realCompanyLogoWidth = companyLogoWidth;\n\n\t\t// User\n\n\t\tUser user = null;\n\n\t\ttry {\n\t\t\tuser = PortalUtil.getUser(request);\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(nsue.getMessage());\n\t\t\t}\n\n\t\t\tlong userId = PortalUtil.getUserId(request);\n\n\t\t\tif (userId > 0) {\n\t\t\t\tsession.invalidate();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tboolean signedIn = false;\n\n\t\tif (user == null) {\n\t\t\tuser = company.getDefaultUser();\n\t\t}\n\t\telse if (!user.isDefaultUser()) {\n\t\t\tsignedIn = true;\n\t\t}\n\n\t\tif (PropsValues.BROWSER_CACHE_SIGNED_IN_DISABLED && signedIn) {\n\t\t\tresponse.setDateHeader(HttpHeaders.EXPIRES, 0);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.CACHE_CONTROL,\n\t\t\t\tHttpHeaders.CACHE_CONTROL_NO_CACHE_VALUE);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.PRAGMA, HttpHeaders.PRAGMA_NO_CACHE_VALUE);\n\t\t}\n\n\t\tUser realUser = user;\n\n\t\tLong realUserId = (Long)session.getAttribute(WebKeys.USER_ID);\n\n\t\tif (realUserId != null) {\n\t\t\tif (user.getUserId() != realUserId.longValue()) {\n\t\t\t\trealUser = UserLocalServiceUtil.getUserById(\n\t\t\t\t\trealUserId.longValue());\n\t\t\t}\n\t\t}\n\n\t\tString doAsUserId = ParamUtil.getString(request, \"doAsUserId\");\n\t\tString doAsUserLanguageId = ParamUtil.getString(\n\t\t\trequest, \"doAsUserLanguageId\");\n\t\tlong doAsGroupId = ParamUtil.getLong(request, \"doAsGroupId\");\n\t\tlong refererPlid = ParamUtil.getLong(request, \"refererPlid\");\n\t\tString controlPanelCategory = ParamUtil.getString(\n\t\t\trequest, \"controlPanelCategory\");\n\n\t\t// Permission checker\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tPermissionCheckerFactoryUtil.create(user, true);\n\n\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t// Locale\n\n\t\tLocale locale = (Locale)session.getAttribute(Globals.LOCALE_KEY);\n\n\t\tif (Validator.isNotNull(doAsUserLanguageId)) {\n\t\t\tlocale = LocaleUtil.fromLanguageId(doAsUserLanguageId);\n\t\t}\n\n\t\tString i18nLanguageId = (String)request.getAttribute(\n\t\t\tWebKeys.I18N_LANGUAGE_ID);\n\n\t\tif (Validator.isNotNull(i18nLanguageId)) {\n\t\t\tlocale = LocaleUtil.fromLanguageId(i18nLanguageId);\n\t\t}\n\t\telse if (locale == null) {\n\t\t\tif (signedIn) {\n\t\t\t\tlocale = user.getLocale();\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// User previously set their preferred language\n\n\t\t\t\tString languageId = CookieKeys.getCookie(\n\t\t\t\t\trequest, CookieKeys.GUEST_LANGUAGE_ID);\n\n\t\t\t\tif (Validator.isNotNull(languageId)) {\n\t\t\t\t\tlocale = LocaleUtil.fromLanguageId(languageId);\n\t\t\t\t}\n\n\t\t\t\t// Get locale from the request\n\n\t\t\t\tif ((locale == null) && PropsValues.LOCALE_DEFAULT_REQUEST) {\n\t\t\t\t\tlocale = request.getLocale();\n\t\t\t\t}\n\n\t\t\t\t// Get locale from the default user\n\n\t\t\t\tif (locale == null) {\n\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t}\n\n\t\t\t\tif (Validator.isNull(locale.getCountry())) {\n\n\t\t\t\t\t// Locales must contain a country code\n\n\t\t\t\t\tlocale = LanguageUtil.getLocale(locale.getLanguage());\n\t\t\t\t}\n\n\t\t\t\tif (!LanguageUtil.isAvailableLocale(locale)) {\n\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsession.setAttribute(Globals.LOCALE_KEY, locale);\n\n\t\t\tLanguageUtil.updateCookie(request, response, locale);\n\t\t}\n\n\t\t// Cookie support\n\n\t\ttry {\n\n\t\t\t// LEP-4069\n\n\t\t\tCookieKeys.validateSupportCookie(request);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tCookieKeys.addSupportCookie(request, response);\n\t\t}\n\n\t\t// Time zone\n\n\t\tTimeZone timeZone = user.getTimeZone();\n\n\t\tif (timeZone == null) {\n\t\t\ttimeZone = company.getTimeZone();\n\t\t}\n\n\t\t// Device\n\n\t\tDevice device = (Device)session.getAttribute(WebKeys.DEVICE);\n\n\t\tif (device == null) {\n\t\t\tdevice = DeviceDetectionUtil.detectDevice(request);\n\n\t\t\tsession.setAttribute(WebKeys.DEVICE, device);\n\t\t}\n\n\t\t// Layouts\n\n\t\tif (signedIn) {\n\t\t\tupdateUserLayouts(user);\n\t\t}\n\n\t\tLayout layout = null;\n\t\tList<Layout> layouts = null;\n\n\t\tlong plid = ParamUtil.getLong(request, \"p_l_id\");\n\n\t\tif (plid > 0) {\n\t\t\tlayout = LayoutLocalServiceUtil.getLayout(plid);\n\t\t}\n\t\telse {\n\t\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\t\t\tboolean privateLayout = ParamUtil.getBoolean(\n\t\t\t\trequest, \"privateLayout\");\n\t\t\tlong layoutId = ParamUtil.getLong(request, \"layoutId\");\n\n\t\t\tif ((groupId > 0) && layoutId > 0) {\n\t\t\t\tlayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tgroupId, privateLayout, layoutId);\n\t\t\t}\n\t\t}\n\n\t\tif (layout != null) {\n\t\t\ttry {\n\t\t\t\tGroup group = layout.getGroup();\n\n\t\t\t\tif (!signedIn && PropsValues.AUTH_FORWARD_BY_REDIRECT) {\n\t\t\t\t\trequest.setAttribute(WebKeys.REQUESTED_LAYOUT, layout);\n\t\t\t\t}\n\n\t\t\t\tboolean isViewableGroup = isViewableGroup(\n\t\t\t\t\tuser, layout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tlayout.getLayoutId(), controlPanelCategory,\n\t\t\t\t\tpermissionChecker);\n\n\t\t\t\tif (!isViewableGroup && group.isStagingGroup()) {\n\t\t\t\t\tlayout = null;\n\t\t\t\t}\n\t\t\t\telse if (!isViewableGroup) {\n\t\t\t\t\tsb = new StringBundler(6);\n\n\t\t\t\t\tsb.append(\"User \");\n\t\t\t\t\tsb.append(user.getUserId());\n\t\t\t\t\tsb.append(\" is not allowed to access the \");\n\t\t\t\t\tsb.append(layout.isPrivateLayout() ? \"private\": \"public\");\n\t\t\t\t\tsb.append(\" pages of group \");\n\t\t\t\t\tsb.append(layout.getGroupId());\n\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(sb.toString());\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new PrincipalException(sb.toString());\n\t\t\t\t}\n\t\t\t\telse if (isViewableGroup &&\n\t\t\t\t\t\t!LayoutPermissionUtil.contains(\n\t\t\t\t\t\t\tpermissionChecker, layout, ActionKeys.VIEW)) {\n\n\t\t\t\t\tlayout = null;\n\t\t\t\t}\n\t\t\t\telse if (group.isLayoutPrototype()) {\n\t\t\t\t\tlayouts = new ArrayList<Layout>();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\t\t\t\tif (!group.isControlPanel()) {\n\t\t\t\t\t\tdoAsGroupId = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchLayoutException nsle) {\n\t\t\t}\n\t\t}\n\n\t\tList<Layout> unfilteredLayouts = layouts;\n\n\t\tif (layout == null) {\n\t\t\tObject[] defaultLayout = getDefaultLayout(request, user, signedIn);\n\n\t\t\tlayout = (Layout)defaultLayout[0];\n\t\t\tlayouts = (List<Layout>)defaultLayout[1];\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT_DEFAULT, Boolean.TRUE);\n\t\t}\n\n\t\tObject[] viewableLayouts = getViewableLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts);\n\n\t\tString layoutSetLogo = null;\n\n\t\tlayout = (Layout)viewableLayouts[0];\n\t\tlayouts = (List<Layout>)viewableLayouts[1];\n\n\t\tGroup group = null;\n\n\t\tif (layout != null) {\n\t\t\tgroup = layout.getGroup();\n\n\t\t\tif (!group.isControlPanel()) {\n\t\t\t\trememberVisitedGroupIds(request, group.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\tLayoutTypePortlet layoutTypePortlet = null;\n\n\t\tlayouts = mergeAdditionalLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts);\n\n\t\tLayoutSet layoutSet = null;\n\n\t\tboolean customizedView = SessionParamUtil.getBoolean(\n\t\t\trequest, \"customized_view\", true);\n\n\t\tif (layout != null) {\n\t\t\tlayoutSet = layout.getLayoutSet();\n\n\t\t\tif (company.isCommunityLogo()) {\n\t\t\t\tlong logoId = 0;\n\n\t\t\t\tif (layoutSet.isLogo()) {\n\t\t\t\t\tlogoId = layoutSet.getLogoId();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLayoutSet siblingLayoutSet =\n\t\t\t\t\t\tLayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\t\t\tlayout.getGroupId(), !layout.isPrivateLayout());\n\n\t\t\t\t\tif (siblingLayoutSet.isLogo()) {\n\t\t\t\t\t\tlogoId = siblingLayoutSet.getLogoId();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (logoId > 0) {\n\t\t\t\t\tsb = new StringBundler(5);\n\n\t\t\t\t\tsb.append(imagePath);\n\t\t\t\t\tsb.append(\"/layout_set_logo?img_id=\");\n\t\t\t\t\tsb.append(logoId);\n\t\t\t\t\tsb.append(\"&t=\");\n\t\t\t\t\tsb.append(ImageServletTokenUtil.getToken(logoId));\n\n\t\t\t\t\tlayoutSetLogo = sb.toString();\n\n\t\t\t\t\tImage layoutSetLogoImage =\n\t\t\t\t\t\tImageLocalServiceUtil.getCompanyLogo(logoId);\n\n\t\t\t\t\tcompanyLogo = layoutSetLogo;\n\t\t\t\t\tcompanyLogoHeight = layoutSetLogoImage.getHeight();\n\t\t\t\t\tcompanyLogoWidth = layoutSetLogoImage.getWidth();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplid = layout.getPlid();\n\n\t\t\t// Updates to shared layouts are not reflected until the next time\n\t\t\t// the user logs in because group layouts are cached in the session\n\n\t\t\tlayout = (Layout)layout.clone();\n\n\t\t\tlayoutTypePortlet = (LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\tboolean customizable = layoutTypePortlet.isCustomizable();\n\n\t\t\tif (!customizable ||\n\t\t\t\t(group.isLayoutPrototype() || group.isLayoutSetPrototype())) {\n\n\t\t\t\tcustomizedView = false;\n\t\t\t}\n\n\t\t\tlayoutTypePortlet.setCustomizedView(customizedView);\n\t\t\tlayoutTypePortlet.setUpdatePermission(\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.UPDATE));\n\n\t\t\tif (signedIn && customizable && customizedView &&\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.CUSTOMIZE)) {\n\n\t\t\t\tPortalPreferences portalPreferences =\n\t\t\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(\n\t\t\t\t\t\tcompanyId, user.getUserId(), true);\n\n\t\t\t\tlayoutTypePortlet.setPortalPreferences(portalPreferences);\n\t\t\t}\n\n\t\t\tLayoutClone layoutClone = LayoutCloneFactory.getInstance();\n\n\t\t\tif (layoutClone != null) {\n\t\t\t\tString typeSettings = layoutClone.get(request, plid);\n\n\t\t\t\tif (typeSettings != null) {\n\t\t\t\t\tUnicodeProperties typeSettingsProperties =\n\t\t\t\t\t\tnew UnicodeProperties(true);\n\n\t\t\t\t\ttypeSettingsProperties.load(typeSettings);\n\n\t\t\t\t\tString stateMax = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MAX);\n\t\t\t\t\tString stateMin = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MIN);\n\t\t\t\t\tString modeAbout = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_ABOUT);\n\t\t\t\t\tString modeConfig = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_CONFIG);\n\t\t\t\t\tString modeEdit = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT);\n\t\t\t\t\tString modeEditDefaults =\n\t\t\t\t\t\ttypeSettingsProperties.getProperty(\n\t\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_DEFAULTS);\n\t\t\t\t\tString modeEditGuest = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_GUEST);\n\t\t\t\t\tString modeHelp = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_HELP);\n\t\t\t\t\tString modePreview = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PREVIEW);\n\t\t\t\t\tString modePrint = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PRINT);\n\n\t\t\t\t\tlayoutTypePortlet.setStateMax(stateMax);\n\t\t\t\t\tlayoutTypePortlet.setStateMin(stateMin);\n\t\t\t\t\tlayoutTypePortlet.setModeAbout(modeAbout);\n\t\t\t\t\tlayoutTypePortlet.setModeConfig(modeConfig);\n\t\t\t\t\tlayoutTypePortlet.setModeEdit(modeEdit);\n\t\t\t\t\tlayoutTypePortlet.setModeEditDefaults(modeEditDefaults);\n\t\t\t\t\tlayoutTypePortlet.setModeEditGuest(modeEditGuest);\n\t\t\t\t\tlayoutTypePortlet.setModeHelp(modeHelp);\n\t\t\t\t\tlayoutTypePortlet.setModePreview(modePreview);\n\t\t\t\t\tlayoutTypePortlet.setModePrint(modePrint);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT, layout);\n\t\t\trequest.setAttribute(WebKeys.LAYOUTS, layouts);\n\n\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\tpermissionChecker.setCheckGuest(false);\n\t\t\t}\n\t\t}\n\n\t\t// Scope\n\n\t\tlong scopeGroupId = PortalUtil.getScopeGroupId(request);\n\t\tlong parentGroupId = PortalUtil.getParentGroupId(scopeGroupId);\n\n\t\t// Theme and color scheme\n\n\t\tTheme theme = null;\n\t\tColorScheme colorScheme = null;\n\n\t\tboolean wapTheme = BrowserSnifferUtil.isWap(request);\n\n\t\tif ((layout != null) &&\n\t\t\tgroup.isControlPanel()) {\n\n\t\t\tString themeId = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsKeys.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID);\n\t\t\tString colorSchemeId =\n\t\t\t\tColorSchemeImpl.getDefaultRegularColorSchemeId();\n\n\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\tcompanyId, themeId, wapTheme);\n\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, wapTheme);\n\n\t\t\tif (!wapTheme && theme.isWapTheme()) {\n\t\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tPropsValues.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID, false);\n\t\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, false);\n\t\t\t}\n\t\t}\n\t\telse if (layout != null) {\n\t\t\tif (wapTheme) {\n\t\t\t\ttheme = layout.getWapTheme();\n\t\t\t\tcolorScheme = layout.getWapColorScheme();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttheme = layout.getTheme();\n\t\t\t\tcolorScheme = layout.getColorScheme();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString themeId = null;\n\t\t\tString colorSchemeId = null;\n\n\t\t\tif (wapTheme) {\n\t\t\t\tthemeId = ThemeImpl.getDefaultWapThemeId(companyId);\n\t\t\t\tcolorSchemeId = ColorSchemeImpl.getDefaultWapColorSchemeId();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthemeId = ThemeImpl.getDefaultRegularThemeId(companyId);\n\t\t\t\tcolorSchemeId =\n\t\t\t\t\tColorSchemeImpl.getDefaultRegularColorSchemeId();\n\t\t\t}\n\n\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\tcompanyId, themeId, wapTheme);\n\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, wapTheme);\n\t\t}\n\n\t\trequest.setAttribute(WebKeys.THEME, theme);\n\t\trequest.setAttribute(WebKeys.COLOR_SCHEME, colorScheme);\n\n\t\tboolean themeCssFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"css_fast_load\", PropsValues.THEME_CSS_FAST_LOAD);\n\t\tboolean themeImagesFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"images_fast_load\", PropsValues.THEME_IMAGES_FAST_LOAD);\n\n\t\tboolean themeJsBarebone = PropsValues.JAVASCRIPT_BAREBONE_ENABLED;\n\n\t\tif (themeJsBarebone) {\n\t\t\tif (signedIn) {\n\t\t\t\tthemeJsBarebone = false;\n\t\t\t}\n\t\t}\n\n\t\tboolean themeJsFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"js_fast_load\", PropsValues.JAVASCRIPT_FAST_LOAD);\n\n\t\tString lifecycle = ParamUtil.getString(request, \"p_p_lifecycle\", \"0\");\n\n\t\tlifecycle = ParamUtil.getString(request, \"p_t_lifecycle\", lifecycle);\n\n\t\tboolean isolated = ParamUtil.getBoolean(request, \"p_p_isolated\");\n\n\t\tString facebookCanvasPageURL = (String)request.getAttribute(\n\t\t\tWebKeys.FACEBOOK_CANVAS_PAGE_URL);\n\n\t\tboolean widget = false;\n\n\t\tBoolean widgetObj = (Boolean)request.getAttribute(WebKeys.WIDGET);\n\n\t\tif (widgetObj != null) {\n\t\t\twidget = widgetObj.booleanValue();\n\t\t}\n\n\t\t// Theme display\n\n\t\tThemeDisplay themeDisplay = ThemeDisplayFactory.create();\n\n\t\t// Set the CDN host, portal URL, and Facebook application ID first\n\t\t// because other methods (setLookAndFeel) depend on them being set\n\n\t\tthemeDisplay.setCDNHost(cdnHost);\n\t\tthemeDisplay.setPortalURL(portalURL);\n\t\tthemeDisplay.setFacebookCanvasPageURL(facebookCanvasPageURL);\n\t\tthemeDisplay.setWidget(widget);\n\n\t\tthemeDisplay.setCompany(company);\n\t\tthemeDisplay.setCompanyLogo(companyLogo);\n\t\tthemeDisplay.setCompanyLogoHeight(companyLogoHeight);\n\t\tthemeDisplay.setCompanyLogoWidth(companyLogoWidth);\n\t\tthemeDisplay.setRealCompanyLogo(realCompanyLogo);\n\t\tthemeDisplay.setRealCompanyLogoHeight(realCompanyLogoHeight);\n\t\tthemeDisplay.setRealCompanyLogoWidth(realCompanyLogoWidth);\n\t\tthemeDisplay.setUser(user);\n\t\tthemeDisplay.setRealUser(realUser);\n\t\tthemeDisplay.setDoAsUserId(doAsUserId);\n\t\tthemeDisplay.setDoAsUserLanguageId(doAsUserLanguageId);\n\t\tthemeDisplay.setDoAsGroupId(doAsGroupId);\n\t\tthemeDisplay.setRefererPlid(refererPlid);\n\t\tthemeDisplay.setControlPanelCategory(controlPanelCategory);\n\t\tthemeDisplay.setLayoutSet(layoutSet);\n\t\tthemeDisplay.setLayoutSetLogo(layoutSetLogo);\n\t\tthemeDisplay.setLayout(layout);\n\t\tthemeDisplay.setLayouts(layouts);\n\t\tthemeDisplay.setUnfilteredLayouts(unfilteredLayouts);\n\t\tthemeDisplay.setPlid(plid);\n\t\tthemeDisplay.setLayoutTypePortlet(layoutTypePortlet);\n\t\tthemeDisplay.setScopeGroupId(scopeGroupId);\n\t\tthemeDisplay.setParentGroupId(parentGroupId);\n\t\tthemeDisplay.setSignedIn(signedIn);\n\t\tthemeDisplay.setPermissionChecker(permissionChecker);\n\t\tthemeDisplay.setLocale(locale);\n\t\tthemeDisplay.setLanguageId(LocaleUtil.toLanguageId(locale));\n\t\tthemeDisplay.setI18nLanguageId(i18nLanguageId);\n\t\tthemeDisplay.setI18nPath(i18nPath);\n\t\tthemeDisplay.setTimeZone(timeZone);\n\t\tthemeDisplay.setDevice(device);\n\t\tthemeDisplay.setLookAndFeel(contextPath, theme, colorScheme);\n\t\tthemeDisplay.setThemeCssFastLoad(themeCssFastLoad);\n\t\tthemeDisplay.setThemeImagesFastLoad(themeImagesFastLoad);\n\t\tthemeDisplay.setThemeJsBarebone(themeJsBarebone);\n\t\tthemeDisplay.setThemeJsFastLoad(themeJsFastLoad);\n\t\tthemeDisplay.setServerName(request.getServerName());\n\t\tthemeDisplay.setServerPort(request.getServerPort());\n\t\tthemeDisplay.setSecure(PortalUtil.isSecure(request));\n\t\tthemeDisplay.setLifecycle(lifecycle);\n\t\tthemeDisplay.setLifecycleAction(lifecycle.equals(\"1\"));\n\t\tthemeDisplay.setLifecycleRender(lifecycle.equals(\"0\"));\n\t\tthemeDisplay.setLifecycleResource(lifecycle.equals(\"2\"));\n\t\tthemeDisplay.setStateExclusive(LiferayWindowState.isExclusive(request));\n\t\tthemeDisplay.setStateMaximized(LiferayWindowState.isMaximized(request));\n\t\tthemeDisplay.setStatePopUp(LiferayWindowState.isPopUp(request));\n\t\tthemeDisplay.setIsolated(isolated);\n\t\tthemeDisplay.setPathApplet(contextPath.concat(\"/applets\"));\n\t\tthemeDisplay.setPathCms(contextPath.concat(\"/cms\"));\n\t\tthemeDisplay.setPathContext(contextPath);\n\t\tthemeDisplay.setPathFlash(contextPath.concat(\"/flash\"));\n\t\tthemeDisplay.setPathFriendlyURLPrivateGroup(\n\t\t\tfriendlyURLPrivateGroupPath);\n\t\tthemeDisplay.setPathFriendlyURLPrivateUser(friendlyURLPrivateUserPath);\n\t\tthemeDisplay.setPathFriendlyURLPublic(friendlyURLPublicPath);\n\t\tthemeDisplay.setPathImage(imagePath);\n\t\tthemeDisplay.setPathJavaScript(\n\t\t\tcdnHost.concat(contextPath).concat(\"/html/js\"));\n\t\tthemeDisplay.setPathMain(mainPath);\n\t\tthemeDisplay.setPathSound(contextPath.concat(\"/html/sound\"));\n\n\t\t// Icons\n\n\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\tthemeDisplay.setShowControlPanelIcon(signedIn);\n\t\tthemeDisplay.setShowHomeIcon(true);\n\t\tthemeDisplay.setShowMyAccountIcon(signedIn);\n\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\tthemeDisplay.setShowPortalIcon(true);\n\t\tthemeDisplay.setShowSignInIcon(!signedIn);\n\t\tthemeDisplay.setShowSignOutIcon(signedIn);\n\n\t\tboolean showSiteContentIcon = false;\n\n\t\tlong controlPanelPlid = 0;\n\n\t\tif (signedIn) {\n\t\t\tGroup controlPanelGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\tcompanyId, GroupConstants.CONTROL_PANEL);\n\n\t\t\tcontrolPanelPlid = LayoutLocalServiceUtil.getDefaultPlid(\n\t\t\t\tcontrolPanelGroup.getGroupId(), true);\n\n\t\t\tList<Portlet> siteContentPortlets =\n\t\t\t\tPortalUtil.getControlPanelPortlets(\n\t\t\t\t\tPortletCategoryKeys.CONTENT, themeDisplay);\n\n\t\t\tPortlet groupPagesPortlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\tPortletKeys.GROUP_PAGES);\n\t\t\tPortlet siteSettingsPortlet =\n\t\t\t\tPortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tPortletKeys.SITE_SETTINGS);\n\n\t\t\tsiteContentPortlets.remove(groupPagesPortlet);\n\t\t\tsiteContentPortlets.remove(siteSettingsPortlet);\n\n\t\t\tshowSiteContentIcon = PortletPermissionUtil.contains(\n\t\t\t\tpermissionChecker, controlPanelGroup.getGroupId(),\n\t\t\t\tcontrolPanelPlid, siteContentPortlets, ActionKeys.VIEW);\n\t\t}\n\n\t\tthemeDisplay.setShowSiteContentIcon(showSiteContentIcon);\n\n\t\tthemeDisplay.setShowStagingIcon(false);\n\n\t\t// Session\n\n\t\tif (!CookieKeys.hasSessionId(request)) {\n\t\t\tthemeDisplay.setAddSessionIdToURL(true);\n\t\t\tthemeDisplay.setSessionId(session.getId());\n\t\t}\n\n\t\t// URLs\n\n\t\tString urlControlPanel = friendlyURLPrivateGroupPath.concat(\n\t\t\tGroupConstants.CONTROL_PANEL_FRIENDLY_URL);\n\n\t\tif (Validator.isNotNull(doAsUserId)) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"doAsUserId\", doAsUserId);\n\t\t}\n\n\t\tif (scopeGroupId > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"doAsGroupId\", scopeGroupId);\n\t\t}\n\n\t\tif (refererPlid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", refererPlid);\n\t\t}\n\t\telse if (plid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", plid);\n\t\t}\n\n\t\tif (themeDisplay.isAddSessionIdToURL()) {\n\t\t\turlControlPanel = PortalUtil.getURLWithSessionId(\n\t\t\t\turlControlPanel, session.getId());\n\t\t}\n\n\t\tthemeDisplay.setURLControlPanel(urlControlPanel);\n\n\t\tString siteContentURL = urlControlPanel;\n\n\t\tsiteContentURL = HttpUtil.addParameter(\n\t\t\tsiteContentURL, \"p_p_id\", PortletKeys.RECENT_CONTENT);\n\t\tsiteContentURL = HttpUtil.addParameter(\n\t\t\tsiteContentURL, \"controlPanelCategory\",\n\t\t\tPortletCategoryKeys.CONTENT);\n\n\t\tthemeDisplay.setURLSiteContent(siteContentURL);\n\n\t\tPortletURL createAccountURL = new PortletURLImpl(\n\t\t\trequest, PortletKeys.LOGIN, plid, PortletRequest.ACTION_PHASE);\n\n\t\tcreateAccountURL.setWindowState(WindowState.MAXIMIZED);\n\t\tcreateAccountURL.setPortletMode(PortletMode.VIEW);\n\n\t\tcreateAccountURL.setParameter(\"saveLastPath\", \"0\");\n\t\tcreateAccountURL.setParameter(\n\t\t\t\"struts_action\", \"/login/create_account\");\n\n\t\tthemeDisplay.setURLCreateAccount(createAccountURL);\n\n\t\tString currentURL = PortalUtil.getCurrentURL(request);\n\n\t\tthemeDisplay.setURLCurrent(currentURL);\n\n\t\tString urlHome = PortalUtil.getHomeURL(request);\n\n\t\tthemeDisplay.setURLHome(urlHome);\n\n\t\tif (layout != null) {\n\t\t\tif (layout.isTypePortlet()) {\n\t\t\t\tboolean freeformLayout =\n\t\t\t\t\tlayoutTypePortlet.getLayoutTemplateId().equals(\n\t\t\t\t\t\t\"freeform\");\n\n\t\t\t\tthemeDisplay.setFreeformLayout(freeformLayout);\n\n\t\t\t\tboolean hasUpdateLayoutPermission =\n\t\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, layout, ActionKeys.UPDATE);\n\n\t\t\t\tif (hasUpdateLayoutPermission) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(true);\n\t\t\t\t\tthemeDisplay.setShowPageCustomizationIcon(true);\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.toggle('\".concat(\n\t\t\t\t\t\t\tPortletKeys.LAYOUT_CONFIGURATION).concat(\"');\"));\n\n\t\t\t\t\tthemeDisplay.setURLLayoutTemplates(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.showTemplates();\");\n\t\t\t\t}\n\n\t\t\t\tboolean hasCustomizePermission = LayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.CUSTOMIZE);\n\n\t\t\t\tif (hasCustomizePermission && customizedView) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.toggle('\".concat(\n\t\t\t\t\t\t\tPortletKeys.LAYOUT_CONFIGURATION).concat(\"');\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean hasManageLayoutsPermission = false;\n\n\t\t\tif (signedIn) {\n\t\t\t\thasManageLayoutsPermission = GroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, scopeGroupId, ActionKeys.MANAGE_LAYOUTS);\n\n\t\t\t\tif (group.isUser()) {\n\t\t\t\t\tif ((layout.isPrivateLayout() &&\n\t\t\t\t\t\t !PropsValues.LAYOUT_USER_PRIVATE_LAYOUTS_MODIFIABLE) ||\n\t\t\t\t\t\t(layout.isPublicLayout() &&\n\t\t\t\t\t\t !PropsValues.LAYOUT_USER_PUBLIC_LAYOUTS_MODIFIABLE)) {\n\n\t\t\t\t\t\thasManageLayoutsPermission = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasManageLayoutsPermission) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\n\t\t\t\tPortletURL pageSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tpageSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tpageSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/layouts_admin/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tpageSettingsURL.setParameter(\"selPlid\", String.valueOf(plid));\n\n\t\t\t\tthemeDisplay.setURLPageSettings(pageSettingsURL);\n\n\t\t\t\tif (group.isSite()) {\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(true);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(false);\n\t\t\t\t}\n\n\t\t\t\tPortletURL manageSiteMembershipsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.SITE_MEMBERSHIPS_ADMIN,\n\t\t\t\t\tcontrolPanelPlid, PortletRequest.RENDER_PHASE);\n\n\t\t\t\tmanageSiteMembershipsURL.setWindowState(\n\t\t\t\t\tLiferayWindowState.POP_UP);\n\t\t\t\tmanageSiteMembershipsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site_assignments\");\n\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\n\t\t\t\tthemeDisplay.setURLManageSiteMemberships(\n\t\t\t\t\tmanageSiteMembershipsURL);\n\t\t\t}\n\n\t\t\tif (!group.isControlPanel() && !group.isUser() &&\n\t\t\t\t!group.isUserGroup() &&\n\t\t\t\t(GroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, group.getGroupId(),\n\t\t\t\t\tActionKeys.MANAGE_STAGING) ||\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, group.getGroupId(),\n\t\t\t\t\tActionKeys.UPDATE))) {\n\n\t\t\t\tthemeDisplay.setShowSiteSettingsIcon(true);\n\n\t\t\t\tPortletURL siteSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.SITE_SETTINGS, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tsiteSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/site_settings/edit_settings\");\n\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\n\t\t\t\tthemeDisplay.setURLSiteSettings(siteSettingsURL);\n\t\t\t}\n\n\t\t\tif (hasManageLayoutsPermission && !group.isLayoutPrototype()) {\n\t\t\t\tthemeDisplay.setShowSiteMapSettingsIcon(true);\n\n\t\t\t\tPortletURL siteMapSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteMapSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tsiteMapSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/layouts_admin/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\n\t\t\t\tthemeDisplay.setURLSiteMapSettings(siteMapSettingsURL);\n\t\t\t}\n\n\t\t\tif (group.hasStagingGroup() && !group.isStagingGroup()) {\n\t\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(false);\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\tif (group.isControlPanel()) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\t// LEP-4987\n\n\t\t\tif (group.isStaged() || group.isStagingGroup()) {\n\t\t\t\tboolean hasPublishStagingPermission =\n\t\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, scopeGroupId,\n\t\t\t\t\t\tActionKeys.PUBLISH_STAGING);\n\n\t\t\t\tif (hasManageLayoutsPermission || hasPublishStagingPermission) {\n\t\t\t\t\tthemeDisplay.setShowStagingIcon(true);\n\t\t\t\t}\n\n\t\t\t\tif (hasPublishStagingPermission) {\n\t\t\t\t\tPortletURL publishToLiveURL = new PortletURLImpl(\n\t\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, plid,\n\t\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\t\tpublishToLiveURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.EXCLUSIVE);\n\t\t\t\t\tpublishToLiveURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/layouts_admin/publish_layouts\");\n\n\t\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t\t}\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\"pagesRedirect\", currentURL);\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\n\t\t\t\t\tthemeDisplay.setURLPublishToLive(publishToLiveURL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPortletURLImpl myAccountURL = new PortletURLImpl(\n\t\t\t\trequest, PortletKeys.MY_ACCOUNT, controlPanelPlid,\n\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\tmyAccountURL.setWindowState(WindowState.MAXIMIZED);\n\t\t\tmyAccountURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\tif (scopeGroupId > 0) {\n\t\t\t\tmyAccountURL.setDoAsGroupId(scopeGroupId);\n\t\t\t}\n\n\t\t\tif (refererPlid > 0) {\n\t\t\t\tmyAccountURL.setRefererPlid(refererPlid);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmyAccountURL.setRefererPlid(plid);\n\t\t\t}\n\n\t\t\tmyAccountURL.setControlPanelCategory(PortletCategoryKeys.MY);\n\n\t\t\tmyAccountURL.setParameter(\"struts_action\", \"/my_account/edit_user\");\n\n\t\t\tthemeDisplay.setURLMyAccount(myAccountURL);\n\t\t}\n\n\t\tif ((!user.isActive()) ||\n\t\t\t(PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.TERMS_OF_USE_REQUIRED) &&\n\t\t\t !user.isAgreedToTermsOfUse())) {\n\n\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t}\n\n\t\tif (group.isLayoutPrototype()) {\n\t\t\tthemeDisplay.setShowControlPanelIcon(false);\n\t\t\tthemeDisplay.setShowHomeIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\t\t\tthemeDisplay.setShowPortalIcon(false);\n\t\t\tthemeDisplay.setShowSignInIcon(false);\n\t\t\tthemeDisplay.setShowSignOutIcon(false);\n\t\t\tthemeDisplay.setShowSiteContentIcon(false);\n\t\t\tthemeDisplay.setShowStagingIcon(false);\n\t\t}\n\n\t\tthemeDisplay.setURLPortal(portalURL.concat(contextPath));\n\n\t\tString urlSignIn = mainPath.concat(\"/portal/login\");\n\n\t\tif (layout != null) {\n\t\t\turlSignIn = HttpUtil.addParameter(\n\t\t\t\turlSignIn, \"p_l_id\", layout.getPlid());\n\t\t}\n\n\t\tthemeDisplay.setURLSignIn(urlSignIn);\n\n\t\tthemeDisplay.setURLSignOut(mainPath.concat(\"/portal/logout\"));\n\n\t\tPortletURL updateManagerURL = new PortletURLImpl(\n\t\t\trequest, PortletKeys.UPDATE_MANAGER, plid,\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tupdateManagerURL.setWindowState(WindowState.MAXIMIZED);\n\t\tupdateManagerURL.setPortletMode(PortletMode.VIEW);\n\n\t\tupdateManagerURL.setParameter(\"struts_action\", \"/update_manager/view\");\n\n\t\tthemeDisplay.setURLUpdateManager(updateManagerURL);\n\n\t\trequest.setAttribute(WebKeys.THEME_DISPLAY, themeDisplay);\n\n\t\t// Service context\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\trequest);\n\n\t\tServiceContextThreadLocal.pushServiceContext(serviceContext);\n\n\t\t// Parallel render\n\n\t\tboolean parallelRenderEnable = true;\n\n\t\tif (layout != null) {\n\t\t\tList<String> portletIds = layoutTypePortlet.getPortletIds();\n\n\t\t\tif (portletIds.size() == 1) {\n\t\t\t\tString portletId = portletIds.get(0);\n\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tportletId);\n\n\t\t\t\tif ((portlet != null) && !portlet.isAjaxable()) {\n\t\t\t\t\tparallelRenderEnable = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tBoolean parallelRenderEnableObj = Boolean.valueOf(ParamUtil.getBoolean(\n\t\t\trequest, \"p_p_parallel\", parallelRenderEnable));\n\n\t\trequest.setAttribute(\n\t\t\tWebKeys.PORTLET_PARALLEL_RENDER, parallelRenderEnableObj);\n\n\t\t// Main Journal article\n\n\t\tlong mainJournalArticleId = ParamUtil.getLong(\n\t\t\trequest, \"p_j_a_id\");\n\n\t\tif (mainJournalArticleId > 0) {\n\t\t\ttry{\n\t\t\t\tJournalArticle mainJournalArticle =\n\t\t\t\t\tJournalArticleServiceUtil.getArticle(mainJournalArticleId);\n\n\t\t\t\tthemeDisplay.setMainJournalArticle(mainJournalArticle);\n\t\t\t}\n\t\t\tcatch (NoSuchArticleException nsae) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(nsae.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":23319,"modified_method":"protected void servicePre(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tHttpSession session = request.getSession();\n\n\t\t// Company\n\n\t\tCompany company = PortalUtil.getCompany(request);\n\n\t\tlong companyId = company.getCompanyId();\n\n\t\t// CDN host\n\n\t\tString cdnHost = null;\n\n\t\tif (request.isSecure()) {\n\t\t\tcdnHost = PortalUtil.getCDNHostHttps();\n\t\t}\n\t\telse {\n\t\t\tcdnHost = PortalUtil.getCDNHostHttp();\n\t\t}\n\n\t\tcdnHost = ParamUtil.getString(request, \"cdn_host\", cdnHost);\n\n\t\t// Portal URL\n\n\t\tString portalURL = PortalUtil.getPortalURL(request);\n\n\t\t// Paths\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\t\tString friendlyURLPrivateGroupPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateGroup();\n\t\tString friendlyURLPrivateUserPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateUser();\n\t\tString friendlyURLPublicPath = PortalUtil.getPathFriendlyURLPublic();\n\t\tString imagePath = cdnHost.concat(PortalUtil.getPathImage());\n\t\tString mainPath = PortalUtil.getPathMain();\n\n\t\tString i18nPath = (String)request.getAttribute(WebKeys.I18N_PATH);\n\n\t\tif (Validator.isNotNull(i18nPath)) {\n\t\t\tif (Validator.isNotNull(contextPath)) {\n\t\t\t\tString i18nContextPath = contextPath.concat(i18nPath);\n\n\t\t\t\tfriendlyURLPrivateGroupPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateGroupPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPrivateUserPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateUserPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPublicPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPublicPath, contextPath, i18nContextPath);\n\t\t\t\tmainPath = StringUtil.replaceFirst(\n\t\t\t\t\tmainPath, contextPath, i18nContextPath);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfriendlyURLPrivateGroupPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateGroupPath);\n\t\t\t\tfriendlyURLPrivateUserPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateUserPath);\n\t\t\t\tfriendlyURLPublicPath = i18nPath.concat(friendlyURLPublicPath);\n\t\t\t\tmainPath = i18nPath.concat(mainPath);\n\t\t\t}\n\t\t}\n\n\t\t// Company logo\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(imagePath);\n\t\tsb.append(\"/company_logo?img_id=\");\n\t\tsb.append(company.getLogoId());\n\t\tsb.append(\"&t=\");\n\t\tsb.append(ImageServletTokenUtil.getToken(company.getLogoId()));\n\n\t\tString companyLogo = sb.toString();\n\n\t\tint companyLogoHeight = 0;\n\t\tint companyLogoWidth = 0;\n\n\t\tImage companyLogoImage = ImageLocalServiceUtil.getCompanyLogo(\n\t\t\tcompany.getLogoId());\n\n\t\tif (companyLogoImage != null) {\n\t\t\tcompanyLogoHeight = companyLogoImage.getHeight();\n\t\t\tcompanyLogoWidth = companyLogoImage.getWidth();\n\t\t}\n\n\t\tString realCompanyLogo = companyLogo;\n\t\tint realCompanyLogoHeight = companyLogoHeight;\n\t\tint realCompanyLogoWidth = companyLogoWidth;\n\n\t\t// User\n\n\t\tUser user = null;\n\n\t\ttry {\n\t\t\tuser = PortalUtil.getUser(request);\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(nsue.getMessage());\n\t\t\t}\n\n\t\t\tlong userId = PortalUtil.getUserId(request);\n\n\t\t\tif (userId > 0) {\n\t\t\t\tsession.invalidate();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tboolean signedIn = false;\n\n\t\tif (user == null) {\n\t\t\tuser = company.getDefaultUser();\n\t\t}\n\t\telse if (!user.isDefaultUser()) {\n\t\t\tsignedIn = true;\n\t\t}\n\n\t\tif (PropsValues.BROWSER_CACHE_SIGNED_IN_DISABLED && signedIn) {\n\t\t\tresponse.setDateHeader(HttpHeaders.EXPIRES, 0);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.CACHE_CONTROL,\n\t\t\t\tHttpHeaders.CACHE_CONTROL_NO_CACHE_VALUE);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.PRAGMA, HttpHeaders.PRAGMA_NO_CACHE_VALUE);\n\t\t}\n\n\t\tUser realUser = user;\n\n\t\tLong realUserId = (Long)session.getAttribute(WebKeys.USER_ID);\n\n\t\tif (realUserId != null) {\n\t\t\tif (user.getUserId() != realUserId.longValue()) {\n\t\t\t\trealUser = UserLocalServiceUtil.getUserById(\n\t\t\t\t\trealUserId.longValue());\n\t\t\t}\n\t\t}\n\n\t\tString doAsUserId = ParamUtil.getString(request, \"doAsUserId\");\n\t\tString doAsUserLanguageId = ParamUtil.getString(\n\t\t\trequest, \"doAsUserLanguageId\");\n\t\tlong doAsGroupId = ParamUtil.getLong(request, \"doAsGroupId\");\n\t\tlong refererPlid = ParamUtil.getLong(request, \"refererPlid\");\n\t\tString controlPanelCategory = ParamUtil.getString(\n\t\t\trequest, \"controlPanelCategory\");\n\n\t\t// Permission checker\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tPermissionCheckerFactoryUtil.create(user, true);\n\n\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t// Locale\n\n\t\tLocale locale = (Locale)session.getAttribute(Globals.LOCALE_KEY);\n\n\t\tif (Validator.isNotNull(doAsUserLanguageId)) {\n\t\t\tlocale = LocaleUtil.fromLanguageId(doAsUserLanguageId);\n\t\t}\n\n\t\tString i18nLanguageId = (String)request.getAttribute(\n\t\t\tWebKeys.I18N_LANGUAGE_ID);\n\n\t\tif (Validator.isNotNull(i18nLanguageId)) {\n\t\t\tlocale = LocaleUtil.fromLanguageId(i18nLanguageId);\n\t\t}\n\t\telse if (locale == null) {\n\t\t\tif (signedIn) {\n\t\t\t\tlocale = user.getLocale();\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// User previously set their preferred language\n\n\t\t\t\tString languageId = CookieKeys.getCookie(\n\t\t\t\t\trequest, CookieKeys.GUEST_LANGUAGE_ID);\n\n\t\t\t\tif (Validator.isNotNull(languageId)) {\n\t\t\t\t\tlocale = LocaleUtil.fromLanguageId(languageId);\n\t\t\t\t}\n\n\t\t\t\t// Get locale from the request\n\n\t\t\t\tif ((locale == null) && PropsValues.LOCALE_DEFAULT_REQUEST) {\n\t\t\t\t\tlocale = request.getLocale();\n\t\t\t\t}\n\n\t\t\t\t// Get locale from the default user\n\n\t\t\t\tif (locale == null) {\n\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t}\n\n\t\t\t\tif (Validator.isNull(locale.getCountry())) {\n\n\t\t\t\t\t// Locales must contain a country code\n\n\t\t\t\t\tlocale = LanguageUtil.getLocale(locale.getLanguage());\n\t\t\t\t}\n\n\t\t\t\tif (!LanguageUtil.isAvailableLocale(locale)) {\n\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsession.setAttribute(Globals.LOCALE_KEY, locale);\n\n\t\t\tLanguageUtil.updateCookie(request, response, locale);\n\t\t}\n\n\t\t// Cookie support\n\n\t\ttry {\n\n\t\t\t// LEP-4069\n\n\t\t\tCookieKeys.validateSupportCookie(request);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tCookieKeys.addSupportCookie(request, response);\n\t\t}\n\n\t\t// Time zone\n\n\t\tTimeZone timeZone = user.getTimeZone();\n\n\t\tif (timeZone == null) {\n\t\t\ttimeZone = company.getTimeZone();\n\t\t}\n\n\t\t// Device\n\n\t\tDevice device = (Device)session.getAttribute(WebKeys.DEVICE);\n\n\t\tif (device == null) {\n\t\t\tdevice = DeviceDetectionUtil.detectDevice(request);\n\n\t\t\tsession.setAttribute(WebKeys.DEVICE, device);\n\t\t}\n\n\t\t// Layouts\n\n\t\tif (signedIn) {\n\t\t\tupdateUserLayouts(user);\n\t\t}\n\n\t\tLayout layout = null;\n\t\tList<Layout> layouts = null;\n\n\t\tlong plid = ParamUtil.getLong(request, \"p_l_id\");\n\n\t\tif (plid > 0) {\n\t\t\tlayout = LayoutLocalServiceUtil.getLayout(plid);\n\t\t}\n\t\telse {\n\t\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\t\t\tboolean privateLayout = ParamUtil.getBoolean(\n\t\t\t\trequest, \"privateLayout\");\n\t\t\tlong layoutId = ParamUtil.getLong(request, \"layoutId\");\n\n\t\t\tif ((groupId > 0) && layoutId > 0) {\n\t\t\t\tlayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tgroupId, privateLayout, layoutId);\n\t\t\t}\n\t\t}\n\n\t\tif (layout != null) {\n\t\t\ttry {\n\t\t\t\tGroup group = layout.getGroup();\n\n\t\t\t\tif (!signedIn && PropsValues.AUTH_FORWARD_BY_REDIRECT) {\n\t\t\t\t\trequest.setAttribute(WebKeys.REQUESTED_LAYOUT, layout);\n\t\t\t\t}\n\n\t\t\t\tboolean isViewableGroup = isViewableGroup(\n\t\t\t\t\tuser, layout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tlayout.getLayoutId(), controlPanelCategory,\n\t\t\t\t\tpermissionChecker);\n\n\t\t\t\tif (!isViewableGroup && group.isStagingGroup()) {\n\t\t\t\t\tlayout = null;\n\t\t\t\t}\n\t\t\t\telse if (!isViewableGroup) {\n\t\t\t\t\tsb = new StringBundler(6);\n\n\t\t\t\t\tsb.append(\"User \");\n\t\t\t\t\tsb.append(user.getUserId());\n\t\t\t\t\tsb.append(\" is not allowed to access the \");\n\t\t\t\t\tsb.append(layout.isPrivateLayout() ? \"private\": \"public\");\n\t\t\t\t\tsb.append(\" pages of group \");\n\t\t\t\t\tsb.append(layout.getGroupId());\n\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(sb.toString());\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new PrincipalException(sb.toString());\n\t\t\t\t}\n\t\t\t\telse if (isViewableGroup &&\n\t\t\t\t\t\t!LayoutPermissionUtil.contains(\n\t\t\t\t\t\t\tpermissionChecker, layout, ActionKeys.VIEW)) {\n\n\t\t\t\t\tlayout = null;\n\t\t\t\t}\n\t\t\t\telse if (group.isLayoutPrototype()) {\n\t\t\t\t\tlayouts = new ArrayList<Layout>();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\t\t\t\tif (!group.isControlPanel()) {\n\t\t\t\t\t\tdoAsGroupId = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchLayoutException nsle) {\n\t\t\t}\n\t\t}\n\n\t\tList<Layout> unfilteredLayouts = layouts;\n\n\t\tif (layout == null) {\n\t\t\tObject[] defaultLayout = getDefaultLayout(request, user, signedIn);\n\n\t\t\tlayout = (Layout)defaultLayout[0];\n\t\t\tlayouts = (List<Layout>)defaultLayout[1];\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT_DEFAULT, Boolean.TRUE);\n\t\t}\n\n\t\tObject[] viewableLayouts = getViewableLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts);\n\n\t\tString layoutSetLogo = null;\n\n\t\tlayout = (Layout)viewableLayouts[0];\n\t\tlayouts = (List<Layout>)viewableLayouts[1];\n\n\t\tGroup group = null;\n\n\t\tif (layout != null) {\n\t\t\tgroup = layout.getGroup();\n\n\t\t\tif (!group.isControlPanel()) {\n\t\t\t\trememberVisitedGroupIds(request, group.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\tLayoutTypePortlet layoutTypePortlet = null;\n\n\t\tlayouts = mergeAdditionalLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts);\n\n\t\tLayoutSet layoutSet = null;\n\n\t\tboolean customizedView = SessionParamUtil.getBoolean(\n\t\t\trequest, \"customized_view\", true);\n\n\t\tif (layout != null) {\n\t\t\tlayoutSet = layout.getLayoutSet();\n\n\t\t\tif (company.isCommunityLogo()) {\n\t\t\t\tlong logoId = 0;\n\n\t\t\t\tif (layoutSet.isLogo()) {\n\t\t\t\t\tlogoId = layoutSet.getLogoId();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLayoutSet siblingLayoutSet =\n\t\t\t\t\t\tLayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\t\t\tlayout.getGroupId(), !layout.isPrivateLayout());\n\n\t\t\t\t\tif (siblingLayoutSet.isLogo()) {\n\t\t\t\t\t\tlogoId = siblingLayoutSet.getLogoId();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (logoId > 0) {\n\t\t\t\t\tsb = new StringBundler(5);\n\n\t\t\t\t\tsb.append(imagePath);\n\t\t\t\t\tsb.append(\"/layout_set_logo?img_id=\");\n\t\t\t\t\tsb.append(logoId);\n\t\t\t\t\tsb.append(\"&t=\");\n\t\t\t\t\tsb.append(ImageServletTokenUtil.getToken(logoId));\n\n\t\t\t\t\tlayoutSetLogo = sb.toString();\n\n\t\t\t\t\tImage layoutSetLogoImage =\n\t\t\t\t\t\tImageLocalServiceUtil.getCompanyLogo(logoId);\n\n\t\t\t\t\tcompanyLogo = layoutSetLogo;\n\t\t\t\t\tcompanyLogoHeight = layoutSetLogoImage.getHeight();\n\t\t\t\t\tcompanyLogoWidth = layoutSetLogoImage.getWidth();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplid = layout.getPlid();\n\n\t\t\t// Updates to shared layouts are not reflected until the next time\n\t\t\t// the user logs in because group layouts are cached in the session\n\n\t\t\tlayout = (Layout)layout.clone();\n\n\t\t\tlayoutTypePortlet = (LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\tboolean customizable = layoutTypePortlet.isCustomizable();\n\n\t\t\tif (!customizable ||\n\t\t\t\t(group.isLayoutPrototype() || group.isLayoutSetPrototype())) {\n\n\t\t\t\tcustomizedView = false;\n\t\t\t}\n\n\t\t\tlayoutTypePortlet.setCustomizedView(customizedView);\n\t\t\tlayoutTypePortlet.setUpdatePermission(\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.UPDATE));\n\n\t\t\tif (signedIn && customizable && customizedView &&\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.CUSTOMIZE)) {\n\n\t\t\t\tPortalPreferences portalPreferences =\n\t\t\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(\n\t\t\t\t\t\tcompanyId, user.getUserId(), true);\n\n\t\t\t\tlayoutTypePortlet.setPortalPreferences(portalPreferences);\n\t\t\t}\n\n\t\t\tLayoutClone layoutClone = LayoutCloneFactory.getInstance();\n\n\t\t\tif (layoutClone != null) {\n\t\t\t\tString typeSettings = layoutClone.get(request, plid);\n\n\t\t\t\tif (typeSettings != null) {\n\t\t\t\t\tUnicodeProperties typeSettingsProperties =\n\t\t\t\t\t\tnew UnicodeProperties(true);\n\n\t\t\t\t\ttypeSettingsProperties.load(typeSettings);\n\n\t\t\t\t\tString stateMax = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MAX);\n\t\t\t\t\tString stateMin = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MIN);\n\t\t\t\t\tString modeAbout = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_ABOUT);\n\t\t\t\t\tString modeConfig = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_CONFIG);\n\t\t\t\t\tString modeEdit = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT);\n\t\t\t\t\tString modeEditDefaults =\n\t\t\t\t\t\ttypeSettingsProperties.getProperty(\n\t\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_DEFAULTS);\n\t\t\t\t\tString modeEditGuest = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_GUEST);\n\t\t\t\t\tString modeHelp = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_HELP);\n\t\t\t\t\tString modePreview = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PREVIEW);\n\t\t\t\t\tString modePrint = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PRINT);\n\n\t\t\t\t\tlayoutTypePortlet.setStateMax(stateMax);\n\t\t\t\t\tlayoutTypePortlet.setStateMin(stateMin);\n\t\t\t\t\tlayoutTypePortlet.setModeAbout(modeAbout);\n\t\t\t\t\tlayoutTypePortlet.setModeConfig(modeConfig);\n\t\t\t\t\tlayoutTypePortlet.setModeEdit(modeEdit);\n\t\t\t\t\tlayoutTypePortlet.setModeEditDefaults(modeEditDefaults);\n\t\t\t\t\tlayoutTypePortlet.setModeEditGuest(modeEditGuest);\n\t\t\t\t\tlayoutTypePortlet.setModeHelp(modeHelp);\n\t\t\t\t\tlayoutTypePortlet.setModePreview(modePreview);\n\t\t\t\t\tlayoutTypePortlet.setModePrint(modePrint);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT, layout);\n\t\t\trequest.setAttribute(WebKeys.LAYOUTS, layouts);\n\n\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\tpermissionChecker.setCheckGuest(false);\n\t\t\t}\n\t\t}\n\n\t\t// Scope\n\n\t\tlong scopeGroupId = PortalUtil.getScopeGroupId(request);\n\t\tlong parentGroupId = PortalUtil.getParentGroupId(scopeGroupId);\n\n\t\tTheme theme = null;\n\t\tColorScheme colorScheme = null;\n\n\t\tboolean wapTheme = BrowserSnifferUtil.isWap(request);\n\n\t\tif ((layout != null) && group.isControlPanel()) {\n\t\t\tString themeId = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsKeys.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID);\n\t\t\tString colorSchemeId =\n\t\t\t\tColorSchemeImpl.getDefaultRegularColorSchemeId();\n\n\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\tcompanyId, themeId, wapTheme);\n\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, wapTheme);\n\n\t\t\tif (!wapTheme && theme.isWapTheme()) {\n\t\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tPropsValues.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID, false);\n\t\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, false);\n\t\t\t}\n\t\t}\n\n\t\tboolean themeCssFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"css_fast_load\", PropsValues.THEME_CSS_FAST_LOAD);\n\t\tboolean themeImagesFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"images_fast_load\", PropsValues.THEME_IMAGES_FAST_LOAD);\n\n\t\tboolean themeJsBarebone = PropsValues.JAVASCRIPT_BAREBONE_ENABLED;\n\n\t\tif (themeJsBarebone) {\n\t\t\tif (signedIn) {\n\t\t\t\tthemeJsBarebone = false;\n\t\t\t}\n\t\t}\n\n\t\tboolean themeJsFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"js_fast_load\", PropsValues.JAVASCRIPT_FAST_LOAD);\n\n\t\tString lifecycle = ParamUtil.getString(request, \"p_p_lifecycle\", \"0\");\n\n\t\tlifecycle = ParamUtil.getString(request, \"p_t_lifecycle\", lifecycle);\n\n\t\tboolean isolated = ParamUtil.getBoolean(request, \"p_p_isolated\");\n\n\t\tString facebookCanvasPageURL = (String)request.getAttribute(\n\t\t\tWebKeys.FACEBOOK_CANVAS_PAGE_URL);\n\n\t\tboolean widget = false;\n\n\t\tBoolean widgetObj = (Boolean)request.getAttribute(WebKeys.WIDGET);\n\n\t\tif (widgetObj != null) {\n\t\t\twidget = widgetObj.booleanValue();\n\t\t}\n\n\t\t// Theme display\n\n\t\tThemeDisplay themeDisplay = ThemeDisplayFactory.create();\n\n\t\t// Set the CDN host, portal URL, and Facebook application ID first\n\t\t// because other methods (setLookAndFeel) depend on them being set\n\n\t\tthemeDisplay.setCDNHost(cdnHost);\n\t\tthemeDisplay.setPortalURL(portalURL);\n\t\tthemeDisplay.setFacebookCanvasPageURL(facebookCanvasPageURL);\n\t\tthemeDisplay.setWidget(widget);\n\n\t\tthemeDisplay.setCompany(company);\n\t\tthemeDisplay.setCompanyLogo(companyLogo);\n\t\tthemeDisplay.setCompanyLogoHeight(companyLogoHeight);\n\t\tthemeDisplay.setCompanyLogoWidth(companyLogoWidth);\n\t\tthemeDisplay.setRealCompanyLogo(realCompanyLogo);\n\t\tthemeDisplay.setRealCompanyLogoHeight(realCompanyLogoHeight);\n\t\tthemeDisplay.setRealCompanyLogoWidth(realCompanyLogoWidth);\n\t\tthemeDisplay.setUser(user);\n\t\tthemeDisplay.setRealUser(realUser);\n\t\tthemeDisplay.setDoAsUserId(doAsUserId);\n\t\tthemeDisplay.setDoAsUserLanguageId(doAsUserLanguageId);\n\t\tthemeDisplay.setDoAsGroupId(doAsGroupId);\n\t\tthemeDisplay.setRefererPlid(refererPlid);\n\t\tthemeDisplay.setControlPanelCategory(controlPanelCategory);\n\t\tthemeDisplay.setLayoutSet(layoutSet);\n\t\tthemeDisplay.setLayoutSetLogo(layoutSetLogo);\n\t\tthemeDisplay.setLayout(layout);\n\t\tthemeDisplay.setLayouts(layouts);\n\t\tthemeDisplay.setUnfilteredLayouts(unfilteredLayouts);\n\t\tthemeDisplay.setPlid(plid);\n\t\tthemeDisplay.setLayoutTypePortlet(layoutTypePortlet);\n\t\tthemeDisplay.setScopeGroupId(scopeGroupId);\n\t\tthemeDisplay.setParentGroupId(parentGroupId);\n\t\tthemeDisplay.setSignedIn(signedIn);\n\t\tthemeDisplay.setPermissionChecker(permissionChecker);\n\t\tthemeDisplay.setLocale(locale);\n\t\tthemeDisplay.setLanguageId(LocaleUtil.toLanguageId(locale));\n\t\tthemeDisplay.setI18nLanguageId(i18nLanguageId);\n\t\tthemeDisplay.setI18nPath(i18nPath);\n\t\tthemeDisplay.setTimeZone(timeZone);\n\t\tthemeDisplay.setDevice(device);\n\n\t\tif (theme != null) {\n\t\t\trequest.setAttribute(WebKeys.THEME, theme);\n\t\t\trequest.setAttribute(WebKeys.COLOR_SCHEME, colorScheme);\n\n\t\t\tthemeDisplay.setLookAndFeel(contextPath, theme, colorScheme);\n\t\t}\n\n\t\tthemeDisplay.setThemeCssFastLoad(themeCssFastLoad);\n\t\tthemeDisplay.setThemeImagesFastLoad(themeImagesFastLoad);\n\t\tthemeDisplay.setThemeJsBarebone(themeJsBarebone);\n\t\tthemeDisplay.setThemeJsFastLoad(themeJsFastLoad);\n\t\tthemeDisplay.setServerName(request.getServerName());\n\t\tthemeDisplay.setServerPort(request.getServerPort());\n\t\tthemeDisplay.setSecure(PortalUtil.isSecure(request));\n\t\tthemeDisplay.setLifecycle(lifecycle);\n\t\tthemeDisplay.setLifecycleAction(lifecycle.equals(\"1\"));\n\t\tthemeDisplay.setLifecycleRender(lifecycle.equals(\"0\"));\n\t\tthemeDisplay.setLifecycleResource(lifecycle.equals(\"2\"));\n\t\tthemeDisplay.setStateExclusive(LiferayWindowState.isExclusive(request));\n\t\tthemeDisplay.setStateMaximized(LiferayWindowState.isMaximized(request));\n\t\tthemeDisplay.setStatePopUp(LiferayWindowState.isPopUp(request));\n\t\tthemeDisplay.setIsolated(isolated);\n\t\tthemeDisplay.setPathApplet(contextPath.concat(\"/applets\"));\n\t\tthemeDisplay.setPathCms(contextPath.concat(\"/cms\"));\n\t\tthemeDisplay.setPathContext(contextPath);\n\t\tthemeDisplay.setPathFlash(contextPath.concat(\"/flash\"));\n\t\tthemeDisplay.setPathFriendlyURLPrivateGroup(\n\t\t\tfriendlyURLPrivateGroupPath);\n\t\tthemeDisplay.setPathFriendlyURLPrivateUser(friendlyURLPrivateUserPath);\n\t\tthemeDisplay.setPathFriendlyURLPublic(friendlyURLPublicPath);\n\t\tthemeDisplay.setPathImage(imagePath);\n\t\tthemeDisplay.setPathJavaScript(\n\t\t\tcdnHost.concat(contextPath).concat(\"/html/js\"));\n\t\tthemeDisplay.setPathMain(mainPath);\n\t\tthemeDisplay.setPathSound(contextPath.concat(\"/html/sound\"));\n\n\t\t// Icons\n\n\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\tthemeDisplay.setShowControlPanelIcon(signedIn);\n\t\tthemeDisplay.setShowHomeIcon(true);\n\t\tthemeDisplay.setShowMyAccountIcon(signedIn);\n\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\tthemeDisplay.setShowPortalIcon(true);\n\t\tthemeDisplay.setShowSignInIcon(!signedIn);\n\t\tthemeDisplay.setShowSignOutIcon(signedIn);\n\n\t\tboolean showSiteContentIcon = false;\n\n\t\tlong controlPanelPlid = 0;\n\n\t\tif (signedIn) {\n\t\t\tGroup controlPanelGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\tcompanyId, GroupConstants.CONTROL_PANEL);\n\n\t\t\tcontrolPanelPlid = LayoutLocalServiceUtil.getDefaultPlid(\n\t\t\t\tcontrolPanelGroup.getGroupId(), true);\n\n\t\t\tList<Portlet> siteContentPortlets =\n\t\t\t\tPortalUtil.getControlPanelPortlets(\n\t\t\t\t\tPortletCategoryKeys.CONTENT, themeDisplay);\n\n\t\t\tPortlet groupPagesPortlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\tPortletKeys.GROUP_PAGES);\n\t\t\tPortlet siteSettingsPortlet =\n\t\t\t\tPortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tPortletKeys.SITE_SETTINGS);\n\n\t\t\tsiteContentPortlets.remove(groupPagesPortlet);\n\t\t\tsiteContentPortlets.remove(siteSettingsPortlet);\n\n\t\t\tshowSiteContentIcon = PortletPermissionUtil.contains(\n\t\t\t\tpermissionChecker, controlPanelGroup.getGroupId(),\n\t\t\t\tcontrolPanelPlid, siteContentPortlets, ActionKeys.VIEW);\n\t\t}\n\n\t\tthemeDisplay.setShowSiteContentIcon(showSiteContentIcon);\n\n\t\tthemeDisplay.setShowStagingIcon(false);\n\n\t\t// Session\n\n\t\tif (!CookieKeys.hasSessionId(request)) {\n\t\t\tthemeDisplay.setAddSessionIdToURL(true);\n\t\t\tthemeDisplay.setSessionId(session.getId());\n\t\t}\n\n\t\t// URLs\n\n\t\tString urlControlPanel = friendlyURLPrivateGroupPath.concat(\n\t\t\tGroupConstants.CONTROL_PANEL_FRIENDLY_URL);\n\n\t\tif (Validator.isNotNull(doAsUserId)) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"doAsUserId\", doAsUserId);\n\t\t}\n\n\t\tif (scopeGroupId > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"doAsGroupId\", scopeGroupId);\n\t\t}\n\n\t\tif (refererPlid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", refererPlid);\n\t\t}\n\t\telse if (plid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", plid);\n\t\t}\n\n\t\tif (themeDisplay.isAddSessionIdToURL()) {\n\t\t\turlControlPanel = PortalUtil.getURLWithSessionId(\n\t\t\t\turlControlPanel, session.getId());\n\t\t}\n\n\t\tthemeDisplay.setURLControlPanel(urlControlPanel);\n\n\t\tString siteContentURL = urlControlPanel;\n\n\t\tsiteContentURL = HttpUtil.addParameter(\n\t\t\tsiteContentURL, \"p_p_id\", PortletKeys.RECENT_CONTENT);\n\t\tsiteContentURL = HttpUtil.addParameter(\n\t\t\tsiteContentURL, \"controlPanelCategory\",\n\t\t\tPortletCategoryKeys.CONTENT);\n\n\t\tthemeDisplay.setURLSiteContent(siteContentURL);\n\n\t\tPortletURL createAccountURL = new PortletURLImpl(\n\t\t\trequest, PortletKeys.LOGIN, plid, PortletRequest.ACTION_PHASE);\n\n\t\tcreateAccountURL.setWindowState(WindowState.MAXIMIZED);\n\t\tcreateAccountURL.setPortletMode(PortletMode.VIEW);\n\n\t\tcreateAccountURL.setParameter(\"saveLastPath\", \"0\");\n\t\tcreateAccountURL.setParameter(\n\t\t\t\"struts_action\", \"/login/create_account\");\n\n\t\tthemeDisplay.setURLCreateAccount(createAccountURL);\n\n\t\tString currentURL = PortalUtil.getCurrentURL(request);\n\n\t\tthemeDisplay.setURLCurrent(currentURL);\n\n\t\tString urlHome = PortalUtil.getHomeURL(request);\n\n\t\tthemeDisplay.setURLHome(urlHome);\n\n\t\tif (layout != null) {\n\t\t\tif (layout.isTypePortlet()) {\n\t\t\t\tboolean freeformLayout =\n\t\t\t\t\tlayoutTypePortlet.getLayoutTemplateId().equals(\n\t\t\t\t\t\t\"freeform\");\n\n\t\t\t\tthemeDisplay.setFreeformLayout(freeformLayout);\n\n\t\t\t\tboolean hasUpdateLayoutPermission =\n\t\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, layout, ActionKeys.UPDATE);\n\n\t\t\t\tif (hasUpdateLayoutPermission) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(true);\n\t\t\t\t\tthemeDisplay.setShowPageCustomizationIcon(true);\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.toggle('\".concat(\n\t\t\t\t\t\t\tPortletKeys.LAYOUT_CONFIGURATION).concat(\"');\"));\n\n\t\t\t\t\tthemeDisplay.setURLLayoutTemplates(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.showTemplates();\");\n\t\t\t\t}\n\n\t\t\t\tboolean hasCustomizePermission = LayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.CUSTOMIZE);\n\n\t\t\t\tif (hasCustomizePermission && customizedView) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.toggle('\".concat(\n\t\t\t\t\t\t\tPortletKeys.LAYOUT_CONFIGURATION).concat(\"');\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean hasManageLayoutsPermission = false;\n\n\t\t\tif (signedIn) {\n\t\t\t\thasManageLayoutsPermission = GroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, scopeGroupId, ActionKeys.MANAGE_LAYOUTS);\n\n\t\t\t\tif (group.isUser()) {\n\t\t\t\t\tif ((layout.isPrivateLayout() &&\n\t\t\t\t\t\t !PropsValues.LAYOUT_USER_PRIVATE_LAYOUTS_MODIFIABLE) ||\n\t\t\t\t\t\t(layout.isPublicLayout() &&\n\t\t\t\t\t\t !PropsValues.LAYOUT_USER_PUBLIC_LAYOUTS_MODIFIABLE)) {\n\n\t\t\t\t\t\thasManageLayoutsPermission = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasManageLayoutsPermission) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\n\t\t\t\tPortletURL pageSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tpageSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tpageSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/layouts_admin/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tpageSettingsURL.setParameter(\"selPlid\", String.valueOf(plid));\n\n\t\t\t\tthemeDisplay.setURLPageSettings(pageSettingsURL);\n\n\t\t\t\tif (group.isSite()) {\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(true);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(false);\n\t\t\t\t}\n\n\t\t\t\tPortletURL manageSiteMembershipsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.SITE_MEMBERSHIPS_ADMIN,\n\t\t\t\t\tcontrolPanelPlid, PortletRequest.RENDER_PHASE);\n\n\t\t\t\tmanageSiteMembershipsURL.setWindowState(\n\t\t\t\t\tLiferayWindowState.POP_UP);\n\t\t\t\tmanageSiteMembershipsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site_assignments\");\n\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\n\t\t\t\tthemeDisplay.setURLManageSiteMemberships(\n\t\t\t\t\tmanageSiteMembershipsURL);\n\t\t\t}\n\n\t\t\tif (!group.isControlPanel() && !group.isUser() &&\n\t\t\t\t!group.isUserGroup() &&\n\t\t\t\t(GroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, group.getGroupId(),\n\t\t\t\t\tActionKeys.MANAGE_STAGING) ||\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, group.getGroupId(),\n\t\t\t\t\tActionKeys.UPDATE))) {\n\n\t\t\t\tthemeDisplay.setShowSiteSettingsIcon(true);\n\n\t\t\t\tPortletURL siteSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.SITE_SETTINGS, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tsiteSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/site_settings/edit_settings\");\n\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\n\t\t\t\tthemeDisplay.setURLSiteSettings(siteSettingsURL);\n\t\t\t}\n\n\t\t\tif (hasManageLayoutsPermission && !group.isLayoutPrototype()) {\n\t\t\t\tthemeDisplay.setShowSiteMapSettingsIcon(true);\n\n\t\t\t\tPortletURL siteMapSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteMapSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tsiteMapSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/layouts_admin/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\n\t\t\t\tthemeDisplay.setURLSiteMapSettings(siteMapSettingsURL);\n\t\t\t}\n\n\t\t\tif (group.hasStagingGroup() && !group.isStagingGroup()) {\n\t\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(false);\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\tif (group.isControlPanel()) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\t// LEP-4987\n\n\t\t\tif (group.isStaged() || group.isStagingGroup()) {\n\t\t\t\tboolean hasPublishStagingPermission =\n\t\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, scopeGroupId,\n\t\t\t\t\t\tActionKeys.PUBLISH_STAGING);\n\n\t\t\t\tif (hasManageLayoutsPermission || hasPublishStagingPermission) {\n\t\t\t\t\tthemeDisplay.setShowStagingIcon(true);\n\t\t\t\t}\n\n\t\t\t\tif (hasPublishStagingPermission) {\n\t\t\t\t\tPortletURL publishToLiveURL = new PortletURLImpl(\n\t\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, plid,\n\t\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\t\tpublishToLiveURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.EXCLUSIVE);\n\t\t\t\t\tpublishToLiveURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/layouts_admin/publish_layouts\");\n\n\t\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t\t}\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\"pagesRedirect\", currentURL);\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\n\t\t\t\t\tthemeDisplay.setURLPublishToLive(publishToLiveURL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPortletURLImpl myAccountURL = new PortletURLImpl(\n\t\t\t\trequest, PortletKeys.MY_ACCOUNT, controlPanelPlid,\n\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\tmyAccountURL.setWindowState(WindowState.MAXIMIZED);\n\t\t\tmyAccountURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\tif (scopeGroupId > 0) {\n\t\t\t\tmyAccountURL.setDoAsGroupId(scopeGroupId);\n\t\t\t}\n\n\t\t\tif (refererPlid > 0) {\n\t\t\t\tmyAccountURL.setRefererPlid(refererPlid);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmyAccountURL.setRefererPlid(plid);\n\t\t\t}\n\n\t\t\tmyAccountURL.setControlPanelCategory(PortletCategoryKeys.MY);\n\n\t\t\tmyAccountURL.setParameter(\"struts_action\", \"/my_account/edit_user\");\n\n\t\t\tthemeDisplay.setURLMyAccount(myAccountURL);\n\t\t}\n\n\t\tif ((!user.isActive()) ||\n\t\t\t(PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.TERMS_OF_USE_REQUIRED) &&\n\t\t\t !user.isAgreedToTermsOfUse())) {\n\n\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t}\n\n\t\tif (group.isLayoutPrototype()) {\n\t\t\tthemeDisplay.setShowControlPanelIcon(false);\n\t\t\tthemeDisplay.setShowHomeIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\t\t\tthemeDisplay.setShowPortalIcon(false);\n\t\t\tthemeDisplay.setShowSignInIcon(false);\n\t\t\tthemeDisplay.setShowSignOutIcon(false);\n\t\t\tthemeDisplay.setShowSiteContentIcon(false);\n\t\t\tthemeDisplay.setShowStagingIcon(false);\n\t\t}\n\n\t\tthemeDisplay.setURLPortal(portalURL.concat(contextPath));\n\n\t\tString urlSignIn = mainPath.concat(\"/portal/login\");\n\n\t\tif (layout != null) {\n\t\t\turlSignIn = HttpUtil.addParameter(\n\t\t\t\turlSignIn, \"p_l_id\", layout.getPlid());\n\t\t}\n\n\t\tthemeDisplay.setURLSignIn(urlSignIn);\n\n\t\tthemeDisplay.setURLSignOut(mainPath.concat(\"/portal/logout\"));\n\n\t\tPortletURL updateManagerURL = new PortletURLImpl(\n\t\t\trequest, PortletKeys.UPDATE_MANAGER, plid,\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tupdateManagerURL.setWindowState(WindowState.MAXIMIZED);\n\t\tupdateManagerURL.setPortletMode(PortletMode.VIEW);\n\n\t\tupdateManagerURL.setParameter(\"struts_action\", \"/update_manager/view\");\n\n\t\tthemeDisplay.setURLUpdateManager(updateManagerURL);\n\n\t\trequest.setAttribute(WebKeys.THEME_DISPLAY, themeDisplay);\n\n\t\t// Service context\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\trequest);\n\n\t\tServiceContextThreadLocal.pushServiceContext(serviceContext);\n\n\t\t// Parallel render\n\n\t\tboolean parallelRenderEnable = true;\n\n\t\tif (layout != null) {\n\t\t\tList<String> portletIds = layoutTypePortlet.getPortletIds();\n\n\t\t\tif (portletIds.size() == 1) {\n\t\t\t\tString portletId = portletIds.get(0);\n\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tportletId);\n\n\t\t\t\tif ((portlet != null) && !portlet.isAjaxable()) {\n\t\t\t\t\tparallelRenderEnable = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tBoolean parallelRenderEnableObj = Boolean.valueOf(ParamUtil.getBoolean(\n\t\t\trequest, \"p_p_parallel\", parallelRenderEnable));\n\n\t\trequest.setAttribute(\n\t\t\tWebKeys.PORTLET_PARALLEL_RENDER, parallelRenderEnableObj);\n\n\t\t// Main Journal article\n\n\t\tlong mainJournalArticleId = ParamUtil.getLong(\n\t\t\trequest, \"p_j_a_id\");\n\n\t\tif (mainJournalArticleId > 0) {\n\t\t\ttry{\n\t\t\t\tJournalArticle mainJournalArticle =\n\t\t\t\t\tJournalArticleServiceUtil.getArticle(mainJournalArticleId);\n\n\t\t\t\tthemeDisplay.setMainJournalArticle(mainJournalArticle);\n\t\t\t}\n\t\t\tcatch (NoSuchArticleException nsae) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(nsae.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"a4af8b3a3d5115a7814c1e937737968912515fa0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Base() {\n\n    // set the look and feel before opening the window\n\n    try {\n      if (Base.isMacOS()) {\n        // Use the Quaqua L & F on OS X to make JFileChooser less awful\n        UIManager.setLookAndFeel(\"ch.randelshofer.quaqua.QuaquaLookAndFeel\");\n        UIManager.put(\"Component.visualMargin\", new Insets(1, 1, 1, 1));\n\n      } else if (Base.isLinux()) {\n        // Linux is by default even uglier than metal (Motif?).\n        // Actually, i'm using native menus, so they're even uglier\n        // and Motif-looking (Lesstif?). Ick. Need to fix this.\n        String lfname = UIManager.getCrossPlatformLookAndFeelClassName();\n        UIManager.setLookAndFeel(lfname);\n\n      } else {\n        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n    // use native popups so they don't look so crappy on osx\n    JPopupMenu.setDefaultLightWeightPopupEnabled(false);\n\n    // build the editor object\n    editor = new Editor();\n\n    // get things rawkin\n    editor.pack();\n\n    // has to be here to set window size properly\n    editor.restorePreferences();\n\n    // show the window\n    editor.show();\n\n    // check for updates\n    if (Preferences.getBoolean(\"update.check\")) {\n      new UpdateCheck(editor);\n    }\n  }","id":23320,"modified_method":"public Base() {\n\n    // set the look and feel before opening the window\n\n    try {\n      if (Base.isMacOS()) {\n        // Use the Quaqua L & F on OS X to make JFileChooser less awful\n        UIManager.setLookAndFeel(\"ch.randelshofer.quaqua.QuaquaLookAndFeel\");\n        UIManager.put(\"Component.visualMargin\", new Insets(1, 1, 1, 1));\n\n      } else if (Base.isLinux()) {\n        // Linux is by default even uglier than metal (Motif?).\n        // Actually, i'm using native menus, so they're even uglier\n        // and Motif-looking (Lesstif?). Ick. Need to fix this.\n        //String lfname = UIManager.getCrossPlatformLookAndFeelClassName();\n        //UIManager.setLookAndFeel(lfname);\n\n        // For 0120, trying out the gtk+ look and feel as the default.\n        // This is available in Java 1.4.2 and later, and it can't possibly\n        // be any worse than Metal. (Ocean might also work, but that's for\n        // Java 1.5, and we aren't going there yet)\n        UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\");\n\n      } else {\n        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n    // use native popups so they don't look so crappy on osx\n    JPopupMenu.setDefaultLightWeightPopupEnabled(false);\n\n    // build the editor object\n    editor = new Editor();\n\n    // get things rawkin\n    editor.pack();\n\n    // has to be here to set window size properly\n    editor.restorePreferences();\n\n    // show the window\n    editor.show();\n\n    // check for updates\n    if (Preferences.getBoolean(\"update.check\")) {\n      new UpdateCheck(editor);\n    }\n  }","commit_id":"88243af47afeff03b5d7c937171c8d4422aca6d8","url":"https://github.com/processing/processing"},{"original_method":"protected void servicePre(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tHttpSession session = request.getSession();\n\n\t\t// Company\n\n\t\tCompany company = PortalUtil.getCompany(request);\n\n\t\tlong companyId = company.getCompanyId();\n\n\t\t// CDN host\n\n\t\tString cdnHost = null;\n\n\t\tif (request.isSecure()) {\n\t\t\tcdnHost = PortalUtil.getCDNHostHttps();\n\t\t}\n\t\telse {\n\t\t\tcdnHost = PortalUtil.getCDNHostHttp();\n\t\t}\n\n\t\tcdnHost = ParamUtil.getString(request, \"cdn_host\", cdnHost);\n\n\t\t// Portal URL\n\n\t\tString portalURL = PortalUtil.getPortalURL(request);\n\n\t\t// Paths\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\t\tString friendlyURLPrivateGroupPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateGroup();\n\t\tString friendlyURLPrivateUserPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateUser();\n\t\tString friendlyURLPublicPath = PortalUtil.getPathFriendlyURLPublic();\n\t\tString imagePath = cdnHost.concat(PortalUtil.getPathImage());\n\t\tString mainPath = PortalUtil.getPathMain();\n\n\t\tString i18nPath = (String)request.getAttribute(WebKeys.I18N_PATH);\n\n\t\tif (Validator.isNotNull(i18nPath)) {\n\t\t\tif (Validator.isNotNull(contextPath)) {\n\t\t\t\tString i18nContextPath = contextPath.concat(i18nPath);\n\n\t\t\t\tfriendlyURLPrivateGroupPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateGroupPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPrivateUserPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateUserPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPublicPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPublicPath, contextPath, i18nContextPath);\n\t\t\t\tmainPath = StringUtil.replaceFirst(\n\t\t\t\t\tmainPath, contextPath, i18nContextPath);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfriendlyURLPrivateGroupPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateGroupPath);\n\t\t\t\tfriendlyURLPrivateUserPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateUserPath);\n\t\t\t\tfriendlyURLPublicPath = i18nPath.concat(friendlyURLPublicPath);\n\t\t\t\tmainPath = i18nPath.concat(mainPath);\n\t\t\t}\n\t\t}\n\n\t\t// Company logo\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(imagePath);\n\t\tsb.append(\"/company_logo?img_id=\");\n\t\tsb.append(company.getLogoId());\n\t\tsb.append(\"&t=\");\n\t\tsb.append(ImageServletTokenUtil.getToken(company.getLogoId()));\n\n\t\tString companyLogo = sb.toString();\n\n\t\tint companyLogoHeight = 0;\n\t\tint companyLogoWidth = 0;\n\n\t\tImage companyLogoImage = ImageLocalServiceUtil.getCompanyLogo(\n\t\t\tcompany.getLogoId());\n\n\t\tif (companyLogoImage != null) {\n\t\t\tcompanyLogoHeight = companyLogoImage.getHeight();\n\t\t\tcompanyLogoWidth = companyLogoImage.getWidth();\n\t\t}\n\n\t\tString realCompanyLogo = companyLogo;\n\t\tint realCompanyLogoHeight = companyLogoHeight;\n\t\tint realCompanyLogoWidth = companyLogoWidth;\n\n\t\t// User\n\n\t\tUser user = null;\n\n\t\ttry {\n\t\t\tuser = PortalUtil.getUser(request);\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(nsue.getMessage());\n\t\t\t}\n\n\t\t\tlong userId = PortalUtil.getUserId(request);\n\n\t\t\tif (userId > 0) {\n\t\t\t\tsession.invalidate();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tboolean signedIn = false;\n\n\t\tif (user == null) {\n\t\t\tuser = company.getDefaultUser();\n\t\t}\n\t\telse if (!user.isDefaultUser()) {\n\t\t\tsignedIn = true;\n\t\t}\n\n\t\tif (PropsValues.BROWSER_CACHE_SIGNED_IN_DISABLED && signedIn) {\n\t\t\tresponse.setDateHeader(HttpHeaders.EXPIRES, 0);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.CACHE_CONTROL,\n\t\t\t\tHttpHeaders.CACHE_CONTROL_NO_CACHE_VALUE);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.PRAGMA, HttpHeaders.PRAGMA_NO_CACHE_VALUE);\n\t\t}\n\n\t\tUser realUser = user;\n\n\t\tLong realUserId = (Long)session.getAttribute(WebKeys.USER_ID);\n\n\t\tif (realUserId != null) {\n\t\t\tif (user.getUserId() != realUserId.longValue()) {\n\t\t\t\trealUser = UserLocalServiceUtil.getUserById(\n\t\t\t\t\trealUserId.longValue());\n\t\t\t}\n\t\t}\n\n\t\tString doAsUserId = ParamUtil.getString(request, \"doAsUserId\");\n\t\tString doAsUserLanguageId = ParamUtil.getString(\n\t\t\trequest, \"doAsUserLanguageId\");\n\t\tlong doAsGroupId = ParamUtil.getLong(request, \"doAsGroupId\");\n\t\tlong refererPlid = ParamUtil.getLong(request, \"refererPlid\");\n\t\tString controlPanelCategory = ParamUtil.getString(\n\t\t\trequest, \"controlPanelCategory\");\n\n\t\t// Permission checker\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tPermissionCheckerFactoryUtil.create(user, true);\n\n\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t// Locale\n\n\t\tLocale locale = (Locale)session.getAttribute(Globals.LOCALE_KEY);\n\n\t\tif (Validator.isNotNull(doAsUserLanguageId)) {\n\t\t\tlocale = LocaleUtil.fromLanguageId(doAsUserLanguageId);\n\t\t}\n\n\t\tString i18nLanguageId = (String)request.getAttribute(\n\t\t\tWebKeys.I18N_LANGUAGE_ID);\n\n\t\tif (Validator.isNotNull(i18nLanguageId)) {\n\t\t\tlocale = LocaleUtil.fromLanguageId(i18nLanguageId);\n\t\t}\n\t\telse if (locale == null) {\n\t\t\tif (signedIn) {\n\t\t\t\tlocale = user.getLocale();\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// User previously set their preferred language\n\n\t\t\t\tString languageId = CookieKeys.getCookie(\n\t\t\t\t\trequest, CookieKeys.GUEST_LANGUAGE_ID);\n\n\t\t\t\tif (Validator.isNotNull(languageId)) {\n\t\t\t\t\tlocale = LocaleUtil.fromLanguageId(languageId);\n\t\t\t\t}\n\n\t\t\t\t// Get locale from the request\n\n\t\t\t\tif ((locale == null) && PropsValues.LOCALE_DEFAULT_REQUEST) {\n\t\t\t\t\tlocale = request.getLocale();\n\t\t\t\t}\n\n\t\t\t\t// Get locale from the default user\n\n\t\t\t\tif (locale == null) {\n\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t}\n\n\t\t\t\tif (Validator.isNull(locale.getCountry())) {\n\n\t\t\t\t\t// Locales must contain a country code\n\n\t\t\t\t\tlocale = LanguageUtil.getLocale(locale.getLanguage());\n\t\t\t\t}\n\n\t\t\t\tif (!LanguageUtil.isAvailableLocale(locale)) {\n\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsession.setAttribute(Globals.LOCALE_KEY, locale);\n\n\t\t\tLanguageUtil.updateCookie(request, response, locale);\n\t\t}\n\n\t\t// Cookie support\n\n\t\ttry {\n\n\t\t\t// LEP-4069\n\n\t\t\tCookieKeys.validateSupportCookie(request);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tCookieKeys.addSupportCookie(request, response);\n\t\t}\n\n\t\t// Time zone\n\n\t\tTimeZone timeZone = user.getTimeZone();\n\n\t\tif (timeZone == null) {\n\t\t\ttimeZone = company.getTimeZone();\n\t\t}\n\n\t\t// Device\n\n\t\tDevice device = (Device)session.getAttribute(WebKeys.DEVICE);\n\n\t\tif (device == null) {\n\t\t\tdevice = DeviceDetectionUtil.detectDevice(request);\n\n\t\t\tsession.setAttribute(WebKeys.DEVICE, device);\n\t\t}\n\n\t\t// Layouts\n\n\t\tif (signedIn) {\n\t\t\tupdateUserLayouts(user);\n\t\t}\n\n\t\tLayout layout = null;\n\t\tList<Layout> layouts = null;\n\n\t\tlong plid = ParamUtil.getLong(request, \"p_l_id\");\n\n\t\tif (plid > 0) {\n\t\t\tlayout = LayoutLocalServiceUtil.getLayout(plid);\n\t\t}\n\t\telse {\n\t\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\t\t\tboolean privateLayout = ParamUtil.getBoolean(\n\t\t\t\trequest, \"privateLayout\");\n\t\t\tlong layoutId = ParamUtil.getLong(request, \"layoutId\");\n\n\t\t\tif ((groupId > 0) && layoutId > 0) {\n\t\t\t\tlayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tgroupId, privateLayout, layoutId);\n\t\t\t}\n\t\t}\n\n\t\tif (layout != null) {\n\t\t\ttry {\n\t\t\t\tGroup group = layout.getGroup();\n\n\t\t\t\tif (!signedIn && PropsValues.AUTH_FORWARD_BY_REDIRECT) {\n\t\t\t\t\trequest.setAttribute(WebKeys.REQUESTED_LAYOUT, layout);\n\t\t\t\t}\n\n\t\t\t\tboolean isViewableGroup = isViewableGroup(\n\t\t\t\t\tuser, layout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tlayout.getLayoutId(), controlPanelCategory,\n\t\t\t\t\tpermissionChecker);\n\n\t\t\t\tif (!isViewableGroup && group.isStagingGroup()) {\n\t\t\t\t\tlayout = null;\n\t\t\t\t}\n\t\t\t\telse if (!isViewableGroup) {\n\t\t\t\t\tsb = new StringBundler(6);\n\n\t\t\t\t\tsb.append(\"User \");\n\t\t\t\t\tsb.append(user.getUserId());\n\t\t\t\t\tsb.append(\" is not allowed to access the \");\n\t\t\t\t\tsb.append(layout.isPrivateLayout() ? \"private\": \"public\");\n\t\t\t\t\tsb.append(\" pages of group \");\n\t\t\t\t\tsb.append(layout.getGroupId());\n\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(sb.toString());\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new PrincipalException(sb.toString());\n\t\t\t\t}\n\t\t\t\telse if (isViewableGroup &&\n\t\t\t\t\t\t!LayoutPermissionUtil.contains(\n\t\t\t\t\t\t\tpermissionChecker, layout, ActionKeys.VIEW)) {\n\n\t\t\t\t\tlayout = null;\n\t\t\t\t}\n\t\t\t\telse if (group.isLayoutPrototype()) {\n\t\t\t\t\tlayouts = new ArrayList<Layout>();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\t\t\t\tif (!group.isControlPanel()) {\n\t\t\t\t\t\tdoAsGroupId = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchLayoutException nsle) {\n\t\t\t}\n\t\t}\n\n\t\tList<Layout> unfilteredLayouts = layouts;\n\n\t\tif (layout == null) {\n\t\t\tObject[] defaultLayout = getDefaultLayout(request, user, signedIn);\n\n\t\t\tlayout = (Layout)defaultLayout[0];\n\t\t\tlayouts = (List<Layout>)defaultLayout[1];\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT_DEFAULT, Boolean.TRUE);\n\t\t}\n\n\t\tObject[] viewableLayouts = getViewableLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts);\n\n\t\tString layoutSetLogo = null;\n\n\t\tlayout = (Layout)viewableLayouts[0];\n\t\tlayouts = (List<Layout>)viewableLayouts[1];\n\n\t\tGroup group = null;\n\n\t\tif (layout != null) {\n\t\t\tgroup = layout.getGroup();\n\n\t\t\tif (!group.isControlPanel()) {\n\t\t\t\trememberVisitedGroupIds(request, group.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\tLayoutTypePortlet layoutTypePortlet = null;\n\n\t\tlayouts = mergeAdditionalLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts);\n\n\t\tLayoutSet layoutSet = null;\n\n\t\tboolean customizedView = SessionParamUtil.getBoolean(\n\t\t\trequest, \"customized_view\", true);\n\n\t\tif (layout != null) {\n\t\t\tlayoutSet = layout.getLayoutSet();\n\n\t\t\tif (company.isCommunityLogo()) {\n\t\t\t\tlong logoId = 0;\n\n\t\t\t\tif (layoutSet.isLogo()) {\n\t\t\t\t\tlogoId = layoutSet.getLogoId();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLayoutSet siblingLayoutSet =\n\t\t\t\t\t\tLayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\t\t\tlayout.getGroupId(), !layout.isPrivateLayout());\n\n\t\t\t\t\tif (siblingLayoutSet.isLogo()) {\n\t\t\t\t\t\tlogoId = siblingLayoutSet.getLogoId();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (logoId > 0) {\n\t\t\t\t\tsb = new StringBundler(5);\n\n\t\t\t\t\tsb.append(imagePath);\n\t\t\t\t\tsb.append(\"/layout_set_logo?img_id=\");\n\t\t\t\t\tsb.append(logoId);\n\t\t\t\t\tsb.append(\"&t=\");\n\t\t\t\t\tsb.append(ImageServletTokenUtil.getToken(logoId));\n\n\t\t\t\t\tlayoutSetLogo = sb.toString();\n\n\t\t\t\t\tImage layoutSetLogoImage =\n\t\t\t\t\t\tImageLocalServiceUtil.getCompanyLogo(logoId);\n\n\t\t\t\t\tcompanyLogo = layoutSetLogo;\n\t\t\t\t\tcompanyLogoHeight = layoutSetLogoImage.getHeight();\n\t\t\t\t\tcompanyLogoWidth = layoutSetLogoImage.getWidth();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplid = layout.getPlid();\n\n\t\t\t// Updates to shared layouts are not reflected until the next time\n\t\t\t// the user logs in because group layouts are cached in the session\n\n\t\t\tlayout = (Layout)layout.clone();\n\n\t\t\tlayoutTypePortlet = (LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\tboolean customizable = layoutTypePortlet.isCustomizable();\n\n\t\t\tif (!customizable ||\n\t\t\t\t(group.isLayoutPrototype() || group.isLayoutSetPrototype())) {\n\n\t\t\t\tcustomizedView = false;\n\t\t\t}\n\n\t\t\tlayoutTypePortlet.setCustomizedView(customizedView);\n\t\t\tlayoutTypePortlet.setUpdatePermission(\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.UPDATE));\n\n\t\t\tif (signedIn && customizable && customizedView &&\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.CUSTOMIZE)) {\n\n\t\t\t\tPortalPreferences portalPreferences =\n\t\t\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(\n\t\t\t\t\t\tcompanyId, user.getUserId(), true);\n\n\t\t\t\tlayoutTypePortlet.setPortalPreferences(portalPreferences);\n\t\t\t}\n\n\t\t\tLayoutClone layoutClone = LayoutCloneFactory.getInstance();\n\n\t\t\tif (layoutClone != null) {\n\t\t\t\tString typeSettings = layoutClone.get(request, plid);\n\n\t\t\t\tif (typeSettings != null) {\n\t\t\t\t\tUnicodeProperties typeSettingsProperties =\n\t\t\t\t\t\tnew UnicodeProperties(true);\n\n\t\t\t\t\ttypeSettingsProperties.load(typeSettings);\n\n\t\t\t\t\tString stateMax = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MAX);\n\t\t\t\t\tString stateMin = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MIN);\n\t\t\t\t\tString modeAbout = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_ABOUT);\n\t\t\t\t\tString modeConfig = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_CONFIG);\n\t\t\t\t\tString modeEdit = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT);\n\t\t\t\t\tString modeEditDefaults =\n\t\t\t\t\t\ttypeSettingsProperties.getProperty(\n\t\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_DEFAULTS);\n\t\t\t\t\tString modeEditGuest = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_GUEST);\n\t\t\t\t\tString modeHelp = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_HELP);\n\t\t\t\t\tString modePreview = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PREVIEW);\n\t\t\t\t\tString modePrint = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PRINT);\n\n\t\t\t\t\tlayoutTypePortlet.setStateMax(stateMax);\n\t\t\t\t\tlayoutTypePortlet.setStateMin(stateMin);\n\t\t\t\t\tlayoutTypePortlet.setModeAbout(modeAbout);\n\t\t\t\t\tlayoutTypePortlet.setModeConfig(modeConfig);\n\t\t\t\t\tlayoutTypePortlet.setModeEdit(modeEdit);\n\t\t\t\t\tlayoutTypePortlet.setModeEditDefaults(modeEditDefaults);\n\t\t\t\t\tlayoutTypePortlet.setModeEditGuest(modeEditGuest);\n\t\t\t\t\tlayoutTypePortlet.setModeHelp(modeHelp);\n\t\t\t\t\tlayoutTypePortlet.setModePreview(modePreview);\n\t\t\t\t\tlayoutTypePortlet.setModePrint(modePrint);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT, layout);\n\t\t\trequest.setAttribute(WebKeys.LAYOUTS, layouts);\n\n\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\tpermissionChecker.setCheckGuest(false);\n\t\t\t}\n\t\t}\n\n\t\t// Scope\n\n\t\tlong scopeGroupId = PortalUtil.getScopeGroupId(request);\n\t\tlong parentGroupId = PortalUtil.getParentGroupId(scopeGroupId);\n\n\t\tTheme theme = null;\n\t\tColorScheme colorScheme = null;\n\n\t\tboolean wapTheme = BrowserSnifferUtil.isWap(request);\n\n\t\tif ((layout != null) && group.isControlPanel()) {\n\t\t\tString themeId = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsKeys.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID);\n\t\t\tString colorSchemeId =\n\t\t\t\tColorSchemeImpl.getDefaultRegularColorSchemeId();\n\n\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\tcompanyId, themeId, wapTheme);\n\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, wapTheme);\n\n\t\t\tif (!wapTheme && theme.isWapTheme()) {\n\t\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tPropsValues.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID, false);\n\t\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, false);\n\t\t\t}\n\t\t}\n\n\t\tboolean themeCssFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"css_fast_load\", PropsValues.THEME_CSS_FAST_LOAD);\n\t\tboolean themeImagesFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"images_fast_load\", PropsValues.THEME_IMAGES_FAST_LOAD);\n\n\t\tboolean themeJsBarebone = PropsValues.JAVASCRIPT_BAREBONE_ENABLED;\n\n\t\tif (themeJsBarebone) {\n\t\t\tif (signedIn) {\n\t\t\t\tthemeJsBarebone = false;\n\t\t\t}\n\t\t}\n\n\t\tboolean themeJsFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"js_fast_load\", PropsValues.JAVASCRIPT_FAST_LOAD);\n\n\t\tString lifecycle = ParamUtil.getString(request, \"p_p_lifecycle\", \"0\");\n\n\t\tlifecycle = ParamUtil.getString(request, \"p_t_lifecycle\", lifecycle);\n\n\t\tboolean isolated = ParamUtil.getBoolean(request, \"p_p_isolated\");\n\n\t\tString facebookCanvasPageURL = (String)request.getAttribute(\n\t\t\tWebKeys.FACEBOOK_CANVAS_PAGE_URL);\n\n\t\tboolean widget = false;\n\n\t\tBoolean widgetObj = (Boolean)request.getAttribute(WebKeys.WIDGET);\n\n\t\tif (widgetObj != null) {\n\t\t\twidget = widgetObj.booleanValue();\n\t\t}\n\n\t\t// Theme display\n\n\t\tThemeDisplay themeDisplay = ThemeDisplayFactory.create();\n\n\t\t// Set the CDN host, portal URL, and Facebook application ID first\n\t\t// because other methods (setLookAndFeel) depend on them being set\n\n\t\tthemeDisplay.setCDNHost(cdnHost);\n\t\tthemeDisplay.setPortalURL(portalURL);\n\t\tthemeDisplay.setFacebookCanvasPageURL(facebookCanvasPageURL);\n\t\tthemeDisplay.setWidget(widget);\n\n\t\tthemeDisplay.setCompany(company);\n\t\tthemeDisplay.setCompanyLogo(companyLogo);\n\t\tthemeDisplay.setCompanyLogoHeight(companyLogoHeight);\n\t\tthemeDisplay.setCompanyLogoWidth(companyLogoWidth);\n\t\tthemeDisplay.setRealCompanyLogo(realCompanyLogo);\n\t\tthemeDisplay.setRealCompanyLogoHeight(realCompanyLogoHeight);\n\t\tthemeDisplay.setRealCompanyLogoWidth(realCompanyLogoWidth);\n\t\tthemeDisplay.setUser(user);\n\t\tthemeDisplay.setRealUser(realUser);\n\t\tthemeDisplay.setDoAsUserId(doAsUserId);\n\t\tthemeDisplay.setDoAsUserLanguageId(doAsUserLanguageId);\n\t\tthemeDisplay.setDoAsGroupId(doAsGroupId);\n\t\tthemeDisplay.setRefererPlid(refererPlid);\n\t\tthemeDisplay.setControlPanelCategory(controlPanelCategory);\n\t\tthemeDisplay.setLayoutSet(layoutSet);\n\t\tthemeDisplay.setLayoutSetLogo(layoutSetLogo);\n\t\tthemeDisplay.setLayout(layout);\n\t\tthemeDisplay.setLayouts(layouts);\n\t\tthemeDisplay.setUnfilteredLayouts(unfilteredLayouts);\n\t\tthemeDisplay.setPlid(plid);\n\t\tthemeDisplay.setLayoutTypePortlet(layoutTypePortlet);\n\t\tthemeDisplay.setScopeGroupId(scopeGroupId);\n\t\tthemeDisplay.setParentGroupId(parentGroupId);\n\t\tthemeDisplay.setSignedIn(signedIn);\n\t\tthemeDisplay.setPermissionChecker(permissionChecker);\n\t\tthemeDisplay.setLocale(locale);\n\t\tthemeDisplay.setLanguageId(LocaleUtil.toLanguageId(locale));\n\t\tthemeDisplay.setI18nLanguageId(i18nLanguageId);\n\t\tthemeDisplay.setI18nPath(i18nPath);\n\t\tthemeDisplay.setTimeZone(timeZone);\n\t\tthemeDisplay.setDevice(device);\n\n\t\tif (theme != null) {\n\t\t\trequest.setAttribute(WebKeys.THEME, theme);\n\t\t\trequest.setAttribute(WebKeys.COLOR_SCHEME, colorScheme);\n\n\t\t\tthemeDisplay.setLookAndFeel(contextPath, theme, colorScheme);\n\t\t}\n\n\t\tthemeDisplay.setThemeCssFastLoad(themeCssFastLoad);\n\t\tthemeDisplay.setThemeImagesFastLoad(themeImagesFastLoad);\n\t\tthemeDisplay.setThemeJsBarebone(themeJsBarebone);\n\t\tthemeDisplay.setThemeJsFastLoad(themeJsFastLoad);\n\t\tthemeDisplay.setServerName(request.getServerName());\n\t\tthemeDisplay.setServerPort(request.getServerPort());\n\t\tthemeDisplay.setSecure(PortalUtil.isSecure(request));\n\t\tthemeDisplay.setLifecycle(lifecycle);\n\t\tthemeDisplay.setLifecycleAction(lifecycle.equals(\"1\"));\n\t\tthemeDisplay.setLifecycleRender(lifecycle.equals(\"0\"));\n\t\tthemeDisplay.setLifecycleResource(lifecycle.equals(\"2\"));\n\t\tthemeDisplay.setStateExclusive(LiferayWindowState.isExclusive(request));\n\t\tthemeDisplay.setStateMaximized(LiferayWindowState.isMaximized(request));\n\t\tthemeDisplay.setStatePopUp(LiferayWindowState.isPopUp(request));\n\t\tthemeDisplay.setIsolated(isolated);\n\t\tthemeDisplay.setPathApplet(contextPath.concat(\"/applets\"));\n\t\tthemeDisplay.setPathCms(contextPath.concat(\"/cms\"));\n\t\tthemeDisplay.setPathContext(contextPath);\n\t\tthemeDisplay.setPathFlash(contextPath.concat(\"/flash\"));\n\t\tthemeDisplay.setPathFriendlyURLPrivateGroup(\n\t\t\tfriendlyURLPrivateGroupPath);\n\t\tthemeDisplay.setPathFriendlyURLPrivateUser(friendlyURLPrivateUserPath);\n\t\tthemeDisplay.setPathFriendlyURLPublic(friendlyURLPublicPath);\n\t\tthemeDisplay.setPathImage(imagePath);\n\t\tthemeDisplay.setPathJavaScript(\n\t\t\tcdnHost.concat(contextPath).concat(\"/html/js\"));\n\t\tthemeDisplay.setPathMain(mainPath);\n\t\tthemeDisplay.setPathSound(contextPath.concat(\"/html/sound\"));\n\n\t\t// Icons\n\n\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\tthemeDisplay.setShowControlPanelIcon(signedIn);\n\t\tthemeDisplay.setShowHomeIcon(true);\n\t\tthemeDisplay.setShowMyAccountIcon(signedIn);\n\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\tthemeDisplay.setShowPortalIcon(true);\n\t\tthemeDisplay.setShowSignInIcon(!signedIn);\n\t\tthemeDisplay.setShowSignOutIcon(signedIn);\n\n\t\tboolean showSiteContentIcon = false;\n\n\t\tlong controlPanelPlid = 0;\n\n\t\tif (signedIn) {\n\t\t\tGroup controlPanelGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\tcompanyId, GroupConstants.CONTROL_PANEL);\n\n\t\t\tcontrolPanelPlid = LayoutLocalServiceUtil.getDefaultPlid(\n\t\t\t\tcontrolPanelGroup.getGroupId(), true);\n\n\t\t\tList<Portlet> siteContentPortlets =\n\t\t\t\tPortalUtil.getControlPanelPortlets(\n\t\t\t\t\tPortletCategoryKeys.CONTENT, themeDisplay);\n\n\t\t\tPortlet groupPagesPortlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\tPortletKeys.GROUP_PAGES);\n\t\t\tPortlet siteSettingsPortlet =\n\t\t\t\tPortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tPortletKeys.SITE_SETTINGS);\n\n\t\t\tsiteContentPortlets.remove(groupPagesPortlet);\n\t\t\tsiteContentPortlets.remove(siteSettingsPortlet);\n\n\t\t\tshowSiteContentIcon = PortletPermissionUtil.contains(\n\t\t\t\tpermissionChecker, controlPanelGroup.getGroupId(),\n\t\t\t\tcontrolPanelPlid, siteContentPortlets, ActionKeys.VIEW);\n\t\t}\n\n\t\tthemeDisplay.setShowSiteContentIcon(showSiteContentIcon);\n\n\t\tthemeDisplay.setShowStagingIcon(false);\n\n\t\t// Session\n\n\t\tif (!CookieKeys.hasSessionId(request)) {\n\t\t\tthemeDisplay.setAddSessionIdToURL(true);\n\t\t\tthemeDisplay.setSessionId(session.getId());\n\t\t}\n\n\t\t// URLs\n\n\t\tString urlControlPanel = friendlyURLPrivateGroupPath.concat(\n\t\t\tGroupConstants.CONTROL_PANEL_FRIENDLY_URL);\n\n\t\tif (Validator.isNotNull(doAsUserId)) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"doAsUserId\", doAsUserId);\n\t\t}\n\n\t\tif (scopeGroupId > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"doAsGroupId\", scopeGroupId);\n\t\t}\n\n\t\tif (refererPlid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", refererPlid);\n\t\t}\n\t\telse if (plid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", plid);\n\t\t}\n\n\t\tif (themeDisplay.isAddSessionIdToURL()) {\n\t\t\turlControlPanel = PortalUtil.getURLWithSessionId(\n\t\t\t\turlControlPanel, session.getId());\n\t\t}\n\n\t\tthemeDisplay.setURLControlPanel(urlControlPanel);\n\n\t\tString siteContentURL = urlControlPanel;\n\n\t\tsiteContentURL = HttpUtil.addParameter(\n\t\t\tsiteContentURL, \"p_p_id\", PortletKeys.RECENT_CONTENT);\n\t\tsiteContentURL = HttpUtil.addParameter(\n\t\t\tsiteContentURL, \"controlPanelCategory\",\n\t\t\tPortletCategoryKeys.CONTENT);\n\n\t\tthemeDisplay.setURLSiteContent(siteContentURL);\n\n\t\tPortletURL createAccountURL = new PortletURLImpl(\n\t\t\trequest, PortletKeys.LOGIN, plid, PortletRequest.ACTION_PHASE);\n\n\t\tcreateAccountURL.setWindowState(WindowState.MAXIMIZED);\n\t\tcreateAccountURL.setPortletMode(PortletMode.VIEW);\n\n\t\tcreateAccountURL.setParameter(\"saveLastPath\", \"0\");\n\t\tcreateAccountURL.setParameter(\n\t\t\t\"struts_action\", \"/login/create_account\");\n\n\t\tthemeDisplay.setURLCreateAccount(createAccountURL);\n\n\t\tString currentURL = PortalUtil.getCurrentURL(request);\n\n\t\tthemeDisplay.setURLCurrent(currentURL);\n\n\t\tString urlHome = PortalUtil.getHomeURL(request);\n\n\t\tthemeDisplay.setURLHome(urlHome);\n\n\t\tif (layout != null) {\n\t\t\tif (layout.isTypePortlet()) {\n\t\t\t\tboolean freeformLayout =\n\t\t\t\t\tlayoutTypePortlet.getLayoutTemplateId().equals(\n\t\t\t\t\t\t\"freeform\");\n\n\t\t\t\tthemeDisplay.setFreeformLayout(freeformLayout);\n\n\t\t\t\tboolean hasUpdateLayoutPermission =\n\t\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, layout, ActionKeys.UPDATE);\n\n\t\t\t\tif (hasUpdateLayoutPermission) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(true);\n\t\t\t\t\tthemeDisplay.setShowPageCustomizationIcon(true);\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.toggle('\".concat(\n\t\t\t\t\t\t\tPortletKeys.LAYOUT_CONFIGURATION).concat(\"');\"));\n\n\t\t\t\t\tthemeDisplay.setURLLayoutTemplates(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.showTemplates();\");\n\t\t\t\t}\n\n\t\t\t\tboolean hasCustomizePermission = LayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.CUSTOMIZE);\n\n\t\t\t\tif (hasCustomizePermission && customizedView) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.toggle('\".concat(\n\t\t\t\t\t\t\tPortletKeys.LAYOUT_CONFIGURATION).concat(\"');\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean hasManageLayoutsPermission = false;\n\n\t\t\tif (signedIn) {\n\t\t\t\thasManageLayoutsPermission = GroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, scopeGroupId, ActionKeys.MANAGE_LAYOUTS);\n\n\t\t\t\tif (group.isUser()) {\n\t\t\t\t\tif ((layout.isPrivateLayout() &&\n\t\t\t\t\t\t !PropsValues.LAYOUT_USER_PRIVATE_LAYOUTS_MODIFIABLE) ||\n\t\t\t\t\t\t(layout.isPublicLayout() &&\n\t\t\t\t\t\t !PropsValues.LAYOUT_USER_PUBLIC_LAYOUTS_MODIFIABLE)) {\n\n\t\t\t\t\t\thasManageLayoutsPermission = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasManageLayoutsPermission) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\n\t\t\t\tPortletURL pageSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tpageSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tpageSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/layouts_admin/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tpageSettingsURL.setParameter(\"selPlid\", String.valueOf(plid));\n\n\t\t\t\tthemeDisplay.setURLPageSettings(pageSettingsURL);\n\n\t\t\t\tif (group.isSite()) {\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(true);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(false);\n\t\t\t\t}\n\n\t\t\t\tPortletURL manageSiteMembershipsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.SITE_MEMBERSHIPS_ADMIN,\n\t\t\t\t\tcontrolPanelPlid, PortletRequest.RENDER_PHASE);\n\n\t\t\t\tmanageSiteMembershipsURL.setWindowState(\n\t\t\t\t\tLiferayWindowState.POP_UP);\n\t\t\t\tmanageSiteMembershipsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site_assignments\");\n\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\n\t\t\t\tthemeDisplay.setURLManageSiteMemberships(\n\t\t\t\t\tmanageSiteMembershipsURL);\n\t\t\t}\n\n\t\t\tif (!group.isControlPanel() && !group.isUser() &&\n\t\t\t\t!group.isUserGroup() &&\n\t\t\t\t(GroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, group.getGroupId(),\n\t\t\t\t\tActionKeys.MANAGE_STAGING) ||\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, group.getGroupId(),\n\t\t\t\t\tActionKeys.UPDATE))) {\n\n\t\t\t\tthemeDisplay.setShowSiteSettingsIcon(true);\n\n\t\t\t\tPortletURL siteSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.SITE_SETTINGS, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tsiteSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/site_settings/edit_settings\");\n\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\n\t\t\t\tthemeDisplay.setURLSiteSettings(siteSettingsURL);\n\t\t\t}\n\n\t\t\tif (hasManageLayoutsPermission && !group.isLayoutPrototype()) {\n\t\t\t\tthemeDisplay.setShowSiteMapSettingsIcon(true);\n\n\t\t\t\tPortletURL siteMapSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteMapSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tsiteMapSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/layouts_admin/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\n\t\t\t\tthemeDisplay.setURLSiteMapSettings(siteMapSettingsURL);\n\t\t\t}\n\n\t\t\tif (group.hasStagingGroup() && !group.isStagingGroup()) {\n\t\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(false);\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\tif (group.isControlPanel()) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\t// LEP-4987\n\n\t\t\tif (group.isStaged() || group.isStagingGroup()) {\n\t\t\t\tboolean hasPublishStagingPermission =\n\t\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, scopeGroupId,\n\t\t\t\t\t\tActionKeys.PUBLISH_STAGING);\n\n\t\t\t\tif (hasManageLayoutsPermission || hasPublishStagingPermission) {\n\t\t\t\t\tthemeDisplay.setShowStagingIcon(true);\n\t\t\t\t}\n\n\t\t\t\tif (hasPublishStagingPermission) {\n\t\t\t\t\tPortletURL publishToLiveURL = new PortletURLImpl(\n\t\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, plid,\n\t\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\t\tpublishToLiveURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.EXCLUSIVE);\n\t\t\t\t\tpublishToLiveURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/layouts_admin/publish_layouts\");\n\n\t\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t\t}\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\"pagesRedirect\", currentURL);\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\n\t\t\t\t\tthemeDisplay.setURLPublishToLive(publishToLiveURL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPortletURLImpl myAccountURL = new PortletURLImpl(\n\t\t\t\trequest, PortletKeys.MY_ACCOUNT, controlPanelPlid,\n\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\tmyAccountURL.setWindowState(WindowState.MAXIMIZED);\n\t\t\tmyAccountURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\tif (scopeGroupId > 0) {\n\t\t\t\tmyAccountURL.setDoAsGroupId(scopeGroupId);\n\t\t\t}\n\n\t\t\tif (refererPlid > 0) {\n\t\t\t\tmyAccountURL.setRefererPlid(refererPlid);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmyAccountURL.setRefererPlid(plid);\n\t\t\t}\n\n\t\t\tmyAccountURL.setControlPanelCategory(PortletCategoryKeys.MY);\n\n\t\t\tmyAccountURL.setParameter(\"struts_action\", \"/my_account/edit_user\");\n\n\t\t\tthemeDisplay.setURLMyAccount(myAccountURL);\n\t\t}\n\n\t\tif ((!user.isActive()) ||\n\t\t\t(PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.TERMS_OF_USE_REQUIRED) &&\n\t\t\t !user.isAgreedToTermsOfUse())) {\n\n\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t}\n\n\t\tif (group.isLayoutPrototype()) {\n\t\t\tthemeDisplay.setShowControlPanelIcon(false);\n\t\t\tthemeDisplay.setShowHomeIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\t\t\tthemeDisplay.setShowPortalIcon(false);\n\t\t\tthemeDisplay.setShowSignInIcon(false);\n\t\t\tthemeDisplay.setShowSignOutIcon(false);\n\t\t\tthemeDisplay.setShowSiteContentIcon(false);\n\t\t\tthemeDisplay.setShowStagingIcon(false);\n\t\t}\n\n\t\tthemeDisplay.setURLPortal(portalURL.concat(contextPath));\n\n\t\tString urlSignIn = mainPath.concat(\"/portal/login\");\n\n\t\tif (layout != null) {\n\t\t\turlSignIn = HttpUtil.addParameter(\n\t\t\t\turlSignIn, \"p_l_id\", layout.getPlid());\n\t\t}\n\n\t\tthemeDisplay.setURLSignIn(urlSignIn);\n\n\t\tthemeDisplay.setURLSignOut(mainPath.concat(\"/portal/logout\"));\n\n\t\tPortletURL updateManagerURL = new PortletURLImpl(\n\t\t\trequest, PortletKeys.UPDATE_MANAGER, plid,\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tupdateManagerURL.setWindowState(WindowState.MAXIMIZED);\n\t\tupdateManagerURL.setPortletMode(PortletMode.VIEW);\n\n\t\tupdateManagerURL.setParameter(\"struts_action\", \"/update_manager/view\");\n\n\t\tthemeDisplay.setURLUpdateManager(updateManagerURL);\n\n\t\trequest.setAttribute(WebKeys.THEME_DISPLAY, themeDisplay);\n\n\t\t// Service context\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\trequest);\n\n\t\tServiceContextThreadLocal.pushServiceContext(serviceContext);\n\n\t\t// Parallel render\n\n\t\tboolean parallelRenderEnable = true;\n\n\t\tif (layout != null) {\n\t\t\tList<String> portletIds = layoutTypePortlet.getPortletIds();\n\n\t\t\tif (portletIds.size() == 1) {\n\t\t\t\tString portletId = portletIds.get(0);\n\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tportletId);\n\n\t\t\t\tif ((portlet != null) && !portlet.isAjaxable()) {\n\t\t\t\t\tparallelRenderEnable = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tBoolean parallelRenderEnableObj = Boolean.valueOf(ParamUtil.getBoolean(\n\t\t\trequest, \"p_p_parallel\", parallelRenderEnable));\n\n\t\trequest.setAttribute(\n\t\t\tWebKeys.PORTLET_PARALLEL_RENDER, parallelRenderEnableObj);\n\n\t\t// Main Journal article\n\n\t\tlong mainJournalArticleId = ParamUtil.getLong(\n\t\t\trequest, \"p_j_a_id\");\n\n\t\tif (mainJournalArticleId > 0) {\n\t\t\ttry{\n\t\t\t\tJournalArticle mainJournalArticle =\n\t\t\t\t\tJournalArticleServiceUtil.getArticle(mainJournalArticleId);\n\n\t\t\t\tthemeDisplay.setMainJournalArticle(mainJournalArticle);\n\t\t\t}\n\t\t\tcatch (NoSuchArticleException nsae) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(nsae.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":23321,"modified_method":"protected void servicePre(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tHttpSession session = request.getSession();\n\n\t\t// Company\n\n\t\tCompany company = PortalUtil.getCompany(request);\n\n\t\tlong companyId = company.getCompanyId();\n\n\t\t// CDN host\n\n\t\tString cdnHost = null;\n\n\t\tif (request.isSecure()) {\n\t\t\tcdnHost = PortalUtil.getCDNHostHttps();\n\t\t}\n\t\telse {\n\t\t\tcdnHost = PortalUtil.getCDNHostHttp();\n\t\t}\n\n\t\tcdnHost = ParamUtil.getString(request, \"cdn_host\", cdnHost);\n\n\t\t// Portal URL\n\n\t\tString portalURL = PortalUtil.getPortalURL(request);\n\n\t\t// Paths\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\t\tString friendlyURLPrivateGroupPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateGroup();\n\t\tString friendlyURLPrivateUserPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateUser();\n\t\tString friendlyURLPublicPath = PortalUtil.getPathFriendlyURLPublic();\n\t\tString imagePath = cdnHost.concat(PortalUtil.getPathImage());\n\t\tString mainPath = PortalUtil.getPathMain();\n\n\t\tString i18nPath = (String)request.getAttribute(WebKeys.I18N_PATH);\n\n\t\tif (Validator.isNotNull(i18nPath)) {\n\t\t\tif (Validator.isNotNull(contextPath)) {\n\t\t\t\tString i18nContextPath = contextPath.concat(i18nPath);\n\n\t\t\t\tfriendlyURLPrivateGroupPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateGroupPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPrivateUserPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateUserPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPublicPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPublicPath, contextPath, i18nContextPath);\n\t\t\t\tmainPath = StringUtil.replaceFirst(\n\t\t\t\t\tmainPath, contextPath, i18nContextPath);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfriendlyURLPrivateGroupPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateGroupPath);\n\t\t\t\tfriendlyURLPrivateUserPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateUserPath);\n\t\t\t\tfriendlyURLPublicPath = i18nPath.concat(friendlyURLPublicPath);\n\t\t\t\tmainPath = i18nPath.concat(mainPath);\n\t\t\t}\n\t\t}\n\n\t\t// Company logo\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(imagePath);\n\t\tsb.append(\"/company_logo?img_id=\");\n\t\tsb.append(company.getLogoId());\n\t\tsb.append(\"&t=\");\n\t\tsb.append(ImageServletTokenUtil.getToken(company.getLogoId()));\n\n\t\tString companyLogo = sb.toString();\n\n\t\tint companyLogoHeight = 0;\n\t\tint companyLogoWidth = 0;\n\n\t\tImage companyLogoImage = ImageLocalServiceUtil.getCompanyLogo(\n\t\t\tcompany.getLogoId());\n\n\t\tif (companyLogoImage != null) {\n\t\t\tcompanyLogoHeight = companyLogoImage.getHeight();\n\t\t\tcompanyLogoWidth = companyLogoImage.getWidth();\n\t\t}\n\n\t\tString realCompanyLogo = companyLogo;\n\t\tint realCompanyLogoHeight = companyLogoHeight;\n\t\tint realCompanyLogoWidth = companyLogoWidth;\n\n\t\t// User\n\n\t\tUser user = null;\n\n\t\ttry {\n\t\t\tuser = PortalUtil.getUser(request);\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(nsue.getMessage());\n\t\t\t}\n\n\t\t\tlong userId = PortalUtil.getUserId(request);\n\n\t\t\tif (userId > 0) {\n\t\t\t\tsession.invalidate();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tboolean signedIn = false;\n\n\t\tif (user == null) {\n\t\t\tuser = company.getDefaultUser();\n\t\t}\n\t\telse if (!user.isDefaultUser()) {\n\t\t\tsignedIn = true;\n\t\t}\n\n\t\tif (PropsValues.BROWSER_CACHE_SIGNED_IN_DISABLED && signedIn) {\n\t\t\tresponse.setDateHeader(HttpHeaders.EXPIRES, 0);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.CACHE_CONTROL,\n\t\t\t\tHttpHeaders.CACHE_CONTROL_NO_CACHE_VALUE);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.PRAGMA, HttpHeaders.PRAGMA_NO_CACHE_VALUE);\n\t\t}\n\n\t\tUser realUser = user;\n\n\t\tLong realUserId = (Long)session.getAttribute(WebKeys.USER_ID);\n\n\t\tif (realUserId != null) {\n\t\t\tif (user.getUserId() != realUserId.longValue()) {\n\t\t\t\trealUser = UserLocalServiceUtil.getUserById(\n\t\t\t\t\trealUserId.longValue());\n\t\t\t}\n\t\t}\n\n\t\tString doAsUserId = ParamUtil.getString(request, \"doAsUserId\");\n\t\tString doAsUserLanguageId = ParamUtil.getString(\n\t\t\trequest, \"doAsUserLanguageId\");\n\t\tlong doAsGroupId = ParamUtil.getLong(request, \"doAsGroupId\");\n\t\tlong refererPlid = ParamUtil.getLong(request, \"refererPlid\");\n\t\tString controlPanelCategory = ParamUtil.getString(\n\t\t\trequest, \"controlPanelCategory\");\n\n\t\t// Permission checker\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tPermissionCheckerFactoryUtil.create(user, true);\n\n\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t// Locale\n\n\t\tLocale locale = (Locale)session.getAttribute(Globals.LOCALE_KEY);\n\n\t\tif (Validator.isNotNull(doAsUserLanguageId)) {\n\t\t\tlocale = LocaleUtil.fromLanguageId(doAsUserLanguageId);\n\t\t}\n\n\t\tString i18nLanguageId = (String)request.getAttribute(\n\t\t\tWebKeys.I18N_LANGUAGE_ID);\n\n\t\tif (Validator.isNotNull(i18nLanguageId)) {\n\t\t\tlocale = LocaleUtil.fromLanguageId(i18nLanguageId);\n\t\t}\n\t\telse if (locale == null) {\n\t\t\tif (signedIn) {\n\t\t\t\tlocale = user.getLocale();\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// User previously set their preferred language\n\n\t\t\t\tString languageId = CookieKeys.getCookie(\n\t\t\t\t\trequest, CookieKeys.GUEST_LANGUAGE_ID);\n\n\t\t\t\tif (Validator.isNotNull(languageId)) {\n\t\t\t\t\tlocale = LocaleUtil.fromLanguageId(languageId);\n\t\t\t\t}\n\n\t\t\t\t// Get locale from the request\n\n\t\t\t\tif ((locale == null) && PropsValues.LOCALE_DEFAULT_REQUEST) {\n\t\t\t\t\tlocale = request.getLocale();\n\t\t\t\t}\n\n\t\t\t\t// Get locale from the default user\n\n\t\t\t\tif (locale == null) {\n\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t}\n\n\t\t\t\tif (Validator.isNull(locale.getCountry())) {\n\n\t\t\t\t\t// Locales must contain a country code\n\n\t\t\t\t\tlocale = LanguageUtil.getLocale(locale.getLanguage());\n\t\t\t\t}\n\n\t\t\t\tif (!LanguageUtil.isAvailableLocale(locale)) {\n\t\t\t\t\tlocale = user.getLocale();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsession.setAttribute(Globals.LOCALE_KEY, locale);\n\n\t\t\tLanguageUtil.updateCookie(request, response, locale);\n\t\t}\n\n\t\t// Cookie support\n\n\t\ttry {\n\n\t\t\t// LEP-4069\n\n\t\t\tCookieKeys.validateSupportCookie(request);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tCookieKeys.addSupportCookie(request, response);\n\t\t}\n\n\t\t// Time zone\n\n\t\tTimeZone timeZone = user.getTimeZone();\n\n\t\tif (timeZone == null) {\n\t\t\ttimeZone = company.getTimeZone();\n\t\t}\n\n\t\t// Device\n\n\t\tDevice device = (Device)session.getAttribute(WebKeys.DEVICE);\n\n\t\tif (device == null) {\n\t\t\tdevice = DeviceDetectionUtil.detectDevice(request);\n\n\t\t\tsession.setAttribute(WebKeys.DEVICE, device);\n\t\t}\n\n\t\t// Layouts\n\n\t\tif (signedIn) {\n\t\t\tupdateUserLayouts(user);\n\t\t}\n\n\t\tLayout layout = null;\n\t\tList<Layout> layouts = null;\n\n\t\tlong plid = ParamUtil.getLong(request, \"p_l_id\");\n\n\t\tif (plid > 0) {\n\t\t\tlayout = LayoutLocalServiceUtil.getLayout(plid);\n\t\t}\n\t\telse {\n\t\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\t\t\tboolean privateLayout = ParamUtil.getBoolean(\n\t\t\t\trequest, \"privateLayout\");\n\t\t\tlong layoutId = ParamUtil.getLong(request, \"layoutId\");\n\n\t\t\tif ((groupId > 0) && layoutId > 0) {\n\t\t\t\tlayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tgroupId, privateLayout, layoutId);\n\t\t\t}\n\t\t}\n\n\t\tif (layout != null) {\n\t\t\ttry {\n\t\t\t\tGroup group = layout.getGroup();\n\n\t\t\t\tif (!signedIn && PropsValues.AUTH_FORWARD_BY_REDIRECT) {\n\t\t\t\t\trequest.setAttribute(WebKeys.REQUESTED_LAYOUT, layout);\n\t\t\t\t}\n\n\t\t\t\tboolean isViewableGroup = isViewableGroup(\n\t\t\t\t\tuser, layout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tlayout.getLayoutId(), controlPanelCategory,\n\t\t\t\t\tpermissionChecker);\n\n\t\t\t\tif (!isViewableGroup && group.isStagingGroup()) {\n\t\t\t\t\tlayout = null;\n\t\t\t\t}\n\t\t\t\telse if (!isViewableGroup) {\n\t\t\t\t\tsb = new StringBundler(6);\n\n\t\t\t\t\tsb.append(\"User \");\n\t\t\t\t\tsb.append(user.getUserId());\n\t\t\t\t\tsb.append(\" is not allowed to access the \");\n\t\t\t\t\tsb.append(layout.isPrivateLayout() ? \"private\": \"public\");\n\t\t\t\t\tsb.append(\" pages of group \");\n\t\t\t\t\tsb.append(layout.getGroupId());\n\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(sb.toString());\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new PrincipalException(sb.toString());\n\t\t\t\t}\n\t\t\t\telse if (isViewableGroup &&\n\t\t\t\t\t\t!LayoutPermissionUtil.contains(\n\t\t\t\t\t\t\tpermissionChecker, layout, ActionKeys.VIEW)) {\n\n\t\t\t\t\tlayout = null;\n\t\t\t\t}\n\t\t\t\telse if (group.isLayoutPrototype()) {\n\t\t\t\t\tlayouts = new ArrayList<Layout>();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\t\t\t\tif (!group.isControlPanel()) {\n\t\t\t\t\t\tdoAsGroupId = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchLayoutException nsle) {\n\t\t\t}\n\t\t}\n\n\t\tList<Layout> unfilteredLayouts = layouts;\n\n\t\tif (layout == null) {\n\t\t\tObject[] defaultLayout = getDefaultLayout(request, user, signedIn);\n\n\t\t\tlayout = (Layout)defaultLayout[0];\n\t\t\tlayouts = (List<Layout>)defaultLayout[1];\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT_DEFAULT, Boolean.TRUE);\n\t\t}\n\n\t\tObject[] viewableLayouts = getViewableLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts);\n\n\t\tString layoutSetLogo = null;\n\n\t\tlayout = (Layout)viewableLayouts[0];\n\t\tlayouts = (List<Layout>)viewableLayouts[1];\n\n\t\tGroup group = null;\n\n\t\tif (layout != null) {\n\t\t\tgroup = layout.getGroup();\n\n\t\t\tif (!group.isControlPanel()) {\n\t\t\t\trememberVisitedGroupIds(request, group.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\tLayoutTypePortlet layoutTypePortlet = null;\n\n\t\tlayouts = mergeAdditionalLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts);\n\n\t\tLayoutSet layoutSet = null;\n\n\t\tboolean customizedView = SessionParamUtil.getBoolean(\n\t\t\trequest, \"customized_view\", true);\n\n\t\tif (layout != null) {\n\t\t\tlayoutSet = layout.getLayoutSet();\n\n\t\t\tif (company.isCommunityLogo()) {\n\t\t\t\tlong logoId = 0;\n\n\t\t\t\tif (layoutSet.isLogo()) {\n\t\t\t\t\tlogoId = layoutSet.getLogoId();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLayoutSet siblingLayoutSet =\n\t\t\t\t\t\tLayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\t\t\tlayout.getGroupId(), !layout.isPrivateLayout());\n\n\t\t\t\t\tif (siblingLayoutSet.isLogo()) {\n\t\t\t\t\t\tlogoId = siblingLayoutSet.getLogoId();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (logoId > 0) {\n\t\t\t\t\tsb = new StringBundler(5);\n\n\t\t\t\t\tsb.append(imagePath);\n\t\t\t\t\tsb.append(\"/layout_set_logo?img_id=\");\n\t\t\t\t\tsb.append(logoId);\n\t\t\t\t\tsb.append(\"&t=\");\n\t\t\t\t\tsb.append(ImageServletTokenUtil.getToken(logoId));\n\n\t\t\t\t\tlayoutSetLogo = sb.toString();\n\n\t\t\t\t\tImage layoutSetLogoImage =\n\t\t\t\t\t\tImageLocalServiceUtil.getCompanyLogo(logoId);\n\n\t\t\t\t\tcompanyLogo = layoutSetLogo;\n\t\t\t\t\tcompanyLogoHeight = layoutSetLogoImage.getHeight();\n\t\t\t\t\tcompanyLogoWidth = layoutSetLogoImage.getWidth();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplid = layout.getPlid();\n\n\t\t\t// Updates to shared layouts are not reflected until the next time\n\t\t\t// the user logs in because group layouts are cached in the session\n\n\t\t\tlayout = (Layout)layout.clone();\n\n\t\t\tlayoutTypePortlet = (LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\tboolean customizable = layoutTypePortlet.isCustomizable();\n\n\t\t\tif (!customizable ||\n\t\t\t\t(group.isLayoutPrototype() || group.isLayoutSetPrototype())) {\n\n\t\t\t\tcustomizedView = false;\n\t\t\t}\n\n\t\t\tlayoutTypePortlet.setCustomizedView(customizedView);\n\t\t\tlayoutTypePortlet.setUpdatePermission(\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.UPDATE));\n\n\t\t\tif (signedIn && customizable && customizedView &&\n\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.CUSTOMIZE)) {\n\n\t\t\t\tPortalPreferences portalPreferences =\n\t\t\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(\n\t\t\t\t\t\tcompanyId, user.getUserId(), true);\n\n\t\t\t\tlayoutTypePortlet.setPortalPreferences(portalPreferences);\n\t\t\t}\n\n\t\t\tLayoutClone layoutClone = LayoutCloneFactory.getInstance();\n\n\t\t\tif (layoutClone != null) {\n\t\t\t\tString typeSettings = layoutClone.get(request, plid);\n\n\t\t\t\tif (typeSettings != null) {\n\t\t\t\t\tUnicodeProperties typeSettingsProperties =\n\t\t\t\t\t\tnew UnicodeProperties(true);\n\n\t\t\t\t\ttypeSettingsProperties.load(typeSettings);\n\n\t\t\t\t\tString stateMax = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MAX);\n\t\t\t\t\tString stateMin = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MIN);\n\t\t\t\t\tString modeAbout = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_ABOUT);\n\t\t\t\t\tString modeConfig = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_CONFIG);\n\t\t\t\t\tString modeEdit = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT);\n\t\t\t\t\tString modeEditDefaults =\n\t\t\t\t\t\ttypeSettingsProperties.getProperty(\n\t\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_DEFAULTS);\n\t\t\t\t\tString modeEditGuest = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_GUEST);\n\t\t\t\t\tString modeHelp = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_HELP);\n\t\t\t\t\tString modePreview = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PREVIEW);\n\t\t\t\t\tString modePrint = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PRINT);\n\n\t\t\t\t\tlayoutTypePortlet.setStateMax(stateMax);\n\t\t\t\t\tlayoutTypePortlet.setStateMin(stateMin);\n\t\t\t\t\tlayoutTypePortlet.setModeAbout(modeAbout);\n\t\t\t\t\tlayoutTypePortlet.setModeConfig(modeConfig);\n\t\t\t\t\tlayoutTypePortlet.setModeEdit(modeEdit);\n\t\t\t\t\tlayoutTypePortlet.setModeEditDefaults(modeEditDefaults);\n\t\t\t\t\tlayoutTypePortlet.setModeEditGuest(modeEditGuest);\n\t\t\t\t\tlayoutTypePortlet.setModeHelp(modeHelp);\n\t\t\t\t\tlayoutTypePortlet.setModePreview(modePreview);\n\t\t\t\t\tlayoutTypePortlet.setModePrint(modePrint);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT, layout);\n\t\t\trequest.setAttribute(WebKeys.LAYOUTS, layouts);\n\n\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\tpermissionChecker.setCheckGuest(false);\n\t\t\t}\n\t\t}\n\n\t\t// Scope\n\n\t\tlong scopeGroupId = PortalUtil.getScopeGroupId(request);\n\t\tlong parentGroupId = PortalUtil.getParentGroupId(scopeGroupId);\n\n\t\t// Theme and color scheme\n\n\t\tTheme theme = null;\n\t\tColorScheme colorScheme = null;\n\n\t\tboolean wapTheme = BrowserSnifferUtil.isWap(request);\n\n\t\tif ((layout != null) && group.isControlPanel()) {\n\t\t\tString themeId = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsKeys.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID);\n\t\t\tString colorSchemeId =\n\t\t\t\tColorSchemeImpl.getDefaultRegularColorSchemeId();\n\n\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\tcompanyId, themeId, wapTheme);\n\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, wapTheme);\n\n\t\t\tif (!wapTheme && theme.isWapTheme()) {\n\t\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tPropsValues.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID, false);\n\t\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, false);\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.THEME, theme);\n\t\t\trequest.setAttribute(WebKeys.COLOR_SCHEME, colorScheme);\n\t\t}\n\n\t\tboolean themeCssFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"css_fast_load\", PropsValues.THEME_CSS_FAST_LOAD);\n\t\tboolean themeImagesFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"images_fast_load\", PropsValues.THEME_IMAGES_FAST_LOAD);\n\n\t\tboolean themeJsBarebone = PropsValues.JAVASCRIPT_BAREBONE_ENABLED;\n\n\t\tif (themeJsBarebone) {\n\t\t\tif (signedIn) {\n\t\t\t\tthemeJsBarebone = false;\n\t\t\t}\n\t\t}\n\n\t\tboolean themeJsFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"js_fast_load\", PropsValues.JAVASCRIPT_FAST_LOAD);\n\n\t\tString lifecycle = ParamUtil.getString(request, \"p_p_lifecycle\", \"0\");\n\n\t\tlifecycle = ParamUtil.getString(request, \"p_t_lifecycle\", lifecycle);\n\n\t\tboolean isolated = ParamUtil.getBoolean(request, \"p_p_isolated\");\n\n\t\tString facebookCanvasPageURL = (String)request.getAttribute(\n\t\t\tWebKeys.FACEBOOK_CANVAS_PAGE_URL);\n\n\t\tboolean widget = false;\n\n\t\tBoolean widgetObj = (Boolean)request.getAttribute(WebKeys.WIDGET);\n\n\t\tif (widgetObj != null) {\n\t\t\twidget = widgetObj.booleanValue();\n\t\t}\n\n\t\t// Theme display\n\n\t\tThemeDisplay themeDisplay = ThemeDisplayFactory.create();\n\n\t\t// Set the CDN host, portal URL, and Facebook application ID first\n\t\t// because other methods (setLookAndFeel) depend on them being set\n\n\t\tthemeDisplay.setCDNHost(cdnHost);\n\t\tthemeDisplay.setPortalURL(portalURL);\n\t\tthemeDisplay.setFacebookCanvasPageURL(facebookCanvasPageURL);\n\t\tthemeDisplay.setWidget(widget);\n\n\t\tthemeDisplay.setCompany(company);\n\t\tthemeDisplay.setCompanyLogo(companyLogo);\n\t\tthemeDisplay.setCompanyLogoHeight(companyLogoHeight);\n\t\tthemeDisplay.setCompanyLogoWidth(companyLogoWidth);\n\t\tthemeDisplay.setRealCompanyLogo(realCompanyLogo);\n\t\tthemeDisplay.setRealCompanyLogoHeight(realCompanyLogoHeight);\n\t\tthemeDisplay.setRealCompanyLogoWidth(realCompanyLogoWidth);\n\t\tthemeDisplay.setUser(user);\n\t\tthemeDisplay.setRealUser(realUser);\n\t\tthemeDisplay.setDoAsUserId(doAsUserId);\n\t\tthemeDisplay.setDoAsUserLanguageId(doAsUserLanguageId);\n\t\tthemeDisplay.setDoAsGroupId(doAsGroupId);\n\t\tthemeDisplay.setRefererPlid(refererPlid);\n\t\tthemeDisplay.setControlPanelCategory(controlPanelCategory);\n\t\tthemeDisplay.setLayoutSet(layoutSet);\n\t\tthemeDisplay.setLayoutSetLogo(layoutSetLogo);\n\t\tthemeDisplay.setLayout(layout);\n\t\tthemeDisplay.setLayouts(layouts);\n\t\tthemeDisplay.setUnfilteredLayouts(unfilteredLayouts);\n\t\tthemeDisplay.setPlid(plid);\n\t\tthemeDisplay.setLayoutTypePortlet(layoutTypePortlet);\n\t\tthemeDisplay.setScopeGroupId(scopeGroupId);\n\t\tthemeDisplay.setParentGroupId(parentGroupId);\n\t\tthemeDisplay.setSignedIn(signedIn);\n\t\tthemeDisplay.setPermissionChecker(permissionChecker);\n\t\tthemeDisplay.setLocale(locale);\n\t\tthemeDisplay.setLanguageId(LocaleUtil.toLanguageId(locale));\n\t\tthemeDisplay.setI18nLanguageId(i18nLanguageId);\n\t\tthemeDisplay.setI18nPath(i18nPath);\n\t\tthemeDisplay.setTimeZone(timeZone);\n\t\tthemeDisplay.setDevice(device);\n\t\tthemeDisplay.setLookAndFeel(contextPath, theme, colorScheme);\n\t\tthemeDisplay.setThemeCssFastLoad(themeCssFastLoad);\n\t\tthemeDisplay.setThemeImagesFastLoad(themeImagesFastLoad);\n\t\tthemeDisplay.setThemeJsBarebone(themeJsBarebone);\n\t\tthemeDisplay.setThemeJsFastLoad(themeJsFastLoad);\n\t\tthemeDisplay.setServerName(request.getServerName());\n\t\tthemeDisplay.setServerPort(request.getServerPort());\n\t\tthemeDisplay.setSecure(PortalUtil.isSecure(request));\n\t\tthemeDisplay.setLifecycle(lifecycle);\n\t\tthemeDisplay.setLifecycleAction(lifecycle.equals(\"1\"));\n\t\tthemeDisplay.setLifecycleRender(lifecycle.equals(\"0\"));\n\t\tthemeDisplay.setLifecycleResource(lifecycle.equals(\"2\"));\n\t\tthemeDisplay.setStateExclusive(LiferayWindowState.isExclusive(request));\n\t\tthemeDisplay.setStateMaximized(LiferayWindowState.isMaximized(request));\n\t\tthemeDisplay.setStatePopUp(LiferayWindowState.isPopUp(request));\n\t\tthemeDisplay.setIsolated(isolated);\n\t\tthemeDisplay.setPathApplet(contextPath.concat(\"/applets\"));\n\t\tthemeDisplay.setPathCms(contextPath.concat(\"/cms\"));\n\t\tthemeDisplay.setPathContext(contextPath);\n\t\tthemeDisplay.setPathFlash(contextPath.concat(\"/flash\"));\n\t\tthemeDisplay.setPathFriendlyURLPrivateGroup(\n\t\t\tfriendlyURLPrivateGroupPath);\n\t\tthemeDisplay.setPathFriendlyURLPrivateUser(friendlyURLPrivateUserPath);\n\t\tthemeDisplay.setPathFriendlyURLPublic(friendlyURLPublicPath);\n\t\tthemeDisplay.setPathImage(imagePath);\n\t\tthemeDisplay.setPathJavaScript(\n\t\t\tcdnHost.concat(contextPath).concat(\"/html/js\"));\n\t\tthemeDisplay.setPathMain(mainPath);\n\t\tthemeDisplay.setPathSound(contextPath.concat(\"/html/sound\"));\n\n\t\t// Icons\n\n\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\tthemeDisplay.setShowControlPanelIcon(signedIn);\n\t\tthemeDisplay.setShowHomeIcon(true);\n\t\tthemeDisplay.setShowMyAccountIcon(signedIn);\n\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\tthemeDisplay.setShowPortalIcon(true);\n\t\tthemeDisplay.setShowSignInIcon(!signedIn);\n\t\tthemeDisplay.setShowSignOutIcon(signedIn);\n\n\t\tboolean showSiteContentIcon = false;\n\n\t\tlong controlPanelPlid = 0;\n\n\t\tif (signedIn) {\n\t\t\tGroup controlPanelGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\tcompanyId, GroupConstants.CONTROL_PANEL);\n\n\t\t\tcontrolPanelPlid = LayoutLocalServiceUtil.getDefaultPlid(\n\t\t\t\tcontrolPanelGroup.getGroupId(), true);\n\n\t\t\tList<Portlet> siteContentPortlets =\n\t\t\t\tPortalUtil.getControlPanelPortlets(\n\t\t\t\t\tPortletCategoryKeys.CONTENT, themeDisplay);\n\n\t\t\tPortlet groupPagesPortlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\tPortletKeys.GROUP_PAGES);\n\t\t\tPortlet siteSettingsPortlet =\n\t\t\t\tPortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tPortletKeys.SITE_SETTINGS);\n\n\t\t\tsiteContentPortlets.remove(groupPagesPortlet);\n\t\t\tsiteContentPortlets.remove(siteSettingsPortlet);\n\n\t\t\tshowSiteContentIcon = PortletPermissionUtil.contains(\n\t\t\t\tpermissionChecker, controlPanelGroup.getGroupId(),\n\t\t\t\tcontrolPanelPlid, siteContentPortlets, ActionKeys.VIEW);\n\t\t}\n\n\t\tthemeDisplay.setShowSiteContentIcon(showSiteContentIcon);\n\n\t\tthemeDisplay.setShowStagingIcon(false);\n\n\t\t// Session\n\n\t\tif (!CookieKeys.hasSessionId(request)) {\n\t\t\tthemeDisplay.setAddSessionIdToURL(true);\n\t\t\tthemeDisplay.setSessionId(session.getId());\n\t\t}\n\n\t\t// URLs\n\n\t\tString urlControlPanel = friendlyURLPrivateGroupPath.concat(\n\t\t\tGroupConstants.CONTROL_PANEL_FRIENDLY_URL);\n\n\t\tif (Validator.isNotNull(doAsUserId)) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"doAsUserId\", doAsUserId);\n\t\t}\n\n\t\tif (scopeGroupId > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"doAsGroupId\", scopeGroupId);\n\t\t}\n\n\t\tif (refererPlid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", refererPlid);\n\t\t}\n\t\telse if (plid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", plid);\n\t\t}\n\n\t\tif (themeDisplay.isAddSessionIdToURL()) {\n\t\t\turlControlPanel = PortalUtil.getURLWithSessionId(\n\t\t\t\turlControlPanel, session.getId());\n\t\t}\n\n\t\tthemeDisplay.setURLControlPanel(urlControlPanel);\n\n\t\tString siteContentURL = urlControlPanel;\n\n\t\tsiteContentURL = HttpUtil.addParameter(\n\t\t\tsiteContentURL, \"p_p_id\", PortletKeys.RECENT_CONTENT);\n\t\tsiteContentURL = HttpUtil.addParameter(\n\t\t\tsiteContentURL, \"controlPanelCategory\",\n\t\t\tPortletCategoryKeys.CONTENT);\n\n\t\tthemeDisplay.setURLSiteContent(siteContentURL);\n\n\t\tPortletURL createAccountURL = new PortletURLImpl(\n\t\t\trequest, PortletKeys.LOGIN, plid, PortletRequest.ACTION_PHASE);\n\n\t\tcreateAccountURL.setWindowState(WindowState.MAXIMIZED);\n\t\tcreateAccountURL.setPortletMode(PortletMode.VIEW);\n\n\t\tcreateAccountURL.setParameter(\"saveLastPath\", \"0\");\n\t\tcreateAccountURL.setParameter(\n\t\t\t\"struts_action\", \"/login/create_account\");\n\n\t\tthemeDisplay.setURLCreateAccount(createAccountURL);\n\n\t\tString currentURL = PortalUtil.getCurrentURL(request);\n\n\t\tthemeDisplay.setURLCurrent(currentURL);\n\n\t\tString urlHome = PortalUtil.getHomeURL(request);\n\n\t\tthemeDisplay.setURLHome(urlHome);\n\n\t\tif (layout != null) {\n\t\t\tif (layout.isTypePortlet()) {\n\t\t\t\tboolean freeformLayout =\n\t\t\t\t\tlayoutTypePortlet.getLayoutTemplateId().equals(\n\t\t\t\t\t\t\"freeform\");\n\n\t\t\t\tthemeDisplay.setFreeformLayout(freeformLayout);\n\n\t\t\t\tboolean hasUpdateLayoutPermission =\n\t\t\t\t\tLayoutPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, layout, ActionKeys.UPDATE);\n\n\t\t\t\tif (hasUpdateLayoutPermission) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(true);\n\t\t\t\t\tthemeDisplay.setShowPageCustomizationIcon(true);\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.toggle('\".concat(\n\t\t\t\t\t\t\tPortletKeys.LAYOUT_CONFIGURATION).concat(\"');\"));\n\n\t\t\t\t\tthemeDisplay.setURLLayoutTemplates(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.showTemplates();\");\n\t\t\t\t}\n\n\t\t\t\tboolean hasCustomizePermission = LayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout, ActionKeys.CUSTOMIZE);\n\n\t\t\t\tif (hasCustomizePermission && customizedView) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.LayoutConfiguration.toggle('\".concat(\n\t\t\t\t\t\t\tPortletKeys.LAYOUT_CONFIGURATION).concat(\"');\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean hasManageLayoutsPermission = false;\n\n\t\t\tif (signedIn) {\n\t\t\t\thasManageLayoutsPermission = GroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, scopeGroupId, ActionKeys.MANAGE_LAYOUTS);\n\n\t\t\t\tif (group.isUser()) {\n\t\t\t\t\tif ((layout.isPrivateLayout() &&\n\t\t\t\t\t\t !PropsValues.LAYOUT_USER_PRIVATE_LAYOUTS_MODIFIABLE) ||\n\t\t\t\t\t\t(layout.isPublicLayout() &&\n\t\t\t\t\t\t !PropsValues.LAYOUT_USER_PUBLIC_LAYOUTS_MODIFIABLE)) {\n\n\t\t\t\t\t\thasManageLayoutsPermission = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasManageLayoutsPermission) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\n\t\t\t\tPortletURL pageSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tpageSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tpageSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/layouts_admin/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tpageSettingsURL.setParameter(\"selPlid\", String.valueOf(plid));\n\n\t\t\t\tthemeDisplay.setURLPageSettings(pageSettingsURL);\n\n\t\t\t\tif (group.isSite()) {\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(true);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(false);\n\t\t\t\t}\n\n\t\t\t\tPortletURL manageSiteMembershipsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.SITE_MEMBERSHIPS_ADMIN,\n\t\t\t\t\tcontrolPanelPlid, PortletRequest.RENDER_PHASE);\n\n\t\t\t\tmanageSiteMembershipsURL.setWindowState(\n\t\t\t\t\tLiferayWindowState.POP_UP);\n\t\t\t\tmanageSiteMembershipsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site_assignments\");\n\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\n\t\t\t\tthemeDisplay.setURLManageSiteMemberships(\n\t\t\t\t\tmanageSiteMembershipsURL);\n\t\t\t}\n\n\t\t\tif (!group.isControlPanel() && !group.isUser() &&\n\t\t\t\t!group.isUserGroup() &&\n\t\t\t\t(GroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, group.getGroupId(),\n\t\t\t\t\tActionKeys.MANAGE_STAGING) ||\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, group.getGroupId(),\n\t\t\t\t\tActionKeys.UPDATE))) {\n\n\t\t\t\tthemeDisplay.setShowSiteSettingsIcon(true);\n\n\t\t\t\tPortletURL siteSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.SITE_SETTINGS, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tsiteSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/site_settings/edit_settings\");\n\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\n\t\t\t\tthemeDisplay.setURLSiteSettings(siteSettingsURL);\n\t\t\t}\n\n\t\t\tif (hasManageLayoutsPermission && !group.isLayoutPrototype()) {\n\t\t\t\tthemeDisplay.setShowSiteMapSettingsIcon(true);\n\n\t\t\t\tPortletURL siteMapSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteMapSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\tsiteMapSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/layouts_admin/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\n\t\t\t\tthemeDisplay.setURLSiteMapSettings(siteMapSettingsURL);\n\t\t\t}\n\n\t\t\tif (group.hasStagingGroup() && !group.isStagingGroup()) {\n\t\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(false);\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\tif (group.isControlPanel()) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\t// LEP-4987\n\n\t\t\tif (group.isStaged() || group.isStagingGroup()) {\n\t\t\t\tboolean hasPublishStagingPermission =\n\t\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, scopeGroupId,\n\t\t\t\t\t\tActionKeys.PUBLISH_STAGING);\n\n\t\t\t\tif (hasManageLayoutsPermission || hasPublishStagingPermission) {\n\t\t\t\t\tthemeDisplay.setShowStagingIcon(true);\n\t\t\t\t}\n\n\t\t\t\tif (hasPublishStagingPermission) {\n\t\t\t\t\tPortletURL publishToLiveURL = new PortletURLImpl(\n\t\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, plid,\n\t\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\t\tpublishToLiveURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.EXCLUSIVE);\n\t\t\t\t\tpublishToLiveURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/layouts_admin/publish_layouts\");\n\n\t\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t\t}\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\"pagesRedirect\", currentURL);\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\n\t\t\t\t\tthemeDisplay.setURLPublishToLive(publishToLiveURL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPortletURLImpl myAccountURL = new PortletURLImpl(\n\t\t\t\trequest, PortletKeys.MY_ACCOUNT, controlPanelPlid,\n\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\tmyAccountURL.setWindowState(WindowState.MAXIMIZED);\n\t\t\tmyAccountURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\tif (scopeGroupId > 0) {\n\t\t\t\tmyAccountURL.setDoAsGroupId(scopeGroupId);\n\t\t\t}\n\n\t\t\tif (refererPlid > 0) {\n\t\t\t\tmyAccountURL.setRefererPlid(refererPlid);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmyAccountURL.setRefererPlid(plid);\n\t\t\t}\n\n\t\t\tmyAccountURL.setControlPanelCategory(PortletCategoryKeys.MY);\n\n\t\t\tmyAccountURL.setParameter(\"struts_action\", \"/my_account/edit_user\");\n\n\t\t\tthemeDisplay.setURLMyAccount(myAccountURL);\n\t\t}\n\n\t\tif ((!user.isActive()) ||\n\t\t\t(PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.TERMS_OF_USE_REQUIRED) &&\n\t\t\t !user.isAgreedToTermsOfUse())) {\n\n\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t}\n\n\t\tif (group.isLayoutPrototype()) {\n\t\t\tthemeDisplay.setShowControlPanelIcon(false);\n\t\t\tthemeDisplay.setShowHomeIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\t\t\tthemeDisplay.setShowPortalIcon(false);\n\t\t\tthemeDisplay.setShowSignInIcon(false);\n\t\t\tthemeDisplay.setShowSignOutIcon(false);\n\t\t\tthemeDisplay.setShowSiteContentIcon(false);\n\t\t\tthemeDisplay.setShowStagingIcon(false);\n\t\t}\n\n\t\tthemeDisplay.setURLPortal(portalURL.concat(contextPath));\n\n\t\tString urlSignIn = mainPath.concat(\"/portal/login\");\n\n\t\tif (layout != null) {\n\t\t\turlSignIn = HttpUtil.addParameter(\n\t\t\t\turlSignIn, \"p_l_id\", layout.getPlid());\n\t\t}\n\n\t\tthemeDisplay.setURLSignIn(urlSignIn);\n\n\t\tthemeDisplay.setURLSignOut(mainPath.concat(\"/portal/logout\"));\n\n\t\tPortletURL updateManagerURL = new PortletURLImpl(\n\t\t\trequest, PortletKeys.UPDATE_MANAGER, plid,\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tupdateManagerURL.setWindowState(WindowState.MAXIMIZED);\n\t\tupdateManagerURL.setPortletMode(PortletMode.VIEW);\n\n\t\tupdateManagerURL.setParameter(\"struts_action\", \"/update_manager/view\");\n\n\t\tthemeDisplay.setURLUpdateManager(updateManagerURL);\n\n\t\trequest.setAttribute(WebKeys.THEME_DISPLAY, themeDisplay);\n\n\t\t// Service context\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\trequest);\n\n\t\tServiceContextThreadLocal.pushServiceContext(serviceContext);\n\n\t\t// Parallel render\n\n\t\tboolean parallelRenderEnable = true;\n\n\t\tif (layout != null) {\n\t\t\tList<String> portletIds = layoutTypePortlet.getPortletIds();\n\n\t\t\tif (portletIds.size() == 1) {\n\t\t\t\tString portletId = portletIds.get(0);\n\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tportletId);\n\n\t\t\t\tif ((portlet != null) && !portlet.isAjaxable()) {\n\t\t\t\t\tparallelRenderEnable = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tBoolean parallelRenderEnableObj = Boolean.valueOf(ParamUtil.getBoolean(\n\t\t\trequest, \"p_p_parallel\", parallelRenderEnable));\n\n\t\trequest.setAttribute(\n\t\t\tWebKeys.PORTLET_PARALLEL_RENDER, parallelRenderEnableObj);\n\n\t\t// Main Journal article\n\n\t\tlong mainJournalArticleId = ParamUtil.getLong(\n\t\t\trequest, \"p_j_a_id\");\n\n\t\tif (mainJournalArticleId > 0) {\n\t\t\ttry{\n\t\t\t\tJournalArticle mainJournalArticle =\n\t\t\t\t\tJournalArticleServiceUtil.getArticle(mainJournalArticleId);\n\n\t\t\t\tthemeDisplay.setMainJournalArticle(mainJournalArticle);\n\t\t\t}\n\t\t\tcatch (NoSuchArticleException nsae) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(nsae.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"4ec40f2af75196d4efaae083e5f7aac525152ecc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void run(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows ActionException {\n\n\t\ttry {\n\t\t\tThemeDisplay themeDisplay = (ThemeDisplay) request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\t// Theme and color scheme\n\n\t\t\tTheme theme = themeDisplay.getTheme();\n\t\t\tColorScheme colorScheme = themeDisplay.getColorScheme();\n\n\t\t\tif (theme != null) {\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\"Theme already set, skipping\");\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tLayout layout = themeDisplay.getLayout();\n\n\t\t\tlong companyId = themeDisplay.getCompanyId();\n\n\t\t\tboolean wapTheme = BrowserSnifferUtil.isWap(request);\n\n\t\t\tString contextPath = PortalUtil.getPathContext();\n\n\t\t\tif (layout != null) {\n\t\t\t\tif (wapTheme) {\n\t\t\t\t\ttheme = layout.getWapTheme();\n\t\t\t\t\tcolorScheme = layout.getWapColorScheme();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttheme = layout.getTheme();\n\t\t\t\t\tcolorScheme = layout.getColorScheme();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString themeId = null;\n\t\t\t\tString colorSchemeId = null;\n\n\t\t\t\tif (wapTheme) {\n\t\t\t\t\tthemeId = ThemeImpl.getDefaultWapThemeId(companyId);\n\t\t\t\t\tcolorSchemeId = ColorSchemeImpl.getDefaultWapColorSchemeId();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthemeId = ThemeImpl.getDefaultRegularThemeId(companyId);\n\t\t\t\t\tcolorSchemeId =\n\t\t\t\t\t\tColorSchemeImpl.getDefaultRegularColorSchemeId();\n\t\t\t\t}\n\n\t\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\t\tcompanyId, themeId, wapTheme);\n\t\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, wapTheme);\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.THEME, theme);\n\t\t\trequest.setAttribute(WebKeys.COLOR_SCHEME, colorScheme);\n\n\t\t\tthemeDisplay.setLookAndFeel(contextPath, theme, colorScheme);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ActionException(e);\n\t\t}\n\t}","id":23322,"modified_method":"@Override\n\tpublic void run(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows ActionException {\n\n\t\ttry {\n\t\t\tservicePre(request, response);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ActionException(e);\n\t\t}\n\t}","commit_id":"4ec40f2af75196d4efaae083e5f7aac525152ecc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Nullable\n  public String getToolsPath(Sdk sdk) {\n    final Sdk jdk = getInternalJavaSdk(sdk);\n    if (jdk != null && jdk.getVersionString() != null){\n      return jdk.getSdkType().getToolsPath(jdk);\n    }\n    return null;\n  }","id":23323,"modified_method":"@Nullable\n  public String getToolsPath(Sdk sdk) {\n    final Sdk jdk = getInternalJavaSdk(sdk);\n    if (jdk != null && jdk.getVersionString() != null){\n      return JavaSdk.getInstance().getToolsPath(jdk);\n    }\n    return null;\n  }","commit_id":"ef4c8a2d6508a9116dececbe991038ef69d2c09d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void patchJavaParameters(@Nullable Module module, JavaParameters javaParameters) {\n    Sdk jdk = javaParameters.getJdk();\n    jdk = IdeaJdk.findIdeaJdk(jdk);\n    if (jdk == null) return;\n\n    @NonNls String libPath = jdk.getHomePath() + File.separator + \"lib\";\n    \n    final ParametersList vm = javaParameters.getVMParametersList();\n    vm.add(\"-Xbootclasspath/p:\" + libPath + File.separator + \"boot.jar\");\n    if (!vm.hasProperty(\"idea.load.plugins.id\") && module != null && PluginModuleType.isOfType(module)) {\n      final String id = DescriptorUtil.getPluginId(module);\n      if (id != null) {\n        vm.defineProperty(\"idea.load.plugins.id\", id);\n      }\n    }\n\n    final String sandboxHome = getSandboxPath(jdk);\n    if (sandboxHome != null) {\n      if (!vm.hasProperty(\"idea.home.path\")) {\n        vm.defineProperty(\"idea.home.path\", sandboxHome + File.separator + \"test\");\n      }\n      if (!vm.hasProperty(\"idea.plugins.path\")) {\n        vm.defineProperty(\"idea.plugins.path\", sandboxHome + File.separator + \"plugins\");\n      }\n    }\n\n    javaParameters.getClassPath().addFirst(libPath + File.separator + \"idea.jar\");\n    javaParameters.getClassPath().addFirst(libPath + File.separator + \"resources.jar\");\n    javaParameters.getClassPath().addFirst(jdk.getSdkType().getToolsPath(jdk));\n  }","id":23324,"modified_method":"public void patchJavaParameters(@Nullable Module module, JavaParameters javaParameters) {\n    Sdk jdk = javaParameters.getJdk();\n    jdk = IdeaJdk.findIdeaJdk(jdk);\n    if (jdk == null) return;\n\n    @NonNls String libPath = jdk.getHomePath() + File.separator + \"lib\";\n    \n    final ParametersList vm = javaParameters.getVMParametersList();\n    vm.add(\"-Xbootclasspath/p:\" + libPath + File.separator + \"boot.jar\");\n    if (!vm.hasProperty(\"idea.load.plugins.id\") && module != null && PluginModuleType.isOfType(module)) {\n      final String id = DescriptorUtil.getPluginId(module);\n      if (id != null) {\n        vm.defineProperty(\"idea.load.plugins.id\", id);\n      }\n    }\n\n    final String sandboxHome = getSandboxPath(jdk);\n    if (sandboxHome != null) {\n      if (!vm.hasProperty(\"idea.home.path\")) {\n        vm.defineProperty(\"idea.home.path\", sandboxHome + File.separator + \"test\");\n      }\n      if (!vm.hasProperty(\"idea.plugins.path\")) {\n        vm.defineProperty(\"idea.plugins.path\", sandboxHome + File.separator + \"plugins\");\n      }\n    }\n\n    javaParameters.getClassPath().addFirst(libPath + File.separator + \"idea.jar\");\n    javaParameters.getClassPath().addFirst(libPath + File.separator + \"resources.jar\");\n    javaParameters.getClassPath().addFirst(((JavaSdkType)jdk.getSdkType()).getToolsPath(jdk));\n  }","commit_id":"ef4c8a2d6508a9116dececbe991038ef69d2c09d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RunProfileState getState(DataContext context,\n                                  RunnerInfo runnerInfo,\n                                  RunnerSettings runnerSettings,\n                                  ConfigurationPerRunnerSettings configurationSettings) throws ExecutionException {\n    if (getModule() == null){\n      throw new ExecutionException(DevKitBundle.message(\"run.configuration.no.module.specified\"));\n    }\n    final ModuleRootManager rootManager = ModuleRootManager.getInstance(getModule());\n    final Sdk jdk = rootManager.getSdk();\n    if (jdk == null) {\n      throw CantRunException.noJdkForModule(getModule());\n    }\n\n    final Sdk ideaJdk = IdeaJdk.findIdeaJdk(jdk);\n    if (ideaJdk == null) {\n      throw new ExecutionException(DevKitBundle.message(\"jdk.type.incorrect.common\"));\n    }\n    String sandboxHome = ((Sandbox)ideaJdk.getSdkAdditionalData()).getSandboxHome();\n\n    if (sandboxHome == null){\n      throw new ExecutionException(DevKitBundle.message(\"sandbox.no.configured\"));\n    }\n\n    try {\n      sandboxHome = new File(sandboxHome).getCanonicalPath();\n    }\n    catch (IOException e) {\n      throw new ExecutionException(DevKitBundle.message(\"sandbox.no.configured\"));\n    }\n    final String canonicalSandbox = sandboxHome;\n\n    //copy license from running instance of idea\n    IdeaLicenseHelper.copyIDEALicencse(sandboxHome, ideaJdk);\n\n    final JavaCommandLineState state = new JavaCommandLineState(runnerSettings, configurationSettings) {\n      protected JavaParameters createJavaParameters() throws ExecutionException {\n\n        final JavaParameters params = new JavaParameters();\n\n        ParametersList vm = params.getVMParametersList();\n\n        fillParameterList(vm, VM_PARAMETERS);\n        fillParameterList(params.getProgramParametersList(), PROGRAM_PARAMETERS);\n\n        @NonNls String libPath = ideaJdk.getHomePath() + File.separator + \"lib\";\n        vm.add(\"-Xbootclasspath/p:\" + libPath + File.separator + \"boot.jar\");\n\n        vm.defineProperty(\"idea.config.path\", canonicalSandbox + File.separator + \"config\");\n        vm.defineProperty(\"idea.system.path\", canonicalSandbox + File.separator + \"system\");\n        vm.defineProperty(\"idea.plugins.path\", canonicalSandbox + File.separator + \"plugins\");\n\n        if (SystemInfo.isMac) {\n          vm.defineProperty(\"idea.smooth.progress\", \"false\");\n          vm.defineProperty(\"apple.laf.useScreenMenuBar\", \"true\");\n        }\n\n        params.setWorkingDirectory(ideaJdk.getHomePath() + File.separator + \"bin\" + File.separator);\n\n        params.setJdk(ideaJdk);\n\n        params.getClassPath().addFirst(libPath + File.separator + \"log4j.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"jdom.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"openapi.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"util.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"extensions.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"bootstrap.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"idea.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"idea_rt.jar\");\n        params.getClassPath().addFirst(ideaJdk.getSdkType().getToolsPath(ideaJdk));\n\n        params.setMainClass(\"com.intellij.idea.Main\");\n\n        return params;\n      }\n    };\n\n    state.setConsoleBuilder(TextConsoleBuilderFactory.getInstance().createBuilder(getProject()));\n    state.setModulesToCompile(getModules());    //todo\n    return state;\n  }","id":23325,"modified_method":"public RunProfileState getState(DataContext context,\n                                  RunnerInfo runnerInfo,\n                                  RunnerSettings runnerSettings,\n                                  ConfigurationPerRunnerSettings configurationSettings) throws ExecutionException {\n    if (getModule() == null){\n      throw new ExecutionException(DevKitBundle.message(\"run.configuration.no.module.specified\"));\n    }\n    final ModuleRootManager rootManager = ModuleRootManager.getInstance(getModule());\n    final Sdk jdk = rootManager.getSdk();\n    if (jdk == null) {\n      throw CantRunException.noJdkForModule(getModule());\n    }\n\n    final Sdk ideaJdk = IdeaJdk.findIdeaJdk(jdk);\n    if (ideaJdk == null) {\n      throw new ExecutionException(DevKitBundle.message(\"jdk.type.incorrect.common\"));\n    }\n    String sandboxHome = ((Sandbox)ideaJdk.getSdkAdditionalData()).getSandboxHome();\n\n    if (sandboxHome == null){\n      throw new ExecutionException(DevKitBundle.message(\"sandbox.no.configured\"));\n    }\n\n    try {\n      sandboxHome = new File(sandboxHome).getCanonicalPath();\n    }\n    catch (IOException e) {\n      throw new ExecutionException(DevKitBundle.message(\"sandbox.no.configured\"));\n    }\n    final String canonicalSandbox = sandboxHome;\n\n    //copy license from running instance of idea\n    IdeaLicenseHelper.copyIDEALicencse(sandboxHome, ideaJdk);\n\n    final JavaCommandLineState state = new JavaCommandLineState(runnerSettings, configurationSettings) {\n      protected JavaParameters createJavaParameters() throws ExecutionException {\n\n        final JavaParameters params = new JavaParameters();\n\n        ParametersList vm = params.getVMParametersList();\n\n        fillParameterList(vm, VM_PARAMETERS);\n        fillParameterList(params.getProgramParametersList(), PROGRAM_PARAMETERS);\n\n        @NonNls String libPath = ideaJdk.getHomePath() + File.separator + \"lib\";\n        vm.add(\"-Xbootclasspath/p:\" + libPath + File.separator + \"boot.jar\");\n\n        vm.defineProperty(\"idea.config.path\", canonicalSandbox + File.separator + \"config\");\n        vm.defineProperty(\"idea.system.path\", canonicalSandbox + File.separator + \"system\");\n        vm.defineProperty(\"idea.plugins.path\", canonicalSandbox + File.separator + \"plugins\");\n\n        if (SystemInfo.isMac) {\n          vm.defineProperty(\"idea.smooth.progress\", \"false\");\n          vm.defineProperty(\"apple.laf.useScreenMenuBar\", \"true\");\n        }\n\n        params.setWorkingDirectory(ideaJdk.getHomePath() + File.separator + \"bin\" + File.separator);\n\n        params.setJdk(ideaJdk);\n\n        params.getClassPath().addFirst(libPath + File.separator + \"log4j.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"jdom.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"openapi.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"util.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"extensions.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"bootstrap.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"idea.jar\");\n        params.getClassPath().addFirst(libPath + File.separator + \"idea_rt.jar\");\n        params.getClassPath().addFirst(((JavaSdkType)ideaJdk.getSdkType()).getToolsPath(ideaJdk));\n\n        params.setMainClass(\"com.intellij.idea.Main\");\n\n        return params;\n      }\n    };\n\n    state.setConsoleBuilder(TextConsoleBuilderFactory.getInstance().createBuilder(getProject()));\n    state.setModulesToCompile(getModules());    //todo\n    return state;\n  }","commit_id":"ef4c8a2d6508a9116dececbe991038ef69d2c09d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Patches command line before virtualenv and buildout patchers.\n   * Default implementation does nothing.\n   *\n   * @param commandLine\n   * @param sdk_home\n   * @param sdk_type\n   */\n  protected void patchCommandLineFirst(GeneralCommandLine commandLine, String sdk_home, SdkType sdk_type) {\n    // override\n  }","id":23326,"modified_method":"/**\n   * Patches command line before virtualenv and buildout patchers.\n   * Default implementation does nothing.\n   *\n   * @param commandLine\n   * @param sdk_home\n   */\n  protected void patchCommandLineFirst(GeneralCommandLine commandLine, String sdk_home) {\n    // override\n  }","commit_id":"c08914555f9a62830276f168340603a28fc01af0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Patches command line after virtualenv and buildout patchers.\n   * Default implementation does nothing.\n   *\n   * @param commandLine\n   * @param sdk_home\n   * @param sdk_type\n   */\n  protected void patchCommandLineLast(GeneralCommandLine commandLine, String sdk_home, SdkType sdk_type) {\n    // override\n  }","id":23327,"modified_method":"/**\n   * Patches command line after virtualenv and buildout patchers.\n   * Default implementation does nothing.\n   *\n   * @param commandLine\n   * @param sdk_home\n   */\n  protected void patchCommandLineLast(GeneralCommandLine commandLine, String sdk_home) {\n    // override\n  }","commit_id":"c08914555f9a62830276f168340603a28fc01af0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Gets called after {@link #patchCommandLineForVirtualenv(com.intellij.execution.configurations.GeneralCommandLine, String, com.intellij.openapi.projectRoots.SdkType)}\n   * Does nothing here, real implementations should use alter running script name or use engulfer.\n   *\n   * @param commandLine\n   * @param sdkHome\n   * @param sdkType\n   */\n  protected void patchCommandLineForBuildout(GeneralCommandLine commandLine, String sdkHome, SdkType sdkType) {\n  }","id":23328,"modified_method":"/**\n   * Gets called after {@link #patchCommandLineForVirtualenv(com.intellij.openapi.projectRoots.SdkType, com.intellij.openapi.projectRoots.SdkType)}\n   * Does nothing here, real implementations should use alter running script name or use engulfer.\n   *\n   * @param commandLine\n   * @param sdkHome\n   */\n  protected void patchCommandLineForBuildout(GeneralCommandLine commandLine, String sdkHome) {\n  }","commit_id":"c08914555f9a62830276f168340603a28fc01af0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Alters PATH so that a virtualenv is activated, if present.\n   *\n   * @param commandLine\n   * @param sdkHome\n   * @param sdkType\n   */\n  protected void patchCommandLineForVirtualenv(GeneralCommandLine commandLine, String sdkHome, SdkType sdkType) {\n    PythonSdkType.patchCommandLineForVirtualenv(commandLine, sdkHome, isPassParentEnvs());\n  }","id":23329,"modified_method":"/**\n   * Alters PATH so that a virtualenv is activated, if present.\n   *\n   * @param commandLine\n   * @param sdkHome\n   */\n  protected void patchCommandLineForVirtualenv(GeneralCommandLine commandLine, String sdkHome) {\n    PythonSdkType.patchCommandLineForVirtualenv(commandLine, sdkHome, isPassParentEnvs());\n  }","commit_id":"c08914555f9a62830276f168340603a28fc01af0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Some setups (e.g. virtualenv) provide a script that alters environment variables before running a python interpreter or other tools.\n   * Such settings are not directly stored but applied right before running using this method.\n   *\n   * @param commandLine what to patch\n   */\n  public void patchCommandLine(GeneralCommandLine commandLine) {\n    final String sdk_home = getSdkHome();\n    Sdk sdk = PythonSdkType.findPythonSdk(getModule());\n    if (sdk != null && sdk_home != null) {\n      SdkType sdkType = sdk.getSdkType();\n      patchCommandLineFirst(commandLine, sdk_home, sdkType);\n      patchCommandLineForVirtualenv(commandLine, sdk_home, sdkType);\n      patchCommandLineForBuildout(commandLine, sdk_home, sdkType);\n      patchCommandLineLast(commandLine, sdk_home, sdkType);\n    }\n  }","id":23330,"modified_method":"/**\n   * Some setups (e.g. virtualenv) provide a script that alters environment variables before running a python interpreter or other tools.\n   * Such settings are not directly stored but applied right before running using this method.\n   *\n   * @param commandLine what to patch\n   */\n  public void patchCommandLine(GeneralCommandLine commandLine) {\n    final String sdk_home = getSdkHome();\n    Sdk sdk = PythonSdkType.findPythonSdk(getModule());\n    if (sdk != null && sdk_home != null) {\n      patchCommandLineFirst(commandLine, sdk_home);\n      patchCommandLineForVirtualenv(commandLine, sdk_home);\n      patchCommandLineForBuildout(commandLine, sdk_home);\n      patchCommandLineLast(commandLine, sdk_home);\n    }\n  }","commit_id":"c08914555f9a62830276f168340603a28fc01af0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PyFile getBuiltinsForSdk(Project project, Sdk sdk) {\n    SdkType sdk_type = sdk.getSdkType();\n    if (sdk_type instanceof PythonSdkType) {\n      // dig out the builtins file, create an instance based on it\n      final String[] urls = sdk.getRootProvider().getUrls(PythonSdkType.BUILTIN_ROOT_TYPE);\n      for (String url : urls) {\n        if (url.contains(PythonSdkType.SKELETON_DIR_NAME)) {\n          final String builtins_url = url + \"/\" + PythonSdkType.getBuiltinsFileName(sdk);\n          File builtins = new File(VfsUtil.urlToPath(builtins_url));\n          if (builtins.isFile() && builtins.canRead()) {\n            VirtualFile builtins_vfile = LocalFileSystem.getInstance().findFileByIoFile(builtins);\n            if (builtins_vfile != null) {\n              PsiFile file = PsiManager.getInstance(project).findFile(builtins_vfile);\n              if (file instanceof PyFile) {\n                return (PyFile)file;\n              }\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }","id":23331,"modified_method":"@Nullable\n  public static PyFile getBuiltinsForSdk(Project project, Sdk sdk) {\n    SdkTypeId sdkType = sdk.getSdkType();\n    if (sdkType instanceof PythonSdkType) {\n      // dig out the builtins file, create an instance based on it\n      final String[] urls = sdk.getRootProvider().getUrls(PythonSdkType.BUILTIN_ROOT_TYPE);\n      for (String url : urls) {\n        if (url.contains(PythonSdkType.SKELETON_DIR_NAME)) {\n          final String builtins_url = url + \"/\" + PythonSdkType.getBuiltinsFileName(sdk);\n          File builtins = new File(VfsUtil.urlToPath(builtins_url));\n          if (builtins.isFile() && builtins.canRead()) {\n            VirtualFile builtins_vfile = LocalFileSystem.getInstance().findFileByIoFile(builtins);\n            if (builtins_vfile != null) {\n              PsiFile file = PsiManager.getInstance(project).findFile(builtins_vfile);\n              if (file instanceof PyFile) {\n                return (PyFile)file;\n              }\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }","commit_id":"c08914555f9a62830276f168340603a28fc01af0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void doCustomize(final JList list, final Sdk sdk, final int index, final boolean selected, final boolean hasFocus) {\n    if (sdk != null) {\n      final PythonSdkFlavor flavor = PythonSdkFlavor.getPlatformIndependentFlavor(sdk.getHomePath());\n      final Icon icon = flavor != null ? flavor.getIcon() : sdk.getSdkType().getIcon();\n      final String name;\n      if (mySdkModificators != null && mySdkModificators.containsKey(sdk)) {\n        name = mySdkModificators.get(sdk).getName();\n      }\n      else {\n        name = sdk.getName();\n      }\n      if (PythonSdkType.isInvalid(sdk)) {\n        append(\"[invalid] \" + name);\n        final LayeredIcon layered = new LayeredIcon(2);\n        layered.setIcon(icon, 0);\n        // TODO: Create a separate invalid SDK overlay icon\n        final Icon overlay = IconLoader.findIcon(\"/actions/cancel.png\");\n        layered.setIcon(overlay, 1);\n        setIcon(layered);\n      }\n      else {\n        append(name);\n        setIcon(icon);\n      }\n    }\n  }","id":23332,"modified_method":"@Override\n  protected void doCustomize(final JList list, final Sdk sdk, final int index, final boolean selected, final boolean hasFocus) {\n    if (sdk != null) {\n      final PythonSdkFlavor flavor = PythonSdkFlavor.getPlatformIndependentFlavor(sdk.getHomePath());\n      final Icon icon = flavor != null ? flavor.getIcon() : ((SdkType) sdk.getSdkType()).getIcon();\n      final String name;\n      if (mySdkModificators != null && mySdkModificators.containsKey(sdk)) {\n        name = mySdkModificators.get(sdk).getName();\n      }\n      else {\n        name = sdk.getName();\n      }\n      if (PythonSdkType.isInvalid(sdk)) {\n        append(\"[invalid] \" + name);\n        final LayeredIcon layered = new LayeredIcon(2);\n        layered.setIcon(icon, 0);\n        // TODO: Create a separate invalid SDK overlay icon\n        final Icon overlay = IconLoader.findIcon(\"/actions/cancel.png\");\n        layered.setIcon(overlay, 1);\n        setIcon(layered);\n      }\n      else {\n        append(name);\n        setIcon(icon);\n      }\n    }\n  }","commit_id":"c08914555f9a62830276f168340603a28fc01af0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateActiveSdks(@NotNull final Project project, final int delay) {\n    final Set<Sdk> sdksToUpdate = new HashSet<Sdk>();\n    for (Module module : ModuleManager.getInstance(project).getModules()) {\n      final Sdk sdk = PythonSdkType.findPythonSdk(module);\n      if (sdk != null) {\n        final SdkType sdkType = sdk.getSdkType();\n        if (sdkType instanceof PythonSdkType && !myAlreadyUpdated.contains(sdk.getHomePath())) {\n          sdksToUpdate.add(sdk);\n        }\n      }\n    }\n\n    // NOTE: everything is run later on the AWT thread\n    if (!sdksToUpdate.isEmpty()) {\n      ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n        public void run() {\n          if (delay > 0) {\n            try {\n              Thread.sleep(delay); // wait until all short-term disk-hitting activity ceases\n            }\n            catch (InterruptedException ignore) {\n            }\n          }\n          // update skeletons\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              ProgressManager.getInstance().run(new Task.Backgroundable(project, PyBundle.message(\"sdk.gen.updating.skels\"), false) {\n                @Override\n                public void run(@NotNull ProgressIndicator indicator) {\n                  for (final Sdk sdk : sdksToUpdate) {\n                    try {\n                      updateSdk(project, sdk);\n                    }\n                    catch (InvalidSdkException e) {\n                      if (!PythonSdkType.isInvalid(sdk)) {\n                        LOG.warn(e);\n                        final Notification notification = PythonSdkType.createInvalidSdkNotification(myProject);\n                        notification.notify(myProject);\n                      }\n                    }\n                    myAlreadyUpdated.add(sdk.getHomePath());\n                  }\n                }\n              });\n            }\n          });\n        }\n      });\n    }\n  }","id":23333,"modified_method":"public void updateActiveSdks(@NotNull final Project project, final int delay) {\n    final Set<Sdk> sdksToUpdate = new HashSet<Sdk>();\n    for (Module module : ModuleManager.getInstance(project).getModules()) {\n      final Sdk sdk = PythonSdkType.findPythonSdk(module);\n      if (sdk != null) {\n        final SdkTypeId sdkType = sdk.getSdkType();\n        if (sdkType instanceof PythonSdkType && !myAlreadyUpdated.contains(sdk.getHomePath())) {\n          sdksToUpdate.add(sdk);\n        }\n      }\n    }\n\n    // NOTE: everything is run later on the AWT thread\n    if (!sdksToUpdate.isEmpty()) {\n      ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n        public void run() {\n          if (delay > 0) {\n            try {\n              Thread.sleep(delay); // wait until all short-term disk-hitting activity ceases\n            }\n            catch (InterruptedException ignore) {\n            }\n          }\n          // update skeletons\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              ProgressManager.getInstance().run(new Task.Backgroundable(project, PyBundle.message(\"sdk.gen.updating.skels\"), false) {\n                @Override\n                public void run(@NotNull ProgressIndicator indicator) {\n                  for (final Sdk sdk : sdksToUpdate) {\n                    try {\n                      updateSdk(project, sdk);\n                    }\n                    catch (InvalidSdkException e) {\n                      if (!PythonSdkType.isInvalid(sdk)) {\n                        LOG.warn(e);\n                        final Notification notification = PythonSdkType.createInvalidSdkNotification(myProject);\n                        notification.notify(myProject);\n                      }\n                    }\n                    myAlreadyUpdated.add(sdk.getHomePath());\n                  }\n                }\n              });\n            }\n          });\n        }\n      });\n    }\n  }","commit_id":"c08914555f9a62830276f168340603a28fc01af0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @NonNls\n  public String getHelpTopic() {\n    return myProjectJdk.getSdkType().getHelpTopic();\n  }","id":23334,"modified_method":"@Nullable\n  @NonNls\n  public String getHelpTopic() {\n    return ((SdkType) myProjectJdk.getSdkType()).getHelpTopic();\n  }","commit_id":"e40851408433ba783791fba1a50476afde5d0f18","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Icon getIcon() {\n    return myProjectJdk.getSdkType().getIcon();\n  }","id":23335,"modified_method":"public Icon getIcon() {\n    return ((SdkType) myProjectJdk.getSdkType()).getIcon();\n  }","commit_id":"e40851408433ba783791fba1a50476afde5d0f18","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Sdk createSdk(final String name, final SdkTypeId sdkType) {\n    return new ProjectJdkImpl(name, (SdkType) sdkType);\n  }","id":23336,"modified_method":"public Sdk createSdk(final String name, final SdkTypeId sdkType) {\n    return new ProjectJdkImpl(name, sdkType);\n  }","commit_id":"e40851408433ba783791fba1a50476afde5d0f18","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setBuildFile(AbstractProperty.AbstractPropertyContainer container, File buildFile) throws CantRunException {\n    String jdkName = AntBuildFileImpl.CUSTOM_JDK_NAME.get(container);\n    Sdk jdk;\n    if (jdkName != null && jdkName.length() > 0) {\n      jdk = GlobalAntConfiguration.findJdk(jdkName);\n    }\n    else {\n      jdkName = AntConfigurationImpl.DEFAULT_JDK_NAME.get(container);\n      if (jdkName == null || jdkName.length() == 0) {\n        throw new CantRunException(AntBundle.message(\"project.jdk.not.specified.error.message\"));\n      }\n      jdk = GlobalAntConfiguration.findJdk(jdkName);\n    }\n    if (jdk == null) {\n      throw new CantRunException(AntBundle.message(\"jdk.with.name.not.configured.error.message\", jdkName));\n    }\n    VirtualFile homeDirectory = jdk.getHomeDirectory();\n    if (homeDirectory == null) {\n      throw new CantRunException(AntBundle.message(\"jdk.with.name.bad.configured.error.message\", jdkName));\n    }\n    myCommandLine.setJdk(jdk);\n\n    ParametersList vmParametersList = myCommandLine.getVMParametersList();\n    vmParametersList.add(\"-Xmx\" + AntBuildFileImpl.MAX_HEAP_SIZE.get(container) + \"m\");\n\n    final AntInstallation antInstallation = AntBuildFileImpl.ANT_INSTALLATION.get(container);\n    if (antInstallation == null) {\n      throw new CantRunException(AntBundle.message(\"ant.installation.not.configured.error.message\"));\n    }\n\n    final String antHome = AntInstallation.HOME_DIR.get(antInstallation.getProperties());\n    vmParametersList.add(\"-Dant.home=\" + antHome);\n\n    String[] urls = jdk.getRootProvider().getUrls(OrderRootType.CLASSES);\n    final String jdkHome = homeDirectory.getPath().replace('/', File.separatorChar);\n    @NonNls final String pathToJre = jdkHome + File.separator + \"jre\" + File.separator;\n    for (String url : urls) {\n      final String path = PathUtil.toPresentableUrl(url);\n      if (!path.startsWith(pathToJre)) {\n        myCommandLine.getClassPath().add(path);\n      }\n    }\n\n    myCommandLine.getClassPath().addAllFiles(AntBuildFileImpl.ALL_CLASS_PATH.get(container));\n    \n    myCommandLine.getClassPath().addAllFiles(AntBuildFileImpl.getUserHomeLibraries());\n    \n    final String toolsJar = jdk.getSdkType().getToolsPath(jdk);\n    if (toolsJar != null) {\n      myCommandLine.getClassPath().add(toolsJar);\n    }\n    PathUtilEx.addRtJar(myCommandLine.getClassPath());\n\n    myCommandLine.setMainClass(AntMain2.class.getName());\n    final ParametersList programParameters = myCommandLine.getProgramParametersList();\n    programParameters.addParametersString(AntBuildFileImpl.ANT_COMMAND_LINE_PARAMETERS.get(container));\n    if (!(programParameters.getList().contains(LOGFILE_SHORT_PARAMETER) || programParameters.getList().contains(LOGFILE_PARAMETER)) ) {\n      programParameters.add(\"-logger\", IdeaAntLogger2.class.getName());\n    }\n    if (!programParameters.getList().contains(INPUT_HANDLER_PARAMETER)) {\n      programParameters.add(INPUT_HANDLER_PARAMETER, IdeaInputHandler.class.getName());\n    }\n\n    myProperties = AntBuildFileImpl.ANT_PROPERTIES.get(container);\n\n    myBuildFilePath = buildFile.getAbsolutePath();\n    myCommandLine.setWorkingDirectory(buildFile.getParent());\n  }","id":23337,"modified_method":"public void setBuildFile(AbstractProperty.AbstractPropertyContainer container, File buildFile) throws CantRunException {\n    String jdkName = AntBuildFileImpl.CUSTOM_JDK_NAME.get(container);\n    Sdk jdk;\n    if (jdkName != null && jdkName.length() > 0) {\n      jdk = GlobalAntConfiguration.findJdk(jdkName);\n    }\n    else {\n      jdkName = AntConfigurationImpl.DEFAULT_JDK_NAME.get(container);\n      if (jdkName == null || jdkName.length() == 0) {\n        throw new CantRunException(AntBundle.message(\"project.jdk.not.specified.error.message\"));\n      }\n      jdk = GlobalAntConfiguration.findJdk(jdkName);\n    }\n    if (jdk == null) {\n      throw new CantRunException(AntBundle.message(\"jdk.with.name.not.configured.error.message\", jdkName));\n    }\n    VirtualFile homeDirectory = jdk.getHomeDirectory();\n    if (homeDirectory == null) {\n      throw new CantRunException(AntBundle.message(\"jdk.with.name.bad.configured.error.message\", jdkName));\n    }\n    myCommandLine.setJdk(jdk);\n\n    ParametersList vmParametersList = myCommandLine.getVMParametersList();\n    vmParametersList.add(\"-Xmx\" + AntBuildFileImpl.MAX_HEAP_SIZE.get(container) + \"m\");\n\n    final AntInstallation antInstallation = AntBuildFileImpl.ANT_INSTALLATION.get(container);\n    if (antInstallation == null) {\n      throw new CantRunException(AntBundle.message(\"ant.installation.not.configured.error.message\"));\n    }\n\n    final String antHome = AntInstallation.HOME_DIR.get(antInstallation.getProperties());\n    vmParametersList.add(\"-Dant.home=\" + antHome);\n\n    String[] urls = jdk.getRootProvider().getUrls(OrderRootType.CLASSES);\n    final String jdkHome = homeDirectory.getPath().replace('/', File.separatorChar);\n    @NonNls final String pathToJre = jdkHome + File.separator + \"jre\" + File.separator;\n    for (String url : urls) {\n      final String path = PathUtil.toPresentableUrl(url);\n      if (!path.startsWith(pathToJre)) {\n        myCommandLine.getClassPath().add(path);\n      }\n    }\n\n    myCommandLine.getClassPath().addAllFiles(AntBuildFileImpl.ALL_CLASS_PATH.get(container));\n    \n    myCommandLine.getClassPath().addAllFiles(AntBuildFileImpl.getUserHomeLibraries());\n\n    final SdkType sdkType = jdk.getSdkType();\n    if (sdkType instanceof JavaSdkType) {\n      final String toolsJar = ((JavaSdkType)sdkType).getToolsPath(jdk);\n      if (toolsJar != null) {\n        myCommandLine.getClassPath().add(toolsJar);\n      }\n    }\n    PathUtilEx.addRtJar(myCommandLine.getClassPath());\n\n    myCommandLine.setMainClass(AntMain2.class.getName());\n    final ParametersList programParameters = myCommandLine.getProgramParametersList();\n    programParameters.addParametersString(AntBuildFileImpl.ANT_COMMAND_LINE_PARAMETERS.get(container));\n    if (!(programParameters.getList().contains(LOGFILE_SHORT_PARAMETER) || programParameters.getList().contains(LOGFILE_PARAMETER)) ) {\n      programParameters.add(\"-logger\", IdeaAntLogger2.class.getName());\n    }\n    if (!programParameters.getList().contains(INPUT_HANDLER_PARAMETER)) {\n      programParameters.add(INPUT_HANDLER_PARAMETER, IdeaInputHandler.class.getName());\n    }\n\n    myProperties = AntBuildFileImpl.ANT_PROPERTIES.get(container);\n\n    myBuildFilePath = buildFile.getAbsolutePath();\n    myCommandLine.setWorkingDirectory(buildFile.getParent());\n  }","commit_id":"18305e2fa02504f8f57c9c6b53f5334819c32247","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void createJdkGenerators(final Project project) {\n    final Sdk[] jdks = getUsedJdks(project);\n\n    if (jdks.length > 0) {\n      add(new Comment(CompilerBundle.message(\"generated.ant.build.jdk.definitions.comment\")), 1);\n\n      for (final Sdk jdk : jdks) {\n        if (jdk.getHomeDirectory() == null || jdk.getSdkType().getBinPath(jdk) == null) {\n          continue;\n        }\n        final File home = VfsUtil.virtualToIoFile(jdk.getHomeDirectory());\n        File homeDir;\n        try {\n          // use canonical path in order to resolve symlinks\n          homeDir = home.getCanonicalFile();\n        }\n        catch (IOException e) {\n          homeDir = home;\n        }\n        final String jdkName = jdk.getName();\n        final String jdkHomeProperty = getJdkHomeProperty(jdkName);\n        final FileSet fileSet = new FileSet(propertyRef(jdkHomeProperty));\n        final String[] urls = jdk.getRootProvider().getUrls(OrderRootType.COMPILATION_CLASSES);\n        for (String url : urls) {\n          final String path = GenerationUtils.trimJarSeparator(VirtualFileManager.extractPath(url));\n          final File pathElement = new File(path);\n          final String relativePath = FileUtil.getRelativePath(homeDir, pathElement);\n          if (relativePath != null) {\n            fileSet.add(new Include(relativePath.replace(File.separatorChar, '/')));\n          }\n        }\n\n        final File binPath = toCanonicalFile(new File(jdk.getSdkType().getBinPath(jdk)));\n        final String relativePath = FileUtil.getRelativePath(homeDir, binPath);\n        if (relativePath != null) {\n          add(new Property(BuildProperties.getJdkBinProperty(jdkName), propertyRef(jdkHomeProperty) + \"/\" + FileUtil.toSystemIndependentName(relativePath)), 1);\n        } else {\n          add(new Property(BuildProperties.getJdkBinProperty(jdkName), FileUtil.toSystemIndependentName(binPath.getPath())), 1);\n        }\n\n        final Path jdkPath = new Path(getJdkPathId(jdkName));\n        jdkPath.add(fileSet);\n        add(jdkPath);\n      }\n    }\n\n    final Sdk projectJdk = ProjectRootManager.getInstance(project).getProjectJdk();\n    add(new Property(PROPERTY_PROJECT_JDK_HOME, projectJdk != null? propertyRef(getJdkHomeProperty(projectJdk.getName())) : \"\"), 1);\n    add(new Property(PROPERTY_PROJECT_JDK_BIN, projectJdk != null? propertyRef(getJdkBinProperty(projectJdk.getName())) : \"\"));\n    add(new Property(PROPERTY_PROJECT_JDK_CLASSPATH, projectJdk != null? getJdkPathId(projectJdk.getName()) : \"\"));\n  }","id":23338,"modified_method":"protected void createJdkGenerators(final Project project) {\n    final Sdk[] jdks = getUsedJdks(project);\n\n    if (jdks.length > 0) {\n      add(new Comment(CompilerBundle.message(\"generated.ant.build.jdk.definitions.comment\")), 1);\n\n      for (final Sdk jdk : jdks) {\n        if (jdk.getHomeDirectory() == null) {\n          continue;\n        }\n        final SdkType sdkType = jdk.getSdkType();\n        if (!(sdkType instanceof JavaSdkType) || ((JavaSdkType)sdkType).getBinPath(jdk) == null) {\n          continue;\n        }\n        final File home = VfsUtil.virtualToIoFile(jdk.getHomeDirectory());\n        File homeDir;\n        try {\n          // use canonical path in order to resolve symlinks\n          homeDir = home.getCanonicalFile();\n        }\n        catch (IOException e) {\n          homeDir = home;\n        }\n        final String jdkName = jdk.getName();\n        final String jdkHomeProperty = getJdkHomeProperty(jdkName);\n        final FileSet fileSet = new FileSet(propertyRef(jdkHomeProperty));\n        final String[] urls = jdk.getRootProvider().getUrls(OrderRootType.COMPILATION_CLASSES);\n        for (String url : urls) {\n          final String path = GenerationUtils.trimJarSeparator(VirtualFileManager.extractPath(url));\n          final File pathElement = new File(path);\n          final String relativePath = FileUtil.getRelativePath(homeDir, pathElement);\n          if (relativePath != null) {\n            fileSet.add(new Include(relativePath.replace(File.separatorChar, '/')));\n          }\n        }\n\n        final File binPath = toCanonicalFile(new File(((JavaSdkType)sdkType).getBinPath(jdk)));\n        final String relativePath = FileUtil.getRelativePath(homeDir, binPath);\n        if (relativePath != null) {\n          add(new Property(BuildProperties.getJdkBinProperty(jdkName), propertyRef(jdkHomeProperty) + \"/\" + FileUtil.toSystemIndependentName(relativePath)), 1);\n        } else {\n          add(new Property(BuildProperties.getJdkBinProperty(jdkName), FileUtil.toSystemIndependentName(binPath.getPath())), 1);\n        }\n\n        final Path jdkPath = new Path(getJdkPathId(jdkName));\n        jdkPath.add(fileSet);\n        add(jdkPath);\n      }\n    }\n\n    final Sdk projectJdk = ProjectRootManager.getInstance(project).getProjectJdk();\n    add(new Property(PROPERTY_PROJECT_JDK_HOME, projectJdk != null? propertyRef(getJdkHomeProperty(projectJdk.getName())) : \"\"), 1);\n    add(new Property(PROPERTY_PROJECT_JDK_BIN, projectJdk != null? propertyRef(getJdkBinProperty(projectJdk.getName())) : \"\"));\n    add(new Property(PROPERTY_PROJECT_JDK_CLASSPATH, projectJdk != null? getJdkPathId(projectJdk.getName()) : \"\"));\n  }","commit_id":"18305e2fa02504f8f57c9c6b53f5334819c32247","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static GeneralCommandLine createFromJavaParameters(final JavaParameters javaParameters) throws CantRunException {\n    try {\n      return ApplicationManager.getApplication().runReadAction(new Computable<GeneralCommandLine>() {\n        public GeneralCommandLine compute() {\n          try {\n            final GeneralCommandLine commandLine = new GeneralCommandLine();\n            final Sdk jdk = javaParameters.getJdk();\n            if(jdk == null) {\n              throw new CantRunException(ExecutionBundle.message(\"run.configuration.error.no.jdk.specified\"));\n            }\n\n            final String exePath = jdk.getSdkType().getVMExecutablePath(jdk);\n            if(exePath == null) {\n              throw new CantRunException(ExecutionBundle.message(\"run.configuration.cannot.find.vm.executable\"));\n            }\n            commandLine.setExePath(exePath);\n            ParametersList parametersList = javaParameters.getVMParametersList();\n            commandLine.addParameters(parametersList.getList());\n            if (!parametersList.hasProperty(\"file.encoding\")) {\n              Charset charset = javaParameters.getCharset();\n              if (charset == null) charset = CharsetToolkit.getIDEOptionsCharset();\n              if (charset == null) charset = CharsetToolkit.getDefaultSystemCharset();\n              commandLine.setCharset(charset);\n            }\n\n            if(!parametersList.hasParameter(\"-classpath\") && !parametersList.hasParameter(\"-cp\")){\n              commandLine.addParameter(\"-classpath\");\n              commandLine.addParameter(javaParameters.getClassPath().getPathsString());\n            }\n\n            String mainClass = javaParameters.getMainClass();\n            if(mainClass == null) throw new CantRunException(ExecutionBundle.message(\"main.class.is.not.specified.error.message\"));\n            commandLine.addParameter(mainClass);\n            commandLine.addParameters(javaParameters.getProgramParametersList().getList());\n            commandLine.setWorkDirectory(javaParameters.getWorkingDirectory());\n\n            final Map<String, String> env = javaParameters.getEnv();\n            if (env != null) {\n              commandLine.setEnvParams(env);\n              commandLine.setPassParentEnvs(javaParameters.isPassParentEnvs());\n            }\n\n            return commandLine;\n          }\n          catch (CantRunException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      });\n    }\n    catch (RuntimeException e) {\n      if(e.getCause() instanceof CantRunException)\n        throw ((CantRunException)e.getCause());\n      else\n        throw e;\n    }\n  }","id":23339,"modified_method":"public static GeneralCommandLine createFromJavaParameters(final JavaParameters javaParameters) throws CantRunException {\n    try {\n      return ApplicationManager.getApplication().runReadAction(new Computable<GeneralCommandLine>() {\n        public GeneralCommandLine compute() {\n          try {\n            final GeneralCommandLine commandLine = new GeneralCommandLine();\n            final Sdk jdk = javaParameters.getJdk();\n            if(jdk == null) {\n              throw new CantRunException(ExecutionBundle.message(\"run.configuration.error.no.jdk.specified\"));\n            }\n\n            final SdkType sdkType = jdk.getSdkType();\n            if (!(sdkType instanceof JavaSdkType)) {\n              throw new CantRunException(ExecutionBundle.message(\"run.configuration.error.no.jdk.specified\"));\n            }\n            \n            final String exePath = ((JavaSdkType)sdkType).getVMExecutablePath(jdk);\n            if(exePath == null) {\n              throw new CantRunException(ExecutionBundle.message(\"run.configuration.cannot.find.vm.executable\"));\n            }\n            commandLine.setExePath(exePath);\n            ParametersList parametersList = javaParameters.getVMParametersList();\n            commandLine.addParameters(parametersList.getList());\n            if (!parametersList.hasProperty(\"file.encoding\")) {\n              Charset charset = javaParameters.getCharset();\n              if (charset == null) charset = CharsetToolkit.getIDEOptionsCharset();\n              if (charset == null) charset = CharsetToolkit.getDefaultSystemCharset();\n              commandLine.setCharset(charset);\n            }\n\n            if(!parametersList.hasParameter(\"-classpath\") && !parametersList.hasParameter(\"-cp\")){\n              commandLine.addParameter(\"-classpath\");\n              commandLine.addParameter(javaParameters.getClassPath().getPathsString());\n            }\n\n            String mainClass = javaParameters.getMainClass();\n            if(mainClass == null) throw new CantRunException(ExecutionBundle.message(\"main.class.is.not.specified.error.message\"));\n            commandLine.addParameter(mainClass);\n            commandLine.addParameters(javaParameters.getProgramParametersList().getList());\n            commandLine.setWorkDirectory(javaParameters.getWorkingDirectory());\n\n            final Map<String, String> env = javaParameters.getEnv();\n            if (env != null) {\n              commandLine.setEnvParams(env);\n              commandLine.setPassParentEnvs(javaParameters.isPassParentEnvs());\n            }\n\n            return commandLine;\n          }\n          catch (CantRunException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      });\n    }\n    catch (RuntimeException e) {\n      if(e.getCause() instanceof CantRunException)\n        throw ((CantRunException)e.getCause());\n      else\n        throw e;\n    }\n  }","commit_id":"18305e2fa02504f8f57c9c6b53f5334819c32247","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createStartupCommand(final ModuleChunk chunk,\n                                    @NonNls final ArrayList<String> commandLine,\n                                    final String outputPath,\n                                    final boolean useTempFile) throws IOException {\n    EclipseCompilerSettings compilerSettings = EclipseCompilerSettings.getInstance(myProject);\n\n    final Sdk projectJdk = ProjectJdkTable.getInstance().getInternalJdk();\n    final String vmExePath = projectJdk.getSdkType().getVMExecutablePath(projectJdk);\n    commandLine.add(vmExePath);\n    commandLine.add(\"-Xmx\" + compilerSettings.MAXIMUM_HEAP_SIZE + \"m\");\n\n    CompilerUtil.addLocaleOptions(commandLine, false);\n\n    commandLine.add(\"-classpath\");\n    commandLine.add(PATH_TO_COMPILER_JAR);\n    commandLine.add(getCompilerClass());\n\n    addCommandLineOptions(commandLine, chunk, outputPath, compilerSettings, useTempFile, true);\n  }","id":23340,"modified_method":"private void createStartupCommand(final ModuleChunk chunk,\n                                    @NonNls final ArrayList<String> commandLine,\n                                    final String outputPath,\n                                    final boolean useTempFile) throws IOException {\n    EclipseCompilerSettings compilerSettings = EclipseCompilerSettings.getInstance(myProject);\n\n    final Sdk projectJdk = ProjectJdkTable.getInstance().getInternalJdk();\n    final String vmExePath = ((JavaSdkType)projectJdk.getSdkType()).getVMExecutablePath(projectJdk);\n    commandLine.add(vmExePath);\n    commandLine.add(\"-Xmx\" + compilerSettings.MAXIMUM_HEAP_SIZE + \"m\");\n\n    CompilerUtil.addLocaleOptions(commandLine, false);\n\n    commandLine.add(\"-classpath\");\n    commandLine.add(PATH_TO_COMPILER_JAR);\n    commandLine.add(getCompilerClass());\n\n    addCommandLineOptions(commandLine, chunk, outputPath, compilerSettings, useTempFile, true);\n  }","commit_id":"18305e2fa02504f8f57c9c6b53f5334819c32247","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addClassPathValue(final Sdk jdk,\n                                 final boolean isVersion1_0,\n                                 final ArrayList<String> commandLine,\n                                 final String cpString,\n                                 @NonNls final String tempFileName) throws IOException {\n    // must include output path to classpath, otherwise javac will compile all dependent files no matter were they compiled before or not\n    if (isVersion1_0) {\n      commandLine.add(jdk.getSdkType().getToolsPath(jdk) + File.pathSeparator + cpString);\n    }\n    else {\n      File cpFile = FileUtil.createTempFile(tempFileName, \".tmp\");\n      cpFile.deleteOnExit();\n      myTempFiles.add(cpFile);\n      final DataOutputStream out = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(cpFile)));\n      try {\n        CompilerIOUtil.writeString(cpString, out);\n      }\n      finally {\n        out.close();\n      }\n      commandLine.add(\"@\" + cpFile.getAbsolutePath());\n    }\n  }","id":23341,"modified_method":"private void addClassPathValue(final Sdk jdk,\n                                 final boolean isVersion1_0,\n                                 final ArrayList<String> commandLine,\n                                 final String cpString,\n                                 @NonNls final String tempFileName) throws IOException {\n    // must include output path to classpath, otherwise javac will compile all dependent files no matter were they compiled before or not\n    if (isVersion1_0) {\n      commandLine.add(((JavaSdkType)jdk.getSdkType()).getToolsPath(jdk) + File.pathSeparator + cpString);\n    }\n    else {\n      File cpFile = FileUtil.createTempFile(tempFileName, \".tmp\");\n      cpFile.deleteOnExit();\n      myTempFiles.add(cpFile);\n      final DataOutputStream out = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(cpFile)));\n      try {\n        CompilerIOUtil.writeString(cpString, out);\n      }\n      finally {\n        out.close();\n      }\n      commandLine.add(\"@\" + cpFile.getAbsolutePath());\n    }\n  }","commit_id":"18305e2fa02504f8f57c9c6b53f5334819c32247","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean checkCompiler(final CompileScope scope) {\n    final Module[] modules = scope.getAffectedModules();\n    final Set<Sdk> checkedJdks = new HashSet<Sdk>();\n    for (final Module module : modules) {\n      final Sdk jdk  = ModuleRootManager.getInstance(module).getSdk();\n      if (jdk == null) {\n        continue;\n      }\n      if (checkedJdks.contains(jdk)) {\n        continue;\n      }\n      final VirtualFile homeDirectory = jdk.getHomeDirectory();\n      if (homeDirectory == null) {\n        Messages.showMessageDialog(myProject, CompilerBundle.jdkHomeNotFoundMessage(jdk),\n                                   CompilerBundle.message(\"compiler.javac.name\"), Messages.getErrorIcon());\n        return false;\n      }\n      final String vmExecutablePath = jdk.getSdkType().getVMExecutablePath(jdk);\n      if (vmExecutablePath == null) {\n        Messages.showMessageDialog(myProject,\n                                   CompilerBundle.message(\"javac.error.vm.executable.missing\", jdk.getName()),\n                                   CompilerBundle.message(\"compiler.javac.name\"), Messages.getErrorIcon());\n        return false;\n      }\n      if (jdk instanceof JavaSdk) {\n        final String toolsJarPath = jdk.getSdkType().getToolsPath(jdk);\n        if (toolsJarPath == null) {\n          Messages.showMessageDialog(myProject,\n                                     CompilerBundle.message(\"javac.error.tools.jar.missing\", jdk.getName()), CompilerBundle.message(\"compiler.javac.name\"),\n                                     Messages.getErrorIcon());\n          return false;\n        }\n      }\n      final String versionString = jdk.getVersionString();\n      if (versionString == null) {\n        Messages.showMessageDialog(myProject, CompilerBundle.message(\"javac.error.unknown.jdk.version\", jdk.getName()),\n                                   CompilerBundle.message(\"compiler.javac.name\"), Messages.getErrorIcon());\n        return false;\n      }\n      if (jdk instanceof JavaSdk) {\n        if (CompilerUtil.isOfVersion(versionString, \"1.0\")) {\n          Messages.showMessageDialog(myProject, CompilerBundle.message(\"javac.error.1_0_compilation.not.supported\"), CompilerBundle.message(\"compiler.javac.name\"), Messages.getErrorIcon());\n          return false;\n        }\n      }\n      checkedJdks.add(jdk);\n    }\n\n    return true;\n  }","id":23342,"modified_method":"public boolean checkCompiler(final CompileScope scope) {\n    final Module[] modules = scope.getAffectedModules();\n    final Set<Sdk> checkedJdks = new HashSet<Sdk>();\n    for (final Module module : modules) {\n      final Sdk jdk  = ModuleRootManager.getInstance(module).getSdk();\n      if (jdk == null) {\n        continue;\n      }\n      if (checkedJdks.contains(jdk)) {\n        continue;\n      }\n      final VirtualFile homeDirectory = jdk.getHomeDirectory();\n      if (homeDirectory == null) {\n        Messages.showMessageDialog(myProject, CompilerBundle.jdkHomeNotFoundMessage(jdk),\n                                   CompilerBundle.message(\"compiler.javac.name\"), Messages.getErrorIcon());\n        return false;\n      }\n      final SdkType sdkType = jdk.getSdkType();\n      if (!(sdkType instanceof JavaSdkType)){\n        return false;\n      }\n      final String vmExecutablePath = ((JavaSdkType)sdkType).getVMExecutablePath(jdk);\n      if (vmExecutablePath == null) {\n        Messages.showMessageDialog(myProject,\n                                   CompilerBundle.message(\"javac.error.vm.executable.missing\", jdk.getName()),\n                                   CompilerBundle.message(\"compiler.javac.name\"), Messages.getErrorIcon());\n        return false;\n      }\n      final String toolsJarPath = ((JavaSdkType)sdkType).getToolsPath(jdk);\n      if (toolsJarPath == null) {\n        Messages.showMessageDialog(myProject,\n                                   CompilerBundle.message(\"javac.error.tools.jar.missing\", jdk.getName()), CompilerBundle.message(\"compiler.javac.name\"),\n                                   Messages.getErrorIcon());\n        return false;\n      }\n      final String versionString = jdk.getVersionString();\n      if (versionString == null) {\n        Messages.showMessageDialog(myProject, CompilerBundle.message(\"javac.error.unknown.jdk.version\", jdk.getName()),\n                                   CompilerBundle.message(\"compiler.javac.name\"), Messages.getErrorIcon());\n        return false;\n      }\n      if (sdkType instanceof JavaSdk) {\n        if (CompilerUtil.isOfVersion(versionString, \"1.0\")) {\n          Messages.showMessageDialog(myProject, CompilerBundle.message(\"javac.error.1_0_compilation.not.supported\"), CompilerBundle.message(\"compiler.javac.name\"), Messages.getErrorIcon());\n          return false;\n        }\n      }\n      checkedJdks.add(jdk);\n    }\n\n    return true;\n  }","commit_id":"18305e2fa02504f8f57c9c6b53f5334819c32247","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void _createStartupCommand(final ModuleChunk chunk, @NonNls final ArrayList<String> commandLine, final String outputPath) throws IOException {\n    final Sdk jdk = getJdkForStartupCommand(chunk);\n    final String versionString = jdk.getVersionString();\n    if (versionString == null || \"\".equals(versionString)) {\n      throw new IllegalArgumentException(CompilerBundle.message(\"javac.error.unknown.jdk.version\", jdk.getName()));\n    }\n    \n    if (!(jdk instanceof JavaSdk)) {\n      final String toolsJarPath = jdk.getSdkType().getToolsPath(jdk);\n      if (toolsJarPath == null) {\n        throw new IllegalArgumentException(CompilerBundle.message(\"javac.error.tools.jar.missing\", jdk.getName()));\n      }\n    }\n    \n    final boolean isVersion1_0 = CompilerUtil.isOfVersion(versionString, \"1.0\");\n    final boolean isVersion1_1 = CompilerUtil.isOfVersion(versionString, \"1.1\");\n    final boolean isVersion1_2 = CompilerUtil.isOfVersion(versionString, \"1.2\");\n    final boolean isVersion1_3 = CompilerUtil.isOfVersion(versionString, \"1.3\");\n    final boolean isVersion1_4 = CompilerUtil.isOfVersion(versionString, \"1.4\");\n    final boolean isVersion1_5 = CompilerUtil.isOfVersion(versionString, \"1.5\") || CompilerUtil.isOfVersion(versionString, \"5.0\");\n    final boolean isVersion1_5_or_higher = isVersion1_5 || !(isVersion1_0 || isVersion1_1 || isVersion1_2 || isVersion1_3 || isVersion1_4);\n\n    final JavacSettings javacSettings = JavacSettings.getInstance(myProject);\n\n    final String vmExePath = jdk.getSdkType().getVMExecutablePath(jdk);\n\n    commandLine.add(vmExePath);\n    if (isVersion1_1 || isVersion1_0) {\n      commandLine.add(\"-mx\" + javacSettings.MAXIMUM_HEAP_SIZE + \"m\");\n    }\n    else {\n      commandLine.add(\"-Xmx\" + javacSettings.MAXIMUM_HEAP_SIZE + \"m\");\n    }\n\n    final List<String> additionalOptions = new ArrayList<String>();\n    StringTokenizer tokenizer = new StringTokenizer(javacSettings.getOptionsString(), \" \");\n    while (tokenizer.hasMoreTokens()) {\n      @NonNls String token = tokenizer.nextToken();\n      if (isVersion1_0) {\n        if (\"-deprecation\".equals(token)) {\n          continue; // not supported for this version\n        }\n      }\n      if (isVersion1_0 || isVersion1_1 || isVersion1_2 || isVersion1_3 || isVersion1_4) {\n        if (\"-Xlint\".equals(token)) {\n          continue; // not supported in these versions\n        }\n      }\n      if (token.startsWith(\"-J-\")) {\n        commandLine.add(token.substring(\"-J\".length()));\n      }\n      else {\n        additionalOptions.add(token);\n      }\n    }\n    \n    CompilerUtil.addLocaleOptions(commandLine, false);\n\n    commandLine.add(\"-classpath\");\n\n    if (isVersion1_0) {\n      commandLine.add(jdk.getSdkType().getToolsPath(jdk)); //  do not use JavacRunner for jdk 1.0\n    }\n    else {\n      commandLine.add(jdk.getSdkType().getToolsPath(jdk) + File.pathSeparator + PathUtilEx.getIdeaRtJarPath());\n      commandLine.add(JavacRunner.class.getName());\n      commandLine.add(\"\\\"\" + versionString + \"\\\"\");\n    }\n\n    if (isVersion1_2 || isVersion1_1 || isVersion1_0) {\n      commandLine.add(JAVAC_MAIN_CLASS_OLD);\n    }\n    else {\n      commandLine.add(JAVAC_MAIN_CLASS);\n    }\n\n    LanguageLevel languageLevel = chunk.getLanguageLevel();\n    CompilerUtil.addSourceCommandLineSwitch(jdk, languageLevel, commandLine);\n\n    commandLine.add(\"-verbose\");\n\n    final String cp = chunk.getCompilationClasspath();\n    final String bootCp = chunk.getCompilationBootClasspath();\n\n    final String classPath;\n    if (isVersion1_0 || isVersion1_1) {\n      classPath = bootCp + File.pathSeparator + cp;\n    }\n    else {\n      classPath = cp;\n      commandLine.add(\"-bootclasspath\");\n      addClassPathValue(jdk, false, commandLine, bootCp, \"javac_bootcp\");\n    }\n\n    commandLine.add(\"-classpath\");\n    addClassPathValue(jdk, isVersion1_0, commandLine, classPath, \"javac_cp\");\n\n    if (!isVersion1_1 && !isVersion1_0) {\n      commandLine.add(\"-sourcepath\");\n      // this way we tell the compiler that the sourcepath is \"empty\". However, javac thinks that sourcepath is 'new File(\"\")'\n      // this may cause problems if we have java code in IDEA working directory\n      commandLine.add(\"\\\"\\\"\");\n    }\n\n    commandLine.add(\"-d\");\n    commandLine.add(outputPath.replace('/', File.separatorChar));\n\n    for (String option : additionalOptions) {\n      commandLine.add(option);\n    }\n    \n    final VirtualFile[] files = chunk.getFilesToCompile();\n\n    if (isVersion1_0) {\n      for (VirtualFile file : files) {\n        String path = file.getPath();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding path for compilation \" + path);\n        }\n        commandLine.add(CompilerUtil.quotePath(path));\n      }\n    }\n    else {\n      File sourcesFile = FileUtil.createTempFile(\"javac\", \".tmp\");\n      sourcesFile.deleteOnExit();\n      myTempFiles.add(sourcesFile);\n      final PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(sourcesFile)));\n      try {\n        for (final VirtualFile file : files) {\n          // Important: should use \"/\" slashes!\n          // but not for JDK 1.5 - see SCR 36673\n          final String path = isVersion1_5_or_higher ? file.getPath().replace('/', File.separatorChar) : file.getPath();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Adding path for compilation \" + path);\n          }\n          writer.println(isVersion1_1 ? path : CompilerUtil.quotePath(path));\n        }\n      }\n      finally {\n        writer.close();\n      }\n      commandLine.add(\"@\" + sourcesFile.getAbsolutePath());\n    }\n  }","id":23343,"modified_method":"private void _createStartupCommand(final ModuleChunk chunk, @NonNls final ArrayList<String> commandLine, final String outputPath) throws IOException {\n    final Sdk jdk = getJdkForStartupCommand(chunk);\n    final String versionString = jdk.getVersionString();\n    if (versionString == null || \"\".equals(versionString)) {\n      throw new IllegalArgumentException(CompilerBundle.message(\"javac.error.unknown.jdk.version\", jdk.getName()));\n    }\n\n    final JavaSdkType sdkType = (JavaSdkType)jdk.getSdkType();\n    final String toolsJarPath = sdkType.getToolsPath(jdk);\n    if (toolsJarPath == null) {\n      throw new IllegalArgumentException(CompilerBundle.message(\"javac.error.tools.jar.missing\", jdk.getName()));\n    }\n\n    final boolean isVersion1_0 = CompilerUtil.isOfVersion(versionString, \"1.0\");\n    final boolean isVersion1_1 = CompilerUtil.isOfVersion(versionString, \"1.1\");\n    final boolean isVersion1_2 = CompilerUtil.isOfVersion(versionString, \"1.2\");\n    final boolean isVersion1_3 = CompilerUtil.isOfVersion(versionString, \"1.3\");\n    final boolean isVersion1_4 = CompilerUtil.isOfVersion(versionString, \"1.4\");\n    final boolean isVersion1_5 = CompilerUtil.isOfVersion(versionString, \"1.5\") || CompilerUtil.isOfVersion(versionString, \"5.0\");\n    final boolean isVersion1_5_or_higher = isVersion1_5 || !(isVersion1_0 || isVersion1_1 || isVersion1_2 || isVersion1_3 || isVersion1_4);\n\n    final JavacSettings javacSettings = JavacSettings.getInstance(myProject);\n\n    final String vmExePath = sdkType.getVMExecutablePath(jdk);\n\n    commandLine.add(vmExePath);\n    if (isVersion1_1 || isVersion1_0) {\n      commandLine.add(\"-mx\" + javacSettings.MAXIMUM_HEAP_SIZE + \"m\");\n    }\n    else {\n      commandLine.add(\"-Xmx\" + javacSettings.MAXIMUM_HEAP_SIZE + \"m\");\n    }\n\n    final List<String> additionalOptions = new ArrayList<String>();\n    StringTokenizer tokenizer = new StringTokenizer(javacSettings.getOptionsString(), \" \");\n    while (tokenizer.hasMoreTokens()) {\n      @NonNls String token = tokenizer.nextToken();\n      if (isVersion1_0) {\n        if (\"-deprecation\".equals(token)) {\n          continue; // not supported for this version\n        }\n      }\n      if (isVersion1_0 || isVersion1_1 || isVersion1_2 || isVersion1_3 || isVersion1_4) {\n        if (\"-Xlint\".equals(token)) {\n          continue; // not supported in these versions\n        }\n      }\n      if (token.startsWith(\"-J-\")) {\n        commandLine.add(token.substring(\"-J\".length()));\n      }\n      else {\n        additionalOptions.add(token);\n      }\n    }\n\n    CompilerUtil.addLocaleOptions(commandLine, false);\n\n    commandLine.add(\"-classpath\");\n\n    if (isVersion1_0) {\n      commandLine.add(sdkType.getToolsPath(jdk)); //  do not use JavacRunner for jdk 1.0\n    }\n    else {\n      commandLine.add(sdkType.getToolsPath(jdk) + File.pathSeparator + PathUtilEx.getIdeaRtJarPath());\n      commandLine.add(JavacRunner.class.getName());\n      commandLine.add(\"\\\"\" + versionString + \"\\\"\");\n    }\n\n    if (isVersion1_2 || isVersion1_1 || isVersion1_0) {\n      commandLine.add(JAVAC_MAIN_CLASS_OLD);\n    }\n    else {\n      commandLine.add(JAVAC_MAIN_CLASS);\n    }\n\n    LanguageLevel languageLevel = chunk.getLanguageLevel();\n    CompilerUtil.addSourceCommandLineSwitch(jdk, languageLevel, commandLine);\n\n    commandLine.add(\"-verbose\");\n\n    final String cp = chunk.getCompilationClasspath();\n    final String bootCp = chunk.getCompilationBootClasspath();\n\n    final String classPath;\n    if (isVersion1_0 || isVersion1_1) {\n      classPath = bootCp + File.pathSeparator + cp;\n    }\n    else {\n      classPath = cp;\n      commandLine.add(\"-bootclasspath\");\n      addClassPathValue(jdk, false, commandLine, bootCp, \"javac_bootcp\");\n    }\n\n    commandLine.add(\"-classpath\");\n    addClassPathValue(jdk, isVersion1_0, commandLine, classPath, \"javac_cp\");\n\n    if (!isVersion1_1 && !isVersion1_0) {\n      commandLine.add(\"-sourcepath\");\n      // this way we tell the compiler that the sourcepath is \"empty\". However, javac thinks that sourcepath is 'new File(\"\")'\n      // this may cause problems if we have java code in IDEA working directory\n      commandLine.add(\"\\\"\\\"\");\n    }\n\n    commandLine.add(\"-d\");\n    commandLine.add(outputPath.replace('/', File.separatorChar));\n\n    for (String option : additionalOptions) {\n      commandLine.add(option);\n    }\n\n    final VirtualFile[] files = chunk.getFilesToCompile();\n\n    if (isVersion1_0) {\n      for (VirtualFile file : files) {\n        String path = file.getPath();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding path for compilation \" + path);\n        }\n        commandLine.add(CompilerUtil.quotePath(path));\n      }\n    }\n    else {\n      File sourcesFile = FileUtil.createTempFile(\"javac\", \".tmp\");\n      sourcesFile.deleteOnExit();\n      myTempFiles.add(sourcesFile);\n      final PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(sourcesFile)));\n      try {\n        for (final VirtualFile file : files) {\n          // Important: should use \"/\" slashes!\n          // but not for JDK 1.5 - see SCR 36673\n          final String path = isVersion1_5_or_higher ? file.getPath().replace('/', File.separatorChar) : file.getPath();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Adding path for compilation \" + path);\n          }\n          writer.println(isVersion1_1 ? path : CompilerUtil.quotePath(path));\n        }\n      }\n      finally {\n        writer.close();\n      }\n      commandLine.add(\"@\" + sourcesFile.getAbsolutePath());\n    }\n  }","commit_id":"18305e2fa02504f8f57c9c6b53f5334819c32247","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String[] createParserSetupCommand(final Sdk jdk) {\n\n    final VirtualFile homeDirectory = jdk.getHomeDirectory();\n    if (homeDirectory == null) {\n      throw new IllegalArgumentException(CompilerBundle.jdkHomeNotFoundMessage(jdk));\n    }\n\n    final List<String> commandLine = new ArrayList<String>();\n    commandLine.add(jdk.getSdkType().getVMExecutablePath(jdk));\n\n    CompilerUtil.addLocaleOptions(commandLine, false);\n\n    //noinspection HardCodedStringLiteral\n    commandLine.add(\"-classpath\");\n    commandLine.add(jdk.getSdkType().getToolsPath(jdk) + File.pathSeparator + PathUtilEx.getIdeaRtJarPath());\n\n    commandLine.add(JavacResourcesReader.class.getName());\n\n    return commandLine.toArray(new String[commandLine.size()]);\n  }","id":23344,"modified_method":"private static String[] createParserSetupCommand(final Sdk jdk) {\n\n    final VirtualFile homeDirectory = jdk.getHomeDirectory();\n    if (homeDirectory == null) {\n      throw new IllegalArgumentException(CompilerBundle.jdkHomeNotFoundMessage(jdk));\n    }\n\n    final List<String> commandLine = new ArrayList<String>();\n    commandLine.add(((JavaSdkType)jdk.getSdkType()).getVMExecutablePath(jdk));\n\n    CompilerUtil.addLocaleOptions(commandLine, false);\n\n    //noinspection HardCodedStringLiteral\n    commandLine.add(\"-classpath\");\n    commandLine.add(((JavaSdkType)jdk.getSdkType()).getToolsPath(jdk) + File.pathSeparator + PathUtilEx.getIdeaRtJarPath());\n\n    commandLine.add(JavacResourcesReader.class.getName());\n\n    return commandLine.toArray(new String[commandLine.size()]);\n  }","commit_id":"18305e2fa02504f8f57c9c6b53f5334819c32247","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setupExeParams(final Sdk jdk, GeneralCommandLine cmdLine) throws ExecutionException {\n      final String jdkPath = jdk != null? new File(jdk.getSdkType().getVMExecutablePath(jdk)).getParent() : null;\n      if (jdkPath == null) {\n        throw new CantRunException(JavadocBundle.message(\"javadoc.generate.no.jdk.path\"));\n      }\n      String versionString = jdk.getVersionString();\n      if (HEAP_SIZE != null && HEAP_SIZE.trim().length() != 0) {\n        if (versionString.indexOf(\"1.1\") > -1) {\n          cmdLine.getParametersList().prepend(\"-J-mx\" + HEAP_SIZE + \"m\");\n        }\n        else {\n          cmdLine.getParametersList().prepend(\"-J-Xmx\" + HEAP_SIZE + \"m\");\n        }\n      }\n      cmdLine.setWorkingDirectory(null);\n      @NonNls final String javadocExecutableName = File.separator + (SystemInfo.isWindows ? \"javadoc.exe\" : \"javadoc\");\n      @NonNls String exePath = jdkPath.replace('/', File.separatorChar) + javadocExecutableName;\n      if (new File(exePath).exists()) {\n        cmdLine.setExePath(exePath);\n      } else { //try to use wrapper jdk\n        exePath = new File(jdkPath).getParent().replace('/', File.separatorChar) + javadocExecutableName;\n        if (!new File(exePath).exists()){\n          final File parent = new File(System.getProperty(\"java.home\")).getParentFile(); //try system jre\n          exePath = parent.getPath() + File.separator + \"bin\" + javadocExecutableName;\n          if (!new File(exePath).exists()){\n            throw new CantRunException(JavadocBundle.message(\"javadoc.generate.no.jdk.path\"));\n          }\n        }\n        cmdLine.setExePath(exePath);\n      }\n    }","id":23345,"modified_method":"private void setupExeParams(final Sdk jdk, GeneralCommandLine cmdLine) throws ExecutionException {\n      final String jdkPath = jdk != null && jdk.getSdkType() instanceof JavaSdkType ? ((JavaSdkType)jdk.getSdkType()).getBinPath(jdk) : null;\n      if (jdkPath == null) {\n        throw new CantRunException(JavadocBundle.message(\"javadoc.generate.no.jdk.path\"));\n      }\n      String versionString = jdk.getVersionString();\n      if (HEAP_SIZE != null && HEAP_SIZE.trim().length() != 0) {\n        if (versionString.indexOf(\"1.1\") > -1) {\n          cmdLine.getParametersList().prepend(\"-J-mx\" + HEAP_SIZE + \"m\");\n        }\n        else {\n          cmdLine.getParametersList().prepend(\"-J-Xmx\" + HEAP_SIZE + \"m\");\n        }\n      }\n      cmdLine.setWorkingDirectory(null);\n      @NonNls final String javadocExecutableName = File.separator + (SystemInfo.isWindows ? \"javadoc.exe\" : \"javadoc\");\n      @NonNls String exePath = jdkPath.replace('/', File.separatorChar) + javadocExecutableName;\n      if (new File(exePath).exists()) {\n        cmdLine.setExePath(exePath);\n      } else { //try to use wrapper jdk\n        exePath = new File(jdkPath).getParent().replace('/', File.separatorChar) + javadocExecutableName;\n        if (!new File(exePath).exists()){\n          final File parent = new File(System.getProperty(\"java.home\")).getParentFile(); //try system jre\n          exePath = parent.getPath() + File.separator + \"bin\" + javadocExecutableName;\n          if (!new File(exePath).exists()){\n            throw new CantRunException(JavadocBundle.message(\"javadoc.generate.no.jdk.path\"));\n          }\n        }\n        cmdLine.setExePath(exePath);\n      }\n    }","commit_id":"18305e2fa02504f8f57c9c6b53f5334819c32247","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean createAutogeneratedLibraryFor(final Sdk flexSdk) {\n    return flexSdk != null && (flexSdk.getSdkType() instanceof FlexSdkType || flexSdk.getSdkType() instanceof AirSdkType);\n  }","id":23346,"modified_method":"private static boolean createAutogeneratedLibraryFor(final Sdk flexSdk) {\n    return flexSdk != null &&\n           flexSdk.getSdkType() instanceof IFlexSdkType &&\n           ((IFlexSdkType)flexSdk.getSdkType()).getSubtype() != IFlexSdkType.Subtype.Flexmojos;\n  }","commit_id":"4b941f6bdc1994821a928d3b286c12246e24f252","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public static List<Sdk> getAllFlexAndAirSdks() {\n    List<Sdk> result = new ArrayList<Sdk>();\n    final Sdk[] sdks = ProjectJdkTable.getInstance().getAllJdks();\n    for (Sdk sdk : sdks) {\n      final SdkType sdkType = sdk.getSdkType();\n      if (sdkType instanceof FlexSdkType || sdkType instanceof AirSdkType) {\n        result.add(sdk);\n      }\n    }\n    return result;\n  }","id":23347,"modified_method":"public static List<Sdk> getAllFlexOrAirOrMobileSdks() {\n    List<Sdk> result = new ArrayList<Sdk>();\n    final Sdk[] sdks = ProjectJdkTable.getInstance().getAllJdks();\n    for (Sdk sdk : sdks) {\n      final SdkType sdkType = sdk.getSdkType();\n      if (sdkType instanceof FlexSdkType || sdkType instanceof AirSdkType) {\n        result.add(sdk);\n      }\n    }\n    return result;\n  }","commit_id":"4b941f6bdc1994821a928d3b286c12246e24f252","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public static boolean hasDependencyOnAir(final @NotNull Module module) {\n    return hasDependencyOn(module, AirSdkType.getInstance(), \"Maven: com.adobe.flex.framework:framework:swc:\");\n  }","id":23348,"modified_method":"public static boolean hasDependencyOnAir(final @NotNull Module module) {\n    return hasDependencyOn(module, AirSdkType.getInstance(), \"Maven: com.adobe.flex.framework:airframework:swc:\");\n  }","commit_id":"4b941f6bdc1994821a928d3b286c12246e24f252","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  private static Sdk findSimilarSdk(final String version) {\n    final int index = version.lastIndexOf('.');\n    if (index <= 0) return null;\n\n    final List<Sdk> sdks = FlexSdkUtils.getAllFlexAndAirSdks();\n\n    // try to find the same version\n    final String baseVersion = version.substring(0, index);\n    final String revision = version.substring(index + 1, version.length());\n    Sdk sdk = selectSdk(sdks, new Processor<String>() {\n      public boolean process(final String sdkVersion) {\n        return sdkVersion.startsWith(baseVersion) && sdkVersion.endsWith(revision);\n      }\n    });\n\n    if (sdk == null) {\n      // the same version not found. Try to find the same major version\n      final String majorVersion = version.substring(0, version.indexOf('.') + 1);\n      sdk = selectSdk(sdks, new Processor<String>() {\n        public boolean process(final String sdkVersion) {\n          return sdkVersion.startsWith(majorVersion);\n        }\n      });\n    }\n\n    if (sdk == null) {\n      // the same major version not found. Take any.\n      if (!sdks.isEmpty()) {\n        sdk = sdks.get(0);\n      }\n    }\n\n    return sdk;\n  }","id":23349,"modified_method":"@Nullable\n  private static Sdk findSimilarSdk(final String version) {\n    final int index = version.lastIndexOf('.');\n    if (index <= 0) return null;\n\n    final List<Sdk> sdks = FlexSdkUtils.getAllFlexOrAirOrMobileSdks();\n\n    // try to find the same version\n    final String baseVersion = version.substring(0, index);\n    final String revision = version.substring(index + 1, version.length());\n    Sdk sdk = selectSdk(sdks, new Processor<String>() {\n      public boolean process(final String sdkVersion) {\n        return sdkVersion.startsWith(baseVersion) && sdkVersion.endsWith(revision);\n      }\n    });\n\n    if (sdk == null) {\n      // the same version not found. Try to find the same major version\n      final String majorVersion = version.substring(0, version.indexOf('.') + 1);\n      sdk = selectSdk(sdks, new Processor<String>() {\n        public boolean process(final String sdkVersion) {\n          return sdkVersion.startsWith(majorVersion);\n        }\n      });\n    }\n\n    if (sdk == null) {\n      // the same major version not found. Take any.\n      if (!sdks.isEmpty()) {\n        sdk = sdks.get(0);\n      }\n    }\n\n    return sdk;\n  }","commit_id":"4b941f6bdc1994821a928d3b286c12246e24f252","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void checkNotNullFieldsInitialized(PsiField field,\n                                                    Annotated annotated,\n                                                    NullableNotNullManager manager, @NotNull ProblemsHolder holder) {\n    if (annotated.isDeclaredNotNull && !HighlightControlFlowUtil.isFieldInitializedAfterObjectConstruction(field)) {\n      final PsiAnnotation annotation = AnnotationUtil.findAnnotation(field, manager.getNotNulls());\n      if (annotation != null) {\n        holder.registerProblem(annotation.isPhysical() ? annotation : field.getNameIdentifier(),\n                               \"Not-null fields must be initialized\",\n                               ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n      }\n    }\n  }","id":23350,"modified_method":"private static void checkNotNullFieldsInitialized(PsiField field, NullableNotNullManager manager, @NotNull ProblemsHolder holder) {\n    PsiAnnotation annotation = manager.getNotNullAnnotation(field, false);\n    if (annotation == null || HighlightControlFlowUtil.isFieldInitializedAfterObjectConstruction(field)) return;\n\n    boolean byDefault = manager.isContainerAnnotation(annotation);\n    PsiJavaCodeReferenceElement name = annotation.getNameReferenceElement();\n    holder.registerProblem(annotation.isPhysical() && !byDefault ? annotation : field.getNameIdentifier(),\n                           (byDefault && name != null ? \"@\" + name.getReferenceName() : \"Not-null\") + \" fields must be initialized\");\n  }","commit_id":"2b9e895827478521a427cb812a1069fba473ac85","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder, boolean isOnTheFly) {\n    final PsiFile file = holder.getFile();\n    if (!PsiUtil.isLanguageLevel5OrHigher(file) || nullabilityAnnotationsNotAvailable(file)) {\n      return new PsiElementVisitor() { };\n    }\n    return new JavaElementVisitor() {\n      @Override\n      public void visitMethod(PsiMethod method) {\n        checkNullableStuffForMethod(method, holder);\n      }\n\n      @Override\n      public void visitField(PsiField field) {\n        final PsiType type = field.getType();\n        final Annotated annotated = check(field, holder, type);\n        if (TypeConversionUtil.isPrimitiveAndNotNull(type)) {\n          return;\n        }\n        Project project = holder.getProject();\n        final NullableNotNullManager manager = NullableNotNullManager.getInstance(project);\n        if (annotated.isDeclaredNotNull ^ annotated.isDeclaredNullable) {\n          final String anno = annotated.isDeclaredNotNull ? manager.getDefaultNotNull() : manager.getDefaultNullable();\n          final List<String> annoToRemove = annotated.isDeclaredNotNull ? manager.getNullables() : manager.getNotNulls();\n\n          if (!checkNonStandardAnnotations(field, annotated, manager, anno, holder)) return;\n\n          checkAccessors(field, annotated, project, manager, anno, annoToRemove, holder);\n\n          if (REQUIRE_NOTNULL_FIELDS_INITIALIZED) {\n            checkNotNullFieldsInitialized(field, annotated, manager, holder);\n          }\n\n          checkConstructorParameters(field, annotated, manager, anno, annoToRemove, holder);\n        }\n      }\n\n      @Override\n      public void visitParameter(PsiParameter parameter) {\n        check(parameter, holder, parameter.getType());\n      }\n\n      @Override\n      public void visitAnnotation(PsiAnnotation annotation) {\n        if (!AnnotationUtil.NOT_NULL.equals(annotation.getQualifiedName())) return;\n\n        PsiAnnotationMemberValue value = annotation.findDeclaredAttributeValue(\"exception\");\n        if (value instanceof PsiClassObjectAccessExpression) {\n          PsiClass psiClass = PsiUtil.resolveClassInClassTypeOnly(((PsiClassObjectAccessExpression)value).getOperand().getType());\n          if (psiClass != null && !hasStringConstructor(psiClass)) {\n            //noinspection DialogTitleCapitalization\n            holder.registerProblem(value,\n                                   \"Custom exception class should have a constructor with a single message parameter of String type\",\n                                   ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n\n          }\n        }\n      }\n\n      private boolean hasStringConstructor(PsiClass aClass) {\n        for (PsiMethod method : aClass.getConstructors()) {\n          PsiParameterList list = method.getParameterList();\n          if (list.getParametersCount() == 1 &&\n              list.getParameters()[0].getType().equalsToText(CommonClassNames.JAVA_LANG_STRING)) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n  }","id":23351,"modified_method":"@Override\n  @NotNull\n  public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder, boolean isOnTheFly) {\n    final PsiFile file = holder.getFile();\n    if (!PsiUtil.isLanguageLevel5OrHigher(file) || nullabilityAnnotationsNotAvailable(file)) {\n      return new PsiElementVisitor() { };\n    }\n    return new JavaElementVisitor() {\n      @Override\n      public void visitMethod(PsiMethod method) {\n        checkNullableStuffForMethod(method, holder);\n      }\n\n      @Override\n      public void visitField(PsiField field) {\n        final PsiType type = field.getType();\n        final Annotated annotated = check(field, holder, type);\n        if (TypeConversionUtil.isPrimitiveAndNotNull(type)) {\n          return;\n        }\n        Project project = holder.getProject();\n        final NullableNotNullManager manager = NullableNotNullManager.getInstance(project);\n        if (annotated.isDeclaredNotNull ^ annotated.isDeclaredNullable) {\n          final String anno = annotated.isDeclaredNotNull ? manager.getDefaultNotNull() : manager.getDefaultNullable();\n          final List<String> annoToRemove = annotated.isDeclaredNotNull ? manager.getNullables() : manager.getNotNulls();\n\n          if (!checkNonStandardAnnotations(field, annotated, manager, anno, holder)) return;\n\n          checkAccessors(field, annotated, project, manager, anno, annoToRemove, holder);\n\n          checkConstructorParameters(field, annotated, manager, anno, annoToRemove, holder);\n        }\n\n        if (REQUIRE_NOTNULL_FIELDS_INITIALIZED && !annotated.isDeclaredNullable) {\n          checkNotNullFieldsInitialized(field, manager, holder);\n        }\n      }\n\n      @Override\n      public void visitParameter(PsiParameter parameter) {\n        check(parameter, holder, parameter.getType());\n      }\n\n      @Override\n      public void visitAnnotation(PsiAnnotation annotation) {\n        if (!AnnotationUtil.NOT_NULL.equals(annotation.getQualifiedName())) return;\n\n        PsiAnnotationMemberValue value = annotation.findDeclaredAttributeValue(\"exception\");\n        if (value instanceof PsiClassObjectAccessExpression) {\n          PsiClass psiClass = PsiUtil.resolveClassInClassTypeOnly(((PsiClassObjectAccessExpression)value).getOperand().getType());\n          if (psiClass != null && !hasStringConstructor(psiClass)) {\n            //noinspection DialogTitleCapitalization\n            holder.registerProblem(value,\n                                   \"Custom exception class should have a constructor with a single message parameter of String type\",\n                                   ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n\n          }\n        }\n      }\n\n      private boolean hasStringConstructor(PsiClass aClass) {\n        for (PsiMethod method : aClass.getConstructors()) {\n          PsiParameterList list = method.getParameterList();\n          if (list.getParametersCount() == 1 &&\n              list.getParameters()[0].getType().equalsToText(CommonClassNames.JAVA_LANG_STRING)) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n  }","commit_id":"2b9e895827478521a427cb812a1069fba473ac85","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected PsiFile createFileCopy(PsiFile file) {\n    if (file.isPhysical()\n        // must not cache injected file copy, since it does not reflect changes in host document\n        && !InjectedLanguageManager.getInstance(file.getProject()).isInjectedFragment(file)) {\n      final SoftReference<PsiFile> reference = file.getUserData(FILE_COPY_KEY);\n      if (reference != null) {\n        final PsiFile copy = reference.get();\n        if (copy != null && copy.isValid() && copy.getClass().equals(file.getClass())) {\n          final Document document = copy.getViewProvider().getDocument();\n          assert document != null;\n          document.setText(file.getText());\n          PsiDocumentManager.getInstance(copy.getProject()).commitDocument(document);\n          return copy;\n        }\n      }\n    }\n\n    final PsiFile copy = (PsiFile)file.copy();\n    file.putUserData(FILE_COPY_KEY, new SoftReference<PsiFile>(copy));\n    return copy;\n  }","id":23352,"modified_method":"protected PsiFile createFileCopy(PsiFile file) {\n    final VirtualFile virtualFile = file.getVirtualFile();\n    if (file.isPhysical() && virtualFile != null && virtualFile.getFileSystem() == LocalFileSystem.getInstance()\n        // must not cache injected file copy, since it does not reflect changes in host document\n        && !InjectedLanguageManager.getInstance(file.getProject()).isInjectedFragment(file)) {\n      final SoftReference<PsiFile> reference = file.getUserData(FILE_COPY_KEY);\n      if (reference != null) {\n        final PsiFile copy = reference.get();\n        if (copy != null && copy.isValid() && copy.getClass().equals(file.getClass())) {\n          final Document document = copy.getViewProvider().getDocument();\n          assert document != null;\n          document.setText(file.getText());\n          PsiDocumentManager.getInstance(copy.getProject()).commitDocument(document);\n          return copy;\n        }\n      }\n    }\n\n    final PsiFile copy = (PsiFile)file.copy();\n    file.putUserData(FILE_COPY_KEY, new SoftReference<PsiFile>(copy));\n    return copy;\n  }","commit_id":"39d5810322bb9a0db5819f08906eedf61ed774b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doComplete(final int offset1,\n                            final int offset2,\n                            final CompletionContext context,\n                            final FileCopyPatcher patcher, final Editor editor, final int invocationCount) {\n    if (!ApplicationManager.getApplication().isUnitTestMode() && context.editor.getComponent().getRootPane() == null) {\n      return;\n    }\n\n\n    final Pair<CompletionContext, PsiElement> insertedInfo = new WriteCommandAction<Pair<CompletionContext, PsiElement>>(context.project) {\n      protected void run(Result<Pair<CompletionContext, PsiElement>> result) throws Throwable {\n        result.setResult(insertDummyIdentifier(context, patcher));\n      }\n    }.execute().getResultObject();\n\n    final PsiElement insertedElement = insertedInfo.getSecond();\n    final CompletionContext newContext = insertedInfo.getFirst();\n    insertedElement.putUserData(CompletionContext.COMPLETION_CONTEXT_KEY, newContext);\n\n    PsiFile originalFile = newContext.file;\n    final PsiFile rightLanguagedOriginal = originalFile.getViewProvider().getPsi(insertedElement.getContainingFile().getLanguage());\n    if (rightLanguagedOriginal != null) {\n      originalFile = rightLanguagedOriginal;\n    }\n\n    final CompletionParameters parameters = new CompletionParameters(insertedElement, originalFile, myCompletionType, newContext.getStartOffset(), invocationCount);\n\n    final Semaphore freezeSemaphore = new Semaphore();\n    freezeSemaphore.down();\n    final CompletionProgressIndicator indicator = new CompletionProgressIndicator(editor, parameters, this, context, freezeSemaphore);\n\n    final Ref<LookupElement[]> data = Ref.create(null);\n\n    final Runnable computeRunnable = new Runnable() {\n      public void run() {\n        ProgressManager.getInstance().runProcess(new Runnable() {\n          public void run() {\n            try {\n\n              final LookupElement[] items = CompletionService.getCompletionService().performCompletion(parameters, new Consumer<LookupElement>() {\n                public void consume(final LookupElement lookupElement) {\n                  indicator.addItem(lookupElement);\n                }\n              });\n              indicator.getLookup().setCalculating(false);\n\n              data.set(items);\n              freezeSemaphore.up();\n              if (items.length == 0) {\n                ApplicationManager.getApplication().invokeLater(new Runnable() {\n                  public void run() {\n                    if (indicator != CompletionServiceImpl.getCompletionService().getCurrentCompletion()) return;\n                    final Lookup lookup = LookupManager.getActiveLookup(editor);\n                    assert lookup == indicator.getLookup() : lookup;\n\n                    indicator.closeAndFinish();\n                    if (editor.isDisposed()) return;\n\n                    CompletionProgressIndicator completion = CompletionServiceImpl.getCompletionService().getCurrentCompletion();\n                    assert completion == null : \"1 this=\" + indicator + \"\\ncurrent=\" + completion;\n                    HintManager.getInstance().hideAllHints();\n                    completion = CompletionServiceImpl.getCompletionService().getCurrentCompletion();\n                    assert completion == null : \"2 this=\" + indicator + \"\\ncurrent=\" + completion;\n                    handleEmptyLookup(context, parameters, indicator);\n                  }\n                });\n              }\n            }\n            catch (ProcessCanceledException ignored) {\n            }\n          }\n        }, indicator);\n      }\n    };\n\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      computeRunnable.run();\n\n      if (data.get().length == 0) {\n        indicator.closeAndFinish();\n      }\n    } else {\n      ApplicationManager.getApplication().executeOnPooledThread(computeRunnable);\n\n      if (!freezeSemaphore.waitFor(2000) || data.isNull()) {\n        indicator.showLookup();\n        return;\n      }\n    }\n\n    completionFinished(offset1, offset2, context, indicator, data.get());\n  }","id":23353,"modified_method":"protected void doComplete(final int offset1,\n                            final int offset2,\n                            final CompletionContext context,\n                            final FileCopyPatcher patcher, final Editor editor, final int invocationCount) {\n    if (!ApplicationManager.getApplication().isUnitTestMode() && context.editor.getComponent().getRootPane() == null) {\n      return;\n    }\n\n\n    final Pair<CompletionContext, PsiElement> insertedInfo = new WriteCommandAction<Pair<CompletionContext, PsiElement>>(context.project) {\n      protected void run(Result<Pair<CompletionContext, PsiElement>> result) throws Throwable {\n        result.setResult(insertDummyIdentifier(context, patcher));\n      }\n    }.execute().getResultObject();\n\n    final PsiElement insertedElement = insertedInfo.getSecond();\n    final CompletionContext newContext = insertedInfo.getFirst();\n    insertedElement.putUserData(CompletionContext.COMPLETION_CONTEXT_KEY, newContext);\n\n    PsiFile originalFile = newContext.file;\n    final PsiFile rightLanguagedOriginal = originalFile.getViewProvider().getPsi(insertedElement.getContainingFile().getLanguage());\n    if (rightLanguagedOriginal != null) {\n      originalFile = rightLanguagedOriginal;\n    }\n\n    final CompletionParameters parameters = new CompletionParameters(insertedElement, originalFile, myCompletionType, newContext.getStartOffset(), invocationCount);\n\n    final Semaphore freezeSemaphore = new Semaphore();\n    freezeSemaphore.down();\n    final CompletionProgressIndicator indicator = new CompletionProgressIndicator(editor, parameters, this, context, freezeSemaphore);\n\n    final Ref<LookupElement[]> data = Ref.create(null);\n    final ModalityState modalityState = ModalityState.current();\n    final Runnable computeRunnable = new Runnable() {\n      public void run() {\n        ProgressManager.getInstance().runProcess(new Runnable() {\n          public void run() {\n            try {\n\n              final LookupElement[] items = CompletionService.getCompletionService().performCompletion(parameters, new Consumer<LookupElement>() {\n                public void consume(final LookupElement lookupElement) {\n                  indicator.addItem(lookupElement);\n                }\n              });\n              indicator.getLookup().setCalculating(false);\n\n              data.set(items);\n              freezeSemaphore.up();\n              if (items.length == 0) {\n                ApplicationManager.getApplication().invokeLater(new Runnable() {\n                  public void run() {\n                    if (indicator != CompletionServiceImpl.getCompletionService().getCurrentCompletion()) return;\n                    final Lookup lookup = LookupManager.getActiveLookup(editor);\n                    assert lookup == indicator.getLookup() : lookup;\n\n                    indicator.closeAndFinish();\n                    if (editor.isDisposed()) return;\n\n                    CompletionProgressIndicator completion = CompletionServiceImpl.getCompletionService().getCurrentCompletion();\n                    assert completion == null : \"1 this=\" + indicator + \"\\ncurrent=\" + completion;\n                    HintManager.getInstance().hideAllHints();\n                    completion = CompletionServiceImpl.getCompletionService().getCurrentCompletion();\n                    assert completion == null : \"2 this=\" + indicator + \"\\ncurrent=\" + completion;\n                    handleEmptyLookup(context, parameters, indicator);\n                  }\n                }, modalityState);\n              }\n            }\n            catch (ProcessCanceledException ignored) {\n            }\n          }\n        }, indicator);\n      }\n    };\n\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      computeRunnable.run();\n\n      if (data.get().length == 0) {\n        indicator.closeAndFinish();\n      }\n    } else {\n      ApplicationManager.getApplication().executeOnPooledThread(computeRunnable);\n\n      if (!freezeSemaphore.waitFor(2000) || data.isNull()) {\n        indicator.showLookup();\n        return;\n      }\n    }\n\n    completionFinished(offset1, offset2, context, indicator, data.get());\n  }","commit_id":"39d5810322bb9a0db5819f08906eedf61ed774b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean xmlElementsEqual(@NotNull final PsiElement fst, @NotNull final PsiElement snd) {\n    if (fst.equals(snd)) return true;\n\n    if (fst.isPhysical() || snd.isPhysical()) return false;\n    if (fst.getTextLength() != snd.getTextLength()) return false;\n    if (fst.getStartOffsetInParent() != snd.getStartOffsetInParent()) return false;\n\n    final PsiElement parent1 = fst.getParent();\n    final PsiElement parent2 = snd.getParent();\n    return parent1 != null && parent2 != null && xmlElementsEqual(parent1, parent2);\n  }","id":23354,"modified_method":"private static boolean xmlElementsEqual(@NotNull final PsiElement fst, @NotNull final PsiElement snd) {\n    if (fst.equals(snd)) return true;\n\n    if (fst.isValid() && fst.isPhysical() || snd.isValid() && snd.isPhysical()) return false;\n    if (fst.getTextLength() != snd.getTextLength()) return false;\n    if (fst.getStartOffsetInParent() != snd.getStartOffsetInParent()) return false;\n\n    final PsiElement parent1 = fst.getParent();\n    final PsiElement parent2 = snd.getParent();\n    return parent1 != null && parent2 != null && xmlElementsEqual(parent1, parent2);\n  }","commit_id":"e7b967e28c29cdce974fb10fa7ff7ceb221f15ac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiFile getContextFile(PsiElement ref) {\n      final PsiFile file = ref.getContainingFile();\n      if (file.isPhysical()) {\n        return file;\n      }\n      else {\n        return getContextFile(file.getContext());\n      }\n    }","id":23355,"modified_method":"private static PsiFile getContextFile(@NotNull PsiElement ref) {\n      final PsiFile file = ref.getContainingFile();\n      if (file.isPhysical() || file.getContext() == null) {\n        return file;\n      }\n      else {\n        return getContextFile(file.getContext());\n      }\n    }","commit_id":"d3be23f7ce49700522d5a354d2689816a807deca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected PsiFile createFileCopy(PsiFile file) {\n    if (file.isPhysical()) {\n      final SoftReference<PsiFile> reference = file.getUserData(FILE_COPY_KEY);\n      if (reference != null) {\n        final PsiFile copy = reference.get();\n        if (copy != null && copy.isValid() && copy.getClass().equals(file.getClass())) {\n          final Document document = copy.getViewProvider().getDocument();\n          assert document != null;\n          document.setText(file.getText());\n          PsiDocumentManager.getInstance(copy.getProject()).commitDocument(document);\n          return copy;\n        }\n      }\n    }\n\n    final PsiFile copy = (PsiFile)file.copy();\n    file.putUserData(FILE_COPY_KEY, new SoftReference<PsiFile>(copy));\n    return copy;\n  }","id":23356,"modified_method":"protected PsiFile createFileCopy(PsiFile file) {\n    if (file.isPhysical()\n        // must not cache injected file copy, since it does not reflect changes in host document\n        && !InjectedLanguageManager.getInstance(file.getProject()).isInjectedFragment(file)) {\n      final SoftReference<PsiFile> reference = file.getUserData(FILE_COPY_KEY);\n      if (reference != null) {\n        final PsiFile copy = reference.get();\n        if (copy != null && copy.isValid() && copy.getClass().equals(file.getClass())) {\n          final Document document = copy.getViewProvider().getDocument();\n          assert document != null;\n          document.setText(file.getText());\n          PsiDocumentManager.getInstance(copy.getProject()).commitDocument(document);\n          return copy;\n        }\n      }\n    }\n\n    final PsiFile copy = (PsiFile)file.copy();\n    file.putUserData(FILE_COPY_KEY, new SoftReference<PsiFile>(copy));\n    return copy;\n  }","commit_id":"33cd8f0a97e6ff621435763fd09a3ed2998ceb6e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiElement[] getSecondaryElements() {\n    PsiElement element = getPsiElement();\n    if (element instanceof PsiField) {\n      final PsiField field = (PsiField)element;\n      PsiClass containingClass = field.getContainingClass();\n      if (containingClass != null) {\n        final String propertyName = JavaCodeStyleManager.getInstance(getProject()).variableNameToPropertyName(field.getName(), VariableKind.FIELD);\n        PsiMethod getter = PropertyUtil.\n          findPropertyGetterWithType(propertyName, field.hasModifierProperty(PsiModifier.STATIC), field.getType(),\n                                     ContainerUtil.iterate(containingClass.getMethods()));\n        PsiMethod setter = PropertyUtil.\n          findPropertySetterWithType(propertyName, field.hasModifierProperty(PsiModifier.STATIC), field.getType(),\n                                     ContainerUtil.iterate(containingClass.getMethods()));\n        if (getter != null && getter.isPhysical() || setter != null && setter.isPhysical()) {\n          if (Messages.showDialog(FindBundle.message(\"find.field.accessors.prompt\", field.getName()),\n                                  FindBundle.message(\"find.field.accessors.title\"),\n                                  new String[]{CommonBundle.getYesButtonText(), CommonBundle.getNoButtonText()}, 0,\n                                  Messages.getQuestionIcon()) == DialogWrapper.OK_EXIT_CODE) {\n            final List<PsiElement> elements = new ArrayList<PsiElement>();\n            if (getter != null) {\n              elements.addAll(Arrays.asList(SuperMethodWarningUtil.checkSuperMethods(getter, ACTION_STRING)));\n            }\n            if (setter != null) {\n              elements.addAll(Arrays.asList(SuperMethodWarningUtil.checkSuperMethods(setter, ACTION_STRING)));\n            }\n            return elements.toArray(new PsiElement[elements.size()]);\n          }\n        }\n      }\n    }\n    return super.getSecondaryElements();\n  }","id":23357,"modified_method":"@NotNull\n  public PsiElement[] getSecondaryElements() {\n    PsiElement element = getPsiElement();\n    if (element instanceof PsiField) {\n      final PsiField field = (PsiField)element;\n      PsiClass containingClass = field.getContainingClass();\n      if (containingClass != null) {\n        final String propertyName = JavaCodeStyleManager.getInstance(getProject()).variableNameToPropertyName(field.getName(), VariableKind.FIELD);\n        PsiMethod getter = PropertyUtil.\n          findPropertyGetterWithType(propertyName, field.hasModifierProperty(PsiModifier.STATIC), field.getType(),\n                                     ContainerUtil.iterate(containingClass.getMethods()));\n        PsiMethod setter = PropertyUtil.\n          findPropertySetterWithType(propertyName, field.hasModifierProperty(PsiModifier.STATIC), field.getType(),\n                                     ContainerUtil.iterate(containingClass.getMethods()));\n        if (getter != null || setter != null) {\n          final boolean doSearch;\n          if ((getter == null || !getter.isPhysical()) && (setter == null || !setter.isPhysical())) {\n            doSearch = true;\n          } else {\n            doSearch = Messages.showDialog(FindBundle.message(\"find.field.accessors.prompt\", field.getName()),\n                                           FindBundle.message(\"find.field.accessors.title\"),\n                                           new String[]{CommonBundle.getYesButtonText(), CommonBundle.getNoButtonText()}, 0,\n                                           Messages.getQuestionIcon()) == DialogWrapper.OK_EXIT_CODE;\n          }\n          if (doSearch) {\n            final List<PsiElement> elements = new ArrayList<PsiElement>();\n            if (getter != null) {\n              elements.addAll(Arrays.asList(SuperMethodWarningUtil.checkSuperMethods(getter, ACTION_STRING)));\n            }\n            if (setter != null) {\n              elements.addAll(Arrays.asList(SuperMethodWarningUtil.checkSuperMethods(setter, ACTION_STRING)));\n            }\n            return elements.toArray(new PsiElement[elements.size()]);\n          }\n        }\n      }\n    }\n    return super.getSecondaryElements();\n  }","commit_id":"2203061d1f45e55431e6d94660cc939d7956a9cb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public TextEditorHighlightingPass createHighlightingPass(@NotNull final PsiFile file, @NotNull final Editor editor) {\n    if (!editor.isOneLineMode() &&\n        CodeInsightSettings.getInstance().HIGHLIGHT_IDENTIFIER_UNDER_CARET &&\n        (!ApplicationManager.getApplication().isHeadlessEnvironment() || ourTestingIdentifierHighlighting) &&\n        file.isPhysical()) {\n      return new IdentifierHighlighterPass(file.getProject(), file, editor);\n    }\n\n    return null;\n  }","id":23358,"modified_method":"@Override\n  public TextEditorHighlightingPass createHighlightingPass(@NotNull final PsiFile file, @NotNull final Editor editor) {\n    if (!editor.isOneLineMode() &&\n        CodeInsightSettings.getInstance().HIGHLIGHT_IDENTIFIER_UNDER_CARET &&\n        (!ApplicationManager.getApplication().isHeadlessEnvironment() || ourTestingIdentifierHighlighting) &&\n        (file.isPhysical() || file.getOriginalFile().isPhysical())) {\n      return new IdentifierHighlighterPass(file.getProject(), file, editor);\n    }\n\n    return null;\n  }","commit_id":"6ed8227f029f2a822ae494596eff3a395f6a49c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n        public boolean apply(Game game, Ability source) {\n            boolean result = false;\n\n            Player player = game.getPlayer(source.getControllerId());\n            if (player != null) {\n                Permanent permanent = game.getPermanent(source.getFirstTarget());\n                if (permanent != null) {\n                    if (permanent.isTapped()) {\n                        if (player.chooseUse(Constants.Outcome.Untap, \"Untap that permanent?\", game)) {\n                            result |= permanent.untap(game);\n                        }\n                    } else {\n                        if (player.chooseUse(Constants.Outcome.Tap, \"Tap that permanent?\", game)) {\n                            result |= permanent.tap(game);\n                        }\n                    }\n                }\n                permanent = game.getPermanent(source.getTargets().get(1).getFirstTarget());\n                if (permanent != null) {\n                    if (permanent.isTapped()) {\n                        if (player.chooseUse(Constants.Outcome.Untap, \"Untap that permanent?\", game)) {\n                            result |= permanent.untap(game);\n                        }\n                    } else {\n                        if (player.chooseUse(Constants.Outcome.Tap, \"Tap that permanent?\", game)) {\n                            result |= permanent.tap(game);\n                        }\n                    }\n                }\n            }\n            return result;\n        }","id":23359,"modified_method":"@Override\n        public boolean apply(Game game, Ability source) {\n            Player player = game.getPlayer(source.getControllerId());\n            if (player != null) {\n                for (UUID targetId : source.getTargets().get(0).getTargets()) {\n                    Permanent permanent = game.getPermanent(targetId);\n                    if (permanent != null) {\n                        if (player.chooseUse(Constants.Outcome.Tap, new StringBuilder(\"Tap \").append(permanent.getName()).append(\"?\").toString(), game)) {\n                            permanent.tap(game);\n                        } else if (player.chooseUse(Constants.Outcome.Untap, new StringBuilder(\"Untap \").append(permanent.getName()).append(\"?\").toString(), game)) {\n                            permanent.untap(game);\n                        }\n                    }\n                }\n                return true;\n            }\n            return false;\n        }","commit_id":"ce771b422b4a36ccc9ca0c1f248aea26c4314b51","url":"https://github.com/magefree/mage"},{"original_method":"public ToilsOfNightAndDay(UUID ownerId) {\n        super(ownerId, 57, \"Toils of Night and Day\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{2}{U}\");\n        this.expansionSetCode = \"BOK\";\n        this.subtype.add(\"Arcane\");\n        this.color.setBlue(true);\n        // You may tap or untap target permanent, then you may tap or untap another target permanent.\n        this.getSpellAbility().addEffect(new ToilsOfNightAndDayEffect());\n        this.getSpellAbility().addTarget(new TargetPermanent());\n        this.getSpellAbility().addTarget(new TargetPermanent());\n    }","id":23360,"modified_method":"public ToilsOfNightAndDay(UUID ownerId) {\n        super(ownerId, 57, \"Toils of Night and Day\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{2}{U}\");\n        this.expansionSetCode = \"BOK\";\n        this.subtype.add(\"Arcane\");\n        this.color.setBlue(true);\n        // You may tap or untap target permanent, then you may tap or untap another target permanent.\n        this.getSpellAbility().addEffect(new ToilsOfNightAndDayEffect());\n        this.getSpellAbility().addTarget(new TargetPermanent(0, 2, new FilterPermanent(), false));\n    }","commit_id":"ce771b422b4a36ccc9ca0c1f248aea26c4314b51","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        int number = Integer.parseInt(source.getChoices().get(0).getChoice());\r\n        for (Permanent permanent : game.getBattlefield().getActivePermanents(source.getControllerId(), game)) {\r\n            if ((permanent.getCardType().contains(CardType.ARTIFACT) || permanent.getCardType().contains(CardType.CREATURE))\r\n                    && permanent.getManaCost().convertedManaCost() == number) {\r\n                permanent.destroy(source.getId(), game, false);\r\n            }\r\n        }\r\n        Player targetPlayer = game.getPlayer(targetPointer.getFirst(game, source));\r\n        if (targetPlayer != null) {\r\n            targetPlayer.revealCards(\"Void\", targetPlayer.getHand(), game);\r\n            for (Card card : targetPlayer.getHand().getCards(game)) {\r\n                if (!card.getCardType().contains(CardType.LAND) && card.getManaCost().convertedManaCost() == number) {\r\n                    card.moveToZone(Constants.Zone.GRAVEYARD, source.getId(), game, false);\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n        return true;\r\n    }","id":23361,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        int number = Integer.parseInt(source.getChoices().get(0).getChoice());\r\n        for (Permanent permanent : game.getBattlefield().getActivePermanents(source.getControllerId(), game)) {\r\n            if ((permanent.getCardType().contains(CardType.ARTIFACT) || permanent.getCardType().contains(CardType.CREATURE))\r\n                    && permanent.getManaCost().convertedManaCost() == number) {\r\n                permanent.destroy(source.getId(), game, false);\r\n            }\r\n        }\r\n        FilterCard filterCard = new FilterCard();\r\n        filterCard.add(new ConvertedManaCostPredicate(Filter.ComparisonType.Equal, number));\r\n        filterCard.add(Predicates.not(new CardTypePredicate(CardType.LAND)));\r\n\r\n        Player targetPlayer = game.getPlayer(targetPointer.getFirst(game, source));\r\n        if (targetPlayer != null) {\r\n            targetPlayer.revealCards(\"Void\", targetPlayer.getHand(), game);\r\n            for (Card card : targetPlayer.getHand().getCards(game)) {\r\n                if (filterCard.match(card, game)) {\r\n                    card.moveToZone(Constants.Zone.GRAVEYARD, source.getId(), game, false);\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n        return true;\r\n    }","commit_id":"ce771b422b4a36ccc9ca0c1f248aea26c4314b51","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        boolean result = false;\r\n\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        if (player != null) {\r\n            Permanent permanent = game.getPermanent(source.getFirstTarget());\r\n            if (permanent != null) {\r\n                if (permanent.isTapped()) {\r\n                    if (player.chooseUse(Constants.Outcome.Untap, \"Untap that permanent?\", game)) {\r\n                        result |= permanent.untap(game);\r\n                    }\r\n                } else {\r\n                    if (player.chooseUse(Constants.Outcome.Tap, \"Tap that permanent?\", game)) {\r\n                        result |= permanent.tap(game);\r\n                    }\r\n                }\r\n            }\r\n            permanent = game.getPermanent(source.getTargets().get(1).getFirstTarget());\r\n            if (permanent != null) {\r\n                if (permanent.isTapped()) {\r\n                    if (player.chooseUse(Constants.Outcome.Untap, \"Untap that permanent?\", game)) {\r\n                        result |= permanent.untap(game);\r\n                    }\r\n                } else {\r\n                    if (player.chooseUse(Constants.Outcome.Tap, \"Tap that permanent?\", game)) {\r\n                        result |= permanent.tap(game);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }","id":23362,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n            Player player = game.getPlayer(source.getControllerId());\r\n            if (player != null) {\r\n                for (UUID targetId : source.getTargets().get(0).getTargets()) {\r\n                    Permanent permanent = game.getPermanent(targetId);\r\n                    if (permanent != null) {\r\n                        if (player.chooseUse(Constants.Outcome.Tap, new StringBuilder(\"Tap \").append(permanent.getName()).append(\"?\").toString(), game)) {\r\n                            permanent.tap(game);\r\n                        } else if (player.chooseUse(Constants.Outcome.Untap, new StringBuilder(\"Untap \").append(permanent.getName()).append(\"?\").toString(), game)) {\r\n                            permanent.untap(game);\r\n                        }\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n    }","commit_id":"e904f9e6ffc2b936bd195d1913b3007e1fc255cd","url":"https://github.com/magefree/mage"},{"original_method":"public HiddenStrings(UUID ownerId) {\r\n        super(ownerId, 12, \"Hidden Strings\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{1}{U}\");\r\n        this.expansionSetCode = \"DGM\";\r\n        this.color.setBlue(true);\r\n\r\n        // You may tap or untap target permanent, then you may tap or untap another target permanent\r\n        this.getSpellAbility().addEffect(new HiddenStringsEffect());\r\n        this.getSpellAbility().addTarget(new TargetPermanent());\r\n        this.getSpellAbility().addTarget(new TargetPermanent());\r\n        // Cipher\r\n        this.getSpellAbility().addEffect(new CipherEffect());\r\n    }","id":23363,"modified_method":"public HiddenStrings(UUID ownerId) {\r\n        super(ownerId, 12, \"Hidden Strings\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{1}{U}\");\r\n        this.expansionSetCode = \"DGM\";\r\n        this.color.setBlue(true);\r\n\r\n        // You may tap or untap target permanent, then you may tap or untap another target permanent\r\n        this.getSpellAbility().addEffect(new HiddenStringsEffect());\r\n        this.getSpellAbility().addTarget(new TargetPermanent(0, 2, new FilterPermanent(), false));\r\n\r\n        // Cipher\r\n        this.getSpellAbility().addEffect(new CipherEffect());\r\n    }","commit_id":"e904f9e6ffc2b936bd195d1913b3007e1fc255cd","url":"https://github.com/magefree/mage"},{"original_method":"public ScavengingOozeEffect() {\r\n        super(Outcome.Benefit);\r\n        this.staticText = \"Exile target card from a graveyard. If it was a creature card, put a +1/+1 counter on {this}\";\r\n    }","id":23364,"modified_method":"public ScavengingOozeEffect() {\r\n        super(Outcome.Benefit);\r\n        this.staticText = \"Exile target card from a graveyard. If it was a creature card, put a +1/+1 counter on {this} and you gain 1 life\";\r\n    }","commit_id":"643b7a5ad8fd652ffce11e95c8bb0b26a1e1f068","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Card card = game.getCard(getTargetPointer().getFirst(game, source));\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null && card != null) {\r\n            controller.moveCardToExileWithInfo(card, null, \"\", source.getSourceId(), game, Zone.GRAVEYARD);\r\n            if (card.getCardType().contains(CardType.CREATURE)) {\r\n                Permanent sourcePermanent = game.getPermanent(source.getSourceId());\r\n                if (sourcePermanent != null) {\r\n                    sourcePermanent.addCounters(CounterType.P1P1.createInstance(), game);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":23365,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Card card = game.getCard(getTargetPointer().getFirst(game, source));\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null && card != null) {\r\n            controller.moveCardToExileWithInfo(card, null, \"\", source.getSourceId(), game, Zone.GRAVEYARD);\r\n            if (card.getCardType().contains(CardType.CREATURE)) {\r\n                Permanent sourcePermanent = game.getPermanent(source.getSourceId());\r\n                if (sourcePermanent != null) {\r\n                    sourcePermanent.addCounters(CounterType.P1P1.createInstance(), game);\r\n                }\r\n                controller.gainLife(1, game);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"643b7a5ad8fd652ffce11e95c8bb0b26a1e1f068","url":"https://github.com/magefree/mage"},{"original_method":"public ScavengingOoze(UUID ownerId) {\r\n        super(ownerId, 170, \"Scavenging Ooze\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{1}{G}\");\r\n        this.expansionSetCode = \"CMD\";\r\n        this.subtype.add(\"Ooze\");\r\n\r\n        this.color.setGreen(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // {G}: Exile target card from a graveyard. If it was a creature card, put a +1/+1 counter on Scavenging Ooze and you gain 1 life.\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ScavengingOozeEffect(), new ManaCostsImpl(\"{G}\"));\r\n        ability.addTarget(new TargetCardInGraveyard());\r\n        Effect effect = new GainLifeEffect(1);\r\n        effect.setText(\"and you gain 1 life\");\r\n        ability.addEffect(effect);\r\n        this.addAbility(ability);\r\n    }","id":23366,"modified_method":"public ScavengingOoze(UUID ownerId) {\r\n        super(ownerId, 170, \"Scavenging Ooze\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{1}{G}\");\r\n        this.expansionSetCode = \"CMD\";\r\n        this.subtype.add(\"Ooze\");\r\n\r\n        this.color.setGreen(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // {G}: Exile target card from a graveyard. If it was a creature card, put a +1/+1 counter on Scavenging Ooze and you gain 1 life.\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ScavengingOozeEffect(), new ManaCostsImpl(\"{G}\"));\r\n        ability.addTarget(new TargetCardInGraveyard());\r\n        this.addAbility(ability);\r\n    }","commit_id":"643b7a5ad8fd652ffce11e95c8bb0b26a1e1f068","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        TargetLandPermanent target = new TargetLandPermanent(0, amount, new FilterLandPermanent(), true);\n        if (target.canChoose(source.getControllerId(), game)) {\n            if (target.choose(Outcome.Untap, source.getControllerId(), source.getSourceId(), game)) {\n                for (Object targetId : target.getTargets()) {\n                    Permanent p = game.getPermanent((UUID) targetId);\n                    if (p.isTapped())\n                        p.untap(game);\n                }\n            }\n        }\n        return false;\n    }","id":23367,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null) {\n            TargetLandPermanent target = new TargetLandPermanent(0, amount, new FilterLandPermanent(), true);\n            if (target.canChoose(source.getControllerId(), game)) {\n                if (target.choose(Outcome.Untap, source.getControllerId(), source.getSourceId(), game)) {\n                    for (Object targetId : target.getTargets()) {\n                        Permanent p = game.getPermanent((UUID) targetId);\n                        if (p != null) {\n                            p.untap(game);\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"643b7a5ad8fd652ffce11e95c8bb0b26a1e1f068","url":"https://github.com/magefree/mage"},{"original_method":"public BatchInsertRelationshipsStage( Configuration config, IdMapper idMapper,\n            InputIterator<InputRelationship> relationships, BatchingNeoStores store, long nextRelationshipId )\n    {\n        super( \"Minority relationships\", config, ORDER_SEND_DOWNSTREAM );\n        add( new InputIteratorBatcherStep<>( control(), config, relationships, InputRelationship.class ) );\n        add( new RelationshipPreparationStep( control(), config, idMapper ) );\n        add( new PropertyEncoderStep<>( control(), config, store.getPropertyKeyRepository(),\n                store.getPropertyStore() ) );\n        add( new BatchInsertRelationshipsStep( control(), config, store.getNeoStores(),\n                store.getRelationshipTypeRepository(), nextRelationshipId ) );\n    }","id":23368,"modified_method":"public BatchInsertRelationshipsStage( Configuration config, IdMapper idMapper,\n            InputIterator<InputRelationship> relationships, BatchingNeoStores store, long nextRelationshipId )\n    {\n        super( \"Minority relationships\", config, ORDER_SEND_DOWNSTREAM );\n        add( new InputIteratorBatcherStep<>( control(), config, relationships, InputRelationship.class ) );\n        add( new RelationshipPreparationStep( control(), config, idMapper ) );\n        add( new PropertyEncoderStep<>( control(), config, store.getPropertyKeyRepository(),\n                store.getPropertyStore() ) );\n        add( new BatchInsertRelationshipsStep( control(), config, store,\n                store.getRelationshipTypeRepository(), nextRelationshipId ) );\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"public BatchInsertRelationshipsStep( StageControl control, Configuration config, NeoStores store,\n            ToIntFunction<Object> typeToId, long nextRelationshipId )\n    {\n        super( control, \"INSERT\", config, 1 );\n        this.typeToId = typeToId;\n        this.relationshipStore = store.getRelationshipStore();\n        RelationshipGroupGetter groupGetter = new RelationshipGroupGetter( store.getRelationshipGroupStore() );\n        this.relationshipCreator = new RelationshipCreator( groupGetter, config.denseNodeThreshold() );\n        PropertyTraverser propertyTraverser = new PropertyTraverser();\n        this.propertyCreator = new PropertyCreator( store.getPropertyStore(), propertyTraverser );\n        this.recordAccess = new DirectRecordAccessSet( store );\n        this.propertyStore = store.getPropertyStore();\n        this.relationshipIdGenerator = new BatchingIdSequence( nextRelationshipId );\n    }","id":23369,"modified_method":"public BatchInsertRelationshipsStep( StageControl control, Configuration config, BatchingNeoStores store,\n            ToIntFunction<Object> typeToId, long nextRelationshipId )\n    {\n        super( control, \"INSERT\", config, 1 );\n        this.typeToId = typeToId;\n        RecordStore<RelationshipGroupRecord> relationshipGroupStore = store.getTemporaryRelationshipGroupStore();\n        RelationshipGroupGetter groupGetter = new RelationshipGroupGetter( relationshipGroupStore );\n        this.relationshipCreator = new RelationshipCreator( groupGetter, config.denseNodeThreshold() );\n        PropertyTraverser propertyTraverser = new PropertyTraverser();\n        this.propertyCreator = new PropertyCreator( store.getPropertyStore(), propertyTraverser );\n        this.propertyStore = store.getPropertyStore();\n        this.recordAccess = new DirectRecordAccessSet( store.getNodeStore(), propertyStore,\n                store.getRelationshipStore(), relationshipGroupStore,\n                store.getNeoStores().getPropertyKeyTokenStore(),\n                store.getNeoStores().getRelationshipTypeTokenStore(),\n                store.getNeoStores().getLabelTokenStore(), store.getNeoStores().getSchemaStore() );\n        this.relationshipIdGenerator = new BatchingIdSequence( nextRelationshipId );\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public void delete()\n        {\n            throw new UnsupportedOperationException();\n        }","id":23370,"modified_method":"@Override\n        public void delete()\n        {\n            // This would be equivalent of not doing anything because close() will create the file\n        }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"public BatchingNeoStores( FileSystemAbstraction fileSystem, File storeDir, RecordFormats recordFormats,\n            Configuration config, LogService logService, AdditionalInitialIds initialIds, Config dbConfig )\n    {\n        this.fileSystem = fileSystem;\n        this.recordFormats = recordFormats;\n        this.logProvider = logService.getInternalLogProvider();\n        this.storeDir = storeDir;\n        long mappedMemory = config.pageCacheMemory();\n        // 30 is the minimum number of pages the page cache wants to keep free at all times.\n        // Having less than that might result in an evicted page will reading, which would mean\n        // unnecessary re-reading. Having slightly more leaves some leg room.\n        int pageSize = calculateOptimalPageSize( mappedMemory, 60 /*pages*/ );\n        this.neo4jConfig = new Config( stringMap( dbConfig.getParams(),\n                dense_node_threshold.name(), valueOf( config.denseNodeThreshold() ),\n                pagecache_memory.name(), valueOf( mappedMemory ),\n                mapped_memory_page_size.name(), valueOf( pageSize ) ),\n                GraphDatabaseSettings.class );\n        final PageCacheTracer tracer = new DefaultPageCacheTracer();\n        this.pageCache = createPageCache( fileSystem, neo4jConfig, logProvider, tracer );\n        this.ioTracer = tracer::bytesWritten;\n        this.neoStores = newNeoStores();\n        if ( alreadyContainsData( neoStores ) )\n        {\n            neoStores.close();\n            throw new IllegalStateException( storeDir + \" already contains data, cannot do import here\" );\n        }\n        try\n        {\n            neoStores.rebuildCountStoreIfNeeded();\n        }\n        catch ( IOException e )\n        {\n            throw new UnderlyingStorageException( e );\n        }\n        neoStores.getMetaDataStore().setLastCommittedAndClosedTransactionId(\n                initialIds.lastCommittedTransactionId(), initialIds.lastCommittedTransactionChecksum(),\n                BASE_TX_COMMIT_TIMESTAMP, initialIds.lastCommittedTransactionLogByteOffset(),\n                initialIds.lastCommittedTransactionLogVersion() );\n        this.propertyKeyRepository = new BatchingPropertyKeyTokenRepository(\n                neoStores.getPropertyKeyTokenStore() );\n        this.labelRepository = new BatchingLabelTokenRepository(\n                neoStores.getLabelTokenStore() );\n        this.relationshipTypeRepository = new BatchingRelationshipTypeTokenRepository(\n                neoStores.getRelationshipTypeTokenStore() );\n\n        // Initialize kernel extensions\n        Dependencies dependencies = new Dependencies();\n        dependencies.satisfyDependency( neo4jConfig );\n        dependencies.satisfyDependency( fileSystem );\n        dependencies.satisfyDependency( this );\n        dependencies.satisfyDependency( logService );\n        dependencies.satisfyDependency( IndexStoreView.EMPTY );\n        KernelContext kernelContext = new SimpleKernelContext( fileSystem, storeDir, DatabaseInfo.UNKNOWN,\n                dependencies );\n        @SuppressWarnings( { \"unchecked\", \"rawtypes\" } )\n        KernelExtensions extensions = life.add( new KernelExtensions(\n                kernelContext, (Iterable) Service.load( KernelExtensionFactory.class ),\n                dependencies, UnsatisfiedDependencyStrategies.ignore() ) );\n        life.start();\n        labelScanStore = life.add( extensions.resolveDependency( LabelScanStoreProvider.class,\n                HighestSelectionStrategy.getInstance() ).getLabelScanStore() );\n    }","id":23371,"modified_method":"public BatchingNeoStores( FileSystemAbstraction fileSystem, File storeDir, RecordFormats recordFormats,\n            Configuration config, LogService logService, AdditionalInitialIds initialIds, Config dbConfig )\n    {\n        this.fileSystem = fileSystem;\n        this.recordFormats = recordFormats;\n        this.logProvider = logService.getInternalLogProvider();\n        this.storeDir = storeDir;\n        long mappedMemory = config.pageCacheMemory();\n        // 30 is the minimum number of pages the page cache wants to keep free at all times.\n        // Having less than that might result in an evicted page will reading, which would mean\n        // unnecessary re-reading. Having slightly more leaves some leg room.\n        int pageSize = calculateOptimalPageSize( mappedMemory, 60 /*pages*/ );\n        this.neo4jConfig = new Config( stringMap( dbConfig.getParams(),\n                dense_node_threshold.name(), valueOf( config.denseNodeThreshold() ),\n                pagecache_memory.name(), valueOf( mappedMemory ),\n                mapped_memory_page_size.name(), valueOf( pageSize ) ),\n                GraphDatabaseSettings.class );\n        final PageCacheTracer tracer = new DefaultPageCacheTracer();\n        this.pageCache = createPageCache( fileSystem, neo4jConfig, logProvider, tracer );\n        this.ioTracer = tracer::bytesWritten;\n        this.neoStores = newStoreFactory( DEFAULT_NAME ).openAllNeoStores( true );\n        if ( alreadyContainsData( neoStores ) )\n        {\n            neoStores.close();\n            throw new IllegalStateException( storeDir + \" already contains data, cannot do import here\" );\n        }\n        try\n        {\n            neoStores.rebuildCountStoreIfNeeded();\n        }\n        catch ( IOException e )\n        {\n            throw new UnderlyingStorageException( e );\n        }\n        neoStores.getMetaDataStore().setLastCommittedAndClosedTransactionId(\n                initialIds.lastCommittedTransactionId(), initialIds.lastCommittedTransactionChecksum(),\n                BASE_TX_COMMIT_TIMESTAMP, initialIds.lastCommittedTransactionLogByteOffset(),\n                initialIds.lastCommittedTransactionLogVersion() );\n        this.propertyKeyRepository = new BatchingPropertyKeyTokenRepository(\n                neoStores.getPropertyKeyTokenStore() );\n        this.labelRepository = new BatchingLabelTokenRepository(\n                neoStores.getLabelTokenStore() );\n        this.relationshipTypeRepository = new BatchingRelationshipTypeTokenRepository(\n                neoStores.getRelationshipTypeTokenStore() );\n\n        // Instantiate the temporary stores\n        temporaryNeoStores = newStoreFactory(\n                \"temp.\" + DEFAULT_NAME, DELETE_ON_CLOSE ).openNeoStores( true, RELATIONSHIP_GROUP );\n\n        // Initialize kernel extensions\n        Dependencies dependencies = new Dependencies();\n        dependencies.satisfyDependency( neo4jConfig );\n        dependencies.satisfyDependency( fileSystem );\n        dependencies.satisfyDependency( this );\n        dependencies.satisfyDependency( logService );\n        dependencies.satisfyDependency( IndexStoreView.EMPTY );\n        KernelContext kernelContext = new SimpleKernelContext( fileSystem, storeDir, DatabaseInfo.UNKNOWN,\n                dependencies );\n        @SuppressWarnings( { \"unchecked\", \"rawtypes\" } )\n        KernelExtensions extensions = life.add( new KernelExtensions(\n                kernelContext, (Iterable) Service.load( KernelExtensionFactory.class ),\n                dependencies, UnsatisfiedDependencyStrategies.ignore() ) );\n        life.start();\n        labelScanStore = life.add( extensions.resolveDependency( LabelScanStoreProvider.class,\n                HighestSelectionStrategy.getInstance() ).getLabelScanStore() );\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void close() throws IOException\n    {\n        // Flush out all pending changes\n        propertyKeyRepository.close();\n        labelRepository.close();\n        relationshipTypeRepository.close();\n\n        // Close the neo store\n        life.shutdown();\n        neoStores.close();\n        if ( replacementNeoStores != null )\n        {\n            replacementNeoStores.close();\n        }\n        pageCache.close();\n\n        if ( replacementNeoStores != null )\n        {\n            StoreFile.fileOperation( MOVE, fileSystem, replacementStoreDir(), storeDir, replacementStoreFiles(),\n                    false, ExistingTargetStrategy.OVERWRITE );\n        }\n    }","id":23372,"modified_method":"@Override\n    public void close() throws IOException\n    {\n        // Flush out all pending changes\n        propertyKeyRepository.close();\n        labelRepository.close();\n        relationshipTypeRepository.close();\n\n        // Close the neo store\n        life.shutdown();\n        neoStores.close();\n        // These temporary stores are configured to be deleted when closed\n        temporaryNeoStores.close();\n        pageCache.close();\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"public CountGroupsStage( Configuration config, BatchingNeoStores neoStore, RelationshipGroupCache groupCache )\n    {\n        super( \"Count groups\", config );\n\n        RecordStore<RelationshipGroupRecord> store = neoStore.getRelationshipGroupStore();\n        add( new ReadRecordsStep<>( control(), config, store, RecordIdIteration.allIn( store ) ) );\n        add( new CountGroupsStep( control(), config, groupCache ) );\n    }","id":23373,"modified_method":"public CountGroupsStage( Configuration config, RecordStore<RelationshipGroupRecord> store,\n            RelationshipGroupCache groupCache )\n    {\n        super( \"Count groups\", config );\n\n        add( new ReadRecordsStep<>( control(), config, store, RecordIdIteration.allIn( store ) ) );\n        add( new CountGroupsStep( control(), config, groupCache ) );\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"public DirectRecordAccessSet( NeoStores neoStores )\n    {\n        Loaders loaders = new Loaders( neoStores );\n        NodeStore nodeStore = neoStores.getNodeStore();\n        PropertyStore propertyStore = neoStores.getPropertyStore();\n        RelationshipStore relationshipStore = neoStores.getRelationshipStore();\n        RecordStore<RelationshipGroupRecord> relationshipGroupStore = neoStores.getRelationshipGroupStore();\n        PropertyKeyTokenStore propertyKeyTokenStore = neoStores.getPropertyKeyTokenStore();\n        RelationshipTypeTokenStore relationshipTypeTokenStore = neoStores.getRelationshipTypeTokenStore();\n        LabelTokenStore labelTokenStore = neoStores.getLabelTokenStore();\n        nodeRecords = new DirectRecordAccess<>( nodeStore, loaders.nodeLoader() );\n        propertyRecords = new DirectRecordAccess<>( propertyStore, loaders.propertyLoader() );\n        relationshipRecords = new DirectRecordAccess<>( relationshipStore, loaders.relationshipLoader() );\n        relationshipGroupRecords = new DirectRecordAccess<>(\n                relationshipGroupStore, loaders.relationshipGroupLoader() );\n        propertyKeyTokenRecords = new DirectRecordAccess<>( propertyKeyTokenStore, loaders.propertyKeyTokenLoader() );\n        relationshipTypeTokenRecords = new DirectRecordAccess<>(\n                relationshipTypeTokenStore, loaders.relationshipTypeTokenLoader() );\n        labelTokenRecords = new DirectRecordAccess<>( labelTokenStore, loaders.labelTokenLoader() );\n        all = new DirectRecordAccess[] {\n                nodeRecords, propertyRecords, relationshipRecords, relationshipGroupRecords,\n                propertyKeyTokenRecords, relationshipTypeTokenRecords, labelTokenRecords\n        };\n    }","id":23374,"modified_method":"public DirectRecordAccessSet( NeoStores neoStores )\n    {\n        this(\n                neoStores.getNodeStore(),\n                neoStores.getPropertyStore(),\n                neoStores.getRelationshipStore(),\n                neoStores.getRelationshipGroupStore(),\n                neoStores.getPropertyKeyTokenStore(),\n                neoStores.getRelationshipTypeTokenStore(),\n                neoStores.getLabelTokenStore(),\n                neoStores.getSchemaStore() );\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static Loader<Integer,PropertyKeyTokenRecord,Void> propertyKeyTokenLoader(\n            final TokenStore<PropertyKeyTokenRecord, Token> store )\n    {\n        return new Loader<Integer, PropertyKeyTokenRecord, Void>()\n        {\n            @Override\n            public PropertyKeyTokenRecord newUnused( Integer key, Void additionalData )\n            {\n                return andMarkAsCreated( new PropertyKeyTokenRecord( key ) );\n            }\n\n            @Override\n            public PropertyKeyTokenRecord load( Integer key, Void additionalData )\n            {\n                return store.getRecord( key, store.newRecord(), NORMAL );\n            }\n\n            @Override\n            public void ensureHeavy( PropertyKeyTokenRecord record )\n            {\n                store.ensureHeavy( record );\n            }\n\n            @Override\n            public PropertyKeyTokenRecord clone( PropertyKeyTokenRecord record )\n            {\n                return record.clone();\n            }\n        };\n    }","id":23375,"modified_method":"public static Loader<Integer,PropertyKeyTokenRecord,Void> propertyKeyTokenLoader(\n            final RecordStore<PropertyKeyTokenRecord> store )\n    {\n        return new Loader<Integer, PropertyKeyTokenRecord, Void>()\n        {\n            @Override\n            public PropertyKeyTokenRecord newUnused( Integer key, Void additionalData )\n            {\n                return andMarkAsCreated( new PropertyKeyTokenRecord( key ) );\n            }\n\n            @Override\n            public PropertyKeyTokenRecord load( Integer key, Void additionalData )\n            {\n                return store.getRecord( key, store.newRecord(), NORMAL );\n            }\n\n            @Override\n            public void ensureHeavy( PropertyKeyTokenRecord record )\n            {\n                store.ensureHeavy( record );\n            }\n\n            @Override\n            public PropertyKeyTokenRecord clone( PropertyKeyTokenRecord record )\n            {\n                return record.clone();\n            }\n        };\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static Loader<Integer,LabelTokenRecord,Void> labelTokenLoader(\n            final TokenStore<LabelTokenRecord, Token> store )\n    {\n        return new Loader<Integer, LabelTokenRecord, Void>()\n        {\n            @Override\n            public LabelTokenRecord newUnused( Integer key, Void additionalData )\n            {\n                return andMarkAsCreated( new LabelTokenRecord( key ) );\n            }\n\n            @Override\n            public LabelTokenRecord load( Integer key, Void additionalData )\n            {\n                return store.getRecord( key, store.newRecord(), NORMAL );\n            }\n\n            @Override\n            public void ensureHeavy( LabelTokenRecord record )\n            {\n                store.ensureHeavy( record );\n            }\n\n            @Override\n            public LabelTokenRecord clone( LabelTokenRecord record )\n            {\n                return record.clone();\n            }\n        };\n    }","id":23376,"modified_method":"public static Loader<Integer,LabelTokenRecord,Void> labelTokenLoader(\n            final RecordStore<LabelTokenRecord> store )\n    {\n        return new Loader<Integer, LabelTokenRecord, Void>()\n        {\n            @Override\n            public LabelTokenRecord newUnused( Integer key, Void additionalData )\n            {\n                return andMarkAsCreated( new LabelTokenRecord( key ) );\n            }\n\n            @Override\n            public LabelTokenRecord load( Integer key, Void additionalData )\n            {\n                return store.getRecord( key, store.newRecord(), NORMAL );\n            }\n\n            @Override\n            public void ensureHeavy( LabelTokenRecord record )\n            {\n                store.ensureHeavy( record );\n            }\n\n            @Override\n            public LabelTokenRecord clone( LabelTokenRecord record )\n            {\n                return record.clone();\n            }\n        };\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static Loader<Long,RelationshipRecord,Void> relationshipLoader( final RelationshipStore store )\n    {\n        return new Loader<Long, RelationshipRecord, Void>()\n        {\n            @Override\n            public RelationshipRecord newUnused( Long key, Void additionalData )\n            {\n                return andMarkAsCreated( new RelationshipRecord( key ) );\n            }\n\n            @Override\n            public RelationshipRecord load( Long key, Void additionalData )\n            {\n                return store.getRecord( key, store.newRecord(), NORMAL );\n            }\n\n            @Override\n            public void ensureHeavy( RelationshipRecord record )\n            {   // Nothing to load\n            }\n\n            @Override\n            public RelationshipRecord clone(RelationshipRecord relationshipRecord)\n            {\n                return relationshipRecord.clone();\n            }\n        };\n    }","id":23377,"modified_method":"public static Loader<Long,RelationshipRecord,Void> relationshipLoader(\n            final RecordStore<RelationshipRecord> store )\n    {\n        return new Loader<Long, RelationshipRecord, Void>()\n        {\n            @Override\n            public RelationshipRecord newUnused( Long key, Void additionalData )\n            {\n                return andMarkAsCreated( new RelationshipRecord( key ) );\n            }\n\n            @Override\n            public RelationshipRecord load( Long key, Void additionalData )\n            {\n                return store.getRecord( key, store.newRecord(), NORMAL );\n            }\n\n            @Override\n            public void ensureHeavy( RelationshipRecord record )\n            {   // Nothing to load\n            }\n\n            @Override\n            public RelationshipRecord clone(RelationshipRecord relationshipRecord)\n            {\n                return relationshipRecord.clone();\n            }\n        };\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static Loader<Long,NodeRecord,Void> nodeLoader( final NodeStore store )\n    {\n        return new Loader<Long,NodeRecord,Void>()\n        {\n            @Override\n            public NodeRecord newUnused( Long key, Void additionalData )\n            {\n                return andMarkAsCreated( new NodeRecord( key ) );\n            }\n\n            @Override\n            public NodeRecord load( Long key, Void additionalData )\n            {\n                return store.getRecord( key, store.newRecord(), NORMAL );\n            }\n\n            @Override\n            public void ensureHeavy( NodeRecord record )\n            {\n                store.ensureHeavy( record );\n            }\n\n            @Override\n            public NodeRecord clone(NodeRecord nodeRecord)\n            {\n                return nodeRecord.clone();\n            }\n        };\n    }","id":23378,"modified_method":"public static Loader<Long,NodeRecord,Void> nodeLoader( final RecordStore<NodeRecord> store )\n    {\n        return new Loader<Long,NodeRecord,Void>()\n        {\n            @Override\n            public NodeRecord newUnused( Long key, Void additionalData )\n            {\n                return andMarkAsCreated( new NodeRecord( key ) );\n            }\n\n            @Override\n            public NodeRecord load( Long key, Void additionalData )\n            {\n                return store.getRecord( key, store.newRecord(), NORMAL );\n            }\n\n            @Override\n            public void ensureHeavy( NodeRecord record )\n            {\n                store.ensureHeavy( record );\n            }\n\n            @Override\n            public NodeRecord clone(NodeRecord nodeRecord)\n            {\n                return nodeRecord.clone();\n            }\n        };\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Loaders( NeoStores neoStores )\n    {\n        nodeLoader = nodeLoader( neoStores.getNodeStore() );\n        propertyLoader = propertyLoader( neoStores.getPropertyStore() );\n        relationshipLoader = relationshipLoader( neoStores.getRelationshipStore() );\n        relationshipGroupLoader = relationshipGroupLoader( neoStores.getRelationshipGroupStore() );\n        schemaRuleLoader = schemaRuleLoader( neoStores.getSchemaStore() );\n        propertyKeyTokenLoader = propertyKeyTokenLoader( neoStores.getPropertyKeyTokenStore() );\n        labelTokenLoader = labelTokenLoader( neoStores.getLabelTokenStore() );\n        relationshipTypeTokenLoader = relationshipTypeTokenLoader( neoStores.getRelationshipTypeTokenStore() );\n    }","id":23379,"modified_method":"public Loaders( NeoStores neoStores )\n    {\n        this(\n                neoStores.getNodeStore(),\n                neoStores.getPropertyStore(),\n                neoStores.getRelationshipStore(),\n                neoStores.getRelationshipGroupStore(),\n                neoStores.getPropertyKeyTokenStore(),\n                neoStores.getRelationshipTypeTokenStore(),\n                neoStores.getLabelTokenStore(),\n                neoStores.getSchemaStore() );\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static Loader<Integer,RelationshipTypeTokenRecord,Void> relationshipTypeTokenLoader(\n            final TokenStore<RelationshipTypeTokenRecord, RelationshipTypeToken> store )\n    {\n        return new Loader<Integer, RelationshipTypeTokenRecord, Void>()\n        {\n            @Override\n            public RelationshipTypeTokenRecord newUnused( Integer key, Void additionalData )\n            {\n                return andMarkAsCreated( new RelationshipTypeTokenRecord( key ) );\n            }\n\n            @Override\n            public RelationshipTypeTokenRecord load( Integer key, Void additionalData )\n            {\n                return store.getRecord( key, store.newRecord(), NORMAL );\n            }\n\n            @Override\n            public void ensureHeavy( RelationshipTypeTokenRecord record )\n            {\n                store.ensureHeavy( record );\n            }\n\n            @Override\n            public RelationshipTypeTokenRecord clone( RelationshipTypeTokenRecord record )\n            {\n                return record.clone();\n            }\n        };\n    }","id":23380,"modified_method":"public static Loader<Integer,RelationshipTypeTokenRecord,Void> relationshipTypeTokenLoader(\n            final RecordStore<RelationshipTypeTokenRecord> store )\n    {\n        return new Loader<Integer, RelationshipTypeTokenRecord, Void>()\n        {\n            @Override\n            public RelationshipTypeTokenRecord newUnused( Integer key, Void additionalData )\n            {\n                return andMarkAsCreated( new RelationshipTypeTokenRecord( key ) );\n            }\n\n            @Override\n            public RelationshipTypeTokenRecord load( Integer key, Void additionalData )\n            {\n                return store.getRecord( key, store.newRecord(), NORMAL );\n            }\n\n            @Override\n            public void ensureHeavy( RelationshipTypeTokenRecord record )\n            {\n                store.ensureHeavy( record );\n            }\n\n            @Override\n            public RelationshipTypeTokenRecord clone( RelationshipTypeTokenRecord record )\n            {\n                return record.clone();\n            }\n        };\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void importRelationships( NodeRelationshipCache nodeRelationshipCache,\n            CountingStoreUpdateMonitor storeUpdateMonitor, BatchingNeoStores neoStore,\n            IoMonitor writeMonitor, IdMapper idMapper, InputIterable<InputRelationship> relationships,\n            InputCache inputCache, Object[] allRelationshipTypes, Object[] minorityRelationshipTypes )\n    {\n        // Imports the relationships from the Input. This isn't a straight forward as importing nodes,\n        // since keeping track of and updating heads of relationship chains in scenarios where most nodes\n        // are dense and there are many relationship types scales poorly w/ regards to cache memory usage\n        // also as a side-effect time required to update this cache.\n        //\n        // The approach is instead to do multiple iterations where each iteration imports relationships\n        // of a single type. For each iteration Node --> Relationship and Relationship --> Relationship\n        // stages _for dense nodes only_ are run so that the cache can be reused to hold relationship chain heads\n        // of the next type in the next iteration. All relationships will be imported this way and then\n        // finally there will be one Node --> Relationship and Relationship --> Relationship stage linking\n        // all sparse relationship chains together.\n\n        Set<Object> minorityRelationshipTypeSet = asSet( minorityRelationshipTypes );\n        PerTypeRelationshipSplitter perTypeIterator = new PerTypeRelationshipSplitter(\n                relationships.iterator(),\n                allRelationshipTypes,\n                type -> minorityRelationshipTypeSet.contains( type ),\n                neoStore.getRelationshipTypeRepository(),\n                inputCache );\n\n        long nextRelationshipId = 0;\n        for ( int i = 0; perTypeIterator.hasNext(); i++ )\n        {\n            // Stage 3a -- relationships, properties\n            nodeRelationshipCache.setForwardScan( true );\n            Object currentType = perTypeIterator.currentType();\n            int currentTypeId = neoStore.getRelationshipTypeRepository().getOrCreateId( currentType );\n\n            InputIterator<InputRelationship> perType = perTypeIterator.next();\n            String topic = \" [:\" + currentType + \"] (\" +\n                    (i+1) + \"/\" + allRelationshipTypes.length + \")\";\n            final RelationshipStage relationshipStage = new RelationshipStage( topic, config, writeMonitor,\n                    perType, idMapper, neoStore, nodeRelationshipCache, storeUpdateMonitor, nextRelationshipId );\n            executeStages( relationshipStage );\n\n            // Stage 4a -- set node nextRel fields for dense nodes\n            executeStages( new NodeFirstRelationshipStage( topic, config, neoStore.getNodeStore(),\n                    neoStore.getRelationshipGroupStore(), nodeRelationshipCache, true/*dense*/, currentTypeId ) );\n\n            // Stage 5a -- link relationship chains together for dense nodes\n            nodeRelationshipCache.setForwardScan( false );\n            executeStages( new RelationshipLinkbackStage( topic, config, neoStore.getRelationshipStore(),\n                    nodeRelationshipCache, nextRelationshipId,\n                    relationshipStage.getNextRelationshipId(), true/*dense*/ ) );\n            nextRelationshipId = relationshipStage.getNextRelationshipId();\n            nodeRelationshipCache.clearChangedChunks( true/*dense*/ ); // cheap higher level clearing\n        }\n\n        String topic = \" Sparse\";\n        nodeRelationshipCache.setForwardScan( true );\n        // Stage 4b -- set node nextRel fields for sparse nodes\n        executeStages( new NodeFirstRelationshipStage( topic, config, neoStore.getNodeStore(),\n                neoStore.getRelationshipGroupStore(), nodeRelationshipCache, false/*sparse*/, -1 ) );\n\n        // Stage 5b -- link relationship chains together for sparse nodes\n        nodeRelationshipCache.setForwardScan( false );\n        executeStages( new RelationshipLinkbackStage( topic, config, neoStore.getRelationshipStore(),\n                nodeRelationshipCache, 0, nextRelationshipId, false/*sparse*/ ) );\n\n        if ( minorityRelationshipTypes.length > 0 )\n        {\n            // Do some batch insertion style random-access insertions for super small minority types\n            executeStages( new BatchInsertRelationshipsStage( config, idMapper,\n                    perTypeIterator.getMinorityRelationships(), neoStore, nextRelationshipId ) );\n        }\n    }","id":23381,"modified_method":"private void importRelationships( NodeRelationshipCache nodeRelationshipCache,\n            CountingStoreUpdateMonitor storeUpdateMonitor, BatchingNeoStores neoStore,\n            IoMonitor writeMonitor, IdMapper idMapper, InputIterable<InputRelationship> relationships,\n            InputCache inputCache, Object[] allRelationshipTypes, Object[] minorityRelationshipTypes )\n    {\n        // Imports the relationships from the Input. This isn't a straight forward as importing nodes,\n        // since keeping track of and updating heads of relationship chains in scenarios where most nodes\n        // are dense and there are many relationship types scales poorly w/ regards to cache memory usage\n        // also as a side-effect time required to update this cache.\n        //\n        // The approach is instead to do multiple iterations where each iteration imports relationships\n        // of a single type. For each iteration Node --> Relationship and Relationship --> Relationship\n        // stages _for dense nodes only_ are run so that the cache can be reused to hold relationship chain heads\n        // of the next type in the next iteration. All relationships will be imported this way and then\n        // finally there will be one Node --> Relationship and Relationship --> Relationship stage linking\n        // all sparse relationship chains together.\n\n        Set<Object> minorityRelationshipTypeSet = asSet( minorityRelationshipTypes );\n        PerTypeRelationshipSplitter perTypeIterator = new PerTypeRelationshipSplitter(\n                relationships.iterator(),\n                allRelationshipTypes,\n                type -> minorityRelationshipTypeSet.contains( type ),\n                neoStore.getRelationshipTypeRepository(),\n                inputCache );\n\n        long nextRelationshipId = 0;\n        for ( int i = 0; perTypeIterator.hasNext(); i++ )\n        {\n            // Stage 3a -- relationships, properties\n            nodeRelationshipCache.setForwardScan( true );\n            Object currentType = perTypeIterator.currentType();\n            int currentTypeId = neoStore.getRelationshipTypeRepository().getOrCreateId( currentType );\n\n            InputIterator<InputRelationship> perType = perTypeIterator.next();\n            String topic = \" [:\" + currentType + \"] (\" +\n                    (i+1) + \"/\" + allRelationshipTypes.length + \")\";\n            final RelationshipStage relationshipStage = new RelationshipStage( topic, config, writeMonitor,\n                    perType, idMapper, neoStore, nodeRelationshipCache, storeUpdateMonitor, nextRelationshipId );\n            executeStages( relationshipStage );\n\n            // Stage 4a -- set node nextRel fields for dense nodes\n            executeStages( new NodeFirstRelationshipStage( topic, config, neoStore.getNodeStore(),\n                    neoStore.getTemporaryRelationshipGroupStore(), nodeRelationshipCache, true/*dense*/,\n                    currentTypeId ) );\n\n            // Stage 5a -- link relationship chains together for dense nodes\n            nodeRelationshipCache.setForwardScan( false );\n            executeStages( new RelationshipLinkbackStage( topic, config, neoStore.getRelationshipStore(),\n                    nodeRelationshipCache, nextRelationshipId,\n                    relationshipStage.getNextRelationshipId(), true/*dense*/ ) );\n            nextRelationshipId = relationshipStage.getNextRelationshipId();\n            nodeRelationshipCache.clearChangedChunks( true/*dense*/ ); // cheap higher level clearing\n        }\n\n        String topic = \" Sparse\";\n        nodeRelationshipCache.setForwardScan( true );\n        // Stage 4b -- set node nextRel fields for sparse nodes\n        executeStages( new NodeFirstRelationshipStage( topic, config, neoStore.getNodeStore(),\n                neoStore.getTemporaryRelationshipGroupStore(), nodeRelationshipCache, false/*sparse*/, -1 ) );\n\n        // Stage 5b -- link relationship chains together for sparse nodes\n        nodeRelationshipCache.setForwardScan( false );\n        executeStages( new RelationshipLinkbackStage( topic, config, neoStore.getRelationshipStore(),\n                nodeRelationshipCache, 0, nextRelationshipId, false/*sparse*/ ) );\n\n        if ( minorityRelationshipTypes.length > 0 )\n        {\n            // Do some batch insertion style random-access insertions for super small minority types\n            executeStages( new BatchInsertRelationshipsStage( config, idMapper,\n                    perTypeIterator.getMinorityRelationships(), neoStore, nextRelationshipId ) );\n        }\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void run( long memoryWeCanHoldForCertain, BatchingNeoStores neoStore, long highNodeId )\n    {\n        try ( RelationshipGroupCache groupCache =\n                new RelationshipGroupCache( AUTO, memoryWeCanHoldForCertain, highNodeId ) )\n        {\n            try\n            {\n                // Count all nodes, how many groups each node has each\n                executeStage( new CountGroupsStage( config, neoStore, groupCache ) );\n                long fromNodeId = 0;\n                long toNodeId = 0;\n                RecordStore<RelationshipGroupRecord> fromStore = neoStore.getRelationshipGroupStore();\n                RecordStore<RelationshipGroupRecord> toStore =\n                        neoStore.getReplacementNeoStores( StoreType.RELATIONSHIP_GROUP ).getRelationshipGroupStore();\n                while ( fromNodeId < highNodeId )\n                {\n                    // See how many nodes' groups we can fit into the cache this iteration of the loop.\n                    // Groups that doesn't fit in this round will be included in consecutive rounds.\n                    toNodeId = groupCache.prepare( fromNodeId );\n                    // Cache those groups\n                    executeStage( new ScanAndCacheGroupsStage( config, fromStore, groupCache ) );\n                    // And write them in sequential order in the store\n                    executeStage( new WriteGroupsStage( config, groupCache, toStore ) );\n\n                    // Make adjustments for the next iteration\n                    fromNodeId = toNodeId;\n                }\n\n                // Now update nodes to point to the new groups\n                ByteArray groupCountCache = groupCache.getGroupCountCache();\n                groupCountCache.clear();\n                executeStage( new NodeFirstGroupStage( config, toStore, neoStore.getNodeStore(), groupCountCache ) );\n            }\n            catch ( Throwable t )\n            {\n                t.printStackTrace();\n                throw t;\n            }\n        }\n    }","id":23382,"modified_method":"public void run( long memoryWeCanHoldForCertain, BatchingNeoStores neoStore, long highNodeId )\n    {\n        try ( RelationshipGroupCache groupCache =\n                new RelationshipGroupCache( AUTO, memoryWeCanHoldForCertain, highNodeId ) )\n        {\n            try\n            {\n                // Read from the temporary relationship group store...\n                RecordStore<RelationshipGroupRecord> fromStore = neoStore.getTemporaryRelationshipGroupStore();\n                // and write into the main relationship group store\n                RecordStore<RelationshipGroupRecord> toStore = neoStore.getRelationshipGroupStore();\n\n                // Count all nodes, how many groups each node has each\n                executeStage( new CountGroupsStage( config, fromStore, groupCache ) );\n                long fromNodeId = 0;\n                long toNodeId = 0;\n                while ( fromNodeId < highNodeId )\n                {\n                    // See how many nodes' groups we can fit into the cache this iteration of the loop.\n                    // Groups that doesn't fit in this round will be included in consecutive rounds.\n                    toNodeId = groupCache.prepare( fromNodeId );\n                    // Cache those groups\n                    executeStage( new ScanAndCacheGroupsStage( config, fromStore, groupCache ) );\n                    // And write them in sequential order in the store\n                    executeStage( new WriteGroupsStage( config, groupCache, toStore ) );\n\n                    // Make adjustments for the next iteration\n                    fromNodeId = toNodeId;\n                }\n\n                // Now update nodes to point to the new groups\n                ByteArray groupCountCache = groupCache.getGroupCountCache();\n                groupCountCache.clear();\n                executeStage( new NodeFirstGroupStage( config, toStore, neoStore.getNodeStore(), groupCountCache ) );\n            }\n            catch ( Throwable t )\n            {\n                t.printStackTrace();\n                throw t;\n            }\n        }\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldDefragmentRelationshipGroupsWhenSomeDense() throws Exception\n    {\n        // GIVEN some nodes which has their groups scattered\n        int nodeCount = 10_000;\n        int relationshipTypeCount = 50;\n        RecordStore<RelationshipGroupRecord> groupStore = stores.getRelationshipGroupStore();\n        RelationshipGroupRecord groupRecord = groupStore.newRecord();\n        RecordStore<NodeRecord> nodeStore = stores.getNodeStore();\n        NodeRecord nodeRecord = nodeStore.newRecord();\n        long cursor = 0;\n        BitSet initializedNodes = new BitSet();\n        for ( int typeId = relationshipTypeCount-1; typeId >= 0; typeId-- )\n        {\n            for ( int nodeId = 0; nodeId < nodeCount; nodeId++, cursor++ )\n            {\n                // Reasoning behind this thing is that we want to have roughly 10% of the nodes dense\n                // right from the beginning and then some stray dense nodes coming into this in the\n                // middle of the type range somewhere\n                double comparison = typeId == 0 || initializedNodes.get( nodeId ) ? 0.1 : 0.001;\n\n                if ( random.nextDouble() < comparison )\n                {\n                    // next doesn't matter at all, as we're rewriting it anyway\n                    // firstOut/In/Loop we could use in verification phase later\n                    groupRecord.initialize( true, typeId, cursor, cursor+1, cursor+2, nodeId, 4 );\n                    groupRecord.setId( groupStore.nextId() );\n                    groupStore.updateRecord( groupRecord );\n\n                    if ( !initializedNodes.get( nodeId ) )\n                    {\n                        nodeRecord.initialize( true, -1, true, groupRecord.getId(), 0 );\n                        nodeRecord.setId( nodeId );\n                        nodeStore.updateRecord( nodeRecord );\n                        initializedNodes.set( nodeId );\n                    }\n                }\n            }\n        }\n\n        // WHEN\n        defrag( nodeCount );\n\n        // THEN all groups should sit sequentially in the store\n        verifyGroupsAreSequentiallyOrderedByNode();\n    }","id":23383,"modified_method":"@Test\n    public void shouldDefragmentRelationshipGroupsWhenSomeDense() throws Exception\n    {\n        // GIVEN some nodes which has their groups scattered\n        int nodeCount = 10_000;\n        int relationshipTypeCount = 50;\n        RecordStore<RelationshipGroupRecord> groupStore = stores.getTemporaryRelationshipGroupStore();\n        RelationshipGroupRecord groupRecord = groupStore.newRecord();\n        RecordStore<NodeRecord> nodeStore = stores.getNodeStore();\n        NodeRecord nodeRecord = nodeStore.newRecord();\n        long cursor = 0;\n        BitSet initializedNodes = new BitSet();\n        for ( int typeId = relationshipTypeCount-1; typeId >= 0; typeId-- )\n        {\n            for ( int nodeId = 0; nodeId < nodeCount; nodeId++, cursor++ )\n            {\n                // Reasoning behind this thing is that we want to have roughly 10% of the nodes dense\n                // right from the beginning and then some stray dense nodes coming into this in the\n                // middle of the type range somewhere\n                double comparison = typeId == 0 || initializedNodes.get( nodeId ) ? 0.1 : 0.001;\n\n                if ( random.nextDouble() < comparison )\n                {\n                    // next doesn't matter at all, as we're rewriting it anyway\n                    // firstOut/In/Loop we could use in verification phase later\n                    groupRecord.initialize( true, typeId, cursor, cursor+1, cursor+2, nodeId, 4 );\n                    groupRecord.setId( groupStore.nextId() );\n                    groupStore.updateRecord( groupRecord );\n\n                    if ( !initializedNodes.get( nodeId ) )\n                    {\n                        nodeRecord.initialize( true, -1, true, groupRecord.getId(), 0 );\n                        nodeRecord.setId( nodeId );\n                        nodeStore.updateRecord( nodeRecord );\n                        nodeStore.setHighestPossibleIdInUse( nodeId );\n                        initializedNodes.set( nodeId );\n                    }\n                }\n            }\n        }\n\n        // WHEN\n        defrag( nodeCount );\n\n        // THEN all groups should sit sequentially in the store\n        verifyGroupsAreSequentiallyOrderedByNode();\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void verifyGroupsAreSequentiallyOrderedByNode()\n    {\n        RecordStore<RelationshipGroupRecord> store = stores.getReplacementNeoStores().getRelationshipGroupStore();\n        long firstId = store.getNumberOfReservedLowIds();\n        long groupCount = store.getHighId() - firstId;\n        RelationshipGroupRecord groupRecord = store.newRecord();\n        RecordCursor<RelationshipGroupRecord> groupCursor =\n                store.newRecordCursor( groupRecord ).acquire( firstId, CHECK );\n        long highGroupId = store.getHighId();\n        long currentNodeId = -1;\n        int currentTypeId = -1;\n        int newGroupCount = 0;\n        int currentGroupLength = 0;\n        for ( long id = firstId; id < highGroupId; id++, newGroupCount++ )\n        {\n            if ( !groupCursor.next( id ) )\n            {\n                // This will be the case if we have double record units, just assert that fact\n                assertTrue( units > 1 );\n                assertTrue( currentGroupLength > 0 );\n                currentGroupLength--;\n                continue;\n            }\n\n            long nodeId = groupRecord.getOwningNode();\n            assertTrue(\n                    \"Expected a group for node >= \" + currentNodeId + \", but was \" + nodeId + \" in \" + groupRecord,\n                    nodeId >= currentNodeId );\n            if ( nodeId != currentNodeId )\n            {\n                currentNodeId = nodeId;\n                currentTypeId = -1;\n                if ( units > 1 )\n                {\n                    assertEquals( 0, currentGroupLength );\n                }\n                currentGroupLength = 0;\n            }\n            currentGroupLength++;\n\n            assertTrue( \"Expected this group to have a next of current + \" + units + \" OR NULL, \" +\n                    \"but was \" + groupRecord.toString(),\n                    groupRecord.getNext() == groupRecord.getId() + 1 ||\n                    groupRecord.getNext() == Record.NO_NEXT_RELATIONSHIP.intValue() );\n            assertTrue( \"Expected \" + groupRecord + \" to have type > \" + currentTypeId,\n                    groupRecord.getType() > currentTypeId );\n            currentTypeId = groupRecord.getType();\n        }\n        assertEquals( groupCount, newGroupCount );\n    }","id":23384,"modified_method":"private void verifyGroupsAreSequentiallyOrderedByNode()\n    {\n        RecordStore<RelationshipGroupRecord> store = stores.getRelationshipGroupStore();\n        long firstId = store.getNumberOfReservedLowIds();\n        long groupCount = store.getHighId() - firstId;\n        RelationshipGroupRecord groupRecord = store.newRecord();\n        RecordCursor<RelationshipGroupRecord> groupCursor =\n                store.newRecordCursor( groupRecord ).acquire( firstId, CHECK );\n        long highGroupId = store.getHighId();\n        long currentNodeId = -1;\n        int currentTypeId = -1;\n        int newGroupCount = 0;\n        int currentGroupLength = 0;\n        for ( long id = firstId; id < highGroupId; id++, newGroupCount++ )\n        {\n            if ( !groupCursor.next( id ) )\n            {\n                // This will be the case if we have double record units, just assert that fact\n                assertTrue( units > 1 );\n                assertTrue( currentGroupLength > 0 );\n                currentGroupLength--;\n                continue;\n            }\n\n            long nodeId = groupRecord.getOwningNode();\n            assertTrue(\n                    \"Expected a group for node >= \" + currentNodeId + \", but was \" + nodeId + \" in \" + groupRecord,\n                    nodeId >= currentNodeId );\n            if ( nodeId != currentNodeId )\n            {\n                currentNodeId = nodeId;\n                currentTypeId = -1;\n                if ( units > 1 )\n                {\n                    assertEquals( 0, currentGroupLength );\n                }\n                currentGroupLength = 0;\n            }\n            currentGroupLength++;\n\n            assertTrue( \"Expected this group to have a next of current + \" + units + \" OR NULL, \" +\n                    \"but was \" + groupRecord.toString(),\n                    groupRecord.getNext() == groupRecord.getId() + 1 ||\n                    groupRecord.getNext() == Record.NO_NEXT_RELATIONSHIP.intValue() );\n            assertTrue( \"Expected \" + groupRecord + \" to have type > \" + currentTypeId,\n                    groupRecord.getType() > currentTypeId );\n            currentTypeId = groupRecord.getType();\n        }\n        assertEquals( groupCount, newGroupCount );\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldDefragmentRelationshipGroupsWhenAllDense() throws Exception\n    {\n        // GIVEN some nodes which has their groups scattered\n        int nodeCount = 10_000;\n        int relationshipTypeCount = 50;\n        RecordStore<RelationshipGroupRecord> groupStore = stores.getRelationshipGroupStore();\n        RelationshipGroupRecord groupRecord = groupStore.newRecord();\n        RecordStore<NodeRecord> nodeStore = stores.getNodeStore();\n        NodeRecord nodeRecord = nodeStore.newRecord();\n        long cursor = 0;\n        for ( int typeId = relationshipTypeCount-1; typeId >= 0; typeId-- )\n        {\n            for ( long nodeId = 0; nodeId < nodeCount; nodeId++, cursor++ )\n            {\n                // next doesn't matter at all, as we're rewriting it anyway\n                // firstOut/In/Loop we could use in verification phase later\n                groupRecord.initialize( true, typeId, cursor, cursor+1, cursor+2, nodeId, 4 );\n                groupRecord.setId( groupStore.nextId() );\n                groupStore.updateRecord( groupRecord );\n\n                if ( typeId == 0 )\n                {\n                    // first round also create the nodes\n                    nodeRecord.initialize( true, -1, true, groupRecord.getId(), 0 );\n                    nodeRecord.setId( nodeId );\n                    nodeStore.updateRecord( nodeRecord );\n                }\n            }\n        }\n\n        // WHEN\n        defrag( nodeCount );\n\n        // THEN all groups should sit sequentially in the store\n        verifyGroupsAreSequentiallyOrderedByNode();\n    }","id":23385,"modified_method":"@Test\n    public void shouldDefragmentRelationshipGroupsWhenAllDense() throws Exception\n    {\n        // GIVEN some nodes which has their groups scattered\n        int nodeCount = 10_000;\n        int relationshipTypeCount = 50;\n        RecordStore<RelationshipGroupRecord> groupStore = stores.getTemporaryRelationshipGroupStore();\n        RelationshipGroupRecord groupRecord = groupStore.newRecord();\n        RecordStore<NodeRecord> nodeStore = stores.getNodeStore();\n        NodeRecord nodeRecord = nodeStore.newRecord();\n        long cursor = 0;\n        for ( int typeId = relationshipTypeCount-1; typeId >= 0; typeId-- )\n        {\n            for ( long nodeId = 0; nodeId < nodeCount; nodeId++, cursor++ )\n            {\n                // next doesn't matter at all, as we're rewriting it anyway\n                // firstOut/In/Loop we could use in verification phase later\n                groupRecord.initialize( true, typeId, cursor, cursor+1, cursor+2, nodeId, 4 );\n                groupRecord.setId( groupStore.nextId() );\n                groupStore.updateRecord( groupRecord );\n\n                if ( typeId == 0 )\n                {\n                    // first round also create the nodes\n                    nodeRecord.initialize( true, -1, true, groupRecord.getId(), 0 );\n                    nodeRecord.setId( nodeId );\n                    nodeStore.updateRecord( nodeRecord );\n                    nodeStore.setHighestPossibleIdInUse( nodeId );\n                }\n            }\n        }\n\n        // WHEN\n        defrag( nodeCount );\n\n        // THEN all groups should sit sequentially in the store\n        verifyGroupsAreSequentiallyOrderedByNode();\n    }","commit_id":"d9982c976e2b61e0c36929e5d615a9395eeb8e11","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n                throws ServletException, IOException {\n            int error =\n                    Integer.valueOf(req.getParameter(\"errorCode\")).intValue();\n            resp.sendError(error);\n        }","id":23386,"modified_method":"@Override\n        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n                throws ServletException, IOException {\n            int error = Integer.parseInt(req.getParameter(\"errorCode\"));\n            resp.sendError(error);\n        }","commit_id":"ba8814f97f60088e2d4d31b8bf703b9ae32863d9","url":"https://github.com/apache/tomcat"},{"original_method":"private static void checkDuplication(FileSystem fs, Path file, Path sorted,\n    Configuration conf) throws IOException {\n    SequenceFile.Sorter sorter = new SequenceFile.Sorter(fs,\n        new Text.Comparator(), Text.class, FileOperation.class, conf);\n    sorter.sort(file, sorted);\n    SequenceFile.Reader in = null;\n    try {\n      in = new SequenceFile.Reader(fs, sorted, conf);\n      FileOperation curop = new FileOperation();\n      Text prevsrc = null, cursrc = new Text(); \n      for(; in.next(cursrc, curop); ) {\n        if (prevsrc != null && cursrc.equals(prevsrc)) {\n          throw new DuplicationException(\n            \"Invalid input, there are duplicated files in the sources: \"\n            + prevsrc + \", \" + cursrc);\n        }\n        prevsrc = cursrc;\n        cursrc = new Text();\n        curop = new FileOperation();\n      }\n    }\n    finally {\n      in.close();\n    }\n  }","id":23387,"modified_method":"private static void checkDuplication(FileSystem fs, Path file, Path sorted,\n    Configuration conf) throws IOException {\n    SequenceFile.Sorter sorter = new SequenceFile.Sorter(fs,\n        new Text.Comparator(), Text.class, FileOperation.class, conf);\n    sorter.sort(file, sorted);\n    try (SequenceFile.Reader in = new SequenceFile.Reader(fs, sorted, conf)) {\n      FileOperation curop = new FileOperation();\n      Text prevsrc = null, cursrc = new Text(); \n      for(; in.next(cursrc, curop); ) {\n        if (prevsrc != null && cursrc.equals(prevsrc)) {\n          throw new DuplicationException(\n            \"Invalid input, there are duplicated files in the sources: \"\n            + prevsrc + \", \" + cursrc);\n        }\n        prevsrc = cursrc;\n        cursrc = new Text();\n        curop = new FileOperation();\n      }\n    }\n  }","commit_id":"02b21b7131d9f1dba6d93fb3f87154e86b9825d6","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n     * Produce splits such that each is no greater than the quotient of the\n     * total size and the number of splits requested.\n     * @param job The handle to the JobConf object\n     * @param numSplits Number of splits requested\n     */\n    public InputSplit[] getSplits(JobConf job, int numSplits\n        ) throws IOException {\n      final int srcCount = job.getInt(OP_COUNT_LABEL, -1);\n      final int targetcount = srcCount / numSplits;\n      String srclist = job.get(OP_LIST_LABEL, \"\");\n      if (srcCount < 0 || \"\".equals(srclist)) {\n        throw new RuntimeException(\"Invalid metadata: #files(\" + srcCount +\n                                   \") listuri(\" + srclist + \")\");\n      }\n      Path srcs = new Path(srclist);\n      FileSystem fs = srcs.getFileSystem(job);\n\n      List<FileSplit> splits = new ArrayList<FileSplit>(numSplits);\n\n      Text key = new Text();\n      FileOperation value = new FileOperation();\n      SequenceFile.Reader in = null;\n      long prev = 0L;\n      int count = 0; //count src\n      try {\n        for(in = new SequenceFile.Reader(fs, srcs, job); in.next(key, value); ) {\n          long curr = in.getPosition();\n          long delta = curr - prev;\n          if (++count > targetcount) {\n            count = 0;\n            splits.add(new FileSplit(srcs, prev, delta, (String[])null));\n            prev = curr;\n          }\n        }\n      }\n      finally {\n        in.close();\n      }\n      long remaining = fs.getFileStatus(srcs).getLen() - prev;\n      if (remaining != 0) {\n        splits.add(new FileSplit(srcs, prev, remaining, (String[])null));\n      }\n      LOG.info(\"numSplits=\"  + numSplits + \", splits.size()=\" + splits.size());\n      return splits.toArray(new FileSplit[splits.size()]);\n    }","id":23388,"modified_method":"/**\n     * Produce splits such that each is no greater than the quotient of the\n     * total size and the number of splits requested.\n     * @param job The handle to the JobConf object\n     * @param numSplits Number of splits requested\n     */\n    public InputSplit[] getSplits(JobConf job, int numSplits\n        ) throws IOException {\n      final int srcCount = job.getInt(OP_COUNT_LABEL, -1);\n      final int targetcount = srcCount / numSplits;\n      String srclist = job.get(OP_LIST_LABEL, \"\");\n      if (srcCount < 0 || \"\".equals(srclist)) {\n        throw new RuntimeException(\"Invalid metadata: #files(\" + srcCount +\n                                   \") listuri(\" + srclist + \")\");\n      }\n      Path srcs = new Path(srclist);\n      FileSystem fs = srcs.getFileSystem(job);\n\n      List<FileSplit> splits = new ArrayList<FileSplit>(numSplits);\n\n      Text key = new Text();\n      FileOperation value = new FileOperation();\n      long prev = 0L;\n      int count = 0; //count src\n      try (SequenceFile.Reader in = new SequenceFile.Reader(fs, srcs, job)) {\n        for ( ; in.next(key, value); ) {\n          long curr = in.getPosition();\n          long delta = curr - prev;\n          if (++count > targetcount) {\n            count = 0;\n            splits.add(new FileSplit(srcs, prev, delta, (String[])null));\n            prev = curr;\n          }\n        }\n      }\n      long remaining = fs.getFileStatus(srcs).getLen() - prev;\n      if (remaining != 0) {\n        splits.add(new FileSplit(srcs, prev, remaining, (String[])null));\n      }\n      LOG.info(\"numSplits=\"  + numSplits + \", splits.size()=\" + splits.size());\n      return splits.toArray(new FileSplit[splits.size()]);\n    }","commit_id":"02b21b7131d9f1dba6d93fb3f87154e86b9825d6","url":"https://github.com/apache/hadoop"},{"original_method":"private boolean setup(List<FileOperation> ops, Path log) \n  throws IOException {\n    final String randomId = getRandomId();\n    JobClient jClient = new JobClient(jobconf);\n    Path stagingArea;\n    try {\n      stagingArea = JobSubmissionFiles.getStagingDir(\n                       jClient.getClusterHandle(), jobconf);\n    } catch (InterruptedException ie){\n      throw new IOException(ie);\n    }\n    Path jobdir = new Path(stagingArea + NAME + \"_\" + randomId);\n    FsPermission mapredSysPerms = \n      new FsPermission(JobSubmissionFiles.JOB_DIR_PERMISSION);\n    FileSystem.mkdirs(jClient.getFs(), jobdir, mapredSysPerms);\n    LOG.info(JOB_DIR_LABEL + \"=\" + jobdir);\n\n    if (log == null) {\n      log = new Path(jobdir, \"_logs\");\n    }\n    FileOutputFormat.setOutputPath(jobconf, log);\n    LOG.info(\"log=\" + log);\n\n    //create operation list\n    FileSystem fs = jobdir.getFileSystem(jobconf);\n    Path opList = new Path(jobdir, \"_\" + OP_LIST_LABEL);\n    jobconf.set(OP_LIST_LABEL, opList.toString());\n    int opCount = 0, synCount = 0;\n    SequenceFile.Writer opWriter = null;\n    try {\n      opWriter = SequenceFile.createWriter(fs, jobconf, opList, Text.class,\n          FileOperation.class, SequenceFile.CompressionType.NONE);\n      for(FileOperation op : ops) {\n        FileStatus srcstat = fs.getFileStatus(op.src); \n        if (srcstat.isDirectory() && op.isDifferent(srcstat)) {\n          ++opCount;\n          opWriter.append(new Text(op.src.toString()), op);\n        }\n\n        Stack<Path> pathstack = new Stack<Path>();\n        for(pathstack.push(op.src); !pathstack.empty(); ) {\n          for(FileStatus stat : fs.listStatus(pathstack.pop())) {\n            if (stat.isDirectory()) {\n              pathstack.push(stat.getPath());\n            }\n\n            if (op.isDifferent(stat)) {              \n              ++opCount;\n              if (++synCount > SYNC_FILE_MAX) {\n                opWriter.sync();\n                synCount = 0;\n              }\n              Path f = stat.getPath();\n              opWriter.append(new Text(f.toString()), new FileOperation(f, op));\n            }\n          }\n        }\n      }\n    } finally {\n      opWriter.close();\n    }\n\n    checkDuplication(fs, opList, new Path(jobdir, \"_sorted\"), jobconf);\n    jobconf.setInt(OP_COUNT_LABEL, opCount);\n    LOG.info(OP_COUNT_LABEL + \"=\" + opCount);\n    jobconf.setNumMapTasks(getMapCount(opCount,\n        new JobClient(jobconf).getClusterStatus().getTaskTrackers()));\n    return opCount != 0;    \n  }","id":23389,"modified_method":"private boolean setup(List<FileOperation> ops, Path log) \n  throws IOException {\n    final String randomId = getRandomId();\n    JobClient jClient = new JobClient(jobconf);\n    Path stagingArea;\n    try {\n      stagingArea = JobSubmissionFiles.getStagingDir(\n                       jClient.getClusterHandle(), jobconf);\n    } catch (InterruptedException ie){\n      throw new IOException(ie);\n    }\n    Path jobdir = new Path(stagingArea + NAME + \"_\" + randomId);\n    FsPermission mapredSysPerms = \n      new FsPermission(JobSubmissionFiles.JOB_DIR_PERMISSION);\n    FileSystem.mkdirs(jClient.getFs(), jobdir, mapredSysPerms);\n    LOG.info(JOB_DIR_LABEL + \"=\" + jobdir);\n\n    if (log == null) {\n      log = new Path(jobdir, \"_logs\");\n    }\n    FileOutputFormat.setOutputPath(jobconf, log);\n    LOG.info(\"log=\" + log);\n\n    //create operation list\n    FileSystem fs = jobdir.getFileSystem(jobconf);\n    Path opList = new Path(jobdir, \"_\" + OP_LIST_LABEL);\n    jobconf.set(OP_LIST_LABEL, opList.toString());\n    int opCount = 0, synCount = 0;\n    try (SequenceFile.Writer opWriter = SequenceFile.createWriter(fs, jobconf, opList, Text.class,\n            FileOperation.class, SequenceFile.CompressionType.NONE)) {\n      for(FileOperation op : ops) {\n        FileStatus srcstat = fs.getFileStatus(op.src); \n        if (srcstat.isDirectory() && op.isDifferent(srcstat)) {\n          ++opCount;\n          opWriter.append(new Text(op.src.toString()), op);\n        }\n\n        Stack<Path> pathstack = new Stack<Path>();\n        for(pathstack.push(op.src); !pathstack.empty(); ) {\n          for(FileStatus stat : fs.listStatus(pathstack.pop())) {\n            if (stat.isDirectory()) {\n              pathstack.push(stat.getPath());\n            }\n\n            if (op.isDifferent(stat)) {              \n              ++opCount;\n              if (++synCount > SYNC_FILE_MAX) {\n                opWriter.sync();\n                synCount = 0;\n              }\n              Path f = stat.getPath();\n              opWriter.append(new Text(f.toString()), new FileOperation(f, op));\n            }\n          }\n        }\n      }\n    }\n\n    checkDuplication(fs, opList, new Path(jobdir, \"_sorted\"), jobconf);\n    jobconf.setInt(OP_COUNT_LABEL, opCount);\n    LOG.info(OP_COUNT_LABEL + \"=\" + opCount);\n    jobconf.setNumMapTasks(getMapCount(opCount,\n        new JobClient(jobconf).getClusterStatus().getTaskTrackers()));\n    return opCount != 0;    \n  }","commit_id":"02b21b7131d9f1dba6d93fb3f87154e86b9825d6","url":"https://github.com/apache/hadoop"},{"original_method":"private static List<Path> fetchFileList(Configuration conf, Path srcList)\n      throws IOException {\n    List<Path> result = new ArrayList<Path>();\n    FileSystem fs = srcList.getFileSystem(conf);\n    BufferedReader input = null;\n    try {\n      input = new BufferedReader(new InputStreamReader(fs.open(srcList)));\n      String line = input.readLine();\n      while (line != null) {\n        result.add(new Path(line));\n        line = input.readLine();\n      }\n    } finally {\n      checkAndClose(input);\n    }\n    return result;\n  }","id":23390,"modified_method":"private static List<Path> fetchFileList(Configuration conf, Path srcList)\n      throws IOException {\n    List<Path> result = new ArrayList<Path>();\n    FileSystem fs = srcList.getFileSystem(conf);\n    try (BufferedReader input = new BufferedReader(new InputStreamReader(fs.open(srcList),\n            Charset.forName(\"UTF-8\")))) {\n      String line = input.readLine();\n      while (line != null) {\n        result.add(new Path(line));\n        line = input.readLine();\n      }\n    }\n    return result;\n  }","commit_id":"02b21b7131d9f1dba6d93fb3f87154e86b9825d6","url":"https://github.com/apache/hadoop"},{"original_method":"static Arguments valueOf(String[] args, Configuration conf\n        ) throws IOException {\n      List<Path> srcs = new ArrayList<Path>();\n      Path dst = null;\n      Path log = null;\n      Path basedir = null;\n      EnumSet<Options> flags = EnumSet.noneOf(Options.class);\n      String presevedAttributes = null;\n      String mapredSslConf = null;\n      long filelimit = Long.MAX_VALUE;\n      long sizelimit = Long.MAX_VALUE;\n      boolean dryrun = false;\n\n      for (int idx = 0; idx < args.length; idx++) {\n        Options[] opt = Options.values();\n        int i = 0;\n        for(; i < opt.length && !args[idx].startsWith(opt[i].cmd); i++);\n\n        if (i < opt.length) {\n          flags.add(opt[i]);\n          if (opt[i] == Options.PRESERVE_STATUS) {\n            presevedAttributes =  args[idx].substring(2);         \n            FileAttribute.parse(presevedAttributes); //validation\n          }\n          else if (opt[i] == Options.FILE_LIMIT) {\n            filelimit = Options.FILE_LIMIT.parseLong(args, ++idx);\n          }\n          else if (opt[i] == Options.SIZE_LIMIT) {\n            sizelimit = Options.SIZE_LIMIT.parseLong(args, ++idx);\n          }\n        } else if (\"-f\".equals(args[idx])) {\n          if (++idx ==  args.length) {\n            throw new IllegalArgumentException(\"urilist_uri not specified in -f\");\n          }\n          srcs.addAll(fetchFileList(conf, new Path(args[idx])));\n        } else if (\"-log\".equals(args[idx])) {\n          if (++idx ==  args.length) {\n            throw new IllegalArgumentException(\"logdir not specified in -log\");\n          }\n          log = new Path(args[idx]);\n        } else if (\"-basedir\".equals(args[idx])) {\n          if (++idx ==  args.length) {\n            throw new IllegalArgumentException(\"basedir not specified in -basedir\");\n          }\n          basedir = new Path(args[idx]);\n        } else if (\"-mapredSslConf\".equals(args[idx])) {\n          if (++idx ==  args.length) {\n            throw new IllegalArgumentException(\"ssl conf file not specified in -mapredSslConf\");\n          }\n          mapredSslConf = args[idx];\n        } else if (\"-dryrun\".equals(args[idx])) {\n          dryrun = true;\n          dst = new Path(\"/tmp/distcp_dummy_dest\");//dummy destination\n        } else if (\"-m\".equals(args[idx])) {\n          if (++idx == args.length) {\n            throw new IllegalArgumentException(\"num_maps not specified in -m\");\n          }\n          try {\n            conf.setInt(MAX_MAPS_LABEL, Integer.valueOf(args[idx]));\n          } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\"Invalid argument to -m: \" +\n                                               args[idx]);\n          }\n        } else if ('-' == args[idx].codePointAt(0)) {\n          throw new IllegalArgumentException(\"Invalid switch \" + args[idx]);\n        } else if (idx == args.length -1 &&\n                   (!dryrun || flags.contains(Options.UPDATE))) {\n          dst = new Path(args[idx]);\n        } else {\n          srcs.add(new Path(args[idx]));\n        }\n      }\n      // mandatory command-line parameters\n      if (srcs.isEmpty() || dst == null) {\n        throw new IllegalArgumentException(\"Missing \"\n            + (dst == null ? \"dst path\" : \"src\"));\n      }\n      // incompatible command-line flags\n      final boolean isOverwrite = flags.contains(Options.OVERWRITE);\n      final boolean isUpdate = flags.contains(Options.UPDATE);\n      final boolean isDelete = flags.contains(Options.DELETE);\n      final boolean skipCRC = flags.contains(Options.SKIPCRC);\n      if (isOverwrite && isUpdate) {\n        throw new IllegalArgumentException(\"Conflicting overwrite policies\");\n      }\n      if (!isUpdate && skipCRC) {\n        throw new IllegalArgumentException(\n            Options.SKIPCRC.cmd + \" is relevant only with the \" +\n            Options.UPDATE.cmd + \" option\");\n      }\n      if (isDelete && !isOverwrite && !isUpdate) {\n        throw new IllegalArgumentException(Options.DELETE.cmd\n            + \" must be specified with \" + Options.OVERWRITE + \" or \"\n            + Options.UPDATE + \".\");\n      }\n      return new Arguments(srcs, basedir, dst, log, flags, presevedAttributes,\n          filelimit, sizelimit, mapredSslConf, dryrun);\n    }","id":23391,"modified_method":"static Arguments valueOf(String[] args, Configuration conf\n        ) throws IOException {\n      List<Path> srcs = new ArrayList<Path>();\n      Path dst = null;\n      Path log = null;\n      Path basedir = null;\n      EnumSet<Options> flags = EnumSet.noneOf(Options.class);\n      String presevedAttributes = null;\n      String mapredSslConf = null;\n      long filelimit = Long.MAX_VALUE;\n      long sizelimit = Long.MAX_VALUE;\n      boolean dryrun = false;\n\n      for (int idx = 0; idx < args.length; idx++) {\n        Options[] opt = Options.values();\n        int i = 0;\n        for(; i < opt.length && !args[idx].startsWith(opt[i].cmd); i++);\n\n        if (i < opt.length) {\n          flags.add(opt[i]);\n          if (opt[i] == Options.PRESERVE_STATUS) {\n            presevedAttributes =  args[idx].substring(2);         \n            FileAttribute.parse(presevedAttributes); //validation\n          }\n          else if (opt[i] == Options.FILE_LIMIT) {\n            filelimit = Options.FILE_LIMIT.parseLong(args, ++idx);\n          }\n          else if (opt[i] == Options.SIZE_LIMIT) {\n            sizelimit = Options.SIZE_LIMIT.parseLong(args, ++idx);\n          }\n        } else if (\"-f\".equals(args[idx])) {\n          if (++idx ==  args.length) {\n            throw new IllegalArgumentException(\"urilist_uri not specified in -f\");\n          }\n          srcs.addAll(fetchFileList(conf, new Path(args[idx])));\n        } else if (\"-log\".equals(args[idx])) {\n          if (++idx ==  args.length) {\n            throw new IllegalArgumentException(\"logdir not specified in -log\");\n          }\n          log = new Path(args[idx]);\n        } else if (\"-basedir\".equals(args[idx])) {\n          if (++idx ==  args.length) {\n            throw new IllegalArgumentException(\"basedir not specified in -basedir\");\n          }\n          basedir = new Path(args[idx]);\n        } else if (\"-mapredSslConf\".equals(args[idx])) {\n          if (++idx ==  args.length) {\n            throw new IllegalArgumentException(\"ssl conf file not specified in -mapredSslConf\");\n          }\n          mapredSslConf = args[idx];\n        } else if (\"-dryrun\".equals(args[idx])) {\n          dryrun = true;\n          dst = new Path(\"/tmp/distcp_dummy_dest\");//dummy destination\n        } else if (\"-m\".equals(args[idx])) {\n          if (++idx == args.length) {\n            throw new IllegalArgumentException(\"num_maps not specified in -m\");\n          }\n          try {\n            conf.setInt(MAX_MAPS_LABEL, Integer.parseInt(args[idx]));\n          } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\"Invalid argument to -m: \" +\n                                               args[idx]);\n          }\n        } else if ('-' == args[idx].codePointAt(0)) {\n          throw new IllegalArgumentException(\"Invalid switch \" + args[idx]);\n        } else if (idx == args.length -1 &&\n                   (!dryrun || flags.contains(Options.UPDATE))) {\n          dst = new Path(args[idx]);\n        } else {\n          srcs.add(new Path(args[idx]));\n        }\n      }\n      // mandatory command-line parameters\n      if (srcs.isEmpty() || dst == null) {\n        throw new IllegalArgumentException(\"Missing \"\n            + (dst == null ? \"dst path\" : \"src\"));\n      }\n      // incompatible command-line flags\n      final boolean isOverwrite = flags.contains(Options.OVERWRITE);\n      final boolean isUpdate = flags.contains(Options.UPDATE);\n      final boolean isDelete = flags.contains(Options.DELETE);\n      final boolean skipCRC = flags.contains(Options.SKIPCRC);\n      if (isOverwrite && isUpdate) {\n        throw new IllegalArgumentException(\"Conflicting overwrite policies\");\n      }\n      if (!isUpdate && skipCRC) {\n        throw new IllegalArgumentException(\n            Options.SKIPCRC.cmd + \" is relevant only with the \" +\n            Options.UPDATE.cmd + \" option\");\n      }\n      if (isDelete && !isOverwrite && !isUpdate) {\n        throw new IllegalArgumentException(Options.DELETE.cmd\n            + \" must be specified with \" + Options.OVERWRITE + \" or \"\n            + Options.UPDATE + \".\");\n      }\n      return new Arguments(srcs, basedir, dst, log, flags, presevedAttributes,\n          filelimit, sizelimit, mapredSslConf, dryrun);\n    }","commit_id":"02b21b7131d9f1dba6d93fb3f87154e86b9825d6","url":"https://github.com/apache/hadoop"},{"original_method":"protected static List<String> readFile(Configuration conf, Path inputfile\n      ) throws IOException {\n    List<String> result = new ArrayList<String>();\n    FileSystem fs = inputfile.getFileSystem(conf);\n    BufferedReader input = null;\n    try {\n      input = new BufferedReader(new InputStreamReader(fs.open(inputfile)));\n      for(String line; (line = input.readLine()) != null;) {\n        result.add(line);\n      }\n    } finally {\n      input.close();\n    }\n    return result;\n  }","id":23392,"modified_method":"protected static List<String> readFile(Configuration conf, Path inputfile\n      ) throws IOException {\n    List<String> result = new ArrayList<String>();\n    FileSystem fs = inputfile.getFileSystem(conf);\n    try (BufferedReader input = new BufferedReader(new InputStreamReader(fs.open(inputfile),\n            Charset.forName(\"UTF-8\")))) {\n      for(String line; (line = input.readLine()) != null;) {\n        result.add(line);\n      }\n    }\n    return result;\n  }","commit_id":"02b21b7131d9f1dba6d93fb3f87154e86b9825d6","url":"https://github.com/apache/hadoop"},{"original_method":"public int compare(byte[] b1, int s1, int l1,\n                       byte[] b2, int s2, int l2) {\n      \n      if (sortSpec == null) {\n        return super.compare(b1, s1, l1, b2, s2, l2);\n      }\n      \n      try {\n        Text logline1 = new Text(); \n        logline1.readFields(new DataInputStream(new ByteArrayInputStream(b1, s1, l1)));\n        String line1 = logline1.toString();\n        String[] logColumns1 = line1.split(columnSeparator);\n        \n        Text logline2 = new Text(); \n        logline2.readFields(new DataInputStream(new ByteArrayInputStream(b2, s2, l2)));\n        String line2 = logline2.toString();\n        String[] logColumns2 = line2.split(columnSeparator);\n        \n        if (logColumns1 == null || logColumns2 == null) {\n          return super.compare(b1, s1, l1, b2, s2, l2);\n        }\n        \n        //Compare column-wise according to *sortSpec*\n        for(int i=0; i < sortSpec.length; ++i) {\n          int column = (Integer.valueOf(sortSpec[i]).intValue());\n          String c1 = logColumns1[column]; \n          String c2 = logColumns2[column];\n          \n          //Compare columns\n          int comparision = super.compareBytes(\n                                               c1.getBytes(), 0, c1.length(),\n                                               c2.getBytes(), 0, c2.length()\n                                               );\n          \n          //They differ!\n          if (comparision != 0) {\n            return comparision;\n          }\n        }\n        \n      } catch (IOException ioe) {\n        LOG.fatal(\"Caught \" + ioe);\n        return 0;\n      }\n      \n      return 0;\n    }","id":23393,"modified_method":"public int compare(byte[] b1, int s1, int l1,\n                       byte[] b2, int s2, int l2) {\n      \n      if (sortSpec == null) {\n        return super.compare(b1, s1, l1, b2, s2, l2);\n      }\n      \n      try {\n        Text logline1 = new Text(); \n        logline1.readFields(new DataInputStream(new ByteArrayInputStream(b1, s1, l1)));\n        String line1 = logline1.toString();\n        String[] logColumns1 = line1.split(columnSeparator);\n        \n        Text logline2 = new Text(); \n        logline2.readFields(new DataInputStream(new ByteArrayInputStream(b2, s2, l2)));\n        String line2 = logline2.toString();\n        String[] logColumns2 = line2.split(columnSeparator);\n        \n        if (logColumns1 == null || logColumns2 == null) {\n          return super.compare(b1, s1, l1, b2, s2, l2);\n        }\n        \n        //Compare column-wise according to *sortSpec*\n        for(int i=0; i < sortSpec.length; ++i) {\n          int column = Integer.parseInt(sortSpec[i]);\n          String c1 = logColumns1[column]; \n          String c2 = logColumns2[column];\n          \n          //Compare columns\n          int comparision = super.compareBytes(\n                                  c1.getBytes(Charset.forName(\"UTF-8\")), 0, c1.length(),\n                                  c2.getBytes(Charset.forName(\"UTF-8\")), 0, c2.length()\n                                  );\n          \n          //They differ!\n          if (comparision != 0) {\n            return comparision;\n          }\n        }\n        \n      } catch (IOException ioe) {\n        LOG.fatal(\"Caught \" + ioe);\n        return 0;\n      }\n      \n      return 0;\n    }","commit_id":"02b21b7131d9f1dba6d93fb3f87154e86b9825d6","url":"https://github.com/apache/hadoop"},{"original_method":"protected String getParam(UMOEventContext context, String name) throws NullPointerException\n    {\n        String value = context.getStringProperty(name);\n        if(value==null) {\n            throw new NullPointerException(\"Parameter '\" + name + \"' must be set on the request\");\n        }\n        return value;\n    }","id":23394,"modified_method":"protected String getParam(UMOEventContext context, String name) throws NullPointerException\n    {\n        String value = context.getMessage().getStringProperty(name, null);\n        if(value==null) {\n            throw new NullPointerException(\"Parameter '\" + name + \"' must be set on the request\");\n        }\n        return value;\n    }","commit_id":"1b033624d0c4a59b4f1abe013099f7e3049accbc","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException {\n\n        String name = null;\n        int ssn = 0;\n        double amount = 0;\n        int duration = 0;\n        try {\n            name = getParam(context, \"customerName\");\n            ssn = Integer.valueOf(getParam(context, \"ssn\")).intValue();\n            amount = Double.valueOf(getParam(context, \"loanAmount\")).doubleValue();\n            duration = Integer.valueOf(getParam(context, \"loanDuration\")).intValue();\n        } catch (Exception e) {\n            throw new TransformerException(this, e);\n        }\n\n        Customer c = new Customer(name, ssn);\n        CustomerQuoteRequest request = new CustomerQuoteRequest(c, amount, duration);\n        return request;\n    }","id":23395,"modified_method":"public Object transform(Object src, String encoding, UMOEventContext context) throws TransformerException {\n\n        String name;\n        int ssn;\n        double amount;\n        int duration;\n        try {\n            name = getParam(context, \"customerName\");\n            ssn = Integer.parseInt(getParam(context, \"ssn\"));\n            amount = Double.parseDouble(getParam(context, \"loanAmount\"));\n            duration = Integer.parseInt(getParam(context, \"loanDuration\"));\n        } catch (Exception e) {\n            throw new TransformerException(this, e);\n        }\n\n        Customer c = new Customer(name, ssn);\n        CustomerQuoteRequest request = new CustomerQuoteRequest(c, amount, duration);\n        return request;\n    }","commit_id":"1b033624d0c4a59b4f1abe013099f7e3049accbc","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Create a new JVM to do the work.\n     * \n     * @since Ant 1.5\n     */\n    private void execFindbugs() throws BuildException {\n\n        System.out.println(\"Executing findbugs from ant task\");\n        createFindbugsEngine();\n        configureFindbugsEngine();\n\n        beforeExecuteJavaProcess();\n\n        if (getDebug()) {\n            log(getFindbugsEngine().getCommandLine().describeCommand());\n        }\n\n        /*\n         * set property containing return code of child process using a task\n         * identifier and a UUID to ensure exit code corresponds to this\n         * execution (the base Ant Task won't overwrite return code once it's\n         * been set, so unique identifiers must be used for each execution if we\n         * want to get the exit code)\n         */\n        String execReturnCodeIdentifier = execResultProperty + \".\" + UUID.randomUUID().toString();\n        getFindbugsEngine().setResultProperty(execReturnCodeIdentifier);\n\n        /*\n         * if the execution fails, we'll report it ourself -- prevent the\n         * underlying Ant Java object from throwing an exception\n         */\n        getFindbugsEngine().setFailonerror(false);\n        try {\n            getFindbugsEngine().execute();\n        } catch (BuildException be) {\n            // setFailonerror(false) should ensure that this doesn't happen,\n            // but...\n            log(be.toString());\n        }\n        String returnProperty = getFindbugsEngine().getProject().getProperty(execReturnCodeIdentifier);\n        int rc = returnProperty == null ? 0 : Integer.valueOf(returnProperty).intValue();\n\n        afterExecuteJavaProcess(rc);\n    }","id":23396,"modified_method":"/**\n     * Create a new JVM to do the work.\n     * \n     * @since Ant 1.5\n     */\n    private void execFindbugs() throws BuildException {\n\n        System.out.println(\"Executing findbugs from ant task\");\n        createFindbugsEngine();\n        configureFindbugsEngine();\n\n        beforeExecuteJavaProcess();\n\n        if (getDebug()) {\n            log(getFindbugsEngine().getCommandLine().describeCommand());\n        }\n\n        /*\n         * set property containing return code of child process using a task\n         * identifier and a UUID to ensure exit code corresponds to this\n         * execution (the base Ant Task won't overwrite return code once it's\n         * been set, so unique identifiers must be used for each execution if we\n         * want to get the exit code)\n         */\n        String execReturnCodeIdentifier = execResultProperty + \".\" + UUID.randomUUID().toString();\n        getFindbugsEngine().setResultProperty(execReturnCodeIdentifier);\n\n        /*\n         * if the execution fails, we'll report it ourself -- prevent the\n         * underlying Ant Java object from throwing an exception\n         */\n        getFindbugsEngine().setFailonerror(false);\n        try {\n            getFindbugsEngine().execute();\n        } catch (BuildException be) {\n            // setFailonerror(false) should ensure that this doesn't happen,\n            // but...\n            log(be.toString());\n        }\n        String returnProperty = getFindbugsEngine().getProject().getProperty(execReturnCodeIdentifier);\n        int rc = returnProperty == null ? 0 : Integer.parseInt(returnProperty);\n\n        afterExecuteJavaProcess(rc);\n    }","commit_id":"8400e8993eea686b81ef7184a18067537a6f308e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n      * Initializes this network address manager service implementation and\n      * starts all processes/threads associated with this address manager, such\n      * as a stun firewall/nat detector, keep alive threads, binding lifetime\n      * discovery threads and etc. The method may also be used after a call to\n      * stop() as a reinitialization technique.\n      */\n     public void start()\n     {\n         // init stun\n         String stunAddressStr = null;\n         int port = -1;\n         stunAddressStr = NetaddrActivator.getConfigurationService().getString(\n             PROP_STUN_SERVER_ADDRESS);\n         String portStr = NetaddrActivator.getConfigurationService().getString(\n             PROP_STUN_SERVER_PORT);\n\n         this.localHostFinderSocket = initRandomPortSocket();\n\n         if (stunAddressStr == null\n             || portStr == null)\n         {\n            useStun = false;\n\n            logger.info(\"Stun server address(\"\n                        +stunAddressStr+\")/port(\"\n                        +portStr\n                        +\") not set (or invalid). Disabling STUN.\");\n\n         }\n         else\n         {\n            try\n            {\n                port = Integer.valueOf(portStr).intValue();\n            }\n            catch (NumberFormatException ex)\n            {\n                logger.info(portStr + \" is not a valid port number. \"\n                             +\"Defaulting to 3478\",\n                             ex);\n                port = DEFAULT_STUN_SERVER_PORT;\n            }\n\n             stunServerAddress = new StunAddress(stunAddressStr, port);\n             detector = new SimpleAddressDetector(stunServerAddress);\n\n             if (logger.isDebugEnabled())\n             {\n                 logger.debug(\n                     \"Created a STUN Address detector for the following \"\n                     + \"STUN server: \"\n                     + stunAddressStr + \":\" + port);\n             }\n             detector.start();\n             logger.debug(\"STUN server detector started;\");\n\n             //make sure that someone doesn't set invalid stun address and port\n             NetaddrActivator.getConfigurationService().addVetoableChangeListener(\n                 PROP_STUN_SERVER_ADDRESS, this);\n             NetaddrActivator.getConfigurationService().addVetoableChangeListener(\n                 PROP_STUN_SERVER_PORT, this);\n\n             //now start a thread query to the stun server and only set the\n             //useStun flag to true if it succeeds.\n             launchStunServerTest();\n         }\n     }","id":23397,"modified_method":"/**\n      * Initializes this network address manager service implementation and\n      * starts all processes/threads associated with this address manager, such\n      * as a stun firewall/nat detector, keep alive threads, binding lifetime\n      * discovery threads and etc. The method may also be used after a call to\n      * stop() as a reinitialization technique.\n      */\n     public void start()\n     {\n         // init stun\n         ConfigurationService configurationService\n             = NetaddrActivator.getConfigurationService();\n         String stunAddressStr\n             = configurationService.getString(PROP_STUN_SERVER_ADDRESS);\n         String portStr\n             = configurationService.getString(PROP_STUN_SERVER_PORT);\n\n         this.localHostFinderSocket = initRandomPortSocket();\n\n         if ((stunAddressStr == null) || (portStr == null))\n         {\n            useStun = false;\n\n            logger.info(\"Stun server address(\"\n                        +stunAddressStr+\")/port(\"\n                        +portStr\n                        +\") not set (or invalid). Disabling STUN.\");\n\n         }\n         else\n         {\n             int port = -1;\n\n             try\n             {\n                port = Integer.parseInt(portStr);\n             }\n             catch (NumberFormatException ex)\n             {\n                 logger.info(portStr + \" is not a valid port number. \"\n                             +\"Defaulting to 3478\",\n                             ex);\n                 port = DEFAULT_STUN_SERVER_PORT;\n             }\n\n             stunServerAddress = new StunAddress(stunAddressStr, port);\n             detector = new SimpleAddressDetector(stunServerAddress);\n\n             if (logger.isDebugEnabled())\n             {\n                 logger.debug(\n                     \"Created a STUN Address detector for the following \"\n                     + \"STUN server: \"\n                     + stunAddressStr + \":\" + port);\n             }\n             detector.start();\n             logger.debug(\"STUN server detector started;\");\n\n             //make sure that someone doesn't set invalid stun address and port\n             configurationService\n                 .addVetoableChangeListener(PROP_STUN_SERVER_ADDRESS, this);\n             configurationService\n                 .addVetoableChangeListener(PROP_STUN_SERVER_PORT, this);\n\n             //now start a thread query to the stun server and only set the\n             //useStun flag to true if it succeeds.\n             launchStunServerTest();\n         }\n     }","commit_id":"75e2478b46327b523b7be1202acd401425e36ef7","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n      * Kills all threads/processes lauched by this thread and prepares it for\n      * shutdown. You may use this method as a reinitialization technique (\n      * you'll have to call start afterwards)\n      */\n     public void stop()\n     {\n         try\n         {\n            try{\n                detector.shutDown();\n            }catch (Exception ex){\n                logger.debug(\"Failed to properly shutdown a stun detector: \"\n                    +ex.getMessage());\n\n            }\n             detector = null;\n             useStun = false;\n\n             //remove the listeners\n             NetaddrActivator.getConfigurationService()\n                 .removeVetoableChangeListener( PROP_STUN_SERVER_ADDRESS, this);\n\n             NetaddrActivator.getConfigurationService()\n                 .removeVetoableChangeListener( PROP_STUN_SERVER_PORT, this);\n\n         }\n         finally\n         {\n             logger.logExit();\n         }\n\n     }","id":23398,"modified_method":"/**\n      * Kills all threads/processes lauched by this thread and prepares it for\n      * shutdown. You may use this method as a reinitialization technique (\n      * you'll have to call start afterwards)\n      */\n     public void stop()\n     {\n         try\n         {\n             if (detector != null)\n             {\n                 try\n                 {\n                     detector.shutDown();\n                 }\n                 catch (Exception ex)\n                 {\n                     logger\n                         .debug(\n                             \"Failed to properly shutdown a stun detector: \"\n                                 + ex.getMessage());\n\n                 }\n                 detector = null;\n             }\n             useStun = false;\n\n             //remove the listeners\n             ConfigurationService configurationService\n                 = NetaddrActivator.getConfigurationService();\n             configurationService\n                 .removeVetoableChangeListener( PROP_STUN_SERVER_ADDRESS, this);\n             configurationService\n                 .removeVetoableChangeListener( PROP_STUN_SERVER_PORT, this);\n\n         }\n         finally\n         {\n             logger.logExit();\n         }\n     }","commit_id":"75e2478b46327b523b7be1202acd401425e36ef7","url":"https://github.com/jitsi/jitsi"},{"original_method":"public static void handleSetProperty(Object bean, String prop,\n                                         char value)\n        throws JasperException\n    {\n        try {\n            Method method = getWriteMethod(bean.getClass(), prop);\n            method.invoke(bean, new Object[] { new Character(value) });\n        } catch (Exception ex) {\n            throw new JasperException(ex);\n        }        \n    }","id":23399,"modified_method":"public static void handleSetProperty(Object bean, String prop,\n                                         char value)\n        throws JasperException\n    {\n        try {\n            Method method = getWriteMethod(bean.getClass(), prop);\n            method.invoke(bean, new Object[] { Character.valueOf(value) });\n        } catch (Exception ex) {\n            throw new JasperException(ex);\n        }        \n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static String toString(int i) {\n        return new Integer(i).toString();\n    }","id":23400,"modified_method":"public static String toString(int i) {\n        return Integer.toString(i);\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static double coerceToDouble(String s) {\n        if (s == null || s.length() == 0)\n            return 0;\n        else\n            return Double.valueOf(s).doubleValue();\n    }","id":23401,"modified_method":"public static double coerceToDouble(String s) {\n        if (s == null || s.length() == 0)\n            return 0;\n        else\n            return Double.parseDouble(s);\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static void handleSetProperty(Object bean, String prop,\n                                         int value)\n        throws JasperException\n    {\n        try {\n            Method method = getWriteMethod(bean.getClass(), prop);\n            method.invoke(bean, new Object[] { new Integer(value) });\n        } catch (Exception ex) {\n            throw new JasperException(ex);\n        }        \n    }","id":23402,"modified_method":"public static void handleSetProperty(Object bean, String prop,\n                                         int value)\n        throws JasperException\n    {\n        try {\n            Method method = getWriteMethod(bean.getClass(), prop);\n            method.invoke(bean, new Object[] { Integer.valueOf(value) });\n        } catch (Exception ex) {\n            throw new JasperException(ex);\n        }        \n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static void handleSetProperty(Object bean, String prop,\n                                         byte value)\n        throws JasperException\n    {\n        try {\n            Method method = getWriteMethod(bean.getClass(), prop);\n            method.invoke(bean, new Object[] { new Byte(value) });\n        } catch (Exception ex) {\n            throw new JasperException(ex);\n        }        \n    }","id":23403,"modified_method":"public static void handleSetProperty(Object bean, String prop,\n                                         byte value)\n        throws JasperException\n    {\n        try {\n            Method method = getWriteMethod(bean.getClass(), prop);\n            method.invoke(bean, new Object[] { Byte.valueOf(value) });\n        } catch (Exception ex) {\n            throw new JasperException(ex);\n        }        \n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static int coerceToInt(String s) {\n        if (s == null || s.length() == 0)\n            return 0;\n        else\n            return Integer.valueOf(s).intValue();\n    }","id":23404,"modified_method":"public static int coerceToInt(String s) {\n        if (s == null || s.length() == 0)\n            return 0;\n        else\n            return Integer.parseInt(s);\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Create a typed array.\n     * This is a special case where params are passed through\n     * the request and the property is indexed.\n     */\n    public static void createTypedArray(String propertyName,\n                                        Object bean,\n                                        Method method,\n                                        String[] values,\n                                        Class<?> t,\n                                        Class<?> propertyEditorClass)\n                throws JasperException {\n\n        try {\n            if (propertyEditorClass != null) {\n                Object[] tmpval = new Integer[values.length];\n                for (int i=0; i<values.length; i++) {\n                    tmpval[i] = getValueFromBeanInfoPropertyEditor(\n                            t, propertyName, values[i], propertyEditorClass);\n                }\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Integer.class)) {\n                Integer []tmpval = new Integer[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] =  new Integer (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Byte.class)) {\n                Byte[] tmpval = new Byte[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = new Byte (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Boolean.class)) {\n                Boolean[] tmpval = new Boolean[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Boolean.valueOf(values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Short.class)) {\n                Short[] tmpval = new Short[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = new Short (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Long.class)) {\n                Long[] tmpval = new Long[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = new Long (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Double.class)) {\n                Double[] tmpval = new Double[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = new Double (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Float.class)) {\n                Float[] tmpval = new Float[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = new Float (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Character.class)) {\n                Character[] tmpval = new Character[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = new Character(values[i].charAt(0));\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(int.class)) {\n                int []tmpval = new int[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Integer.parseInt (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(byte.class)) {\n                byte[] tmpval = new byte[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Byte.parseByte (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(boolean.class)) {\n                boolean[] tmpval = new boolean[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = (Boolean.valueOf(values[i])).booleanValue();\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(short.class)) {\n                short[] tmpval = new short[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Short.parseShort (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(long.class)) {\n                long[] tmpval = new long[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Long.parseLong (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(double.class)) {\n                double[] tmpval = new double[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Double.valueOf(values[i]).doubleValue();\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(float.class)) {\n                float[] tmpval = new float[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Float.valueOf(values[i]).floatValue();\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(char.class)) {\n                char[] tmpval = new char[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = values[i].charAt(0);\n                method.invoke (bean, new Object[] {tmpval});\n            } else {\n                Object[] tmpval = new Integer[values.length];\n                for (int i=0; i<values.length; i++) {\n                    tmpval[i] =  \n                        getValueFromPropertyEditorManager(\n                                            t, propertyName, values[i]);\n                }\n                method.invoke (bean, new Object[] {tmpval});\n            }\n        } catch (Exception ex) {\n            throw new JasperException (\"error in invoking method\", ex);\n        }\n    }","id":23405,"modified_method":"/**\n     * Create a typed array.\n     * This is a special case where params are passed through\n     * the request and the property is indexed.\n     */\n    public static void createTypedArray(String propertyName,\n                                        Object bean,\n                                        Method method,\n                                        String[] values,\n                                        Class<?> t,\n                                        Class<?> propertyEditorClass)\n                throws JasperException {\n\n        try {\n            if (propertyEditorClass != null) {\n                Object[] tmpval = new Integer[values.length];\n                for (int i=0; i<values.length; i++) {\n                    tmpval[i] = getValueFromBeanInfoPropertyEditor(\n                            t, propertyName, values[i], propertyEditorClass);\n                }\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Integer.class)) {\n                Integer []tmpval = new Integer[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] =  new Integer (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Byte.class)) {\n                Byte[] tmpval = new Byte[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = new Byte (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Boolean.class)) {\n                Boolean[] tmpval = new Boolean[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Boolean.valueOf(values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Short.class)) {\n                Short[] tmpval = new Short[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = new Short (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Long.class)) {\n                Long[] tmpval = new Long[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = new Long (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Double.class)) {\n                Double[] tmpval = new Double[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = new Double (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Float.class)) {\n                Float[] tmpval = new Float[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = new Float (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(Character.class)) {\n                Character[] tmpval = new Character[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Character.valueOf(values[i].charAt(0));\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(int.class)) {\n                int []tmpval = new int[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Integer.parseInt (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(byte.class)) {\n                byte[] tmpval = new byte[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Byte.parseByte (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(boolean.class)) {\n                boolean[] tmpval = new boolean[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = (Boolean.valueOf(values[i])).booleanValue();\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(short.class)) {\n                short[] tmpval = new short[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Short.parseShort (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(long.class)) {\n                long[] tmpval = new long[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Long.parseLong (values[i]);\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(double.class)) {\n                double[] tmpval = new double[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Double.valueOf(values[i]).doubleValue();\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(float.class)) {\n                float[] tmpval = new float[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = Float.valueOf(values[i]).floatValue();\n                method.invoke (bean, new Object[] {tmpval});\n            } else if (t.equals(char.class)) {\n                char[] tmpval = new char[values.length];\n                for (int i = 0 ; i < values.length; i++)\n                    tmpval[i] = values[i].charAt(0);\n                method.invoke (bean, new Object[] {tmpval});\n            } else {\n                Object[] tmpval = new Integer[values.length];\n                for (int i=0; i<values.length; i++) {\n                    tmpval[i] =  \n                        getValueFromPropertyEditorManager(\n                                            t, propertyName, values[i]);\n                }\n                method.invoke (bean, new Object[] {tmpval});\n            }\n        } catch (Exception ex) {\n            throw new JasperException (\"error in invoking method\", ex);\n        }\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static void handleSetProperty(Object bean, String prop,\n                                         short value)\n        throws JasperException\n    {\n        try {\n            Method method = getWriteMethod(bean.getClass(), prop);\n            method.invoke(bean, new Object[] { new Short(value) });\n        } catch (Exception ex) {\n            throw new JasperException(ex);\n        }        \n    }","id":23406,"modified_method":"public static void handleSetProperty(Object bean, String prop,\n                                         short value)\n        throws JasperException\n    {\n        try {\n            Method method = getWriteMethod(bean.getClass(), prop);\n            method.invoke(bean, new Object[] { Short.valueOf(value) });\n        } catch (Exception ex) {\n            throw new JasperException(ex);\n        }        \n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static String toString(byte b) {\n        return new Byte(b).toString();\n    }","id":23407,"modified_method":"public static String toString(byte b) {\n        return Byte.toString(b);\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static boolean coerceToBoolean(String s) {\n        if (s == null || s.length() == 0)\n            return false;\n        else\n            return Boolean.valueOf(s).booleanValue();\n    }","id":23408,"modified_method":"public static boolean coerceToBoolean(String s) {\n        if (s == null || s.length() == 0)\n            return false;\n        else\n            return Boolean.parseBoolean(s);\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static String toString(short s) {\n        return new Short(s).toString();\n    }","id":23409,"modified_method":"public static String toString(short s) {\n        return Short.toString(s);\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static short coerceToShort(String s) {\n        if (s == null || s.length() == 0)\n            return (short) 0;\n        else\n            return Short.valueOf(s).shortValue();\n    }","id":23410,"modified_method":"public static short coerceToShort(String s) {\n        if (s == null || s.length() == 0)\n            return (short) 0;\n        else\n            return Short.parseShort(s);\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static Object convert(String propertyName, String s, Class<?> t,\n            Class<?> propertyEditorClass) \n       throws JasperException \n    {\n        try {\n            if (s == null) {\n                if (t.equals(Boolean.class) || t.equals(Boolean.TYPE))\n                    s = \"false\";\n                else\n                    return null;\n            }\n            if (propertyEditorClass != null) {\n                return getValueFromBeanInfoPropertyEditor(\n                                    t, propertyName, s, propertyEditorClass);\n            } else if ( t.equals(Boolean.class) || t.equals(Boolean.TYPE) ) {\n                if (s.equalsIgnoreCase(\"on\") || s.equalsIgnoreCase(\"true\"))\n                    s = \"true\";\n                else\n                    s = \"false\";\n                return Boolean.valueOf(s);\n            } else if ( t.equals(Byte.class) || t.equals(Byte.TYPE) ) {\n                return new Byte(s);\n            } else if (t.equals(Character.class) || t.equals(Character.TYPE)) {\n                return s.length() > 0 ? new Character(s.charAt(0)) : null;\n            } else if ( t.equals(Short.class) || t.equals(Short.TYPE) ) {\n                return new Short(s);\n            } else if ( t.equals(Integer.class) || t.equals(Integer.TYPE) ) {\n                return new Integer(s);\n            } else if ( t.equals(Float.class) || t.equals(Float.TYPE) ) {\n                return new Float(s);\n            } else if ( t.equals(Long.class) || t.equals(Long.TYPE) ) {\n                return new Long(s);\n            } else if ( t.equals(Double.class) || t.equals(Double.TYPE) ) {\n                return new Double(s);\n            } else if ( t.equals(String.class) ) {\n                return s;\n            } else if ( t.equals(java.io.File.class) ) {\n                return new java.io.File(s);\n            } else if (t.getName().equals(\"java.lang.Object\")) {\n                return new Object[] {s};\n            } else {\n                return getValueFromPropertyEditorManager(\n                                            t, propertyName, s);\n            }\n        } catch (Exception ex) {\n            throw new JasperException(ex);\n        }\n    }","id":23411,"modified_method":"public static Object convert(String propertyName, String s, Class<?> t,\n            Class<?> propertyEditorClass) \n       throws JasperException \n    {\n        try {\n            if (s == null) {\n                if (t.equals(Boolean.class) || t.equals(Boolean.TYPE))\n                    s = \"false\";\n                else\n                    return null;\n            }\n            if (propertyEditorClass != null) {\n                return getValueFromBeanInfoPropertyEditor(\n                                    t, propertyName, s, propertyEditorClass);\n            } else if ( t.equals(Boolean.class) || t.equals(Boolean.TYPE) ) {\n                if (s.equalsIgnoreCase(\"on\") || s.equalsIgnoreCase(\"true\"))\n                    s = \"true\";\n                else\n                    s = \"false\";\n                return Boolean.valueOf(s);\n            } else if ( t.equals(Byte.class) || t.equals(Byte.TYPE) ) {\n                return Byte.valueOf(s);\n            } else if (t.equals(Character.class) || t.equals(Character.TYPE)) {\n                return s.length() > 0 ? Character.valueOf(s.charAt(0)) : null;\n            } else if ( t.equals(Short.class) || t.equals(Short.TYPE) ) {\n                return Short.valueOf(s);\n            } else if ( t.equals(Integer.class) || t.equals(Integer.TYPE) ) {\n                return Integer.valueOf(s);\n            } else if ( t.equals(Float.class) || t.equals(Float.TYPE) ) {\n                return Float.valueOf(s);\n            } else if ( t.equals(Long.class) || t.equals(Long.TYPE) ) {\n                return Long.valueOf(s);\n            } else if ( t.equals(Double.class) || t.equals(Double.TYPE) ) {\n                return Double.valueOf(s);\n            } else if ( t.equals(String.class) ) {\n                return s;\n            } else if ( t.equals(java.io.File.class) ) {\n                return new java.io.File(s);\n            } else if (t.getName().equals(\"java.lang.Object\")) {\n                return new Object[] {s};\n            } else {\n                return getValueFromPropertyEditorManager(\n                                            t, propertyName, s);\n            }\n        } catch (Exception ex) {\n            throw new JasperException(ex);\n        }\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static String toString(float f) {\n        return new Float(f).toString();\n    }","id":23412,"modified_method":"public static String toString(float f) {\n        return Float.toString(f);\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static long coerceToLong(String s) {\n        if (s == null || s.length() == 0)\n            return 0;\n        else\n            return Long.valueOf(s).longValue();\n    }","id":23413,"modified_method":"public static long coerceToLong(String s) {\n        if (s == null || s.length() == 0)\n            return 0;\n        else\n            return Long.parseLong(s);\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static String toString(boolean b) {\n        return Boolean.valueOf(b).toString();\n    }","id":23414,"modified_method":"public static String toString(boolean b) {\n        return Boolean.toString(b);\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static float coerceToFloat(String s) {\n        if (s == null || s.length() == 0)\n            return 0;\n        else\n            return Float.valueOf(s).floatValue();\n    }","id":23415,"modified_method":"public static float coerceToFloat(String s) {\n        if (s == null || s.length() == 0)\n            return 0;\n        else\n            return Float.parseFloat(s);\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static String toString(double d) {\n        return new Double(d).toString();\n    }","id":23416,"modified_method":"public static String toString(double d) {\n        return Double.toString(d);\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static byte coerceToByte(String s) {\n        if (s == null || s.length() == 0)\n            return (byte) 0;\n        else\n            return Byte.valueOf(s).byteValue();\n    }","id":23417,"modified_method":"public static byte coerceToByte(String s) {\n        if (s == null || s.length() == 0)\n            return (byte) 0;\n        else\n            return Byte.parseByte(s);\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static void handleSetProperty(Object bean, String prop,\n                                         float value)\n        throws JasperException\n    {\n        try {\n            Method method = getWriteMethod(bean.getClass(), prop);\n            method.invoke(bean, new Object[] { new Float(value) });\n        } catch (Exception ex) {\n            throw new JasperException(ex);\n        }        \n    }","id":23418,"modified_method":"public static void handleSetProperty(Object bean, String prop,\n                                         float value)\n        throws JasperException\n    {\n        try {\n            Method method = getWriteMethod(bean.getClass(), prop);\n            method.invoke(bean, new Object[] { Float.valueOf(value) });\n        } catch (Exception ex) {\n            throw new JasperException(ex);\n        }        \n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static void handleSetProperty(Object bean, String prop,\n                                         double value)\n        throws JasperException\n    {\n        try {\n            Method method = getWriteMethod(bean.getClass(), prop);\n            method.invoke(bean, new Object[] { new Double(value) });\n        } catch (Exception ex) {\n            throw new JasperException(ex);\n        }        \n    }","id":23419,"modified_method":"public static void handleSetProperty(Object bean, String prop,\n                                         double value)\n        throws JasperException\n    {\n        try {\n            Method method = getWriteMethod(bean.getClass(), prop);\n            method.invoke(bean, new Object[] { Double.valueOf(value) });\n        } catch (Exception ex) {\n            throw new JasperException(ex);\n        }        \n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static String toString(long l) {\n        return new Long(l).toString();\n    }","id":23420,"modified_method":"public static String toString(long l) {\n        return Long.toString(l);\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static Object coerce(String s, Class<?> target) {\n\n        boolean isNullOrEmpty = (s == null || s.length() == 0);\n\n        if (target == Boolean.class) {\n            if (isNullOrEmpty) {\n                s = \"false\";\n            }\n            return Boolean.valueOf(s);\n        } else if (target == Byte.class) {\n            if (isNullOrEmpty)\n                return new Byte((byte) 0);\n            else\n                return new Byte(s);\n        } else if (target == Character.class) {\n            if (isNullOrEmpty)\n                return new Character((char) 0);\n            else \n                return new Character(s.charAt(0));\n        } else if (target == Double.class) {\n            if (isNullOrEmpty)\n                return new Double(0);\n            else\n                return new Double(s);\n        } else if (target == Float.class) {\n            if (isNullOrEmpty)\n                return new Float(0);\n            else\n                return new Float(s);\n        } else if (target == Integer.class) {\n            if (isNullOrEmpty)\n                return new Integer(0);\n            else\n                return new Integer(s);\n        } else if (target == Short.class) {\n            if (isNullOrEmpty)\n                return new Short((short) 0);\n            else\n                return new Short(s);\n        } else if (target == Long.class) {\n            if (isNullOrEmpty)\n                return new Long(0);\n            else\n                return new Long(s);\n        } else {\n            return null;\n        }\n    }","id":23421,"modified_method":"public static Object coerce(String s, Class<?> target) {\n\n        boolean isNullOrEmpty = (s == null || s.length() == 0);\n\n        if (target == Boolean.class) {\n            if (isNullOrEmpty) {\n                s = \"false\";\n            }\n            return Boolean.valueOf(s);\n        } else if (target == Byte.class) {\n            if (isNullOrEmpty)\n                return Byte.valueOf((byte) 0);\n            else\n                return Byte.valueOf(s);\n        } else if (target == Character.class) {\n            if (isNullOrEmpty)\n                return Character.valueOf((char) 0);\n            else \n                return Character.valueOf(s.charAt(0));\n        } else if (target == Double.class) {\n            if (isNullOrEmpty)\n                return Double.valueOf(0);\n            else\n                return Double.valueOf(s);\n        } else if (target == Float.class) {\n            if (isNullOrEmpty)\n                return Float.valueOf(0);\n            else\n                return Float.valueOf(s);\n        } else if (target == Integer.class) {\n            if (isNullOrEmpty)\n                return Integer.valueOf(0);\n            else\n                return Integer.valueOf(s);\n        } else if (target == Short.class) {\n            if (isNullOrEmpty)\n                return Short.valueOf((short) 0);\n            else\n                return Short.valueOf(s);\n        } else if (target == Long.class) {\n            if (isNullOrEmpty)\n                return Long.valueOf(0);\n            else\n                return Long.valueOf(s);\n        } else {\n            return null;\n        }\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static String toString(char c) {\n        return new Character(c).toString();\n    }","id":23422,"modified_method":"public static String toString(char c) {\n        return Character.toString(c);\n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public static void handleSetProperty(Object bean, String prop,\n                                         long value)\n        throws JasperException\n    {\n        try {\n            Method method = getWriteMethod(bean.getClass(), prop);\n            method.invoke(bean, new Object[] { new Long(value) });\n        } catch (Exception ex) {\n            throw new JasperException(ex);\n        }        \n    }","id":23423,"modified_method":"public static void handleSetProperty(Object bean, String prop,\n                                         long value)\n        throws JasperException\n    {\n        try {\n            Method method = getWriteMethod(bean.getClass(), prop);\n            method.invoke(bean, new Object[] { Long.valueOf(value) });\n        } catch (Exception ex) {\n            throw new JasperException(ex);\n        }        \n    }","commit_id":"20ace4109bcecccc136b9324921614b046772134","url":"https://github.com/apache/tomcat"},{"original_method":"public int compareTo(HServerAddress o) {\n    // Addresses as Strings may not compare though address is for the one\n    // server with only difference being that one address has hostname\n    // resolved whereas other only has IP.\n    if (this.address.equals(o.address)) return 0;\n    return this.toString().compareTo(o.toString());\n  }","id":23424,"modified_method":"public int compareTo(HServerAddress o) {\n    // Addresses as Strings may not compare though address is for the one\n    // server with only difference being that one address has hostname\n    // resolved whereas other only has IP.\n    if (address.equals(o.address)) return 0;\n    return toString().compareTo(o.toString());\n  }","commit_id":"2993d97c97a69906b6f790bbc0608848f26d5b48","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Construct a HServerAddress from an InetSocketAddress\n   * @param address InetSocketAddress of server\n   */\n  public HServerAddress(InetSocketAddress address) {\n    this.address = address;\n    this.stringValue = address.getAddress().getHostAddress() + \":\" +\n      address.getPort();\n  }","id":23425,"modified_method":"/**\n   * Construct an instance from an {@link InetSocketAddress}.\n   * @param address InetSocketAddress of server\n   */\n  public HServerAddress(InetSocketAddress address) {\n    this.address = address;\n    this.stringValue = address.getAddress().getHostAddress() + \":\" +\n      address.getPort();\n    checkBindAddressCanBeResolved();\n  }","commit_id":"2993d97c97a69906b6f790bbc0608848f26d5b48","url":"https://github.com/apache/hbase"},{"original_method":"/** @return Hostname */\n  public String getHostname() {\n    return this.address.getHostName();\n  }","id":23426,"modified_method":"/** @return Hostname */\n  public String getHostname() {\n    return address.getHostName();\n  }","commit_id":"2993d97c97a69906b6f790bbc0608848f26d5b48","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public int hashCode() {\n    int result = this.address.hashCode();\n    result ^= this.stringValue.hashCode();\n    return result;\n  }","id":23427,"modified_method":"@Override\n  public int hashCode() {\n    int result = address.hashCode();\n    result ^= stringValue.hashCode();\n    return result;\n  }","commit_id":"2993d97c97a69906b6f790bbc0608848f26d5b48","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Copy-constructor\n   *\n   * @param other HServerAddress to copy from\n   */\n  public HServerAddress(HServerAddress other) {\n    String bindAddress = other.getBindAddress();\n    int port = other.getPort();\n    this.address = new InetSocketAddress(bindAddress, port);\n    stringValue = bindAddress + \":\" + port;\n  }","id":23428,"modified_method":"/**\n   * Copy-constructor.\n   * @param other HServerAddress to copy from\n   */\n  public HServerAddress(HServerAddress other) {\n    String bindAddress = other.getBindAddress();\n    int port = other.getPort();\n    this.address = new InetSocketAddress(bindAddress, port);\n    stringValue = other.stringValue;\n    checkBindAddressCanBeResolved();\n  }","commit_id":"2993d97c97a69906b6f790bbc0608848f26d5b48","url":"https://github.com/apache/hbase"},{"original_method":"/** @return The InetSocketAddress */\n  public InetSocketAddress getInetSocketAddress() {\n    return this.address;\n  }","id":23429,"modified_method":"/** @return The InetSocketAddress */\n  public InetSocketAddress getInetSocketAddress() {\n    return address;\n  }","commit_id":"2993d97c97a69906b6f790bbc0608848f26d5b48","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * @return String formatted as <code>&lt;bind address> ':' &lt;port><\/code>\n   */\n  @Override\n  public String toString() {\n    return (this.stringValue == null ? \"\" : this.stringValue);\n  }","id":23430,"modified_method":"/**\n   * @return String formatted as <code>&lt;bind address> ':' &lt;port><\/code>\n   */\n  @Override\n  public String toString() {\n    return stringValue == null ? \"\" : stringValue;\n  }","commit_id":"2993d97c97a69906b6f790bbc0608848f26d5b48","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * @param bindAddress Hostname\n   * @param port Port number\n   */\n  public HServerAddress(String bindAddress, int port) {\n    this.address = new InetSocketAddress(bindAddress, port);\n    this.stringValue = bindAddress + \":\" + port;\n  }","id":23431,"modified_method":"/**\n   * @param bindAddress Hostname\n   * @param port Port number\n   */\n  public HServerAddress(String bindAddress, int port) {\n    this.address = new InetSocketAddress(bindAddress, port);\n    this.stringValue = bindAddress + \":\" + port;\n    checkBindAddressCanBeResolved();\n  }","commit_id":"2993d97c97a69906b6f790bbc0608848f26d5b48","url":"https://github.com/apache/hbase"},{"original_method":"public void readFields(DataInput in) throws IOException {\n    String bindAddress = in.readUTF();\n    int port = in.readInt();\n\n    if(bindAddress == null || bindAddress.length() == 0) {\n      address = null;\n      stringValue = null;\n\n    } else {\n      address = new InetSocketAddress(bindAddress, port);\n      stringValue = bindAddress + \":\" + port;\n    }\n  }","id":23432,"modified_method":"public void readFields(DataInput in) throws IOException {\n    String bindAddress = in.readUTF();\n    int port = in.readInt();\n\n    if (bindAddress == null || bindAddress.length() == 0) {\n      address = null;\n      stringValue = null;\n    } else {\n      address = new InetSocketAddress(bindAddress, port);\n      stringValue = bindAddress + \":\" + port;\n      checkBindAddressCanBeResolved();\n    }\n  }","commit_id":"2993d97c97a69906b6f790bbc0608848f26d5b48","url":"https://github.com/apache/hbase"},{"original_method":"/** @return Port number */\n  public int getPort() {\n    return this.address.getPort();\n  }","id":23433,"modified_method":"/** @return Port number */\n  public int getPort() {\n    return address.getPort();\n  }","commit_id":"2993d97c97a69906b6f790bbc0608848f26d5b48","url":"https://github.com/apache/hbase"},{"original_method":"/** @return Bind address */\n  public String getBindAddress() {\n    return this.address.getAddress().getHostAddress();\n  }","id":23434,"modified_method":"/** @return Bind address */\n  public String getBindAddress() {\n    final InetAddress addr = address.getAddress();\n    if (addr != null) {\n      return addr.getHostAddress();\n    } else {\n      LogFactory.getLog(HServerAddress.class).error(\"Could not resolve the\"\n          + \" DNS name of \" + stringValue);\n      return null;\n    }\n  }","commit_id":"2993d97c97a69906b6f790bbc0608848f26d5b48","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * @param hostAndPort Hostname and port formatted as <code>&lt;hostname> ':' &lt;port><\/code>\n   */\n  public HServerAddress(String hostAndPort) {\n    int colonIndex = hostAndPort.lastIndexOf(':');\n    if(colonIndex < 0) {\n      throw new IllegalArgumentException(\"Not a host:port pair: \" + hostAndPort);\n    }\n    String host = hostAndPort.substring(0, colonIndex);\n    int port =\n      Integer.valueOf(hostAndPort.substring(colonIndex + 1)).intValue();\n    this.address = new InetSocketAddress(host, port);\n    this.stringValue = hostAndPort;\n  }","id":23435,"modified_method":"/**\n   * @param hostAndPort Hostname and port formatted as <code>&lt;hostname> ':' &lt;port><\/code>\n   */\n  public HServerAddress(String hostAndPort) {\n    int colonIndex = hostAndPort.lastIndexOf(':');\n    if (colonIndex < 0) {\n      throw new IllegalArgumentException(\"Not a host:port pair: \" + hostAndPort);\n    }\n    String host = hostAndPort.substring(0, colonIndex);\n    int port = Integer.parseInt(hostAndPort.substring(colonIndex + 1));\n    this.address = new InetSocketAddress(host, port);\n    this.stringValue = hostAndPort;\n    checkBindAddressCanBeResolved();\n  }","commit_id":"2993d97c97a69906b6f790bbc0608848f26d5b48","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null) {\n      return false;\n    }\n    if (getClass() != o.getClass()) {\n      return false;\n    }\n    return this.compareTo((HServerAddress)o) == 0;\n  }","id":23436,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null) {\n      return false;\n    }\n    if (getClass() != o.getClass()) {\n      return false;\n    }\n    return compareTo((HServerAddress) o) == 0;\n  }","commit_id":"2993d97c97a69906b6f790bbc0608848f26d5b48","url":"https://github.com/apache/hbase"},{"original_method":"private boolean importOldIndentOptions(@NonNls Element element) {\n    final List options = element.getChildren(\"option\");\n    boolean optionsImported = false;\n    for (Object option1 : options) {\n      @NonNls Element option = (Element)option1;\n      @NonNls final String name = option.getAttributeValue(\"name\");\n      if (\"TAB_SIZE\".equals(name)) {\n        final int value = Integer.valueOf(option.getAttributeValue(\"value\")).intValue();\n        JAVA_INDENT_OPTIONS.TAB_SIZE = value;\n        JSP_INDENT_OPTIONS.TAB_SIZE = value;\n        XML_INDENT_OPTIONS.TAB_SIZE = value;\n        OTHER_INDENT_OPTIONS.TAB_SIZE = value;\n        optionsImported = true;\n      }\n      else if (\"INDENT_SIZE\".equals(name)) {\n        final int value = Integer.valueOf(option.getAttributeValue(\"value\")).intValue();\n        JAVA_INDENT_OPTIONS.INDENT_SIZE = value;\n        JSP_INDENT_OPTIONS.INDENT_SIZE = value;\n        XML_INDENT_OPTIONS.INDENT_SIZE = value;\n        OTHER_INDENT_OPTIONS.INDENT_SIZE = value;\n        optionsImported = true;\n      }\n      else if (\"CONTINUATION_INDENT_SIZE\".equals(name)) {\n        final int value = Integer.valueOf(option.getAttributeValue(\"value\")).intValue();\n        JAVA_INDENT_OPTIONS.CONTINUATION_INDENT_SIZE = value;\n        JSP_INDENT_OPTIONS.CONTINUATION_INDENT_SIZE = value;\n        XML_INDENT_OPTIONS.CONTINUATION_INDENT_SIZE = value;\n        OTHER_INDENT_OPTIONS.CONTINUATION_INDENT_SIZE = value;\n        optionsImported = true;\n      }\n      else if (\"USE_TAB_CHARACTER\".equals(name)) {\n        final boolean value = Boolean.valueOf(option.getAttributeValue(\"value\")).booleanValue();\n        JAVA_INDENT_OPTIONS.USE_TAB_CHARACTER = value;\n        JSP_INDENT_OPTIONS.USE_TAB_CHARACTER = value;\n        XML_INDENT_OPTIONS.USE_TAB_CHARACTER = value;\n        OTHER_INDENT_OPTIONS.USE_TAB_CHARACTER = value;\n        optionsImported = true;\n      }\n      else if (\"SMART_TABS\".equals(name)) {\n        final boolean value = Boolean.valueOf(option.getAttributeValue(\"value\")).booleanValue();\n        JAVA_INDENT_OPTIONS.SMART_TABS = value;\n        JSP_INDENT_OPTIONS.SMART_TABS = value;\n        XML_INDENT_OPTIONS.SMART_TABS = value;\n        OTHER_INDENT_OPTIONS.SMART_TABS = value;\n        optionsImported = true;\n      } else if (\"SPACE_AFTER_UNARY_OPERATOR\".equals(name)) {\n        SPACE_AROUND_UNARY_OPERATOR = Boolean.valueOf(option.getAttributeValue(\"value\")).booleanValue();\n        optionsImported = true;\n      }\n    }\n    return optionsImported;\n  }","id":23437,"modified_method":"private boolean importOldIndentOptions(@NonNls Element element) {\n    final List options = element.getChildren(\"option\");\n    boolean optionsImported = false;\n    for (Object option1 : options) {\n      @NonNls Element option = (Element)option1;\n      @NonNls final String name = option.getAttributeValue(\"name\");\n      if (\"TAB_SIZE\".equals(name)) {\n        final int value = Integer.parseInt(option.getAttributeValue(\"value\"));\n        JAVA_INDENT_OPTIONS.TAB_SIZE = value;\n        JSP_INDENT_OPTIONS.TAB_SIZE = value;\n        XML_INDENT_OPTIONS.TAB_SIZE = value;\n        OTHER_INDENT_OPTIONS.TAB_SIZE = value;\n        optionsImported = true;\n      }\n      else if (\"INDENT_SIZE\".equals(name)) {\n        final int value = Integer.parseInt(option.getAttributeValue(\"value\"));\n        JAVA_INDENT_OPTIONS.INDENT_SIZE = value;\n        JSP_INDENT_OPTIONS.INDENT_SIZE = value;\n        XML_INDENT_OPTIONS.INDENT_SIZE = value;\n        OTHER_INDENT_OPTIONS.INDENT_SIZE = value;\n        optionsImported = true;\n      }\n      else if (\"CONTINUATION_INDENT_SIZE\".equals(name)) {\n        final int value = Integer.parseInt(option.getAttributeValue(\"value\"));\n        JAVA_INDENT_OPTIONS.CONTINUATION_INDENT_SIZE = value;\n        JSP_INDENT_OPTIONS.CONTINUATION_INDENT_SIZE = value;\n        XML_INDENT_OPTIONS.CONTINUATION_INDENT_SIZE = value;\n        OTHER_INDENT_OPTIONS.CONTINUATION_INDENT_SIZE = value;\n        optionsImported = true;\n      }\n      else if (\"USE_TAB_CHARACTER\".equals(name)) {\n        final boolean value = Boolean.parseBoolean(option.getAttributeValue(\"value\"));\n        JAVA_INDENT_OPTIONS.USE_TAB_CHARACTER = value;\n        JSP_INDENT_OPTIONS.USE_TAB_CHARACTER = value;\n        XML_INDENT_OPTIONS.USE_TAB_CHARACTER = value;\n        OTHER_INDENT_OPTIONS.USE_TAB_CHARACTER = value;\n        optionsImported = true;\n      }\n      else if (\"SMART_TABS\".equals(name)) {\n        final boolean value = Boolean.parseBoolean(option.getAttributeValue(\"value\"));\n        JAVA_INDENT_OPTIONS.SMART_TABS = value;\n        JSP_INDENT_OPTIONS.SMART_TABS = value;\n        XML_INDENT_OPTIONS.SMART_TABS = value;\n        OTHER_INDENT_OPTIONS.SMART_TABS = value;\n        optionsImported = true;\n      }\n      else if (\"SPACE_AFTER_UNARY_OPERATOR\".equals(name)) {\n        SPACE_AROUND_UNARY_OPERATOR = Boolean.parseBoolean(option.getAttributeValue(\"value\"));\n        optionsImported = true;\n      }\n    }\n    return optionsImported;\n  }","commit_id":"ac419ff71970a2464c3d25eeea8da87933188047","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void copyCustomSettingsFrom(@NotNull CodeStyleSettings from) {\n    myCustomSettings.clear();\n    for (final CustomCodeStyleSettings settings : from.getCustomSettingsValues()) {\n      addCustomSettings((CustomCodeStyleSettings) settings.clone());\n    }\n\n    FIELD_TYPE_TO_NAME.copyFrom(from.FIELD_TYPE_TO_NAME);\n    STATIC_FIELD_TYPE_TO_NAME.copyFrom(from.STATIC_FIELD_TYPE_TO_NAME);\n    PARAMETER_TYPE_TO_NAME.copyFrom(from.PARAMETER_TYPE_TO_NAME);\n    LOCAL_VARIABLE_TYPE_TO_NAME.copyFrom(from.LOCAL_VARIABLE_TYPE_TO_NAME);\n\n    PACKAGES_TO_USE_IMPORT_ON_DEMAND.copyFrom(from.PACKAGES_TO_USE_IMPORT_ON_DEMAND);\n    IMPORT_LAYOUT_TABLE.copyFrom(from.IMPORT_LAYOUT_TABLE);\n\n    OTHER_INDENT_OPTIONS.copyFrom(from.OTHER_INDENT_OPTIONS);\n\n    myAdditionalIndentOptions.clear();\n    for(Map.Entry<FileType, IndentOptions> optionEntry: from.myAdditionalIndentOptions.entrySet()) {\n      IndentOptions options = optionEntry.getValue();\n      myAdditionalIndentOptions.put(optionEntry.getKey(),(IndentOptions)options.clone());\n    }\n    \n    myCommonSettingsManager = from.myCommonSettingsManager.clone(this);\n  }","id":23438,"modified_method":"private void copyCustomSettingsFrom(@NotNull CodeStyleSettings from) {\n    synchronized (myCustomSettings) {\n      myCustomSettings.clear();\n    }\n    for (final CustomCodeStyleSettings settings : from.getCustomSettingsValues()) {\n      addCustomSettings((CustomCodeStyleSettings) settings.clone());\n    }\n\n    FIELD_TYPE_TO_NAME.copyFrom(from.FIELD_TYPE_TO_NAME);\n    STATIC_FIELD_TYPE_TO_NAME.copyFrom(from.STATIC_FIELD_TYPE_TO_NAME);\n    PARAMETER_TYPE_TO_NAME.copyFrom(from.PARAMETER_TYPE_TO_NAME);\n    LOCAL_VARIABLE_TYPE_TO_NAME.copyFrom(from.LOCAL_VARIABLE_TYPE_TO_NAME);\n\n    PACKAGES_TO_USE_IMPORT_ON_DEMAND.copyFrom(from.PACKAGES_TO_USE_IMPORT_ON_DEMAND);\n    IMPORT_LAYOUT_TABLE.copyFrom(from.IMPORT_LAYOUT_TABLE);\n\n    OTHER_INDENT_OPTIONS.copyFrom(from.OTHER_INDENT_OPTIONS);\n\n    myAdditionalIndentOptions.clear();\n    for(Map.Entry<FileType, IndentOptions> optionEntry: from.myAdditionalIndentOptions.entrySet()) {\n      IndentOptions options = optionEntry.getValue();\n      myAdditionalIndentOptions.put(optionEntry.getKey(),(IndentOptions)options.clone());\n    }\n    \n    myCommonSettingsManager = from.myCommonSettingsManager.clone(this);\n  }","commit_id":"ac419ff71970a2464c3d25eeea8da87933188047","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void setupGeneratedMethod(PsiMethod method) {\n    PsiClass containingClass = method.getContainingClass();\n    PsiClass base = containingClass == null ? null : containingClass.getSuperClass();\n    PsiMethod overridden = base == null ? null : base.findMethodBySignature(method, true);\n\n    if (overridden == null) {\n      CreateFromUsageUtils.setupMethodBody(method, containingClass);\n      return;\n    }\n\n    OverrideImplementUtil.setupMethodBody(method, overridden, containingClass);\n    OverrideImplementUtil.annotateOnOverrideImplement(method, base, overridden);\n  }","id":23439,"modified_method":"public static void setupGeneratedMethod(PsiMethod method) {\n    PsiClass containingClass = method.getContainingClass();\n    PsiClass base = containingClass == null ? null : containingClass.getSuperClass();\n    PsiMethod overridden = base == null ? null : base.findMethodBySignature(method, true);\n\n    boolean emptyTemplate = true;\n    PsiCodeBlock body = method.getBody();\n    if (body != null) {\n      PsiJavaToken lBrace = body.getLBrace();\n      int left = lBrace != null ? lBrace.getStartOffsetInParent() + 1 : 0;\n      PsiJavaToken rBrace = body.getRBrace();\n      int right = rBrace != null ? rBrace.getStartOffsetInParent() : body.getTextLength();\n      emptyTemplate = StringUtil.isEmptyOrSpaces(body.getText().substring(left, right));\n    }\n    \n    if (overridden == null) {\n      if (emptyTemplate) {\n        CreateFromUsageUtils.setupMethodBody(method, containingClass);\n      }\n      return;\n    }\n\n    if (emptyTemplate) {\n      OverrideImplementUtil.setupMethodBody(method, overridden, containingClass);\n    }\n    OverrideImplementUtil.annotateOnOverrideImplement(method, base, overridden);\n  }","commit_id":"49a6bb7f873afd43a676dd82db5799f8929923e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void readJdomExternalizables(ModuleImpl module) {\n    final ModuleRootManagerImpl moduleRootManager = (ModuleRootManagerImpl)ModuleRootManager.getInstance(module);\n    module.doInitJdomExternalizable(ModuleRootManager.class, moduleRootManager);\n\n    ModuleBuildPropertiesEx moduleBuildProperties = (ModuleBuildPropertiesEx)ModuleBuildProperties.getInstance(module);\n    if (moduleBuildProperties != null) {\n      module.doInitJdomExternalizable(ModuleBuildPropertiesEx.class, moduleBuildProperties);\n    }\n\n    JavaeeModuleProperties moduleProperties = JavaeeModuleProperties.getInstance(module);\n    if (moduleProperties != null){\n      module.doInitJdomExternalizable(JavaeeModuleProperties.class, moduleProperties);\n    }\n  }","id":23440,"modified_method":"protected static void readJdomExternalizables(ModuleImpl module) {\n    final ModuleRootManagerImpl moduleRootManager = (ModuleRootManagerImpl)ModuleRootManager.getInstance(module);\n    module.doInitJdomExternalizable(ModuleRootManager.class, moduleRootManager);\n\n    ModuleBuildProperties moduleBuildProperties = ModuleBuildProperties.getInstance(module);\n    if (moduleBuildProperties != null) {\n      module.doInitJdomExternalizable(ModuleBuildProperties.class, moduleBuildProperties);\n    }\n\n    JavaeeModuleProperties moduleProperties = JavaeeModuleProperties.getInstance(module);\n    if (moduleProperties != null){\n      module.doInitJdomExternalizable(JavaeeModuleProperties.class, moduleProperties);\n    }\n  }","commit_id":"bafeb94118433f11f1d2a2a853cb431da54b8de0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static Map<MethodSignature, CandidateInfo> getMapToOverrideImplement(PsiClass aClass,\n                                                                               boolean toImplement) {\n    final PsiSubstitutor contextSubstitutor = getContextSubstitutor(aClass);\n    Map<MethodSignature, PsiMethod> abstracts = new LinkedHashMap<MethodSignature,PsiMethod>();\n    Map<MethodSignature, PsiMethod> finals = new HashMap<MethodSignature,PsiMethod>();\n    Map<MethodSignature, PsiMethod> concretes = new LinkedHashMap<MethodSignature,PsiMethod>();\n    Map<PsiClass, PsiSubstitutor> substitutors = new HashMap<PsiClass,PsiSubstitutor>();\n\n    PsiMethod[] allMethods = aClass.getAllMethods();\n    PsiResolveHelper resolveHelper = aClass.getManager().getResolveHelper();\n    for (PsiMethod method : allMethods) {\n      if (method.hasModifierProperty(PsiModifier.STATIC) || !resolveHelper.isAccessible(method, aClass, aClass)) continue;\n      PsiClass hisClass = method.getContainingClass();\n      //Filter non-immediate super constructors\n      if (method.isConstructor() && (!aClass.isInheritor(hisClass, false) || aClass instanceof PsiAnonymousClass || aClass.isEnum())) {\n        continue;\n      }\n\n      PsiSubstitutor substitutor;\n      if ((substitutor = substitutors.get(hisClass)) == null) {\n        substitutor = aClass.isInheritor(hisClass, true) ?\n                      TypeConversionUtil.getSuperClassSubstitutor(hisClass, aClass, PsiSubstitutor.EMPTY) : PsiSubstitutor.EMPTY;\n        substitutor = substitutor.putAll(contextSubstitutor);\n        substitutors.put(hisClass, substitutor);\n      }\n\n      String name = method.isConstructor() ? aClass.getName() : method.getName();\n      substitutor = GenerateMembersUtil.correctSubstitutor(method, substitutor);\n\n      MethodSignature signature = MethodSignatureUtil.createMethodSignature(name, method.getParameterList(), method.getTypeParameterList(),\n                                                                            substitutor);\n      if (MethodSignatureUtil.findMethodBySignature(aClass, signature, false) != null) continue;\n\n      if (method.hasModifierProperty(PsiModifier.FINAL)) {\n        finals.put(signature, method);\n        continue;\n      }\n\n      Map<MethodSignature, PsiMethod> map = hisClass.isInterface() || method.hasModifierProperty(PsiModifier.ABSTRACT)\n                                            ? abstracts\n                                            : concretes;\n      PsiMethod other = map.get(signature);\n      if (other == null || PsiUtil.getAccessLevel(method.getModifierList()) > PsiUtil.getAccessLevel(other.getModifierList())) {\n        map.put(signature, method);\n      }\n    }\n\n    Map<MethodSignature, CandidateInfo> result = new LinkedHashMap<MethodSignature,CandidateInfo>();\n    if (toImplement || aClass.isInterface()) {\n      for (Map.Entry<MethodSignature, PsiMethod> entry : abstracts.entrySet()) {\n        MethodSignature signature = entry.getKey();\n        PsiMethod abstractOne = entry.getValue();\n        PsiMethod concrete = concretes.get(signature);\n        if (concrete == null ||\n            PsiUtil.getAccessLevel(concrete.getModifierList()) < PsiUtil\n              .getAccessLevel(abstractOne.getModifierList()) ||\n                                                             (!abstractOne.getContainingClass().isInterface() &&\n                                                              abstractOne.getContainingClass()\n                                                                .isInheritor(concrete.getContainingClass(), true))) {\n          if (finals.get(signature) == null) {\n            PsiSubstitutor subst = GenerateMembersUtil.correctSubstitutor(abstractOne,\n                                                                                substitutors.get(abstractOne.getContainingClass()));\n            CandidateInfo info = new CandidateInfo(abstractOne, subst);\n            result.put(signature, info);\n          }\n        }\n      }\n\n      PsiMethod[] ejbMethods = EjbUtil.getEjbMethodsToImplement(aClass);\n      for (PsiMethod method : ejbMethods) {\n        MethodSignature signature = MethodSignatureUtil.createMethodSignature(method.getName(), method.getParameterList(),\n                                                                              method.getTypeParameterList(), PsiSubstitutor.EMPTY);\n        CandidateInfo info = new CandidateInfo(method, PsiSubstitutor.EMPTY);\n        result.put(signature, info);\n      }\n    } else {\n      for (Map.Entry<MethodSignature, PsiMethod> entry : concretes.entrySet()) {\n        MethodSignature signature = entry.getKey();\n        PsiMethod concrete = entry.getValue();\n        if (finals.get(signature) == null) {\n          PsiMethod abstractOne = abstracts.get(signature);\n          if (abstractOne == null || !abstractOne.getContainingClass().isInheritor(concrete.getContainingClass(), true) ||\n              concrete.getContainingClass().getQualifiedName().equals(\"java.lang.Object\")) {\n            PsiSubstitutor subst = GenerateMembersUtil.correctSubstitutor(concrete, substitutors.get(concrete.getContainingClass()));\n            CandidateInfo info = new CandidateInfo(concrete, subst);\n            result.put(signature, info);\n          }\n        }\n      }\n    }\n\n    return result;\n  }","id":23441,"modified_method":"@NotNull\n  private static Map<MethodSignature, CandidateInfo> getMapToOverrideImplement(PsiClass aClass,\n                                                                               boolean toImplement) {\n    final PsiSubstitutor contextSubstitutor = getContextSubstitutor(aClass);\n    Map<MethodSignature, PsiMethod> abstracts = new LinkedHashMap<MethodSignature,PsiMethod>();\n    Map<MethodSignature, PsiMethod> finals = new HashMap<MethodSignature,PsiMethod>();\n    Map<MethodSignature, PsiMethod> concretes = new LinkedHashMap<MethodSignature,PsiMethod>();\n    Map<PsiClass, PsiSubstitutor> substitutors = new HashMap<PsiClass,PsiSubstitutor>();\n\n    PsiMethod[] allMethods = aClass.getAllMethods();\n    PsiResolveHelper resolveHelper = aClass.getManager().getResolveHelper();\n    for (PsiMethod method : allMethods) {\n      if (method.hasModifierProperty(PsiModifier.STATIC) || !resolveHelper.isAccessible(method, aClass, aClass)) continue;\n      PsiClass hisClass = method.getContainingClass();\n      //Filter non-immediate super constructors\n      if (method.isConstructor() && (!aClass.isInheritor(hisClass, false) || aClass instanceof PsiAnonymousClass || aClass.isEnum())) {\n        continue;\n      }\n\n      PsiSubstitutor substitutor;\n      if ((substitutor = substitutors.get(hisClass)) == null) {\n        substitutor = aClass.isInheritor(hisClass, true) ?\n                      TypeConversionUtil.getSuperClassSubstitutor(hisClass, aClass, PsiSubstitutor.EMPTY) : PsiSubstitutor.EMPTY;\n        substitutor = substitutor.putAll(contextSubstitutor);\n        substitutors.put(hisClass, substitutor);\n      }\n\n      String name = method.isConstructor() ? aClass.getName() : method.getName();\n      substitutor = GenerateMembersUtil.correctSubstitutor(method, substitutor);\n\n      MethodSignature signature = MethodSignatureUtil.createMethodSignature(name, method.getParameterList(), method.getTypeParameterList(),\n                                                                            substitutor);\n      if (MethodSignatureUtil.findMethodBySignature(aClass, signature, false) != null) continue;\n\n      if (method.hasModifierProperty(PsiModifier.FINAL)) {\n        finals.put(signature, method);\n        continue;\n      }\n\n      Map<MethodSignature, PsiMethod> map = hisClass.isInterface() || method.hasModifierProperty(PsiModifier.ABSTRACT)\n                                            ? abstracts\n                                            : concretes;\n      PsiMethod other = map.get(signature);\n      if (other == null || PsiUtil.getAccessLevel(method.getModifierList()) > PsiUtil.getAccessLevel(other.getModifierList())) {\n        map.put(signature, method);\n      }\n    }\n\n    Map<MethodSignature, CandidateInfo> result = new LinkedHashMap<MethodSignature,CandidateInfo>();\n    if (toImplement || aClass.isInterface()) {\n      for (Map.Entry<MethodSignature, PsiMethod> entry : abstracts.entrySet()) {\n        MethodSignature signature = entry.getKey();\n        PsiMethod abstractOne = entry.getValue();\n        PsiMethod concrete = concretes.get(signature);\n        if (concrete == null ||\n            PsiUtil.getAccessLevel(concrete.getModifierList()) < PsiUtil\n              .getAccessLevel(abstractOne.getModifierList()) ||\n                                                             (!abstractOne.getContainingClass().isInterface() &&\n                                                              abstractOne.getContainingClass()\n                                                                .isInheritor(concrete.getContainingClass(), true))) {\n          if (finals.get(signature) == null) {\n            PsiSubstitutor subst = GenerateMembersUtil.correctSubstitutor(abstractOne,\n                                                                          substitutors.get(abstractOne.getContainingClass()));\n            CandidateInfo info = new CandidateInfo(abstractOne, subst);\n            result.put(signature, info);\n          }\n        }\n      }\n\n      for (final MethodImplementor implementor : getImplementors()) {\n        for (final PsiMethod method : implementor.getMethodsToImplement(aClass)) {\n          MethodSignature signature = MethodSignatureUtil.createMethodSignature(method.getName(), method.getParameterList(),\n                                                                                method.getTypeParameterList(), PsiSubstitutor.EMPTY);\n          CandidateInfo info = new CandidateInfo(method, PsiSubstitutor.EMPTY);\n          result.put(signature, info);\n        }\n      }\n    } else {\n      for (Map.Entry<MethodSignature, PsiMethod> entry : concretes.entrySet()) {\n        MethodSignature signature = entry.getKey();\n        PsiMethod concrete = entry.getValue();\n        if (finals.get(signature) == null) {\n          PsiMethod abstractOne = abstracts.get(signature);\n          if (abstractOne == null || !abstractOne.getContainingClass().isInheritor(concrete.getContainingClass(), true) ||\n              concrete.getContainingClass().getQualifiedName().equals(\"java.lang.Object\")) {\n            PsiSubstitutor subst = GenerateMembersUtil.correctSubstitutor(concrete, substitutors.get(concrete.getContainingClass()));\n            CandidateInfo info = new CandidateInfo(concrete, subst);\n            result.put(signature, info);\n          }\n        }\n      }\n    }\n\n    return result;\n  }","commit_id":"bafeb94118433f11f1d2a2a853cb431da54b8de0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static PsiMethod[] overrideOrImplementMethod(PsiClass aClass,\n                                                       PsiMethod method,\n                                                       PsiSubstitutor substitutor,\n                                                       boolean toCopyJavaDoc,\n                                                       boolean insertAtOverride) throws IncorrectOperationException {\n    if (!method.isValid() || !substitutor.isValid()) return PsiMethod.EMPTY_ARRAY;\n\n    PsiMethod[] results = EjbUtil.suggestImplementations(method);\n\n    if (results.length == 0){\n      PsiMethod method1 = substitutor != PsiSubstitutor.EMPTY ?\n                          GenerateMembersUtil.substituteGenericMethod(method, substitutor) : method;\n\n      PsiElementFactory factory = method.getManager().getElementFactory();\n      PsiMethod result = (PsiMethod)factory.createClass(\"Dummy\").add(method1);\n\n      result.getModifierList().setModifierProperty(PsiModifier.ABSTRACT, aClass.isInterface());\n      result.getModifierList().setModifierProperty(PsiModifier.NATIVE, false);\n\n      if (!toCopyJavaDoc){\n        PsiDocComment comment = result.getDocComment();\n        if (comment != null){\n          comment.delete();\n        }\n      }\n\n      if (insertAtOverride && !method.isConstructor()) {\n        PsiModifierList modifierList = result.getModifierList();\n        if (modifierList.findAnnotation(\"java.lang.Override\") == null) {\n          PsiAnnotation annotation = factory.createAnnotationFromText(\"@java.lang.Override\", null);\n          modifierList.addAfter(annotation, null);\n        }\n      }\n\n      final PsiCodeBlock body = method.getManager().getElementFactory().createCodeBlockFromText(\"{}\", null);\n      if (result.getBody() != null){\n        result.getBody().replace(body);\n      }\n      else{\n        result.add(body);\n      }\n\n      results = new PsiMethod[]{result};\n    }\n\n    List<PsiMethod> list = new ArrayList<PsiMethod>();\n\n    for (PsiMethod result : results) {\n      EjbUtil.tuneMethodForEjb(EjbRolesUtil.getEjbRolesUtil().getEjbRole(aClass), method, result);\n\n      setupMethodBody(result, method, aClass);\n\n      // probably, it's better to reformat the whole method - it can go from other style sources\n      CodeStyleManager codeStyleManager = method.getManager().getCodeStyleManager();\n      CodeStyleSettings settings = CodeStyleSettingsManager.getSettings(codeStyleManager.getProject());\n      boolean keepBreaks = settings.KEEP_LINE_BREAKS;\n      settings.KEEP_LINE_BREAKS = false;\n      result = (PsiMethod)codeStyleManager.shortenClassReferences(result);\n      result = (PsiMethod)codeStyleManager.reformat(result);\n      settings.KEEP_LINE_BREAKS = keepBreaks;\n\n      if (aClass.findMethodBySignature(result, false) == null) {\n        list.add(result);\n      }\n    }\n\n    return list.toArray(new PsiMethod[list.size()]);\n  }","id":23442,"modified_method":"@NotNull\n  private static PsiMethod[] overrideOrImplementMethod(PsiClass aClass,\n                                                       PsiMethod method,\n                                                       PsiSubstitutor substitutor,\n                                                       boolean toCopyJavaDoc,\n                                                       boolean insertAtOverride) throws IncorrectOperationException {\n    if (!method.isValid() || !substitutor.isValid()) return PsiMethod.EMPTY_ARRAY;\n\n    List<PsiMethod> results = new ArrayList<PsiMethod>();\n    for (final MethodImplementor implementor : getImplementors()) {\n      results.addAll(Arrays.asList(implementor.createImplementationPrototypes(aClass, method)));\n    }\n    if (results.isEmpty()) {\n      PsiMethod method1 = substitutor != PsiSubstitutor.EMPTY ?\n                          GenerateMembersUtil.substituteGenericMethod(method, substitutor) : method;\n\n      PsiElementFactory factory = method.getManager().getElementFactory();\n      PsiMethod result = (PsiMethod)factory.createClass(\"Dummy\").add(method1);\n      results.add(result);\n    }\n\n    for (Iterator<PsiMethod> iterator = results.iterator(); iterator.hasNext();) {\n      PsiMethod result = iterator.next();\n      result.getModifierList().setModifierProperty(PsiModifier.ABSTRACT, aClass.isInterface());\n      result.getModifierList().setModifierProperty(PsiModifier.NATIVE, false);\n\n      if (!toCopyJavaDoc){\n        PsiDocComment comment = result.getDocComment();\n        if (comment != null){\n          comment.delete();\n        }\n      }\n\n      if (insertAtOverride && !method.isConstructor()) {\n        PsiModifierList modifierList = result.getModifierList();\n        if (modifierList.findAnnotation(\"java.lang.Override\") == null) {\n          PsiAnnotation annotation = method.getManager().getElementFactory().createAnnotationFromText(\"@java.lang.Override\", null);\n          modifierList.addAfter(annotation, null);\n        }\n      }\n\n      final PsiCodeBlock body = method.getManager().getElementFactory().createCodeBlockFromText(\"{}\", null);\n      if (result.getBody() != null){\n        result.getBody().replace(body);\n      }\n      else{\n        result.add(body);\n      }\n\n      setupMethodBody(result, method, aClass);\n\n      // probably, it's better to reformat the whole method - it can go from other style sources\n      CodeStyleManager codeStyleManager = method.getManager().getCodeStyleManager();\n      CodeStyleSettings settings = CodeStyleSettingsManager.getSettings(codeStyleManager.getProject());\n      boolean keepBreaks = settings.KEEP_LINE_BREAKS;\n      settings.KEEP_LINE_BREAKS = false;\n      result = (PsiMethod)codeStyleManager.shortenClassReferences(result);\n      result = (PsiMethod)codeStyleManager.reformat(result);\n      settings.KEEP_LINE_BREAKS = keepBreaks;\n\n      if (aClass.findMethodBySignature(result, false) != null) {\n        iterator.remove();\n      }\n    }\n\n    return results.toArray(new PsiMethod[results.size()]);\n  }","commit_id":"bafeb94118433f11f1d2a2a853cb431da54b8de0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static FileTemplate setupMethodBody(final List<HierarchicalMethodSignature> superSignatures,\n                                      final PsiMethod templateMethod,\n                                      final PsiClass aClass, final boolean useDefaultTemplate) throws IncorrectOperationException {\n    FileTemplateManager templateManager = FileTemplateManager.getInstance();\n    FileTemplate template;\n    if (superSignatures.size() == 0) {\n      String name = FileTemplateManager.TEMPLATE_FROM_USAGE_METHOD_BODY;\n      template = useDefaultTemplate ? templateManager.getDefaultTemplate(name) : templateManager.getCodeTemplate(name);\n      CreateFromUsageUtils.setupMethodBody(templateMethod, aClass, template);\n    }\n    else {\n      PsiMethod superMethod = superSignatures.get(0).getMethod();\n      String name = superMethod.hasModifierProperty(PsiModifier.ABSTRACT) ?\n                    FileTemplateManager.TEMPLATE_IMPLEMENTED_METHOD_BODY : FileTemplateManager.TEMPLATE_OVERRIDDEN_METHOD_BODY;\n      template = useDefaultTemplate ? templateManager.getDefaultTemplate(name) : templateManager.getCodeTemplate(name);\n      OverrideImplementUtil.setupMethodBody(templateMethod, superMethod, aClass,template);\n    }\n    return template;\n  }","id":23443,"modified_method":"private static FileTemplate setupMethodBody(final List<HierarchicalMethodSignature> superSignatures,\n                                              final PsiMethod templateMethod,\n                                              final PsiClass aClass,\n                                              final boolean useDefaultTemplate) throws IncorrectOperationException {\n    FileTemplate template = getMethodFileTemplate(superSignatures, useDefaultTemplate);\n    if (NEW_METHOD_BODY_TEMPLATE_NAME.equals(template.getName())) {\n      CreateFromUsageUtils.setupMethodBody(templateMethod, aClass, template);\n    }\n    else {\n      PsiMethod superMethod = superSignatures.get(0).getMethod();\n      OverrideImplementUtil.setupMethodBody(templateMethod, superMethod, aClass,template);\n    }\n    return template;\n  }","commit_id":"730f25aeec6544a74947498406fec019703a10ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static void checkMethodBody(final PsiMethod method,\n                                      final InspectionManager manager,\n                                      final Collection<ProblemDescriptor> problemDescriptors) {\n    PsiType returnType = method.getReturnType();\n    if (method.isConstructor() || returnType == null) return;\n    PsiCodeBlock body = method.getBody();\n    if (body == null) return;\n    PsiClass aClass = method.getContainingClass();\n    if (aClass == null) return;\n    List<HierarchicalMethodSignature> superSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();\n    try {\n      PsiMethod templateMethod = method.getManager().getElementFactory().createMethod(\"x\", returnType);\n      setupMethodBody(superSignatures, templateMethod, aClass, true);\n      if (!PsiEquivalenceUtil.areElementsEquivalent(templateMethod.getBody(), body)) return;\n      Pair<? extends PsiElement, ? extends PsiElement> range = DefaultFileTemplateUsageInspection.getInteriorRange(body);\n      final String description = InspectionsBundle.message(\"default.file.template.description\");\n      ProblemDescriptor problem = manager.createProblemDescriptor(range.first, range.second,\n                                                                  description, ProblemHighlightType.GENERIC_ERROR_OR_WARNING, createMethodBodyQuickFix(method));\n      problemDescriptors.add(problem);\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","id":23444,"modified_method":"static void checkMethodBody(final PsiMethod method,\n                              final InspectionManager manager,\n                              final Collection<ProblemDescriptor> problemDescriptors) {\n    PsiType returnType = method.getReturnType();\n    if (method.isConstructor() || returnType == null) return;\n    PsiCodeBlock body = method.getBody();\n    if (body == null) return;\n    PsiClass aClass = method.getContainingClass();\n    if (aClass == null) return;\n    List<HierarchicalMethodSignature> superSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();\n    final PsiMethod superMethod = superSignatures.size() ==0 ? null : superSignatures.get(0).getMethod();\n    final PsiMethod templateMethod = getTemplateMethod(returnType, superSignatures, aClass);\n    if (PsiEquivalenceUtil.areElementsEquivalent(body, templateMethod.getBody(), new Comparator<PsiElement>(){\n      public int compare(final PsiElement element1, final PsiElement element2) {\n        // templates may be different on super method name                              \n        if (element1 == superMethod && (element2 == templateMethod || element2 == null)) return 0;\n        return 1;\n      }\n    })) {\n      Pair<? extends PsiElement, ? extends PsiElement> range = DefaultFileTemplateUsageInspection.getInteriorRange(body);\n      final String description = InspectionsBundle.message(\"default.file.template.description\");\n      ProblemDescriptor problem = manager.createProblemDescriptor(range.first, range.second, description,\n                                                                  ProblemHighlightType.GENERIC_ERROR_OR_WARNING,\n                                                                  createMethodBodyQuickFix(method));\n      problemDescriptors.add(problem);\n    }\n  }","commit_id":"730f25aeec6544a74947498406fec019703a10ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n       if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n           \n\t\tif(contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\t\t\n        Sequence result;\n        Expression arg = getArgument(0);\t\t\n\t\t// case 1: if the argument expression returns a node set,\n\t\t// subtract the set from the context node set and return\n\t\t// the remaining set\n\t\tif (Type.subTypeOf(arg.returnsType(), Type.NODE) &&\n\t\t\t!Dependency.dependsOn(arg, Dependency.CONTEXT_ITEM)) {\n\t\t\tif (contextSequence == null || contextSequence.isEmpty()) {\n\t\t\t\t// TODO: special treatment if the context sequence is empty:\n\t\t\t\t// within a predicate, we just return the empty sequence\n\t\t\t\t// otherwise evaluate the argument and return a boolean result\t\t\t    \n\t\t\t\tif (inPredicate && !inWhereClause)\n                    result = Sequence.EMPTY_SEQUENCE;\n\t\t\t\telse\n                    result = evalBoolean(contextSequence, contextItem, arg);\n\t\t\t} else {            \n    \t\t\tresult = new ExtArrayNodeSet();\n    \t\t\t\n    \t\t\tif(!contextSequence.isEmpty())\n    \t\t\t\tresult.addAll(contextSequence);\n\n    \t\t\tif (inPredicate) {\n    \t\t\t\tfor (SequenceIterator i = result.iterate(); i.hasNext();) {\n    \t\t\t\t\tNodeProxy item = (NodeProxy) i.nextItem();\n    \t\t\t\t\tif (contextId != Expression.NO_CONTEXT_ID)\n                            item.addContextNode(contextId, item);\n    \t\t\t\t\titem.addContextNode(getExpressionId(), item);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\t// evaluate argument expression\n    \t\t\tSequence argSeq = arg.eval(result);\n    \t\t\tNodeSet argSet = argSeq.toNodeSet().getContextNodes(getExpressionId());\n    \t\t\tresult = ((NodeSet)result).except(argSet);\n            }\n\t\t\t\n\t\t// case 2: simply invert the boolean value\n\t\t} else {\n\t\t\treturn evalBoolean(contextSequence, contextItem, arg);\n\t\t}\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;           \n\t}","id":23445,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n       if (context.getProfiler().isEnabled()) {\n            context.getProfiler().start(this);       \n            context.getProfiler().message(this, Profiler.DEPENDENCIES, \"DEPENDENCIES\", Dependency.getDependenciesName(this.getDependencies()));\n            if (contextSequence != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT SEQUENCE\", contextSequence);\n            if (contextItem != null)\n                context.getProfiler().message(this, Profiler.START_SEQUENCES, \"CONTEXT ITEM\", contextItem.toSequence());\n        }\n           \n\t\tif(contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\t\t\n        Sequence result;\n        Expression arg = getArgument(0);\t\t\n\t\t// case 1: if the argument expression returns a node set,\n\t\t// subtract the set from the context node set and return\n\t\t// the remaining set\n\t\tif (Type.subTypeOf(arg.returnsType(), Type.NODE) &&\n\t\t\t!Dependency.dependsOn(arg, Dependency.CONTEXT_ITEM)) {\n\t\t\tif (contextSequence == null || contextSequence.isEmpty()) {\n\t\t\t\t// TODO: special treatment if the context sequence is empty:\n\t\t\t\t// within a predicate, we just return the empty sequence\n\t\t\t\t// otherwise evaluate the argument and return a boolean result\t\t\t    \n\t\t\t\tif (inPredicate && !inWhereClause)\n                    result = Sequence.EMPTY_SEQUENCE;\n\t\t\t\telse\n                    result = evalBoolean(contextSequence, contextItem, arg);\n\t\t\t} else {            \n    \t\t\tresult = new ExtArrayNodeSet();\n    \t\t\t\n    \t\t\tif(!contextSequence.isEmpty())\n    \t\t\t\tresult.addAll(contextSequence);\n\n    \t\t\tif (inPredicate) {\n    \t\t\t\tfor (SequenceIterator i = result.iterate(); i.hasNext();) {\n    \t\t\t\t\tNodeProxy item = (NodeProxy) i.nextItem();\n    \t\t\t\t\titem.addContextNode(getExpressionId(), item);\n    \t\t\t\t\tif (contextId != Expression.NO_CONTEXT_ID)\n                            item.addContextNode(contextId, item);\n    \t\t\t\t\telse\n    \t\t\t\t\t\titem.addContextNode(getExpressionId(), item);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\t// evaluate argument expression\n    \t\t\tSequence argSeq = arg.eval(result);\n    \t\t\tNodeSet argSet;\n    \t\t\tif (contextId != Expression.NO_CONTEXT_ID)\n\t    \t\t\targSet = argSeq.toNodeSet().getContextNodes(contextId);\n\t    \t\telse\n\t\t    \t\targSet = argSeq.toNodeSet().getContextNodes(getExpressionId());\n    \t\t\tresult = ((NodeSet)result).except(argSet);\n            }\n\t\t\t\n\t\t// case 2: simply invert the boolean value\n\t\t} else {\n\t\t\treturn evalBoolean(contextSequence, contextItem, arg);\n\t\t}\n        \n        if (context.getProfiler().isEnabled()) \n            context.getProfiler().end(this, \"\", result); \n        \n        return result;           \n\t}","commit_id":"a3e28543f18738b7d22bbc0089c05985f86f00f5","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * @param context\n\t * @param contextSet\n\t * @return\n\t */\n\tprotected Sequence getSelf(XQueryContext context, NodeSet contextSet) {\n\t\tif(test.isWildcardTest()) {\n\t\t\tif(test.getType() == Type.NODE) {\n\t\t\t\tif (inPredicate) {\n\t\t\t\t\tif (contextSet instanceof VirtualNodeSet) {\n\t\t\t\t\t\t((VirtualNodeSet) contextSet).setInPredicate(true);\n\t\t\t\t\t\t((VirtualNodeSet) contextSet).setSelfIsContext();\n                    } else if(Type.subTypeOf(contextSet.getItemType(), Type.NODE)) {\n\t\t\t\t\t\tNodeProxy p;\n\t\t\t\t\t\tfor (Iterator i = contextSet.iterator(); i.hasNext();) {\n\t\t\t\t\t\t\tp = (NodeProxy) i.next();\n\t\t\t\t\t\t\tp.addContextNode(p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn contextSet;\n\t\t\t} else {\n//                NodeSet result = new ExtArrayNodeSet();\n//                NodeProxy p;\n//                for (Iterator i = contextSet.iterator(); i.hasNext(); ) {\n//                    p = (NodeProxy) i.next();\n//                    if (test.matches(p)) {\n//                        result.add(p);\n//                        p.addContextNode(p);\n//                    }\n//                }\n//                return result;\n\t\t\t\tVirtualNodeSet vset = new VirtualNodeSet(axis, test, contextSet);\n\t\t\t\tvset.setInPredicate(inPredicate);\n\t\t\t\treturn vset;\n\t\t\t}\n\t\t} else {\n\t\t\tDocumentSet docs = getDocumentSet(contextSet);\n\t\t    NodeSelector selector = new SelfSelector(contextSet, inPredicate);\n\t\t    NodeSet result = context.getBroker().getElementIndex().findElementsByTagName(\n\t\t    \t\tElementValue.ELEMENT, docs, test.getName(), selector\n\t\t    );\n\t\t\treturn result;\n\t\t}\n\t}","id":23446,"modified_method":"/**\n\t * @param context\n\t * @param contextSet\n\t * @return\n\t */\n\tprotected Sequence getSelf(XQueryContext context, NodeSet contextSet) {\n\t\tif(test.isWildcardTest()) {\n\t\t\tif(test.getType() == Type.NODE) {\n\t\t\t\tif (inPredicate) {\n\t\t\t\t\tif (contextSet instanceof VirtualNodeSet) {\n\t\t\t\t\t\t((VirtualNodeSet) contextSet).setInPredicate(true);\n\t\t\t\t\t\t((VirtualNodeSet) contextSet).setSelfIsContext();\n                    } else if(Type.subTypeOf(contextSet.getItemType(), Type.NODE)) {\n\t\t\t\t\t\tNodeProxy p;\n\t\t\t\t\t\tfor (Iterator i = contextSet.iterator(); i.hasNext();) {\n\t\t\t\t\t\t\tp = (NodeProxy) i.next();\n\t\t\t\t\t\t\tif (test.matches(p))\n\t\t\t\t\t\t\t\tp.addContextNode(p);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn contextSet;\n\t\t\t} else {\n//                NodeSet result = new ExtArrayNodeSet();\n//                NodeProxy p;\n//                for (Iterator i = contextSet.iterator(); i.hasNext(); ) {\n//                    p = (NodeProxy) i.next();\n//                    if (test.matches(p)) {\n//                        result.add(p);\n//                        p.addContextNode(p);\n//                    }\n//                }\n//                return result;\n\t\t\t\tVirtualNodeSet vset = new VirtualNodeSet(axis, test, contextSet);\n\t\t\t\tvset.setInPredicate(inPredicate);\n\t\t\t\treturn vset;\n\t\t\t}\n\t\t} else {\n\t\t\tDocumentSet docs = getDocumentSet(contextSet);\n\t\t    NodeSelector selector = new SelfSelector(contextSet, inPredicate);\n\t\t    NodeSet result = context.getBroker().getElementIndex().findElementsByTagName(\n\t\t    \t\tElementValue.ELEMENT, docs, test.getName(), selector\n\t\t    );\n\t\t\treturn result;\n\t\t}\n\t}","commit_id":"1653fd347b7c5731bc9980e7f1df38cb0f8b0f07","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * The method <code>getSelf<\/code>\n     *\n     * @param context a <code>XQueryContext<\/code> value\n     * @param contextSet a <code>NodeSet<\/code> value\n     * @return a <code>Sequence<\/code> value\n     */\n    protected Sequence getSelf(XQueryContext context, NodeSet contextSet) {\n        if (test.getType() == Type.PROCESSING_INSTRUCTION) {\n            VirtualNodeSet vset = new VirtualNodeSet(axis, test, contextId,\n                                                     contextSet);\n            vset.setInPredicate(Expression.NO_CONTEXT_ID != contextId);\n            return vset;\n        }\n\n        if (test.isWildcardTest()) {\n            if (nodeTestType == null) {\n                nodeTestType = new Integer(test.getType());\n            }\n            if (Type.subTypeOf(nodeTestType.intValue(), Type.NODE)) {\n                if (Expression.NO_CONTEXT_ID != contextId) {\n                    if (contextSet instanceof VirtualNodeSet) {\n                        ((VirtualNodeSet) contextSet).setInPredicate(true);\n                        ((VirtualNodeSet) contextSet).setSelfIsContext();\n                        ((VirtualNodeSet) contextSet).setContextId(contextId);\n                    } else if (Type.subTypeOf(contextSet.getItemType(),\n                                              Type.NODE)) {\n                        NodeProxy p;\n                        for (Iterator i = contextSet.iterator(); i.hasNext();) {\n                            p = (NodeProxy) i.next();\n                            if (test.matches(p))\n                                p.addContextNode(contextId, p);\n                        }\n                    }\n                }\n                return contextSet;\n\n            } else {\n                VirtualNodeSet vset = new VirtualNodeSet(axis, test, contextId,\n                                                         contextSet);\n                vset.setInPredicate(Expression.NO_CONTEXT_ID != contextId);\n                return vset;\n            }\n        } else {\n            DocumentSet docs = getDocumentSet(contextSet);\n            NodeSelector selector = new SelfSelector(contextSet, contextId);\n            ElementIndex index = context.getBroker().getElementIndex();\n            if (context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                              \"OPTIMIZATION\",\n                                              \"Using structural index '\" + index.toString() + \"'\");\n            return index.findElementsByTagName(ElementValue.ELEMENT, docs, test\n                                               .getName(), selector);\n        }\n    }","id":23447,"modified_method":"/**\n     * The method <code>getSelf<\/code>\n     *\n     * @param context a <code>XQueryContext<\/code> value\n     * @param contextSet a <code>NodeSet<\/code> value\n     * @return a <code>Sequence<\/code> value\n     */\n    protected Sequence getSelf(XQueryContext context, NodeSet contextSet) {\n        if (test.getType() == Type.PROCESSING_INSTRUCTION) {\n            VirtualNodeSet vset = new VirtualNodeSet(axis, test, contextId,\n                                                     contextSet);\n            vset.setInPredicate(Expression.NO_CONTEXT_ID != contextId);\n            return vset;\n        }\n\n        if (test.isWildcardTest()) {\n            if (nodeTestType == null) {\n                nodeTestType = new Integer(test.getType());\n            }\n            if (Type.subTypeOf(nodeTestType.intValue(), Type.NODE)) {\n                NodeSet result = null;\n                if (Expression.NO_CONTEXT_ID != contextId && contextSet instanceof VirtualNodeSet) {\n                    ((VirtualNodeSet) contextSet).setInPredicate(true);\n                    ((VirtualNodeSet) contextSet).setSelfIsContext();\n                    ((VirtualNodeSet) contextSet).setContextId(contextId);\n                } else if (Type.subTypeOf(contextSet.getItemType(), Type.NODE)) {\n                    NodeProxy p;\n                    if (test.getType() != Type.NODE)\n                        result = new ExtArrayNodeSet();\n                    for (Iterator i = contextSet.iterator(); i.hasNext();) {\n                        p = (NodeProxy) i.next();\n                        if (test.matches(p)) {\n                            p.addContextNode(contextId, p);\n                            if (result != null)\n                                result.add(p);\n                        }\n                    }\n                }\n                return result == null ? contextSet : result;\n            } else {\n                VirtualNodeSet vset = new VirtualNodeSet(axis, test, contextId,\n                                                         contextSet);\n                vset.setInPredicate(Expression.NO_CONTEXT_ID != contextId);\n                return vset;\n            }\n        } else {\n            DocumentSet docs = getDocumentSet(contextSet);\n            NodeSelector selector = new SelfSelector(contextSet, contextId);\n            ElementIndex index = context.getBroker().getElementIndex();\n            if (context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS,\n                                              \"OPTIMIZATION\",\n                                              \"Using structural index '\" + index.toString() + \"'\");\n            return index.findElementsByTagName(ElementValue.ELEMENT, docs, test\n                                               .getName(), selector);\n        }\n    }","commit_id":"0a1771822b5e3429e865eb7c3e26971933eda0f6","url":"https://github.com/eXist-db/exist"},{"original_method":"public static boolean call_isDescendant_1213877355812(SNode thisNode, SNode classToCompare) {\n    boolean namesAreSame;\n    if (INamedConcept_Behavior.call_getFqName_1213877404258(thisNode) == null) {\n      if (INamedConcept_Behavior.call_getFqName_1213877404258(classToCompare) != null) {\n        namesAreSame = false;\n      } else\n      {\n        namesAreSame = true;\n      }\n    } else\n    {\n      namesAreSame = INamedConcept_Behavior.call_getFqName_1213877404258(thisNode).equals(INamedConcept_Behavior.call_getFqName_1213877404258(classToCompare));\n    }\n    if (namesAreSame) {\n      return true;\n    } else\n    {\n      if (SLinkOperations.getTarget(thisNode, \"superclass\", true) == null) {\n        return false;\n      } else\n      {\n        return ClassConcept_Behavior.call_isDescendant_1213877355812(SLinkOperations.getTarget(SLinkOperations.getTarget(thisNode, \"superclass\", true), \"classifier\", false), classToCompare);\n      }\n    }\n  }","id":23448,"modified_method":"public static boolean call_isDescendant_1213877355812(SNode thisNode, SNode classToCompare) {\n    if (EqualUtil.equals(INamedConcept_Behavior.call_getFqName_1213877404258(thisNode), INamedConcept_Behavior.call_getFqName_1213877404258(classToCompare))) {\n      return true;\n    }\n    if (SLinkOperations.getTarget(thisNode, \"superclass\", true) == null) {\n      return false;\n    }\n    return ClassConcept_Behavior.call_isDescendant_1213877355812(SLinkOperations.getTarget(SLinkOperations.getTarget(thisNode, \"superclass\", true), \"classifier\", false), classToCompare);\n  }","commit_id":"943efc457a91e75951364361e4c4cde9a5d45402","url":"https://github.com/JetBrains/MPS"},{"original_method":"public LanguageRepository() {\n    CommandProcessor.instance().addCommandListener(myCommandTranslator);\n    CommandProcessor.instance().addCommandListener(new CommandAdapter() {\n      public void beforeCommandFinished(CommandEvent event) {\n        removeUnusedLanguages();\n        SModelRepository.getInstance().removeUnusedDescriptors();\n      }\n    });\n  }","id":23449,"modified_method":"public LanguageRepository() {\n    CommandProcessor.instance().addCommandListener(myCommandTranslator);\n    myListenerToRemoveUnusedModules = new CommandAdapter() {\n      public void beforeCommandFinished(CommandEvent event) {\n        removeUnusedLanguages();\n        SModelRepository.getInstance().removeUnusedDescriptors();\n      }\n    };\n    CommandProcessor.instance().addCommandListener(myListenerToRemoveUnusedModules);\n  }","commit_id":"e23dd73f039235c05e9794304c44d21bcde81d52","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void initComponent() {\n    CommandProcessor.getInstance().addCommandListener(new CommandAdapter() {\n      @Override\n      public void commandFinished(CommandEvent event) {\n        for (IFile vf : myFilesToSynchronize) {\n          VFileSystem.refreshFileSynchronously(vf);\n        }\n        myFilesToSynchronize.clear();\n      }\n    });\n  }","id":23450,"modified_method":"public void initComponent() {\n    CommandProcessor.getInstance().addCommandListener(myListener);\n  }","commit_id":"d8756a38a84304b622354d9490d27cd65ae250bc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void disposeComponent() {\n\n  }","id":23451,"modified_method":"public void disposeComponent() {\n    CommandProcessor.getInstance().removeCommandListener(myListener);\n  }","commit_id":"d8756a38a84304b622354d9490d27cd65ae250bc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void commandFinished(CommandEvent event) {\n      if (myDeferredUpdate) {\n        myDeferredUpdate = false;\n        ModelAccess.instance().runReadInEDT(new Runnable() {\n          public void run() {\n            myTree.rebuildNow();\n          }\n        });\n      }\n    }","id":23452,"modified_method":"public void commandFinished(CommandEvent event) {\n      if (!myDeferredUpdate) return;\n      \n      myDeferredUpdate = false;\n      ModelAccess.instance().runReadInEDT(new Runnable() {\n        public void run() {\n          myTree.rebuildNow();\n        }\n      });\n    }","commit_id":"d8756a38a84304b622354d9490d27cd65ae250bc","url":"https://github.com/JetBrains/MPS"},{"original_method":"private UnregisteredNodes() {\n    CommandProcessor.instance().addCommandListener(new CommandAdapter() {\n      public void commandFinished(@NotNull CommandEvent event) {\n        myMap.clear();\n      }\n    });\n  }","id":23453,"modified_method":"private UnregisteredNodes() {\n    myListener = new CommandAdapter() {\n      public void commandFinished(@NotNull CommandEvent event) {\n        myMap.clear();\n      }\n    };\n    CommandProcessor.instance().addCommandListener(myListener);\n  }","commit_id":"e45320624faf10f6c96eece13c455320e28fb593","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public List<String> findUsernamesWhereUsernameStarts(Subject invokingUser, String startsWith) {\n\n        List<String> usernames = new ArrayList<String>();\n\n        LdapContext ctx = null;\n        try {\n            ctx = getContext(invokingUser);\n\n            LDAPSearchContext search = ensureContextFactory().getSearch();\n            String searchFilter = buildSearchFilter(search.getSearchAccount().getSearchFilterPrefix(), search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.NAME), startsWith + \"*\");\n\n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            searchControls.setReturningAttributes(new String[] { search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.NAME) });\n\n\n            NamingEnumeration<SearchResult> results = ctx.search(search.getBase(), searchFilter, searchControls);\n\n            SearchResult searchResult = null;\n            while(results.hasMoreElements()) {\n                searchResult = (SearchResult) results.nextElement();\n                String username = addDomainPostfix((String)searchResult.getAttributes().get(search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.NAME)).get());\n                \n                if(checkAccountRestrictionList(username)) {\n                    usernames.add(username);\n                }\n            }\n        } catch(NamingException ne) {\n            LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));\n        } finally {\n            if(ctx != null) {\n                LdapUtils.closeContext(ctx);\n            }\n        }\n\n        return usernames;\n    }","id":23454,"modified_method":"@Override\n    public List<String> findUsernamesWhereUsernameStarts(Subject invokingUser, String startsWith) {\n        \n        startsWith = ensureCase(startsWith);\n        \n        List<String> usernames = new ArrayList<String>();\n\n        LdapContext ctx = null;\n        try {\n            ctx = getContext(invokingUser);\n\n            LDAPSearchContext search = ensureContextFactory().getSearch();\n            String searchFilter = buildSearchFilter(search.getSearchAccount().getSearchFilterPrefix(), search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.NAME), startsWith + \"*\");\n\n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            searchControls.setReturningAttributes(new String[] { search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.NAME) });\n\n\n            NamingEnumeration<SearchResult> results = ctx.search(search.getBase(), searchFilter, searchControls);\n\n            SearchResult searchResult = null;\n            while(results.hasMoreElements()) {\n                searchResult = (SearchResult) results.nextElement();\n                String username = ensureCase(addDomainPostfix((String)searchResult.getAttributes().get(search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.NAME)).get()));\n                \n                if(checkAccountRestrictionList(username)) {\n                    usernames.add(username);\n                }\n            }\n        } catch(NamingException ne) {\n            LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));\n        } finally {\n            if(ctx != null) {\n                LdapUtils.closeContext(ctx);\n            }\n        }\n\n        return usernames;\n    }","commit_id":"fd8eec73024590c4a36463f631c9ccec61124799","url":"https://github.com/eXist-db/exist"},{"original_method":"private List<String> findGroupnamesForUserDistinguishedName(Subject invokingUser, String userDistinguishedName) {\n\n        List<String> groupnames = new ArrayList<String>();\n\n        LdapContext ctx = null;\n        try {\n            ctx = getContext(invokingUser);\n\n            LDAPSearchContext search = ensureContextFactory().getSearch();\n            String searchFilter = buildSearchFilter(search.getSearchGroup().getSearchFilterPrefix(), search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.MEMBER), userDistinguishedName);\n\n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            searchControls.setReturningAttributes(new String[] { search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.NAME) });\n\n\n            NamingEnumeration<SearchResult> results = ctx.search(search.getAbsoluteBase(), searchFilter, searchControls);\n\n            SearchResult searchResult = null;\n            while(results.hasMoreElements()) {\n                searchResult = (SearchResult) results.nextElement();\n                String groupname = addDomainPostfix((String)searchResult.getAttributes().get(search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.NAME)).get());\n                if(checkGroupRestrictionList(groupname)) {\n                    groupnames.add(groupname);\n                }\n            }\n        } catch(NamingException ne) {\n            LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));\n        } finally {\n            if(ctx != null) {\n                LdapUtils.closeContext(ctx);\n            }\n        }\n\n        return groupnames;\n    }","id":23455,"modified_method":"private List<String> findGroupnamesForUserDistinguishedName(Subject invokingUser, String userDistinguishedName) {\n\n        List<String> groupnames = new ArrayList<String>();\n\n        LdapContext ctx = null;\n        try {\n            ctx = getContext(invokingUser);\n\n            LDAPSearchContext search = ensureContextFactory().getSearch();\n            String searchFilter = buildSearchFilter(search.getSearchGroup().getSearchFilterPrefix(), search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.MEMBER), userDistinguishedName);\n\n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            searchControls.setReturningAttributes(new String[] { search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.NAME) });\n\n\n            NamingEnumeration<SearchResult> results = ctx.search(search.getAbsoluteBase(), searchFilter, searchControls);\n\n            SearchResult searchResult = null;\n            while(results.hasMoreElements()) {\n                searchResult = (SearchResult) results.nextElement();\n                String groupname = ensureCase(addDomainPostfix((String)searchResult.getAttributes().get(search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.NAME)).get()));\n                if(checkGroupRestrictionList(groupname)) {\n                    groupnames.add(groupname);\n                }\n            }\n        } catch(NamingException ne) {\n            LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));\n        } finally {\n            if(ctx != null) {\n                LdapUtils.closeContext(ctx);\n            }\n        }\n\n        return groupnames;\n    }","commit_id":"fd8eec73024590c4a36463f631c9ccec61124799","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public List<String> findUsernamesWhereNameStarts(Subject invokingUser, String startsWith) {\n        List<String> usernames = new ArrayList<String>();\n\n        LdapContext ctx = null;\n        try {\n            ctx = getContext(invokingUser);\n\n            LDAPSearchContext search = ensureContextFactory().getSearch();\n            String searchFilter = buildSearchFilter(search.getSearchAccount().getSearchFilterPrefix(), search.getSearchAccount().getMetadataSearchAttribute(AXSchemaType.FULLNAME), startsWith + \"*\");\n\n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            searchControls.setReturningAttributes(new String[] { search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.NAME) });\n\n            NamingEnumeration<SearchResult> results = ctx.search(search.getBase(), searchFilter, searchControls);\n\n            SearchResult searchResult = null;\n            while(results.hasMoreElements()) {\n                searchResult = (SearchResult) results.nextElement();\n                String username = addDomainPostfix((String)searchResult.getAttributes().get(search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.NAME)).get());\n                if(checkAccountRestrictionList(username)) {\n                    usernames.add(username);\n                }\n            }\n        } catch(NamingException ne) {\n            LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));\n        } finally {\n            if(ctx != null) {\n                LdapUtils.closeContext(ctx);\n            }\n        }\n\n        return usernames;\n    }","id":23456,"modified_method":"@Override\n    public List<String> findUsernamesWhereNameStarts(Subject invokingUser, String startsWith) {\n        \n        startsWith = ensureCase(startsWith);\n        \n        List<String> usernames = new ArrayList<String>();\n\n        LdapContext ctx = null;\n        try {\n            ctx = getContext(invokingUser);\n\n            LDAPSearchContext search = ensureContextFactory().getSearch();\n            String searchFilter = buildSearchFilter(search.getSearchAccount().getSearchFilterPrefix(), search.getSearchAccount().getMetadataSearchAttribute(AXSchemaType.FULLNAME), startsWith + \"*\");\n\n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            searchControls.setReturningAttributes(new String[] { search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.NAME) });\n\n            NamingEnumeration<SearchResult> results = ctx.search(search.getBase(), searchFilter, searchControls);\n\n            SearchResult searchResult = null;\n            while(results.hasMoreElements()) {\n                searchResult = (SearchResult) results.nextElement();\n                String username = ensureCase(addDomainPostfix((String)searchResult.getAttributes().get(search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.NAME)).get()));\n                if(checkAccountRestrictionList(username)) {\n                    usernames.add(username);\n                }\n            }\n        } catch(NamingException ne) {\n            LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));\n        } finally {\n            if(ctx != null) {\n                LdapUtils.closeContext(ctx);\n            }\n        }\n\n        return usernames;\n    }","commit_id":"fd8eec73024590c4a36463f631c9ccec61124799","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public List<String> findAllGroupNames(Subject invokingUser) {\n        List<String> groupnames = new ArrayList<String>();\n\n        LdapContext ctx = null;\n        try {\n            ctx = getContext(invokingUser);\n\n            LDAPSearchContext search = ensureContextFactory().getSearch();\n            String searchFilter = buildSearchFilter(search.getSearchGroup().getSearchFilterPrefix(), null, null);\n\n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            searchControls.setReturningAttributes(new String[] { search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.NAME) });\n\n            NamingEnumeration<SearchResult> results = ctx.search(search.getBase(), searchFilter, searchControls);\n\n            SearchResult searchResult = null;\n            while(results.hasMoreElements()) {\n                searchResult = (SearchResult) results.nextElement();\n                String groupname = addDomainPostfix((String)searchResult.getAttributes().get(search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.NAME)).get());\n                if(checkGroupRestrictionList(groupname)) {\n                    groupnames.add(groupname);\n                }\n            }\n        } catch(NamingException ne) {\n            LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));\n        } finally {\n            if(ctx != null) {\n                LdapUtils.closeContext(ctx);\n            }\n        }\n\n        return groupnames;\n    }","id":23457,"modified_method":"@Override\n    public List<String> findAllGroupNames(Subject invokingUser) {\n        List<String> groupnames = new ArrayList<String>();\n\n        LdapContext ctx = null;\n        try {\n            ctx = getContext(invokingUser);\n\n            LDAPSearchContext search = ensureContextFactory().getSearch();\n            String searchFilter = buildSearchFilter(search.getSearchGroup().getSearchFilterPrefix(), null, null);\n\n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            searchControls.setReturningAttributes(new String[] { search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.NAME) });\n\n            NamingEnumeration<SearchResult> results = ctx.search(search.getBase(), searchFilter, searchControls);\n\n            SearchResult searchResult = null;\n            while(results.hasMoreElements()) {\n                searchResult = (SearchResult) results.nextElement();\n                String groupname = ensureCase(addDomainPostfix((String)searchResult.getAttributes().get(search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.NAME)).get()));\n                if(checkGroupRestrictionList(groupname)) {\n                    groupnames.add(groupname);\n                }\n            }\n        } catch(NamingException ne) {\n            LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));\n        } finally {\n            if(ctx != null) {\n                LdapUtils.closeContext(ctx);\n            }\n        }\n\n        return groupnames;\n    }","commit_id":"fd8eec73024590c4a36463f631c9ccec61124799","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public List<String> findGroupnamesWhereGroupnameStarts(Subject invokingUser, String startsWith) {\n\n        List<String> groupnames = new ArrayList<String>();\n\n        LdapContext ctx = null;\n        try {\n            ctx = getContext(invokingUser);\n\n            LDAPSearchContext search = ensureContextFactory().getSearch();\n            String searchFilter = buildSearchFilter(search.getSearchGroup().getSearchFilterPrefix(), search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.NAME), startsWith + \"*\");\n\n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            searchControls.setReturningAttributes(new String[] { search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.NAME) });\n\n\n            NamingEnumeration<SearchResult> results = ctx.search(search.getBase(), searchFilter, searchControls);\n\n            SearchResult searchResult = null;\n            while(results.hasMoreElements()) {\n                searchResult = (SearchResult) results.nextElement();\n                String groupname = addDomainPostfix((String)searchResult.getAttributes().get(search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.NAME)).get());\n                if(checkGroupRestrictionList(groupname)) {\n                    groupnames.add(groupname);\n                }\n            }\n        } catch(NamingException ne) {\n            LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));\n        } finally {\n            if(ctx != null) {\n                LdapUtils.closeContext(ctx);\n            }\n        }\n\n        return groupnames;\n    }","id":23458,"modified_method":"@Override\n    public List<String> findGroupnamesWhereGroupnameStarts(Subject invokingUser, String startsWith) {\n\n        startsWith = ensureCase(startsWith);\n        \n        List<String> groupnames = new ArrayList<String>();\n\n        LdapContext ctx = null;\n        try {\n            ctx = getContext(invokingUser);\n\n            LDAPSearchContext search = ensureContextFactory().getSearch();\n            String searchFilter = buildSearchFilter(search.getSearchGroup().getSearchFilterPrefix(), search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.NAME), startsWith + \"*\");\n\n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            searchControls.setReturningAttributes(new String[] { search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.NAME) });\n\n\n            NamingEnumeration<SearchResult> results = ctx.search(search.getBase(), searchFilter, searchControls);\n\n            SearchResult searchResult = null;\n            while(results.hasMoreElements()) {\n                searchResult = (SearchResult) results.nextElement();\n                String groupname = ensureCase(addDomainPostfix((String)searchResult.getAttributes().get(search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.NAME)).get()));\n                if(checkGroupRestrictionList(groupname)) {\n                    groupnames.add(groupname);\n                }\n            }\n        } catch(NamingException ne) {\n            LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));\n        } finally {\n            if(ctx != null) {\n                LdapUtils.closeContext(ctx);\n            }\n        }\n\n        return groupnames;\n    }","commit_id":"fd8eec73024590c4a36463f631c9ccec61124799","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public List<String> findAllGroupMembers(Subject invokingUser, String groupName) {\n\n        List<String> groupMembers = new ArrayList<String>();\n        \n        if(!checkGroupRestrictionList(groupName)) {\n            return groupMembers;\n        }\n\n        LdapContext ctx = null;\n        try {\n            ctx = getContext(invokingUser);\n\n            //find the dn of the group\n            SearchResult searchResult = findGroupByGroupName(ctx, removeDomainPostfix(groupName));\n            LDAPSearchContext search = ensureContextFactory().getSearch();\n            String dnGroup = (String)searchResult.getAttributes().get(search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.DN)).get();\n\n            //find all accounts that are a member of the group\n            String searchFilter = buildSearchFilter(search.getSearchAccount().getSearchFilterPrefix(), search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.MEMBER_OF), dnGroup);\n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            searchControls.setReturningAttributes(new String[] { search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.NAME) });\n\n            NamingEnumeration<SearchResult> results = ctx.search(search.getBase(), searchFilter, searchControls);\n\n            while(results.hasMoreElements()) {\n                searchResult = (SearchResult) results.nextElement();\n                String member = addDomainPostfix((String)searchResult.getAttributes().get(search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.NAME)).get());\n                if(checkAccountRestrictionList(member)) {\n                    groupMembers.add(member);\n                }\n            }\n\n        } catch(NamingException ne) {\n            LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));\n        } finally {\n            if(ctx != null) {\n                LdapUtils.closeContext(ctx);\n            }\n        }\n\n        return groupMembers;\n    }","id":23459,"modified_method":"@Override\n    public List<String> findAllGroupMembers(Subject invokingUser, String groupName) {\n\n        groupName = ensureCase(groupName);\n        \n        List<String> groupMembers = new ArrayList<String>();\n        \n        if(!checkGroupRestrictionList(groupName)) {\n            return groupMembers;\n        }\n\n        LdapContext ctx = null;\n        try {\n            ctx = getContext(invokingUser);\n\n            //find the dn of the group\n            SearchResult searchResult = findGroupByGroupName(ctx, removeDomainPostfix(groupName));\n            LDAPSearchContext search = ensureContextFactory().getSearch();\n            String dnGroup = (String)searchResult.getAttributes().get(search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.DN)).get();\n\n            //find all accounts that are a member of the group\n            String searchFilter = buildSearchFilter(search.getSearchAccount().getSearchFilterPrefix(), search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.MEMBER_OF), dnGroup);\n            SearchControls searchControls = new SearchControls();\n            searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n            searchControls.setReturningAttributes(new String[] { search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.NAME) });\n\n            NamingEnumeration<SearchResult> results = ctx.search(search.getBase(), searchFilter, searchControls);\n\n            while(results.hasMoreElements()) {\n                searchResult = (SearchResult) results.nextElement();\n                String member = ensureCase(addDomainPostfix((String)searchResult.getAttributes().get(search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.NAME)).get()));\n                if(checkAccountRestrictionList(member)) {\n                    groupMembers.add(member);\n                }\n            }\n\n        } catch(NamingException ne) {\n            LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));\n        } finally {\n            if(ctx != null) {\n                LdapUtils.closeContext(ctx);\n            }\n        }\n\n        return groupMembers;\n    }","commit_id":"fd8eec73024590c4a36463f631c9ccec61124799","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public boolean updateGroup(Subject invokingUser, Group group) throws PermissionDeniedException, EXistException {\n        // TODO we dont support writting to LDAP\n        return false;\n    }","id":23460,"modified_method":"@Override\n    public boolean updateGroup(Subject invokingUser, Group group) throws PermissionDeniedException, EXistException {\n        return super.updateGroup(invokingUser, group);\n    }","commit_id":"fd8eec73024590c4a36463f631c9ccec61124799","url":"https://github.com/eXist-db/exist"},{"original_method":"private boolean checkPrincipalRestrictionList(String principalName, AbstractLDAPSearchPrincipal searchPrinciple) {\n        \n        if(principalName.indexOf('@') > -1) {\n            principalName = principalName.substring(0, principalName.indexOf('@'));\n        }\n        \n        List<String> blackList = null;\n        if(searchPrinciple.getBlackList() != null) {\n            blackList = searchPrinciple.getBlackList().getPrincipals();\n        }\n        \n        List<String> whiteList = null;\n        if(searchPrinciple.getWhiteList() != null) {\n            whiteList = searchPrinciple.getWhiteList().getPrincipals();\n        }\n        \n        if(blackList != null) {\n            for(String blackEntry : blackList) {\n                if(blackEntry.equals(principalName)) {\n                    return false;\n                }\n            }\n        }\n        \n        if(whiteList != null && whiteList.size() > 0) {\n            for(String whiteEntry : whiteList) {\n                if(whiteEntry.equals(principalName)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        \n        return true;\n    }","id":23461,"modified_method":"private boolean checkPrincipalRestrictionList(String principalName, AbstractLDAPSearchPrincipal searchPrinciple) {\n        \n        principalName = ensureCase(principalName);\n        \n        if(principalName.indexOf('@') > -1) {\n            principalName = principalName.substring(0, principalName.indexOf('@'));\n        }\n        \n        List<String> blackList = null;\n        if(searchPrinciple.getBlackList() != null) {\n            blackList = searchPrinciple.getBlackList().getPrincipals();\n        }\n        \n        List<String> whiteList = null;\n        if(searchPrinciple.getWhiteList() != null) {\n            whiteList = searchPrinciple.getWhiteList().getPrincipals();\n        }\n        \n        if(blackList != null) {\n            for(String blackEntry : blackList) {\n                if(ensureCase(blackEntry).equals(principalName)) {\n                    return false;\n                }\n            }\n        }\n        \n        if(whiteList != null && whiteList.size() > 0) {\n            for(String whiteEntry : whiteList) {\n                if(ensureCase(whiteEntry).equals(principalName)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        \n        return true;\n    }","commit_id":"fd8eec73024590c4a36463f631c9ccec61124799","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * The binary data is in form:\n     * byte[0] - revision level\n     * byte[1] - count of sub-authorities\n     * byte[2-7] - 48 bit authority (big-endian)\n     * and then count x 32 bit sub authorities (little-endian)\n     * \n     * The String value is: S-Revision-Authority-SubAuthority[n]...\n     * \n     * http://forums.oracle.com/forums/thread.jspa?threadID=1155740&tstart=0\n     */\n    public static String decodeSID(byte[] sid) {\n        \n        final StringBuilder strSid = new StringBuilder(\"S-\");\n\n        // get version\n        final int revision = sid[0];\n        strSid.append(Integer.toString(revision));\n        \n        //next byte is the count of sub-authorities\n        final int countSubAuths = sid[1] & 0xFF;\n        \n        //get the authority\n        long authority = 0;\n        //String rid = \"\";\n        for(int i = 2; i <= 7; i++) {\n           authority |= ((long)sid[i]) << (8 * (5 - (i - 2)));\n        }\n        strSid.append(\"-\");\n        strSid.append(Long.toHexString(authority));\n        \n        //iterate all the sub-auths\n        int offset = 8;\n        int size = 4; //4 bytes for each sub auth\n        for(int j = 0; j < countSubAuths; j++) {\n            long subAuthority = 0;\n            for(int k = 0; k < size; k++) {\n                subAuthority |= (long)(sid[offset + k] & 0xFF) << (8 * k);\n            }\n            \n            strSid.append(\"-\");\n            strSid.append(subAuthority);\n            \n            offset += size;\n        }\n        \n        return strSid.toString();    \n    }","id":23462,"modified_method":"/**\n     * The binary data is in form:\n     * byte[0] - revision level\n     * byte[1] - count of sub-authorities\n     * byte[2-7] - 48 bit authority (big-endian)\n     * and then count x 32 bit sub authorities (little-endian)\n     * \n     * The String value is: S-Revision-Authority-SubAuthority[n]...\n     * \n     * http://forums.oracle.com/forums/thread.jspa?threadID=1155740&tstart=0\n     */\n    private static String decodeSID(byte[] sid) {\n        \n        final StringBuilder strSid = new StringBuilder(\"S-\");\n\n        // get version\n        final int revision = sid[0];\n        strSid.append(Integer.toString(revision));\n        \n        //next byte is the count of sub-authorities\n        final int countSubAuths = sid[1] & 0xFF;\n        \n        //get the authority\n        long authority = 0;\n        //String rid = \"\";\n        for(int i = 2; i <= 7; i++) {\n           authority |= ((long)sid[i]) << (8 * (5 - (i - 2)));\n        }\n        strSid.append(\"-\");\n        strSid.append(Long.toHexString(authority));\n        \n        //iterate all the sub-auths\n        int offset = 8;\n        int size = 4; //4 bytes for each sub auth\n        for(int j = 0; j < countSubAuths; j++) {\n            long subAuthority = 0;\n            for(int k = 0; k < size; k++) {\n                subAuthority |= (long)(sid[offset + k] & 0xFF) << (8 * k);\n            }\n            \n            strSid.append(\"-\");\n            strSid.append(subAuthority);\n            \n            offset += size;\n        }\n        \n        return strSid.toString();    \n    }","commit_id":"fd8eec73024590c4a36463f631c9ccec61124799","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public final synchronized Group getGroup(Subject invokingUser, String name) {\n        Group grp = groupsByName.get(name);\n        if(grp != null) {\n            return grp;\n        } else {\n            //if the group is not cached, we should try and find it in LDAP and cache it if it exists\n            LdapContext ctx = null;\n            try {\n                ctx = getContext(invokingUser);\n\n                //do the lookup\n                SearchResult ldapGroup = findGroupByGroupName(ctx, removeDomainPostfix(name));\n                if(ldapGroup == null) {\n                    return null;\n                } else {\n                    //found a group from ldap so cache them and return\n                    try {\n                        return createGroupInDatabase(invokingUser, name);\n                        //registerGroup(grp); //TODO do we need to do this?\n                    } catch(AuthenticationException ae) {\n                        LOG.error(ae.getMessage(), ae);\n                        return null;\n                    }\n                }\n            } catch(NamingException ne) {\n                LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));\n                return null;\n            } finally {\n                if(ctx != null) {\n                    LdapUtils.closeContext(ctx);\n                }\n            }\n        }\n    }","id":23463,"modified_method":"@Override\n    public final synchronized Group getGroup(Subject invokingUser, String name) {\n        \n        name = ensureCase(name);\n        \n        Group grp = groupsByName.get(name);\n        if(grp != null) {\n            return grp;\n        } else {\n            //if the group is not cached, we should try and find it in LDAP and cache it if it exists\n            LdapContext ctx = null;\n            try {\n                ctx = getContext(invokingUser);\n\n                //do the lookup\n                SearchResult ldapGroup = findGroupByGroupName(ctx, removeDomainPostfix(name));\n                if(ldapGroup == null) {\n                    return null;\n                } else {\n                    //found a group from ldap so cache them and return\n                    try {\n                        return createGroupInDatabase(invokingUser, name);\n                        //registerGroup(grp); //TODO do we need to do this?\n                    } catch(AuthenticationException ae) {\n                        LOG.error(ae.getMessage(), ae);\n                        return null;\n                    }\n                }\n            } catch(NamingException ne) {\n                LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));\n                return null;\n            } finally {\n                if(ctx != null) {\n                    LdapUtils.closeContext(ctx);\n                }\n            }\n        }\n    }","commit_id":"fd8eec73024590c4a36463f631c9ccec61124799","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public Subject authenticate(String username, Object credentials) throws AuthenticationException {\n        // Binds using the username and password provided by the user.\n        LdapContext ctx = null;\n        try {\n            ctx = ensureContextFactory().getLdapContext(username, String.valueOf(credentials));\n\n        } catch(NamingException e) {\n            if(e instanceof javax.naming.AuthenticationException) {\n                throw new AuthenticationException(AuthenticationException.ACCOUNT_NOT_FOUND, e.getMessage());\n            } else {\n                throw new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, e.getMessage());\n            }\n\n        } finally {\n            LdapUtils.closeContext(ctx);\n        }\n\n        AbstractAccount account = (AbstractAccount) getAccount(null, username);\n        /*if(account == null) {\n            account = (AbstractAccount) createAccountInDatabase(null, username);\n        }*/\n\n        return new AuthenticatedLdapSubjectAccreditedImpl(account, ctx, String.valueOf(credentials));\n    }","id":23464,"modified_method":"@Override\n    public Subject authenticate(String username, Object credentials) throws AuthenticationException {\n        \n        username = ensureCase(username);\n        \n        // Binds using the username and password provided by the user.\n        LdapContext ctx = null;\n        try {\n            ctx = ensureContextFactory().getLdapContext(username, String.valueOf(credentials));\n\n        } catch(NamingException e) {\n            if(e instanceof javax.naming.AuthenticationException) {\n                throw new AuthenticationException(AuthenticationException.ACCOUNT_NOT_FOUND, e.getMessage());\n            } else {\n                throw new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, e.getMessage());\n            }\n\n        } finally {\n            LdapUtils.closeContext(ctx);\n        }\n\n        AbstractAccount account = (AbstractAccount) getAccount(null, username);\n        /*if(account == null) {\n            account = (AbstractAccount) createAccountInDatabase(null, username);\n        }*/\n\n        return new AuthenticatedLdapSubjectAccreditedImpl(account, ctx, String.valueOf(credentials));\n    }","commit_id":"fd8eec73024590c4a36463f631c9ccec61124799","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    public final synchronized Account getAccount(Subject invokingUser, String name) {\n\n        //first attempt to get the cached account\n        Account acct = super.getAccount(invokingUser, name);\n\n        if(acct != null) {\n            return acct;\n        } else {\n            //if the account is not cached, we should try and find it in LDAP and cache it if it exists\n            LdapContext ctx = null;\n            try{\n                ctx = getContext(invokingUser);\n\n                //do the lookup\n                SearchResult ldapUser = findAccountByAccountName(ctx, name);\n                if(ldapUser == null) {\n                    return null;\n                } else {\n                    //found a user from ldap so cache them and return\n                    try {\n                        LDAPSearchContext search = ensureContextFactory().getSearch();\n                        String primaryGroup = findGroupBySID(ctx, getPrimaryGroupSID(ldapUser));\n                        return createAccountInDatabase(invokingUser, name, ldapUser, primaryGroup);\n                        //registerAccount(acct); //TODO do we need this\n                    } catch(AuthenticationException ae) {\n                        LOG.error(ae.getMessage(), ae);\n                        return null;\n                    }\n                }\n            } catch(NamingException ne) {\n                LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));\n                            return null;\n            } finally {\n                if(ctx != null){\n                    LdapUtils.closeContext(ctx);\n                }\n            }\n        }\n    }","id":23465,"modified_method":"@Override\n    public final synchronized Account getAccount(Subject invokingUser, String name) {\n\n        name = ensureCase(name);\n        \n        //first attempt to get the cached account\n        Account acct = super.getAccount(invokingUser, name);\n\n        if(acct != null) {\n            return acct;\n        } else {\n            //if the account is not cached, we should try and find it in LDAP and cache it if it exists\n            LdapContext ctx = null;\n            try{\n                ctx = getContext(invokingUser);\n\n                //do the lookup\n                SearchResult ldapUser = findAccountByAccountName(ctx, name);\n                if(ldapUser == null) {\n                    return null;\n                } else {\n                    //found a user from ldap so cache them and return\n                    try {\n                        String primaryGroup = findGroupBySID(ctx, getPrimaryGroupSID(ldapUser));\n                        return createAccountInDatabase(invokingUser, name, ldapUser, ensureCase(primaryGroup));\n                        //registerAccount(acct); //TODO do we need this\n                    } catch(AuthenticationException ae) {\n                        LOG.error(ae.getMessage(), ae);\n                        return null;\n                    }\n                }\n            } catch(NamingException ne) {\n                LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));\n                            return null;\n            } finally {\n                if(ctx != null){\n                    LdapUtils.closeContext(ctx);\n                }\n            }\n        }\n    }","commit_id":"fd8eec73024590c4a36463f631c9ccec61124799","url":"https://github.com/eXist-db/exist"},{"original_method":"private Account createAccountInDatabase(final Subject invokingUser, final String username, final SearchResult ldapUser, final String primaryGroupName) throws AuthenticationException {\n\n        final LDAPSearchAccount searchAccount = ensureContextFactory().getSearch().getSearchAccount();\n\n        try {\n            return executeAsSystemUser(invokingUser, new Unit<Account>(){\n                @Override\n                public Account execute(Subject invokingUser, DBBroker broker) throws EXistException, PermissionDeniedException, NamingException {\n                    //get (or create) the primary group if it doesnt exist\n                    Group primaryGroup = getGroup(invokingUser, primaryGroupName);\n\n                    //get (or create) member groups\n                    LDAPSearchContext search = ensureContextFactory().getSearch();\n                    String userDistinguishedName = (String)ldapUser.getAttributes().get(search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.DN)).get();\n                    List<String> memberOf_groupNames = findGroupnamesForUserDistinguishedName(invokingUser, userDistinguishedName);\n\n                    List<Group> memberOf_groups = new ArrayList<Group>();\n                    for(String memberOf_groupName : memberOf_groupNames) {\n                        memberOf_groups.add(getGroup(invokingUser, memberOf_groupName));\n                    }\n\n                    //create the user account\n                    UserAider userAider = new UserAider(ID, username, primaryGroup);\n\n                    //add the member groups\n                    for(Group memberOf_group : memberOf_groups) {\n                        userAider.addGroup(memberOf_group);\n                    }\n\n                    //store any requested metadata\n                    for(AXSchemaType axSchemaType : searchAccount.getMetadataSearchAttributeKeys()) {\n                        String searchAttribute = searchAccount.getMetadataSearchAttribute(axSchemaType);\n                        Attributes userAttributes = ldapUser.getAttributes();\n                        if(userAttributes != null) {\n                            Attribute userAttribute = userAttributes.get(searchAttribute);\n                            if(userAttribute != null) {\n                                String attributeValue = userAttribute.get().toString();\n                                userAider.setMetadataValue(axSchemaType, attributeValue);\n                            }\n                        }\n                    }\n\n                    Account account = getSecurityManager().addAccount(userAider);\n\n                    //LDAPAccountImpl account = sm.addAccount(instantiateAccount(ID, username));\n\n                    //TODO expand to a general method that rewrites the useraider based on the realTransformation\n                    boolean updatedAccount = false;\n                    if(ensureContextFactory().getTransformationContext() != null){\n                        List<String> additionalGroupNames = ensureContextFactory().getTransformationContext().getAdditionalGroups();\n                        if(additionalGroupNames != null) {\n                            for(String additionalGroupName : additionalGroupNames) {\n                                Group additionalGroup = getSecurityManager().getGroup(invokingUser, additionalGroupName);\n                                if(additionalGroup != null) {\n                                    account.addGroup(additionalGroup);\n                                    updatedAccount = true;\n                                }\n                            }\n                        }\n                    }\n                    if(updatedAccount) {\n                        boolean updated = getSecurityManager().updateAccount(invokingUser, account);\n                        if(!updated) {\n                            LOG.error(\"Could not update account\");\n                        }\n                    }\n\n                    return account;\n                }\n            });\n        } catch(Exception e) {\n            throw new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, e.getMessage(), e);\n        }\n    }","id":23466,"modified_method":"private Account createAccountInDatabase(final Subject invokingUser, final String username, final SearchResult ldapUser, final String primaryGroupName) throws AuthenticationException {\n\n        final LDAPSearchAccount searchAccount = ensureContextFactory().getSearch().getSearchAccount();\n\n        try {\n            return executeAsSystemUser(invokingUser, new Unit<Account>(){\n                @Override\n                public Account execute(Subject invokingUser, DBBroker broker) throws EXistException, PermissionDeniedException, NamingException {\n                    //get (or create) the primary group if it doesnt exist\n                    Group primaryGroup = getGroup(invokingUser, primaryGroupName);\n\n                    //get (or create) member groups\n                    LDAPSearchContext search = ensureContextFactory().getSearch();\n                    String userDistinguishedName = (String)ldapUser.getAttributes().get(search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.DN)).get();\n                    List<String> memberOf_groupNames = findGroupnamesForUserDistinguishedName(invokingUser, userDistinguishedName);\n\n                    List<Group> memberOf_groups = new ArrayList<Group>();\n                    for(String memberOf_groupName : memberOf_groupNames) {\n                        memberOf_groups.add(getGroup(invokingUser, memberOf_groupName));\n                    }\n\n                    //create the user account\n                    UserAider userAider = new UserAider(ID, username, primaryGroup);\n\n                    //add the member groups\n                    for(Group memberOf_group : memberOf_groups) {\n                        userAider.addGroup(memberOf_group);\n                    }\n\n                    //store any requested metadata\n                    for(AXSchemaType axSchemaType : searchAccount.getMetadataSearchAttributeKeys()) {\n                        String searchAttribute = searchAccount.getMetadataSearchAttribute(axSchemaType);\n                        Attributes userAttributes = ldapUser.getAttributes();\n                        if(userAttributes != null) {\n                            Attribute userAttribute = userAttributes.get(searchAttribute);\n                            if(userAttribute != null) {\n                                String attributeValue = userAttribute.get().toString();\n                                userAider.setMetadataValue(axSchemaType, attributeValue);\n                            }\n                        }\n                    }\n\n                    Account account = getSecurityManager().addAccount(userAider);\n\n                    //LDAPAccountImpl account = sm.addAccount(instantiateAccount(ID, username));\n\n                    //TODO expand to a general method that rewrites the useraider based on the realTransformation\n                    boolean updatedAccount = false;\n                    if(ensureContextFactory().getTransformationContext() != null){\n                        List<String> additionalGroupNames = ensureContextFactory().getTransformationContext().getAdditionalGroups();\n                        if(additionalGroupNames != null) {\n                            for(String additionalGroupName : additionalGroupNames) {\n                                Group additionalGroup = getSecurityManager().getGroup(invokingUser, ensureCase(additionalGroupName));\n                                if(additionalGroup != null) {\n                                    account.addGroup(additionalGroup);\n                                    updatedAccount = true;\n                                }\n                            }\n                        }\n                    }\n                    if(updatedAccount) {\n                        boolean updated = getSecurityManager().updateAccount(invokingUser, account);\n                        if(!updated) {\n                            LOG.error(\"Could not update account\");\n                        }\n                    }\n\n                    return account;\n                }\n            });\n        } catch(Exception e) {\n            throw new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, e.getMessage(), e);\n        }\n    }","commit_id":"fd8eec73024590c4a36463f631c9ccec61124799","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void generateIndex(File f, Set<String> alreadyGeneratedFiles, Set<String> alreadyUploadedFiles) {\r\n\t\tif (!generateIndexes) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tDataExtraction extr = new DataExtraction(indexAddress, indexPOI, indexTransport, indexAddress, false, false, indexDirFiles);\r\n\t\t\ttry {\r\n\t\t\t\talreadyGeneratedFiles.add(f.getName());\r\n\t\t\t\tRegion country = extr.readCountry(f.getAbsolutePath(), new ConsoleProgressImplementation(9), null);\r\n\t\t\t\tDataIndexWriter dataIndexWriter = new DataIndexWriter(indexDirFiles, country);\r\n\t\t\t\tString name = country.getName();\r\n\t\t\t\tif (indexAddress) {\r\n\t\t\t\t\tString fName = name + \"_\" + IndexConstants.ADDRESS_TABLE_VERSION + IndexConstants.ADDRESS_INDEX_EXT;\r\n\t\t\t\t\tdataIndexWriter.writeAddress(fName, f.lastModified(), writeWayNodes);\r\n\t\t\t\t\tuploadIndex(new File(indexDirFiles, fName), alreadyUploadedFiles);\r\n\t\t\t\t}\r\n\t\t\t\tif (indexPOI) {\r\n\t\t\t\t\tString fName = name + \"_\" + IndexConstants.POI_TABLE_VERSION + IndexConstants.POI_INDEX_EXT;\r\n\t\t\t\t\tdataIndexWriter.writePOI(fName, f.lastModified());\r\n\t\t\t\t\tuploadIndex(new File(indexDirFiles, fName), alreadyUploadedFiles);\r\n\t\t\t\t}\r\n\t\t\t\tif (indexTransport) {\r\n\t\t\t\t\tString fName = name + \"_\" + IndexConstants.TRANSPORT_TABLE_VERSION + IndexConstants.TRANSPORT_INDEX_EXT;\r\n\t\t\t\t\tdataIndexWriter.writeTransport(fName, f.lastModified());\r\n\t\t\t\t\tuploadIndex(new File(indexDirFiles, fName), alreadyUploadedFiles);\r\n\t\t\t\t}\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\tlog.error(\"Exception generating indexes for \" + f.getName(), e); //$NON-NLS-1$ \r\n\t\t\t}\r\n\t\t} catch (OutOfMemoryError e) {\r\n\t\t\tSystem.gc();\r\n\t\t\tlog.error(\"OutOfMemory\", e);\r\n\r\n\t\t}\r\n\t\tSystem.gc();\r\n\t}","id":23467,"modified_method":"protected void generateIndex(File f, Set<String> alreadyGeneratedFiles, Set<String> alreadyUploadedFiles) {\r\n\t\tif (!generateIndexes) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tIndexCreator indexCreator = new IndexCreator(indexDirFiles);\r\n\t\t\tindexCreator.setIndexAddress(indexAddress);\r\n\t\t\tindexCreator.setIndexAddress(indexPOI);\r\n\t\t\tindexCreator.setIndexAddress(indexTransport);\r\n\t\t\tindexCreator.setNormalizeStreets(true);\r\n\t\t\tindexCreator.setSaveAddressWays(writeWayNodes);\r\n\r\n\t\t\tString regionName = f.getName();\r\n\t\t\tint i = f.getName().indexOf('.');\r\n\t\t\tif (i > -1) {\r\n\t\t\t\tregionName = Algoritms.capitalizeFirstLetterAndLowercase(f.getName().substring(0, i));\r\n\t\t\t}\r\n\t\t\tString addressFileName = regionName + \"_\" + IndexConstants.ADDRESS_TABLE_VERSION + IndexConstants.ADDRESS_INDEX_EXT;\r\n\t\t\tindexCreator.setAddressFileName(addressFileName);\r\n\t\t\tString transportFileName = regionName + \"_\" + IndexConstants.TRANSPORT_TABLE_VERSION + IndexConstants.TRANSPORT_INDEX_EXT;\r\n\t\t\tindexCreator.setTransportFileName(transportFileName);\r\n\t\t\tString poiFileName = regionName + \"_\" + IndexConstants.POI_TABLE_VERSION + IndexConstants.POI_INDEX_EXT;\r\n\t\t\tindexCreator.setPoiFileName(poiFileName);\r\n\t\t\ttry {\r\n\t\t\t\talreadyGeneratedFiles.add(f.getName());\r\n\t\t\t\tindexCreator.generateIndexes(f, new ConsoleProgressImplementation(3),  null);\r\n\t\t\t\tif (indexAddress) {\r\n\t\t\t\t\tuploadIndex(new File(indexDirFiles, addressFileName), alreadyUploadedFiles);\r\n\t\t\t\t}\r\n\t\t\t\tif (indexPOI) {\r\n\t\t\t\t\tuploadIndex(new File(indexDirFiles, poiFileName), alreadyUploadedFiles);\r\n\t\t\t\t}\r\n\t\t\t\tif (indexTransport) {\r\n\t\t\t\t\tuploadIndex(new File(indexDirFiles, transportFileName), alreadyUploadedFiles);\r\n\t\t\t\t}\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\tlog.error(\"Exception generating indexes for \" + f.getName(), e); //$NON-NLS-1$ \r\n\t\t\t}\r\n\t\t} catch (OutOfMemoryError e) {\r\n\t\t\tSystem.gc();\r\n\t\t\tlog.error(\"OutOfMemory\", e);\r\n\r\n\t\t}\r\n\t\tSystem.gc();\r\n\t}","commit_id":"fa091e92d7fc6e6ef0ffe22e8f186dc20968b6f0","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static void main(String[] args) throws IOException, SAXException, SQLException {\r\n\t\tFile workDir = new File(\"e:/Information/OSM maps/osmand/\");\r\n\t\tIndexCreator extr = new IndexCreator(workDir);\r\n\t\textr.setIndexPOI(true);\r\n\t\textr.setIndexTransport(true);\r\n\t\textr.setIndexAddress(true);\r\n\t\textr.setNormalizeStreets(true);\r\n\t\textr.setSaveAddressWays(true);\r\n\r\n\t\tFile file = new File(workDir, \"netherlands.odb\");\r\n\t\textr.setNodesDBFile(file);\r\n\t\textr.generateIndexes(file, new ConsoleProgressImplementation(2), null);\r\n\t\t\r\n//\t\textr.generateIndexes(new File(\"e:/Information/OSM maps/osm_map/netherlands.osm.bz2\"), new ConsoleProgressImplementation(2), null);\r\n\t\t\r\n//\t\textr.generateIndexes(new File(\"e:/Information/OSM maps/belarus osm/minsk.osm\"), new ConsoleProgressImplementation(4), null);\r\n\t\t\r\n//\t\textr.generateIndexes(new File(\"e:/Information/OSM maps/belarus osm/belarus_2010_06_02.osm.bz2\"), new ConsoleProgressImplementation(4), null);\r\n\t\t\r\n\t\t\r\n//\t\tFile file = new File(workDir, \"nodes.map.odb\");\r\n//\t\textr.setNodesDBFile(file);\r\n//\t\textr.generateIndexes(file, new ConsoleProgressImplementation(2), null);\r\n\t\t\r\n\t}","id":23468,"modified_method":"public static void main(String[] args) throws IOException, SAXException, SQLException {\r\n\t\tFile workDir = new File(\"e:/Information/OSM maps/osmand/\");\r\n\t\tIndexCreator extr = new IndexCreator(workDir);\r\n//\t\textr.setIndexPOI(true);\r\n//\t\textr.setIndexTransport(true);\r\n\t\textr.setIndexAddress(true);\r\n\t\textr.setNormalizeStreets(true);\r\n\t\textr.setSaveAddressWays(true);\r\n\r\n\t\tFile file = new File(workDir, \"netherlands.odb\");\r\n\t\textr.setNodesDBFile(file);\r\n\t\textr.generateIndexes(file, new ConsoleProgressImplementation(2), null);\r\n\t\t\r\n//\t\textr.generateIndexes(new File(\"e:/Information/OSM maps/osm_map/netherlands.osm.bz2\"), new ConsoleProgressImplementation(2), null);\r\n\t\t\r\n//\t\textr.generateIndexes(new File(\"e:/Information/OSM maps/belarus osm/minsk.osm\"), new ConsoleProgressImplementation(4), null);\r\n\t\t\r\n//\t\textr.generateIndexes(new File(\"e:/Information/OSM maps/belarus osm/belarus_2010_06_02.osm.bz2\"), new ConsoleProgressImplementation(4), null);\r\n\t\t\r\n\t\t\r\n//\t\tFile file = new File(workDir, \"nodes.map.odb\");\r\n//\t\textr.setNodesDBFile(file);\r\n//\t\textr.generateIndexes(file, new ConsoleProgressImplementation(2), null);\r\n\t\t\r\n\t}","commit_id":"fa091e92d7fc6e6ef0ffe22e8f186dc20968b6f0","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void registerCityIfNeeded(Entity e) {\r\n\t\tif (e instanceof Node && e.getTag(OSMTagKey.PLACE) != null) {\r\n\t\t\tCity city = new City((Node) e);\r\n\t\t\tif(city.getType() != null && !Algoritms.isEmpty(city.getName())){\r\n\t\t\t\tconvertEnglishName(city);\r\n\t\t\t\tcityManager.registerObject(((Node) e).getLatitude(), ((Node) e).getLongitude(), city);\r\n\t\t\t\tcities.put(city.getEntityId(), city);\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":23469,"modified_method":"private void registerCityIfNeeded(Entity e) {\r\n\t\tif (e instanceof Node && e.getTag(OSMTagKey.PLACE) != null) {\r\n\t\t\tCity city = new City((Node) e);\r\n\t\t\tif(city.getType() != null && !Algoritms.isEmpty(city.getName())){\r\n\t\t\t\tconvertEnglishName(city);\r\n\t\t\t\tif(city.getType() == CityType.CITY || city.getType() == CityType.TOWN){\r\n\t\t\t\t\tcityManager.registerObject(((Node) e).getLatitude(), ((Node) e).getLongitude(), city);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcityVillageManager.registerObject(((Node) e).getLatitude(), ((Node) e).getLongitude(), city);\r\n\t\t\t\t}\r\n\t\t\t\tcities.put(city.getEntityId(), city);\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"fa091e92d7fc6e6ef0ffe22e8f186dc20968b6f0","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public City getClosestCity(LatLon point) {\r\n\t\tif(point == null){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tCity closest = null;\r\n\t\tdouble relDist = Double.POSITIVE_INFINITY;\r\n\t\tfor (City c : cityManager.getClosestObjects(point.getLatitude(), point.getLongitude())) {\r\n\t\t\tdouble rel = MapUtils.getDistance(c.getLocation(), point) / c.getType().getRadius();\r\n\t\t\tif (rel < relDist) {\r\n\t\t\t\tclosest = c;\r\n\t\t\t\trelDist = rel;\r\n\t\t\t\tif(relDist < 0.2d){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn closest;\r\n\t}","id":23470,"modified_method":"public City getClosestCity(LatLon point) {\r\n\t\tif(point == null){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tCity closest = null;\r\n\t\tdouble relDist = Double.POSITIVE_INFINITY;\r\n\t\tfor (City c : cityManager.getClosestObjects(point.getLatitude(), point.getLongitude(), 3)) {\r\n\t\t\tdouble rel = MapUtils.getDistance(c.getLocation(), point) / c.getType().getRadius();\r\n\t\t\tif (rel < relDist) {\r\n\t\t\t\tclosest = c;\r\n\t\t\t\trelDist = rel;\r\n\t\t\t\tif(relDist < 0.2d){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(relDist < 0.2d){\r\n\t\t\treturn closest;\r\n\t\t}\r\n\t\tfor (City c : cityVillageManager.getClosestObjects(point.getLatitude(), point.getLongitude(), 3)) {\r\n\t\t\tdouble rel = MapUtils.getDistance(c.getLocation(), point) / c.getType().getRadius();\r\n\t\t\tif (rel < relDist) {\r\n\t\t\t\tclosest = c;\r\n\t\t\t\trelDist = rel;\r\n\t\t\t\tif(relDist < 0.2d){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn closest;\r\n\t}","commit_id":"fa091e92d7fc6e6ef0ffe22e8f186dc20968b6f0","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void iterateEntity(Entity e, int step) throws SQLException {\r\n\t\tif (step == STEP_MAIN) {\r\n\t\t\tif (indexPOI && Amenity.isAmenity(e)) {\r\n\t\t\t\tloadEntityData(e, false);\r\n\t\t\t\tif (poiPreparedStatement != null) {\r\n\t\t\t\t\tAmenity a = new Amenity(e);\r\n\t\t\t\t\tif (a.getLocation() != null) {\r\n\t\t\t\t\t\tconvertEnglishName(a);\r\n\t\t\t\t\t\tDataIndexWriter.insertAmenityIntoPoi(poiPreparedStatement, pStatements, a, BATCH_SIZE);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (indexTransport) {\r\n\t\t\t\tif (e instanceof Relation && e.getTag(OSMTagKey.ROUTE) != null) {\r\n\t\t\t\t\tloadEntityData(e, true);\r\n\t\t\t\t\tTransportRoute route = indexTransportRoute((Relation) e);\r\n\t\t\t\t\tif (route != null) {\r\n\t\t\t\t\t\tDataIndexWriter.insertTransportIntoIndex(transRouteStat, transRouteStopsStat, transStopsStat, visitedStops, route,\r\n\t\t\t\t\t\t\t\tpStatements, BATCH_SIZE);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (indexAddress) {\r\n\t\t\t\t// index not only buildings but also nodes that belongs to addr:interpolation ways\r\n\t\t\t\tif (e.getTag(OSMTagKey.ADDR_HOUSE_NUMBER) != null && e.getTag(OSMTagKey.ADDR_STREET) != null) {\r\n\t\t\t\t\t// TODO e.getTag(OSMTagKey.ADDR_CITY) could be used to find city however many cities could have same name!\r\n\t\t\t\t\t// check that building is not registered already\r\n\t\t\t\t\tboolean exist = false;\r\n\t\t\t\t\tif(loadInMemory){\r\n\t\t\t\t\t\taddressSearchBuildingStat.setLong(1, e.getId());\r\n\t\t\t\t\t\tResultSet rs = addressSearchBuildingStat.executeQuery();\r\n\t\t\t\t\t\texist = rs.next();\r\n\t\t\t\t\t\trs.close();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\texist = addressBuildingLocalSet.contains(e.getId());\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!exist) {\r\n\t\t\t\t\t\tloadEntityData(e, false);\r\n\t\t\t\t\t\tLatLon l = e.getLatLon();\r\n\t\t\t\t\t\tCity city = getClosestCity(l);\r\n\t\t\t\t\t\tLong idStreet = getStreetInCity(city, e.getTag(OSMTagKey.ADDR_STREET), l, e.getId());\r\n\t\t\t\t\t\tif (idStreet != null) {\r\n\t\t\t\t\t\t\tBuilding building = new Building(e);\r\n\t\t\t\t\t\t\tbuilding.setName(e.getTag(OSMTagKey.ADDR_HOUSE_NUMBER));\r\n\t\t\t\t\t\t\tconvertEnglishName(building);\r\n\t\t\t\t\t\t\tDataIndexWriter.writeBuilding(addressBuildingStat, pStatements, idStreet, building, BATCH_SIZE);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// suppose that streets with names are ways for car\r\n\t\t\t\tif (e instanceof Way /* && OSMSettings.wayForCar(e.getTag(OSMTagKey.HIGHWAY)) */\r\n\t\t\t\t\t\t&& e.getTag(OSMTagKey.HIGHWAY) != null && e.getTag(OSMTagKey.NAME) != null) {\r\n\t\t\t\t\tboolean exist = false;\r\n\t\t\t\t\tif(loadInMemory){\r\n\t\t\t\t\t\taddressSearchStreetNodeStat.setLong(1, e.getId());\r\n\t\t\t\t\t\tResultSet rs = addressSearchStreetNodeStat.executeQuery();\r\n\t\t\t\t\t\texist = rs.next();\r\n\t\t\t\t\t\trs.close();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\texist = addressStreetNodeLocalSet.contains(e.getId());\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// check that building is not registered already \r\n\t\t\t\t\tif (!exist) {\r\n\t\t\t\t\t\tloadEntityData(e, false);\r\n\t\t\t\t\t\tLatLon l = e.getLatLon();\r\n\t\t\t\t\t\tCity city = getClosestCity(l);\r\n\t\t\t\t\t\tLong idStreet = getStreetInCity(city, e.getTag(OSMTagKey.NAME), l, e.getId());\r\n\t\t\t\t\t\tif (idStreet != null && saveAddressWays) {\r\n\t\t\t\t\t\t\tDataIndexWriter.writeStreetWayNodes(addressStreetNodeStat, pStatements, idStreet, (Way) e, BATCH_SIZE);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (e instanceof Relation) {\r\n\t\t\t\t\tif (e.getTag(OSMTagKey.POSTAL_CODE) != null) {\r\n\t\t\t\t\t\tloadEntityData(e, false);\r\n\t\t\t\t\t\tpostalCodeRelations.add((Relation) e);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (step == STEP_ADDRESS_RELATIONS) {\r\n\t\t\tif (e instanceof Relation && \"address\".equals(e.getTag(OSMTagKey.TYPE))) {\r\n\t\t\t\tindexAddressRelation((Relation) e);\r\n\t\t\t}\r\n\t\t} else if (step == STEP_CITY_NODES) {\r\n\t\t\tregisterCityIfNeeded(e);\r\n\t\t}\r\n\t\t\r\n\t}","id":23471,"modified_method":"private void iterateEntity(Entity e, int step) throws SQLException {\r\n\t\tif (step == STEP_MAIN) {\r\n\t\t\tif (indexPOI && Amenity.isAmenity(e)) {\r\n\t\t\t\tloadEntityData(e, false);\r\n\t\t\t\tif (poiPreparedStatement != null) {\r\n\t\t\t\t\tAmenity a = new Amenity(e);\r\n\t\t\t\t\tif (a.getLocation() != null) {\r\n\t\t\t\t\t\tconvertEnglishName(a);\r\n\t\t\t\t\t\tDataIndexWriter.insertAmenityIntoPoi(poiPreparedStatement, pStatements, a, BATCH_SIZE);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (indexTransport) {\r\n\t\t\t\tif (e instanceof Relation && e.getTag(OSMTagKey.ROUTE) != null) {\r\n\t\t\t\t\tloadEntityData(e, true);\r\n\t\t\t\t\tTransportRoute route = indexTransportRoute((Relation) e);\r\n\t\t\t\t\tif (route != null) {\r\n\t\t\t\t\t\tDataIndexWriter.insertTransportIntoIndex(transRouteStat, transRouteStopsStat, transStopsStat, visitedStops, route,\r\n\t\t\t\t\t\t\t\tpStatements, BATCH_SIZE);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (indexAddress) {\r\n\t\t\t\t// index not only buildings but also nodes that belongs to addr:interpolation ways\r\n\t\t\t\tif (e.getTag(OSMTagKey.ADDR_HOUSE_NUMBER) != null && e.getTag(OSMTagKey.ADDR_STREET) != null) {\r\n\t\t\t\t\t// TODO e.getTag(OSMTagKey.ADDR_CITY) could be used to find city however many cities could have same name!\r\n\t\t\t\t\t// check that building is not registered already\r\n\t\t\t\t\tboolean exist = false;\r\n\t\t\t\t\tif(loadInMemory){\r\n\t\t\t\t\t\texist = addressBuildingLocalSet.contains(e.getId());\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\taddressSearchBuildingStat.setLong(1, e.getId());\r\n\t\t\t\t\t\tResultSet rs = addressSearchBuildingStat.executeQuery();\r\n\t\t\t\t\t\texist = rs.next();\r\n\t\t\t\t\t\trs.close();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!exist) {\r\n\t\t\t\t\t\tloadEntityData(e, false);\r\n\t\t\t\t\t\tLatLon l = e.getLatLon();\r\n\t\t\t\t\t\tCity city = getClosestCity(l);\r\n\t\t\t\t\t\tLong idStreet = getStreetInCity(city, e.getTag(OSMTagKey.ADDR_STREET), l, e.getId());\r\n\t\t\t\t\t\tif (idStreet != null) {\r\n\t\t\t\t\t\t\tBuilding building = new Building(e);\r\n\t\t\t\t\t\t\tbuilding.setName(e.getTag(OSMTagKey.ADDR_HOUSE_NUMBER));\r\n\t\t\t\t\t\t\tconvertEnglishName(building);\r\n\t\t\t\t\t\t\tDataIndexWriter.writeBuilding(addressBuildingStat, pStatements, idStreet, building, BATCH_SIZE);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// suppose that streets with names are ways for car\r\n\t\t\t\tif (e instanceof Way /* && OSMSettings.wayForCar(e.getTag(OSMTagKey.HIGHWAY)) */\r\n\t\t\t\t\t\t&& e.getTag(OSMTagKey.HIGHWAY) != null && e.getTag(OSMTagKey.NAME) != null) {\r\n\t\t\t\t\tboolean exist = false;\r\n\t\t\t\t\tif(loadInMemory){\r\n\t\t\t\t\t\texist = addressStreetNodeLocalSet.contains(e.getId());\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\taddressSearchStreetNodeStat.setLong(1, e.getId());\r\n\t\t\t\t\t\tResultSet rs = addressSearchStreetNodeStat.executeQuery();\r\n\t\t\t\t\t\texist = rs.next();\r\n\t\t\t\t\t\trs.close();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// check that building is not registered already \r\n\t\t\t\t\tif (!exist) {\r\n\t\t\t\t\t\tloadEntityData(e, false);\r\n\t\t\t\t\t\tLatLon l = e.getLatLon();\r\n\t\t\t\t\t\tCity city = getClosestCity(l);\r\n\t\t\t\t\t\tLong idStreet = getStreetInCity(city, e.getTag(OSMTagKey.NAME), l, e.getId());\r\n\t\t\t\t\t\tif (idStreet != null && saveAddressWays) {\r\n\t\t\t\t\t\t\tDataIndexWriter.writeStreetWayNodes(addressStreetNodeStat, pStatements, idStreet, (Way) e, BATCH_SIZE);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (e instanceof Relation) {\r\n\t\t\t\t\tif (e.getTag(OSMTagKey.POSTAL_CODE) != null) {\r\n\t\t\t\t\t\tloadEntityData(e, false);\r\n\t\t\t\t\t\tpostalCodeRelations.add((Relation) e);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (step == STEP_ADDRESS_RELATIONS) {\r\n\t\t\tif (e instanceof Relation && \"address\".equals(e.getTag(OSMTagKey.TYPE))) {\r\n\t\t\t\tindexAddressRelation((Relation) e);\r\n\t\t\t}\r\n\t\t} else if (step == STEP_CITY_NODES) {\r\n\t\t\tregisterCityIfNeeded(e);\r\n\t\t}\r\n\t\t\r\n\t}","commit_id":"fa091e92d7fc6e6ef0ffe22e8f186dc20968b6f0","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n    protected DefaultListableBeanFactory createBeanFactory()\n    {\n        //Copy all postProcessors defined in the defaultMuleConfig so that they get applied to the child container\n        DefaultListableBeanFactory beanFactory = super.createBeanFactory();\n        beanFactory.setInstantiationStrategy(new LaxInstantiationStrategyWrapper(new CglibSubclassingInstantiationStrategy(), optionalObjectsController));\n\n        if (getParent() != null)\n        {\n            //Copy over all processors\n            AbstractBeanFactory parentBeanFactory = (AbstractBeanFactory) getParent().getAutowireCapableBeanFactory();\n            beanFactory.copyConfigurationFrom(parentBeanFactory);\n        }\n        return beanFactory;\n    }","id":23472,"modified_method":"@Override\n    protected DefaultListableBeanFactory createBeanFactory()\n    {\n        //Copy all postProcessors defined in the defaultMuleConfig so that they get applied to the child container\n        DefaultListableBeanFactory beanFactory = new MuleBeanFactory(getInternalParentBeanFactory());\n        beanFactory.setInstantiationStrategy(new LaxInstantiationStrategyWrapper(new CglibSubclassingInstantiationStrategy(), optionalObjectsController));\n\n        if (getParent() != null)\n        {\n            //Copy over all processors\n            AbstractBeanFactory parentBeanFactory = (AbstractBeanFactory) getParent().getAutowireCapableBeanFactory();\n            beanFactory.copyConfigurationFrom(parentBeanFactory);\n        }\n        return beanFactory;\n    }","commit_id":"0056ab6071b326fdc0ce250cc7c965ee7cb15255","url":"https://github.com/mulesoft/mule"},{"original_method":"public static Map<Class<? extends Annotation>, Annotation> toMap(Annotation[] annotations)\n    {\n\n        Map<Class<? extends Annotation>, Annotation> map = new HashMap<>();\n\n        for (Annotation annotation : annotations)\n        {\n            map.put(resolveAnnotationClass(annotation), annotation);\n        }\n\n        return map;\n    }","id":23473,"modified_method":"public static Map<Class<? extends Annotation>, Annotation> toMap(Annotation[] annotations)\n    {\n\n        Map<Class<? extends Annotation>, Annotation> map = new HashMap<>();\n\n        for (Annotation annotation : annotations)\n        {\n            map.put(ClassUtils.resolveAnnotationClass(annotation), annotation);\n        }\n\n        return map;\n    }","commit_id":"0056ab6071b326fdc0ce250cc7c965ee7cb15255","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void injectWithInheritance() throws Exception {\n        TestLifecycleObject object = new ExtendedTestLifecycleObject();\n        muleContext.getRegistry().registerObject(KEY, object);\n\n        assertInjection(object);\n    }","id":23474,"modified_method":"@Test\n    public void injectWithInheritance() throws Exception\n    {\n        TestLifecycleObject child1 = new TestLifecycleObject();\n        TestLifecycleObject child2 = new TestLifecycleObject();\n        muleContext.getRegistry().registerObject(KEY, child1);\n        muleContext.getRegistry().registerObject(KEY2, child2);\n\n        assertThat(muleContext.getRegistry().lookupByType(TestLifecycleObject.class).size(), is(2));\n\n        ExtendedTestLifecycleObject object = new ExtendedTestLifecycleObject();\n\n        muleContext.getRegistry().registerObject(EXTENDED_KEY, object);\n        assertInjection(object);\n        assertThat(object.getKeyChild(), is(sameInstance(child1)));\n        assertThat(object.getKey2Child(), is(sameInstance(child2)));\n    }","commit_id":"0056ab6071b326fdc0ce250cc7c965ee7cb15255","url":"https://github.com/mulesoft/mule"},{"original_method":"protected String parseSocketBinding(final XMLExtendedStreamReader reader, final Set<String> interfaces, final ModelNode address, final String inheritedInterfaceName, final List<ModelNode> updates) throws XMLStreamException {\n\n        final EnumSet<Attribute> required = EnumSet.of(Attribute.NAME, Attribute.PORT);\n        String name = null;\n\n        final ModelNode binding = new ModelNode();\n        binding.get(OP_ADDR); // undefined until we parse name\n        binding.get(OP).set(ADD);\n\n        // Handle attributes\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i ++) {\n            final String value = reader.getAttributeValue(i);\n            if (!isNoNamespaceAttribute(reader, i)) {\n                throw unexpectedAttribute(reader, i);\n            } else {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                required.remove(attribute);\n                switch (attribute) {\n                    case NAME: {\n                        name = value;\n                        binding.get(OP_ADDR).set(address).add(SOCKET_BINDING, name);\n                        break;\n                    }\n                    case INTERFACE: {\n                        if (! interfaces.contains(value)) {\n                            throw new XMLStreamException(\"Unknown interface \" + value +\n                                    \" \" + attribute.getLocalName() + \" must be declared in element \" +\n                                    Element.INTERFACES.getLocalName(), reader.getLocation());\n                        }\n                        binding.get(INTERFACE).set(value);\n                        break;\n                    }\n                    case PORT: {\n                        binding.get(PORT).set(parseBoundedIntegerAttribute(reader, i, 0, 65535));\n                        break;\n                    }\n                    case FIXED_PORT: {\n                        binding.get(FIXED_PORT).set(Boolean.parseBoolean(value));\n                        break;\n                    }\n                    case MULTICAST_ADDRESS: {\n                        try {\n                            final InetAddress mcastAddr = InetAddress.getByName(value);\n                            if (!mcastAddr.isMulticastAddress()) {\n                                throw new XMLStreamException(\"Value \" + value + \" for attribute \" +\n                                        attribute.getLocalName() + \" is not a valid multicast address\",\n                                        reader.getLocation());\n                            }\n                            binding.get(MULTICAST_ADDRESS).set(value);\n                            break;\n                        } catch (final UnknownHostException e) {\n                            throw new XMLStreamException(\"Value \" + value + \" for attribute \" +\n                                    attribute.getLocalName() + \" is not a valid multicast address\",\n                                    reader.getLocation(), e);\n                        }\n                        break;\n                    }\n                    case MULTICAST_PORT: {\n                        binding.get(MULTICAST_PORT).set(parseBoundedIntegerAttribute(reader, i, 1, 65535));\n                        required.remove(Attribute.PORT);\n                        break;\n                    }\n                    default:\n                        throw unexpectedAttribute(reader, i);\n                }\n            }\n        }\n\n        if (! required.isEmpty()) {\n            throw missingRequired(reader, required);\n        }\n        // Handle elements\n        requireNoContent(reader);\n\n        updates.add(binding);\n        return name;\n    }","id":23475,"modified_method":"protected String parseSocketBinding(final XMLExtendedStreamReader reader, final Set<String> interfaces, final ModelNode address, final String inheritedInterfaceName, final List<ModelNode> updates) throws XMLStreamException {\n\n        final EnumSet<Attribute> required = EnumSet.of(Attribute.NAME, Attribute.PORT);\n        String name = null;\n\n        final ModelNode binding = new ModelNode();\n        binding.get(OP_ADDR); // undefined until we parse name\n        binding.get(OP).set(ADD);\n\n        // Handle attributes\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i ++) {\n            final String value = reader.getAttributeValue(i);\n            if (!isNoNamespaceAttribute(reader, i)) {\n                throw unexpectedAttribute(reader, i);\n            } else {\n                final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                required.remove(attribute);\n                switch (attribute) {\n                    case NAME: {\n                        name = value;\n                        binding.get(OP_ADDR).set(address).add(SOCKET_BINDING, name);\n                        break;\n                    }\n                    case INTERFACE: {\n                        if (! interfaces.contains(value)) {\n                            throw new XMLStreamException(\"Unknown interface \" + value +\n                                    \" \" + attribute.getLocalName() + \" must be declared in element \" +\n                                    Element.INTERFACES.getLocalName(), reader.getLocation());\n                        }\n                        binding.get(INTERFACE).set(value);\n                        break;\n                    }\n                    case PORT: {\n                        binding.get(PORT).set(parseBoundedIntegerAttribute(reader, i, 0, 65535));\n                        break;\n                    }\n                    case FIXED_PORT: {\n                        binding.get(FIXED_PORT).set(Boolean.parseBoolean(value));\n                        break;\n                    }\n                    case MULTICAST_ADDRESS: {\n                        try {\n                            final InetAddress mcastAddr = InetAddress.getByName(value);\n                            if (!mcastAddr.isMulticastAddress()) {\n                                throw new XMLStreamException(\"Value \" + value + \" for attribute \" +\n                                        attribute.getLocalName() + \" is not a valid multicast address\",\n                                        reader.getLocation());\n                            }\n                            binding.get(MULTICAST_ADDRESS).set(value);\n                        } catch (final UnknownHostException e) {\n                            throw new XMLStreamException(\"Value \" + value + \" for attribute \" +\n                                    attribute.getLocalName() + \" is not a valid multicast address\",\n                                    reader.getLocation(), e);\n                        }\n                        break;\n                    }\n                    case MULTICAST_PORT: {\n                        binding.get(MULTICAST_PORT).set(parseBoundedIntegerAttribute(reader, i, 1, 65535));\n                        required.remove(Attribute.PORT);\n                        break;\n                    }\n                    default:\n                        throw unexpectedAttribute(reader, i);\n                }\n            }\n        }\n\n        if (! required.isEmpty()) {\n            throw missingRequired(reader, required);\n        }\n        // Handle elements\n        requireNoContent(reader);\n\n        updates.add(binding);\n        return name;\n    }","commit_id":"2d0ee07c40f0694133965d24ff5d24c7b5c142a6","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public synchronized void start(StartContext context) throws StartException {\n        if (org.apache.tomcat.util.Constants.ENABLE_MODELER) {\n            // Set the MBeanServer\n            final MBeanServer mbeanServer = this.mbeanServer.getOptionalValue();\n            if(mbeanServer != null) {\n                Registry.getRegistry(null, null).setMBeanServer(mbeanServer);\n            }\n        }\n\n        final Catalina catalina = new Catalina();\n        catalina.setCatalinaHome(pathInjector.getValue());\n\n        final StandardServer server = new StandardServer();\n        catalina.setServer(server);\n        registerObject(mbeanServer, \"jboss.web:type=Server\", server,  \"org.apache.catalina.startup.StandardServer\");\n\n        final StandardService service = new StandardService();\n        registerObject(mbeanServer, \"jboss.web:service=WebServer\", service, \"org.apache.catalina.core.StandardService\");\n        service.setName(JBOSS_WEB);\n        service.setServer(server);\n        server.addService(service);\n\n        final Engine engine = new StandardEngine();\n        engine.setName(JBOSS_WEB);\n        engine.setService(service);\n        engine.setDefaultHost(defaultHost);\n\n        service.setContainer(engine);\n\n        if (useNative) {\n            final AprLifecycleListener apr = new AprLifecycleListener();\n            apr.setSSLEngine(\"on\");\n            server.addLifecycleListener(apr);\n        }\n        server.addLifecycleListener(new JasperListener());\n\n        try {\n            catalina.create();\n            server.initialize();\n            catalina.start();\n            // Register here ?\n        } catch (Exception e) {\n            throw new StartException(e);\n        }\n        this.catalina = catalina;\n        this.service = service;\n        this.engine = engine;\n    }","id":23476,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public synchronized void start(StartContext context) throws StartException {\n        MBeanServer mbeanServer = null;\n        if (org.apache.tomcat.util.Constants.ENABLE_MODELER) {\n            // Set the MBeanServer\n            mbeanServer = this.mbeanServer.getOptionalValue();\n            if(mbeanServer != null) {\n                Registry.getRegistry(null, null).setMBeanServer(mbeanServer);\n            }\n        }\n\n        final Catalina catalina = new Catalina();\n        catalina.setCatalinaHome(pathInjector.getValue());\n\n        final StandardServer server = new StandardServer();\n        catalina.setServer(server);\n        if (mbeanServer != null)\n            registerObject(mbeanServer, \"jboss.web:type=Server\", server,  \"org.apache.catalina.startup.StandardServer\");\n\n        final StandardService service = new StandardService();\n        if (mbeanServer != null)\n            registerObject(mbeanServer, \"jboss.web:service=WebServer\", service, \"org.apache.catalina.core.StandardService\");\n        service.setName(JBOSS_WEB);\n        service.setServer(server);\n        server.addService(service);\n\n        final Engine engine = new StandardEngine();\n        engine.setName(JBOSS_WEB);\n        engine.setService(service);\n        engine.setDefaultHost(defaultHost);\n\n        service.setContainer(engine);\n\n        if (useNative) {\n            final AprLifecycleListener apr = new AprLifecycleListener();\n            apr.setSSLEngine(\"on\");\n            server.addLifecycleListener(apr);\n        }\n        server.addLifecycleListener(new JasperListener());\n\n        try {\n            catalina.create();\n            server.initialize();\n            catalina.start();\n            // Register here ?\n        } catch (Exception e) {\n            throw new StartException(e);\n        }\n        this.catalina = catalina;\n        this.service = service;\n        this.engine = engine;\n    }","commit_id":"2d0ee07c40f0694133965d24ff5d24c7b5c142a6","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void testAssureSet() {\n    String s = \"\";\n    try {\n      StringTools.assureSet(s, \"varName\");\n      fail();\n    } catch (IllegalArgumentException expected) {\n      // expected exception\n    }\n    s = \" \\t\";\n    try {\n      StringTools.assureSet(s, \"varName\");\n      fail();\n    } catch (IllegalArgumentException expected) {\n      // expected exception\n    }\n    s = null;\n    try {\n      StringTools.assureSet(s, \"varName\");\n      fail();\n    } catch (NullPointerException expected) {\n      // expected exception\n    }\n    s = \"foo\";\n    StringTools.assureSet(s, \"varName\");\n  }","id":23477,"modified_method":"public void testAssureSet() {\n    try {\n      StringTools.assureSet(\"\", \"varName\");\n      fail();\n    } catch (IllegalArgumentException expected) {\n      // expected exception\n    }\n    try {\n      StringTools.assureSet(\" \\t\", \"varName\");\n      fail();\n    } catch (IllegalArgumentException expected) {\n      // expected exception\n    }\n    try {\n      StringTools.assureSet(null, \"varName\");\n      fail();\n    } catch (NullPointerException expected) {\n      // expected exception\n    }\n    StringTools.assureSet(\"foo\", \"varName\");\n  }","commit_id":"9fb88ce8daa45a229ef8eb689819dc6845f97b0e","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void testStack() {\n    UnsyncStack<String> stack = new UnsyncStack<String>();\n    assertTrue(stack.empty());    \n    stack.push(\"test\");\n    assertEquals(\"test\", stack.peek());\n    assertFalse(stack.empty());\n    assertEquals(\"test\", stack.pop());\n    assertTrue(stack.empty());    \n  }","id":23478,"modified_method":"public void testStack() {\n    final UnsyncStack<String> stack = new UnsyncStack<String>();\n    assertTrue(stack.empty());\n    stack.push(\"test\");\n    assertEquals(\"test\", stack.peek());\n    assertFalse(stack.empty());\n    assertEquals(\"test\", stack.pop());\n    assertTrue(stack.empty());    \n  }","commit_id":"9fb88ce8daa45a229ef8eb689819dc6845f97b0e","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n\t * Create a new CachedIntrospectionResults instance for the given class.\n\t * @param beanClass the bean class to analyze\n\t * @throws BeansException in case of introspection failure\n\t */\n\tprivate CachedIntrospectionResults(Class<?> beanClass) throws BeansException {\n\t\ttry {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Getting BeanInfo for class [\" + beanClass.getName() + \"]\");\n\t\t\t}\n\n\t\t\tBeanInfo beanInfo = null;\n\t\t\tfor (BeanInfoFactory beanInfoFactory : beanInfoFactories) {\n\t\t\t\tbeanInfo = beanInfoFactory.getBeanInfo(beanClass);\n\t\t\t\tif (beanInfo != null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (beanInfo == null) {\n\t\t\t\t// If none of the factories supported the class, fall back to the default\n\t\t\t\tbeanInfo = Introspector.getBeanInfo(beanClass);\n\t\t\t}\n\t\t\tthis.beanInfo = beanInfo;\n\n\t\t\t// Immediately remove class from Introspector cache, to allow for proper\n\t\t\t// garbage collection on class loader shutdown - we cache it here anyway,\n\t\t\t// in a GC-friendly manner. In contrast to CachedIntrospectionResults,\n\t\t\t// Introspector does not use WeakReferences as values of its WeakHashMap!\n\t\t\tClass<?> classToFlush = beanClass;\n\t\t\tdo {\n\t\t\t\tIntrospector.flushFromCaches(classToFlush);\n\t\t\t\tclassToFlush = classToFlush.getSuperclass();\n\t\t\t}\n\t\t\twhile (classToFlush != null);\n\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Caching PropertyDescriptors for class [\" + beanClass.getName() + \"]\");\n\t\t\t}\n\t\t\tthis.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>();\n\n\t\t\t// This call is slow so we do it once.\n\t\t\tPropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors();\n\t\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\t\tif (Class.class.equals(beanClass) &&\n\t\t\t\t\t\t(\"classLoader\".equals(pd.getName()) ||  \"protectionDomain\".equals(pd.getName()))) {\n\t\t\t\t\t// Ignore Class.getClassLoader() and getProtectionDomain() methods - nobody needs to bind to those\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Found bean property '\" + pd.getName() + \"'\" +\n\t\t\t\t\t\t\t(pd.getPropertyType() != null ? \" of type [\" + pd.getPropertyType().getName() + \"]\" : \"\") +\n\t\t\t\t\t\t\t(pd.getPropertyEditorClass() != null ?\n\t\t\t\t\t\t\t\t\t\"; editor [\" + pd.getPropertyEditorClass().getName() + \"]\" : \"\"));\n\t\t\t\t}\n\t\t\t\tpd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd);\n\t\t\t\tthis.propertyDescriptorCache.put(pd.getName(), pd);\n\t\t\t}\n\n\t\t\tthis.typeDescriptorCache = new HashMap<PropertyDescriptor, TypeDescriptor>();\n\t\t}\n\t\tcatch (IntrospectionException ex) {\n\t\t\tthrow new FatalBeanException(\"Failed to obtain BeanInfo for class [\" + beanClass.getName() + \"]\", ex);\n\t\t}\n\t}","id":23479,"modified_method":"/**\n\t * Create a new CachedIntrospectionResults instance for the given class.\n\t * @param beanClass the bean class to analyze\n\t * @throws BeansException in case of introspection failure\n\t */\n\tprivate CachedIntrospectionResults(Class<?> beanClass) throws BeansException {\n\t\ttry {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Getting BeanInfo for class [\" + beanClass.getName() + \"]\");\n\t\t\t}\n\n\t\t\tBeanInfo beanInfo = null;\n\t\t\tfor (BeanInfoFactory beanInfoFactory : beanInfoFactories) {\n\t\t\t\tbeanInfo = beanInfoFactory.getBeanInfo(beanClass);\n\t\t\t\tif (beanInfo != null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (beanInfo == null) {\n\t\t\t\t// If none of the factories supported the class, fall back to the default\n\t\t\t\tbeanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?\n\t\t\t\t\t\tIntrospector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :\n\t\t\t\t\t\tIntrospector.getBeanInfo(beanClass));\n\t\t\t}\n\t\t\tthis.beanInfo = beanInfo;\n\n\t\t\t// Immediately remove class from Introspector cache, to allow for proper\n\t\t\t// garbage collection on class loader shutdown - we cache it here anyway,\n\t\t\t// in a GC-friendly manner. In contrast to CachedIntrospectionResults,\n\t\t\t// Introspector does not use WeakReferences as values of its WeakHashMap!\n\t\t\tClass<?> classToFlush = beanClass;\n\t\t\tdo {\n\t\t\t\tIntrospector.flushFromCaches(classToFlush);\n\t\t\t\tclassToFlush = classToFlush.getSuperclass();\n\t\t\t}\n\t\t\twhile (classToFlush != null);\n\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Caching PropertyDescriptors for class [\" + beanClass.getName() + \"]\");\n\t\t\t}\n\t\t\tthis.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>();\n\n\t\t\t// This call is slow so we do it once.\n\t\t\tPropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors();\n\t\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\t\tif (Class.class.equals(beanClass) &&\n\t\t\t\t\t\t(\"classLoader\".equals(pd.getName()) ||  \"protectionDomain\".equals(pd.getName()))) {\n\t\t\t\t\t// Ignore Class.getClassLoader() and getProtectionDomain() methods - nobody needs to bind to those\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Found bean property '\" + pd.getName() + \"'\" +\n\t\t\t\t\t\t\t(pd.getPropertyType() != null ? \" of type [\" + pd.getPropertyType().getName() + \"]\" : \"\") +\n\t\t\t\t\t\t\t(pd.getPropertyEditorClass() != null ?\n\t\t\t\t\t\t\t\t\t\"; editor [\" + pd.getPropertyEditorClass().getName() + \"]\" : \"\"));\n\t\t\t\t}\n\t\t\t\tpd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd);\n\t\t\t\tthis.propertyDescriptorCache.put(pd.getName(), pd);\n\t\t\t}\n\n\t\t\tthis.typeDescriptorCache = new HashMap<PropertyDescriptor, TypeDescriptor>();\n\t\t}\n\t\tcatch (IntrospectionException ex) {\n\t\t\tthrow new FatalBeanException(\"Failed to obtain BeanInfo for class [\" + beanClass.getName() + \"]\", ex);\n\t\t}\n\t}","commit_id":"240819f955eed5624a1a0b2dcdd582b6ed829bbe","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n     * Create a new CachedIntrospectionResults instance for the given class.\n     * @param beanClass the bean class to analyze\n     * @throws BeansException in case of introspection failure\n     */\n    private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {\n        try {\n            BeanInfo beanInfo = null;\n            for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {\n                beanInfo = beanInfoFactory.getBeanInfo(beanClass);\n                if (beanInfo != null) {\n                    break;\n                }\n            }\n            if (beanInfo == null) {\n                // If none of the factories supported the class, fall back to the default\n                beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?\n                        Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :\n                        Introspector.getBeanInfo(beanClass));\n            }\n            this.beanInfo = beanInfo;\n\n            this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>();\n\n            // This call is slow so we do it once.\n            PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors();\n            for (PropertyDescriptor pd : pds) {\n                if (Class.class.equals(beanClass) &&\n                        (\"classLoader\".equals(pd.getName()) ||  \"protectionDomain\".equals(pd.getName()))) {\n                    // Ignore Class.getClassLoader() and getProtectionDomain() methods - nobody needs to bind to those\n                    continue;\n                }\n                pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd);\n                this.propertyDescriptorCache.put(pd.getName(), pd);\n            }\n\n            this.typeDescriptorCache = new ConcurrentReferenceHashMap<PropertyDescriptor, TypeDescriptor>();\n        }\n        catch (IntrospectionException ex) {\n            throw new FatalBeanException(\"Failed to obtain BeanInfo for class [\" + beanClass.getName() + \"]\", ex);\n        }\n    }","id":23480,"modified_method":"/**\n     * Create a new CachedIntrospectionResults instance for the given class.\n     * @param beanClass the bean class to analyze\n     * @throws BeansException in case of introspection failure\n     */\n    private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {\n        try {\n            BeanInfo beanInfo = new ExtendedBeanInfo(Introspector.getBeanInfo(beanClass));\n            if (beanInfo == null) {\n                // If none of the factories supported the class, fall back to the default\n                beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?\n                        Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :\n                        Introspector.getBeanInfo(beanClass));\n            }\n            this.beanInfo = beanInfo;\n\n            this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>();\n\n            // This call is slow so we do it once.\n            PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors();\n            for (PropertyDescriptor pd : pds) {\n                if (Class.class.equals(beanClass) &&\n                        (\"classLoader\".equals(pd.getName()) ||  \"protectionDomain\".equals(pd.getName()))) {\n                    // Ignore Class.getClassLoader() and getProtectionDomain() methods - nobody needs to bind to those\n                    continue;\n                }\n                pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd);\n                this.propertyDescriptorCache.put(pd.getName(), pd);\n            }\n\n            this.typeDescriptorCache = new ConcurrentReferenceHashMap<PropertyDescriptor, TypeDescriptor>();\n        }\n        catch (IntrospectionException ex) {\n            throw new FatalBeanException(\"Failed to obtain BeanInfo for class [\" + beanClass.getName() + \"]\", ex);\n        }\n    }","commit_id":"088e892981efc596717d5491c700f607f61a1a4e","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n        public boolean equals(Object other) {\n            if (this == other) {\n                return true;\n            }\n            if (!(other instanceof GenericTypeAwarePropertyDescriptor)) {\n                return false;\n            }\n            GenericTypeAwarePropertyDescriptor otherPd = (GenericTypeAwarePropertyDescriptor) other;\n            return (getBeanClass().equals(otherPd.getBeanClass()) && equals(this, otherPd));\n        }","id":23481,"modified_method":"@Override\n        public boolean equals(Object other) {\n            if (this == other) {\n                return true;\n            }\n            if (!(other instanceof GenericTypeAwarePropertyDescriptor)) {\n                return false;\n            }\n            GenericTypeAwarePropertyDescriptor otherPd = (GenericTypeAwarePropertyDescriptor) other;\n            return (getBeanClass().equals(otherPd.getBeanClass()) && CachedIntrospectionResults.equals(this, otherPd));\n        }","commit_id":"088e892981efc596717d5491c700f607f61a1a4e","url":"https://github.com/grails/grails-core"},{"original_method":"@Test\n\tpublic void reproSpr8806() throws IntrospectionException {\n\t\tBeanInfo bi = Introspector.getBeanInfo(LawLibrary.class);\n\t\tnew ExtendedBeanInfo(bi); // throws\n\t}","id":23482,"modified_method":"@Test\n\tpublic void reproSpr8806() throws IntrospectionException {\n\t\t// does not throw\n\t\tIntrospector.getBeanInfo(LawLibrary.class);\n\n\t\t// does not throw after the changes introduced in SPR-8806\n\t\tnew ExtendedBeanInfo(Introspector.getBeanInfo(LawLibrary.class)); \n\t}","commit_id":"c1df51a3b48b8d826a4ddb2976d44ab845bd0847","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test(timeout = 20000)\n    public void test_setAttribute() throws Exception {\n        CookieStore cookieStore = new BasicCookieStore();\n        executeRequest(\"setAttribute?key=value&key2=value2&key2=value22\", serverPort1, cookieStore);\n        IMap<Object, Object> map = hz.getMap(DEFAULT_MAP_NAME);\n        assertEquals(1, map.size());\n        String hazelcastSessionId = getHazelcastSessionId(cookieStore);\n        SessionState sessionState = (SessionState) map.get(hazelcastSessionId);\n        assertEquals(2, sessionState.getAttributes().size());\n        LocalMapStats stats = map.getLocalMapStats();\n        assertEquals(1, stats.getPutOperationCount());\n        assertEquals(\"value\", executeRequest(\"read\", serverPort1, cookieStore));\n        assertEquals(1, map.size());\n        server1.stop();\n        assertEquals(1, map.size());\n        sessionState = (SessionState) map.get(hazelcastSessionId);\n        System.out.println(sessionState);\n        assertEquals(2, sessionState.getAttributes().size());\n        assertEquals(\"value\", executeRequest(\"read\", serverPort2, cookieStore));\n        server2.stop();\n        assertEquals(1, map.size());\n        sessionState = (SessionState) map.get(hazelcastSessionId);\n        assertEquals(2, sessionState.getAttributes().size());\n        server1.start();\n        assertEquals(\"value\", executeRequest(\"read\", serverPort1, cookieStore));\n        server2.start();\n        assertEquals(\"value\", executeRequest(\"read\", serverPort2, cookieStore));\n        executeRequest(\"invalidate\", serverPort2, cookieStore);\n        assertEquals(0, map.size());\n        assertNull(map.get(hazelcastSessionId));\n        assertEquals(\"null\", executeRequest(\"read\", serverPort2, cookieStore));\n        assertEquals(\"value\", executeRequest(\"read\", serverPort1, cookieStore));\n    }","id":23483,"modified_method":"@Test(timeout = 20000)\n    public void test_setAttribute() throws Exception {\n        CookieStore cookieStore = new BasicCookieStore();\n        executeRequest(\"setAttribute?key=value&key2=value2&key2=value22\", serverPort1, cookieStore);\n        IMap<Object, Object> map = hz.getMap(DEFAULT_MAP_NAME);\n        assertEquals(1, map.size());\n        String hazelcastSessionId = getHazelcastSessionId(cookieStore);\n        SessionState sessionState = (SessionState) map.get(hazelcastSessionId);\n        assertEquals(2, sessionState.getAttributes().size());\n        LocalMapStats stats = map.getLocalMapStats();\n        assertEquals(1, stats.getPutOperationCount());\n        assertEquals(\"value\", executeRequest(\"read\", serverPort1, cookieStore));\n        assertEquals(1, map.size());\n        server1.stop();\n        assertEquals(1, map.size());\n        sessionState = (SessionState) map.get(hazelcastSessionId);\n        System.out.println(sessionState);\n        assertEquals(2, sessionState.getAttributes().size());\n        assertEquals(\"value\", executeRequest(\"read\", serverPort2, cookieStore));\n        server2.stop();\n        assertEquals(1, map.size());\n        sessionState = (SessionState) map.get(hazelcastSessionId);\n        assertEquals(2, sessionState.getAttributes().size());\n        server1.start();\n        assertEquals(\"value\", executeRequest(\"read\", serverPort1, cookieStore));\n        server2.start();\n        assertEquals(\"value\", executeRequest(\"read\", serverPort2, cookieStore));\n        executeRequest(\"invalidate\", serverPort2, cookieStore);\n        assertEquals(0, map.size());\n        assertNull(map.get(hazelcastSessionId));\n        assertEquals(\"null\", executeRequest(\"read\", serverPort2, cookieStore));\n        assertEquals(\"null\", executeRequest(\"read\", serverPort1, cookieStore));\n    }","commit_id":"98850a51c610de0259cede1eea5f1054af4b0b7f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test(timeout = 20000)\n    public void test_setAttribute() throws Exception {\n        CookieStore cookieStore = new BasicCookieStore();\n        executeRequest(\"setAttribute?key=value&key2=value2&key2=value22\", serverPort1, cookieStore);\n        IMap<Object, Object> map = hz.getMap(DEFAULT_MAP_NAME);\n        assertEquals(1, map.size());\n        SessionState sessionState = (SessionState) map.get(getHazelcastSessionId(cookieStore));\n        assertEquals(2, sessionState.getAttributes().size());\n        LocalMapStats stats = map.getLocalMapStats();\n        assertEquals(1, stats.getPutOperationCount());\n        assertEquals(\"value\", executeRequest(\"read\", serverPort1, cookieStore));\n        assertEquals(\"value\", executeRequest(\"read\", serverPort2, cookieStore));\n        assertEquals(1, map.size());\n        assertEquals(\"value\", executeRequest(\"read\", serverPort2, cookieStore));\n        assertEquals(\"true\", executeRequest(\"update\", serverPort2, cookieStore));\n        assertEquals(\"value-updated\", executeRequest(\"read\", serverPort2, cookieStore));\n        assertEquals(\"value\", executeRequest(\"read\", serverPort1, cookieStore));\n    }","id":23484,"modified_method":"@Test(timeout = 20000)\n    public void test_setAttribute() throws Exception {\n        CookieStore cookieStore = new BasicCookieStore();\n        executeRequest(\"setAttribute?key=value&key2=value2&key2=value22\", serverPort1, cookieStore);\n        IMap<Object, Object> map = hz.getMap(DEFAULT_MAP_NAME);\n        assertEquals(1, map.size());\n        SessionState sessionState = (SessionState) map.get(getHazelcastSessionId(cookieStore));\n        assertEquals(2, sessionState.getAttributes().size());\n        LocalMapStats stats = map.getLocalMapStats();\n        assertEquals(1, stats.getPutOperationCount());\n        assertEquals(\"value\", executeRequest(\"read\", serverPort1, cookieStore));\n        assertEquals(\"value\", executeRequest(\"read\", serverPort2, cookieStore));\n        assertEquals(1, map.size());\n        assertEquals(\"value\", executeRequest(\"read\", serverPort2, cookieStore));\n        assertEquals(\"true\", executeRequest(\"update\", serverPort2, cookieStore));\n        assertEquals(\"value-updated\", executeRequest(\"read\", serverPort2, cookieStore));\n        assertEquals(\"value-updated\", executeRequest(\"read\", serverPort1, cookieStore));\n    }","commit_id":"98850a51c610de0259cede1eea5f1054af4b0b7f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public HazelcastHttpSession(WebFilter webFilter, final String sessionId, final HttpSession originalSession,\n                                final boolean deferredWrite) {\n        this.webFilter = webFilter;\n        this.id = sessionId;\n        this.originalSession = originalSession;\n        this.deferredWrite = deferredWrite;\n        String transientAttributesParam = webFilter.getParam(\"transient-attributes\");\n        if (transientAttributesParam == null) {\n            this.transientAttributes = Collections.emptySet();\n        } else {\n            this.transientAttributes = new HashSet<String>();\n            StringTokenizer st = new StringTokenizer(transientAttributesParam, \",\");\n            while (st.hasMoreTokens()) {\n                String token = st.nextToken();\n                this.transientAttributes.add(token.trim());\n            }\n        }\n        if (this.deferredWrite) {\n            buildLocalCache();\n        }\n    }","id":23485,"modified_method":"public HazelcastHttpSession(WebFilter webFilter, final String sessionId, final HttpSession originalSession,\n                                final boolean deferredWrite, final boolean stickySession) {\n        this.webFilter = webFilter;\n        this.id = sessionId;\n        this.originalSession = originalSession;\n        this.deferredWrite = deferredWrite;\n        this.stickySession = stickySession;\n        String transientAttributesParam = webFilter.getParam(\"transient-attributes\");\n        if (transientAttributesParam == null) {\n            this.transientAttributes = Collections.emptySet();\n        } else {\n            this.transientAttributes = new HashSet<String>();\n            StringTokenizer st = new StringTokenizer(transientAttributesParam, \",\");\n            while (st.hasMoreTokens()) {\n                String token = st.nextToken();\n                this.transientAttributes.add(token.trim());\n            }\n        }\n        buildLocalCache();\n    }","commit_id":"98850a51c610de0259cede1eea5f1054af4b0b7f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void setAttribute(final String name, final Object value) {\n        if (name == null) {\n            throw new NullPointerException(\"name must not be null\");\n        }\n        if (value == null) {\n            removeAttribute(name);\n            return;\n        }\n        boolean transientEntry = false;\n        if (transientAttributes.contains(name)) {\n            transientEntry = true;\n        }\n        LocalCacheEntry entry = localCache.get(name);\n        if (entry == null || entry == WebFilter.NULL_ENTRY) {\n            entry = new LocalCacheEntry(transientEntry);\n            localCache.put(name, entry);\n        }\n        entry.setValue(value);\n        entry.setDirty(true);\n        if (!deferredWrite && !transientEntry) {\n            try {\n                webFilter.getClusteredSessionService().setAttribute(id, name, value);\n                entry.setDirty(false);\n            } catch (Exception ignored) {\n                EmptyStatement.ignore(ignored);\n            }\n        }\n    }","id":23486,"modified_method":"public void setAttribute(final String name, final Object value) {\n        if (name == null) {\n            throw new NullPointerException(\"name must not be null\");\n        }\n        if (value == null) {\n            removeAttribute(name);\n            return;\n        }\n        boolean transientEntry = false;\n        if (transientAttributes.contains(name)) {\n            transientEntry = true;\n        }\n        LocalCacheEntry entry = localCache.get(name);\n        if (entry == null || entry == WebFilter.NULL_ENTRY) {\n            entry = new LocalCacheEntry(transientEntry);\n            localCache.put(name, entry);\n        }\n        entry.setValue(value);\n        entry.setDirty(true);\n        entry.setRemoved(false);\n        if (!deferredWrite && !transientEntry) {\n            try {\n                webFilter.getClusteredSessionService().setAttribute(id, name, value);\n                entry.setDirty(false);\n            } catch (Exception ignored) {\n                EmptyStatement.ignore(ignored);\n            }\n        }\n    }","commit_id":"98850a51c610de0259cede1eea5f1054af4b0b7f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object getAttribute(final String name) {\n        boolean transientAttribute = transientAttributes.contains(name);\n        if (deferredWrite) {\n            return getAttributeWhenDeferredWrite(name, transientAttribute);\n        }\n        try {\n            Object value = null;\n            if (!transientAttribute) {\n                value = webFilter.getClusteredSessionService().getAttribute(id, name);\n            }\n            LocalCacheEntry cacheEntry = localCache.get(name);\n            if (cacheEntry == null) {\n                return value;\n            }\n            if (cacheEntry.isDirty()) {\n                return (cacheEntry.isRemoved()) ? null : cacheEntry.getValue();\n            }\n            return value;\n        } catch (Exception e) {\n            return getLocalAttribute(name);\n        }\n    }","id":23487,"modified_method":"public Object getAttribute(final String name) {\n        LocalCacheEntry cacheEntry = localCache.get(name);\n        Object value = null;\n\n        if (cacheEntry == null || cacheEntry.isReload()) {\n            try {\n                value = webFilter.getClusteredSessionService().getAttribute(id, name);\n                if (value == null) {\n                    return null;\n                }\n                cacheEntry = new LocalCacheEntry(false, value);\n            } catch (Exception e) {\n                WebFilter.LOGGER.warning(\"session could not be load so you might be dealing with stale data\", e);\n                if (cacheEntry == null) {\n                    return null;\n                }\n            }\n        }\n        if (cacheEntry.isRemoved()) {\n            return null;\n        }\n        return cacheEntry.getValue();\n    }","commit_id":"98850a51c610de0259cede1eea5f1054af4b0b7f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * @return {@code true} if {@link #deferredWrite} is enabled <i>and<\/i> at least one entry in the local\n     * cache is dirty; otherwise, {@code false}\n     */\n    public boolean sessionChanged() {\n        if (!deferredWrite) {\n            return false;\n        }\n        for (Map.Entry<String, LocalCacheEntry> entry : localCache.entrySet()) {\n            if (entry.getValue().isDirty()) {\n                return true;\n            }\n        }\n        return false;\n    }","id":23488,"modified_method":"/**\n     * @return {@code true} if {@link #deferredWrite} is enabled <i>and<\/i> at least one entry in the local\n     * cache is dirty; otherwise, {@code false}\n     */\n    public boolean sessionChanged() {\n        for (Map.Entry<String, LocalCacheEntry> entry : localCache.entrySet()) {\n            if (entry.getValue().isDirty()) {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"98850a51c610de0259cede1eea5f1054af4b0b7f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"void sessionDeferredWrite() {\n        if (sessionChanged() || isNew()) {\n            if (localCache == null) {\n                return;\n            }\n            Map<String, Object> updates = new HashMap<String, Object>(1);\n            for (Map.Entry<String, LocalCacheEntry> entry : localCache.entrySet()) {\n                String name = entry.getKey();\n                LocalCacheEntry cacheEntry = entry.getValue();\n                if (!cacheEntry.isTransient() && entry.getValue().isDirty()) {\n                    if (cacheEntry.isRemoved()) {\n                        updates.put(name, null);\n                    } else {\n                        updates.put(name, cacheEntry.getValue());\n                    }\n                }\n            }\n            try {\n                webFilter.getClusteredSessionService().updateAttributes(id, updates);\n                Iterator<Map.Entry<String, LocalCacheEntry>> iterator = localCache.entrySet().iterator();\n                while (iterator.hasNext()) {\n                    Map.Entry<String, LocalCacheEntry> entry = iterator.next();\n                    LocalCacheEntry cacheEntry = entry.getValue();\n                    if (cacheEntry.isDirty()) {\n                        if (cacheEntry.isRemoved()) {\n                            iterator.remove();\n                        } else {\n                            cacheEntry.setDirty(false);\n                        }\n                    }\n                }\n            } catch (Exception ignored) {\n                EmptyStatement.ignore(ignored);\n            }\n        }\n    }","id":23489,"modified_method":"void sessionDeferredWrite() {\n        if (sessionChanged() || isNew()) {\n            Map<String, Object> updates = new HashMap<String, Object>();\n\n            Iterator<Map.Entry<String, LocalCacheEntry>> iterator = localCache.entrySet().iterator();\n            while (iterator.hasNext()) {\n                Map.Entry<String, LocalCacheEntry> entry = iterator.next();\n                LocalCacheEntry cacheEntry = entry.getValue();\n\n                if (cacheEntry.isDirty() && !cacheEntry.isTransient()) {\n                    if (cacheEntry.isRemoved()) {\n                        updates.put(entry.getKey(), null);\n                    } else {\n                        updates.put(entry.getKey(), cacheEntry.getValue());\n                    }\n                    cacheEntry.setDirty(false);\n\n                }\n            }\n\n            try {\n                webFilter.getClusteredSessionService().updateAttributes(id, updates);\n            } catch (Exception ignored) {\n                EmptyStatement.ignore(ignored);\n            }\n        }\n    }","commit_id":"98850a51c610de0259cede1eea5f1054af4b0b7f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Instantiates a new Local cache entry.\n     *\n     * @param transientEntry the transient entry\n     */\n    public LocalCacheEntry(boolean transientEntry) {\n        this.transientEntry = transientEntry;\n    }","id":23490,"modified_method":"/**\n     * Instantiates a new Local cache entry.\n     *\n     * @param transientEntry the transient entry\n     */\n    public LocalCacheEntry(boolean transientEntry) {\n        this.transientEntry = transientEntry;\n        this.reload = true;\n    }","commit_id":"98850a51c610de0259cede1eea5f1054af4b0b7f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public final void doFilter(ServletRequest req, ServletResponse res, final FilterChain chain)\n            throws IOException, ServletException {\n        if (!(req instanceof HttpServletRequest)) {\n            chain.doFilter(req, res);\n        } else {\n            if (req instanceof RequestWrapper) {\n                LOGGER.finest(\"Request is instance of RequestWrapper! Continue...\");\n                chain.doFilter(req, res);\n                return;\n            }\n            HttpServletRequest httpReq = (HttpServletRequest) req;\n            RequestWrapper existingReq = (RequestWrapper) req.getAttribute(HAZELCAST_REQUEST);\n            final ResponseWrapper resWrapper = new ResponseWrapper((HttpServletResponse) res);\n            final RequestWrapper reqWrapper = new RequestWrapper(httpReq, resWrapper);\n            if (existingReq != null) {\n                reqWrapper.setHazelcastSession(existingReq.hazelcastSession, existingReq.requestedSessionId);\n            }\n            chain.doFilter(reqWrapper, resWrapper);\n            if (existingReq != null) {\n                return;\n            }\n            HazelcastHttpSession session = reqWrapper.getSession(false);\n            if (session != null && session.isValid()) {\n                if (LOGGER.isFinestEnabled()) {\n                    LOGGER.finest(\"UPDATING SESSION \" + session.getId());\n                }\n                session.sessionDeferredWrite();\n            }\n        }\n    }","id":23491,"modified_method":"public final void doFilter(ServletRequest req, ServletResponse res, final FilterChain chain)\n            throws IOException, ServletException {\n        if (!(req instanceof HttpServletRequest)) {\n            chain.doFilter(req, res);\n        } else {\n            if (req instanceof RequestWrapper) {\n                LOGGER.finest(\"Request is instance of RequestWrapper! Continue...\");\n                chain.doFilter(req, res);\n                return;\n            }\n            HttpServletRequest httpReq = (HttpServletRequest) req;\n            RequestWrapper existingReq = (RequestWrapper) req.getAttribute(HAZELCAST_REQUEST);\n            final ResponseWrapper resWrapper = new ResponseWrapper((HttpServletResponse) res);\n            final RequestWrapper reqWrapper = new RequestWrapper(httpReq, resWrapper);\n            if (existingReq != null) {\n                reqWrapper.setHazelcastSession(existingReq.hazelcastSession, existingReq.requestedSessionId);\n            }\n            chain.doFilter(reqWrapper, resWrapper);\n            if (existingReq != null) {\n                return;\n            }\n            HazelcastHttpSession session = reqWrapper.getSession(false);\n            if (session != null && session.isValid()) {\n                if (LOGGER.isFinestEnabled()) {\n                    LOGGER.finest(\"UPDATING SESSION \" + session.getId());\n                }\n                if (deferredWrite) {\n                    session.sessionDeferredWrite();\n                }\n            }\n        }\n    }","commit_id":"98850a51c610de0259cede1eea5f1054af4b0b7f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * {@code HazelcastHttpSession instance} creation is split off to a separate method to allow subclasses to return a\n     * customized / extended version of {@code HazelcastHttpSession}.\n     *\n     * @param id              the session id\n     * @param originalSession the original session\n     * @param deferredWrite   whether writes are deferred\n     * @return a new HazelcastHttpSession instance\n     */\n    protected HazelcastHttpSession createHazelcastHttpSession(String id, HttpSession originalSession, boolean deferredWrite) {\n        return new HazelcastHttpSession(this, id, originalSession, deferredWrite);\n    }","id":23492,"modified_method":"/**\n     * {@code HazelcastHttpSession instance} creation is split off to a separate method to allow subclasses to return a\n     * customized / extended version of {@code HazelcastHttpSession}.\n     *\n     * @param id              the session id\n     * @param originalSession the original session\n     * @param deferredWrite   whether writes are deferred\n     * @return a new HazelcastHttpSession instance\n     */\n    protected HazelcastHttpSession createHazelcastHttpSession(String id, HttpSession originalSession, boolean deferredWrite) {\n        return new HazelcastHttpSession(this, id, originalSession, deferredWrite, stickySession);\n    }","commit_id":"98850a51c610de0259cede1eea5f1054af4b0b7f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n        public HazelcastHttpSession getSession(final boolean create) {\n            if (hazelcastSession != null && !hazelcastSession.isValid()) {\n                LOGGER.finest(\"Session is invalid!\");\n                destroySession(hazelcastSession, true);\n                hazelcastSession = null;\n            } else if (hazelcastSession != null) {\n                return hazelcastSession;\n            }\n            HttpSession originalSession = getOriginalSession(false);\n            if (originalSession != null) {\n                String hazelcastSessionId = originalSessions.get(originalSession.getId());\n                if (hazelcastSessionId != null) {\n                    hazelcastSession = sessions.get(hazelcastSessionId);\n                    return hazelcastSession;\n                }\n                originalSessions.remove(originalSession.getId());\n                originalSession.invalidate();\n            }\n            if (requestedSessionId != null) {\n                hazelcastSession = sessions.get(requestedSessionId);\n            }\n            if (hazelcastSession == null) {\n                hazelcastSession = getOrCreateHazelcastSession();\n            }\n            return hazelcastSession;\n        }","id":23493,"modified_method":"@Override\n        public HazelcastHttpSession getSession(final boolean create) {\n            hazelcastSession = readSessionFromLocal();\n            if (hazelcastSession == null) {\n                hazelcastSession = getOrCreateHazelcastSession();\n            }\n            return hazelcastSession;\n        }","commit_id":"98850a51c610de0259cede1eea5f1054af4b0b7f","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"void sessionDeferredWrite() {\n        if (sessionChanged() || isNew()) {\n            if (localCache == null) {\n                return;\n            }\n            Map<String, Object> updates = new HashMap<String, Object>(1);\n            for (Map.Entry<String, LocalCacheEntry> entry : localCache.entrySet()) {\n                String name = entry.getKey();\n                LocalCacheEntry cacheEntry = entry.getValue();\n                if (!cacheEntry.isTransient() && entry.getValue().isDirty()) {\n                    if (cacheEntry.isRemoved()) {\n                        updates.put(name, null);\n                    } else {\n                        updates.put(name, cacheEntry.getValue());\n                    }\n                }\n            }\n            try {\n                webFilter.getClusteredSessionService().updateAttributes(id, updates);\n                Iterator<Map.Entry<String, LocalCacheEntry>> iterator = localCache.entrySet().iterator();\n                while (iterator.hasNext()) {\n                    Map.Entry<String, LocalCacheEntry> entry = iterator.next();\n                    LocalCacheEntry cacheEntry = entry.getValue();\n                    if (cacheEntry.isDirty()) {\n                        if (cacheEntry.isRemoved()) {\n                            iterator.remove();\n                        } else {\n                            cacheEntry.setDirty(false);\n                        }\n                    }\n                }\n            } catch (Exception ignored) {\n                EmptyStatement.ignore(ignored);\n            }\n        }\n    }","id":23494,"modified_method":"void sessionDeferredWrite() {\n        if (sessionChanged() || isNew()) {\n            if (localCache == null) {\n                return;\n            }\n            Map<String, Object> updates = new HashMap<String, Object>(1);\n            updateLocalCache(updates);\n            updateRemoteCache(updates);\n        }\n    }","commit_id":"132063b2fc0cf188157a4d531e660056ab707bf1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Object getAttribute(final String name) {\n        boolean transientAttribute = transientAttributes.contains(name);\n        if (deferredWrite) {\n            return getAttributeWhenDeferredWrite(name, transientAttribute);\n        }\n        try {\n            Object value = null;\n            if (!transientAttribute) {\n                value = webFilter.getClusteredSessionService().getAttribute(id, name);\n            }\n            LocalCacheEntry cacheEntry = localCache.get(name);\n            if (cacheEntry == null) {\n                return value;\n            }\n            if (cacheEntry.isDirty()) {\n                return (cacheEntry.isRemoved()) ? null : cacheEntry.getValue();\n            }\n            return value;\n        } catch (Exception e) {\n            return getLocalAttribute(name);\n        }\n    }","id":23495,"modified_method":"public Object getAttribute(final String name) {\n        LocalCacheEntry cacheEntry = localCache.get(name);\n        Object value = null;\n        if (cacheEntry == null || cacheEntry.isReload()) {\n            try {\n                value = webFilter.getClusteredSessionService().getAttribute(id, name);\n                if (cacheEntry == null) {\n                    return value;\n                } else {\n                    if (!deferredWrite) {\n                        cacheEntry.setValue(value);\n                    }\n                    cacheEntry.setDirty(false);\n                    cacheEntry.setRemoved(false);\n                }\n            } catch (Exception e) {\n                WebFilter.LOGGER.warning(\"session could not be load so you might be dealing with stale data\", e);\n                if (cacheEntry == null) {\n                    return null;\n                }\n            }\n        }\n        if (cacheEntry.isRemoved()) {\n            return null;\n        }\n        return cacheEntry.getValue();\n    }","commit_id":"132063b2fc0cf188157a4d531e660056ab707bf1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public HazelcastHttpSession(WebFilter webFilter, final String sessionId, final HttpSession originalSession,\n                                final boolean deferredWrite) {\n        this.webFilter = webFilter;\n        this.id = sessionId;\n        this.originalSession = originalSession;\n        this.deferredWrite = deferredWrite;\n        String transientAttributesParam = webFilter.getParam(\"transient-attributes\");\n        if (transientAttributesParam == null) {\n            this.transientAttributes = Collections.emptySet();\n        } else {\n            this.transientAttributes = new HashSet<String>();\n            StringTokenizer st = new StringTokenizer(transientAttributesParam, \",\");\n            while (st.hasMoreTokens()) {\n                String token = st.nextToken();\n                this.transientAttributes.add(token.trim());\n            }\n        }\n        if (this.deferredWrite) {\n            buildLocalCache();\n        }\n    }","id":23496,"modified_method":"public HazelcastHttpSession(WebFilter webFilter, final String sessionId, final HttpSession originalSession,\n                                final boolean deferredWrite, final boolean stickySession) {\n        this.webFilter = webFilter;\n        this.id = sessionId;\n        this.originalSession = originalSession;\n        this.deferredWrite = deferredWrite;\n        this.stickySession = stickySession;\n        String transientAttributesParam = webFilter.getParam(\"transient-attributes\");\n        if (transientAttributesParam == null) {\n            this.transientAttributes = Collections.emptySet();\n        } else {\n            this.transientAttributes = new HashSet<String>();\n            StringTokenizer st = new StringTokenizer(transientAttributesParam, \",\");\n            while (st.hasMoreTokens()) {\n                String token = st.nextToken();\n                this.transientAttributes.add(token.trim());\n            }\n        }\n        buildLocalCache();\n    }","commit_id":"132063b2fc0cf188157a4d531e660056ab707bf1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Instantiates a new Local cache entry.\n     *\n     * @param transientEntry the transient entry\n     */\n    public LocalCacheEntry(boolean transientEntry) {\n        this.transientEntry = transientEntry;\n    }","id":23497,"modified_method":"/**\n     * Instantiates a new Local cache entry.\n     *\n     * @param transientEntry the transient entry\n     */\n    public LocalCacheEntry(boolean transientEntry) {\n        this.transientEntry = transientEntry;\n        this.reload = true;\n    }","commit_id":"132063b2fc0cf188157a4d531e660056ab707bf1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * {@code HazelcastHttpSession instance} creation is split off to a separate method to allow subclasses to return a\n     * customized / extended version of {@code HazelcastHttpSession}.\n     *\n     * @param id              the session id\n     * @param originalSession the original session\n     * @param deferredWrite   whether writes are deferred\n     * @return a new HazelcastHttpSession instance\n     */\n    protected HazelcastHttpSession createHazelcastHttpSession(String id, HttpSession originalSession, boolean deferredWrite) {\n        return new HazelcastHttpSession(this, id, originalSession, deferredWrite);\n    }","id":23498,"modified_method":"/**\n     * {@code HazelcastHttpSession instance} creation is split off to a separate method to allow subclasses to return a\n     * customized / extended version of {@code HazelcastHttpSession}.\n     *\n     * @param id              the session id\n     * @param originalSession the original session\n     * @param deferredWrite   whether writes are deferred\n     * @return a new HazelcastHttpSession instance\n     */\n    protected HazelcastHttpSession createHazelcastHttpSession(String id, HttpSession originalSession, boolean deferredWrite) {\n        return new HazelcastHttpSession(this, id, originalSession, deferredWrite, stickySession);\n    }","commit_id":"132063b2fc0cf188157a4d531e660056ab707bf1","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void update(Observable o, Object arg) {\n        if (arg instanceof SubsystemState.ChangeEvent == false)\n            return;\n\n        SubsystemState.ChangeEvent event = (ChangeEvent) arg;\n        if (event.getType() != ChangeType.CAPABILITY)\n            return;\n\n        if (!event.isRemoved()) {\n            try {\n                for (final OSGiCapability module : injectedSubsystemState.getValue().getCapabilities()) {\n                    if (module.getIdentifier().toString().equals(event.getId())) {\n                        final ServiceName serviceName = installModule(injectedBundleManager.getValue(), module);\n\n                        ServiceBuilder<Void> builder = serviceController.getServiceContainer().addService(\n                                ServiceName.of(Services.AUTOINSTALL_PROVIDER, \"ModuleUpdater\", \"\" + updateServiceIdCounter.incrementAndGet()),\n                                new AbstractService<Void>() {\n                                    @Override\n                                    public void start(StartContext context) throws StartException {\n                                        try {\n                                            startBundle(serviceController.getServiceContainer(), serviceName, module);\n                                        } finally {\n                                            // Remove this temporary service\n                                            context.getController().setMode(Mode.REMOVE);\n                                        }\n                                    }\n                                });\n                        builder.addDependency(serviceName);\n                        builder.install();\n                        return;\n                    }\n                }\n            } catch (Exception e) {\n                ROOT_LOGGER.errorAddingModule(e, event.getId());\n                return;\n            }\n            ROOT_LOGGER.moduleNotFound(event.getId());\n        }\n    }","id":23499,"modified_method":"@Override\n    public void update(Observable o, Object arg) {\n        if (arg instanceof SubsystemState.ChangeEvent == false)\n            return;\n\n        SubsystemState.ChangeEvent event = (ChangeEvent) arg;\n        if (event.getType() != ChangeType.CAPABILITY)\n            return;\n\n        if (event.isRemoved() == false) {\n            try {\n                for (final OSGiCapability module : injectedSubsystemState.getValue().getCapabilities()) {\n                    if (module.getIdentifier().toString().equals(event.getId())) {\n                        final ServiceName serviceName = installModule(injectedBundleManager.getValue(), module);\n                        if (serviceName != null) {\n                            ServiceBuilder<Void> builder = serviceController.getServiceContainer().addService(\n                                    ServiceName.of(Services.AUTOINSTALL_PROVIDER, \"ModuleUpdater\", \"\" + updateServiceIdCounter.incrementAndGet()),\n                                    new AbstractService<Void>() {\n                                        @Override\n                                        public void start(StartContext context) throws StartException {\n                                            try {\n                                                startBundle(serviceController.getServiceContainer(), serviceName, module);\n                                            } finally {\n                                                // Remove this temporary service\n                                                context.getController().setMode(Mode.REMOVE);\n                                            }\n                                        }\n                                    });\n                            builder.addDependency(serviceName);\n                            builder.install();\n                        }\n                        return;\n                    }\n                }\n            } catch (Exception e) {\n                ROOT_LOGGER.errorAddingModule(e, event.getId());\n                return;\n            }\n            ROOT_LOGGER.moduleNotFound(event.getId());\n        }\n    }","commit_id":"ebb21d201c12e7f57b58def4dd4abe6f5cb02c55","url":"https://github.com/wildfly/wildfly"},{"original_method":"ServiceName installModule(BundleManagerService bundleManager, OSGiCapability moduleMetaData) throws Exception {\n        ModuleIdentifier identifier = moduleMetaData.getIdentifier();\n        Integer startLevel = moduleMetaData.getStartLevel();\n\n        // Attempt to install bundle from the bundles hirarchy\n        File modulesFile = ModuleIdentityArtifactProvider.getRepositoryEntry(bundlesDir, identifier);\n        if (modulesFile != null) {\n            URL url = modulesFile.toURI().toURL();\n            return installBundleFromURL(bundleManager, url, startLevel);\n        }\n\n        // Register module with the OSGi layer\n        ModuleLoader moduleLoader = Module.getBootModuleLoader();\n        Module module = moduleLoader.loadModule(identifier);\n        OSGiMetaData metadata = getModuleMetadata(module);\n        return bundleManager.registerModule(serviceTarget, module, metadata);\n    }","id":23500,"modified_method":"ServiceName installModule(BundleManagerService bundleManager, OSGiCapability moduleMetaData) throws Exception {\n        String identifier = moduleMetaData.getIdentifier();\n        Integer startLevel = moduleMetaData.getStartLevel();\n\n        // Try the identifier as ModuleIdentifier\n        if (isValidModuleIdentifier(identifier)) {\n            ModuleIdentifier moduleId = ModuleIdentifier.fromString(identifier);\n\n            // Attempt to install bundle from the bundles hirarchy\n            File modulesFile = ModuleIdentityArtifactProvider.getRepositoryEntry(bundlesDir, moduleId);\n            if (modulesFile != null) {\n                URL url = modulesFile.toURI().toURL();\n                return installBundleFromURL(bundleManager, url, startLevel);\n            }\n\n            // Register module with the OSGi layer\n            ModuleLoader moduleLoader = Module.getBootModuleLoader();\n            Module module = moduleLoader.loadModule(moduleId);\n            OSGiMetaData metadata = getModuleMetadata(module);\n            return bundleManager.registerModule(serviceTarget, module, metadata);\n        }\n\n        ROOT_LOGGER.cannotResolveCapability(identifier);\n        return null;\n    }","commit_id":"ebb21d201c12e7f57b58def4dd4abe6f5cb02c55","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public synchronized void start(StartContext context) throws StartException {\n        serviceController = context.getController();\n        ROOT_LOGGER.debugf(\"Starting: %s in mode %s\", serviceController.getName(), serviceController.getMode());\n\n        final Map<ServiceName, OSGiCapability> pendingServices = new LinkedHashMap<ServiceName, OSGiCapability>();\n        try {\n            final BundleManagerService bundleManager = injectedBundleManager.getValue();\n            final ServiceContainer serviceContainer = serviceController.getServiceContainer();\n            serviceTarget = context.getChildTarget();\n\n            ServerEnvironment serverEnvironment = injectedEnvironment.getValue();\n            bundlesDir = serverEnvironment.getBundlesDir();\n\n            if (bundlesDir.isDirectory() == false)\n                throw MESSAGES.cannotFindBundleDir(bundlesDir);\n\n            injectedSubsystemState.getValue().addObserver(this);\n\n            List<OSGiCapability> configcaps = new ArrayList<OSGiCapability>();\n            configcaps.add(new OSGiCapability(ModuleIdentifier.create(\"javax.api\"), null));\n            configcaps.add(new OSGiCapability(ModuleIdentifier.create(\"org.osgi.enterprise\"), null));\n            configcaps.add(new OSGiCapability(ModuleIdentifier.create(\"org.jboss.osgi.repository.api\"), null));\n            configcaps.addAll(injectedSubsystemState.getValue().getCapabilities());\n            for (OSGiCapability moduleMetaData : configcaps) {\n                ServiceName serviceName = installModule(bundleManager, moduleMetaData);\n                pendingServices.put(serviceName, moduleMetaData);\n            }\n\n            // Install a service that has a dependency on all pending bundle INSTALLED services\n            ServiceName servicesInstalled = Services.AUTOINSTALL_PROVIDER.append(\"INSTALLED\");\n            ServiceBuilder<Void> builder = serviceTarget.addService(servicesInstalled, new AbstractService<Void>() {\n                public void start(StartContext context) throws StartException {\n                    ROOT_LOGGER.debugf(\"Auto bundles installed\");\n                }\n            });\n            builder.addDependencies(pendingServices.keySet());\n            builder.install();\n\n            // Install a service that starts the bundles\n            builder = serviceTarget.addService(Services.AUTOINSTALL_PROVIDER_COMPLETE, new AbstractService<Void>() {\n                public void start(StartContext context) throws StartException {\n                    for (ServiceName serviceName : pendingServices.keySet()) {\n                        OSGiCapability moduleMetaData = pendingServices.get(serviceName);\n                        startBundle(serviceContainer, serviceName, moduleMetaData);\n                    }\n                    ROOT_LOGGER.debugf(\"Auto bundles bundles started\");\n                }\n            });\n            builder.addDependencies(servicesInstalled);\n            builder.install();\n\n        } catch (Exception ex) {\n            throw new StartException(MESSAGES.failedToCreateAutoInstallList(), ex);\n        }\n    }","id":23501,"modified_method":"@Override\n    public synchronized void start(StartContext context) throws StartException {\n        serviceController = context.getController();\n        ROOT_LOGGER.debugf(\"Starting: %s in mode %s\", serviceController.getName(), serviceController.getMode());\n\n        final Map<ServiceName, OSGiCapability> pendingServices = new LinkedHashMap<ServiceName, OSGiCapability>();\n        try {\n            final BundleManagerService bundleManager = injectedBundleManager.getValue();\n            final ServiceContainer serviceContainer = serviceController.getServiceContainer();\n            serviceTarget = context.getChildTarget();\n\n            ServerEnvironment serverEnvironment = injectedEnvironment.getValue();\n            bundlesDir = serverEnvironment.getBundlesDir();\n\n            if (bundlesDir.isDirectory() == false)\n                throw MESSAGES.cannotFindBundleDir(bundlesDir);\n\n            injectedSubsystemState.getValue().addObserver(this);\n\n            List<OSGiCapability> configcaps = new ArrayList<OSGiCapability>();\n            configcaps.add(new OSGiCapability(\"javax.api\", null));\n            configcaps.add(new OSGiCapability(\"org.osgi.enterprise\", null));\n            configcaps.add(new OSGiCapability(\"org.jboss.osgi.repository.api\", null));\n            configcaps.addAll(injectedSubsystemState.getValue().getCapabilities());\n            for (OSGiCapability moduleMetaData : configcaps) {\n                ServiceName serviceName = installModule(bundleManager, moduleMetaData);\n                if (serviceName != null) {\n                    pendingServices.put(serviceName, moduleMetaData);\n                }\n            }\n\n            // Install a service that has a dependency on all pending bundle INSTALLED services\n            ServiceName servicesInstalled = Services.AUTOINSTALL_PROVIDER.append(\"INSTALLED\");\n            ServiceBuilder<Void> builder = serviceTarget.addService(servicesInstalled, new AbstractService<Void>() {\n                public void start(StartContext context) throws StartException {\n                    ROOT_LOGGER.debugf(\"Auto bundles installed\");\n                }\n            });\n            builder.addDependencies(pendingServices.keySet());\n            builder.install();\n\n            // Install a service that starts the bundles\n            builder = serviceTarget.addService(Services.AUTOINSTALL_PROVIDER_COMPLETE, new AbstractService<Void>() {\n                public void start(StartContext context) throws StartException {\n                    for (ServiceName serviceName : pendingServices.keySet()) {\n                        OSGiCapability moduleMetaData = pendingServices.get(serviceName);\n                        startBundle(serviceContainer, serviceName, moduleMetaData);\n                    }\n                    ROOT_LOGGER.debugf(\"Auto bundles bundles started\");\n                }\n            });\n            builder.addDependencies(servicesInstalled);\n            builder.install();\n\n        } catch (Exception ex) {\n            throw new StartException(MESSAGES.failedToCreateAutoInstallList(), ex);\n        }\n    }","commit_id":"ebb21d201c12e7f57b58def4dd4abe6f5cb02c55","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public void testUpdateAddModule() throws Exception {\n        // This is a fairly involved unit test, but this is unavoidable as the relevant code is quite dependent\n        // on other infrastructure which is being mocked up here.\n\n        // What is being tested here is that the AutoInstallIntegration code correctly responds to new modules\n        // being added through the management console at runtime.\n\n        // First we create a test version of AutoInstallIntegration that intercepts the installModule and startBundle\n        // methods so that it can be checked that they are called.\n        final ServiceName dummyService = ServiceName.of(\"dummy\");\n        final List<OSGiCapability> installedModules = new ArrayList<SubsystemState.OSGiCapability>();\n        final List<OSGiCapability> startedBundles = new ArrayList<SubsystemState.OSGiCapability>();\n        AutoInstallIntegration aii = new AutoInstallIntegration() {\n            @Override\n            ServiceName installModule(BundleManagerService bundleManager, OSGiCapability moduleMetaData) {\n                installedModules.add(moduleMetaData);\n                return dummyService;\n            }\n\n            @Override\n            void startBundle(ServiceContainer serviceContainer, ServiceName serviceName, OSGiCapability moduleMetaData) {\n                startedBundles.add(moduleMetaData);\n            }\n        };\n\n        // Now we set up the SubsystemState object.\n        List<OSGiCapability> modules = new ArrayList<SubsystemState.OSGiCapability>();\n        ModuleIdentifier id = ModuleIdentifier.fromString(\"abc\");\n        OSGiCapability module = new OSGiCapability(id, null);\n        modules.add(module);\n        SubsystemState state = Mockito.mock(SubsystemState.class);\n        Mockito.when(state.getCapabilities()).thenReturn(modules);\n\n        // Provide some mock injected services into AutoInstallIntegration\n        aii.injectedSubsystemState.setValue(new ImmediateValue<SubsystemState>(state));\n        aii.injectedBundleManager.setValue(Mockito.mock(BundleManagerService.class));\n\n        // Here we create a mock serviceController that allows us to catch the (temporary) service\n        // created by the update and start it later from inside this test.\n        final List<Service<?>> addedServices = new ArrayList<Service<?>>(); // the caught services\n        final ServiceBuilder<Void> builder = Mockito.mock(ServiceBuilder.class);\n        ServiceContainer container = Mockito.mock(ServiceContainer.class);\n        Mockito.when(container.addService((ServiceName) Mockito.any(), (Service<?>) Mockito.any())).thenAnswer(\n            new Answer<ServiceBuilder<Void>>() {\n                @Override\n                public ServiceBuilder<Void> answer(InvocationOnMock invocation) throws Throwable {\n                    addedServices.add((Service<?>) invocation.getArguments()[1]);\n                    return builder;\n                }\n        });\n        ServiceController<?> controller = Mockito.mock(ServiceController.class);\n        Mockito.when(controller.getServiceContainer()).thenReturn(container);\n        aii.serviceController = controller;\n\n        // Do the actual Observer invocation on the AutoInstallIntegration object.\n        SubsystemState.ChangeEvent event = new SubsystemState.ChangeEvent(SubsystemState.ChangeType.CAPABILITY, false, id.toString());\n        aii.update(null, event);\n\n        Assert.assertEquals(\"The new module should have been installed in the system\",\n            1, installedModules.size());\n        Assert.assertEquals(module, installedModules.get(0));\n        Assert.assertEquals(\"The new bundle is not yet started, this is done in a service instead\",\n            0, startedBundles.size());\n        Mockito.verify(builder).addDependency(dummyService);\n        Mockito.verify(builder).install();\n\n        // Now we're going to check that the service that was created inside aii.update() works correctly...\n        // First, mock up a separate ServiceController, specific to the service created in aii.update()\n        ServiceController innerController = Mockito.mock(ServiceController.class);\n        StartContext context = Mockito.mock(StartContext.class);\n        Mockito.when(context.getController()).thenReturn(innerController);\n        Assert.assertEquals(1, addedServices.size());\n\n        // Call start() on the service, which should do its work...\n        addedServices.get(0).start(context);\n\n        Assert.assertEquals(\"The bundle should have been started\", 1, startedBundles.size());\n        Assert.assertEquals(module, startedBundles.get(0));\n        // The service should have been removed again after doing its work.\n        Mockito.verify(innerController).setMode(Mode.REMOVE);\n    }","id":23502,"modified_method":"@Test\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public void testUpdateAddModule() throws Exception {\n        // This is a fairly involved unit test, but this is unavoidable as the relevant code is quite dependent\n        // on other infrastructure which is being mocked up here.\n\n        // What is being tested here is that the AutoInstallIntegration code correctly responds to new modules\n        // being added through the management console at runtime.\n\n        // First we create a test version of AutoInstallIntegration that intercepts the installModule and startBundle\n        // methods so that it can be checked that they are called.\n        final ServiceName dummyService = ServiceName.of(\"dummy\");\n        final List<OSGiCapability> installedModules = new ArrayList<SubsystemState.OSGiCapability>();\n        final List<OSGiCapability> startedBundles = new ArrayList<SubsystemState.OSGiCapability>();\n        AutoInstallIntegration aii = new AutoInstallIntegration() {\n            @Override\n            ServiceName installModule(BundleManagerService bundleManager, OSGiCapability moduleMetaData) {\n                installedModules.add(moduleMetaData);\n                return dummyService;\n            }\n\n            @Override\n            void startBundle(ServiceContainer serviceContainer, ServiceName serviceName, OSGiCapability moduleMetaData) {\n                startedBundles.add(moduleMetaData);\n            }\n        };\n\n        // Now we set up the SubsystemState object.\n        List<OSGiCapability> modules = new ArrayList<SubsystemState.OSGiCapability>();\n        OSGiCapability module = new OSGiCapability(\"abc\", null);\n        modules.add(module);\n        SubsystemState state = Mockito.mock(SubsystemState.class);\n        Mockito.when(state.getCapabilities()).thenReturn(modules);\n\n        // Provide some mock injected services into AutoInstallIntegration\n        aii.injectedSubsystemState.setValue(new ImmediateValue<SubsystemState>(state));\n        aii.injectedBundleManager.setValue(Mockito.mock(BundleManagerService.class));\n\n        // Here we create a mock serviceController that allows us to catch the (temporary) service\n        // created by the update and start it later from inside this test.\n        final List<Service<?>> addedServices = new ArrayList<Service<?>>(); // the caught services\n        final ServiceBuilder<Void> builder = Mockito.mock(ServiceBuilder.class);\n        ServiceContainer container = Mockito.mock(ServiceContainer.class);\n        Mockito.when(container.addService((ServiceName) Mockito.any(), (Service<?>) Mockito.any())).thenAnswer(\n            new Answer<ServiceBuilder<Void>>() {\n                @Override\n                public ServiceBuilder<Void> answer(InvocationOnMock invocation) throws Throwable {\n                    addedServices.add((Service<?>) invocation.getArguments()[1]);\n                    return builder;\n                }\n        });\n        ServiceController<?> controller = Mockito.mock(ServiceController.class);\n        Mockito.when(controller.getServiceContainer()).thenReturn(container);\n        aii.serviceController = controller;\n\n        // Do the actual Observer invocation on the AutoInstallIntegration object.\n        SubsystemState.ChangeEvent event = new SubsystemState.ChangeEvent(SubsystemState.ChangeType.CAPABILITY, false, \"abc\");\n        aii.update(null, event);\n\n        Assert.assertEquals(\"The new module should have been installed in the system\",\n            1, installedModules.size());\n        Assert.assertEquals(module, installedModules.get(0));\n        Assert.assertEquals(\"The new bundle is not yet started, this is done in a service instead\",\n            0, startedBundles.size());\n        Mockito.verify(builder).addDependency(dummyService);\n        Mockito.verify(builder).install();\n\n        // Now we're going to check that the service that was created inside aii.update() works correctly...\n        // First, mock up a separate ServiceController, specific to the service created in aii.update()\n        ServiceController innerController = Mockito.mock(ServiceController.class);\n        StartContext context = Mockito.mock(StartContext.class);\n        Mockito.when(context.getController()).thenReturn(innerController);\n        Assert.assertEquals(1, addedServices.size());\n\n        // Call start() on the service, which should do its work...\n        addedServices.get(0).start(context);\n\n        Assert.assertEquals(\"The bundle should have been started\", 1, startedBundles.size());\n        Assert.assertEquals(module, startedBundles.get(0));\n        // The service should have been removed again after doing its work.\n        Mockito.verify(innerController).setMode(Mode.REMOVE);\n    }","commit_id":"ebb21d201c12e7f57b58def4dd4abe6f5cb02c55","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler,\n            List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        ModelNode slNode = null;\n        if (operation.has(ModelConstants.STARTLEVEL)) {\n            slNode = operation.get(ModelConstants.STARTLEVEL);\n            model.get(ModelConstants.STARTLEVEL).set(slNode);\n        }\n        final Integer startLevel = (slNode != null ? slNode.asInt() : null);\n\n        String identifier = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(ModelConstants.CAPABILITY).asString();\n        OSGiCapability module = new OSGiCapability(ModuleIdentifier.fromString(identifier), startLevel);\n\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null) {\n            subsystemState.addCapability(module);\n        }\n    }","id":23503,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler,\n            List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        ModelNode slNode = null;\n        if (operation.has(ModelConstants.STARTLEVEL)) {\n            slNode = operation.get(ModelConstants.STARTLEVEL);\n            model.get(ModelConstants.STARTLEVEL).set(slNode);\n        }\n        final Integer startLevel = (slNode != null ? slNode.asInt() : null);\n\n        String identifier = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(ModelConstants.CAPABILITY).asString();\n        OSGiCapability module = new OSGiCapability(identifier, startLevel);\n\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null) {\n            subsystemState.addCapability(module);\n        }\n    }","commit_id":"ebb21d201c12e7f57b58def4dd4abe6f5cb02c55","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testOSGiCapabilityAddRemove() throws Exception {\n        SubsystemState stateService = new SubsystemState();\n        List<OperationStepHandler> addedSteps = new ArrayList<OperationStepHandler>();\n        OperationContext context = mockOperationContext(stateService, addedSteps, OperationContext.ResultAction.KEEP);\n\n        ModelNode op = getAddOperation(\"org.acme.module1\", 4);\n\n        Assert.assertEquals(\"Precondition\", 0, addedSteps.size());\n        execute(OSGiCapabilityAdd.INSTANCE, context, op);\n        Assert.assertEquals(1, addedSteps.size());\n\n        Assert.assertEquals(\"Precondition\", 0, stateService.getCapabilities().size());\n        execute(addedSteps.get(0), context, op);\n        Assert.assertEquals(1, stateService.getCapabilities().size());\n        OSGiCapability module = stateService.getCapabilities().get(0);\n        Assert.assertEquals(\"org.acme.module1:main\", module.getIdentifier().toString());\n        Assert.assertEquals(new Integer(4), module.getStartLevel());\n\n        execute(OSGiCapabilityRemove.INSTANCE, context, op);\n        Assert.assertEquals(\"Actual remove added as async step\", 2, addedSteps.size());\n\n        configureForRollback(context, op);\n        execute(addedSteps.get(1), context, op);\n        Assert.assertEquals(\"Module should have been kept as the operation was rolled back\", module, stateService.getCapabilities().get(0));\n\n        configureForSuccess(context);\n        execute(addedSteps.get(1), context, op);\n        Assert.assertEquals(\"Module should have been removed\", 0, stateService.getCapabilities().size());\n    }","id":23504,"modified_method":"@Test\n    public void testOSGiCapabilityAddRemove() throws Exception {\n        SubsystemState stateService = new SubsystemState();\n        List<OperationStepHandler> addedSteps = new ArrayList<OperationStepHandler>();\n        OperationContext context = mockOperationContext(stateService, addedSteps, OperationContext.ResultAction.KEEP);\n\n        ModelNode op = getAddOperation(\"org.acme.module1\", 4);\n\n        Assert.assertEquals(\"Precondition\", 0, addedSteps.size());\n        execute(OSGiCapabilityAdd.INSTANCE, context, op);\n        Assert.assertEquals(1, addedSteps.size());\n\n        Assert.assertEquals(\"Precondition\", 0, stateService.getCapabilities().size());\n        execute(addedSteps.get(0), context, op);\n        Assert.assertEquals(1, stateService.getCapabilities().size());\n        OSGiCapability module = stateService.getCapabilities().get(0);\n        Assert.assertEquals(\"org.acme.module1\", module.getIdentifier());\n        Assert.assertEquals(new Integer(4), module.getStartLevel());\n\n        execute(OSGiCapabilityRemove.INSTANCE, context, op);\n        Assert.assertEquals(\"Actual remove added as async step\", 2, addedSteps.size());\n\n        configureForRollback(context, op);\n        execute(addedSteps.get(1), context, op);\n        Assert.assertEquals(\"Module should have been kept as the operation was rolled back\", module, stateService.getCapabilities().get(0));\n\n        configureForSuccess(context);\n        execute(addedSteps.get(1), context, op);\n        Assert.assertEquals(\"Module should have been removed\", 0, stateService.getCapabilities().size());\n    }","commit_id":"ebb21d201c12e7f57b58def4dd4abe6f5cb02c55","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ModuleIdentifier getIdentifier() {\n            return identifier;\n        }","id":23505,"modified_method":"public String getIdentifier() {\n            return identifier;\n        }","commit_id":"ebb21d201c12e7f57b58def4dd4abe6f5cb02c55","url":"https://github.com/wildfly/wildfly"},{"original_method":"public OSGiCapability(ModuleIdentifier identifier, Integer startlevel) {\n            this.identifier = identifier;\n            this.startlevel = startlevel;\n        }","id":23506,"modified_method":"public OSGiCapability(String identifier, Integer startlevel) {\n            this.identifier = identifier;\n            this.startlevel = startlevel;\n        }","commit_id":"ebb21d201c12e7f57b58def4dd4abe6f5cb02c55","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testModules() {\n        SubsystemState state = new SubsystemState();\n\n        final List<Observable> observables = new ArrayList<Observable>();\n        final List<Object> arguments = new ArrayList<Object>();\n        Observer o = new Observer() {\n            @Override\n            public void update(Observable o, Object arg) {\n                observables.add(o);\n                arguments.add(arg);\n            }\n        };\n        state.addObserver(o);\n\n        Assert.assertEquals(\"Precondition\", 0, state.getCapabilities().size());\n\n        Assert.assertEquals(\"Precondition\", 0, arguments.size());\n        ModuleIdentifier id = ModuleIdentifier.fromString(\"hi\");\n        SubsystemState.OSGiCapability m = new SubsystemState.OSGiCapability(id, 3);\n        state.addCapability(m);\n\n        Assert.assertEquals(1, arguments.size());\n        SubsystemState.ChangeEvent event = (SubsystemState.ChangeEvent) arguments.get(0);\n        assertEventEquals(id.toString(), false, SubsystemState.ChangeType.CAPABILITY, event);\n\n        Assert.assertEquals(Collections.singletonList(m), state.getCapabilities());\n\n        Assert.assertNull(state.removeCapability(\"abc\"));\n        Assert.assertEquals(Collections.singletonList(m), state.getCapabilities());\n\n        Assert.assertEquals(m, state.removeCapability(\"hi\"));\n\n        Assert.assertEquals(2, arguments.size());\n        SubsystemState.ChangeEvent event2 = (SubsystemState.ChangeEvent) arguments.get(1);\n        assertEventEquals(id.toString(), true, SubsystemState.ChangeType.CAPABILITY, event2);\n\n        Assert.assertEquals(0, state.getCapabilities().size());\n    }","id":23507,"modified_method":"@Test\n    public void testModules() {\n        SubsystemState state = new SubsystemState();\n\n        final List<Observable> observables = new ArrayList<Observable>();\n        final List<Object> arguments = new ArrayList<Object>();\n        Observer o = new Observer() {\n            @Override\n            public void update(Observable o, Object arg) {\n                observables.add(o);\n                arguments.add(arg);\n            }\n        };\n        state.addObserver(o);\n\n        Assert.assertEquals(\"Precondition\", 0, state.getCapabilities().size());\n\n        Assert.assertEquals(\"Precondition\", 0, arguments.size());\n        SubsystemState.OSGiCapability m = new SubsystemState.OSGiCapability(\"hi\", 3);\n        state.addCapability(m);\n\n        Assert.assertEquals(1, arguments.size());\n        SubsystemState.ChangeEvent event = (SubsystemState.ChangeEvent) arguments.get(0);\n        assertEventEquals(\"hi\", false, SubsystemState.ChangeType.CAPABILITY, event);\n\n        Assert.assertEquals(Collections.singletonList(m), state.getCapabilities());\n\n        Assert.assertNull(state.removeCapability(\"abc\"));\n        Assert.assertEquals(Collections.singletonList(m), state.getCapabilities());\n\n        Assert.assertEquals(m, state.removeCapability(\"hi\"));\n\n        Assert.assertEquals(2, arguments.size());\n        SubsystemState.ChangeEvent event2 = (SubsystemState.ChangeEvent) arguments.get(1);\n        assertEventEquals(\"hi\", true, SubsystemState.ChangeType.CAPABILITY, event2);\n\n        Assert.assertEquals(0, state.getCapabilities().size());\n    }","commit_id":"ebb21d201c12e7f57b58def4dd4abe6f5cb02c55","url":"https://github.com/wildfly/wildfly"},{"original_method":"boolean exceptionMatch(AnalyzedToken token) {\n    if (exceptionSet) {\n      return (matchExceptionStringToken(token) != exceptionNegation)\n          && (matchExceptionPosToken(token) != exceptionPosNegation);\n    } else {\n      return false;\n    }\n  }","id":23508,"modified_method":"boolean exceptionMatch(AnalyzedToken token) {\n    boolean exceptionMatched = false;\n    if (exceptionSet) {\n    Iterator<Element> it = exceptionList.iterator();    \n    while (it.hasNext()) {\n      exceptionMatched = exceptionMatched || it.next().match(token);\n      if (exceptionMatched) {\n        break;\n      }\n    }\n    }\n    return exceptionMatched;    \n  }","commit_id":"7ac88d786791b56f039486c3d868214f58c57ede","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void setStringException(String token, boolean regExp, boolean inflected, boolean negation) {\n    exceptionStringToken = token;\n    exceptionRegExp = regExp;\n    exceptionInflected = inflected;\n    exceptionNegation = negation;\n    exceptionSet = true;\n  }","id":23509,"modified_method":"public void setStringException(String token, boolean regExp, boolean inflected, boolean negation, boolean scope) {\n    Element stringException = new Element(token, this.caseSensitive, regExp, inflected);\n    stringException.setNegation(negation);\n    stringException.exceptionValidNext=scope;\n    if (exceptionList == null) {\n      exceptionList = new ArrayList<Element>();\n    }\n    if (!exceptionSet) {\n      exceptionSet = true;          \n    }\n      exceptionList.add(stringException);    \n  }","commit_id":"7ac88d786791b56f039486c3d868214f58c57ede","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void setPosException(String posToken, boolean regExp, boolean negation) {\n    exceptionPosToken = posToken;\n    exceptionPosNegation = negation;\n    exceptionPosRegExp = regExp;\n    exceptionSet = true;\n  }","id":23510,"modified_method":"public void setPosException(String posToken, boolean regExp, boolean negation, boolean scope) {\n      Element posException = new Element(\"\", this.caseSensitive, regExp, false);   \n      posException.setPosElement(posToken, regExp, negation);\n      posException.exceptionValidNext=scope;\n      if (exceptionList == null) {\n        exceptionList = new ArrayList<Element>();\n      }\n      if (!exceptionSet) {\n        exceptionSet = true;  \n      }\n      exceptionList.add(posException);          \n  }","commit_id":"7ac88d786791b56f039486c3d868214f58c57ede","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@SuppressWarnings(\"unused\")\n  public void startElement(String namespaceURI, String lName, String qName, Attributes attrs) throws SAXException {\n\t  if (qName.equals(\"rule\")) {\n\t\t  translations = new ArrayList<StringBuilder>();\n\t\t  id = attrs.getValue(\"id\");\n\t\t  if (inRuleGroup && id == null)\n\t\t\t  id = ruleGroupId;\n\t\t  correctExamples = new ArrayList<String>();\n\t\t  incorrectExamples = new ArrayList<String>();\n\t  } else if (qName.equals(\"pattern\")) {\n\t\t  inPattern = true;\n\t\t  String languageStr = attrs.getValue(\"lang\");\n\t\t  language = Language.getLanguageforShortName(languageStr);\n\t\t  if (language == null) {\n\t\t\t  throw new SAXException(\"Unknown language '\" + languageStr + \"'\");\n\t\t  }\n\t  } else if (qName.equals(\"exception\")) {\n\t    \tinException = true;\n\t    \texceptionSet = true;\n\t    \texceptions = new StringBuffer();\n\t    \t\n\t    \tif (attrs.getValue(\"negate\")!=null) {\n\t\t \t\texceptionStringNegation=attrs.getValue(\"negate\").equals(\"yes\");\n\t    \t}\n\t    \tif (attrs.getValue(\"inflected\")!=null) {\n\t\t \t\texceptionStringInflected=attrs.getValue(\"inflected\").equals(\"yes\");\n\t    \t}\n\t    \tif (attrs.getValue(\"postag\")!=null) {    \t\t\n\t    \t\texceptionPosToken = attrs.getValue(\"postag\");\n\t    \t\tif (attrs.getValue(\"postag_regexp\")!=null) {\n\t    \t\t\texceptionPosRegExp = attrs.getValue(\"postag_regexp\").equals(\"yes\");\n\t    \t\t}\n\t    \t\tif (attrs.getValue(\"negate_pos\")!=null) {\n\t    \t \t\texceptionPosNegation = attrs.getValue(\"negate_pos\").equals(\"yes\");\n\t        \t}    \t \t\n\t    \t}\n\t    \tif (attrs.getValue(\"regexp\")!=null) {\n\t    \t\texceptionStringRegExp = attrs.getValue(\"regexp\").equals(\"yes\");\n\t    \t}\n\t    \t\n\t    } else if (qName.equals(\"token\")) {\n\t\t  inToken = true;\n\t\t  if (attrs.getValue(\"negate\") != null){\n\t\t\t  tokenNegated = attrs.getValue(\"negate\").equals(\"yes\");\n\t\t  }\n\t\t  if (attrs.getValue(\"inflected\") != null){\n\t\t\t  tokenInflected = attrs.getValue(\"inflected\").equals(\"yes\");\n\t\t  }\n\t\t  if (attrs.getValue(\"skip\") != null){\n\t\t\t  skipPos = Integer.parseInt(attrs.getValue(\"skip\"));\n\t\t  }\n\t\t  elements = new StringBuffer();\n\t\t  if (elementList == null) //lazy init\n\t\t  {\n\t\t\t  elementList = new ArrayList<Element>();\n\t\t  }\n\t\t  if (attrs.getValue(\"postag\") != null)\n\t\t  {\n\t\t\t  posToken = attrs.getValue(\"postag\");\n\t\t\t  if (attrs.getValue(\"postag_regexp\") != null){\n\t\t\t\t  regular = attrs.getValue(\"postag_regexp\").equals(\"yes\");\n\t\t\t  }\n\t\t\t  if (attrs.getValue(\"negate_pos\") != null){\n\t\t\t\t  posNegation = (attrs.getValue(\"negate_pos\").equals(\"yes\"));\n\t\t\t  }\n\t\t\t  \n\t\t\t  if (elementList == null) { //lazy init\n\t\t\t\t  elementList = new ArrayList<Element>();\n\t\t\t  }\n\t\t  }\n\t\t  if (attrs.getValue(\"regexp\") != null){\n\t\t\t  regExpression = attrs.getValue(\"regexp\").equals(\"yes\");\n\t\t  }\n\t\t  \n\t  } else if (qName.equals(\"translation\")) {\n\t\t  inTranslation = true;\n\t\t  String languageStr = attrs.getValue(\"lang\");\n      Language tmpLang = Language.getLanguageforShortName(languageStr);\n      currentTranslationLanguage = tmpLang;\n      if (tmpLang == motherTongue) {\n        translationLanguage = tmpLang;\n        if (translationLanguage == null) {\n          throw new SAXException(\"Unknown language '\" + languageStr + \"'\");\n        }\n      }\n\t  } else if (qName.equals(\"example\") && attrs.getValue(\"type\").equals(\"correct\")) {\n\t\t  inCorrectExample = true;\n\t\t  correctExample = new StringBuffer();\n\t  } else if (qName.equals(\"example\") && attrs.getValue(\"type\").equals(\"incorrect\")) {\n\t\t  inIncorrectExample = true;\n\t\t  incorrectExample = new StringBuffer();\n\t  } else if (qName.equals(\"message\")) {\n\t\t  inMessage = true;\n\t\t  message = new StringBuffer();\n\t  } else if (qName.equals(\"rulegroup\")) {\n\t\t  ruleGroupId = attrs.getValue(\"id\");\n\t\t  inRuleGroup = true;\n\t  }\n  }","id":23511,"modified_method":"@SuppressWarnings(\"unused\")\n  public void startElement(String namespaceURI, String lName, String qName, Attributes attrs) throws SAXException {\n\t  if (qName.equals(\"rule\")) {\n\t\t  translations = new ArrayList<StringBuilder>();\n\t\t  id = attrs.getValue(\"id\");\n\t\t  if (inRuleGroup && id == null)\n\t\t\t  id = ruleGroupId;\n\t\t  correctExamples = new ArrayList<String>();\n\t\t  incorrectExamples = new ArrayList<String>();\n\t  } else if (qName.equals(\"pattern\")) {\n\t\t  inPattern = true;\n\t\t  String languageStr = attrs.getValue(\"lang\");\n\t\t  language = Language.getLanguageforShortName(languageStr);\n\t\t  if (language == null) {\n\t\t\t  throw new SAXException(\"Unknown language '\" + languageStr + \"'\");\n\t\t  }\n\t  } else if (qName.equals(\"exception\")) {\n\t    \tinException = true;\n\t    \texceptionSet = true;\n\t    \texceptions = new StringBuffer();\n\t    \t\n\t    \tif (attrs.getValue(\"negate\")!=null) {\n\t\t \t\texceptionStringNegation=attrs.getValue(\"negate\").equals(\"yes\");\n\t    \t}\n            if (attrs.getValue(\"scope\") != null) {\n              exceptionValidNext = attrs.getValue(\"scope\").equals(\"next\");\n            }\n\t    \tif (attrs.getValue(\"inflected\")!=null) {\n\t\t \t\texceptionStringInflected=attrs.getValue(\"inflected\").equals(\"yes\");\n\t    \t}\n\t    \tif (attrs.getValue(\"postag\")!=null) {    \t\t\n\t    \t\texceptionPosToken = attrs.getValue(\"postag\");\n\t    \t\tif (attrs.getValue(\"postag_regexp\")!=null) {\n\t    \t\t\texceptionPosRegExp = attrs.getValue(\"postag_regexp\").equals(\"yes\");\n\t    \t\t}\n\t    \t\tif (attrs.getValue(\"negate_pos\")!=null) {\n\t    \t \t\texceptionPosNegation = attrs.getValue(\"negate_pos\").equals(\"yes\");\n\t        \t}    \t \t\n\t    \t}\n\t    \tif (attrs.getValue(\"regexp\")!=null) {\n\t    \t\texceptionStringRegExp = attrs.getValue(\"regexp\").equals(\"yes\");\n\t    \t}\n\t    \t\n\t    } else if (qName.equals(\"token\")) {\n\t\t  inToken = true;\n\t\t  if (attrs.getValue(\"negate\") != null){\n\t\t\t  tokenNegated = attrs.getValue(\"negate\").equals(\"yes\");\n\t\t  }\n\t\t  if (attrs.getValue(\"inflected\") != null){\n\t\t\t  tokenInflected = attrs.getValue(\"inflected\").equals(\"yes\");\n\t\t  }\n\t\t  if (attrs.getValue(\"skip\") != null){\n\t\t\t  skipPos = Integer.parseInt(attrs.getValue(\"skip\"));\n\t\t  }\n\t\t  elements = new StringBuffer();\n\t\t  if (elementList == null) //lazy init\n\t\t  {\n\t\t\t  elementList = new ArrayList<Element>();\n\t\t  }\n\t\t  if (attrs.getValue(\"postag\") != null)\n\t\t  {\n\t\t\t  posToken = attrs.getValue(\"postag\");\n\t\t\t  if (attrs.getValue(\"postag_regexp\") != null){\n\t\t\t\t  regular = attrs.getValue(\"postag_regexp\").equals(\"yes\");\n\t\t\t  }\n\t\t\t  if (attrs.getValue(\"negate_pos\") != null){\n\t\t\t\t  posNegation = (attrs.getValue(\"negate_pos\").equals(\"yes\"));\n\t\t\t  }\n\t\t\t  \n\t\t\t  if (elementList == null) { //lazy init\n\t\t\t\t  elementList = new ArrayList<Element>();\n\t\t\t  }\n\t\t  }\n\t\t  if (attrs.getValue(\"regexp\") != null){\n\t\t\t  regExpression = attrs.getValue(\"regexp\").equals(\"yes\");\n\t\t  }\n\t\t  \n\t  } else if (qName.equals(\"translation\")) {\n\t\t  inTranslation = true;\n\t\t  String languageStr = attrs.getValue(\"lang\");\n      Language tmpLang = Language.getLanguageforShortName(languageStr);\n      currentTranslationLanguage = tmpLang;\n      if (tmpLang == motherTongue) {\n        translationLanguage = tmpLang;\n        if (translationLanguage == null) {\n          throw new SAXException(\"Unknown language '\" + languageStr + \"'\");\n        }\n      }\n\t  } else if (qName.equals(\"example\") && attrs.getValue(\"type\").equals(\"correct\")) {\n\t\t  inCorrectExample = true;\n\t\t  correctExample = new StringBuffer();\n\t  } else if (qName.equals(\"example\") && attrs.getValue(\"type\").equals(\"incorrect\")) {\n\t\t  inIncorrectExample = true;\n\t\t  incorrectExample = new StringBuffer();\n\t  } else if (qName.equals(\"message\")) {\n\t\t  inMessage = true;\n\t\t  message = new StringBuffer();\n\t  } else if (qName.equals(\"rulegroup\")) {\n\t\t  ruleGroupId = attrs.getValue(\"id\");\n\t\t  inRuleGroup = true;\n\t  }\n  }","commit_id":"7ac88d786791b56f039486c3d868214f58c57ede","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@SuppressWarnings(\"unused\")\n  public void endElement(String namespaceURI, String sName, String qName) {\n\t  if (qName.equals(\"rule\")) {\n\t\t  if (language == textLanguage && translationLanguage != null && translationLanguage == motherTongue) {\n\t\t\t  formatter.applyPattern(messages.getString(\"false_friend_hint\"));\n\t\t\t  Object[] messageArguments = {\n\t\t\t\t\t  elements.toString().replace('|', '/'),\n            messages.getString(textLanguage.getShortName()),\n\t\t\t\t\t  formatTranslations(translations),\n            messages.getString(motherTongue.getShortName())\n\t\t\t  };\n\t\t\t  String description = formatter.format(messageArguments);\n\t\t\t  PatternRule rule = new PatternRule(id, language, elementList, \n\t\t\t\t\t  messages.getString(\"false_friend_desc\") + \" \" + elements.toString().replace('|', '/'),\n\t\t\t\t\t  description);\n\t\t\t  rule.setCorrectExamples(correctExamples);\n\t\t\t  rule.setIncorrectExamples(incorrectExamples);\n\t\t\t  rules.add(rule);\n\t\t  }\n\t\t  \n      if (suggestions.size() > 0) {\n        List<String> l = new ArrayList<String>(suggestions);\n        suggestionMap.put(id, l);\n        suggestions.clear();\n      }\n\t\t  if (elementList != null) {\n\t\t\t  elementList.clear();\n\t\t  }\n\t\t  \n\t  } else if (qName.equals(\"exception\")) {    \t\n\t    \tinException = false;    \t\n\t  } else if (qName.equals(\"token\")) {\n\t\t  if (inToken)\n\t\t  {\n\t\t\t  Element stringElement = new Element(elements.toString(), caseSensitive, regExpression, tokenInflected);\n\t\t\t  stringElement.setNegation(tokenNegated);\n\t\t\t  if (skipPos!=0) {\n\t\t\t\t  stringElement.setSkipNext(skipPos);\n\t\t\t\t  skipPos = 0;\n\t\t\t  }\n\t\t\t  if (posToken!=null) {\n\t\t\t \t\tstringElement.setPosElement(posToken, regular, posNegation);\n\t\t\t \t\tposToken = null;\n\t\t\t \t}\n\t\t\t  \n\t\t\t  if (exceptionSet) {\n\t\t    \t\tstringElement.setStringException(exceptions.toString(), exceptionStringRegExp, exceptionStringInflected, exceptionStringNegation);\n\t\t    \t\texceptionSet = false;\n\t\t    \t}\n\t\t    \tif (exceptionPosToken!=null) {\n\t\t    \t\tstringElement.setPosException(exceptionPosToken, exceptionPosRegExp, exceptionPosNegation);\n\t\t    \t\texceptionPosToken = null;\n\t\t    \t}\n\t\t    \n\t\t\t  elementList.add(stringElement);\n\t\t\t  tokenNegated = false;\n\t\t\t  tokenInflected = false;\n\t\t\t  posNegation = false;\n\t\t      regular = false;\n\t\t  }\n\t\t  inToken = false;\n\t\t  regExpression = false;\n\t\t  \n\t\t  exceptionStringNegation = false;\n\t\t  exceptionStringInflected = false;\n\t\t  exceptionPosNegation = false;\n\t\t  exceptionPosRegExp = false;\n\t\t  exceptionStringRegExp = false;\n\t\t  \n\t  } else if (qName.equals(\"pattern\")) {\n\t\t  inPattern = false;\n\t  } else if (qName.equals(\"translation\")) {\n      if (currentTranslationLanguage == motherTongue) {\n        translations.add(translation);\n      }\n      if (currentTranslationLanguage == textLanguage) {\n        suggestions.add(translation.toString());\n      }\n      translation = new StringBuilder();\n\t\t  inTranslation = false;\n      currentTranslationLanguage = null;\n\t  } else if (qName.equals(\"example\")) {\n\t\t  if (inCorrectExample) {\n\t\t\t  correctExamples.add(correctExample.toString());\n\t\t  } else if (inIncorrectExample) {\n\t\t\t  incorrectExamples.add(incorrectExample.toString());\n\t\t  }\n\t\t  inCorrectExample = false;\n\t\t  inIncorrectExample = false;\n\t\t  correctExample = new StringBuffer();\n\t\t  incorrectExample = new StringBuffer();\n\t  } else if (qName.equals(\"message\")) {\n\t\t  inMessage = false;\n\t  } else if (qName.equals(\"rulegroup\")) {\n\t\t  inRuleGroup = false;\n\t  }\n  }","id":23512,"modified_method":"@SuppressWarnings(\"unused\")\n  public void endElement(String namespaceURI, String sName, String qName) {\n\t  if (qName.equals(\"rule\")) {\n\t\t  if (language == textLanguage && translationLanguage != null && translationLanguage == motherTongue) {\n\t\t\t  formatter.applyPattern(messages.getString(\"false_friend_hint\"));\n\t\t\t  Object[] messageArguments = {\n\t\t\t\t\t  elements.toString().replace('|', '/'),\n            messages.getString(textLanguage.getShortName()),\n\t\t\t\t\t  formatTranslations(translations),\n            messages.getString(motherTongue.getShortName())\n\t\t\t  };\n\t\t\t  String description = formatter.format(messageArguments);\n\t\t\t  PatternRule rule = new PatternRule(id, language, elementList, \n\t\t\t\t\t  messages.getString(\"false_friend_desc\") + \" \" + elements.toString().replace('|', '/'),\n\t\t\t\t\t  description);\n\t\t\t  rule.setCorrectExamples(correctExamples);\n\t\t\t  rule.setIncorrectExamples(incorrectExamples);\n\t\t\t  rules.add(rule);\n\t\t  }\n\t\t  \n      if (suggestions.size() > 0) {\n        List<String> l = new ArrayList<String>(suggestions);\n        suggestionMap.put(id, l);\n        suggestions.clear();\n      }\n\t\t  if (elementList != null) {\n\t\t\t  elementList.clear();\n\t\t  }\n\t\t  \n\t  } else if (qName.equals(\"exception\")) {    \t\n\t    \tinException = false;\n             if (!exceptionSet) {\n                  stringElement = new Element(elements.toString(), caseSensitive, regExpression,\n                      tokenInflected);\n                  exceptionSet = true;\n                  }\n                  stringElement.setNegation(tokenNegated);\n                    if (!exceptions.toString().equals(\"\")) {\n                    stringElement.setStringException(exceptions.toString(), exceptionStringRegExp, \n                        exceptionStringInflected, exceptionStringNegation, exceptionValidNext);\n                    }              \n                  if (exceptionPosToken != null) {\n                    stringElement.setPosException(exceptionPosToken, exceptionPosRegExp, exceptionPosNegation, exceptionValidNext);\n                    exceptionPosToken = null;\n                  }\n\t  } else if (qName.equals(\"token\")) {\n\t\t  if (inToken)\n\t\t  {\n            if (!exceptionSet || stringElement==null) {\n              stringElement = new Element(elements.toString(), caseSensitive, regExpression,\n                  tokenInflected);\n              stringElement.setNegation(tokenNegated);\n              } else {\n                stringElement.setStringElement(elements.toString());\n              }\n\t\t\t  if (skipPos!=0) {\n\t\t\t\t  stringElement.setSkipNext(skipPos);\n\t\t\t\t  skipPos = 0;\n\t\t\t  }\n\t\t\t  if (posToken!=null) {\n\t\t\t \t\tstringElement.setPosElement(posToken, regular, posNegation);\n\t\t\t \t\tposToken = null;\n\t\t\t \t}\n\t\t\t  \t\t\t  \t\t    \n\t\t\t  elementList.add(stringElement);\n\t\t\t  tokenNegated = false;\n\t\t\t  tokenInflected = false;\n\t\t\t  posNegation = false;\n\t\t      regular = false;\n              exceptionValidNext = true;\n\t\t  }\n\t\t  inToken = false;\n\t\t  regExpression = false;\n\t\t  \n\t\t  exceptionStringNegation = false;\n\t\t  exceptionStringInflected = false;\n\t\t  exceptionPosNegation = false;\n\t\t  exceptionPosRegExp = false;\n\t\t  exceptionStringRegExp = false;\n\t\t  \n\t  } else if (qName.equals(\"pattern\")) {\n\t\t  inPattern = false;\n\t  } else if (qName.equals(\"translation\")) {\n      if (currentTranslationLanguage == motherTongue) {\n        translations.add(translation);\n      }\n      if (currentTranslationLanguage == textLanguage) {\n        suggestions.add(translation.toString());\n      }\n      translation = new StringBuilder();\n\t\t  inTranslation = false;\n      currentTranslationLanguage = null;\n\t  } else if (qName.equals(\"example\")) {\n\t\t  if (inCorrectExample) {\n\t\t\t  correctExamples.add(correctExample.toString());\n\t\t  } else if (inIncorrectExample) {\n\t\t\t  incorrectExamples.add(incorrectExample.toString());\n\t\t  }\n\t\t  inCorrectExample = false;\n\t\t  inIncorrectExample = false;\n\t\t  correctExample = new StringBuffer();\n\t\t  incorrectExample = new StringBuffer();\n\t  } else if (qName.equals(\"message\")) {\n\t\t  inMessage = false;\n\t  } else if (qName.equals(\"rulegroup\")) {\n\t\t  inRuleGroup = false;\n\t  }\n  }","commit_id":"7ac88d786791b56f039486c3d868214f58c57ede","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public RuleMatch[] match(AnalyzedSentence text) {\n    List<RuleMatch> ruleMatches = new ArrayList<RuleMatch>();\n    AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();\n    \n    int tokenPos = 0;\n    int prevSkipNext = 0;\n    int skipNext = 0;\n    int matchPos = 0;\n    int skipShift = 0;\n    \n    int firstMatchToken = -1;\n    int lastMatchToken = -1;\n    Element elem = null, prevElement = null;\n    \n    for (int i = 0; i < tokens.length; i++) {\n      boolean allElementsMatch = true;\n      \n      int matchingTokens = 0;\n      for (int k = 0; k < patternElements.size(); k++) {\n        if (elem!=null) { \n          prevElement = elem;\n        }\n        elem = patternElements.get(k);\n        skipNext = elem.getSkipNext();\n        int nextPos = tokenPos + k + skipShift;\n        if (nextPos >= tokens.length) {\n          allElementsMatch = false;\n          break;\n        }\n        boolean skipMatch = false, exceptionMatched = false;\n        if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) { // SENT_END?\n          prevSkipNext = tokens.length - (nextPos + 1);\n        }\n        for (int m = nextPos; m <= nextPos + prevSkipNext; m++) {\n          boolean matched = false;\n          for (int l = 0; l < tokens[m].getReadingsLength(); l++) {\n            \n            AnalyzedToken matchToken = tokens[m].getAnalyzedToken(l);\n            \n            if (prevSkipNext >0 && prevElement!=null) {\n              if (prevElement.exceptionMatch(matchToken)) {\n                exceptionMatched = true;\n              }               \n            }\n            \n            exceptionMatched=exceptionMatched || elem.exceptionMatch(matchToken);\n            // Logical OR (cannot be AND):\n            if (!(elem.match(matchToken)&& !exceptionMatched)) {             \n              matched = matched || false;\n            } else {              \n            matched = true;\n            matchPos = m;\n            skipShift = matchPos - nextPos;\n          }\n          skipMatch = (skipMatch || matched) && !exceptionMatched;\n          \n        }\n        if (skipMatch) {\n          break;\n        }\n        }\n        allElementsMatch = skipMatch;\n        if (skipMatch) {\n          prevSkipNext = skipNext;        \n        } else {\n          prevSkipNext = 0;\n        }\n        if (!allElementsMatch) {\n          break;\n        } else {\n          matchingTokens++;\n          lastMatchToken = matchPos; // nextPos;\n          if (firstMatchToken == -1)\n            firstMatchToken = matchPos; // nextPos;\n        }\n      }\n    \n      if (allElementsMatch) {\n        String errMessage = message;\n        // TODO: implement skipping tokens while marking error tokens\n        // replace back references like \\1 in message:\n        for (int j = 0; j < matchingTokens; j++) {\n          errMessage = errMessage.replaceAll(\"\\\\\\\\\" + (j + 1), tokens[firstMatchToken + j]\n                                                                      .getToken());\n        }\n        boolean startsWithUppercase = StringTools.startsWithUppercase(tokens[firstMatchToken\n                                                                             + startPositionCorrection].toString());\n        RuleMatch ruleMatch = new RuleMatch(this, tokens[firstMatchToken + startPositionCorrection]\n                                                         .getStartPos(), tokens[lastMatchToken + endPositionCorrection].getStartPos()\n                                                         + tokens[lastMatchToken + endPositionCorrection].getToken().length(), errMessage,\n                                                         startsWithUppercase);\n        ruleMatches.add(ruleMatch);\n      } else {\n        firstMatchToken = -1;\n        lastMatchToken = -1;\n      }      \n      tokenPos++;\n    }\n    \n    return (RuleMatch[]) ruleMatches.toArray(new RuleMatch[0]);\n  }","id":23513,"modified_method":"public RuleMatch[] match(AnalyzedSentence text) {\n    List<RuleMatch> ruleMatches = new ArrayList<RuleMatch>();\n    AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();\n    \n    int tokenPos = 0;\n    int prevSkipNext = 0;\n    int skipNext = 0;\n    int matchPos = 0;\n    int skipShift = 0;\n    \n    int firstMatchToken = -1;\n    int lastMatchToken = -1;\n    Element elem = null, prevElement = null;\n    \n    for (int i = 0; i < tokens.length; i++) {\n      boolean allElementsMatch = true;\n      \n      int matchingTokens = 0;\n      for (int k = 0; k < patternElements.size(); k++) {\n        if (elem!=null) { \n          prevElement = elem;\n        }\n        elem = patternElements.get(k);\n        skipNext = elem.getSkipNext();\n        int nextPos = tokenPos + k + skipShift;\n        if (nextPos >= tokens.length) {\n          allElementsMatch = false;\n          break;\n        }\n        boolean skipMatch = false, exceptionMatched = false;\n        if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) { // SENT_END?\n          prevSkipNext = tokens.length - (nextPos + 1);\n        }\n        for (int m = nextPos; m <= nextPos + prevSkipNext; m++) {\n          boolean matched = false;\n          for (int l = 0; l < tokens[m].getReadingsLength(); l++) {\n            \n            AnalyzedToken matchToken = tokens[m].getAnalyzedToken(l);\n            \n            if (prevSkipNext >0 && prevElement!=null) {\n              if (prevElement.exceptionMatch(matchToken) && prevElement.exceptionValid()) {\n                exceptionMatched = true;\n              }               \n            }\n            \n            exceptionMatched=exceptionMatched || elem.exceptionMatch(matchToken);\n            // Logical OR (cannot be AND):\n            if (!(elem.match(matchToken)&& !exceptionMatched)) {             \n              matched = matched || false;\n            } else {              \n            matched = true;\n            matchPos = m;\n            skipShift = matchPos - nextPos;\n          }\n          skipMatch = (skipMatch || matched) && !exceptionMatched;\n          \n        }\n        if (skipMatch) {\n          break;\n        }\n        }\n        allElementsMatch = skipMatch;\n        if (skipMatch) {\n          prevSkipNext = skipNext;        \n        } else {\n          prevSkipNext = 0;\n        }\n        if (!allElementsMatch) {\n          break;\n        } else {\n          matchingTokens++;\n          lastMatchToken = matchPos; // nextPos;\n          if (firstMatchToken == -1)\n            firstMatchToken = matchPos; // nextPos;\n        }\n      }\n    \n      if (allElementsMatch) {\n        String errMessage = message;\n        // TODO: implement skipping tokens while marking error tokens\n        // replace back references like \\1 in message:\n        for (int j = 0; j < matchingTokens; j++) {\n          errMessage = errMessage.replaceAll(\"\\\\\\\\\" + (j + 1), tokens[firstMatchToken + j]\n                                                                      .getToken());\n        }\n        boolean startsWithUppercase = StringTools.startsWithUppercase(tokens[firstMatchToken\n                                                                             + startPositionCorrection].toString());\n        RuleMatch ruleMatch = new RuleMatch(this, tokens[firstMatchToken + startPositionCorrection]\n                                                         .getStartPos(), tokens[lastMatchToken + endPositionCorrection].getStartPos()\n                                                         + tokens[lastMatchToken + endPositionCorrection].getToken().length(), errMessage,\n                                                         startsWithUppercase);\n        ruleMatches.add(ruleMatch);\n      } else {\n        firstMatchToken = -1;\n        lastMatchToken = -1;\n      }      \n      tokenPos++;\n    }\n    \n    return (RuleMatch[]) ruleMatches.toArray(new RuleMatch[0]);\n  }","commit_id":"7ac88d786791b56f039486c3d868214f58c57ede","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@SuppressWarnings(\"unused\")\n  public void startElement(String namespaceURI, String lName, String qName, Attributes attrs)\n      throws SAXException {\n    if (qName.equals(\"category\")) {\n      String catName = attrs.getValue(\"name\");\n      String prioStr = attrs.getValue(\"priority\");\n      int prio = 0;\n      if (prioStr != null)\n        category = new Category(catName, Integer.parseInt(prioStr));\n      else\n        category = new Category(catName);\n    } else if (qName.equals(\"rules\")) {\n      String languageStr = attrs.getValue(\"lang\");\n      language = Language.getLanguageforShortName(languageStr);\n      if (language == null) {\n        throw new SAXException(\"Unknown language '\" + languageStr + \"'\");\n      }\n    } else if (qName.equals(\"rule\")) {\n      id = attrs.getValue(\"id\");\n      if (inRuleGroup && id == null)\n        id = ruleGroupId;\n      description = attrs.getValue(\"name\");\n      if (inRuleGroup && description == null)\n        description = ruleGroupDescription;\n      correctExamples = new ArrayList<String>();\n      incorrectExamples = new ArrayList<String>();\n    } else if (qName.equals(\"pattern\")) {\n      inPattern = true;\n      if (attrs.getValue(\"mark_from\") != null)\n        startPositionCorrection = Integer.parseInt(attrs.getValue(\"mark_from\"));\n      if (attrs.getValue(\"mark_to\") != null)\n        endPositionCorrection = Integer.parseInt(attrs.getValue(\"mark_to\"));\n      if (attrs.getValue(\"case_sensitive\") != null\n          && attrs.getValue(\"case_sensitive\").equals(\"yes\"))\n        caseSensitive = true;\n    } else if (qName.equals(\"token\")) {\n      inToken = true;\n      if (attrs.getValue(\"negate\") != null) {\n        stringNegation = attrs.getValue(\"negate\").equals(\"yes\");\n      }\n      if (attrs.getValue(\"inflected\") != null) {\n        stringInflected = attrs.getValue(\"inflected\").equals(\"yes\");\n      }\n      if (attrs.getValue(\"skip\") != null) {\n        skipPos = Integer.parseInt(attrs.getValue(\"skip\"));\n      }\n      elements = new StringBuffer();\n      if (elementList == null) // lazy init\n      {\n        elementList = new ArrayList<Element>();\n      }\n      // POSElement creation\n      if (attrs.getValue(\"postag\") != null) {\n        posToken = attrs.getValue(\"postag\");\n        if (attrs.getValue(\"postag_regexp\") != null) {\n          posRegExp = attrs.getValue(\"postag_regexp\").equals(\"yes\");\n        }\n        if (attrs.getValue(\"negate_pos\") != null) {\n          posNegation = attrs.getValue(\"negate_pos\").equals(\"yes\");\n        }\n        if (elementList == null) { // lazy init\n          elementList = new ArrayList<Element>();\n        }\n      }\n      if (attrs.getValue(\"regexp\") != null) {\n        stringRegExp = attrs.getValue(\"regexp\").equals(\"yes\");\n      }\n\n    } else if (qName.equals(\"exception\")) {\n      inException = true;\n      exceptionSet = true;\n      exceptions = new StringBuffer();\n\n      if (attrs.getValue(\"negate\") != null) {\n        exceptionStringNegation = attrs.getValue(\"negate\").equals(\"yes\");\n      }\n      if (attrs.getValue(\"inflected\") != null) {\n        exceptionStringInflected = attrs.getValue(\"inflected\").equals(\"yes\");\n      }\n      if (attrs.getValue(\"postag\") != null) {\n        exceptionPosToken = attrs.getValue(\"postag\");\n        if (attrs.getValue(\"postag_regexp\") != null) {\n          exceptionPosRegExp = attrs.getValue(\"postag_regexp\").equals(\"yes\");\n        }\n        if (attrs.getValue(\"negate_pos\") != null) {\n          exceptionPosNegation = attrs.getValue(\"negate_pos\").equals(\"yes\");\n        }\n      }\n      if (attrs.getValue(\"regexp\") != null) {\n        exceptionStringRegExp = attrs.getValue(\"regexp\").equals(\"yes\");\n      }\n\n    } else if (qName.equals(\"example\") && attrs.getValue(\"type\").equals(\"correct\")) {\n      inCorrectExample = true;\n      correctExample = new StringBuffer();\n    } else if (qName.equals(\"example\") && attrs.getValue(\"type\").equals(\"incorrect\")) {\n      inIncorrectExample = true;\n      incorrectExample = new StringBuffer();\n    } else if (qName.equals(\"message\")) {\n      inMessage = true;\n      message = new StringBuffer();\n    } else if (qName.equals(\"rulegroup\")) {\n      ruleGroupId = attrs.getValue(\"id\");\n      ruleGroupDescription = attrs.getValue(\"name\");\n      inRuleGroup = true;\n    } else if (qName.equals(\"suggestion\") && inMessage) {\n      message.append(\"<suggestion>\");\n    } else if (qName.equals(\"marker\") && inCorrectExample) {\n      correctExample.append(\"<marker>\");\n    } else if (qName.equals(\"marker\") && inIncorrectExample) {\n      incorrectExample.append(\"<marker>\");\n    }\n  }","id":23514,"modified_method":"@SuppressWarnings(\"unused\")\n  public void startElement(String namespaceURI, String lName, String qName, Attributes attrs)\n      throws SAXException {\n    if (qName.equals(\"category\")) {\n      String catName = attrs.getValue(\"name\");\n      String prioStr = attrs.getValue(\"priority\");\n      int prio = 0;\n      if (prioStr != null)\n        category = new Category(catName, Integer.parseInt(prioStr));\n      else\n        category = new Category(catName);\n    } else if (qName.equals(\"rules\")) {\n      String languageStr = attrs.getValue(\"lang\");\n      language = Language.getLanguageforShortName(languageStr);\n      if (language == null) {\n        throw new SAXException(\"Unknown language '\" + languageStr + \"'\");\n      }\n    } else if (qName.equals(\"rule\")) {\n      id = attrs.getValue(\"id\");\n      if (inRuleGroup && id == null)\n        id = ruleGroupId;\n      description = attrs.getValue(\"name\");\n      if (inRuleGroup && description == null)\n        description = ruleGroupDescription;\n      correctExamples = new ArrayList<String>();\n      incorrectExamples = new ArrayList<String>();\n    } else if (qName.equals(\"pattern\")) {\n      inPattern = true;\n      if (attrs.getValue(\"mark_from\") != null)\n        startPositionCorrection = Integer.parseInt(attrs.getValue(\"mark_from\"));\n      if (attrs.getValue(\"mark_to\") != null)\n        endPositionCorrection = Integer.parseInt(attrs.getValue(\"mark_to\"));\n      if (attrs.getValue(\"case_sensitive\") != null\n          && attrs.getValue(\"case_sensitive\").equals(\"yes\"))\n        caseSensitive = true;\n    } else if (qName.equals(\"token\")) {\n      inToken = true;\n      if (attrs.getValue(\"negate\") != null) {\n        stringNegation = attrs.getValue(\"negate\").equals(\"yes\");\n      }\n      if (attrs.getValue(\"inflected\") != null) {\n        stringInflected = attrs.getValue(\"inflected\").equals(\"yes\");\n      }\n      if (attrs.getValue(\"skip\") != null) {\n        skipPos = Integer.parseInt(attrs.getValue(\"skip\"));\n      }\n      elements = new StringBuffer();\n      if (elementList == null) // lazy init\n      {\n        elementList = new ArrayList<Element>();\n      }\n      // POSElement creation\n      if (attrs.getValue(\"postag\") != null) {\n        posToken = attrs.getValue(\"postag\");\n        if (attrs.getValue(\"postag_regexp\") != null) {\n          posRegExp = attrs.getValue(\"postag_regexp\").equals(\"yes\");\n        }\n        if (attrs.getValue(\"negate_pos\") != null) {\n          posNegation = attrs.getValue(\"negate_pos\").equals(\"yes\");\n        }\n        if (elementList == null) { // lazy init\n          elementList = new ArrayList<Element>();\n        }\n      }\n      if (attrs.getValue(\"regexp\") != null) {\n        stringRegExp = attrs.getValue(\"regexp\").equals(\"yes\");\n      }\n\n    } else if (qName.equals(\"exception\")) {\n      inException = true;      \n      exceptions = new StringBuffer();\n\n      if (attrs.getValue(\"negate\") != null) {\n        exceptionStringNegation = attrs.getValue(\"negate\").equals(\"yes\");\n      }\n      if (attrs.getValue(\"scope\") != null) {\n        exceptionValidNext = attrs.getValue(\"scope\").equals(\"next\");\n      }\n      if (attrs.getValue(\"inflected\") != null) {\n        exceptionStringInflected = attrs.getValue(\"inflected\").equals(\"yes\");\n      }\n      if (attrs.getValue(\"postag\") != null) {\n        exceptionPosToken = attrs.getValue(\"postag\");\n        if (attrs.getValue(\"postag_regexp\") != null) {\n          exceptionPosRegExp = attrs.getValue(\"postag_regexp\").equals(\"yes\");\n        }\n        if (attrs.getValue(\"negate_pos\") != null) {\n          exceptionPosNegation = attrs.getValue(\"negate_pos\").equals(\"yes\");\n        }\n      }\n      if (attrs.getValue(\"regexp\") != null) {\n        exceptionStringRegExp = attrs.getValue(\"regexp\").equals(\"yes\");\n      }\n\n    } else if (qName.equals(\"example\") && attrs.getValue(\"type\").equals(\"correct\")) {\n      inCorrectExample = true;\n      correctExample = new StringBuffer();\n    } else if (qName.equals(\"example\") && attrs.getValue(\"type\").equals(\"incorrect\")) {\n      inIncorrectExample = true;\n      incorrectExample = new StringBuffer();\n    } else if (qName.equals(\"message\")) {\n      inMessage = true;\n      message = new StringBuffer();\n    } else if (qName.equals(\"rulegroup\")) {\n      ruleGroupId = attrs.getValue(\"id\");\n      ruleGroupDescription = attrs.getValue(\"name\");\n      inRuleGroup = true;\n    } else if (qName.equals(\"suggestion\") && inMessage) {\n      message.append(\"<suggestion>\");\n    } else if (qName.equals(\"marker\") && inCorrectExample) {\n      correctExample.append(\"<marker>\");\n    } else if (qName.equals(\"marker\") && inIncorrectExample) {\n      incorrectExample.append(\"<marker>\");\n    }\n  }","commit_id":"7ac88d786791b56f039486c3d868214f58c57ede","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@SuppressWarnings(\"unused\")\n  public void endElement(String namespaceURI, String sName, String qName) {\n    if (qName.equals(\"rule\")) {\n      PatternRule rule = new PatternRule(id, language, elementList, description, message.toString());\n      rule.setStartPositionCorrection(startPositionCorrection);\n      rule.setEndPositionCorrection(endPositionCorrection);\n      startPositionCorrection = 0;\n      endPositionCorrection = 0;\n      rule.setCorrectExamples(correctExamples);\n      rule.setIncorrectExamples(incorrectExamples);\n      rule.setCaseSensitive(caseSensitive);\n      rule.setCategory(category);\n      caseSensitive = false;\n      rules.add(rule);\n      if (elementList != null) {\n        elementList.clear();\n      }\n    } else if (qName.equals(\"exception\")) {\n      inException = false;\n    } else if (qName.equals(\"token\")) {\n      Element stringElement = new Element(elements.toString(), caseSensitive, stringRegExp,\n          stringInflected);\n      stringElement.setNegation(stringNegation);\n      if (skipPos != 0) {\n        stringElement.setSkipNext(skipPos);\n        skipPos = 0;\n      }\n      if (posToken != null) {\n        stringElement.setPosElement(posToken, posRegExp, posNegation);\n        posToken = null;\n      }\n      if (exceptionSet) {\n        stringElement.setStringException(exceptions.toString(), exceptionStringRegExp, \n            exceptionStringInflected, exceptionStringNegation);\n        exceptionSet = false;\n      }\n      if (exceptionPosToken != null) {\n        stringElement.setPosException(exceptionPosToken, exceptionPosRegExp, exceptionPosNegation);\n        exceptionPosToken = null;\n      }\n      elementList.add(stringElement);\n      stringNegation = false;\n      stringInflected = false;\n      posNegation = false;\n      posRegExp = false;\n      inToken = false;\n      stringRegExp = false;\n\n      exceptionStringNegation = false;\n      exceptionStringInflected = false;\n      exceptionPosNegation = false;\n      exceptionPosRegExp = false;\n      exceptionStringRegExp = false;\n\n    } else if (qName.equals(\"pattern\")) {\n      inPattern = false;\n    } else if (qName.equals(\"example\")) {\n      if (inCorrectExample) {\n        correctExamples.add(correctExample.toString());\n      } else if (inIncorrectExample) {\n        incorrectExamples.add(incorrectExample.toString());\n      }\n      inCorrectExample = false;\n      inIncorrectExample = false;\n      correctExample = new StringBuffer();\n      incorrectExample = new StringBuffer();\n    } else if (qName.equals(\"message\")) {\n      inMessage = false;\n    } else if (qName.equals(\"rulegroup\")) {\n      inRuleGroup = false;\n    } else if (qName.equals(\"suggestion\") && inMessage) {\n      message.append(\"<\/suggestion>\");\n    } else if (qName.equals(\"marker\") && inCorrectExample) {\n      correctExample.append(\"<\/marker>\");\n    } else if (qName.equals(\"marker\") && inIncorrectExample) {\n      incorrectExample.append(\"<\/marker>\");\n    }\n  }","id":23515,"modified_method":"@SuppressWarnings(\"unused\")\n  public void endElement(String namespaceURI, String sName, String qName) {\n    \n    if (qName.equals(\"rule\")) {\n      PatternRule rule = new PatternRule(id, language, elementList, description, message.toString());\n      rule.setStartPositionCorrection(startPositionCorrection);\n      rule.setEndPositionCorrection(endPositionCorrection);\n      startPositionCorrection = 0;\n      endPositionCorrection = 0;\n      rule.setCorrectExamples(correctExamples);\n      rule.setIncorrectExamples(incorrectExamples);\n      rule.setCaseSensitive(caseSensitive);\n      rule.setCategory(category);\n      caseSensitive = false;\n      rules.add(rule);\n      if (elementList != null) {\n        elementList.clear();\n      }\n    } else if (qName.equals(\"exception\")) {\n      inException = false;\n      if (!exceptionSet) {\n      stringElement = new Element(elements.toString(), caseSensitive, stringRegExp,\n          stringInflected);\n      exceptionSet = true;\n      }\n      stringElement.setNegation(stringNegation);\n        if (!exceptions.toString().equals(\"\")) {\n        stringElement.setStringException(exceptions.toString(), exceptionStringRegExp, \n            exceptionStringInflected, exceptionStringNegation, exceptionValidNext);\n        }              \n      if (exceptionPosToken != null) {\n        stringElement.setPosException(exceptionPosToken, exceptionPosRegExp, exceptionPosNegation, exceptionValidNext);\n        exceptionPosToken = null;\n      }\n      \n    } else if (qName.equals(\"token\")) {\n      if (!exceptionSet || stringElement==null) {\n      stringElement = new Element(elements.toString(), caseSensitive, stringRegExp,\n          stringInflected);\n      stringElement.setNegation(stringNegation);\n      } else {\n        stringElement.setStringElement(elements.toString());\n      }\n      if (skipPos != 0) {\n        stringElement.setSkipNext(skipPos);\n        skipPos = 0;\n      }\n      if (posToken != null) {\n        stringElement.setPosElement(posToken, posRegExp, posNegation);\n        posToken = null;\n      }      \n      elementList.add(stringElement);\n      stringNegation = false;\n      stringInflected = false;\n      posNegation = false;\n      posRegExp = false;\n      inToken = false;\n      stringRegExp = false;\n\n      exceptionStringNegation = false;\n      exceptionStringInflected = false;\n      exceptionPosNegation = false;\n      exceptionPosRegExp = false;\n      exceptionStringRegExp = false;\n      exceptionValidNext = true;\n      exceptionSet = false;\n\n    } else if (qName.equals(\"pattern\")) {\n      inPattern = false;\n    } else if (qName.equals(\"example\")) {\n      if (inCorrectExample) {\n        correctExamples.add(correctExample.toString());\n      } else if (inIncorrectExample) {\n        incorrectExamples.add(incorrectExample.toString());\n      }\n      inCorrectExample = false;\n      inIncorrectExample = false;\n      correctExample = new StringBuffer();\n      incorrectExample = new StringBuffer();\n    } else if (qName.equals(\"message\")) {\n      inMessage = false;\n    } else if (qName.equals(\"rulegroup\")) {\n      inRuleGroup = false;\n    } else if (qName.equals(\"suggestion\") && inMessage) {\n      message.append(\"<\/suggestion>\");\n    } else if (qName.equals(\"marker\") && inCorrectExample) {\n      correctExample.append(\"<\/marker>\");\n    } else if (qName.equals(\"marker\") && inIncorrectExample) {\n      incorrectExample.append(\"<\/marker>\");\n    }\n  }","commit_id":"7ac88d786791b56f039486c3d868214f58c57ede","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public final AnalyzedSentence replace(final AnalyzedSentence text) throws IOException {\n                    \n    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();\n    AnalyzedTokenReadings[] whTokens = text.getTokens();\n    int[] tokenPositions = new int[tokens.length + 1 ];\n    \n    int tokenPos = 0;\n    int prevSkipNext = 0;\n    int skipNext = 0;\n    int matchPos = 0;\n    int skipShift = 0;\n    // this variable keeps the total number\n    // of tokens skipped - used to avoid\n    // that nextPos gets back to unmatched tokens...\n    int skipShiftTotal = 0;\n\n    int firstMatchToken = -1;\n    int lastMatchToken = -1;\n    final int patternSize = patternElements.size();\n    Element elem = null, prevElement = null;\n    final boolean startWithSentStart = patternElements.get(0).isSentStart();\n\n    for (int i = 0; i < tokens.length; i++) {\n      boolean allElementsMatch = true;\n\n      //stop processing if rule is longer than the sentence\n      if (patternSize + i > tokens.length) {\n        allElementsMatch = false;\n        break;\n      }            \n      \n      //stop looking for sent_start - it will never match any\n      //token except the first\n      if (startWithSentStart && i > 0) {\n        allElementsMatch = false;\n        break;\n      }\n\n      int matchingTokens = 0;\n      for (int k = 0; (k < patternSize); k++) {\n        if (elem != null) {\n          prevElement = elem;\n        }\n        elem = patternElements.get(k);\n        skipNext = elem.getSkipNext();\n        final int nextPos = tokenPos + k + skipShiftTotal;\n               \n        if (nextPos >= tokens.length) {\n          allElementsMatch = false;\n          break;\n        }\n\n        boolean skipMatch = false, thisMatched = false, prevMatched = false;\n        boolean exceptionMatched = false;\n        if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) { // SENT_END?\n          prevSkipNext = tokens.length - (nextPos + 1);\n        }\n        for (int m = nextPos; m <= nextPos + prevSkipNext; m++) {          \n          boolean matched = false;\n          final int numberOfReadings = tokens[m].getReadingsLength();\n\n          for (int l = 0; l < numberOfReadings; l++) {\n            final AnalyzedToken matchToken = tokens[m].getAnalyzedToken(l);\n            if (prevSkipNext > 0 && prevElement != null) {\n              if (prevElement.prevExceptionMatch(matchToken)) {\n                exceptionMatched = true;\n                prevMatched = true;\n              }\n            }\n            thisMatched |= elem.match(matchToken);\n            exceptionMatched |= elem.exceptionMatch(matchToken);\n            // Logical OR (cannot be AND):\n            if (!thisMatched && !exceptionMatched) {\n              matched |= false;\n            } else {\n              matched = true;\n              matchPos = m;\n              skipShift = matchPos - nextPos;              \n              tokenPositions[matchingTokens] = skipShift + 1;              \n            }\n            skipMatch = (skipMatch || matched) && !exceptionMatched;\n          }\n          \n          //disallow exceptions that should match only current tokens          \n          if (!thisMatched && !prevMatched) {\n            exceptionMatched = false;\n          }\n                    \n          if (skipMatch) {\n            break;\n          }\n          \n        }\n        //disallow exceptions that should match only current tokens        \n        if (!thisMatched && !prevMatched) {\n          skipMatch = false;\n        }\n        allElementsMatch = skipMatch;\n        if (skipMatch) {\n          prevSkipNext = skipNext;\n        } else {\n          prevSkipNext = 0;\n        }\n        if (allElementsMatch) {                              \n          matchingTokens++;\n          lastMatchToken = matchPos; // nextPos;          \n          if (firstMatchToken == -1) {\n            firstMatchToken = matchPos; // nextPos;\n          }\n          skipShiftTotal += skipShift;\n        } else {\n          skipShiftTotal = 0;\n          break;\n        }\n      }\n      \n      tokenPos++;\n      \n      if (allElementsMatch) {\n        int correctedStPos = 0;\n        if (startPositionCorrection > 0) {        \n        for (int l = 0; l <= startPositionCorrection; l++) {\n          correctedStPos +=  tokenPositions[l];\n        }\n        correctedStPos--;\n        }        \n        \n        int correctedEndPos = 0;\n        if (endPositionCorrection < 0) {\n          int l = 0;\n          while (l > endPositionCorrection) {\n            int test = matchingTokens + l - 1;\n            test = tokenPositions[test];\n            correctedEndPos -= tokenPositions[matchingTokens + l - 1];\n            l--;\n          }\n          }         \n        \n        final int fromPos = text.getOriginalPosition(firstMatchToken + correctedStPos);\n        //int toPos = lastMatchToken + correctedEndPos;\n          final int numRead = whTokens[fromPos].getReadingsLength();         \n          String lemma = \"\";\n          for (int l = 0; l < numRead; l++) {\n            if (whTokens[fromPos].getAnalyzedToken(l).getPOSTag() != null) {\n            if (whTokens[fromPos].getAnalyzedToken(l).getPOSTag().equals(disambiguatedPOS)) {\n              if (whTokens[fromPos].getAnalyzedToken(l).getLemma() != null) {\n                lemma = whTokens[fromPos].getAnalyzedToken(l).getLemma();\n              }\n            }\n            } \n          }\n          if (lemma.equals(\"\")) {\n            lemma = whTokens[fromPos].getAnalyzedToken(0).getLemma();\n          }\n          \n          AnalyzedTokenReadings toReplace = new AnalyzedTokenReadings(\n                new AnalyzedToken(whTokens[fromPos].getToken(), disambiguatedPOS, lemma,\n                    whTokens[fromPos].getStartPos()));\n          whTokens[fromPos] = toReplace;\n      } else {\n        firstMatchToken = -1;\n        lastMatchToken = -1;\n        skipShiftTotal = 0;\n      }\n    }\n\n    return new AnalyzedSentence(whTokens);\n  }","id":23516,"modified_method":"public final AnalyzedSentence replace(final AnalyzedSentence text) throws IOException {\n                    \n    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();\n    AnalyzedTokenReadings[] whTokens = text.getTokens();\n    int[] tokenPositions = new int[tokens.length + 1 ];\n    \n    int tokenPos = 0;\n    int prevSkipNext = 0;\n    int skipNext = 0;\n    int matchPos = 0;\n    int skipShift = 0;\n    // this variable keeps the total number\n    // of tokens skipped - used to avoid\n    // that nextPos gets back to unmatched tokens...\n    int skipShiftTotal = 0;\n\n    int firstMatchToken = -1;\n    int lastMatchToken = -1;\n    final int patternSize = patternElements.size();\n    Element elem = null, prevElement = null;\n    final boolean startWithSentStart = patternElements.get(0).isSentStart();\n\n    for (int i = 0; i < tokens.length; i++) {\n      boolean allElementsMatch = true;\n\n      //stop processing if rule is longer than the sentence\n      if (patternSize + i > tokens.length) {\n        allElementsMatch = false;\n        break;\n      }            \n      \n      //stop looking for sent_start - it will never match any\n      //token except the first\n      if (startWithSentStart && i > 0) {\n        allElementsMatch = false;\n        break;\n      }\n\n      int matchingTokens = 0;\n      for (int k = 0; (k < patternSize); k++) {\n        if (elem != null) {\n          prevElement = elem;\n        }\n        elem = patternElements.get(k);\n        skipNext = elem.getSkipNext();\n        final int nextPos = tokenPos + k + skipShiftTotal;\n               \n        if (nextPos >= tokens.length) {\n          allElementsMatch = false;\n          break;\n        }\n\n        boolean skipMatch = false, thisMatched = false, prevMatched = false;\n        boolean exceptionMatched = false;\n        if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) { // SENT_END?\n          prevSkipNext = tokens.length - (nextPos + 1);\n        }\n        for (int m = nextPos; m <= nextPos + prevSkipNext; m++) {          \n          boolean matched = false;\n          final int numberOfReadings = tokens[m].getReadingsLength();\n\n          for (int l = 0; l < numberOfReadings; l++) {\n            final AnalyzedToken matchToken = tokens[m].getAnalyzedToken(l);\n            if (prevSkipNext > 0 && prevElement != null) {\n              if (prevElement.prevExceptionMatch(matchToken)) {\n                exceptionMatched = true;\n                prevMatched = true;\n              }\n            }\n            thisMatched |= elem.match(matchToken);\n            exceptionMatched |= (elem.exceptionMatch(matchToken)\n                || elem.andGroupExceptionMatch(matchToken));\n            // Logical OR (cannot be AND):\n            if (!thisMatched && !exceptionMatched) {\n              matched |= false;\n            } else {\n              matched = true;\n              matchPos = m;\n              skipShift = matchPos - nextPos;              \n              tokenPositions[matchingTokens] = skipShift + 1;              \n            }\n            skipMatch = (skipMatch || matched) && !exceptionMatched;\n          }\n          \n          //disallow exceptions that should match only current tokens          \n          if (!thisMatched && !prevMatched) {\n            exceptionMatched = false;\n          }\n                    \n          if (skipMatch) {\n            break;\n          }\n          \n        }\n        //disallow exceptions that should match only current tokens        \n        if (!thisMatched && !prevMatched) {\n          skipMatch = false;\n        }\n        allElementsMatch = skipMatch;\n        if (skipMatch) {\n          prevSkipNext = skipNext;\n        } else {\n          prevSkipNext = 0;\n        }\n        if (allElementsMatch) {                              \n          matchingTokens++;\n          lastMatchToken = matchPos; // nextPos;          \n          if (firstMatchToken == -1) {\n            firstMatchToken = matchPos; // nextPos;\n          }\n          skipShiftTotal += skipShift;\n        } else {\n          skipShiftTotal = 0;\n          break;\n        }\n      }\n      \n      tokenPos++;\n      \n      if (allElementsMatch) {\n        int correctedStPos = 0;\n        if (startPositionCorrection > 0) {        \n        for (int l = 0; l <= startPositionCorrection; l++) {\n          correctedStPos +=  tokenPositions[l];\n        }\n        correctedStPos--;\n        }        \n        \n        int correctedEndPos = 0;\n        if (endPositionCorrection < 0) {\n          int l = 0;\n          while (l > endPositionCorrection) {\n            int test = matchingTokens + l - 1;\n            test = tokenPositions[test];\n            correctedEndPos -= tokenPositions[matchingTokens + l - 1];\n            l--;\n          }\n          }         \n        \n        final int fromPos = text.getOriginalPosition(firstMatchToken + correctedStPos);\n        //int toPos = lastMatchToken + correctedEndPos;\n          final int numRead = whTokens[fromPos].getReadingsLength();         \n          String lemma = \"\";\n          for (int l = 0; l < numRead; l++) {\n            if (whTokens[fromPos].getAnalyzedToken(l).getPOSTag() != null) {\n            if (whTokens[fromPos].getAnalyzedToken(l).getPOSTag().equals(disambiguatedPOS)) {\n              if (whTokens[fromPos].getAnalyzedToken(l).getLemma() != null) {\n                lemma = whTokens[fromPos].getAnalyzedToken(l).getLemma();\n              }\n            }\n            } \n          }\n          if (lemma.equals(\"\")) {\n            lemma = whTokens[fromPos].getAnalyzedToken(0).getLemma();\n          }\n          \n          AnalyzedTokenReadings toReplace = new AnalyzedTokenReadings(\n                new AnalyzedToken(whTokens[fromPos].getToken(), disambiguatedPOS, lemma,\n                    whTokens[fromPos].getStartPos()));\n          whTokens[fromPos] = toReplace;\n      } else {\n        firstMatchToken = -1;\n        lastMatchToken = -1;\n        skipShiftTotal = 0;\n      }\n    }\n\n    return new AnalyzedSentence(whTokens);\n  }","commit_id":"bc6e211ae99647a4ec3463a61e9b4e8966536845","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public final boolean match(final AnalyzedToken token) {\n    // this var is used to determine\n    // if calling matchStringToken\n    // has any sense - this method takes\n    // most time so it's best reduce the\n    // number it's being called\n    boolean testString = true;\n    if (stringToken == null) {\n      testString = false;\n    } else {\n    if (stringToken.equals(\"\")) {\n      testString = false;\n      }\n    }\n    if (testString) {\n      return (matchStringToken(token) != negation) && (matchPosToken(token) != posNegation);\n    } else {\n      return (!negation) && (matchPosToken(token) != posNegation);\n    }\n  }","id":23517,"modified_method":"public final boolean match(final AnalyzedToken token) {\n    // this var is used to determine\n    // if calling matchStringToken\n    // has any sense - this method takes\n    // most time so it's best reduce the\n    // number it's being called\n    boolean testString = true;\n    if (stringToken == null) {\n      testString = false;\n    } else {\n    if (stringToken.equals(\"\")) {\n      testString = false;\n      }\n    }\n    if (testString) {\n      return (matchStringToken(token) != negation) \n          && (matchPosToken(token) != posNegation)\n          && andGroupMatch(token);\n    } else {\n      return (!negation) && (matchPosToken(token) != posNegation);\n    }\n  }","commit_id":"3e97a537631038d74cb75b76e3146241703ee16b","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public final String toString() {\n    if (posToken != null) {\n      return stringToken.concat(\"/\").concat(posToken);\n    } else {\n      return stringToken;\n    }\n  }","id":23518,"modified_method":"public final String toString() {\n    if (posToken != null) {\n      return stringToken + \"/\" + posToken;\n    } else {\n      return stringToken;\n    }\n  }","commit_id":"3e97a537631038d74cb75b76e3146241703ee16b","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void setLemmaString(final String lemmaString) {\n    if (lemmaString != null) {\n      if (!lemmaString.equals(\"\")) {\n        formattedToken = new AnalyzedTokenReadings(new AnalyzedToken(lemmaString, null, lemmaString));\n        staticLemma = true;\n        postagRegexp = true;\n        if (postagRegexp & posTag != null) {\n          pPosRegexMatch = Pattern.compile(posTag);\n        }\n      }\n    }\n  }","id":23519,"modified_method":"public void setLemmaString(final String lemmaString) {\n    if (lemmaString != null) {\n      if (!lemmaString.equals(\"\")) {\n        formattedToken = new AnalyzedTokenReadings(new AnalyzedToken(lemmaString, null, lemmaString));\n        staticLemma = true;\n        postagRegexp = true;\n        if (postagRegexp && posTag != null) {\n          pPosRegexMatch = Pattern.compile(posTag);\n        }\n      }\n    }\n  }","commit_id":"3e97a537631038d74cb75b76e3146241703ee16b","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"Match(final String posTag, final String posTagReplace,\n      final boolean postagRegexp,      \n      final String regexMatch,\n      final String regexReplace,      \n      final CaseConversion caseConversionType)  {\n    this.posTag = posTag;\n    this.postagRegexp = postagRegexp;\n    this.caseConversionType = caseConversionType;\n\n    if (regexMatch != null) {\n      pRegexMatch = Pattern.compile(regexMatch);\n    }\n    if (postagRegexp & posTag != null) {\n      pPosRegexMatch = Pattern.compile(posTag);\n    }\n\n    this.regexReplace = regexReplace;  \n    this.posTagReplace = posTagReplace;\n  }","id":23520,"modified_method":"Match(final String posTag, final String posTagReplace,\n      final boolean postagRegexp,      \n      final String regexMatch,\n      final String regexReplace,      \n      final CaseConversion caseConversionType)  {\n    this.posTag = posTag;\n    this.postagRegexp = postagRegexp;\n    this.caseConversionType = caseConversionType;\n\n    if (regexMatch != null) {\n      pRegexMatch = Pattern.compile(regexMatch);\n    }\n    if (postagRegexp && posTag != null) {\n      pPosRegexMatch = Pattern.compile(posTag);\n    }\n\n    this.regexReplace = regexReplace;  \n    this.posTagReplace = posTagReplace;\n  }","commit_id":"3e97a537631038d74cb75b76e3146241703ee16b","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public String[] toFinalString() throws IOException {\n    String[] formattedString = new String[1];\n    if (formattedToken != null) {\n      if (posTag == null) {\n        formattedString[0] = formattedToken.getToken();\n        if (pRegexMatch != null) {          \n          formattedString[0] \n          = pRegexMatch.matcher(formattedString[0]).replaceAll(regexReplace);\n          }        \n          switch (caseConversionType) {\n            default : formattedString[0] = formattedString[0]; break;\n            case NONE : formattedString[0] = formattedString[0]; break;\n            case STARTLOWER : formattedString[0] = formattedString[0].\n                    substring(0, 1).toLowerCase() \n                    + formattedToken.getToken().substring(1); break;\n            case STARTUPPER : formattedString[0] = formattedString[0].\n                  substring(0, 1).toUpperCase() \n                  + formattedToken.getToken().substring(1); break;\n            case ALLUPPER : formattedString[0] = formattedString[0].\n                  toUpperCase(); break;\n            case ALLLOWER : formattedString[0] = formattedString[0].\n                  toLowerCase(); break;              \n          }         \n        \n      } else {\n        if (synthesizer == null) {\n        formattedString[0] = formattedToken.getToken();\n        } else if (postagRegexp) {\n          int readingCount = formattedToken.getReadingsLength();\n          String targetPosTag = posTag;\n          if (staticLemma) {\n            int numRead = matchedToken.getReadingsLength();\n            for (int i = 0; i < numRead; i++) {\n              String tst = matchedToken.getAnalyzedToken(i).getPOSTag();\n              if (tst != null) {\n              if (pPosRegexMatch.matcher(tst).matches()) {\n                targetPosTag = matchedToken.getAnalyzedToken(i).getPOSTag();\n                break;\n              }\n              }\n            }            \n            if (pPosRegexMatch != null & posTagReplace != null) {            \n              targetPosTag = pPosRegexMatch.matcher(targetPosTag).replaceAll(posTagReplace);  \n            }\n            if (targetPosTag.indexOf(\"?\") > 0) {\n              targetPosTag = targetPosTag.replaceAll(\"\\\\?\", \"\\\\\\\\?\");\n              }\n          } else {\n            int numRead = formattedToken.getReadingsLength();\n            for (int i = 0; i < numRead; i++) {\n              String tst = formattedToken.getAnalyzedToken(i).getPOSTag();\n              if (tst != null) {\n              if (pPosRegexMatch.matcher(tst).matches()) {\n                targetPosTag = formattedToken.getAnalyzedToken(i).getPOSTag();\n                break;\n              }\n              }\n            }\n          if (pPosRegexMatch != null & posTagReplace != null) {            \n            targetPosTag = pPosRegexMatch.matcher(targetPosTag).replaceAll(posTagReplace);  \n          }\n          }\n          TreeSet<String> wordForms = new TreeSet<String>();          \n          for (int i = 0; i < readingCount; i++) {\n                String[] possibleWordForms = \n                  synthesizer.synthesize(\n                    formattedToken.getAnalyzedToken(i),\n                    targetPosTag, true);\n                if (possibleWordForms != null) {\n                  for (String form : possibleWordForms) {           \n                    wordForms.add(form);\n                  }\n                }\n            }\n          if (wordForms != null) {\n            if (wordForms.size() > 0) {\n            formattedString = wordForms.toArray(new String[wordForms.size()]);\n            } else {\n            formattedString[0] = \"(\" + formattedToken.getToken() + \")\";            \n            }\n          } else {\n            formattedString[0] = formattedToken.getToken();\n          }\n        } else {\n          int readingCount = formattedToken.getReadingsLength();\n          TreeSet<String> wordForms = new TreeSet<String>();\n          for (int i = 0; i < readingCount; i++) {\n                String[] possibleWordForms = \n                  synthesizer.synthesize(\n                    formattedToken.getAnalyzedToken(i),\n                    posTag);\n                if (possibleWordForms != null) {\n                  for (String form : possibleWordForms) {           \n                    wordForms.add(form);\n                  }\n                }\n            }\n          if (wordForms != null) {\n            formattedString = wordForms.toArray(new String[wordForms.size()]);\n          } else {\n            formattedString[0] = formattedToken.getToken();\n          }\n        }\n      }\n    }\n    return formattedString;\n  }","id":23521,"modified_method":"public String[] toFinalString() throws IOException {\n    String[] formattedString = new String[1];\n    if (formattedToken != null) {\n      if (posTag == null) {\n        formattedString[0] = formattedToken.getToken();\n        if (pRegexMatch != null) {          \n          formattedString[0] \n          = pRegexMatch.matcher(formattedString[0]).replaceAll(regexReplace);\n          }        \n          switch (caseConversionType) {\n            case NONE : formattedString[0] = formattedString[0]; break;\n            case STARTLOWER : formattedString[0] = formattedString[0].\n                    substring(0, 1).toLowerCase() \n                    + formattedToken.getToken().substring(1); break;\n            case STARTUPPER : formattedString[0] = formattedString[0].\n                  substring(0, 1).toUpperCase() \n                  + formattedToken.getToken().substring(1); break;\n            case ALLUPPER : formattedString[0] = formattedString[0].\n                  toUpperCase(); break;\n            case ALLLOWER : formattedString[0] = formattedString[0].\n                  toLowerCase(); break;\n            default : formattedString[0] = formattedString[0]; break;\n          }         \n        \n      } else {\n        if (synthesizer == null) {\n        formattedString[0] = formattedToken.getToken();\n        } else if (postagRegexp) {\n          int readingCount = formattedToken.getReadingsLength();\n          String targetPosTag = posTag;\n          if (staticLemma) {\n            int numRead = matchedToken.getReadingsLength();\n            for (int i = 0; i < numRead; i++) {\n              String tst = matchedToken.getAnalyzedToken(i).getPOSTag();\n              if (tst != null) {\n              if (pPosRegexMatch.matcher(tst).matches()) {\n                targetPosTag = matchedToken.getAnalyzedToken(i).getPOSTag();\n                break;\n              }\n              }\n            }            \n            if (pPosRegexMatch != null & posTagReplace != null) {            \n              targetPosTag = pPosRegexMatch.matcher(targetPosTag).replaceAll(posTagReplace);  \n            }\n            if (targetPosTag.indexOf(\"?\") > 0) {\n              targetPosTag = targetPosTag.replaceAll(\"\\\\?\", \"\\\\\\\\?\");\n              }\n          } else {\n            int numRead = formattedToken.getReadingsLength();\n            for (int i = 0; i < numRead; i++) {\n              String tst = formattedToken.getAnalyzedToken(i).getPOSTag();\n              if (tst != null) {\n              if (pPosRegexMatch.matcher(tst).matches()) {\n                targetPosTag = formattedToken.getAnalyzedToken(i).getPOSTag();\n                break;\n              }\n              }\n            }\n          if (pPosRegexMatch != null & posTagReplace != null) {            \n            targetPosTag = pPosRegexMatch.matcher(targetPosTag).replaceAll(posTagReplace);  \n          }\n          }\n          TreeSet<String> wordForms = new TreeSet<String>();          \n          for (int i = 0; i < readingCount; i++) {\n                String[] possibleWordForms = \n                  synthesizer.synthesize(\n                    formattedToken.getAnalyzedToken(i),\n                    targetPosTag, true);\n                if (possibleWordForms != null) {\n                  for (String form : possibleWordForms) {           \n                    wordForms.add(form);\n                  }\n                }\n            }\n          if (wordForms != null) {\n            if (wordForms.size() > 0) {\n            formattedString = wordForms.toArray(new String[wordForms.size()]);\n            } else {\n            formattedString[0] = \"(\" + formattedToken.getToken() + \")\";            \n            }\n          } else {\n            formattedString[0] = formattedToken.getToken();\n          }\n        } else {\n          int readingCount = formattedToken.getReadingsLength();\n          TreeSet<String> wordForms = new TreeSet<String>();\n          for (int i = 0; i < readingCount; i++) {\n                String[] possibleWordForms = \n                  synthesizer.synthesize(\n                    formattedToken.getAnalyzedToken(i),\n                    posTag);\n                if (possibleWordForms != null) {\n                  for (String form : possibleWordForms) {           \n                    wordForms.add(form);\n                  }\n                }\n            }\n          if (wordForms != null) {\n            formattedString = wordForms.toArray(new String[wordForms.size()]);\n          } else {\n            formattedString[0] = formattedToken.getToken();\n          }\n        }\n      }\n    }\n    return formattedString;\n  }","commit_id":"3e97a537631038d74cb75b76e3146241703ee16b","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/** Replace back references generated with &lt;match&gt; and \\\\1 \n   *  in message using Match class, and take care of skipping.\n  *    @return String Formatted message. \n  **/\n  public final String formatMatches(final AnalyzedTokenReadings[] toks,\n      final int[] positions, final int firstMatchTok, int matchingTok,\n      final String errorMsg) throws IOException {\n    String errorMessage = errorMsg;\n    if (firstMatchTok + matchingTok >= toks.length) {\n      matchingTok = toks.length - firstMatchTok;\n    }\n    int matchCounter = 0;\n    boolean newWay = false;\n    int errLen = errorMessage.length();\n    int errMarker = errorMessage.indexOf(\"\\\\\");\n    boolean numberFollows = false;\n    if (errMarker > 0 & errMarker < errLen - 1) {\n      numberFollows = errorMessage.charAt(errMarker + 1) >= '1'\n        & errorMessage.charAt(errMarker + 1) <= '9';\n    }\n    while (errMarker > 0 & numberFollows) {\n      int ind = errorMessage.indexOf(\"\\\\\"); \n      if (ind > 0) {\n        if (errorMessage.charAt(ind + 1) >= '1'\n          & errorMessage.charAt(ind + 1) <= '9') {            \n          int j = errorMessage.charAt(ind + 1) - '1';\n          int repTokenPos = 0;\n          for (int l = 0; l <= j; l++) {\n            repTokenPos += positions[l];\n          }          \n          if (suggestionMatches != null) {\n            if (matchCounter < suggestionMatches.size()) {\n              if (suggestionMatches.get(matchCounter) != null) {             \n                suggestionMatches.get(matchCounter)\n                .setToken(toks[firstMatchTok + repTokenPos - 1]);\n                suggestionMatches.get(matchCounter).setSynthesizer(language[0].getSynthesizer());              \n                String leftSide = errorMessage.substring(0, ind);\n                String suggestionLeft = \"\";\n                String suggestionRight = \"\";\n                String rightSide = errorMessage.substring(ind + 2);\n                String[] matches = suggestionMatches.get(matchCounter).toFinalString();\n                if (matches.length == 1) {\n                  errorMessage = leftSide \n                  + suggestionLeft\n                  + matches[0]\n                            + suggestionRight\n                            + rightSide;              \n                } else {                  \n                  suggestionLeft = leftSide.substring(leftSide.lastIndexOf(\"<suggestion>\") +\"<suggestion>\".length());\n                  if (suggestionLeft.equals(\"\")) {\n                    errorMessage = leftSide;\n                  } else {\n                    errorMessage = leftSide.substring(0, leftSide.lastIndexOf(\"<suggestion>\"))\n                      + \"<suggestion>\";\n                  }\n                  suggestionRight = rightSide.substring(0, rightSide.indexOf(\"<\/suggestion>\"));\n                  if (!suggestionRight.equals(\"\")) {\n                    rightSide = rightSide.substring(rightSide.indexOf(\"<\/suggestion>\"));\n                  }\n                  int lastLeftSugEnd = leftSide.indexOf(\"<\/suggestion>\");\n                  int lastLeftSugStart = leftSide.lastIndexOf(\"<suggestion>\");\n                  for (String formatMatch : matches) {\n                    errorMessage += suggestionLeft\n                    + formatMatch \n                    + suggestionRight;\n                    if (lastLeftSugEnd == -1 && lastLeftSugStart > 0) {\n                      errorMessage += \"<\/suggestion>, <suggestion>\";\n                    }\n                  }\n                  int correctionSug = errorMessage.lastIndexOf(\", <suggestion>\");\n                  if (correctionSug + \", <suggestion>\".length() == errorMessage.length())\n                    errorMessage = errorMessage.substring(0, correctionSug);\n                  errorMessage += rightSide;             \n                }\n                matchCounter++;\n                newWay = true;\n              }\n            }\n          }\n\n          if (!newWay) {\n            //in case <match> elements weren't used (yet)\n            errorMessage = errorMessage.replaceAll(\"\\\\\\\\\" + (j + 1), \n                toks[firstMatchTok + repTokenPos - 1].getToken());          \n            errMarker = errorMessage.indexOf(\"\\\\\");\n            numberFollows = false;\n            errLen = errorMessage.length();\n            if (errMarker > 0 & errMarker < errLen - 1) {\n              numberFollows = errorMessage.charAt(errMarker + 1) >= '1'\n                & errorMessage.charAt(errMarker + 1) <= '9';\n            }\n          }\n        }\n      } else {\n        errMarker = errorMessage.indexOf(\"\\\\\");\n        numberFollows = false;\n        errLen = errorMessage.length();\n        if (errMarker > 0 & errMarker < errLen - 1) {\n          numberFollows = errorMessage.charAt(errMarker + 1) >= '1'\n            & errorMessage.charAt(errMarker + 1) <= '9';\n        }\n      }\n    }\n    return errorMessage;\n  }","id":23522,"modified_method":"/** Replace back references generated with &lt;match&gt; and \\\\1 \n   *  in message using Match class, and take care of skipping.\n  *    @return String Formatted message. \n  **/\n  public final String formatMatches(final AnalyzedTokenReadings[] toks,\n      final int[] positions, final int firstMatchTok, int matchingTok,\n      final String errorMsg) throws IOException {\n    String errorMessage = errorMsg;    \n    int matchCounter = 0;\n    boolean newWay = false;\n    int errLen = errorMessage.length();\n    int errMarker = errorMessage.indexOf(\"\\\\\");\n    boolean numberFollows = false;\n    if (errMarker > 0 & errMarker < errLen - 1) {\n      numberFollows = errorMessage.charAt(errMarker + 1) >= '1'\n        & errorMessage.charAt(errMarker + 1) <= '9';\n    }\n    while (errMarker > 0 && numberFollows) {\n      int ind = errorMessage.indexOf(\"\\\\\"); \n      if (ind > 0) {\n        if (errorMessage.charAt(ind + 1) >= '1'\n          & errorMessage.charAt(ind + 1) <= '9') {            \n          int j = errorMessage.charAt(ind + 1) - '1';\n          int repTokenPos = 0;\n          for (int l = 0; l <= j; l++) {\n            repTokenPos += positions[l];\n          }          \n          if (suggestionMatches != null) {\n            if (matchCounter < suggestionMatches.size()) {\n              if (suggestionMatches.get(matchCounter) != null) {             \n                suggestionMatches.get(matchCounter)\n                .setToken(toks[firstMatchTok + repTokenPos - 1]);\n                suggestionMatches.get(matchCounter).setSynthesizer(language[0].getSynthesizer());              \n                String leftSide = errorMessage.substring(0, ind);\n                String suggestionLeft = \"\";\n                String suggestionRight = \"\";\n                String rightSide = errorMessage.substring(ind + 2);\n                String[] matches = suggestionMatches.get(matchCounter).toFinalString();\n                if (matches.length == 1) {\n                  errorMessage = leftSide \n                  + suggestionLeft\n                  + matches[0]\n                            + suggestionRight\n                            + rightSide;              \n                } else {                  \n                  suggestionLeft = leftSide.substring(leftSide.lastIndexOf(\"<suggestion>\") +\"<suggestion>\".length());\n                  if (suggestionLeft.equals(\"\")) {\n                    errorMessage = leftSide;\n                  } else {\n                    errorMessage = leftSide.substring(0, leftSide.lastIndexOf(\"<suggestion>\"))\n                      + \"<suggestion>\";\n                  }\n                  suggestionRight = rightSide.substring(0, rightSide.indexOf(\"<\/suggestion>\"));\n                  if (!suggestionRight.equals(\"\")) {\n                    rightSide = rightSide.substring(rightSide.indexOf(\"<\/suggestion>\"));\n                  }\n                  int lastLeftSugEnd = leftSide.indexOf(\"<\/suggestion>\");\n                  int lastLeftSugStart = leftSide.lastIndexOf(\"<suggestion>\");\n                  for (String formatMatch : matches) {\n                    errorMessage += suggestionLeft\n                    + formatMatch \n                    + suggestionRight;\n                    if (lastLeftSugEnd == -1 && lastLeftSugStart > 0) {\n                      errorMessage += \"<\/suggestion>, <suggestion>\";\n                    }\n                  }\n                  int correctionSug = errorMessage.lastIndexOf(\", <suggestion>\");\n                  if (correctionSug + \", <suggestion>\".length() == errorMessage.length())\n                    errorMessage = errorMessage.substring(0, correctionSug);\n                  errorMessage += rightSide;             \n                }\n                matchCounter++;\n                newWay = true;\n              }\n            }\n          }\n\n          if (!newWay) {\n            //in case <match> elements weren't used (yet)\n            errorMessage = errorMessage.replaceAll(\"\\\\\\\\\" + (j + 1), \n                toks[firstMatchTok + repTokenPos - 1].getToken());          \n            errMarker = errorMessage.indexOf(\"\\\\\");\n            numberFollows = false;\n            errLen = errorMessage.length();\n            if (errMarker > 0 & errMarker < errLen - 1) {\n              numberFollows = errorMessage.charAt(errMarker + 1) >= '1'\n                & errorMessage.charAt(errMarker + 1) <= '9';\n            }\n          }\n        }\n      } else {\n        errMarker = errorMessage.indexOf(\"\\\\\");\n        numberFollows = false;\n        errLen = errorMessage.length();\n        if (errMarker > 0 & errMarker < errLen - 1) {\n          numberFollows = errorMessage.charAt(errMarker + 1) >= '1'\n            & errorMessage.charAt(errMarker + 1) <= '9';\n        }\n      }\n    }\n    return errorMessage;\n  }","commit_id":"3e97a537631038d74cb75b76e3146241703ee16b","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public final RuleMatch[] match(final AnalyzedSentence text) throws IOException {\n            \n    List<RuleMatch> ruleMatches = new ArrayList<RuleMatch>();    \n    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();\n    int[] tokenPositions = new int[tokens.length + 1 ];\n    \n    int tokenPos = 0;\n    int prevSkipNext = 0;\n    int skipNext = 0;\n    int matchPos = 0;\n    int skipShift = 0;\n    // this variable keeps the total number\n    // of tokens skipped - used to avoid\n    // that nextPos gets back to unmatched tokens...\n    int skipShiftTotal = 0;\n\n    int firstMatchToken = -1;\n    int lastMatchToken = -1;\n    int patternSize = patternElements.size();\n    Element elem = null, prevElement = null;\n    final boolean startWithSentStart = patternElements.get(0).isSentStart();\n\n    for (int i = 0; i < tokens.length; i++) {\n      boolean allElementsMatch = true;\n\n      //stop processing if rule is longer than the sentence\n      if (patternSize + i > tokens.length) {\n        allElementsMatch = false;\n        break;\n      }\n\n      //stop looking for sent_start - it will never match any\n      //token except the first\n      if (startWithSentStart && i > 0) {\n        allElementsMatch = false;\n        break;\n      }\n\n      int matchingTokens = 0;\n      for (int k = 0; (k < patternSize); k++) {\n        if (elem != null) {\n          prevElement = elem;\n        }\n        elem = patternElements.get(k);\n        skipNext = elem.getSkipNext();\n        int nextPos = tokenPos + k + skipShiftTotal;\n        if (nextPos >= tokens.length) {\n          allElementsMatch = false;\n          break;\n        }\n\n        boolean skipMatch = false, thisMatched = false, prevMatched = false;\n        boolean exceptionMatched = false;\n        if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) { // SENT_END?\n          prevSkipNext = tokens.length - (nextPos + 1);\n        }\n        for (int m = nextPos; m <= nextPos + prevSkipNext; m++) {\n          boolean matched = false;\n          int numberOfReadings = tokens[m].getReadingsLength();\n\n          for (int l = 0; l < numberOfReadings; l++) {\n            AnalyzedToken matchToken = tokens[m].getAnalyzedToken(l);\n            if (prevSkipNext > 0 && prevElement != null) {\n              if (prevElement.prevExceptionMatch(matchToken)) {\n                exceptionMatched = true;\n                prevMatched = true;\n              }\n            }\n            thisMatched |= elem.match(matchToken);\n            exceptionMatched |= elem.exceptionMatch(matchToken);\n            // Logical OR (cannot be AND):\n            if (!thisMatched && !exceptionMatched) {\n              matched |= false;\n            } else {\n              matched = true;\n              matchPos = m;\n              skipShift = matchPos - nextPos;              \n              tokenPositions[matchingTokens] = skipShift + 1;              \n            }\n            skipMatch = (skipMatch || matched) && !exceptionMatched;\n          }\n          \n          //disallow exceptions that should match only current tokens          \n          if (!thisMatched && !prevMatched) {\n            exceptionMatched = false;\n          }\n                    \n          if (skipMatch) {\n            break;\n          }\n          \n        }\n        //disallow exceptions that should match only current tokens        \n        if (!thisMatched && !prevMatched) {\n          skipMatch = false;\n        }\n        allElementsMatch = skipMatch;\n        if (skipMatch) {\n          prevSkipNext = skipNext;\n        } else {\n          prevSkipNext = 0;\n        }\n        if (allElementsMatch) {                              \n          matchingTokens++;\n          lastMatchToken = matchPos; // nextPos;          \n          if (firstMatchToken == -1)\n            firstMatchToken = matchPos; // nextPos;\n          skipShiftTotal += skipShift;\n        } else {\n          skipShiftTotal = 0;\n          break;\n        }\n      }\n      \n      tokenPos++;\n      \n      if (allElementsMatch) {\n        String errMessage = formatMatches(tokens,\n            tokenPositions, firstMatchToken, matchingTokens,\n            message);\n                \n        int correctedStPos = 0;\n        if (startPositionCorrection > 0) {        \n        for (int l = 0; l <= startPositionCorrection; l++) {\n          correctedStPos +=  tokenPositions[l];\n        }\n        correctedStPos--;\n        }        \n        \n        int correctedEndPos = 0;\n        if (endPositionCorrection < 0) {\n          int l = 0;\n          while (l > endPositionCorrection) {\n            int test = matchingTokens + l - 1;\n            test = tokenPositions[test];\n            correctedEndPos -= tokenPositions[matchingTokens + l - 1];\n            l--;\n          }\n          }         \n        \n        AnalyzedTokenReadings firstMatchTokenObj = tokens[firstMatchToken + correctedStPos];\n        boolean startsWithUppercase = StringTools.startsWithUppercase(firstMatchTokenObj.toString());\n        if (firstMatchTokenObj.isSentStart() && tokens.length > firstMatchToken + correctedStPos + 1) {\n          // make uppercasing work also at sentence start: \n          firstMatchTokenObj = tokens[firstMatchToken + correctedStPos + 1];\n          startsWithUppercase = StringTools.startsWithUppercase(firstMatchTokenObj.toString());\n        }\n        int fromPos = tokens[firstMatchToken + correctedStPos]\n                             .getStartPos();\n        int toPos = tokens[lastMatchToken + correctedEndPos].getStartPos()\n        + tokens[lastMatchToken + correctedEndPos].getToken().length();\n        if (fromPos < toPos) { //this can happen with some skip=\"-1\" when the last token is not matched\n        RuleMatch ruleMatch = new RuleMatch(this, fromPos, toPos, errMessage,\n            startsWithUppercase);        \n          ruleMatches.add(ruleMatch);        \n        }\n      } else {\n        firstMatchToken = -1;\n        lastMatchToken = -1;\n        skipShiftTotal = 0;\n      }\n    }\n\n    return (RuleMatch[]) ruleMatches.toArray(new RuleMatch[ruleMatches.size()]);\n  }","id":23523,"modified_method":"public final RuleMatch[] match(final AnalyzedSentence text) throws IOException {\n            \n    List<RuleMatch> ruleMatches = new ArrayList<RuleMatch>();    \n    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();\n    int[] tokenPositions = new int[tokens.length + 1 ];\n    \n    int tokenPos = 0;\n    int prevSkipNext = 0;\n    int skipNext = 0;\n    int matchPos = 0;\n    int skipShift = 0;\n    // this variable keeps the total number\n    // of tokens skipped - used to avoid\n    // that nextPos gets back to unmatched tokens...\n    int skipShiftTotal = 0;\n\n    int firstMatchToken = -1;\n    int lastMatchToken = -1;\n    int patternSize = patternElements.size();\n    Element elem = null, prevElement = null;\n    final boolean startWithSentStart = patternElements.get(0).isSentStart();\n\n    for (int i = 0; i < tokens.length; i++) {\n      boolean allElementsMatch = true;\n\n      //stop processing if rule is longer than the sentence\n      if (patternSize + i > tokens.length) {\n        allElementsMatch = false;\n        break;\n      }\n\n      //stop looking for sent_start - it will never match any\n      //token except the first\n      if (startWithSentStart && i > 0) {\n        allElementsMatch = false;\n        break;\n      }\n\n      int matchingTokens = 0;\n      for (int k = 0; (k < patternSize); k++) {\n        if (elem != null) {\n          prevElement = elem;\n        }\n        elem = patternElements.get(k);\n        skipNext = elem.getSkipNext();\n        int nextPos = tokenPos + k + skipShiftTotal;\n        if (nextPos >= tokens.length) {\n          allElementsMatch = false;\n          break;\n        }\n\n        boolean skipMatch = false, thisMatched = false, prevMatched = false;\n        boolean exceptionMatched = false;\n        if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) { // SENT_END?\n          prevSkipNext = tokens.length - (nextPos + 1);\n        }\n        for (int m = nextPos; m <= nextPos + prevSkipNext; m++) {\n          boolean matched = false;\n          int numberOfReadings = tokens[m].getReadingsLength();\n\n          for (int l = 0; l < numberOfReadings; l++) {\n            AnalyzedToken matchToken = tokens[m].getAnalyzedToken(l);\n            if (prevSkipNext > 0 && prevElement != null) {\n              if (prevElement.prevExceptionMatch(matchToken)) {\n                exceptionMatched = true;\n                prevMatched = true;\n              }\n            }\n            thisMatched |= elem.match(matchToken);\n            exceptionMatched |= (elem.exceptionMatch(matchToken) \n                  || elem.andGroupExceptionMatch(matchToken));\n            // Logical OR (cannot be AND):\n            if (!thisMatched && !exceptionMatched) {\n              matched |= false;\n            } else {\n              matched = true;\n              matchPos = m;\n              skipShift = matchPos - nextPos;              \n              tokenPositions[matchingTokens] = skipShift + 1;              \n            }\n            skipMatch = (skipMatch || matched) && !exceptionMatched;\n          }\n          \n          //disallow exceptions that should match only current tokens          \n          if (!thisMatched && !prevMatched) {\n            exceptionMatched = false;\n          }\n                    \n          if (skipMatch) {\n            break;\n          }\n          \n        }\n        //disallow exceptions that should match only current tokens        \n        if (!thisMatched && !prevMatched) {\n          skipMatch = false;\n        }\n        allElementsMatch = skipMatch;\n        if (skipMatch) {\n          prevSkipNext = skipNext;\n        } else {\n          prevSkipNext = 0;\n        }\n        if (allElementsMatch) {                              \n          matchingTokens++;\n          lastMatchToken = matchPos; // nextPos;          \n          if (firstMatchToken == -1)\n            firstMatchToken = matchPos; // nextPos;\n          skipShiftTotal += skipShift;\n        } else {\n          skipShiftTotal = 0;\n          break;\n        }\n      }\n      \n      tokenPos++;\n      \n      if (allElementsMatch) {\n        if (firstMatchToken + matchingTokens >= tokens.length) {\n          matchingTokens = tokens.length - firstMatchToken;\n        }\n        String errMessage = formatMatches(tokens,\n            tokenPositions, firstMatchToken, matchingTokens,\n            message);\n                \n        int correctedStPos = 0;\n        if (startPositionCorrection > 0) {        \n        for (int l = 0; l <= startPositionCorrection; l++) {\n          correctedStPos +=  tokenPositions[l];\n        }\n        correctedStPos--;\n        }        \n        \n        int correctedEndPos = 0;\n        if (endPositionCorrection < 0) {\n          int l = 0;\n          while (l > endPositionCorrection) {\n            int test = matchingTokens + l - 1;\n            test = tokenPositions[test];\n            correctedEndPos -= tokenPositions[matchingTokens + l - 1];\n            l--;\n          }\n          }         \n        \n        AnalyzedTokenReadings firstMatchTokenObj = tokens[firstMatchToken + correctedStPos];\n        boolean startsWithUppercase = StringTools.startsWithUppercase(firstMatchTokenObj.toString());\n        if (firstMatchTokenObj.isSentStart() && tokens.length > firstMatchToken + correctedStPos + 1) {\n          // make uppercasing work also at sentence start: \n          firstMatchTokenObj = tokens[firstMatchToken + correctedStPos + 1];\n          startsWithUppercase = StringTools.startsWithUppercase(firstMatchTokenObj.toString());\n        }\n        int fromPos = tokens[firstMatchToken + correctedStPos]\n                             .getStartPos();\n        int toPos = tokens[lastMatchToken + correctedEndPos].getStartPos()\n        + tokens[lastMatchToken + correctedEndPos].getToken().length();\n        if (fromPos < toPos) { //this can happen with some skip=\"-1\" when the last token is not matched\n        RuleMatch ruleMatch = new RuleMatch(this, fromPos, toPos, errMessage,\n            startsWithUppercase);        \n          ruleMatches.add(ruleMatch);        \n        }\n      } else {\n        firstMatchToken = -1;\n        lastMatchToken = -1;\n        skipShiftTotal = 0;\n      }\n    }\n\n    return (RuleMatch[]) ruleMatches.toArray(new RuleMatch[ruleMatches.size()]);\n  }","commit_id":"3e97a537631038d74cb75b76e3146241703ee16b","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@SuppressWarnings(\"unused\")\n  public void startElement(String namespaceURI, String lName, String qName, Attributes attrs)\n      throws SAXException {\n    if (qName.equals(\"category\")) {\n      String catName = attrs.getValue(\"name\");\n      String prioStr = attrs.getValue(\"priority\");\n      int prio = 0;\n      if (prioStr != null)\n        category = new Category(catName, Integer.parseInt(prioStr));\n      else\n        category = new Category(catName);\n    } else if (qName.equals(\"rules\")) {\n      String languageStr = attrs.getValue(\"lang\");\n      language = Language.getLanguageForShortName(languageStr);\n      if (language == null) {\n        throw new SAXException(\"Unknown language '\" + languageStr + \"'\");\n      }\n    } else if (qName.equals(\"rule\")) {\n      id = attrs.getValue(\"id\");\n      if (inRuleGroup && id == null)\n        id = ruleGroupId;\n      description = attrs.getValue(\"name\");\n      if (inRuleGroup && description == null)\n        description = ruleGroupDescription;\n      correctExamples = new ArrayList<String>();\n      incorrectExamples = new ArrayList<String>();\n    } else if (qName.equals(\"pattern\")) {\n      inPattern = true;\n      if (attrs.getValue(\"mark_from\") != null)\n        startPositionCorrection = Integer.parseInt(attrs.getValue(\"mark_from\"));\n      if (attrs.getValue(\"mark_to\") != null)\n        endPositionCorrection = Integer.parseInt(attrs.getValue(\"mark_to\"));\n      if (attrs.getValue(\"case_sensitive\") != null\n          && attrs.getValue(\"case_sensitive\").equals(\"yes\"))\n        caseSensitive = true;\n    } else if (qName.equals(\"token\")) {\n      inToken = true;\n      \n      if (lastPhrase && elementList != null) {\n        elementList.clear();\n      }\n      \n      lastPhrase = false;\n      if (attrs.getValue(\"negate\") != null) {\n        stringNegation = attrs.getValue(\"negate\").equals(\"yes\");\n      }\n      if (attrs.getValue(\"inflected\") != null) {\n        stringInflected = attrs.getValue(\"inflected\").equals(\"yes\");\n      }\n      if (attrs.getValue(\"skip\") != null) {\n        skipPos = Integer.parseInt(attrs.getValue(\"skip\"));\n      }\n      elements = new StringBuffer();\n      if (elementList == null) {\n        elementList = new ArrayList<Element>();\n      }\n      // POSElement creation\n      if (attrs.getValue(\"postag\") != null) {\n        posToken = attrs.getValue(\"postag\");\n        if (attrs.getValue(\"postag_regexp\") != null) {\n          posRegExp = attrs.getValue(\"postag_regexp\").equals(\"yes\");\n        }\n        if (attrs.getValue(\"negate_pos\") != null) {\n          posNegation = attrs.getValue(\"negate_pos\").equals(\"yes\");\n        }\n      }\n      if (attrs.getValue(\"regexp\") != null) {\n        stringRegExp = attrs.getValue(\"regexp\").equals(\"yes\");\n      }\n\n    } else if (qName.equals(\"exception\")) {\n      inException = true;      \n      exceptions = new StringBuffer();\n\n      if (attrs.getValue(\"negate\") != null) {\n        exceptionStringNegation = attrs.getValue(\"negate\").equals(\"yes\");\n      }\n      if (attrs.getValue(\"scope\") != null) {\n        exceptionValidNext = attrs.getValue(\"scope\").equals(\"next\");\n      }\n      if (attrs.getValue(\"inflected\") != null) {\n        exceptionStringInflected = attrs.getValue(\"inflected\").equals(\"yes\");\n      }\n      if (attrs.getValue(\"postag\") != null) {\n        exceptionPosToken = attrs.getValue(\"postag\");\n        if (attrs.getValue(\"postag_regexp\") != null) {\n          exceptionPosRegExp = attrs.getValue(\"postag_regexp\").equals(\"yes\");\n        }\n        if (attrs.getValue(\"negate_pos\") != null) {\n          exceptionPosNegation = attrs.getValue(\"negate_pos\").equals(\"yes\");\n        }\n      }\n      if (attrs.getValue(\"regexp\") != null) {\n        exceptionStringRegExp = attrs.getValue(\"regexp\").equals(\"yes\");\n      }\n\n    } else if (qName.equals(\"example\") \n        && attrs.getValue(\"type\").equals(\"correct\")) {\n      inCorrectExample = true;\n      correctExample = new StringBuffer();\n    } else if (qName.equals(\"example\") \n        && attrs.getValue(\"type\").equals(\"incorrect\")) {\n      inIncorrectExample = true;\n      incorrectExample = new StringBuffer();\n      //kludgy but simple\n      if (attrs.getValue(\"correction\") != null) {\n        incorrectExample.append(\"<correction>\" \n            + attrs.getValue(\"correction\")\n            + \"<\/correction>\");\n      }\n    } else if (qName.equals(\"message\")) {\n      inMessage = true;\n      message = new StringBuffer();\n    } else if (qName.equals(\"rulegroup\")) {\n      ruleGroupId = attrs.getValue(\"id\");\n      ruleGroupDescription = attrs.getValue(\"name\");\n      inRuleGroup = true;\n    } else if (qName.equals(\"suggestion\") && inMessage) {\n      message.append(\"<suggestion>\");\n    } else if (qName.equals(\"match\") && inMessage) {\n      inMatch = true;\n      match = new StringBuffer();\n      if (suggestionMatches == null) {\n        suggestionMatches = new ArrayList<Match>();        \n      }      \n      Match.CaseConversion caseConv = Match.CaseConversion.NONE; \n      if (attrs.getValue(\"case_conversion\") != null) {\n        caseConv = Match.CaseConversion.toCase(\n              attrs.getValue(\"case_conversion\").toUpperCase());\n      }      \n      Match mWorker = new Match(attrs.getValue(\"postag\"),\n          attrs.getValue(\"postag_replace\"),\n          \"yes\".equals(attrs.getValue(\"postag_regexp\")),\n          attrs.getValue(\"regexp_match\"), \n          attrs.getValue(\"regexp_replace\"), caseConv);       \n      suggestionMatches.add(mWorker);\n      message.append(\"\\\\\" + attrs.getValue(\"no\"));\n    } else if (qName.equals(\"marker\") && inCorrectExample) {\n      correctExample.append(\"<marker>\");\n    } else if (qName.equals(\"marker\") && inIncorrectExample) {\n      incorrectExample.append(\"<marker>\");\n    } else if (qName.equals(\"phrases\")) {\n      inPhrases = true;\n    } else if (qName.equals(\"includephrases\")) {\n      // lazy init\n      if (phraseElementList == null) {\n        phraseElementList = new ArrayList < ArrayList < Element > > ();\n      }\n      if (elementList == null) {\n        elementList = new ArrayList < Element >();\n      }\n          \n    } else if (qName.equals(\"phrase\") && inPhrases) {\n      phraseId = attrs.getValue(\"id\");      \n    } else if (qName.equals(\"phraseref\")) {\n      if (attrs.getValue(\"idref\") != null) {\n        phraseIdRef = attrs.getValue(\"idref\");\n      if (phraseMap.containsKey(phraseIdRef)) {      \n      ArrayList < ArrayList < Element > > curPhraseElementList = phraseMap.get(phraseIdRef);              \n      Iterator < ArrayList <Element> > it = curPhraseElementList.iterator();\n      //ArrayList <Element> prevList = new ArrayList <Element > (elementList);                                   \n      \n      while (it.hasNext()) {              \n        if (!elementList.isEmpty()) {\n          ArrayList <Element> prevList = new ArrayList <Element > (elementList);\n          prevList.addAll(it.next());\n          phraseElementList.add(new ArrayList <Element>(prevList));\n          prevList.clear();\n        } else {        \n        phraseElementList.add(new ArrayList <Element>(it.next()));\n        }       \n      }\n      lastPhrase = true;\n      }                     \n     }\n    }\n   }","id":23524,"modified_method":"@SuppressWarnings(\"unused\")\n  public void startElement(String namespaceURI, String lName, String qName, Attributes attrs)\n      throws SAXException {\n    if (qName.equals(\"category\")) {\n      String catName = attrs.getValue(\"name\");\n      String prioStr = attrs.getValue(\"priority\");\n      int prio = 0;\n      if (prioStr != null)\n        category = new Category(catName, Integer.parseInt(prioStr));\n      else\n        category = new Category(catName);\n    } else if (qName.equals(\"rules\")) {\n      String languageStr = attrs.getValue(\"lang\");\n      language = Language.getLanguageForShortName(languageStr);\n      if (language == null) {\n        throw new SAXException(\"Unknown language '\" + languageStr + \"'\");\n      }\n    } else if (qName.equals(\"rule\")) {\n      id = attrs.getValue(\"id\");\n      if (inRuleGroup && id == null)\n        id = ruleGroupId;\n      description = attrs.getValue(\"name\");\n      if (inRuleGroup && description == null)\n        description = ruleGroupDescription;\n      correctExamples = new ArrayList<String>();\n      incorrectExamples = new ArrayList<String>();\n    } else if (qName.equals(\"pattern\")) {\n      inPattern = true;\n      if (attrs.getValue(\"mark_from\") != null)\n        startPositionCorrection = Integer.parseInt(attrs.getValue(\"mark_from\"));\n      if (attrs.getValue(\"mark_to\") != null)\n        endPositionCorrection = Integer.parseInt(attrs.getValue(\"mark_to\"));\n      if (attrs.getValue(\"case_sensitive\") != null\n          && attrs.getValue(\"case_sensitive\").equals(\"yes\"))\n        caseSensitive = true;\n    } else if (qName.equals(\"and\")) {\n      inAndGroup = true;\n    } else if (qName.equals(\"token\")) {\n      inToken = true;\n      \n      if (lastPhrase && elementList != null) {\n        elementList.clear();\n      }\n      \n      lastPhrase = false;\n      if (attrs.getValue(\"negate\") != null) {\n        stringNegation = attrs.getValue(\"negate\").equals(\"yes\");\n      }\n      if (attrs.getValue(\"inflected\") != null) {\n        stringInflected = attrs.getValue(\"inflected\").equals(\"yes\");\n      }\n      if (attrs.getValue(\"skip\") != null) {\n        skipPos = Integer.parseInt(attrs.getValue(\"skip\"));\n      }\n      elements = new StringBuffer();\n      if (elementList == null) {\n        elementList = new ArrayList<Element>();\n      }\n      // POSElement creation\n      if (attrs.getValue(\"postag\") != null) {\n        posToken = attrs.getValue(\"postag\");\n        if (attrs.getValue(\"postag_regexp\") != null) {\n          posRegExp = attrs.getValue(\"postag_regexp\").equals(\"yes\");\n        }\n        if (attrs.getValue(\"negate_pos\") != null) {\n          posNegation = attrs.getValue(\"negate_pos\").equals(\"yes\");\n        }\n      }\n      if (attrs.getValue(\"regexp\") != null) {\n        stringRegExp = attrs.getValue(\"regexp\").equals(\"yes\");\n      }\n\n    } else if (qName.equals(\"exception\")) {\n      inException = true;      \n      exceptions = new StringBuffer();\n\n      if (attrs.getValue(\"negate\") != null) {\n        exceptionStringNegation = attrs.getValue(\"negate\").equals(\"yes\");\n      }\n      if (attrs.getValue(\"scope\") != null) {\n        exceptionValidNext = attrs.getValue(\"scope\").equals(\"next\");\n      }\n      if (attrs.getValue(\"inflected\") != null) {\n        exceptionStringInflected = attrs.getValue(\"inflected\").equals(\"yes\");\n      }\n      if (attrs.getValue(\"postag\") != null) {\n        exceptionPosToken = attrs.getValue(\"postag\");\n        if (attrs.getValue(\"postag_regexp\") != null) {\n          exceptionPosRegExp = attrs.getValue(\"postag_regexp\").equals(\"yes\");\n        }\n        if (attrs.getValue(\"negate_pos\") != null) {\n          exceptionPosNegation = attrs.getValue(\"negate_pos\").equals(\"yes\");\n        }\n      }\n      if (attrs.getValue(\"regexp\") != null) {\n        exceptionStringRegExp = attrs.getValue(\"regexp\").equals(\"yes\");\n      }\n\n    } else if (qName.equals(\"example\") \n        && attrs.getValue(\"type\").equals(\"correct\")) {\n      inCorrectExample = true;\n      correctExample = new StringBuffer();\n    } else if (qName.equals(\"example\") \n        && attrs.getValue(\"type\").equals(\"incorrect\")) {\n      inIncorrectExample = true;\n      incorrectExample = new StringBuffer();\n      //kludgy but simple\n      if (attrs.getValue(\"correction\") != null) {\n        incorrectExample.append(\"<correction>\" \n            + attrs.getValue(\"correction\")\n            + \"<\/correction>\");\n      }\n    } else if (qName.equals(\"message\")) {\n      inMessage = true;\n      message = new StringBuffer();\n    } else if (qName.equals(\"rulegroup\")) {\n      ruleGroupId = attrs.getValue(\"id\");\n      ruleGroupDescription = attrs.getValue(\"name\");\n      inRuleGroup = true;\n    } else if (qName.equals(\"suggestion\") && inMessage) {\n      message.append(\"<suggestion>\");\n    } else if (qName.equals(\"match\") && inMessage) {\n      inMatch = true;\n      match = new StringBuffer();\n      if (suggestionMatches == null) {\n        suggestionMatches = new ArrayList<Match>();        \n      }      \n      Match.CaseConversion caseConv = Match.CaseConversion.NONE; \n      if (attrs.getValue(\"case_conversion\") != null) {\n        caseConv = Match.CaseConversion.toCase(\n              attrs.getValue(\"case_conversion\").toUpperCase());\n      }      \n      final Match mWorker = new Match(attrs.getValue(\"postag\"),\n          attrs.getValue(\"postag_replace\"),\n          \"yes\".equals(attrs.getValue(\"postag_regexp\")),\n          attrs.getValue(\"regexp_match\"), \n          attrs.getValue(\"regexp_replace\"), caseConv);       \n      suggestionMatches.add(mWorker);\n      message.append(\"\\\\\" + attrs.getValue(\"no\"));\n    } else if (qName.equals(\"marker\") && inCorrectExample) {\n      correctExample.append(\"<marker>\");\n    } else if (qName.equals(\"marker\") && inIncorrectExample) {\n      incorrectExample.append(\"<marker>\");\n    } else if (qName.equals(\"phrases\")) {\n      inPhrases = true;\n    } else if (qName.equals(\"includephrases\")) {\n      phraseElementInit();      \n      if (elementList == null) {\n        elementList = new ArrayList < Element >();\n      }\n          \n    } else if (qName.equals(\"phrase\") && inPhrases) {\n      phraseId = attrs.getValue(\"id\");      \n    } else if (qName.equals(\"phraseref\")) {\n      if (attrs.getValue(\"idref\") != null) {\n        phraseIdRef = attrs.getValue(\"idref\");\n      if (phraseMap.containsKey(phraseIdRef)) {      \n      ArrayList < ArrayList < Element > > curPhraseElementList = phraseMap.get(phraseIdRef);              \n      for (ArrayList < Element > curPhrEl : curPhraseElementList) {              \n        if (!elementList.isEmpty()) {\n          ArrayList < Element > prevList = new ArrayList < Element > (elementList);\n          prevList.addAll(curPhrEl);\n          phraseElementList.add(new ArrayList <Element>(prevList));\n          prevList.clear();\n        } else {        \n        phraseElementList.add(new ArrayList <Element>(curPhrEl));\n        }       \n      }\n      lastPhrase = true;\n      }                     \n     }\n    }\n   }","commit_id":"3e97a537631038d74cb75b76e3146241703ee16b","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@SuppressWarnings(\"unused\")\n  public void endElement(String namespaceURI, String sName, String qName) {\n    \n    if (qName.equals(\"rule\")) {\n      if (phraseElementList == null) {\n        phraseElementList = new ArrayList < ArrayList < Element > > ();\n      }\n        if (!phraseElementList.isEmpty()) {                                       \n          \n          if (!elementList.isEmpty()) { \n          Iterator < ArrayList < Element > > phIt = phraseElementList.iterator();                    \n          while (phIt.hasNext()) {\n            phIt.next().addAll(new ArrayList <Element> (elementList));\n          }\n          }\n          \n          Iterator < ArrayList < Element > > it = phraseElementList.iterator();\n            while (it.hasNext()) {\n              PatternRule rule = new PatternRule(id, language, it.next(), description, message.toString(), phraseElementList.size()>1);      \n              rule.setStartPositionCorrection(startPositionCorrection);\n              rule.setEndPositionCorrection(endPositionCorrection);\n              startPositionCorrection = 0;\n              endPositionCorrection = 0;\n              rule.setCorrectExamples(correctExamples);\n              rule.setIncorrectExamples(incorrectExamples);              \n              rule.setCategory(category);\n              caseSensitive = false;\n              if (suggestionMatches != null) {\n                for (Match m : suggestionMatches) {\n                  rule.addSuggestionMatch(m);\n                }\n                suggestionMatches.clear();\n              }\n              rules.add(rule);              \n            }\n        } else {\n      PatternRule rule = new PatternRule(id, language, elementList, description, message.toString());      \n      rule.setStartPositionCorrection(startPositionCorrection);\n      rule.setEndPositionCorrection(endPositionCorrection);\n      startPositionCorrection = 0;\n      endPositionCorrection = 0;\n      rule.setCorrectExamples(correctExamples);\n      rule.setIncorrectExamples(incorrectExamples);      \n      rule.setCategory(category);\n      caseSensitive = false;\n      if (suggestionMatches != null) {\n        for (Match m : suggestionMatches) {\n          rule.addSuggestionMatch(m);\n        }\n        suggestionMatches.clear();\n      }\n      rules.add(rule);\n      }\n      \n       if (elementList != null) {\n        elementList.clear();\n      }      \n       if (phraseElementList != null) {\n        phraseElementList.clear();\n      }\n      \n    } else if (qName.equals(\"exception\")) {\n      inException = false;\n      if (!exceptionSet) {\n      stringElement = new Element(elements.toString(), caseSensitive, stringRegExp,\n          stringInflected);\n      exceptionSet = true;\n      }\n      stringElement.setNegation(stringNegation);\n        if (!exceptions.toString().equals(\"\")) {\n        stringElement.setStringException(exceptions.toString(), exceptionStringRegExp, \n            exceptionStringInflected, exceptionStringNegation, exceptionValidNext);\n        }              \n      if (exceptionPosToken != null) {\n        stringElement.setPosException(exceptionPosToken, exceptionPosRegExp, exceptionPosNegation, exceptionValidNext);\n        exceptionPosToken = null;\n      }\n      \n    } else if (qName.equals(\"token\")) {\n      if (!exceptionSet || stringElement == null) {\n      stringElement = new Element(elements.toString(), caseSensitive, stringRegExp,\n          stringInflected);\n      stringElement.setNegation(stringNegation);\n      } else {\n        stringElement.setStringElement(elements.toString());\n      }\n      if (skipPos != 0) {\n        stringElement.setSkipNext(skipPos);\n        skipPos = 0;\n      }\n      if (posToken != null) {\n        stringElement.setPosElement(posToken, posRegExp, posNegation);\n        posToken = null;\n      }      \n      elementList.add(stringElement);\n      stringNegation = false;\n      stringInflected = false;\n      posNegation = false;\n      posRegExp = false;\n      inToken = false;\n      stringRegExp = false;\n\n      exceptionStringNegation = false;\n      exceptionStringInflected = false;\n      exceptionPosNegation = false;\n      exceptionPosRegExp = false;\n      exceptionStringRegExp = false;\n      exceptionValidNext = true;\n      exceptionSet = false;\n\n    } else if (qName.equals(\"pattern\")) {\n      inPattern = false;\n      if (lastPhrase) {\n        elementList.clear();\n      }\n    } else if (qName.equals(\"example\")) {\n      if (inCorrectExample) {\n        correctExamples.add(correctExample.toString());\n      } else if (inIncorrectExample) {\n        incorrectExamples.add(incorrectExample.toString());\n      }\n      inCorrectExample = false;\n      inIncorrectExample = false;\n      correctExample = new StringBuffer();\n      incorrectExample = new StringBuffer();\n    } else if (qName.equals(\"message\")) {\n      inMessage = false; \n    } else if (qName.equals(\"match\")) {\n      suggestionMatches.get(suggestionMatches.size() - 1).setLemmaString(match.toString());\n      inMatch = false;\n    } else if (qName.equals(\"rulegroup\")) {\n      inRuleGroup = false;\n    } else if (qName.equals(\"suggestion\") && inMessage) {\n      message.append(\"<\/suggestion>\");\n    } else if (qName.equals(\"marker\") && inCorrectExample) {\n      correctExample.append(\"<\/marker>\");\n    } else if (qName.equals(\"marker\") && inIncorrectExample) {\n      incorrectExample.append(\"<\/marker>\");\n    } else if (qName.equals(\"phrase\") && inPhrases) {      \n      // lazy init\n      if (phraseMap == null) {\n        phraseMap = new HashMap < String, ArrayList < ArrayList < Element > > > ();\n      }      \n      if (phraseElementList == null) {\n        phraseElementList = new ArrayList < ArrayList < Element > > ();\n      }\n      \n      if (elementList != null) {\n      if (!phraseElementList.isEmpty()) {\n        Iterator < ArrayList < Element > > phIt = phraseElementList.iterator();\n         while (phIt.hasNext()) {\n           phIt.next().addAll(new ArrayList <Element> (elementList));\n         }\n      } else {\n        phraseElementList.add(new ArrayList < Element > (elementList));\n        }\n      }     \n      phraseMap.put(phraseId, new ArrayList < ArrayList < Element > >(phraseElementList));\n      if (elementList != null) {\n        elementList.clear();\n      }\n      phraseElementList.clear();\n    } else if (qName.equals(\"includephrases\")) {\n      elementList.clear();      \n    } else if (qName.equals(\"phrases\") && inPhrases) {\n      inPhrases = false;\n    } \n  }","id":23525,"modified_method":"@SuppressWarnings(\"unused\")\n  public void endElement(String namespaceURI, String sName, String qName) {\n\n    if (qName.equals(\"rule\")) {\n      phraseElementInit();\n      if (!phraseElementList.isEmpty()) {                                       \n\n        if (!elementList.isEmpty()) { \n          for (ArrayList < Element > ph : phraseElementList) {\n            ph.addAll(new ArrayList <Element> (elementList));\n          }\n        }\n\n        for (ArrayList < Element > phraseElement : phraseElementList) {\n          PatternRule rule = new PatternRule(id, language, phraseElement, description, message.toString(), phraseElementList.size()>1);      \n          prepareRule(rule);\n          rules.add(rule);              \n        }\n      } else {\n        PatternRule rule = new PatternRule(id, language, elementList, description, message.toString());\n        prepareRule(rule);\n        rules.add(rule);\n      }\n\n      if (elementList != null) {\n        elementList.clear();\n      }      \n      if (phraseElementList != null) {\n        phraseElementList.clear();\n      }\n\n    } else if (qName.equals(\"exception\")) {\n      inException = false;\n      if (!exceptionSet) {\n        tokenElement = new Element(elements.toString(), \n            caseSensitive, stringRegExp, stringInflected);\n        exceptionSet = true;\n      }\n      tokenElement.setNegation(stringNegation);\n      if (!exceptions.toString().equals(\"\")) {\n        tokenElement.setStringException(exceptions.toString(), exceptionStringRegExp, \n            exceptionStringInflected, exceptionStringNegation, exceptionValidNext);\n      }              \n      if (exceptionPosToken != null) {\n        tokenElement.setPosException(exceptionPosToken, exceptionPosRegExp, exceptionPosNegation, exceptionValidNext);\n        exceptionPosToken = null;\n      }\n\n    } else if (qName.equals(\"and\")) {\n      inAndGroup = false;\n      andGroupCounter = 0;\n    } else if (qName.equals(\"token\")) {\n      if (!exceptionSet || tokenElement == null) {\n        tokenElement = new Element(elements.toString(), caseSensitive, stringRegExp,\n            stringInflected);\n        tokenElement.setNegation(stringNegation);\n      } else {\n        tokenElement.setStringElement(elements.toString());\n      }\n      if (skipPos != 0) {\n        tokenElement.setSkipNext(skipPos);\n        skipPos = 0;\n      }\n      if (posToken != null) {\n        tokenElement.setPosElement(posToken, posRegExp, posNegation);\n        posToken = null;\n      }\n      if (inAndGroup && andGroupCounter > 0) {\n        elementList.get(elementList.size() - 1).setAndGroupElement(tokenElement);\n      } else {\n        elementList.add(tokenElement);\n      }\n      if (inAndGroup) {\n        andGroupCounter++;\n      }\n      resetToken();\n    } else if (qName.equals(\"pattern\")) {\n      inPattern = false;\n      if (lastPhrase) {\n        elementList.clear();\n      }\n    } else if (qName.equals(\"example\")) {\n      if (inCorrectExample) {\n        correctExamples.add(correctExample.toString());\n      } else if (inIncorrectExample) {\n        incorrectExamples.add(incorrectExample.toString());\n      }\n      inCorrectExample = false;\n      inIncorrectExample = false;\n      correctExample = new StringBuffer();\n      incorrectExample = new StringBuffer();\n    } else if (qName.equals(\"message\")) {\n      inMessage = false; \n    } else if (qName.equals(\"match\")) {\n      suggestionMatches.get(suggestionMatches.size() - 1).setLemmaString(match.toString());\n      inMatch = false;\n    } else if (qName.equals(\"rulegroup\")) {\n      inRuleGroup = false;\n    } else if (qName.equals(\"suggestion\") && inMessage) {\n      message.append(\"<\/suggestion>\");\n    } else if (qName.equals(\"marker\") && inCorrectExample) {\n      correctExample.append(\"<\/marker>\");\n    } else if (qName.equals(\"marker\") && inIncorrectExample) {\n      incorrectExample.append(\"<\/marker>\");\n    } else if (qName.equals(\"phrase\") && inPhrases) {      \n      // lazy init\n      if (phraseMap == null) {\n        phraseMap = new HashMap < String, ArrayList < ArrayList < Element > > > ();\n      }      \n      phraseElementInit();\n\n      if (elementList != null) {\n        if (!phraseElementList.isEmpty()) {\n          for (ArrayList < Element > ph : phraseElementList) {\n            ph.addAll(new ArrayList <Element> (elementList));\n          }\n        } else {\n          phraseElementList.add(new ArrayList < Element > (elementList));\n        }\n      }     \n      phraseMap.put(phraseId, new ArrayList < ArrayList < Element > >(phraseElementList));\n      if (elementList != null) {\n        elementList.clear();\n      }\n      phraseElementList.clear();\n    } else if (qName.equals(\"includephrases\")) {\n      elementList.clear();      \n    } else if (qName.equals(\"phrases\") && inPhrases) {\n      inPhrases = false;\n    } \n  }","commit_id":"3e97a537631038d74cb75b76e3146241703ee16b","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public String[] synthesize(AnalyzedToken token, String posTag) throws IOException {\n    if (synthesizer == null) {\n      synthesizer = \n        new Lametyzator(this.getClass().getResourceAsStream(RESOURCE_FILENAME),\n          \"iso8859-2\", '+');\n    }\n    boolean isNegated = false;\n    if (posTag != null && token.getPOSTag() != null) {\n      isNegated = posTag.indexOf(\":neg\") > 0 \n      || token.getPOSTag().indexOf(\":neg\") > 0;\n    }\n\n    String[] wordForms = null;\n    if (isNegated) {\n      wordForms = synthesizer.stem(token.getLemma() + \"|\" + posTag.replaceFirst(\":neg\", \":pneg\"));\n      if (wordForms != null) {\n        String[] negForms = wordForms;\n        for (int i = 0; i < wordForms.length; i++) {\n          negForms[i] = \"nie\" + wordForms[i];\n        }\n        wordForms = negForms;\n      }\n    } else {\n    wordForms = synthesizer.stem(token.getLemma() + \"|\" + posTag);\n    }\n    return wordForms;\n  }","id":23526,"modified_method":"public String[] synthesize(AnalyzedToken token, String posTag) throws IOException {\n    if (posTag == null) {\n      return null;\n    }\n    if (synthesizer == null) {\n      synthesizer = \n        new Lametyzator(this.getClass().getResourceAsStream(RESOURCE_FILENAME),\n          \"iso8859-2\", '+');\n    }\n    boolean isNegated = false;\n    if (token.getPOSTag() != null) {\n      isNegated = posTag.indexOf(\":neg\") > 0 \n      || token.getPOSTag().indexOf(\":neg\") > 0;\n    }\n    if (posTag.indexOf(\"+\") > 0) {      \n      return synthesize(token, posTag, true);\n    } else {\n    String[] wordForms = null;\n    if (isNegated) {\n      wordForms = synthesizer.stem(token.getLemma() + \"|\" + posTag.replaceFirst(\":neg\", \":pneg\"));\n      if (wordForms != null) {\n        String[] negForms = wordForms;\n        for (int i = 0; i < wordForms.length; i++) {\n          negForms[i] = \"nie\" + wordForms[i];\n        }\n        wordForms = negForms;\n      }\n    } else {\n    wordForms = synthesizer.stem(token.getLemma() + \"|\" + posTag);\n    }\n    return wordForms;\n    }\n  }","commit_id":"3e97a537631038d74cb75b76e3146241703ee16b","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public String[] synthesize(AnalyzedToken token, String posTag, boolean posTagRegExp)\n      throws IOException {\n    \n    if (posTagRegExp) {\n    if (possibleTags == null) {\n      possibleTags = loadWords(this.getClass().getResourceAsStream(TAGS_FILE_NAME));\n    }\n    if (synthesizer == null) {\n      synthesizer = \n        new Lametyzator(this.getClass().getResourceAsStream(RESOURCE_FILENAME),\n          \"iso8859-2\", '+');\n    }    \n    Pattern p = Pattern.compile(posTag.replaceAll(\"\\\\+\", \"|\"));\n    ArrayList<String> results = new ArrayList<String>();\n    \n    boolean isNegated = false;\n    if (posTag != null && token.getPOSTag() != null) {\n      isNegated = posTag.indexOf(\":neg\") > 0 \n      || token.getPOSTag().indexOf(\":neg\") > 0;\n    }\n    \n    for (String tag : possibleTags) {\n      Matcher m = p.matcher(tag);\n        if (m.matches()) {\n          String[] wordForms = null;          \n          if (isNegated) {\n            wordForms = synthesizer.stem(token.getLemma() + \"|\" + tag.replaceAll(\":neg\", \":pneg\"));\n            if (wordForms != null) {\n              String[] negForms = wordForms;\n              for (int i = 0; i < wordForms.length; i++) {\n                negForms[i] = \"nie\" + wordForms[i];\n              }\n              wordForms = negForms;\n            }\n          } else { \n          wordForms = synthesizer.stem(token.getLemma() + \"|\" + tag);\n          }\n          if (wordForms != null) {\n            results.addAll(Arrays.asList(wordForms));\n          }\n      }\n    }\n       return (String[]) results.toArray(new String[results.size()]);    \n    } else {\n      return synthesize(token, posTag);\n    }    \n  }","id":23527,"modified_method":"public String[] synthesize(AnalyzedToken token, String posTag, boolean posTagRegExp)\n      throws IOException {\n    if (posTag == null) {\n      return null;\n    }\n    if (posTagRegExp) {\n    if (possibleTags == null) {\n      possibleTags = loadWords(this.getClass().getResourceAsStream(TAGS_FILE_NAME));\n    }\n    if (synthesizer == null) {\n      synthesizer = \n        new Lametyzator(this.getClass().getResourceAsStream(RESOURCE_FILENAME),\n          \"iso8859-2\", '+');\n    }    \n    final Pattern p = Pattern.compile(posTag.replaceAll(\"\\\\+\", \"|\"));\n    ArrayList<String> results = new ArrayList<String>();\n    \n    boolean isNegated = false;\n    if (token.getPOSTag() != null) {\n      isNegated = posTag.indexOf(\":neg\") > 0 \n      || token.getPOSTag().indexOf(\":neg\") > 0;\n    }\n    \n    for (String tag : possibleTags) {\n      Matcher m = p.matcher(tag);\n        if (m.matches()) {\n          String[] wordForms = null;          \n          if (isNegated) {\n            wordForms = synthesizer.stem(token.getLemma() + \"|\" + tag.replaceAll(\":neg\", \":pneg\"));\n            if (wordForms != null) {\n              String[] negForms = wordForms;\n              for (int i = 0; i < wordForms.length; i++) {\n                negForms[i] = \"nie\" + wordForms[i];\n              }\n              wordForms = negForms;\n            }\n          } else { \n          wordForms = synthesizer.stem(token.getLemma() + \"|\" + tag);\n          }\n          if (wordForms != null) {\n            results.addAll(Arrays.asList(wordForms));\n          }\n      }\n    }\n       return (String[]) results.toArray(new String[results.size()]);    \n    } else {\n      return synthesize(token, posTag);\n    }    \n  }","commit_id":"3e97a537631038d74cb75b76e3146241703ee16b","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n\t\t * @see org.apache.wicket.model.AbstractReadOnlyModel#getObject()\n\t\t */\n\t\t@Override\n\t\tpublic String getObject()\n\t\t{\n\t\t\tif (max == UNLIMITED)\n\t\t\t{\n\t\t\t\treturn getString(RESOURCE_UNLIMITED);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn getString(RESOURCE_LIMITED, Model.valueOf(Collections.singletonMap(\"max\",\n\t\t\t\t\tnew Integer(max))));\n\t\t\t}\n\t\t}","id":23528,"modified_method":"/**\n\t\t * @see org.apache.wicket.model.AbstractReadOnlyModel#getObject()\n\t\t */\n\t\t@Override\n\t\tpublic String getObject()\n\t\t{\n\t\t\tif (max == UNLIMITED)\n\t\t\t{\n\t\t\t\treturn getString(RESOURCE_UNLIMITED);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tHashMap<String, Object> vars = new HashMap<String, Object>(1);\n\t\t\t\tvars.put(\"max\", max);\n\t\t\t\treturn getString(RESOURCE_LIMITED, Model.of(vars));\n\t\t\t}\n\t\t}","commit_id":"6bc096c9d2e419fb1733dbf01727a8e149c1dc16","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t * @param model\n\t */\n\tpublic MultiFileUploadField(String id, IModel model)\n\t{\n\t\tthis(id, model, UNLIMITED);\n\t}","id":23529,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t * @param model\n\t */\n\tpublic MultiFileUploadField(String id, IModel<Collection<FileUpload>> model)\n\t{\n\t\tthis(id, model, UNLIMITED);\n\t}","commit_id":"6bc096c9d2e419fb1733dbf01727a8e149c1dc16","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t * @param model\n\t * @param max\n\t *            max number of files a user can upload\n\t * \n\t */\n\tpublic MultiFileUploadField(String id, IModel model, int max)\n\t{\n\t\tsuper(id, model);\n\n\t\tthis.max = max;\n\n\t\tupload = new WebComponent<FileUpload>(\"upload\");\n\t\tupload.setOutputMarkupId(true);\n\t\tadd(upload);\n\n\t\tcontainer = new WebMarkupContainer<Void>(\"container\");\n\t\tcontainer.setOutputMarkupId(true);\n\t\tadd(container);\n\n\t\tcontainer.add(new Label<String>(\"caption\", new CaptionModel()));\n\t}","id":23530,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t * @param model\n\t * @param max\n\t *            max number of files a user can upload\n\t * \n\t */\n\tpublic MultiFileUploadField(String id, IModel<Collection<FileUpload>> model, int max)\n\t{\n\t\tsuper(id, model);\n\n\t\tthis.max = max;\n\n\t\tupload = new WebComponent<FileUpload>(\"upload\");\n\t\tupload.setOutputMarkupId(true);\n\t\tadd(upload);\n\n\t\tcontainer = new WebMarkupContainer<Void>(\"container\");\n\t\tcontainer.setOutputMarkupId(true);\n\t\tadd(container);\n\n\t\tcontainer.add(new Label<String>(\"caption\", new CaptionModel()));\n\t}","commit_id":"6bc096c9d2e419fb1733dbf01727a8e149c1dc16","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.markup.html.form.FormComponent#updateModel()\n\t */\n\t@Override\n\tpublic void updateModel()\n\t{\n\t\tfinal Object object = getModelObject();\n\n\t\t// figure out if there is an existing model object collection for us to\n\t\t// reuse\n\t\tif (object == null)\n\t\t{\n\t\t\t// no existing collection, push the one we created\n\t\t\tsetModelObject(getConvertedInput());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!(object instanceof Collection))\n\t\t\t{\n\t\t\t\t// fail early if there is something interesting in the model\n\t\t\t\tthrow new IllegalStateException(\"Model object of \" + getClass().getName() +\n\t\t\t\t\t\" component must be of type `\" + Collection.class.getName() + \"<\" +\n\t\t\t\t\tFileUpload.class.getName() + \">` but is of type `\" +\n\t\t\t\t\tobject.getClass().getName() + \"`\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// refresh the existing collection\n\t\t\t\tCollection<FileUpload> collection = (Collection<FileUpload>)object;\n\t\t\t\tcollection.clear();\n\t\t\t\tif (getConvertedInput() != null)\n\t\t\t\t{\n\t\t\t\t\tcollection.addAll((Collection<FileUpload>)getConvertedInput());\n\t\t\t\t}\n\n\t\t\t\t// push the collection in case the model is listening to\n\t\t\t\t// setobject calls\n\t\t\t\tsetModelObject(collection);\n\t\t\t}\n\t\t}\n\t}","id":23531,"modified_method":"/**\n\t * @see org.apache.wicket.markup.html.form.FormComponent#updateModel()\n\t */\n\t@Override\n\tpublic void updateModel()\n\t{\n\t\tfinal Collection<FileUpload> collection = getModelObject();\n\n\t\t// figure out if there is an existing model object collection for us to\n\t\t// reuse\n\t\tif (collection == null)\n\t\t{\n\t\t\t// no existing collection, push the one we created\n\t\t\tsetModelObject(getConvertedInput());\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// refresh the existing collection\n\t\t\tcollection.clear();\n\t\t\tif (getConvertedInput() != null)\n\t\t\t{\n\t\t\t\tcollection.addAll(getConvertedInput());\n\t\t\t}\n\n\t\t\t// push the collection in case the model is listening to\n\t\t\t// setobject calls\n\t\t\tsetModelObject(collection);\n\t\t}\n\t}","commit_id":"6bc096c9d2e419fb1733dbf01727a8e149c1dc16","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.Component#onDetach()\n\t */\n\t@Override\n\tprotected void onDetach()\n\t{\n\t\t// cleanup any opened filestreams\n\t\tCollection<FileUpload> uploads = (Collection<FileUpload>)getConvertedInput();\n\t\tif (uploads != null)\n\t\t{\n\t\t\tIterator<FileUpload> it = uploads.iterator();\n\t\t\twhile (it.hasNext())\n\t\t\t{\n\t\t\t\tfinal FileUpload upload = it.next();\n\t\t\t\tupload.closeStreams();\n\t\t\t}\n\t\t}\n\n\t\t// cleanup any caches\n\t\tinputArrayCache = null;\n\n\t\t// clean up the model because we don't want FileUpload objects in session\n\t\tObject modelObject = getModelObject();\n\t\tif (modelObject != null && (modelObject instanceof Collection))\n\t\t{\n\t\t\t((Collection<FileUpload>)modelObject).clear();\n\t\t}\n\n\t\tsuper.onDetach();\n\t}","id":23532,"modified_method":"/**\n\t * @see org.apache.wicket.Component#onDetach()\n\t */\n\t@Override\n\tprotected void onDetach()\n\t{\n\t\t// cleanup any opened filestreams\n\t\tCollection<FileUpload> uploads = getConvertedInput();\n\t\tif (uploads != null)\n\t\t{\n\t\t\tIterator<FileUpload> it = uploads.iterator();\n\t\t\twhile (it.hasNext())\n\t\t\t{\n\t\t\t\tfinal FileUpload upload = it.next();\n\t\t\t\tupload.closeStreams();\n\t\t\t}\n\t\t}\n\n\t\t// cleanup any caches\n\t\tinputArrayCache = null;\n\n\t\t// clean up the model because we don't want FileUpload objects in session\n\t\tCollection<FileUpload> modelObject = getModelObject();\n\t\tif (modelObject != null)\n\t\t{\n\t\t\tmodelObject.clear();\n\t\t}\n\n\t\tsuper.onDetach();\n\t}","commit_id":"6bc096c9d2e419fb1733dbf01727a8e149c1dc16","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see FormComponent#updateModel()\n\t */\n\tpublic void updateModel()\n\t{\n\t\tObject object = getModelObject();\n\t\tboolean isModelCollection = object instanceof Collection;\n\n\t\tList converted = (List)getConvertedInput();\n\t\tif (!isModelCollection && converted.size() > 1)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\"The model of Select component [\"\n\t\t\t\t\t\t\t+ getPath()\n\t\t\t\t\t\t\t+ \"] is not of type java.util.Collection, but more then one SelectOption component has been selected. Either remove the multiple attribute from the select tag or make the model of the Select component a collection\");\n\t\t}\n\n\t\t/*\n\t\t * update the model\n\t\t */\n\t\tif (isModelCollection)\n\t\t{\n\t\t\tCollection modelCollection = (Collection)object;\n\t\t\tmodelChanging();\n\t\t\tmodelCollection.clear();\n\t\t\tif (converted != null)\n\t\t\t{\n\t\t\t\tmodelCollection.addAll(converted);\n\t\t\t}\n\t\t\tmodelChanged();\n\t\t\t// force notify of model update via setObject()\n\t\t\tgetModel().setObject(modelCollection);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tobject = null;\n\t\t\tif (converted != null)\n\t\t\t{\n\t\t\t\tobject = converted.get(0);\n\t\t\t}\n\t\t\tsetModelObject(object);\n\t\t}\n\t}","id":23533,"modified_method":"/**\n\t * @see FormComponent#updateModel()\n\t */\n\tpublic void updateModel()\n\t{\n\t\tObject object = getModelObject();\n\t\tboolean supportsMultiple = object instanceof Collection;\n\n\t\tObject converted = getConvertedInput();\n\t\t/*\n\t\t * update the model\n\t\t */\n\t\tif (supportsMultiple)\n\t\t{\n\t\t\tCollection modelCollection = (Collection)object;\n\t\t\tmodelChanging();\n\t\t\tmodelCollection.clear();\n\t\t\tif (converted != null)\n\t\t\t{\n\t\t\t\tmodelCollection.addAll((Collection)converted);\n\t\t\t}\n\t\t\tmodelChanged();\n\t\t\t// force notify of model update via setObject()\n\t\t\tgetModel().setObject(modelCollection);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsetModelObject(converted);\n\t\t}\n\t}","commit_id":"509f1113989b77bf8cfeddec0542c095b84b5dfb","url":"https://github.com/apache/wicket"},{"original_method":"protected void convertInput()\n\t{\n\t\t/*\n\t\t * the input contains an array of full path of the selected option\n\t\t * components unless nothing was selected in which case the input\n\t\t * contains null\n\t\t */\n\t\tString[] paths = getInputAsArray();\n\n\t\tif (paths == null || paths.length == 0)\n\t\t{\n\t\t\tsetConvertedInput(null);\n\t\t\treturn;\n\t\t}\n\n\t\tList converted = new ArrayList(paths.length);\n\n\t\t/*\n\t\t * if the input is null we do not need to do anything since the model\n\t\t * collection has already been cleared\n\t\t */\n\t\tfor (int i = 0; i < paths.length; i++)\n\t\t{\n\t\t\tString path = paths[i];\n\n\t\t\t/*\n\t\t\t * option component path sans select component path = relative path\n\t\t\t * from group to option since we know the option is child of select\n\t\t\t */\n\t\t\tpath = path.substring(getPath().length() + 1);\n\n\t\t\t// retrieve the selected option component\n\t\t\tSelectOption option = (SelectOption)get(path);\n\n\t\t\tif (option == null)\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\"submitted http post value [\"\n\t\t\t\t\t\t\t\t+ paths.toString()\n\t\t\t\t\t\t\t\t+ \"] for SelectOption component [\"\n\t\t\t\t\t\t\t\t+ getPath()\n\t\t\t\t\t\t\t\t+ \"] contains an illegal relative path element [\"\n\t\t\t\t\t\t\t\t+ path\n\t\t\t\t\t\t\t\t+ \"] which does not point to an SelectOption component. Due to this the Select component cannot resolve the selected SelectOption component pointed to by the illegal value. A possible reason is that component hierarchy changed between rendering and form submission.\");\n\t\t\t}\n\n\t\t\tconverted.add(option.getModelObject());\n\t\t}\n\n\t\tsetConvertedInput(converted);\n\t}","id":23534,"modified_method":"protected void convertInput()\n\t{\n\t\tboolean supportsMultiple = getModelObject() instanceof Collection;\n\n\t\t/*\n\t\t * the input contains an array of full path of the selected option\n\t\t * components unless nothing was selected in which case the input\n\t\t * contains null\n\t\t */\n\t\tString[] paths = getInputAsArray();\n\n\t\tif (paths == null || paths.length == 0)\n\t\t{\n\t\t\tsetConvertedInput(null);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!supportsMultiple && paths.length > 1)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\"The model of Select component [\"\n\t\t\t\t\t\t\t+ getPath()\n\t\t\t\t\t\t\t+ \"] is not of type java.util.Collection, but more then one SelectOption component has been selected. Either remove the multiple attribute from the select tag or make the model of the Select component a collection\");\n\t\t}\n\n\t\tList converted = new ArrayList(paths.length);\n\n\t\t/*\n\t\t * if the input is null we do not need to do anything since the model\n\t\t * collection has already been cleared\n\t\t */\n\t\tfor (int i = 0; i < paths.length; i++)\n\t\t{\n\t\t\tString path = paths[i];\n\t\t\tif (!Strings.isEmpty(path))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * option component path sans select component path = relative\n\t\t\t\t * path from group to option since we know the option is child\n\t\t\t\t * of select\n\t\t\t\t */\n\t\t\t\tpath = path.substring(getPath().length() + 1);\n\n\t\t\t\t// retrieve the selected option component\n\t\t\t\tSelectOption option = (SelectOption)get(path);\n\n\t\t\t\tif (option == null)\n\t\t\t\t{\n\t\t\t\t\tthrow new WicketRuntimeException(\n\t\t\t\t\t\t\t\"submitted http post value [\"\n\t\t\t\t\t\t\t\t\t+ paths.toString()\n\t\t\t\t\t\t\t\t\t+ \"] for SelectOption component [\"\n\t\t\t\t\t\t\t\t\t+ getPath()\n\t\t\t\t\t\t\t\t\t+ \"] contains an illegal relative path element [\"\n\t\t\t\t\t\t\t\t\t+ path\n\t\t\t\t\t\t\t\t\t+ \"] which does not point to an SelectOption component. Due to this the Select component cannot resolve the selected SelectOption component pointed to by the illegal value. A possible reason is that component hierarchy changed between rendering and form submission.\");\n\t\t\t\t}\n\t\t\t\tconverted.add(option.getModelObject());\n\t\t\t}\n\n\t\t}\n\n\t\tif (converted.isEmpty())\n\t\t{\n\t\t\tsetConvertedInput(null);\n\t\t}\n\t\telse if (!supportsMultiple)\n\t\t{\n\t\t\tsetConvertedInput(converted.get(0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsetConvertedInput(converted);\n\t\t}\n\t}","commit_id":"509f1113989b77bf8cfeddec0542c095b84b5dfb","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String)\n\t */\n\tpublic AbstractChoice(final String id, final List<V> choices)\n\t{\n\t\tthis(id, new Model<List<V>>(choices), new ChoiceRenderer<V>());\n\t}","id":23535,"modified_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String)\n\t */\n\tpublic AbstractChoice(final String id, final List<E> choices)\n\t{\n\t\tthis(id, new Model<List<E>>(choices), new ChoiceRenderer<E>());\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param renderer\n\t *            The rendering engine\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String)\n\t */\n\tpublic AbstractChoice(final String id, final List<V> choices, final IChoiceRenderer<V> renderer)\n\t{\n\t\tthis(id, new Model<List<V>>(choices), renderer);\n\t}","id":23536,"modified_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param renderer\n\t *            The rendering engine\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String)\n\t */\n\tpublic AbstractChoice(final String id, final List<E> choices, final IChoiceRenderer<E> renderer)\n\t{\n\t\tthis(id, new Model<List<E>>(choices), renderer);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            See Component\n\t * @param choices\n\t *            The drop down choices\n\t * @param renderer\n\t *            The rendering engine\n\t * @see wicket.Component#Component(String, IModel)\n\t */\n\tpublic AbstractChoice(final String id, IModel<V> model, final List<V> choices,\n\t\t\tfinal IChoiceRenderer<V> renderer)\n\t{\n\t\tthis(id, model, new Model<List<V>>(choices), renderer);\n\t}","id":23537,"modified_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            See Component\n\t * @param choices\n\t *            The drop down choices\n\t * @param renderer\n\t *            The rendering engine\n\t * @see wicket.Component#Component(String, IModel)\n\t */\n\tpublic AbstractChoice(final String id, IModel<M> model, final List<E> choices,\n\t\t\tfinal IChoiceRenderer<E> renderer)\n\t{\n\t\tthis(id, model, new Model<List<E>>(choices), renderer);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Set the choice renderer to be used.\n\t * \n\t * @param renderer\n\t */\n\tpublic final void setChoiceRenderer(IChoiceRenderer<V> renderer)\n\t{\n\t\tthis.renderer = renderer;\n\t}","id":23538,"modified_method":"/**\n\t * Set the choice renderer to be used.\n\t * \n\t * @param renderer\n\t */\n\tpublic final void setChoiceRenderer(IChoiceRenderer<E> renderer)\n\t{\n\t\tthis.renderer = renderer;\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            See Component\n\t * @param renderer\n\t *            The rendering engine\n\t * @param choices\n\t *            The drop down choices\n\t * @see wicket.Component#Component(String, IModel)\n\t */\n\tpublic AbstractChoice(final String id, IModel<V> model, final IModel<List<V>> choices,\n\t\t\tfinal IChoiceRenderer<V> renderer)\n\t{\n\t\tsuper(id, model);\n\t\tthis.choices = choices;\n\t\tthis.renderer = renderer;\n\t}","id":23539,"modified_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            See Component\n\t * @param renderer\n\t *            The rendering engine\n\t * @param choices\n\t *            The drop down choices\n\t * @see wicket.Component#Component(String, IModel)\n\t */\n\tpublic AbstractChoice(final String id, IModel<M> model, final IModel<List<E>> choices,\n\t\t\tfinal IChoiceRenderer<E> renderer)\n\t{\n\t\tsuper(id, model);\n\t\tthis.choices = choices;\n\t\tthis.renderer = renderer;\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String, IModel)\n\t */\n\tpublic AbstractChoice(final String id, IModel<V> model, final List<V> choices)\n\t{\n\t\tthis(id, model, new Model<List<V>>(choices), new ChoiceRenderer<V>());\n\t}","id":23540,"modified_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String, IModel)\n\t */\n\tpublic AbstractChoice(final String id, IModel<M> model, final List<E> choices)\n\t{\n\t\tthis(id, model, new Model<List<E>>(choices), new ChoiceRenderer<E>());\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @see wicket.Component#Component(String)\n\t */\n\tpublic AbstractChoice(final String id)\n\t{\n\t\tthis(id, new Model<List<V>>(new ArrayList<V>()), new ChoiceRenderer<V>());\n\t}","id":23541,"modified_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @see wicket.Component#Component(String)\n\t */\n\tpublic AbstractChoice(final String id)\n\t{\n\t\tthis(id, new Model<List<E>>(new ArrayList<E>()), new ChoiceRenderer<E>());\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param renderer\n\t *            The rendering engine\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String)\n\t */\n\tpublic AbstractChoice(final String id, final IModel<List<V>> choices, final IChoiceRenderer<V> renderer)\n\t{\n\t\tsuper(id);\n\t\tthis.choices = choices;\n\t\tthis.renderer = renderer;\n\t}","id":23542,"modified_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param renderer\n\t *            The rendering engine\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String)\n\t */\n\tpublic AbstractChoice(final String id, final IModel<List<E>> choices,\n\t\t\tfinal IChoiceRenderer<E> renderer)\n\t{\n\t\tsuper(id);\n\t\tthis.choices = choices;\n\t\tthis.renderer = renderer;\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @return The collection of object that this choice has\n\t */\n\tpublic List<V> getChoices()\n\t{\n\t\tList<V> choices = this.choices.getObject(this);\n\t\tif (choices == null)\n\t\t{\n\t\t\tthrow new NullPointerException(\"List of choices is null - Was the supplied 'Choices' model empty?\");\n\t\t}\n\t\treturn choices;\n\t}","id":23543,"modified_method":"/**\n\t * @return The collection of object that this choice has\n\t */\n\tpublic List<E> getChoices()\n\t{\n\t\tList<E> choices = this.choices.getObject(this);\n\t\tif (choices == null)\n\t\t{\n\t\t\tthrow new NullPointerException(\n\t\t\t\t\t\"List of choices is null - Was the supplied 'Choices' model empty?\");\n\t\t}\n\t\treturn choices;\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String, IModel)\n\t */\n\tpublic AbstractChoice(final String id, IModel<V> model, final IModel<List<V>> choices)\n\t{\n\t\tthis(id, model, choices, new ChoiceRenderer<V>());\n\t}","id":23544,"modified_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String, IModel)\n\t */\n\tpublic AbstractChoice(final String id, IModel<M> model, final IModel<List<E>> choices)\n\t{\n\t\tthis(id, model, choices, new ChoiceRenderer<E>());\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Handle the container's body.\n\t * \n\t * @param markupStream\n\t *            The markup stream\n\t * @param openTag\n\t *            The open tag for the body\n\t * @see wicket.Component#onComponentTagBody(MarkupStream, ComponentTag)\n\t */\n\t@Override\n\tprotected void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag)\n\t{\n\t\tList<V> choices = getChoices();\n\t\tfinal AppendingStringBuffer buffer = new AppendingStringBuffer((choices.size() * 50) + 16);\n\t\tfinal String selected = getValue();\n\n\t\t// Append default option\n\t\tbuffer.append(getDefaultChoice(selected));\n\n\t\tfor (int index = 0; index < choices.size(); index++)\n\t\t{\n\t\t\tfinal V choice = choices.get(index);\n\t\t\tappendOptionHtml(buffer, choice, index, selected);\n\t\t}\n\n\t\tbuffer.append(\"\\n\");\n\t\treplaceComponentTagBody(markupStream, openTag, buffer);\n\t}","id":23545,"modified_method":"/**\n\t * Handle the container's body.\n\t * \n\t * @param markupStream\n\t *            The markup stream\n\t * @param openTag\n\t *            The open tag for the body\n\t * @see wicket.Component#onComponentTagBody(MarkupStream, ComponentTag)\n\t */\n\t@Override\n\tprotected void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag)\n\t{\n\t\tList<E> choices = getChoices();\n\t\tfinal AppendingStringBuffer buffer = new AppendingStringBuffer((choices.size() * 50) + 16);\n\t\tfinal String selected = getValue();\n\n\t\t// Append default option\n\t\tbuffer.append(getDefaultChoice(selected));\n\n\t\tfor (int index = 0; index < choices.size(); index++)\n\t\t{\n\t\t\tfinal E choice = choices.get(index);\n\t\t\tappendOptionHtml(buffer, choice, index, selected);\n\t\t}\n\n\t\tbuffer.append(\"\\n\");\n\t\treplaceComponentTagBody(markupStream, openTag, buffer);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @return The IChoiceRenderer used for rendering the data objects\n\t */\n\tpublic final IChoiceRenderer<V> getChoiceRenderer()\n\t{\n\t\treturn renderer;\n\t}","id":23546,"modified_method":"/**\n\t * @return The IChoiceRenderer used for rendering the data objects\n\t */\n\tpublic final IChoiceRenderer<E> getChoiceRenderer()\n\t{\n\t\treturn renderer;\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets whether the given value represents the current selection.\n\t * \n\t * @param object\n\t *            The object to check\n\t * @param index\n\t *            The index in the choices collection this object is in.\n\t * @param selected\n\t *            The currently selected string value\n\t * @return Whether the given value represents the current selection\n\t */\n\tprotected abstract boolean isSelected(final V object, int index, String selected);","id":23547,"modified_method":"/**\n\t * Gets whether the given value represents the current selection.\n\t * \n\t * @param object\n\t *            The object to check\n\t * @param index\n\t *            The index in the choices collection this object is in.\n\t * @param selected\n\t *            The currently selected string value\n\t * @return Whether the given value represents the current selection\n\t */\n\tprotected abstract boolean isSelected(final E object, int index, String selected);","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Sets the list of choices\n\t * \n\t * @param choices\n\t *            model representing the list of choices\n\t */\n\tpublic final void setChoices(IModel<List<V>> choices)\n\t{\n\t\tif (this.choices != null && this.choices != choices)\n\t\t{\n\t\t\tif (isVersioned())\n\t\t\t{\n\t\t\t\taddStateChange(new ChoicesListChange());\n\t\t\t}\n\t\t}\n\t\tthis.choices = choices;\n\t}","id":23548,"modified_method":"/**\n\t * Sets the list of choices\n\t * \n\t * @param choices\n\t *            model representing the list of choices\n\t */\n\tpublic final void setChoices(IModel<List<E>> choices)\n\t{\n\t\tif (this.choices != null && this.choices != choices)\n\t\t{\n\t\t\tif (isVersioned())\n\t\t\t{\n\t\t\t\taddStateChange(new ChoicesListChange());\n\t\t\t}\n\t\t}\n\t\tthis.choices = choices;\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Sets the list of choices.\n\t * \n\t * @param choices\n\t *            the list of choices\n\t */\n\tpublic final void setChoices(List<V> choices)\n\t{\n\t\tif ((this.choices != null))\n\t\t{\n\t\t\tif (isVersioned())\n\t\t\t{\n\t\t\t\taddStateChange(new ChoicesListChange());\n\t\t\t}\n\t\t}\n\t\tthis.choices = new Model<List<V>>(choices);\n\t}","id":23549,"modified_method":"/**\n\t * Sets the list of choices.\n\t * \n\t * @param choices\n\t *            the list of choices\n\t */\n\tpublic final void setChoices(List<E> choices)\n\t{\n\t\tif ((this.choices != null))\n\t\t{\n\t\t\tif (isVersioned())\n\t\t\t{\n\t\t\t\taddStateChange(new ChoicesListChange());\n\t\t\t}\n\t\t}\n\t\tthis.choices = new Model<List<E>>(choices);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Generats and appends html for a single choice into the provided buffer\n\t * \n\t * @param buffer\n\t *            Appending string buffer that will have the generated html appended\n\t * @param choice\n\t *            Choice object\n\t * @param index\n\t *            The index of this option\n\t * @param selected\n\t *            The currently selected string value\n\t */\n\tprotected void appendOptionHtml(AppendingStringBuffer buffer, V choice, int index,\n\t\t\tString selected)\n\t{\n\t\tObject objectValue = renderer.getDisplayValue(choice);\n\t\tClass objectClass = objectValue == null?null:objectValue.getClass();\n\t\tfinal String displayValue = getConverter(objectClass).convertToString(\n\t\t\t\tobjectValue, getLocale());\n\t\tbuffer.append(\"\\n<option \");\n\t\tif (isSelected(choice, index, selected))\n\t\t{\n\t\t\tbuffer.append(\"selected=\\\"selected\\\" \");\n\t\t}\n\t\tbuffer.append(\"value=\\\"\");\n\t\tbuffer.append(renderer.getIdValue(choice, index));\n\t\tbuffer.append(\"\\\">\");\n\n\t\tString display = displayValue;\n\t\tif (localizeDisplayValues())\n\t\t{\n\t\t\tdisplay = getLocalizer().getString(displayValue, this, displayValue);\n\t\t}\n\t\tCharSequence escaped = Strings.escapeMarkup(display, false, true);\n\t\tbuffer.append(escaped);\n\t\tbuffer.append(\"<\/option>\");\n\t}","id":23550,"modified_method":"/**\n\t * Generats and appends html for a single choice into the provided buffer\n\t * \n\t * @param buffer\n\t *            Appending string buffer that will have the generated html\n\t *            appended\n\t * @param choice\n\t *            Choice object\n\t * @param index\n\t *            The index of this option\n\t * @param selected\n\t *            The currently selected string value\n\t */\n\tprotected void appendOptionHtml(AppendingStringBuffer buffer, E choice, int index,\n\t\t\tString selected)\n\t{\n\t\tObject objectValue = renderer.getDisplayValue(choice);\n\t\tClass objectClass = objectValue == null ? null : objectValue.getClass();\n\t\tfinal String displayValue = getConverter(objectClass).convertToString(objectValue,\n\t\t\t\tgetLocale());\n\t\tbuffer.append(\"\\n<option \");\n\t\tif (isSelected(choice, index, selected))\n\t\t{\n\t\t\tbuffer.append(\"selected=\\\"selected\\\" \");\n\t\t}\n\t\tbuffer.append(\"value=\\\"\");\n\t\tbuffer.append(renderer.getIdValue(choice, index));\n\t\tbuffer.append(\"\\\">\");\n\n\t\tString display = displayValue;\n\t\tif (localizeDisplayValues())\n\t\t{\n\t\t\tdisplay = getLocalizer().getString(displayValue, this, displayValue);\n\t\t}\n\t\tCharSequence escaped = Strings.escapeMarkup(display, false, true);\n\t\tbuffer.append(escaped);\n\t\tbuffer.append(\"<\/option>\");\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String)\n\t */\n\tpublic AbstractChoice(final String id, final IModel<List<V>> choices)\n\t{\n\t\tthis(id, choices, new ChoiceRenderer<V>());\n\t}","id":23551,"modified_method":"/**\n\t * Constructor.\n\t * \n\t * @param id\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the dropdown\n\t * @see wicket.Component#Component(String)\n\t */\n\tpublic AbstractChoice(final String id, final IModel<List<E>> choices)\n\t{\n\t\tthis(id, choices, new ChoiceRenderer<E>());\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            The model that is updated with changes in this component. See\n\t *            Component\n\t * @param choices\n\t *            The collection of choices in the radio choice\n\t * @param renderer\n\t *            The rendering engine\n\t * @see wicket.Component#Component(String, wicket.model.IModel)\n\t * @see AbstractChoice#AbstractChoice(String, wicket.model.IModel,\n\t *      wicket.model.IModel,wicket.markup.html.form.IChoiceRenderer)\n\t */\n\tpublic CheckBoxMultipleChoice(String id, IModel model, IModel choices, IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, model, choices, renderer);\n\t}","id":23552,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the radio choice\n\t * @param renderer\n\t *            The rendering engine\n\t * @see wicket.Component#Component(String, wicket.model.IModel)\n\t * @see AbstractChoice#AbstractChoice(String, wicket.model.IModel,\n\t *      java.util.List,wicket.markup.html.form.IChoiceRenderer)\n\t */\n\tpublic CheckBoxMultipleChoice(final String id, IModel<Collection<V>> model, final List<V> choices,\n\t\t\tfinal IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, model, choices, renderer);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the radio choice\n\t * @see wicket.Component#Component(String)\n\t * @see AbstractChoice#AbstractChoice(String, java.util.List)\n\t */\n\tpublic CheckBoxMultipleChoice(final String id, final List choices)\n\t{\n\t\tsuper(id, choices);\n\t}","id":23553,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the radio choice\n\t * @see wicket.Component#Component(String)\n\t * @see AbstractChoice#AbstractChoice(String, java.util.List)\n\t */\n\tpublic CheckBoxMultipleChoice(final String id, final List<V> choices)\n\t{\n\t\tsuper(id, choices);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the radio choice\n\t * @param renderer\n\t *            The rendering engine\n\t * @see wicket.Component#Component(String, wicket.model.IModel)\n\t * @see AbstractChoice#AbstractChoice(String, wicket.model.IModel,\n\t *      java.util.List,wicket.markup.html.form.IChoiceRenderer)\n\t */\n\tpublic CheckBoxMultipleChoice(final String id, IModel model, final List choices,\n\t\t\tfinal IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, model, choices, renderer);\n\t}","id":23554,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the radio choice\n\t * @param renderer\n\t *            The rendering engine\n\t * @see AbstractChoice#AbstractChoice(String,\n\t *      wicket.model.IModel,wicket.markup.html.form.IChoiceRenderer)\n\t * @see wicket.Component#Component(String)\n\t */\n\tpublic CheckBoxMultipleChoice(String id, IModel<List<V>> choices, IChoiceRenderer<V> renderer)\n\t{\n\t\tsuper(id, choices, renderer);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the radio choice\n\t * @see wicket.Component#Component(String, wicket.model.IModel)\n\t * @see AbstractChoice#AbstractChoice(String, wicket.model.IModel,\n\t *      java.util.List)\n\t */\n\tpublic CheckBoxMultipleChoice(final String id, IModel model, final List choices)\n\t{\n\t\tsuper(id, model, choices);\n\t}","id":23555,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the radio choice\n\t * @see wicket.Component#Component(String)\n\t * @see AbstractChoice#AbstractChoice(String, wicket.model.IModel)\n\t */\n\tpublic CheckBoxMultipleChoice(String id, IModel<List<V>> choices)\n\t{\n\t\tsuper(id, choices);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the radio choice\n\t * @see wicket.Component#Component(String)\n\t * @see AbstractChoice#AbstractChoice(String, wicket.model.IModel)\n\t */\n\tpublic CheckBoxMultipleChoice(String id, IModel choices)\n\t{\n\t\tsuper(id, choices);\n\t}","id":23556,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            The model that is updated with changes in this component. See\n\t *            Component\n\t * @param choices\n\t *            The collection of choices in the radio choice\n\t * @see AbstractChoice#AbstractChoice(String,\n\t *      wicket.model.IModel,wicket.model.IModel)\n\t * @see wicket.Component#Component(String, wicket.model.IModel)\n\t */\n\tpublic CheckBoxMultipleChoice(String id, IModel<Collection<V>> model, IModel<List<V>> choices)\n\t{\n\t\tsuper(id, model, choices);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            See Component\n\t * @param renderer\n\t *            The rendering engine\n\t * @param choices\n\t *            The collection of choices in the radio choice\n\t * @see wicket.Component#Component(String)\n\t * @see AbstractChoice#AbstractChoice(String,\n\t *      java.util.List,wicket.markup.html.form.IChoiceRenderer)\n\t */\n\tpublic CheckBoxMultipleChoice(final String id, final List choices,\n\t\t\tfinal IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, choices, renderer);\n\t}","id":23557,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            See Component\n\t * @param renderer\n\t *            The rendering engine\n\t * @param choices\n\t *            The collection of choices in the radio choice\n\t * @see wicket.Component#Component(String)\n\t * @see AbstractChoice#AbstractChoice(String,\n\t *      java.util.List,wicket.markup.html.form.IChoiceRenderer)\n\t */\n\tpublic CheckBoxMultipleChoice(final String id, final List<V> choices,\n\t\t\tfinal IChoiceRenderer<V> renderer)\n\t{\n\t\tsuper(id, choices, renderer);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.Component#onComponentTagBody(wicket.markup.MarkupStream,\n\t *      wicket.markup.ComponentTag)\n\t */\n\t@Override\n\tprotected final void onComponentTagBody(final MarkupStream markupStream,\n\t\t\tfinal ComponentTag openTag)\n\t{\n\t\t// Iterate through choices\n\t\tfinal List choices = getChoices();\n\n\t\t// Buffer to hold generated body\n\t\tfinal AppendingStringBuffer buffer = new AppendingStringBuffer(70*(choices.size()+1));\n\n\t\t// Value of this choice\n\t\tfinal String selected = getValue();\n\t\t\n\t\t// Loop through choices\n\t\tfor (int index = 0; index < choices.size(); index++)\n\t\t{\n\t\t\t// Get next choice\n\t\t\tfinal Object choice = choices.get(index);\n\n\t\t\tObject displayValue = getChoiceRenderer().getDisplayValue(choice);\n\t\t\tClass objectClass = displayValue == null?null:displayValue.getClass();\n\t\t\t// Get label for choice\n\t\t\tfinal String label = getConverter(objectClass).convertToString(displayValue, getLocale());\n\n\t\t\t// If there is a display value for the choice, then we know that the\n\t\t\t// choice is automatic in some way. If label is /null/ then we know\n\t\t\t// that the choice is a manually created checkbox tag at some random\n\t\t\t// location in the page markup!\n\t\t\tif (label != null)\n\t\t\t{\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getPrefix());\n\n\t\t\t\tString id = getChoiceRenderer().getIdValue(choice, index);\n\t\t\t\tfinal String idAttr = getInputName() + \"_\" + id;\n\n\t\t\t\t// Add checkbox element\n\t\t\t\tbuffer.append(\"<input name=\\\"\").append(getInputName()).append(\"\\\"\").append(\" type=\\\"checkbox\\\"\").append(\n\t\t\t\t\t\t(isSelected(choice, index, selected) ? \" checked=\\\"checked\\\"\" : \"\")).append(\" value=\\\"\").append(\n\t\t\t\t\t\tid).append(\"\\\" id=\\\"\").append(idAttr).append(\"\\\"/>\");\n\n\t\t\t\t// Add label for checkbox\n\t\t\t\tString display = label;\n\t\t\t\tif(localizeDisplayValues())\n\t\t\t\t{\n\t\t\t\t\tdisplay = getLocalizer().getString(label, this, label);\n\t\t\t\t}\n\t\t\t\tCharSequence escaped = Strings.escapeMarkup(display, false, true);\n\n\t\t\t\tbuffer.append(\"<label for=\\\"\");\n\t\t\t\tbuffer.append(idAttr);\n\t\t\t\tbuffer.append(\"\\\">\").append(escaped).append(\"<\/label>\");\n\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getSuffix());\n\t\t\t}\n\t\t}\n\n\t\t// Replace body\n\t\treplaceComponentTagBody(markupStream, openTag, buffer);\n\t}","id":23558,"modified_method":"/**\n\t * @see wicket.Component#onComponentTagBody(wicket.markup.MarkupStream,\n\t *      wicket.markup.ComponentTag)\n\t */\n\t@Override\n\tprotected final void onComponentTagBody(final MarkupStream markupStream,\n\t\t\tfinal ComponentTag openTag)\n\t{\n\t\t// Iterate through choices\n\t\tfinal List<V> choices = getChoices();\n\n\t\t// Buffer to hold generated body\n\t\tfinal AppendingStringBuffer buffer = new AppendingStringBuffer(70*(choices.size()+1));\n\n\t\t// Value of this choice\n\t\tfinal String selected = getValue();\n\t\t\n\t\t// Loop through choices\n\t\tfor (int index = 0; index < choices.size(); index++)\n\t\t{\n\t\t\t// Get next choice\n\t\t\tfinal V choice = choices.get(index);\n\n\t\t\tObject displayValue = getChoiceRenderer().getDisplayValue(choice);\n\t\t\tClass objectClass = displayValue == null?null:displayValue.getClass();\n\t\t\t// Get label for choice\n\t\t\tfinal String label = getConverter(objectClass).convertToString(displayValue, getLocale());\n\n\t\t\t// If there is a display value for the choice, then we know that the\n\t\t\t// choice is automatic in some way. If label is /null/ then we know\n\t\t\t// that the choice is a manually created checkbox tag at some random\n\t\t\t// location in the page markup!\n\t\t\tif (label != null)\n\t\t\t{\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getPrefix());\n\n\t\t\t\tString id = getChoiceRenderer().getIdValue(choice, index);\n\t\t\t\tfinal String idAttr = getInputName() + \"_\" + id;\n\n\t\t\t\t// Add checkbox element\n\t\t\t\tbuffer.append(\"<input name=\\\"\").append(getInputName()).append(\"\\\"\").append(\" type=\\\"checkbox\\\"\").append(\n\t\t\t\t\t\t(isSelected(choice, index, selected) ? \" checked=\\\"checked\\\"\" : \"\")).append(\" value=\\\"\").append(\n\t\t\t\t\t\tid).append(\"\\\" id=\\\"\").append(idAttr).append(\"\\\"/>\");\n\n\t\t\t\t// Add label for checkbox\n\t\t\t\tString display = label;\n\t\t\t\tif(localizeDisplayValues())\n\t\t\t\t{\n\t\t\t\t\tdisplay = getLocalizer().getString(label, this, label);\n\t\t\t\t}\n\t\t\t\tCharSequence escaped = Strings.escapeMarkup(display, false, true);\n\n\t\t\t\tbuffer.append(\"<label for=\\\"\");\n\t\t\t\tbuffer.append(idAttr);\n\t\t\t\tbuffer.append(\"\\\">\").append(escaped).append(\"<\/label>\");\n\n\t\t\t\t// Append option suffix\n\t\t\t\tbuffer.append(getSuffix());\n\t\t\t}\n\t\t}\n\n\t\t// Replace body\n\t\treplaceComponentTagBody(markupStream, openTag, buffer);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            The model that is updated with changes in this component. See\n\t *            Component\n\t * @param choices\n\t *            The collection of choices in the radio choice\n\t * @see AbstractChoice#AbstractChoice(String,\n\t *      wicket.model.IModel,wicket.model.IModel)\n\t * @see wicket.Component#Component(String, wicket.model.IModel)\n\t */\n\tpublic CheckBoxMultipleChoice(String id, IModel model, IModel choices)\n\t{\n\t\tsuper(id, model, choices);\n\t}","id":23559,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the radio choice\n\t * @see wicket.Component#Component(String, wicket.model.IModel)\n\t * @see AbstractChoice#AbstractChoice(String, wicket.model.IModel,\n\t *      java.util.List)\n\t */\n\tpublic CheckBoxMultipleChoice(final String id, IModel<Collection<V>> model, final List<V> choices)\n\t{\n\t\tsuper(id, model, choices);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            See Component\n\t * @param choices\n\t *            The collection of choices in the radio choice\n\t * @param renderer\n\t *            The rendering engine\n\t * @see AbstractChoice#AbstractChoice(String,\n\t *      wicket.model.IModel,wicket.markup.html.form.IChoiceRenderer)\n\t * @see wicket.Component#Component(String)\n\t */\n\tpublic CheckBoxMultipleChoice(String id, IModel choices, IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, choices, renderer);\n\t}","id":23560,"modified_method":"/**\n\t * Constructor\n\t * \n\t * @param id\n\t *            See Component\n\t * @param model\n\t *            The model that is updated with changes in this component. See\n\t *            Component\n\t * @param choices\n\t *            The collection of choices in the radio choice\n\t * @param renderer\n\t *            The rendering engine\n\t * @see wicket.Component#Component(String, wicket.model.IModel)\n\t * @see AbstractChoice#AbstractChoice(String, wicket.model.IModel,\n\t *      wicket.model.IModel,wicket.markup.html.form.IChoiceRenderer)\n\t */\n\tpublic CheckBoxMultipleChoice(String id, IModel<Collection<V>> model, IModel<List<V>> choices, IChoiceRenderer<V> renderer)\n\t{\n\t\tsuper(id, model, choices, renderer);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Creates a multiple choice list with a maximum number of visible rows.\n\t * \n\t * @param id\n\t *            component id\n\t * @param choices\n\t *            list of choices\n\t * @param maxRows\n\t *            the maximum number of visible rows.\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, List)\n\t */\n\tpublic ListMultipleChoice(final String id, final List choices, final int maxRows)\n\t{\n\t\tsuper(id, choices);\n\t\tthis.maxRows = maxRows;\n\t}","id":23561,"modified_method":"/**\n\t * Creates a multiple choice list with a maximum number of visible rows.\n\t * \n\t * @param id\n\t *            component id\n\t * @param choices\n\t *            list of choices\n\t * @param maxRows\n\t *            the maximum number of visible rows.\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, List)\n\t */\n\tpublic ListMultipleChoice(final String id, final List<V> choices, final int maxRows)\n\t{\n\t\tsuper(id, choices);\n\t\tthis.maxRows = maxRows;\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#isSelected(Object,int,\n\t *      String)\n\t */\n\t@Override\n\tprotected final boolean isSelected(Object choice, int index, String selected)\n\t{\n\t\t// Have a value at all?\n\t\tif (selected != null)\n\t\t{\n\t\t\t// Loop through ids\n\t\t\tfor (final StringTokenizer tokenizer = new StringTokenizer(selected, VALUE_SEPARATOR); tokenizer\n\t\t\t\t\t.hasMoreTokens();)\n\t\t\t{\n\t\t\t\tfinal String id = tokenizer.nextToken();\n\t\t\t\tif (id.equals(getChoiceRenderer().getIdValue(choice, index)))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":23562,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#isSelected(Object,int,\n\t *      String)\n\t */\n\t@Override\n\tprotected final boolean isSelected(V choice, int index, String selected)\n\t{\n\t\t// Have a value at all?\n\t\tif (selected != null)\n\t\t{\n\t\t\t// Loop through ids\n\t\t\tfor (final StringTokenizer tokenizer = new StringTokenizer(selected, VALUE_SEPARATOR); tokenizer\n\t\t\t\t\t.hasMoreTokens();)\n\t\t\t{\n\t\t\t\tfinal String id = tokenizer.nextToken();\n\t\t\t\tif (id.equals(getChoiceRenderer().getIdValue(choice, index)))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see FormComponent#getModelValue()\n\t */\n\t@Override\n\tpublic final String getModelValue()\n\t{\n\t\t// Get the list of selected values\n\t\tfinal Collection selectedValues = (Collection)getModelObject();\n\t\tfinal AppendingStringBuffer buffer = new AppendingStringBuffer();\n\t\tif (selectedValues != null)\n\t\t{\n\t\t\tfinal List choices = getChoices();\n\t\t\tfor (final Iterator iterator = selectedValues.iterator(); iterator.hasNext();)\n\t\t\t{\n\t\t\t\tfinal Object object = iterator.next();\n\n\t\t\t\tint index = choices.indexOf(object);\n\t\t\t\tbuffer.append(getChoiceRenderer().getIdValue(object, index));\n\t\t\t\tbuffer.append(VALUE_SEPARATOR);\n\t\t\t}\n\t\t}\n\t\treturn buffer.toString();\n\t}","id":23563,"modified_method":"/**\n\t * @see FormComponent#getModelValue()\n\t */\n\tpublic final String getModelValue()\n\t{\n\t\t// Get the list of selected values\n\t\tfinal Collection<V> selectedValues = getModelObject();\n\t\tfinal AppendingStringBuffer buffer = new AppendingStringBuffer();\n\t\tif (selectedValues != null)\n\t\t{\n\t\t\tfinal List<V> choices = getChoices();\n\t\t\tfor (final Iterator<V> iterator = selectedValues.iterator(); iterator.hasNext();)\n\t\t\t{\n\t\t\t\tfinal V object = iterator.next();\n\n\t\t\t\tint index = choices.indexOf(object);\n\t\t\t\tbuffer.append(getChoiceRenderer().getIdValue(object, index));\n\t\t\t\tbuffer.append(VALUE_SEPARATOR);\n\t\t\t}\n\t\t}\n\t\treturn buffer.toString();\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String,\n\t *      IModel,IModel)\n\t */\n\tpublic ListMultipleChoice(String id, IModel model, IModel choices)\n\t{\n\t\tsuper(id, model, choices);\n\t}","id":23564,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String,\n\t *      IModel,IModel)\n\t */\n\tpublic ListMultipleChoice(String id, IModel<Collection<V>> model, IModel<List<V>> choices)\n\t{\n\t\tsuper(id, model, choices);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String,\n\t *      List,IChoiceRenderer)\n\t */\n\tpublic ListMultipleChoice(final String id, final List choices, final IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, choices, renderer);\n\t}","id":23565,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String,\n\t *      List,IChoiceRenderer)\n\t */\n\tpublic ListMultipleChoice(final String id, final List<V> choices, final IChoiceRenderer<V> renderer)\n\t{\n\t\tsuper(id, choices, renderer);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String,\n\t *      IModel)\n\t */\n\tpublic ListMultipleChoice(String id, IModel choices)\n\t{\n\t\tsuper(id, choices);\n\t}","id":23566,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String,\n\t *      IModel)\n\t */\n\tpublic ListMultipleChoice(String id, IModel<List<V>> choices)\n\t{\n\t\tsuper(id, choices);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String,\n\t *      IModel, List)\n\t */\n\tpublic ListMultipleChoice(final String id, IModel object, final List choices)\n\t{\n\t\tsuper(id, object, choices);\n\t}","id":23567,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String,\n\t *      IModel, List)\n\t */\n\tpublic ListMultipleChoice(final String id, IModel<Collection<V>> object, final List<V> choices)\n\t{\n\t\tsuper(id, object, choices);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see FormComponent#updateModel()\n\t */\n\t@Override\n\tpublic final void updateModel()\n\t{\n\t\tCollection selectedValues = (Collection)getModelObject();\n\t\tif (selectedValues != null)\n\t\t{\n\t\t\tmodelChanging();\n\t\t\tselectedValues.clear();\n\t\t\tselectedValues.addAll((Collection)getConvertedInput());\n\t\t\tmodelChanged();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectedValues = (Collection)getConvertedInput();\n\t\t\tsetModelObject(selectedValues);\n\t\t}\n\t}","id":23568,"modified_method":"/**\n\t * @see FormComponent#updateModel()\n\t */\n\tpublic final void updateModel()\n\t{\n\t\tCollection<V> selectedValues = getModelObject();\n\t\tif (selectedValues != null)\n\t\t{\n\t\t\tmodelChanging();\n\t\t\tselectedValues.clear();\n\t\t\tselectedValues.addAll(getConvertedInput());\n\t\t\tmodelChanged();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tselectedValues = getConvertedInput();\n\t\t\tsetModelObject(selectedValues);\n\t\t}\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.FormComponent#convertValue(String[])\n\t */\n\t@Override\n\tprotected Object convertValue(String[] ids) throws ConversionException\n\t{\n\t\tArrayList selectedValues = new ArrayList();\n\n\t\t// If one or more ids is selected\n\t\tif (ids != null && ids.length > 0 && !Strings.isEmpty(ids[0]))\n\t\t{\n\t\t\t// Get values that could be selected\n\t\t\tfinal List choices = getChoices();\n\n\t\t\t// Loop through selected indices\n\t\t\tfor (int i = 0; i < ids.length; i++)\n\t\t\t{\n\t\t\t\tfor (int index = 0; index < choices.size(); index++)\n\t\t\t\t{\n\t\t\t\t\t// Get next choice\n\t\t\t\t\tfinal Object choice = choices.get(index);\n\t\t\t\t\tif (getChoiceRenderer().getIdValue(choice, index).equals(ids[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tselectedValues.add(choice);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn selectedValues;\n\t}","id":23569,"modified_method":"/**\n\t * @see wicket.markup.html.form.FormComponent#convertValue(String[])\n\t */\n\t@Override\n\tprotected Collection<V> convertValue(String[] ids) throws ConversionException\n\t{\n\t\tArrayList<V> selectedValues = new ArrayList<V>();\n\n\t\t// If one or more ids is selected\n\t\tif (ids != null && ids.length > 0 && !Strings.isEmpty(ids[0]))\n\t\t{\n\t\t\t// Get values that could be selected\n\t\t\tfinal List<V> choices = getChoices();\n\n\t\t\t// Loop through selected indices\n\t\t\tfor (int i = 0; i < ids.length; i++)\n\t\t\t{\n\t\t\t\tfor (int index = 0; index < choices.size(); index++)\n\t\t\t\t{\n\t\t\t\t\t// Get next choice\n\t\t\t\t\tfinal V choice = choices.get(index);\n\t\t\t\t\tif (getChoiceRenderer().getIdValue(choice, index).equals(ids[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tselectedValues.add(choice);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn selectedValues;\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, List)\n\t */\n\tpublic ListMultipleChoice(final String id, final List choices)\n\t{\n\t\tsuper(id, choices);\n\t}","id":23570,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String, List)\n\t */\n\tpublic ListMultipleChoice(final String id, final List<V> choices)\n\t{\n\t\tsuper(id, choices);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String,\n\t *      IModel, IModel,IChoiceRenderer)\n\t */\n\tpublic ListMultipleChoice(String id, IModel model, IModel choices, IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, model, choices, renderer);\n\t}","id":23571,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String,\n\t *      IModel, IModel,IChoiceRenderer)\n\t */\n\tpublic ListMultipleChoice(String id, IModel<Collection<V>> model, IModel<List<V>> choices, IChoiceRenderer<V> renderer)\n\t{\n\t\tsuper(id, model, choices, renderer);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String,\n\t *      IModel,IChoiceRenderer)\n\t */\n\tpublic ListMultipleChoice(String id, IModel choices, IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, choices, renderer);\n\t}","id":23572,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String,\n\t *      IModel,IChoiceRenderer)\n\t */\n\tpublic ListMultipleChoice(String id, IModel<List<V>> choices, IChoiceRenderer<V> renderer)\n\t{\n\t\tsuper(id, choices, renderer);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String,\n\t *      IModel, List,IChoiceRenderer)\n\t */\n\tpublic ListMultipleChoice(final String id, IModel object, final List choices,\n\t\t\tfinal IChoiceRenderer renderer)\n\t{\n\t\tsuper(id, object, choices, renderer);\n\t}","id":23573,"modified_method":"/**\n\t * @see wicket.markup.html.form.AbstractChoice#AbstractChoice(String,\n\t *      IModel, List,IChoiceRenderer)\n\t */\n\tpublic ListMultipleChoice(final String id, IModel<Collection<V>> object, final List<V> choices,\n\t\t\tfinal IChoiceRenderer<V> renderer)\n\t{\n\t\tsuper(id, object, choices, renderer);\n\t}","commit_id":"52bde646ef6ef1fa9781d4da1c3d85fb8c97b5e7","url":"https://github.com/apache/wicket"},{"original_method":"public static void createSpeakerNotes1PerPage(File file)\n\t{\n\t\t\n\t\t // step 1: creation of a document-object\n\t\t\n\t\t//This is a bit of a mess but because of hte bugs with drawing the slides\n\t\t//the easy way, we have no other choice but to render them directly onto the pdf\n\t\t//which makes it hard to use tables for stuff like formatting text...so we'll render\n\t\t// a blank table cell then render the image into it.\n        Document document = new Document();\n        \n        try {\n        \t   GUI.activateWaitCursor();\n            // step 2:\n            // we create a writer that listens to the document\n            // and directs a PDF-stream to a file            \n            PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(file));\n            \n            // step 3: we open the document\n            document.open();\n            \n            PdfPTable table;\n            PdfPCell cell;            \n                                                  \n            for (LWPathway.Entry entry : VUE.getActivePathway().getEntries()) {\n            \t\n                final LWSlide slide = entry.produceSlide();\n                final LWComponent toDraw = (slide == null ? entry.node : slide);\n                final String notes = entry.getNotes();\n                //String label = entry.getLabel();\n                \n                PdfContentByte cb = writer.getDirectContent();\n\n                Point2D.Float offset = new Point2D.Float();\n            \n                Rectangle2D bounds = null;\n                \n                //if (!entry.isMapView())\n                \tbounds = slide.getBounds();\n                //else \n                \t//bounds = entry.getFocal().getBounds();\n            \n                Dimension page = null;\n            \n            \n                page = new Dimension(432,324);\n            \n                PdfTemplate tp = cb.createTemplate(432,324);                \n                double scale = ZoomTool.computeZoomFit(page, 5, bounds, offset, true);\n                Graphics2D g2d = tp.createGraphics(432,324, new DefaultFontMapper(),false,60.0f);\n                DrawContext dc = new DrawContext(g2d,\n                    scale,\n                    -offset.x,\n                    -offset.y,\n                    null, // frame would be the PageFormat offset & size rectangle\n                    entry.isMapView() ? entry.getFocal() : slide,\n                    false); // todo: absolute links shouldn't be spec'd here\n\n                dc.setClipOptimized(false);\n                /*if (!entry.isMapView())                \t\n                \tslide.drawZero(dc);\n                else\n                {                \n                \tentry.getFocal().draw(dc);\n                }*/\n                toDraw.drawFit(dc,0);\n\n                                                                                        \n                g2d.dispose();                                                                                                         \n\n                cb.addTemplate(tp,80, 482);\n\n                \n                //Paragraph p = new Paragraph();\n                //p.setExtraParagraphSpace(330);\n               // p.setSpacingBefore(330f);\n              //  p.setAlignment(Element.ALIGN_CENTER);\n                \n                Paragraph phrase = new Paragraph(notes);\n                //phrase.setExtraParagraphSpace(340f);\n                phrase.setSpacingBefore(320f);\n                phrase.setKeepTogether(true);\n               //cell = new PdfPCell(phrase);\n                //cell.setBorder(0);\n                   //         table = new PdfPTable(new float[]{ 1 });\n                  //        table.setWidthPercentage(100.0f);\n                  //        table.getDefaultCell().setBorder(0);\n                          //table.getDefaultCell().setPaddingTop(30);\n            \n                                                                                                            \n                \n                //PdfPCell c2 = new PdfPCell();\n                //c2.setFixedHeight(340); //slides are 540x405\n                //c2.setBorder(0);\n                //table.addCell(c2);                \n                //table.addCell(cell);\n                //table.setKeepTogether(false);\n                //cell.setVerticalAlignment(PdfPCell.ALIGN_TOP);\n                \n                //p.add(table);\n                //System.out.println(\"CELL HEIGHT : \" + cell.getHeight());\n                //Section s1 = new Section();\n                //ColumnText chunk2 = new ColumnText(cb);\n                //chunk2.setText(phrase);\n                //chunk2.setSi\n                //chunk2.setSimpleColumn(phrase,70, 330, document.getPageSize().width()-70,document.getPageSize().height()-70,15, Element.ALIGN_LEFT);\n               // chunk2.go();\n                //PdfChunk chunk2 = new PdfChunk);\n                Paragraph p2 = new Paragraph(\" \");\n                p2.setKeepTogether(false);\n                phrase.setKeepTogether(false);\n               // p2.setExtraParagraphSpace(230f);\n                document.add(p2);\n                document.add(phrase);\n                document.newPage();\n\n                \n              \n                \n            }\n        }\n        catch(DocumentException de) {\n            System.err.println(de.getMessage());\n        }\n        catch(IOException ioe) {\n            System.err.println(ioe.getMessage());\n        }\n        finally\n        {\n        \tGUI.clearWaitCursor();\n        }\n        \n        // step 5: we close the document\n        document.close();\n    }","id":23574,"modified_method":"public static void createSpeakerNotes1PerPage(File file)\n\t{\n\t\t\n\t\t // step 1: creation of a document-object\n\t\t\n\t\t//This is a bit of a mess but because of hte bugs with drawing the slides\n\t\t//the easy way, we have no other choice but to render them directly onto the pdf\n\t\t//which makes it hard to use tables for stuff like formatting text...so we'll render\n\t\t// a blank table cell then render the image into it.\n        Document document = new Document();\n        \n        try {\n        \t   GUI.activateWaitCursor();\n            // step 2:\n            // we create a writer that listens to the document\n            // and directs a PDF-stream to a file            \n            PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(file));\n            \n            // step 3: we open the document\n            document.open();\n            \n            PdfPTable table;\n            PdfPCell cell;            \n                                                  \n            for (LWPathway.Entry entry : VUE.getActivePathway().getEntries()) {\n            \t\n                final LWSlide slide = entry.produceSlide();\n                final LWComponent toDraw = (slide == null ? entry.node : slide);\n                final String notes = entry.getNotes();\n                //String label = entry.getLabel();\n                \n                PdfContentByte cb = writer.getDirectContent();\n\n                Point2D.Float offset = new Point2D.Float();\n            \n                Rectangle2D bounds = null;\n                \n                //if (!entry.isMapView())\n                \tbounds = slide.getBounds();\n                //else \n                \t//bounds = entry.getFocal().getBounds();\n            \n                Dimension page = null;\n            \n            \n                page = new Dimension(432,324);\n            \n                PdfTemplate tp = cb.createTemplate(432,324);                \n                double scale = ZoomTool.computeZoomFit(page, 5, bounds, offset, true);\n                PdfGraphics2D g2d = (PdfGraphics2D)tp.createGraphics(432,324, new DefaultFontMapper(),false,60.0f);\n                DrawContext dc = new DrawContext(g2d,\n                    scale,\n                    -offset.x,\n                    -offset.y,\n                    null, // frame would be the PageFormat offset & size rectangle\n                    entry.isMapView() ? entry.getFocal() : slide,\n                    false); // todo: absolute links shouldn't be spec'd here\n\n                dc.setClipOptimized(false);\n                /*if (!entry.isMapView())                \t\n                \tslide.drawZero(dc);\n                else\n                {                \n                \tentry.getFocal().draw(dc);\n                }*/\n                toDraw.drawFit(dc,0);\n\n                                                                                        \n                g2d.dispose();                                                                                                         \n\n                cb.addTemplate(tp,80, 482);\n\n                \n                //Paragraph p = new Paragraph();\n                //p.setExtraParagraphSpace(330);\n               // p.setSpacingBefore(330f);\n              //  p.setAlignment(Element.ALIGN_CENTER);\n                \n                Paragraph phrase = new Paragraph(notes);\n                //phrase.setExtraParagraphSpace(340f);\n                phrase.setSpacingBefore(320f);\n                phrase.setKeepTogether(true);\n               //cell = new PdfPCell(phrase);\n                //cell.setBorder(0);\n                   //         table = new PdfPTable(new float[]{ 1 });\n                  //        table.setWidthPercentage(100.0f);\n                  //        table.getDefaultCell().setBorder(0);\n                          //table.getDefaultCell().setPaddingTop(30);\n            \n                                                                                                            \n                \n                //PdfPCell c2 = new PdfPCell();\n                //c2.setFixedHeight(340); //slides are 540x405\n                //c2.setBorder(0);\n                //table.addCell(c2);                \n                //table.addCell(cell);\n                //table.setKeepTogether(false);\n                //cell.setVerticalAlignment(PdfPCell.ALIGN_TOP);\n                \n                //p.add(table);\n                //System.out.println(\"CELL HEIGHT : \" + cell.getHeight());\n                //Section s1 = new Section();\n                //ColumnText chunk2 = new ColumnText(cb);\n                //chunk2.setText(phrase);\n                //chunk2.setSi\n                //chunk2.setSimpleColumn(phrase,70, 330, document.getPageSize().width()-70,document.getPageSize().height()-70,15, Element.ALIGN_LEFT);\n               // chunk2.go();\n                //PdfChunk chunk2 = new PdfChunk);\n                Paragraph p2 = new Paragraph(\" \");\n                p2.setKeepTogether(false);\n                phrase.setKeepTogether(false);\n               // p2.setExtraParagraphSpace(230f);\n                document.add(p2);\n                document.add(phrase);\n                document.newPage();\n\n                \n              \n                \n            }\n        }\n        catch(DocumentException de) {\n            System.err.println(de.getMessage());\n        }\n        catch(IOException ioe) {\n            System.err.println(ioe.getMessage());\n        }\n        finally\n        {\n        \tGUI.clearWaitCursor();\n        }\n        \n        // step 5: we close the document\n        document.close();\n    }","commit_id":"b7bc72589251996f5feecd5c9d7d223c67d84c5f","url":"https://github.com/VUE/VUE"},{"original_method":"public static void createAudienceNotes(File file)\n\t{\n\t\t//page size notes:\n\t\t//martin-top,left,right,bottom = 36\n\t\t//widht :612\n\t\t//height : 792\n\t\t//usable space 540 x 720\n        // step 1: creation of a document-object\n        Document document = new Document(PageSize.LETTER);\n        \n        try {\n        \t   GUI.activateWaitCursor();\n            // step 2:\n            // we create a writer that listens to the document\n            // and directs a PDF-stream to a file            \n            PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(file));\n          //  writer.setDefaultColorspace(PdfName.DEFAULTRGB, null);\n           // writer.setStrictImageSequence(true);\n            \n            // step 3: we open the document\n            document.open();\n\n           // PdfPTable table;\n           // PdfPCell cell;            \n            int entryCount = 0;\n            int entryOnPage =0;\n            for (LWPathway.Entry entry : VUE.getActivePathway().getEntries()) {\n            \t\n                final LWSlide slide = entry.produceSlide();\n                final LWComponent toDraw = (slide == null ? entry.node : slide);\n                \n                entryCount++;\n                //String label = entry.getLabel();\n                PdfContentByte cb = writer.getDirectContent();\n                //cb.cr\n                PdfTemplate tp = cb.createTemplate(SlideSizeX,SlideSizeY);\n                Point2D.Float offset = new Point2D.Float();\n                // center vertically only if landscape mode\n                //if (format.getOrientation() == PageFormat.LANDSCAPE)\n                //TODO: allow horizontal centering, but not vertical centering (handle in computeZoomFit)\n                \n                Rectangle2D bounds = null;\n               \n                bounds = slide.getBounds();\n                \n                Dimension page = null;\n                \n                \n                page = new Dimension(SlideSizeX,172);\n                \n                //PdfTemplate tp = cb.createTemplate(document.getPageSize().width()-80, document.getPageSize().height()-80);\n                double scale = ZoomTool.computeZoomFit(page, 5, bounds, offset, true);\n                Graphics2D g2d = tp.createGraphics(SlideSizeX,SlideSizeY, new DefaultFontMapper(),false,60.0f);\n                DrawContext dc = new DrawContext(g2d,\n                        scale,\n                        -offset.x,\n                        -offset.y,\n                        null, // frame would be the PageFormat offset & size rectangle\n                        entry.isMapView() ? entry.getFocal() : slide,\n                        false); // todo: absolute links shouldn't be spec'd here\n \n                dc.setClipOptimized(false);\n                toDraw.drawFit(dc,0);\n\n                                                                                            \n                g2d.dispose();                                                                                                         \n                //document.add(Image.getInstance(tp));\n                \n                if (entryOnPage == 0)\n                {\n                \tdrawSequenceNumber(writer,36,739,entryCount);\n                \tcb.addTemplate(tp,56, 583);                \t                    \n                    cb.addTemplate(drawLines(writer),296,565);\n                \t\n                }\n                if (entryOnPage == 1)\n                {\n                \tdrawSequenceNumber(writer,36,559,entryCount);\n                \tcb.addTemplate(tp,56, 403);\n                \tcb.addTemplate(drawLines(writer),296,385);\n                }\n                if (entryOnPage == 2)\n                {\n                \tdrawSequenceNumber(writer,36,375,entryCount);\n                \tcb.addTemplate(tp,56, 219);\n                \tcb.addTemplate(drawLines(writer),296,201);\n                }\n                if (entryOnPage == 3)\n                {\n                \tdrawSequenceNumber(writer,36,192,entryCount);\n                \tcb.addTemplate(tp,56, 36);\n                \tcb.addTemplate(drawLines(writer),296,18);\n                }\n                \t\t\t\t\t\t   \n                \t\n                entryOnPage++;\n               if (entryCount % 4 == 0)\n               {\n            \t   document.newPage();\n            \t   entryOnPage =0;\n               }\n            }\n        }\n        catch(DocumentException de) {\n            System.err.println(de.getMessage());\n        }\n        catch(IOException ioe) {\n            System.err.println(ioe.getMessage());\n        }\n        finally\n        {\n        \tGUI.clearWaitCursor();\n        }\n        \n        // step 5: we close the document\n        document.close();     \n    }","id":23575,"modified_method":"public static void createAudienceNotes(File file)\n\t{\n\t\t//page size notes:\n\t\t//martin-top,left,right,bottom = 36\n\t\t//widht :612\n\t\t//height : 792\n\t\t//usable space 540 x 720\n        // step 1: creation of a document-object\n        Document document = new Document(PageSize.LETTER);\n        \n        try {\n        \t   GUI.activateWaitCursor();\n            // step 2:\n            // we create a writer that listens to the document\n            // and directs a PDF-stream to a file            \n            PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(file));\n          //  writer.setDefaultColorspace(PdfName.DEFAULTRGB, null);\n           // writer.setStrictImageSequence(true);\n            \n            // step 3: we open the document\n            document.open();\n\n           // PdfPTable table;\n           // PdfPCell cell;            \n            int entryCount = 0;\n            int entryOnPage =0;\n            for (LWPathway.Entry entry : VUE.getActivePathway().getEntries()) {\n            \t\n                final LWSlide slide = entry.produceSlide();\n                final LWComponent toDraw = (slide == null ? entry.node : slide);\n                \n                entryCount++;\n                //String label = entry.getLabel();\n                PdfContentByte cb = writer.getDirectContent();\n                //cb.cr\n                PdfTemplate tp = cb.createTemplate(SlideSizeX,SlideSizeY);\n                Point2D.Float offset = new Point2D.Float();\n                // center vertically only if landscape mode\n                //if (format.getOrientation() == PageFormat.LANDSCAPE)\n                //TODO: allow horizontal centering, but not vertical centering (handle in computeZoomFit)\n                \n                Rectangle2D bounds = null;\n               \n                bounds = slide.getBounds();\n                \n                Dimension page = null;\n                \n                \n                page = new Dimension(SlideSizeX,172);\n                \n                //PdfTemplate tp = cb.createTemplate(document.getPageSize().width()-80, document.getPageSize().height()-80);\n                double scale = ZoomTool.computeZoomFit(page, 5, bounds, offset, true);\n                PdfGraphics2D g2d = (PdfGraphics2D)tp.createGraphics(SlideSizeX,SlideSizeY, new DefaultFontMapper(),false,60.0f);\n                DrawContext dc = new DrawContext(g2d,\n                        scale,\n                        -offset.x,\n                        -offset.y,\n                        null, // frame would be the PageFormat offset & size rectangle\n                        entry.isMapView() ? entry.getFocal() : slide,\n                        false); // todo: absolute links shouldn't be spec'd here\n \n                dc.setClipOptimized(false);\n                toDraw.drawFit(dc,0);\n\n                                                                                            \n                g2d.dispose();                                                                                                         \n                //document.add(Image.getInstance(tp));\n                \n                if (entryOnPage == 0)\n                {\n                \tdrawSequenceNumber(writer,36,739,entryCount);\n                \tcb.addTemplate(tp,56, 583);                \t                    \n                    cb.addTemplate(drawLines(writer),296,565);\n                \t\n                }\n                if (entryOnPage == 1)\n                {\n                \tdrawSequenceNumber(writer,36,559,entryCount);\n                \tcb.addTemplate(tp,56, 403);\n                \tcb.addTemplate(drawLines(writer),296,385);\n                }\n                if (entryOnPage == 2)\n                {\n                \tdrawSequenceNumber(writer,36,375,entryCount);\n                \tcb.addTemplate(tp,56, 219);\n                \tcb.addTemplate(drawLines(writer),296,201);\n                }\n                if (entryOnPage == 3)\n                {\n                \tdrawSequenceNumber(writer,36,192,entryCount);\n                \tcb.addTemplate(tp,56, 36);\n                \tcb.addTemplate(drawLines(writer),296,18);\n                }\n                \t\t\t\t\t\t   \n                \t\n                entryOnPage++;\n               if (entryCount % 4 == 0)\n               {\n            \t   document.newPage();\n            \t   entryOnPage =0;\n               }\n            }\n        }\n        catch(DocumentException de) {\n            System.err.println(de.getMessage());\n        }\n        catch(IOException ioe) {\n            System.err.println(ioe.getMessage());\n        }\n        finally\n        {\n        \tGUI.clearWaitCursor();\n        }\n        \n        // step 5: we close the document\n        document.close();     \n    }","commit_id":"b7bc72589251996f5feecd5c9d7d223c67d84c5f","url":"https://github.com/VUE/VUE"},{"original_method":"public static void createSpeakerNotes4PerPage(File file)\n\t{\n\t\t//page size notes:\n\t\t//martin-top,left,right,bottom = 36\n\t\t//widht :612\n\t\t//height : 792\n\t\t//usable space 540 x 720\n        // step 1: creation of a document-object\n\t\t\n\t\t\n\t\t\n        Document document = new Document(PageSize.LETTER);\n        \n        try {\n        \t   GUI.activateWaitCursor();\n            // step 2:\n            // we create a writer that listens to the document\n            // and directs a PDF-stream to a file            \n            PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(file));\n          //  writer.setDefaultColorspace(PdfName.DEFAULTRGB, null);\n           // writer.setStrictImageSequence(true);\n            \n            // step 3: we open the document\n            document.open();\n\n            PdfPTable table;\n            PdfPCell cell;            \n            int entryCount = 0;\n            int entryOnPage =0;\n            for (LWPathway.Entry entry : VUE.getActivePathway().getEntries()) {\n            \t\n\n                final LWSlide slide = entry.produceSlide();\n                final LWComponent toDraw = (slide == null ? entry.node : slide);\n                final String notes = entry.getNotes();\n                entryCount++;\n                \n                \n                table = new PdfPTable(new float[]{ 1,1 });\n                table.getDefaultCell().setBorder(0);\n                //table.getDefaultCell().setPaddingBottom(50.0f);\n                table.setSpacingAfter(20.0f);\n                Paragraph p = new Paragraph();\n                \n                p.setAlignment(Element.ALIGN_CENTER);\n                                                \n                Phrase phrase = new Phrase(notes);\n                Font f = phrase.getFont();\n                f.setSize(8.0f);\n                p.setFont(f);\n                cell = new PdfPCell(phrase);\n                cell.setBorder(0);         \n                \n                PdfPCell i2 = new PdfPCell();\n                i2.setFixedHeight(172);\n                i2.setBorder(0);\n                \n                \n                \n                \n                                 \n                \n                //Render the table then throw the images on\n\t            PdfContentByte cb = writer.getDirectContent();\t            \n\t            PdfTemplate tp = cb.createTemplate(SlideSizeX,SlideSizeY);\n\t            \n\t            Point2D.Float offset = new Point2D.Float();\n                // center vertically only if landscape mode\n                //if (format.getOrientation() == PageFormat.LANDSCAPE)\n                //TODO: allow horizontal centering, but not vertical centering (handle in computeZoomFit)\n                \n                Rectangle2D bounds = null;\n                //if (!entry.isMapView())\n                \tbounds = slide.getBounds();\n                //else \n                \t//bounds = entry.getFocal().getBounds();\n                \n                Dimension page = null;\n                \n                \n                page = new Dimension(SlideSizeX,172);\n                \n                //PdfTemplate tp = cb.createTemplate(document.getPageSize().width()-80, document.getPageSize().height()-80);\n                double scale = ZoomTool.computeZoomFit(page, 5, bounds, offset, true);\n                Graphics2D g2d = tp.createGraphics(SlideSizeX,SlideSizeY, new DefaultFontMapper(),false,60.0f);\n                DrawContext dc = new DrawContext(g2d,\n                        scale,\n                        -offset.x,\n                        -offset.y,\n                        null, // frame would be the PageFormat offset & size rectangle\n                        entry.isMapView() ? entry.getFocal() : slide,\n                        false); // todo: absolute links shouldn't be spec'd here\n \n                dc.setClipOptimized(false);\n                /*if (!entry.isMapView())                \t\n                \tslide.drawZero(dc);\n                else\n                {                \n                \tentry.getFocal().draw(dc);\n                }*/\n                toDraw.drawFit(dc,0);\n\n                                                                                            \n                g2d.dispose();                                                                                                         \n                //document.add(Image.getInstance(tp));\n                \n              //  int position = cell.\n           //     drawSequenceNumber(writer,36,position+203,entryCount);\n                \n           //     cb.addTemplate(tp,56, position);                \t                                        \n                \t\t\t\t\t\t   \n                              \n                Image img = Image.getInstance(tp);\n\t            table.addCell(img);\n\t            table.addCell(cell);\n\t            p.add(table);\n\t            document.add(p);\n            }\n            \n        }\n        catch(DocumentException de) {\n            System.err.println(de.getMessage());\n        }\n        catch(IOException ioe) {\n            System.err.println(ioe.getMessage());\n        }\n        finally\n        {\n        \tGUI.clearWaitCursor();\n        }\n        \n        // step 5: we close the document\n        document.close();\n        \n\t}","id":23576,"modified_method":"public static void createSpeakerNotes4PerPage(File file)\n\t{\n\t\t//page size notes:\n\t\t//martin-top,left,right,bottom = 36\n\t\t//widht :612\n\t\t//height : 792\n\t\t//usable space 540 x 720\n        // step 1: creation of a document-object\n\t\t\n\t\t\n\t\t\n        Document document = new Document(PageSize.LETTER);\n        \n        try {\n        \t   GUI.activateWaitCursor();\n            // step 2:\n            // we create a writer that listens to the document\n            // and directs a PDF-stream to a file            \n            PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(file));\n          //  writer.setDefaultColorspace(PdfName.DEFAULTRGB, null);\n           // writer.setStrictImageSequence(true);\n            \n            // step 3: we open the document\n            document.open();\n\n            PdfPTable table;\n            PdfPCell cell;            \n            int entryCount = 0;\n            int entryOnPage =0;\n            for (LWPathway.Entry entry : VUE.getActivePathway().getEntries()) {\n            \t\n\n                final LWSlide slide = entry.produceSlide();\n                final LWComponent toDraw = (slide == null ? entry.node : slide);\n                final String notes = entry.getNotes();\n                entryCount++;\n                \n                \n                table = new PdfPTable(new float[]{ 1,1 });\n                table.getDefaultCell().setBorder(0);\n                //table.getDefaultCell().setPaddingBottom(50.0f);\n                table.setSpacingAfter(20.0f);\n                Paragraph p = new Paragraph();\n                \n                p.setAlignment(Element.ALIGN_CENTER);\n                                                \n                Phrase phrase = new Phrase(notes);\n                Font f = phrase.getFont();\n                f.setSize(8.0f);\n                p.setFont(f);\n                cell = new PdfPCell(phrase);\n                cell.setBorder(0);         \n                \n                PdfPCell i2 = new PdfPCell();\n                i2.setFixedHeight(172);\n                i2.setBorder(0);\n                \n                \n                \n                \n                                 \n                \n                //Render the table then throw the images on\n\t            PdfContentByte cb = writer.getDirectContent();\t            \n\t            PdfTemplate tp = cb.createTemplate(SlideSizeX,SlideSizeY);\n\t            \n\t            Point2D.Float offset = new Point2D.Float();\n                // center vertically only if landscape mode\n                //if (format.getOrientation() == PageFormat.LANDSCAPE)\n                //TODO: allow horizontal centering, but not vertical centering (handle in computeZoomFit)\n                \n                Rectangle2D bounds = null;\n                //if (!entry.isMapView())\n                \tbounds = slide.getBounds();\n                //else \n                \t//bounds = entry.getFocal().getBounds();\n                \n                Dimension page = null;\n                \n                \n                page = new Dimension(SlideSizeX,172);\n                \n                //PdfTemplate tp = cb.createTemplate(document.getPageSize().width()-80, document.getPageSize().height()-80);\n                double scale = ZoomTool.computeZoomFit(page, 5, bounds, offset, true);\n                PdfGraphics2D g2d = (PdfGraphics2D)tp.createGraphics(SlideSizeX,SlideSizeY, new DefaultFontMapper(),false,60.0f);\n                DrawContext dc = new DrawContext(g2d,\n                        scale,\n                        -offset.x,\n                        -offset.y,\n                        null, // frame would be the PageFormat offset & size rectangle\n                        entry.isMapView() ? entry.getFocal() : slide,\n                        false); // todo: absolute links shouldn't be spec'd here\n \n                dc.setClipOptimized(false);\n                /*if (!entry.isMapView())                \t\n                \tslide.drawZero(dc);\n                else\n                {                \n                \tentry.getFocal().draw(dc);\n                }*/\n                toDraw.drawFit(dc,0);\n\n                                                                                            \n                g2d.dispose();                                                                                                         \n                //document.add(Image.getInstance(tp));\n                \n              //  int position = cell.\n           //     drawSequenceNumber(writer,36,position+203,entryCount);\n                \n           //     cb.addTemplate(tp,56, position);                \t                                        \n                \t\t\t\t\t\t   \n                              \n                Image img = Image.getInstance(tp);\n\t            table.addCell(img);\n\t            table.addCell(cell);\n\t            p.add(table);\n\t            document.add(p);\n            }\n            \n        }\n        catch(DocumentException de) {\n            System.err.println(de.getMessage());\n        }\n        catch(IOException ioe) {\n            System.err.println(ioe.getMessage());\n        }\n        finally\n        {\n        \tGUI.clearWaitCursor();\n        }\n        \n        // step 5: we close the document\n        document.close();\n        \n\t}","commit_id":"b7bc72589251996f5feecd5c9d7d223c67d84c5f","url":"https://github.com/VUE/VUE"},{"original_method":"public static void createPresentationNotes8PerPage(File file)\n\t{\n\t\t//page size notes:\n\t\t//martin-top,left,right,bottom = 36\n\t\t//widht :612\n\t\t//height : 792\n\t\t//usable space 540 x 720\n        // step 1: creation of a document-object\n        Document document = new Document(PageSize.LETTER);\n        \n        try {\n        \tGUI.activateWaitCursor();\n            // step 2:\n            // we create a writer that listens to the document\n            // and directs a PDF-stream to a file            \n            PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(file));\n          //  writer.setDefaultColorspace(PdfName.DEFAULTRGB, null);\n           // writer.setStrictImageSequence(true);\n            \n            // step 3: we open the document\n            document.open();\n\n           // PdfPTable table;\n           // PdfPCell cell;            \n            int entryCount = 0;\n            int entryOnPage =0;\n            for (LWPathway.Entry entry : VUE.getActivePathway().getEntries()) {\n            \t\n                final LWSlide slide = entry.produceSlide();\n                final LWComponent toDraw = (slide == null ? entry.node : slide);\n                \n                entryCount++;\n                //String label = entry.getLabel();\n                PdfContentByte cb = writer.getDirectContent();\n                //cb.cr\n                PdfTemplate tp = cb.createTemplate(SlideSizeX,SlideSizeY);\n                Point2D.Float offset = new Point2D.Float();\n                \n                Rectangle2D bounds = null;\n         \n               \tbounds = slide.getBounds();\n                \n                Dimension page = null;\n                \n                \n                page = new Dimension(SlideSizeX,172);\n                \n                //PdfTemplate tp = cb.createTemplate(document.getPageSize().width()-80, document.getPageSize().height()-80);\n                double scale = ZoomTool.computeZoomFit(page, 5, bounds, offset, true);\n                Graphics2D g2d = tp.createGraphics(SlideSizeX,SlideSizeY, new DefaultFontMapper(),false,60.0f);\n                DrawContext dc = new DrawContext(g2d,\n                        scale,\n                        -offset.x,\n                        -offset.y,\n                        null, // frame would be the PageFormat offset & size rectangle\n                        entry.isMapView() ? entry.getFocal() : slide,\n                        false); // todo: absolute links shouldn't be spec'd here\n \n                dc.setClipOptimized(false);                        \t\n                //slide.drawZero(dc);\n                toDraw.drawFit(dc, 0);\n                                                                                            \n                g2d.dispose();                                                                                                         \n                //document.add(Image.getInstance(tp));\n                \n                if (entryOnPage == 0)\n                {\n                \tdrawSequenceNumber(writer,36,739,entryCount);\n                \tcb.addTemplate(tp,56, 583);                \t                                                        \t\n                }\n                if (entryOnPage == 1)\n                {\n                \tdrawSequenceNumber(writer,296,739,entryCount);\n                \tcb.addTemplate(tp,306, 583);                \t                                                        \t\n                }\n                if (entryOnPage == 2)\n                {\n                \tdrawSequenceNumber(writer,36,559,entryCount);\n                \tcb.addTemplate(tp,56, 403);                \t\n                }\n                if (entryOnPage == 3)\n                {\n                \tdrawSequenceNumber(writer,296,559,entryCount);\n                \tcb.addTemplate(tp,306, 403);                \t                                                        \t\n                }\n                if (entryOnPage == 4)\n                {\n                \tdrawSequenceNumber(writer,36,375,entryCount);\n                \tcb.addTemplate(tp,56, 219);                \t\n                }\n                if (entryOnPage == 5)\n                {\n                \tdrawSequenceNumber(writer,296,375,entryCount);\n                \tcb.addTemplate(tp,306, 219);                \t                                                        \t\n                }\n                if (entryOnPage == 6)\n                {\n                \tdrawSequenceNumber(writer,36,192,entryCount);\n                \tcb.addTemplate(tp,56, 36);\n                \t//cb.addTemplate(drawLines(writer),296,18);\n                }\n                if (entryOnPage == 7)\n                {\n                \tdrawSequenceNumber(writer,296,192,entryCount);\n                \tcb.addTemplate(tp,306, 36);                \t                                                        \t\n                }\n                \t\t\t\t\t\t   \n                \t\n                entryOnPage++;\n               if (entryCount % 8 == 0)\n               {\n            \t   document.newPage();\n            \t   entryOnPage =0;\n               }\n            }\n        }\n        catch(DocumentException de) {\n            System.err.println(de.getMessage());\n        }\n        catch(IOException ioe) {\n            System.err.println(ioe.getMessage());\n        }\n        finally\n        {\n        \t GUI.clearWaitCursor();\n        }\n        \n        // step 5: we close the document\n        document.close();\n    }","id":23577,"modified_method":"public static void createPresentationNotes8PerPage(File file)\n\t{\n\t\t//page size notes:\n\t\t//martin-top,left,right,bottom = 36\n\t\t//widht :612\n\t\t//height : 792\n\t\t//usable space 540 x 720\n        // step 1: creation of a document-object\n        Document document = new Document(PageSize.LETTER);\n        \n        try {\n        \tGUI.activateWaitCursor();\n            // step 2:\n            // we create a writer that listens to the document\n            // and directs a PDF-stream to a file            \n            PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(file));\n          //  writer.setDefaultColorspace(PdfName.DEFAULTRGB, null);\n           // writer.setStrictImageSequence(true);\n            \n            // step 3: we open the document\n            document.open();\n\n           // PdfPTable table;\n           // PdfPCell cell;            \n            int entryCount = 0;\n            int entryOnPage =0;\n            for (LWPathway.Entry entry : VUE.getActivePathway().getEntries()) {\n            \t\n                final LWSlide slide = entry.produceSlide();\n                final LWComponent toDraw = (slide == null ? entry.node : slide);\n                \n                entryCount++;\n                //String label = entry.getLabel();\n                PdfContentByte cb = writer.getDirectContent();\n                //cb.cr\n                PdfTemplate tp = cb.createTemplate(SlideSizeX,SlideSizeY);\n                Point2D.Float offset = new Point2D.Float();\n                \n                Rectangle2D bounds = null;\n         \n               \tbounds = slide.getBounds();\n                \n                Dimension page = null;\n                \n                \n                page = new Dimension(SlideSizeX,172);\n                \n                //PdfTemplate tp = cb.createTemplate(document.getPageSize().width()-80, document.getPageSize().height()-80);\n                double scale = ZoomTool.computeZoomFit(page, 5, bounds, offset, true);\n                PdfGraphics2D g2d = (PdfGraphics2D)tp.createGraphics(SlideSizeX,SlideSizeY, new DefaultFontMapper(),false,60.0f);\n                DrawContext dc = new DrawContext(g2d,\n                        scale,\n                        -offset.x,\n                        -offset.y,\n                        null, // frame would be the PageFormat offset & size rectangle\n                        entry.isMapView() ? entry.getFocal() : slide,\n                        false); // todo: absolute links shouldn't be spec'd here\n \n                dc.setClipOptimized(false);                        \t\n                //slide.drawZero(dc);\n                toDraw.drawFit(dc, 0);\n                                                                                            \n                g2d.dispose();                                                                                                         \n                //document.add(Image.getInstance(tp));\n                \n                if (entryOnPage == 0)\n                {\n                \tdrawSequenceNumber(writer,36,739,entryCount);\n                \tcb.addTemplate(tp,56, 583);                \t                                                        \t\n                }\n                if (entryOnPage == 1)\n                {\n                \tdrawSequenceNumber(writer,296,739,entryCount);\n                \tcb.addTemplate(tp,306, 583);                \t                                                        \t\n                }\n                if (entryOnPage == 2)\n                {\n                \tdrawSequenceNumber(writer,36,559,entryCount);\n                \tcb.addTemplate(tp,56, 403);                \t\n                }\n                if (entryOnPage == 3)\n                {\n                \tdrawSequenceNumber(writer,296,559,entryCount);\n                \tcb.addTemplate(tp,306, 403);                \t                                                        \t\n                }\n                if (entryOnPage == 4)\n                {\n                \tdrawSequenceNumber(writer,36,375,entryCount);\n                \tcb.addTemplate(tp,56, 219);                \t\n                }\n                if (entryOnPage == 5)\n                {\n                \tdrawSequenceNumber(writer,296,375,entryCount);\n                \tcb.addTemplate(tp,306, 219);                \t                                                        \t\n                }\n                if (entryOnPage == 6)\n                {\n                \tdrawSequenceNumber(writer,36,192,entryCount);\n                \tcb.addTemplate(tp,56, 36);\n                \t//cb.addTemplate(drawLines(writer),296,18);\n                }\n                if (entryOnPage == 7)\n                {\n                \tdrawSequenceNumber(writer,296,192,entryCount);\n                \tcb.addTemplate(tp,306, 36);                \t                                                        \t\n                }\n                \t\t\t\t\t\t   \n                \t\n                entryOnPage++;\n               if (entryCount % 8 == 0)\n               {\n            \t   document.newPage();\n            \t   entryOnPage =0;\n               }\n            }\n        }\n        catch(DocumentException de) {\n            System.err.println(de.getMessage());\n        }\n        catch(IOException ioe) {\n            System.err.println(ioe.getMessage());\n        }\n        finally\n        {\n        \t GUI.clearWaitCursor();\n        }\n        \n        // step 5: we close the document\n        document.close();\n    }","commit_id":"b7bc72589251996f5feecd5c9d7d223c67d84c5f","url":"https://github.com/VUE/VUE"},{"original_method":"public static void createNodeNotes4PerPage(File file)\n\t{\n\t\t//page size notes:\n\t\t//martin-top,left,right,bottom = 36\n\t\t//widht :612\n\t\t//height : 792\n\t\t//usable space 540 x 720\n        // step 1: creation of a document-object\n\t\t\n\t\t\n\t\t\n        Document document = new Document(PageSize.LETTER);\n        \n        try {\n        \t   GUI.activateWaitCursor();\n            // step 2:\n            // we create a writer that listens to the document\n            // and directs a PDF-stream to a file            \n            PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(file));\n          //  writer.setDefaultColorspace(PdfName.DEFAULTRGB, null);\n           // writer.setStrictImageSequence(true);\n            \n            // step 3: we open the document\n            document.open();\n\n            PdfPTable table;\n            PdfPCell cell;            \n            int entryCount = 0;\n            int entryOnPage =0;\n                       \n            Iterator i = VUE.getActiveMap().getAllDescendents(LWComponent.ChildKind.PROPER).iterator();\n            while (i.hasNext())\n            {\n                LWComponent component = (LWComponent) i.next();\n                if (component instanceof LWNode)\n                {\n                \tfinal LWNode node= (LWNode)component;\n                \t\n                \tfinal String notes = node.getNotes();                                \n                \n                \tentryCount++;                \n                \n                \ttable = new PdfPTable(new float[]{ 1,1 });\n                \ttable.getDefaultCell().setBorder(0);\n\n                \ttable.setSpacingAfter(20.0f);\n                \tParagraph p = new Paragraph();\n                \n                \tp.setAlignment(Element.ALIGN_CENTER);\n                                                \n                \tPhrase phrase = new Phrase(notes);\n                \t\n                \tFont f = phrase.getFont();\n                \tf.setSize(8.0f);\n                \tp.setFont(f);\n                \tcell = new PdfPCell(phrase);\n                \tcell.setVerticalAlignment(PdfPCell.ALIGN_MIDDLE);\n                \tcell.setBorder(0);         \n                \n                \tPdfPCell i2 = new PdfPCell();\n                \ti2.setFixedHeight(172);\n                \ti2.setBorder(0);                                                                                             \n                \n                \t//Render the table then throw the images on\n                \tPdfContentByte cb = writer.getDirectContent();\t            \n                \tPdfTemplate tp = cb.createTemplate(SlideSizeX,SlideSizeY);\n\t            \n                \tPoint2D.Float offset = new Point2D.Float();\n                \t//center vertically only if landscape mode\n                \t//if (format.getOrientation() == PageFormat.LANDSCAPE)\n                \t//TODO: allow horizontal centering, but not vertical centering (handle in computeZoomFit)\n                \n                \tRectangle2D bounds = null;\n                \n                \tbounds = node.getBounds();\n                \n                \tDimension page = null;\n                \n                \n                \tpage = new Dimension(SlideSizeX,172);\n                \n                //\tPdfTemplate tp = cb.createTemplate(document.getPageSize().width()-80, document.getPageSize().height()-80);\n                \tdouble scale = ZoomTool.computeZoomFit(page, 15, bounds, offset, true);\n                \tGraphics2D g2d = tp.createGraphics(SlideSizeX,SlideSizeY, new DefaultFontMapper(),false,60.0f);\n                \tDrawContext dc = new DrawContext(g2d,\n                        scale,\n                        -offset.x,\n                        -offset.y,\n                        null, // frame would be the PageFormat offset & size rectangle\n                        node,\n                        false); // todo: absolute links shouldn't be spec'd here\n \n                \tdc.setClipOptimized(false);\n                    node.drawFit(dc,15);\n                    \n\n                                                                                            \n                    g2d.dispose();                                                                                                         \n                              \n                    Image img = Image.getInstance(tp);\n                    table.addCell(img);\n                    table.addCell(cell);\n                    p.add(table);\n                    document.add(p);\n                }\n            }\n            \n        }\n        catch(DocumentException de) {\n            System.err.println(de.getMessage());\n        }\n        catch(IOException ioe) {\n            System.err.println(ioe.getMessage());\n        }\n        finally\n        {\n        \tGUI.clearWaitCursor();\n        }\n        \n        // step 5: we close the document\n        document.close();\n        \n\t}","id":23578,"modified_method":"public static void createNodeNotes4PerPage(File file)\n\t{\n\t\t//page size notes:\n\t\t//martin-top,left,right,bottom = 36\n\t\t//widht :612\n\t\t//height : 792\n\t\t//usable space 540 x 720\n        // step 1: creation of a document-object\n\t\t\n\t\t\n\t\t\n        Document document = new Document(PageSize.LETTER);\n        \n        try {\n        \t   GUI.activateWaitCursor();\n            // step 2:\n            // we create a writer that listens to the document\n            // and directs a PDF-stream to a file            \n            PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(file));\n          //  writer.setDefaultColorspace(PdfName.DEFAULTRGB, null);\n           // writer.setStrictImageSequence(true);\n            \n            // step 3: we open the document\n            document.open();\n\n            PdfPTable table;\n            PdfPCell cell;            \n            int entryCount = 0;\n            int entryOnPage =0;\n                       \n            Iterator i = VUE.getActiveMap().getAllDescendents(LWComponent.ChildKind.PROPER).iterator();\n            while (i.hasNext())\n            {\n                LWComponent component = (LWComponent) i.next();\n                if (component instanceof LWNode)\n                {\n                \tfinal LWNode node= (LWNode)component;\n                \t\n                \tfinal String notes = node.getNotes();                                \n                \n                \tentryCount++;                \n                \n                \ttable = new PdfPTable(new float[]{ 1,1 });\n                \ttable.getDefaultCell().setBorder(0);\n\n                \ttable.setSpacingAfter(20.0f);\n                \tParagraph p = new Paragraph();\n                \n                \tp.setAlignment(Element.ALIGN_CENTER);\n                                                \n                \tPhrase phrase = new Phrase(notes);\n                \t\n                \tFont f = phrase.getFont();\n                \tf.setSize(8.0f);\n                \tp.setFont(f);\n                \tcell = new PdfPCell(phrase);\n                \tcell.setVerticalAlignment(PdfPCell.ALIGN_MIDDLE);\n                \tcell.setBorder(0);         \n                \n                \tPdfPCell i2 = new PdfPCell();\n                \ti2.setFixedHeight(172);\n                \ti2.setBorder(0);                                                                                             \n                \n                \t//Render the table then throw the images on\n                \tPdfContentByte cb = writer.getDirectContent();\t            \n                \tPdfTemplate tp = cb.createTemplate(SlideSizeX,SlideSizeY);\n\t            \n                \tPoint2D.Float offset = new Point2D.Float();\n                \t//center vertically only if landscape mode\n                \t//if (format.getOrientation() == PageFormat.LANDSCAPE)\n                \t//TODO: allow horizontal centering, but not vertical centering (handle in computeZoomFit)\n                \n                \tRectangle2D bounds = null;\n                \n                \tbounds = node.getBounds();\n                \n                \tDimension page = null;\n                \n                \n                \tpage = new Dimension(SlideSizeX,172);\n                \n                //\tPdfTemplate tp = cb.createTemplate(document.getPageSize().width()-80, document.getPageSize().height()-80);\n                \tdouble scale = ZoomTool.computeZoomFit(page, 15, bounds, offset, true);\n                \tPdfGraphics2D g2d = (PdfGraphics2D)tp.createGraphics(SlideSizeX,SlideSizeY, new DefaultFontMapper(),false,60.0f);\n                \tDrawContext dc = new DrawContext(g2d,\n                        scale,\n                        -offset.x,\n                        -offset.y,\n                        null, // frame would be the PageFormat offset & size rectangle\n                        node,\n                        false); // todo: absolute links shouldn't be spec'd here\n \n                \tdc.setClipOptimized(false);\n                    node.drawFit(dc,15);\n                    \n\n                                                                                            \n                    g2d.dispose();                                                                                                         \n                              \n                    Image img = Image.getInstance(tp);\n                    table.addCell(img);\n                    table.addCell(cell);\n                    p.add(table);\n                    document.add(p);\n                }\n            }\n            \n        }\n        catch(DocumentException de) {\n            System.err.println(de.getMessage());\n        }\n        catch(IOException ioe) {\n            System.err.println(ioe.getMessage());\n        }\n        finally\n        {\n        \tGUI.clearWaitCursor();\n        }\n        \n        // step 5: we close the document\n        document.close();\n        \n\t}","commit_id":"b7bc72589251996f5feecd5c9d7d223c67d84c5f","url":"https://github.com/VUE/VUE"},{"original_method":"public static void createMapAsPDF(File file)\n\t{\n        // step 1: creation of a document-object\n        Document document = new Document(PageSize.LETTER.rotate());\n        \n        try {\n        \tGUI.activateWaitCursor();\n            // step 2:\n            // we create a writer that listens to the document\n            // and directs a PDF-stream to a file            \n            PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(file));\n            writer.setDefaultColorspace(PdfName.DEFAULTRGB, null);\n           // writer.setStrictImageSequence(true);\n            // step 3: we open the document\n            \n            document.open();            \n            \n\n            PdfContentByte cb = writer.getDirectContent();\n            \n            PdfTemplate tp = cb.createTemplate(document.getPageSize().width()-70, document.getPageSize().height()-70);\n            \n            Graphics2D g2d = tp.createGraphics(document.getPageSize().width()-70, document.getPageSize().height()-70, new DefaultFontMapper(),false,60.0f);                                   \n            \n            Dimension page = new Dimension((int)document.getPageSize().width()-70,(int)document.getPageSize().getHeight()-70);\n            // compute zoom & offset for visible map components\n            Point2D.Float offset = new Point2D.Float();\n            // center vertically only if landscape mode\n            //if (format.getOrientation() == PageFormat.LANDSCAPE)\n            //TODO: allow horizontal centering, but not vertical centering (handle in computeZoomFit)\n            Rectangle2D bounds = VUE.getActiveMap().getBounds();\n            double scale = ZoomTool.computeZoomFit(page, 5, bounds, offset, true);\n          //  System.out.println(scale  + \" zoom factor...\");\n            // set up the DrawContext\n            DrawContext dc = new DrawContext(g2d,\n                      scale,\n                      -offset.x,\n                      -offset.y,\n                      null, // frame would be the PageFormat offset & size rectangle\n                      VUE.getActiveMap(),\n                      false); // todo: absolute links shouldn't be spec'd here\n\n        //    dc.setAntiAlias(true);\n            dc.setMapDrawing();\n            dc.setPrioritizeQuality(false);\n            dc.setAntiAlias(false);\n            \n            dc.setClipOptimized(true);\t\n         //   dc.setDraftQuality(true);\n          //  dc.setRawDrawing();\n            //dc.setClipOptimized(false);\n            \n            dc.setInteractive(false);\n            dc.setDrawPathways(false);\n           // VUE.getActiveMap().draw(dc);\n            LWPathway.setShowSlides(false);\n            VUE.getActiveMap().drawZero(dc);\n            LWPathway.setShowSlides(true);\n            g2d.dispose();\n            \n            cb.addTemplate(tp,35,35);\n            document.newPage();\n                                                          \n        }\n        catch(DocumentException de) {\n            System.err.println(de.getMessage());\n        }\n        catch(IOException ioe) {\n            System.err.println(ioe.getMessage());\n        }\n        finally\n        {\n        \t   GUI.clearWaitCursor();\n        }\n        \n        // step 5: we close the document\n        document.close();\n    }","id":23579,"modified_method":"public static void createMapAsPDF(File file)\n\t{\n        // step 1: creation of a document-object\n        Document document = new Document(PageSize.LETTER.rotate());\n        \n        try {\n        \tGUI.activateWaitCursor();\n            // step 2:\n            // we create a writer that listens to the document\n            // and directs a PDF-stream to a file            \n            PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(file));\n            writer.setDefaultColorspace(PdfName.DEFAULTRGB, null);\n           // writer.setStrictImageSequence(true);\n            // step 3: we open the document\n            \n            document.open();            \n            \n\n            PdfContentByte cb = writer.getDirectContent();\n            \n            PdfTemplate tp = cb.createTemplate(document.getPageSize().getWidth()-70, document.getPageSize().getHeight()-70);\n            \n            PdfGraphics2D g2d = (PdfGraphics2D)tp.createGraphics(document.getPageSize().getWidth()-70, document.getPageSize().getHeight()-70, new DefaultFontMapper(),false,60.0f);                                   \n            \n            Dimension page = new Dimension((int)document.getPageSize().getWidth()-70,(int)document.getPageSize().getHeight()-70);\n            // compute zoom & offset for visible map components\n            Point2D.Float offset = new Point2D.Float();\n            // center vertically only if landscape mode\n            //if (format.getOrientation() == PageFormat.LANDSCAPE)\n            //TODO: allow horizontal centering, but not vertical centering (handle in computeZoomFit)\n            Rectangle2D bounds = VUE.getActiveMap().getBounds();\n            double scale = ZoomTool.computeZoomFit(page, 5, bounds, offset, true);\n          //  System.out.println(scale  + \" zoom factor...\");\n            // set up the DrawContext\n            DrawContext dc = new DrawContext(g2d,\n                      scale,\n                      -offset.x,\n                      -offset.y,\n                      null, // frame would be the PageFormat offset & size rectangle\n                      VUE.getActiveMap(),\n                      false); // todo: absolute links shouldn't be spec'd here\n\n        //    dc.setAntiAlias(true);\n            dc.setMapDrawing();\n            dc.setPrioritizeQuality(false);\n            dc.setAntiAlias(false);\n            \n            dc.setClipOptimized(true);\t\n         //   dc.setDraftQuality(true);\n          //  dc.setRawDrawing();\n            //dc.setClipOptimized(false);\n            \n            dc.setInteractive(false);\n            dc.setDrawPathways(false);\n           // VUE.getActiveMap().draw(dc);\n            LWPathway.setShowSlides(false);\n            VUE.getActiveMap().drawZero(dc);\n            LWPathway.setShowSlides(true);\n            g2d.dispose();\n          //  document.add(new Paragraph(new Chunk().setAnchor(\"http://www.cnn.com\")));\n            cb.addTemplate(tp,35,35);\n            document.newPage();\n                                                          \n        }\n        catch(DocumentException de) {\n            System.err.println(de.getMessage());\n        }\n        catch(IOException ioe) {\n            System.err.println(ioe.getMessage());\n        }\n        finally\n        {\n        \t   GUI.clearWaitCursor();\n        }\n        \n        // step 5: we close the document\n        document.close();\n    }","commit_id":"b7bc72589251996f5feecd5c9d7d223c67d84c5f","url":"https://github.com/VUE/VUE"},{"original_method":"public static void createPresentationSlidesDeck(File file)\n\t{\n        // step 1: creation of a document-object\n        final Document document = new Document(PageSize.LETTER.rotate());\n        \n        try {\n        \tGUI.activateWaitCursor();\n            // step 2:\n            // we create a writer that listens to the document\n            // and directs a PDF-stream to a file            \n            final PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(file));\n            writer.setDefaultColorspace(PdfName.DEFAULTRGB, null);\n            writer.setStrictImageSequence(true);\n            // step 3: we open the document\n            \n            document.open();\n            \n            final float pageWidth = document.getPageSize().width();\n            final float pageHeight = document.getPageSize().height();\n            final float fillWidth = pageWidth - 70;\n            final float fillHeight = pageHeight - 70;\n\n            if (DEBUG.Enabled) {\n                System.out.println(\"\\n---------------------------------\");\n                System.out.println(\"PDF DOCUMENT: pageSize \" + document.getPageSize());\n                System.out.println(\"fillWidth=\" + fillWidth + \" fillHeight=\" + fillHeight);\n            }\n            \n\n            for (LWPathway.Entry entry : VUE.getActivePathway().getEntries()) {\n\n                if (DEBUG.Enabled) System.out.println(\"\\nHANDLING ENTRY \" + entry);\n                final LWSlide slide = entry.produceSlide();\n                final LWComponent toDraw = (slide == null ? entry.node : slide);\n                \n                final PdfTemplate template = PdfTemplate.createTemplate(writer, fillWidth, fillHeight);\n                final Graphics2D graphics = template.createGraphics(fillWidth, fillHeight, new DefaultFontMapper(), false, 60.0f);\n                final DrawContext dc = new DrawContext(graphics, 1.0);\n                //final DrawContext dc = new DrawContext(graphics, scale);\n                //final DrawContext dc = new DrawContext(graphics, toDraw);\n                dc.setClipOptimized(false);\n                dc.setInteractive(false);\n                \n                if (DEBUG.Enabled) {\n                    System.out.println(\"  DRAWING INTO \" + dc + \" g=\" + graphics + \" clip=\" + tufts.Util.fmt(graphics.getClip()));\n                    if (DEBUG.PDF) {\n                        dc.g.setColor(Color.green);\n                        dc.g.fillRect(-Short.MAX_VALUE/2, -Short.MAX_VALUE/2, Short.MAX_VALUE, Short.MAX_VALUE);\n                    }\n                }\n\n                toDraw.drawFit(dc, 0);\n                if (DEBUG.PDF) {\n                    final String dcDesc = dc.toString() + String.format(\" scale=%.1f%%\", dc.g.getTransform().getScaleX() * 100);\n                    dc.setRawDrawing();\n                    dc.g.setColor(Color.red);\n                    dc.g.setFont(VueConstants.FixedSmallFont);\n                    dc.g.drawString(dcDesc, 10, fillHeight - 27);\n                    dc.g.drawString(entry.toString(), 10, fillHeight - 16);\n                    dc.g.drawString(toDraw.toString(), 10, fillHeight - 5);\n                }\n                \n                // the graphics dispose appears to be very important -- we've seen completely intermittant\n                // problems with generating many page PDF documents, which would be well explained by\n                // java or internal itext buffers running out of memory.\n                graphics.dispose();\n\n                document.add(Image.getInstance(template));\n                document.newPage();\n            }\n        }\n        catch(DocumentException de) {\n            System.err.println(de.getMessage());\n        }\n        catch(IOException ioe) {\n            System.err.println(ioe.getMessage());\n        }\n        finally\n        {\n        \t   GUI.clearWaitCursor();\n        }\n        \n        // step 5: we close the document\n        document.close();\n    }","id":23580,"modified_method":"public static void createPresentationSlidesDeck(File file)\n\t{\n        // step 1: creation of a document-object\n        final Document document = new Document(PageSize.LETTER.rotate());\n        \n        try {\n        \tGUI.activateWaitCursor();\n            // step 2:\n            // we create a writer that listens to the document\n            // and directs a PDF-stream to a file            \n            final PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream(file));\n            writer.setDefaultColorspace(PdfName.DEFAULTRGB, null);\n            writer.setStrictImageSequence(true);\n            // step 3: we open the document\n            \n            document.open();\n            \n            final float pageWidth = document.getPageSize().getWidth();\n            final float pageHeight = document.getPageSize().getHeight();\n            final float fillWidth = pageWidth - 70;\n            final float fillHeight = pageHeight - 70;\n\n            if (DEBUG.Enabled) {\n                System.out.println(\"\\n---------------------------------\");\n                System.out.println(\"PDF DOCUMENT: pageSize \" + document.getPageSize());\n                System.out.println(\"fillWidth=\" + fillWidth + \" fillHeight=\" + fillHeight);\n            }\n            \n\n            for (LWPathway.Entry entry : VUE.getActivePathway().getEntries()) {\n\n                if (DEBUG.Enabled) System.out.println(\"\\nHANDLING ENTRY \" + entry);\n                final LWSlide slide = entry.produceSlide();\n                final LWComponent toDraw = (slide == null ? entry.node : slide);\n                \n                final PdfTemplate template = PdfTemplate.createTemplate(writer, fillWidth, fillHeight);\n                final PdfGraphics2D graphics = (PdfGraphics2D) template.createGraphics(fillWidth, fillHeight, new DefaultFontMapper(), false, 60.0f);\n                final DrawContext dc = new DrawContext(graphics, 1.0);\n                //final DrawContext dc = new DrawContext(graphics, scale);\n                //final DrawContext dc = new DrawContext(graphics, toDraw);\n                dc.setClipOptimized(false);\n                dc.setInteractive(false);\n                \n                if (DEBUG.Enabled) {\n                    System.out.println(\"  DRAWING INTO \" + dc + \" g=\" + graphics + \" clip=\" + tufts.Util.fmt(graphics.getClip()));\n                    if (DEBUG.PDF) {\n                        dc.g.setColor(Color.green);\n                        dc.g.fillRect(-Short.MAX_VALUE/2, -Short.MAX_VALUE/2, Short.MAX_VALUE, Short.MAX_VALUE);\n                    }\n                }\n\n                toDraw.drawFit(dc, 0);\n                if (DEBUG.PDF) {\n                    final String dcDesc = dc.toString() + String.format(\" scale=%.1f%%\", dc.g.getTransform().getScaleX() * 100);\n                    dc.setRawDrawing();\n                    dc.g.setColor(Color.red);\n                    dc.g.setFont(VueConstants.FixedSmallFont);\n                    dc.g.drawString(dcDesc, 10, fillHeight - 27);\n                    dc.g.drawString(entry.toString(), 10, fillHeight - 16);\n                    dc.g.drawString(toDraw.toString(), 10, fillHeight - 5);\n                }\n                \n                // the graphics dispose appears to be very important -- we've seen completely intermittant\n                // problems with generating many page PDF documents, which would be well explained by\n                // java or internal itext buffers running out of memory.\n                graphics.dispose();\n\n                document.add(Image.getInstance(template));\n                document.newPage();\n            }\n        }\n        catch(DocumentException de) {\n            System.err.println(de.getMessage());\n        }\n        catch(IOException ioe) {\n            System.err.println(ioe.getMessage());\n        }\n        finally\n        {\n        \t   GUI.clearWaitCursor();\n        }\n        \n        // step 5: we close the document\n        document.close();\n    }","commit_id":"b7bc72589251996f5feecd5c9d7d223c67d84c5f","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n\t * Create a message from a SimpleFieldSet, and the message's name, if possible. \n\t */\n\tpublic static FCPMessage create(String name, SimpleFieldSet fs, BucketFactory bfTemp, PersistentTempBucketFactory bfPersistent) throws MessageInvalidException {\n\t\tif(name.equals(AddPeer.NAME))\n\t\t\treturn new AddPeer(fs);\n\t\tif(name.equals(ClientGetMessage.NAME))\n\t\t\treturn new ClientGetMessage(fs);\n\t\tif(name.equals(ClientHelloMessage.NAME))\n\t\t\treturn new ClientHelloMessage(fs);\n\t\tif(name.equals(ClientPutComplexDirMessage.NAME))\n\t\t\treturn new ClientPutComplexDirMessage(fs, bfTemp, bfPersistent);\n\t\tif(name.equals(ClientPutDiskDirMessage.NAME))\n\t\t\treturn new ClientPutDiskDirMessage(fs);\n\t\tif(name.equals(ClientPutMessage.NAME))\n\t\t\treturn new ClientPutMessage(fs);\n\t\tif(name.equals(SendBookmarkFeedMessage.NAME))\n\t\t\treturn new SendBookmarkFeedMessage(fs);\n\t\tif(name.equals(SendDownloadFeedMessage.NAME))\n\t\t\treturn new SendDownloadFeedMessage(fs);\n\t\tif(name.equals(SendTextFeedMessage.NAME))\n\t\t\treturn new SendTextFeedMessage(fs);\n\t\tif(name.equals(FCPPluginMessage.NAME))\n\t\t\treturn new FCPPluginMessage(fs);\n\t\tif(name.equals(GenerateSSKMessage.NAME))\n\t\t\treturn new GenerateSSKMessage(fs);\n\t\tif(name.equals(GetConfig.NAME))\n\t\t\treturn new GetConfig(fs);\n\t\tif(name.equals(GetNode.NAME))\n\t\t\treturn new GetNode(fs);\n\t\tif(name.equals(GetPluginInfo.NAME))\n\t\t\treturn new GetPluginInfo(fs);\n\t\tif(name.equals(GetRequestStatusMessage.NAME))\n\t\t\treturn new GetRequestStatusMessage(fs);\n\t\tif(name.equals(ListPeerMessage.NAME))\n\t\t\treturn new ListPeerMessage(fs);\n\t\tif(name.equals(ListPeersMessage.NAME))\n\t\t\treturn new ListPeersMessage(fs);\n\t\tif(name.equals(ListPeerNotesMessage.NAME))\n\t\t\treturn new ListPeerNotesMessage(fs);\n\t\tif(name.equals(ListPersistentRequestsMessage.NAME))\n\t\t\treturn new ListPersistentRequestsMessage(fs);\n\t\tif(name.equals(ModifyConfig.NAME))\n\t\t\treturn new ModifyConfig(fs);\n\t\tif(name.equals(ModifyPeer.NAME))\n\t\t\treturn new ModifyPeer(fs);\n\t\tif(name.equals(ModifyPeerNote.NAME))\n\t\t\treturn new ModifyPeerNote(fs);\n\t\tif(name.equals(ModifyPersistentRequest.NAME))\n\t\t\treturn new ModifyPersistentRequest(fs);\n\t\tif(name.equals(RemovePeer.NAME))\n\t\t\treturn new RemovePeer(fs);\n\t\tif(name.equals(RemovePersistentRequest.NAME)\n\t\t\t\t|| name.equals(RemovePersistentRequest.ALT_NAME))\n\t\t\treturn new RemovePersistentRequest(fs);\n\t\tif(name.equals(ShutdownMessage.NAME))\n\t\t\treturn new ShutdownMessage();\n\t\tif(name.equals(SubscribeFeedsMessage.NAME))\n\t\t\treturn new SubscribeFeedsMessage(fs);\n\t\tif(name.equals(SubscribeUSKMessage.NAME))\n\t\t\treturn new SubscribeUSKMessage(fs);\n\t\tif(name.equals(UnsubscribeFeedMessages.NAME))\n\t\t\treturn new UnsubscribeFeedMessages(fs);\n\t\tif(name.equals(UnsubscribeUSKMessage.NAME))\n\t\t\treturn new UnsubscribeUSKMessage(fs);\n\t\tif(name.equals(TestDDARequestMessage.NAME))\n\t\t\treturn new TestDDARequestMessage(fs);\n\t\tif(name.equals(TestDDAResponseMessage.NAME))\n\t\t\treturn new TestDDAResponseMessage(fs);\n\t\tif(name.equals(WatchGlobal.NAME))\n\t\t\treturn new WatchGlobal(fs);\n\t\tif(name.equals(\"Void\"))\n\t\t\treturn null;\n\n\t\tthrow new MessageInvalidException(ProtocolErrorMessage.INVALID_MESSAGE, \"Unknown message name \"+name, null, false);\n\t}","id":23581,"modified_method":"/**\n\t * Create a message from a SimpleFieldSet, and the message's name, if possible. \n\t */\n\tpublic static FCPMessage create(String name, SimpleFieldSet fs, BucketFactory bfTemp, PersistentTempBucketFactory bfPersistent) throws MessageInvalidException {\n\t\tif(name.equals(AddPeer.NAME))\n\t\t\treturn new AddPeer(fs);\n\t\tif(name.equals(ClientGetMessage.NAME))\n\t\t\treturn new ClientGetMessage(fs);\n\t\tif(name.equals(ClientHelloMessage.NAME))\n\t\t\treturn new ClientHelloMessage(fs);\n\t\tif(name.equals(ClientPutComplexDirMessage.NAME))\n\t\t\treturn new ClientPutComplexDirMessage(fs, bfTemp, bfPersistent);\n\t\tif(name.equals(ClientPutDiskDirMessage.NAME))\n\t\t\treturn new ClientPutDiskDirMessage(fs);\n\t\tif(name.equals(ClientPutMessage.NAME))\n\t\t\treturn new ClientPutMessage(fs);\n\t\tif(name.equals(SendBookmarkFeedMessage.NAME))\n\t\t\treturn new SendBookmarkFeedMessage(fs);\n\t\tif(name.equals(SendDownloadFeedMessage.NAME))\n\t\t\treturn new SendDownloadFeedMessage(fs);\n\t\tif(name.equals(SendTextFeedMessage.NAME))\n\t\t\treturn new SendTextFeedMessage(fs);\n\t\tif(name.equals(FCPPluginMessage.NAME))\n\t\t\treturn new FCPPluginMessage(fs);\n\t\tif(name.equals(GenerateSSKMessage.NAME))\n\t\t\treturn new GenerateSSKMessage(fs);\n\t\tif(name.equals(GetConfig.NAME))\n\t\t\treturn new GetConfig(fs);\n\t\tif(name.equals(GetNode.NAME))\n\t\t\treturn new GetNode(fs);\n\t\tif(name.equals(GetPluginInfo.NAME))\n\t\t\treturn new GetPluginInfo(fs);\n\t\tif(name.equals(GetRequestStatusMessage.NAME))\n\t\t\treturn new GetRequestStatusMessage(fs);\n\t\tif(name.equals(ListPeerMessage.NAME))\n\t\t\treturn new ListPeerMessage(fs);\n\t\tif(name.equals(ListPeersMessage.NAME))\n\t\t\treturn new ListPeersMessage(fs);\n\t\tif(name.equals(ListPeerNotesMessage.NAME))\n\t\t\treturn new ListPeerNotesMessage(fs);\n\t\tif(name.equals(ListPersistentRequestsMessage.NAME))\n\t\t\treturn new ListPersistentRequestsMessage(fs);\n\t\tif(name.equals(LoadPlugin.NAME))\n\t\t\treturn new LoadPlugin(fs);\n\t\tif(name.equals(ModifyConfig.NAME))\n\t\t\treturn new ModifyConfig(fs);\n\t\tif(name.equals(ModifyPeer.NAME))\n\t\t\treturn new ModifyPeer(fs);\n\t\tif(name.equals(ModifyPeerNote.NAME))\n\t\t\treturn new ModifyPeerNote(fs);\n\t\tif(name.equals(ModifyPersistentRequest.NAME))\n\t\t\treturn new ModifyPersistentRequest(fs);\n\t\tif(name.equals(ReloadPlugin.NAME))\n\t\t\treturn new ReloadPlugin(fs);\n\t\tif(name.equals(RemovePeer.NAME))\n\t\t\treturn new RemovePeer(fs);\n\t\tif(name.equals(RemovePersistentRequest.NAME)\n\t\t\t\t|| name.equals(RemovePersistentRequest.ALT_NAME))\n\t\t\treturn new RemovePersistentRequest(fs);\n\t\tif(name.equals(RemovePlugin.NAME))\n\t\t\treturn new RemovePlugin(fs);\n\t\tif(name.equals(ShutdownMessage.NAME))\n\t\t\treturn new ShutdownMessage();\n\t\tif(name.equals(SubscribeFeedsMessage.NAME))\n\t\t\treturn new SubscribeFeedsMessage(fs);\n\t\tif(name.equals(SubscribeUSKMessage.NAME))\n\t\t\treturn new SubscribeUSKMessage(fs);\n\t\tif(name.equals(UnsubscribeFeedMessages.NAME))\n\t\t\treturn new UnsubscribeFeedMessages(fs);\n\t\tif(name.equals(UnsubscribeUSKMessage.NAME))\n\t\t\treturn new UnsubscribeUSKMessage(fs);\n\t\tif(name.equals(TestDDARequestMessage.NAME))\n\t\t\treturn new TestDDARequestMessage(fs);\n\t\tif(name.equals(TestDDAResponseMessage.NAME))\n\t\t\treturn new TestDDAResponseMessage(fs);\n\t\tif(name.equals(WatchGlobal.NAME))\n\t\t\treturn new WatchGlobal(fs);\n\t\tif(name.equals(\"Void\"))\n\t\t\treturn null;\n\n\t\tthrow new MessageInvalidException(ProtocolErrorMessage.INVALID_MESSAGE, \"Unknown message name \"+name, null, false);\n\t}","commit_id":"acd49fa6248d4b2d834a45a67d6564dc26efdadc","url":"https://github.com/freenet/fred"},{"original_method":"public void startPluginFile(final String filename, boolean store) {\n\t\trealStartPlugin(new PluginDownLoaderFile(), filename, store);\n\t}","id":23582,"modified_method":"public PluginInfoWrapper startPluginFile(final String filename, boolean store) {\n\t\treturn realStartPlugin(new PluginDownLoaderFile(), filename, store);\n\t}","commit_id":"acd49fa6248d4b2d834a45a67d6564dc26efdadc","url":"https://github.com/freenet/fred"},{"original_method":"public void startPluginFreenet(final String filename, boolean store) {\n\t\trealStartPlugin(new PluginDownLoaderFreenet(client), filename, store);\n\t}","id":23583,"modified_method":"public PluginInfoWrapper startPluginFreenet(final String filename, boolean store) {\n\t\treturn realStartPlugin(new PluginDownLoaderFreenet(client), filename, store);\n\t}","commit_id":"acd49fa6248d4b2d834a45a67d6564dc26efdadc","url":"https://github.com/freenet/fred"},{"original_method":"public void startPluginURL(final String filename, boolean store) {\n\t\trealStartPlugin(new PluginDownLoaderURL(), filename, store);\n\t}","id":23584,"modified_method":"public PluginInfoWrapper startPluginURL(final String filename, boolean store) {\n\t\treturn realStartPlugin(new PluginDownLoaderURL(), filename, store);\n\t}","commit_id":"acd49fa6248d4b2d834a45a67d6564dc26efdadc","url":"https://github.com/freenet/fred"},{"original_method":"public void startPluginOfficial(final String pluginname, boolean store) {\n\t\trealStartPlugin(new PluginDownLoaderOfficial(), pluginname, store);\n\t}","id":23585,"modified_method":"public PluginInfoWrapper startPluginOfficial(final String pluginname, boolean store) {\n\t\treturn realStartPlugin(new PluginDownLoaderOfficial(), pluginname, store);\n\t}","commit_id":"acd49fa6248d4b2d834a45a67d6564dc26efdadc","url":"https://github.com/freenet/fred"},{"original_method":"public void startPluginAuto(final String pluginname, boolean store) {\n\n\t\tif(isOfficialPlugin(pluginname)) {\n\t\t\tstartPluginOfficial(pluginname, store);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tnew FreenetURI(pluginname); // test for MalformedURLException \n\t\t\tstartPluginFreenet(pluginname, store);\n\t\t\treturn;\n\t\t} catch(MalformedURLException e) {\n\t\t\t// not a freenet key\n\t\t}\n\n\t\tFile[] roots = File.listRoots();\n\t\tfor(File f : roots) {\n\t\t\tif(pluginname.startsWith(f.getName()) && new File(pluginname).exists()) {\n\t\t\t\tstartPluginFile(pluginname, store);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tstartPluginURL(pluginname, store);\n\t}","id":23586,"modified_method":"public PluginInfoWrapper startPluginAuto(final String pluginname, boolean store) {\n\n\t\tif(isOfficialPlugin(pluginname)) {\n\t\t\treturn startPluginOfficial(pluginname, store);\n\t\t}\n\n\t\ttry {\n\t\t\tnew FreenetURI(pluginname); // test for MalformedURLException \n\t\t\treturn startPluginFreenet(pluginname, store);\n\t\t} catch(MalformedURLException e) {\n\t\t\t// not a freenet key\n\t\t}\n\n\t\tFile[] roots = File.listRoots();\n\t\tfor(File f : roots) {\n\t\t\tif(pluginname.startsWith(f.getName()) && new File(pluginname).exists()) {\n\t\t\t\treturn startPluginFile(pluginname, store);\n\t\t\t}\n\t\t}\n\n\t\treturn startPluginURL(pluginname, store);\n\t}","commit_id":"acd49fa6248d4b2d834a45a67d6564dc26efdadc","url":"https://github.com/freenet/fred"},{"original_method":"private void realStartPlugin(final PluginDownLoader<?> pdl, final String filename, final boolean store) {\n\t\tif(filename.trim().length() == 0)\n\t\t\treturn;\n\t\tfinal PluginProgress pluginProgress = new PluginProgress(filename);\n\t\tsynchronized(startingPlugins) {\n\t\t\tstartingPlugins.add(pluginProgress);\n\t\t}\n\t\t\t\tLogger.normal(this, \"Loading plugin: \" + filename);\n\t\t\t\tFredPlugin plug;\n\t\t\t\ttry {\n\t\t\t\t\tplug = loadPlugin(pdl, filename);\n\t\t\t\t\tif(plug == null) return; // Already loaded\n\t\t\t\t\tpluginProgress.setProgress(PluginProgress.STARTING);\n\t\t\t\t\tPluginInfoWrapper pi = PluginHandler.startPlugin(PluginManager.this, filename, plug, new PluginRespirator(node, PluginManager.this, plug));\n\t\t\t\t\tsynchronized(pluginWrappers) {\n\t\t\t\t\t\tpluginWrappers.add(pi);\n\t\t\t\t\t\tpluginsFailedLoad.remove(filename);\n\t\t\t\t\t}\n\t\t\t\t\tLogger.normal(this, \"Plugin loaded: \" + filename);\n\t\t\t\t} catch(PluginNotFoundException e) {\n\t\t\t\t\tLogger.normal(this, \"Loading plugin failed (\" + filename + ')', e);\n\t\t\t\t\tString message = e.getMessage();\n\t\t\t\t\tsynchronized(pluginWrappers) {\n\t\t\t\t\t\tpluginsFailedLoad.add(filename);\n\t\t\t\t\t}\n\t\t\t\t\tcore.alerts.register(new PluginLoadFailedUserAlert(filename, pdl instanceof PluginDownLoaderOfficial, e));\n\t\t\t\t} catch(UnsupportedClassVersionError e) {\n\t\t\t\t\tLogger.error(this, \"Could not load plugin \" + filename + \" : \" + e, e);\n\t\t\t\t\tSystem.err.println(\"Could not load plugin \" + filename + \" : \" + e);\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tSystem.err.println(\"Plugin \" + filename + \" appears to require a later JVM\");\n\t\t\t\t\tLogger.error(this, \"Plugin \" + filename + \" appears to require a later JVM\");\n\t\t\t\t\tsynchronized(pluginWrappers) {\n\t\t\t\t\t\tpluginsFailedLoad.add(filename);\n\t\t\t\t\t}\n\t\t\t\t\tcore.alerts.register(new PluginLoadFailedUserAlert(filename, pdl instanceof PluginDownLoaderOfficial, l10n(\"pluginReqNewerJVMTitle\", \"name\", filename)));\n\t\t\t\t} catch(Throwable e) {\n\t\t\t\t\tLogger.error(this, \"Could not load plugin \" + filename + \" : \" + e, e);\n\t\t\t\t\tSystem.err.println(\"Could not load plugin \" + filename + \" : \" + e);\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tSystem.err.println(\"Plugin \" + filename + \" is broken, but we want to retry after next startup\");\n\t\t\t\t\tLogger.error(this, \"Plugin \" + filename + \" is broken, but we want to retry after next startup\");\n\t\t\t\t\tsynchronized(pluginWrappers) {\n\t\t\t\t\t\tpluginsFailedLoad.add(filename);\n\t\t\t\t\t}\n\t\t\t\t\tcore.alerts.register(new PluginLoadFailedUserAlert(filename, pdl instanceof PluginDownLoaderOfficial, e));\n\t\t\t\t} finally {\n\t\t\t\t\tsynchronized(startingPlugins) {\n\t\t\t\t\t\tstartingPlugins.remove(pluginProgress);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* try not to destroy the config. */\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tif(store)\n\t\t\t\t\t\tcore.storeConfig();\n\t\t\t\t}\n\t}","id":23587,"modified_method":"private PluginInfoWrapper realStartPlugin(final PluginDownLoader<?> pdl, final String filename, final boolean store) {\n\t\tif(filename.trim().length() == 0)\n\t\t\treturn null;\n\t\tfinal PluginProgress pluginProgress = new PluginProgress(filename);\n\t\tsynchronized(startingPlugins) {\n\t\t\tstartingPlugins.add(pluginProgress);\n\t\t}\n\t\tLogger.normal(this, \"Loading plugin: \" + filename);\n\t\tFredPlugin plug;\n\t\tPluginInfoWrapper pi = null;\n\t\ttry {\n\t\t\tplug = loadPlugin(pdl, filename);\n\t\t\tif (plug == null)\n\t\t\t\treturn null; // Already loaded\n\t\t\tpluginProgress.setProgress(PluginProgress.STARTING);\n\t\t\tpi = PluginHandler.startPlugin(PluginManager.this, filename, plug, new PluginRespirator(node, PluginManager.this, plug));\n\t\t\tsynchronized (pluginWrappers) {\n\t\t\t\tpluginWrappers.add(pi);\n\t\t\t\tpluginsFailedLoad.remove(filename);\n\t\t\t}\n\t\t\tLogger.normal(this, \"Plugin loaded: \" + filename);\n\t\t} catch (PluginNotFoundException e) {\n\t\t\tLogger.normal(this, \"Loading plugin failed (\" + filename + ')', e);\n\t\t\tString message = e.getMessage();\n\t\t\tsynchronized (pluginWrappers) {\n\t\t\t\tpluginsFailedLoad.add(filename);\n\t\t\t}\n\t\t\tcore.alerts.register(new PluginLoadFailedUserAlert(filename,\n\t\t\t\t\tpdl instanceof PluginDownLoaderOfficial, e));\n\t\t} catch (UnsupportedClassVersionError e) {\n\t\t\tLogger.error(this, \"Could not load plugin \" + filename + \" : \" + e,\n\t\t\t\t\te);\n\t\t\tSystem.err.println(\"Could not load plugin \" + filename + \" : \" + e);\n\t\t\te.printStackTrace();\n\t\t\tSystem.err.println(\"Plugin \" + filename + \" appears to require a later JVM\");\n\t\t\tLogger.error(this, \"Plugin \" + filename + \" appears to require a later JVM\");\n\t\t\tsynchronized (pluginWrappers) {\n\t\t\t\tpluginsFailedLoad.add(filename);\n\t\t\t}\n\t\t\tcore.alerts.register(new PluginLoadFailedUserAlert(filename, pdl instanceof PluginDownLoaderOfficial, l10n(\"pluginReqNewerJVMTitle\", \"name\", filename)));\n\t\t} catch (Throwable e) {\n\t\t\tLogger.error(this, \"Could not load plugin \" + filename + \" : \" + e, e);\n\t\t\tSystem.err.println(\"Could not load plugin \" + filename + \" : \" + e);\n\t\t\te.printStackTrace();\n\t\t\tSystem.err.println(\"Plugin \"+filename+\" is broken, but we want to retry after next startup\");\n\t\t\tLogger.error(this, \"Plugin \"+filename+\" is broken, but we want to retry after next startup\");\n\t\t\tsynchronized (pluginWrappers) {\n\t\t\t\tpluginsFailedLoad.add(filename);\n\t\t\t}\n\t\t\tcore.alerts.register(new PluginLoadFailedUserAlert(filename, pdl instanceof PluginDownLoaderOfficial, e));\n\t\t} finally {\n\t\t\tsynchronized (startingPlugins) {\n\t\t\t\tstartingPlugins.remove(pluginProgress);\n\t\t\t}\n\t\t}\n\t\t/* try not to destroy the config. */\n\t\tsynchronized(this) {\n\t\t\tif (store)\n\t\t\t\tcore.storeConfig();\n\t\t}\n\t\treturn pi;\n\t}","commit_id":"acd49fa6248d4b2d834a45a67d6564dc26efdadc","url":"https://github.com/freenet/fred"},{"original_method":"/**\r\n     * Determines if the specified node denotes a power tower/pole.\r\n     * @param w The node to be tested\r\n     * @return True if power key is set and equal to tower/pole\r\n     */\r\n    protected static final boolean isPowerTower(Node n) {\r\n        String v = n.get(\"power\");\r\n        return v != null && (v.equals(\"tower\") || v.equals(\"pole\"));\r\n    }","id":23588,"modified_method":"/**\r\n     * Determines if the specified node denotes a power tower/pole.\r\n     * @param w The node to be tested\r\n     * @return True if power key is set and equal to tower/pole\r\n     */\r\n    protected static final boolean isPowerTower(Node n) {\r\n        return isPowerIn(n, POWER_TOWER_TAGS);\r\n    }","commit_id":"953298ecf88d8f1afce2a405b008ff2e65250a41","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\r\n    public void visit(Way w) {\r\n        if (w.isUsable() && isPowerLine(w)) {\r\n            String fixValue = null;\r\n            boolean erroneous = false;\r\n            boolean canFix = false;\r\n            for (Node n : w.getNodes()) {\r\n                if (!isPowerTower(n)) {\r\n                    errors.add(new PowerLineError(n, w));\r\n                    erroneous = true;\r\n                } else if (fixValue == null) {\r\n                    // First tower/pole tag found, remember it\r\n                    fixValue = n.get(\"power\");\r\n                    canFix = true;\r\n                } else if (!fixValue.equals(n.get(\"power\"))) {\r\n                    // The power line contains both \"tower\" and \"pole\" -> cannot fix this error\r\n                    canFix = false;\r\n                }\r\n            }\r\n            if (erroneous && canFix) {\r\n                towerPoleTagMap.put(w, fixValue);\r\n            }\r\n        }\r\n    }","id":23589,"modified_method":"@Override\r\n    public void visit(Way w) {\r\n        if (w.isUsable()) {\r\n            if (isPowerLine(w)) {\r\n                String fixValue = null;\r\n                boolean erroneous = false;\r\n                boolean canFix = false;\r\n                for (Node n : w.getNodes()) {\r\n                    if (!isPowerTower(n)) {\r\n                        if (!w.isFirstLastNode(n) && !isPowerAllowed(n)) {\r\n                            potentialErrors.add(new PowerLineError(n, w));\r\n                            erroneous = true;\r\n                        }\r\n                    } else if (fixValue == null) {\r\n                        // First tower/pole tag found, remember it\r\n                        fixValue = n.get(\"power\");\r\n                        canFix = true;\r\n                    } else if (!fixValue.equals(n.get(\"power\"))) {\r\n                        // The power line contains both \"tower\" and \"pole\" -> cannot fix this error\r\n                        canFix = false;\r\n                    }\r\n                }\r\n                if (erroneous && canFix) {\r\n                    towerPoleTagMap.put(w, fixValue);\r\n                }\r\n            } else if (w.isClosed() && isPowerStation(w)) {\r\n                powerStations.add(w);\r\n            }\r\n        }\r\n    }","commit_id":"953298ecf88d8f1afce2a405b008ff2e65250a41","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\r\n     * Determines if the specified way denotes a power line.\r\n     * @param w The way to be tested\r\n     * @return True if power key is set and equal to line/minor_line\r\n     */\r\n    protected static final boolean isPowerLine(Way w) {\r\n        String v = w.get(\"power\");\r\n        return v != null && (v.equals(\"line\") || v.equals(\"minor_line\"));\r\n    }","id":23590,"modified_method":"/**\r\n     * Determines if the specified way denotes a power line.\r\n     * @param w The way to be tested\r\n     * @return True if power key is set and equal to line/minor_line\r\n     */\r\n    protected static final boolean isPowerLine(Way w) {\r\n        return isPowerIn(w, POWER_LINE_TAGS);\r\n    }","commit_id":"953298ecf88d8f1afce2a405b008ff2e65250a41","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\r\n    public void visit(Way w) {\r\n        if (w.isUsable() && w.hasKey(\"highway\") && w.hasKey(\"junction\") && w.get(\"junction\").equals(\"roundabout\")) {\r\n            testWrongRoundabout(w);\r\n        }\r\n    }","id":23591,"modified_method":"@Override\r\n    public void visit(Way w) {\r\n        if (w.isUsable()) {\r\n            if (w.hasKey(\"highway\") && w.hasKey(\"junction\") && w.get(\"junction\").equals(\"roundabout\")) {\r\n                testWrongRoundabout(w);\r\n            }\r\n            if (w.hasKey(\"source:maxspeed\")) {\r\n                // Check maxspeed, including context against highway\r\n                testSourceMaxspeed(w, true);\r\n            }\r\n        }\r\n    }","commit_id":"9c867c120bf6eb1092d81d44caa8948340a72ba0","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\r\n    public void visit(Node n) {\r\n        if (n.isUsable() && !n.hasTag(\"highway\", \"crossing\") && !n.hasTag(\"crossing\", \"no\") && n.isReferredByWays(2)) {\r\n            testMissingPedestrianCrossing(n);\r\n        }\r\n    }","id":23592,"modified_method":"@Override\r\n    public void visit(Node n) {\r\n        if (n.isUsable()) {\r\n            if (!n.hasTag(\"highway\", \"crossing\") && !n.hasTag(\"crossing\", \"no\") && n.isReferredByWays(2)) {\r\n                testMissingPedestrianCrossing(n);\r\n            }\r\n            if (n.hasKey(\"source:maxspeed\")) {\r\n                // Check maxspeed but not context against highway for nodes as maxspeed is not set on highways here but on signs, speed cameras, etc.\r\n                testSourceMaxspeed(n, false);\r\n            }\r\n        }\r\n    }","commit_id":"9c867c120bf6eb1092d81d44caa8948340a72ba0","url":"https://github.com/openstreetmap/josm"},{"original_method":"private List<String> getTestSpecs() {\n    List<String> specs = new ArrayList<String>();\n\n    switch (myConfig.getTestType()) {\n      case TEST_SCRIPT:\n        specs.add(myConfig.getScriptName());\n        break;\n      case TEST_CLASS:\n        specs.add(myConfig.getScriptName() + \"::\" + myConfig.getClassName());\n        break;\n      case TEST_METHOD:\n        specs.add(myConfig.getScriptName() + \"::\" + myConfig.getClassName() + \"::\" + myConfig.getMethodName());\n        break;\n      case TEST_FOLDER:\n\t      if (!myConfig.getPattern().isEmpty())\n          specs.add(myConfig.getFolderName() + \"/\" + \";\" + myConfig.getPattern() + \"$\");\n        else\n\t        specs.add(myConfig.getFolderName() + \"/\");\n\t      // TODO[kate]:think about delimiter between folderName and Pattern\n        break;\n      default:\n        throw new IllegalArgumentException(\"Unknown test type: \" + myConfig.getTestType());\n    }\n\n    return specs;\n  }","id":23593,"modified_method":"private List<String> getTestSpecs() {\n    List<String> specs = new ArrayList<String>();\n\n    switch (myConfig.getTestType()) {\n      case TEST_SCRIPT:\n        specs.add(myConfig.getScriptName());\n        break;\n      case TEST_CLASS:\n        specs.add(myConfig.getScriptName() + \"::\" + myConfig.getClassName());\n        break;\n      case TEST_METHOD:\n        specs.add(myConfig.getScriptName() + \"::\" + myConfig.getClassName() + \"::\" + myConfig.getMethodName());\n        break;\n      case TEST_FOLDER:\n\t    if (!myConfig.getPattern().isEmpty())\n          specs.add(myConfig.getFolderName() + \"/\" + \";\" + myConfig.getPattern() + \"$\");\n        else\n\t      specs.add(myConfig.getFolderName() + \"/\");\n\t      // TODO[kate]:think about delimiter between folderName and Pattern\n        break;\n      case TEST_FUNCTION:\n        specs.add(myConfig.getScriptName() + \"::::\" + myConfig.getMethodName());\n        break;\n      default:\n        throw new IllegalArgumentException(\"Unknown test type: \" + myConfig.getTestType());\n    }\n\n    return specs;\n  }","commit_id":"87b41b99a14523c133ed1852d15068e162a12d7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private RunnerAndConfigurationSettings createConfigurationFromFile(Location location, PsiElement element) {\n    PsiElement file = element.getContainingFile();\n    if (file == null || !(file instanceof PyFile)) return null;\n\n    final PyFile pyFile = (PyFile)file;\n    final List<PyClass> testCases = PythonUnitTestUtil.getTestCaseClassesFromFile(pyFile);\n    if (testCases.isEmpty()) return null;\n\n    final RunnerAndConfigurationSettings settings = makeConfigurationSettings(location, \"tests from file\");\n    final PythonUnitTestRunConfiguration configuration = (PythonUnitTestRunConfiguration)settings.getConfiguration();\n\n    configuration.setTestType(PythonUnitTestRunConfiguration.TestType.TEST_SCRIPT);\n    if (!setupConfigurationScript(configuration, pyFile)) return null;\n\n    configuration.setName(configuration.suggestedName());\n    myPsiElement = pyFile;\n    return settings;\n  }","id":23594,"modified_method":"@Nullable\n  private RunnerAndConfigurationSettings createConfigurationFromFile(Location location, PsiElement element) {\n    PsiElement file = element.getContainingFile();\n    if (file == null || !(file instanceof PyFile)) return null;\n\n    final PyFile pyFile = (PyFile)file;\n    final List<PyStatement> testCases = PythonUnitTestUtil.getTestCaseClassesFromFile(pyFile);\n    if (testCases.isEmpty()) return null;\n\n    final RunnerAndConfigurationSettings settings = makeConfigurationSettings(location, \"tests from file\");\n    final PythonUnitTestRunConfiguration configuration = (PythonUnitTestRunConfiguration)settings.getConfiguration();\n\n    configuration.setTestType(PythonUnitTestRunConfiguration.TestType.TEST_SCRIPT);\n    if (!setupConfigurationScript(configuration, pyFile)) return null;\n\n    configuration.setName(configuration.suggestedName());\n    myPsiElement = pyFile;\n    return settings;\n  }","commit_id":"87b41b99a14523c133ed1852d15068e162a12d7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private RunnerAndConfigurationSettings createConfigurationFromFunction(Location location, PyElement element) {\n    PyFunction pyFunction = PsiTreeUtil.getParentOfType(element, PyFunction.class, false);\n    if (pyFunction == null || !PythonUnitTestUtil.isTestCaseFunction(pyFunction)) return null;\n\n    final PyClass containingClass = pyFunction.getContainingClass();\n    if (containingClass == null) return null;\n\n    final RunnerAndConfigurationSettings settings = makeConfigurationSettings(location, \"tests from function\");\n    final PythonUnitTestRunConfiguration configuration = (PythonUnitTestRunConfiguration)settings.getConfiguration();\n\n    configuration.setTestType(PythonUnitTestRunConfiguration.TestType.TEST_METHOD);\n    configuration.setMethodName(pyFunction.getName());\n    configuration.setClassName(containingClass.getName());\n    if (!setupConfigurationScript(configuration, pyFunction)) return null;\n\n    configuration.setName(configuration.suggestedName());\n    myPsiElement = pyFunction;\n    return settings;\n  }","id":23595,"modified_method":"@Nullable\n  private RunnerAndConfigurationSettings createConfigurationFromFunction(Location location, PyElement element) {\n    PyFunction pyFunction = PsiTreeUtil.getParentOfType(element, PyFunction.class, false);\n    if (pyFunction == null || !PythonUnitTestUtil.isTestCaseFunction(pyFunction)) return null;\n    final PyClass containingClass = pyFunction.getContainingClass();\n    final RunnerAndConfigurationSettings settings = makeConfigurationSettings(location, \"tests from function\");\n    final PythonUnitTestRunConfiguration configuration = (PythonUnitTestRunConfiguration)settings.getConfiguration();\n    configuration.setMethodName(pyFunction.getName());\n    if (containingClass != null) {\n      configuration.setClassName(containingClass.getName());\n      configuration.setTestType(PythonUnitTestRunConfiguration.TestType.TEST_METHOD);\n    }\n    else {\n      configuration.setTestType(PythonUnitTestRunConfiguration.TestType.TEST_FUNCTION);\n    }\n    if (!setupConfigurationScript(configuration, pyFunction)) return null;\n    configuration.setName(configuration.suggestedName());\n    myPsiElement = pyFunction;\n    return settings;\n  }","commit_id":"87b41b99a14523c133ed1852d15068e162a12d7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String suggestedName() {\n    switch (myTestType) {\n      case TEST_CLASS:\n        return \"Tests in \" + myClassName;\n      case TEST_METHOD:\n        return \"Test \" + myClassName + \".\" + myMethodName;\n      case TEST_SCRIPT:\n        return \"Tests in \" + myScriptName;\n      case TEST_FOLDER:\n        return \"Tests in \" + FileUtil.toSystemDependentName(myFolderName);\n      default:\n        throw new IllegalStateException(\"Unknown test type: \" + myTestType);\n    }\n  }","id":23596,"modified_method":"@Override\n  public String suggestedName() {\n    switch (myTestType) {\n      case TEST_CLASS:\n        return \"Tests in \" + myClassName;\n      case TEST_METHOD:\n        return \"Test \" + myClassName + \".\" + myMethodName;\n      case TEST_SCRIPT:\n        return \"Tests in \" + myScriptName;\n      case TEST_FOLDER:\n        return \"Tests in \" + FileUtil.toSystemDependentName(myFolderName);\n      case TEST_FUNCTION:\n        return \"Test \" + myMethodName;\n      default:\n        throw new IllegalStateException(\"Unknown test type: \" + myTestType);\n    }\n  }","commit_id":"87b41b99a14523c133ed1852d15068e162a12d7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TestType getTestType() {\n    if (myAllInFolderRB.isSelected()) {\n      return TestType.TEST_FOLDER;\n    }\n    else if (myTestScriptRB.isSelected()) {\n      return TestType.TEST_SCRIPT;\n    }\n    else if (myTestClassRB.isSelected()) {\n      return TestType.TEST_CLASS;\n    }\n    else {\n      return TestType.TEST_METHOD;\n    }\n  }","id":23597,"modified_method":"public TestType getTestType() {\n    if (myAllInFolderRB.isSelected()) {\n      return TestType.TEST_FOLDER;\n    }\n    else if (myTestScriptRB.isSelected()) {\n      return TestType.TEST_SCRIPT;\n    }\n    else if (myTestClassRB.isSelected()) {\n      return TestType.TEST_CLASS;\n    }\n    else if (myTestMethodRB.isSelected()) {\n      return TestType.TEST_METHOD;\n    }\n    else {\n      return TestType.TEST_FUNCTION;\n    }\n  }","commit_id":"87b41b99a14523c133ed1852d15068e162a12d7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setTestType(TestType testType) {\n    setSelectedIfNeeded(testType == TestType.TEST_FOLDER, myAllInFolderRB);\n    setSelectedIfNeeded(testType == TestType.TEST_SCRIPT, myTestScriptRB);\n    setSelectedIfNeeded(testType == TestType.TEST_CLASS, myTestClassRB);\n    setSelectedIfNeeded(testType == TestType.TEST_METHOD, myTestMethodRB);\n\n    myTestFolderComponent.setEnabled(testType == TestType.TEST_FOLDER);\n    myTestScriptComponent.setEnabled(testType != TestType.TEST_FOLDER);\n    myTestClassComponent.setEnabled(testType == TestType.TEST_CLASS || testType == TestType.TEST_METHOD);\n    myTestMethodComponent.setEnabled(testType == TestType.TEST_METHOD);\n    myPatternComponent.setEnabled(testType == TestType.TEST_FOLDER);\n  }","id":23598,"modified_method":"public void setTestType(TestType testType) {\n    setSelectedIfNeeded(testType == TestType.TEST_FOLDER, myAllInFolderRB);\n    setSelectedIfNeeded(testType == TestType.TEST_SCRIPT, myTestScriptRB);\n    setSelectedIfNeeded(testType == TestType.TEST_CLASS, myTestClassRB);\n    setSelectedIfNeeded(testType == TestType.TEST_METHOD, myTestMethodRB);\n    setSelectedIfNeeded(testType == TestType.TEST_FUNCTION, myTestFunctionRB);\n\n    myTestFolderComponent.setEnabled(testType == TestType.TEST_FOLDER);\n    myTestScriptComponent.setEnabled(testType != TestType.TEST_FOLDER);\n    myTestClassComponent.setEnabled(testType == TestType.TEST_CLASS || testType == TestType.TEST_METHOD);\n    myTestMethodComponent.setEnabled(testType == TestType.TEST_METHOD || testType == TestType.TEST_FUNCTION);\n    myPatternComponent.setEnabled(testType == TestType.TEST_FOLDER);\n  }","commit_id":"87b41b99a14523c133ed1852d15068e162a12d7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initComponents() {\n\n    final ActionListener testTypeListener = new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        setTestType(getTestType());\n      }\n    };\n\n    myAllInFolderRB.addActionListener(testTypeListener);\n    myTestScriptRB.addActionListener(testTypeListener);\n    myTestClassRB.addActionListener(testTypeListener);\n    myTestMethodRB.addActionListener(testTypeListener);\n  }","id":23599,"modified_method":"private void initComponents() {\n\n    final ActionListener testTypeListener = new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        setTestType(getTestType());\n      }\n    };\n\n    myAllInFolderRB.addActionListener(testTypeListener);\n    myTestScriptRB.addActionListener(testTypeListener);\n    myTestClassRB.addActionListener(testTypeListener);\n    myTestMethodRB.addActionListener(testTypeListener);\n    myTestFunctionRB.addActionListener(testTypeListener);\n  }","commit_id":"87b41b99a14523c133ed1852d15068e162a12d7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isTestCaseClass(@NotNull PyClass cls, Set<String> testQualifiedNames) {\n    for (PyClass ancestor : cls.iterateAncestors()) {\n      if (ancestor == null) continue;\n\n      String qName = ancestor.getQualifiedName();\n      if (testQualifiedNames.contains(qName)) {\n        return true;\n      }\n    }\n\n    return false;\n  }","id":23600,"modified_method":"public static boolean isTestCaseClass(@NotNull PyClass cls, Set<String> testQualifiedNames) {\n    for (PyClass ancestor : cls.iterateAncestors()) {\n      if (ancestor == null) continue;\n\n      String qName = ancestor.getQualifiedName();\n      if (testQualifiedNames.contains(qName)) {\n        return true;\n      }\n      String clsName = cls.getQualifiedName();\n      String[] names = clsName.split(\"\\\\.\");\n      clsName = names[names.length - 1];\n\n      if (TEST_MATCH_PATTERN.matcher(clsName).find()) {\n        return true;\n      }\n    }\n\n    return false;\n  }","commit_id":"87b41b99a14523c133ed1852d15068e162a12d7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isTestCaseFunction(PyFunction function, Set<String> testQualifiedNames) {\n    final String name = function.getName();\n    if (name == null || !name.startsWith(TESTCASE_METHOD_PREFIX)) {\n      return false;\n    }\n\n    final PyClass containingClass = function.getContainingClass();\n    if (containingClass == null || !isTestCaseClass(containingClass, testQualifiedNames)) {\n      return false;\n    }\n\n    return true;\n  }","id":23601,"modified_method":"public static boolean isTestCaseFunction(PyFunction function, Set<String> testQualifiedNames) {\n    final String name = function.getName();\n    if (name == null || !TEST_MATCH_PATTERN.matcher(name).find()) {\n      return false;\n    }\n    return true;\n  }","commit_id":"87b41b99a14523c133ed1852d15068e162a12d7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<PyClass> getTestCaseClassesFromFile(PyFile file, Set<String> testQualifiedNames) {\n    List<PyClass> result = Lists.newArrayList();\n    for (PyClass cls : file.getTopLevelClasses()) {\n      if (isTestCaseClass(cls, testQualifiedNames)) {\n        result.add(cls);\n      }\n    }\n    return result;\n  }","id":23602,"modified_method":"public static List<PyStatement> getTestCaseClassesFromFile(PyFile file, Set<String> testQualifiedNames) {\n    List<PyStatement> result = Lists.newArrayList();\n    for (PyClass cls : file.getTopLevelClasses()) {\n      if (isTestCaseClass(cls, testQualifiedNames)) {\n        result.add(cls);\n      }\n    }\n    for (PyFunction cls : file.getTopLevelFunctions()) {\n      if (isTestCaseFunction(cls, testQualifiedNames)) {\n        result.add(cls);\n      }\n    }\n    return result;\n  }","commit_id":"87b41b99a14523c133ed1852d15068e162a12d7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<PyClass> getTestCaseClassesFromFile(PyFile file) {\n    return getTestCaseClassesFromFile(file, PYTHON_TEST_QUALIFIED_CLASSES);\n  }","id":23603,"modified_method":"public static List<PyStatement> getTestCaseClassesFromFile(PyFile file) {\n    return getTestCaseClassesFromFile(file, PYTHON_TEST_QUALIFIED_CLASSES);\n  }","commit_id":"87b41b99a14523c133ed1852d15068e162a12d7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void onTestRegistered(BrowserInfo browser, TestCase testCase) {\n    synchronized (MONITOR) {\n      for (String testName : testCase.getTests()) {\n        File jsTestFile = resolveTestFile(testCase.getFileName());\n        TestPath testPath = myTestPathFactory.createTestPath(\n          browser,\n          jsTestFile,\n          testCase.getName(),\n          testName\n        );\n        myTreeManager.onTestRegistered(testPath);\n      }\n    }\n  }","id":23604,"modified_method":"@Override\n  public void onTestRegistered(BrowserInfo browser, TestCase testCase) {\n    synchronized (MONITOR) {\n      String testCaseName = myTestFileScope.getTestCaseName();\n      if (testCaseName != null && !testCaseName.equals(testCase.getName())) {\n        return;\n      }\n      String testMethodName = myTestFileScope.getTestMethodName();\n      for (String testName : testCase.getTests()) {\n        if (testMethodName != null && !testMethodName.equals(testName)) {\n          continue;\n        }\n        File jsTestFile = resolveTestFile(testCase.getFileName());\n        TestPath testPath = myTestPathFactory.createTestPath(\n          browser,\n          jsTestFile,\n          testCase.getName(),\n          testName\n        );\n        myTreeManager.onTestRegistered(testPath);\n      }\n    }\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public IdeaTestListener(\n    @NotNull TreeManager treeManager,\n    @NotNull File jstdConfigFile,\n    @NotNull File singleBasePath,\n    boolean dryRun\n  ) {\n    myTreeManager = treeManager;\n    myBasePath = singleBasePath;\n    myDryRun = dryRun;\n    myTestPathFactory = new TestPathFactory(jstdConfigFile);\n  }","id":23605,"modified_method":"public IdeaTestListener(@NotNull TreeManager treeManager,\n                          @NotNull File jstdConfigFile,\n                          @NotNull File singleBasePath,\n                          boolean dryRun,\n                          @NotNull TestFileScope testFileScope) {\n    myTreeManager = treeManager;\n    myBasePath = singleBasePath;\n    myDryRun = dryRun;\n    myTestFileScope = testFileScope;\n    myTestPathFactory = new TestPathFactory(jstdConfigFile);\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public Icon getIcon(@NotNull final PsiElement element, @Iconable.IconFlags final int flags) {\n    if (element instanceof JSFile && isTestFile((JSFile)element)) {\n      return JstdIcons.TEST_FILE;\n    }\n    return null;\n  }","id":23606,"modified_method":"@Override\n  public Icon getIcon(@NotNull final PsiElement element, @Iconable.IconFlags final int flags) {\n    if (element instanceof JSFile && isTestFile((JSFile)element)) {\n      return JstdIcons.TEST_FILE_ICON;\n    }\n    return null;\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public static <K> K getVerifiedHierarchyHead(PsiElement psiElement, Class<?>[] hierarchyClasses, Class<K> headHierarchyClass) {\n    for (Class<?> clazz : hierarchyClasses) {\n      if (!clazz.isInstance(psiElement)) {\n        return null;\n      }\n      psiElement = psiElement.getParent();\n    }\n    return CastUtils.tryCast(psiElement, headHierarchyClass);\n  }","id":23607,"modified_method":"public static <K> K getVerifiedHierarchyHead(PsiElement psiElement, Class<?>[] hierarchyClasses, Class<K> headHierarchyClass) {\n    for (Class<?> clazz : hierarchyClasses) {\n      if (!clazz.isInstance(psiElement)) {\n        return null;\n      }\n      psiElement = psiElement.getParent();\n    }\n    return ObjectUtils.tryCast(psiElement, headHierarchyClass);\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public static boolean isJstdConfigFile(@NotNull VirtualFile virtualFile) {\n    if (!virtualFile.isInLocalFileSystem()) {\n      return false;\n    }\n    FileType fileType = virtualFile.getFileType();\n    return fileType == JstdConfigFileType.INSTANCE;\n  }","id":23608,"modified_method":"public static boolean isJstdConfigFile(@NotNull VirtualFile virtualFile) {\n    FileType fileType = virtualFile.getFileType();\n    return fileType == JstdConfigFileType.INSTANCE;\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  protected RunnerAndConfigurationSettings createConfigurationByElement(Location location, ConfigurationContext context) {\n    long startTimeNano = System.nanoTime();\n    @SuppressWarnings({\"unchecked\"})\n    RunSettingsContext runSettingsContext = buildRunSettingsContext(location);\n    if (runSettingsContext == null) {\n      logDoneCreateConfigurationByElement(startTimeNano, \"1\");\n      return null;\n    }\n\n    final RunnerAndConfigurationSettings runnerSettings = cloneTemplateConfiguration(location.getProject(), context);\n    if (!(runnerSettings.getConfiguration() instanceof JstdRunConfiguration)) {\n      logDoneCreateConfigurationByElement(startTimeNano, \"2\");\n      return null;\n    }\n    JstdRunConfiguration runConfiguration = (JstdRunConfiguration) runnerSettings.getConfiguration();\n\n    runConfiguration.setRunSettings(runSettingsContext.runSettings);\n\n    mySourceElement = runSettingsContext.psiElement;\n    runnerSettings.setName(runConfiguration.suggestedName());\n    logDoneCreateConfigurationByElement(startTimeNano, \"3\");\n    return runnerSettings;\n  }","id":23609,"modified_method":"@Override\n  protected RunnerAndConfigurationSettings createConfigurationByElement(Location location, ConfigurationContext context) {\n    long startTimeNano = System.nanoTime();\n    @SuppressWarnings({\"unchecked\"})\n    RunSettingsContext runSettingsContext = buildRunSettingsContext(location);\n    if (runSettingsContext == null) {\n      logDoneCreateConfigurationByElement(startTimeNano, \"1\");\n      return null;\n    }\n\n    final RunnerAndConfigurationSettings runnerSettings = cloneTemplateConfiguration(location.getProject(), context);\n    if (!(runnerSettings.getConfiguration() instanceof JstdRunConfiguration)) {\n      logDoneCreateConfigurationByElement(startTimeNano, \"2\");\n      return null;\n    }\n    JstdRunConfiguration runConfiguration = (JstdRunConfiguration) runnerSettings.getConfiguration();\n\n    runConfiguration.setRunSettings(runSettingsContext.myRunSettings);\n\n    mySourceElement = runSettingsContext.myPsiElement;\n    runnerSettings.setName(runConfiguration.suggestedName());\n    logDoneCreateConfigurationByElement(startTimeNano, \"3\");\n    return runnerSettings;\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n    public JstdRunSettings provideSettings(@NotNull PsiElement psiElement) {\n      if (!(psiElement instanceof PsiDirectory)) {\n        return null;\n      }\n      PsiDirectory psiDirectory = (PsiDirectory) psiElement;\n      VirtualFile directory = psiDirectory.getVirtualFile();\n      boolean jstdConfigs = JstdSettingsUtil.areJstdConfigFilesInDirectory(psiDirectory.getProject(), directory);\n      if (!jstdConfigs) {\n        return null;\n      }\n      JstdRunSettings.Builder builder = new JstdRunSettings.Builder();\n      builder.setTestType(TestType.ALL_CONFIGS_IN_DIRECTORY)\n             .setDirectory(directory.getPath())\n             .setServerType(ServerType.INTERNAL);\n      return builder.build();\n    }","id":23610,"modified_method":"@Override\n    public JstdRunSettings provideSettings(@NotNull PsiElement psiElement) {\n      PsiDirectory psiDirectory = ObjectUtils.tryCast(psiElement, PsiDirectory.class);\n      if (psiDirectory == null) {\n        return null;\n      }\n      VirtualFile directory = psiDirectory.getVirtualFile();\n      boolean jstdConfigs = JstdSettingsUtil.areJstdConfigFilesInDirectory(psiDirectory.getProject(), directory);\n      if (!jstdConfigs) {\n        return null;\n      }\n      JstdRunSettings.Builder builder = new JstdRunSettings.Builder();\n      builder.setTestType(TestType.ALL_CONFIGS_IN_DIRECTORY)\n             .setDirectory(directory.getPath())\n             .setServerType(ServerType.INTERNAL);\n      return builder.build();\n    }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@SuppressWarnings({\"RawUseOfParameterizedType\"})\n  @Override\n  protected RunnerAndConfigurationSettings findExistingByElement(final Location location,\n                                                                 @NotNull final RunnerAndConfigurationSettings[] existingConfigurations,\n                                                                 ConfigurationContext context) {\n    long startTimeNano = System.nanoTime();\n    RunSettingsContext runSettingsContext = buildRunSettingsContext(location);\n    if (runSettingsContext == null) {\n      logDoneFindExistingByElement(startTimeNano, \"1\");\n      return null;\n    }\n    final JstdRunSettings runSettingsPattern = runSettingsContext.runSettings;\n    RunnerAndConfigurationSettings bestRaCSettings = null;\n    for (RunnerAndConfigurationSettings candidateRaCSettings : existingConfigurations) {\n      JstdRunConfiguration runConfiguration = CastUtils.tryCast(candidateRaCSettings.getConfiguration(), JstdRunConfiguration.class);\n      if (runConfiguration == null) {\n        continue;\n      }\n      JstdRunSettings runSettingsCandidate = runConfiguration.getRunSettings();\n      TestType patternTestType = runSettingsPattern.getTestType();\n      if (patternTestType == runSettingsCandidate.getTestType()) {\n        if (runSettingsPattern.getTestType() == TestType.ALL_CONFIGS_IN_DIRECTORY) {\n          File dir1 = new File(runSettingsPattern.getDirectory());\n          File dir2 = new File(runSettingsCandidate.getDirectory());\n          if (dir1.isDirectory() && dir2.isDirectory() && dir1.equals(dir2)) {\n            bestRaCSettings = candidateRaCSettings;\n            break;\n          }\n        } else if (patternTestType == TestType.CONFIG_FILE) {\n          File configFilePattern = new File(runSettingsPattern.getConfigFile());\n          File configFileCandidate = new File(runSettingsCandidate.getConfigFile());\n          if (configFilePattern.isFile() && configFileCandidate.isFile() && configFilePattern.equals(configFileCandidate)) {\n            bestRaCSettings = candidateRaCSettings;\n            break;\n          }\n        } else if (patternTestType == TestType.JS_FILE || patternTestType == TestType.TEST_CASE || patternTestType == TestType.TEST_METHOD) {\n          File jsFilePattern = new File(runSettingsPattern.getJsFilePath());\n          File jsFileCandidate = new File(runSettingsCandidate.getJsFilePath());\n          boolean eq = jsFileCandidate.isFile() && jsFilePattern.equals(jsFileCandidate);\n          if (patternTestType == TestType.TEST_CASE) {\n            eq = eq && runSettingsPattern.getTestCaseName().equals(runSettingsCandidate.getTestCaseName());\n          }\n          if (patternTestType == TestType.TEST_METHOD) {\n            eq = eq && runSettingsPattern.getTestMethodName().equals(runSettingsCandidate.getTestMethodName());\n          }\n          if (eq) {\n            if (bestRaCSettings == null) {\n              bestRaCSettings = candidateRaCSettings;\n            } else {\n              JstdRunConfiguration bestRunConfiguration = CastUtils.tryCast(bestRaCSettings.getConfiguration(), JstdRunConfiguration.class);\n              if (bestRunConfiguration != null) {\n                JstdRunSettings bestRunSettings = bestRunConfiguration.getRunSettings();\n                if (bestRunSettings.getConfigType() == JstdConfigType.GENERATED) {\n                  bestRaCSettings = candidateRaCSettings;\n                } else if (!new File(bestRunSettings.getConfigFile()).isFile()) {\n                  bestRaCSettings = candidateRaCSettings;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    logDoneFindExistingByElement(startTimeNano, \"2\");\n    return bestRaCSettings;\n  }","id":23611,"modified_method":"@SuppressWarnings({\"RawUseOfParameterizedType\"})\n  @Override\n  protected RunnerAndConfigurationSettings findExistingByElement(final Location location,\n                                                                 @NotNull final RunnerAndConfigurationSettings[] existingConfigurations,\n                                                                 ConfigurationContext context) {\n    long startTimeNano = System.nanoTime();\n    RunSettingsContext runSettingsContext = buildRunSettingsContext(location);\n    if (runSettingsContext == null) {\n      logDoneFindExistingByElement(startTimeNano, \"1\");\n      return null;\n    }\n    final JstdRunSettings runSettingsPattern = runSettingsContext.myRunSettings;\n    RunnerAndConfigurationSettings bestRaCSettings = null;\n    for (RunnerAndConfigurationSettings candidateRaCSettings : existingConfigurations) {\n      JstdRunConfiguration runConfiguration = ObjectUtils.tryCast(candidateRaCSettings.getConfiguration(), JstdRunConfiguration.class);\n      if (runConfiguration == null) {\n        continue;\n      }\n      JstdRunSettings runSettingsCandidate = runConfiguration.getRunSettings();\n      TestType patternTestType = runSettingsPattern.getTestType();\n      if (patternTestType == runSettingsCandidate.getTestType()) {\n        if (runSettingsPattern.getTestType() == TestType.ALL_CONFIGS_IN_DIRECTORY) {\n          File dir1 = new File(runSettingsPattern.getDirectory());\n          File dir2 = new File(runSettingsCandidate.getDirectory());\n          if (dir1.isDirectory() && dir2.isDirectory() && dir1.equals(dir2)) {\n            bestRaCSettings = candidateRaCSettings;\n            break;\n          }\n        } else if (patternTestType == TestType.CONFIG_FILE) {\n          File configFilePattern = new File(runSettingsPattern.getConfigFile());\n          File configFileCandidate = new File(runSettingsCandidate.getConfigFile());\n          if (configFilePattern.isFile() && configFileCandidate.isFile() && configFilePattern.equals(configFileCandidate)) {\n            bestRaCSettings = candidateRaCSettings;\n            break;\n          }\n        } else if (patternTestType == TestType.JS_FILE || patternTestType == TestType.TEST_CASE || patternTestType == TestType.TEST_METHOD) {\n          File jsFilePattern = new File(runSettingsPattern.getJsFilePath());\n          File jsFileCandidate = new File(runSettingsCandidate.getJsFilePath());\n          boolean eq = jsFileCandidate.isFile() && jsFilePattern.equals(jsFileCandidate);\n          if (patternTestType == TestType.TEST_CASE) {\n            eq = eq && runSettingsPattern.getTestCaseName().equals(runSettingsCandidate.getTestCaseName());\n          }\n          if (patternTestType == TestType.TEST_METHOD) {\n            eq = eq && runSettingsPattern.getTestMethodName().equals(runSettingsCandidate.getTestMethodName());\n          }\n          if (eq) {\n            if (bestRaCSettings == null) {\n              bestRaCSettings = candidateRaCSettings;\n            } else {\n              JstdRunConfiguration bestRunConfiguration = ObjectUtils.tryCast(bestRaCSettings.getConfiguration(), JstdRunConfiguration.class);\n              if (bestRunConfiguration != null) {\n                JstdRunSettings bestRunSettings = bestRunConfiguration.getRunSettings();\n                if (bestRunSettings.getConfigType() == JstdConfigType.GENERATED) {\n                  bestRaCSettings = candidateRaCSettings;\n                } else if (!new File(bestRunSettings.getConfigFile()).isFile()) {\n                  bestRaCSettings = candidateRaCSettings;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    logDoneFindExistingByElement(startTimeNano, \"2\");\n    return bestRaCSettings;\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  private static RunSettingsContext buildRunSettingsContext(@Nullable Location<PsiElement> location) {\n    if (location instanceof PsiLocation) {\n      PsiElement element = location.getPsiElement();\n      JstdRunSettings runSettings = findJstdRunSettings(element);\n      if (runSettings != null) {\n        return new RunSettingsContext(runSettings, element);\n      }\n    }\n    return null;\n  }","id":23612,"modified_method":"@Nullable\n  private static RunSettingsContext buildRunSettingsContext(@Nullable Location<?> location) {\n    if (location != null) {\n      PsiElement element = location.getPsiElement();\n      JstdRunSettings runSettings = findJstdRunSettings(element);\n      if (runSettings != null) {\n        return new RunSettingsContext(runSettings, element);\n      }\n    }\n    return null;\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private RunSettingsContext(JstdRunSettings runSettings, PsiElement psiElement) {\n      this.runSettings = runSettings;\n      this.psiElement = psiElement;\n    }","id":23613,"modified_method":"private RunSettingsContext(JstdRunSettings runSettings, PsiElement psiElement) {\n      myRunSettings = runSettings;\n      myPsiElement = psiElement;\n    }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n    public JstdRunSettings provideSettings(@NotNull PsiElement psiElement) {\n      PsiFile psiFile = psiElement.getContainingFile();\n      if (psiFile == null) {\n        return null;\n      }\n      final VirtualFile virtualFile = psiFile.getVirtualFile();\n      if (virtualFile == null || virtualFile.getFileType() != JavaScriptSupportLoader.JAVASCRIPT) {\n        return null;\n      }\n      VirtualFile entity = virtualFile;\n      VirtualFile projectDir = psiElement.getProject().getBaseDir();\n      boolean testFound = false;\n      while (entity != null) {\n        if (matchTestSource(entity.getName())) {\n          testFound = true;\n        }\n        if (entity.equals(projectDir)) {\n          break;\n        }\n        entity = entity.getParent();\n      }\n      if (Comparing.equal(entity, projectDir) && testFound) {\n        JstdRunSettings.Builder builder = new JstdRunSettings.Builder();\n        builder.setTestType(TestType.JS_FILE);\n        builder.setConfigType(JstdConfigType.GENERATED);\n        builder.setJSFilePath(virtualFile.getPath());\n        builder.setServerType(ServerType.INTERNAL);\n        return builder.build();\n      }\n      return null;\n    }","id":23614,"modified_method":"@Override\n    @Nullable\n    public JstdRunSettings provideSettings(@NotNull PsiElement psiElement) {\n      PsiFile psiFile = psiElement.getContainingFile();\n      if (psiFile == null) {\n        return null;\n      }\n      final VirtualFile virtualFile = psiFile.getVirtualFile();\n      if (virtualFile == null || virtualFile.getFileType() != JavaScriptSupportLoader.JAVASCRIPT) {\n        return null;\n      }\n      Project project = psiFile.getProject();\n      JSIndexEntry entry = JavaScriptIndex.getInstance(project).getEntryForFile(psiFile);\n      if (entry == null || !entry.isTestFile()) {\n        return null;\n      }\n      JstdRunSettings.Builder builder = new JstdRunSettings.Builder();\n      builder.setTestType(TestType.JS_FILE);\n      builder.setConfigType(JstdConfigType.FILE_PATH);\n      List<VirtualFile> jstdConfigFiles = JstdTestFilePathIndex.findConfigFilesInProject(virtualFile, project);\n      if (jstdConfigFiles.size() == 1) {\n        builder.setConfigFile(jstdConfigFiles.get(0).getPath());\n      }\n      builder.setJSFilePath(virtualFile.getPath());\n      builder.setServerType(ServerType.INTERNAL);\n      return builder.build();\n    }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n    public JstdRunSettings provideSettings(@NotNull PsiElement psiElement) {\n      JSFile jsFile = CastUtils.tryCast(psiElement.getContainingFile(), JSFile.class);\n      VirtualFile virtualFile = jsFile != null ? jsFile.getVirtualFile() : null;\n      if (virtualFile == null) {\n        return null;\n      }\n      TestFileStructurePack pack = TestFileStructureManager.fetchTestFileStructurePackByJsFile(jsFile);\n      if (pack != null) {\n        JstdRunElement jstdRunElement = pack.getJstdRunElement(psiElement);\n        if (jstdRunElement != null) {\n          String testMethodName = jstdRunElement.getTestMethodName();\n          if (testMethodName != null) {\n            return new JstdRunSettings.Builder()\n                .setTestType(TestType.TEST_METHOD)\n                .setJSFilePath(virtualFile.getPath())\n                .setTestCaseName(jstdRunElement.getTestCaseName())\n                .setTestMethodName(testMethodName)\n                .build();\n          } else {\n            return new JstdRunSettings.Builder()\n                .setTestType(TestType.TEST_CASE)\n                .setJSFilePath(virtualFile.getPath())\n                .setTestCaseName(jstdRunElement.getTestCaseName())\n                .build();\n          }\n        }\n      }\n      return null;\n    }","id":23615,"modified_method":"@Override\n    public JstdRunSettings provideSettings(@NotNull PsiElement psiElement) {\n      JSFile jsFile = ObjectUtils.tryCast(psiElement.getContainingFile(), JSFile.class);\n      if (jsFile == null) {\n        return null;\n      }\n      VirtualFile virtualFile = jsFile.getVirtualFile();\n      if (virtualFile == null || virtualFile.getFileType() != JavaScriptSupportLoader.JAVASCRIPT) {\n        return null;\n      }\n      TestFileStructurePack pack = TestFileStructureManager.fetchTestFileStructurePackByJsFile(jsFile);\n      if (pack == null) {\n        return null;\n      }\n      JstdRunElement jstdRunElement = pack.getJstdRunElement(psiElement);\n      if (jstdRunElement != null) {\n        Project project = jsFile.getProject();\n        JstdRunSettings.Builder builder = new JstdRunSettings.Builder();\n        builder.setJSFilePath(virtualFile.getPath());\n        builder.setTestCaseName(jstdRunElement.getTestCaseName());\n        builder.setConfigType(JstdConfigType.FILE_PATH);\n        List<VirtualFile> jstdConfigs = JstdTestFilePathIndex.findConfigFilesInProject(virtualFile, project);\n        if (jstdConfigs.size() == 1) {\n          builder.setConfigFile(jstdConfigs.get(0).getPath());\n        }\n        String testMethodName = jstdRunElement.getTestMethodName();\n        if (testMethodName != null) {\n          builder.setTestType(TestType.TEST_METHOD);\n          builder.setTestMethodName(testMethodName);\n        } else {\n          builder.setTestType(TestType.TEST_CASE);\n        }\n        return builder.build();\n      }\n      return null;\n    }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public int getVersion() {\n    return 0;\n  }","id":23616,"modified_method":"@Override\n  public int getVersion() {\n    return 1;\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  public static List<VirtualFile> findConfigFiles(@NotNull VirtualFile jsTestFile, @NotNull GlobalSearchScope scope) {\n    final List<VirtualFile> jstdConfigs = new ArrayList<VirtualFile>();\n    FileBasedIndex.getInstance().processValues(\n      KEY,\n      jsTestFile.getPath(),\n      null,\n      new FileBasedIndex.ValueProcessor<Void>() {\n        @Override\n        public boolean process(final VirtualFile file, final Void value) {\n          jstdConfigs.add(file);\n          return true;\n        }\n      },\n      scope\n    );\n    return jstdConfigs;\n  }","id":23617,"modified_method":"@NotNull\n  public static List<VirtualFile> findConfigFilesInScope(@NotNull VirtualFile jsTestFile, @NotNull GlobalSearchScope scope) {\n    final List<VirtualFile> jstdConfigs = new ArrayList<VirtualFile>(1);\n    FileBasedIndex.getInstance().processValues(\n      KEY,\n      jsTestFile.getPath(),\n      null,\n      new FileBasedIndex.ValueProcessor<Void>() {\n        @Override\n        public boolean process(final VirtualFile file, final Void value) {\n          jstdConfigs.add(file);\n          return true;\n        }\n      },\n      scope\n    );\n    return jstdConfigs;\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  @Override\n  public JstdTestFileStructure buildTestFileStructure(@NotNull JSFile jsFile) {\n    JstdTestFileStructure jsTestFileStructure = new JstdTestFileStructure(jsFile);\n    List<JSStatement> statements = JsPsiUtils.listStatementsInExecutionOrder(jsFile);\n    for (JSStatement statement : statements) {\n      fillJsTestFileStructure(jsTestFileStructure, statement);\n    }\n    return jsTestFileStructure;\n  }","id":23618,"modified_method":"@NotNull\n  @Override\n  public JstdTestFileStructure buildTestFileStructure(@NotNull JSFile jsFile) {\n    JstdTestFileStructure jsTestFileStructure = new JstdTestFileStructure(jsFile);\n    List<JSStatement> statements = JsPsiUtils.listStatementsInExecutionOrder(jsFile);\n    for (JSStatement statement : statements) {\n      fillJsTestFileStructure(jsTestFileStructure, statement);\n    }\n    for (JstdTestCaseStructure testCaseStructure : jsTestFileStructure.getTestCaseStructures()) {\n      for (JstdTestStructure testStructure : testCaseStructure.getTestStructures()) {\n        PsiElement anchor = testStructure.getTestMethodNameDeclaration();\n        anchor.putUserData(JstdTestFileStructure.TEST_ELEMENT_NAME_KEY, testStructure.getName());\n      }\n      JSExpression testCaseMethodExpr = testCaseStructure.getEnclosingCallExpression().getMethodExpression();\n      if (testCaseMethodExpr != null) {\n        testCaseMethodExpr.putUserData(JstdTestFileStructure.TEST_ELEMENT_NAME_KEY, testCaseStructure.getName());\n      }\n    }\n    return jsTestFileStructure;\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void executeAll() {\n    for (File config : mySettings.getConfigFiles()) {\n      executeConfig(config);\n    }\n    if (myCoverageSession != null) {\n      myCoverageSession.finish();\n    }\n  }","id":23619,"modified_method":"public void executeAll() {\n    for (File config : mySettings.getConfigFiles()) {\n      executeTests(config);\n    }\n    if (myCoverageSession != null) {\n      myCoverageSession.finish();\n    }\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public TestRunner(@NotNull Settings settings, @NotNull TreeManager treeManager) {\n    mySettings = settings;\n    myTreeManager = treeManager;\n    File ideCoverageFile = mySettings.getIdeCoverageFile();\n    if (ideCoverageFile != null) {\n      myCoverageSession = new CoverageSession(ideCoverageFile);\n    } else {\n      myCoverageSession = null;\n    }\n  }","id":23620,"modified_method":"public TestRunner(@NotNull JstdSettings settings, @NotNull TreeManager treeManager) {\n    mySettings = settings;\n    myTreeManager = treeManager;\n    File ideCoverageFile = mySettings.getIdeCoverageFile();\n    if (ideCoverageFile != null) {\n      myCoverageSession = new CoverageSession(ideCoverageFile);\n    } else {\n      myCoverageSession = null;\n    }\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static boolean validateServer(@NotNull Settings settings, @NotNull TreeManager treeManager) throws IOException {\n    String serverUrl = settings.getServerUrl();\n    JstdServerFetchResult fetchResult = JstdServerUtilsRt.syncFetchServerInfo(serverUrl);\n    String message = null;\n    if (fetchResult.isError()) {\n      message = \"Could not connect to a JsTestDriver server running at \" + serverUrl + \"\\n\" +\n                \"Check that the server is running.\";\n    } else if (fetchResult.getServerInfo().getCapturedBrowsers().isEmpty()) {\n      message = \"No captured browsers found.\\n\" +\n                \"To capture browser open '\" + serverUrl + \"' in browser.\";\n    }\n    if (message != null) {\n      treeManager.reportRootError(message);\n      return false;\n    }\n    return true;\n  }","id":23621,"modified_method":"private static boolean validateServer(@NotNull JstdSettings settings, @NotNull TreeManager treeManager) throws IOException {\n    String serverUrl = settings.getServerUrl();\n    JstdServerFetchResult fetchResult = JstdServerUtilsRt.syncFetchServerInfo(serverUrl);\n    String message = null;\n    if (fetchResult.isError()) {\n      message = \"Could not connect to a JsTestDriver server running at \" + serverUrl + \"\\n\" +\n                \"Check that the server is running.\";\n    } else if (fetchResult.getServerInfo().getCapturedBrowsers().isEmpty()) {\n      message = \"No captured browsers found.\\n\" +\n                \"To capture browser open '\" + serverUrl + \"' in browser.\";\n    }\n    if (message != null) {\n      treeManager.reportRootError(message);\n      return false;\n    }\n    return true;\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public static void main(String[] args) throws Exception {\n    Map<ParameterKey, String> paramMap = parseParams(args);\n    Settings settings = Settings.build(paramMap);\n    TreeManager treeManager = new TreeManager(settings.getRunAllConfigsInDirectory());\n    if (!validateServer(settings, treeManager)) {\n      System.exit(1);\n      return;\n    }\n    try {\n      new TestRunner(settings, treeManager).executeAll();\n    } catch (Exception ex) {\n      treeManager.printThrowable(\"Unexpected crash!\", ex);\n    } finally {\n      treeManager.onTestingFinished();\n    }\n  }","id":23622,"modified_method":"public static void main(String[] args) throws Exception {\n    Map<ParameterKey, String> paramMap = parseParams(args);\n    JstdSettings settings = JstdSettings.build(paramMap);\n    TreeManager treeManager = new TreeManager(settings.getRunAllConfigsInDirectory());\n    if (!validateServer(settings, treeManager)) {\n      System.exit(1);\n      return;\n    }\n    try {\n      new TestRunner(settings, treeManager).executeAll();\n    } catch (Exception ex) {\n      treeManager.printThrowable(\"Unexpected crash!\", ex);\n    } finally {\n      treeManager.onTestingFinished();\n    }\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@SuppressWarnings(\"deprecation\")\n  private void runTests(@NotNull final File configFile, @NotNull String[] extraArgs, final boolean dryRun) throws ConfigurationException {\n    JsTestDriverBuilder builder = new JsTestDriverBuilder();\n\n    final ParsedConfiguration parsedConfiguration;\n    try {\n      parsedConfiguration = JstdConfigParsingUtils.parseConfiguration(configFile);\n    } catch (Exception e) {\n      throw new ConfigurationException(\"Configuration file parsing failed.\\n\" +\n                                       \"See http://code.google.com/p/js-test-driver/wiki/ConfigurationFile for clarification.\\n\\n\" +\n                                       \"Details:\", e);\n    }\n    final File singleBasePath = JstdConfigParsingUtils.getSingleBasePath(parsedConfiguration.getBasePaths(), configFile);\n    myTreeManager.setCurrentBasePath(singleBasePath.getAbsolutePath());\n    wipeCoveragePlugin(parsedConfiguration);\n    builder.setDefaultConfiguration(parsedConfiguration);\n    builder.withPluginInitializer(new PluginInitializer() {\n      @Override\n      public Module initializeModule(Flags flags, Configuration config) {\n        return new AbstractModule() {\n          @Override\n          public void configure() {\n            Multibinder<TestListener> testListeners = Multibinder.newSetBinder(binder(), TestListener.class);\n            testListeners.addBinding().to(TestResultHolder.class);\n            testListeners.addBinding().toInstance(new IdeaTestListener(\n              myTreeManager,\n              configFile,\n              singleBasePath,\n              dryRun\n            ));\n          }\n        };\n      }\n    });\n\n    builder.setRunnerMode(RunnerMode.QUIET);\n    builder.setServer(mySettings.getServerUrl());\n\n    List<String> flagArgs = Lists.newArrayList(\"--captureConsole\", \"--server\", mySettings.getServerUrl());\n    flagArgs.addAll(Arrays.asList(extraArgs));\n    List<String> coverageExcludedFiles = null;\n    File emptyOutputDir = null;\n    boolean runCoverage = false;\n    if (myCoverageSession != null && !dryRun) {\n      emptyOutputDir = createTempDir();\n      if (emptyOutputDir != null) {\n        flagArgs.add(\"--testOutput\");\n        flagArgs.add(emptyOutputDir.getAbsolutePath());\n        List<String> testPaths = getTestFilePaths(parsedConfiguration);\n        coverageExcludedFiles = Lists.newArrayList(testPaths);\n        coverageExcludedFiles.addAll(mySettings.getFilesExcludedFromCoverage());\n        PluginInitializer coverageInitializer = getCoverageInitializer(coverageExcludedFiles);\n        if (coverageInitializer != null) {\n          builder.withPluginInitializer(coverageInitializer);\n          builder.withPluginInitializer(new DependenciesTouchFix());\n          runCoverage = true;\n        }\n      }\n    }\n\n    builder.setFlags(toStringArray(flagArgs));\n    JsTestDriver jstd = builder.build();\n    jstd.runConfiguration();\n    if (runCoverage) {\n      File[] coverageReportFiles = emptyOutputDir.listFiles(new FilenameFilter() {\n        @Override\n        public boolean accept(File dir, String name) {\n          return name.endsWith(\"-coverage.dat\");\n        }\n      });\n      if (coverageReportFiles != null && coverageReportFiles.length == 1) {\n        try {\n          CoverageReport coverageReport = CoverageSerializationUtils.readLCOV(coverageReportFiles[0]);\n          for (String excludedPath : coverageExcludedFiles) {\n            coverageReport.clearReportByFilePath(excludedPath);\n          }\n          myCoverageSession.mergeReport(coverageReport);\n        }\n        catch (Exception e) {\n          myTreeManager.printThrowable(e);\n        }\n      }\n    }\n  }","id":23623,"modified_method":"@SuppressWarnings(\"deprecation\")\n  private void runTests(@NotNull final File configFile, @NotNull String[] extraArgs, final boolean dryRun) throws ConfigurationException {\n    JsTestDriverBuilder builder = new JsTestDriverBuilder();\n\n    final ParsedConfiguration parsedConfiguration;\n    try {\n      parsedConfiguration = JstdConfigParsingUtils.parseConfiguration(configFile);\n    } catch (Exception e) {\n      throw new ConfigurationException(\"Configuration file parsing failed.\\n\" +\n                                       \"See http://code.google.com/p/js-test-driver/wiki/ConfigurationFile for clarification.\\n\\n\" +\n                                       \"Details:\", e);\n    }\n    final File singleBasePath = JstdConfigParsingUtils.getSingleBasePath(parsedConfiguration.getBasePaths(), configFile);\n    myTreeManager.setCurrentBasePath(singleBasePath.getAbsolutePath());\n    wipeCoveragePlugin(parsedConfiguration);\n    builder.setDefaultConfiguration(parsedConfiguration);\n    builder.withPluginInitializer(new PluginInitializer() {\n      @Override\n      public Module initializeModule(Flags flags, Configuration config) {\n        return new AbstractModule() {\n          @Override\n          public void configure() {\n            Multibinder<TestListener> testListeners = Multibinder.newSetBinder(binder(), TestListener.class);\n            testListeners.addBinding().to(TestResultHolder.class);\n            testListeners.addBinding().toInstance(new IdeaTestListener(\n              myTreeManager,\n              configFile,\n              singleBasePath,\n              dryRun,\n              mySettings.getTestFileScope()\n            ));\n          }\n        };\n      }\n    });\n\n    builder.setRunnerMode(RunnerMode.QUIET);\n    builder.setServer(mySettings.getServerUrl());\n\n    List<String> flagArgs = Lists.newArrayList(\"--captureConsole\", \"--server\", mySettings.getServerUrl());\n    flagArgs.addAll(Arrays.asList(extraArgs));\n    List<String> coverageExcludedFiles = null;\n    File emptyOutputDir = null;\n    boolean runCoverage = false;\n    if (myCoverageSession != null && !dryRun) {\n      emptyOutputDir = createTempDir();\n      if (emptyOutputDir != null) {\n        flagArgs.add(\"--testOutput\");\n        flagArgs.add(emptyOutputDir.getAbsolutePath());\n        List<String> testPaths = getTestFilePaths(parsedConfiguration);\n        coverageExcludedFiles = Lists.newArrayList(testPaths);\n        coverageExcludedFiles.addAll(mySettings.getFilesExcludedFromCoverage());\n        PluginInitializer coverageInitializer = getCoverageInitializer(coverageExcludedFiles);\n        if (coverageInitializer != null) {\n          builder.withPluginInitializer(coverageInitializer);\n          builder.withPluginInitializer(new DependenciesTouchFix());\n          runCoverage = true;\n        }\n      }\n    }\n\n    builder.setFlags(toStringArray(flagArgs));\n    JsTestDriver jstd = builder.build();\n    jstd.runConfiguration();\n    if (runCoverage) {\n      File[] coverageReportFiles = emptyOutputDir.listFiles(new FilenameFilter() {\n        @Override\n        public boolean accept(File dir, String name) {\n          return name.endsWith(\"-coverage.dat\");\n        }\n      });\n      if (coverageReportFiles != null && coverageReportFiles.length == 1) {\n        try {\n          CoverageReport coverageReport = CoverageSerializationUtils.readLCOV(coverageReportFiles[0]);\n          for (String excludedPath : coverageExcludedFiles) {\n            coverageReport.clearReportByFilePath(excludedPath);\n          }\n          myCoverageSession.mergeReport(coverageReport);\n        }\n        catch (Exception e) {\n          myTreeManager.printThrowable(e);\n        }\n      }\n    }\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void executeTests(@NotNull File config, @NotNull String tests) {\n    Exception exception = null;\n    PrintStream nullSystemOut = new PrintStream(new NullOutputStream());\n    try {\n      System.setOut(nullSystemOut);\n      myTreeManager.onJstdConfigRunningStarted(config);\n      runTests(config, new String[]{\"--reset\", \"--dryRunFor\", tests}, true);\n      runTests(config, new String[]{\"--tests\", tests}, false);\n    } catch (ConfigurationException ce) {\n      exception = ce;\n    } catch (Exception e) {\n      exception = new Exception(\"Can't run tests. Details:\", e);\n    } finally {\n      myTreeManager.onJstdConfigRunningFinished(exception);\n      nullSystemOut.close();\n      System.setOut(myTreeManager.getSystemOutStream());\n    }\n  }","id":23624,"modified_method":"private void executeTests(@NotNull File config) {\n    Exception exception = null;\n    PrintStream nullSystemOut = new PrintStream(new NullOutputStream());\n    try {\n      System.setOut(nullSystemOut);\n      myTreeManager.onJstdConfigRunningStarted(config);\n      String runScope = mySettings.getTestFileScope().toJstdScope();\n      runTests(config, new String[]{\"--reset\", \"--dryRunFor\", runScope}, true);\n      runTests(config, new String[]{\"--tests\", runScope}, false);\n    } catch (ConfigurationException ce) {\n      exception = ce;\n    } catch (Exception e) {\n      exception = new Exception(\"Can't run tests. Details:\", e);\n    } finally {\n      myTreeManager.onJstdConfigRunningFinished(exception);\n      nullSystemOut.close();\n      System.setOut(myTreeManager.getSystemOutStream());\n    }\n  }","commit_id":"49c0515e7ee263c74258e61bf639e4f5e5371427","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n\t * @return duration in milliseconds of how long the attachment was\n\t */\n\tpublic long detach(A resourceKey, B attachedResourceKey, long timestampMs)\n\t{\n\t\tif (timestampMs < reportBeginMs) return 0l; //Attachment falls entirely outside report boundaries\n\t\tif (! attachments.containsKey(resourceKey)) {\n\t\t\tattachments.put(resourceKey, new HashMap<B,TreeSet<Long>>());\n\t\t}\n\t\tMap<B,TreeSet<Long>> innerMap = attachments.get(resourceKey);\n\t\tif (!innerMap.containsKey(attachedResourceKey)) {\n\t\t\tinnerMap.put(attachedResourceKey, new TreeSet<Long>());\n\t\t}\n\t\tTreeSet<Long> timestamps = innerMap.get(attachedResourceKey);\n\t\tLong attachTimestamp = timestamps.floor(timestampMs);\n\t\tif (attachTimestamp != null) {\n\t\t\treturn (Math.min(timestampMs, reportEndMs) - attachTimestamp.longValue());\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}","id":23625,"modified_method":"/**\n\t * @return duration in milliseconds of how long the attachment was\n\t */\n\tpublic long detach(A resourceKey, B attachedResourceKey, long timestampMs)\n\t{\n\t\tif (timestampMs < reportBeginMs) return 0l; //Attachment falls entirely outside report boundaries\n\t\tif (! attachments.containsKey(resourceKey)) {\n\t\t\tattachments.put(resourceKey, new HashMap<B,TreeSet<Long>>());\n\t\t}\n\t\tMap<B,TreeSet<Long>> innerMap = attachments.get(resourceKey);\n\t\tif (!innerMap.containsKey(attachedResourceKey)) {\n\t\t\tinnerMap.put(attachedResourceKey, new TreeSet<Long>());\n\t\t}\n\t\tTreeSet<Long> timestamps = innerMap.get(attachedResourceKey);\n\t\tLong attachTimestamp = timestamps.floor(timestampMs);\n\t\tif (attachTimestamp != null) {\n\t\t\treturn DurationCalculator.boundDuration(reportBeginMs, reportEndMs,\n\t\t\t\t\tattachTimestamp.longValue(), timestampMs);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}","commit_id":"f76c08850497cf722de2829b79dfad6f7ef8307a","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ReportArtEntity generateReportArt(ReportArtEntity report)\n\t{\n\t\tlog.debug(\"GENERATING REPORT ART\");\n\t\tEntityWrapper wrapper = EntityWrapper.get( ReportingVolumeCreateEvent.class );\n\n\t\t/* Create super-tree of availZones, accounts, users, and volumes;\n\t\t * and create a Map of the volume nodes at the bottom with start times.\n\t\t */\n\t\tIterator iter = wrapper.scanWithNativeQuery( \"scanVolumeCreateEvents\" );\n\t\tMap<String,VolumeArtEntity> volumeEntities = new HashMap<String,VolumeArtEntity>();\n\t\tMap<String,StartEndTimes> volStartEndTimes = new HashMap<String,StartEndTimes>();\n\t\twhile (iter.hasNext()) {\n\t\t\tReportingVolumeCreateEvent createEvent = (ReportingVolumeCreateEvent) iter.next();\n\t\t\tif (! report.getZones().containsKey(createEvent.getAvailabilityZone())) {\n\t\t\t\treport.getZones().put(createEvent.getAvailabilityZone(), new AvailabilityZoneArtEntity());\n\t\t\t}\n\t\t\tAvailabilityZoneArtEntity zone = report.getZones().get(createEvent.getAvailabilityZone());\n\t\t\t\n\t\t\tReportingUser reportingUser = ReportingUserDao.getInstance().getReportingUser(createEvent.getUserId());\n\t\t\tif (reportingUser==null) {\n\t\t\t\tlog.error(\"No user corresponding to event:\" + createEvent.getUserId());\n\t\t\t}\n\t\t\tReportingAccount reportingAccount = ReportingAccountDao.getInstance().getReportingAccount(reportingUser.getAccountId());\n\t\t\tif (reportingAccount==null) {\n\t\t\t\tlog.error(\"No account corresponding to user:\" + reportingUser.getAccountId());\n\t\t\t}\n\t\t\tif (! zone.getAccounts().containsKey(reportingAccount.getName())) {\n\t\t\t\tzone.getAccounts().put(reportingAccount.getName(), new AccountArtEntity());\n\t\t\t}\n\t\t\tAccountArtEntity account = zone.getAccounts().get(reportingAccount.getName());\n\t\t\tif (! account.getUsers().containsKey(reportingUser.getName())) {\n\t\t\t\taccount.getUsers().put(reportingUser.getName(), new UserArtEntity());\n\t\t\t}\n\t\t\tUserArtEntity user = account.getUsers().get(reportingUser.getName());\n\t\t\tVolumeArtEntity volume = new VolumeArtEntity(createEvent.getVolumeId());\n\t\t\tvolume.getUsage().setSizeGB( createEvent.getSizeGB() );\n\t\t\tlong startTime = Math.max(report.getBeginMs(), createEvent.getTimestampMs());\n\t\t\tif (startTime <= report.getEndMs()) {\n\t\t\t\tuser.getVolumes().put(createEvent.getUuid(), volume);\n\t\t\t\tvolStartEndTimes.put(createEvent.getUuid(), new StartEndTimes( startTime, report.getEndMs() ));\n\t\t\t\tvolumeEntities.put(createEvent.getUuid(), volume);\n\t\t\t\tvolume.getUsage().setVolumeCnt(1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Find end times for the volumes\n\t\t */\n\t\titer = wrapper.scanWithNativeQuery( \"scanVolumeDeleteEvents\" );\n\t\twhile (iter.hasNext()) {\n\t\t\tReportingVolumeDeleteEvent deleteEvent = (ReportingVolumeDeleteEvent) iter.next();\n\t\t\tlong endTime = Math.min(deleteEvent.getTimestampMs(), report.getEndMs());\n\t\t\tif (endTime >= report.getBeginMs() && volStartEndTimes.containsKey(deleteEvent.getUuid())) {\n\t\t\t\tStartEndTimes startEndTimes = volStartEndTimes.get(deleteEvent.getUuid());\n\t\t\t\tstartEndTimes.setEndTime(endTime);\n\t\t\t\tvolumeEntities.remove(deleteEvent.getUuid());\n\t\t\t\tvolStartEndTimes.remove(deleteEvent.getUuid());\n\t\t\t}\n\t\t}\n\n\t\t/* Set the duration of each volume\n\t\t */\n\t\tfor (String uuid: volumeEntities.keySet()) {\n\t\t\tVolumeArtEntity volume = volumeEntities.get(uuid);\n\t\t\tStartEndTimes startEndTimes = volStartEndTimes.get(uuid);\n\t\t\tif (uuid == null) {\n\t\t\t\tlog.error(\"volume without corresponding start end times:\" + uuid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlong duration = DurationCalculator.boundDuration(report.getBeginMs(), report.getEndMs(),\n\t\t\t\t\tstartEndTimes.getStartTime(), startEndTimes.getEndTime());\n\t\t\tvolume.getUsage().setGBSecs(duration*volume.getUsage().getSizeGB());\n\t\t}\n\t\t\n\n\t\t/* Scan instance entities so we can get the instance id from the uuid\n\t\t */\n\t\tMap<String,InstanceArtEntity> instanceEntities = new HashMap<String,InstanceArtEntity>();\n\t\titer = wrapper.scanWithNativeQuery( \"scanInstanceCreateEvents\" );\n\t\twhile (iter.hasNext()) {\n\t\t\tReportingInstanceCreateEvent createEvent = (ReportingInstanceCreateEvent) iter.next();\n\t\t\tInstanceArtEntity instance = new InstanceArtEntity(createEvent.getInstanceType(), createEvent.getInstanceId());\n\t\t\tinstanceEntities.put(createEvent.getUuid(), instance);\n\t\t}\n\t\t\n\n\t\t/* Find attachment start times\n\t\t */\n\t\tAttachDurationCalculator<String,String> durationCalc = new AttachDurationCalculator<String,String>(report.getBeginMs(), report.getEndMs());\n\t\titer = wrapper.scanWithNativeQuery( \"scanVolumeAttachEvents\" );\n\t\twhile (iter.hasNext()) {\n\t\t\tReportingVolumeAttachEvent attachEvent = (ReportingVolumeAttachEvent) iter.next();\n\t\t\tdurationCalc.attach(attachEvent.getInstanceUuid(), attachEvent.getVolumeUuid(),\n\t\t\t\t\tattachEvent.getTimestampMs());\n\t\t}\n\n\t\t/* Find attachment end times and set durations\n\t\t */\n\t\titer = wrapper.scanWithNativeQuery( \"scanVolumeDetachEvents\" );\n\t\twhile (iter.hasNext()) {\n\t\t\tReportingVolumeDetachEvent detachEvent = (ReportingVolumeDetachEvent) iter.next();\n\t\t\tlong duration = durationCalc.detach(detachEvent.getInstanceUuid(),\n\t\t\t\t\tdetachEvent.getVolumeUuid(), detachEvent.getTimestampMs());\n\t\t\tif (duration==0) continue;\n\t\t\tif (! volumeEntities.containsKey(detachEvent.getVolumeUuid())) continue;\n\t\t\tVolumeArtEntity volume = volumeEntities.get(detachEvent.getVolumeUuid());\n\t\t\tlong gbsecs = duration * volume.getUsage().getSizeGB();\n\t\t\t/* If a volume is repeatedly attached to and detached from an instance,\n\t\t\t * add up the total attachment time.\n\t\t\t */\n\t\t\tif (volume.getInstanceAttachments().containsKey(detachEvent.getInstanceUuid())) {\n\t\t\t\tgbsecs += volume.getInstanceAttachments().get(detachEvent.getInstanceUuid()).getGBSecs();\n\t\t\t}\n\t\t\tVolumeUsageArtEntity usage = new VolumeUsageArtEntity();\n\t\t\tusage.setGBSecs(gbsecs);\n\t\t\tusage.setSizeGB(volume.getUsage().getSizeGB());\n\t\t\tusage.setVolumeCnt(1);\n\t\t\tvolume.getInstanceAttachments().put(detachEvent.getInstanceUuid(), usage);\n\t\t}\n\n\t\t\n\t\t/* Perform totals and summations for user, account, and zone\n\t\t */\n\t\tfor (String zoneName : report.getZones().keySet()) {\n\t\t\tAvailabilityZoneArtEntity zone = report.getZones().get(zoneName);\n\t\t\tfor (String accountName : zone.getAccounts().keySet()) {\n\t\t\t\tAccountArtEntity account = zone.getAccounts().get(accountName);\n\t\t\t\tfor (String userName : account.getUsers().keySet()) {\n\t\t\t\t\tUserArtEntity user = account.getUsers().get(userName);\n\t\t\t\t\tfor (String volumeUuid : user.getVolumes().keySet()) {\n\t\t\t\t\t\tVolumeArtEntity volume = user.getVolumes().get(volumeUuid);\n\t\t\t\t\t\tupdateUsageTotals(user.getUsageTotals().getVolumeTotals(), volume.getUsage());\n\t\t\t\t\t\tupdateUsageTotals(account.getUsageTotals().getVolumeTotals(), volume.getUsage());\n\t\t\t\t\t\tupdateUsageTotals(zone.getUsageTotals().getVolumeTotals(), volume.getUsage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\treturn report;\n\t}","id":23626,"modified_method":"public ReportArtEntity generateReportArt(ReportArtEntity report)\n\t{\n\t\tlog.debug(\"GENERATING REPORT ART\");\n\t\tEntityWrapper wrapper = EntityWrapper.get( ReportingVolumeCreateEvent.class );\n\n\t\t/* Create super-tree of availZones, accounts, users, and volumes;\n\t\t * and create a Map of the volume nodes at the bottom with start times.\n\t\t */\n\t\tIterator iter = wrapper.scanWithNativeQuery( \"scanVolumeCreateEvents\" );\n\t\tMap<String,VolumeArtEntity> volumeEntities = new HashMap<String,VolumeArtEntity>();\n\t\tMap<String,StartEndTimes> volStartEndTimes = new HashMap<String,StartEndTimes>();\n\t\twhile (iter.hasNext()) {\n\t\t\tReportingVolumeCreateEvent createEvent = (ReportingVolumeCreateEvent) iter.next();\n\t\t\tif (! report.getZones().containsKey(createEvent.getAvailabilityZone())) {\n\t\t\t\treport.getZones().put(createEvent.getAvailabilityZone(), new AvailabilityZoneArtEntity());\n\t\t\t}\n\t\t\tAvailabilityZoneArtEntity zone = report.getZones().get(createEvent.getAvailabilityZone());\n\t\t\t\n\t\t\tReportingUser reportingUser = ReportingUserDao.getInstance().getReportingUser(createEvent.getUserId());\n\t\t\tif (reportingUser==null) {\n\t\t\t\tlog.error(\"No user corresponding to event:\" + createEvent.getUserId());\n\t\t\t}\n\t\t\tReportingAccount reportingAccount = ReportingAccountDao.getInstance().getReportingAccount(reportingUser.getAccountId());\n\t\t\tif (reportingAccount==null) {\n\t\t\t\tlog.error(\"No account corresponding to user:\" + reportingUser.getAccountId());\n\t\t\t}\n\t\t\tif (! zone.getAccounts().containsKey(reportingAccount.getName())) {\n\t\t\t\tzone.getAccounts().put(reportingAccount.getName(), new AccountArtEntity());\n\t\t\t}\n\t\t\tAccountArtEntity account = zone.getAccounts().get(reportingAccount.getName());\n\t\t\tif (! account.getUsers().containsKey(reportingUser.getName())) {\n\t\t\t\taccount.getUsers().put(reportingUser.getName(), new UserArtEntity());\n\t\t\t}\n\t\t\tUserArtEntity user = account.getUsers().get(reportingUser.getName());\n\t\t\tVolumeArtEntity volume = new VolumeArtEntity(createEvent.getVolumeId());\n\t\t\tvolume.getUsage().setSizeGB( createEvent.getSizeGB() );\n\t\t\tlong startTime = createEvent.getTimestampMs();\n\t\t\tif (startTime <= report.getEndMs()) {\n\t\t\t\tuser.getVolumes().put(createEvent.getUuid(), volume);\n\t\t\t\tvolStartEndTimes.put(createEvent.getUuid(), new StartEndTimes( startTime, report.getEndMs() ));\n\t\t\t\tvolumeEntities.put(createEvent.getUuid(), volume);\n\t\t\t\tvolume.getUsage().setVolumeCnt(1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Find end times for the volumes\n\t\t */\n\t\titer = wrapper.scanWithNativeQuery( \"scanVolumeDeleteEvents\" );\n\t\twhile (iter.hasNext()) {\n\t\t\tReportingVolumeDeleteEvent deleteEvent = (ReportingVolumeDeleteEvent) iter.next();\n\t\t\tlong endTime = deleteEvent.getTimestampMs();\n\t\t\tif (endTime >= report.getBeginMs() && volStartEndTimes.containsKey(deleteEvent.getUuid())) {\n\t\t\t\tStartEndTimes startEndTimes = volStartEndTimes.get(deleteEvent.getUuid());\n\t\t\t\tstartEndTimes.setEndTime(endTime);\n\t\t\t} else {\n\t\t\t\tvolumeEntities.remove(deleteEvent.getUuid());\n\t\t\t\tvolStartEndTimes.remove(deleteEvent.getUuid());\n\t\t\t}\n\t\t}\n\n\t\t/* Set the duration of each volume\n\t\t */\n\t\tfor (String uuid: volumeEntities.keySet()) {\n\t\t\tVolumeArtEntity volume = volumeEntities.get(uuid);\n\t\t\tStartEndTimes startEndTimes = volStartEndTimes.get(uuid);\n\t\t\tif (uuid == null) {\n\t\t\t\tlog.error(\"volume without corresponding start end times:\" + uuid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlong duration = DurationCalculator.boundDuration(report.getBeginMs(), report.getEndMs(),\n\t\t\t\t\tstartEndTimes.getStartTime(), startEndTimes.getEndTime());\n\t\t\tvolume.getUsage().setGBSecs(duration*volume.getUsage().getSizeGB());\n\t\t}\n\t\t\n\n\t\t/* Scan instance entities so we can get the instance id from the uuid\n\t\t */\n\t\tMap<String,InstanceArtEntity> instanceEntities = new HashMap<String,InstanceArtEntity>();\n\t\titer = wrapper.scanWithNativeQuery( \"scanInstanceCreateEvents\" );\n\t\twhile (iter.hasNext()) {\n\t\t\tReportingInstanceCreateEvent createEvent = (ReportingInstanceCreateEvent) iter.next();\n\t\t\tInstanceArtEntity instance = new InstanceArtEntity(createEvent.getInstanceType(), createEvent.getInstanceId());\n\t\t\tinstanceEntities.put(createEvent.getUuid(), instance);\n\t\t}\n\t\t\n\n\t\t/* Find attachment start times\n\t\t */\n\t\tAttachDurationCalculator<String,String> durationCalc = new AttachDurationCalculator<String,String>(report.getBeginMs(), report.getEndMs());\n\t\titer = wrapper.scanWithNativeQuery( \"scanVolumeAttachEvents\" );\n\t\twhile (iter.hasNext()) {\n\t\t\tReportingVolumeAttachEvent attachEvent = (ReportingVolumeAttachEvent) iter.next();\n\t\t\tdurationCalc.attach(attachEvent.getInstanceUuid(), attachEvent.getVolumeUuid(),\n\t\t\t\t\tattachEvent.getTimestampMs());\n\t\t}\n\n\t\t/* Find attachment end times and set durations\n\t\t */\n\t\titer = wrapper.scanWithNativeQuery( \"scanVolumeDetachEvents\" );\n\t\twhile (iter.hasNext()) {\n\t\t\tReportingVolumeDetachEvent detachEvent = (ReportingVolumeDetachEvent) iter.next();\n\t\t\tlong duration = durationCalc.detach(detachEvent.getInstanceUuid(),\n\t\t\t\t\tdetachEvent.getVolumeUuid(), detachEvent.getTimestampMs());\n\t\t\tif (duration==0) continue;\n\t\t\tif (! volumeEntities.containsKey(detachEvent.getVolumeUuid())) continue;\n\t\t\tVolumeArtEntity volume = volumeEntities.get(detachEvent.getVolumeUuid());\n\t\t\tlong gbsecs = duration * volume.getUsage().getSizeGB();\n\t\t\t/* If a volume is repeatedly attached to and detached from an instance,\n\t\t\t * add up the total attachment time.\n\t\t\t */\n\t\t\tif (volume.getInstanceAttachments().containsKey(detachEvent.getInstanceUuid())) {\n\t\t\t\tgbsecs += volume.getInstanceAttachments().get(detachEvent.getInstanceUuid()).getGBSecs();\n\t\t\t}\n\t\t\tVolumeUsageArtEntity usage = new VolumeUsageArtEntity();\n\t\t\tusage.setGBSecs(gbsecs);\n\t\t\tusage.setSizeGB(volume.getUsage().getSizeGB());\n\t\t\tusage.setVolumeCnt(1);\n\t\t\tvolume.getInstanceAttachments().put(detachEvent.getInstanceUuid(), usage);\n\t\t}\n\n\t\t\n\t\t/* Perform totals and summations for user, account, and zone\n\t\t */\n\t\tfor (String zoneName : report.getZones().keySet()) {\n\t\t\tAvailabilityZoneArtEntity zone = report.getZones().get(zoneName);\n\t\t\tfor (String accountName : zone.getAccounts().keySet()) {\n\t\t\t\tAccountArtEntity account = zone.getAccounts().get(accountName);\n\t\t\t\tfor (String userName : account.getUsers().keySet()) {\n\t\t\t\t\tUserArtEntity user = account.getUsers().get(userName);\n\t\t\t\t\tfor (String volumeUuid : user.getVolumes().keySet()) {\n\t\t\t\t\t\tVolumeArtEntity volume = user.getVolumes().get(volumeUuid);\n\t\t\t\t\t\tupdateUsageTotals(user.getUsageTotals().getVolumeTotals(), volume.getUsage());\n\t\t\t\t\t\tupdateUsageTotals(account.getUsageTotals().getVolumeTotals(), volume.getUsage());\n\t\t\t\t\t\tupdateUsageTotals(zone.getUsageTotals().getVolumeTotals(), volume.getUsage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\treturn report;\n\t}","commit_id":"f76c08850497cf722de2829b79dfad6f7ef8307a","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ReportArtEntity generateReportArt(ReportArtEntity report)\n\t{\n\t\tlog.debug(\"GENERATING REPORT ART\");\n\t\tEntityWrapper wrapper = EntityWrapper.get( ReportingVolumeCreateEvent.class );\n\n\t\t/* Create super-tree of availZones, accounts, users, and volumes;\n\t\t * and create a Map of the volume nodes at the bottom with start times.\n\t\t */\n\t\tIterator iter = wrapper.scanWithNativeQuery( \"scanVolumeCreateEvents\" );\n\t\tMap<String,VolumeArtEntity> volumeEntities = new HashMap<String,VolumeArtEntity>();\n\t\twhile (iter.hasNext()) {\n\t\t\tReportingVolumeCreateEvent createEvent = (ReportingVolumeCreateEvent) iter.next();\n\t\t\tif (! report.getZones().containsKey(createEvent.getAvailabilityZone())) {\n\t\t\t\treport.getZones().put(createEvent.getAvailabilityZone(), new AvailabilityZoneArtEntity());\n\t\t\t}\n\t\t\tAvailabilityZoneArtEntity zone = report.getZones().get(createEvent.getAvailabilityZone());\n\t\t\t\n\t\t\tReportingUser reportingUser = ReportingUserDao.getInstance().getReportingUser(createEvent.getUserId());\n\t\t\tif (reportingUser==null) {\n\t\t\t\tlog.error(\"No user corresponding to event:\" + createEvent.getUserId());\n\t\t\t}\n\t\t\tReportingAccount reportingAccount = ReportingAccountDao.getInstance().getReportingAccount(reportingUser.getAccountId());\n\t\t\tif (reportingAccount==null) {\n\t\t\t\tlog.error(\"No account corresponding to user:\" + reportingUser.getAccountId());\n\t\t\t}\n\t\t\tif (! zone.getAccounts().containsKey(reportingAccount.getName())) {\n\t\t\t\tzone.getAccounts().put(reportingAccount.getName(), new AccountArtEntity());\n\t\t\t}\n\t\t\tAccountArtEntity account = zone.getAccounts().get(reportingAccount.getName());\n\t\t\tif (! account.getUsers().containsKey(reportingUser.getName())) {\n\t\t\t\taccount.getUsers().put(reportingUser.getName(), new UserArtEntity());\n\t\t\t}\n\t\t\tUserArtEntity user = account.getUsers().get(reportingUser.getName());\n\t\t\tVolumeArtEntity volume = new VolumeArtEntity(createEvent.getVolumeId());\n\t\t\tuser.getVolumes().put(createEvent.getUuid(), volume);\n\t\t\tvolumeEntities.put(createEvent.getUuid(), volume);\n\t\t}\n\t\t\n\n\t\titer = wrapper.scanWithNativeQuery( \"scanVolumeSnapshotCreateEvents\" );\n\t\tMap<String, VolumeSnapshotUsageArtEntity> snapshotEntities = new HashMap<String, VolumeSnapshotUsageArtEntity>();\n\t\tMap<String, Long> snapshotStartTimes = new HashMap<String, Long>();\n\t\twhile (iter.hasNext()) {\n\t\t\tReportingVolumeSnapshotCreateEvent createEvent = (ReportingVolumeSnapshotCreateEvent) iter.next();\n\t\t\tif (createEvent.getTimestampMs() > report.getEndMs()) continue; //not included in this report\n\t\t\tVolumeSnapshotUsageArtEntity usage = new VolumeSnapshotUsageArtEntity();\n\t\t\tusage.setSizeGB(createEvent.getSizeGB());\n\t\t\tusage.setSnapshotNum(1);\n\t\t\t/* Default sizeGB is remainder of report * GB. This will be overwritten later if there's\n\t\t\t * a corresponding delete event before the report end, later.\n\t\t\t */\n\t\t\tusage.setGBSecs(createEvent.getSizeGB() * (report.getEndMs() - createEvent.getTimestampMs()));\n\t\t\tVolumeArtEntity volume = volumeEntities.get(createEvent.getVolumeUuid());\n\t\t\tvolume.getSnapshotUsage().put(createEvent.getVolumeSnapshotId(), usage);\n\t\t\tsnapshotEntities.put(createEvent.getUuid(), usage);\n\t\t\tsnapshotStartTimes.put(createEvent.getUuid(), createEvent.getTimestampMs());\n\t}\n\t\t\n\t\titer = wrapper.scanWithNativeQuery( \"scanVolumeSnapshotDeleteEvents\" );\n\t\twhile (iter.hasNext()) {\n\t\t\tReportingVolumeSnapshotCreateEvent deleteEvent = (ReportingVolumeSnapshotCreateEvent) iter.next();\n\t\t\tif (snapshotEntities.containsKey(deleteEvent.getUuid())) {\n\t\t\t\tVolumeSnapshotUsageArtEntity snap = snapshotEntities.get(deleteEvent.getUuid());\n\t\t\t\tlong startTimeMs = snapshotStartTimes.get(deleteEvent.getUuid()).longValue();\n\t\t\t\tlong duration = DurationCalculator.boundDuration(report.getBeginMs(), report.getEndMs(),\n\t\t\t\t\t\tstartTimeMs, deleteEvent.getTimestampMs());\n\t\t\t\tsnap.setSizeGB(snap.getSizeGB() * duration);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Perform totals and summations for user, account, and zone\n\t\t */\n\t\tfor (String zoneName : report.getZones().keySet()) {\n\t\t\tAvailabilityZoneArtEntity zone = report.getZones().get(zoneName);\n\t\t\tfor (String accountName : zone.getAccounts().keySet()) {\n\t\t\t\tAccountArtEntity account = zone.getAccounts().get(accountName);\n\t\t\t\tfor (String userName : account.getUsers().keySet()) {\n\t\t\t\t\tUserArtEntity user = account.getUsers().get(userName);\n\t\t\t\t\tfor (String volumeUuid : user.getVolumes().keySet()) {\n\t\t\t\t\t\tVolumeArtEntity volume = user.getVolumes().get(volumeUuid);\n\t\t\t\t\t\tfor (String snapId: volume.getSnapshotUsage().keySet()) {\n\t\t\t\t\t\t\tVolumeSnapshotUsageArtEntity snap = volume.getSnapshotUsage().get(snapId);\n\t\t\t\t\t\t\tupdateUsageTotals(volume.getSnapshotTotals(), snap);\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tupdateUsageTotals(user.getUsageTotals().getSnapshotTotals(), snap);\n\t\t\t\t\t\t\tupdateUsageTotals(account.getUsageTotals().getSnapshotTotals(), snap);\n\t\t\t\t\t\t\tupdateUsageTotals(zone.getUsageTotals().getSnapshotTotals(), snap);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\treturn report;\n\t}","id":23627,"modified_method":"public ReportArtEntity generateReportArt(ReportArtEntity report)\n\t{\n\t\tlog.debug(\"GENERATING REPORT ART\");\n\t\tEntityWrapper wrapper = EntityWrapper.get( ReportingVolumeCreateEvent.class );\n\n\t\t/* Create super-tree of availZones, accounts, users, and volumes;\n\t\t * and create a Map of the volume nodes at the bottom with start times.\n\t\t */\n\t\tIterator iter = wrapper.scanWithNativeQuery( \"scanVolumeCreateEvents\" );\n\t\tMap<String,VolumeArtEntity> volumeEntities = new HashMap<String,VolumeArtEntity>();\n\t\twhile (iter.hasNext()) {\n\t\t\tReportingVolumeCreateEvent createEvent = (ReportingVolumeCreateEvent) iter.next();\n\t\t\tif (! report.getZones().containsKey(createEvent.getAvailabilityZone())) {\n\t\t\t\treport.getZones().put(createEvent.getAvailabilityZone(), new AvailabilityZoneArtEntity());\n\t\t\t}\n\t\t\tAvailabilityZoneArtEntity zone = report.getZones().get(createEvent.getAvailabilityZone());\n\t\t\t\n\t\t\tReportingUser reportingUser = ReportingUserDao.getInstance().getReportingUser(createEvent.getUserId());\n\t\t\tif (reportingUser==null) {\n\t\t\t\tlog.error(\"No user corresponding to event:\" + createEvent.getUserId());\n\t\t\t}\n\t\t\tReportingAccount reportingAccount = ReportingAccountDao.getInstance().getReportingAccount(reportingUser.getAccountId());\n\t\t\tif (reportingAccount==null) {\n\t\t\t\tlog.error(\"No account corresponding to user:\" + reportingUser.getAccountId());\n\t\t\t}\n\t\t\tif (! zone.getAccounts().containsKey(reportingAccount.getName())) {\n\t\t\t\tzone.getAccounts().put(reportingAccount.getName(), new AccountArtEntity());\n\t\t\t}\n\t\t\tAccountArtEntity account = zone.getAccounts().get(reportingAccount.getName());\n\t\t\tif (! account.getUsers().containsKey(reportingUser.getName())) {\n\t\t\t\taccount.getUsers().put(reportingUser.getName(), new UserArtEntity());\n\t\t\t}\n\t\t\tUserArtEntity user = account.getUsers().get(reportingUser.getName());\n\t\t\tVolumeArtEntity volume = new VolumeArtEntity(createEvent.getVolumeId());\n\t\t\tuser.getVolumes().put(createEvent.getUuid(), volume);\n\t\t\tvolumeEntities.put(createEvent.getUuid(), volume);\n\t\t}\n\t\t\n\n\t\titer = wrapper.scanWithNativeQuery( \"scanVolumeSnapshotCreateEvents\" );\n\t\tMap<String, VolumeSnapshotUsageArtEntity> snapshotEntities = new HashMap<String, VolumeSnapshotUsageArtEntity>();\n\t\tMap<String, Long> snapshotStartTimes = new HashMap<String, Long>();\n\t\twhile (iter.hasNext()) {\n\t\t\tReportingVolumeSnapshotCreateEvent createEvent = (ReportingVolumeSnapshotCreateEvent) iter.next();\n\t\t\tif (createEvent.getTimestampMs() > report.getEndMs()) continue; //not included in this report\n\t\t\tVolumeSnapshotUsageArtEntity usage = new VolumeSnapshotUsageArtEntity();\n\t\t\tusage.setSizeGB(createEvent.getSizeGB());\n\t\t\tusage.setSnapshotNum(1);\n\t\t\t/* Default sizeGB is remainder of report * GB. This will be overwritten later if there's\n\t\t\t * a corresponding delete event before the report end, later.\n\t\t\t */\n\t\t\tusage.setGBSecs(createEvent.getSizeGB() * DurationCalculator.boundDuration(report.getBeginMs(),\n\t\t\t\t\treport.getEndMs(), createEvent.getTimestampMs()));\n\t\t\tVolumeArtEntity volume = volumeEntities.get(createEvent.getVolumeUuid());\n\t\t\tvolume.getSnapshotUsage().put(createEvent.getVolumeSnapshotId(), usage);\n\t\t\tsnapshotEntities.put(createEvent.getUuid(), usage);\n\t\t\tsnapshotStartTimes.put(createEvent.getUuid(), createEvent.getTimestampMs());\n\t}\n\t\t\n\t\titer = wrapper.scanWithNativeQuery( \"scanVolumeSnapshotDeleteEvents\" );\n\t\twhile (iter.hasNext()) {\n\t\t\tReportingVolumeSnapshotCreateEvent deleteEvent = (ReportingVolumeSnapshotCreateEvent) iter.next();\n\t\t\tif (snapshotEntities.containsKey(deleteEvent.getUuid())) {\n\t\t\t\tVolumeSnapshotUsageArtEntity snap = snapshotEntities.get(deleteEvent.getUuid());\n\t\t\t\tlong startTimeMs = snapshotStartTimes.get(deleteEvent.getUuid()).longValue();\n\t\t\t\tlong duration = DurationCalculator.boundDuration(report.getBeginMs(), report.getEndMs(),\n\t\t\t\t\t\tstartTimeMs, deleteEvent.getTimestampMs());\n\t\t\t\tsnap.setGBSecs(snap.getSizeGB() * duration);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Perform totals and summations for user, account, and zone\n\t\t */\n\t\tfor (String zoneName : report.getZones().keySet()) {\n\t\t\tAvailabilityZoneArtEntity zone = report.getZones().get(zoneName);\n\t\t\tfor (String accountName : zone.getAccounts().keySet()) {\n\t\t\t\tAccountArtEntity account = zone.getAccounts().get(accountName);\n\t\t\t\tfor (String userName : account.getUsers().keySet()) {\n\t\t\t\t\tUserArtEntity user = account.getUsers().get(userName);\n\t\t\t\t\tfor (String volumeUuid : user.getVolumes().keySet()) {\n\t\t\t\t\t\tVolumeArtEntity volume = user.getVolumes().get(volumeUuid);\n\t\t\t\t\t\tfor (String snapId: volume.getSnapshotUsage().keySet()) {\n\t\t\t\t\t\t\tVolumeSnapshotUsageArtEntity snap = volume.getSnapshotUsage().get(snapId);\n\t\t\t\t\t\t\tupdateUsageTotals(volume.getSnapshotTotals(), snap);\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tupdateUsageTotals(user.getUsageTotals().getSnapshotTotals(), snap);\n\t\t\t\t\t\t\tupdateUsageTotals(account.getUsageTotals().getSnapshotTotals(), snap);\n\t\t\t\t\t\t\tupdateUsageTotals(zone.getUsageTotals().getSnapshotTotals(), snap);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\treturn report;\n\t}","commit_id":"f76c08850497cf722de2829b79dfad6f7ef8307a","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void setGBSecs(long gBSecs)\n\t{\n\t\tthis.gBSecs = gBSecs;\n\t}","id":23628,"modified_method":"public void setGBSecs(long gBSecs)\n\t{\n\t\tif (gBSecs < 0) throw new IllegalArgumentException(\"gBSecs can't be negative\");\n\t\tthis.gBSecs = gBSecs;\n\t}","commit_id":"f76c08850497cf722de2829b79dfad6f7ef8307a","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void setGBSecs(long gBSecs)\n\t{\n\t\tthis.gBSecs = gBSecs;\n\t}","id":23629,"modified_method":"public void setGBSecs(long gBSecs)\n\t{\n\t\tif (gBSecs < 0) throw new IllegalArgumentException(\"gBSecs can't be negative\");\n\t\tthis.gBSecs = gBSecs;\n\t}","commit_id":"f76c08850497cf722de2829b79dfad6f7ef8307a","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\tpublic ReportArtEntity generateReportArt( final ReportArtEntity report )\n\t{\n\t\tlog.debug(\"Generating report ART\");\n\n\t\t// Find end times for the elastic ips (key is uuid)\n\t\tfinal Map<String,List<Long>> ipToDeleteTimesMap = Maps.newHashMap();\n\t\tforeachElasticIpDeleteEvent( buildTimestampMap( report, ipToDeleteTimesMap ) );\n\n\t\t// cache for user/account info\n\t\tfinal Map<String,ReportingUser> reportingUsersById = Maps.newHashMap();\n\t\tfinal Map<String,String> accountNamesById = Maps.newHashMap();\n\n\t\t/* Create super-tree of availZones, clusters, accounts, users, and instances;\n\t\t * and create a Map of the instance nodes at the bottom.\n\t\t */\n\t\tfinal Map<String,List<ElasticIpAllocation>> ipUuidToAllocationListMap = Maps.newHashMap();\n\t\tforeachElasticIpCreateEvent( new Predicate<ReportingElasticIpCreateEvent>() {\n\t\t\t@Override\n\t\t\tpublic boolean apply( final ReportingElasticIpCreateEvent createEvent ) {\n\t\t\t\tfinal Long deleteTime = findTimeAfter( ipToDeleteTimesMap, createEvent.getUuid(), createEvent.getTimestampMs() );\n\t\t\t\tif ( deleteTime < report.getBeginMs() ) {\n\t\t\t\t\treturn true; // usage not relevant for this report\n\t\t\t\t}\n\t\t\t\tif ( createEvent.getTimestampMs() > report.getEndMs() ) {\n\t\t\t\t\treturn false; // end of relevant events for this report\n\t\t\t\t}\n\t\t\t\tfinal ReportingUser reportingUser = getUserById( reportingUsersById, createEvent.getUserId() );\n\t\t\t\tif (reportingUser==null) {\n\t\t\t\t\tlog.error(\"No user corresponding to event:\" + createEvent.getUserId() + \" \" + createEvent.getUuid());\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tfinal String accountName = getAccountNameById( accountNamesById, reportingUser.getAccountId() );\n\t\t\t\tif (accountName==null) {\n\t\t\t\t\tlog.error(\"No account corresponding to user:\" + reportingUser.getAccountId()+ \" \" + createEvent.getUuid());\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tList<ElasticIpAllocation> allocations = ipUuidToAllocationListMap.get( createEvent.getUuid() );\n\t\t\t\tif ( allocations == null ) {\n\t\t\t\t\tallocations = Lists.newArrayList();\n\t\t\t\t\tipUuidToAllocationListMap.put( createEvent.getUuid(), allocations );\n\t\t\t\t}\n\t\t\t\tallocations.add( new ElasticIpAllocation( accountName, reportingUser.getName(), createEvent.getIp(), createEvent.getTimestampMs(), deleteTime ) );\n\t\t\t\tfinal AccountArtEntity account;\n\t\t\t\tif (!report.getAccounts().containsKey(accountName)) {\n\t\t\t\t\taccount = new AccountArtEntity();\n\t\t\t\t\treport.getAccounts().put(accountName, account);\n\t\t\t\t} else {\n\t\t\t\t\taccount = report.getAccounts().get(accountName);\n\t\t\t\t}\n\t\t\t\tfinal UserArtEntity user;\n\t\t\t\tif (!account.getUsers().containsKey(reportingUser.getName())) {\n\t\t\t\t\tuser = new UserArtEntity();\n\t\t\t\t\taccount.getUsers().put(reportingUser.getName(), user);\n\t\t\t\t} else {\n\t\t\t\t\tuser = account.getUsers().get(reportingUser.getName());\n\t\t\t\t}\n\t\t\t\tfinal ElasticIpArtEntity elasticIp;\n\t\t\t\tif (!user.getElasticIps().containsKey(createEvent.getIp())) {\n\t\t\t\t\telasticIp = new ElasticIpArtEntity();\n\t\t\t\t\telasticIp.getUsage().setIpNum(1);\n\t\t\t\t\tuser.getElasticIps().put(createEvent.getIp(), elasticIp);\n\t\t\t\t} else {\n\t\t\t\t\telasticIp = user.getElasticIps().get(createEvent.getIp());\n\t\t\t\t}\n\t\t\t\telasticIp.getUsage().setDurationMs( elasticIp.getUsage().getDurationMs() + calculateDuration( report, createEvent.getTimestampMs(), deleteTime ) );\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} );\n\n\n\t\t/* Scan instance entities so we can get the instance id from the uuid\n\t\t\t\t */\n\t\tfinal Map<String,InstanceArtEntity> instanceEntities = Maps.newHashMap();\n\t\tforeachInstanceCreateEvent( new Predicate<ReportingInstanceCreateEvent>() {\n\t\t\t@Override\n\t\t\tpublic boolean apply( final ReportingInstanceCreateEvent createEvent ) {\n\t\t\t\tif ( createEvent.getTimestampMs() > report.getEndMs() ) {\n\t\t\t\t\treturn false; // end of relevant events for this report\n\t\t\t\t}\n\t\t\t\tfinal InstanceArtEntity instance = new InstanceArtEntity(createEvent.getInstanceType(), createEvent.getInstanceId());\n\t\t\t\tinstanceEntities.put(createEvent.getUuid(), instance);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} );\n\n\t\t// Find end times for the elastic ips (key is uuid)\n\t\tfinal Map<String,List<Long>> ipToDetachTimesMap = Maps.newHashMap();\n\t\tforeachElasticIpDetachEvent( buildTimestampMap( report, ipToDetachTimesMap ) );\n\n\t\t/* Find attachment start times\n\t\t\t\t */\n\t\tforeachElasticIpAttachEvent( new Predicate<ReportingElasticIpAttachEvent>() {\n\t\t\t@Override\n\t\t\tpublic boolean apply( final ReportingElasticIpAttachEvent attachEvent ) {\n\t\t\t\t// tolerate missing detach events by accounting for delete events also\n\t\t\t\tfinal Long deleteTime = findTimeAfter( ipToDeleteTimesMap, attachEvent.getIpUuid(), attachEvent.getTimestampMs() );\n\t\t\t\tfinal Long detachTime = Math.min( deleteTime, findTimeAfter( ipToDetachTimesMap, attachEvent.getIpUuid(), attachEvent.getTimestampMs() ));\n\t\t\t\tif ( detachTime < report.getBeginMs() ) {\n\t\t\t\t\treturn true; // usage not relevant for this report\n\t\t\t\t}\n\t\t\t\tif ( attachEvent.getTimestampMs() > report.getEndMs() ) {\n\t\t\t\t\treturn false; // end of relevant events for this report\n\t\t\t\t}\n\t\t\t\tfinal Long attachmentDuration = calculateDuration( report, attachEvent.getTimestampMs(), detachTime );\n\t\t\t\tfinal ElasticIpArtEntity entity = findEntityForTimestamp( report, ipUuidToAllocationListMap, attachEvent.getIpUuid(), attachEvent.getTimestampMs() );\n\t\t\t\tif ( entity == null ) {\n\t\t\t\t\tlog.error(\"Unable to find elastic ip owner for attachment, instance uuid: \" + attachEvent.getInstanceUuid() );\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tfinal InstanceArtEntity instance = instanceEntities.get( attachEvent.getInstanceUuid() );\n\t\t\t\tif ( instance == null ) {\n\t\t\t\t\tlog.error(\"Unable to find instance for attachment, instance uuid: \" + attachEvent.getInstanceUuid() );\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tElasticIpUsageArtEntity usage = entity.getInstanceAttachments().get( instance.getInstanceId() );\n\t\t\t\tif ( usage == null ) {\n\t\t\t\t\tusage = new ElasticIpUsageArtEntity();\n\t\t\t\t\tusage.setIpNum( 1 );\n\t\t\t\t\tentity.getInstanceAttachments().put(  instance.getInstanceId(), usage );\n\t\t\t\t}\n\t\t\t\tusage.setDurationMs( usage.getDurationMs() + attachmentDuration );\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} );\n\n\t\t/* Perform totals and summations for user, account, and global\n\t\t */\n\t\tfor( final AccountArtEntity account : report.getAccounts().values() ) {\n\t\t\tfor( final UserArtEntity user  : account.getUsers().values() ) {\n\t\t\t\tfor( final ElasticIpArtEntity ip : user.getElasticIps().values() ) {\n\t\t\t\t\tupdateUsageTotals(user.getUsageTotals().getElasticIpTotals(), ip.getUsage());\n\t\t\t\t\tupdateUsageTotals(account.getUsageTotals().getElasticIpTotals(), ip.getUsage());\n\t\t\t\t\tupdateUsageTotals(report.getUsageTotals().getElasticIpTotals(), ip.getUsage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn report;\n\t}","id":23630,"modified_method":"@Override\n\tpublic ReportArtEntity generateReportArt( final ReportArtEntity report )\n\t{\n\t\tlog.debug(\"Generating report ART\");\n\n\t\t// Find end times for the elastic ips (key is uuid)\n\t\tfinal Map<String,List<Long>> ipToDeleteTimesMap = Maps.newHashMap();\n\t\tforeachElasticIpDeleteEvent( buildTimestampMap( report, ipToDeleteTimesMap, ipUuid() ) );\n\n\t\t// cache for user/account info\n\t\tfinal Map<String,ReportingUser> reportingUsersById = Maps.newHashMap();\n\t\tfinal Map<String,String> accountNamesById = Maps.newHashMap();\n\n\t\t/* Create super-tree of availZones, clusters, accounts, users, and instances;\n\t\t * and create a Map of the instance nodes at the bottom.\n\t\t */\n\t\tfinal Map<String,List<ElasticIpAllocation>> ipUuidToAllocationListMap = Maps.newHashMap();\n\t\tforeachElasticIpCreateEvent( new Predicate<ReportingElasticIpCreateEvent>() {\n\t\t\t@Override\n\t\t\tpublic boolean apply( final ReportingElasticIpCreateEvent createEvent ) {\n\t\t\t\tfinal Long deleteTime = findTimeAfter( ipToDeleteTimesMap, createEvent.getUuid(), createEvent.getTimestampMs() );\n\t\t\t\tif ( deleteTime < report.getBeginMs() ) {\n\t\t\t\t\treturn true; // usage not relevant for this report\n\t\t\t\t}\n\t\t\t\tif ( createEvent.getTimestampMs() > report.getEndMs() ) {\n\t\t\t\t\treturn false; // end of relevant events for this report\n\t\t\t\t}\n\t\t\t\tfinal ReportingUser reportingUser = getUserById( reportingUsersById, createEvent.getUserId() );\n\t\t\t\tif (reportingUser==null) {\n\t\t\t\t\tlog.error(\"No user corresponding to event:\" + createEvent.getUserId() + \" \" + createEvent.getUuid());\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tfinal String accountName = getAccountNameById( accountNamesById, reportingUser.getAccountId() );\n\t\t\t\tif (accountName==null) {\n\t\t\t\t\tlog.error(\"No account corresponding to user:\" + reportingUser.getAccountId()+ \" \" + createEvent.getUuid());\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tList<ElasticIpAllocation> allocations = ipUuidToAllocationListMap.get( createEvent.getUuid() );\n\t\t\t\tif ( allocations == null ) {\n\t\t\t\t\tallocations = Lists.newArrayList();\n\t\t\t\t\tipUuidToAllocationListMap.put( createEvent.getUuid(), allocations );\n\t\t\t\t}\n\t\t\t\tallocations.add( new ElasticIpAllocation( accountName, reportingUser.getName(), createEvent.getIp(), createEvent.getTimestampMs(), deleteTime ) );\n\t\t\t\tfinal AccountArtEntity account;\n\t\t\t\tif (!report.getAccounts().containsKey(accountName)) {\n\t\t\t\t\taccount = new AccountArtEntity();\n\t\t\t\t\treport.getAccounts().put(accountName, account);\n\t\t\t\t} else {\n\t\t\t\t\taccount = report.getAccounts().get(accountName);\n\t\t\t\t}\n\t\t\t\tfinal UserArtEntity user;\n\t\t\t\tif (!account.getUsers().containsKey(reportingUser.getName())) {\n\t\t\t\t\tuser = new UserArtEntity();\n\t\t\t\t\taccount.getUsers().put(reportingUser.getName(), user);\n\t\t\t\t} else {\n\t\t\t\t\tuser = account.getUsers().get(reportingUser.getName());\n\t\t\t\t}\n\t\t\t\tfinal ElasticIpArtEntity elasticIp;\n\t\t\t\tif (!user.getElasticIps().containsKey(createEvent.getIp())) {\n\t\t\t\t\telasticIp = new ElasticIpArtEntity();\n\t\t\t\t\telasticIp.getUsage().setIpNum(1);\n\t\t\t\t\tuser.getElasticIps().put(createEvent.getIp(), elasticIp);\n\t\t\t\t} else {\n\t\t\t\t\telasticIp = user.getElasticIps().get(createEvent.getIp());\n\t\t\t\t}\n\t\t\t\telasticIp.getUsage().setDurationMs( elasticIp.getUsage().getDurationMs() + calculateDuration( report, createEvent.getTimestampMs(), deleteTime ) );\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} );\n\n\n\t\t/* Scan instance entities so we can get the instance id from the uuid\n\t\t\t\t */\n\t\tfinal Map<String,InstanceArtEntity> instanceEntities = Maps.newHashMap();\n\t\tforeachInstanceCreateEvent( new Predicate<ReportingInstanceCreateEvent>() {\n\t\t\t@Override\n\t\t\tpublic boolean apply( final ReportingInstanceCreateEvent createEvent ) {\n\t\t\t\tif ( createEvent.getTimestampMs() > report.getEndMs() ) {\n\t\t\t\t\treturn false; // end of relevant events for this report\n\t\t\t\t}\n\t\t\t\tfinal InstanceArtEntity instance = new InstanceArtEntity(createEvent.getInstanceType(), createEvent.getInstanceId());\n\t\t\t\tinstanceEntities.put(createEvent.getUuid(), instance);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} );\n\n\t\t// Find end times for the elastic ips (key is uuid)\n\t\tfinal Map<String,List<Long>> ipToDetachTimesMap = Maps.newHashMap();\n\t\tforeachElasticIpDetachEvent( buildTimestampMap( report, ipToDetachTimesMap, ipUuid() ) );\n\n\t\t/* Find attachment start times\n\t\t\t\t */\n\t\tforeachElasticIpAttachEvent( new Predicate<ReportingElasticIpAttachEvent>() {\n\t\t\t@Override\n\t\t\tpublic boolean apply( final ReportingElasticIpAttachEvent attachEvent ) {\n\t\t\t\t// tolerate missing detach events by accounting for delete events also\n\t\t\t\tfinal Long deleteTime = findTimeAfter( ipToDeleteTimesMap, attachEvent.getIpUuid(), attachEvent.getTimestampMs() );\n\t\t\t\tfinal Long detachTime = Math.min( deleteTime, findTimeAfter( ipToDetachTimesMap, attachEvent.getIpUuid(), attachEvent.getTimestampMs() ));\n\t\t\t\tif ( detachTime < report.getBeginMs() ) {\n\t\t\t\t\treturn true; // usage not relevant for this report\n\t\t\t\t}\n\t\t\t\tif ( attachEvent.getTimestampMs() > report.getEndMs() ) {\n\t\t\t\t\treturn false; // end of relevant events for this report\n\t\t\t\t}\n\t\t\t\tfinal Long attachmentDuration = calculateDuration( report, attachEvent.getTimestampMs(), detachTime );\n\t\t\t\tfinal ElasticIpArtEntity entity = findEntityForTimestamp( report, ipUuidToAllocationListMap, attachEvent.getIpUuid(), attachEvent.getTimestampMs() );\n\t\t\t\tif ( entity == null ) {\n\t\t\t\t\tlog.error(\"Unable to find elastic ip owner for attachment, instance uuid: \" + attachEvent.getInstanceUuid() );\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tfinal InstanceArtEntity instance = instanceEntities.get( attachEvent.getInstanceUuid() );\n\t\t\t\tif ( instance == null ) {\n\t\t\t\t\tlog.error(\"Unable to find instance for attachment, instance uuid: \" + attachEvent.getInstanceUuid() );\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tElasticIpUsageArtEntity usage = entity.getInstanceAttachments().get( instance.getInstanceId() );\n\t\t\t\tif ( usage == null ) {\n\t\t\t\t\tusage = new ElasticIpUsageArtEntity();\n\t\t\t\t\tusage.setIpNum( 1 );\n\t\t\t\t\tentity.getInstanceAttachments().put(  instance.getInstanceId(), usage );\n\t\t\t\t}\n\t\t\t\tusage.setDurationMs( usage.getDurationMs() + attachmentDuration );\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} );\n\n\t\t/* Perform totals and summations for user, account, and global\n\t\t */\n\t\tfor( final AccountArtEntity account : report.getAccounts().values() ) {\n\t\t\tfor( final UserArtEntity user  : account.getUsers().values() ) {\n\t\t\t\tfor( final ElasticIpArtEntity ip : user.getElasticIps().values() ) {\n\t\t\t\t\tupdateUsageTotals(user.getUsageTotals().getElasticIpTotals(), ip.getUsage());\n\t\t\t\t\tupdateUsageTotals(account.getUsageTotals().getElasticIpTotals(), ip.getUsage());\n\t\t\t\t\tupdateUsageTotals(report.getUsageTotals().getElasticIpTotals(), ip.getUsage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn report;\n\t}","commit_id":"0376335bb7631f7c927feb45c63adfb5fbd1b30f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"protected ReportingS3ObjectDeleteEvent(String s3BucketName, String s3ObjectName, String objectVersion,\n\t\t\tLong timestampMs)\n\t{\n\t\tthis.s3BucketName = s3BucketName;\n\t\tthis.s3ObjectKey = s3ObjectName;\n\t\tthis.objectVersion = objectVersion;\n\t\tthis.timestampMs = timestampMs;\n\t}","id":23631,"modified_method":"protected ReportingS3ObjectDeleteEvent(String s3BucketName, String s3ObjectKey, String objectVersion,\n\t\t\tLong timestampMs)\n\t{\n\t\tthis.s3BucketName = s3BucketName;\n\t\tthis.s3ObjectKey = s3ObjectKey;\n\t\tthis.objectVersion = objectVersion;\n\t\tthis.timestampMs = timestampMs;\n\t}","commit_id":"0376335bb7631f7c927feb45c63adfb5fbd1b30f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ReportArtEntity generateReportArt(final ReportArtEntity report)\n\t{\n\t\tlog.debug(\"GENERATING REPORT ART\");\n\n\t\t/* NOTE: careful! This is subtler than it appears at first. A single object can\n\t\t * be repeatedly created and deleted within the period, so we cannot just hang on\n\t\t * to start times and end times then subtract at the end. Furthermore, an object\n\t\t * can be created but never deleted.\n\t\t */\n\t\t\n\t\t/* Generate a tree of zones, accounts, users, and bucket usages.\n\t\t * Retain a Map of bucket usages at the leaf nodes.\n\t\t * Find and retain start times and sizes for S3 objects.\n\t\t * Set default object duration to the remaining of report (in case no\n\t\t *   subsequent delete event is ever encountered), to be overwritten\n\t\t *   if there is later found a delete event (or multiple delete events).\n\t\t */\n\t\tfinal Map<String,BucketUsageArtEntity> bucketUsageEntities = new HashMap<String,BucketUsageArtEntity>();\n\t\tfinal Map<S3ObjectKey,S3ObjectData> objectData = new HashMap<S3ObjectKey,S3ObjectData>();\n\t\tfinal DurationCalculator<S3ObjectKey> objectDurationCalculator = new DurationCalculator<S3ObjectKey>(report.getBeginMs(),report.getEndMs());\n\t\tforeachReportingS3ObjectCreateEvent( report.getEndMs(), new Predicate<ReportingS3ObjectCreateEvent>() {\n\t\t\t@Override\n\t\t\tpublic boolean apply( final ReportingS3ObjectCreateEvent createEvent ) {\n\t\t\t\n\t\t\t\tReportingUser reportingUser = ReportingUserDao.getInstance().getReportingUser(createEvent.getUserId());\n\t\t\t\tif (reportingUser==null) {\n\t\t\t\t\tlog.error(\"No user corresponding to event:\" + createEvent.getUserId());\n\t\t\t\t}\n\t\t\t\tReportingAccount reportingAccount = ReportingAccountDao.getInstance().getReportingAccount(reportingUser.getAccountId());\n\t\t\t\tif (reportingAccount==null) {\n\t\t\t\t\tlog.error(\"No account corresponding to user:\" + reportingUser.getAccountId());\n\t\t\t\t}\n\t\t\t\tif (! report.getAccounts().containsKey(reportingAccount.getName())) {\n\t\t\t\t\treport.getAccounts().put(reportingAccount.getName(), new AccountArtEntity());\n\t\t\t\t}\n\t\t\t\tAccountArtEntity account = report.getAccounts().get(reportingAccount.getName());\n\t\t\t\tif (! account.getUsers().containsKey(reportingUser.getName())) {\n\t\t\t\t\taccount.getUsers().put(reportingUser.getName(), new UserArtEntity());\n\t\t\t\t}\n\t\t\t\tUserArtEntity user = account.getUsers().get(reportingUser.getName());\n\t\t\t\tif (! user.getBucketUsage().containsKey(createEvent.getS3BucketName())) {\n\t\t\t\t\tuser.getBucketUsage().put(createEvent.getS3BucketName(), new BucketUsageArtEntity());\n\t\t\t\t}\n\t\t\t\tBucketUsageArtEntity bucketUsage = user.getBucketUsage().get(createEvent.getS3BucketName());\n\t\t\t\tbucketUsageEntities.put(createEvent.getS3BucketName(), bucketUsage);\n\n\t\t\t\tS3ObjectKey objectKey = new S3ObjectKey(createEvent.getS3BucketName(),\n\t\t\t\t\t\tcreateEvent.getS3ObjectKey(), createEvent.getObjectVersion());\n\t\t\t\t/* A duration calculator, rather than a simple Map of start and end times,\n\t\t\t\t * is necessary here. This is because a single object can be subsequently\n\t\t\t\t * created and deleted within the period.\n\t\t\t\t */\n\t\t\t\tobjectDurationCalculator.addStart(objectKey, createEvent.getTimestampMs());\n\t\t\t\t/* Retain the information necessary to calculate GB-secs from object durations\n\t\t\t\t * later. The default duration is the remaining length of the report but this\n\t\t\t\t * will be overwritten later if we encounter a delete event (or multiple delete\n\t\t\t\t * events) for an object before the end of the report.\n\t\t\t\t */\n\t\t\t\tobjectData.put(objectKey, new S3ObjectData(createEvent.getSize()));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\t\n\t\t/* Find end timestamps for objects which are subsequently deleted, including\n\t\t * objects which are created and deleted repeatedly during a single period, which\n\t\t * is the purpose of using the duration calculator rather than just keeping a Map\n\t\t * of start and end times. \n\t\t */\n\t\tforeachReportingS3ObjectDeleteEvent( report.getEndMs(), new Predicate<ReportingS3ObjectDeleteEvent>() {\n\t\t\t@Override\n\t\t\tpublic boolean apply( final ReportingS3ObjectDeleteEvent deleteEvent ) {\n\t\t\t\tif (deleteEvent.getTimestampMs() < report.getEndMs()) {\n\t\t\t\t\tS3ObjectKey key = new S3ObjectKey(deleteEvent.getS3BucketName(), deleteEvent.getS3ObjectKey(),\n\t\t\t\t\t\t\tdeleteEvent.getObjectVersion());\n\t\t\t\t\tobjectDurationCalculator.addEnd(key, deleteEvent.getTimestampMs());\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tMap<S3ObjectKey,Long> durationMap = objectDurationCalculator.getDurationMap();\n\t\tfor (S3ObjectKey key: durationMap.keySet()) {\n\t\t\tif (objectData.containsKey(key)) {\n\t\t\t\tobjectData.get(key).durationMs = durationMap.get(key);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Go through all object data and update buckets\n\t\t */\n\t\tfor (S3ObjectKey objKey : objectData.keySet()) {\n\t\t\tS3ObjectData data = objectData.get(objKey);\n\t\t\tif (bucketUsageEntities.containsKey(objKey.bucketName)) {\n\t\t\t\tBucketUsageArtEntity usage = bucketUsageEntities.get(objKey.bucketName);\n\t\t\t\tusage.setObjectsNum(usage.getObjectsNum()+1);\n\t\t\t\tlong gBSecs = (data.durationMs/1000) * //TODO:STEVE: should sum first then calc GB secs\n\t\t\t\t\t\tUnitUtil.convertSize( data.size, SizeUnit.BYTES, SizeUnit.GB );\n\t\t\t\tusage.setGBSecs( usage.getGBSecs() + gBSecs );\n\t\t\t\tusage.setSize( usage.getSize() + data.size );\n\t\t\t} else {\n\t\t\t\tlog.error(\"Object without corresponding bucket:\" + objKey.bucketName);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Perform totals and summations for user, account, zone, and bucket\n\t\t */\n\t\tfor (String accountName : report.getAccounts().keySet()) {\n\t\t\tAccountArtEntity account = report.getAccounts().get(accountName);\n\t\t\tfor (String userName : account.getUsers().keySet()) {\n\t\t\t\tUserArtEntity user = account.getUsers().get(userName);\n\t\t\t\tfor (String bucketName : user.getBucketUsage().keySet()) {\n\t\t\t\t\tBucketUsageArtEntity usage = user.getBucketUsage().get(bucketName);\n\t\t\t\t\tupdateUsageTotals(user.getUsageTotals().getBucketTotals(), usage);\n\t\t\t\t\tupdateUsageTotals(account.getUsageTotals().getBucketTotals(), usage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\treturn report;\n\t}","id":23632,"modified_method":"@Override\n  public ReportArtEntity generateReportArt(final ReportArtEntity report)\n\t{\n\t\tlog.debug(\"Generating S3 report ART\");\n\n\t\t/* NOTE: careful! This is subtler than it appears at first. A single object can\n\t\t * be repeatedly created and deleted within the period, so we cannot just hang on\n\t\t * to start times and end times then subtract at the end. Furthermore, an object\n\t\t * can be created but never deleted.\n\t\t */\n\n\t\t/* Find end timestamps for objects which are subsequently deleted, including\n\t\t\t\t * objects which are created and deleted repeatedly during a single period.\n\t\t\t\t */\n\t\tfinal Map<S3ObjectKey,List<Long>> endTimesMap = Maps.newHashMap();\n\t\tforeachReportingS3ObjectDeleteEvent( report.getEndMs(), buildTimestampMap( report, endTimesMap, key() ) );\n\n\t\t/* Generate a tree of zones, accounts, users, and bucket usages.\n\t\t * Retain a Map of bucket usages at the leaf nodes.\n\t\t * Find and retain start times and sizes for S3 objects.\n\t\t * Set default object duration to the remaining of report (in case no\n\t\t *   subsequent delete event is ever encountered), to be overwritten\n\t\t *   if there is later found a delete event (or multiple delete events).\n\t\t */\n\t\tfinal Map<String,ReportingUser> users = Maps.newHashMap();\n\t\tfinal Map<String,String> accounts = Maps.newHashMap();\n\t\tfinal Map<BucketUsageArtEntity,List<S3ObjectData>> bucketObjectData = Maps.newHashMap();\n\t\tforeachReportingS3ObjectCreateEvent( report.getEndMs(), new Predicate<ReportingS3ObjectCreateEvent>() {\n\t\t\t@Override\n\t\t\tpublic boolean apply( final ReportingS3ObjectCreateEvent createEvent ) {\n\t\t\t\tfinal S3ObjectKey objectKey = new S3ObjectKey(createEvent.getS3BucketName(),\n\t\t\t\t\t\tcreateEvent.getS3ObjectKey(), createEvent.getObjectVersion());\n\t\t\t\tfinal Long objectEndTime = Math.min( findTimeAfter( endTimesMap, objectKey, createEvent.getTimestampMs() ), report.getEndMs() );\n\t\t\t\tif ( objectEndTime < report.getBeginMs() ) {\n\t\t\t\t\treturn true; // usage not relevant for this report\n\t\t\t\t}\n\t\t\t\tfinal ReportingUser reportingUser = getUserById( users, createEvent.getUserId() );\n\t\t\t\tif (reportingUser==null) {\n\t\t\t\t\tlog.error(\"No user corresponding to event:\" + createEvent.getUserId());\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tfinal String accountName = getAccountNameById( accounts, reportingUser.getAccountId() );\n\t\t\t\tif (accountName==null) {\n\t\t\t\t\tlog.error(\"No account corresponding to user:\" + reportingUser.getAccountId());\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!report.getAccounts().containsKey( accountName )) {\n\t\t\t\t\treport.getAccounts().put(accountName, new AccountArtEntity());\n\t\t\t\t}\n\t\t\t\tfinal AccountArtEntity account = report.getAccounts().get(accountName);\n\t\t\t\tif (! account.getUsers().containsKey(reportingUser.getName())) {\n\t\t\t\t\taccount.getUsers().put(reportingUser.getName(), new UserArtEntity());\n\t\t\t\t}\n\t\t\t\tfinal UserArtEntity user = account.getUsers().get(reportingUser.getName());\n\t\t\t\tif (! user.getBucketUsage().containsKey(createEvent.getS3BucketName())) {\n\t\t\t\t\tuser.getBucketUsage().put(createEvent.getS3BucketName(), new BucketUsageArtEntity());\n\t\t\t\t}\n\t\t\t\tfinal BucketUsageArtEntity bucketUsage = user.getBucketUsage().get(createEvent.getS3BucketName());\n\n\t\t\t\t/* Retain the information necessary to calculate GB-secs from object durations\n\t\t\t\t * later.\n\t\t\t\t */\n\t\t\t\tfinal S3ObjectData data = new S3ObjectData(\n\t\t\t\t\t\tcreateEvent.getSize(),\n\t\t\t\t\t\tobjectEndTime - Math.max(createEvent.getTimestampMs(),report.getBeginMs()) );\n\t\t\t\tList<S3ObjectData> bucketUserData = bucketObjectData.get( bucketUsage );\n\t\t\t\tif ( bucketUserData == null ) {\n\t\t\t\t\tbucketUserData = Lists.newLinkedList();\n\t\t\t\t\tbucketObjectData.put( bucketUsage, bucketUserData );\n\t\t\t\t}\n\t\t\t\tbucketUserData.add(data);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\t\n\t\t/* Perform totals and summations for user, account, zone, and bucket\n\t\t */\n\t\tfor ( final String accountName : report.getAccounts().keySet() ) {\n\t\t\tfinal AccountArtEntity account = report.getAccounts().get(accountName);\n\t\t\tfor ( final String userName : account.getUsers().keySet() ) {\n\t\t\t\tfinal UserArtEntity user = account.getUsers().get(userName);\n\t\t\t\tfor ( final String bucketName : user.getBucketUsage().keySet() ) {\n\t\t\t\t\tfinal BucketUsageArtEntity usage = user.getBucketUsage().get(bucketName);\n\t\t\t\t\tfinal List<S3ObjectData> objectUsages = bucketObjectData.get( usage );\n\t\t\t\t\tif ( objectUsages == null ) {\n\t\t\t\t\t\tlog.error(\"Missing object usage for bucket\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tusage.setObjectsNum( objectUsages.size() );\n\t\t\t\t\tlong size = 0;\n\t\t\t\t\tlong KBSecs = 0;\n\t\t\t\t\tfor ( final S3ObjectData data : objectUsages ) {\n\t\t\t\t\t\tsize += data.size;\n\t\t\t\t\t\tKBSecs += (data.durationMs/1000) *\n\t\t\t\t\t\t\t\tUnitUtil.convertSize( data.size, SizeUnit.BYTES, SizeUnit.KB );\n\t\t\t\t\t}\n\n\t\t\t\t\tlong gBSecs =\n\t\t\t\t\t\t\tUnitUtil.convertSizeTime( KBSecs, SizeUnit.KB,  SizeUnit.GB, TimeUnit.SECS,TimeUnit.SECS );\n\t\t\t\t\tusage.setGBSecs( gBSecs );\n\t\t\t\t\tusage.setSize( size );\n\t\t\t\t\tupdateUsageTotals(user.getUsageTotals().getBucketTotals(), usage);\n\t\t\t\t\tupdateUsageTotals(account.getUsageTotals().getBucketTotals(), usage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn report;\n\t}","commit_id":"0376335bb7631f7c927feb45c63adfb5fbd1b30f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private S3ObjectData(long size)\n\t\t{\n\t\t\tthis.durationMs = 0l;\n\t\t\tthis.size = size;\n\t\t}","id":23633,"modified_method":"private S3ObjectData( final long size, final long durationMs )\n\t\t{\n\t\t\tthis.durationMs = durationMs;\n\t\t\tthis.size = size;\n\t\t}","commit_id":"0376335bb7631f7c927feb45c63adfb5fbd1b30f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static void updateUsageTotals(BucketUsageArtEntity totalEntity,\n\t\t\tBucketUsageArtEntity newEntity)\n\t{\n\n\t\ttotalEntity.setObjectsNum(totalEntity.getObjectsNum() + newEntity.getObjectsNum());\n\t\ttotalEntity.setSize( totalEntity.getSize() + newEntity.getSize() );\n\t\ttotalEntity.setGBSecs(totalEntity.getGBSecs() + newEntity.getGBSecs());\n\t\ttotalEntity.setNumGetRequests(totalEntity.getNumGetRequests() + newEntity.getNumGetRequests());\n\t\ttotalEntity.setNumPutRequests(totalEntity.getNumPutRequests() + newEntity.getNumPutRequests());\n\n\t}","id":23634,"modified_method":"private static void updateUsageTotals(\n\t\t\tBucketUsageArtEntity totalEntity,\n\t\t\tBucketUsageArtEntity newEntity)\n\t{\n\t\ttotalEntity.setObjectsNum( totalEntity.getObjectsNum() + newEntity.getObjectsNum() );\n\t\ttotalEntity.setSize( totalEntity.getSize() + newEntity.getSize() );\n\t\ttotalEntity.setGBSecs( totalEntity.getGBSecs() + newEntity.getGBSecs() );\n\t}","commit_id":"0376335bb7631f7c927feb45c63adfb5fbd1b30f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public int resetForMethodEntry(final DismantleBytecode v) {\n\t\tjumpEntries.clear();\n \t\tint result= resetForMethodEntry0(v);\n \t\tCode code = v.getMethod().getCode();\n\t\tif (code == null) return result;\n\t\n\t\tif (false) {\n\t\t\t// Be clever\n\t\t\t\n \t\tDismantleBytecode branchAnalysis = new DismantleBytecode() {\n \t \t\t@Override\n \t \t\tpublic void sawOpcode(int seen) {\n \t \t\t\tOpcodeStack.this.sawOpcode(this,seen);\n \t \t\t}\n \t \t\t@Override\n \t \t\tpublic void sawBranchTo(int pc) {\n \t \t\t\taddJumpValue(pc);\n \t \t\t}\n \t \t};\n \t \tbranchAnalysis.setupVisitorForClass(v.getThisClass());\n \t \tbranchAnalysis.doVisitMethod(v.getMethod());\n \t \tresetForMethodEntry0(v);\n\t\t}\n \t\n \t\treturn result;\n \t\n\t\t}","id":23635,"modified_method":"public int resetForMethodEntry(final DismantleBytecode v) {\n\t\tjumpEntries.clear();\n \t\tint result= resetForMethodEntry0(v);\n \t\tCode code = v.getMethod().getCode();\n\t\tif (code == null) return result;\n\t\n\t\tif (false) {\n\t\t\t// Be clever\n\t\t\t\n \t\tDismantleBytecode branchAnalysis = new DismantleBytecode() {\n \t \t\t@Override\n \t \t\tpublic void sawOpcode(int seen) {\n \t \t\t\tOpcodeStack.this.sawOpcode(this,seen);\n \t \t\t}\n \t \t\t@Override\n \t \t\tpublic void sawBranchTo(int pc) {\n \t \t\t\taddJumpValue(pc);\n \t \t\t}\n \t \t};\n \t \tbranchAnalysis.setupVisitorForClass(v.getThisClass());\n \t \tbranchAnalysis.doVisitMethod(v.getMethod());\n\t\tif (DEBUG && !jumpEntries.isEmpty()) {\n\t\t\tSystem.out.println(\"Found dataflow for jumps\");\n\t\t\tfor(Integer pc : jumpEntries.keySet())\n\t\t\t\tSystem.out.println(pc + \" -> \" + jumpEntries.get(pc));\n\t\t\t}\n \t \tresetForMethodEntry0(v);\n\t\t}\n \t\n \t\treturn result;\n \t\n\t\t}","commit_id":"eb79fac3d4ddaf08b38bdfab1d9b2a8972a7bd27","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void mergeJumps(DismantleBytecode dbc) {\n\t\tif (!needToMerge) return;\n\t\tneedToMerge = false;\n\t\tList<Item> jumpEntry = jumpEntries.get(dbc.getPC());\n \t\tif (jumpEntry != null) {\n// \t\t\tSystem.out.println(\"************\");\n// \t\t\tSystem.out.println(\"jump entry at \" + dbc.getPC() + \" -> \" + jumpEntry);\n// \t\t\tSystem.out.println(\" current lvValues \" + lvValues);\n \t\t\t\n \t\t\tmergeLists(lvValues, jumpEntry);\n// \t\t\tSystem.out.println(\" merged lvValues \" + lvValues);\n \t\t}\n\t\tif (dbc.getPC() == jumpTarget) {\n\t\t\tjumpTarget = -1;\n\t\t\tif (!jumpStack.empty()) {\n\t\t\t\tList<Item> stackToMerge = jumpStack.pop();\n\n\t\t\t\tmergeLists(stack, stackToMerge);\n\t\t\t}\n\t\t}\n\t}","id":23636,"modified_method":"public void mergeJumps(DismantleBytecode dbc) {\n\t\tif (!needToMerge) return;\n\t\tneedToMerge = false;\n\t\tList<Item> jumpEntry = jumpEntries.get(dbc.getPC());\n \t\tif (jumpEntry != null) {\n\t\t\tif (DEBUG) {\n \t\t\tSystem.out.println(\"XXXXXXX\");\n \t\t\tSystem.out.println(\"merging lvValues at jump target \" + dbc.getPC() + \" -> \" + jumpEntry);\n \t\t\tSystem.out.println(\" current lvValues \" + lvValues);\n\t\t\t}\n \t\t\t\n \t\t\tmergeLists(lvValues, jumpEntry);\n\t\t\tif (DEBUG)\n \t\t\tSystem.out.println(\" merged lvValues \" + lvValues);\n \t\t}\n\t\tif (dbc.getPC() == jumpTarget) {\n\t\t\tjumpTarget = -1;\n\t\t\tif (!jumpStack.empty()) {\n\t\t\t\t\n\t\t\t\tList<Item> stackToMerge = jumpStack.pop();\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(\"************\");\n\t\t\t\t\tSystem.out.println(\"merging stacks at \" + dbc.getPC() + \" -> \" + stackToMerge);\n\t\t\t\t\tSystem.out.println(\" current stack \" + stack);\n\t\t\t\t\t}\n\t\t\t\tmergeLists(stack, stackToMerge);\n\t\t\t\tif (DEBUG) \n\t\t\t\t\tSystem.out.println(\" updated stack \" + stack);\n\t\t\t} }\n\t\t}","commit_id":"eb79fac3d4ddaf08b38bdfab1d9b2a8972a7bd27","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n         public void sawOpcode(int seen) {\n\t\tstack.mergeJumps(this);\n         if (false && (seen == INVOKEVIRTUAL)\n                &&   getNameConstantOperand().equals(\"equals\")\n                &&   getSigConstantOperand().equals(\"(Ljava/lang/Object;)Z\")\n\t\t&& stack.getStackDepth() > 1) {\n\t\t\tOpcodeStack.Item item0 = stack.getStackItem(0);\n\t\t\tOpcodeStack.Item item1 = stack.getStackItem(1);\n\n\t\t\tif (item0.isArray() || item1.isArray()) {\n\t\t\t\tbugReporter.reportBug(new BugInstance(\"EC_BAD_ARRAY_COMPARE\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addSourceLine(this));\n\t\t}\n\t\t}\n \n\n\n\t\tif ((seen == IFEQ || seen == IFNE) && getPrevOpcode(1) == IMUL\n\t\t\t&& ( getPrevOpcode(2) == SIPUSH\n\t\t\t\t|| getPrevOpcode(2) == BIPUSH\n\t\t\t\t)\n\t\t\t&& getPrevOpcode(3) == IREM\n\t\t\t\t)\n\t\t\t bugReporter.reportBug(new BugInstance(this, \"IM_MULTIPLYING_RESULT_OF_IREM\", LOW_PRIORITY)\n                                        .addClassAndMethod(this)\n                                        .addSourceLine(this));\n\t\tif (seen == I2S && getPrevOpcode(1) == IUSHR\n\t\t\t\t&& (!constantArgumentToShift || valueOfConstantArgumentToShift % 16 != 0)\n\t\t\t||\n\t\t    seen == I2B && getPrevOpcode(1) == IUSHR\n\t\t\t\t&& (!constantArgumentToShift || valueOfConstantArgumentToShift % 8 != 0)\n\t\t\t )\n\t\t\t bugReporter.reportBug(new BugInstance(this, \"ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT\", LOW_PRIORITY)\n                                        .addClassAndMethod(this)\n                                        .addSourceLine(this));\n\n\t\tconstantArgumentToShift = false;\n\t\tif ( (seen == IUSHR \n\t\t\t\t|| seen == ISHR \n\t\t\t\t|| seen == ISHL )) {\n\t\t\tif (stack.getStackDepth() <= 1) {\n\t\t\t\t// don't understand; lie so other detectors won't get concerned\n\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\tvalueOfConstantArgumentToShift = 8;\n\t\t\t\t}\n\t\t\telse {\n\t\t\tObject rightHandSide\n\t\t\t\t = stack.getStackItem(0).getConstant();\n\t\t\tObject leftHandSide \n\t\t\t\t=  stack.getStackItem(1).getConstant();\n\t\t\tif (rightHandSide != null && rightHandSide instanceof Integer) {\n\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\tvalueOfConstantArgumentToShift = ((Integer) rightHandSide);\n\t\t\t\tif (valueOfConstantArgumentToShift < 0 || valueOfConstantArgumentToShift >= 32)\n\t\t\t\t bugReporter.reportBug(new BugInstance(this, \"ICAST_BAD_SHIFT_AMOUNT\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(valueOfConstantArgumentToShift)\n\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (leftHandSide != null \n\t\t\t\t\t&& leftHandSide instanceof Integer\n\t\t\t\t\t&& ((Integer) leftHandSide)\n\t\t\t\t\t\t> 0) {\n\t\t\t\t// boring; lie so other detectors won't get concerned\n\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\tvalueOfConstantArgumentToShift = 8;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\n\n\n\t   if (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0\n                        && getClassConstantOperand().equals(\"java/util/Date\")\n                        && getNameConstantOperand().equals(\"setMonth\")\n                        && getSigConstantOperand().equals(\"(I)V\")) {\n\t\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\t\tObject o = item.getConstant();\n\t\t\tif (o != null && o instanceof Integer) {\n\t\t\t\tint v = (Integer) o;\n\t\t\t\tif (v < 0 || v > 11)\n\t\t\t\t bugReporter.reportBug(new BugInstance(this, \"DMI_BAD_MONTH\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(v)\n\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t}\n\t\t\t\t\n\t   if (seen == INVOKEVIRTUAL && stack.getStackDepth() > 1\n                        && getClassConstantOperand().equals(\"java/util/Calendar\")\n                        && getNameConstantOperand().equals(\"set\")\n                        && getSigConstantOperand().equals(\"(III)V\")\n\t\t||\n\t   \tseen == INVOKESPECIAL && stack.getStackDepth() > 1\n                        && getClassConstantOperand().equals(\"java/util/GregorianCalendar\")\n                        && getNameConstantOperand().equals(\"<init>\")\n                        && getSigConstantOperand().equals(\"(III)V\")\n\t\t) {\n\t\t\tOpcodeStack.Item item = stack.getStackItem(1);\n\t\t\tObject o = item.getConstant();\n\t\t\tif (o != null && o instanceof Integer) {\n\t\t\t\tint v = (Integer) o;\n\t\t\t\tif (v < 0 || v > 11)\n\t\t\t\t bugReporter.reportBug(new BugInstance(this, \"DMI_BAD_MONTH\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(v)\n\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t}\n\t\t\t\t\n\n\n\t\tif (isRegisterStore() && (seen == ISTORE \n\t\t\t|| seen == ISTORE_0\n\t\t\t|| seen == ISTORE_1\n\t\t\t|| seen == ISTORE_2\n\t\t\t|| seen == ISTORE_3)\n\t\t\t&& getRegisterOperand() == prevOpcodeIncrementedRegister) {\n\t\t\t bugReporter.reportBug(new BugInstance(this, \"DLS_OVERWRITTEN_INCREMENT\", HIGH_PRIORITY)\n                                        .addClassAndMethod(this)\n                                        .addSourceLine(this));\n\n\t\t\t}\n\t\tif (seen == IINC) {\n\t\t\tprevOpcodeIncrementedRegister = getRegisterOperand();\t\n\t\t\t}\n\t\telse\n\t\t\tprevOpcodeIncrementedRegister = -1;\n\t\t\n\t\t\n\t\t// Java Puzzlers, Chapter 2, puzzle 1\n\t\t  // Look for ICONST_2 IREM ICONST_1  IF_ICMPNE L1\n\t\t\n\t\tswitch (badlyComputingOddState) {\n\t\tcase 0:\n\t\t\tif (seen == ICONST_2) badlyComputingOddState++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (seen == IREM) badlyComputingOddState++;\n\t\t\telse badlyComputingOddState = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (seen == ICONST_1) badlyComputingOddState++;\n\t\t\telse badlyComputingOddState = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (seen == IF_ICMPEQ || seen == IF_ICMPNE) \n\t\t\t\t bugReporter.reportBug(new BugInstance(this, \"IM_BAD_CHECK_FOR_ODD\", NORMAL_PRIORITY)\n                         .addClassAndMethod(this)\n                         .addSourceLine(this));\n\t\t\t\tbadlyComputingOddState = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// Java Puzzlers, chapter 3, puzzle 12\n\t\t  if (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0 \n                  && (getNameConstantOperand().equals(\"toString\")\n                      && getSigConstantOperand().equals(\"()Ljava/lang/String;\")\n                      || getNameConstantOperand().equals(\"append\")\n                      && getSigConstantOperand().equals(\"(Ljava/lang/Object;)Ljava/lang/StringBuilder;\") && getClassConstantOperand().equals(\"java/lang/StringBuilder\")\n                      || getNameConstantOperand().equals(\"append\")\n                      && getSigConstantOperand().equals(\"(Ljava/lang/Object;)Ljava/lang/StringBuffer;\") && getClassConstantOperand().equals(\"java/lang/StringBuffer\")\n                      )\n                  ) {\n\t\t\t  String classConstants = getClassConstantOperand();\n\t\t\t  OpcodeStack.Item item = stack.getStackItem(0);\n\t\t\t  String signature = item.getSignature();\n\t\t\t  if (signature != null && signature.startsWith(\"[\")) \n\t\t\t\t\t bugReporter.reportBug(new BugInstance(this, \"DMI_INVOKING_TOSTRING_ON_ARRAY\", NORMAL_PRIORITY)\n\t                         .addClassAndMethod(this)\n\t                         .addSourceLine(this));\n\t\t  }\n\n\t\n\t\n\t\tstack.sawOpcode(this,seen);\n\t}","id":23637,"modified_method":"@Override\n         public void sawOpcode(int seen) {\n\t\tstack.mergeJumps(this);\n         if (false && (seen == INVOKEVIRTUAL)\n                &&   getNameConstantOperand().equals(\"equals\")\n                &&   getSigConstantOperand().equals(\"(Ljava/lang/Object;)Z\")\n\t\t&& stack.getStackDepth() > 1) {\n\t\t\tOpcodeStack.Item item0 = stack.getStackItem(0);\n\t\t\tOpcodeStack.Item item1 = stack.getStackItem(1);\n\n\t\t\tif (item0.isArray() || item1.isArray()) {\n\t\t\t\tbugReporter.reportBug(new BugInstance(\"EC_BAD_ARRAY_COMPARE\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t.addSourceLine(this));\n\t\t}\n\t\t}\n \n\n         if (seen >= IALOAD && seen <= SALOAD || seen >= IASTORE && seen <= SASTORE ) {\n        \t Item index  = stack.getStackItem(0);\n        \t if (index.getSpecialKind() == Item.AVERAGE_COMPUTED_USING_DIVISION)\n        \t\t bugReporter.reportBug(new BugInstance(this, \"IM_AVERAGE_COMPUTATION_COULD_OVERFLOW\", HIGH_PRIORITY)\n                 .addClassAndMethod(this)\n                 .addSourceLine(this));\n         }\n\n\t\tif ((seen == IFEQ || seen == IFNE) && getPrevOpcode(1) == IMUL\n\t\t\t&& ( getPrevOpcode(2) == SIPUSH\n\t\t\t\t|| getPrevOpcode(2) == BIPUSH\n\t\t\t\t)\n\t\t\t&& getPrevOpcode(3) == IREM\n\t\t\t\t)\n\t\t\t bugReporter.reportBug(new BugInstance(this, \"IM_MULTIPLYING_RESULT_OF_IREM\", LOW_PRIORITY)\n                                        .addClassAndMethod(this)\n                                        .addSourceLine(this));\n\t\tif (seen == I2S && getPrevOpcode(1) == IUSHR\n\t\t\t\t&& (!constantArgumentToShift || valueOfConstantArgumentToShift % 16 != 0)\n\t\t\t||\n\t\t    seen == I2B && getPrevOpcode(1) == IUSHR\n\t\t\t\t&& (!constantArgumentToShift || valueOfConstantArgumentToShift % 8 != 0)\n\t\t\t )\n\t\t\t bugReporter.reportBug(new BugInstance(this, \"ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT\", LOW_PRIORITY)\n                                        .addClassAndMethod(this)\n                                        .addSourceLine(this));\n\n\t\tconstantArgumentToShift = false;\n\t\tif ( (seen == IUSHR \n\t\t\t\t|| seen == ISHR \n\t\t\t\t|| seen == ISHL )) {\n\t\t\tif (stack.getStackDepth() <= 1) {\n\t\t\t\t// don't understand; lie so other detectors won't get concerned\n\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\tvalueOfConstantArgumentToShift = 8;\n\t\t\t\t}\n\t\t\telse {\n\t\t\tObject rightHandSide\n\t\t\t\t = stack.getStackItem(0).getConstant();\n\t\t\tObject leftHandSide \n\t\t\t\t=  stack.getStackItem(1).getConstant();\n\t\t\tif (rightHandSide != null && rightHandSide instanceof Integer) {\n\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\tvalueOfConstantArgumentToShift = ((Integer) rightHandSide);\n\t\t\t\tif (valueOfConstantArgumentToShift < 0 || valueOfConstantArgumentToShift >= 32)\n\t\t\t\t bugReporter.reportBug(new BugInstance(this, \"ICAST_BAD_SHIFT_AMOUNT\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(valueOfConstantArgumentToShift)\n\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (leftHandSide != null \n\t\t\t\t\t&& leftHandSide instanceof Integer\n\t\t\t\t\t&& ((Integer) leftHandSide)\n\t\t\t\t\t\t> 0) {\n\t\t\t\t// boring; lie so other detectors won't get concerned\n\t\t\t\tconstantArgumentToShift = true;\n\t\t\t\tvalueOfConstantArgumentToShift = 8;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\n\n\n\t   if (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0\n                        && getClassConstantOperand().equals(\"java/util/Date\")\n                        && getNameConstantOperand().equals(\"setMonth\")\n                        && getSigConstantOperand().equals(\"(I)V\")) {\n\t\t\tOpcodeStack.Item item = stack.getStackItem(0);\n\t\t\tObject o = item.getConstant();\n\t\t\tif (o != null && o instanceof Integer) {\n\t\t\t\tint v = (Integer) o;\n\t\t\t\tif (v < 0 || v > 11)\n\t\t\t\t bugReporter.reportBug(new BugInstance(this, \"DMI_BAD_MONTH\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(v)\n\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t}\n\t\t\t\t\n\t   if (seen == INVOKEVIRTUAL && stack.getStackDepth() > 1\n                        && getClassConstantOperand().equals(\"java/util/Calendar\")\n                        && getNameConstantOperand().equals(\"set\")\n                        && getSigConstantOperand().equals(\"(III)V\")\n\t\t||\n\t   \tseen == INVOKESPECIAL && stack.getStackDepth() > 1\n                        && getClassConstantOperand().equals(\"java/util/GregorianCalendar\")\n                        && getNameConstantOperand().equals(\"<init>\")\n                        && getSigConstantOperand().equals(\"(III)V\")\n\t\t) {\n\t\t\tOpcodeStack.Item item = stack.getStackItem(1);\n\t\t\tObject o = item.getConstant();\n\t\t\tif (o != null && o instanceof Integer) {\n\t\t\t\tint v = (Integer) o;\n\t\t\t\tif (v < 0 || v > 11)\n\t\t\t\t bugReporter.reportBug(new BugInstance(this, \"DMI_BAD_MONTH\", NORMAL_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(this)\n\t\t\t\t\t\t.addInt(v)\n\t\t\t\t\t\t.addCalledMethod(this)\n\t\t\t\t\t\t.addSourceLine(this)\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t}\n\t\t\t\t\n\n\n\t\tif (isRegisterStore() && (seen == ISTORE \n\t\t\t|| seen == ISTORE_0\n\t\t\t|| seen == ISTORE_1\n\t\t\t|| seen == ISTORE_2\n\t\t\t|| seen == ISTORE_3)\n\t\t\t&& getRegisterOperand() == prevOpcodeIncrementedRegister) {\n\t\t\t bugReporter.reportBug(new BugInstance(this, \"DLS_OVERWRITTEN_INCREMENT\", HIGH_PRIORITY)\n                                        .addClassAndMethod(this)\n                                        .addSourceLine(this));\n\n\t\t\t}\n\t\tif (seen == IINC) {\n\t\t\tprevOpcodeIncrementedRegister = getRegisterOperand();\t\n\t\t\t}\n\t\telse\n\t\t\tprevOpcodeIncrementedRegister = -1;\n\t\t\n\t\t\n\t\t// Java Puzzlers, Chapter 2, puzzle 1\n\t\t  // Look for ICONST_2 IREM ICONST_1  IF_ICMPNE L1\n\t\t\n\t\tswitch (badlyComputingOddState) {\n\t\tcase 0:\n\t\t\tif (seen == ICONST_2) badlyComputingOddState++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (seen == IREM) badlyComputingOddState++;\n\t\t\telse badlyComputingOddState = 0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (seen == ICONST_1) badlyComputingOddState++;\n\t\t\telse badlyComputingOddState = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (seen == IF_ICMPEQ || seen == IF_ICMPNE) \n\t\t\t\t bugReporter.reportBug(new BugInstance(this, \"IM_BAD_CHECK_FOR_ODD\", NORMAL_PRIORITY)\n                         .addClassAndMethod(this)\n                         .addSourceLine(this));\n\t\t\t\tbadlyComputingOddState = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// Java Puzzlers, chapter 3, puzzle 12\n\t\t  if (seen == INVOKEVIRTUAL && stack.getStackDepth() > 0 \n                  && (getNameConstantOperand().equals(\"toString\")\n                      && getSigConstantOperand().equals(\"()Ljava/lang/String;\")\n                      || getNameConstantOperand().equals(\"append\")\n                      && getSigConstantOperand().equals(\"(Ljava/lang/Object;)Ljava/lang/StringBuilder;\") && getClassConstantOperand().equals(\"java/lang/StringBuilder\")\n                      || getNameConstantOperand().equals(\"append\")\n                      && getSigConstantOperand().equals(\"(Ljava/lang/Object;)Ljava/lang/StringBuffer;\") && getClassConstantOperand().equals(\"java/lang/StringBuffer\")\n                      )\n                  ) {\n\t\t\t  String classConstants = getClassConstantOperand();\n\t\t\t  OpcodeStack.Item item = stack.getStackItem(0);\n\t\t\t  String signature = item.getSignature();\n\t\t\t  if (signature != null && signature.startsWith(\"[\")) \n\t\t\t\t\t bugReporter.reportBug(new BugInstance(this, \"DMI_INVOKING_TOSTRING_ON_ARRAY\", NORMAL_PRIORITY)\n\t                         .addClassAndMethod(this)\n\t                         .addSourceLine(this));\n\t\t  }\n\n\t\n\t\n\t\tstack.sawOpcode(this,seen);\n\t}","commit_id":"ac826de6b79fc3659ab714df87fb22ffae7a4b8f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void pushByIntMath(int seen, Item lhs, Item rhs) {\n\t\t if (DEBUG) System.out.println(\"pushByIntMath: \" + rhs.getConstant()  + \" \" + lhs.getConstant() );\n \t\tItem newValue  = new Item(\"I\");\n \t\ttry {\n \t\n\t\tif ((rhs.getConstant() != null) && lhs.getConstant() != null) {\n\t\t\tInteger lhsValue = (Integer) lhs.getConstant();\n\t\t\tInteger rhsValue = (Integer) rhs.getConstant();\n\t\t\tif (seen == IADD)\n\t\t\t\tnewValue = new Item(\"I\",lhsValue + rhsValue);\n\t\t\telse if (seen == ISUB)\n\t\t\t\tnewValue = new Item(\"I\",lhsValue - rhsValue);\n\t\t\telse if (seen == IMUL)\n\t\t\t\tnewValue = new Item(\"I\", lhsValue * rhsValue);\n\t\t\telse if (seen == IDIV)\n\t\t\t\tnewValue = new Item(\"I\", lhsValue / rhsValue);\n\t\t\telse if (seen == IAND) {\n\t\t\t\tnewValue = new Item(\"I\", lhsValue & rhsValue);\n\t\t\t\tif ((rhsValue&0xff) == 0 && rhsValue != 0 || (lhsValue&0xff) == 0 && lhsValue != 0 ) \t\n\t\t\t\t\tnewValue.specialKind = Item.LOW_8_BITS_CLEAR;\n\t\t\t\n\t\t\t} else if (seen == IOR)\n\t\t\t\tnewValue = new Item(\"I\",lhsValue | rhsValue);\n\t\t\telse if (seen == IXOR)\n\t\t\t\tnewValue = new Item(\"I\",lhsValue ^ rhsValue);\n\t\t\telse if (seen == ISHL) {\n\t\t\t\tnewValue = new Item(\"I\",lhsValue << rhsValue);\n\t\t\t\tif (rhsValue >= 8) \tnewValue.specialKind = Item.LOW_8_BITS_CLEAR;\n\t\t\t}\n\t\t\telse if (seen == ISHR)\n\t\t\t\tnewValue = new Item(\"I\",lhsValue >> rhsValue);\n\t\t\telse if (seen == IREM)\n\t\t\t\tnewValue = new Item(\"I\", lhsValue % rhsValue);\n\t\t\telse if (seen == IUSHR)\n\t\t\t\tnewValue = new Item(\"I\", lhsValue >>> rhsValue);\n\t\t} else if (rhs.getConstant() != null && seen == ISHL  && (Integer) rhs.getConstant() >= 8)\n\t\t\tnewValue.specialKind = Item.LOW_8_BITS_CLEAR;\n \t\telse if (lhs.getConstant() != null && seen == IAND  && ((Integer) lhs.getConstant() & 0xff) == 0)\n\t\t\tnewValue.specialKind = Item.LOW_8_BITS_CLEAR;\n \t\telse if (rhs.getConstant() != null && seen == IAND  && ((Integer) rhs.getConstant() & 0xff) == 0)\n\t\t\tnewValue.specialKind = Item.LOW_8_BITS_CLEAR;\n\t\t} catch (RuntimeException e) {\n \t\t\t// ignore it\n \t\t}\n \t\tif (DEBUG) System.out.println(\"push: \" + newValue);\n \t\tpush(newValue);\n\t}","id":23638,"modified_method":"private void pushByIntMath(int seen, Item lhs, Item rhs) {\n\t\t if (DEBUG) System.out.println(\"pushByIntMath: \" + rhs.getConstant()  + \" \" + lhs.getConstant() );\n \t\tItem newValue  = new Item(\"I\");\n \t\ttry {\n \t\n\t\tif ((rhs.getConstant() != null) && lhs.getConstant() != null) {\n\t\t\tInteger lhsValue = (Integer) lhs.getConstant();\n\t\t\tInteger rhsValue = (Integer) rhs.getConstant();\n\t\t\tif (seen == IADD)\n\t\t\t\tnewValue = new Item(\"I\",lhsValue + rhsValue);\n\t\t\telse if (seen == ISUB)\n\t\t\t\tnewValue = new Item(\"I\",lhsValue - rhsValue);\n\t\t\telse if (seen == IMUL)\n\t\t\t\tnewValue = new Item(\"I\", lhsValue * rhsValue);\n\t\t\telse if (seen == IDIV)\n\t\t\t\tnewValue = new Item(\"I\", lhsValue / rhsValue);\n\t\t\telse if (seen == IAND) {\n\t\t\t\tnewValue = new Item(\"I\", lhsValue & rhsValue);\n\t\t\t\tif ((rhsValue&0xff) == 0 && rhsValue != 0 || (lhsValue&0xff) == 0 && lhsValue != 0 ) \t\n\t\t\t\t\tnewValue.specialKind = Item.LOW_8_BITS_CLEAR;\n\t\t\t\n\t\t\t} else if (seen == IOR)\n\t\t\t\tnewValue = new Item(\"I\",lhsValue | rhsValue);\n\t\t\telse if (seen == IXOR)\n\t\t\t\tnewValue = new Item(\"I\",lhsValue ^ rhsValue);\n\t\t\telse if (seen == ISHL) {\n\t\t\t\tnewValue = new Item(\"I\",lhsValue << rhsValue);\n\t\t\t\tif (rhsValue >= 8) \tnewValue.specialKind = Item.LOW_8_BITS_CLEAR;\n\t\t\t}\n\t\t\telse if (seen == ISHR)\n\t\t\t\tnewValue = new Item(\"I\",lhsValue >> rhsValue);\n\t\t\telse if (seen == IREM)\n\t\t\t\tnewValue = new Item(\"I\", lhsValue % rhsValue);\n\t\t\telse if (seen == IUSHR)\n\t\t\t\tnewValue = new Item(\"I\", lhsValue >>> rhsValue);\n\t\t} else if (rhs.getConstant() != null && seen == ISHL  && (Integer) rhs.getConstant() >= 8)\n\t\t\tnewValue.specialKind = Item.LOW_8_BITS_CLEAR;\n \t\telse if (lhs.getConstant() != null && seen == IAND  && ((Integer) lhs.getConstant() & 0xff) == 0)\n\t\t\tnewValue.specialKind = Item.LOW_8_BITS_CLEAR;\n \t\telse if (rhs.getConstant() != null && seen == IAND  && ((Integer) rhs.getConstant() & 0xff) == 0)\n\t\t\tnewValue.specialKind = Item.LOW_8_BITS_CLEAR;\n\t\t} catch (RuntimeException e) {\n \t\t\t// ignore it\n \t\t}\n\t\tif (lhs.specialKind == Item.INTEGER_SUM && rhs.getConstant() != null ) {\n\t\t\tint rhsValue = (Integer) rhs.getConstant();\n\t\t\tif (seen == IDIV && rhsValue ==2  || seen == ISHR  && rhsValue == 1)\n\t\t\t\tnewValue.specialKind = Item.AVERAGE_COMPUTED_USING_DIVISION;\n\t\t}\n\t\tif (seen == IADD && newValue.specialKind == 0 &&   lhs.getConstant() == null && rhs.getConstant() == null ) \n\t\t\tnewValue.specialKind = Item.INTEGER_SUM;\n \t\tif (DEBUG) System.out.println(\"push: \" + newValue);\n \t\tpush(newValue);\n\t}","commit_id":"ac826de6b79fc3659ab714df87fb22ffae7a4b8f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void sawOpcode(DismantleBytecode dbc, int seen) {\n \t\tint register;\n \t\tString signature;\n \t\tItem it, it2, it3;\n \t\tConstant cons;\n\n \t\tmergeJumps(dbc);\n \t\tneedToMerge = true;\n \t\n \t\t\n \t\ttry\n \t\t{\n\t \t\tswitch (seen) {\n\t \t\t\tcase ALOAD:\n\t \t\t\t\tpushByLocalObjectLoad(dbc, dbc.getRegisterOperand());\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase ALOAD_0:\n\t \t\t\tcase ALOAD_1:\n\t \t\t\tcase ALOAD_2:\n\t \t\t\tcase ALOAD_3:\n\t \t\t\t\tpushByLocalObjectLoad(dbc, seen - ALOAD_0);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DLOAD:\n\t \t\t\t\tpushByLocalLoad(\"D\", dbc.getRegisterOperand());\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DLOAD_0:\n\t \t\t\tcase DLOAD_1:\n\t \t\t\tcase DLOAD_2:\n\t \t\t\tcase DLOAD_3:\n\t \t\t\t\tpushByLocalLoad(\"D\", seen - DLOAD_0);\n\t \t\t\tbreak;\n\n\t \t\t\tcase FLOAD:\n\t \t\t\t\tpushByLocalLoad(\"F\", dbc.getRegisterOperand());\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase FLOAD_0:\n\t \t\t\tcase FLOAD_1:\n\t \t\t\tcase FLOAD_2:\n\t \t\t\tcase FLOAD_3:\n\t \t\t\t\tpushByLocalLoad(\"F\", seen - FLOAD_0);\n\t \t\t\tbreak;\n\n\t \t\t\tcase ILOAD:\n\t \t\t\t\tpushByLocalLoad(\"I\", dbc.getRegisterOperand());\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase ILOAD_0:\n\t \t\t\tcase ILOAD_1:\n\t \t\t\tcase ILOAD_2:\n\t \t\t\tcase ILOAD_3:\n\t \t\t\t\tpushByLocalLoad(\"I\", seen - ILOAD_0);\n\t \t\t\tbreak;\n\n\t \t\t\tcase LLOAD:\n\t \t\t\t\tpushByLocalLoad(\"J\", dbc.getRegisterOperand());\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase LLOAD_0:\n\t \t\t\tcase LLOAD_1:\n\t \t\t\tcase LLOAD_2:\n\t \t\t\tcase LLOAD_3:\n\t \t\t\t\tpushByLocalLoad(\"J\", seen - LLOAD_0);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\t\n\t \t\t\tcase GETSTATIC:\n\t\t\t\t\t{\n\t \t\t\t\tItem i = new Item(dbc.getSigConstantOperand(), \n\t\t\t\t\t\tFieldAnnotation.fromReferencedField(dbc));\n\t \t\t\t\tpush(i);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t \t\t\t\n\t \t\t\tcase LDC:\n\t \t\t\tcase LDC_W:\n\t\t\t\tcase LDC2_W:\n\t \t\t\t\tcons = dbc.getConstantRefOperand();\n\t \t\t\t\tpushByConstant(dbc, cons);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase INSTANCEOF:\n\t\t\t\t\tpop();\n\t\t\t\t\tpush(new Item(\"I\"));\n\t\t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase ARETURN:\n\t \t\t\tcase DRETURN:\n\t \t\t\tcase FRETURN:\n\t \t\t\tcase IFEQ:\n\t \t\t\tcase IFNE:\n\t \t\t\tcase IFLT:\n\t \t\t\tcase IFLE:\n\t \t\t\tcase IFGT:\n\t \t\t\tcase IFGE:\n\t \t\t\tcase IFNONNULL:\n\t \t\t\tcase IFNULL:\n\t \t\t\tcase IRETURN:\n\t \t\t\tcase LOOKUPSWITCH:\n\t \t\t\tcase LRETURN:\n\t \t\t\tcase TABLESWITCH:\n\t\t\t\t\tseenTransferOfControl = true;\n\t \t\t\t\tpop();\n\t \t\t\tbreak;\n\t \t\t\tcase MONITORENTER:\n\t \t\t\tcase MONITOREXIT:\n\t \t\t\tcase POP:\n\t \t\t\tcase PUTSTATIC:\n\t \t\t\t\tpop();\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase IF_ACMPEQ:\n\t \t\t\tcase IF_ACMPNE:\n\t \t\t\tcase IF_ICMPEQ:\n\t \t\t\tcase IF_ICMPNE:\n\t \t\t\tcase IF_ICMPLT:\n\t \t\t\tcase IF_ICMPLE:\n\t \t\t\tcase IF_ICMPGT:\n\t \t\t\tcase IF_ICMPGE:\n\t\t\t\t\tseenTransferOfControl = true;\n\t \t\t\t\tpop(2);\n\t\t\t\t\tbreak;\n\t \t\t\tcase POP2:\n\t \t\t\tcase PUTFIELD:\n\t \t\t\t\tpop(2);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase IALOAD:\n\t \t\t\tcase SALOAD:\n\t \t\t\t\tpop(2);\n\t \t\t\t\tpush(new Item(\"I\"));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DUP:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tpush(it);\n\t \t\t\t\tpush(it);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DUP2:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif  (it.getSize() == 2) {\n\t \t\t\t\t\tpush(it);\n\t \t\t\t\t\tpush(it);\n\t \t\t\t\t}\n\t \t\t\t\telse {\n\t \t\t\t\t\tit2 = pop();\n\t \t\t\t\t\tpush(it2);\n\t\t \t\t\t\tpush(it);\n\t\t \t\t\t\tpush(it2);\n\t\t \t\t\t\tpush(it);\n\t \t\t\t\t}\n\t \t\t\t\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DUP_X1:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tpush(it);\n\t \t\t\t\tpush(it2);\n\t \t\t\t\tpush(it);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DUP_X2:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tsignature = it2.getSignature();\n\t \t\t\t\tif (signature.equals(\"J\") || signature.equals(\"D\")) {\n\t \t\t\t\t\tpush(it);\n\t \t\t\t\t\tpush(it2);\n\t \t\t\t\t\tpush(it);\t \t\t\t\t\n\t \t\t\t\t} else {\n\t \t\t\t\t\tit3 = pop();\n\t \t\t\t\t\tpush(it);\n\t \t\t\t\t\tpush(it3);\n\t \t\t\t\t\tpush(it2);\n\t \t\t\t\t\tpush(it);\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DUP2_X1:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tsignature = it.getSignature();\n\t \t\t\t\tif (signature.equals(\"J\") || signature.equals(\"D\")) {\n\t \t\t\t\t\tpush(it);\n\t \t\t\t\t\tpush(it2);\n\t \t\t\t\t\tpush(it);\t \t\t\t\t\n\t \t\t\t\t} else {\n\t \t\t\t\t\tit3 = pop();\n\t \t\t\t\t\tpush(it2);\n\t \t\t\t\t\tpush(it);\n\t \t\t\t\t\tpush(it3);\n\t \t\t\t\t\tpush(it2);\n\t \t\t\t\t\tpush(it);\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\t \t\t\t\n\t \t\t\tcase IINC:\n\t \t\t\t\tregister = dbc.getRegisterOperand();\n\t \t\t\t\tit = getLVValue( register );\n\t \t\t\t\tit2 = new Item(\"I\", new Integer(dbc.getIntConstant()));\n\t \t\t\t\tpushByIntMath( IADD, it2, it);\n\t \t\t\t\tpushByLocalStore(register);\n\t \t\t\tbreak;\n\n\t \t\t\tcase ATHROW:\n\t\t\t\t\tpop();\n\t\t\t\t\tbreak;\n\n\t \t\t\tcase CHECKCAST:\n\t \t\t\tcase NOP:\n\t\t\t\t\tbreak;\n\t \t\t\tcase RET:\n\t \t\t\tcase RETURN:\n\t\t\t\t\tseenTransferOfControl = true;\n\t\t\t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase GOTO:\n\t \t\t\tcase GOTO_W:\t\t\t\t\t//It is assumed that no stack items are present when\n\t\t\t\t\tseenTransferOfControl = true;\n\t\t\t\t\tif (getStackDepth() > 0) {\n\t\t\t\t\t\tjumpStack.push(new ArrayList<Item>(stack));\n\t\t\t\t\t\tpop();\n\t\t\t\t\t\tjumpTarget = dbc.getBranchTarget();\n\t\t\t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\t\n\t \t\t\t\n\t \t\t\tcase SWAP:\n\t \t\t\t\tItem i1 = pop();\n\t \t\t\t\tItem i2 = pop();\n\t \t\t\t\tpush(i1);\n\t \t\t\t\tpush(i2);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase ICONST_M1:\n\t \t\t\tcase ICONST_0:\n\t \t\t\tcase ICONST_1:\n\t \t\t\tcase ICONST_2:\n\t \t\t\tcase ICONST_3:\n\t \t\t\tcase ICONST_4:\n\t \t\t\tcase ICONST_5:\n\t \t\t\t\tpush(new Item(\"I\", new Integer(seen-ICONST_0)));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase LCONST_0:\n\t \t\t\tcase LCONST_1:\n\t \t\t\t\tpush(new Item(\"J\", new Long(seen-LCONST_0)));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DCONST_0:\n\t \t\t\tcase DCONST_1:\n\t \t\t\t\tpush(new Item(\"D\", new Double(seen-DCONST_0)));\n\t \t\t\tbreak;\n\n\t \t\t\tcase FCONST_0:\n\t \t\t\tcase FCONST_1:\n\t \t\t\tcase FCONST_2:\n\t \t\t\t\tpush(new Item(\"F\", new Float(seen-FCONST_0)));\n\t \t\t\tbreak;\n\n\t \t\t\tcase ACONST_NULL:\n\t \t\t\t\tpush(new Item());\n\t \t\t\tbreak;\n\t \t\t\t\t \t\t\t\t \t\t\t\n\t \t\t\tcase ASTORE:\n\t \t\t\tcase DSTORE:\n\t \t\t\tcase FSTORE:\n\t \t\t\tcase ISTORE:\n\t \t\t\tcase LSTORE:\n\t \t\t\t\tpushByLocalStore(dbc.getRegisterOperand());\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase ASTORE_0:\n\t \t\t\tcase ASTORE_1:\n\t \t\t\tcase ASTORE_2:\n\t \t\t\tcase ASTORE_3:\n\t \t\t\t\tpushByLocalStore(seen - ASTORE_0);\n\t \t\t\tbreak;\n\n\t \t\t\tcase DSTORE_0:\n\t \t\t\tcase DSTORE_1:\n\t \t\t\tcase DSTORE_2:\n\t \t\t\tcase DSTORE_3:\n\t \t\t\t\tpushByLocalStore(seen - DSTORE_0);\n\t \t\t\tbreak;\n\n\n\t \t\t\tcase FSTORE_0:\n\t \t\t\tcase FSTORE_1:\n\t \t\t\tcase FSTORE_2:\n\t \t\t\tcase FSTORE_3:\n\t \t\t\t\tpushByLocalStore(seen - FSTORE_0);\n\t \t\t\tbreak;\n\n\t \t\t\tcase ISTORE_0:\n\t \t\t\tcase ISTORE_1:\n\t \t\t\tcase ISTORE_2:\n\t \t\t\tcase ISTORE_3:\n\t \t\t\t\tpushByLocalStore(seen - ISTORE_0);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase LSTORE_0:\n\t \t\t\tcase LSTORE_1:\n\t \t\t\tcase LSTORE_2:\n\t \t\t\tcase LSTORE_3:\n\t \t\t\t\tpushByLocalStore(seen - LSTORE_0);\n\t \t\t\tbreak;\n\n\t \t\t\tcase GETFIELD:\n\t \t\t\t\tpop();\n\t \t\t\t\tpush(new Item(dbc.getSigConstantOperand(), \n\t\t\t\t\t\tFieldAnnotation.fromReferencedField(dbc)));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase ARRAYLENGTH:\n\t \t\t\t\tpop();\n\t \t\t\t\tpush(new Item(\"I\"));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase BALOAD:\n\t \t\t\t{\n\t \t\t\t\tpop(2);\n\t \t\t\t\tItem v =  new Item(\"I\");\n\t \t\t\t\tv.setSpecialKind(Item.BYTE_ARRAY_LOAD);\n\t \t\t\t\tpush(v);\n\t \t\t\t\tbreak;\n\t \t\t\t}\n\t \t\t\tcase CALOAD:\n\t \t\t\t\tpop(2);\n\t \t\t\t\tpush(new Item(\"I\"));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DALOAD:\n\t \t\t\t\tpop(2);\n\t \t\t\t\tpush(new Item(\"D\"));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase FALOAD:\n\t \t\t\t\tpop(2);\n\t \t\t\t\tpush(new Item(\"F\"));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase LALOAD:\n\t \t\t\t\tpop(2);\n\t \t\t\t\tpush(new Item(\"J\"));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase AASTORE:\n\t \t\t\tcase BASTORE:\n\t \t\t\tcase CASTORE:\n\t \t\t\tcase DASTORE:\n\t \t\t\tcase FASTORE:\n\t \t\t\tcase IASTORE:\n\t \t\t\tcase LASTORE:\n\t \t\t\tcase SASTORE:\n\t \t\t\t\tpop(3);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase BIPUSH:\n\t \t\t\tcase SIPUSH:\n\t \t\t\t\tpush(new Item(\"I\", new Integer(dbc.getIntConstant())));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase IADD:\n\t \t\t\tcase ISUB:\n\t \t\t\tcase IMUL:\n\t \t\t\tcase IDIV:\n\t \t\t\tcase IAND:\n\t \t\t\tcase IOR:\n\t \t\t\tcase IXOR:\n\t \t\t\tcase ISHL:\n\t \t\t\tcase ISHR:\n\t \t\t\tcase IREM:\n\t \t\t\tcase IUSHR:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tpushByIntMath(seen, it2, it);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase INEG:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"I\", new Integer(-(Integer) it.getConstant())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase LNEG:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"J\", new Long(-(Long) it.getConstant())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"J\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase DNEG:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"D\", new Double(-(Double) it.getConstant())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"D\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase LADD:\n\t \t\t\tcase LSUB:\n\t \t\t\tcase LMUL:\n\t \t\t\tcase LDIV:\n\t \t\t\tcase LAND:\n\t \t\t\tcase LOR:\n\t \t\t\tcase LXOR:\n\t \t\t\tcase LSHL:\n\t \t\t\tcase LSHR:\n\t \t\t\tcase LREM:\n\t \t\t\tcase LUSHR:\n\t \t\t\t\tif (DEBUG) \n\t \t\t\t\t\tSystem.out.println(\"Long math: \" + this);\n\t \t\t\t\t\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\ttry {\n\t \t\t\t\tpushByLongMath(seen, it2, it);\n\t \t\t\t\t}\n\t \t\t\t\tcatch (Exception e) {\n\t \t\t\t\t\te.printStackTrace();\n\t \t\t\t\t} finally {\n\t \t\t\t\tif (DEBUG) \n\t \t\t\t\t\tSystem.out.println(\"After long math: \" + this);\n\t \t\t\t\t}\n\t \t\t\t\t\n\t \t\t\tbreak;\n \t\t\t\n\t \t\t\tcase LCMP:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tif ((it.getConstant() != null) && it2.getConstant() != null) {\n\t \t\t\t\t\tlong l = (Long) it.getConstant();\n\t \t\t\t\t\tlong l2 = (Long) it.getConstant();\n\t \t\t\t\t\tif (l2 < l)\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(-1)));\n\t \t\t\t\t\telse if (l2 > l)\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(1)));\n\t \t\t\t\t\telse\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(0)));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\t\n\t \t\t\tcase FCMPG:\n\t \t\t\tcase FCMPL:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tif ((it.getConstant() != null) && it2.getConstant() != null) {\n\t \t\t\t\t\tfloat f = (Float) it.getConstant();\n\t \t\t\t\t\tfloat f2 = (Float) it.getConstant();\n\t \t\t\t\t\tif (f2 < f)\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(-1)));\n\t \t\t\t\t\telse if (f2 > f)\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(1)));\n\t \t\t\t\t\telse\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(0)));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase DCMPG:\n\t \t\t\tcase DCMPL:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tif ((it.getConstant() != null) && it2.getConstant() != null) {\n\t \t\t\t\t\tdouble d = (Double) it.getConstant();\n\t \t\t\t\t\tdouble d2 = (Double) it.getConstant();\n\t \t\t\t\t\tif (d2 < d)\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(-1)));\n\t \t\t\t\t\telse if (d2 > d)\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(1)));\n\t \t\t\t\t\telse\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(0)));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase FADD:\n\t \t\t\tcase FSUB:\n\t \t\t\tcase FMUL:\n\t \t\t\tcase FDIV:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tpushByFloatMath(seen, it, it2);\n\t \t\t\tbreak;\n\n\t \t\t\tcase DADD:\n\t \t\t\tcase DSUB:\n\t \t\t\tcase DMUL:\n\t \t\t\tcase DDIV:\n\t \t\t\tcase DREM:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tpushByDoubleMath(seen, it, it2);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase I2B:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"I\", new Integer((int)((byte)((Integer)it.getConstant()).intValue()))));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase I2C:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"I\", new Integer((int)((char)((Integer)it.getConstant()).intValue()))));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase I2D:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"D\", new Double((double)((Integer)it.getConstant()).intValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"D\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase I2F:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"F\", new Float((float)((Integer)it.getConstant()).intValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"F\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase I2L:{\n\t \t\t\t\tit = pop();\n\t \t\t\t\tItem newValue;\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tnewValue = new Item(\"J\", new Long((long)((Integer)it.getConstant()).intValue()));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tnewValue = new Item(\"J\");\n\t \t\t\t\t}\n\t \t\t\t\tnewValue.setSpecialKind(it.getSpecialKind());\n\t \t\t\t\tpush(newValue);\n\t \t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase I2S:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"I\", new Integer((int)((short)((Integer)it.getConstant()).intValue()))));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase D2I:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"I\", (Integer) it.getConstant()));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase D2F:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"F\", new Float((float)((Double)it.getConstant()).doubleValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"F\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase D2L:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"J\", new Long((long)((Double)it.getConstant()).doubleValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"J\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase L2I:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"I\", new Integer((int)((Long)it.getConstant()).longValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase L2D:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"D\", new Double((double)((Long)it.getConstant()).longValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"D\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase L2F:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"F\", new Float((float)((Long)it.getConstant()).longValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"F\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase F2I:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"I\", new Integer((int)((Float)it.getConstant()).floatValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase F2D:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"D\", new Double((double)((Float)it.getConstant()).floatValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"D\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase NEW:\n\t \t\t\t\tpushBySignature(\"L\" + dbc.getClassConstantOperand() + \";\");\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase NEWARRAY:\n\t \t\t\t\tpop();\n\t \t\t\t\tsignature = \"[\" + BasicType.getType((byte)dbc.getIntConstant()).getSignature();\n\t \t\t\t\tpushBySignature(signature);\n\t \t\t\tbreak;\n\n\t\t\t\t// According to the VM Spec 4.4.1, anewarray and multianewarray\n\t\t\t\t// can refer to normal class/interface types (encoded in\n\t\t\t\t// \"internal form\"), or array classes (encoded as signatures\n\t\t\t\t// beginning with \"[\").\n\t \t\t\t\n\t \t\t\tcase ANEWARRAY:\n\t \t\t\t\tpop();\n\t\t\t\t\tsignature = dbc.getClassConstantOperand();\n\t\t\t\t\tif (!signature.startsWith(\"[\")) {\n\t\t\t\t\t\tsignature = \"L\" + signature + \";\";\n\t\t\t\t\t}\n\t \t\t\t\tpushBySignature(signature);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase MULTIANEWARRAY:\n\t \t\t\t\tint dims = dbc.getIntConstant();\n\t \t\t\t\twhile ((dims--) > 0) {\n\t \t\t\t\t\tpop();\n\t \t\t\t\t}\n\t\t\t\t\tsignature = dbc.getClassConstantOperand();\n\t\t\t\t\tif (!signature.startsWith(\"[\")) {\n\t\t\t\t\t\tsignature = \"L\" + signature + \";\";\n\t\t\t\t\t}\n\t\t\t\t\tpushBySignature(signature);\n\t \t\t\tbreak;\n\t \t\t\t\t\n\t \t\t\tcase AALOAD:\n\t \t\t\t\tpop();\n\t \t\t\t\tit = pop();\n\t \t\t\t\tpushBySignature(it.getElementSignature());\n\t \t\t\tbreak;\n\t \t\t\t\t \t\t\t\n\t \t\t\tcase JSR:\n\t \t\t\t\tpush(new Item(\"\")); //?\n\t \t\t\tbreak;\n\t \t\t\t\n\t\t\t\tcase INVOKEINTERFACE:\n\t \t\t\tcase INVOKESPECIAL:\n\t \t\t\tcase INVOKESTATIC:\n\t \t\t\tcase INVOKEVIRTUAL:\n\t \t\t\t\tprocessMethodCall(dbc, seen);\n\t \t\t\tbreak;\n\t \t\t\t\t\n\t \t\t\tdefault:\n\t \t\t\t\tthrow new UnsupportedOperationException(\"OpCode not supported yet\" );\n\t \t\t}\n\t \t}\n\n\t \tcatch (RuntimeException e) {\n\t \t\t//If an error occurs, we clear the stack and locals. one of two things will occur. \n\t \t\t//Either the client will expect more stack items than really exist, and so they're condition check will fail, \n\t \t\t//or the stack will resync with the code. But hopefully not false positives\n\t \t\tif (DEBUG) \n\t \t\t\te.printStackTrace();\n\t \t\tclear();\n\t \t}\n\t \tfinally {\n\t \t\tif (exceptionHandlers.get(dbc.getNextPC()))\n\t \t\t\tpush(new Item());\n\t \t\tif (DEBUG) {\n\t \t\t\tSystem.out.println(dbc.getNextPC() + \" : \" + OPCODE_NAMES[seen] + \"  stack depth: \" + getStackDepth());\n\t \t\t\tSystem.out.println(this);\n\t \t\t}\n\t \t}\n \t}","id":23639,"modified_method":"public void sawOpcode(DismantleBytecode dbc, int seen) {\n \t\tint register;\n \t\tString signature;\n \t\tItem it, it2, it3;\n \t\tConstant cons;\n\n \t\tmergeJumps(dbc);\n \t\tneedToMerge = true;\n \t\n \t\t\n \t\ttry\n \t\t{\n\t \t\tswitch (seen) {\n\t \t\t\tcase ALOAD:\n\t \t\t\t\tpushByLocalObjectLoad(dbc, dbc.getRegisterOperand());\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase ALOAD_0:\n\t \t\t\tcase ALOAD_1:\n\t \t\t\tcase ALOAD_2:\n\t \t\t\tcase ALOAD_3:\n\t \t\t\t\tpushByLocalObjectLoad(dbc, seen - ALOAD_0);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DLOAD:\n\t \t\t\t\tpushByLocalLoad(\"D\", dbc.getRegisterOperand());\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DLOAD_0:\n\t \t\t\tcase DLOAD_1:\n\t \t\t\tcase DLOAD_2:\n\t \t\t\tcase DLOAD_3:\n\t \t\t\t\tpushByLocalLoad(\"D\", seen - DLOAD_0);\n\t \t\t\tbreak;\n\n\t \t\t\tcase FLOAD:\n\t \t\t\t\tpushByLocalLoad(\"F\", dbc.getRegisterOperand());\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase FLOAD_0:\n\t \t\t\tcase FLOAD_1:\n\t \t\t\tcase FLOAD_2:\n\t \t\t\tcase FLOAD_3:\n\t \t\t\t\tpushByLocalLoad(\"F\", seen - FLOAD_0);\n\t \t\t\tbreak;\n\n\t \t\t\tcase ILOAD:\n\t \t\t\t\tpushByLocalLoad(\"I\", dbc.getRegisterOperand());\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase ILOAD_0:\n\t \t\t\tcase ILOAD_1:\n\t \t\t\tcase ILOAD_2:\n\t \t\t\tcase ILOAD_3:\n\t \t\t\t\tpushByLocalLoad(\"I\", seen - ILOAD_0);\n\t \t\t\tbreak;\n\n\t \t\t\tcase LLOAD:\n\t \t\t\t\tpushByLocalLoad(\"J\", dbc.getRegisterOperand());\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase LLOAD_0:\n\t \t\t\tcase LLOAD_1:\n\t \t\t\tcase LLOAD_2:\n\t \t\t\tcase LLOAD_3:\n\t \t\t\t\tpushByLocalLoad(\"J\", seen - LLOAD_0);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\t\n\t \t\t\tcase GETSTATIC:\n\t\t\t\t\t{\n\t \t\t\t\tItem i = new Item(dbc.getSigConstantOperand(), \n\t\t\t\t\t\tFieldAnnotation.fromReferencedField(dbc));\n\t \t\t\t\tpush(i);\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t \t\t\t\n\t \t\t\tcase LDC:\n\t \t\t\tcase LDC_W:\n\t\t\t\tcase LDC2_W:\n\t \t\t\t\tcons = dbc.getConstantRefOperand();\n\t \t\t\t\tpushByConstant(dbc, cons);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase INSTANCEOF:\n\t\t\t\t\tpop();\n\t\t\t\t\tpush(new Item(\"I\"));\n\t\t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase ARETURN:\n\t \t\t\tcase DRETURN:\n\t \t\t\tcase FRETURN:\n\t \t\t\tcase IFEQ:\n\t \t\t\tcase IFNE:\n\t \t\t\tcase IFLT:\n\t \t\t\tcase IFLE:\n\t \t\t\tcase IFGT:\n\t \t\t\tcase IFGE:\n\t \t\t\tcase IFNONNULL:\n\t \t\t\tcase IFNULL:\n\t \t\t\tcase IRETURN:\n\t \t\t\tcase LOOKUPSWITCH:\n\t \t\t\tcase LRETURN:\n\t \t\t\tcase TABLESWITCH:\n\t\t\t\t\tseenTransferOfControl = true;\n\t \t\t\t\tpop();\n\t \t\t\tbreak;\n\t \t\t\tcase MONITORENTER:\n\t \t\t\tcase MONITOREXIT:\n\t \t\t\tcase POP:\n\t \t\t\tcase PUTSTATIC:\n\t \t\t\t\tpop();\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase IF_ACMPEQ:\n\t \t\t\tcase IF_ACMPNE:\n\t \t\t\tcase IF_ICMPEQ:\n\t \t\t\tcase IF_ICMPNE:\n\t \t\t\tcase IF_ICMPLT:\n\t \t\t\tcase IF_ICMPLE:\n\t \t\t\tcase IF_ICMPGT:\n\t \t\t\tcase IF_ICMPGE:\n\t\t\t\t\tseenTransferOfControl = true;\n\t \t\t\t\tpop(2);\n\t\t\t\t\tbreak;\n\t \t\t\tcase POP2:\n\t \t\t\tcase PUTFIELD:\n\t \t\t\t\tpop(2);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase IALOAD:\n\t \t\t\tcase SALOAD:\n\t \t\t\t\tpop(2);\n\t \t\t\t\tpush(new Item(\"I\"));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DUP:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tpush(it);\n\t \t\t\t\tpush(it);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DUP2:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif  (it.getSize() == 2) {\n\t \t\t\t\t\tpush(it);\n\t \t\t\t\t\tpush(it);\n\t \t\t\t\t}\n\t \t\t\t\telse {\n\t \t\t\t\t\tit2 = pop();\n\t \t\t\t\t\tpush(it2);\n\t\t \t\t\t\tpush(it);\n\t\t \t\t\t\tpush(it2);\n\t\t \t\t\t\tpush(it);\n\t \t\t\t\t}\n\t \t\t\t\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DUP_X1:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tpush(it);\n\t \t\t\t\tpush(it2);\n\t \t\t\t\tpush(it);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DUP_X2:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tsignature = it2.getSignature();\n\t \t\t\t\tif (signature.equals(\"J\") || signature.equals(\"D\")) {\n\t \t\t\t\t\tpush(it);\n\t \t\t\t\t\tpush(it2);\n\t \t\t\t\t\tpush(it);\t \t\t\t\t\n\t \t\t\t\t} else {\n\t \t\t\t\t\tit3 = pop();\n\t \t\t\t\t\tpush(it);\n\t \t\t\t\t\tpush(it3);\n\t \t\t\t\t\tpush(it2);\n\t \t\t\t\t\tpush(it);\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DUP2_X1:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tsignature = it.getSignature();\n\t \t\t\t\tif (signature.equals(\"J\") || signature.equals(\"D\")) {\n\t \t\t\t\t\tpush(it);\n\t \t\t\t\t\tpush(it2);\n\t \t\t\t\t\tpush(it);\t \t\t\t\t\n\t \t\t\t\t} else {\n\t \t\t\t\t\tit3 = pop();\n\t \t\t\t\t\tpush(it2);\n\t \t\t\t\t\tpush(it);\n\t \t\t\t\t\tpush(it3);\n\t \t\t\t\t\tpush(it2);\n\t \t\t\t\t\tpush(it);\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\t \t\t\t\n\t \t\t\tcase IINC:\n\t \t\t\t\tregister = dbc.getRegisterOperand();\n\t \t\t\t\tit = getLVValue( register );\n\t \t\t\t\tit2 = new Item(\"I\", new Integer(dbc.getIntConstant()));\n\t \t\t\t\tpushByIntMath( IADD, it2, it);\n\t \t\t\t\tpushByLocalStore(register);\n\t \t\t\tbreak;\n\n\t \t\t\tcase ATHROW:\n\t\t\t\t\tpop();\n\t\t\t\t\tseenTransferOfControl = true;\n\t\t\t\t\treachOnlyByBranch = true;\n\t\t\t\t\tbreak;\n\n\t \t\t\tcase CHECKCAST:\n\t \t\t\tcase NOP:\n\t\t\t\t\tbreak;\n\t \t\t\tcase RET:\n\t \t\t\tcase RETURN:\n\t\t\t\t\tseenTransferOfControl = true;\n\t\t\t\t\treachOnlyByBranch = true;\n\t\t\t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase GOTO:\n\t \t\t\tcase GOTO_W:\t\t\t\t\t//It is assumed that no stack items are present when\n\t\t\t\t\tseenTransferOfControl = true;\n\t\t\t\t\treachOnlyByBranch = true;\n\t\t\t\t\tif (getStackDepth() > 0) {\n\t\t\t\t\t\tjumpStack.push(new ArrayList<Item>(stack));\n\t\t\t\t\t\tpop();\n\t\t\t\t\t\tjumpTarget = dbc.getBranchTarget();\n\t\t\t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\t\n\t \t\t\t\n\t \t\t\tcase SWAP:\n\t \t\t\t\tItem i1 = pop();\n\t \t\t\t\tItem i2 = pop();\n\t \t\t\t\tpush(i1);\n\t \t\t\t\tpush(i2);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase ICONST_M1:\n\t \t\t\tcase ICONST_0:\n\t \t\t\tcase ICONST_1:\n\t \t\t\tcase ICONST_2:\n\t \t\t\tcase ICONST_3:\n\t \t\t\tcase ICONST_4:\n\t \t\t\tcase ICONST_5:\n\t \t\t\t\tpush(new Item(\"I\", new Integer(seen-ICONST_0)));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase LCONST_0:\n\t \t\t\tcase LCONST_1:\n\t \t\t\t\tpush(new Item(\"J\", new Long(seen-LCONST_0)));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DCONST_0:\n\t \t\t\tcase DCONST_1:\n\t \t\t\t\tpush(new Item(\"D\", new Double(seen-DCONST_0)));\n\t \t\t\tbreak;\n\n\t \t\t\tcase FCONST_0:\n\t \t\t\tcase FCONST_1:\n\t \t\t\tcase FCONST_2:\n\t \t\t\t\tpush(new Item(\"F\", new Float(seen-FCONST_0)));\n\t \t\t\tbreak;\n\n\t \t\t\tcase ACONST_NULL:\n\t \t\t\t\tpush(new Item());\n\t \t\t\tbreak;\n\t \t\t\t\t \t\t\t\t \t\t\t\n\t \t\t\tcase ASTORE:\n\t \t\t\tcase DSTORE:\n\t \t\t\tcase FSTORE:\n\t \t\t\tcase ISTORE:\n\t \t\t\tcase LSTORE:\n\t \t\t\t\tpushByLocalStore(dbc.getRegisterOperand());\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase ASTORE_0:\n\t \t\t\tcase ASTORE_1:\n\t \t\t\tcase ASTORE_2:\n\t \t\t\tcase ASTORE_3:\n\t \t\t\t\tpushByLocalStore(seen - ASTORE_0);\n\t \t\t\tbreak;\n\n\t \t\t\tcase DSTORE_0:\n\t \t\t\tcase DSTORE_1:\n\t \t\t\tcase DSTORE_2:\n\t \t\t\tcase DSTORE_3:\n\t \t\t\t\tpushByLocalStore(seen - DSTORE_0);\n\t \t\t\tbreak;\n\n\n\t \t\t\tcase FSTORE_0:\n\t \t\t\tcase FSTORE_1:\n\t \t\t\tcase FSTORE_2:\n\t \t\t\tcase FSTORE_3:\n\t \t\t\t\tpushByLocalStore(seen - FSTORE_0);\n\t \t\t\tbreak;\n\n\t \t\t\tcase ISTORE_0:\n\t \t\t\tcase ISTORE_1:\n\t \t\t\tcase ISTORE_2:\n\t \t\t\tcase ISTORE_3:\n\t \t\t\t\tpushByLocalStore(seen - ISTORE_0);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase LSTORE_0:\n\t \t\t\tcase LSTORE_1:\n\t \t\t\tcase LSTORE_2:\n\t \t\t\tcase LSTORE_3:\n\t \t\t\t\tpushByLocalStore(seen - LSTORE_0);\n\t \t\t\tbreak;\n\n\t \t\t\tcase GETFIELD:\n\t \t\t\t\tpop();\n\t \t\t\t\tpush(new Item(dbc.getSigConstantOperand(), \n\t\t\t\t\t\tFieldAnnotation.fromReferencedField(dbc)));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase ARRAYLENGTH:\n\t \t\t\t\tpop();\n\t \t\t\t\tpush(new Item(\"I\"));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase BALOAD:\n\t \t\t\t{\n\t \t\t\t\tpop(2);\n\t \t\t\t\tItem v =  new Item(\"I\");\n\t \t\t\t\tv.setSpecialKind(Item.BYTE_ARRAY_LOAD);\n\t \t\t\t\tpush(v);\n\t \t\t\t\tbreak;\n\t \t\t\t}\n\t \t\t\tcase CALOAD:\n\t \t\t\t\tpop(2);\n\t \t\t\t\tpush(new Item(\"I\"));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase DALOAD:\n\t \t\t\t\tpop(2);\n\t \t\t\t\tpush(new Item(\"D\"));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase FALOAD:\n\t \t\t\t\tpop(2);\n\t \t\t\t\tpush(new Item(\"F\"));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase LALOAD:\n\t \t\t\t\tpop(2);\n\t \t\t\t\tpush(new Item(\"J\"));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase AASTORE:\n\t \t\t\tcase BASTORE:\n\t \t\t\tcase CASTORE:\n\t \t\t\tcase DASTORE:\n\t \t\t\tcase FASTORE:\n\t \t\t\tcase IASTORE:\n\t \t\t\tcase LASTORE:\n\t \t\t\tcase SASTORE:\n\t \t\t\t\tpop(3);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase BIPUSH:\n\t \t\t\tcase SIPUSH:\n\t \t\t\t\tpush(new Item(\"I\", new Integer(dbc.getIntConstant())));\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase IADD:\n\t \t\t\tcase ISUB:\n\t \t\t\tcase IMUL:\n\t \t\t\tcase IDIV:\n\t \t\t\tcase IAND:\n\t \t\t\tcase IOR:\n\t \t\t\tcase IXOR:\n\t \t\t\tcase ISHL:\n\t \t\t\tcase ISHR:\n\t \t\t\tcase IREM:\n\t \t\t\tcase IUSHR:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tpushByIntMath(seen, it2, it);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase INEG:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"I\", new Integer(-(Integer) it.getConstant())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase LNEG:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"J\", new Long(-(Long) it.getConstant())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"J\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase DNEG:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"D\", new Double(-(Double) it.getConstant())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"D\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase LADD:\n\t \t\t\tcase LSUB:\n\t \t\t\tcase LMUL:\n\t \t\t\tcase LDIV:\n\t \t\t\tcase LAND:\n\t \t\t\tcase LOR:\n\t \t\t\tcase LXOR:\n\t \t\t\tcase LSHL:\n\t \t\t\tcase LSHR:\n\t \t\t\tcase LREM:\n\t \t\t\tcase LUSHR:\n\t \t\t\t\tif (DEBUG) \n\t \t\t\t\t\tSystem.out.println(\"Long math: \" + this);\n\t \t\t\t\t\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\ttry {\n\t \t\t\t\tpushByLongMath(seen, it2, it);\n\t \t\t\t\t}\n\t \t\t\t\tcatch (Exception e) {\n\t \t\t\t\t\te.printStackTrace();\n\t \t\t\t\t} finally {\n\t \t\t\t\tif (DEBUG) \n\t \t\t\t\t\tSystem.out.println(\"After long math: \" + this);\n\t \t\t\t\t}\n\t \t\t\t\t\n\t \t\t\tbreak;\n \t\t\t\n\t \t\t\tcase LCMP:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tif ((it.getConstant() != null) && it2.getConstant() != null) {\n\t \t\t\t\t\tlong l = (Long) it.getConstant();\n\t \t\t\t\t\tlong l2 = (Long) it.getConstant();\n\t \t\t\t\t\tif (l2 < l)\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(-1)));\n\t \t\t\t\t\telse if (l2 > l)\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(1)));\n\t \t\t\t\t\telse\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(0)));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\t\n\t \t\t\tcase FCMPG:\n\t \t\t\tcase FCMPL:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tif ((it.getConstant() != null) && it2.getConstant() != null) {\n\t \t\t\t\t\tfloat f = (Float) it.getConstant();\n\t \t\t\t\t\tfloat f2 = (Float) it.getConstant();\n\t \t\t\t\t\tif (f2 < f)\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(-1)));\n\t \t\t\t\t\telse if (f2 > f)\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(1)));\n\t \t\t\t\t\telse\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(0)));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase DCMPG:\n\t \t\t\tcase DCMPL:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tif ((it.getConstant() != null) && it2.getConstant() != null) {\n\t \t\t\t\t\tdouble d = (Double) it.getConstant();\n\t \t\t\t\t\tdouble d2 = (Double) it.getConstant();\n\t \t\t\t\t\tif (d2 < d)\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(-1)));\n\t \t\t\t\t\telse if (d2 > d)\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(1)));\n\t \t\t\t\t\telse\n\t \t\t\t\t\t\tpush(new Item(\"I\", new Integer(0)));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase FADD:\n\t \t\t\tcase FSUB:\n\t \t\t\tcase FMUL:\n\t \t\t\tcase FDIV:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tpushByFloatMath(seen, it, it2);\n\t \t\t\tbreak;\n\n\t \t\t\tcase DADD:\n\t \t\t\tcase DSUB:\n\t \t\t\tcase DMUL:\n\t \t\t\tcase DDIV:\n\t \t\t\tcase DREM:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tit2 = pop();\n\t \t\t\t\tpushByDoubleMath(seen, it, it2);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase I2B:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"I\", new Integer((int)((byte)((Integer)it.getConstant()).intValue()))));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase I2C:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"I\", new Integer((int)((char)((Integer)it.getConstant()).intValue()))));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase I2D:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"D\", new Double((double)((Integer)it.getConstant()).intValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"D\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase I2F:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"F\", new Float((float)((Integer)it.getConstant()).intValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"F\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase I2L:{\n\t \t\t\t\tit = pop();\n\t \t\t\t\tItem newValue;\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tnewValue = new Item(\"J\", new Long((long)((Integer)it.getConstant()).intValue()));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tnewValue = new Item(\"J\");\n\t \t\t\t\t}\n\t \t\t\t\tnewValue.setSpecialKind(it.getSpecialKind());\n\t \t\t\t\tpush(newValue);\n\t \t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase I2S:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"I\", new Integer((int)((short)((Integer)it.getConstant()).intValue()))));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase D2I:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"I\", (Integer) it.getConstant()));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase D2F:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"F\", new Float((float)((Double)it.getConstant()).doubleValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"F\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase D2L:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"J\", new Long((long)((Double)it.getConstant()).doubleValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"J\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase L2I:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"I\", new Integer((int)((Long)it.getConstant()).longValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase L2D:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"D\", new Double((double)((Long)it.getConstant()).longValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"D\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase L2F:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"F\", new Float((float)((Long)it.getConstant()).longValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"F\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase F2I:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"I\", new Integer((int)((Float)it.getConstant()).floatValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"I\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\n\t \t\t\tcase F2D:\n\t \t\t\t\tit = pop();\n\t \t\t\t\tif (it.getConstant() != null) {\n\t \t\t\t\t\tpush(new Item(\"D\", new Double((double)((Float)it.getConstant()).floatValue())));\n\t \t\t\t\t} else {\n\t \t\t\t\t\tpush(new Item(\"D\"));\n\t \t\t\t\t}\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase NEW:\n\t \t\t\t\tpushBySignature(\"L\" + dbc.getClassConstantOperand() + \";\");\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase NEWARRAY:\n\t \t\t\t\tpop();\n\t \t\t\t\tsignature = \"[\" + BasicType.getType((byte)dbc.getIntConstant()).getSignature();\n\t \t\t\t\tpushBySignature(signature);\n\t \t\t\tbreak;\n\n\t\t\t\t// According to the VM Spec 4.4.1, anewarray and multianewarray\n\t\t\t\t// can refer to normal class/interface types (encoded in\n\t\t\t\t// \"internal form\"), or array classes (encoded as signatures\n\t\t\t\t// beginning with \"[\").\n\t \t\t\t\n\t \t\t\tcase ANEWARRAY:\n\t \t\t\t\tpop();\n\t\t\t\t\tsignature = dbc.getClassConstantOperand();\n\t\t\t\t\tif (!signature.startsWith(\"[\")) {\n\t\t\t\t\t\tsignature = \"L\" + signature + \";\";\n\t\t\t\t\t}\n\t \t\t\t\tpushBySignature(signature);\n\t \t\t\tbreak;\n\t \t\t\t\n\t \t\t\tcase MULTIANEWARRAY:\n\t \t\t\t\tint dims = dbc.getIntConstant();\n\t \t\t\t\twhile ((dims--) > 0) {\n\t \t\t\t\t\tpop();\n\t \t\t\t\t}\n\t\t\t\t\tsignature = dbc.getClassConstantOperand();\n\t\t\t\t\tif (!signature.startsWith(\"[\")) {\n\t\t\t\t\t\tsignature = \"L\" + signature + \";\";\n\t\t\t\t\t}\n\t\t\t\t\tpushBySignature(signature);\n\t \t\t\tbreak;\n\t \t\t\t\t\n\t \t\t\tcase AALOAD:\n\t \t\t\t\tpop();\n\t \t\t\t\tit = pop();\n\t \t\t\t\tpushBySignature(it.getElementSignature());\n\t \t\t\tbreak;\n\t \t\t\t\t \t\t\t\n\t \t\t\tcase JSR:\n\t \t\t\t\tpush(new Item(\"\")); //?\n\t \t\t\tbreak;\n\t \t\t\t\n\t\t\t\tcase INVOKEINTERFACE:\n\t \t\t\tcase INVOKESPECIAL:\n\t \t\t\tcase INVOKESTATIC:\n\t \t\t\tcase INVOKEVIRTUAL:\n\t \t\t\t\tprocessMethodCall(dbc, seen);\n\t \t\t\tbreak;\n\t \t\t\t\t\n\t \t\t\tdefault:\n\t \t\t\t\tthrow new UnsupportedOperationException(\"OpCode not supported yet\" );\n\t \t\t}\n\t \t}\n\n\t \tcatch (RuntimeException e) {\n\t \t\t//If an error occurs, we clear the stack and locals. one of two things will occur. \n\t \t\t//Either the client will expect more stack items than really exist, and so they're condition check will fail, \n\t \t\t//or the stack will resync with the code. But hopefully not false positives\n\t \t\tif (DEBUG) \n\t \t\t\te.printStackTrace();\n\t \t\tclear();\n\t \t}\n\t \tfinally {\n\t \t\tif (exceptionHandlers.get(dbc.getNextPC()))\n\t \t\t\tpush(new Item());\n\t \t\tif (DEBUG) {\n\t \t\t\tSystem.out.println(dbc.getNextPC() + \" : \" + OPCODE_NAMES[seen] + \"  stack depth: \" + getStackDepth());\n\t \t\t\tSystem.out.println(this);\n\t \t\t}\n\t \t}\n \t}","commit_id":"ac826de6b79fc3659ab714df87fb22ffae7a4b8f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private int resetForMethodEntry0(PreorderVisitor v) {\n\t\tif (DEBUG) System.out.println(\" --- \");\n \t\tstack.clear();\n\t\tjumpTarget = -1;\n \t\tlvValues.clear();\n\t\tjumpStack.clear();\n\n\t\tseenTransferOfControl = false;\n\t\tString className = v.getClassName();\n\t\n\t\tString signature = v.getMethodSig();\n\t\texceptionHandlers.clear();\n \t\tMethod m = v.getMethod();\n \t\tCode code = m.getCode();\n\t\tif (code != null) \n\t {\n\t\t\tCodeException[] exceptionTable = code.getExceptionTable();\n\t\t\tif (exceptionTable != null)\n\t\t\t\tfor(CodeException ex : exceptionTable) \n\t\t\t\t\texceptionHandlers.set(ex.getHandlerPC());\n\t\t}\n\t\tif (DEBUG) System.out.println(\" --- \" + className \n\t\t\t\t+ \" \" + m.getName() + \" \" + signature);\n\t\tType[] argTypes = Type.getArgumentTypes(signature);\n\t\tint reg = 0;\n\t\tif (!m.isStatic()) {\n\t\t\tItem it = new Item(\"L\" + className+\";\");\n\t\t\tit.isInitialParameter = true;\n\t\t\tit.registerNumber = reg;\n\t\t\tsetLVValue( reg++, it);\n\t\t\t}\n\t\t for (Type argType : argTypes) {\n\t\t\t Item it = new Item(argType.getSignature());\n\t\t\t it.registerNumber = reg;\n\t\t\t it.isInitialParameter = true;\n\t\t\t setLVValue(reg++, it);\n\t\t }\n\t\treturn reg;\n\t}","id":23640,"modified_method":"private int resetForMethodEntry0(PreorderVisitor v) {\n\t\tif (DEBUG) System.out.println(\" --- \");\n \t\tstack.clear();\n\t\tjumpTarget = -1;\n \t\tlvValues.clear();\n\t\tjumpStack.clear();\n\t\treachOnlyByBranch = false;\n\t\tseenTransferOfControl = false;\n\t\tString className = v.getClassName();\n\t\n\t\tString signature = v.getMethodSig();\n\t\texceptionHandlers.clear();\n \t\tMethod m = v.getMethod();\n \t\tCode code = m.getCode();\n\t\tif (code != null) \n\t {\n\t\t\tCodeException[] exceptionTable = code.getExceptionTable();\n\t\t\tif (exceptionTable != null)\n\t\t\t\tfor(CodeException ex : exceptionTable) \n\t\t\t\t\texceptionHandlers.set(ex.getHandlerPC());\n\t\t}\n\t\tif (DEBUG) System.out.println(\" --- \" + className \n\t\t\t\t+ \" \" + m.getName() + \" \" + signature);\n\t\tType[] argTypes = Type.getArgumentTypes(signature);\n\t\tint reg = 0;\n\t\tif (!m.isStatic()) {\n\t\t\tItem it = new Item(\"L\" + className+\";\");\n\t\t\tit.isInitialParameter = true;\n\t\t\tit.registerNumber = reg;\n\t\t\tsetLVValue( reg++, it);\n\t\t\t}\n\t\t for (Type argType : argTypes) {\n\t\t\t Item it = new Item(argType.getSignature());\n\t\t\t it.registerNumber = reg;\n\t\t\t it.isInitialParameter = true;\n\t\t\t setLVValue(reg++, it);\n\t\t }\n\t\treturn reg;\n\t}","commit_id":"ac826de6b79fc3659ab714df87fb22ffae7a4b8f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void mergeJumps(DismantleBytecode dbc) {\n\t\tif (!needToMerge) return;\n\t\tneedToMerge = false;\n\t\tList<Item> jumpEntry = jumpEntries.get(dbc.getPC());\n \t\tif (jumpEntry != null) {\n\t\t\tif (DEBUG) {\n \t\t\tSystem.out.println(\"XXXXXXX\");\n \t\t\tSystem.out.println(\"merging lvValues at jump target \" + dbc.getPC() + \" -> \" + jumpEntry);\n \t\t\tSystem.out.println(\" current lvValues \" + lvValues);\n\t\t\t}\n \t\t\t\n \t\t\tmergeLists(lvValues, jumpEntry, false);\n\t\t\tif (DEBUG)\n \t\t\tSystem.out.println(\" merged lvValues \" + lvValues);\n \t\t}\n\t\tif (dbc.getPC() == jumpTarget) {\n\t\t\tjumpTarget = -1;\n\t\t\tif (!jumpStack.empty()) {\n\t\t\t\t\n\t\t\t\tList<Item> stackToMerge = jumpStack.pop();\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(\"************\");\n\t\t\t\t\tSystem.out.println(\"merging stacks at \" + dbc.getPC() + \" -> \" + stackToMerge);\n\t\t\t\t\tSystem.out.println(\" current stack \" + stack);\n\t\t\t\t\t}\n\t\t\t\tmergeLists(stack, stackToMerge, true);\n\t\t\t\tif (DEBUG) \n\t\t\t\t\tSystem.out.println(\" updated stack \" + stack);\n\t\t\t} }\n\t\t}","id":23641,"modified_method":"public void mergeJumps(DismantleBytecode dbc) {\n\t\tif (!needToMerge) return;\n\t\tneedToMerge = false;\n\t\tList<Item> jumpEntry = jumpEntries.get(dbc.getPC());\n \t\tif (jumpEntry != null) {\n\t\t\tif (DEBUG) {\n \t\t\tSystem.out.println(\"XXXXXXX \" + reachOnlyByBranch);\n \t\t\tSystem.out.println(\"merging lvValues at jump target \" + dbc.getPC() + \" -> \" + jumpEntry);\n \t\t\tSystem.out.println(\" current lvValues \" + lvValues);\n\t\t\t}\n \t\t\t\n\t\t\tif (reachOnlyByBranch) lvValues = new ArrayList<Item>(jumpEntry);\n\t\t\telse mergeLists(lvValues, jumpEntry, false);\n\t\t\tif (DEBUG)\n \t\t\tSystem.out.println(\" merged lvValues \" + lvValues);\n \t\t}\n \t\telse if (dbc.getPC() == jumpTarget) {\n\t\t\tjumpTarget = -1;\n\t\t\tif (!jumpStack.empty()) {\n\t\t\t\t\n\t\t\t\tList<Item> stackToMerge = jumpStack.pop();\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(\"************\");\n\t\t\t\t\tSystem.out.println(\"merging stacks at \" + dbc.getPC() + \" -> \" + stackToMerge);\n\t\t\t\t\tSystem.out.println(\" current stack \" + stack);\n\t\t\t\t\t}\n\t\t\t\tif (reachOnlyByBranch) lvValues = new ArrayList<Item>(stackToMerge);\n\t\t\t\telse mergeLists(stack, stackToMerge, true);\n\t\t\t\tif (DEBUG) \n\t\t\t\t\tSystem.out.println(\" updated stack \" + stack);\n\t\t\t} }\n \t\treachOnlyByBranch = false;\n\t\t}","commit_id":"ac826de6b79fc3659ab714df87fb22ffae7a4b8f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public String toString() {\n\t\t\tStringBuffer buf = new StringBuffer(\"< \");\n\t\t\tbuf.append(signature);\n\t\t\tif (specialKind == BYTE_ARRAY_LOAD)\n\t\t\t\tbuf.append(\", byte_array_load\");\n\t\t\telse if (specialKind == RANDOM_INT)\n\t\t\t\tbuf.append(\", random_int\");\n\t\t\telse if (specialKind == LOW_8_BITS_CLEAR)\n\t\t\t\tbuf.append(\", low8clear\");\n\t\t\tif (constValue != UNKNOWN) {\n\t\t\t\tbuf.append(\", \");\n\t\t\t\tbuf.append(constValue);\n\t\t\t\t}\n\t\t\tif (field!= UNKNOWN) {\n\t\t\t\tbuf.append(\", \");\n\t\t\t\tbuf.append(field);\n\t\t\t\t}\n\t\t\tif (isInitialParameter) {\n\t\t\t\tbuf.append(\", IP\");\n\t\t\t\t}\n\t\t\tif (isNull) {\n\t\t\t\tbuf.append(\", isNull\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\tif (registerNumber != -1) {\n\t\t\t\tbuf.append(\", r\");\n\t\t\t\tbuf.append(registerNumber);\n\t\t\t\t}\n\t\t\tif (couldBeZero) buf.append(\", cbz\");\n\t\t\tbuf.append(\" >\");\n\t\t\treturn buf.toString();\n\t\t\t}","id":23642,"modified_method":"public String toString() {\n\t\t\tStringBuffer buf = new StringBuffer(\"< \");\n\t\t\tbuf.append(signature);\n\t\t\tif (specialKind == BYTE_ARRAY_LOAD)\n\t\t\t\tbuf.append(\", byte_array_load\");\n\t\t\telse if (specialKind == RANDOM_INT)\n\t\t\t\tbuf.append(\", random_int\");\n\t\t\telse if (specialKind == LOW_8_BITS_CLEAR)\n\t\t\t\tbuf.append(\", low8clear\");\n\t\t\telse if (specialKind == HASHCODE_INT)\n\t\t\t\tbuf.append(\", hashcode_int\");\n\t\t\telse if (specialKind == INTEGER_SUM)\n\t\t\t\tbuf.append(\", int_sum\");\n\t\t\telse if (specialKind == AVERAGE_COMPUTED_USING_DIVISION)\n\t\t\t\tbuf.append(\", averageComputingUsingDivision\");\n\t\t\tif (constValue != UNKNOWN) {\n\t\t\t\tbuf.append(\", \");\n\t\t\t\tbuf.append(constValue);\n\t\t\t\t}\n\t\t\tif (field!= UNKNOWN) {\n\t\t\t\tbuf.append(\", \");\n\t\t\t\tbuf.append(field);\n\t\t\t\t}\n\t\t\tif (isInitialParameter) {\n\t\t\t\tbuf.append(\", IP\");\n\t\t\t\t}\n\t\t\tif (isNull) {\n\t\t\t\tbuf.append(\", isNull\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\tif (registerNumber != -1) {\n\t\t\t\tbuf.append(\", r\");\n\t\t\t\tbuf.append(registerNumber);\n\t\t\t\t}\n\t\t\tif (couldBeZero) buf.append(\", cbz\");\n\t\t\tbuf.append(\" >\");\n\t\t\treturn buf.toString();\n\t\t\t}","commit_id":"ac826de6b79fc3659ab714df87fb22ffae7a4b8f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public int resetForMethodEntry(final DismantleBytecode v) {\n\t\tjumpEntries.clear();\n \t\tint result= resetForMethodEntry0(v);\n \t\tCode code = v.getMethod().getCode();\n\t\tif (code == null) return result;\n\t\n\t\tif (useIterativeAnalysis) {\n\t\t\t// FIXME: Be clever\n\n\t\t\tDismantleBytecode branchAnalysis = new DismantleBytecode() {\n\t\t\t\t@Override\n\t\t\t\tpublic void sawOpcode(int seen) {\n\t\t\t\t\tOpcodeStack.this.sawOpcode(this, seen);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void sawBranchTo(int pc) {\n\t\t\t\t\taddJumpValue(pc);\n\t\t\t\t}\n\t\t\t};\n\t\t\tbranchAnalysis.setupVisitorForClass(v.getThisClass());\n\t\t\tbranchAnalysis.doVisitMethod(v.getMethod());\n\t\t\tif (DEBUG && !jumpEntries.isEmpty()) {\n\t\t\t\tSystem.out.println(\"Found dataflow for jumps in \" + v.getMethodName());\n\t\t\t\tfor (Integer pc : jumpEntries.keySet())\n\t\t\t\t\tSystem.out.println(pc + \" -> \" + jumpEntries.get(pc));\n\t\t\t}\n\t\t\tresetForMethodEntry0(v);\n\t\t}\n \t\n \t\treturn result;\n \t\n\t\t}","id":23643,"modified_method":"public int resetForMethodEntry(final DismantleBytecode v) {\n\t\tjumpEntries.clear();\n\t\treachOnlyByBranch = false;\n \t\tint result= resetForMethodEntry0(v);\n \t\tCode code = v.getMethod().getCode();\n\t\tif (code == null) return result;\n\t\n\t\tif (useIterativeAnalysis) {\n\t\t\t// FIXME: Be clever\n\n\t\t\tDismantleBytecode branchAnalysis = new DismantleBytecode() {\n\t\t\t\t@Override\n\t\t\t\tpublic void sawOpcode(int seen) {\n\t\t\t\t\tOpcodeStack.this.sawOpcode(this, seen);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void sawBranchTo(int pc) {\n\t\t\t\t\taddJumpValue(pc);\n\t\t\t\t}\n\t\t\t};\n\t\t\tbranchAnalysis.setupVisitorForClass(v.getThisClass());\n\t\t\tbranchAnalysis.doVisitMethod(v.getMethod());\n\t\t\tif (DEBUG && !jumpEntries.isEmpty()) {\n\t\t\t\tSystem.out.println(\"Found dataflow for jumps in \" + v.getMethodName());\n\t\t\t\tfor (Integer pc : jumpEntries.keySet())\n\t\t\t\t\tSystem.out.println(pc + \" -> \" + jumpEntries.get(pc));\n\t\t\t}\n\t\t\tresetForMethodEntry0(v);\n\t\t}\n \t\n \t\treturn result;\n \t\n\t\t}","commit_id":"ac826de6b79fc3659ab714df87fb22ffae7a4b8f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testCheckingOtherWriteAccessProvidersOnUnlockAll() throws Exception {\n    final VirtualFile nonProjectFile1 = createNonProjectFile();\n    final VirtualFile nonProjectFile2 = createNonProjectFile();\n\n    final List<VirtualFile> requested = registerWriteAccessProvider(nonProjectFile1);\n\n    NonProjectFileNotificationPanel panel = typeAndCheck(nonProjectFile1, false);\n    typeAndCheck(nonProjectFile2, false);\n\n    assertNotNull(getNotificationPanel(nonProjectFile1));\n    assertNotNull(getNotificationPanel(nonProjectFile2));\n\n    panel.getUnlockAllLabel().doClick();\n    assertSameElements(requested, nonProjectFile1);\n\n    typeAndCheck(nonProjectFile1, false, false); // can't write, but access panel is not shown \n    typeAndCheck(nonProjectFile2, true);\n  }","id":23644,"modified_method":"public void testCheckingOtherWriteAccessProvidersOnUnlockAll() throws Exception {\n    final VirtualFile nonProjectFile1 = createNonProjectFile();\n    final VirtualFile nonProjectFile2 = createNonProjectFile();\n\n    registerWriteAccessProvider(nonProjectFile1);\n\n    typeAndCheck(nonProjectFile1, NonProjectFileWritingAccessProvider.UnlockOption.UNLOCK_ALL, \n                 false); // can't write since denied by another write-access provider  \n    typeAndCheck(nonProjectFile2, true);\n  }","commit_id":"6c0132db48220510441dbbfd8cd026fb21d00a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<VirtualFile> registerWriteAccessProvider(final VirtualFile... filesToDeny) {\n    final List<VirtualFile> requested = new ArrayList<VirtualFile>();\n    PlatformTestUtil.registerExtension(Extensions.getArea(getProject()), WritingAccessProvider.EP_NAME, new WritingAccessProvider() {\n      @NotNull\n      @Override\n      public Collection<VirtualFile> requestWriting(VirtualFile... files) {\n        Collections.addAll(requested, files);\n        HashSet<VirtualFile> denied = new HashSet<VirtualFile>(Arrays.asList(filesToDeny));\n        denied.retainAll(Arrays.asList(files));\n        return denied;\n      }\n\n      @Override\n      public boolean isPotentiallyWritable(@NotNull VirtualFile file) {\n        return true;\n      }\n    }, myTestRootDisposable);\n    return requested;\n  }","id":23645,"modified_method":"private Set<VirtualFile> registerWriteAccessProvider(final VirtualFile... filesToDeny) {\n    final Set<VirtualFile> requested = new LinkedHashSet<VirtualFile>();\n    PlatformTestUtil.registerExtension(Extensions.getArea(getProject()), WritingAccessProvider.EP_NAME, new WritingAccessProvider() {\n      @NotNull\n      @Override\n      public Collection<VirtualFile> requestWriting(VirtualFile... files) {\n        Collections.addAll(requested, files);\n        HashSet<VirtualFile> denied = new HashSet<VirtualFile>(Arrays.asList(filesToDeny));\n        denied.retainAll(Arrays.asList(files));\n        return denied;\n      }\n\n      @Override\n      public boolean isPotentiallyWritable(@NotNull VirtualFile file) {\n        return true;\n      }\n    }, myTestRootDisposable);\n    return requested;\n  }","commit_id":"6c0132db48220510441dbbfd8cd026fb21d00a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private NonProjectFileNotificationPanel typeAndCheck(VirtualFile file, boolean fileHasBeenChanged) {\n    return typeAndCheck(file, fileHasBeenChanged, !fileHasBeenChanged);\n  }","id":23646,"modified_method":"private void typeAndCheck(VirtualFile file, boolean fileHasBeenChanged) {\n    typeAndCheck(file, null, fileHasBeenChanged);\n  }","commit_id":"6c0132db48220510441dbbfd8cd026fb21d00a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testUpdatingNotificationsOnRootChanges() throws Exception {\n    VirtualFile nonProjectFile1 = createNonProjectFile();\n    VirtualFile nonProjectFile2 = createNonProjectFile();\n\n    typeAndCheck(nonProjectFile1, false);\n    typeAndCheck(nonProjectFile2, false);\n\n    assertNotNull(getNotificationPanel(nonProjectFile1));\n    assertNotNull(getNotificationPanel(nonProjectFile2));\n\n    ContentEntry contextRoot = PsiTestUtil.addContentRoot(myModule, nonProjectFile2.getParent());\n    \n    // removing notification panel for newly added files\n    assertNotNull(NonProjectFileWritingAccessProvider.getAccessStatus(getProject(), nonProjectFile1));\n    assertNull(NonProjectFileWritingAccessProvider.getAccessStatus(getProject(), nonProjectFile2));\n\n    PsiTestUtil.removeContentEntry(myModule, contextRoot);\n\n    // do not add notification panel until access is requested\n    assertNotNull(NonProjectFileWritingAccessProvider.getAccessStatus(getProject(), nonProjectFile1));\n    assertNull(NonProjectFileWritingAccessProvider.getAccessStatus(getProject(), nonProjectFile2));\n\n    // but files are still not writable\n    typeAndCheck(nonProjectFile1, false);\n    typeAndCheck(nonProjectFile2, false);\n    assertNotNull(NonProjectFileWritingAccessProvider.getAccessStatus(getProject(), nonProjectFile1));\n    assertNotNull(NonProjectFileWritingAccessProvider.getAccessStatus(getProject(), nonProjectFile2));\n  }","id":23647,"modified_method":"public void testUpdatingNotificationsOnRootChanges() throws Exception {\n    VirtualFile nonProjectFile1 = createNonProjectFile();\n    VirtualFile nonProjectFile2 = createNonProjectFile();\n\n    typeAndCheck(nonProjectFile1, false);\n    typeAndCheck(nonProjectFile2, false);\n\n    assertNotNull(NonProjectFileWritingAccessProvider.getAccessStatus(getProject(), nonProjectFile1));\n    assertNotNull(NonProjectFileWritingAccessProvider.getAccessStatus(getProject(), nonProjectFile2));\n\n    ContentEntry contextRoot = PsiTestUtil.addContentRoot(myModule, nonProjectFile2.getParent());\n    \n    // removing notification panel for newly added files\n    assertNotNull(NonProjectFileWritingAccessProvider.getAccessStatus(getProject(), nonProjectFile1));\n    assertNull(NonProjectFileWritingAccessProvider.getAccessStatus(getProject(), nonProjectFile2));\n\n    PsiTestUtil.removeContentEntry(myModule, contextRoot);\n\n    // do not add notification panel until access is requested\n    assertNotNull(NonProjectFileWritingAccessProvider.getAccessStatus(getProject(), nonProjectFile1));\n    assertNull(NonProjectFileWritingAccessProvider.getAccessStatus(getProject(), nonProjectFile2));\n\n    // but files are still not writable\n    typeAndCheck(nonProjectFile1, false);\n    typeAndCheck(nonProjectFile2, false);\n    assertNotNull(NonProjectFileWritingAccessProvider.getAccessStatus(getProject(), nonProjectFile1));\n    assertNotNull(NonProjectFileWritingAccessProvider.getAccessStatus(getProject(), nonProjectFile2));\n  }","commit_id":"6c0132db48220510441dbbfd8cd026fb21d00a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testAllowEditingInAllFiles() throws Exception {\n    VirtualFile nonProjectFile1 = createNonProjectFile();\n    VirtualFile nonProjectFile2 = createNonProjectFile();\n\n    NonProjectFileNotificationPanel panel1 = typeAndCheck(nonProjectFile1, false);\n    typeAndCheck(nonProjectFile2, false);\n\n    assertNotNull(getNotificationPanel(nonProjectFile1));\n    assertNotNull(getNotificationPanel(nonProjectFile2));\n\n    panel1.getUnlockAllLabel().doClick();\n    assertNull(getNotificationPanel(nonProjectFile1));\n    assertNull(getNotificationPanel(nonProjectFile2));\n\n    typeAndCheck(nonProjectFile1, true);\n    typeAndCheck(nonProjectFile2, true);\n  }","id":23648,"modified_method":"public void testAllowEditingInAllFiles() throws Exception {\n    VirtualFile nonProjectFile1 = createNonProjectFile();\n    VirtualFile nonProjectFile2 = createNonProjectFile();\n    VirtualFile nonProjectFile3 = createNonProjectFile();\n\n    typeAndCheck(nonProjectFile1, false);\n    typeAndCheck(nonProjectFile2, false);\n    typeAndCheck(nonProjectFile3, false);\n\n    typeAndCheck(nonProjectFile1, NonProjectFileWritingAccessProvider.UnlockOption.UNLOCK_ALL, true);\n    // affects other files\n    typeAndCheck(nonProjectFile2, true);\n    typeAndCheck(nonProjectFile3, true);\n  }","commit_id":"6c0132db48220510441dbbfd8cd026fb21d00a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testAllowEditingInOneFileOnly() throws Exception {\n    VirtualFile nonProjectFile1 = createNonProjectFile();\n    VirtualFile nonProjectFile2 = createNonProjectFile();\n\n    NonProjectFileNotificationPanel panel1 = typeAndCheck(nonProjectFile1, false);\n    NonProjectFileNotificationPanel panel2 = typeAndCheck(nonProjectFile2, false);\n\n    panel1.getUnlockAction().doClick();\n    assertNull(getNotificationPanel(nonProjectFile1));\n    assertNotNull(getNotificationPanel(nonProjectFile2));\n\n    typeAndCheck(nonProjectFile1, true);\n    typeAndCheck(nonProjectFile2, false);\n\n    panel2.getUnlockAction().doClick();\n    assertNull(getNotificationPanel(nonProjectFile1));\n    assertNull(getNotificationPanel(nonProjectFile2));\n\n    typeAndCheck(nonProjectFile1, true);\n    typeAndCheck(nonProjectFile2, true);\n  }","id":23649,"modified_method":"public void testAllowEditingInOneFileOnly() throws Exception {\n    VirtualFile nonProjectFile1 = createNonProjectFile();\n    VirtualFile nonProjectFile2 = createNonProjectFile();\n\n    typeAndCheck(nonProjectFile1, NonProjectFileWritingAccessProvider.UnlockOption.UNLOCK, true);\n    typeAndCheck(nonProjectFile2, null, false);\n\n    typeAndCheck(nonProjectFile1, null, true);\n    typeAndCheck(nonProjectFile2, NonProjectFileWritingAccessProvider.UnlockOption.UNLOCK, true);\n\n    // let's check both files one more time to make sure unlock option doesn't have eny unexpected effect\n    typeAndCheck(nonProjectFile1, null, true);\n    typeAndCheck(nonProjectFile2, null, true);\n  }","commit_id":"6c0132db48220510441dbbfd8cd026fb21d00a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testCheckingOtherWriteAccessProvidersOnUnlock() throws Exception {\n    final VirtualFile nonProjectFile1 = createNonProjectFile();\n    final VirtualFile nonProjectFile2 = createNonProjectFile();\n\n    final List<VirtualFile> requested = registerWriteAccessProvider(nonProjectFile1);\n\n    NonProjectFileNotificationPanel panel1 = typeAndCheck(nonProjectFile1, false);\n    panel1.getUnlockAction().doClick();\n    assertSameElements(requested, nonProjectFile1);\n    typeAndCheck(nonProjectFile1, false); // leave file locked if other provides denied access \n\n    requested.clear();\n\n    NonProjectFileNotificationPanel panel2 = typeAndCheck(nonProjectFile2, false);\n    panel2.getUnlockAction().doClick();\n    assertSameElements(requested, nonProjectFile2);\n    typeAndCheck(nonProjectFile2, true);\n  }","id":23650,"modified_method":"public void testCheckingOtherWriteAccessProvidersOnUnlock() throws Exception {\n    final VirtualFile nonProjectFile1 = createNonProjectFile();\n    final VirtualFile nonProjectFile2 = createNonProjectFile();\n\n    final Set<VirtualFile> requested = registerWriteAccessProvider(nonProjectFile1);\n\n    typeAndCheck(nonProjectFile1, false);\n    assertSameElements(requested); // not called since non-project file access is denied\n\n    typeAndCheck(nonProjectFile1, NonProjectFileWritingAccessProvider.UnlockOption.UNLOCK, false);\n    assertSameElements(requested, nonProjectFile1);\n    \n    typeAndCheck(nonProjectFile1, false); // leave file locked if other provides denied access \n    requested.clear();\n\n    typeAndCheck(nonProjectFile2, NonProjectFileWritingAccessProvider.UnlockOption.UNLOCK, true);\n    assertSameElements(requested, nonProjectFile2);\n  }","commit_id":"6c0132db48220510441dbbfd8cd026fb21d00a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void tearDown() throws Exception {\n    NonProjectFileWritingAccessProvider.enableChecksInTests(getProject(), false);\n    super.tearDown();\n  }","id":23651,"modified_method":"@Override\n  protected void tearDown() throws Exception {\n    NonProjectFileWritingAccessProvider.setCustomUnlocker(null);\n    NonProjectFileWritingAccessProvider.enableChecksInTests(getProject(), false);\n    super.tearDown();\n  }","commit_id":"6c0132db48220510441dbbfd8cd026fb21d00a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testBasicAccessCheck() throws Exception {\n    VirtualFile projectFile = createProjectFile();\n    typeAndCheck(projectFile, true);\n    typeAndCheck(projectFile, true); // still allowed\n\n    VirtualFile nonProjectFile = createNonProjectFile();\n    typeAndCheck(nonProjectFile, false);\n    NonProjectFileNotificationPanel panel = typeAndCheck(nonProjectFile, false);// still not allowed\n\n    panel.getUnlockAction().doClick();\n    assertNull(getNotificationPanel(projectFile));\n    assertNull(getNotificationPanel(nonProjectFile));\n\n    typeAndCheck(nonProjectFile, true);\n    assertNull(getNotificationPanel(projectFile));\n    assertNull(getNotificationPanel(nonProjectFile));\n  }","id":23652,"modified_method":"public void testBasicAccessCheck() throws Exception {\n    VirtualFile projectFile = createProjectFile();\n    typeAndCheck(projectFile, true);\n    typeAndCheck(projectFile, true); // still allowed\n\n    VirtualFile nonProjectFile = createNonProjectFile();\n    typeAndCheck(nonProjectFile, false);\n    typeAndCheck(nonProjectFile, false);// still not allowed\n\n    typeAndCheck(nonProjectFile, NonProjectFileWritingAccessProvider.UnlockOption.UNLOCK, true);\n    typeAndCheck(nonProjectFile, null, true); // still allowed after previous Unlock\n  }","commit_id":"6c0132db48220510441dbbfd8cd026fb21d00a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private NonProjectFileNotificationPanel typeAndCheck(VirtualFile file, boolean changed, boolean hasWarningPanel) {\n    Editor editor = getEditor(file);\n\n    String before = editor.getDocument().getText();\n    typeInChar(editor, 'a');\n\n    NonProjectFileNotificationPanel panel = getNotificationPanel(file);\n    if (changed) {\n      assertEquals(\"Text should be changed\", 'a' + before, editor.getDocument().getText());\n    }\n    else {\n      assertEquals(\"Text should not be changed\", before, editor.getDocument().getText());\n    }\n    assertEquals(hasWarningPanel, panel != null);\n    return panel;\n  }","id":23653,"modified_method":"private void typeAndCheck(VirtualFile file,\n                            @Nullable final NonProjectFileWritingAccessProvider.UnlockOption option,\n                            boolean fileHasBeenChanged) {\n    Editor editor = getEditor(file);\n\n    NullableFunction<List<VirtualFile>, NonProjectFileWritingAccessProvider.UnlockOption> unlocker =\n      new NullableFunction<List<VirtualFile>, NonProjectFileWritingAccessProvider.UnlockOption>() {\n        @Nullable\n        @Override\n        public NonProjectFileWritingAccessProvider.UnlockOption fun(List<VirtualFile> files) {\n          return option;\n        }\n      };\n    NonProjectFileWritingAccessProvider.setCustomUnlocker(unlocker);\n\n    String before = editor.getDocument().getText();\n    typeInChar(editor, 'a');\n\n    if (fileHasBeenChanged) {\n      assertEquals(\"Text should be changed\", 'a' + before, editor.getDocument().getText());\n    }\n    else {\n      assertEquals(\"Text should not be changed\", before, editor.getDocument().getText());\n    }\n  }","commit_id":"6c0132db48220510441dbbfd8cd026fb21d00a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Collection<VirtualFile> requestWriting(VirtualFile... files) {\n    if (allAccessAllowed(myProject)) return Collections.emptyList();\n\n    List<VirtualFile> deniedFiles = new SmartList<VirtualFile>();\n\n    Map<VirtualFile, AccessStatus> statuses = getRegisteredFiles(myProject);\n    for (VirtualFile each : files) {\n      if (statuses.get(each) == AccessStatus.ALLOWED) continue;\n\n      if (!(each.getFileSystem() instanceof LocalFileSystem)) continue; // do not block e.g., HttpFileSystem, LightFileSystem etc.  \n      if (isProjectFile(each)) {\n        if (statuses.remove(each) != null) {\n          EditorNotifications.getInstance(myProject).updateNotifications(each);\n        }\n        continue;\n      }\n\n      statuses.put(each, AccessStatus.REQUESTED);\n      deniedFiles.add(each);\n      EditorNotifications.getInstance(myProject).updateNotifications(each);\n    }\n\n    return deniedFiles;\n  }","id":23654,"modified_method":"@NotNull\n  @Override\n  public Collection<VirtualFile> requestWriting(VirtualFile... files) {\n    if (allAccessAllowed(myProject)) return Collections.emptyList();\n\n    List<VirtualFile> deniedFiles = new SmartList<VirtualFile>();\n\n    Map<VirtualFile, AccessStatus> statuses = getRegisteredFiles(myProject);\n    for (VirtualFile each : files) {\n      if (statuses.get(each) == AccessStatus.ALLOWED) continue;\n\n      if (!(each.getFileSystem() instanceof LocalFileSystem)) continue; // do not block e.g., HttpFileSystem, LightFileSystem etc.  \n      if (isProjectFile(each)) {\n        statuses.remove(each);\n        continue;\n      }\n\n      statuses.put(each, AccessStatus.REQUESTED);\n      deniedFiles.add(each);\n    }\n\n    if (deniedFiles.isEmpty()) return Collections.emptyList();\n\n    UnlockOption unlockOption = askToUnlock(deniedFiles);\n    if (unlockOption == null) return deniedFiles;\n\n    switch (unlockOption) {\n      case UNLOCK:\n        for (VirtualFile eachAllowed : deniedFiles) {\n          statuses.put(eachAllowed, AccessStatus.ALLOWED);\n        }\n        break;\n      case UNLOCK_ALL:\n        myProject.putUserData(ALL_ACCESS_ALLOWED, Boolean.TRUE);\n        break;\n    }\n\n    return Collections.emptyList();\n  }","commit_id":"6c0132db48220510441dbbfd8cd026fb21d00a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public NonProjectFileWritingAccessProvider(@NotNull final Project project) {\n    myProject = project;\n    VirtualFileManager.getInstance().addVirtualFileListener(new VirtualFileAdapter() {\n      @Override\n      public void fileDeleted(@NotNull VirtualFileEvent event) {\n        getRegisteredFiles(project).remove(event.getFile());\n      }\n    }, project);\n\n    myProject.getMessageBus().connect().subscribe(ProjectTopics.PROJECT_ROOTS, new ModuleRootAdapter() {\n      @Override\n      public void rootsChanged(ModuleRootEvent event) {\n        Map<VirtualFile, AccessStatus> files = getRegisteredFiles(project);\n        \n        // reset access status and notifications for files that became project files  \n        for (VirtualFile each : new ArrayList<VirtualFile>(files.keySet())) {\n          if (isProjectFile(each)) {\n            files.remove(each);\n            EditorNotifications.getInstance(myProject).updateNotifications(each);\n          }\n        }\n      }\n    });\n  }","id":23655,"modified_method":"public NonProjectFileWritingAccessProvider(@NotNull final Project project) {\n    myProject = project;\n    VirtualFileManager.getInstance().addVirtualFileListener(new VirtualFileAdapter() {\n      @Override\n      public void fileDeleted(@NotNull VirtualFileEvent event) {\n        getRegisteredFiles(project).remove(event.getFile());\n      }\n    }, project);\n\n    myProject.getMessageBus().connect().subscribe(ProjectTopics.PROJECT_ROOTS, new ModuleRootAdapter() {\n      @Override\n      public void rootsChanged(ModuleRootEvent event) {\n        Map<VirtualFile, AccessStatus> files = getRegisteredFiles(project);\n        \n        // reset access status and notifications for files that became project files  \n        for (VirtualFile each : new ArrayList<VirtualFile>(files.keySet())) {\n          if (isProjectFile(each)) {\n            files.remove(each);\n          }\n        }\n      }\n    });\n  }","commit_id":"6c0132db48220510441dbbfd8cd026fb21d00a2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static CallbackData create(@NotNull final Runnable afterUpdate, final String title, final ModalityState state,\n                                    final InvokeAfterUpdateMode mode, @NotNull final Project project) {\n    if (mode.isSilently()) {\n      return new CallbackData(new Runnable() {\n        public void run() {\n          if (mode.isCallbackOnAwt()) {\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              public void run() {\n                LOG.debug(\"invokeAfterUpdate: silent wrapper called for project: \" + project.getName());\n                if (project.isDisposed()) return;\n                afterUpdate.run();\n              }\n            });\n          }\n          else {\n            ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n              @Override\n              public void run() {\n                if (!project.isDisposed()) afterUpdate.run();\n              }\n            });\n          }\n        }\n      }, null);\n    }\n    else {\n      if (mode.isSynchronous()) {\n        final Waiter waiter = new Waiter(project, afterUpdate,\n                                         VcsBundle.message(\"change.list.manager.wait.lists.synchronization\", title), mode.isCancellable());\n        return new CallbackData(\n          new Runnable() {\n            public void run() {\n              LOG.debug(\"invokeAfterUpdate: NOT silent SYNCHRONOUS wrapper called for project: \" + project.getName());\n              waiter.done();\n            }\n          }, new Runnable() {\n          public void run() {\n            ProgressManager.getInstance().run(waiter);\n          }\n        }\n        );\n      }\n      else {\n        final FictiveBackgroundable fictiveBackgroundable =\n          new FictiveBackgroundable(project, afterUpdate, mode.isCancellable(), title, state);\n        return new CallbackData(\n          new Runnable() {\n            public void run() {\n              LOG.debug(\"invokeAfterUpdate: NOT silent wrapper called for project: \" + project.getName());\n              fictiveBackgroundable.done();\n            }\n          }, new Runnable() {\n          public void run() {\n            ProgressManager.getInstance().run(fictiveBackgroundable);\n          }\n        }\n        );\n      }\n    }\n  }","id":23656,"modified_method":"@NotNull\n  public static CallbackData create(@NotNull Project project,\n                                    @NotNull InvokeAfterUpdateMode mode,\n                                    @NotNull Runnable afterUpdate,\n                                    @Nullable String title,\n                                    @Nullable ModalityState state) {\n    return mode.isSilently() ? createSilent(project, mode, afterUpdate) : createInteractive(project, mode, afterUpdate, title, state);\n  }","commit_id":"1cb8ecd0366e51126375e7969d0030a5a613a265","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void run(@NotNull final ProgressIndicator indicator) {\n    myWaiter.run(indicator);\n    WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n        public void run() {\n          myWaiter.onSuccess();\n        }\n      }, myState == null ? ModalityState.NON_MODAL : myState, myProject);\n  }","id":23657,"modified_method":"public void run(@NotNull ProgressIndicator indicator) {\n    myWaiter.run(indicator);\n    runOrInvokeLaterAboveProgress(() -> myWaiter.onSuccess(), notNull(myState, ModalityState.NON_MODAL), myProject);\n  }","commit_id":"1cb8ecd0366e51126375e7969d0030a5a613a265","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invokeAfterUpdate(final Runnable afterUpdate, final InvokeAfterUpdateMode mode, final String title,\n                                @Nullable final Consumer<VcsDirtyScopeManager> dirtyScopeManagerFiller, final ModalityState state) {\n    LOG.debug(\"invokeAfterUpdate for project: \" + myProject.getName());\n    final CallbackData data = CallbackData.create(afterUpdate, title, state, mode, myProject);\n\n    if (dirtyScopeManagerFiller != null) {\n      VcsDirtyScopeManagerProxy managerProxy = new VcsDirtyScopeManagerProxy();\n\n      dirtyScopeManagerFiller.consume(managerProxy);\n      if (!myProject.isDisposed()) {\n        managerProxy.callRealManager(VcsDirtyScopeManager.getInstance(myProject));\n      }\n    }\n\n    synchronized (myLock) {\n      if (! myStopped) {\n        myWaitingUpdateCompletionQueue.add(data.getCallback());\n        schedule();\n      }\n    }\n    // do not run under lock; stopped cannot be switched into not stopped - can check without lock\n    if (myStopped) {\n      LOG.debug(\"invokeAfterUpdate: stopped, invoke right now for project: \" + myProject.getName());\n      SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n          if (!myProject.isDisposed()) {\n            afterUpdate.run();\n          }\n        }\n      });\n      return;\n    }\n    // invoke progress if needed\n    if (data.getWrapperStarter() != null) {\n      data.getWrapperStarter().run();\n    }\n    LOG.debug(\"invokeAfterUpdate: exit for project: \" + myProject.getName());\n  }","id":23658,"modified_method":"public void invokeAfterUpdate(@NotNull Runnable afterUpdate,\n                                @NotNull InvokeAfterUpdateMode mode,\n                                @Nullable String title,\n                                @Nullable Consumer<VcsDirtyScopeManager> dirtyScopeManagerFiller,\n                                @Nullable ModalityState state) {\n    LOG.debug(\"invokeAfterUpdate for project: \" + myProject.getName());\n    final CallbackData data = CallbackData.create(myProject, mode, afterUpdate, title, state);\n\n    if (dirtyScopeManagerFiller != null) {\n      VcsDirtyScopeManagerProxy managerProxy = new VcsDirtyScopeManagerProxy();\n\n      dirtyScopeManagerFiller.consume(managerProxy);\n      if (!myProject.isDisposed()) {\n        managerProxy.callRealManager(VcsDirtyScopeManager.getInstance(myProject));\n      }\n    }\n\n    synchronized (myLock) {\n      if (! myStopped) {\n        myWaitingUpdateCompletionQueue.add(data.getCallback());\n        schedule();\n      }\n    }\n    // do not run under lock; stopped cannot be switched into not stopped - can check without lock\n    if (myStopped) {\n      LOG.debug(\"invokeAfterUpdate: stopped, invoke right now for project: \" + myProject.getName());\n      SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n          if (!myProject.isDisposed()) {\n            afterUpdate.run();\n          }\n        }\n      });\n      return;\n    }\n    // invoke progress if needed\n    data.getWrapperStarter().run();\n    LOG.debug(\"invokeAfterUpdate: exit for project: \" + myProject.getName());\n  }","commit_id":"1cb8ecd0366e51126375e7969d0030a5a613a265","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void execute(Collection<Change> changes, String commitMessage) {\n      final String fileName = myPanel.getFileName();\n      final File file = new File(fileName).getAbsoluteFile();\n      if (file.exists()) {\n        final int[] result = new int[1];\n        WaitForProgressToShow.runOrInvokeAndWaitAboveProgress(new Runnable() {\n          @Override\n          public void run() {\n            result[0] = Messages.showYesNoDialog(myProject, \"File \" + file.getName() + \" (\" + file.getParent() + \")\" +\n                                                            \" already exists.\\nDo you want to overwrite it?\",\n                                                 CommonBundle.getWarningTitle(), Messages.getWarningIcon());\n          }\n        });\n        if (Messages.NO == result[0]) return;\n      }\n      if (file.getParentFile() == null) {\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          @Override\n          public void run() {\n            Messages.showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", \"Can not write patch to specified file: \" +\n                                                                                              file.getPath()), CommonBundle.getErrorTitle());\n          }\n        }, ModalityState.NON_MODAL, myProject);\n        return;\n      }\n\n      int binaryCount = 0;\n      for(Change change: changes) {\n        if (ChangesUtil.isBinaryChange(change)) {\n          binaryCount++;\n        }\n      }\n      if (binaryCount == changes.size()) {\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          public void run() {\n            Messages.showInfoMessage(myProject, VcsBundle.message(\"create.patch.all.binary\"),\n                                     VcsBundle.message(\"create.patch.commit.action.title\"));\n          }\n        }, null, myProject);\n        return;\n      }\n      try {\n        file.getParentFile().mkdirs();\n        VcsConfiguration.getInstance(myProject).acceptLastCreatedPatchName(file.getName());\n        PATCH_PATH = file.getParent();\n        VcsApplicationSettings.getInstance().PATCH_STORAGE_LOCATION = PATCH_PATH;\n        final boolean reversePatch = myPanel.isReversePatch();\n\n        String baseDirName = myPanel.getBaseDirName();\n        List<FilePatch> patches = IdeaTextPatchBuilder.buildPatch(myProject, changes, baseDirName, reversePatch);\n        PatchWriter.writePatches(myProject, fileName, baseDirName, patches, myCommitContext, myPanel.getEncoding());\n        final String message;\n        if (binaryCount == 0) {\n          message = VcsBundle.message(\"create.patch.success.confirmation\", file.getPath());\n        }\n        else {\n          message = VcsBundle.message(\"create.patch.partial.success.confirmation\", file.getPath(),\n                                      binaryCount);\n        }\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          public void run() {\n            final VcsConfiguration configuration = VcsConfiguration.getInstance(myProject);\n            if (Boolean.TRUE.equals(configuration.SHOW_PATCH_IN_EXPLORER)) {\n              ShowFilePathAction.openFile(file);\n            } else if (Boolean.FALSE.equals(configuration.SHOW_PATCH_IN_EXPLORER)) {\n              return;\n            } else {\n              configuration.SHOW_PATCH_IN_EXPLORER =\n                ShowFilePathAction.showDialog(myProject, message, VcsBundle.message(\"create.patch.commit.action.title\"), file);\n            }\n          }\n        }, null, myProject);\n      } catch (ProcessCanceledException e) {\n        //\n      } catch (final Exception ex) {\n        LOG.info(ex);\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          public void run() {\n            Messages.showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", ex.getMessage()),\n                                     CommonBundle.getErrorTitle());\n          }\n        }, null, myProject);\n      }\n    }","id":23659,"modified_method":"public void execute(Collection<Change> changes, String commitMessage) {\n      final String fileName = myPanel.getFileName();\n      final File file = new File(fileName).getAbsoluteFile();\n      if (file.exists()) {\n        final int[] result = new int[1];\n        WaitForProgressToShow.runOrInvokeAndWaitAboveProgress(\n          () -> result[0] = Messages.showYesNoDialog(myProject, \"File \" + file.getName() + \" (\" + file.getParent() + \")\" +\n                                                                \" already exists.\\nDo you want to overwrite it?\",\n                                                     CommonBundle.getWarningTitle(), Messages.getWarningIcon()));\n        if (Messages.NO == result[0]) return;\n      }\n      if (file.getParentFile() == null) {\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(() ->\n                                                              Messages.showErrorDialog(myProject, VcsBundle\n                                                                .message(\"create.patch.error.title\",\n                                                                         \"Can not write patch to specified file: \" +\n                                                                         file.getPath()), CommonBundle.getErrorTitle()),\n                                                            ModalityState.NON_MODAL, myProject);\n        return;\n      }\n      try {\n        //noinspection ResultOfMethodCallIgnored\n        file.getParentFile().mkdirs();\n        VcsConfiguration.getInstance(myProject).acceptLastCreatedPatchName(file.getName());\n        PATCH_PATH = file.getParent();\n        VcsApplicationSettings.getInstance().PATCH_STORAGE_LOCATION = PATCH_PATH;\n        final boolean reversePatch = myPanel.isReversePatch();\n\n        String baseDirName = myPanel.getBaseDirName();\n        List<FilePatch> patches = IdeaTextPatchBuilder.buildPatch(myProject, changes, baseDirName, reversePatch);\n        PatchWriter.writePatches(myProject, fileName, baseDirName, patches, myCommitContext, myPanel.getEncoding(), true);\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(() -> {\n          final VcsConfiguration configuration = VcsConfiguration.getInstance(myProject);\n          if (Boolean.TRUE.equals(configuration.SHOW_PATCH_IN_EXPLORER)) {\n            ShowFilePathAction.openFile(file);\n          }\n          else if (configuration.SHOW_PATCH_IN_EXPLORER == null) {\n            configuration.SHOW_PATCH_IN_EXPLORER =\n              ShowFilePathAction.showDialog(myProject, VcsBundle.message(\"create.patch.success.confirmation\", file.getPath()),\n                                            VcsBundle.message(\"create.patch.commit.action.title\"), file);\n          }\n        }, null, myProject);\n      } catch (ProcessCanceledException e) {\n        //\n      } catch (final Exception ex) {\n        LOG.info(ex);\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(\n          () -> Messages.showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", ex.getMessage()),\n                                         CommonBundle.getErrorTitle()), null, myProject);\n      }\n    }","commit_id":"936637adcf887adf2759b07d35a58909002a259f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void writePatches(@NotNull final Project project,\n                                  String fileName,\n                                  @Nullable String basePath,\n                                  List<FilePatch> patches,\n                                  CommitContext commitContext,\n                                  @NotNull Charset charset) throws IOException {\n    Writer writer = new OutputStreamWriter(new FileOutputStream(fileName), charset);\n    try {\n      final String lineSeparator = CodeStyleFacade.getInstance(project).getLineSeparator();\n      UnifiedDiffWriter\n        .write(project, basePath, patches, writer, lineSeparator, Extensions.getExtensions(PatchEP.EP_NAME, project), commitContext);\n    }\n    finally {\n      writer.close();\n    }\n  }","id":23660,"modified_method":"public static void writePatches(@NotNull final Project project,\n                                  String fileName,\n                                  @NotNull String basePath,\n                                  List<FilePatch> patches,\n                                  CommitContext commitContext,\n                                  @NotNull Charset charset) throws IOException {\n    writePatches(project, fileName, basePath, patches, commitContext, charset, false);\n  }","commit_id":"936637adcf887adf2759b07d35a58909002a259f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void execute(Collection<Change> changes, String commitMessage) {\n      if (! myPanel.isOkToExecute()) {\n        Messages.showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", myPanel.getError()), CommonBundle.getErrorTitle());\n        return;\n      }\n      int binaryCount = 0;\n      for(Change change: changes) {\n        if (ChangesUtil.isBinaryChange(change)) {\n          binaryCount++;\n        }\n      }\n      if (binaryCount == changes.size()) {\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          public void run() {\n            Messages.showInfoMessage(myProject, VcsBundle.message(\"create.patch.all.binary\"),\n                                     VcsBundle.message(\"create.patch.commit.action.title\"));\n          }\n        }, null, myProject);\n        return;\n      }\n      try {\n        final String fileName = myPanel.getFileName();\n        final File file = new File(fileName).getAbsoluteFile();\n        VcsConfiguration.getInstance(myProject).acceptLastCreatedPatchName(file.getName());\n        PATCH_PATH = file.getParent();\n        REVERSE_PATCH = myPanel.isReversePatch();\n        \n        List<FilePatch> patches = IdeaTextPatchBuilder.buildPatch(myProject, changes, myProject.getBaseDir().getPresentableUrl(), REVERSE_PATCH);\n        PatchWriter.writePatches(myProject, fileName, patches);\n        if (binaryCount == 0) {\n          WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n            public void run() {\n              Messages.showInfoMessage(myProject, VcsBundle.message(\"create.patch.success.confirmation\", file.getPath()),\n                                       VcsBundle.message(\"create.patch.commit.action.title\"));\n            }\n          }, null, myProject);\n        }\n        else {\n          final int binaryCount1 = binaryCount;\n          WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n            public void run() {\n              Messages.showInfoMessage(myProject, VcsBundle.message(\"create.patch.partial.success.confirmation\", file.getPath(),\n                                                                    binaryCount1),\n                                       VcsBundle.message(\"create.patch.commit.action.title\"));\n            }\n          }, null, myProject);\n        }\n      }\n      catch (final Exception ex) {\n        LOG.info(ex);\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          public void run() {\n            Messages.showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", ex.getMessage()), CommonBundle.getErrorTitle());\n          }\n        }, null, myProject);\n      }\n    }","id":23661,"modified_method":"public void execute(Collection<Change> changes, String commitMessage) {\n      if (! myPanel.isOkToExecute()) {\n        Messages.showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", myPanel.getError()), CommonBundle.getErrorTitle());\n        return;\n      }\n      int binaryCount = 0;\n      for(Change change: changes) {\n        if (ChangesUtil.isBinaryChange(change)) {\n          binaryCount++;\n        }\n      }\n      if (binaryCount == changes.size()) {\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          public void run() {\n            Messages.showInfoMessage(myProject, VcsBundle.message(\"create.patch.all.binary\"),\n                                     VcsBundle.message(\"create.patch.commit.action.title\"));\n          }\n        }, null, myProject);\n        return;\n      }\n      try {\n        final String fileName = myPanel.getFileName();\n        final File file = new File(fileName).getAbsoluteFile();\n        VcsConfiguration.getInstance(myProject).acceptLastCreatedPatchName(file.getName());\n        PATCH_PATH = file.getParent();\n        REVERSE_PATCH = myPanel.isReversePatch();\n        \n        List<FilePatch> patches = IdeaTextPatchBuilder.buildPatch(myProject, changes, myProject.getBaseDir().getPresentableUrl(), REVERSE_PATCH);\n        PatchWriter.writePatches(myProject, fileName, patches);\n        final String message;\n        if (binaryCount == 0) {\n          message = VcsBundle.message(\"create.patch.success.confirmation\", file.getPath());\n        }\n        else {\n          message = VcsBundle.message(\"create.patch.partial.success.confirmation\", file.getPath(),\n                                      binaryCount);\n        }\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          public void run() {\n            if (Messages.showDialog(myProject, message,\n                                    VcsBundle.message(\"create.patch.commit.action.title\"),\n                                    new String[]{RevealFileAction.getActionName(), IdeBundle.message(\"action.close\")},\n                                    0, Messages.getInformationIcon()) == 0) {\n              ShowFilePathAction.open(file, file);\n            }\n          }\n        }, null, myProject);\n      }\n      catch (final Exception ex) {\n        LOG.info(ex);\n        WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n          public void run() {\n            Messages.showErrorDialog(myProject, VcsBundle.message(\"create.patch.error.title\", ex.getMessage()), CommonBundle.getErrorTitle());\n          }\n        }, null, myProject);\n      }\n    }","commit_id":"0d15172bb196ddb076755334066dc61a5a6c29e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createPatch() {\n    try {\n      if (!myModel.canPerformCreatePatch()) {\n        showError(message(\"message.cannot.create.patch.because.of.unavailable.content\"));\n        return;\n      }\n\n      CreatePatchConfigurationPanel p = new CreatePatchConfigurationPanel(myProject);\n      p.setFileName(getDefaultPatchFile());\n      if (!showAsDialog(p)) return;\n      myModel.createPatch(p.getFileName(), p.isReversePatch());\n\n      showNotification(LocalHistoryBundle.message(\"message.patch.created\"));\n    }\n    catch (VcsException e) {\n      showError(message(\"message.error.during.create.patch\", e));\n    }\n    catch (IOException e) {\n      showError(message(\"message.error.during.create.patch\", e));\n    }\n  }","id":23662,"modified_method":"private void createPatch() {\n    try {\n      if (!myModel.canPerformCreatePatch()) {\n        showError(message(\"message.cannot.create.patch.because.of.unavailable.content\"));\n        return;\n      }\n\n      CreatePatchConfigurationPanel p = new CreatePatchConfigurationPanel(myProject);\n      p.setFileName(getDefaultPatchFile());\n      if (!showAsDialog(p)) return;\n      myModel.createPatch(p.getFileName(), p.isReversePatch());\n\n      showNotification(LocalHistoryBundle.message(\"message.patch.created\"));\n      ShowFilePathAction.open(new File(p.getFileName()), null);\n    }\n    catch (VcsException e) {\n      showError(message(\"message.error.during.create.patch\", e));\n    }\n    catch (IOException e) {\n      showError(message(\"message.error.during.create.patch\", e));\n    }\n  }","commit_id":"0d15172bb196ddb076755334066dc61a5a6c29e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * @return the DecorationModel instance from <code>site.xml<\/code>\n     * @throws MojoExecutionException if any\n     */\n    private DecorationModel getDefaultDecorationModel()\n        throws MojoExecutionException\n    {\n        if ( this.defaultDecorationModel == null )\n        {\n            final Locale locale = getDefaultLocale();\n\n            final File descriptorFile =\n                siteTool.getSiteDescriptorFromBasedir( PathUtils.toRelative( project.getBasedir(),\n                                                                             siteDirectory.getAbsolutePath() ),\n                                                       project.getBasedir(), locale );\n            DecorationModel decoration = null;\n            if ( descriptorFile.exists() )\n            {\n                XmlStreamReader reader = null;\n                try\n                {\n                    reader = ReaderFactory.newXmlReader( descriptorFile );\n                    String siteDescriptorContent = IOUtil.toString( reader );\n\n                    siteDescriptorContent =\n                        siteTool.getInterpolatedSiteDescriptorContent( new HashMap(), project, siteDescriptorContent,\n                                                                       reader.getEncoding(), reader.getEncoding() );\n\n                    decoration = new DecorationXpp3Reader().read( new StringReader( siteDescriptorContent ) );\n                }\n                catch ( XmlPullParserException e )\n                {\n                    throw new MojoExecutionException( \"Error parsing site descriptor\", e );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Error reading site descriptor\", e );\n                }\n                catch ( SiteToolException e )\n                {\n                    throw new MojoExecutionException( \"Error when interpoling site descriptor\", e );\n                }\n                finally\n                {\n                    IOUtil.close( reader );\n                }\n            }\n\n            this.defaultDecorationModel = decoration;\n        }\n\n        return this.defaultDecorationModel;\n    }","id":23663,"modified_method":"/**\n     * @return the DecorationModel instance from <code>site.xml<\/code>\n     * @throws MojoExecutionException if any\n     */\n    private DecorationModel getDefaultDecorationModel()\n        throws MojoExecutionException\n    {\n        if ( this.defaultDecorationModel == null )\n        {\n            final Locale locale = getDefaultLocale();\n\n            final File basedir = project.getBasedir();\n            final String relativePath = siteTool.getRelativePath(\n                    basedir.getAbsolutePath(), siteDirectory.getAbsolutePath() );\n\n            final File descriptorFile = siteTool.getSiteDescriptorFromBasedir( relativePath, basedir, locale );\n            DecorationModel decoration = null;\n\n            if ( descriptorFile.exists() )\n            {\n                XmlStreamReader reader = null;\n                try\n                {\n                    reader = ReaderFactory.newXmlReader( descriptorFile );\n                    String siteDescriptorContent = IOUtil.toString( reader );\n\n                    siteDescriptorContent =\n                        siteTool.getInterpolatedSiteDescriptorContent( new HashMap(), project, siteDescriptorContent,\n                                                                       reader.getEncoding(), reader.getEncoding() );\n\n                    decoration = new DecorationXpp3Reader().read( new StringReader( siteDescriptorContent ) );\n                }\n                catch ( XmlPullParserException e )\n                {\n                    throw new MojoExecutionException( \"Error parsing site descriptor\", e );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Error reading site descriptor\", e );\n                }\n                catch ( SiteToolException e )\n                {\n                    throw new MojoExecutionException( \"Error when interpoling site descriptor\", e );\n                }\n                finally\n                {\n                    IOUtil.close( reader );\n                }\n            }\n\n            this.defaultDecorationModel = decoration;\n        }\n\n        return this.defaultDecorationModel;\n    }","commit_id":"bd1a4fa604fa5f6235ed78a5ca7a6b8d598bbc44","url":"https://github.com/apache/maven-plugins"},{"original_method":"public Jdk6TestMavenProjectStub()\n    {\n        readModel( new File( getBasedir(), \"jdk6-test-plugin-config.xml\" ) );\n\n        setGroupId( getModel().getGroupId() );\n        setArtifactId( getModel().getArtifactId() );\n        setVersion( getModel().getVersion() );\n        setName( getModel().getName() );\n        setUrl( getModel().getUrl() );\n        setPackaging( getModel().getPackaging() );\n\n        Scm scm = new Scm();\n        scm.setConnection( \"scm:svn:http://svn.apache.org/maven/sample/trunk\" );\n        setScm( scm );\n\n        Build build = new Build();\n        build.setFinalName( getModel().getArtifactId() );\n        build.setDirectory( super.getBasedir() + \"/target/test/unit/jdk6-test/target\" );\n        setBuild( build );\n\n        List compileSourceRoots = new ArrayList();\n        compileSourceRoots.add( getBasedir() + \"/src/test/resources/unit/jdk6-test/\" );\n        setCompileSourceRoots( compileSourceRoots );\n    }","id":23664,"modified_method":"public Jdk6TestMavenProjectStub()\n    {\n        readModel( new File( getBasedir(), \"jdk6-test-plugin-config.xml\" ) );\n\n        setGroupId( getModel().getGroupId() );\n        setArtifactId( getModel().getArtifactId() );\n        setVersion( getModel().getVersion() );\n        setName( getModel().getName() );\n        setUrl( getModel().getUrl() );\n        setPackaging( getModel().getPackaging() );\n\n        Scm scm = new Scm();\n        scm.setConnection( \"scm:svn:http://svn.apache.org/maven/sample/trunk\" );\n        setScm( scm );\n\n        Build build = new Build();\n        build.setFinalName( getModel().getArtifactId() );\n        build.setDirectory( super.getBasedir() + \"/target/test/unit/jdk6-test/target\" );\n        setBuild( build );\n\n        List compileSourceRoots = new ArrayList();\n        compileSourceRoots.add( getBasedir().getAbsolutePath() );\n        setCompileSourceRoots( compileSourceRoots );\n    }","commit_id":"514bc379ad046ca1d2a97d3a0860941c86764011","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Translate the absolutePath into its relative path.\n     *\n     * @param basedir      The basedir of the project.\n     * @param absolutePath The absolute path that must be translated to relative path.\n     * @return relative  Relative path of the parameter absolute path.\n     */\n    protected String toRelative( File basedir, String absolutePath )\n    {\n        String relative;\n        String convertedBasedirAbsolutePath = convertDriveLetter( basedir.getAbsolutePath() );\n        String convertedAbsolutePath = convertDriveLetter( absolutePath );\n\n        if ( convertedAbsolutePath.startsWith( convertedBasedirAbsolutePath )\n            && convertedAbsolutePath.length() > convertedBasedirAbsolutePath.length() )\n        {\n            // Simple case, path starts with basepath\n            relative = convertedAbsolutePath.substring( convertedBasedirAbsolutePath.length() + 1 );\n            relative = StringUtils.replace( relative, \"\\\\\", \"/\" );\n        }\n        else\n        {\n            // It's more complex...\n            convertedAbsolutePath = StringUtils.replace( convertedAbsolutePath, \"\\\\\", \"/\" );\n            convertedBasedirAbsolutePath = StringUtils.replace( convertedBasedirAbsolutePath, \"\\\\\", \"/\" );\n\n            StringTokenizer baseTokens = new StringTokenizer( convertedBasedirAbsolutePath, \"/\", false );\n\n            int baseCount = baseTokens.countTokens();\n            List baseTokenList = new ArrayList( baseCount );\n            while ( baseTokens.hasMoreTokens() )\n            {\n                baseTokenList.add( baseTokens.nextToken() );\n            }\n\n            StringTokenizer pathTokens = new StringTokenizer( convertedAbsolutePath, \"/\", false );\n\n            int pathCount = pathTokens.countTokens();\n            List pathTokenList = new ArrayList( pathCount );\n            while ( pathTokens.hasMoreTokens() )\n            {\n                pathTokenList.add( pathTokens.nextToken() );\n            }\n\n            int maxCount = Math.max( baseTokenList.size(), pathTokenList.size() );\n            int differIndex = -1;\n            for ( int i = 0; i < maxCount; i++ )\n            {\n                if ( i >= pathTokenList.size() || i >= baseTokenList.size() )\n                {\n                    differIndex = i;\n                    break;\n                }\n                String basePart = (String) baseTokenList.get( i );\n                String pathPart = (String) pathTokenList.get( i );\n                if ( !basePart.equals( pathPart ) )\n                {\n                    differIndex = i;\n                    break;\n                }\n            }\n            if ( getLog().isDebugEnabled() )\n            {\n                getLog().debug( \"Construction of relative path... differIndex=\" + differIndex );\n            }\n            if ( differIndex < 1 )\n            {\n                // Paths are either equal or completely different\n                relative = convertedAbsolutePath;\n            }\n            else\n            {\n                StringBuffer result = new StringBuffer();\n                int parentCount = baseTokenList.size() - differIndex;\n                if ( getLog().isDebugEnabled() )\n                {\n                    getLog().debug( \"parentCount=\" + parentCount );\n                }\n                boolean isFirst = true;\n                for ( int i = 0; i < parentCount; i++ )\n                {\n                    // Add parents\n                    if ( isFirst )\n                    {\n                        isFirst = false;\n                    }\n                    else\n                    {\n                        result.append( \"/\" );\n                    }\n                    result.append( \"..\" );\n                }\n                for ( int i = differIndex; i < pathTokenList.size(); i++ )\n                {\n                    // Add the remaining path elements\n                    if ( isFirst )\n                    {\n                        isFirst = false;\n                    }\n                    else\n                    {\n                        result.append( \"/\" );\n                    }\n                    result.append( pathTokenList.get( i ) );\n                }\n                relative = result.toString();\n            }\n        }\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"toRelative(\" + basedir + \", \" + absolutePath + \") => \" + relative );\n        }\n\n        return relative;\n    }","id":23665,"modified_method":"/**\n     * Translate the absolutePath into its relative path.\n     *\n     * @param basedir      The basedir of the project.\n     * @param absolutePath The absolute path that must be translated to relative path.\n     * @return relative  Relative path of the parameter absolute path.\n     */\n    protected String toRelative( String basedir, String absolutePath )\n    {\n        String relative;\n\n        // Convert drive letter\n        String convertedBasedir = convertDriveLetter( basedir );\n        String convertedAbsolutePath = convertDriveLetter( absolutePath );\n\n        // Normalize path separators\n        convertedBasedir = StringUtils.replace( convertedBasedir, \"\\\\\", \"/\" );\n        convertedAbsolutePath = StringUtils.replace( convertedAbsolutePath, \"\\\\\", \"/\" );\n\n        // Strip trailing slash\n        if( convertedBasedir.endsWith( \"/\" ) )\n        {\n            convertedBasedir = convertedBasedir.substring( 0, convertedBasedir.length() - 1 );\n        }\n        if( convertedAbsolutePath.endsWith( \"/\" ) )\n        {\n            convertedAbsolutePath = convertedAbsolutePath.substring( 0, convertedAbsolutePath.length() - 1 );\n        }\n\n        if ( convertedAbsolutePath.startsWith( convertedBasedir )\n            && convertedAbsolutePath.length() > convertedBasedir.length() )\n        {\n            // Simple case, path starts with basepath\n            relative = convertedAbsolutePath.substring( convertedBasedir.length() + 1 );\n        }\n        else\n        {\n            // It's more complex...\n            StringTokenizer baseTokens = new StringTokenizer( convertedBasedir, \"/\", false );\n\n            int baseCount = baseTokens.countTokens();\n            List baseTokenList = new ArrayList( baseCount );\n            while ( baseTokens.hasMoreTokens() )\n            {\n                baseTokenList.add( baseTokens.nextToken() );\n            }\n\n            StringTokenizer pathTokens = new StringTokenizer( convertedAbsolutePath, \"/\", false );\n\n            int pathCount = pathTokens.countTokens();\n            List pathTokenList = new ArrayList( pathCount );\n            while ( pathTokens.hasMoreTokens() )\n            {\n                pathTokenList.add( pathTokens.nextToken() );\n            }\n\n            int maxCount = Math.max( baseTokenList.size(), pathTokenList.size() );\n            int differIndex = -1;\n            for ( int i = 0; i < maxCount; i++ )\n            {\n                if ( i >= pathTokenList.size() || i >= baseTokenList.size() )\n                {\n                    differIndex = i;\n                    break;\n                }\n                String basePart = (String) baseTokenList.get( i );\n                String pathPart = (String) pathTokenList.get( i );\n                if ( !basePart.equals( pathPart ) )\n                {\n                    differIndex = i;\n                    break;\n                }\n            }\n            if ( getLog().isDebugEnabled() )\n            {\n                getLog().debug( \"Construction of relative path... differIndex=\" + differIndex );\n            }\n            if ( differIndex < 1 )\n            {\n                // Paths are either equal or completely different\n                relative = convertedAbsolutePath;\n            }\n            else\n            {\n                StringBuffer result = new StringBuffer();\n                int parentCount = baseTokenList.size() - differIndex;\n                if ( getLog().isDebugEnabled() )\n                {\n                    getLog().debug( \"parentCount=\" + parentCount );\n                }\n                boolean isFirst = true;\n                for ( int i = 0; i < parentCount; i++ )\n                {\n                    // Add parents\n                    if ( isFirst )\n                    {\n                        isFirst = false;\n                    }\n                    else\n                    {\n                        result.append( \"/\" );\n                    }\n                    result.append( \"..\" );\n                }\n                for ( int i = differIndex; i < pathTokenList.size(); i++ )\n                {\n                    // Add the remaining path elements\n                    if ( isFirst )\n                    {\n                        isFirst = false;\n                    }\n                    else\n                    {\n                        result.append( \"/\" );\n                    }\n                    result.append( pathTokenList.get( i ) );\n                }\n                relative = result.toString();\n            }\n        }\n\n        if ( getLog().isDebugEnabled() )\n        {\n            getLog().debug( \"toRelative(\" + basedir + \", \" + absolutePath + \") => \" + relative );\n        }\n\n        return relative;\n    }","commit_id":"4a432fa55fc2cbc28a05b16bfa4a7676632200b2","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Translate the relative path of the file into module path\n     *\n     * @param basedir File to use as basedir\n     * @param path    Absolute path string to translate to ModuleFileUrl\n     * @return moduleFileUrl Translated Module File URL\n     */\n    private String getModuleFileUrl( File basedir, String path )\n    {\n        return \"file://$MODULE_DIR$/\" + toRelative( basedir, path );\n    }","id":23666,"modified_method":"/**\n     * Translate the relative path of the file into module path\n     *\n     * @param basedir File to use as basedir\n     * @param path    Absolute path string to translate to ModuleFileUrl\n     * @return moduleFileUrl Translated Module File URL\n     */\n    private String getModuleFileUrl( File basedir, String path )\n    {\n        return \"file://$MODULE_DIR$/\" + toRelative( basedir.getAbsolutePath(), path );\n    }","commit_id":"4a432fa55fc2cbc28a05b16bfa4a7676632200b2","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testToRelative()\n    {\n        String relativePath;\n\n        relativePath = mojo.toRelative( new File( \"C:/dev/voca/gateway/\" ),\n                                               \"C:/dev/voca/gateway/parser/gateway-parser.iml\" );\n        assertEquals( \"Test toRelative child\", \"parser/gateway-parser.iml\", relativePath );\n\n        relativePath = mojo.toRelative( new File( \"C:\\\\foo\\\\master \" ),\n                                               \"C:\\\\foo\\\\child\" );\n        assertEquals( \"Test toRelative sibling\", \"../child\", relativePath );\n    }","id":23667,"modified_method":"public void testToRelative()\n    {\n        String relativePath;\n\n        relativePath = mojo.toRelative( \"C:\\\\dev\\\\voca\\\\gateway\",\n                                        \"C:/dev/voca/gateway/parser/gateway-parser.iml\" );\n        assertEquals( \"Test toRelative child, backslash\", \"parser/gateway-parser.iml\", relativePath );\n\n        relativePath = mojo.toRelative( \"C:\\\\dev\\\\voca\\\\gateway\\\\\",\n                                        \"C:/dev/voca/gateway/parser/gateway-parser.iml\" );\n        assertEquals( \"Test toRelative child, trailing backslash\", \"parser/gateway-parser.iml\", relativePath );\n\n        relativePath = mojo.toRelative( \"C:/dev/voca/gateway\",\n                                        \"C:/dev/voca/gateway/parser/gateway-parser.iml\" );\n        assertEquals( \"Test toRelative child, slash\", \"parser/gateway-parser.iml\", relativePath );\n\n        relativePath = mojo.toRelative( \"C:/dev/voca/gateway/\",\n                                        \"C:/dev/voca/gateway/parser/gateway-parser.iml\" );\n        assertEquals( \"Test toRelative child, trailing slash\", \"parser/gateway-parser.iml\", relativePath );\n\n        relativePath = mojo.toRelative( \"C:\\\\foo\\\\master\",\n                                        \"C:\\\\foo\\\\child\" );\n        assertEquals( \"Test toRelative sibling, no trailing backspace\", \"../child\", relativePath );\n\n        relativePath = mojo.toRelative( \"C:\\\\foo\\\\master\\\\\",\n                                        \"C:\\\\foo\\\\child\" );\n        assertEquals( \"Test toRelative sibling, first trailing backspace\", \"../child\", relativePath );\n\n        relativePath = mojo.toRelative( \"C:\\\\foo\\\\master\",\n                                        \"C:\\\\foo\\\\child\\\\\" );\n        assertEquals( \"Test toRelative sibling, second trailing backspace\", \"../child\", relativePath );\n\n        relativePath = mojo.toRelative( \"C:\\\\foo\\\\master\\\\\",\n                                        \"C:\\\\foo\\\\child\\\\\" );\n        assertEquals( \"Test toRelative sibling, both trailing backspace\", \"../child\", relativePath );\n    }","commit_id":"4a432fa55fc2cbc28a05b16bfa4a7676632200b2","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void rewriteProject()\n        throws MojoExecutionException\n    {\n        File projectFile = new File( executedProject.getBasedir(), executedProject.getArtifactId() + \".ipr\" );\n\n        try\n        {\n            Document document = readXmlDocument( projectFile, \"project.xml\" );\n\n            Element module = document.getRootElement();\n\n            // Set the jdk name if set\n            if ( jdkName != null )\n            {\n                setJdkName( module, jdkName );\n            }\n            else\n            {\n                String javaVersion = System.getProperty( \"java.version\" );\n                String defaultJdkName;\n\n                if ( ideaVersion.startsWith( \"4\" ) )\n                {\n                    defaultJdkName = \"java version &quot;\" + javaVersion + \"&quot;\";\n                }\n                else\n                {\n                    defaultJdkName = javaVersion.substring( 0, 3 );\n                }\n                getLog().info( \"jdkName is not set, using [java version\" + javaVersion + \"] as default.\" );\n                setJdkName( module, defaultJdkName );\n            }\n\n            setWildcardResourcePatterns( module, wildcardResourcePatterns );\n\n            Element component = findComponent( module, \"ProjectModuleManager\" );\n            Element modules = findElement( component, \"modules\" );\n\n            removeOldElements( modules, \"module\" );\n\n            if ( executedProject.getCollectedProjects().size() > 0 )\n            {\n                Element m = createElement( modules, \"module\" );\n                String projectPath =\n                    new File( executedProject.getBasedir(),\n                              executedProject.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.addAttribute( \"filepath\",\n                                \"$PROJECT_DIR$/\" + toRelative( executedProject.getBasedir(), projectPath ) );\n\n                for ( Iterator i = executedProject.getCollectedProjects().iterator(); i.hasNext(); )\n                {\n                    MavenProject p = (MavenProject) i.next();\n\n                    m = createElement( modules, \"module\" );\n                    String modulePath = new File( p.getBasedir(), p.getArtifactId() + \".iml\" ).getAbsolutePath();\n                    m.addAttribute( \"filepath\",\n                                    \"$PROJECT_DIR$/\" + toRelative( executedProject.getBasedir(), modulePath ) );\n                }\n            }\n            else\n            {\n                Element m = createElement( modules, \"module\" );\n                String modulePath =\n                    new File( executedProject.getBasedir(),\n                              executedProject.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.addAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( executedProject.getBasedir(), modulePath ) );\n            }\n\n            // add any PathMacros we've come across\n            if ( macros != null && module.elements( \"UsedPathMacros\" ).size() > 0 )\n            {\n                Element usedPathMacros = (Element) module.elements( \"UsedPathMacros\" ).get( 0 );\n                removeOldElements( usedPathMacros, \"macro\" );\n                for ( Iterator iterator = macros.iterator(); iterator.hasNext(); )\n                {\n                    String macro = (String) iterator.next();\n                    Element macroElement = createElement( usedPathMacros, \"macro\" );\n                    macroElement.addAttribute( \"name\", macro );\n                }\n            }\n\n            writeXmlDocument( projectFile, document );\n        }\n        catch ( DocumentException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n    }","id":23668,"modified_method":"public void rewriteProject()\n        throws MojoExecutionException\n    {\n        File projectFile = new File( executedProject.getBasedir(), executedProject.getArtifactId() + \".ipr\" );\n\n        try\n        {\n            Document document = readXmlDocument( projectFile, \"project.xml\" );\n\n            Element module = document.getRootElement();\n\n            // Set the jdk name if set\n            if ( jdkName != null )\n            {\n                setJdkName( module, jdkName );\n            }\n            else\n            {\n                String javaVersion = System.getProperty( \"java.version\" );\n                String defaultJdkName;\n\n                if ( ideaVersion.startsWith( \"4\" ) )\n                {\n                    defaultJdkName = \"java version &quot;\" + javaVersion + \"&quot;\";\n                }\n                else\n                {\n                    defaultJdkName = javaVersion.substring( 0, 3 );\n                }\n                getLog().info( \"jdkName is not set, using [java version\" + javaVersion + \"] as default.\" );\n                setJdkName( module, defaultJdkName );\n            }\n\n            setWildcardResourcePatterns( module, wildcardResourcePatterns );\n\n            Element component = findComponent( module, \"ProjectModuleManager\" );\n            Element modules = findElement( component, \"modules\" );\n\n            removeOldElements( modules, \"module\" );\n\n            if ( executedProject.getCollectedProjects().size() > 0 )\n            {\n                Element m = createElement( modules, \"module\" );\n                String projectPath =\n                    new File( executedProject.getBasedir(),\n                              executedProject.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.addAttribute( \"filepath\",\n                                \"$PROJECT_DIR$/\" + toRelative( executedProject.getBasedir().getAbsolutePath(), projectPath ) );\n\n                for ( Iterator i = executedProject.getCollectedProjects().iterator(); i.hasNext(); )\n                {\n                    MavenProject p = (MavenProject) i.next();\n\n                    m = createElement( modules, \"module\" );\n                    String modulePath = new File( p.getBasedir(), p.getArtifactId() + \".iml\" ).getAbsolutePath();\n                    m.addAttribute( \"filepath\",\n                                    \"$PROJECT_DIR$/\" + toRelative( executedProject.getBasedir().getAbsolutePath(), modulePath ) );\n                }\n            }\n            else\n            {\n                Element m = createElement( modules, \"module\" );\n                String modulePath =\n                    new File( executedProject.getBasedir(),\n                              executedProject.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.addAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( executedProject.getBasedir().getAbsolutePath(), modulePath ) );\n            }\n\n            // add any PathMacros we've come across\n            if ( macros != null && module.elements( \"UsedPathMacros\" ).size() > 0 )\n            {\n                Element usedPathMacros = (Element) module.elements( \"UsedPathMacros\" ).get( 0 );\n                removeOldElements( usedPathMacros, \"macro\" );\n                for ( Iterator iterator = macros.iterator(); iterator.hasNext(); )\n                {\n                    String macro = (String) iterator.next();\n                    Element macroElement = createElement( usedPathMacros, \"macro\" );\n                    macroElement.addAttribute( \"name\", macro );\n                }\n            }\n\n            writeXmlDocument( projectFile, document );\n        }\n        catch ( DocumentException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n    }","commit_id":"4a432fa55fc2cbc28a05b16bfa4a7676632200b2","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void addFileSet( FileSet fileSet, Archiver archiver, AssemblerConfigurationSource configSource,\n                               File archiveBaseDir )\n        throws AssemblyFormattingException, ArchiveCreationException\n    {\n        // throw this check in just in case someone extends this class...\n        checkLogger();\n\n        FileSetFormatter fileSetFormatter = new FileSetFormatter( configSource, logger );\n\n        File basedir = configSource.getBasedir();\n        \n        if ( project == null )\n        {\n            project = configSource.getProject();\n        }\n\n        String destDirectory = fileSet.getOutputDirectory();\n\n        if ( destDirectory == null )\n        {\n            destDirectory = fileSet.getDirectory();\n        }\n\n        if ( logger.isDebugEnabled() )\n        {\n            logger.debug( \"FileSet[\" + destDirectory + \"]\" + \" dir perms: \"\n                + Integer.toString( archiver.getDefaultDirectoryMode(), 8 ) + \" file perms: \"\n                + Integer.toString( archiver.getDefaultFileMode(), 8 )\n                + ( fileSet.getLineEnding() == null ? \"\" : \" lineEndings: \" + fileSet.getLineEnding() ) );\n        }\n\n        destDirectory = AssemblyFormatUtils.getOutputDirectory( destDirectory, project, configSource.getFinalName(),\n                                                                includeBaseDirectory );\n\n        logger.debug( \"The archive base directory is '\" + archiveBaseDir.getAbsolutePath() + \"'\" );\n\n        File fileSetDir = getFileSetDirectory( fileSet, basedir, archiveBaseDir );\n\n        if ( fileSetDir.exists() )\n        {\n            try\n            {\n                fileSetDir = fileSetFormatter.formatFileSetForAssembly( fileSetDir, fileSet );\n            }\n            catch ( IOException e )\n            {\n                throw new ArchiveCreationException( \"Error fixing file-set line endings for assembly: \"\n                    + e.getMessage(), e );\n            }\n\n            logger.debug( \"file-set directory: '\" + fileSetDir.getAbsolutePath() + \"'\" );\n\n            AddDirectoryTask task = new AddDirectoryTask( fileSetDir );\n\n            task.setDirectoryMode( Integer.parseInt( fileSet.getDirectoryMode(), 8 ) );\n            task.setFileMode( Integer.parseInt( fileSet.getFileMode(), 8 ) );\n            task.setExcludes( fileSet.getExcludes() );\n            task.setIncludes( fileSet.getIncludes() );\n            task.setOutputDirectory( destDirectory );\n\n            task.execute( archiver, configSource );\n        }\n    }","id":23669,"modified_method":"protected void addFileSet( FileSet fileSet, Archiver archiver, AssemblerConfigurationSource configSource,\n                               File archiveBaseDir )\n        throws AssemblyFormattingException, ArchiveCreationException\n    {\n        // throw this check in just in case someone extends this class...\n        checkLogger();\n\n        FileSetFormatter fileSetFormatter = new FileSetFormatter( configSource, logger );\n\n        File basedir = configSource.getBasedir();\n        \n        if ( project == null )\n        {\n            project = configSource.getProject();\n        }\n\n        String destDirectory = fileSet.getOutputDirectory();\n\n        if ( destDirectory == null )\n        {\n            destDirectory = fileSet.getDirectory();\n        }\n\n        if ( logger.isDebugEnabled() )\n        {\n            logger.debug( \"FileSet[\" + destDirectory + \"]\" + \" dir perms: \"\n                + Integer.toString( archiver.getDefaultDirectoryMode(), 8 ) + \" file perms: \"\n                + Integer.toString( archiver.getDefaultFileMode(), 8 )\n                + ( fileSet.getLineEnding() == null ? \"\" : \" lineEndings: \" + fileSet.getLineEnding() ) );\n        }\n\n        destDirectory = AssemblyFormatUtils.getOutputDirectory( destDirectory, project, configSource.getFinalName(),\n                                                                includeBaseDirectory );\n\n        logger.debug( \"The archive base directory is '\" + archiveBaseDir + \"'\" );\n\n        File fileSetDir = getFileSetDirectory( fileSet, basedir, archiveBaseDir );\n\n        if ( fileSetDir.exists() )\n        {\n            try\n            {\n                fileSetDir = fileSetFormatter.formatFileSetForAssembly( fileSetDir, fileSet );\n            }\n            catch ( IOException e )\n            {\n                throw new ArchiveCreationException( \"Error fixing file-set line endings for assembly: \"\n                    + e.getMessage(), e );\n            }\n\n            logger.debug( \"file-set directory: '\" + fileSetDir.getAbsolutePath() + \"'\" );\n\n            AddDirectoryTask task = new AddDirectoryTask( fileSetDir );\n\n            task.setDirectoryMode( Integer.parseInt( fileSet.getDirectoryMode(), 8 ) );\n            task.setFileMode( Integer.parseInt( fileSet.getFileMode(), 8 ) );\n            task.setExcludes( fileSet.getExcludes() );\n            task.setIncludes( fileSet.getIncludes() );\n            task.setOutputDirectory( destDirectory );\n\n            task.execute( archiver, configSource );\n        }\n    }","commit_id":"fcbf2d7e6b0034bb441e500278f97310e9a04dc8","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void assemble( File repositoryDirectory, Repository repository, AssemblerConfigurationSource configSource )\n        throws RepositoryAssemblyException\n    {\n        MavenProject project = configSource.getProject();\n        ArtifactRepository localRepository = configSource.getLocalRepository();\n\n        createGroupVersionAlignments( repository.getGroupVersionAlignments() );\n\n        ArtifactRepository targetRepository = createLocalRepository( repositoryDirectory );\n\n        ArtifactResolutionResult result;\n        try\n        {\n            // i have to get everything first as a filter or transformation here\n            // doesn't seem to work\n            // to align everything. If I use a filter to change the version on\n            // the fly then I get the\n            // I get JARs but no POMs, and in some directories POMs with no\n            // JARs.\n\n            // FIXME I'm not getting runtime dependencies here\n            result = artifactResolver.resolveTransitively( project.getDependencyArtifacts(), project.getArtifact(),\n                project.getRemoteArtifactRepositories(), localRepository, metadataSource );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new RepositoryAssemblyException( \"Error resolving artifacts: \" + e.getMessage(), e );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            throw new RepositoryAssemblyException( \"Error resolving artifacts: \" + e.getMessage(), e );\n        }\n\n        try\n        {\n            // Blow the cache in the project builder so that we get POMs again\n            // on this next download\n            invalidateProccessedProjectCache();\n        }\n        catch ( Exception e )\n        {\n            throw new RepositoryAssemblyException( \"Error invalidating the processed project cache.\", e );\n        }\n        \n        ArtifactFilter filter = buildRepositoryFilter( repository, project);\n\n        assembleRepositoryArtifacts( result, filter, project, localRepository, targetRepository, repositoryDirectory );\n        \n        ArtifactRepository centralRepository = findCentralRepository( project );\n\n        if ( repository.isIncludeMetadata() )\n        {\n            assembleRepositoryMetadata( result, filter, centralRepository, targetRepository );\n        }\n    }","id":23670,"modified_method":"public void assemble( File repositoryDirectory, Repository repository, AssemblerConfigurationSource configSource )\n        throws RepositoryAssemblyException\n    {\n        MavenProject project = configSource.getProject();\n        ArtifactRepository localRepository = configSource.getLocalRepository();\n\n        Map groupVersionAlignments = createGroupVersionAlignments( repository.getGroupVersionAlignments() );\n\n        ArtifactRepository targetRepository = createLocalRepository( repositoryDirectory );\n\n        ArtifactResolutionResult result = null;\n        \n        Set dependencyArtifacts = project.getDependencyArtifacts();\n        \n        if ( dependencyArtifacts == null )\n        {\n            Logger logger = getLogger();\n            \n            if ( logger.isDebugEnabled() )\n            {\n                logger.debug( \"dependency-artifact set for project: \" + project.getId() + \" is null. Skipping repository processing.\" );\n            }\n            \n            return;\n        }\n        \n        try\n        {\n            // i have to get everything first as a filter or transformation here\n            // doesn't seem to work\n            // to align everything. If I use a filter to change the version on\n            // the fly then I get the\n            // I get JARs but no POMs, and in some directories POMs with no\n            // JARs.\n\n            // FIXME I'm not getting runtime dependencies here\n            result = artifactResolver.resolveTransitively( dependencyArtifacts, project.getArtifact(),\n                project.getRemoteArtifactRepositories(), localRepository, metadataSource );\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new RepositoryAssemblyException( \"Error resolving artifacts: \" + e.getMessage(), e );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            throw new RepositoryAssemblyException( \"Error resolving artifacts: \" + e.getMessage(), e );\n        }\n\n        try\n        {\n            // Blow the cache in the project builder so that we get POMs again\n            // on this next download\n            invalidateProccessedProjectCache();\n        }\n        catch ( Exception e )\n        {\n            throw new RepositoryAssemblyException( \"Error invalidating the processed project cache.\", e );\n        }\n        \n        ArtifactFilter filter = buildRepositoryFilter( repository, project);\n\n        assembleRepositoryArtifacts( result, filter, project, localRepository, targetRepository, repositoryDirectory, groupVersionAlignments );\n        \n        ArtifactRepository centralRepository = findCentralRepository( project );\n\n        if ( repository.isIncludeMetadata() )\n        {\n            assembleRepositoryMetadata( result, filter, centralRepository, targetRepository );\n        }\n    }","commit_id":"fcbf2d7e6b0034bb441e500278f97310e9a04dc8","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void writeChecksums( File file )\n        throws IOException, RepositoryAssemblyException\n    {\n        try\n        {\n            String md5 = digester.createChecksum( file, \"MD5\" );\n            String sha1 = digester.createChecksum( file, \"SHA-1\" );\n\n            FileUtils.fileWrite( new File( file.getParentFile(), file.getName() + \".md5\" ).getAbsolutePath(), md5\n                .toLowerCase() );\n            FileUtils.fileWrite( new File( file.getParentFile(), file.getName() + \".sha1\" ).getAbsolutePath(), sha1\n                .toLowerCase() );\n        }\n        catch ( NoSuchAlgorithmException e )\n        {\n            throw new RepositoryAssemblyException( \"Unable to get write checksums: \" + e.getMessage(), e );\n        }\n    }","id":23671,"modified_method":"private void writeChecksums( File file )\n        throws IOException, RepositoryAssemblyException\n    {\n        try\n        {\n            String md5 = DigestUtils.createChecksum( file, \"MD5\" );\n            String sha1 = DigestUtils.createChecksum( file, \"SHA-1\" );\n\n            FileUtils.fileWrite( new File( file.getParentFile(), file.getName() + \".md5\" ).getAbsolutePath(), md5\n                .toLowerCase() );\n            FileUtils.fileWrite( new File( file.getParentFile(), file.getName() + \".sha1\" ).getAbsolutePath(), sha1\n                .toLowerCase() );\n        }\n        catch ( NoSuchAlgorithmException e )\n        {\n            throw new RepositoryAssemblyException( \"Unable to get write checksums: \" + e.getMessage(), e );\n        }\n    }","commit_id":"fcbf2d7e6b0034bb441e500278f97310e9a04dc8","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void setAlignment( Artifact artifact )\n    {\n        GroupVersionAlignment alignment = (GroupVersionAlignment) groupVersionAlignments.get( artifact.getGroupId() );\n\n        if ( alignment != null )\n        {\n            if ( !alignment.getExcludes().contains( artifact.getArtifactId() ) )\n            {\n                artifact.setVersion( alignment.getVersion() );\n            }\n        }\n    }","id":23672,"modified_method":"private void setAlignment( Artifact artifact, Map groupVersionAlignments )\n    {\n        GroupVersionAlignment alignment = (GroupVersionAlignment) groupVersionAlignments.get( artifact.getGroupId() );\n\n        if ( alignment != null )\n        {\n            if ( !alignment.getExcludes().contains( artifact.getArtifactId() ) )\n            {\n                artifact.setVersion( alignment.getVersion() );\n            }\n        }\n    }","commit_id":"fcbf2d7e6b0034bb441e500278f97310e9a04dc8","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void createGroupVersionAlignments( List versionAlignments )\n    {\n        groupVersionAlignments = new HashMap();\n\n        for ( Iterator i = versionAlignments.iterator(); i.hasNext(); )\n        {\n            GroupVersionAlignment alignment = (GroupVersionAlignment) i.next();\n\n            groupVersionAlignments.put( alignment.getId(), alignment );\n        }\n    }","id":23673,"modified_method":"protected Map createGroupVersionAlignments( List versionAlignments )\n    {\n        Map groupVersionAlignments = new HashMap();\n\n        for ( Iterator i = versionAlignments.iterator(); i.hasNext(); )\n        {\n            GroupVersionAlignment alignment = (GroupVersionAlignment) i.next();\n\n            groupVersionAlignments.put( alignment.getId(), alignment );\n        }\n        \n        return groupVersionAlignments;\n    }","commit_id":"fcbf2d7e6b0034bb441e500278f97310e9a04dc8","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void assembleRepositoryArtifacts( ArtifactResolutionResult result, ArtifactFilter filter,\n                                              MavenProject project, ArtifactRepository localRepository,\n                                              ArtifactRepository targetRepository, File repositoryDirectory )\n        throws RepositoryAssemblyException\n    {\n        try\n        {\n            // Now that we have the graph, let's try to align it to versions\n            // that we want and remove\n            // the repository we previously populated.\n            FileUtils.deleteDirectory( repositoryDirectory );\n\n            FileUtils.mkdir( repositoryDirectory.getAbsolutePath() );\n\n            for ( Iterator i = result.getArtifacts().iterator(); i.hasNext(); )\n            {\n                Artifact a = (Artifact) i.next();\n\n                if ( filter.include( a ) )\n                {\n                    setAlignment( a );\n\n                    // We need to flip it back to not being resolved so we can\n                    // look for it again!\n                    a.setResolved( false );\n\n                    artifactResolver.resolve( a, project.getRemoteArtifactRepositories(), localRepository );\n\n                    File targetFile = new File( targetRepository.getBasedir(), targetRepository.pathOf( a ) );\n                    FileUtils.copyFile( a.getFile(), targetFile );\n\n                    writeChecksums( targetFile );\n\n                    if ( !\"pom\".equals( a.getType() ) )\n                    {\n                        a = artifactFactory.createProjectArtifact( a.getGroupId(), a.getArtifactId(), a.getVersion() );\n\n                        MavenProject p = projectBuilder.buildFromRepository( a,\n                            project.getRemoteArtifactRepositories(), localRepository );\n\n                        do\n                        {\n                            a = artifactFactory.createProjectArtifact( p.getGroupId(), p.getArtifactId(), p\n                                .getVersion() );\n\n                            setAlignment( a );\n\n                            File sourceFile = new File( localRepository.getBasedir(), localRepository.pathOf( a ) );\n\n                            if ( !sourceFile.exists() )\n                            {\n                                break;\n                            }\n\n                            targetFile = new File( targetRepository.getBasedir(), targetRepository.pathOf( a ) );\n\n                            FileUtils.copyFile( sourceFile, targetFile );\n\n                            writeChecksums( targetFile );\n\n                            p = p.getParent();\n                        } while ( p != null );\n                    }\n                }\n            }\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new RepositoryAssemblyException( \"Error resolving artifacts: \" + e.getMessage(), e );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            throw new RepositoryAssemblyException( \"Error resolving artifacts: \" + e.getMessage(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new RepositoryAssemblyException( \"Error writing artifact metdata.\", e );\n        }\n        catch ( ProjectBuildingException e )\n        {\n            throw new RepositoryAssemblyException( \"Error reading POM.\", e );\n        }\n    }","id":23674,"modified_method":"private void assembleRepositoryArtifacts( ArtifactResolutionResult result, ArtifactFilter filter,\n                                              MavenProject project, ArtifactRepository localRepository,\n                                              ArtifactRepository targetRepository, File repositoryDirectory, Map groupVersionAlignments )\n        throws RepositoryAssemblyException\n    {\n        try\n        {\n            // Now that we have the graph, let's try to align it to versions\n            // that we want and remove\n            // the repository we previously populated.\n            FileUtils.deleteDirectory( repositoryDirectory );\n\n            FileUtils.mkdir( repositoryDirectory.getAbsolutePath() );\n\n            for ( Iterator i = result.getArtifacts().iterator(); i.hasNext(); )\n            {\n                Artifact a = (Artifact) i.next();\n\n                if ( filter.include( a ) )\n                {\n                    setAlignment( a, groupVersionAlignments );\n\n                    // We need to flip it back to not being resolved so we can\n                    // look for it again!\n                    a.setResolved( false );\n\n                    artifactResolver.resolve( a, project.getRemoteArtifactRepositories(), localRepository );\n\n                    File targetFile = new File( targetRepository.getBasedir(), targetRepository.pathOf( a ) );\n                    FileUtils.copyFile( a.getFile(), targetFile );\n\n                    writeChecksums( targetFile );\n\n                    if ( !\"pom\".equals( a.getType() ) )\n                    {\n                        a = artifactFactory.createProjectArtifact( a.getGroupId(), a.getArtifactId(), a.getVersion() );\n\n                        MavenProject p = projectBuilder.buildFromRepository( a,\n                            project.getRemoteArtifactRepositories(), localRepository );\n\n                        do\n                        {\n                            a = artifactFactory.createProjectArtifact( p.getGroupId(), p.getArtifactId(), p\n                                .getVersion() );\n\n                            setAlignment( a, groupVersionAlignments );\n\n                            File sourceFile = new File( localRepository.getBasedir(), localRepository.pathOf( a ) );\n\n                            if ( !sourceFile.exists() )\n                            {\n                                break;\n                            }\n\n                            targetFile = new File( targetRepository.getBasedir(), targetRepository.pathOf( a ) );\n\n                            FileUtils.copyFile( sourceFile, targetFile );\n\n                            writeChecksums( targetFile );\n\n                            p = p.getParent();\n                        } while ( p != null );\n                    }\n                }\n            }\n        }\n        catch ( ArtifactResolutionException e )\n        {\n            throw new RepositoryAssemblyException( \"Error resolving artifacts: \" + e.getMessage(), e );\n        }\n        catch ( ArtifactNotFoundException e )\n        {\n            throw new RepositoryAssemblyException( \"Error resolving artifacts: \" + e.getMessage(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new RepositoryAssemblyException( \"Error writing artifact metdata.\", e );\n        }\n        catch ( ProjectBuildingException e )\n        {\n            throw new RepositoryAssemblyException( \"Error reading POM.\", e );\n        }\n    }","commit_id":"fcbf2d7e6b0034bb441e500278f97310e9a04dc8","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void addModuleSourceFileSets( ModuleSources sources, Set moduleProjects, Archiver archiver,\n                                            AssemblerConfigurationSource configSource, boolean includeBaseDirectory )\n        throws ArchiveCreationException, AssemblyFormattingException\n    {\n        if ( sources == null )\n        {\n            return;\n        }\n\n        for ( Iterator j = moduleProjects.iterator(); j.hasNext(); )\n        {\n            MavenProject moduleProject = ( MavenProject ) j.next();\n\n            sources.setDirectory( PathUtils.toRelative( moduleProject.getBasedir(), sources.getDirectory() ) );\n\n            AddFileSetsTask task = new AddFileSetsTask( Collections.singletonList( sources ) );\n\n            task.setProject( moduleProject );\n            task.setLogger( getLogger() );\n            task.setIncludeBaseDirectory( includeBaseDirectory );\n\n            task.execute( archiver, configSource );\n        }\n    }","id":23675,"modified_method":"protected void addModuleSourceFileSets( ModuleSources sources, Set moduleProjects, Archiver archiver,\n                                            AssemblerConfigurationSource configSource, boolean includeBaseDirectory )\n        throws ArchiveCreationException, AssemblyFormattingException\n    {\n        if ( sources == null )\n        {\n            return;\n        }\n\n        for ( Iterator j = moduleProjects.iterator(); j.hasNext(); )\n        {\n            MavenProject moduleProject = ( MavenProject ) j.next();\n\n            getLogger().debug( \"Processing sources for module project: \" + moduleProject.getId() );\n            \n            String sourcePath = sources.getDirectory();\n            \n            File moduleBasedir = moduleProject.getBasedir();\n            \n            if ( sourcePath != null )\n            {\n                File sourceDir = new File( sourcePath );\n                \n                if ( !sourceDir.isAbsolute() )\n                {\n                    sourcePath = new File( moduleBasedir, sourcePath ).getAbsolutePath();\n                    sources.setDirectory( sourcePath );\n                }\n            }\n            else\n            {\n                sourcePath = moduleBasedir.getAbsolutePath();\n            }\n\n            AddFileSetsTask task = new AddFileSetsTask( Collections.singletonList( sources ) );\n\n            task.setProject( moduleProject );\n            task.setLogger( getLogger() );\n            task.setIncludeBaseDirectory( includeBaseDirectory );\n\n            task.execute( archiver, configSource );\n        }\n    }","commit_id":"fcbf2d7e6b0034bb441e500278f97310e9a04dc8","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void addModuleBinaries( ModuleBinaries binaries, Set moduleProjects, Archiver archiver,\n                                      AssemblerConfigurationSource configSource, boolean includeBaseDirectory )\n        throws ArchiveCreationException, AssemblyFormattingException\n    {\n        if ( binaries == null )\n        {\n            return;\n        }\n\n        Set visitedArtifacts = new HashSet();\n        \n        for ( Iterator j = moduleProjects.iterator(); j.hasNext(); )\n        {\n            MavenProject project = ( MavenProject ) j.next();\n            Artifact artifact = project.getArtifact();\n\n            addArtifact( artifact, project, archiver, configSource, binaries, includeBaseDirectory );\n            \n            visitedArtifacts.add( artifact.getDependencyConflictId() );\n        }\n        \n        if ( binaries.isIncludeDependencies() )\n        {\n            // FIXME: This will produce unpredictable results when module dependencies have a version conflict.\n            getLogger().warn( \"NOTE: Currently, inclusion of module dependencies may produce unpredictable \" +\n                    \"results if a version conflict occurs.\" );\n            \n            for ( Iterator it = moduleProjects.iterator(); it.hasNext(); )\n            {\n                MavenProject moduleProject = ( MavenProject ) it.next();\n\n                Set binaryDependencies = moduleProject.getArtifacts();\n\n                List includes = binaries.getIncludes();\n                \n                // we don't need to include dependencies which have already been found.\n//                List excludes = collectExcludesFromQueuedArtifacts( visitedArtifacts, binaries.getExcludes() );\n                List excludes = binaries.getExcludes();\n\n                FilterUtils.filterArtifacts( binaryDependencies, includes, excludes, true, Collections.EMPTY_LIST,\n                                             getLogger() );\n\n                for ( Iterator binDepIterator = binaryDependencies.iterator(); binDepIterator.hasNext(); )\n                {\n                    Artifact artifact = ( Artifact ) binDepIterator.next();\n                    MavenProject project;\n                    try\n                    {\n                        project = projectBuilder.buildFromRepository( artifact, configSource.getRemoteRepositories(),\n                                                            configSource.getLocalRepository() );\n                    }\n                    catch ( ProjectBuildingException e )\n                    {\n                        throw new ArchiveCreationException( \"Error retrieving POM of module-dependency: \" + artifact.getId()\n                                        + \"; Reason: \" + e.getMessage(), e );\n                    }\n                    \n                    addArtifact( artifact, project, archiver, configSource, binaries, includeBaseDirectory );\n                    \n                    visitedArtifacts.add( artifact.getDependencyConflictId() );\n                }\n            }\n        }\n    }","id":23676,"modified_method":"protected void addModuleBinaries( ModuleBinaries binaries, Set moduleProjects, Archiver archiver,\n                                      AssemblerConfigurationSource configSource, boolean includeBaseDirectory )\n        throws ArchiveCreationException, AssemblyFormattingException\n    {\n        if ( binaries == null )\n        {\n            return;\n        }\n\n        Set visitedArtifacts = new HashSet();\n        \n        for ( Iterator j = moduleProjects.iterator(); j.hasNext(); )\n        {\n            MavenProject project = ( MavenProject ) j.next();\n            \n            getLogger().debug( \"Processing binary artifact for module project: \" + project.getId() );\n            \n            Artifact artifact = project.getArtifact();\n\n            addArtifact( artifact, project, archiver, configSource, binaries, includeBaseDirectory );\n            \n            visitedArtifacts.add( artifact.getDependencyConflictId() );\n        }\n        \n        if ( binaries.isIncludeDependencies() )\n        {\n            // FIXME: This will produce unpredictable results when module dependencies have a version conflict.\n            getLogger().warn( \"NOTE: Currently, inclusion of module dependencies may produce unpredictable \" +\n                    \"results if a version conflict occurs.\" );\n            \n            for ( Iterator it = moduleProjects.iterator(); it.hasNext(); )\n            {\n                MavenProject moduleProject = ( MavenProject ) it.next();\n\n                getLogger().debug( \"Processing binary dependencies for module project: \" + moduleProject.getId() );\n                \n                Set binaryDependencies = moduleProject.getArtifacts();\n\n                List includes = binaries.getIncludes();\n                \n                // we don't need to include dependencies which have already been found.\n//                List excludes = collectExcludesFromQueuedArtifacts( visitedArtifacts, binaries.getExcludes() );\n                List excludes = binaries.getExcludes();\n\n                FilterUtils.filterArtifacts( binaryDependencies, includes, excludes, true, Collections.EMPTY_LIST,\n                                             getLogger() );\n\n                for ( Iterator binDepIterator = binaryDependencies.iterator(); binDepIterator.hasNext(); )\n                {\n                    Artifact artifact = ( Artifact ) binDepIterator.next();\n                    MavenProject project;\n                    try\n                    {\n                        project = projectBuilder.buildFromRepository( artifact, configSource.getRemoteRepositories(),\n                                                            configSource.getLocalRepository() );\n                    }\n                    catch ( ProjectBuildingException e )\n                    {\n                        throw new ArchiveCreationException( \"Error retrieving POM of module-dependency: \" + artifact.getId()\n                                        + \"; Reason: \" + e.getMessage(), e );\n                    }\n                    \n                    addArtifact( artifact, project, archiver, configSource, binaries, includeBaseDirectory );\n                    \n                    visitedArtifacts.add( artifact.getDependencyConflictId() );\n                }\n            }\n        }\n    }","commit_id":"fcbf2d7e6b0034bb441e500278f97310e9a04dc8","url":"https://github.com/apache/maven-plugins"},{"original_method":"public static Set getProjectModules( MavenProject project, List reactorProjects, Logger logger )\n        throws IOException\n    {\n        Set moduleCandidates = new HashSet( reactorProjects );\n\n        Set modules = new HashSet();\n\n        // we temporarily add the master project to the modules set, since this\n        // set is pulling double duty as a set of\n        // potential module parents in the tree rooted at the master\n        // project...this allows us to use the same looping\n        // algorithm below to discover both direct modules of the master project\n        // AND modules of those direct modules.\n        modules.add( project );\n\n        int changed = 0;\n\n        do\n        {\n            changed = 0;\n\n            for ( Iterator candidateIterator = moduleCandidates.iterator(); candidateIterator.hasNext(); )\n            {\n                MavenProject moduleCandidate = (MavenProject) candidateIterator.next();\n\n                if ( moduleCandidate.getFile() == null )\n                {\n                    logger.warn( \"Cannot compute whether \" + moduleCandidate.getId() + \" is a module of: \"\n                        + project.getId() + \"; it does not have an associated POM file on the local filesystem.\" );\n                    continue;\n                }\n\n                for ( Iterator parentIterator = modules.iterator(); parentIterator.hasNext(); )\n                {\n                    MavenProject potentialParent = (MavenProject) parentIterator.next();\n\n                    if ( potentialParent.getFile() == null )\n                    {\n                        logger.warn( \"Cannot use: \" + moduleCandidate.getId()\n                            + \" as a potential module-parent while computing the module set for: \" + project.getId()\n                            + \"; it does not have an associated POM file on the local filesystem.\" );\n                        continue;\n                    }\n\n                    // if this parent has an entry for the module candidate in\n                    // the path adjustments map, it's a direct\n                    // module of that parent.\n                    if ( projectContainsModule( potentialParent, moduleCandidate ) )\n                    {\n                        // add the candidate to the list of modules (and\n                        // potential parents)\n                        modules.add( moduleCandidate );\n\n                        // remove the candidate from the candidate pool, because\n                        // it's been verified.\n                        candidateIterator.remove();\n\n                        // increment the change counter, to show that we\n                        // verified a new module on this pass.\n                        changed++;\n                    }\n                }\n            }\n        } while ( changed != 0 );\n\n        // remove the master project from the modules set, now that we're done\n        // using it as a set of potential module\n        // parents...\n        modules.remove( project );\n\n        return modules;\n    }","id":23677,"modified_method":"public static Set getProjectModules( MavenProject project, List reactorProjects, Logger logger )\n        throws IOException\n    {\n        Set moduleCandidates = new HashSet( reactorProjects );\n\n        Set modules = new HashSet();\n\n        // we temporarily add the master project to the modules set, since this\n        // set is pulling double duty as a set of\n        // potential module parents in the tree rooted at the master\n        // project...this allows us to use the same looping\n        // algorithm below to discover both direct modules of the master project\n        // AND modules of those direct modules.\n        modules.add( project );\n\n        int changed = 0;\n\n        do\n        {\n            changed = 0;\n\n            for ( Iterator candidateIterator = moduleCandidates.iterator(); candidateIterator.hasNext(); )\n            {\n                MavenProject moduleCandidate = (MavenProject) candidateIterator.next();\n\n                if ( moduleCandidate.getFile() == null )\n                {\n                    logger.warn( \"Cannot compute whether \" + moduleCandidate.getId() + \" is a module of: \"\n                        + project.getId() + \"; it does not have an associated POM file on the local filesystem.\" );\n                    continue;\n                }\n\n                Set currentPotentialParents = new HashSet( modules );\n                \n                for ( Iterator parentIterator = currentPotentialParents.iterator(); parentIterator.hasNext(); )\n                {\n                    MavenProject potentialParent = (MavenProject) parentIterator.next();\n\n                    if ( potentialParent.getFile() == null )\n                    {\n                        logger.warn( \"Cannot use: \" + moduleCandidate.getId()\n                            + \" as a potential module-parent while computing the module set for: \" + project.getId()\n                            + \"; it does not have an associated POM file on the local filesystem.\" );\n                        continue;\n                    }\n\n                    // if this parent has an entry for the module candidate in\n                    // the path adjustments map, it's a direct\n                    // module of that parent.\n                    if ( projectContainsModule( potentialParent, moduleCandidate ) )\n                    {\n                        // add the candidate to the list of modules (and\n                        // potential parents)\n                        modules.add( moduleCandidate );\n\n                        // remove the candidate from the candidate pool, because\n                        // it's been verified.\n                        candidateIterator.remove();\n\n                        // increment the change counter, to show that we\n                        // verified a new module on this pass.\n                        changed++;\n                    }\n                }\n            }\n        } while ( changed != 0 );\n\n        // remove the master project from the modules set, now that we're done\n        // using it as a set of potential module\n        // parents...\n        modules.remove( project );\n\n        return modules;\n    }","commit_id":"fcbf2d7e6b0034bb441e500278f97310e9a04dc8","url":"https://github.com/apache/maven-plugins"},{"original_method":"public List<String> getClassPath() {\n\t\tString path = PluginManager.getPlugin(PluginId.getId(\"org.eclipse.xtext.idea.example.entities.idea\")).getPath().getPath();\n\t\treturn Arrays.asList(\n\t\t\tpath + \"/bin\", \n\t\t\tpath + \"/../../org.eclipse.xtext.idea.example.entities/bin\"\n\t\t);\n\t}","id":23678,"modified_method":"public List<String> getClassPath() {\n\t\tString path = PluginManager.getPlugin(PluginId.getId(\"org.eclipse.xtext.idea.example.entities.idea\")).getPath().getPath();\n\t\treturn Arrays.asList(\n\t\t\tpath + \"/bin\", \n\t\t\tpath + \"/../org.eclipse.xtext.idea.example.entities/bin\"\n\t\t);\n\t}","commit_id":"4bd1bac29ccc2589e7b4075d9fa32d8054fcfc25","url":"https://github.com/eclipse/xtext"},{"original_method":"public LanguageAccess(Set<OutputConfiguration> outputConfigurations,\n\t\t\tIResourceServiceProvider resourceServiceProvider, boolean linksAgainstJavaTypes, File baseDir) {\n\t\tthis.outputConfigs = outputConfigurations;\n\t\tthis.resourceServiceProvider = resourceServiceProvider;\n\t\tthis.linksAgainstJava = linksAgainstJavaTypes;\n\t\tthis.baseDir = baseDir;\n\t}","id":23679,"modified_method":"public LanguageAccess(Set<OutputConfiguration> outputConfigurations,\n\t\t\tIResourceServiceProvider resourceServiceProvider, boolean linksAgainstJavaTypes) {\n\t\tthis.outputConfigs = outputConfigurations;\n\t\tthis.resourceServiceProvider = resourceServiceProvider;\n\t\tthis.linksAgainstJava = linksAgainstJavaTypes;\n\t}","commit_id":"4bd1bac29ccc2589e7b4075d9fa32d8054fcfc25","url":"https://github.com/eclipse/xtext"},{"original_method":"protected String resolveToBaseDir(final String directory) {\n\t\tFile outDir = new File(directory);\n\t\tif (!outDir.isAbsolute()) {\n\t\t\toutDir = new File(baseDir, directory);\n\t\t}\n\t\treturn outDir.getAbsolutePath();\n\t}","id":23680,"modified_method":"protected String resolveToBaseDir(final String directory, File baseDir) {\n\t\tFile outDir = new File(directory);\n\t\tif (!outDir.isAbsolute()) {\n\t\t\toutDir = new File(baseDir, directory);\n\t\t}\n\t\treturn outDir.getAbsolutePath();\n\t}","commit_id":"4bd1bac29ccc2589e7b4075d9fa32d8054fcfc25","url":"https://github.com/eclipse/xtext"},{"original_method":"public JavaIoFileSystemAccess getFileSystemAccess() {\n\t\tif (fsa == null) {\n\t\t\tfsa = configuredFileSystemAccess(resourceServiceProvider.get(JavaIoFileSystemAccess.class));\n\t\t}\n\t\treturn fsa;\n\t}","id":23681,"modified_method":"public JavaIoFileSystemAccess createFileSystemAccess(final File baseDir) {\n\t\tJavaIoFileSystemAccess fsa = resourceServiceProvider.get(JavaIoFileSystemAccess.class);\n\t\tSet<OutputConfiguration> confsForFsa = Sets.newHashSet();\n\t\tSet<OutputConfiguration> pomOutputConfigs = getConfiguredOutputConfigs();\n\t\tif (pomOutputConfigs != null && !pomOutputConfigs.isEmpty()) {\n\t\t\tfor (OutputConfiguration pomConfig : pomOutputConfigs) {\n\t\t\t\tif (getOutputConfigurationProvider().getOutputConfigurations().contains(pomConfig)) {\n\t\t\t\t\tconfsForFsa.add(pomConfig);\n\t\t\t\t} else {\n\t\t\t\t\tLOG.warn(\"Output '\" + pomConfig.getName() + \"' is not configured in OutputConfigurationProvider.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconfsForFsa.addAll(getOutputConfigurationProvider().getOutputConfigurations());\n\t\tMap<String, OutputConfiguration> asMap = IterableExtensions.toMap(\n\t\t\t\tIterables.transform(confsForFsa, new Function<OutputConfiguration, OutputConfiguration>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic OutputConfiguration apply(OutputConfiguration output) {\n\t\t\t\t\t\toutput.setOutputDirectory(resolveToBaseDir(output.getOutputDirectory(), baseDir));\n\t\t\t\t\t\tfor (SourceMapping sourceMapping : output.getSourceMappings()) {\n\t\t\t\t\t\t\tsourceMapping.setOutputDirectory(resolveToBaseDir(sourceMapping.getOutputDirectory(), baseDir));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn output;\n\t\t\t\t\t}\n\t\t\t\t}), new Function1<OutputConfiguration, String>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String apply(final OutputConfiguration it) {\n\t\t\t\t\t\treturn it.getName();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tfsa.setOutputConfigurations(asMap);\n\t\treturn fsa;\n\t}","commit_id":"4bd1bac29ccc2589e7b4075d9fa32d8054fcfc25","url":"https://github.com/eclipse/xtext"},{"original_method":"public LanguageAccess(Set<OutputConfiguration> outputConfigurations,\n\t\t\tIResourceServiceProvider resourceServiceProvider, File baseDir) {\n\t\tthis(outputConfigurations, resourceServiceProvider, false, baseDir);\n\t}","id":23682,"modified_method":"public LanguageAccess(Set<OutputConfiguration> outputConfigurations,\n\t\t\tIResourceServiceProvider resourceServiceProvider) {\n\t\tthis(outputConfigurations, resourceServiceProvider, false);\n\t}","commit_id":"4bd1bac29ccc2589e7b4075d9fa32d8054fcfc25","url":"https://github.com/eclipse/xtext"},{"original_method":"public Map<String,LanguageAccess> createLanguageAccess(List<? extends ILanguageConfiguration> languageConfigs, ClassLoader compilerClassLoder, File baseDir) {\n\t\tMap<String,LanguageAccess> result = new HashMap<String, LanguageAccess>();\n\t\tfor (ILanguageConfiguration languageGenConf : languageConfigs) {\n\t\t\tISetup setup;\n\t\t\ttry {\n\t\t\t\tClass<?> loadClass = compilerClassLoder.loadClass(languageGenConf.getSetup());\n\t\t\t\tif (!ISetup.class.isAssignableFrom(loadClass)) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Language setup class \" + languageGenConf.getSetup()\n\t\t\t\t\t\t\t+ \" must implement \" + ISetup.class.getName());\n\t\t\t\t}\n\t\t\t\tsetup = (ISetup) loadClass.newInstance();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to load language setup for class '\"+languageGenConf.getSetup()+\"'.\", e);\n\t\t\t}\n\n\t\t\tInjector injector = setup.createInjectorAndDoEMFRegistration();\n\t\t\tIResourceServiceProvider serviceProvider = injector.getInstance(IResourceServiceProvider.class);\n\t\t\tFileExtensionProvider fileExtensionProvider = injector.getInstance(FileExtensionProvider.class);\n\t\t\tLanguageAccess languageAccess = new LanguageAccess(languageGenConf.getOutputConfigurations(), serviceProvider, languageGenConf.isJavaSupport(), baseDir);\n\t\t\tfor (String extension : fileExtensionProvider.getFileExtensions()) {\n\t\t\t\tresult.put(extension, languageAccess);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":23683,"modified_method":"public Map<String,LanguageAccess> createLanguageAccess(List<? extends ILanguageConfiguration> languageConfigs, ClassLoader compilerClassLoder) {\n\t\tMap<String,LanguageAccess> result = new HashMap<String, LanguageAccess>();\n\t\tfor (ILanguageConfiguration languageGenConf : languageConfigs) {\n\t\t\tISetup setup;\n\t\t\ttry {\n\t\t\t\tClass<?> loadClass = compilerClassLoder.loadClass(languageGenConf.getSetup());\n\t\t\t\tif (!ISetup.class.isAssignableFrom(loadClass)) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Language setup class \" + languageGenConf.getSetup()\n\t\t\t\t\t\t\t+ \" must implement \" + ISetup.class.getName());\n\t\t\t\t}\n\t\t\t\tsetup = (ISetup) loadClass.newInstance();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to load language setup for class '\"+languageGenConf.getSetup()+\"'.\", e);\n\t\t\t}\n\n\t\t\tInjector injector = setup.createInjectorAndDoEMFRegistration();\n\t\t\tIResourceServiceProvider serviceProvider = injector.getInstance(IResourceServiceProvider.class);\n\t\t\tFileExtensionProvider fileExtensionProvider = injector.getInstance(FileExtensionProvider.class);\n\t\t\tLanguageAccess languageAccess = new LanguageAccess(languageGenConf.getOutputConfigurations(), serviceProvider, languageGenConf.isJavaSupport());\n\t\t\tfor (String extension : fileExtensionProvider.getFileExtensions()) {\n\t\t\t\tresult.put(extension, languageAccess);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"4bd1bac29ccc2589e7b4075d9fa32d8054fcfc25","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void generate(final List<Resource> sourceResources) {\n    for (final Resource it : sourceResources) {\n      {\n        URI _uRI = it.getURI();\n        String _lastSegment = _uRI.lastSegment();\n        String _plus = (\"Starting generator for input: \\'\" + _lastSegment);\n        String _plus_1 = (_plus + \"\\'\");\n        StandaloneBuilder.LOG.info(_plus_1);\n        URI _uRI_1 = it.getURI();\n        this.registerCurrentSource(_uRI_1);\n        URI _uRI_2 = it.getURI();\n        final LanguageAccess access = this.languageAccess(_uRI_2);\n        boolean _isWriteStorageResources = this.isWriteStorageResources();\n        if (_isWriteStorageResources) {\n          boolean _matched = false;\n          if (!_matched) {\n            if (it instanceof StorageAwareResource) {\n              IResourceStorageFacade _resourceStorageFacade = ((StorageAwareResource)it).getResourceStorageFacade();\n              boolean _notEquals = (!Objects.equal(_resourceStorageFacade, null));\n              if (_notEquals) {\n                _matched=true;\n                IResourceStorageFacade _resourceStorageFacade_1 = ((StorageAwareResource)it).getResourceStorageFacade();\n                JavaIoFileSystemAccess _fileSystemAccess = access.getFileSystemAccess();\n                _resourceStorageFacade_1.saveResource(((StorageAwareResource)it), _fileSystemAccess);\n              }\n            }\n          }\n        }\n        IGenerator _generator = access.getGenerator();\n        JavaIoFileSystemAccess _fileSystemAccess = access.getFileSystemAccess();\n        _generator.doGenerate(it, _fileSystemAccess);\n      }\n    }\n  }","id":23684,"modified_method":"protected void generate(final List<Resource> sourceResources) {\n    for (final Resource it : sourceResources) {\n      {\n        URI _uRI = it.getURI();\n        String _lastSegment = _uRI.lastSegment();\n        String _plus = (\"Starting generator for input: \\'\" + _lastSegment);\n        String _plus_1 = (_plus + \"\\'\");\n        StandaloneBuilder.LOG.info(_plus_1);\n        URI _uRI_1 = it.getURI();\n        this.registerCurrentSource(_uRI_1);\n        URI _uRI_2 = it.getURI();\n        final LanguageAccess access = this.languageAccess(_uRI_2);\n        final JavaIoFileSystemAccess fileSystemAccess = this.getFileSystemAccess(access);\n        boolean _isWriteStorageResources = this.isWriteStorageResources();\n        if (_isWriteStorageResources) {\n          boolean _matched = false;\n          if (!_matched) {\n            if (it instanceof StorageAwareResource) {\n              IResourceStorageFacade _resourceStorageFacade = ((StorageAwareResource)it).getResourceStorageFacade();\n              boolean _notEquals = (!Objects.equal(_resourceStorageFacade, null));\n              if (_notEquals) {\n                _matched=true;\n                IResourceStorageFacade _resourceStorageFacade_1 = ((StorageAwareResource)it).getResourceStorageFacade();\n                _resourceStorageFacade_1.saveResource(((StorageAwareResource)it), fileSystemAccess);\n              }\n            }\n          }\n        }\n        IGenerator _generator = access.getGenerator();\n        _generator.doGenerate(it, fileSystemAccess);\n      }\n    }\n  }","commit_id":"4bd1bac29ccc2589e7b4075d9fa32d8054fcfc25","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void registerCurrentSource(final URI uri) {\n    LanguageAccess _languageAccess = this.languageAccess(uri);\n    final JavaIoFileSystemAccess fsa = _languageAccess.getFileSystemAccess();\n    final Function1<String, String> _function = new Function1<String, String>() {\n      @Override\n      public String apply(final String it) {\n        File _file = new File(it);\n        String _absolutePath = _file.getAbsolutePath();\n        URI _createFileURI = URI.createFileURI(_absolutePath);\n        return _createFileURI.toString();\n      }\n    };\n    Iterable<String> _map = IterableExtensions.<String, String>map(this.sourceDirs, _function);\n    final Function1<String, Boolean> _function_1 = new Function1<String, Boolean>() {\n      @Override\n      public Boolean apply(final String it) {\n        String _string = uri.toString();\n        return Boolean.valueOf(_string.startsWith(it));\n      }\n    };\n    Iterable<String> _filter = IterableExtensions.<String>filter(_map, _function_1);\n    final Function2<String, String, String> _function_2 = new Function2<String, String, String>() {\n      @Override\n      public String apply(final String longest, final String current) {\n        String _xifexpression = null;\n        int _length = current.length();\n        int _length_1 = longest.length();\n        boolean _greaterThan = (_length > _length_1);\n        if (_greaterThan) {\n          _xifexpression = current;\n        } else {\n          _xifexpression = longest;\n        }\n        return _xifexpression;\n      }\n    };\n    String _reduce = IterableExtensions.<String>reduce(_filter, _function_2);\n    URI _createFileURI = null;\n    if (_reduce!=null) {\n      _createFileURI=URI.createFileURI(_reduce);\n    }\n    final URI absoluteSource = _createFileURI;\n    boolean _equals = Objects.equal(absoluteSource, null);\n    if (_equals) {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"Resource \");\n      _builder.append(uri, \"\");\n      _builder.append(\" is not contained in any of the known source folders \");\n      _builder.append(this.sourceDirs, \"\");\n      _builder.append(\".\");\n      throw new IllegalStateException(_builder.toString());\n    }\n    Map<String, OutputConfiguration> _outputConfigurations = fsa.getOutputConfigurations();\n    Collection<OutputConfiguration> _values = _outputConfigurations.values();\n    for (final OutputConfiguration output : _values) {\n      Set<String> _sourceFolders = output.getSourceFolders();\n      for (final String relativeSource : _sourceFolders) {\n        String _string = absoluteSource.toString();\n        boolean _endsWith = _string.endsWith(relativeSource);\n        if (_endsWith) {\n          fsa.setCurrentSource(relativeSource);\n        }\n      }\n    }\n  }","id":23685,"modified_method":"protected void registerCurrentSource(final URI uri) {\n    LanguageAccess _languageAccess = this.languageAccess(uri);\n    final JavaIoFileSystemAccess fsa = this.getFileSystemAccess(_languageAccess);\n    final Function1<String, String> _function = new Function1<String, String>() {\n      @Override\n      public String apply(final String it) {\n        File _file = new File(it);\n        String _absolutePath = _file.getAbsolutePath();\n        URI _createFileURI = URI.createFileURI(_absolutePath);\n        return _createFileURI.toString();\n      }\n    };\n    Iterable<String> _map = IterableExtensions.<String, String>map(this.sourceDirs, _function);\n    final Function1<String, Boolean> _function_1 = new Function1<String, Boolean>() {\n      @Override\n      public Boolean apply(final String it) {\n        String _string = uri.toString();\n        return Boolean.valueOf(_string.startsWith(it));\n      }\n    };\n    Iterable<String> _filter = IterableExtensions.<String>filter(_map, _function_1);\n    final Function2<String, String, String> _function_2 = new Function2<String, String, String>() {\n      @Override\n      public String apply(final String longest, final String current) {\n        String _xifexpression = null;\n        int _length = current.length();\n        int _length_1 = longest.length();\n        boolean _greaterThan = (_length > _length_1);\n        if (_greaterThan) {\n          _xifexpression = current;\n        } else {\n          _xifexpression = longest;\n        }\n        return _xifexpression;\n      }\n    };\n    String _reduce = IterableExtensions.<String>reduce(_filter, _function_2);\n    URI _createFileURI = null;\n    if (_reduce!=null) {\n      _createFileURI=URI.createFileURI(_reduce);\n    }\n    final URI absoluteSource = _createFileURI;\n    boolean _equals = Objects.equal(absoluteSource, null);\n    if (_equals) {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"Resource \");\n      _builder.append(uri, \"\");\n      _builder.append(\" is not contained in any of the known source folders \");\n      _builder.append(this.sourceDirs, \"\");\n      _builder.append(\".\");\n      throw new IllegalStateException(_builder.toString());\n    }\n    Map<String, OutputConfiguration> _outputConfigurations = fsa.getOutputConfigurations();\n    Collection<OutputConfiguration> _values = _outputConfigurations.values();\n    for (final OutputConfiguration output : _values) {\n      Set<String> _sourceFolders = output.getSourceFolders();\n      for (final String relativeSource : _sourceFolders) {\n        String _string = absoluteSource.toString();\n        boolean _endsWith = _string.endsWith(relativeSource);\n        if (_endsWith) {\n          fsa.setCurrentSource(relativeSource);\n        }\n      }\n    }\n  }","commit_id":"4bd1bac29ccc2589e7b4075d9fa32d8054fcfc25","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean launch() {\n    Collection<LanguageAccess> _values = this.languages.values();\n    final Function1<LanguageAccess, Boolean> _function = new Function1<LanguageAccess, Boolean>() {\n      @Override\n      public Boolean apply(final LanguageAccess it) {\n        return Boolean.valueOf(it.isLinksAgainstJava());\n      }\n    };\n    final boolean needsJava = IterableExtensions.<LanguageAccess>exists(_values, _function);\n    if (needsJava) {\n      StandaloneBuilder.LOG.info(\"Using common types.\");\n    }\n    final XtextResourceSet resourceSet = this.resourceSetProvider.get();\n    boolean _notEquals = (!Objects.equal(this.encoding, null));\n    if (_notEquals) {\n      this.forceDebugLog(\"Setting encoding.\");\n      Collection<LanguageAccess> _values_1 = this.languages.values();\n      this.fileEncodingSetup(_values_1, this.encoding);\n    }\n    StandaloneBuilder.LOG.info(\"Collecting source models.\");\n    final long startedAt = System.currentTimeMillis();\n    Iterable<String> rootsToTravers = this.classPathEntries;\n    boolean _notEquals_1 = (!Objects.equal(this.classPathLookUpFilter, null));\n    if (_notEquals_1) {\n      StandaloneBuilder.LOG.info(\"Class path look up filter is active.\");\n      final Pattern cpLookUpFilter = Pattern.compile(this.classPathLookUpFilter);\n      final Function1<String, Boolean> _function_1 = new Function1<String, Boolean>() {\n        @Override\n        public Boolean apply(final String root) {\n          Matcher _matcher = cpLookUpFilter.matcher(root);\n          return Boolean.valueOf(_matcher.matches());\n        }\n      };\n      Iterable<String> _filter = IterableExtensions.<String>filter(this.classPathEntries, _function_1);\n      rootsToTravers = _filter;\n      final Iterable<String> _converted_rootsToTravers = (Iterable<String>)rootsToTravers;\n      int _length = ((Object[])Conversions.unwrapArray(_converted_rootsToTravers, Object.class)).length;\n      String _plus = (\"Investigating \" + Integer.valueOf(_length));\n      String _plus_1 = (_plus + \" of \");\n      int _length_1 = ((Object[])Conversions.unwrapArray(this.classPathEntries, Object.class)).length;\n      String _plus_2 = (_plus_1 + Integer.valueOf(_length_1));\n      String _plus_3 = (_plus_2 + \" class path entries.\");\n      StandaloneBuilder.LOG.info(_plus_3);\n    }\n    final List<URI> sourceResourceURIs = this.collectResources(this.sourceDirs, resourceSet);\n    List<URI> _collectResources = this.collectResources(rootsToTravers, resourceSet);\n    final Iterable<URI> allResourcesURIs = Iterables.<URI>concat(sourceResourceURIs, _collectResources);\n    long _currentTimeMillis = System.currentTimeMillis();\n    long _minus = (_currentTimeMillis - startedAt);\n    String _plus_4 = (\"Finished collecting source models. Took: \" + Long.valueOf(_minus));\n    String _plus_5 = (_plus_4 + \" ms.\");\n    this.forceDebugLog(_plus_5);\n    final Iterable<String> allClassPathEntries = Iterables.<String>concat(this.sourceDirs, this.classPathEntries);\n    if (needsJava) {\n      StandaloneBuilder.LOG.info(\"Installing type provider.\");\n      this.installTypeProvider(allClassPathEntries, resourceSet, null);\n    }\n    IResourceClusteringPolicy _xifexpression = null;\n    boolean _notEquals_2 = (!Objects.equal(this.clusteringConfig, null));\n    if (_notEquals_2) {\n      DynamicResourceClusteringPolicy _xblockexpression = null;\n      {\n        StandaloneBuilder.LOG.info(\"Clustering configured.\");\n        DynamicResourceClusteringPolicy _dynamicResourceClusteringPolicy = new DynamicResourceClusteringPolicy();\n        final Procedure1<DynamicResourceClusteringPolicy> _function_2 = new Procedure1<DynamicResourceClusteringPolicy>() {\n          @Override\n          public void apply(final DynamicResourceClusteringPolicy it) {\n            long _minimumFreeMemory = StandaloneBuilder.this.clusteringConfig.getMinimumFreeMemory();\n            long _multiply = (_minimumFreeMemory * 1024);\n            long _multiply_1 = (_multiply * 1024);\n            it.setMinimumFreeMemory(_multiply_1);\n            int _minimumClusterSize = StandaloneBuilder.this.clusteringConfig.getMinimumClusterSize();\n            it.setMinimumClusterSize(_minimumClusterSize);\n            long _minimumPercentFreeMemory = StandaloneBuilder.this.clusteringConfig.getMinimumPercentFreeMemory();\n            it.setMinimumPercentFreeMemory(_minimumPercentFreeMemory);\n          }\n        };\n        _xblockexpression = ObjectExtensions.<DynamicResourceClusteringPolicy>operator_doubleArrow(_dynamicResourceClusteringPolicy, _function_2);\n      }\n      _xifexpression = _xblockexpression;\n    } else {\n      _xifexpression = new DisabledClusteringPolicy();\n    }\n    final IResourceClusteringPolicy strategy = _xifexpression;\n    ArrayList<IResourceDescription> _newArrayList = CollectionLiterals.<IResourceDescription>newArrayList();\n    ResourceDescriptionsData index = new ResourceDescriptionsData(_newArrayList);\n    Iterator<URI> allResourceIterator = allResourcesURIs.iterator();\n    while (allResourceIterator.hasNext()) {\n      {\n        List<Resource> resources = CollectionLiterals.<Resource>newArrayList();\n        int clusterIndex = 0;\n        boolean continue_ = true;\n        while ((allResourceIterator.hasNext() && continue_)) {\n          {\n            final URI uri = allResourceIterator.next();\n            final Resource resource = resourceSet.getResource(uri, true);\n            resources.add(resource);\n            this.fillIndex(uri, resource, index);\n            clusterIndex++;\n            boolean _continueProcessing = strategy.continueProcessing(resourceSet, null, clusterIndex);\n            boolean _not = (!_continueProcessing);\n            if (_not) {\n              continue_ = false;\n            }\n          }\n        }\n        if ((!continue_)) {\n          this.clearResourceSet(resourceSet);\n        }\n      }\n    }\n    this.installIndex(resourceSet, index);\n    if (needsJava) {\n      File _generateStubs = this.generateStubs(index, sourceResourceURIs);\n      final String stubsClasses = this.compileStubs(_generateStubs);\n      StandaloneBuilder.LOG.info(\"Installing type provider for stubs.\");\n      ArrayList<String> _newArrayList_1 = CollectionLiterals.<String>newArrayList(stubsClasses);\n      Iterable<String> _plus_6 = Iterables.<String>concat(allClassPathEntries, _newArrayList_1);\n      this.installTypeProvider(_plus_6, resourceSet, this.jvmTypeAccess);\n    }\n    StandaloneBuilder.LOG.info(\"Validate and generate.\");\n    final Iterator<URI> sourceResourceIterator = sourceResourceURIs.iterator();\n    boolean isErrorFree = true;\n    while (sourceResourceIterator.hasNext()) {\n      {\n        List<Resource> resources = CollectionLiterals.<Resource>newArrayList();\n        int clusterIndex = 0;\n        boolean continue_ = true;\n        while ((sourceResourceIterator.hasNext() && continue_)) {\n          {\n            final URI uri = sourceResourceIterator.next();\n            final Resource resource = resourceSet.getResource(uri, true);\n            resources.add(resource);\n            resource.getContents();\n            EcoreUtil2.resolveLazyCrossReferences(resource, CancelIndicator.NullImpl);\n            boolean _validate = this.validate(resource);\n            isErrorFree = _validate;\n            clusterIndex++;\n            boolean _continueProcessing = strategy.continueProcessing(resourceSet, null, clusterIndex);\n            boolean _not = (!_continueProcessing);\n            if (_not) {\n              continue_ = false;\n            }\n          }\n        }\n        boolean _and = false;\n        if (!this.failOnValidationError) {\n          _and = false;\n        } else {\n          _and = (!isErrorFree);\n        }\n        if (_and) {\n          return isErrorFree;\n        }\n        this.generate(resources);\n        if ((!continue_)) {\n          this.clearResourceSet(resourceSet);\n        }\n      }\n    }\n    return isErrorFree;\n  }","id":23686,"modified_method":"public boolean launch() {\n    Collection<LanguageAccess> _values = this.languages.values();\n    final Function1<LanguageAccess, Boolean> _function = new Function1<LanguageAccess, Boolean>() {\n      @Override\n      public Boolean apply(final LanguageAccess it) {\n        return Boolean.valueOf(it.isLinksAgainstJava());\n      }\n    };\n    final boolean needsJava = IterableExtensions.<LanguageAccess>exists(_values, _function);\n    boolean _equals = Objects.equal(this.baseDir, null);\n    if (_equals) {\n      String _property = System.getProperty(\"user.dir\");\n      this.baseDir = _property;\n      StandaloneBuilder.LOG.warn(((\"Property baseDir not set. Using \\'\" + this.baseDir) + \"\\'\"));\n    }\n    if (needsJava) {\n      StandaloneBuilder.LOG.info(\"Using common types.\");\n    }\n    final XtextResourceSet resourceSet = this.resourceSetProvider.get();\n    boolean _notEquals = (!Objects.equal(this.encoding, null));\n    if (_notEquals) {\n      this.forceDebugLog(\"Setting encoding.\");\n      Collection<LanguageAccess> _values_1 = this.languages.values();\n      this.fileEncodingSetup(_values_1, this.encoding);\n    }\n    StandaloneBuilder.LOG.info(\"Collecting source models.\");\n    final long startedAt = System.currentTimeMillis();\n    Iterable<String> rootsToTravers = this.classPathEntries;\n    boolean _notEquals_1 = (!Objects.equal(this.classPathLookUpFilter, null));\n    if (_notEquals_1) {\n      StandaloneBuilder.LOG.info(\"Class path look up filter is active.\");\n      final Pattern cpLookUpFilter = Pattern.compile(this.classPathLookUpFilter);\n      final Function1<String, Boolean> _function_1 = new Function1<String, Boolean>() {\n        @Override\n        public Boolean apply(final String root) {\n          Matcher _matcher = cpLookUpFilter.matcher(root);\n          return Boolean.valueOf(_matcher.matches());\n        }\n      };\n      Iterable<String> _filter = IterableExtensions.<String>filter(this.classPathEntries, _function_1);\n      rootsToTravers = _filter;\n      final Iterable<String> _converted_rootsToTravers = (Iterable<String>)rootsToTravers;\n      int _length = ((Object[])Conversions.unwrapArray(_converted_rootsToTravers, Object.class)).length;\n      String _plus = (\"Investigating \" + Integer.valueOf(_length));\n      String _plus_1 = (_plus + \" of \");\n      int _length_1 = ((Object[])Conversions.unwrapArray(this.classPathEntries, Object.class)).length;\n      String _plus_2 = (_plus_1 + Integer.valueOf(_length_1));\n      String _plus_3 = (_plus_2 + \" class path entries.\");\n      StandaloneBuilder.LOG.info(_plus_3);\n    }\n    final List<URI> sourceResourceURIs = this.collectResources(this.sourceDirs, resourceSet);\n    List<URI> _collectResources = this.collectResources(rootsToTravers, resourceSet);\n    final Iterable<URI> allResourcesURIs = Iterables.<URI>concat(sourceResourceURIs, _collectResources);\n    long _currentTimeMillis = System.currentTimeMillis();\n    long _minus = (_currentTimeMillis - startedAt);\n    String _plus_4 = (\"Finished collecting source models. Took: \" + Long.valueOf(_minus));\n    String _plus_5 = (_plus_4 + \" ms.\");\n    this.forceDebugLog(_plus_5);\n    final Iterable<String> allClassPathEntries = Iterables.<String>concat(this.sourceDirs, this.classPathEntries);\n    if (needsJava) {\n      StandaloneBuilder.LOG.info(\"Installing type provider.\");\n      this.installTypeProvider(allClassPathEntries, resourceSet, null);\n    }\n    IResourceClusteringPolicy _xifexpression = null;\n    boolean _notEquals_2 = (!Objects.equal(this.clusteringConfig, null));\n    if (_notEquals_2) {\n      DynamicResourceClusteringPolicy _xblockexpression = null;\n      {\n        StandaloneBuilder.LOG.info(\"Clustering configured.\");\n        DynamicResourceClusteringPolicy _dynamicResourceClusteringPolicy = new DynamicResourceClusteringPolicy();\n        final Procedure1<DynamicResourceClusteringPolicy> _function_2 = new Procedure1<DynamicResourceClusteringPolicy>() {\n          @Override\n          public void apply(final DynamicResourceClusteringPolicy it) {\n            long _minimumFreeMemory = StandaloneBuilder.this.clusteringConfig.getMinimumFreeMemory();\n            long _multiply = (_minimumFreeMemory * 1024);\n            long _multiply_1 = (_multiply * 1024);\n            it.setMinimumFreeMemory(_multiply_1);\n            int _minimumClusterSize = StandaloneBuilder.this.clusteringConfig.getMinimumClusterSize();\n            it.setMinimumClusterSize(_minimumClusterSize);\n            long _minimumPercentFreeMemory = StandaloneBuilder.this.clusteringConfig.getMinimumPercentFreeMemory();\n            it.setMinimumPercentFreeMemory(_minimumPercentFreeMemory);\n          }\n        };\n        _xblockexpression = ObjectExtensions.<DynamicResourceClusteringPolicy>operator_doubleArrow(_dynamicResourceClusteringPolicy, _function_2);\n      }\n      _xifexpression = _xblockexpression;\n    } else {\n      _xifexpression = new DisabledClusteringPolicy();\n    }\n    final IResourceClusteringPolicy strategy = _xifexpression;\n    ArrayList<IResourceDescription> _newArrayList = CollectionLiterals.<IResourceDescription>newArrayList();\n    ResourceDescriptionsData index = new ResourceDescriptionsData(_newArrayList);\n    Iterator<URI> allResourceIterator = allResourcesURIs.iterator();\n    while (allResourceIterator.hasNext()) {\n      {\n        List<Resource> resources = CollectionLiterals.<Resource>newArrayList();\n        int clusterIndex = 0;\n        boolean continue_ = true;\n        while ((allResourceIterator.hasNext() && continue_)) {\n          {\n            final URI uri = allResourceIterator.next();\n            final Resource resource = resourceSet.getResource(uri, true);\n            resources.add(resource);\n            this.fillIndex(uri, resource, index);\n            clusterIndex++;\n            boolean _continueProcessing = strategy.continueProcessing(resourceSet, null, clusterIndex);\n            boolean _not = (!_continueProcessing);\n            if (_not) {\n              continue_ = false;\n            }\n          }\n        }\n        if ((!continue_)) {\n          this.clearResourceSet(resourceSet);\n        }\n      }\n    }\n    this.installIndex(resourceSet, index);\n    if (needsJava) {\n      File _generateStubs = this.generateStubs(index, sourceResourceURIs);\n      final String stubsClasses = this.compileStubs(_generateStubs);\n      StandaloneBuilder.LOG.info(\"Installing type provider for stubs.\");\n      ArrayList<String> _newArrayList_1 = CollectionLiterals.<String>newArrayList(stubsClasses);\n      Iterable<String> _plus_6 = Iterables.<String>concat(allClassPathEntries, _newArrayList_1);\n      this.installTypeProvider(_plus_6, resourceSet, this.jvmTypeAccess);\n    }\n    StandaloneBuilder.LOG.info(\"Validate and generate.\");\n    final Iterator<URI> sourceResourceIterator = sourceResourceURIs.iterator();\n    boolean isErrorFree = true;\n    while (sourceResourceIterator.hasNext()) {\n      {\n        List<Resource> resources = CollectionLiterals.<Resource>newArrayList();\n        int clusterIndex = 0;\n        boolean continue_ = true;\n        while ((sourceResourceIterator.hasNext() && continue_)) {\n          {\n            final URI uri = sourceResourceIterator.next();\n            final Resource resource = resourceSet.getResource(uri, true);\n            resources.add(resource);\n            resource.getContents();\n            EcoreUtil2.resolveLazyCrossReferences(resource, CancelIndicator.NullImpl);\n            boolean _validate = this.validate(resource);\n            isErrorFree = _validate;\n            clusterIndex++;\n            boolean _continueProcessing = strategy.continueProcessing(resourceSet, null, clusterIndex);\n            boolean _not = (!_continueProcessing);\n            if (_not) {\n              continue_ = false;\n            }\n          }\n        }\n        boolean _and = false;\n        if (!this.failOnValidationError) {\n          _and = false;\n        } else {\n          _and = (!isErrorFree);\n        }\n        if (_and) {\n          return isErrorFree;\n        }\n        this.generate(resources);\n        if ((!continue_)) {\n          this.clearResourceSet(resourceSet);\n        }\n      }\n    }\n    return isErrorFree;\n  }","commit_id":"4bd1bac29ccc2589e7b4075d9fa32d8054fcfc25","url":"https://github.com/eclipse/xtext"},{"original_method":"private StandaloneBuilder initBuilder(ILanguageConfiguration config) {\n\t\tString sourceDir1 = new File(PROJECT_DIR, \"src\").getAbsolutePath();\n\t\tString sourceDir2 = new File(PROJECT_DIR, \"src2\").getAbsolutePath();\n\t\tbuilder.setSourceDirs(ImmutableList.of(sourceDir1, sourceDir2));\n\t\tMap<String, LanguageAccess> languages = new LanguageAccessFactory().createLanguageAccess(\n\t\t\t\tImmutableList.of(config), getClass().getClassLoader(), PROJECT_DIR);\n\t\tbuilder.setLanguages(languages);\n\t\tbuilder.setClassPathEntries(ImmutableList.<String> of());\n\t\treturn builder;\n\t}","id":23687,"modified_method":"private StandaloneBuilder initBuilder(ILanguageConfiguration config) {\n\t\tString sourceDir1 = new File(PROJECT_DIR, \"src\").getAbsolutePath();\n\t\tString sourceDir2 = new File(PROJECT_DIR, \"src2\").getAbsolutePath();\n\t\tbuilder.setSourceDirs(ImmutableList.of(sourceDir1, sourceDir2));\n\t\tMap<String, LanguageAccess> languages = new LanguageAccessFactory().createLanguageAccess(\n\t\t\t\tImmutableList.of(config), getClass().getClassLoader());\n\t\tbuilder.setBaseDir(PROJECT_DIR.getAbsolutePath());\n\t\tbuilder.setLanguages(languages);\n\t\tbuilder.setClassPathEntries(ImmutableList.<String> of());\n\t\treturn builder;\n\t}","commit_id":"4bd1bac29ccc2589e7b4075d9fa32d8054fcfc25","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic List<String> getClassPath() {\n\t\tString path = PluginManager.getPlugin(PluginId.getId(\"org.eclipse.xtend.idea\")).getPath().getPath();\n\t\treturn Arrays.asList(\n\t\t\tpath + \"/bin\", \n\t\t\tpath + \"/../../org.eclipse.xtend.core/bin\"\n\t\t);\n\t}","id":23688,"modified_method":"@Override\n\tpublic List<String> getClassPath() {\n\t\tString path = PluginManager.getPlugin(PluginId.getId(\"org.eclipse.xtend.idea\")).getPath().getPath();\n\t\treturn Arrays.asList(\n\t\t\tpath + \"/bin\", \n\t\t\tpath + \"/../../plugins/org.eclipse.xtend.core/bin\"\n\t\t);\n\t}","commit_id":"4bd1bac29ccc2589e7b4075d9fa32d8054fcfc25","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public List<String> getClassPath() {\n    ArrayList<String> _xblockexpression = null;\n    {\n      PluginId _id = PluginId.getId(\"org.eclipse.xtext.idea\");\n      final IdeaPluginDescriptor plugin = PluginManager.getPlugin(_id);\n      final File pluginFolder = plugin.getPath();\n      String _path = pluginFolder.getPath();\n      String _plus = (_path + \"/../org.eclipse.xtext.idea.builder/bin\");\n      final ArrayList<String> result = CollectionLiterals.<String>newArrayList(_plus);\n      File _file = new File(pluginFolder, \"lib\");\n      File[] _listFiles = _file.listFiles();\n      final Function1<File, Boolean> _function = new Function1<File, Boolean>() {\n        @Override\n        public Boolean apply(final File it) {\n          boolean _and = false;\n          boolean _isFile = it.isFile();\n          if (!_isFile) {\n            _and = false;\n          } else {\n            String _name = it.getName();\n            boolean _endsWith = _name.endsWith(\".jar\");\n            _and = _endsWith;\n          }\n          return Boolean.valueOf(_and);\n        }\n      };\n      Iterable<File> _filter = IterableExtensions.<File>filter(((Iterable<File>)Conversions.doWrapArray(_listFiles)), _function);\n      final Function1<File, String> _function_1 = new Function1<File, String>() {\n        @Override\n        public String apply(final File it) {\n          return it.getPath();\n        }\n      };\n      Iterable<String> _map = IterableExtensions.<File, String>map(_filter, _function_1);\n      Iterables.<String>addAll(result, _map);\n      _xblockexpression = result;\n    }\n    return _xblockexpression;\n  }","id":23689,"modified_method":"@Override\n  public List<String> getClassPath() {\n    ArrayList<String> _xblockexpression = null;\n    {\n      PluginId _id = PluginId.getId(\"org.eclipse.xtext.idea\");\n      final IdeaPluginDescriptor plugin = PluginManager.getPlugin(_id);\n      File _path = plugin.getPath();\n      final String builderPluginFolder = (_path + \"/../org.eclipse.xtext.idea.builder\");\n      final ArrayList<String> result = CollectionLiterals.<String>newArrayList((builderPluginFolder + \"/bin\"));\n      result.add((builderPluginFolder + \"/../../plugins/org.eclipse.xtext.builder.standalone/bin\"));\n      File _file = new File(builderPluginFolder, \"lib\");\n      File[] _listFiles = _file.listFiles();\n      final Function1<File, Boolean> _function = new Function1<File, Boolean>() {\n        @Override\n        public Boolean apply(final File it) {\n          boolean _and = false;\n          boolean _isFile = it.isFile();\n          if (!_isFile) {\n            _and = false;\n          } else {\n            String _name = it.getName();\n            boolean _endsWith = _name.endsWith(\".jar\");\n            _and = _endsWith;\n          }\n          return Boolean.valueOf(_and);\n        }\n      };\n      Iterable<File> _filter = IterableExtensions.<File>filter(((Iterable<File>)Conversions.doWrapArray(_listFiles)), _function);\n      final Function1<File, String> _function_1 = new Function1<File, String>() {\n        @Override\n        public String apply(final File it) {\n          return it.getPath();\n        }\n      };\n      Iterable<String> _map = IterableExtensions.<File, String>map(_filter, _function_1);\n      Iterables.<String>addAll(result, _map);\n      _xblockexpression = result;\n    }\n    return _xblockexpression;\n  }","commit_id":"4bd1bac29ccc2589e7b4075d9fa32d8054fcfc25","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void internalExecute() throws MojoExecutionException, MojoFailureException {\n\t\tMap<String, LanguageAccess> languages = new LanguageAccessFactory().createLanguageAccess(getLanguages(), this\n\t\t\t\t.getClass().getClassLoader(), project.getBasedir());\n\t\tIterable<String> classPathEntries = filter(getClasspathElements(), emptyStringFilter());\n\t\tInjector injector = Guice.createInjector(new MavenStandaloneBuilderModule());\n\t\tStandaloneBuilder builder = injector.getInstance(StandaloneBuilder.class);\n\t\tbuilder.setLanguages(languages);\n\t\tbuilder.setEncoding(encoding);\n\t\tbuilder.setClassPathEntries(classPathEntries);\n\t\tbuilder.setClassPathLookUpFilter(classPathLookupFilter);\n\t\tbuilder.setSourceDirs(sourceRoots);\n\t\tbuilder.setJavaSourceDirs(javaSourceRoots);\n\t\tbuilder.setFailOnValidationError(failOnValidationError);\n\t\tbuilder.setTempDir(createTempDir().getAbsolutePath());\n\t\tbuilder.setDebugLog(getLog().isDebugEnabled());\n\t\tif(clusteringConfig != null)\n\t\t\tbuilder.setClusteringConfig(clusteringConfig.convertToStandaloneConfig());\n\t\tconfigureCompiler(builder.getCompiler());\n\t\tlogState();\n\t\tboolean errorDetected = !builder.launch();\n\t\tif (errorDetected && failOnValidationError) {\n\t\t\tthrow new MojoExecutionException(\"Execution failed due to a severe validation error.\");\n\t\t}\n\t}","id":23690,"modified_method":"protected void internalExecute() throws MojoExecutionException, MojoFailureException {\n\t\tMap<String, LanguageAccess> languages = new LanguageAccessFactory().createLanguageAccess(getLanguages(), this\n\t\t\t\t.getClass().getClassLoader());\n\t\tIterable<String> classPathEntries = filter(getClasspathElements(), emptyStringFilter());\n\t\tInjector injector = Guice.createInjector(new MavenStandaloneBuilderModule());\n\t\tStandaloneBuilder builder = injector.getInstance(StandaloneBuilder.class);\n\t\tbuilder.setBaseDir(project.getBasedir().getAbsolutePath());\n\t\tbuilder.setLanguages(languages);\n\t\tbuilder.setEncoding(encoding);\n\t\tbuilder.setClassPathEntries(classPathEntries);\n\t\tbuilder.setClassPathLookUpFilter(classPathLookupFilter);\n\t\tbuilder.setSourceDirs(sourceRoots);\n\t\tbuilder.setJavaSourceDirs(javaSourceRoots);\n\t\tbuilder.setFailOnValidationError(failOnValidationError);\n\t\tbuilder.setTempDir(createTempDir().getAbsolutePath());\n\t\tbuilder.setDebugLog(getLog().isDebugEnabled());\n\t\tif(clusteringConfig != null)\n\t\t\tbuilder.setClusteringConfig(clusteringConfig.convertToStandaloneConfig());\n\t\tconfigureCompiler(builder.getCompiler());\n\t\tlogState();\n\t\tboolean errorDetected = !builder.launch();\n\t\tif (errorDetected && failOnValidationError) {\n\t\t\tthrow new MojoExecutionException(\"Execution failed due to a severe validation error.\");\n\t\t}\n\t}","commit_id":"4bd1bac29ccc2589e7b4075d9fa32d8054fcfc25","url":"https://github.com/eclipse/xtext"},{"original_method":"protected SiteRenderingContext createSiteRenderingContext( Locale locale )\n        throws MojoExecutionException, IOException, MojoFailureException\n    {\n        if ( attributes == null )\n        {\n            attributes = new HashMap<Object, Object>();\n        }\n\n        if ( attributes.get( \"project\" ) == null )\n        {\n            attributes.put( \"project\", project );\n        }\n\n        if ( attributes.get( \"inputEncoding\" ) == null )\n        {\n            attributes.put( \"inputEncoding\", getInputEncoding() );\n        }\n\n        if ( attributes.get( \"outputEncoding\" ) == null )\n        {\n            attributes.put( \"outputEncoding\", getOutputEncoding() );\n        }\n\n        // Put any of the properties in directly into the Velocity context\n        attributes.putAll( project.getProperties() );\n\n        DecorationModel decorationModel;\n        try\n        {\n            decorationModel = siteTool.getDecorationModel( project, reactorProjects, localRepository, repositories,\n                                                           toRelative( project.getBasedir(),\n                                                                       siteDirectory.getAbsolutePath() ),\n                                                           locale, getInputEncoding(), getOutputEncoding() );\n        }\n        catch ( SiteToolException e )\n        {\n            throw new MojoExecutionException( \"SiteToolException: \" + e.getMessage(), e );\n        }\n\n        if ( relativizeDecorationLinks )\n        {\n            final String url = project.getUrl();\n\n            if ( url == null )\n            {\n                getLog().warn( \"No project URL defined - decoration links will not be relativized!\" );\n            }\n            else\n            {\n                getLog().info( \"Relativizing decoration links with respect to project URL: \" + url );\n                assembler.resolvePaths( decorationModel, url );\n            }\n        }\n\n        if ( template != null )\n        {\n            if ( templateFile != null )\n            {\n                getLog().warn( \"'template' configuration is ignored when 'templateFile' is set\" );\n            }\n            else\n            {\n                templateFile = new File( templateDirectory, template );\n            }\n        }\n\n        File skinFile;\n        try\n        {\n            Artifact skinArtifact =\n                siteTool.getSkinArtifactFromRepository( localRepository, repositories, decorationModel );\n            getLog().info( \"Rendering site with \" + skinArtifact.getId() + \" skin.\" );\n\n            skinFile = skinArtifact.getFile();\n        }\n        catch ( SiteToolException e )\n        {\n            throw new MojoExecutionException( \"SiteToolException: \" + e.getMessage(), e );\n        }\n        SiteRenderingContext context;\n        if ( templateFile != null )\n        {\n            if ( !templateFile.exists() )\n            {\n                throw new MojoFailureException( \"Template file '\" + templateFile + \"' does not exist\" );\n            }\n            context = siteRenderer.createContextForTemplate( templateFile, skinFile, attributes, decorationModel,\n                                                             project.getName(), locale );\n        }\n        else\n        {\n            context = siteRenderer.createContextForSkin( skinFile, attributes, decorationModel, project.getName(),\n                                                         locale );\n        }\n\n        // Generate static site\n        if ( !locale.getLanguage().equals( Locale.getDefault().getLanguage() ) )\n        {\n            context.addSiteDirectory( new File( siteDirectory, locale.getLanguage() ) );\n            context.addModuleDirectory( new File( xdocDirectory, locale.getLanguage() ), \"xdoc\" );\n            context.addModuleDirectory( new File( xdocDirectory, locale.getLanguage() ), \"fml\" );\n        }\n        else\n        {\n            context.addSiteDirectory( siteDirectory );\n            context.addModuleDirectory( xdocDirectory, \"xdoc\" );\n            context.addModuleDirectory( xdocDirectory, \"fml\" );\n        }\n\n        if ( moduleExcludes != null )\n        {\n            context.setModuleExcludes( moduleExcludes );\n        }\n\n        return context;\n    }","id":23691,"modified_method":"protected SiteRenderingContext createSiteRenderingContext( Locale locale )\n        throws MojoExecutionException, IOException, MojoFailureException\n    {\n        if ( attributes == null )\n        {\n            attributes = new HashMap<Object, Object>();\n        }\n\n        if ( attributes.get( \"project\" ) == null )\n        {\n            attributes.put( \"project\", project );\n        }\n\n        if ( attributes.get( \"inputEncoding\" ) == null )\n        {\n            attributes.put( \"inputEncoding\", getInputEncoding() );\n        }\n\n        if ( attributes.get( \"outputEncoding\" ) == null )\n        {\n            attributes.put( \"outputEncoding\", getOutputEncoding() );\n        }\n\n        // Put any of the properties in directly into the Velocity context\n        attributes.putAll( project.getProperties() );\n\n        DecorationModel decorationModel;\n        try\n        {\n            decorationModel = siteTool.getDecorationModel( project, reactorProjects, localRepository, repositories,\n                                                           siteTool.getRelativePath( siteDirectory.getAbsolutePath(),\n                                                           project.getBasedir().getAbsolutePath() ),\n                                                           locale, getInputEncoding(), getOutputEncoding() );\n        }\n        catch ( SiteToolException e )\n        {\n            throw new MojoExecutionException( \"SiteToolException: \" + e.getMessage(), e );\n        }\n\n        if ( relativizeDecorationLinks )\n        {\n            final String url = project.getUrl();\n\n            if ( url == null )\n            {\n                getLog().warn( \"No project URL defined - decoration links will not be relativized!\" );\n            }\n            else\n            {\n                getLog().info( \"Relativizing decoration links with respect to project URL: \" + url );\n                assembler.resolvePaths( decorationModel, url );\n            }\n        }\n\n        if ( template != null )\n        {\n            if ( templateFile != null )\n            {\n                getLog().warn( \"'template' configuration is ignored when 'templateFile' is set\" );\n            }\n            else\n            {\n                templateFile = new File( templateDirectory, template );\n            }\n        }\n\n        File skinFile;\n        try\n        {\n            Artifact skinArtifact =\n                siteTool.getSkinArtifactFromRepository( localRepository, repositories, decorationModel );\n            getLog().info( \"Rendering site with \" + skinArtifact.getId() + \" skin.\" );\n\n            skinFile = skinArtifact.getFile();\n        }\n        catch ( SiteToolException e )\n        {\n            throw new MojoExecutionException( \"SiteToolException: \" + e.getMessage(), e );\n        }\n        SiteRenderingContext context;\n        if ( templateFile != null )\n        {\n            if ( !templateFile.exists() )\n            {\n                throw new MojoFailureException( \"Template file '\" + templateFile + \"' does not exist\" );\n            }\n            context = siteRenderer.createContextForTemplate( templateFile, skinFile, attributes, decorationModel,\n                                                             project.getName(), locale );\n        }\n        else\n        {\n            context = siteRenderer.createContextForSkin( skinFile, attributes, decorationModel, project.getName(),\n                                                         locale );\n        }\n\n        // Generate static site\n        if ( !locale.getLanguage().equals( Locale.getDefault().getLanguage() ) )\n        {\n            context.addSiteDirectory( new File( siteDirectory, locale.getLanguage() ) );\n            context.addModuleDirectory( new File( xdocDirectory, locale.getLanguage() ), \"xdoc\" );\n            context.addModuleDirectory( new File( xdocDirectory, locale.getLanguage() ), \"fml\" );\n        }\n        else\n        {\n            context.addSiteDirectory( siteDirectory );\n            context.addModuleDirectory( xdocDirectory, \"xdoc\" );\n            context.addModuleDirectory( xdocDirectory, \"fml\" );\n        }\n\n        if ( moduleExcludes != null )\n        {\n            context.setModuleExcludes( moduleExcludes );\n        }\n\n        return context;\n    }","commit_id":"287e6f20277842ae389e226254c40e38172d7a5d","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void execute()\n        throws MojoExecutionException\n    {\n        List<Locale> localesList = siteTool.getAvailableLocales( locales );\n\n        for ( Locale locale : localesList )\n        {\n            File descriptorFile = siteTool.getSiteDescriptorFromBasedir( toRelative( project.getBasedir(),\n                                                                                     siteDirectory.getAbsolutePath() ),\n                                                                         basedir, locale );\n\n            if ( descriptorFile.exists() )\n            {\n                DecorationModel decoration;\n                XmlStreamReader reader = null;\n                try\n                {\n                    reader = ReaderFactory.newXmlReader( descriptorFile );\n                    String siteDescriptorContent = IOUtil.toString( reader );\n\n                    decoration = new DecorationXpp3Reader().read( new StringReader( siteDescriptorContent ) );\n                }\n                catch ( XmlPullParserException e )\n                {\n                    throw new MojoExecutionException( \"Error parsing site descriptor\", e );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Error reading site descriptor\", e );\n                }\n                finally\n                {\n                    IOUtil.close( reader );\n                }\n\n                // Calculate the classifier to use\n                String classifier = null;\n                int index = descriptorFile.getName().lastIndexOf( '.' );\n                if ( index > 0 )\n                {\n                    classifier = descriptorFile.getName().substring( 0, index );\n                }\n                else\n                {\n                    throw new MojoExecutionException( \"Unable to determine the classifier to use\" );\n                }\n\n                // Prepare a file for the interpolated site descriptor\n                String filename = project.getArtifactId() + \"-\" + project.getVersion() + \"-\" + descriptorFile.getName();\n                File interpolatedDescriptorFile = new File( project.getBuild().getDirectory(), filename );\n                interpolatedDescriptorFile.getParentFile().mkdirs();\n\n                Writer writer = null;\n                try\n                {\n                    // Write the interpolated site descriptor to a file\n                    writer = WriterFactory.newXmlWriter( interpolatedDescriptorFile );\n                    new DecorationXpp3Writer().write( writer, decoration );\n                    // Attach the interpolated site descriptor\n                    getLog().debug( \"Attaching the site descriptor '\" + interpolatedDescriptorFile.getAbsolutePath()\n                        + \"' with classifier '\" + classifier + \"' to the project.\" );\n                    projectHelper.attachArtifact( project, \"xml\", classifier, interpolatedDescriptorFile );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Unable to store interpolated site descriptor\", e );\n                }\n                finally\n                {\n                    IOUtil.close( writer );\n                }\n            }\n        }\n    }","id":23692,"modified_method":"public void execute()\n        throws MojoExecutionException\n    {\n        List<Locale> localesList = siteTool.getAvailableLocales( locales );\n\n        for ( Locale locale : localesList )\n        {\n            File descriptorFile = siteTool.getSiteDescriptorFromBasedir(\n                siteTool.getRelativePath( siteDirectory.getAbsolutePath(), project.getBasedir().getAbsolutePath() ),\n                                                                         basedir, locale );\n\n            if ( descriptorFile.exists() )\n            {\n                DecorationModel decoration;\n                XmlStreamReader reader = null;\n                try\n                {\n                    reader = ReaderFactory.newXmlReader( descriptorFile );\n                    String siteDescriptorContent = IOUtil.toString( reader );\n\n                    decoration = new DecorationXpp3Reader().read( new StringReader( siteDescriptorContent ) );\n                }\n                catch ( XmlPullParserException e )\n                {\n                    throw new MojoExecutionException( \"Error parsing site descriptor\", e );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Error reading site descriptor\", e );\n                }\n                finally\n                {\n                    IOUtil.close( reader );\n                }\n\n                // Calculate the classifier to use\n                String classifier = null;\n                int index = descriptorFile.getName().lastIndexOf( '.' );\n                if ( index > 0 )\n                {\n                    classifier = descriptorFile.getName().substring( 0, index );\n                }\n                else\n                {\n                    throw new MojoExecutionException( \"Unable to determine the classifier to use\" );\n                }\n\n                // Prepare a file for the interpolated site descriptor\n                String filename = project.getArtifactId() + \"-\" + project.getVersion() + \"-\" + descriptorFile.getName();\n                File interpolatedDescriptorFile = new File( project.getBuild().getDirectory(), filename );\n                interpolatedDescriptorFile.getParentFile().mkdirs();\n\n                Writer writer = null;\n                try\n                {\n                    // Write the interpolated site descriptor to a file\n                    writer = WriterFactory.newXmlWriter( interpolatedDescriptorFile );\n                    new DecorationXpp3Writer().write( writer, decoration );\n                    // Attach the interpolated site descriptor\n                    getLog().debug( \"Attaching the site descriptor '\" + interpolatedDescriptorFile.getAbsolutePath()\n                        + \"' with classifier '\" + classifier + \"' to the project.\" );\n                    projectHelper.attachArtifact( project, \"xml\", classifier, interpolatedDescriptorFile );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Unable to store interpolated site descriptor\", e );\n                }\n                finally\n                {\n                    IOUtil.close( writer );\n                }\n            }\n        }\n    }","commit_id":"287e6f20277842ae389e226254c40e38172d7a5d","url":"https://github.com/apache/maven-plugins"},{"original_method":"public BaseQueuedResend setPrev(Item i) {\n\t\t\tBaseQueuedResend old = prev;\n\t\t\tprev = (BaseQueuedResend)i;\n\t\t\treturn old;\n\t\t}","id":23693,"modified_method":"public BaseQueuedResend setPrev(Item<?> i) {\n\t\t\tBaseQueuedResend old = prev;\n\t\t\tprev = (BaseQueuedResend)i;\n\t\t\treturn old;\n\t\t}","commit_id":"dae2611e9e47f431dc03166f475e3bdc16b5054e","url":"https://github.com/freenet/fred"},{"original_method":"public final BaseQueuedResend setNext(Item i) {\n\t\t\tBaseQueuedResend old = next;\n\t\t\tnext = (BaseQueuedResend)i;\n\t\t\treturn old;\n\t\t}","id":23694,"modified_method":"public final BaseQueuedResend setNext(Item<?> i) {\n\t\t\tBaseQueuedResend old = next;\n\t\t\tnext = (BaseQueuedResend)i;\n\t\t\treturn old;\n\t\t}","commit_id":"dae2611e9e47f431dc03166f475e3bdc16b5054e","url":"https://github.com/freenet/fred"},{"original_method":"public DoublyLinkedList setParent(DoublyLinkedList l) {\n\t\t\tDoublyLinkedList old = parent;\n\t\t\tparent = l;\n\t\t\treturn old;\n\t\t}","id":23695,"modified_method":"public DoublyLinkedList<? super BaseQueuedResend> setParent(DoublyLinkedList<? super BaseQueuedResend> l) {\n\t\t\tDoublyLinkedList<? super BaseQueuedResend> old = parent;\n\t\t\tparent = l;\n\t\t\treturn old;\n\t\t}","commit_id":"dae2611e9e47f431dc03166f475e3bdc16b5054e","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * @return The item on the list with the lowest value.\n     */\n    public synchronized UpdatableSortedLinkedListItem getLowest() {\n        return (UpdatableSortedLinkedListItem) list.head();\n    }","id":23696,"modified_method":"/**\n     * @return The item on the list with the lowest value.\n     */\n    public synchronized T getLowest() {\n        return list.head();\n    }","commit_id":"dae2611e9e47f431dc03166f475e3bdc16b5054e","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized void moveTo(UpdatableSortedLinkedList dest) throws UpdatableSortedLinkedListKilledException {\n\t\tEnumeration e = list.elements();\n\t\twhile(e.hasMoreElements()) {\n\t\t\tUpdatableSortedLinkedListItem item = (UpdatableSortedLinkedListItem) e.nextElement();\n\t\t\tremove(item);\n\t\t\tdest.add(item);\n\t\t}\n\t}","id":23697,"modified_method":"public synchronized void moveTo(UpdatableSortedLinkedList<T> dest) throws UpdatableSortedLinkedListKilledException {\n\t\tEnumeration<T> e = list.elements();\n\t\twhile(e.hasMoreElements()) {\n\t\t\tT item = e.nextElement();\n\t\t\tremove(item);\n\t\t\tdest.add(item);\n\t\t}\n\t}","commit_id":"dae2611e9e47f431dc03166f475e3bdc16b5054e","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized UpdatableSortedLinkedListItem removeLowest() throws UpdatableSortedLinkedListKilledException {\n\t\tif(isEmpty()) return null;\n\t\tUpdatableSortedLinkedListItem i = getLowest();\n\t\tremove(i);\n\t\treturn i;\n\t}","id":23698,"modified_method":"public synchronized T removeLowest() throws UpdatableSortedLinkedListKilledException {\n\t\tif(isEmpty()) return null;\n\t\tT i = getLowest();\n\t\tremove(i);\n\t\treturn i;\n\t}","commit_id":"dae2611e9e47f431dc03166f475e3bdc16b5054e","url":"https://github.com/freenet/fred"},{"original_method":"public UpdatableSortedLinkedList() {\n        list = new DoublyLinkedListImpl();\n    }","id":23699,"modified_method":"public UpdatableSortedLinkedList() {\n        list = new DoublyLinkedListImpl<T>();\n    }","commit_id":"dae2611e9e47f431dc03166f475e3bdc16b5054e","url":"https://github.com/freenet/fred"},{"original_method":"public DoublyLinkedList setParent(DoublyLinkedList l) {\n\t\tDoublyLinkedList oldParent = parentList;\n\t\tparentList = l;\n\t\treturn oldParent;\n\t}","id":23700,"modified_method":"public DoublyLinkedList<? super T> setParent(DoublyLinkedList<? super T> l) {\n\t\tDoublyLinkedList<? super T> oldParent = parentList;\n\t\tparentList = l;\n\t\treturn oldParent;\n\t}","commit_id":"dae2611e9e47f431dc03166f475e3bdc16b5054e","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized IndexableUpdatableSortedLinkedListItem get(Object key) {\n\t\treturn (IndexableUpdatableSortedLinkedListItem)map.get(key);\n\t}","id":23701,"modified_method":"public synchronized IndexableUpdatableSortedLinkedListItem<?> get(Object key) {\n\t\treturn (IndexableUpdatableSortedLinkedListItem<?>)map.get(key);\n\t}","commit_id":"dae2611e9e47f431dc03166f475e3bdc16b5054e","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized boolean contains(IndexableUpdatableSortedLinkedListItem item) {\n    \treturn containsKey(item.indexValue());\n    }","id":23702,"modified_method":"public synchronized boolean contains(IndexableUpdatableSortedLinkedListItem<?> item) {\n    \treturn containsKey(item.indexValue());\n    }","commit_id":"dae2611e9e47f431dc03166f475e3bdc16b5054e","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * Remove an element from the list by its key.\n     * @throws UpdatableSortedLinkedListKilledException \n     */\n    public synchronized IndexableUpdatableSortedLinkedListItem removeByKey(Object key) throws UpdatableSortedLinkedListKilledException {\n    \tif(killed) throw new UpdatableSortedLinkedListKilledException();\n        IndexableUpdatableSortedLinkedListItem item = \n            (IndexableUpdatableSortedLinkedListItem) map.get(key);\n        if(item != null) remove(item);\n        checkList();\n        return item;\n    }","id":23703,"modified_method":"/**\n     * Remove an element from the list by its key.\n     * @throws UpdatableSortedLinkedListKilledException \n     */\n    public synchronized IndexableUpdatableSortedLinkedListItem<?> removeByKey(Object key) throws UpdatableSortedLinkedListKilledException {\n    \tif(killed) throw new UpdatableSortedLinkedListKilledException();\n        T item = map.get(key);\n        if(item != null) remove(item);\n        checkList();\n        return item;\n    }","commit_id":"dae2611e9e47f431dc03166f475e3bdc16b5054e","url":"https://github.com/freenet/fred"},{"original_method":"public UpdatableSortedLinkedListWithForeignIndex() {\n        super();\n        map = new HashMap();\n    }","id":23704,"modified_method":"public UpdatableSortedLinkedListWithForeignIndex() {\n        super();\n        map = new HashMap<Object, T>();\n    }","commit_id":"dae2611e9e47f431dc03166f475e3bdc16b5054e","url":"https://github.com/freenet/fred"},{"original_method":"public void testShiftN() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tlist.push(new T(i));\n\t\t}\n\n\t\tDoublyLinkedList<T> list2 = list.shift(2);\n\t\tassertEquals(\"list2.size()\", 2, list2.size());\n\t\t((T) list2.shift()).assertV(0);\n\t\t((T) list2.shift()).assertV(1);\n\t\tassertTrue(\"list2.isEmpty()\", list2.isEmpty());\n\n\t\tassertEquals(\"list.size()\", 3, list.size());\n\t\t((T) list.shift()).assertV(2);\n\n\t\tlist2 = list.shift(20);\n\t\tassertTrue(\"list.isEmpty()\", list.isEmpty());\n\t\t((T) list2.shift()).assertV(3);\n\t\t((T) list2.shift()).assertV(4);\n\t\tassertTrue(\"list2.isEmpty()\", list2.isEmpty());\n\n\t\tlist2 = list.shift(20);\n\t\tassertTrue(\"list2.isEmpty()\", list2.isEmpty());\n\t}","id":23705,"modified_method":"public void testShiftN() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tlist.push(new T(i));\n\t\t}\n\n\t\tDoublyLinkedList<T> list2 = list.shift(2);\n\t\tassertEquals(\"list2.size()\", 2, list2.size());\n\t\tlist2.shift().assertV(0);\n\t\tlist2.shift().assertV(1);\n\t\tassertTrue(\"list2.isEmpty()\", list2.isEmpty());\n\n\t\tassertEquals(\"list.size()\", 3, list.size());\n\t\tlist.shift().assertV(2);\n\n\t\tlist2 = list.shift(20);\n\t\tassertTrue(\"list.isEmpty()\", list.isEmpty());\n\t\tlist2.shift().assertV(3);\n\t\tlist2.shift().assertV(4);\n\t\tassertTrue(\"list2.isEmpty()\", list2.isEmpty());\n\n\t\tlist2 = list.shift(20);\n\t\tassertTrue(\"list2.isEmpty()\", list2.isEmpty());\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"public void testForwardShiftUnshift() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\t\tlist.unshift(new T(0));\n\t\tlist.unshift(new T(1));\n\t\tlist.unshift(new T(2));\n\t\tlist.unshift(new T(3));\n\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\t((T) list.shift()).assertV(3);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\t((T) list.shift()).assertV(2);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\n\t\t// add again\n\t\tlist.unshift(new T(4));\n\t\tlist.unshift(new T(5));\n\n\t\t((T) list.shift()).assertV(5);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\t((T) list.shift()).assertV(4);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\t((T) list.shift()).assertV(1);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\t((T) list.shift()).assertV(0);\n\n\t\tassertTrue(\"isEmpty()\", list.isEmpty());\n\t\tassertNull(\"shift()\", list.shift());\n\t}","id":23706,"modified_method":"public void testForwardShiftUnshift() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\t\tlist.unshift(new T(0));\n\t\tlist.unshift(new T(1));\n\t\tlist.unshift(new T(2));\n\t\tlist.unshift(new T(3));\n\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\tlist.shift().assertV(3);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\tlist.shift().assertV(2);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\n\t\t// add again\n\t\tlist.unshift(new T(4));\n\t\tlist.unshift(new T(5));\n\n\t\tlist.shift().assertV(5);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\tlist.shift().assertV(4);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\tlist.shift().assertV(1);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\tlist.shift().assertV(0);\n\n\t\tassertTrue(\"isEmpty()\", list.isEmpty());\n\t\tassertNull(\"shift()\", list.shift());\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"public void testIternator() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\t\tT[] array = new T[5];\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tarray[i] = new T(i);\n\t\t\tlist.push(array[i]);\n\t\t}\n\n\t\t// manual, forward\n\t\tT h = (T) list.head();\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tassertEquals(\"manual iternate, forward\", array[i], h);\n\t\t\t//assertEquals(\"DoublyLinkedList.next() == Item.next()\", h.getNext(), list.next(h));\n\t\t\tassertEquals(\"hasNext()\", i != 4, list.hasNext(h));\n\t\t\tassertEquals(\"hasPrev()\", i != 0, list.hasPrev(h));\n\n\t\t\th.assertV(i);\n\n\t\t\th = (T) list.next(h);\n\t\t}\n\t\tassertEquals(\"h==null\", null, h);\n\n\t\t// manual, reverse\n\t\tT t = (T) list.tail();\n\t\tfor (int i = 4; i >= 0; i--) {\n\t\t\tassertEquals(\"manual iternate, reverse\", array[i], t);\n\t\t\t//assertEquals(\"DoublyLinkedList.prev() == Item.getPrev()\", tail.getPrev(), list.prev(tail));\n\t\t\tassertEquals(\"hasNext()\", i != 4, list.hasNext(t));\n\t\t\tassertEquals(\"hasPrev()\", i != 0, list.hasPrev(t));\n\n\t\t\tt.assertV(i);\n\n\t\t\tt = (T) list.prev(t);\n\t\t}\n\t\tassertNull(\"t==null\", t);\n\n\t\tEnumeration<T> e = list.elements();\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tassertTrue(\"hasMoreElements()\", e.hasMoreElements());\n\n\t\t\tT n = e.nextElement();\n\t\t\tn.assertV(i);\n\n\t\t\tassertEquals(\"hasMoreElements()\", i != 4, e.hasMoreElements());\n\t\t}\n\t\ttry {\n\t\t\te.nextElement();\n\t\t\tfail(\"NoSuchElementException\");\n\t\t} catch (NoSuchElementException nsee) {\n\t\t}\n\t}","id":23707,"modified_method":"public void testIternator() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\t\tT[] array = new T[5];\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tarray[i] = new T(i);\n\t\t\tlist.push(array[i]);\n\t\t}\n\n\t\t// manual, forward\n\t\tT h = list.head();\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tassertEquals(\"manual iternate, forward\", array[i], h);\n\t\t\t//assertEquals(\"DoublyLinkedList.next() == Item.next()\", h.getNext(), list.next(h));\n\t\t\tassertEquals(\"hasNext()\", i != 4, list.hasNext(h));\n\t\t\tassertEquals(\"hasPrev()\", i != 0, list.hasPrev(h));\n\n\t\t\th.assertV(i);\n\n\t\t\th = list.next(h);\n\t\t}\n\t\tassertEquals(\"h==null\", null, h);\n\n\t\t// manual, reverse\n\t\tT t = list.tail();\n\t\tfor (int i = 4; i >= 0; i--) {\n\t\t\tassertEquals(\"manual iternate, reverse\", array[i], t);\n\t\t\t//assertEquals(\"DoublyLinkedList.prev() == Item.getPrev()\", tail.getPrev(), list.prev(tail));\n\t\t\tassertEquals(\"hasNext()\", i != 4, list.hasNext(t));\n\t\t\tassertEquals(\"hasPrev()\", i != 0, list.hasPrev(t));\n\n\t\t\tt.assertV(i);\n\n\t\t\tt = list.prev(t);\n\t\t}\n\t\tassertNull(\"t==null\", t);\n\n\t\tEnumeration<T> e = list.elements();\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tassertTrue(\"hasMoreElements()\", e.hasMoreElements());\n\n\t\t\tT n = e.nextElement();\n\t\t\tn.assertV(i);\n\n\t\t\tassertEquals(\"hasMoreElements()\", i != 4, e.hasMoreElements());\n\t\t}\n\t\ttry {\n\t\t\te.nextElement();\n\t\t\tfail(\"NoSuchElementException\");\n\t\t} catch (NoSuchElementException nsee) {\n\t\t}\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"public void testRandomRemovePush() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\t\tT[] array = new T[5];\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tarray[i] = new T(i);\n\t\t\tlist.push(array[i]);\n\t\t}\n\n\t\tassertTrue(list.remove(array[3]) == array[3]);\n\t\tlist.push(array[3]);\n\n\t\t// Remove non-exist item -> give null\n\t\tassertNull(list.remove(new T(-1)));\n\n\t\t// Remove non-identical (but equal) item -> give null\n\t\tassertNull(list.remove(new T(2)));\n\n\t\t((T) list.shift()).assertV(0);\n\t\t((T) list.shift()).assertV(1);\n\t\t((T) list.shift()).assertV(2);\n\t\t((T) list.shift()).assertV(4);\n\t\t((T) list.shift()).assertV(3);\n\n\t\tassertNull(list.remove(new T(-1)));\n\t}","id":23708,"modified_method":"public void testRandomRemovePush() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\t\tT[] array = new T[5];\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tarray[i] = new T(i);\n\t\t\tlist.push(array[i]);\n\t\t}\n\n\t\tassertTrue(list.remove(array[3]) == array[3]);\n\t\tlist.push(array[3]);\n\n\t\t// Remove non-exist item -> give null\n\t\tassertNull(list.remove(new T(-1)));\n\n\t\t// Remove non-identical (but equal) item -> give null\n\t\tassertNull(list.remove(new T(2)));\n\n\t\tlist.shift().assertV(0);\n\t\tlist.shift().assertV(1);\n\t\tlist.shift().assertV(2);\n\t\tlist.shift().assertV(4);\n\t\tlist.shift().assertV(3);\n\n\t\tassertNull(list.remove(new T(-1)));\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"public void testForwardPushPop() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\t\tlist.push(new T(0));\n\t\tlist.push(new T(1));\n\t\tlist.push(new T(2));\n\t\tlist.push(new T(3));\n\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\t((T) list.pop()).assertV(3);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\t((T) list.pop()).assertV(2);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\n\t\t// add again\n\t\tlist.push(new T(4));\n\t\tlist.push(new T(5));\n\n\t\t((T) list.pop()).assertV(5);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\t((T) list.pop()).assertV(4);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\t((T) list.pop()).assertV(1);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\t((T) list.pop()).assertV(0);\n\n\t\tassertTrue(\"isEmpty()\", list.isEmpty());\n\t\tassertNull(\"pop()\", list.pop());\n\t}","id":23709,"modified_method":"public void testForwardPushPop() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\t\tlist.push(new T(0));\n\t\tlist.push(new T(1));\n\t\tlist.push(new T(2));\n\t\tlist.push(new T(3));\n\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\tlist.pop().assertV(3);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\tlist.pop().assertV(2);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\n\t\t// add again\n\t\tlist.push(new T(4));\n\t\tlist.push(new T(5));\n\n\t\tlist.pop().assertV(5);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\tlist.pop().assertV(4);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\tlist.pop().assertV(1);\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\tlist.pop().assertV(0);\n\n\t\tassertTrue(\"isEmpty()\", list.isEmpty());\n\t\tassertNull(\"pop()\", list.pop());\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"public void testPopN() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tlist.unshift(new T(i));\n\t\t}\n\n\t\tDoublyLinkedList<T> list2 = list.pop(2);\n\t\tassertEquals(\"list2.size()\", 2, list2.size());\n\t\t((T) list2.pop()).assertV(0);\n\t\t((T) list2.pop()).assertV(1);\n\t\tassertTrue(\"list2.isEmpty()\", list2.isEmpty());\n\n\t\tassertEquals(\"list.size()\", 3, list.size());\n\t\t((T) list.pop()).assertV(2);\n\n\t\tlist2 = list.pop(20);\n\t\tassertTrue(\"list.isEmpty()\", list.isEmpty());\n\t\t((T) list2.pop()).assertV(3);\n\t\t((T) list2.pop()).assertV(4);\n\t\tassertTrue(\"list2.isEmpty()\", list2.isEmpty());\n\n\t\tlist2 = list.pop(20);\n\t\tassertTrue(\"list2.isEmpty()\", list2.isEmpty());\n\t}","id":23710,"modified_method":"public void testPopN() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tlist.unshift(new T(i));\n\t\t}\n\n\t\tDoublyLinkedList<T> list2 = list.pop(2);\n\t\tassertEquals(\"list2.size()\", 2, list2.size());\n\t\tlist2.pop().assertV(0);\n\t\tlist2.pop().assertV(1);\n\t\tassertTrue(\"list2.isEmpty()\", list2.isEmpty());\n\n\t\tassertEquals(\"list.size()\", 3, list.size());\n\t\tlist.pop().assertV(2);\n\n\t\tlist2 = list.pop(20);\n\t\tassertTrue(\"list.isEmpty()\", list.isEmpty());\n\t\tlist2.pop().assertV(3);\n\t\tlist2.pop().assertV(4);\n\t\tassertTrue(\"list2.isEmpty()\", list2.isEmpty());\n\n\t\tlist2 = list.pop(20);\n\t\tassertTrue(\"list2.isEmpty()\", list2.isEmpty());\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"public void testRandomShiftPush() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\t\tlist.push(new T(0));\n\t\tlist.push(new T(1));\n\t\tlist.unshift(new T(2));\n\t\tlist.push(new T(3));\n\t\tlist.unshift(new T(4));\n\t\tlist.unshift(new T(5));\n\n\t\t((T) list.shift()).assertV(5);\n\t\t((T) list.pop()).assertV(3);\n\t\t((T) list.pop()).assertV(1);\n\t\t((T) list.pop()).assertV(0);\n\t\t((T) list.shift()).assertV(4);\n\t\t((T) list.shift()).assertV(2);\n\t}","id":23711,"modified_method":"public void testRandomShiftPush() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\t\tlist.push(new T(0));\n\t\tlist.push(new T(1));\n\t\tlist.unshift(new T(2));\n\t\tlist.push(new T(3));\n\t\tlist.unshift(new T(4));\n\t\tlist.unshift(new T(5));\n\n\t\tlist.shift().assertV(5);\n\t\tlist.pop().assertV(3);\n\t\tlist.pop().assertV(1);\n\t\tlist.pop().assertV(0);\n\t\tlist.shift().assertV(4);\n\t\tlist.shift().assertV(2);\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"public void testRandomInsert() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\t\tT[] array = new T[5];\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tarray[i] = new T(i);\n\t\t\tlist.push(array[i]);\n\t\t}\n\n\t\tlist.insertPrev(array[0], new T(100));\n\t\tlist.insertPrev(array[2], new T(102));\n\t\tlist.insertNext(array[4], new T(104));\n\t\tlist.insertNext(array[4], new T(105));\n\n\t\tDoublyLinkedList<T> list2 = new DoublyLinkedListImpl<T>();\n\t\tT l2 = new T(9999);\n\t\tlist2.push(l2);\n\t\ttry {\n\t\t\t// already exist\n\t\t\tlist2.insertNext(l2, l2);\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// already exist\n\t\t\tlist2.insertNext(l2, l2);\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// bad position\n\t\t\tlist2.insertPrev(array[3], new T(8888));\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// bad position\n\t\t\tlist2.insertNext(array[3], new T(8888));\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\n\t\ttry {\n\t\t\t// item in other list\n\t\t\tlist2.insertPrev(l2, array[3]);\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// item in other list\n\t\t\tlist2.insertNext(l2, array[3]);\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\n\t\tT l3 = new T(9999);\n\t\tlist2.push(l3);\n\t\ttry {\n\t\t\t// VirginItemException\n\t\t\tl3.setPrev(null); // corrupt it\n\t\t\tlist2.insertPrev(l3, new T(8888));\n\t\t\tfail(\"VirginItemException\");\n\t\t} catch (VirginItemException vie) {\n\t\t}\n\t\ttry {\n\t\t\t// VirginItemException\n\t\t\tl2.setNext(null); // corrupt it\n\t\t\tlist2.insertNext(l2, new T(8888));\n\t\t\tfail(\"VirginItemException\");\n\t\t} catch (VirginItemException vie) {\n\t\t}\n\n\t\t((T) list.shift()).assertV(100);\n\t\t((T) list.shift()).assertV(0);\n\t\t((T) list.shift()).assertV(1);\n\t\t((T) list.shift()).assertV(102);\n\t\t((T) list.shift()).assertV(2);\n\t\t((T) list.shift()).assertV(3);\n\t\t((T) list.shift()).assertV(4);\n\t\t((T) list.shift()).assertV(105);\n\t\t((T) list.shift()).assertV(104);\n\n\t}","id":23712,"modified_method":"public void testRandomInsert() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\t\tT[] array = new T[5];\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tarray[i] = new T(i);\n\t\t\tlist.push(array[i]);\n\t\t}\n\n\t\tlist.insertPrev(array[0], new T(100));\n\t\tlist.insertPrev(array[2], new T(102));\n\t\tlist.insertNext(array[4], new T(104));\n\t\tlist.insertNext(array[4], new T(105));\n\n\t\tDoublyLinkedList<T> list2 = new DoublyLinkedListImpl<T>();\n\t\tT l2 = new T(9999);\n\t\tlist2.push(l2);\n\t\ttry {\n\t\t\t// already exist\n\t\t\tlist2.insertNext(l2, l2);\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// already exist\n\t\t\tlist2.insertNext(l2, l2);\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// bad position\n\t\t\tlist2.insertPrev(array[3], new T(8888));\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// bad position\n\t\t\tlist2.insertNext(array[3], new T(8888));\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\n\t\ttry {\n\t\t\t// item in other list\n\t\t\tlist2.insertPrev(l2, array[3]);\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// item in other list\n\t\t\tlist2.insertNext(l2, array[3]);\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\n\t\tT l3 = new T(9999);\n\t\tlist2.push(l3);\n\t\ttry {\n\t\t\t// VirginItemException\n\t\t\tl3.setPrev(null); // corrupt it\n\t\t\tlist2.insertPrev(l3, new T(8888));\n\t\t\tfail(\"VirginItemException\");\n\t\t} catch (VirginItemException vie) {\n\t\t}\n\t\ttry {\n\t\t\t// VirginItemException\n\t\t\tl2.setNext(null); // corrupt it\n\t\t\tlist2.insertNext(l2, new T(8888));\n\t\t\tfail(\"VirginItemException\");\n\t\t} catch (VirginItemException vie) {\n\t\t}\n\n\t\tlist.shift().assertV(100);\n\t\tlist.shift().assertV(0);\n\t\tlist.shift().assertV(1);\n\t\tlist.shift().assertV(102);\n\t\tlist.shift().assertV(2);\n\t\tlist.shift().assertV(3);\n\t\tlist.shift().assertV(4);\n\t\tlist.shift().assertV(105);\n\t\tlist.shift().assertV(104);\n\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"public void testClearSize() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\t\tlist.unshift(new T(0));\n\t\tlist.unshift(new T(1));\n\t\tlist.unshift(new T(2));\n\t\tlist.unshift(new T(3));\n\n\t\tassertEquals(\"size()\", 4, list.size());\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\t((T) list.shift()).assertV(3);\n\t\tassertEquals(\"size()\", 3, list.size());\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\t((T) list.shift()).assertV(2);\n\t\tassertEquals(\"size()\", 2, list.size());\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\n\t\tlist.clear();\n\n\t\tassertEquals(\"size()\", 0, list.size());\n\t\tassertTrue(\"isEmpty()\", list.isEmpty());\n\n\t\t// add again\n\t\tlist.unshift(new T(4));\n\t\tlist.unshift(new T(5));\n\t\tassertEquals(\"size()\", 2, list.size());\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\n\t\t((T) list.shift()).assertV(5);\n\t\t((T) list.shift()).assertV(4);\n\n\t\tassertEquals(\"size()\", 0, list.size());\n\t\tassertTrue(\"isEmpty()\", list.isEmpty());\n\t}","id":23713,"modified_method":"public void testClearSize() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\t\tlist.unshift(new T(0));\n\t\tlist.unshift(new T(1));\n\t\tlist.unshift(new T(2));\n\t\tlist.unshift(new T(3));\n\n\t\tassertEquals(\"size()\", 4, list.size());\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\tlist.shift().assertV(3);\n\t\tassertEquals(\"size()\", 3, list.size());\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\t\tlist.shift().assertV(2);\n\t\tassertEquals(\"size()\", 2, list.size());\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\n\t\tlist.clear();\n\n\t\tassertEquals(\"size()\", 0, list.size());\n\t\tassertTrue(\"isEmpty()\", list.isEmpty());\n\n\t\t// add again\n\t\tlist.unshift(new T(4));\n\t\tlist.unshift(new T(5));\n\t\tassertEquals(\"size()\", 2, list.size());\n\t\tassertFalse(\"isEmpty()\", list.isEmpty());\n\n\t\tlist.shift().assertV(5);\n\t\tlist.shift().assertV(4);\n\n\t\tassertEquals(\"size()\", 0, list.size());\n\t\tassertTrue(\"isEmpty()\", list.isEmpty());\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests popValue() method\n\t * popping a value from an empty\n\t * LRUHashtable.\n\t */\n\tpublic void testPopValueFromEmpty() {\n\t\tLRUHashtable methodLRUht = new LRUHashtable();\n\t\tassertNull(methodLRUht.popValue());\n\t}","id":23714,"modified_method":"/**\n\t * Tests popValue() method\n\t * popping a value from an empty\n\t * LRUHashtable.\n\t */\n\tpublic void testPopValueFromEmpty() {\n\t\tLRUHashtable<?, ?> methodLRUht = new LRUHashtable<Object, Object>();\n\t\tassertNull(methodLRUht.popValue());\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests keys() method\n\t * verifying if the Enumeration provided\n\t * is correct\n\t */\n\tpublic void testKeys() {\n\t\tLRUHashtable<Object, Object> methodLRUht = new LRUHashtable<Object, Object>();\n\t\tObject[][] sampleObjects = createSampleKeyVal(sampleElemsNumber);\n\t\t//pushing objects\n\t\tfor (int i=0; i<sampleObjects.length; i++)\n\t\t\tmethodLRUht.push(sampleObjects[i][0],sampleObjects[i][1]);\n\t\tEnumeration methodEnumeration = methodLRUht.keys();\n\t\tint j=0;\n\t\twhile(methodEnumeration.hasMoreElements()) {\t\t\t\n\t\t\tassertEquals(methodEnumeration.nextElement(),sampleObjects[j][0]);\n\t\t\tj++; }\n\t}","id":23715,"modified_method":"/**\n\t * Tests keys() method\n\t * verifying if the Enumeration provided\n\t * is correct\n\t */\n\tpublic void testKeys() {\n\t\tLRUHashtable<Object, Object> methodLRUht = new LRUHashtable<Object, Object>();\n\t\tObject[][] sampleObjects = createSampleKeyVal(sampleElemsNumber);\n\t\t//pushing objects\n\t\tfor (int i=0; i<sampleObjects.length; i++)\n\t\t\tmethodLRUht.push(sampleObjects[i][0],sampleObjects[i][1]);\n\t\tEnumeration<Object> methodEnumeration = methodLRUht.keys();\n\t\tint j=0;\n\t\twhile(methodEnumeration.hasMoreElements()) {\t\t\t\n\t\t\tassertEquals(methodEnumeration.nextElement(),sampleObjects[j][0]);\n\t\t\tj++; }\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests {@link LRUQueue#remove(Object)} method verifies if all objects are\n\t * correctly removed checking the method return value, if the object is\n\t * still contained and the queue size.\n\t */\n\tpublic void testRemove() {\n\t\tLRUQueue methodLRUQueue = new LRUQueue();\n\t\tObject[] sampleObjects = createSampleObjects(sampleElemsNumber);\n\t\tfor (int i=0;i<sampleObjects.length;i++)\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\t\t//removing all objects in the opposite way used by pop() method\n\t\tfor(int i=sampleObjects.length-1;i>=0;i--) {\n\t\t\tassertTrue(methodLRUQueue.remove(sampleObjects[i]));\n\t\t\tassertFalse(methodLRUQueue.contains(sampleObjects[i])); \n\t\t\tassertEquals(i, methodLRUQueue.size());\n\t\t}\n\t}","id":23716,"modified_method":"/**\n\t * Tests {@link LRUQueue#remove(Object)} method verifies if all objects are\n\t * correctly removed checking the method return value, if the object is\n\t * still contained and the queue size.\n\t */\n\tpublic void testRemove() {\n\t\tLRUQueue<Object> methodLRUQueue = new LRUQueue<Object>();\n\t\tObject[] sampleObjects = createSampleObjects(sampleElemsNumber);\n\t\tfor (int i=0;i<sampleObjects.length;i++)\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\t\t//removing all objects in the opposite way used by pop() method\n\t\tfor(int i=sampleObjects.length-1;i>=0;i--) {\n\t\t\tassertTrue(methodLRUQueue.remove(sampleObjects[i]));\n\t\t\tassertFalse(methodLRUQueue.contains(sampleObjects[i])); \n\t\t\tassertEquals(i, methodLRUQueue.size());\n\t\t}\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests {@link LRUQueue#contains(Object)} method trying to find a not\n\t * present object after setting up a sample queue. Then it search a present\n\t * object.\n\t */\n\tpublic void testContains() {\n\t\tLRUQueue methodLRUQueue = createSampleQueue(sampleElemsNumber);\n\t\tassertFalse(methodLRUQueue.contains(new Object()));\n\t\tObject methodSampleObj = new Object();\n\t\tmethodLRUQueue.push(methodSampleObj);\n\t\tassertTrue(methodLRUQueue.contains(methodSampleObj));\n\t}","id":23717,"modified_method":"/**\n\t * Tests {@link LRUQueue#contains(Object)} method trying to find a not\n\t * present object after setting up a sample queue. Then it search a present\n\t * object.\n\t */\n\tpublic void testContains() {\n\t\tLRUQueue<Object> methodLRUQueue = createSampleQueue(sampleElemsNumber);\n\t\tassertFalse(methodLRUQueue.contains(new Object()));\n\t\tObject methodSampleObj = new Object();\n\t\tmethodLRUQueue.push(methodSampleObj);\n\t\tassertTrue(methodLRUQueue.contains(methodSampleObj));\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests isEmpty() method\n\t * trying it with an empty queue\n\t * and then with a sample queue.\n\t */\n\tpublic void testIsEmpty() {\n\t\tLRUQueue methodLRUQueue = new LRUQueue();\n\t\tassertTrue(methodLRUQueue.isEmpty());\n\t\tmethodLRUQueue = createSampleQueue(sampleElemsNumber);\n\t\tassertFalse(methodLRUQueue.isEmpty());\n\t\t//emptying the queue...\n\t\tfor(int i=0;i<sampleElemsNumber;i++)\t\t\n\t\t\tmethodLRUQueue.pop();\n\t\tassertTrue(methodLRUQueue.isEmpty());\n\t}","id":23718,"modified_method":"/**\n\t * Tests isEmpty() method\n\t * trying it with an empty queue\n\t * and then with a sample queue.\n\t */\n\tpublic void testIsEmpty() {\n\t\tLRUQueue<Object> methodLRUQueue = new LRUQueue<Object>();\n\t\tassertTrue(methodLRUQueue.isEmpty());\n\t\tmethodLRUQueue = createSampleQueue(sampleElemsNumber);\n\t\tassertFalse(methodLRUQueue.isEmpty());\n\t\t//emptying the queue...\n\t\tfor(int i=0;i<sampleElemsNumber;i++)\t\t\n\t\t\tmethodLRUQueue.pop();\n\t\tassertTrue(methodLRUQueue.isEmpty());\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests {@link LRUQueue#toArrayOrdered()} method\n\t */\n\tpublic void testToArrayOrdered() {\n\t\tLRUQueue methodLRUQueue = new LRUQueue();\n\t\tObject[] sampleObjects = createSampleObjects(sampleElemsNumber);\n\n\t\t// pushing objects\n\t\tfor (int i = 0; i < sampleObjects.length; i++)\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\n\t\tObject[] resultingArray = methodLRUQueue.toArrayOrdered();\n\n\t\tassertEquals(sampleObjects.length, resultingArray.length);\t\t\n\t\tfor (int i = 0; i < sampleObjects.length; i++)\n\t\t\tassertEquals(sampleObjects[i], resultingArray[i]);\n\t}","id":23719,"modified_method":"/**\n\t * Tests {@link LRUQueue#toArrayOrdered()} method\n\t */\n\tpublic void testToArrayOrdered() {\n\t\tLRUQueue<Object> methodLRUQueue = new LRUQueue<Object>();\n\t\tObject[] sampleObjects = createSampleObjects(sampleElemsNumber);\n\n\t\t// pushing objects\n\t\tfor (int i = 0; i < sampleObjects.length; i++)\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\n\t\tObject[] resultingArray = methodLRUQueue.toArrayOrdered();\n\n\t\tassertEquals(sampleObjects.length, resultingArray.length);\t\t\n\t\tfor (int i = 0; i < sampleObjects.length; i++)\n\t\t\tassertEquals(sampleObjects[i], resultingArray[i]);\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests {@link LRUQueue#elements()} method verifying if the Enumeration\n\t * provided is correct\n\t */\n\tpublic void testElements() {\n\t\tObject[] sampleObjects = createSampleObjects(sampleElemsNumber);\n\t\tLRUQueue methodLRUQueue = new LRUQueue();\n\t\t//pushing objects\n\t\tfor (int i=0; i<sampleObjects.length; i++)\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\t\tEnumeration methodEnumeration = methodLRUQueue.elements();\n\t\tint j=0;\n\t\twhile(methodEnumeration.hasMoreElements()) {\t\t\t\n\t\t\tassertEquals(sampleObjects[j], methodEnumeration.nextElement());\n\t\t\tj++;\n\t\t}\n\t}","id":23720,"modified_method":"/**\n\t * Tests {@link LRUQueue#elements()} method verifying if the Enumeration\n\t * provided is correct\n\t */\n\tpublic void testElements() {\n\t\tObject[] sampleObjects = createSampleObjects(sampleElemsNumber);\n\t\tLRUQueue<Object> methodLRUQueue = new LRUQueue<Object>();\n\t\t//pushing objects\n\t\tfor (int i=0; i<sampleObjects.length; i++)\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\t\tEnumeration<Object> methodEnumeration = methodLRUQueue.elements();\n\t\tint j=0;\n\t\twhile(methodEnumeration.hasMoreElements()) {\t\t\t\n\t\t\tassertEquals(sampleObjects[j], methodEnumeration.nextElement());\n\t\t\tj++;\n\t\t}\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests{@link LRUQueue#pop()} method pushing and popping objects and\n\t * verifying if they are correctly (in a FIFO manner) fetched and deleted\n\t */\n\tpublic void testPop() {\n\t\tLRUQueue methodLRUQueue = new LRUQueue();\n\t\tObject[] sampleObjects = createSampleObjects(sampleElemsNumber);\n\t\t//pushing objects\n\t\tfor (int i=0; i<sampleObjects.length; i++)\t\t\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\t\t//getting objects\n\t\tfor (int i=0; i<sampleObjects.length; i++)\t\t\n\t\t\tassertEquals(sampleObjects[i],methodLRUQueue.pop());\n\t\t//the queue must be empty\n\t\tassertNull(methodLRUQueue.pop());\t\t\t\t\n\t}","id":23721,"modified_method":"/**\n\t * Tests{@link LRUQueue#pop()} method pushing and popping objects and\n\t * verifying if they are correctly (in a FIFO manner) fetched and deleted\n\t */\n\tpublic void testPop() {\n\t\tLRUQueue<Object> methodLRUQueue = new LRUQueue<Object>();\n\t\tObject[] sampleObjects = createSampleObjects(sampleElemsNumber);\n\t\t//pushing objects\n\t\tfor (int i=0; i<sampleObjects.length; i++)\t\t\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\t\t//getting objects\n\t\tfor (int i=0; i<sampleObjects.length; i++)\t\t\n\t\t\tassertEquals(sampleObjects[i],methodLRUQueue.pop());\n\t\t//the queue must be empty\n\t\tassertNull(methodLRUQueue.pop());\t\t\t\t\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests {@link LRUQueue#pushLeast(Object)} method\n\t */\n\tpublic void testPushLeast() {\n\t\tLRUQueue methodLRUQueue = new LRUQueue();\n\t\tObject[] sampleObj = { new Object(), new Object() };\n\n\t\tmethodLRUQueue.push(sampleObj[0]);\n\t\tmethodLRUQueue.pushLeast(sampleObj[1]);\n\n\t\tassertEquals(2, methodLRUQueue.size());\n\t\tassertTrue(verifyLastElemsOrder(methodLRUQueue, sampleObj[1], sampleObj[0]));\n\t\t\n\t\t// --> Same element\n\t\tmethodLRUQueue.pushLeast(sampleObj[0]);\n\n\t\tassertEquals(2, methodLRUQueue.size());\n\t\tassertTrue(verifyLastElemsOrder(methodLRUQueue, sampleObj[0], sampleObj[1]));\n\t}","id":23722,"modified_method":"/**\n\t * Tests {@link LRUQueue#pushLeast(Object)} method\n\t */\n\tpublic void testPushLeast() {\n\t\tLRUQueue<Object> methodLRUQueue = new LRUQueue<Object>();\n\t\tObject[] sampleObj = { new Object(), new Object() };\n\n\t\tmethodLRUQueue.push(sampleObj[0]);\n\t\tmethodLRUQueue.pushLeast(sampleObj[1]);\n\n\t\tassertEquals(2, methodLRUQueue.size());\n\t\tassertTrue(verifyLastElemsOrder(methodLRUQueue, sampleObj[1], sampleObj[0]));\n\t\t\n\t\t// --> Same element\n\t\tmethodLRUQueue.pushLeast(sampleObj[0]);\n\n\t\tassertEquals(2, methodLRUQueue.size());\n\t\tassertTrue(verifyLastElemsOrder(methodLRUQueue, sampleObj[0], sampleObj[1]));\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests {@link LRUQueue#toArray()} method verifying if the array generated\n\t * has the same object that are put into the created LRUQueue\n\t */\n\tpublic void testToArray() {\n\t\tLRUQueue methodLRUQueue = new LRUQueue();\n\t\tObject[] sampleObjects = createSampleObjects(sampleElemsNumber);\n\t\t\n\t\t//pushing objects\n\t\tfor (int i=0; i<sampleObjects.length; i++)\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\t\t\n\t\tObject[] resultingArray = methodLRUQueue.toArray();\n\t\t\n\t\tassertEquals(sampleObjects.length, resultingArray.length);\t\t\n\t\tfor(int i=0;i<sampleObjects.length;i++)\n\t\t\tassertTrue(isPresent(resultingArray, sampleObjects[i]));\n\t}","id":23723,"modified_method":"/**\n\t * Tests {@link LRUQueue#toArray()} method verifying if the array generated\n\t * has the same object that are put into the created LRUQueue\n\t */\n\tpublic void testToArray() {\n\t\tLRUQueue<Object> methodLRUQueue = new LRUQueue<Object>();\n\t\tObject[] sampleObjects = createSampleObjects(sampleElemsNumber);\n\t\t\n\t\t//pushing objects\n\t\tfor (int i=0; i<sampleObjects.length; i++)\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\t\t\n\t\tObject[] resultingArray = methodLRUQueue.toArray();\n\t\t\n\t\tassertEquals(sampleObjects.length, resultingArray.length);\t\t\n\t\tfor(int i=0;i<sampleObjects.length;i++)\n\t\t\tassertTrue(isPresent(resultingArray, sampleObjects[i]));\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests {@link LRUQueue#push(Object)} method and verifies the behaviour\n\t * when pushing the same object more than one time.\n\t */\n\tpublic void testPushSameObjTwice() {\n\t\tLRUQueue methodLRUQueue = this.createSampleQueue(sampleElemsNumber);\n\t\tObject[] sampleObj = {new Object(), new Object()};\n\t\t\n\t\tmethodLRUQueue.push(sampleObj[0]);\n\t\tmethodLRUQueue.push(sampleObj[1]);\n\t\t\n\t\t//check size\n\t\tassertEquals(sampleElemsNumber + 2, methodLRUQueue.size());\t\t\t\n\t\t//check order\n\t\tassertTrue(verifyLastElemsOrder(methodLRUQueue, sampleObj[0], sampleObj[1]));\t\t\n\t\t\n\t\tmethodLRUQueue.push(sampleObj[0]);\n\t\t//check size\n\t\tassertEquals(sampleElemsNumber + 2, methodLRUQueue.size());\t\t\t\n\t\t//check order\n\t\tassertTrue(verifyLastElemsOrder(methodLRUQueue, sampleObj[1], sampleObj[0]));\t\t\n\t}","id":23724,"modified_method":"/**\n\t * Tests {@link LRUQueue#push(Object)} method and verifies the behaviour\n\t * when pushing the same object more than one time.\n\t */\n\tpublic void testPushSameObjTwice() {\n\t\tLRUQueue<Object> methodLRUQueue = this.createSampleQueue(sampleElemsNumber);\n\t\tObject[] sampleObj = {new Object(), new Object()};\n\t\t\n\t\tmethodLRUQueue.push(sampleObj[0]);\n\t\tmethodLRUQueue.push(sampleObj[1]);\n\t\t\n\t\t//check size\n\t\tassertEquals(sampleElemsNumber + 2, methodLRUQueue.size());\t\t\t\n\t\t//check order\n\t\tassertTrue(verifyLastElemsOrder(methodLRUQueue, sampleObj[0], sampleObj[1]));\t\t\n\t\t\n\t\tmethodLRUQueue.push(sampleObj[0]);\n\t\t//check size\n\t\tassertEquals(sampleElemsNumber + 2, methodLRUQueue.size());\t\t\t\n\t\t//check order\n\t\tassertTrue(verifyLastElemsOrder(methodLRUQueue, sampleObj[1], sampleObj[0]));\t\t\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Verifies if the order of the last two elements in the\n\t * queue is correct\n\t * @param aLRUQueue the LRUQueue to check\n\t * @param nextToLast the next-to-last element expected\n\t * @param last the last element expected\n\t * @return true if the order is correct\n\t */\n\tprivate boolean verifyLastElemsOrder(LRUQueue aLRUQueue, Object nextToLast, Object last ) {\n\t\tboolean retVal = true;\n\t\tint size = aLRUQueue.size();\n\t\tEnumeration methodEnum = aLRUQueue.elements();\n\t\tint counter = 0;\n\t\twhile (methodEnum.hasMoreElements()) {\n\t\t\t//next-to-last object\n\t\t\tif (counter == size-2)\n\t\t\t\tretVal &= (methodEnum.nextElement()).equals(nextToLast);\n\t\t\t//last object\n\t\t\telse if (counter == size-1)\n\t\t\t\tretVal &= (methodEnum.nextElement()).equals(last);\n\t\t\telse\n\t\t\t\tmethodEnum.nextElement();\n\t\t\tcounter++; }\n\t\treturn retVal;\n\t}","id":23725,"modified_method":"/**\n\t * Verifies if the order of the last two elements in the\n\t * queue is correct\n\t * @param aLRUQueue the LRUQueue to check\n\t * @param nextToLast the next-to-last element expected\n\t * @param last the last element expected\n\t * @return true if the order is correct\n\t */\n\tprivate boolean verifyLastElemsOrder(LRUQueue<Object> aLRUQueue, Object nextToLast, Object last ) {\n\t\tboolean retVal = true;\n\t\tint size = aLRUQueue.size();\n\t\tEnumeration<Object> methodEnum = aLRUQueue.elements();\n\t\tint counter = 0;\n\t\twhile (methodEnum.hasMoreElements()) {\n\t\t\t//next-to-last object\n\t\t\tif (counter == size-2)\n\t\t\t\tretVal &= (methodEnum.nextElement()).equals(nextToLast);\n\t\t\t//last object\n\t\t\telse if (counter == size-1)\n\t\t\t\tretVal &= (methodEnum.nextElement()).equals(last);\n\t\t\telse\n\t\t\t\tmethodEnum.nextElement();\n\t\t\tcounter++; }\n\t\treturn retVal;\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Creates a LRUQueue filled with the specified objects number\n\t * @param size queue size\n\t * @return the created LRUQueue\n\t */\n\tprivate LRUQueue createSampleQueue(int size) {\n\t\tLRUQueue methodLRUQueue = new LRUQueue();\n\t\tObject[] sampleObjects = createSampleObjects(size);\n\t\tfor (int i=0;i<sampleObjects.length;i++)\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\t\treturn methodLRUQueue;\n\t}","id":23726,"modified_method":"/**\n\t * Creates a LRUQueue filled with the specified objects number\n\t * @param size queue size\n\t * @return the created LRUQueue\n\t */\n\tprivate LRUQueue<Object> createSampleQueue(int size) {\n\t\tLRUQueue<Object> methodLRUQueue = new LRUQueue<Object>();\n\t\tObject[] sampleObjects = createSampleObjects(size);\n\t\tfor (int i=0;i<sampleObjects.length;i++)\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\t\treturn methodLRUQueue;\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests {@link LRUQueue#size()} method checking size when empty, when\n\t * putting each object and when popping each object.\n\t */\n\tpublic void testSize() {\n\t\tObject[] sampleObjects = createSampleObjects(sampleElemsNumber);\n\t\tLRUQueue methodLRUQueue = new LRUQueue();\n\t\tassertEquals(0, methodLRUQueue.size());\n\t\t//pushing objects\n\t\tfor (int i=0; i<sampleObjects.length; i++) {\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\t\t\tassertEquals(i + 1, methodLRUQueue.size());\n\t\t}\n\t\t//getting all objects\n\t\tfor (int i=sampleObjects.length-1; i>=0; i--) {\n\t\t\tmethodLRUQueue.pop();\n\t\t\tassertEquals(i, methodLRUQueue.size());\n\t\t}\n\t\tassertEquals(0, methodLRUQueue.size());\n\t}","id":23727,"modified_method":"/**\n\t * Tests {@link LRUQueue#size()} method checking size when empty, when\n\t * putting each object and when popping each object.\n\t */\n\tpublic void testSize() {\n\t\tObject[] sampleObjects = createSampleObjects(sampleElemsNumber);\n\t\tLRUQueue<Object> methodLRUQueue = new LRUQueue<Object>();\n\t\tassertEquals(0, methodLRUQueue.size());\n\t\t//pushing objects\n\t\tfor (int i=0; i<sampleObjects.length; i++) {\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\t\t\tassertEquals(i + 1, methodLRUQueue.size());\n\t\t}\n\t\t//getting all objects\n\t\tfor (int i=sampleObjects.length-1; i>=0; i--) {\n\t\t\tmethodLRUQueue.pop();\n\t\t\tassertEquals(i, methodLRUQueue.size());\n\t\t}\n\t\tassertEquals(0, methodLRUQueue.size());\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests {@link LRUQueue#push(Object)} method providing a null object as\n\t * argument (after setting up a sample queue) and verifying if the correct\n\t * exception is raised\n\t */\n\tpublic void testPushNull() {\n\t\tLRUQueue methodLRUQueue = this.createSampleQueue(sampleElemsNumber);\n\t\ttry {\n\t\t\tmethodLRUQueue.push(null);\n\t\t\tfail(\"Expected Exception Error Not Thrown!\"); }\n\t\tcatch (NullPointerException anException) {\n\t\t\tassertNotNull(anException);\t}\n\n\t\ttry {\n\t\t\tmethodLRUQueue.pushLeast(null);\n\t\t\tfail(\"Expected Exception Error Not Thrown!\");\n\t\t} catch (NullPointerException anException) {\n\t\t\tassertNotNull(anException);\n\t\t}\n\t}","id":23728,"modified_method":"/**\n\t * Tests {@link LRUQueue#push(Object)} method providing a null object as\n\t * argument (after setting up a sample queue) and verifying if the correct\n\t * exception is raised\n\t */\n\tpublic void testPushNull() {\n\t\tLRUQueue<Object> methodLRUQueue = this.createSampleQueue(sampleElemsNumber);\n\t\ttry {\n\t\t\tmethodLRUQueue.push(null);\n\t\t\tfail(\"Expected Exception Error Not Thrown!\"); }\n\t\tcatch (NullPointerException anException) {\n\t\t\tassertNotNull(anException);\t}\n\n\t\ttry {\n\t\t\tmethodLRUQueue.pushLeast(null);\n\t\t\tfail(\"Expected Exception Error Not Thrown!\");\n\t\t} catch (NullPointerException anException) {\n\t\t\tassertNotNull(anException);\n\t\t}\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests toArray() method\n\t * when the queue is empty\n\t */\n\tpublic void testToArrayEmptyQueue() {\n\t\tLRUQueue methodLRUQueue = new LRUQueue();\n\t\tassertEquals(0, methodLRUQueue.toArray().length);\n\t}","id":23729,"modified_method":"/**\n\t * Tests toArray() method\n\t * when the queue is empty\n\t */\n\tpublic void testToArrayEmptyQueue() {\n\t\tLRUQueue<Object> methodLRUQueue = new LRUQueue<Object>();\n\t\tassertEquals(0, methodLRUQueue.toArray().length);\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests {@link LRUQueue#remove(Object)} method trying to remove a not\n\t * present object after setting up a sample queue.\n\t */\n\tpublic void testRemoveNotPresent() {\n\t\tLRUQueue methodLRUQueue = createSampleQueue(sampleElemsNumber);\n\t\tassertFalse(methodLRUQueue.remove(new Object()));\n\t}","id":23730,"modified_method":"/**\n\t * Tests {@link LRUQueue#remove(Object)} method trying to remove a not\n\t * present object after setting up a sample queue.\n\t */\n\tpublic void testRemoveNotPresent() {\n\t\tLRUQueue<Object> methodLRUQueue = createSampleQueue(sampleElemsNumber);\n\t\tassertFalse(methodLRUQueue.remove(new Object()));\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests {@link LRUQueue#toArray(Object[])} method\n\t */\n\tpublic void testToArray2() {\n\t\tLRUQueue methodLRUQueue = new LRUQueue();\n\t\tObject[] sampleObjects = createSampleObjects(sampleElemsNumber);\n\n\t\t// pushing objects\n\t\tfor (int i = 0; i < sampleObjects.length; i++)\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\t\t\n\t\tObject[] resultingArray = new Object[sampleObjects.length];\n\t\tmethodLRUQueue.toArray(resultingArray);\n\n\t\tassertEquals(sampleObjects.length, resultingArray.length);\t\t\n\t\tfor (int i = 0; i < sampleObjects.length; i++)\n\t\t\tassertTrue(isPresent(resultingArray, sampleObjects[i]));\n\t}","id":23731,"modified_method":"/**\n\t * Tests {@link LRUQueue#toArray(Object[])} method\n\t */\n\tpublic void testToArray2() {\n\t\tLRUQueue<Object> methodLRUQueue = new LRUQueue<Object>();\n\t\tObject[] sampleObjects = createSampleObjects(sampleElemsNumber);\n\n\t\t// pushing objects\n\t\tfor (int i = 0; i < sampleObjects.length; i++)\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\t\t\n\t\tObject[] resultingArray = new Object[sampleObjects.length];\n\t\tmethodLRUQueue.toArray(resultingArray);\n\n\t\tassertEquals(sampleObjects.length, resultingArray.length);\t\t\n\t\tfor (int i = 0; i < sampleObjects.length; i++)\n\t\t\tassertTrue(isPresent(resultingArray, sampleObjects[i]));\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests <code>toArrayOrdered(Object[])<\/code> method\n\t */\n\tpublic void testToArrayOrdered2() {\n\t\tLRUQueue methodLRUQueue = new LRUQueue();\n\t\tObject[] sampleObjects = createSampleObjects(sampleElemsNumber);\n\n\t\t// pushing objects\n\t\tfor (int i = 0; i < sampleObjects.length; i++)\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\n\t\tObject[] resultingArray = new Object[sampleObjects.length];\n\t\tmethodLRUQueue.toArrayOrdered(resultingArray);\n\t\t\n\t\tassertEquals(resultingArray.length, sampleObjects.length);\n\t\tfor (int i = 0; i < sampleObjects.length; i++)\n\t\t\tassertEquals(sampleObjects[i], resultingArray[i]);\n\t}","id":23732,"modified_method":"/**\n\t * Tests <code>toArrayOrdered(Object[])<\/code> method\n\t */\n\tpublic void testToArrayOrdered2() {\n\t\tLRUQueue<Object> methodLRUQueue = new LRUQueue<Object>();\n\t\tObject[] sampleObjects = createSampleObjects(sampleElemsNumber);\n\n\t\t// pushing objects\n\t\tfor (int i = 0; i < sampleObjects.length; i++)\n\t\t\tmethodLRUQueue.push(sampleObjects[i]);\n\n\t\tObject[] resultingArray = new Object[sampleObjects.length];\n\t\tmethodLRUQueue.toArrayOrdered(resultingArray);\n\t\t\n\t\tassertEquals(resultingArray.length, sampleObjects.length);\n\t\tfor (int i = 0; i < sampleObjects.length; i++)\n\t\t\tassertEquals(sampleObjects[i], resultingArray[i]);\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Tests{@link LRUQueue#remove(Object)} providing a null argument and\n\t * trying to remove it after setting up a sample queue.\n\t */\n\tpublic void testRemoveNull() {\n\t\tLRUQueue methodLRUQueue = createSampleQueue(sampleElemsNumber);\n\t\ttry {\n\t\t\tmethodLRUQueue.remove(null);\n\t\t\tfail(\"Expected Exception Error Not Thrown!\"); }\n\t\tcatch (NullPointerException anException) {\n\t\t\tassertNotNull(anException);\t}\n\t}","id":23733,"modified_method":"/**\n\t * Tests{@link LRUQueue#remove(Object)} providing a null argument and\n\t * trying to remove it after setting up a sample queue.\n\t */\n\tpublic void testRemoveNull() {\n\t\tLRUQueue<Object> methodLRUQueue = createSampleQueue(sampleElemsNumber);\n\t\ttry {\n\t\t\tmethodLRUQueue.remove(null);\n\t\t\tfail(\"Expected Exception Error Not Thrown!\"); }\n\t\tcatch (NullPointerException anException) {\n\t\t\tassertNotNull(anException);\t}\n\t}","commit_id":"1c9be1745167a99053575a1014b4e480a44a461f","url":"https://github.com/freenet/fred"},{"original_method":"protected void initializeHTTPS() throws Exception\n    {\n        if (m_useNIO) {\n            // we do not want to create a compile time dependency on Java 5 classes\n            // so we use a bit of reflection here\n            SelectChannelConnector s_listener = (SelectChannelConnector) Class.forName(\"org.mortbay.jetty.security.SslSelectChannelConnector\").newInstance();\n            s_listener.addLifeCycleListener(new ConnectorListener(m_httpsPortProperty));\n            s_listener.setPort(m_httpsPort);\n            s_listener.setMaxIdleTime(60000);\n            if (m_keystore != null) {\n                s_listener.getClass().getMethod(\"setKeystore\", new Class[] {String.class}).invoke(s_listener, new Object[] { m_keystore });\n            }\n            if (m_passwd != null) {\n                System.setProperty(\"jetty.ssl.password\" /* SslSelectChannelConnector.PASSWORD_PROPERTY */ , m_passwd);\n                s_listener.getClass().getMethod(\"setPassword\", new Class[] {String.class}).invoke(s_listener, new Object[] { m_passwd });\n            }\n            if (m_keyPasswd != null) {\n                System.setProperty(\"jetty.ssl.keypassword\" /* SslSelectChannelConnector.KEYPASSWORD_PROPERTY */, m_keyPasswd);\n                s_listener.getClass().getMethod(\"setKeyPassword\", new Class[] {String.class}).invoke(s_listener, new Object[] { m_keyPasswd });\n            }\n            m_server.addConnector(s_listener);\n        }\n        else {\n            SslSocketConnector s_listener = new SslSocketConnector();\n            s_listener.addLifeCycleListener(new ConnectorListener(m_httpsPortProperty));\n            s_listener.setPort(m_httpsPort);\n            s_listener.setMaxIdleTime(60000);\n            if (m_keystore != null) {\n                s_listener.setKeystore(m_keystore);\n            }\n            if (m_passwd != null) {\n                System.setProperty(SslSocketConnector.PASSWORD_PROPERTY, m_passwd);\n                s_listener.setPassword(m_passwd);\n            }\n            if (m_keyPasswd != null) {\n                System.setProperty(SslSocketConnector.KEYPASSWORD_PROPERTY, m_keyPasswd);\n                s_listener.setKeyPassword(m_keyPasswd);\n            }\n            m_server.addConnector(s_listener);\n        }\n    }","id":23734,"modified_method":"protected void initializeHTTPS() throws Exception\n    {\n        if (m_useNIO) {\n            SelectChannelConnector s_listener = (SelectChannelConnector) Class.forName(\"org.mortbay.jetty.security.SslSelectChannelConnector\").newInstance();\n            s_listener.addLifeCycleListener(new ConnectorListener(m_httpsPortProperty));\n            s_listener.setPort(m_httpsPort);\n            s_listener.setMaxIdleTime(60000);\n            if (m_keystore != null) {\n                s_listener.getClass().getMethod(\"setKeystore\", new Class[] {String.class}).invoke(s_listener, new Object[] { m_keystore });\n            }\n            if (m_passwd != null) {\n                System.setProperty(\"jetty.ssl.password\" /* SslSelectChannelConnector.PASSWORD_PROPERTY */ , m_passwd);\n                s_listener.getClass().getMethod(\"setPassword\", new Class[] {String.class}).invoke(s_listener, new Object[] { m_passwd });\n            }\n            if (m_keyPasswd != null) {\n                System.setProperty(\"jetty.ssl.keypassword\" /* SslSelectChannelConnector.KEYPASSWORD_PROPERTY */, m_keyPasswd);\n                s_listener.getClass().getMethod(\"setKeyPassword\", new Class[] {String.class}).invoke(s_listener, new Object[] { m_keyPasswd });\n            }\n            if (m_truststore != null) {\n                s_listener.getClass().getMethod(\"setTruststore\", new Class[] {String.class}).invoke(s_listener, new Object[] { m_truststore });\n            }\n            if (m_trustpasswd != null) {\n                s_listener.getClass().getMethod(\"setTrustPassword\", new Class[] {String.class}).invoke(s_listener, new Object[] { m_trustpasswd });\n            }\n            if (\"wants\".equals(m_clientcert)) {\n                s_listener.getClass().getMethod(\"setWantClientAuth\", new Class[] { Boolean.TYPE }).invoke(s_listener, new Object[] { Boolean.TRUE });\n            }\n            else if (\"needs\".equals(m_clientcert)) {\n                s_listener.getClass().getMethod(\"setNeedClientAuth\", new Class[] { Boolean.TYPE }).invoke(s_listener, new Object[] { Boolean.TRUE });\n            }\n            m_server.addConnector(s_listener);\n        }\n        else {\n            SslSocketConnector s_listener = new SslSocketConnector();\n            s_listener.addLifeCycleListener(new ConnectorListener(m_httpsPortProperty));\n            s_listener.setPort(m_httpsPort);\n            s_listener.setMaxIdleTime(60000);\n            if (m_keystore != null) {\n                s_listener.setKeystore(m_keystore);\n            }\n            if (m_passwd != null) {\n                System.setProperty(SslSocketConnector.PASSWORD_PROPERTY, m_passwd);\n                s_listener.setPassword(m_passwd);\n            }\n            if (m_keyPasswd != null) {\n                System.setProperty(SslSocketConnector.KEYPASSWORD_PROPERTY, m_keyPasswd);\n                s_listener.setKeyPassword(m_keyPasswd);\n            }\n            if (m_truststore != null) {\n                s_listener.setTruststore(m_truststore);\n            }\n            if (m_trustpasswd != null) {\n                s_listener.setTrustPassword(m_trustpasswd);\n            }\n            if (\"wants\".equals(m_clientcert)) {\n                s_listener.setWantClientAuth(true);\n                s_listener.getClass().getMethod(\"setWantClientAuth\", new Class[] {Boolean.class}).invoke(s_listener, new Object[] { Boolean.TRUE });\n            }\n            else if (\"needs\".equals(m_clientcert)) {\n                s_listener.setNeedClientAuth(true);\n            }\n            m_server.addConnector(s_listener);\n        }\n    }","commit_id":"839ca81818bf42f7bff75306848e4eb26d1bf12b","url":"https://github.com/apache/felix"},{"original_method":"public String getStringProperty(String name, String dflt_val)\n    {\n        String retval = dflt_val;\n        \n        String strval = m_bundleContext.getProperty( name );\n        if ( strval != null)\n        {\n            retval = strval;\n        }\n        \n        return retval;\n    }","id":23735,"modified_method":"private String getStringProperty(Dictionary props, String name, String dflt_val) {\n        String retval = dflt_val;\n        String strval = getProperty(props, name);\n        if (strval != null) {\n            retval = strval;\n        }\n        return retval;\n    }","commit_id":"839ca81818bf42f7bff75306848e4eb26d1bf12b","url":"https://github.com/apache/felix"},{"original_method":"public void start( BundleContext bundleContext ) throws BundleException\n    {\n        m_bundleContext = bundleContext;\n\n\n        setConfiguration();\n\n        m_logTracker = new ServiceTracker( bundleContext, LogService.class.getName(), null );\n        m_logTracker.open();\n\n        // org.mortbay.util.Loader needs this (used for JDK 1.4 log classes)\n        Thread.currentThread().setContextClassLoader( this.getClass().getClassLoader() );\n        // set the Jetty logger to be LogService based\n        initializeJettyLogger();\n\n        try\n        {\n            initializeJetty();\n\n        }\n        catch ( Exception ex )\n        {\n            //TODO: maybe throw a bundle exception in here?\n            log( LogService.LOG_INFO, \"Http2\", ex );\n            return;\n        }\n\n        m_httpServ = new HttpServiceFactory();\n        m_svcReg = m_bundleContext.registerService( HttpService.class.getName(), m_httpServ, m_svcProperties );\n        // OSGi spec states the properties should not be changed after registration,\n        // so create new copy for later  clone for updates\n        m_svcProperties = new Properties(m_svcProperties);\n    }","id":23736,"modified_method":"public void start(BundleContext bundleContext) throws BundleException {\n        m_bundleContext = bundleContext;\n\n        m_logTracker = new ServiceTracker( bundleContext, LogService.class.getName(), null );\n        m_logTracker.open();\n\n        setConfiguration(EMPTY_PROPS);\n        \n        m_running = true;\n        m_thread = new Thread(this, \"Jetty HTTP Service Launcher\");\n        m_thread.start();\n        \n        m_configSvcReg = m_bundleContext.registerService(ManagedService.class.getName(), this, new Properties() {{ put(Constants.SERVICE_PID, PID); }} );\n    }","commit_id":"839ca81818bf42f7bff75306848e4eb26d1bf12b","url":"https://github.com/apache/felix"},{"original_method":"public boolean getBooleanProperty(String name, boolean dflt_val)\n    {\n        boolean retval = dflt_val;\n        \n        String strval = m_bundleContext.getProperty( name );\n        if ( strval != null)\n        {\n            if (strval.toLowerCase().equals( \"true\" ) ||\n                strval.toLowerCase().equals( \"yes\" ))\n            {\n                retval = true;\n            }\n            else\n            {\n                // poss should raise error/warn here\n                retval = false;\n            }\n        }\n        \n        return retval;\n    }","id":23737,"modified_method":"private boolean getBooleanProperty(Dictionary props, String name, boolean dflt_val) {\n        boolean retval = dflt_val;\n        String strval = getProperty(props, name);\n        if (strval != null) {\n            retval = (strval.toLowerCase().equals(\"true\") || strval.toLowerCase().equals(\"yes\"));\n        }\n        return retval;\n    }","commit_id":"839ca81818bf42f7bff75306848e4eb26d1bf12b","url":"https://github.com/apache/felix"},{"original_method":"public void stop( BundleContext bundleContext ) throws BundleException\n    {\n        //TODO: wonder if we need to closedown service factory ???\n\n        if ( m_svcReg != null )\n        {\n            m_svcReg.unregister();\n        }\n\n        try\n        {\n            m_server.stop();\n        }\n        catch ( Exception e )\n        {\n            //TODO: log some form of error\n        }\n\n        // replace non-LogService logger for jetty\n        Log.setLog( new StdErrLog() );\n        \n        m_logTracker.close();\n    }","id":23738,"modified_method":"public void stop(BundleContext bundleContext) throws BundleException {\n        if (m_configSvcReg != null) {\n            m_configSvcReg.unregister();\n        }\n        \n        m_running = false;\n        m_thread.interrupt();\n        \n        m_logTracker.close();\n    }","commit_id":"839ca81818bf42f7bff75306848e4eb26d1bf12b","url":"https://github.com/apache/felix"},{"original_method":"protected void initializeJettyLogger() {\n        String oldProperty = System.getProperty( \"org.mortbay.log.class\" );\n        System.setProperty( \"org.mortbay.log.class\", LogServiceLog.class.getName() );\n        \n        if (!(Log.getLog() instanceof LogServiceLog)) {\n            Log.setLog( new LogServiceLog() );\n        }\n        \n        Log.getLog().setDebugEnabled( debug );\n        \n        if (oldProperty != null) {\n            System.setProperty( \"org.mortbay.log.class\", oldProperty );\n        }\n    }","id":23739,"modified_method":"private void setConfiguration(Dictionary props) {\n        debug = getBooleanProperty(props, FELIX_HTTP_DEBUG, getBooleanProperty(props, HTTP_DEBUG, false));\n        \n        // get default HTTP and HTTPS ports as per the OSGi spec\n        m_httpPort = getIntProperty(props, HTTP_PORT, DEFAULT_HTTP_PORT);\n        m_httpsPort = getIntProperty(props, HTTPS_PORT, DEFAULT_HTTPS_PORT);\n        // collect other properties, default to legacy names only if new ones are not available\n        m_useNIO = getBooleanProperty(props, HTTP_NIO, DEFAULT_USE_NIO);\n        m_sslProvider = getStringProperty(props, FELIX_SSL_PROVIDER, getStringProperty(props, OSCAR_SSL_PROVIDER, DEFAULT_SSL_PROVIDER));\n        m_httpsPortProperty = getStringProperty(props, HTTPS_SVCPROP_PORT, HTTPS_PORT);\n        m_keystore = getStringProperty(props, FELIX_KEYSTORE, m_bundleContext.getProperty(OSCAR_KEYSTORE));\n        m_passwd = getStringProperty(props, FELIX_KEYSTORE_PASSWORD, m_bundleContext.getProperty(OSCAR_KEYSTORE_PASSWORD));\n        m_keyPasswd = getStringProperty(props, FELIX_KEYSTORE_KEY_PASSWORD, m_bundleContext.getProperty(OSCAR_KEYSTORE_KEY_PASSWORD));\n        m_useHttps = getBooleanProperty(props, FELIX_HTTPS_ENABLE, getBooleanProperty(props, OSCAR_HTTPS_ENABLE, DEFAULT_HTTPS_ENABLE));\n        m_httpPortProperty = getStringProperty(props, HTTP_SVCPROP_PORT, HTTP_PORT);\n        m_useHttp = getBooleanProperty(props, FELIX_HTTP_ENABLE, DEFAULT_HTTP_ENABLE);\n        m_truststore = getStringProperty(props, FELIX_TRUSTSTORE, null);\n        m_trustpasswd = getStringProperty(props, FELIX_TRUSTSTORE_PASSWORD, null);\n        m_clientcert = getStringProperty(props, FELIX_HTTPS_CLIENT_CERT, DEFAULT_HTTPS_CLIENT_CERT);\n    }","commit_id":"839ca81818bf42f7bff75306848e4eb26d1bf12b","url":"https://github.com/apache/felix"},{"original_method":"public int getIntProperty(String name, int dflt_val)\n    {\n        int retval = dflt_val;\n        \n        try\n        {\n            retval = Integer.parseInt( m_bundleContext.getProperty( name ) );\n        }\n        catch ( Exception e )\n        {\n            // maybe log a message saying using default?\n            retval = dflt_val;\n        }\n        \n        return retval;\n    }","id":23740,"modified_method":"private int getIntProperty(Dictionary props, String name, int dflt_val) {\n        int retval = dflt_val;\n        try {\n            retval = Integer.parseInt(getProperty(props, name));\n        }\n        catch (Exception e) {\n            retval = dflt_val;\n        }\n        return retval;\n    }","commit_id":"839ca81818bf42f7bff75306848e4eb26d1bf12b","url":"https://github.com/apache/felix"},{"original_method":"public InjectorForTopDownAnalyzer(\n        @NotNull Project project,\n        @NotNull TopDownAnalysisParameters topDownAnalysisParameters,\n        @NotNull ModuleConfiguration moduleConfiguration,\n        @NotNull ModuleDescriptor moduleDescriptor,\n        JetControlFlowDataTraceFactory jetControlFlowDataTraceFactory\n    ) {\n        this.topDownAnalyzer = new TopDownAnalyzer();\n        this.topDownAnalysisContext = new TopDownAnalysisContext();\n        this.bodyResolver = new BodyResolver();\n        this.controlFlowAnalyzer = new ControlFlowAnalyzer();\n        this.declarationsChecker = new DeclarationsChecker();\n        this.descriptorResolver = new DescriptorResolver();\n        this.project = project;\n        this.topDownAnalysisParameters = topDownAnalysisParameters;\n        DeclarationResolver declarationResolver = new DeclarationResolver();\n        AnnotationResolver annotationResolver = new AnnotationResolver();\n        CallResolver callResolver = new CallResolver();\n        ExpressionTypingServices expressionTypingServices = new ExpressionTypingServices();\n        TypeResolver typeResolver = new TypeResolver();\n        OverloadingConflictResolver overloadingConflictResolver = new OverloadingConflictResolver();\n        ImportsResolver importsResolver = new ImportsResolver();\n        DelegationResolver delegationResolver = new DelegationResolver();\n        OverloadResolver overloadResolver = new OverloadResolver();\n        OverrideResolver overrideResolver = new OverrideResolver();\n        TypeHierarchyResolver typeHierarchyResolver = new TypeHierarchyResolver();\n\n        this.topDownAnalyzer.setBodyResolver(bodyResolver);\n        this.topDownAnalyzer.setConfiguration(moduleConfiguration);\n        this.topDownAnalyzer.setContext(topDownAnalysisContext);\n        this.topDownAnalyzer.setControlFlowAnalyzer(controlFlowAnalyzer);\n        this.topDownAnalyzer.setDeclarationResolver(declarationResolver);\n        this.topDownAnalyzer.setDeclarationsChecker(declarationsChecker);\n        this.topDownAnalyzer.setDelegationResolver(delegationResolver);\n        this.topDownAnalyzer.setModuleDescriptor(moduleDescriptor);\n        this.topDownAnalyzer.setOverloadResolver(overloadResolver);\n        this.topDownAnalyzer.setOverrideResolver(overrideResolver);\n        this.topDownAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.topDownAnalyzer.setTypeHierarchyResolver(typeHierarchyResolver);\n\n        this.topDownAnalysisContext.setTopDownAnalysisParameters(topDownAnalysisParameters);\n\n        this.bodyResolver.setCallResolver(callResolver);\n        this.bodyResolver.setContext(topDownAnalysisContext);\n        this.bodyResolver.setDescriptorResolver(descriptorResolver);\n        this.bodyResolver.setExpressionTypingServices(expressionTypingServices);\n        this.bodyResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n\n        this.controlFlowAnalyzer.setContext(topDownAnalysisContext);\n        this.controlFlowAnalyzer.setFlowDataTraceFactory(jetControlFlowDataTraceFactory);\n        this.controlFlowAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n\n        this.declarationsChecker.setContext(topDownAnalysisContext);\n\n        this.descriptorResolver.setAnnotationResolver(annotationResolver);\n        this.descriptorResolver.setExpressionTypingServices(expressionTypingServices);\n        this.descriptorResolver.setTypeResolver(typeResolver);\n\n        declarationResolver.setAnnotationResolver(annotationResolver);\n        declarationResolver.setContext(topDownAnalysisContext);\n        declarationResolver.setDescriptorResolver(descriptorResolver);\n        declarationResolver.setImportsResolver(importsResolver);\n\n        annotationResolver.setCallResolver(callResolver);\n        annotationResolver.setExpressionTypingServices(expressionTypingServices);\n\n        callResolver.setDescriptorResolver(descriptorResolver);\n        callResolver.setExpressionTypingServices(expressionTypingServices);\n        callResolver.setOverloadingConflictResolver(overloadingConflictResolver);\n        callResolver.setTypeResolver(typeResolver);\n\n        expressionTypingServices.setCallResolver(callResolver);\n        expressionTypingServices.setDescriptorResolver(descriptorResolver);\n        expressionTypingServices.setProject(project);\n        expressionTypingServices.setTypeResolver(typeResolver);\n\n        typeResolver.setAnnotationResolver(annotationResolver);\n        typeResolver.setDescriptorResolver(descriptorResolver);\n\n        importsResolver.setConfiguration(moduleConfiguration);\n        importsResolver.setContext(topDownAnalysisContext);\n\n        delegationResolver.setContext(topDownAnalysisContext);\n\n        overloadResolver.setContext(topDownAnalysisContext);\n\n        overrideResolver.setContext(topDownAnalysisContext);\n        overrideResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n\n        typeHierarchyResolver.setConfiguration(moduleConfiguration);\n        typeHierarchyResolver.setContext(topDownAnalysisContext);\n        typeHierarchyResolver.setDescriptorResolver(descriptorResolver);\n        typeHierarchyResolver.setImportsResolver(importsResolver);\n        typeHierarchyResolver.setModuleDescriptor(moduleDescriptor);\n\n    }","id":23741,"modified_method":"public InjectorForTopDownAnalyzer(\n        @NotNull Project project,\n        @NotNull TopDownAnalysisParameters topDownAnalysisParameters,\n        @NotNull ModuleConfiguration moduleConfiguration,\n        @NotNull ModuleDescriptor moduleDescriptor,\n        JetControlFlowDataTraceFactory jetControlFlowDataTraceFactory\n    ) {\n        this.topDownAnalyzer = new TopDownAnalyzer();\n        this.topDownAnalysisContext = new TopDownAnalysisContext();\n        this.bodyResolver = new BodyResolver();\n        this.controlFlowAnalyzer = new ControlFlowAnalyzer();\n        this.declarationsChecker = new DeclarationsChecker();\n        this.descriptorResolver = new DescriptorResolver();\n        this.project = project;\n        this.topDownAnalysisParameters = topDownAnalysisParameters;\n        DeclarationResolver declarationResolver = new DeclarationResolver();\n        AnnotationResolver annotationResolver = new AnnotationResolver();\n        CallResolver callResolver = new CallResolver();\n        ExpressionTypingServices expressionTypingServices = new ExpressionTypingServices();\n        TypeResolver typeResolver = new TypeResolver();\n        OverloadingConflictResolver overloadingConflictResolver = new OverloadingConflictResolver();\n        ImportsResolver importsResolver = new ImportsResolver();\n        DelegationResolver delegationResolver = new DelegationResolver();\n        NamespaceFactoryImpl namespaceFactoryImpl = new NamespaceFactoryImpl();\n        OverloadResolver overloadResolver = new OverloadResolver();\n        OverrideResolver overrideResolver = new OverrideResolver();\n        TypeHierarchyResolver typeHierarchyResolver = new TypeHierarchyResolver();\n\n        this.topDownAnalyzer.setBodyResolver(bodyResolver);\n        this.topDownAnalyzer.setConfiguration(moduleConfiguration);\n        this.topDownAnalyzer.setContext(topDownAnalysisContext);\n        this.topDownAnalyzer.setControlFlowAnalyzer(controlFlowAnalyzer);\n        this.topDownAnalyzer.setDeclarationResolver(declarationResolver);\n        this.topDownAnalyzer.setDeclarationsChecker(declarationsChecker);\n        this.topDownAnalyzer.setDelegationResolver(delegationResolver);\n        this.topDownAnalyzer.setModuleDescriptor(moduleDescriptor);\n        this.topDownAnalyzer.setNamespaceFactory(namespaceFactoryImpl);\n        this.topDownAnalyzer.setOverloadResolver(overloadResolver);\n        this.topDownAnalyzer.setOverrideResolver(overrideResolver);\n        this.topDownAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n        this.topDownAnalyzer.setTypeHierarchyResolver(typeHierarchyResolver);\n\n        this.topDownAnalysisContext.setTopDownAnalysisParameters(topDownAnalysisParameters);\n\n        this.bodyResolver.setCallResolver(callResolver);\n        this.bodyResolver.setContext(topDownAnalysisContext);\n        this.bodyResolver.setDescriptorResolver(descriptorResolver);\n        this.bodyResolver.setExpressionTypingServices(expressionTypingServices);\n        this.bodyResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n\n        this.controlFlowAnalyzer.setContext(topDownAnalysisContext);\n        this.controlFlowAnalyzer.setFlowDataTraceFactory(jetControlFlowDataTraceFactory);\n        this.controlFlowAnalyzer.setTopDownAnalysisParameters(topDownAnalysisParameters);\n\n        this.declarationsChecker.setContext(topDownAnalysisContext);\n\n        this.descriptorResolver.setAnnotationResolver(annotationResolver);\n        this.descriptorResolver.setExpressionTypingServices(expressionTypingServices);\n        this.descriptorResolver.setTypeResolver(typeResolver);\n\n        declarationResolver.setAnnotationResolver(annotationResolver);\n        declarationResolver.setContext(topDownAnalysisContext);\n        declarationResolver.setDescriptorResolver(descriptorResolver);\n        declarationResolver.setImportsResolver(importsResolver);\n\n        annotationResolver.setCallResolver(callResolver);\n        annotationResolver.setExpressionTypingServices(expressionTypingServices);\n\n        callResolver.setDescriptorResolver(descriptorResolver);\n        callResolver.setExpressionTypingServices(expressionTypingServices);\n        callResolver.setOverloadingConflictResolver(overloadingConflictResolver);\n        callResolver.setTypeResolver(typeResolver);\n\n        expressionTypingServices.setCallResolver(callResolver);\n        expressionTypingServices.setDescriptorResolver(descriptorResolver);\n        expressionTypingServices.setProject(project);\n        expressionTypingServices.setTypeResolver(typeResolver);\n\n        typeResolver.setAnnotationResolver(annotationResolver);\n        typeResolver.setDescriptorResolver(descriptorResolver);\n\n        importsResolver.setConfiguration(moduleConfiguration);\n        importsResolver.setContext(topDownAnalysisContext);\n\n        delegationResolver.setContext(topDownAnalysisContext);\n\n        namespaceFactoryImpl.setConfiguration(moduleConfiguration);\n        namespaceFactoryImpl.setContext(topDownAnalysisContext);\n        namespaceFactoryImpl.setModuleDescriptor(moduleDescriptor);\n\n        overloadResolver.setContext(topDownAnalysisContext);\n\n        overrideResolver.setContext(topDownAnalysisContext);\n        overrideResolver.setTopDownAnalysisParameters(topDownAnalysisParameters);\n\n        typeHierarchyResolver.setContext(topDownAnalysisContext);\n        typeHierarchyResolver.setDescriptorResolver(descriptorResolver);\n        typeHierarchyResolver.setImportsResolver(importsResolver);\n        typeHierarchyResolver.setNamespaceFactory(namespaceFactoryImpl);\n\n    }","commit_id":"4c8cd6ca5c764e2f162899d4813f5b5edfe00bc7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void doAnalyzeFilesWithGivenTrance2(Collection<JetFile> files) {\n        final WritableScope scope = new WritableScopeImpl(\n                JetScope.EMPTY, moduleDescriptor,\n                new TraceBasedRedeclarationHandler(topDownAnalysisParameters.getTrace())).setDebugName(\"Root scope in analyzeNamespace\");\n        scope.changeLockLevel(WritableScope.LockLevel.BOTH);\n\n        // Import the lang package\n        scope.importScope(JetStandardLibrary.getInstance().getLibraryScope());\n\n        NamespaceDescriptorImpl rootNs = typeHierarchyResolver.createNamespaceDescriptorIfNeeded(null, moduleDescriptor, \"<root>\", true);\n\n        // Import a scope that contains all top-level namespaces that come from dependencies\n        // This makes the namespaces visible at all, does not import themselves\n        scope.importScope(rootNs.getMemberScope());\n\n        // dummy builder is used because \"root\" is module descriptor,\n        // namespaces added to module explicitly in\n        doProcess(scope, new NamespaceLikeBuilderDummy(), files);\n    }","id":23742,"modified_method":"private void doAnalyzeFilesWithGivenTrance2(Collection<JetFile> files) {\n        final WritableScope scope = new WritableScopeImpl(\n                JetScope.EMPTY, moduleDescriptor,\n                new TraceBasedRedeclarationHandler(topDownAnalysisParameters.getTrace())).setDebugName(\"Root scope in analyzeNamespace\");\n        scope.changeLockLevel(WritableScope.LockLevel.BOTH);\n\n        // Import the lang package\n        scope.importScope(JetStandardLibrary.getInstance().getLibraryScope());\n\n        NamespaceDescriptorImpl rootNs = namespaceFactory.createNamespaceDescriptorPathIfNeeded(FqName.ROOT);\n\n        // Import a scope that contains all top-level namespaces that come from dependencies\n        // This makes the namespaces visible at all, does not import themselves\n        scope.importScope(rootNs.getMemberScope());\n\n        // dummy builder is used because \"root\" is module descriptor,\n        // namespaces added to module explicitly in\n        doProcess(scope, new NamespaceLikeBuilderDummy(), files);\n    }","commit_id":"4c8cd6ca5c764e2f162899d4813f5b5edfe00bc7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void collectNamespacesAndClassifiers(\n            @NotNull final JetScope outerScope,\n            @NotNull final JetScope outerScopeForStatic,\n            @NotNull final NamespaceLikeBuilder owner,\n            @NotNull Collection<? extends PsiElement> declarations) {\n        for (PsiElement declaration : declarations) {\n            declaration.accept(new JetVisitorVoid() {\n                @Override\n                public void visitJetFile(JetFile file) {\n                    NamespaceDescriptorImpl namespaceDescriptor = createNamespaceDescriptorPathIfNeeded(file, outerScope);\n                    context.getNamespaceDescriptors().put(file, namespaceDescriptor);\n\n                    WriteThroughScope namespaceScope = new WriteThroughScope(outerScope, namespaceDescriptor.getMemberScope(), new TraceBasedRedeclarationHandler(context.getTrace()));\n                    namespaceScope.changeLockLevel(WritableScope.LockLevel.BOTH);\n                    context.getNamespaceScopes().put(file, namespaceScope);\n\n                    collectNamespacesAndClassifiers(namespaceScope, namespaceScope, namespaceDescriptor, file.getDeclarations());\n                }\n\n                @Override\n                public void visitClass(JetClass klass) {\n                    MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), owner.getOwnerForChildren(), outerScope, getClassKind(klass));\n                    context.getTrace().record(FQNAME_TO_CLASS_DESCRIPTOR, JetPsiUtil.getFQName(klass), mutableClassDescriptor);\n\n                    if (klass.hasModifier(JetTokens.ENUM_KEYWORD)) {\n                        MutableClassDescriptor classObjectDescriptor = new MutableClassDescriptor(context.getTrace(), mutableClassDescriptor, outerScope, ClassKind.OBJECT);\n                        classObjectDescriptor.setName(\"class-object-for-\" + klass.getName());\n                        classObjectDescriptor.setModality(Modality.FINAL);\n                        classObjectDescriptor.setVisibility(DescriptorResolver.resolveVisibilityFromModifiers(klass.getModifierList()));\n                        classObjectDescriptor.setTypeParameterDescriptors(new ArrayList<TypeParameterDescriptor>(0));\n                        classObjectDescriptor.createTypeConstructor();\n                        createPrimaryConstructorForObject(null, classObjectDescriptor);\n                        mutableClassDescriptor.setClassObjectDescriptor(classObjectDescriptor);\n                    }\n\n                    visitClassOrObject(klass, (Map) context.getClasses(), mutableClassDescriptor);\n\n                    owner.addClassifierDescriptor(mutableClassDescriptor);\n                }\n\n                @Override\n                public void visitObjectDeclaration(JetObjectDeclaration declaration) {\n                    final MutableClassDescriptor objectDescriptor = createClassDescriptorForObject(declaration, owner, outerScope, ClassKind.OBJECT);\n                    context.getTrace().record(FQNAME_TO_CLASS_DESCRIPTOR, JetPsiUtil.getFQName(declaration), objectDescriptor);\n                }\n\n                @Override\n                public void visitEnumEntry(JetEnumEntry enumEntry) {\n                    MutableClassDescriptorLite classObjectDescriptor = ((MutableClassDescriptor) owner).getClassObjectDescriptor();\n                    assert classObjectDescriptor != null : enumEntry.getParent().getText();\n                    if (enumEntry.getPrimaryConstructorParameterList() == null) {\n                        createClassDescriptorForObject(enumEntry, classObjectDescriptor, outerScopeForStatic, ClassKind.ENUM_ENTRY);\n                        return;\n                    }\n                    MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), classObjectDescriptor, outerScope, ClassKind.ENUM_ENTRY);\n                    visitClassOrObject(\n                            enumEntry,\n                            (Map) context.getClasses(),\n                            mutableClassDescriptor\n                    );\n                    classObjectDescriptor.addObjectDescriptor(mutableClassDescriptor);\n                }\n\n                private MutableClassDescriptor createClassDescriptorForObject(@NotNull JetClassOrObject declaration, @NotNull NamespaceLikeBuilder owner, JetScope scope, ClassKind classKind) {\n                    MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), owner.getOwnerForChildren(), scope, classKind) {\n                        @Override\n                        public ClassObjectStatus setClassObjectDescriptor(@NotNull MutableClassDescriptorLite classObjectDescriptor) {\n                            return ClassObjectStatus.NOT_ALLOWED;\n                        }\n                    };\n                    Map<JetClassOrObject, MutableClassDescriptor> map = classKind == ClassKind.OBJECT ? (Map) context.getObjects() : (Map) context.getClasses();\n                    visitClassOrObject(declaration, map, mutableClassDescriptor);\n                    createPrimaryConstructorForObject((JetDeclaration) declaration, mutableClassDescriptor);\n                    owner.addObjectDescriptor(mutableClassDescriptor);\n                    context.getTrace().record(BindingContext.CLASS, declaration, mutableClassDescriptor);\n                    return mutableClassDescriptor;\n                }\n\n                private void createPrimaryConstructorForObject(@Nullable JetDeclaration object, MutableClassDescriptor mutableClassDescriptor) {\n                    ConstructorDescriptorImpl constructorDescriptor = new ConstructorDescriptorImpl(mutableClassDescriptor, Collections.<AnnotationDescriptor>emptyList(), true);\n                    constructorDescriptor.initialize(Collections.<TypeParameterDescriptor>emptyList(), Collections.<ValueParameterDescriptor>emptyList(),\n                            Visibility.INTERNAL);//TODO check set mutableClassDescriptor.getVisibility()\n                    // TODO : make the constructor private?\n                    mutableClassDescriptor.setPrimaryConstructor(constructorDescriptor, context.getTrace());\n                    if (object != null) {\n                        context.getTrace().record(CONSTRUCTOR, object, constructorDescriptor);\n                    }\n                }\n\n                private void visitClassOrObject(@NotNull JetClassOrObject declaration, Map<JetClassOrObject, MutableClassDescriptor> map, MutableClassDescriptor mutableClassDescriptor) {\n                    mutableClassDescriptor.setName(JetPsiUtil.safeName(declaration.getName()));\n\n                    map.put(declaration, mutableClassDescriptor);\n\n                    JetScope classScope = mutableClassDescriptor.getScopeForMemberResolution();\n                    JetScope scopeForStatic = declaration instanceof JetObjectDeclaration ? classScope : outerScopeForStatic;\n                    collectNamespacesAndClassifiers(classScope, scopeForStatic, mutableClassDescriptor, declaration.getDeclarations());\n                }\n\n                @Override\n                public void visitTypedef(JetTypedef typedef) {\n                    context.getTrace().report(UNSUPPORTED.on(typedef, \"TypeHierarchyResolver\"));\n                }\n\n                @Override\n                public void visitClassObject(JetClassObject classObject) {\n                    JetObjectDeclaration objectDeclaration = classObject.getObjectDeclaration();\n                    if (objectDeclaration != null) {\n                        NamespaceLikeBuilder.ClassObjectStatus status = owner.setClassObjectDescriptor(createClassDescriptorForObject(objectDeclaration, owner, outerScopeForStatic, ClassKind.OBJECT));\n                        switch (status) {\n                            case DUPLICATE:\n                                context.getTrace().report(MANY_CLASS_OBJECTS.on(classObject));\n                                break;\n                            case NOT_ALLOWED:\n                                context.getTrace().report(CLASS_OBJECT_NOT_ALLOWED.on(classObject));\n                                break;\n                        }\n                    }\n                }\n            });\n        }\n    }","id":23743,"modified_method":"private void collectNamespacesAndClassifiers(\n            @NotNull final JetScope outerScope,\n            @NotNull final JetScope outerScopeForStatic,\n            @NotNull final NamespaceLikeBuilder owner,\n            @NotNull Collection<? extends PsiElement> declarations) {\n        for (PsiElement declaration : declarations) {\n            declaration.accept(new JetVisitorVoid() {\n                @Override\n                public void visitJetFile(JetFile file) {\n                    NamespaceDescriptorImpl namespaceDescriptor = namespaceFactory.createNamespaceDescriptorPathIfNeeded(file, outerScope);\n                    context.getNamespaceDescriptors().put(file, namespaceDescriptor);\n\n                    WriteThroughScope namespaceScope = new WriteThroughScope(outerScope, namespaceDescriptor.getMemberScope(), new TraceBasedRedeclarationHandler(context.getTrace()));\n                    namespaceScope.changeLockLevel(WritableScope.LockLevel.BOTH);\n                    context.getNamespaceScopes().put(file, namespaceScope);\n\n                    collectNamespacesAndClassifiers(namespaceScope, namespaceScope, namespaceDescriptor, file.getDeclarations());\n                }\n\n                @Override\n                public void visitClass(JetClass klass) {\n                    MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), owner.getOwnerForChildren(), outerScope, getClassKind(klass));\n                    context.getTrace().record(FQNAME_TO_CLASS_DESCRIPTOR, JetPsiUtil.getFQName(klass), mutableClassDescriptor);\n\n                    if (klass.hasModifier(JetTokens.ENUM_KEYWORD)) {\n                        MutableClassDescriptor classObjectDescriptor = new MutableClassDescriptor(context.getTrace(), mutableClassDescriptor, outerScope, ClassKind.OBJECT);\n                        classObjectDescriptor.setName(\"class-object-for-\" + klass.getName());\n                        classObjectDescriptor.setModality(Modality.FINAL);\n                        classObjectDescriptor.setVisibility(DescriptorResolver.resolveVisibilityFromModifiers(klass.getModifierList()));\n                        classObjectDescriptor.setTypeParameterDescriptors(new ArrayList<TypeParameterDescriptor>(0));\n                        classObjectDescriptor.createTypeConstructor();\n                        createPrimaryConstructorForObject(null, classObjectDescriptor);\n                        mutableClassDescriptor.setClassObjectDescriptor(classObjectDescriptor);\n                    }\n\n                    visitClassOrObject(klass, (Map) context.getClasses(), mutableClassDescriptor);\n\n                    owner.addClassifierDescriptor(mutableClassDescriptor);\n                }\n\n                @Override\n                public void visitObjectDeclaration(JetObjectDeclaration declaration) {\n                    final MutableClassDescriptor objectDescriptor = createClassDescriptorForObject(declaration, owner, outerScope, ClassKind.OBJECT);\n                    context.getTrace().record(FQNAME_TO_CLASS_DESCRIPTOR, JetPsiUtil.getFQName(declaration), objectDescriptor);\n                }\n\n                @Override\n                public void visitEnumEntry(JetEnumEntry enumEntry) {\n                    MutableClassDescriptorLite classObjectDescriptor = ((MutableClassDescriptor) owner).getClassObjectDescriptor();\n                    assert classObjectDescriptor != null : enumEntry.getParent().getText();\n                    if (enumEntry.getPrimaryConstructorParameterList() == null) {\n                        createClassDescriptorForObject(enumEntry, classObjectDescriptor, outerScopeForStatic, ClassKind.ENUM_ENTRY);\n                        return;\n                    }\n                    MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), classObjectDescriptor, outerScope, ClassKind.ENUM_ENTRY);\n                    visitClassOrObject(\n                            enumEntry,\n                            (Map) context.getClasses(),\n                            mutableClassDescriptor\n                    );\n                    classObjectDescriptor.addObjectDescriptor(mutableClassDescriptor);\n                }\n\n                private MutableClassDescriptor createClassDescriptorForObject(@NotNull JetClassOrObject declaration, @NotNull NamespaceLikeBuilder owner, JetScope scope, ClassKind classKind) {\n                    MutableClassDescriptor mutableClassDescriptor = new MutableClassDescriptor(context.getTrace(), owner.getOwnerForChildren(), scope, classKind) {\n                        @Override\n                        public ClassObjectStatus setClassObjectDescriptor(@NotNull MutableClassDescriptorLite classObjectDescriptor) {\n                            return ClassObjectStatus.NOT_ALLOWED;\n                        }\n                    };\n                    Map<JetClassOrObject, MutableClassDescriptor> map = classKind == ClassKind.OBJECT ? (Map) context.getObjects() : (Map) context.getClasses();\n                    visitClassOrObject(declaration, map, mutableClassDescriptor);\n                    createPrimaryConstructorForObject((JetDeclaration) declaration, mutableClassDescriptor);\n                    owner.addObjectDescriptor(mutableClassDescriptor);\n                    context.getTrace().record(BindingContext.CLASS, declaration, mutableClassDescriptor);\n                    return mutableClassDescriptor;\n                }\n\n                private void createPrimaryConstructorForObject(@Nullable JetDeclaration object, MutableClassDescriptor mutableClassDescriptor) {\n                    ConstructorDescriptorImpl constructorDescriptor = new ConstructorDescriptorImpl(mutableClassDescriptor, Collections.<AnnotationDescriptor>emptyList(), true);\n                    constructorDescriptor.initialize(Collections.<TypeParameterDescriptor>emptyList(), Collections.<ValueParameterDescriptor>emptyList(),\n                            Visibility.INTERNAL);//TODO check set mutableClassDescriptor.getVisibility()\n                    // TODO : make the constructor private?\n                    mutableClassDescriptor.setPrimaryConstructor(constructorDescriptor, context.getTrace());\n                    if (object != null) {\n                        context.getTrace().record(CONSTRUCTOR, object, constructorDescriptor);\n                    }\n                }\n\n                private void visitClassOrObject(@NotNull JetClassOrObject declaration, Map<JetClassOrObject, MutableClassDescriptor> map, MutableClassDescriptor mutableClassDescriptor) {\n                    mutableClassDescriptor.setName(JetPsiUtil.safeName(declaration.getName()));\n\n                    map.put(declaration, mutableClassDescriptor);\n\n                    JetScope classScope = mutableClassDescriptor.getScopeForMemberResolution();\n                    JetScope scopeForStatic = declaration instanceof JetObjectDeclaration ? classScope : outerScopeForStatic;\n                    collectNamespacesAndClassifiers(classScope, scopeForStatic, mutableClassDescriptor, declaration.getDeclarations());\n                }\n\n                @Override\n                public void visitTypedef(JetTypedef typedef) {\n                    context.getTrace().report(UNSUPPORTED.on(typedef, \"TypeHierarchyResolver\"));\n                }\n\n                @Override\n                public void visitClassObject(JetClassObject classObject) {\n                    JetObjectDeclaration objectDeclaration = classObject.getObjectDeclaration();\n                    if (objectDeclaration != null) {\n                        NamespaceLikeBuilder.ClassObjectStatus status = owner.setClassObjectDescriptor(createClassDescriptorForObject(objectDeclaration, owner, outerScopeForStatic, ClassKind.OBJECT));\n                        switch (status) {\n                            case DUPLICATE:\n                                context.getTrace().report(MANY_CLASS_OBJECTS.on(classObject));\n                                break;\n                            case NOT_ALLOWED:\n                                context.getTrace().report(CLASS_OBJECT_NOT_ALLOWED.on(classObject));\n                                break;\n                        }\n                    }\n                }\n            });\n        }\n    }","commit_id":"4c8cd6ca5c764e2f162899d4813f5b5edfe00bc7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * @see org.opencms.xml.content.I_CmsXmlContentHandler#getWidget(org.opencms.xml.types.I_CmsXmlSchemaType)\n     */\n    public I_CmsWidget getWidget(I_CmsXmlSchemaType value) {\n\n        // try the specific widget settings first\n        I_CmsWidget result = m_elementWidgets.get(value.getName());\n        if (result == null) {\n            // use default widget mappings\n            result = OpenCms.getXmlContentTypeManager().getWidgetDefault(value.getTypeName());\n        } else {\n            result = result.newInstance();\n        }\n        // set the configuration value for this widget\n        String configuration = getConfiguration(value);\n        if (configuration == null) {\n            // no individual configuration defined, try to get global default configuration\n            configuration = OpenCms.getXmlContentTypeManager().getWidgetDefaultConfiguration(result);\n        }\n        result.setConfiguration(configuration);\n\n        return result;\n    }","id":23744,"modified_method":"/**\n     * @see org.opencms.xml.content.I_CmsXmlContentHandler#getWidget(org.opencms.xml.types.I_CmsXmlSchemaType)\n     */\n    public I_CmsWidget getWidget(I_CmsXmlSchemaType value) {\n\n        // try the specific widget settings first\n        I_CmsWidget result = m_elementWidgets.get(value.getName());\n        if (result == null) {\n            // use default widget mappings\n            result = OpenCms.getXmlContentTypeManager().getWidgetDefault(value.getTypeName());\n        } else {\n            result = result.newInstance();\n        }\n        if (result != null) {\n            // set the configuration value for this widget\n            String configuration = getConfiguration(value);\n            if (configuration == null) {\n                // no individual configuration defined, try to get global default configuration\n                configuration = OpenCms.getXmlContentTypeManager().getWidgetDefaultConfiguration(result);\n            }\n            result.setConfiguration(configuration);\n        }\n        return result;\n    }","commit_id":"cce8e6cd5a9e681543104b598de72fc01ada643b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds or remove the specified config properties to the specified profile.\n     * @param configProperties      The array of config properties.\n     * @param profile               The target profile.\n     */\n    private void handleConfigProperties(String[] configProperties, Profile profile) {\n        for (String configProperty : configProperties) {\n            Map<String, String> configMap = extractConfigs(configProperty);\n            for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                String key = configEntries.getKey();\n                String value = configEntries.getValue();\n                if (append) {\n                    System.out.println(\"Appending value:\" + value + \" key:\" + key + \" from config properties and profile:\" + profile + \" version:\" + versionName);\n                } else if (delete) {\n                    System.out.println(\"Deleting key:\" + key + \" from config properties and profile:\" + profile + \" version:\" + versionName);\n                } else if (set) {\n                    System.out.println(\"Setting value:\" + value + \" key:\" + key + \" from config properties and profile:\" + profile + \" version:\" + versionName);\n                } else {\n                    System.out.println(\"Removing value:\" + value + \" key:\" + key + \" from config properties and profile:\" + profile + \" version:\" + versionName);\n                }\n                updatedDelimitedList(profile.getConfiguration(AGENT_PID), CONFIG_PREFIX + key, value, delimiter, set, delete, append, remove);\n            }\n        }\n    }","id":23745,"modified_method":"/**\n     * Adds or remove the specified config properties to the specified profile.\n     * @param configProperties      The array of config properties.\n     * @param profile               The target profile.\n     */\n    private void handleConfigProperties(String[] configProperties, Profile profile) {\n        Map<String, String> conf = profile.getConfiguration(AGENT_PID);\n        for (String configProperty : configProperties) {\n            Map<String, String> configMap = extractConfigs(configProperty);\n            for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                String key = configEntries.getKey();\n                String value = configEntries.getValue();\n                if (append) {\n                    System.out.println(\"Appending value:\" + value + \" key:\" + key + \" from config properties and profile:\" + profile + \" version:\" + versionName);\n                } else if (delete) {\n                    System.out.println(\"Deleting key:\" + key + \" from config properties and profile:\" + profile + \" version:\" + versionName);\n                } else if (set) {\n                    System.out.println(\"Setting value:\" + value + \" key:\" + key + \" from config properties and profile:\" + profile + \" version:\" + versionName);\n                }\n                updatedDelimitedList(conf, CONFIG_PREFIX + key, value, delimiter, set, delete, append, remove);\n            }\n        }\n        profile.setConfiguration(AGENT_PID, conf);\n    }","commit_id":"90fc9a4224d09b8c7ad2cfb4c1c09aa033c00fca","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Adds or remove the specified features to the specified profile.\n     * @param features  The array of feature names.\n     * @param profile   The target profile.\n     */\n    private void handleFeatures(String[] features, Profile profile) {\n        for (String feature : features) {\n            if (delete) {\n                System.out.println(\"Deleting feature:\" + feature + \" from profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n            } else {\n                System.out.println(\"Adding feature:\" + feature + \" to profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n            }\n            updateConfig(profile.getConfiguration(AGENT_PID), FEATURE_PREFIX + feature.replace('/', '_'), feature, set, delete);\n        }\n    }","id":23746,"modified_method":"/**\n     * Adds or remove the specified features to the specified profile.\n     * @param features  The array of feature names.\n     * @param profile   The target profile.\n     */\n    private void handleFeatures(String[] features, Profile profile) {\n        Map<String, String> conf = profile.getConfiguration(AGENT_PID);\n        for (String feature : features) {\n            if (delete) {\n                System.out.println(\"Deleting feature:\" + feature + \" from profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n            } else {\n                System.out.println(\"Adding feature:\" + feature + \" to profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n            }\n            updateConfig(conf, FEATURE_PREFIX + feature.replace('/', '_'), feature, set, delete);\n            profile.setConfiguration(AGENT_PID, conf);\n        }\n    }","commit_id":"90fc9a4224d09b8c7ad2cfb4c1c09aa033c00fca","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Adds or remove the specified fabs to the specified profile.\n     * @param fabs      The array of fabs.\n     * @param profile   The target profile.\n     */\n    private void handleFabs(String[] fabs, Profile profile) {\n        for (String fab : fabs) {\n            if (set) {\n                System.out.println(\"Adding FAB:\" + fab + \" to profile:\" + profile + \" version:\" + versionName);\n            } else if (delete) {\n                System.out.println(\"Deleting FAB:\" + fab + \" from profile:\" + profile + \" version:\" + versionName);\n            }\n            updateConfig(profile.getConfiguration(AGENT_PID), FAB_PREFIX + fab.replace('/', '_'), fab, set, delete);\n        }\n    }","id":23747,"modified_method":"/**\n     * Adds or remove the specified fabs to the specified profile.\n     * @param fabs      The array of fabs.\n     * @param profile   The target profile.\n     */\n    private void handleFabs(String[] fabs, Profile profile) {\n        Map<String, String> conf = profile.getConfiguration(AGENT_PID);\n        for (String fab : fabs) {\n            if (set) {\n                System.out.println(\"Adding FAB:\" + fab + \" to profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n            } else if (delete) {\n                System.out.println(\"Deleting FAB:\" + fab + \" from profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n            }\n            updateConfig(conf, FAB_PREFIX + fab.replace('/', '_'), fab, set, delete);\n        }\n        profile.setConfiguration(AGENT_PID, conf);\n    }","commit_id":"90fc9a4224d09b8c7ad2cfb4c1c09aa033c00fca","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Adds or remove the specified system properties to the specified profile.\n     * @param systemProperties      The array of system properties.\n     * @param profile               The target profile.\n     */\n    private void handleSystemProperties(String[] systemProperties, Profile profile) {\n        for (String systemProperty : systemProperties) {\n            Map<String, String> configMap = extractConfigs(systemProperty);\n            for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                String key = configEntries.getKey();\n                String value = configEntries.getValue();\n                if (append) {\n                    System.out.println(\"Appending value:\" + value + \" key:\" + key + \" from system properties and profile:\" + profile + \" version:\" + versionName);\n                } else if (delete) {\n                    System.out.println(\"Deleting key:\" + key + \" from system properties and profile:\" + profile + \" version:\" + versionName);\n                } else if (set) {\n                    System.out.println(\"Setting value:\" + value + \" key:\" + key + \" from system properties and profile:\" + profile + \" version:\" + versionName);\n                } else {\n                    System.out.println(\"Removing value:\" + value + \" key:\" + key + \" from system properties and profile:\" + profile + \" version:\" + versionName);\n                }\n                updatedDelimitedList(profile.getConfiguration(AGENT_PID), SYSTEM_PREFIX + key, value, delimiter, set, delete, append, remove);\n            }\n        }\n    }","id":23748,"modified_method":"/**\n     * Adds or remove the specified system properties to the specified profile.\n     * @param systemProperties      The array of system properties.\n     * @param profile               The target profile.\n     */\n    private void handleSystemProperties(String[] systemProperties, Profile profile) {\n        Map<String, String> conf = profile.getConfiguration(AGENT_PID);\n        for (String systemProperty : systemProperties) {\n            Map<String, String> configMap = extractConfigs(systemProperty);\n            for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                String key = configEntries.getKey();\n                String value = configEntries.getValue();\n                if (append) {\n                    System.out.println(\"Appending value:\" + value + \" key:\" + key + \" from system properties and profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n                } else if (delete) {\n                    System.out.println(\"Deleting key:\" + key + \" from system properties and profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n                } else if (set) {\n                    System.out.println(\"Setting value:\" + value + \" key:\" + key + \" from system properties and profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n                } else {\n                    System.out.println(\"Removing value:\" + value + \" key:\" + key + \" from system properties and profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n                }\n                updatedDelimitedList(conf, SYSTEM_PREFIX + key, value, delimiter, set, delete, append, remove);\n            }\n        }\n        profile.setConfiguration(AGENT_PID, conf);\n    }","commit_id":"90fc9a4224d09b8c7ad2cfb4c1c09aa033c00fca","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Adds or remove the specified system properties to the specified profile.\n     * @param pidProperties         The array of system properties.\n     * @param profile               The target profile.\n     */\n    private void handlePid(String[] pidProperties, Profile profile) {\n        for (String pidProperty : pidProperties) {\n            String currentPid = null;\n\n\n            String keyValuePair = \"\";\n            if (pidProperty.contains(PID_KEY_SEPARATOR)) {\n                currentPid = pidProperty.substring(0, pidProperty.indexOf(PID_KEY_SEPARATOR));\n                keyValuePair = pidProperty.substring(pidProperty.indexOf(PID_KEY_SEPARATOR) + 1);\n            } else {\n                currentPid = pidProperty;\n            }\n\n            Map<String, String> existingConfig = profile.getConfiguration(currentPid);\n\n            //We only support import when a single pid is specified\n            if (pidProperties.length == 1 && importPid) {\n                System.out.println(\"Importing pid:\" + currentPid + \" to profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n                importPidFromLocalConfigAdmin(currentPid, existingConfig);\n            }\n\n\n            Map<String, String> configMap = extractConfigs(keyValuePair);\n            if (configMap.isEmpty() && delete) {\n                System.out.println(\"Deleting pid:\" + currentPid + \" from profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n                Map<String, Map<String,String>> profileConfigs = profile.getConfigurations();\n                profileConfigs.remove(currentPid);\n                profile.setConfigurations(profileConfigs);\n            } else {\n                for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                    String key = configEntries.getKey();\n                    String value = configEntries.getValue();\n                    if (value == null && delete) {\n                        System.out.println(\"Deleting key:\" + key + \" from pid:\" + currentPid + \" and profile:\" + profile.getId() + \" version:\" +  profile.getVersion());\n                        existingConfig.remove(key);\n                    } else {\n                        if (append) {\n                            System.out.println(\"Appending value:\" + value + \" key:\" + key + \" from pid:\" + currentPid + \" and profile:\" + profile.getId() + \" version:\" +  profile.getVersion());\n                        } else if (remove) {\n                            System.out.println(\"Removing value:\" + value + \" key:\" + key + \" from pid:\" + currentPid + \" and profile:\" + profile.getId() + \" version:\" +  profile.getVersion());\n                        } else {\n                            System.out.println(\"Setting value:\" + value + \" key:\" + key + \" from pid:\" + currentPid + \" and profile:\" + profile.getId() + \" version:\" +  profile.getVersion());\n                        }\n                        updatedDelimitedList(existingConfig, key, value, delimiter, set, delete, append, remove);\n                    }\n                }\n                profile.setConfiguration(currentPid, existingConfig);\n            }\n        }\n    }","id":23749,"modified_method":"/**\n     * Adds or remove the specified system properties to the specified profile.\n     * @param pidProperties         The array of system properties.\n     * @param profile               The target profile.\n     * @return                      True if the edit can take place in line.\n     */\n    private boolean handlePid(String[] pidProperties, Profile profile) {\n        boolean editInline = true;\n        for (String pidProperty : pidProperties) {\n            String currentPid = null;\n\n\n            String keyValuePair = \"\";\n            if (pidProperty.contains(PID_KEY_SEPARATOR)) {\n                currentPid = pidProperty.substring(0, pidProperty.indexOf(PID_KEY_SEPARATOR));\n                keyValuePair = pidProperty.substring(pidProperty.indexOf(PID_KEY_SEPARATOR) + 1);\n            } else {\n                currentPid = pidProperty;\n            }\n\n            Map<String, String> conf = profile.getConfiguration(currentPid);\n            //We only support import when a single pid is specified\n            if (pidProperties.length == 1 && importPid) {\n                System.out.println(\"Importing pid:\" + currentPid + \" to profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n                importPidFromLocalConfigAdmin(currentPid, conf);\n                profile.setConfiguration(currentPid, conf);\n                return true;\n            }\n\n\n            Map<String, String> configMap = extractConfigs(keyValuePair);\n            if (configMap.isEmpty() && set) {\n                editInline = false;\n            } else if (configMap.isEmpty() && delete) {\n                editInline = true;\n                System.out.println(\"Deleting pid:\" + currentPid + \" from profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n                Map<String, Map<String,String>> profileConfigs = profile.getConfigurations();\n                profileConfigs.remove(currentPid);\n                profile.setConfigurations(profileConfigs);\n            } else {\n                for (Map.Entry<String, String> configEntries : configMap.entrySet()) {\n                    String key = configEntries.getKey();\n                    String value = configEntries.getValue();\n                    if (value == null && delete) {\n                        System.out.println(\"Deleting key:\" + key + \" from pid:\" + currentPid + \" and profile:\" + profile.getId() + \" version:\" +  profile.getVersion());\n                        conf.remove(key);\n                    } else {\n                        if (append) {\n                            System.out.println(\"Appending value:\" + value + \" key:\" + key + \" to pid:\" + currentPid + \" and profile:\" + profile.getId() + \" version:\" +  profile.getVersion());\n                        } else if (remove) {\n                            System.out.println(\"Removing value:\" + value + \" key:\" + key + \" from pid:\" + currentPid + \" and profile:\" + profile.getId() + \" version:\" +  profile.getVersion());\n                        } else if(set) {\n                            System.out.println(\"Setting value:\" + value + \" key:\" + key + \" on pid:\" + currentPid + \" and profile:\" + profile.getId() + \" version:\" +  profile.getVersion());\n                        }\n                        updatedDelimitedList(conf, key, value, delimiter, set, delete, append, remove);\n                    }\n                }\n                editInline = true;\n                profile.setConfiguration(currentPid, conf);\n            }\n        }\n        return editInline;\n    }","commit_id":"90fc9a4224d09b8c7ad2cfb4c1c09aa033c00fca","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Adds or remove the specified bundles to the specified profile.\n     * @param bundles   The array of bundles.\n     * @param profile   The target profile.\n     */\n    private void handleBundles(String[] bundles, Profile profile) {\n        for (String bundle : bundles) {\n            if (set) {\n                System.out.println(\"Adding bundle:\" + bundle + \" to profile:\" + profile + \" version:\" + versionName);\n            } else if (delete) {\n                System.out.println(\"Deleting bundle:\" + bundle + \" from profile:\" + profile + \" version:\" + versionName);\n            }\n            updateConfig(profile.getConfiguration(AGENT_PID), BUNDLE_PREFIX + bundle.replace('/', '_'), bundle, set, delete);\n        }\n    }","id":23750,"modified_method":"/**\n     * Adds or remove the specified bundles to the specified profile.\n     * @param bundles   The array of bundles.\n     * @param profile   The target profile.\n     */\n    private void handleBundles(String[] bundles, Profile profile) {\n        Map<String, String> conf = profile.getConfiguration(AGENT_PID);\n        for (String bundle : bundles) {\n            if (set) {\n                System.out.println(\"Adding bundle:\" + bundle + \" to profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n            } else if (delete) {\n                System.out.println(\"Deleting bundle:\" + bundle + \" from profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n            }\n            updateConfig(conf, BUNDLE_PREFIX + bundle.replace('/', '_'), bundle, set, delete);\n        }\n        profile.setConfiguration(AGENT_PID, conf);\n    }","commit_id":"90fc9a4224d09b8c7ad2cfb4c1c09aa033c00fca","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Adds or remove the specified feature repositories to the specified profile.\n     * @param features  The array of feature repositories.\n     * @param profile   The target profile.\n     */\n    private void handleFeatureRepositories(String[] features, Profile profile) {\n        for (String repositoryURI : repositories) {\n            if (set) {\n                System.out.println(\"Adding feature repository:\" + repositoryURI + \" to profile:\" + profile + \" version:\" + versionName);\n            } else if (delete) {\n                System.out.println(\"Deleting feature repository:\" + repositoryURI + \" from profile:\" + profile + \" version:\" + versionName);\n            }\n            updateConfig(profile.getConfiguration(AGENT_PID), REPOSITORY_PREFIX + repositoryURI.replace('/', '_'), repositoryURI, set, delete);\n        }\n    }","id":23751,"modified_method":"/**\n     * Adds or remove the specified feature repositories to the specified profile.\n     * @param repositories  The array of feature repositories.\n     * @param profile   The target profile.\n     */\n    private void handleFeatureRepositories(String[] repositories, Profile profile) {\n        Map<String, String> conf = profile.getConfiguration(AGENT_PID);\n        for (String repositoryURI : repositories) {\n            if (set) {\n                System.out.println(\"Adding feature repository:\" + repositoryURI + \" to profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n            } else if (delete) {\n                System.out.println(\"Deleting feature repository:\" + repositoryURI + \" from profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n            }\n            updateConfig(conf, REPOSITORY_PREFIX + repositoryURI.replace('/', '_'), repositoryURI, set, delete);\n        }\n        profile.setConfiguration(AGENT_PID, conf);\n    }","commit_id":"90fc9a4224d09b8c7ad2cfb4c1c09aa033c00fca","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Adds or remove the specified overrides to the specified profile.\n     * @param overrides     The array of overrides.\n     * @param profile       The target profile.\n     */\n    private void handleOverrides(String[] overrides, Profile profile) {\n        for (String overrie : overrides) {\n            if (set) {\n                System.out.println(\"Adding override:\" + overrie + \" to profile:\" + profile + \" version:\" + versionName);\n            } else if (delete) {\n                System.out.println(\"Deleting override:\" + overrie + \" from profile:\" + profile + \" version:\" + versionName);\n            }\n            updateConfig(profile.getConfiguration(AGENT_PID), OVERRIDE_PREFIX + overrie.replace('/', '_'), overrie, set, delete);\n        }\n    }","id":23752,"modified_method":"/**\n     * Adds or remove the specified overrides to the specified profile.\n     * @param overrides     The array of overrides.\n     * @param profile       The target profile.\n     */\n    private void handleOverrides(String[] overrides, Profile profile) {\n        Map<String, String> conf = profile.getConfiguration(AGENT_PID);\n        for (String overrie : overrides) {\n            if (set) {\n                System.out.println(\"Adding override:\" + overrie + \" to profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n            } else if (delete) {\n                System.out.println(\"Deleting override:\" + overrie + \" from profile:\" + profile.getId() + \" version:\" + profile.getVersion());\n            }\n            updateConfig(conf, OVERRIDE_PREFIX + overrie.replace('/', '_'), overrie, set, delete);\n        }\n        profile.setConfiguration(AGENT_PID, conf);\n    }","commit_id":"90fc9a4224d09b8c7ad2cfb4c1c09aa033c00fca","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private void editProfile(Profile profile) throws Exception {\n        String pid = AGENT_PID;\n        boolean editInLine = false;\n\n        Map<String, Map<String, String>> config = profile.getConfigurations();\n        Map<String, String> pidConfig = config.get(pid);\n\n        if (pidConfig == null) {\n            pidConfig = new HashMap<String, String>();\n        }\n\n        if (delete || remove) {\n            editInLine = true;\n        }\n\n        if (features != null && features.length > 0) {\n            editInLine = true;\n            handleFeatures(features, profile);\n        }\n        if (repositories != null && repositories.length > 0) {\n            editInLine = true;\n            handleFeatureRepositories(repositories, profile);\n        }\n        if (bundles != null && bundles.length > 0) {\n            editInLine = true;\n            handleBundles(bundles, profile);\n        }\n        if (fabs != null && fabs.length > 0) {\n            editInLine = true;\n            handleFabs(fabs, profile);\n        }\n        if (overrides != null && overrides.length > 0) {\n            editInLine = true;\n            handleOverrides(overrides, profile);\n        }\n\n        if (pidProperties != null && pidProperties.length > 0) {\n            handlePid(pidProperties, profile);\n        }\n\n        if (systemProperties != null && systemProperties.length > 0) {\n            editInLine = true;\n            handleSystemProperties(systemProperties, profile);\n        }\n\n        if (configProperties != null && configProperties.length > 0) {\n            editInLine = true;\n            handleConfigProperties(configProperties, profile);\n        }\n\n        if (editInLine) {\n            config.put(pid, pidConfig);\n            profile.setConfigurations(config);\n        } else {\n            resource = resource != null ? resource : \"org.fusesource.fabric.agent.properties\";\n            //If a single pid has been selected, but not a key value has been specified or import has been selected,\n            //then open the resource in the editor.\n            if (pidProperties != null && pidProperties.length == 1) {\n                resource = pidProperties[0] + \".properties\";\n            }\n            openInEditor(profile, resource);\n        }\n    }","id":23753,"modified_method":"private void editProfile(Profile profile) throws Exception {\n        String pid = AGENT_PID;\n        boolean editInLine = false;\n\n        if (delete || remove) {\n            editInLine = true;\n        }\n\n        if (features != null && features.length > 0) {\n            editInLine = true;\n            handleFeatures(features, profile);\n        }\n        if (repositories != null && repositories.length > 0) {\n            editInLine = true;\n            handleFeatureRepositories(repositories, profile);\n        }\n        if (bundles != null && bundles.length > 0) {\n            editInLine = true;\n            handleBundles(bundles, profile);\n        }\n        if (fabs != null && fabs.length > 0) {\n            editInLine = true;\n            handleFabs(fabs, profile);\n        }\n        if (overrides != null && overrides.length > 0) {\n            editInLine = true;\n            handleOverrides(overrides, profile);\n        }\n\n        if (pidProperties != null && pidProperties.length > 0) {\n            editInLine = handlePid(pidProperties, profile);\n        }\n\n        if (systemProperties != null && systemProperties.length > 0) {\n            editInLine = true;\n            handleSystemProperties(systemProperties, profile);\n        }\n\n        if (configProperties != null && configProperties.length > 0) {\n            editInLine = true;\n            handleConfigProperties(configProperties, profile);\n        }\n\n        if (!editInLine) {\n            resource = resource != null ? resource : \"org.fusesource.fabric.agent.properties\";\n            //If a single pid has been selected, but not a key value has been specified or import has been selected,\n            //then open the resource in the editor.\n            if (pidProperties != null && pidProperties.length == 1) {\n                resource = pidProperties[0] + \".properties\";\n            }\n            openInEditor(profile, resource);\n        }\n    }","commit_id":"90fc9a4224d09b8c7ad2cfb4c1c09aa033c00fca","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@BeforeMethod\n    public void setUp() throws Exception {\n        MockitoAnnotations.initMocks(this);\n        ResourceUtils resourceUtils = new ResourceUtils();\n        resourceUtils.create(); // postConstruct\n        TransUnitTransformer transUnitTransformer =\n                SeamAutowire.instance().reset().use(\"resourceUtils\", resourceUtils)\n                        .autowire(TransUnitTransformer.class);\n\n        SeamAutowire seam =\n                SeamAutowire\n                        .instance()\n                        .use(\"localeServiceImpl\", localeService)\n                        .use(\"documentDAO\", new DocumentDAO(getSession()))\n                        .use(\"projectIterationDAO\",\n                                new ProjectIterationDAO(getSession()))\n                        .use(\"entityManager\",\n                                new FullTextEntityManagerImpl(getEm()))\n                        .use(\"session\", new FullTextSessionImpl(getSession()))\n                        .use(\"identity\", identity)\n                        .use(\"textFlowDAO\", new TextFlowDAO(getSession()))\n                        .use(\"transUnitTransformer\", transUnitTransformer)\n                        .use(\"webtrans.gwt.GetTransUnitsNavigationHandler\",\n                                getTransUnitsNavigationService)\n                        .useImpl(TranslationStateCacheImpl.class)\n                        .useImpl(TextFlowSearchServiceImpl.class)\n                        .useImpl(ValidationServiceImpl.class).allowCycles();\n\n        // @formatter:off\n      handler = seam.autowire(GetTransUnitListHandler.class);\n      // @formatter:on\n\n        jaHLocale = getEm().find(HLocale.class, 3L);\n    }","id":23754,"modified_method":"@BeforeMethod\n    public void setUp() throws Exception {\n        MockitoAnnotations.initMocks(this);\n        ResourceUtils resourceUtils = new ResourceUtils();\n        resourceUtils.create(); // postConstruct\n        TransUnitTransformer transUnitTransformer =\n            seam.reset().use(\"resourceUtils\", resourceUtils)\n                .autowire(TransUnitTransformer.class);\n\n            seam.use(\"localeServiceImpl\", localeService)\n                        .use(\"documentDAO\", new DocumentDAO(getSession()))\n                        .use(\"projectIterationDAO\",\n                                new ProjectIterationDAO(getSession()))\n                        .use(\"entityManager\",\n                                new FullTextEntityManagerImpl(getEm()))\n                        .use(\"session\", new FullTextSessionImpl(getSession()))\n                        .use(\"identity\", identity)\n                        .use(\"textFlowDAO\", new TextFlowDAO(getSession()))\n                        .use(\"transUnitTransformer\", transUnitTransformer)\n                        .use(\"webtrans.gwt.GetTransUnitsNavigationHandler\",\n                                getTransUnitsNavigationService)\n                        .useImpl(TranslationStateCacheImpl.class)\n                        .useImpl(TextFlowSearchServiceImpl.class)\n                        .useImpl(ValidationServiceImpl.class).allowCycles();\n\n        // @formatter:off\n      handler = seam.autowire(GetTransUnitListHandler.class);\n      // @formatter:on\n\n        jaHLocale = getEm().find(HLocale.class, 3L);\n    }","commit_id":"bbe7243aea60b2d45820c8ee17fbda7c375024d3","url":"https://github.com/zanata/zanata-server"},{"original_method":"public TranslationStateCacheImpl() {\n        // constructor for Seam\n        this.docStatusLoader = new HTextFlowTargetIdLoader();\n        this.targetValidationLoader = new HTextFlowTargetValidationLoader();\n    }","id":23755,"modified_method":"public TranslationStateCacheImpl() {\n        this(new DocumentStatisticLoader(), new HTextFlowTargetIdLoader(),\n                new HTextFlowTargetValidationLoader());\n    }","commit_id":"bbe7243aea60b2d45820c8ee17fbda7c375024d3","url":"https://github.com/zanata/zanata-server"},{"original_method":"DocumentDAO getDocumentDAO() {\n        return (DocumentDAO) Component.getInstance(DocumentDAO.class);\n    }","id":23756,"modified_method":"DocumentDAO getDocumentDAO() {\n        return serviceLocator.getInstance(DocumentDAO.class);\n    }","commit_id":"bbe7243aea60b2d45820c8ee17fbda7c375024d3","url":"https://github.com/zanata/zanata-server"},{"original_method":"TextFlowTargetDAO getTextFlowTargetDAO() {\n        TextFlowTargetDAO textFlowTargetDAO = (TextFlowTargetDAO) Component.getInstance(TextFlowTargetDAO.class);\n        return textFlowTargetDAO;\n    }","id":23757,"modified_method":"TextFlowTargetDAO getTextFlowTargetDAO() {\n        return serviceLocator.getInstance(TextFlowTargetDAO.class);\n    }","commit_id":"bbe7243aea60b2d45820c8ee17fbda7c375024d3","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * This method contains all logic to be run immediately after a Text Flow\n     * Target has been successfully translated.\n     */\n    @Observer(TextFlowTargetStateEvent.EVENT_NAME)\n    @Override\n    public void textFlowStateUpdated(TextFlowTargetStateEvent event) {\n        // updateDocStatusCache(event.getDocumentId(), event.getLocaleId(),\n        // event.getTextFlowTargetId());\n\n        // TODO enhance TextFlowTargetStateEvent and update this cache directly\n        // (no database I/O) rather than invalidating\n        invalidateDocLastTranslatedCache(event.getDocumentId(),\n                event.getLocaleId());\n        invalidateTargetValidationCache(event.getTextFlowTargetId());\n    }","id":23758,"modified_method":"/**\n     * This method contains all logic to be run immediately after a Text Flow\n     * Target has been successfully translated.\n     */\n    @Observer(TextFlowTargetStateEvent.EVENT_NAME)\n    @Override\n    public void textFlowStateUpdated(TextFlowTargetStateEvent event) {\n        DocumentLocaleKey key =\n                new DocumentLocaleKey(event.getDocumentId(),\n                        event.getLocaleId());\n\n        WordStatistic stats = documentStatisticCache.get(key);\n\n        if (stats != null) {\n            HTextFlow textFlow = getTextFlowDAO().findById(\n                    event.getTextFlowId());\n\n            stats.decrement(event.getPreviousState(),\n                    textFlow.getWordCount().intValue());\n            stats.increment(event.getNewState(),\n                    textFlow.getWordCount().intValue());\n            documentStatisticCache.put(key, stats);\n        }\n\n        // update document status information\n        updateDocStatusCache(key, event.getTextFlowTargetId());\n\n        // invalidate target validation\n        targetValidationCache.remove(event.getTextFlowTargetId());\n    }","commit_id":"bbe7243aea60b2d45820c8ee17fbda7c375024d3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n    public DocumentStatus getDocumentStatus(Long documentId, LocaleId localeId) {\n        return docStatusCache.getWithLoader(new TranslatedDocumentKey(\n                documentId, localeId));\n    }","id":23759,"modified_method":"@Override\n    public DocumentStatus getDocumentStatus(Long documentId, LocaleId localeId) {\n        return docStatusCache.getWithLoader(new DocumentLocaleKey(\n                documentId, localeId));\n    }","commit_id":"bbe7243aea60b2d45820c8ee17fbda7c375024d3","url":"https://github.com/zanata/zanata-server"},{"original_method":"private Boolean loadTargetValidation(Long textFlowTargetId,\n            ValidationId validationId) {\n        TextFlowTargetDAO textFlowTargetDAO = getTextFlowTargetDAO();\n        HTextFlowTarget tft =\n                textFlowTargetDAO.findById(textFlowTargetId, false);\n\n        if (tft != null) {\n            ValidationAction action =\n                    ValidationFactoryProvider.getFactoryInstance()\n                            .getValidationAction(validationId);\n            List<String> errorList =\n                    action.validate(tft.getTextFlow().getContents().get(0), tft\n                            .getContents().get(0));\n            return !errorList.isEmpty();\n        }\n        return null;\n    }","id":23760,"modified_method":"private Boolean loadTargetValidation(Long textFlowTargetId,\n            ValidationId validationId) {\n        HTextFlowTarget tft =\n                getTextFlowTargetDAO().findById(textFlowTargetId, false);\n        if (tft != null) {\n            ValidationAction action =\n                    ValidationFactoryProvider.getFactoryInstance()\n                            .getValidationAction(validationId);\n            List<String> errorList =\n                    action.validate(tft.getTextFlow().getContents().get(0), tft\n                            .getContents().get(0));\n            return !errorList.isEmpty();\n        }\n        return null;\n    }","commit_id":"bbe7243aea60b2d45820c8ee17fbda7c375024d3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Create\n    public void create() {\n        cacheManager = CacheManager.create();\n        docStatusCache =\n                EhcacheWrapper.create(DOC_STATUS_CACHE_NAME, cacheManager,\n                        docStatusLoader);\n        targetValidationCache =\n                EhcacheWrapper.create(TFT_VALIDATION_CACHE_NAME, cacheManager,\n                        targetValidationLoader);\n    }","id":23761,"modified_method":"@Create\n    public void create() {\n        cacheManager = CacheManager.create();\n        documentStatisticCache =\n                EhcacheWrapper.create(DOC_STATISTIC_CACHE_NAME,\n                        cacheManager, documentStatisticLoader);\n\n        docStatusCache =\n                EhcacheWrapper.create(DOC_STATUS_CACHE_NAME, cacheManager,\n                        docStatusLoader);\n        targetValidationCache =\n                EhcacheWrapper.create(TFT_VALIDATION_CACHE_NAME, cacheManager,\n                        targetValidationLoader);\n    }","commit_id":"bbe7243aea60b2d45820c8ee17fbda7c375024d3","url":"https://github.com/zanata/zanata-server"},{"original_method":"private static DocumentStatus updateDocumentStatus(DocumentDAO documentDAO,\n            DocumentStatus documentStatus, Long documentId, LocaleId localeId,\n            HTextFlowTarget target) {\n        Date lastTranslatedDate = null;\n        String lastTranslatedBy = \"\";\n\n        if (target != null) {\n            lastTranslatedDate = target.getLastChanged();\n\n            if (target.getLastModifiedBy() != null) {\n                lastTranslatedBy =\n                        target.getLastModifiedBy().getAccount().getUsername();\n            }\n        }\n        HDocument document = documentDAO.findById(documentId, false);\n        documentStatus.update(\n                new DocumentId(document.getId(), document.getDocId()),\n                lastTranslatedDate, lastTranslatedBy);\n        return documentStatus;\n    }","id":23762,"modified_method":"private static DocumentStatus updateDocumentStatus(DocumentDAO documentDAO,\n            DocumentStatus documentStatus, Long documentId,\n            HTextFlowTarget target) {\n\n        Date lastTranslatedDate = null;\n        String lastTranslatedBy = \"\";\n\n        if (target != null) {\n            lastTranslatedDate = target.getLastChanged();\n\n            if (target.getLastModifiedBy() != null) {\n                lastTranslatedBy =\n                        target.getLastModifiedBy().getAccount().getUsername();\n            }\n        }\n        HDocument document = documentDAO.findById(documentId, false);\n        documentStatus.update(\n                new DocumentId(document.getId(), document.getDocId()),\n                lastTranslatedDate, lastTranslatedBy);\n        return documentStatus;\n    }","commit_id":"bbe7243aea60b2d45820c8ee17fbda7c375024d3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n        public DocumentStatus load(TranslatedDocumentKey key) throws Exception {\n            DocumentDAO documentDAO = getDocumentDAO();\n            HTextFlowTarget target =\n                    documentDAO.getLastTranslatedTarget(key.getDocumentId(),\n                            key.getLocaleId());\n            DocumentStatus documentStatus = new DocumentStatus();\n\n            return updateDocumentStatus(documentDAO, documentStatus, key.getDocumentId(),\n                    key.getLocaleId(), target);\n        }","id":23763,"modified_method":"private void updateDocStatusCache(DocumentLocaleKey key,\n            Long updatedTargetId) {\n        DocumentStatus documentStatus = docStatusCache.get(key);\n        HTextFlowTarget target =\n                getTextFlowTargetDAO().findById(updatedTargetId, false);\n        updateDocumentStatus(getDocumentDAO(), documentStatus,\n                key.getDocumentId(), target);\n    }","commit_id":"bbe7243aea60b2d45820c8ee17fbda7c375024d3","url":"https://github.com/zanata/zanata-server"},{"original_method":"public TranslationStateCacheImpl(\n            CacheLoader<TranslatedDocumentKey, DocumentStatus> docStatsLoader,\n            CacheLoader<Long, Map<ValidationId, Boolean>> targetValidationLoader) {\n        // constructor for testing\n        this.docStatusLoader = docStatsLoader;\n        this.targetValidationLoader = targetValidationLoader;\n    }","id":23764,"modified_method":"public TranslationStateCacheImpl(\n        CacheLoader<DocumentLocaleKey, WordStatistic> documentStatisticLoader,\n        CacheLoader<DocumentLocaleKey, DocumentStatus> docStatsLoader,\n        CacheLoader<Long, Map<ValidationId, Boolean>> targetValidationLoader) {\n        this.documentStatisticLoader = documentStatisticLoader;\n        this.docStatusLoader = docStatsLoader;\n        this.targetValidationLoader = targetValidationLoader;\n    }","commit_id":"bbe7243aea60b2d45820c8ee17fbda7c375024d3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@BeforeMethod\n    public void beforeMethod() {\n        MockitoAnnotations.initMocks(this);\n        tsCache =\n                new TranslationStateCacheImpl(docStatsLoader,\n                        targetValidationLoader) {\n            @Override\n            TextFlowTargetDAO getTextFlowTargetDAO() {\n                return textFlowTargetDAO;\n            }\n        };\n\n        tsCache.create();\n        tsCache.destroy();\n        tsCache.create();\n    }","id":23765,"modified_method":"@BeforeMethod\n    public void beforeMethod() {\n        MockitoAnnotations.initMocks(this);\n        tsCache =\n                new TranslationStateCacheImpl(docStatisticLoader, docStatsLoader,\n                        targetValidationLoader) {\n            @Override\n            TextFlowTargetDAO getTextFlowTargetDAO() {\n                return textFlowTargetDAO;\n            }\n        };\n\n        tsCache.create();\n        tsCache.destroy();\n        tsCache.create();\n    }","commit_id":"bbe7243aea60b2d45820c8ee17fbda7c375024d3","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void testGetLastModifiedTextFlowTarget() throws Exception {\n        // Given:\n        Long documentId = new Long(\"100\");\n        LocaleId testLocaleId = LocaleId.DE;\n        TranslatedDocumentKey key =\n                new TranslatedDocumentKey(documentId, testLocaleId);\n        DocumentStatus docStats =\n                new DocumentStatus(new DocumentId(documentId, \"\"), new Date(),\n                        \"\");\n\n        // When:\n        when(docStatsLoader.load(key)).thenReturn(docStats);\n\n        DocumentStatus result1 =\n                tsCache.getDocumentStatus(documentId, testLocaleId);\n        DocumentStatus result2 =\n                tsCache.getDocumentStatus(documentId, testLocaleId);\n\n        // Then:\n        verify(docStatsLoader).load(key); // only load the value once\n        assertThat(result1, equalTo(docStats));\n        assertThat(result2, equalTo(docStats));\n    }","id":23766,"modified_method":"public void testGetLastModifiedTextFlowTarget() throws Exception {\n        // Given:\n        Long documentId = new Long(\"100\");\n        LocaleId testLocaleId = LocaleId.DE;\n        TranslationStateCacheImpl.DocumentLocaleKey key =\n                new DocumentLocaleKey(documentId, testLocaleId);\n        DocumentStatus docStats =\n                new DocumentStatus(new DocumentId(documentId, \"\"), new Date(),\n                        \"\");\n\n        // When:\n        when(docStatsLoader.load(key)).thenReturn(docStats);\n\n        DocumentStatus result1 =\n                tsCache.getDocumentStatus(documentId, testLocaleId);\n        DocumentStatus result2 =\n                tsCache.getDocumentStatus(documentId, testLocaleId);\n\n        // Then:\n        verify(docStatsLoader).load(key); // only load the value once\n        assertThat(result1, equalTo(docStats));\n        assertThat(result2, equalTo(docStats));\n    }","commit_id":"bbe7243aea60b2d45820c8ee17fbda7c375024d3","url":"https://github.com/zanata/zanata-server"},{"original_method":"public WordStatistic getStatisticForDocument(Long documentId,\n            LocaleId localeId) {\n        DocumentLocaleKey key = new DocumentLocaleKey(documentId, localeId);\n        if (!documentStatisticMap.containsKey(key)) {\n            WordStatistic wordStatistic =\n                    documentDAO.getWordStatistics(documentId, localeId);\n            wordStatistic.setRemainingHours(StatisticsUtil\n                    .getRemainingHours(wordStatistic));\n            documentStatisticMap.put(key, wordStatistic);\n        }\n        return documentStatisticMap.get(key);\n    }","id":23767,"modified_method":"public WordStatistic getStatisticForDocument(Long documentId,\n            LocaleId localeId) {\n        DocumentLocaleKey key = new DocumentLocaleKey(documentId, localeId);\n        if (!documentStatisticMap.containsKey(key)) {\n            WordStatistic wordStatistic =\n                    translationStateCacheImpl.getDocumentStatistics(documentId,\n                            localeId);\n            wordStatistic.setRemainingHours(StatisticsUtil\n                    .getRemainingHours(wordStatistic));\n            documentStatisticMap.put(key, wordStatistic);\n        }\n        return documentStatisticMap.get(key);\n    }","commit_id":"bbe7243aea60b2d45820c8ee17fbda7c375024d3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Observer(TextFlowTargetStateEvent.EVENT_NAME)\n    @Override\n    public void textFlowStateUpdated(TextFlowTargetStateEvent event) {\n        VersionLocaleKey key =\n                new VersionLocaleKey(event.getProjectIterationId(),\n                        event.getLocaleId());\n        WordStatistic stats = versionStatisticCache.get(key);\n        TextFlowDAO textFlowDAO = serviceLocator.getInstance(TextFlowDAO.class);\n        HTextFlow textFlow = textFlowDAO.findById(event.getTextFlowId());\n\n        if (stats != null) {\n            stats.decrement(event.getPreviousState(),\n                    textFlow.getWordCount().intValue());\n            stats.increment(event.getNewState(),\n                    textFlow.getWordCount().intValue());\n            versionStatisticCache.put(key, stats);\n        }\n    }","id":23768,"modified_method":"@Observer(TextFlowTargetStateEvent.EVENT_NAME)\n    @Override\n    public void textFlowStateUpdated(TextFlowTargetStateEvent event) {\n        VersionLocaleKey key =\n                new VersionLocaleKey(event.getProjectIterationId(),\n                        event.getLocaleId());\n        WordStatistic stats = versionStatisticCache.get(key);\n        if (stats != null) {\n            TextFlowDAO textFlowDAO = serviceLocator.getInstance(TextFlowDAO.class);\n            HTextFlow textFlow = textFlowDAO.findById(event.getTextFlowId());\n\n            stats.decrement(event.getPreviousState(),\n                    textFlow.getWordCount().intValue());\n            stats.increment(event.getNewState(),\n                    textFlow.getWordCount().intValue());\n            versionStatisticCache.put(key, stats);\n        }\n    }","commit_id":"bbe7243aea60b2d45820c8ee17fbda7c375024d3","url":"https://github.com/zanata/zanata-server"},{"original_method":"protected ArrayList<TransMemoryResultItem> searchTransMemory(HLocale hLocale, TransMemoryQuery transMemoryQuery)\n   {\n      ArrayList<TransMemoryResultItem> results = Lists.newArrayList();\n      try\n      {\n         List<Object[]> matches = textFlowDAO.getSearchResult(transMemoryQuery, MAX_RESULTS);\n\n         Map<TMKey, TransMemoryResultItem> matchesMap = new LinkedHashMap<TMKey, TransMemoryResultItem>(matches.size());\n         for (Object[] match : matches)\n         {\n            float score = (Float) match[0];\n            HTextFlowTarget textFlowTarget = (HTextFlowTarget) match[1];\n\n            if (isInvalidResult(textFlowTarget, hLocale))\n            {\n               continue;\n            }\n\n            double percent = calculateSimilarityPercentage(transMemoryQuery, textFlowTarget.getTextFlow().getContents());\n\n            ArrayList<String> textFlowContents = new ArrayList<String>(textFlowTarget.getTextFlow().getContents());\n            ArrayList<String> targetContents = new ArrayList<String>(textFlowTarget.getTextFlow().getTargets().get(hLocale.getId()).getContents());\n\n            TMKey key = new TMKey(textFlowContents, targetContents);\n            TransMemoryResultItem item = matchesMap.get(key);\n            if (item == null)\n            {\n               item = new TransMemoryResultItem(textFlowContents, targetContents, score, percent);\n               matchesMap.put(key, item);\n            }\n            item.addSourceId(textFlowTarget.getTextFlow().getId());\n         }\n         results.addAll(matchesMap.values());\n      }\n      catch (ParseException e)\n      {\n         if (transMemoryQuery.getSearchType() == SearchType.RAW)\n         {\n            // TODO tell the user\n            log.warn(\"Can't parse raw query {}\", transMemoryQuery);\n         }\n         else\n         {\n            // escaping failed!\n            log.error(\"Can't parse query \" + transMemoryQuery, e);\n         }\n      }\n\n      Collections.sort(results, TransMemoryResultComparator.COMPARATOR);\n      return results;\n   }","id":23769,"modified_method":"protected ArrayList<TransMemoryResultItem> searchTransMemory(HLocale hLocale, HLocale sourceLocale, TransMemoryQuery transMemoryQuery)\n   {\n      ArrayList<TransMemoryResultItem> results = Lists.newArrayList();\n      try\n      {\n         List<Object[]> matches = textFlowDAO.getSearchResult(transMemoryQuery, sourceLocale.getLocaleId(), MAX_RESULTS);\n\n         Map<TMKey, TransMemoryResultItem> matchesMap = new LinkedHashMap<TMKey, TransMemoryResultItem>(matches.size());\n         for (Object[] match : matches)\n         {\n            float score = (Float) match[0];\n            HTextFlowTarget textFlowTarget = (HTextFlowTarget) match[1];\n\n            if (isInvalidResult(textFlowTarget, hLocale))\n            {\n               continue;\n            }\n\n            double percent = calculateSimilarityPercentage(transMemoryQuery, textFlowTarget.getTextFlow().getContents());\n\n            ArrayList<String> textFlowContents = new ArrayList<String>(textFlowTarget.getTextFlow().getContents());\n            ArrayList<String> targetContents = new ArrayList<String>(textFlowTarget.getTextFlow().getTargets().get(hLocale.getId()).getContents());\n\n            TMKey key = new TMKey(textFlowContents, targetContents);\n            TransMemoryResultItem item = matchesMap.get(key);\n            if (item == null)\n            {\n               item = new TransMemoryResultItem(textFlowContents, targetContents, score, percent);\n               matchesMap.put(key, item);\n            }\n            item.addSourceId(textFlowTarget.getTextFlow().getId());\n         }\n         results.addAll(matchesMap.values());\n      }\n      catch (ParseException e)\n      {\n         if (transMemoryQuery.getSearchType() == SearchType.RAW)\n         {\n            // TODO tell the user\n            log.warn(\"Can't parse raw query {}\", transMemoryQuery);\n         }\n         else\n         {\n            // escaping failed!\n            log.error(\"Can't parse query \" + transMemoryQuery, e);\n         }\n      }\n\n      Collections.sort(results, TransMemoryResultComparator.COMPARATOR);\n      return results;\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public GetTranslationMemoryResult execute(GetTranslationMemory action, ExecutionContext context) throws ActionException\n   {\n      ZanataIdentity.instance().checkLoggedIn();\n\n      TransMemoryQuery transMemoryQuery = action.getQuery();\n      log.debug(\"Fetching matches for {}\", transMemoryQuery);\n\n      LocaleId localeID = action.getLocaleId();\n      HLocale hLocale = localeServiceImpl.getByLocaleId(localeID);\n\n      ArrayList<TransMemoryResultItem> results = searchTransMemory(hLocale, transMemoryQuery);\n\n      log.debug(\"Returning {} TM matches for {}\", results.size(), transMemoryQuery);\n      return new GetTranslationMemoryResult(action, results);\n   }","id":23770,"modified_method":"@Override\n   public GetTranslationMemoryResult execute(GetTranslationMemory action, ExecutionContext context) throws ActionException\n   {\n      ZanataIdentity.instance().checkLoggedIn();\n\n      TransMemoryQuery transMemoryQuery = action.getQuery();\n      log.debug(\"Fetching matches for {}\", transMemoryQuery);\n\n      HLocale hLocale = localeServiceImpl.getByLocaleId(action.getLocaleId().getId());\n      HLocale sourceLocale = localeServiceImpl.getByLocaleId(action.getSourceLocaleId().getId());\n\n      ArrayList<TransMemoryResultItem> results = searchTransMemory(hLocale, sourceLocale, transMemoryQuery);\n\n      log.debug(\"Returning {} TM matches for {}\", results.size(), transMemoryQuery);\n      return new GetTranslationMemoryResult(action, results);\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"public GetTranslationMemory(TransMemoryQuery query, LocaleId localeId)\n   {\n      this.query = query;\n      this.localeId = localeId;\n   }","id":23771,"modified_method":"public GetTranslationMemory(TransMemoryQuery query, LocaleId localeId, LocaleId sourceLocaleId)\n   {\n      this.query = query;\n      this.localeId = localeId;\n      this.sourceLocaleId = sourceLocaleId;\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public int hashCode()\n   {\n      final int prime = 31;\n      int result = 1;\n      result = prime * result + ((localeId == null) ? 0 : localeId.hashCode());\n      result = prime * result + ((query == null) ? 0 : query.hashCode());\n      return result;\n   }","id":23772,"modified_method":"@Override\n   public int hashCode()\n   {\n      final int prime = 31;\n      int result = 1;\n      result = prime * result + ((sourceLocaleId == null) ? 0 : sourceLocaleId.hashCode());\n      result = prime * result + ((localeId == null) ? 0 : localeId.hashCode());\n      result = prime * result + ((query == null) ? 0 : query.hashCode());\n      return result;\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public boolean equals(Object obj)\n   {\n      if (this == obj)\n      {\n         return true;\n      }\n      if (obj == null)\n      {\n         return false;\n      }\n      if (!(obj instanceof GetTranslationMemory))\n      {\n         return false;\n      }\n      GetTranslationMemory other = (GetTranslationMemory) obj;\n      if (localeId == null)\n      {\n         if (other.localeId != null)\n         {\n            return false;\n         }\n      }\n      else if (!localeId.equals(other.localeId))\n      {\n         return false;\n      }\n      if (query == null)\n      {\n         if (other.query != null)\n         {\n            return false;\n         }\n      }\n      else if (!query.equals(other.query))\n      {\n         return false;\n      }\n      return true;\n   }","id":23773,"modified_method":"@Override\n   public boolean equals(Object obj)\n   {\n      if (this == obj)\n      {\n         return true;\n      }\n      if (obj == null)\n      {\n         return false;\n      }\n      if (!(obj instanceof GetTranslationMemory))\n      {\n         return false;\n      }\n      GetTranslationMemory other = (GetTranslationMemory) obj;\n      if (localeId == null)\n      {\n         if (other.localeId != null)\n         {\n            return false;\n         }\n      }\n      else if (!localeId.equals(other.localeId))\n      {\n         return false;\n      }\n      if (sourceLocaleId == null)\n      {\n         if (other.sourceLocaleId != null)\n         {\n            return false;\n         }\n      }\n      else if (!sourceLocaleId.equals(other.sourceLocaleId))\n      {\n         return false;\n      }\n      if (query == null)\n      {\n         if (other.query != null)\n         {\n            return false;\n         }\n      }\n      else if (!query.equals(other.query))\n      {\n         return false;\n      }\n      return true;\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void set(String name, Object value, Document luceneDocument, LuceneOptions luceneOptions)\n   {\n      // Using word search now, so no n-grams\n      /*if (multiNgrams)\n      {\n         analyzer = new ConfigurableNgramAnalyzer(1, 3, !caseSensitive);\n      }\n      else\n      {\n         analyzer = new ConfigurableNgramAnalyzer(3, !caseSensitive);\n      }*/\n\n      analyzer = new StandardAnalyzer(Version.LUCENE_29);\n\n      if (!(value instanceof List<?>))\n      {\n         throw new IllegalArgumentException(\"this bridge must be applied to a List\");\n      }\n      @SuppressWarnings(\"unchecked\")\n      List<String> strings = (List<String>) value;\n      for (int i = 0; i < strings.size(); i++)\n      {\n         addStringField(name + i, strings.get(i), luceneDocument, luceneOptions);\n      }\n   }","id":23774,"modified_method":"@Override\n   public void set(String name, Object value, Document luceneDocument, LuceneOptions luceneOptions)\n   {\n      if (!(value instanceof List<?>))\n      {\n         throw new IllegalArgumentException(\"this bridge must be applied to a List\");\n      }\n      @SuppressWarnings(\"unchecked\")\n      List<String> strings = (List<String>) value;\n      for (int i = 0; i < strings.size(); i++)\n      {\n         addStringField(name + i, strings.get(i), luceneDocument, luceneOptions);\n      }\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void addStringField(String fieldName, String fieldValue, Document luceneDocument, LuceneOptions luceneOptions)\n   {\n      Field field = new Field(fieldName, fieldValue, luceneOptions.getStore(), luceneOptions.getIndex(), luceneOptions.getTermVector());\n      field.setBoost(luceneOptions.getBoost());\n\n      // manually apply token stream from analyzer, as hibernate search does not\n      // apply the specified analyzer properly\n      try\n      {\n         field.setTokenStream(analyzer.reusableTokenStream(fieldName, new StringReader(fieldValue)));\n      }\n      catch (IOException e)\n      {\n         log.error(\"Failed to get token stream from analyzer for field [{}] with [content {}]\", fieldName, fieldValue);\n         log.error(\"exception\", e);\n      }\n      luceneDocument.add(field);\n   }","id":23775,"modified_method":"private void addStringField(String fieldName, String fieldValue, Document luceneDocument, LuceneOptions luceneOptions)\n   {\n      Field field = new Field(fieldName, fieldValue, luceneOptions.getStore(), luceneOptions.getIndex(), luceneOptions.getTermVector());\n      field.setBoost(luceneOptions.getBoost());\n      luceneDocument.add(field);\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"public List<Object[]> getSearchResult(TransMemoryQuery query, final int maxResult) throws ParseException\n   {\n      String queryText = null;\n      String[] multiQueryText = null;\n\n      switch (query.getSearchType())\n      {\n      // 'Lucene' in the editor\n      case RAW:\n         queryText = query.getQueries().get(0);\n         break;\n\n      // 'Fuzzy' in the editor\n      case FUZZY:\n         queryText = QueryParser.escape(query.getQueries().get(0));\n         break;\n\n      // 'Phrase' in the editor\n      case EXACT:\n         queryText = \"\\\"\" + QueryParser.escape(query.getQueries().get(0)) + \"\\\"\";\n         break;\n\n      // 'Fuzzy' in the editor, plus it is a plural entry\n      case FUZZY_PLURAL:\n         multiQueryText = new String[query.getQueries().size()];\n         for (int i = 0; i < query.getQueries().size(); i++)\n         {\n            multiQueryText[i] = QueryParser.escape(query.getQueries().get(i));\n         }\n         break;\n      default:\n         throw new RuntimeException(\"Unknown query type: \" + query.getSearchType());\n      }\n\n      org.apache.lucene.search.Query textQuery;\n      Analyzer analyzer = new StandardAnalyzer(Version.LUCENE_29);\n      if (query.getSearchType() == SearchType.FUZZY_PLURAL)\n      {\n         int queriesSize = multiQueryText.length;\n         if (queriesSize > IndexFieldLabels.TF_CONTENT_FIELDS.length)\n         {\n            log.warn(\"query contains {} fields, but we only index {}\", queriesSize, IndexFieldLabels.TF_CONTENT_FIELDS.length);\n         }\n         String[] searchFields = new String[queriesSize];\n         System.arraycopy(IndexFieldLabels.TF_CONTENT_FIELDS, 0, searchFields, 0, queriesSize);\n\n         textQuery = MultiFieldQueryParser.parse(LUCENE_VERSION, multiQueryText, searchFields, analyzer);\n      }\n      else\n      {\n         MultiFieldQueryParser parser = new MultiFieldQueryParser(LUCENE_VERSION, IndexFieldLabels.TF_CONTENT_FIELDS, analyzer);\n         textQuery = parser.parse(queryText);\n      }\n      FullTextQuery ftQuery = entityManager.createFullTextQuery(textQuery, HTextFlowTarget.class);\n\n      ftQuery.setProjection(FullTextQuery.SCORE, FullTextQuery.THIS);\n      @SuppressWarnings(\"unchecked\")\n      List<Object[]> matches = ftQuery.setMaxResults(maxResult).getResultList();\n      return matches;\n   }","id":23776,"modified_method":"public List<Object[]> getSearchResult(TransMemoryQuery query, LocaleId locale, final int maxResult) throws ParseException\n   {\n      String queryText = null;\n      String[] multiQueryText = null;\n\n      switch (query.getSearchType())\n      {\n      // 'Lucene' in the editor\n      case RAW:\n         queryText = query.getQueries().get(0);\n         break;\n\n      // 'Fuzzy' in the editor\n      case FUZZY:\n         queryText = QueryParser.escape(query.getQueries().get(0));\n         break;\n\n      // 'Phrase' in the editor\n      case EXACT:\n         queryText = \"\\\"\" + QueryParser.escape(query.getQueries().get(0)) + \"\\\"\";\n         break;\n\n      // 'Fuzzy' in the editor, plus it is a plural entry\n      case FUZZY_PLURAL:\n         multiQueryText = new String[query.getQueries().size()];\n         for (int i = 0; i < query.getQueries().size(); i++)\n         {\n            multiQueryText[i] = QueryParser.escape(query.getQueries().get(i));\n         }\n         break;\n      default:\n         throw new RuntimeException(\"Unknown query type: \" + query.getSearchType());\n      }\n\n      org.apache.lucene.search.Query textQuery;\n      // Analyzer determined by the language\n      String analyzerDefName = TextContainerAnalyzerDiscriminator.getAnalyzerDefinitionName( locale.getId() );\n      Analyzer analyzer = entityManager.getSearchFactory().getAnalyzer(analyzerDefName);\n\n      if (query.getSearchType() == SearchType.FUZZY_PLURAL)\n      {\n         int queriesSize = multiQueryText.length;\n         if (queriesSize > IndexFieldLabels.TF_CONTENT_FIELDS.length)\n         {\n            log.warn(\"query contains {} fields, but we only index {}\", queriesSize, IndexFieldLabels.TF_CONTENT_FIELDS.length);\n         }\n         String[] searchFields = new String[queriesSize];\n         System.arraycopy(IndexFieldLabels.TF_CONTENT_FIELDS, 0, searchFields, 0, queriesSize);\n\n         textQuery = MultiFieldQueryParser.parse(LUCENE_VERSION, multiQueryText, searchFields, analyzer);\n      }\n      else\n      {\n         MultiFieldQueryParser parser = new MultiFieldQueryParser(LUCENE_VERSION, IndexFieldLabels.TF_CONTENT_FIELDS, analyzer);\n         textQuery = parser.parse(queryText);\n      }\n      FullTextQuery ftQuery = entityManager.createFullTextQuery(textQuery, HTextFlowTarget.class);\n\n      ftQuery.setProjection(FullTextQuery.SCORE, FullTextQuery.THIS);\n      @SuppressWarnings(\"unchecked\")\n      List<Object[]> matches = ftQuery.setMaxResults(maxResult).getResultList();\n      return matches;\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * @param workspace\n    * @param documentPaths null or empty to search entire project, otherwise\n    *           only results for the given document paths will be returned\n    * @param constraints\n    * @return\n    */\n   private List<HTextFlow> findTextFlowsByDocumentPaths(WorkspaceId workspace, List<String> documentPaths, FilterConstraints constraints)\n   {\n      LocaleId localeId = workspace.getLocaleId();\n      String projectSlug = workspace.getProjectIterationId().getProjectSlug();\n      String iterationSlug = workspace.getProjectIterationId().getIterationSlug();\n\n      // TODO consider whether to allow null and empty search strings.\n      // May want to fork to use a different method to retrieve all targets if\n      // empty targets are required.\n\n      // check that locale is valid for the workspace\n      try\n      {\n         localeServiceImpl.validateLocaleByProjectIteration(localeId, projectSlug, iterationSlug);\n      }\n      catch (ZanataServiceException e)\n      {\n         throw new ZanataServiceException(\"Failed to validate locale\", e);\n      }\n\n      if (!constraints.isSearchInSource() && !constraints.isSearchInTarget())\n      {\n         //searching nowhere\n         return Collections.emptyList();\n      }\n\n      Analyzer standardAnalyzer = new StandardAnalyzer(Version.LUCENE_29);\n\n      // Common query terms between source and targets\n      TermQuery projectQuery = new TermQuery(new Term(IndexFieldLabels.PROJECT_FIELD, projectSlug));\n      TermQuery iterationQuery = new TermQuery(new Term(IndexFieldLabels.ITERATION_FIELD, iterationSlug));\n      TermQuery localeQuery = new TermQuery(new Term(IndexFieldLabels.LOCALE_ID_FIELD, localeId.getId()));\n\n      Query contentPhraseQuery;\n      QueryParser contentQueryParser = new MultiFieldQueryParser(Version.LUCENE_29, IndexFieldLabels.CONTENT_FIELDS, standardAnalyzer);\n      try\n      {\n         // add a wilcard at the end to search for partial words\n         // NB: No search for partial word endings.\n         contentPhraseQuery = contentQueryParser.parse(\"\\\"\" + QueryParser.escape(constraints.getSearchString()) + \"\\\"\");\n      }\n      catch (ParseException e)\n      {\n         throw new ZanataServiceException(\"Failed to parse query\", e);\n      }\n\n      MultiPhraseQuery documentsQuery = new MultiPhraseQuery();\n      if (documentPaths != null && !documentPaths.isEmpty())\n      {\n         ArrayList<Term> docPathTerms = new ArrayList<Term>();\n         for (String s : documentPaths)\n         {\n            docPathTerms.add(new Term(IndexFieldLabels.DOCUMENT_ID_FIELD, s));\n         }\n         documentsQuery.add(docPathTerms.toArray(new Term[docPathTerms.size()]));\n      }\n\n      List<HTextFlow> resultList = new ArrayList<HTextFlow>();\n      if (constraints.isSearchInTarget())\n      {\n         // Target Query\n         BooleanQuery targetQuery = new BooleanQuery();\n         targetQuery.add(projectQuery, Occur.MUST);\n         targetQuery.add(iterationQuery, Occur.MUST);\n         targetQuery.add(contentPhraseQuery, Occur.MUST);\n         if( documentsQuery.getTermArrays().size() > 0 )\n         {\n            targetQuery.add(documentsQuery, Occur.MUST);\n         }\n         targetQuery.add(localeQuery, Occur.MUST);\n\n         if (!constraints.isIncludeApproved())\n         {\n            TermQuery approvedStateQuery = new TermQuery(new Term(IndexFieldLabels.CONTENT_STATE_FIELD, ContentState.Approved.toString()));\n            targetQuery.add(approvedStateQuery, Occur.MUST_NOT);\n         }\n\n         if (!constraints.isIncludeFuzzy())\n         {\n            TermQuery approvedStateQuery = new TermQuery(new Term(IndexFieldLabels.CONTENT_STATE_FIELD, ContentState.NeedReview.toString()));\n            targetQuery.add(approvedStateQuery, Occur.MUST_NOT);\n         }\n\n         if (!constraints.isIncludeNew())\n         {\n            TermQuery approvedStateQuery = new TermQuery(new Term(IndexFieldLabels.CONTENT_STATE_FIELD, ContentState.New.toString()));\n            targetQuery.add(approvedStateQuery, Occur.MUST_NOT);\n         }\n\n         FullTextQuery ftQuery = entityManager.createFullTextQuery(targetQuery, HTextFlowTarget.class);\n         @SuppressWarnings(\"unchecked\")\n         List<HTextFlowTarget> matchedTargets = (List<HTextFlowTarget>) ftQuery.getResultList();\n         log.info(\"got {} HTextFLowTarget results\", matchedTargets.size());\n         for (HTextFlowTarget htft : matchedTargets)\n         {\n            // manually check for case sensitive matches\n            if( !constraints.isCaseSensitive() || (constraints.isCaseSensitive() && contentIsValid(htft.getContents(), constraints)) )\n            {\n               resultList.add(htft.getTextFlow());\n            }\n         }\n      }\n\n      if (constraints.isSearchInSource())\n      {\n         // Source Query\n         BooleanQuery sourceQuery = new BooleanQuery();\n         sourceQuery.add(projectQuery, Occur.MUST);\n         sourceQuery.add(iterationQuery, Occur.MUST);\n         sourceQuery.add(contentPhraseQuery, Occur.MUST);\n         if( documentsQuery.getTermArrays().size() > 0 )\n         {\n            sourceQuery.add(documentsQuery, Occur.MUST);\n         }\n\n         FullTextQuery ftQuery = entityManager.createFullTextQuery(sourceQuery, HTextFlow.class);\n         @SuppressWarnings(\"unchecked\")\n         List<HTextFlow> matchedSources = (List<HTextFlow>) ftQuery.getResultList();\n         log.info(\"got {} HTextFLow results\", matchedSources.size());\n         for (HTextFlow htf : matchedSources)\n         {\n            if (!resultList.contains(htf))\n            {\n               // manually check for case sensitive matches\n               if( !constraints.isCaseSensitive() || (constraints.isCaseSensitive() && contentIsValid(htf.getContents(), constraints)) )\n               {\n                  resultList.add(htf);\n               }\n            }\n         }\n      }\n\n      return resultList;\n   }","id":23777,"modified_method":"/**\n    * @param workspace\n    * @param documentPaths null or empty to search entire project, otherwise\n    *           only results for the given document paths will be returned\n    * @param constraints\n    * @return\n    */\n   private List<HTextFlow> findTextFlowsByDocumentPaths(WorkspaceId workspace, List<String> documentPaths, FilterConstraints constraints)\n   {\n      LocaleId localeId = workspace.getLocaleId();\n      String projectSlug = workspace.getProjectIterationId().getProjectSlug();\n      String iterationSlug = workspace.getProjectIterationId().getIterationSlug();\n\n      // TODO consider whether to allow null and empty search strings.\n      // May want to fork to use a different method to retrieve all targets if\n      // empty targets are required.\n\n      // check that locale is valid for the workspace\n      try\n      {\n         localeServiceImpl.validateLocaleByProjectIteration(localeId, projectSlug, iterationSlug);\n      }\n      catch (ZanataServiceException e)\n      {\n         throw new ZanataServiceException(\"Failed to validate locale\", e);\n      }\n\n      if (!constraints.isSearchInSource() && !constraints.isSearchInTarget())\n      {\n         //searching nowhere\n         return Collections.emptyList();\n      }\n\n      // Common query terms between source and targets\n      TermQuery projectQuery = new TermQuery(new Term(IndexFieldLabels.PROJECT_FIELD, projectSlug));\n      TermQuery iterationQuery = new TermQuery(new Term(IndexFieldLabels.ITERATION_FIELD, iterationSlug));\n      TermQuery localeQuery = new TermQuery(new Term(IndexFieldLabels.LOCALE_ID_FIELD, localeId.getId()));\n\n      MultiPhraseQuery documentsQuery = new MultiPhraseQuery();\n      if (documentPaths != null && !documentPaths.isEmpty())\n      {\n         ArrayList<Term> docPathTerms = new ArrayList<Term>();\n         for (String s : documentPaths)\n         {\n            docPathTerms.add(new Term(IndexFieldLabels.DOCUMENT_ID_FIELD, s));\n         }\n         documentsQuery.add(docPathTerms.toArray(new Term[docPathTerms.size()]));\n      }\n\n      List<HTextFlow> resultList = new ArrayList<HTextFlow>();\n      if (constraints.isSearchInTarget())\n      {\n         // Content query for target\n         String targetAnalyzerName = TextContainerAnalyzerDiscriminator.getAnalyzerDefinitionName( localeId.getId() );\n         Analyzer targetAnalyzer = entityManager.getSearchFactory().getAnalyzer( targetAnalyzerName );\n\n         Query tgtContentPhraseQuery;\n         QueryParser contentQueryParser = new MultiFieldQueryParser(Version.LUCENE_29, IndexFieldLabels.CONTENT_FIELDS, targetAnalyzer);\n         try\n         {\n            tgtContentPhraseQuery = contentQueryParser.parse(\"\\\"\" + QueryParser.escape(constraints.getSearchString()) + \"\\\"\");\n         }\n         catch (ParseException e)\n         {\n            throw new ZanataServiceException(\"Failed to parse query\", e);\n         }\n\n         // Target Query\n         BooleanQuery targetQuery = new BooleanQuery();\n         targetQuery.add(projectQuery, Occur.MUST);\n         targetQuery.add(iterationQuery, Occur.MUST);\n         targetQuery.add(tgtContentPhraseQuery, Occur.MUST);\n         if( documentsQuery.getTermArrays().size() > 0 )\n         {\n            targetQuery.add(documentsQuery, Occur.MUST);\n         }\n         targetQuery.add(localeQuery, Occur.MUST);\n\n         if (!constraints.isIncludeApproved())\n         {\n            TermQuery approvedStateQuery = new TermQuery(new Term(IndexFieldLabels.CONTENT_STATE_FIELD, ContentState.Approved.toString()));\n            targetQuery.add(approvedStateQuery, Occur.MUST_NOT);\n         }\n\n         if (!constraints.isIncludeFuzzy())\n         {\n            TermQuery approvedStateQuery = new TermQuery(new Term(IndexFieldLabels.CONTENT_STATE_FIELD, ContentState.NeedReview.toString()));\n            targetQuery.add(approvedStateQuery, Occur.MUST_NOT);\n         }\n\n         if (!constraints.isIncludeNew())\n         {\n            TermQuery approvedStateQuery = new TermQuery(new Term(IndexFieldLabels.CONTENT_STATE_FIELD, ContentState.New.toString()));\n            targetQuery.add(approvedStateQuery, Occur.MUST_NOT);\n         }\n\n         FullTextQuery ftQuery = entityManager.createFullTextQuery(targetQuery, HTextFlowTarget.class);\n         @SuppressWarnings(\"unchecked\")\n         List<HTextFlowTarget> matchedTargets = (List<HTextFlowTarget>) ftQuery.getResultList();\n         log.info(\"got {} HTextFLowTarget results\", matchedTargets.size());\n         for (HTextFlowTarget htft : matchedTargets)\n         {\n            // manually check for case sensitive matches\n            if( !constraints.isCaseSensitive() || (constraints.isCaseSensitive() && contentIsValid(htft.getContents(), constraints)) )\n            {\n               resultList.add(htft.getTextFlow());\n            }\n         }\n      }\n\n      if (constraints.isSearchInSource())\n      {\n         // Source locale\n         // NB: Assume the first document's locale, or the same target locale if there are no documents\n         // TODO Move source locale to the Project iteration level\n         LocaleId sourceLocaleId = localeId;\n         HProjectIteration projectIteration = projectIterationDAO.getBySlug(projectSlug, iterationSlug);\n         if( !projectIteration.getDocuments().isEmpty() )\n         {\n            sourceLocaleId = projectIteration.getDocuments().values().iterator().next().getLocale().getLocaleId();\n         }\n\n         // Content query for source\n         String sourceAnalyzerName = TextContainerAnalyzerDiscriminator.getAnalyzerDefinitionName( sourceLocaleId.getId() );\n         Analyzer sourceAnalyzer = entityManager.getSearchFactory().getAnalyzer( sourceAnalyzerName );\n\n         Query srcContentPhraseQuery;\n         QueryParser srcContentQueryParser = new MultiFieldQueryParser(Version.LUCENE_29, IndexFieldLabels.CONTENT_FIELDS, sourceAnalyzer);\n         try\n         {\n            srcContentPhraseQuery = srcContentQueryParser.parse(\"\\\"\" + QueryParser.escape(constraints.getSearchString()) + \"\\\"\");\n         }\n         catch (ParseException e)\n         {\n            throw new ZanataServiceException(\"Failed to parse query\", e);\n         }\n\n         // Source Query\n         BooleanQuery sourceQuery = new BooleanQuery();\n         sourceQuery.add(projectQuery, Occur.MUST);\n         sourceQuery.add(iterationQuery, Occur.MUST);\n         sourceQuery.add(srcContentPhraseQuery, Occur.MUST);\n         if( documentsQuery.getTermArrays().size() > 0 )\n         {\n            sourceQuery.add(documentsQuery, Occur.MUST);\n         }\n\n         FullTextQuery ftQuery = entityManager.createFullTextQuery(sourceQuery, HTextFlow.class);\n         @SuppressWarnings(\"unchecked\")\n         List<HTextFlow> matchedSources = (List<HTextFlow>) ftQuery.getResultList();\n         log.info(\"got {} HTextFLow results\", matchedSources.size());\n         for (HTextFlow htf : matchedSources)\n         {\n            if (!resultList.contains(htf))\n            {\n               // manually check for case sensitive matches\n               if( !constraints.isCaseSensitive() || (constraints.isCaseSensitive() && contentIsValid(htf.getContents(), constraints)) )\n               {\n                  resultList.add(htf);\n               }\n            }\n         }\n      }\n\n      return resultList;\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public UpdateTransUnitResult execute(TransMemoryMerge action, ExecutionContext context) throws ActionException\n   {\n      SecurityService.SecurityCheckResult securityCheckResult = securityServiceImpl.checkPermission(action, MODIFY);\n      HLocale hLocale = securityCheckResult.getLocale();\n      TranslationWorkspace workspace = securityCheckResult.getWorkspace();\n\n      Map<Long, TransUnitUpdateRequest> requestMap = transformToMap(action.getUpdateRequests());\n      List<HTextFlow> hTextFlows = textFlowDAO.findByIdList(Lists.newArrayList(requestMap.keySet()));\n\n      TransMemoryAboveThresholdPredicate predicate = new TransMemoryAboveThresholdPredicate(action.getThresholdPercent());\n\n      List<TransUnitUpdateRequest> updateRequests = Lists.newArrayList();\n      for (HTextFlow hTextFlow : hTextFlows)\n      {\n         HTextFlowTarget hTextFlowTarget = hTextFlow.getTargets().get(hLocale.getId());\n         if (hTextFlowTarget != null && hTextFlowTarget.getState() != ContentState.New)\n         {\n            log.warn(\"Text flow id {} is not untranslated. Ignored.\", hTextFlow.getId());\n            continue;\n         }\n         ArrayList<TransMemoryResultItem> tmResults = getTransMemoryHandler.searchTransMemory(hLocale, new TransMemoryQuery(hTextFlow.getContents(), SearchType.FUZZY_PLURAL));\n         TransMemoryResultItem tmResult = findTMAboveThreshold(tmResults, predicate);\n         TransUnitUpdateRequest request = createRequest(action, hLocale, requestMap, hTextFlow, tmResult);\n         if (request != null)\n         {\n            updateRequests.add(request);\n         }\n      }\n\n      if (updateRequests.isEmpty())\n      {\n         return new UpdateTransUnitResult();\n      }\n      return updateTransUnitHandler.doTranslation(hLocale.getLocaleId(), workspace, updateRequests, action.getEditorClientId(), TransUnitUpdated.UpdateType.TMMerge);\n   }","id":23778,"modified_method":"@Override\n   public UpdateTransUnitResult execute(TransMemoryMerge action, ExecutionContext context) throws ActionException\n   {\n      SecurityService.SecurityCheckResult securityCheckResult = securityServiceImpl.checkPermission(action, MODIFY);\n      HLocale hLocale = securityCheckResult.getLocale();\n      TranslationWorkspace workspace = securityCheckResult.getWorkspace();\n\n      Map<Long, TransUnitUpdateRequest> requestMap = transformToMap(action.getUpdateRequests());\n      List<HTextFlow> hTextFlows = textFlowDAO.findByIdList(Lists.newArrayList(requestMap.keySet()));\n\n      TransMemoryAboveThresholdPredicate predicate = new TransMemoryAboveThresholdPredicate(action.getThresholdPercent());\n\n      List<TransUnitUpdateRequest> updateRequests = Lists.newArrayList();\n      for (HTextFlow hTextFlow : hTextFlows)\n      {\n         HTextFlowTarget hTextFlowTarget = hTextFlow.getTargets().get(hLocale.getId());\n         HLocale sourceLocale = hTextFlow.getDocument().getLocale();\n\n         if (hTextFlowTarget != null && hTextFlowTarget.getState() != ContentState.New)\n         {\n            log.warn(\"Text flow id {} is not untranslated. Ignored.\", hTextFlow.getId());\n            continue;\n         }\n         ArrayList<TransMemoryResultItem> tmResults = getTransMemoryHandler.searchTransMemory(hLocale, sourceLocale, new TransMemoryQuery(hTextFlow.getContents(), SearchType.FUZZY_PLURAL));\n         TransMemoryResultItem tmResult = findTMAboveThreshold(tmResults, predicate);\n         TransUnitUpdateRequest request = createRequest(action, hLocale, requestMap, hTextFlow, tmResult);\n         if (request != null)\n         {\n            updateRequests.add(request);\n         }\n      }\n\n      if (updateRequests.isEmpty())\n      {\n         return new UpdateTransUnitResult();\n      }\n      return updateTransUnitHandler.doTranslation(hLocale.getLocaleId(), workspace, updateRequests, action.getEditorClientId(), TransUnitUpdated.UpdateType.TMMerge);\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void willNotTranslateIfDifferentMetaDataOptionSetToSkip() throws ActionException\n   {\n      // Given: an action with threshold 80% and trans unit id is 1, with different doc id option set to skip\n      final long transUnitId = 1L;\n      ArrayList<TransUnitUpdateRequest> requests = Lists.newArrayList(new TransUnitUpdateRequest(new TransUnitId(1L), null, null, 0));\n      TransMemoryMerge action = new TransMemoryMerge(80, requests, MergeOption.IGNORE_CHECK, MergeOption.REJECT, MergeOption.IGNORE_CHECK);\n      mockSecurityService(action);\n\n      HTextFlow hTextFlow = TestFixture.makeHTextFlow(transUnitId, hLocale, ContentState.New, \"pot/a.po\");\n      when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(newArrayList(hTextFlow));\n      // Given: there are three TM results returned for text flow id 1, and the most matched one is text flow id 11\n      HTextFlow tmResultSource = TestFixture.makeApprovedHTextFlow(11L, hLocale);\n      TransMemoryResultItem mostSimilarTM = tmResult(tmResultSource.getId(), 100);\n      TransMemoryQuery tmQuery = new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n      when(getTransMemoryHandler.searchTransMemory(hLocale, tmQuery))\n            .thenReturn(newArrayList(mostSimilarTM, tmResult(12L, 90), tmResult(13L, 80)));\n      when(textFlowDAO.findById(tmResultSource.getId(), false)).thenReturn(tmResultSource);\n      // Given: tm detail of text flow id 11 which has different doc id\n      TransMemoryDetails tmDetails = new TransMemoryDetails(\"\", \"\", \"project a\", \"master\", \"different/doc/id\", \"resId\", \"\", \"\", \"\");\n      when(getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale, tmResultSource)).thenReturn(tmDetails);\n\n      // When: execute the action\n      UpdateTransUnitResult result = handler.execute(action, null);\n\n      // Then: we should have EMPTY trans unit update request\n      verifyZeroInteractions(updateTransUnitHandler);\n      assertThat(result.getUpdateInfoList(), Matchers.<TransUnitUpdateInfo>empty());\n   }","id":23779,"modified_method":"@Test\n   public void willNotTranslateIfDifferentMetaDataOptionSetToSkip() throws ActionException\n   {\n      // Given: an action with threshold 80% and trans unit id is 1, with different doc id option set to skip\n      final long transUnitId = 1L;\n      ArrayList<TransUnitUpdateRequest> requests = Lists.newArrayList(new TransUnitUpdateRequest(new TransUnitId(1L), null, null, 0));\n      TransMemoryMerge action = new TransMemoryMerge(80, requests, MergeOption.IGNORE_CHECK, MergeOption.REJECT, MergeOption.IGNORE_CHECK);\n      mockSecurityService(action);\n\n      HTextFlow hTextFlow = TestFixture.makeHTextFlow(transUnitId, hLocale, ContentState.New, \"pot/a.po\");\n      when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(newArrayList(hTextFlow));\n      // Given: there are three TM results returned for text flow id 1, and the most matched one is text flow id 11\n      HTextFlow tmResultSource = TestFixture.makeApprovedHTextFlow(11L, hLocale);\n      TransMemoryResultItem mostSimilarTM = tmResult(tmResultSource.getId(), 100);\n      TransMemoryQuery tmQuery = new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n      when(getTransMemoryHandler.searchTransMemory(hLocale, sourceLocale, tmQuery))\n            .thenReturn(newArrayList(mostSimilarTM, tmResult(12L, 90), tmResult(13L, 80)));\n      when(textFlowDAO.findById(tmResultSource.getId(), false)).thenReturn(tmResultSource);\n      // Given: tm detail of text flow id 11 which has different doc id\n      TransMemoryDetails tmDetails = new TransMemoryDetails(\"\", \"\", \"project a\", \"master\", \"different/doc/id\", \"resId\", \"\", \"\", \"\");\n      when(getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale, tmResultSource)).thenReturn(tmDetails);\n\n      // When: execute the action\n      UpdateTransUnitResult result = handler.execute(action, null);\n\n      // Then: we should have EMPTY trans unit update request\n      verifyZeroInteractions(updateTransUnitHandler);\n      assertThat(result.getUpdateInfoList(), Matchers.<TransUnitUpdateInfo>empty());\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void willNotTranslateIfTMBelowThreshold() throws ActionException\n   {\n      // Given: an action with threshold 80% and trans unit id is 1\n      final long transUnitId = 1L;\n      TransMemoryMerge action = prepareActionAndMockSecurityService(80, transUnitId);\n\n      HTextFlow hTextFlow = TestFixture.makeHTextFlow(transUnitId, hLocale, ContentState.New, \"pot/a.po\");\n      when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(newArrayList(hTextFlow));\n      // Given: there are three TM results returned for text flow id 1, and the most matched one has percentage 79\n      TransMemoryQuery tmQuery = new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n      when(getTransMemoryHandler.searchTransMemory(hLocale, tmQuery))\n            .thenReturn(newArrayList(tmResult(11L, 79), tmResult(12L, 60), tmResult(13L, 50)));\n\n      // When: execute the action\n      UpdateTransUnitResult result = handler.execute(action, null);\n\n      // Then: we should have EMPTY trans unit update request\n      verifyZeroInteractions(updateTransUnitHandler);\n      assertThat(result.getUpdateInfoList(), Matchers.<TransUnitUpdateInfo>empty());\n   }","id":23780,"modified_method":"@Test\n   public void willNotTranslateIfTMBelowThreshold() throws ActionException\n   {\n      // Given: an action with threshold 80% and trans unit id is 1\n      final long transUnitId = 1L;\n      TransMemoryMerge action = prepareActionAndMockSecurityService(80, transUnitId);\n\n      HTextFlow hTextFlow = TestFixture.makeHTextFlow(transUnitId, hLocale, ContentState.New, \"pot/a.po\");\n      when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(newArrayList(hTextFlow));\n      // Given: there are three TM results returned for text flow id 1, and the most matched one has percentage 79\n      TransMemoryQuery tmQuery = new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n      when(getTransMemoryHandler.searchTransMemory(hLocale, sourceLocale, tmQuery))\n            .thenReturn(newArrayList(tmResult(11L, 79), tmResult(12L, 60), tmResult(13L, 50)));\n\n      // When: execute the action\n      UpdateTransUnitResult result = handler.execute(action, null);\n\n      // Then: we should have EMPTY trans unit update request\n      verifyZeroInteractions(updateTransUnitHandler);\n      assertThat(result.getUpdateInfoList(), Matchers.<TransUnitUpdateInfo>empty());\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void canAutoTranslateIfHasTMAboveThreshold() throws ActionException\n   {\n      // Given: an action with threshold 80% and trans unit id is 1\n      final long transUnitId = 1L;\n      TransMemoryMerge action = prepareActionAndMockSecurityService(80, transUnitId);\n\n      HTextFlow hTextFlow = TestFixture.makeHTextFlow(transUnitId, hLocale, ContentState.New, \"pot/a.po\");\n      when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(newArrayList(hTextFlow));\n      // Given: there are three TM results returned for text flow id 1, and the most matched one is text flow id 11\n      HTextFlow tmResultSource = TestFixture.makeApprovedHTextFlow(11L, hLocale);\n      TransMemoryResultItem mostSimilarTM = tmResult(tmResultSource.getId(), 100);\n      TransMemoryQuery tmQuery = new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n      when(getTransMemoryHandler.searchTransMemory(hLocale, tmQuery))\n            .thenReturn(newArrayList(mostSimilarTM, tmResult(12L, 90), tmResult(13L, 80)));\n      when(textFlowDAO.findById(tmResultSource.getId(), false)).thenReturn(tmResultSource);\n      // Given: tm detail of text flow id 11\n      when(getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale, tmResultSource)).thenReturn(tmDetail());\n\n      // When: execute the action\n      handler.execute(action, null);\n\n      // Then: we should have text flow auto translated by using the most similar TM\n      verify(updateTransUnitHandler).doTranslation(same(hLocale.getLocaleId()), same(workspace), updateRequestCaptor.capture(), same(action.getEditorClientId()), eq(TransUnitUpdated.UpdateType.TMMerge));\n      List<TransUnitUpdateRequest> updateRequest = updateRequestCaptor.getValue();\n      assertThat(updateRequest, Matchers.hasSize(1));\n      TransUnitUpdateRequest transUnitUpdateRequest = updateRequest.get(0);\n      assertThat(transUnitUpdateRequest.getNewContents(), Matchers.equalTo(mostSimilarTM.getTargetContents()));\n      assertThat(transUnitUpdateRequest.getTargetComment(), Matchers.equalTo(\"auto translated by TM merge\"));\n   }","id":23781,"modified_method":"@Test\n   public void canAutoTranslateIfHasTMAboveThreshold() throws ActionException\n   {\n      // Given: an action with threshold 80% and trans unit id is 1\n      final long transUnitId = 1L;\n      TransMemoryMerge action = prepareActionAndMockSecurityService(80, transUnitId);\n\n      HTextFlow hTextFlow = TestFixture.makeHTextFlow(transUnitId, hLocale, ContentState.New, \"pot/a.po\");\n      when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(newArrayList(hTextFlow));\n      // Given: there are three TM results returned for text flow id 1, and the most matched one is text flow id 11\n      HTextFlow tmResultSource = TestFixture.makeApprovedHTextFlow(11L, hLocale);\n      TransMemoryResultItem mostSimilarTM = tmResult(tmResultSource.getId(), 100);\n      TransMemoryQuery tmQuery = new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n      when(getTransMemoryHandler.searchTransMemory(hLocale, sourceLocale, tmQuery))\n            .thenReturn(newArrayList(mostSimilarTM, tmResult(12L, 90), tmResult(13L, 80)));\n      when(textFlowDAO.findById(tmResultSource.getId(), false)).thenReturn(tmResultSource);\n      // Given: tm detail of text flow id 11\n      when(getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale, tmResultSource)).thenReturn(tmDetail());\n\n      // When: execute the action\n      handler.execute(action, null);\n\n      // Then: we should have text flow auto translated by using the most similar TM\n      verify(updateTransUnitHandler).doTranslation(same(hLocale.getLocaleId()), same(workspace), updateRequestCaptor.capture(), same(action.getEditorClientId()), eq(TransUnitUpdated.UpdateType.TMMerge));\n      List<TransUnitUpdateRequest> updateRequest = updateRequestCaptor.getValue();\n      assertThat(updateRequest, Matchers.hasSize(1));\n      TransUnitUpdateRequest transUnitUpdateRequest = updateRequest.get(0);\n      assertThat(transUnitUpdateRequest.getNewContents(), Matchers.equalTo(mostSimilarTM.getTargetContents()));\n      assertThat(transUnitUpdateRequest.getTargetComment(), Matchers.equalTo(\"auto translated by TM merge\"));\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void canHandleMultipleTextFlows() throws ActionException\n   {\n      // Given: an action with threshold 90% and trans unit id is 1, 2, 3, 4\n      final long idWith100MatchTM = 1L;\n      final long idWithoutTM = 2L;\n      final long idWith80MatchTM = 3L;\n      final long idWith90MatchTM = 4L;\n      TransMemoryMerge action = prepareActionAndMockSecurityService(90, idWith100MatchTM, idWithoutTM, idWith80MatchTM, idWith90MatchTM);\n\n      HTextFlow textFlow100TM = TestFixture.makeHTextFlow(idWith100MatchTM, hLocale, ContentState.New, \"pot/a.po\");\n      HTextFlow textFlowNoTM = TestFixture.makeHTextFlow(idWithoutTM, hLocale, ContentState.New, \"pot/a.po\");\n      HTextFlow textFlow80TM = TestFixture.makeHTextFlow(idWith80MatchTM, hLocale, ContentState.New, \"pot/a.po\");\n      HTextFlow textFLow90TM = TestFixture.makeHTextFlow(idWith90MatchTM, hLocale, ContentState.New, \"pot/a.po\");\n\n      when(textFlowDAO.findByIdList(newArrayList(idWith100MatchTM, idWithoutTM, idWith80MatchTM, idWith90MatchTM)))\n            .thenReturn(newArrayList(textFlow100TM, textFlowNoTM, textFlow80TM, textFLow90TM));\n      // Given: TM results\n      HTextFlow tmResultSource = TestFixture.makeApprovedHTextFlow(11L, hLocale);\n      TransMemoryResultItem tm100 = tmResult(tmResultSource.getId(), 100);\n      TransMemoryResultItem tm90 = tmResult(tmResultSource.getId(), 90);\n      TransMemoryResultItem tm80 = tmResult(tmResultSource.getId(), 80);\n\n      when(getTransMemoryHandler.searchTransMemory(hLocale, new TransMemoryQuery(textFlow100TM.getContents(), FUZZY_PLURAL))).thenReturn(newArrayList(tm100));\n      when(getTransMemoryHandler.searchTransMemory(hLocale, new TransMemoryQuery(textFLow90TM.getContents(), FUZZY_PLURAL))).thenReturn(newArrayList(tm90));\n      when(getTransMemoryHandler.searchTransMemory(hLocale, new TransMemoryQuery(textFlow80TM.getContents(), FUZZY_PLURAL))).thenReturn(newArrayList(tm80));\n      when(getTransMemoryHandler.searchTransMemory(hLocale, new TransMemoryQuery(textFlowNoTM.getContents(), FUZZY_PLURAL))).thenReturn(Lists.<TransMemoryResultItem>newArrayList());\n\n\n      when(textFlowDAO.findById(tmResultSource.getId(), false)).thenReturn(tmResultSource);\n      // Given: tm detail of text flow id 11\n      when(getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale, tmResultSource)).thenReturn(tmDetail());\n\n      // When: execute the action\n      handler.execute(action, null);\n\n      // Then: we should have text flow auto translated by using the most similar TM\n      verify(updateTransUnitHandler).doTranslation(same(hLocale.getLocaleId()), same(workspace), updateRequestCaptor.capture(), same(action.getEditorClientId()), eq(TransUnitUpdated.UpdateType.TMMerge));\n      List<TransUnitUpdateRequest> updateRequest = updateRequestCaptor.getValue();\n      assertThat(updateRequest, Matchers.hasSize(2));\n      assertThat(updateRequest.get(0).getNewContents(), Matchers.equalTo(tm100.getTargetContents()));\n      assertThat(updateRequest.get(1).getNewContents(), Matchers.equalTo(tm90.getTargetContents()));\n   }","id":23782,"modified_method":"@Test\n   public void canHandleMultipleTextFlows() throws ActionException\n   {\n      // Given: an action with threshold 90% and trans unit id is 1, 2, 3, 4\n      final long idWith100MatchTM = 1L;\n      final long idWithoutTM = 2L;\n      final long idWith80MatchTM = 3L;\n      final long idWith90MatchTM = 4L;\n      TransMemoryMerge action = prepareActionAndMockSecurityService(90, idWith100MatchTM, idWithoutTM, idWith80MatchTM, idWith90MatchTM);\n\n      HTextFlow textFlow100TM = TestFixture.makeHTextFlow(idWith100MatchTM, hLocale, ContentState.New, \"pot/a.po\");\n      HTextFlow textFlowNoTM = TestFixture.makeHTextFlow(idWithoutTM, hLocale, ContentState.New, \"pot/a.po\");\n      HTextFlow textFlow80TM = TestFixture.makeHTextFlow(idWith80MatchTM, hLocale, ContentState.New, \"pot/a.po\");\n      HTextFlow textFLow90TM = TestFixture.makeHTextFlow(idWith90MatchTM, hLocale, ContentState.New, \"pot/a.po\");\n\n      when(textFlowDAO.findByIdList(newArrayList(idWith100MatchTM, idWithoutTM, idWith80MatchTM, idWith90MatchTM)))\n            .thenReturn(newArrayList(textFlow100TM, textFlowNoTM, textFlow80TM, textFLow90TM));\n      // Given: TM results\n      HTextFlow tmResultSource = TestFixture.makeApprovedHTextFlow(11L, hLocale);\n      TransMemoryResultItem tm100 = tmResult(tmResultSource.getId(), 100);\n      TransMemoryResultItem tm90 = tmResult(tmResultSource.getId(), 90);\n      TransMemoryResultItem tm80 = tmResult(tmResultSource.getId(), 80);\n\n      when(getTransMemoryHandler.searchTransMemory(hLocale, sourceLocale, new TransMemoryQuery(textFlow100TM.getContents(), FUZZY_PLURAL))).thenReturn(newArrayList(tm100));\n      when(getTransMemoryHandler.searchTransMemory(hLocale, sourceLocale, new TransMemoryQuery(textFLow90TM.getContents(), FUZZY_PLURAL))).thenReturn(newArrayList(tm90));\n      when(getTransMemoryHandler.searchTransMemory(hLocale, sourceLocale, new TransMemoryQuery(textFlow80TM.getContents(), FUZZY_PLURAL))).thenReturn(newArrayList(tm80));\n      when(getTransMemoryHandler.searchTransMemory(hLocale, sourceLocale, new TransMemoryQuery(textFlowNoTM.getContents(), FUZZY_PLURAL))).thenReturn(Lists.<TransMemoryResultItem>newArrayList());\n\n\n      when(textFlowDAO.findById(tmResultSource.getId(), false)).thenReturn(tmResultSource);\n      // Given: tm detail of text flow id 11\n      when(getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale, tmResultSource)).thenReturn(tmDetail());\n\n      // When: execute the action\n      handler.execute(action, null);\n\n      // Then: we should have text flow auto translated by using the most similar TM\n      verify(updateTransUnitHandler).doTranslation(same(hLocale.getLocaleId()), same(workspace), updateRequestCaptor.capture(), same(action.getEditorClientId()), eq(TransUnitUpdated.UpdateType.TMMerge));\n      List<TransUnitUpdateRequest> updateRequest = updateRequestCaptor.getValue();\n      assertThat(updateRequest, Matchers.hasSize(2));\n      assertThat(updateRequest.get(0).getNewContents(), Matchers.equalTo(tm100.getTargetContents()));\n      assertThat(updateRequest.get(1).getNewContents(), Matchers.equalTo(tm90.getTargetContents()));\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void willTranslateIfTargetIsNull() throws ActionException\n   {\n      // Given: text flow id 1 is not untranslated\n      final long transUnitId = 1L;\n      TransMemoryMerge action = prepareActionAndMockSecurityService(80, transUnitId);\n\n      HTextFlow hTextFlow = TestFixture.makeHTextFlow(transUnitId, hLocale, ContentState.New, \"pot/a.po\");\n      hTextFlow.getTargets().put(hLocale.getId(), null); //make sure target is null\n      when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(newArrayList(hTextFlow));\n      // Given: there is TM results returned for text flow id 1\n      HTextFlow tmResultSource = TestFixture.makeApprovedHTextFlow(11L, hLocale);\n      TransMemoryQuery tmQuery = new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n      TransMemoryResultItem tmResult = tmResult(tmResultSource.getId(), 100);\n      when(getTransMemoryHandler.searchTransMemory(hLocale, tmQuery))\n            .thenReturn(newArrayList(tmResult));\n      when(textFlowDAO.findById(tmResultSource.getId(), false)).thenReturn(tmResultSource);\n      // Given: tm detail of text flow id 11\n      when(getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale, tmResultSource)).thenReturn(tmDetail());\n\n      // When: execute the action\n      handler.execute(action, null);\n\n      // Then: we should have translation auto filled\n      verify(updateTransUnitHandler).doTranslation(same(hLocale.getLocaleId()), same(workspace), updateRequestCaptor.capture(), same(action.getEditorClientId()), eq(TransUnitUpdated.UpdateType.TMMerge));\n      List<TransUnitUpdateRequest> updateRequest = updateRequestCaptor.getValue();\n      assertThat(updateRequest, Matchers.hasSize(1));\n      assertThat(updateRequest.get(0).getNewContents(), Matchers.equalTo(tmResult.getTargetContents()));\n   }","id":23783,"modified_method":"@Test\n   public void willTranslateIfTargetIsNull() throws ActionException\n   {\n      // Given: text flow id 1 is not untranslated\n      final long transUnitId = 1L;\n      TransMemoryMerge action = prepareActionAndMockSecurityService(80, transUnitId);\n\n      HTextFlow hTextFlow = TestFixture.makeHTextFlow(transUnitId, hLocale, ContentState.New, \"pot/a.po\");\n      hTextFlow.getTargets().put(hLocale.getId(), null); //make sure target is null\n      when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(newArrayList(hTextFlow));\n      // Given: there is TM results returned for text flow id 1\n      HTextFlow tmResultSource = TestFixture.makeApprovedHTextFlow(11L, hLocale);\n      TransMemoryQuery tmQuery = new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n      TransMemoryResultItem tmResult = tmResult(tmResultSource.getId(), 100);\n      when(getTransMemoryHandler.searchTransMemory(hLocale, sourceLocale, tmQuery))\n            .thenReturn(newArrayList(tmResult));\n      when(textFlowDAO.findById(tmResultSource.getId(), false)).thenReturn(tmResultSource);\n      // Given: tm detail of text flow id 11\n      when(getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale, tmResultSource)).thenReturn(tmDetail());\n\n      // When: execute the action\n      handler.execute(action, null);\n\n      // Then: we should have translation auto filled\n      verify(updateTransUnitHandler).doTranslation(same(hLocale.getLocaleId()), same(workspace), updateRequestCaptor.capture(), same(action.getEditorClientId()), eq(TransUnitUpdated.UpdateType.TMMerge));\n      List<TransUnitUpdateRequest> updateRequest = updateRequestCaptor.getValue();\n      assertThat(updateRequest, Matchers.hasSize(1));\n      assertThat(updateRequest.get(0).getNewContents(), Matchers.equalTo(tmResult.getTargetContents()));\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void willNotTranslateIfNoTM() throws ActionException\n   {\n      // Given: an action with threshold 80% and trans unit id is 1\n      final long transUnitId = 1L;\n      TransMemoryMerge action = prepareActionAndMockSecurityService(80, transUnitId);\n\n      HTextFlow hTextFlow = TestFixture.makeHTextFlow(transUnitId, hLocale, ContentState.New, \"pot/a.po\");\n      when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(newArrayList(hTextFlow));\n      // Given: there is no TM results returned for text flow id 1\n      TransMemoryQuery tmQuery = new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n      when(getTransMemoryHandler.searchTransMemory(hLocale, tmQuery))\n            .thenReturn(Lists.<TransMemoryResultItem>newArrayList());\n\n      // When: execute the action\n      UpdateTransUnitResult result = handler.execute(action, null);\n\n      // Then: we should have EMPTY trans unit update request\n      verifyZeroInteractions(updateTransUnitHandler);\n      assertThat(result.getUpdateInfoList(), Matchers.<TransUnitUpdateInfo>empty());\n   }","id":23784,"modified_method":"@Test\n   public void willNotTranslateIfNoTM() throws ActionException\n   {\n      // Given: an action with threshold 80% and trans unit id is 1\n      final long transUnitId = 1L;\n      TransMemoryMerge action = prepareActionAndMockSecurityService(80, transUnitId);\n\n      HTextFlow hTextFlow = TestFixture.makeHTextFlow(transUnitId, hLocale, ContentState.New, \"pot/a.po\");\n      when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(newArrayList(hTextFlow));\n      // Given: there is no TM results returned for text flow id 1\n      TransMemoryQuery tmQuery = new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n      when(getTransMemoryHandler.searchTransMemory(hLocale, sourceLocale, tmQuery))\n            .thenReturn(Lists.<TransMemoryResultItem>newArrayList());\n\n      // When: execute the action\n      UpdateTransUnitResult result = handler.execute(action, null);\n\n      // Then: we should have EMPTY trans unit update request\n      verifyZeroInteractions(updateTransUnitHandler);\n      assertThat(result.getUpdateInfoList(), Matchers.<TransUnitUpdateInfo>empty());\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void createTMRequest(TransMemoryQuery query)\n   {\n      dataProvider.getList().clear();\n      display.startProcessing();\n      final GetTranslationMemory action = new GetTranslationMemory(query, userWorkspaceContext.getWorkspaceContext().getWorkspaceId().getLocaleId());\n      scheduleTMRequest(action);\n   }","id":23785,"modified_method":"private void createTMRequest(TransMemoryQuery query)\n   {\n      dataProvider.getList().clear();\n      display.startProcessing();\n      final GetTranslationMemory action = new GetTranslationMemory(query,\n            userWorkspaceContext.getWorkspaceContext().getWorkspaceId().getLocaleId(),\n            userWorkspaceContext.getSelectedDoc().getSourceLocale());\n      scheduleTMRequest(action);\n   }","commit_id":"a832884242579857b033802974f77f7d31a82527","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n\tpublic GetTranslationMemoryResult execute(GetTranslationMemory action,\n\t\t\tExecutionContext context) throws ActionException {\n\t\tFliesIdentity.instance().checkLoggedIn();\n\t\t\n\t\tlog.info(\"Fetching TM matches for {0}\", action.getQuery());\n\t\t\n\t\t\n\t\torg.hibernate.Query query = session.createQuery(\n\t\t\t\t\"from HTextFlow tf where lower(tf.content) like :q escape '\"+ESCAPE+\"'\")\n\t\t\t\t.setParameter(\"q\", wildcard(action.getQuery()));\n\t\t\n\t\t\n\t\tList<HTextFlow> textFlows = query \n\t\t\t\t.setMaxResults(MAX_RESULTS)\n\t\t\t\t.list();\n\t\tint size = textFlows.size();\n\t\t\n\t\tArrayList<TransMemory> results = new ArrayList<TransMemory>(size);\n\t\t\n\t\tfor(HTextFlow textFlow : textFlows) {\n\t\t\tHTextFlowTarget target = textFlow.getTargets().get(action.getLocaleId());\n\t\t\tif(target != null) {\n\t\t\t\t// filter by status Approved?\n//\t\t\t\ttu.setStatus( target.getState() );\n\t\t\t\tTransMemory memory = new TransMemory(\n\t\t\t\t\t\ttextFlow.getContent(), \n\t\t\t\t\t\ttarget.getContent(),\n\t\t\t\t\t\ttextFlow.getDocument().getDocId(),\n\t\t\t\t\t\t100);\n\t\t\t\tresults.add(memory);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new GetTranslationMemoryResult(results);\n\t}","id":23786,"modified_method":"@Override\n\tpublic GetTranslationMemoryResult execute(GetTranslationMemory action,\n\t\t\tExecutionContext context) throws ActionException {\n\t\tFliesIdentity.instance().checkLoggedIn();\n\t\t\n\t\tlog.info(\"Fetching {0} TM matches for \\\"{1}\\\"\", \n\t\t\t\taction.getFuzzy() ? \"fuzzy\" : \"exact\", \n\t\t\t\taction.getQuery());\n\t\t\n\t\tLocaleId localeID = action.getLocaleId();\n\t\tif (action.getFuzzy()) {\n\t\t\tList<HTextFlow> matches = findMatchingTextFlows(action.getQuery());\n\t\t\tArrayList<TransMemory> results = new ArrayList<TransMemory>(matches.size());\n\t\t\tfor (HTextFlow match : matches) {\n\t\t\t\tMap<LocaleId, HTextFlowTarget> matchTargets = match.getTargets();\n\t\t\t\tHTextFlowTarget target = matchTargets.get(localeID);\n\t\t\t\tif (target != null) {\n\t\t\t\t\tTransMemory mem = new TransMemory(\n\t\t\t\t\t\t\tmatch.getContent(), \n\t\t\t\t\t\t\ttarget.getContent(), \n\t\t\t\t\t\t\tmatch.getDocument().getDocId(), \n\t\t\t\t\t\t\t50); // FIXME get relevance score from Hibernate Search\n\t\t\t\t\tresults.add(mem);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new GetTranslationMemoryResult(results);\n\t\t} else {\n\t\t\t\n\t\t\t// TODO this should probably be based on the Hibernate Search approach for fuzzy search\n\t\t\t// TODO filter by status Approved and by locale\n\t\t\torg.hibernate.Query query = session.createQuery(\n\t\t\t\t\t\"from HTextFlow tf where lower(tf.content) like :q escape '\"+ESCAPE+\"'\")\n\t\t\t\t\t.setParameter(\"q\", wildcard(action.getQuery()));\n\t\t\t\n\t\t\t\n\t\t\tList<HTextFlow> textFlows = query \n\t\t\t\t\t.setMaxResults(MAX_RESULTS)\n\t\t\t\t\t.list();\n\t\t\tint size = textFlows.size();\n\t\t\t\n\t\t\tArrayList<TransMemory> results = new ArrayList<TransMemory>(size);\n\t\t\t\n\t\t\tfor(HTextFlow textFlow : textFlows) {\n\t\t\t\tHTextFlowTarget target = textFlow.getTargets().get(localeID);\n\t\t\t\tif(target != null) {\n\t\t\t\t\tTransMemory memory = new TransMemory(\n\t\t\t\t\t\t\ttextFlow.getContent(), \n\t\t\t\t\t\t\ttarget.getContent(),\n\t\t\t\t\t\t\ttextFlow.getDocument().getDocId(),\n\t\t\t\t\t\t\t100);\n\t\t\t\t\tresults.add(memory);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new GetTranslationMemoryResult(results);\n\t\t}\t\t\n\t}","commit_id":"f03f5278a63317a29f20676fb135b365276c3b5f","url":"https://github.com/zanata/zanata-server"},{"original_method":"private ArrayList<TransUnit> generateTransUnitSampleData(LocaleId localeId, int numRows, int start) {\n\t\tArrayList<TransUnit> units = new ArrayList<TransUnit>();\n\t\tfor(int i=start;i<start+numRows; i++) {\n\t\t\tTransUnit unit = new TransUnit( new TransUnitId(i+1), localeId, \"<hellow num=\\\"\" + (i+1) + \"\\\" />\", \"<world> \\\"\" + (i+1) +\"\\\"<\/world>\", ContentState.NeedReview);\n\t\t\tunits.add(unit);\n\t\t}\n\t\treturn units;\n\t}","id":23787,"modified_method":"private ArrayList<TransUnit> generateTransUnitSampleData(LocaleId localeId, int numRows, int start) {\n\t\tArrayList<TransUnit> units = new ArrayList<TransUnit>();\n\t\tfor(int i=start;i<start+numRows; i++) {\n\t\t\tTransUnit unit = new TransUnit( new TransUnitId(i+1), localeId, \"<hellow num=\\\"\" + (i+1) + \"\\\" />\", \"<world> \\\"\" + (i+1) +\"\\\"<\/world>\", ContentState.NeedReview, EditState.UnLock);\n\t\t\tunits.add(unit);\n\t\t}\n\t\treturn units;\n\t}","commit_id":"d42590f831cde9099aab21b6323ff2628d929068","url":"https://github.com/zanata/zanata-server"},{"original_method":"public EventRegistry() {\n\t\t\t\n\t\t\t// put any additional factories here\n\t\t\tfactories.put(TransUnitUpdated.class, new EventFactory<TransUnitUpdatedEvent>() {\n\t\t\t\t@Override\n\t\t\t\tpublic TransUnitUpdatedEvent create(SessionEvent<?> event) {\n\t\t\t\t\treturn new TransUnitUpdatedEvent(\n\t\t\t\t\t\t\t(HasTransUnitUpdatedData) event.getData(), event.getSequence());\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tfactories.put(ExitWorkspace.class, new EventFactory<ExitWorkspaceEvent>() {\n\t\t\t\t@Override\n\t\t\t\tpublic ExitWorkspaceEvent create(SessionEvent<?> event) {\n\t\t\t\t\treturn new ExitWorkspaceEvent(\n\t\t\t\t\t\t\t(HasExitWorkspaceData) event.getData(), event.getSequence());\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tfactories.put(EnterWorkspace.class, new EventFactory<EnterWorkspaceEvent>() {\n\t\t\t\t@Override\n\t\t\t\tpublic EnterWorkspaceEvent create(SessionEvent<?> event) {\n\t\t\t\t\treturn new EnterWorkspaceEvent(\n\t\t\t\t\t\t\t(HasEnterWorkspaceData) event.getData(), event.getSequence());\n\t\t\t\t}\n\t\t\t});\n\t\t}","id":23788,"modified_method":"public EventRegistry() {\n\t\t\t\n\t\t\t// put any additional factories here\n\t\t\tfactories.put(TransUnitUpdated.class, new EventFactory<TransUnitUpdatedEvent>() {\n\t\t\t\t@Override\n\t\t\t\tpublic TransUnitUpdatedEvent create(SessionEvent<?> event) {\n\t\t\t\t\treturn new TransUnitUpdatedEvent(\n\t\t\t\t\t\t\t(HasTransUnitUpdatedData) event.getData(), event.getSequence());\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tfactories.put(TransUnitEditing.class, new EventFactory<TransUnitEditEvent>() {\n\t\t\t\t@Override\n\t\t\t\tpublic TransUnitEditEvent create(SessionEvent<?> event) {\n\t\t\t\t\treturn new TransUnitEditEvent(\n\t\t\t\t\t\t\t(HasTransUnitEditData) event.getData(), event.getSequence());\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tfactories.put(ExitWorkspace.class, new EventFactory<ExitWorkspaceEvent>() {\n\t\t\t\t@Override\n\t\t\t\tpublic ExitWorkspaceEvent create(SessionEvent<?> event) {\n\t\t\t\t\treturn new ExitWorkspaceEvent(\n\t\t\t\t\t\t\t(HasExitWorkspaceData) event.getData(), event.getSequence());\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tfactories.put(EnterWorkspace.class, new EventFactory<EnterWorkspaceEvent>() {\n\t\t\t\t@Override\n\t\t\t\tpublic EnterWorkspaceEvent create(SessionEvent<?> event) {\n\t\t\t\t\treturn new EnterWorkspaceEvent(\n\t\t\t\t\t\t\t(HasEnterWorkspaceData) event.getData(), event.getSequence());\n\t\t\t\t}\n\t\t\t});\n\t\t}","commit_id":"d42590f831cde9099aab21b6323ff2628d929068","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n\tpublic GetTransUnitsResult execute(GetTransUnits action, ExecutionContext context)\n\t\t\tthrows ActionException {\n\n\t\tFliesIdentity.instance().checkLoggedIn();\n\t\t\n\t\tlog.info(\"Fetching Transunits for {0}\", action.getDocumentId());\n\t\t\n\t\tQuery query = session.createQuery(\n\t\t\t\"from HTextFlow tf where tf.document.id = :id\")\n\t\t\t.setParameter(\"id\", action.getDocumentId().getValue());\n\t\t\n\t\tint size = query.list().size();\n\t\t\n\t\tList<HTextFlow> textFlows = query \n\t\t\t\t.setFirstResult(action.getOffset())\n\t\t\t\t.setMaxResults(action.getCount())\n\t\t\t\t.list();\n\n\t\tArrayList<TransUnit> units = new ArrayList<TransUnit>();\n\t\tfor(HTextFlow textFlow : textFlows) {\n\t\t\tTransUnit tu = new TransUnit(new TransUnitId(textFlow.getId()), action.getLocaleId(), textFlow.getContent(), \"\", ContentState.New);\n\t\t\tHTextFlowTarget target = textFlow.getTargets().get(action.getLocaleId());\n\t\t\tif(target != null) {\n\t\t\t\ttu.setTarget(target.getContent());\n\t\t\t\ttu.setStatus( target.getState() );\n\t\t\t}\n\t\t\tunits.add(tu);\n\t\t}\n\n\t\treturn new GetTransUnitsResult(action.getDocumentId(), units, size );\n\t}","id":23789,"modified_method":"@Override\n\tpublic GetTransUnitsResult execute(GetTransUnits action, ExecutionContext context)\n\t\t\tthrows ActionException {\n\n\t\tFliesIdentity.instance().checkLoggedIn();\n\t\t\n\t\tlog.info(\"Fetching Transunits for {0}\", action.getDocumentId());\n\t\t\n\t\tQuery query = session.createQuery(\n\t\t\t\"from HTextFlow tf where tf.document.id = :id\")\n\t\t\t.setParameter(\"id\", action.getDocumentId().getValue());\n\t\t\n\t\tint size = query.list().size();\n\t\t\n\t\tList<HTextFlow> textFlows = query \n\t\t\t\t.setFirstResult(action.getOffset())\n\t\t\t\t.setMaxResults(action.getCount())\n\t\t\t\t.list();\n\t\t\n\t\t\n\t\t\n\t\tArrayList<TransUnit> units = new ArrayList<TransUnit>();\n\t\tfor(HTextFlow textFlow : textFlows) {\n\t\t\t\n\t\t\tTransUnitId tuId = new TransUnitId(textFlow.getId());\n\t\t\tTranslationWorkspace workspace = translationWorkspaceManager.getOrRegisterWorkspace(\n\t\t\t\t\ttextFlow.getDocument().getProject().getId(), action.getLocaleId() );\n\t\t\tif(!workspace.containTransUnit(tuId)) {\n\t\t\t\tworkspace.addTransUnit(tuId);\n\t\t\t}\n\t\t\tEditState editstate = workspace.getTransUnitStatus(tuId);\n\t\t\tTransUnit tu = new TransUnit(tuId, action.getLocaleId(), textFlow.getContent(), \"\", ContentState.New, editstate);\n\t\t\tHTextFlowTarget target = textFlow.getTargets().get(action.getLocaleId());\n\t\t\tif(target != null) {\n\t\t\t\ttu.setTarget(target.getContent());\n\t\t\t\ttu.setStatus( target.getState() );\n\t\t\t}\n\t\t\tunits.add(tu);\n\t\t}\n\n\t\treturn new GetTransUnitsResult(action.getDocumentId(), units, size );\n\t}","commit_id":"d42590f831cde9099aab21b6323ff2628d929068","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void addHandlers() {\n\t\tactionHandlerRegistry.addHandler( new GetTransUnitsHandler());\n\t\tactionHandlerRegistry.addHandler( new GetDocsListHandler());\n\t\tactionHandlerRegistry.addHandler(new ActivateWorkspaceHandler());\n\t\tactionHandlerRegistry.addHandler(new UpdateTransUnitHandler());\n\t\tactionHandlerRegistry.addHandler(new AuthenticateHandler());\n\t\tactionHandlerRegistry.addHandler(new EnsureLoggedInHandler());\n\t\tactionHandlerRegistry.addHandler(new GetStatusCountHandler());\n\t\tactionHandlerRegistry.addHandler(new GetProjectStatusCountHandler());\n\t\tactionHandlerRegistry.addHandler(new GetTranslatorListHandler());\n\t\tactionHandlerRegistry.addHandler(new GetEventsActionHandler());\n\t\tactionHandlerRegistry.addHandler(new GetGlossaryConceptHandler());\n\t\tactionHandlerRegistry.addHandler(new GetCommentsActionHandler());\n\t\tactionHandlerRegistry.addHandler(new ExitWorkspaceHandler());\n\t}","id":23790,"modified_method":"private void addHandlers() {\n\t\tactionHandlerRegistry.addHandler( new GetTransUnitsHandler());\n\t\tactionHandlerRegistry.addHandler( new GetDocsListHandler());\n\t\tactionHandlerRegistry.addHandler(new ActivateWorkspaceHandler());\n\t\tactionHandlerRegistry.addHandler(new UpdateTransUnitHandler());\n\t\tactionHandlerRegistry.addHandler(new AuthenticateHandler());\n\t\tactionHandlerRegistry.addHandler(new EnsureLoggedInHandler());\n\t\tactionHandlerRegistry.addHandler(new GetStatusCountHandler());\n\t\tactionHandlerRegistry.addHandler(new GetProjectStatusCountHandler());\n\t\tactionHandlerRegistry.addHandler(new GetTranslatorListHandler());\n\t\tactionHandlerRegistry.addHandler(new GetEventsActionHandler());\n\t\tactionHandlerRegistry.addHandler(new GetGlossaryConceptHandler());\n\t\tactionHandlerRegistry.addHandler(new GetCommentsActionHandler());\n\t\tactionHandlerRegistry.addHandler(new EditTransUnitHandler());\n\t\tactionHandlerRegistry.addHandler(new ExitWorkspaceHandler());\n\t}","commit_id":"d42590f831cde9099aab21b6323ff2628d929068","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n\tprotected void onBind() {\n\t\tdisplay.setTableModelHandler(tableModelHandler);\n\t\tdisplay.setPageSize(50);\n\t\tregisterHandler(display.getSelectionHandlers().addSelectionHandler(new SelectionHandler<TransUnit>() {\n\t\t\t@Override\n\t\t\tpublic void onSelection(SelectionEvent<TransUnit> event) {\n\t\t\t\tif(event.getSelectedItem() != currentSelection) {\n\t\t\t\t\tcurrentSelection = event.getSelectedItem();\n\t\t\t\t\teventBus.fireEvent(event);\n\t\t\t\t}\n\t\t\t\t//Send a START_EDIT event\n\t\t\t\t\n\t\t\t}\n\t\t}));\n\n\t\tregisterHandler(\n\t\t\t\teventBus.addHandler(DocumentSelectionEvent.getType(), new DocumentSelectionHandler() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onDocumentSelected(DocumentSelectionEvent event) {\n\t\t\t\t\t\tif(!event.getDocumentId().equals(documentId)) {\n\t\t\t\t\t\t\tdocumentId = event.getDocumentId();\n\t\t\t\t\t\t\tdisplay.getTableModel().clearCache();\n\t\t\t\t\t\t\tdisplay.getTableModel().setRowCount(TableModel.UNKNOWN_ROW_COUNT);\n\t\t\t\t\t\t\tdisplay.gotoPage(0, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\t\t\n\t\tregisterHandler(eventBus.addHandler(FilterEnabledEvent.getType(), new FilterEnabledEventHandler() {\n\t\t\t@Override\n\t\t\tpublic void onFilterEnabled(FilterEnabledEvent event) {\n\t\t\t\tdisplay.setContentFilter(event.getContentFilter());\n\t\t\t}\n\t\t}));\n\t\t\n\t\tregisterHandler(eventBus.addHandler(FilterDisabledEvent.getType(), new FilterDisabledEventHandler() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onFilterDisabled(FilterDisabledEvent event) {\n\t\t\t\tdisplay.clearContentFilter();\n\t\t\t}\n\t\t}));\n\t\t\n\t\tregisterHandler(eventBus.addHandler(TransUnitUpdatedEvent.getType(), new TransUnitUpdatedEventHandler() {\n\t\t\t@Override\n\t\t\tpublic void onTransUnitUpdated(TransUnitUpdatedEvent event) {\n\t\t\t\tif(documentId != null && documentId.equals(event.getDocumentId())) {\n\t\t\t\t\tif(currentSelection != null && currentSelection.getId().equals(event.getTransUnitId())) {\n\t\t\t\t\t\t// handle change in current selection\n\t\t\t\t\t\teventBus.fireEvent(new NotificationEvent(Severity.Warning, \"Someone else updated this translation unit. you're in trouble...\"));\n\t\t\t\t\t\t//display.getTableModel().setRowValue(row, rowValue);\n\t\t\t\t\t}\n\t\t\t\t\tdisplay.getTableModel().clearCache();\n\t\t\t\t\t// TODO add model with methods such as\n\t\t\t\t\t// getRowIndex(TransUnitId) \n\t\t\t\t\t// - add TU index to model\n\t\t\t\t\tdisplay.reloadPage();\n\t\t\t\t\t//dispatcher.execute(new GetTransUnits(documentId, localeId, page*pageSize+rowOffset, 1, count), callback)\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t\t\n\t\tdisplay.gotoFirstPage();\n\n\t}","id":23791,"modified_method":"@Override\n\tprotected void onBind() {\n\t\tdisplay.setTableModelHandler(tableModelHandler);\n\t\tdisplay.setPageSize(50);\n\t\tregisterHandler(display.getSelectionHandlers().addSelectionHandler(new SelectionHandler<TransUnit>() {\n\t\t\t@Override\n\t\t\tpublic void onSelection(SelectionEvent<TransUnit> event) {\n\t\t\t\tif(event.getSelectedItem() != currentSelection) {\n\t\t\t\t\tcurrentSelection = event.getSelectedItem();\n\t\t\t\t\t//Send a START_EDIT event\n\t\t\t\t\tdispatcher.execute(\n\t\t\t\t\t\t\tnew EditingTranslationAction(event.getSelectedItem().getId(), workspaceContext.getLocaleId(), EditState.Lock), \n\t\t\t\t\t\t\tnew AsyncCallback<EditingTranslationResult>() {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic void onFailure(Throwable caught) {\n\t\t\t\t\t\t\t\t\teventBus.fireEvent(new NotificationEvent(Severity.Error, \"Failed to Lock TransUnit\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic void onSuccess(EditingTranslationResult result) {\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\teventBus.fireEvent(event);\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\n\t\tregisterHandler(\n\t\t\t\teventBus.addHandler(DocumentSelectionEvent.getType(), new DocumentSelectionHandler() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onDocumentSelected(DocumentSelectionEvent event) {\n\t\t\t\t\t\tif(!event.getDocumentId().equals(documentId)) {\n\t\t\t\t\t\t\tdocumentId = event.getDocumentId();\n\t\t\t\t\t\t\tdisplay.getTableModel().clearCache();\n\t\t\t\t\t\t\tdisplay.getTableModel().setRowCount(TableModel.UNKNOWN_ROW_COUNT);\n\t\t\t\t\t\t\tdisplay.gotoPage(0, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\t\t\n\t\tregisterHandler(eventBus.addHandler(FilterEnabledEvent.getType(), new FilterEnabledEventHandler() {\n\t\t\t@Override\n\t\t\tpublic void onFilterEnabled(FilterEnabledEvent event) {\n\t\t\t\tdisplay.setContentFilter(event.getContentFilter());\n\t\t\t}\n\t\t}));\n\t\t\n\t\tregisterHandler(eventBus.addHandler(FilterDisabledEvent.getType(), new FilterDisabledEventHandler() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onFilterDisabled(FilterDisabledEvent event) {\n\t\t\t\tdisplay.clearContentFilter();\n\t\t\t}\n\t\t}));\n\t\t\n\t\tregisterHandler(eventBus.addHandler(TransUnitUpdatedEvent.getType(), new TransUnitUpdatedEventHandler() {\n\t\t\t@Override\n\t\t\tpublic void onTransUnitUpdated(TransUnitUpdatedEvent event) {\n\t\t\t\tif(documentId != null && documentId.equals(event.getDocumentId())) {\n\t\t\t\t\tif(currentSelection != null && currentSelection.getId().equals(event.getTransUnitId())) {\n\t\t\t\t\t\t// handle change in current selection\n\t\t\t\t\t\teventBus.fireEvent(new NotificationEvent(Severity.Warning, \"Someone else updated this translation unit. you're in trouble...\"));\n\t\t\t\t\t\t//display.getTableModel().setRowValue(row, rowValue);\n\t\t\t\t\t}\n\t\t\t\t\tdisplay.getTableModel().clearCache();\n\t\t\t\t\t// TODO add model with methods such as\n\t\t\t\t\t// getRowIndex(TransUnitId) \n\t\t\t\t\t// - add TU index to model\n\t\t\t\t\tdisplay.reloadPage();\n\t\t\t\t\t//dispatcher.execute(new GetTransUnits(documentId, localeId, page*pageSize+rowOffset, 1, count), callback)\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t\t\n\t\tregisterHandler(eventBus.addHandler(TransUnitEditEvent.getType(), new TransUnitEditEventHandler() {\n\t\t\t@Override\n\t\t\tpublic void onTransUnitEdit(TransUnitEditEvent event) {\n\t\t\t\tif(documentId != null && documentId.equals(event.getDocumentId())) {\n\t\t\t\t\tif(currentSelection != null && currentSelection.getId().equals(event.getTransUnitId())) {\n\t\t\t\t\t\t// handle change in current selection\n\t\t\t\t\t}\n\t\t\t\t\tdisplay.getTableModel().clearCache();\n\t\t\t\t\tdisplay.reloadPage();\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t\t\n\t\tdisplay.gotoFirstPage();\n\n\t}","commit_id":"d42590f831cde9099aab21b6323ff2628d929068","url":"https://github.com/zanata/zanata-server"},{"original_method":"public TransUnit(TransUnitId id, LocaleId localeId, String source, String target, ContentState status) {\n\t\tthis.id = id;\n\t\tthis.localeId = localeId;\n\t\tthis.source = source;\n\t\tthis.target = target;\n\t\tthis.status = status;\n\t}","id":23792,"modified_method":"public TransUnit(TransUnitId id, LocaleId localeId, String source, String target, ContentState status, EditState editstatus) {\n\t\tthis.id = id;\n\t\tthis.localeId = localeId;\n\t\tthis.source = source;\n\t\tthis.target = target;\n\t\tthis.status = status;\n\t\tthis.editstatus = editstatus;\n\t}","commit_id":"d42590f831cde9099aab21b6323ff2628d929068","url":"https://github.com/zanata/zanata-server"},{"original_method":"private static String getDigitPrefix(final String indexName) {\n    final StringBuilder builder = StringBuilderSpinAllocator.alloc();\n    try {\n      for (int i = 0; i < indexName.length(); i++) {\n        final char c = indexName.charAt(i);\n        if (Character.isDigit(c)) {\n          builder.append(c);\n        }\n        else {\n          break;\n        }\n      }\n      return builder.toString();\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(builder);\n    }\n  }","id":23793,"modified_method":"private static String getDigitPrefix(@NotNull String indexName) {\n    int i;\n    for (i = 0; i < indexName.length(); i++) {\n      final char c = indexName.charAt(i);\n      if (!Character.isDigit(c)) {\n        break;\n      }\n    }\n    return i == 0 ? \"\" : indexName.substring(0, i);\n  }","commit_id":"1298e515ab17b34e0b237701bb7d6847c17aa3cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int matchingDegree(@NotNull String name) {\n    FList<TextRange> iterable = matchingFragments(name);\n    if (iterable == null) return Integer.MIN_VALUE;\n    if (iterable.isEmpty()) return 0;\n\n    final TextRange first = iterable.getHead();\n\n    int matchingCase = 0;\n    int p = -1;\n\n    int integral = 0; // sum of matching-character-count * hump-index over all matched humps; favors longer fragments matching earlier words\n    int humpIndex = 1;\n    int nextHumpStart = 0;\n    for (TextRange range : iterable) {\n      for (int i = range.getStartOffset(); i < range.getEndOffset(); i++) {\n        boolean isHumpStart = false;\n        while (nextHumpStart <= i) {\n          if (nextHumpStart == i) {\n            isHumpStart = true;\n          }\n          nextHumpStart = NameUtil.nextWord(name, nextHumpStart);\n          if (first != range) {\n            humpIndex++;\n          }\n        }\n        integral += humpIndex;\n\n        char c = name.charAt(i);\n        p = StringUtil.indexOf(myPattern, c, p + 1, myPattern.length, false);\n        if (p < 0) {\n          break;\n        }\n\n        // favor uppercase letters matching hump start\n        if (c == myPattern[p]) {\n          matchingCase += isUpperCase[p] ? 50 : isHumpStart ? 1 : 0;\n        } else if (isHumpStart) {\n          // disfavor hump starts where pattern letter case doesn't match name case\n          matchingCase -= 20;\n        }\n      }\n    }\n\n    int startIndex = first.getStartOffset();\n    boolean afterSeparator = StringUtil.indexOfAny(name, HARD_SEPARATORS, 0, startIndex) >= 0;\n    boolean wordStart = startIndex == 0 || NameUtil.isWordStart(name, startIndex) && !NameUtil.isWordStart(name, startIndex - 1);\n\n    return (wordStart ? 1000 : 0) - integral * 10 + matchingCase + (afterSeparator ? 0 : 1);\n  }","id":23794,"modified_method":"public int matchingDegree(@NotNull String name) {\n    FList<TextRange> iterable = matchingFragments(name);\n    if (iterable == null) return Integer.MIN_VALUE;\n    if (iterable.isEmpty()) return 0;\n\n    final TextRange first = iterable.getHead();\n\n    int matchingCase = 0;\n    int p = -1;\n\n    int integral = 0; // sum of matching-character-count * hump-index over all matched humps; favors longer fragments matching earlier words\n    int humpIndex = 1;\n    int nextHumpStart = 0;\n    for (TextRange range : iterable) {\n      for (int i = range.getStartOffset(); i < range.getEndOffset(); i++) {\n        boolean isHumpStart = false;\n        while (nextHumpStart <= i) {\n          if (nextHumpStart == i) {\n            isHumpStart = true;\n          }\n          nextHumpStart = NameUtil.nextWord(name, nextHumpStart);\n          if (first != range) {\n            humpIndex++;\n          }\n        }\n        integral += humpIndex;\n\n        char c = name.charAt(i);\n        p = StringUtil.indexOf(myPattern, c, p + 1, myPattern.length, false);\n        if (p < 0) {\n          break;\n        }\n\n        // favor uppercase letters matching hump start\n        if (c == myPattern[p]) {\n          matchingCase += isUpperCase[p] ? 50 : isHumpStart ? 1 : 0;\n        } else if (isHumpStart) {\n          // disfavor hump starts where pattern letter case doesn't match name case\n          matchingCase -= 20;\n        }\n      }\n    }\n\n    int startIndex = first.getStartOffset();\n    boolean afterSeparator = StringUtil.indexOfAny(name, HARD_SEPARATORS, 0, startIndex) >= 0;\n    boolean wordStart = startIndex == 0 || isWordStart(name, startIndex) && !isWordStart(name, startIndex - 1);\n\n    return (wordStart ? 1000 : 0) - integral * 10 + matchingCase + (afterSeparator ? 0 : 1);\n  }","commit_id":"b2fe1b27d2036284227e5bb8485618685b87aca4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MinusculeMatcher(@NotNull String pattern, @NotNull NameUtil.MatchingCaseSensitivity options) {\n    myOptions = options;\n    myPattern = StringUtil.trimEnd(pattern, \"* \").toCharArray();\n    isLowerCase = new boolean[myPattern.length];\n    isUpperCase = new boolean[myPattern.length];\n    isWordSeparator = new boolean[myPattern.length];\n    toUpperCase = new char[myPattern.length];\n    toLowerCase = new char[myPattern.length];\n    for (int k = 0; k < myPattern.length; k++) {\n      char c = myPattern[k];\n      isLowerCase[k] = Character.isLowerCase(c);\n      isUpperCase[k] = Character.isUpperCase(c);\n      isWordSeparator[k] = isWordSeparator(c);\n      toUpperCase[k] = StringUtil.toUpperCase(c);\n      toLowerCase[k] = StringUtil.toLowerCase(c);\n    }\n    int i = 0;\n    while (isWildcard(i)) i++;\n    myHasHumps = hasFlag(i + 1, isUpperCase) && hasFlag(i, isLowerCase) || pattern.contains(\"+\");\n    myHasSeparators = hasFlag(i, isWordSeparator);\n    myHasDots = hasDots(i);\n    myHasWildCards = hasWildCards();\n  }","id":23795,"modified_method":"public MinusculeMatcher(@NotNull String pattern, @NotNull NameUtil.MatchingCaseSensitivity options) {\n    myOptions = options;\n    myPattern = StringUtil.trimEnd(pattern, \"* \").toCharArray();\n    isLowerCase = new boolean[myPattern.length];\n    isUpperCase = new boolean[myPattern.length];\n    isWordSeparator = new boolean[myPattern.length];\n    toUpperCase = new char[myPattern.length];\n    toLowerCase = new char[myPattern.length];\n    for (int k = 0; k < myPattern.length; k++) {\n      char c = myPattern[k];\n      isLowerCase[k] = Character.isLowerCase(c);\n      isUpperCase[k] = Character.isUpperCase(c);\n      isWordSeparator[k] = isWordSeparator(c);\n      toUpperCase[k] = StringUtil.toUpperCase(c);\n      toLowerCase[k] = StringUtil.toLowerCase(c);\n    }\n    int i = 0;\n    while (isWildcard(i)) i++;\n    myHasHumps = hasFlag(i + 1, isUpperCase) && hasFlag(i, isLowerCase);\n    myHasSeparators = hasFlag(i, isWordSeparator);\n    myHasDots = hasDots(i);\n    myHasWildCards = hasWildCards();\n  }","commit_id":"b2fe1b27d2036284227e5bb8485618685b87aca4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Enumerates places in name that could be matched by the pattern at patternIndex position\n   * and invokes {@link #matchFragment(String, int, int, com.intellij.psi.codeStyle.MinusculeMatcher.MatchingState)} at those candidate positions\n   */\n  @Nullable\n  private FList<TextRange> matchSkippingWords(@NotNull String name,\n                                              final int patternIndex,\n                                              int nameIndex,\n                                              boolean allowSpecialChars,\n                                              MatchingState matchingState) {\n    boolean star = isPatternChar(patternIndex - 1, '*');\n    final char p = myPattern[patternIndex];\n    while (true) {\n      int nextOccurrence = star ?\n                           indexOfIgnoreCase(name, nameIndex + 1, p, patternIndex, matchingState.isAsciiName) :\n                           indexOfWordStart(name, patternIndex, nameIndex, matchingState.isAsciiName);\n      if (nextOccurrence < 0) {\n        return null;\n      }\n      // pattern humps are allowed to match in words separated by \" ()\", lowercase characters aren't\n      if (!allowSpecialChars && !myHasSeparators && !myHasHumps && StringUtil.containsAnyChar(name, HARD_SEPARATORS, nameIndex, nextOccurrence)) {\n        return null;\n      }\n      // if the user has typed a dot, don't skip other dots between humps\n      if (!allowSpecialChars && myHasDots && StringUtil.contains(name, nameIndex, nextOccurrence, '.')) {\n        return null;\n      }\n      // uppercase should match either uppercase or a word start\n      if (!isUpperCase[patternIndex] ||\n          star && Character.isUpperCase(name.charAt(nextOccurrence)) ||\n          NameUtil.isWordStart(name, nextOccurrence)) {\n        FList<TextRange> ranges = matchFragment(name, patternIndex, nextOccurrence, matchingState);\n        if (ranges != null) {\n          return ranges;\n        }\n      }\n      nameIndex = nextOccurrence;\n    }\n  }","id":23796,"modified_method":"/**\n   * Enumerates places in name that could be matched by the pattern at patternIndex position\n   * and invokes {@link #matchFragment(String, int, int, com.intellij.psi.codeStyle.MinusculeMatcher.MatchingState)} at those candidate positions\n   */\n  @Nullable\n  private FList<TextRange> matchSkippingWords(@NotNull String name,\n                                              final int patternIndex,\n                                              int nameIndex,\n                                              boolean allowSpecialChars,\n                                              MatchingState matchingState) {\n    boolean star = isPatternChar(patternIndex - 1, '*');\n    final char p = myPattern[patternIndex];\n    while (true) {\n      int nextOccurrence = star ?\n                           indexOfIgnoreCase(name, nameIndex + 1, p, patternIndex, matchingState.isAsciiName) :\n                           indexOfWordStart(name, patternIndex, nameIndex, matchingState.isAsciiName);\n      if (nextOccurrence < 0) {\n        return null;\n      }\n      // pattern humps are allowed to match in words separated by \" ()\", lowercase characters aren't\n      if (!allowSpecialChars && !myHasSeparators && !myHasHumps && StringUtil.containsAnyChar(name, HARD_SEPARATORS, nameIndex, nextOccurrence)) {\n        return null;\n      }\n      // if the user has typed a dot, don't skip other dots between humps\n      if (!allowSpecialChars && myHasDots && StringUtil.contains(name, nameIndex, nextOccurrence, '.')) {\n        return null;\n      }\n      // uppercase should match either uppercase or a word start\n      if (!isUpperCase[patternIndex] ||\n          star && Character.isUpperCase(name.charAt(nextOccurrence)) ||\n          isWordStart(name, nextOccurrence)) {\n        FList<TextRange> ranges = matchFragment(name, patternIndex, nextOccurrence, matchingState);\n        if (ranges != null) {\n          return ranges;\n        }\n      }\n      nameIndex = nextOccurrence;\n    }\n  }","commit_id":"b2fe1b27d2036284227e5bb8485618685b87aca4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Attempts to match an alphanumeric sequence of pattern (starting at patternIndex)\n   * to some continuous substring of name, starting from nameIndex.\n   */\n  private FList<TextRange> doMatchFragments(String name,\n                                            int patternIndex,\n                                            int nameIndex,\n                                            MatchingState matchingState) {\n    if (!isFirstCharMatching(name, nameIndex, patternIndex)) {\n      return null;\n    }\n\n    // middle matches have to be at least of length 3, to prevent too many irrelevant matches\n    int minFragment = isPatternChar(patternIndex - 1, '*') && !isWildcard(patternIndex + 1) &&\n                      Character.isLetterOrDigit(name.charAt(nameIndex)) && !NameUtil.isWordStart(name, nameIndex)\n                      ? 3 : 1;\n    int i = 1;\n    boolean ignoreCase = myOptions != NameUtil.MatchingCaseSensitivity.ALL;\n    while (nameIndex + i < name.length() &&\n           patternIndex + i < myPattern.length &&\n           charEquals(myPattern[patternIndex+i], patternIndex+i, name.charAt(nameIndex + i), ignoreCase)) {\n      if (isUpperCase[patternIndex + i]) {\n        if (i < minFragment) {\n          return null;\n        }\n        // when an uppercase pattern letter matches lowercase name letter, try to find an uppercase (better) match further in the name\n        if (myPattern[patternIndex + i] != name.charAt(nameIndex + i)) {\n          int nextWordStart = indexOfWordStart(name, patternIndex + i, nameIndex + i, matchingState.isAsciiName);\n          FList<TextRange> ranges = matchWildcards(name, patternIndex + i, nextWordStart, matchingState);\n          if (ranges != null) {\n            return prependRange(ranges, nameIndex, i);\n          }\n          // at least three consecutive uppercase letters shouldn't match lowercase\n          if (myHasHumps && i > 1 && isUpperCase[patternIndex + i - 1] && isUpperCase[patternIndex + i - 2]) {\n            return null;\n          }\n        }\n      }\n      i++;\n    }\n\n    // we've found the longest fragment matching pattern and name\n\n    if (patternIndex + i >= myPattern.length) {\n      return FList.<TextRange>emptyList().prepend(TextRange.from(nameIndex, i));\n    }\n\n    // try to match the remainder of pattern with the remainder of name\n    // it may not succeed with the longest matching fragment, then try shorter matches\n    while (i >= minFragment) {\n      FList<TextRange> ranges = isWildcard(patternIndex + i) ?\n                                matchWildcards(name, patternIndex + i, nameIndex + i, matchingState) :\n                                matchSkippingWords(name, patternIndex + i, nameIndex + i, false, matchingState);\n      if (ranges != null) {\n        return prependRange(ranges, nameIndex, i);\n      }\n      i--;\n    }\n    return null;\n  }","id":23797,"modified_method":"/**\n   * Attempts to match an alphanumeric sequence of pattern (starting at patternIndex)\n   * to some continuous substring of name, starting from nameIndex.\n   */\n  private FList<TextRange> doMatchFragments(String name,\n                                            int patternIndex,\n                                            int nameIndex,\n                                            MatchingState matchingState) {\n    if (!isFirstCharMatching(name, nameIndex, patternIndex)) {\n      return null;\n    }\n\n    // middle matches have to be at least of length 3, to prevent too many irrelevant matches\n    int minFragment = isPatternChar(patternIndex - 1, '*') && !isWildcard(patternIndex + 1) &&\n                      Character.isLetterOrDigit(name.charAt(nameIndex)) && !isWordStart(name, nameIndex)\n                      ? 3 : 1;\n    int i = 1;\n    boolean ignoreCase = myOptions != NameUtil.MatchingCaseSensitivity.ALL;\n    while (nameIndex + i < name.length() &&\n           patternIndex + i < myPattern.length &&\n           charEquals(myPattern[patternIndex+i], patternIndex+i, name.charAt(nameIndex + i), ignoreCase)) {\n      if (isUpperCase[patternIndex + i]) {\n        if (i < minFragment) {\n          return null;\n        }\n        // when an uppercase pattern letter matches lowercase name letter, try to find an uppercase (better) match further in the name\n        if (myPattern[patternIndex + i] != name.charAt(nameIndex + i)) {\n          int nextWordStart = indexOfWordStart(name, patternIndex + i, nameIndex + i, matchingState.isAsciiName);\n          FList<TextRange> ranges = matchWildcards(name, patternIndex + i, nextWordStart, matchingState);\n          if (ranges != null) {\n            return prependRange(ranges, nameIndex, i);\n          }\n          // at least three consecutive uppercase letters shouldn't match lowercase\n          if (myHasHumps && i > 1 && isUpperCase[patternIndex + i - 1] && isUpperCase[patternIndex + i - 2]) {\n            return null;\n          }\n        }\n      }\n      i++;\n    }\n\n    // we've found the longest fragment matching pattern and name\n\n    if (patternIndex + i >= myPattern.length) {\n      return FList.<TextRange>emptyList().prepend(TextRange.from(nameIndex, i));\n    }\n\n    // try to match the remainder of pattern with the remainder of name\n    // it may not succeed with the longest matching fragment, then try shorter matches\n    while (i >= minFragment) {\n      FList<TextRange> ranges = isWildcard(patternIndex + i) ?\n                                matchWildcards(name, patternIndex + i, nameIndex + i, matchingState) :\n                                matchSkippingWords(name, patternIndex + i, nameIndex + i, false, matchingState);\n      if (ranges != null) {\n        return prependRange(ranges, nameIndex, i);\n      }\n      i--;\n    }\n    return null;\n  }","commit_id":"b2fe1b27d2036284227e5bb8485618685b87aca4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static ASTApply make(AST args[],Exec2 E, int x) {\n    // Make a type variable for this application\n    Type ts[] = new Type[args.length];\n    ts[0] = Type.unbound();\n    for( int i=1; i<ts.length; i++ )\n      ts[i] = args[i]._t.find();\n    Type ft1 = Type.fcn(ts);\n    AST fast = args[0];\n    Type ft2 = fast._t.find();  // Should be a function type\n    if( ft1.union(ft2) )        // Union 'em\n      return new ASTApply(args,x);\n    // Error handling\n    if( ft2.isNotFun() )      // Oops, failed basic sanity\n      E.throwErr(\"Function-parens following a \"+ft2,x);\n    if( ft2._ts.length != ts.length )\n      E.throwErr(\"Passed \"+(ts.length-1)+\" args but expected \"+(ft2._ts.length-1),x);\n    String vars[] = (fast instanceof ASTOp) ? ((ASTOp)fast)._vars : null;\n    for( int i=1; i<ts.length; i++ )\n      if( !ft2._ts[i].union(args[i]._t) )\n        E.throwErr(\"Arg \"+(vars==null?(\"#\"+i):(\"'\"+vars[i]+\"'\"))+\" typed as \"+ft2._ts[i]+\" but passed \"+args[i]._t.find(),x);\n    throw H2O.fail();\n  }","id":23798,"modified_method":"static ASTApply make(AST args[],Exec2 E, int x) {\n    // Make a type variable for this application\n    Type ts[] = new Type[args.length];\n    ts[0] = Type.unbound();\n    for( int i=1; i<ts.length; i++ )\n      ts[i] = args[i]._t.find();\n    Type ft1 = Type.fcn(ts);\n    AST fast = args[0];\n    Type ft2 = fast._t.find();  // Should be a function type\n    if( ft1.union(ft2) )        // Union 'em\n      return new ASTApply(args);\n    // Error handling\n    if( ft2.isNotFun() )      // Oops, failed basic sanity\n      E.throwErr(\"Function-parens following a \"+ft2,x);\n    if( ft2._ts.length != ts.length )\n      E.throwErr(\"Passed \"+(ts.length-1)+\" args but expected \"+(ft2._ts.length-1),x);\n    String vars[] = (fast instanceof ASTOp) ? ((ASTOp)fast)._vars : null;\n    for( int i=1; i<ts.length; i++ )\n      if( !ft2._ts[i].union(args[i]._t) )\n        E.throwErr(\"Arg \"+(vars==null?(\"#\"+i):(\"'\"+vars[i]+\"'\"))+\" typed as \"+ft2._ts[i]+\" but passed \"+args[i]._t.find(),x);\n    throw H2O.fail();\n  }","commit_id":"93b91b428f8178804f35c46bcd6403b4bc759f9a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public static void main (String[] args) {\n    // Unit tests for horrible Double.valueOf parsing hack.\n\n    {\n      String s = \"fooo1.23e+154\";\n      int i = 4;\n      MyInteger C = new MyInteger();\n      Double D = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      assert D.doubleValue() == 1.23e+154;\n      assert C._val == 9;\n      System.out.println (D);\n    }\n\n    {\n      String s = \"fooo1.23e+154blah\";\n      int i = 4;\n      MyInteger C = new MyInteger();\n      Double D = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      assert D.doubleValue() == 1.23e+154;\n      assert C._val == 9;\n      System.out.println (D);\n    }\n\n    {\n      String s = \"fooo1.23e14blah\";\n      int i = 4;\n      MyInteger C = new MyInteger();\n      Double D = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      assert D.doubleValue() == 1.23e14;\n      assert C._val == 7;\n      System.out.println (D);\n    }\n\n    {\n      String s = \"fooo1.23e\";\n      int i = 4;\n      MyInteger C = new MyInteger();\n      Double D = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      assert D == null;\n      assert C._val == 0;\n      System.out.println (D);\n    }\n\n    {\n      String s = \"fooo1.23E-10\";\n      int i = 4;\n      MyInteger C = new MyInteger();\n      Double D = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      assert D == 1.23E-10;\n      assert C._val == 8;\n      System.out.println (D);\n    }\n\n    {\n      String s = \"1.23E-10\";\n      int i = 0;\n      MyInteger C = new MyInteger();\n      Double D = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      assert D == 1.23E-10;\n      assert C._val == 8;\n      System.out.println (D);\n    }\n\n    {\n      String s = \"1.23E10E22\";\n      int i = 0;\n      MyInteger C = new MyInteger();\n      Double D = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      assert D == 1.23E10;\n      assert C._val == 7;\n      System.out.println (D);\n    }\n\n    {\n      String s = \"hex[( hex[,c(5)] <= 1.97872258214 ) & ( hex[,c(6)] <= 32.8571773789 ) & ( ( hex[,c(2)] <= 72.2154196079 )) ,]\";\n      int i = 20;\n      MyInteger C = new MyInteger();\n      Double D = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      System.out.println (D);\n      assert D == 1.97872258214;\n      assert C._val == 13;\n    }\n\n    {\n      String s = \"1    \";\n      int i = 0;\n      MyInteger C = new MyInteger();\n      Double D = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      System.out.println (D);\n      System.out.println (\"C._val is \" + C._val);\n      assert D == 1;\n      assert C._val == 1;\n    }\n  }","id":23799,"modified_method":"public static void main (String[] args) {\n    // Unit tests for horrible Double.valueOf parsing hack.\n\n    {\n      String s = \"fooo1.23e+154\";\n      int i = 4;\n      MyInteger C = new MyInteger();\n      double d = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      assert d == 1.23e+154;\n      assert C._val == 9;\n      System.out.println (d);\n    }\n\n    {\n      String s = \"fooo1.23e+154blah\";\n      int i = 4;\n      MyInteger C = new MyInteger();\n      double d = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      assert d == 1.23e+154;\n      assert C._val == 9;\n      System.out.println (d);\n    }\n\n    {\n      String s = \"fooo1.23e14blah\";\n      int i = 4;\n      MyInteger C = new MyInteger();\n      double d = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      assert d == 1.23e14;\n      assert C._val == 7;\n      System.out.println (d);\n    }\n\n    {\n      String s = \"fooo1.23e\";\n      int i = 4;\n      MyInteger C = new MyInteger();\n      double d = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      assert d == 0;\n      assert C._val == 0;\n      System.out.println (d);\n    }\n\n    {\n      String s = \"fooo1.23E-10\";\n      int i = 4;\n      MyInteger C = new MyInteger();\n      double d = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      assert d == 1.23E-10;\n      assert C._val == 8;\n      System.out.println (d);\n    }\n\n    {\n      String s = \"1.23E-10\";\n      int i = 0;\n      MyInteger C = new MyInteger();\n      double d = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      assert d == 1.23E-10;\n      assert C._val == 8;\n      System.out.println (d);\n    }\n\n    {\n      String s = \"1.23E10E22\";\n      int i = 0;\n      MyInteger C = new MyInteger();\n      double d = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      assert d == 1.23E10;\n      assert C._val == 7;\n      System.out.println (d);\n    }\n\n    {\n      String s = \"hex[( hex[,c(5)] <= 1.97872258214 ) & ( hex[,c(6)] <= 32.8571773789 ) & ( ( hex[,c(2)] <= 72.2154196079 )) ,]\";\n      int i = 20;\n      MyInteger C = new MyInteger();\n      double d = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      assert d == 1.97872258214;\n      assert C._val == 13;\n      System.out.println (d);\n    }\n\n    {\n      String s = \"1    \";\n      int i = 0;\n      MyInteger C = new MyInteger();\n      double d = parseNumberWithScientificNotationProperlyHandled(s, i, C);\n      assert d == 1;\n      assert C._val == 1;\n      System.out.println (d);\n    }\n  }","commit_id":"93b91b428f8178804f35c46bcd6403b4bc759f9a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n   * Parse a scientific number more correctly for commands passed in from R.\n   * Unfortunately, NumberFormat.parse doesn't get the job done.\n   * It expects 'E' and can't handle 'e' or 'E+nnn'.\n   *\n   * @param s String to parse\n   * @param startPosition Starting position in the string to parse from.\n   * @param charactersConsumed [output] Characters consumed.\n   * @return The parsed value if one was found, null otherwise.  If a value was parsed, charactersConsumed will be set to something greater than 0.  If no value was parsed, charactersConsumed will be 0.\n   */\n  static private Double parseNumberWithScientificNotationProperlyHandled (String s, final int startPosition, MyInteger charactersConsumed) {\n    charactersConsumed._val = 0;    // Paranoid.\n\n    ParsePosition pp = new ParsePosition(startPosition);\n    Number N = NF.parse(s, pp);\n\n    if ( pp.getIndex()==startPosition ) {\n      // If no number was found, just return null immediately.\n      return null;\n    }\n\n    assert N instanceof Double || N instanceof Long;\n\n    // Check if the number we just parsed had an 'e' or 'E' in it.  So it's scientific already.\n    for (int i = startPosition; i < pp.getIndex(); i++) {\n      char c = s.charAt(i);\n      if ((c == 'e') || (c == 'E')) {\n        // We already got a scientific number.  Return it.\n        charactersConsumed._val = pp.getIndex() - startPosition;\n        double d = (N instanceof Double) ? (double)(Double)N : (double)(Long)N;\n        return new Double(d);\n      }\n    }\n\n    // If we consumed all of str, then just return the value now.\n    assert (pp.getIndex() <= s.length());\n    if (pp.getIndex() >= s.length()) {\n      charactersConsumed._val = pp.getIndex() - startPosition;\n      double d = (N instanceof Double) ? (double)(Double)N : (double)(Long)N;\n      return new Double(d);\n    }\n\n    // If the lookahead character is not 'e' then just return the value now.\n    char lookaheadChar = s.charAt(pp.getIndex());\n    if ((lookaheadChar != 'e') && (lookaheadChar != 'E')) {\n      charactersConsumed._val = pp.getIndex() - startPosition;\n      double d = (N instanceof Double) ? (double)(Double)N : (double)(Long)N;\n      return new Double(d);\n    }\n\n    // The lookahead character is 'e'.  Find the remaining trailing numbers\n    // and attach them to this token.\n    // Start with sb as stuff from NF.parse plus the 'e'.\n    StringBuffer sb = new StringBuffer();\n    sb.append(s.substring(startPosition, pp.getIndex() + 1));\n    boolean first = true;\n    for (int i = pp.getIndex() + 1; i < s.length(); i++) {\n      char c = s.charAt(i);\n\n      // The first character after the 'e' might be a '+' or '-'.\n      if (first && ((c=='+') || (c=='-'))) {\n        sb.append(c);\n        first = false;\n        continue;\n      }\n      first = false;\n\n      // Only digits allowed after that.\n      if (Character.isDigit(c)) {\n        sb.append(c);\n      }\n      else {\n        break;\n      }\n    }\n\n    // Really parse the double now.  If we fail here, just bail out and don't\n    // consider it a number.\n    double d;\n    try {\n      d = Double.valueOf(sb.toString());\n    }\n    catch (Exception e) {\n      return null;\n    }\n\n    charactersConsumed._val = sb.length();\n    return new Double(d);\n  }","id":23800,"modified_method":"/**\n   * Parse a scientific number more correctly for commands passed in from R.\n   * Unfortunately, NumberFormat.parse doesn't get the job done.\n   * It expects 'E' and can't handle 'e' or 'E+nnn'.\n   *\n   * @param s String to parse\n   * @param startPosition Starting position in the string to parse from.\n   * @param charactersConsumed [output] Characters consumed.\n   * @return The parsed value if one was found, null otherwise.  If a value was parsed, charactersConsumed will be set to something greater than 0.  If no value was parsed, charactersConsumed will be 0.\n   */\n  static private double parseNumberWithScientificNotationProperlyHandled (String s, final int startPosition, MyInteger charactersConsumed) {\n    charactersConsumed._val = 0;    // Paranoid.\n    ParsePosition pp = new ParsePosition(startPosition);\n    Number N = NF.parse(s, pp);\n    if ( pp.getIndex()==startPosition ) // If no number was found, just return immediately.\n      return 0;\n    assert N instanceof Double || N instanceof Long;\n\n    // Check if the number we just parsed had an 'e' or 'E' in it.  So it's scientific already.\n    for (int i = startPosition; i < pp.getIndex(); i++) {\n      char c = s.charAt(i);\n      if ((c == 'e') || (c == 'E')) {\n        // We already got a scientific number.  Return it.\n        charactersConsumed._val = pp.getIndex() - startPosition;\n        if( N instanceof Double ) return (Double)N;\n        return (double)(Long)N;\n      }\n    }\n\n    // If we consumed all of str, then just return the value now.\n    assert (pp.getIndex() <= s.length());\n    if (pp.getIndex() >= s.length()) {\n      charactersConsumed._val = pp.getIndex() - startPosition;\n      if( N instanceof Double ) return (Double)N;\n      return (double)(Long)N;\n    }\n\n    // If the lookahead character is not 'e' then just return the value now.\n    char lookaheadChar = s.charAt(pp.getIndex());\n    if ((lookaheadChar != 'e') && (lookaheadChar != 'E')) {\n      charactersConsumed._val = pp.getIndex() - startPosition;\n      if( N instanceof Double ) return (Double)N;\n      return (double)(Long)N;\n    }\n\n    // The lookahead character is 'e'.  Find the remaining trailing numbers\n    // and attach them to this token.\n    // Start with sb as stuff from NF.parse plus the 'e'.\n    StringBuffer sb = new StringBuffer();\n    sb.append(s.substring(startPosition, Math.min(s.length(),pp.getIndex() + 2)));\n    for( int i = pp.getIndex() + 2; i < s.length(); i++ ) {\n      char c = s.charAt(i);\n      if( c!='+' && c!='-' && !Character.isDigit(c) ) // Only +-digits allowed after that.\n        break;\n      sb.append(c);\n    }\n\n    // Really parse the double now.  If we fail here, just bail out and don't\n    // consider it a number.\n    try {\n      double d = Double.valueOf(sb.toString());\n      charactersConsumed._val = sb.length(); // Set length consumed before return\n      return d;\n    }\n    catch (Exception e) {  return 0;   } // No set length; just return.\n  }","commit_id":"93b91b428f8178804f35c46bcd6403b4bc759f9a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"static ASTAssign parse(Exec2 E, AST ast) {\n    int x = E._x;\n    // Allow '=' and '<-' assignment\n    if( !E.peek('=') ) {\n      if( !(E.peek('<') && E.peek('-')) ) { E._x=x; return null; }\n    }\n    AST ast2=ast;\n    ASTSlice slice= null;\n    if( (ast instanceof ASTSlice) ) // Peek thru slice op\n      ast2 = (slice=(ASTSlice)ast)._ast;\n    // Must be a simple in-scope ID\n    if( !(ast2 instanceof ASTId) ) E.throwErr(\"Can only assign to ID (or slice)\",x);\n    AST eval = parseCXExpr(E);\n    if( eval == null ) E.throwErr(\"Missing RHS\",x);\n    ASTId id = (ASTId)ast2;\n    boolean partial = slice != null && (slice._cols != null || slice._rows != null);\n    if( partial ) {             // Partial slice assignment?\n      if( eval._t.isFcn() ) E.throwErr(\"Assigning a \"+eval._t+\" into '\"+id._id+\"' which is a \"+id._t,x);\n      if(  E.lexical_depth()> 0 ) throw H2O.unimpl(); // Must copy whole array locally, before updating the local copy\n    }\n\n    if( id._depth > 0 ) {       // Shadowing an outer scope?\n      // Inner-scope assignment to a new local\n      ast = id = extend_local(E,eval._t,id._id);\n    } else {                    // Overwriting same scope\n      if( E.lexical_depth()>0 ) { // Inner scope?\n        if( !ast._t.union(eval._t) ) // Disallow type changes in local scope in functions.\n          E.throwErr(\"Assigning a \"+eval._t+\" into '\"+id._id+\"' which is a \"+id._t,x);\n      } else {                  // Outer scope; can change type willy-nilly\n        if( !partial && !ast._t.union(eval._t) ) {\n          ArrayList<ASTId> vars = E._env.get(0);\n          ASTId id2 = new ASTId(eval._t,id._id,0,id._num);\n          vars.set(id2._num,id2);\n          ast = id2;\n        }\n      }\n    }\n\n    return new ASTAssign(ast,eval);\n  }","id":23801,"modified_method":"static ASTAssign parse(Exec2 E, AST ast) {\n    int x = E._x;\n    // Allow '=' and '<-' assignment\n    if( !E.peek('=') ) {\n      if( !(E.peek('<') && E.peek('-')) ) { E._x=x; return null; }\n    }\n    AST ast2=ast;\n    ASTSlice slice= null;\n    if( (ast instanceof ASTSlice) ) // Peek thru slice op\n      ast2 = (slice=(ASTSlice)ast)._ast;\n    // Must be a simple in-scope ID\n    if( !(ast2 instanceof ASTId) ) E.throwErr(\"Can only assign to ID (or slice)\",x);\n    ASTId id = (ASTId)ast2;\n    final AST eval = parseCXExpr(E);\n    if( eval == null ) E.throwErr(\"Missing RHS\",x);\n    boolean partial = slice != null && (slice._cols != null || slice._rows != null);\n    if( partial ) {             // Partial slice assignment?\n      if( eval._t.isFcn() ) E.throwErr(\"Assigning a \"+eval._t+\" into '\"+id._id+\"' which is a \"+id._t,x);\n      if(  E.lexical_depth()> 0 ) throw H2O.unimpl(); // Must copy whole array locally, before updating the local copy\n    }\n\n    if( id._depth > 0 ) {       // Shadowing an outer scope?\n      // Inner-scope assignment to a new local\n      ast = id = extend_local(E,eval._t,id._id);\n    } else {                    // Overwriting same scope\n      if( E.lexical_depth()>0 ) { // Inner scope?\n        if( !ast._t.union(eval._t) ) // Disallow type changes in local scope in functions.\n          E.throwErr(\"Assigning a \"+eval._t+\" into '\"+id._id+\"' which is a \"+id._t,x);\n      } else {                  // Outer scope; can change type willy-nilly\n        if( !partial && !ast._t.union(eval._t) ) {\n          ArrayList<ASTId> vars = E._env.get(0);\n          ASTId id2 = new ASTId(eval._t,id._id,0,id._num);\n          vars.set(id2._num,id2);\n          ast = id2;\n        }\n      }\n    }\n\n    return new ASTAssign(ast,eval);\n  }","commit_id":"93b91b428f8178804f35c46bcd6403b4bc759f9a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"static ASTNum parse(Exec2 E) {\n    int startPosition = E._x;\n    MyInteger charactersConsumed = new MyInteger();\n    Double D = parseNumberWithScientificNotationProperlyHandled(E._str, startPosition, charactersConsumed);\n    if( charactersConsumed._val == 0 ) return null;\n    E._x = startPosition + charactersConsumed._val;\n    return new ASTNum(D.doubleValue());\n  }","id":23802,"modified_method":"static ASTNum parse(Exec2 E) {\n    int startPosition = E._x;\n    MyInteger charactersConsumed = new MyInteger();\n    double d = parseNumberWithScientificNotationProperlyHandled(E._str, startPosition, charactersConsumed);\n    if( charactersConsumed._val == 0 ) return null;\n    E._x = startPosition + charactersConsumed._val;\n    return new ASTNum(d);\n  }","commit_id":"93b91b428f8178804f35c46bcd6403b4bc759f9a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private ASTApply( AST args[], int x ) { super(args[0]._t.ret());  _args = args;  }","id":23803,"modified_method":"private ASTApply( AST args[] ) { super(args[0]._t.ret());  _args = args;  }","commit_id":"93b91b428f8178804f35c46bcd6403b4bc759f9a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override void exec(Env env) {\n    _eval.exec(env);            // RHS before LHS (R eval order)\n    if( _lhs instanceof ASTId ) {\n      ASTId id = (ASTId)_lhs;\n      env.tos_into_slot(id._depth,id._num,id._id);\n      return;\n    }\n    // Peel apart a slice assignment\n    ASTSlice slice = (ASTSlice)_lhs;\n    ASTId id = (ASTId)slice._ast;\n    assert id._depth==0;        // Can only modify in the local scope.\n    // Simple assignment using the slice syntax\n    if( slice._rows==null & slice._cols==null ) {\n      env.tos_into_slot(id._depth,id._num,id._id);\n      return;\n    }\n    // Pull the LHS off the stack; do not lower the refcnt\n    Frame ary = env.frId(id._depth,id._num);\n    // Pull the RHS off the stack; do not lower the refcnt\n    Frame ary_rhs=null;  double d=Double.NaN;\n    if( env.isDbl() )\n      d = env.popDbl();\n    else\n      ary_rhs = env.peekAry();\n\n    // Typed as a double ==> the row & col selectors are simple constants\n    if( slice._t == Type.DBL ) { // Typed as a double?\n      assert ary_rhs==null;\n      long row = (long)((ASTNum)slice._rows)._d;\n      int  col = (int )((ASTNum)slice._cols)._d;\n      ary.vecs()[col].set(row,d);\n      env.push(d);\n      return;\n    }\n\n    // Execute the slice LHS selection operators\n    Object cols = ASTSlice.select(ary.numCols(),slice._cols,env);\n    Object rows = ASTSlice.select(ary.numRows(),slice._rows,env);\n\n    long[] cs1; long[] rs1;\n    if(cols != null && rows != null && (cs1 = (long[])cols).length == 1 && (rs1 = (long[])rows).length == 1) {\n      assert ary_rhs == null;\n        long row = rs1[0]-1;\n        int col = (int)cs1[0]-1;\n        if(col >= ary.numCols() || row >= ary.numRows())\n          throw H2O.unimpl();\n        if(ary.vecs()[col].isEnum())\n          throw new IllegalArgumentException(\"Currently can only set numeric columns\");\n        ary.vecs()[col].set(row,d);\n        env.push(d);\n        return;\n    }\n\n    // Partial row assignment?\n    if( rows != null ) {\n        throw H2O.unimpl();\n    }\n    assert cols != null; // all/all assignment uses simple-assignment\n\n    // Convert constant into a whole vec\n    if( ary_rhs == null )\n      ary_rhs = new Frame(ary.anyVec().makeCon(d));\n    // Make sure we either have 1 col (repeated) or exactly a matching count\n    long[] cs = (long[]) cols;  // Columns to act on\n    if( ary_rhs.numCols() != 1 &&\n        ary_rhs.numCols() != cs.length )\n      throw new IllegalArgumentException(\"Can only assign to a matching set of columns; trying to assign \"+ary_rhs.numCols()+\" cols over \"+cs.length+\" cols\");\n    // Replace the LHS cols with the RHS cols\n    Vec rvecs[] = ary_rhs.vecs();\n    Futures fs = null;\n    for( long i : cs ) {\n      int cidx = (int)i-1;      // Convert 1-based to 0-based\n      Vec rv = env.addRef(rvecs[rvecs.length==1?0:cidx]);\n      if( cidx == ary.numCols() ) ary.add(\"C\"+cidx,rv);\n      else env.subRef(ary.replace(cidx,rv),fs);\n    }\n    if( fs != null )  fs.blockForPending();\n\n    // After slicing, pop all expressions (cannot lower refcnt till after all uses)\n    int narg = 1;\n    if( rows!= null ) narg++;\n    if( cols!= null ) narg++;\n    env.poppush(narg,ary,null);\n  }","id":23804,"modified_method":"@Override void exec(Env env) {\n    _eval.exec(env);            // RHS before LHS (R eval order)\n    if( _lhs instanceof ASTId ) {\n      ASTId id = (ASTId)_lhs;\n      env.tos_into_slot(id._depth,id._num,id._id);\n      return;\n    }\n    // Peel apart a slice assignment\n    ASTSlice slice = (ASTSlice)_lhs;\n    ASTId id = (ASTId)slice._ast;\n    assert id._depth==0;        // Can only modify in the local scope.\n    // Simple assignment using the slice syntax\n    if( slice._rows==null & slice._cols==null ) {\n      env.tos_into_slot(id._depth,id._num,id._id);\n      return;\n    }\n    // Pull the LHS off the stack; do not lower the refcnt\n    Frame ary = env.frId(id._depth,id._num);\n    // Pull the RHS off the stack; do not lower the refcnt\n    Frame ary_rhs=null;  double d=Double.NaN;\n    if( env.isDbl() )\n      d = env.popDbl();\n    else\n      ary_rhs = env.peekAry();\n\n    // Typed as a double ==> the row & col selectors are simple constants\n    if( slice._t == Type.DBL ) { // Typed as a double?\n      assert ary_rhs==null;\n      long row = (long)((ASTNum)slice._rows)._d;\n      int  col = (int )((ASTNum)slice._cols)._d;\n      ary.vecs()[col].set(row,d);\n      env.push(d);\n      return;\n    }\n\n    // Execute the slice LHS selection operators\n    Object cols = ASTSlice.select(ary.numCols(),slice._cols,env);\n    Object rows = ASTSlice.select(ary.numRows(),slice._rows,env);\n\n    long[] cs1; long[] rs1;\n    if(cols != null && rows != null && (cs1 = (long[])cols).length == 1 && (rs1 = (long[])rows).length == 1) {\n      assert ary_rhs == null;\n        long row = rs1[0]-1;\n        int col = (int)cs1[0]-1;\n        if(col >= ary.numCols() || row >= ary.numRows())\n          throw H2O.unimpl();\n        if(ary.vecs()[col].isEnum())\n          throw new IllegalArgumentException(\"Currently can only set numeric columns\");\n        ary.vecs()[col].set(row,d);\n        env.push(d);\n        return;\n    }\n\n    // Partial row assignment?\n    if( rows != null ) {\n        throw H2O.unimpl();\n    }\n    assert cols != null; // all/all assignment uses simple-assignment\n\n    // Convert constant into a whole vec\n    if( ary_rhs == null )\n      ary_rhs = new Frame(ary.anyVec().makeCon(d));\n    // Make sure we either have 1 col (repeated) or exactly a matching count\n    long[] cs = (long[]) cols;  // Columns to act on\n    if( ary_rhs.numCols() != 1 &&\n        ary_rhs.numCols() != cs.length )\n      throw new IllegalArgumentException(\"Can only assign to a matching set of columns; trying to assign \"+ary_rhs.numCols()+\" cols over \"+cs.length+\" cols\");\n    // Replace the LHS cols with the RHS cols\n    Vec rvecs[] = ary_rhs.vecs();\n    Futures fs = null;\n    for( long i : cs ) {\n      int cidx = (int)i-1;      // Convert 1-based to 0-based\n      Vec rv = env.addRef(rvecs[rvecs.length==1?0:cidx]);\n      if( cidx == ary.numCols() ) ary.add(\"C\"+cidx,rv);\n      else fs = env.subRef(ary.replace(cidx,rv),fs);\n    }\n    if( fs != null )  fs.blockForPending();\n\n    // After slicing, pop all expressions (cannot lower refcnt till after all uses)\n    int narg = 1;\n    if( rows!= null ) narg++;\n    if( cols!= null ) narg++;\n    env.poppush(narg,ary,null);\n  }","commit_id":"93b91b428f8178804f35c46bcd6403b4bc759f9a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"static boolean isLetter2(char c) { \n    if( c=='.' || c==':' || c=='\\\\' ) return true;\n    return isDigit(c) || isLetter(c);\n  }","id":23805,"modified_method":"static boolean isLetter2(char c) { \n    return c=='.' || c==':' || c=='\\\\' || isDigit(c) || isLetter(c);\n  }","commit_id":"93b91b428f8178804f35c46bcd6403b4bc759f9a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public static Env exec( String str ) throws IllegalArgumentException {\n    // Preload the global environment from existing Frames\n    Env env = new Env();\n    ArrayList<ASTId> global = new ArrayList<ASTId>();\n    for( Value v : H2O.values() ) { // Add Frames to parser's namespace\n      Frame fr;\n      if( v.type()==TypeMap.VALUE_ARRAY ) fr = ValueArray.asFrame(v);\n      else if( v.type()==TypeMap.FRAME ) fr = (Frame)v.get();\n      else continue;\n      env.push(fr,v._key.toString());\n      global.add(new ASTId(Type.ARY,v._key.toString(),0,global.size()));\n    }\n\n    // Some global constants\n    global.add(new ASTId(Type.DBL,\"T\",0,global.size()));  env.push(1.0);\n    global.add(new ASTId(Type.DBL,\"F\",0,global.size()));  env.push(0.0);\n    global.add(new ASTId(Type.DBL,\"NA\",0,global.size()));  env.push(Double.NaN);\n    global.add(new ASTId(Type.DBL,\"Inf\",0,global.size())); env.push(Double.POSITIVE_INFINITY);\n\n    // Parse.  Type-errors get caught here and throw IAE\n    int argcnt = global.size();\n    Exec2 ex = new Exec2(str, global);\n    AST ast = ex.parse();\n\n    try {\n      env.push(global.size()-argcnt);   // Push space for temps\n      ast.exec(env);\n      env.postWrite();\n    } catch( RuntimeException t ) {\n      env.remove();\n      throw t;\n    }\n    return env;\n  }","id":23806,"modified_method":"public static Env exec( String str ) throws IllegalArgumentException {\n    // Preload the global environment from existing Frames\n    Env env = new Env();\n    ArrayList<ASTId> global = new ArrayList<ASTId>();\n    for( Value v : H2O.values() ) { // Add Frames to parser's namespace\n      Frame fr;\n      if( v.type()==TypeMap.VALUE_ARRAY ) fr = ValueArray.asFrame(v);\n      else if( v.type()==TypeMap.FRAME  ) fr = v.get();\n      else continue;\n      env.push(fr,v._key.toString());\n      global.add(new ASTId(Type.ARY,v._key.toString(),0,global.size()));\n    }\n\n    // Some global constants\n    global.add(new ASTId(Type.DBL,\"T\",0,global.size()));  env.push(1.0);\n    global.add(new ASTId(Type.DBL,\"F\",0,global.size()));  env.push(0.0);\n    global.add(new ASTId(Type.DBL,\"NA\",0,global.size()));  env.push(Double.NaN);\n    global.add(new ASTId(Type.DBL,\"Inf\",0,global.size())); env.push(Double.POSITIVE_INFINITY);\n\n    // Parse.  Type-errors get caught here and throw IAE\n    int argcnt = global.size();\n    Exec2 ex = new Exec2(str, global);\n    AST ast = ex.parse();\n\n    try {\n      env.push(global.size()-argcnt);   // Push space for temps\n      ast.exec(env);\n      env.postWrite();\n    } catch( RuntimeException t ) {\n      env.remove();\n      throw t;\n    }\n    return env;\n  }","commit_id":"93b91b428f8178804f35c46bcd6403b4bc759f9a","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public GridCaptionPanel(final GuiEditor editor, final boolean isRow) {\n    myEditor = editor;\n    myIsRow = isRow;\n    mySelectionModel.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n    setBackground(Color.LIGHT_GRAY);\n    editor.addComponentSelectionListener(this);\n\n    addMouseListener(new MyMouseListener());\n  }","id":23807,"modified_method":"public GridCaptionPanel(final GuiEditor editor, final boolean isRow) {\n    myEditor = editor;\n    myIsRow = isRow;\n    mySelectionModel.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n    setBackground(Color.LIGHT_GRAY);\n    editor.addComponentSelectionListener(this);\n\n    final MyMouseListener listener = new MyMouseListener();\n    addMouseListener(listener);\n    addMouseMotionListener(listener);\n  }","commit_id":"c0ba963b167c4b462833cba50a2d7621ed7f678a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void selectedComponentChanged(GuiEditor source) {\n    RadContainer container = getSelectedGridContainer();\n    if (container != myLastContainer) {\n      myLastContainer = container;\n      mySelectionModel.clearSelection();\n    }\n    repaint();\n  }","id":23808,"modified_method":"public void selectedComponentChanged(GuiEditor source) {\n    RadContainer container = getSelectedGridContainer();\n    if (container != mySelectedContainer) {\n      mySelectedContainer = container;\n      mySelectionModel.clearSelection();\n    }\n    repaint();\n  }","commit_id":"c0ba963b167c4b462833cba50a2d7621ed7f678a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override public void mouseClicked(MouseEvent e) {\n      RadContainer container = getSelectedGridContainer();\n      if (container == null) return;\n      GridLayoutManager layout = (GridLayoutManager) container.getLayout();\n      Point pnt = SwingUtilities.convertPoint(GridCaptionPanel.this, e.getPoint(), container.getDelegee());\n      int cell = myIsRow ? layout.getRowAt(pnt.y) : layout.getColumnAt(pnt.x);\n      if ((e.getModifiers() & MouseEvent.CTRL_MASK) != 0) {\n        mySelectionModel.addSelectionInterval(cell, cell);\n      }\n      else if ((e.getModifiers() & MouseEvent.SHIFT_MASK) != 0) {\n        mySelectionModel.addSelectionInterval(mySelectionModel.getAnchorSelectionIndex(), cell);\n      }\n      else {\n        mySelectionModel.setSelectionInterval(cell, cell);\n      }\n      /*\n      for(RadComponent component: container.getComponents()) {\n        GridConstraints c = component.getConstraints();\n        if (cell >= c.getCell(myIsRow) && cell < c.getCell(myIsRow) + c.getSpan(myIsRow)) {\n          component.setSelected(true);\n        }\n      }\n      */\n      repaint();\n    }","id":23809,"modified_method":"@Override public void mouseClicked(MouseEvent e) {\n      int cell = getCellAt(e.getPoint());\n      if (cell == -1) return;\n      if ((e.getModifiers() & MouseEvent.CTRL_MASK) != 0) {\n        mySelectionModel.addSelectionInterval(cell, cell);\n      }\n      else if ((e.getModifiers() & MouseEvent.SHIFT_MASK) != 0) {\n        mySelectionModel.addSelectionInterval(mySelectionModel.getAnchorSelectionIndex(), cell);\n      }\n      else {\n        mySelectionModel.setSelectionInterval(cell, cell);\n      }\n      /*\n      for(RadComponent component: container.getComponents()) {\n        GridConstraints c = component.getConstraints();\n        if (cell >= c.getCell(myIsRow) && cell < c.getCell(myIsRow) + c.getSpan(myIsRow)) {\n          component.setSelected(true);\n        }\n      }\n      */\n      repaint();\n    }","commit_id":"c0ba963b167c4b462833cba50a2d7621ed7f678a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable private RadContainer getSelectedGridContainer() {\n    final ArrayList<RadComponent> selection = FormEditingUtil.getSelectedComponents(myEditor);\n    RadContainer container = GuiEditorUtil.getSelectionParent(selection);\n    if (container == null && myEditor.getRootContainer().getComponentCount() > 0) {\n      container = (RadContainer)myEditor.getRootContainer().getComponent(0);\n    }\n    if (container != null && !container.isGrid()) {\n      return null;\n    }\n    return container;\n  }","id":23810,"modified_method":"@Nullable private RadContainer getSelectedGridContainer() {\n    final ArrayList<RadComponent> selection = FormEditingUtil.getSelectedComponents(myEditor);\n    RadContainer container = GuiEditorUtil.getSelectionParent(selection);\n    if (container == null && myEditor.getRootContainer().getComponentCount() > 0) {\n      container = (RadContainer)myEditor.getRootContainer().getComponent(0);\n    }\n    if (container != null && !container.isGrid() && selection.size() == 1 &&\n        selection.get(0) instanceof RadContainer) {\n      container = (RadContainer) selection.get(0);\n    }\n    if (container != null && !container.isGrid()) {\n      return null;\n    }\n    return container;\n  }","commit_id":"c0ba963b167c4b462833cba50a2d7621ed7f678a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override public void mouseReleased(MouseEvent e) {\n      RadContainer container = getSelectedGridContainer();\n      if (container == null) return;\n      GridLayoutManager layout = (GridLayoutManager) container.getLayout();\n      Point pnt = SwingUtilities.convertPoint(GridCaptionPanel.this, e.getPoint(), container.getDelegee());\n      int cell = myIsRow ? layout.getRowAt(pnt.y) : layout.getColumnAt(pnt.x);\n\n      if (e.isPopupTrigger()) {\n        GridChangeActionGroup group = new GridChangeActionGroup(myEditor, container, cell,\n                                                                myIsRow ? SwingConstants.VERTICAL : SwingConstants.HORIZONTAL);\n        final ActionPopupMenu popupMenu = ActionManager.getInstance().createActionPopupMenu(ActionPlaces.UNKNOWN, group);\n        popupMenu.getComponent().show(GridCaptionPanel.this, e.getX(), e.getY());\n      }\n    }","id":23811,"modified_method":"@Override public void mouseReleased(MouseEvent e) {\n      setCursor(Cursor.getDefaultCursor());\n      myEditor.getActiveDecorationLayer().removeFeedback();\n\n      if (myResizeLine >= 0) {\n        Point pnt = SwingUtilities.convertPoint(GridCaptionPanel.this, e.getPoint(),\n                                                mySelectedContainer.getDelegee());\n        doResize(pnt);\n        myResizeLine = -1;\n      }\n\n      int cell = getCellAt(e.getPoint());\n\n      if (cell >= 0 && e.isPopupTrigger()) {\n        GridChangeActionGroup group = new GridChangeActionGroup(myEditor, mySelectedContainer, cell,\n                                                                myIsRow ? SwingConstants.VERTICAL : SwingConstants.HORIZONTAL);\n        final ActionPopupMenu popupMenu = ActionManager.getInstance().createActionPopupMenu(ActionPlaces.UNKNOWN, group);\n        popupMenu.getComponent().show(GridCaptionPanel.this, e.getX(), e.getY());\n      }\n    }","commit_id":"c0ba963b167c4b462833cba50a2d7621ed7f678a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void mouseUp(MouseEvent event, EditableArea area) throws Exception {\n    if (myTracker != null) {\n      myTracker.mouseUp(event, area);\n    }\n    super.mouseUp(event, area);\n    if (event.isPopupTrigger()) {\n      ActionManager actionManager = ActionManager.getInstance();\n      ActionPopupMenu popupMenu = actionManager.createActionPopupMenu(area.getPopupPlace(), area.getPopupActions());\n      popupMenu.getComponent().show(area.getNativeComponent(), event.getX(), event.getY());\n    }\n  }","id":23812,"modified_method":"@Override\n  public void mouseUp(MouseEvent event, EditableArea area) throws Exception {\n    if (myTracker != null) {\n      myTracker.mouseUp(event, area);\n    }\n    super.mouseUp(event, area);\n    if (event.isPopupTrigger() || (SystemInfo.isMac && event.getButton() == MouseEvent.BUTTON3)) {\n      ActionManager actionManager = ActionManager.getInstance();\n      ActionPopupMenu popupMenu = actionManager.createActionPopupMenu(area.getPopupPlace(), area.getPopupActions());\n      popupMenu.getComponent().show(area.getNativeComponent(), event.getX(), event.getY());\n    }\n  }","commit_id":"01c6518c46ef9fdd152b82706a29bd9e2edf845a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @return <code>true<\/code> if and only if the passed event is already dispatched by the\n   *         <code>IdeMouseEventDispatcher<\/code> and there is no need for any other processing of the event.\n   *         If the method returns <code>false<\/code> then it means that the event should be delivered\n   *         to normal event dispatching.\n   */\n  public boolean dispatchMouseEvent(MouseEvent e) {\n    Component c = e.getComponent();\n\n    //frame activation by mouse click\n    if (e.getID() == MOUSE_PRESSED && c instanceof IdeFrame && !c.hasFocus()) {\n      IdeFocusManager focusManager = IdeFocusManager.getGlobalInstance();\n      if (focusManager instanceof FocusManagerImpl) {\n        Component at = SwingUtilities.getDeepestComponentAt(c, e.getX(), e.getY());\n        if (at != null && at.isFocusable()) {\n          ((FocusManagerImpl)focusManager).setLastFocusedAtDeactivation((IdeFrame)c, at);\n        }\n      }\n    }\n\n    if (SystemInfo.isXWindow && e.isPopupTrigger() && e.getButton() != 3) {\n      // we can do better than silly triggering popup on everything but left click\n      resetPopupTrigger(e);\n    }\n\n    boolean ignore = false;\n    if (!(e.getID() == MouseEvent.MOUSE_PRESSED ||\n          e.getID() == MouseEvent.MOUSE_RELEASED ||\n          e.getID() == MOUSE_WHEEL && 0 < e.getModifiersEx() ||\n          e.getID() == MOUSE_CLICKED)) {\n      ignore = true;\n    }\n\n    patchClickCount(e);\n\n    int clickCount = e.getClickCount();\n    int button = MouseShortcut.getButton(e);\n    if (button == MouseShortcut.BUTTON_WHEEL_UP || button == MouseShortcut.BUTTON_WHEEL_DOWN) {\n      clickCount = 1;\n    }\n\n    if (e.isConsumed()\n        || e.isPopupTrigger()\n        || (button > 3 ? e.getID() != MOUSE_PRESSED && e.getID() != MOUSE_WHEEL : e.getID() != MOUSE_RELEASED)\n        || clickCount < 1\n        || button == NOBUTTON) { // See #16995. It did happen\n      ignore = true;\n    }\n\n    @JdkConstants.InputEventMask\n    int modifiers = e.getModifiers();\n    @JdkConstants.InputEventMask\n    int modifiersEx = e.getModifiersEx();\n    if (e.getID() == MOUSE_PRESSED) {\n      myPressedModifiersStored = true;\n      myModifiers = modifiers;\n      myModifiersEx = modifiersEx;\n    }\n    else if (e.getID() == MOUSE_RELEASED) {\n      myForceTouchIsAllowed = true;\n      if (myPressedModifiersStored) {\n        myPressedModifiersStored = false;\n        modifiers = myModifiers;\n        modifiersEx = myModifiersEx;\n      }\n    }\n\n    final JRootPane root = findRoot(e);\n    if (root != null) {\n      BlockState blockState = myRootPane2BlockedId.get(root);\n      if (blockState != null) {\n        if (SWING_EVENTS_PRIORITY.indexOf(blockState.currentEventId) < SWING_EVENTS_PRIORITY.indexOf(e.getID())) {\n          blockState.currentEventId = e.getID();\n          if (blockState.blockMode == IdeEventQueue.BlockMode.COMPLETE) {\n            return true;\n          }\n          else {\n            ignore = true;\n          }\n        } else {\n          myRootPane2BlockedId.remove(root);\n        }\n      }\n    }\n\n    if (c == null) {\n      throw new IllegalStateException(\"component cannot be null\");\n    }\n    c = SwingUtilities.getDeepestComponentAt(c, e.getX(), e.getY());\n\n    if (c instanceof IdeGlassPaneImpl) {\n      c = ((IdeGlassPaneImpl)c).getTargetComponentFor(e);\n    }\n\n    if (c == null) { // do nothing if component doesn't contains specified point\n      return false;\n    }\n\n    if (c instanceof MouseShortcutPanel || c.getParent() instanceof MouseShortcutPanel) {\n      return false; // forward mouse processing to the special shortcut panel\n    }\n\n    if (isHorizontalScrolling(c, e)) {\n      boolean done = doHorizontalScrolling(c, (MouseWheelEvent)e);\n      if (done) return true;\n    }\n\n    if (ignore) return false;\n\n    // avoid \"cyclic component initialization error\" in case of dialogs shown because of component initialization failure\n    if (!KeymapManagerImpl.ourKeymapManagerInitialized) {\n      return false;\n    }\n\n    final MouseShortcut shortcut = new MouseShortcut(button, modifiersEx, clickCount);\n    fillActionsList(c, shortcut, IdeKeyEventDispatcher.isModalContext(c));\n    ActionManagerEx actionManager = ActionManagerEx.getInstanceEx();\n    if (actionManager != null) {\n      AnAction[] actions = myActions.toArray(new AnAction[myActions.size()]);\n      for (AnAction action : actions) {\n        DataContext dataContext = DataManager.getInstance().getDataContext(c);\n        Presentation presentation = myPresentationFactory.getPresentation(action);\n        AnActionEvent actionEvent = new AnActionEvent(e, dataContext, ActionPlaces.MAIN_MENU, presentation,\n                                                      ActionManager.getInstance(),\n                                                      modifiers);\n        action.beforeActionPerformedUpdate(actionEvent);\n\n        if (presentation.isEnabled()) {\n          actionManager.fireBeforeActionPerformed(action, dataContext, actionEvent);\n          final Component context = PlatformDataKeys.CONTEXT_COMPONENT.getData(dataContext);\n\n          if (context != null && !context.isShowing()) continue;\n\n          action.actionPerformed(actionEvent);\n          e.consume();\n        }\n      }\n    }\n    return e.getButton() > 3;\n  }","id":23813,"modified_method":"/**\n   * @return <code>true<\/code> if and only if the passed event is already dispatched by the\n   *         <code>IdeMouseEventDispatcher<\/code> and there is no need for any other processing of the event.\n   *         If the method returns <code>false<\/code> then it means that the event should be delivered\n   *         to normal event dispatching.\n   */\n  public boolean dispatchMouseEvent(MouseEvent e) {\n    Component c = e.getComponent();\n\n    //frame activation by mouse click\n    if (e.getID() == MOUSE_PRESSED && c instanceof IdeFrame && !c.hasFocus()) {\n      IdeFocusManager focusManager = IdeFocusManager.getGlobalInstance();\n      if (focusManager instanceof FocusManagerImpl) {\n        Component at = SwingUtilities.getDeepestComponentAt(c, e.getX(), e.getY());\n        if (at != null && at.isFocusable()) {\n          ((FocusManagerImpl)focusManager).setLastFocusedAtDeactivation((IdeFrame)c, at);\n        }\n      }\n    }\n\n    if (e.isPopupTrigger()) {\n      if (BUTTON3 == e.getButton()) {\n        if (Registry.is(\"ide.mouse.popup.trigger.modifiers.disabled\") && (~BUTTON3_DOWN_MASK & e.getModifiersEx()) != 0) {\n          // it allows to use our mouse shortcuts for Ctrl+Button3, for example\n          resetPopupTrigger(e);\n        }\n      }\n      else if (SystemInfo.isXWindow) {\n        // we can do better than silly triggering popup on everything but left click\n        resetPopupTrigger(e);\n      }\n    }\n\n    boolean ignore = false;\n    if (!(e.getID() == MOUSE_PRESSED ||\n          e.getID() == MOUSE_RELEASED ||\n          e.getID() == MOUSE_WHEEL && 0 < e.getModifiersEx() ||\n          e.getID() == MOUSE_CLICKED)) {\n      ignore = true;\n    }\n\n    patchClickCount(e);\n\n    int clickCount = e.getClickCount();\n    int button = MouseShortcut.getButton(e);\n    if (button == MouseShortcut.BUTTON_WHEEL_UP || button == MouseShortcut.BUTTON_WHEEL_DOWN) {\n      clickCount = 1;\n    }\n\n    if (e.isConsumed()\n        || e.isPopupTrigger()\n        || (button > 3 ? e.getID() != MOUSE_PRESSED && e.getID() != MOUSE_WHEEL : e.getID() != MOUSE_RELEASED)\n        || clickCount < 1\n        || button == NOBUTTON) { // See #16995. It did happen\n      ignore = true;\n    }\n\n    @JdkConstants.InputEventMask\n    int modifiers = e.getModifiers();\n    @JdkConstants.InputEventMask\n    int modifiersEx = e.getModifiersEx();\n    if (e.getID() == MOUSE_PRESSED) {\n      myPressedModifiersStored = true;\n      myModifiers = modifiers;\n      myModifiersEx = modifiersEx;\n    }\n    else if (e.getID() == MOUSE_RELEASED) {\n      myForceTouchIsAllowed = true;\n      if (myPressedModifiersStored) {\n        myPressedModifiersStored = false;\n        modifiers = myModifiers;\n        modifiersEx = myModifiersEx;\n      }\n    }\n\n    final JRootPane root = findRoot(e);\n    if (root != null) {\n      BlockState blockState = myRootPane2BlockedId.get(root);\n      if (blockState != null) {\n        if (SWING_EVENTS_PRIORITY.indexOf(blockState.currentEventId) < SWING_EVENTS_PRIORITY.indexOf(e.getID())) {\n          blockState.currentEventId = e.getID();\n          if (blockState.blockMode == IdeEventQueue.BlockMode.COMPLETE) {\n            return true;\n          }\n          else {\n            ignore = true;\n          }\n        } else {\n          myRootPane2BlockedId.remove(root);\n        }\n      }\n    }\n\n    if (c == null) {\n      throw new IllegalStateException(\"component cannot be null\");\n    }\n    c = SwingUtilities.getDeepestComponentAt(c, e.getX(), e.getY());\n\n    if (c instanceof IdeGlassPaneImpl) {\n      c = ((IdeGlassPaneImpl)c).getTargetComponentFor(e);\n    }\n\n    if (c == null) { // do nothing if component doesn't contains specified point\n      return false;\n    }\n\n    if (c instanceof MouseShortcutPanel || c.getParent() instanceof MouseShortcutPanel) {\n      return false; // forward mouse processing to the special shortcut panel\n    }\n\n    if (isHorizontalScrolling(c, e)) {\n      boolean done = doHorizontalScrolling(c, (MouseWheelEvent)e);\n      if (done) return true;\n    }\n\n    if (ignore) return false;\n\n    // avoid \"cyclic component initialization error\" in case of dialogs shown because of component initialization failure\n    if (!KeymapManagerImpl.ourKeymapManagerInitialized) {\n      return false;\n    }\n\n    final MouseShortcut shortcut = new MouseShortcut(button, modifiersEx, clickCount);\n    fillActionsList(c, shortcut, IdeKeyEventDispatcher.isModalContext(c));\n    ActionManagerEx actionManager = ActionManagerEx.getInstanceEx();\n    if (actionManager != null) {\n      AnAction[] actions = myActions.toArray(new AnAction[myActions.size()]);\n      for (AnAction action : actions) {\n        DataContext dataContext = DataManager.getInstance().getDataContext(c);\n        Presentation presentation = myPresentationFactory.getPresentation(action);\n        AnActionEvent actionEvent = new AnActionEvent(e, dataContext, ActionPlaces.MAIN_MENU, presentation,\n                                                      ActionManager.getInstance(),\n                                                      modifiers);\n        action.beforeActionPerformedUpdate(actionEvent);\n\n        if (presentation.isEnabled()) {\n          actionManager.fireBeforeActionPerformed(action, dataContext, actionEvent);\n          final Component context = PlatformDataKeys.CONTEXT_COMPONENT.getData(dataContext);\n\n          if (context != null && !context.isShowing()) continue;\n\n          action.actionPerformed(actionEvent);\n          e.consume();\n        }\n      }\n    }\n    return e.getButton() > 3;\n  }","commit_id":"48e2ed8b0842905414145053f19f82b36bf7aaaa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\r\n\t\tpublic void mouseReleased(MouseEvent e) {\r\n\t\t\tif(e.getButton() == MouseEvent.BUTTON3){\r\n\t\t\t\tif(startDragging != null){\r\n\t\t\t\t\tdragTo(e.getPoint());\r\n\t\t\t\t\tfireMapLocationListeners();\r\n\t\t\t\t\tstartDragging = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(e.getButton() == MouseEvent.BUTTON1){\r\n\t\t\t\tif(startSelecting != null){\r\n\t\t\t\t\tselectionArea.setSelectedArea(startSelecting.x, startSelecting.y, e.getPoint().x, e.getPoint().y);\r\n\t\t\t\t\tstartSelecting = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// possible bug if popup neither button1|| button3\r\n\t\t\tif(willBePopupShown && e.isPopupTrigger()){\r\n\t\t\t\tpopupMenuPoint = new Point(e.getX(), e.getY());\r\n\t\t\t\tpopupMenu.show(MapPanel.this, e.getX(), e.getY());\r\n\t\t\t\twillBePopupShown = false;\r\n\t\t\t}\t\t\t\r\n\t\t\tsuper.mouseReleased(e);\r\n\t\t}","id":23814,"modified_method":"@Override\r\n\t\tpublic void mouseReleased(MouseEvent e) {\r\n\t\t\tif(e.getButton() == MouseEvent.BUTTON3){\r\n\t\t\t\tif(startDragging != null){\r\n\t\t\t\t\tdragTo(e.getPoint());\r\n\t\t\t\t\tfireMapLocationListeners();\r\n\t\t\t\t\tstartDragging = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(e.getButton() == MouseEvent.BUTTON1){\r\n\t\t\t\tif(startSelecting != null){\r\n\t\t\t\t\tselectionArea.setSelectedArea(startSelecting.x, startSelecting.y, e.getPoint().x, e.getPoint().y);\r\n\t\t\t\t\tstartSelecting = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// possible bug if popup neither button1|| button3\r\n\t\t\tif(willBePopupShown && (e.isPopupTrigger() || e.getButton() == MouseEvent.BUTTON3)){\r\n\t\t\t\tpopupMenuPoint = new Point(e.getX(), e.getY());\r\n\t\t\t\tpopupMenu.show(MapPanel.this, e.getX(), e.getY());\r\n\t\t\t\twillBePopupShown = false;\r\n\t\t\t}\t\t\t\r\n\t\t\tsuper.mouseReleased(e);\r\n\t\t}","commit_id":"b2bf8fbb46e0b5c4f930236fe3086e34283524b3","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected void processMouseEvent(final MouseEvent e) {\n    if (e.isPopupTrigger()) {\n      super.processMouseEvent(e);\n      return;\n    }\n\n    if (UIUtil.isCloseClick(e)) {\n      myDecorator.fireHiddenSide();\n      return;\n    }\n\n    if (e.getButton() != MouseEvent.BUTTON1) return;\n\n    if (MouseEvent.MOUSE_PRESSED == e.getID()) {\n      myPressedPoint = e.getPoint();\n      myPressedWhenSelected = isSelected();\n    }\n    else if (MouseEvent.MOUSE_RELEASED == e.getID()) {\n      finishDragging();\n      myPressedPoint = null;\n      myDragButtonImage = null;\n    }\n    super.processMouseEvent(e);\n  }","id":23815,"modified_method":"protected void processMouseEvent(final MouseEvent e) {\n    if (e.isPopupTrigger() && e.getComponent().isShowing()) {\n      super.processMouseEvent(e);\n      return;\n    }\n\n    if (UIUtil.isCloseClick(e)) {\n      myDecorator.fireHiddenSide();\n      return;\n    }\n\n    if (e.getButton() != MouseEvent.BUTTON1) return;\n\n    if (MouseEvent.MOUSE_PRESSED == e.getID()) {\n      myPressedPoint = e.getPoint();\n      myPressedWhenSelected = isSelected();\n    }\n    else if (MouseEvent.MOUSE_RELEASED == e.getID()) {\n      finishDragging();\n      myPressedPoint = null;\n      myDragButtonImage = null;\n    }\n    super.processMouseEvent(e);\n  }","commit_id":"4173122c78b6f72672bdfddec0afe6e85666ede4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @param containerTokenIdentifier\n   *          of the container to be started\n   * @throws YarnException\n   */\n  @Private\n  @VisibleForTesting\n  protected void authorizeStartRequest(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier) throws YarnException {\n\n    ContainerId containerId = containerTokenIdentifier.getContainerID();\n    String containerIDStr = containerId.toString();\n    boolean unauthorized = false;\n    StringBuilder messageBuilder =\n        new StringBuilder(\"Unauthorized request to start container. \");\n    if (!nmTokenIdentifier.getApplicationAttemptId().equals(\n        containerId.getApplicationAttemptId())) {\n      unauthorized = true;\n      messageBuilder.append(\"\\nNMToken for application attempt : \")\n        .append(nmTokenIdentifier.getApplicationAttemptId())\n        .append(\" was used for starting container with container token\")\n        .append(\" issued for application attempt : \")\n        .append(containerId.getApplicationAttemptId());\n    } else if (!this.context.getContainerTokenSecretManager()\n        .isValidStartContainerRequest(containerTokenIdentifier)) {\n      // Is the container being relaunched? Or RPC layer let startCall with\n      // tokens generated off old-secret through?\n      unauthorized = true;\n      messageBuilder.append(\"\\n Attempt to relaunch the same \")\n        .append(\"container with id \").append(containerIDStr).append(\".\");\n    } else if (containerTokenIdentifier.getExpiryTimeStamp() < System\n      .currentTimeMillis()) {\n      // Ensure the token is not expired.\n      unauthorized = true;\n      messageBuilder.append(\"\\nThis token is expired. current time is \")\n        .append(System.currentTimeMillis()).append(\" found \")\n        .append(containerTokenIdentifier.getExpiryTimeStamp());\n    }\n    if (unauthorized) {\n      String msg = messageBuilder.toString();\n      LOG.error(msg);\n      throw RPCUtil.getRemoteException(msg);\n    }\n  }","id":23816,"modified_method":"/**\n   * @param containerTokenIdentifier\n   *          of the container to be started\n   * @throws YarnException\n   */\n  @Private\n  @VisibleForTesting\n  protected void authorizeStartRequest(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier) throws YarnException {\n\n    ContainerId containerId = containerTokenIdentifier.getContainerID();\n    String containerIDStr = containerId.toString();\n    boolean unauthorized = false;\n    StringBuilder messageBuilder =\n        new StringBuilder(\"Unauthorized request to start container. \");\n    if (!nmTokenIdentifier.getApplicationAttemptId().getApplicationId().equals(\n        containerId.getApplicationAttemptId().getApplicationId())) {\n      unauthorized = true;\n      messageBuilder.append(\"\\nNMToken for application attempt : \")\n        .append(nmTokenIdentifier.getApplicationAttemptId())\n        .append(\" was used for starting container with container token\")\n        .append(\" issued for application attempt : \")\n        .append(containerId.getApplicationAttemptId());\n    } else if (!this.context.getContainerTokenSecretManager()\n        .isValidStartContainerRequest(containerTokenIdentifier)) {\n      // Is the container being relaunched? Or RPC layer let startCall with\n      // tokens generated off old-secret through?\n      unauthorized = true;\n      messageBuilder.append(\"\\n Attempt to relaunch the same \")\n        .append(\"container with id \").append(containerIDStr).append(\".\");\n    } else if (containerTokenIdentifier.getExpiryTimeStamp() < System\n      .currentTimeMillis()) {\n      // Ensure the token is not expired.\n      unauthorized = true;\n      messageBuilder.append(\"\\nThis token is expired. current time is \")\n        .append(System.currentTimeMillis()).append(\" found \")\n        .append(containerTokenIdentifier.getExpiryTimeStamp());\n    }\n    if (unauthorized) {\n      String msg = messageBuilder.toString();\n      LOG.error(msg);\n      throw RPCUtil.getRemoteException(msg);\n    }\n  }","commit_id":"d1f54f4f4bed6c5f8e27bc80c3e33081f5c5d63f","url":"https://github.com/apache/hadoop"},{"original_method":"@Private\n  @VisibleForTesting\n  protected void authorizeGetAndStopContainerRequest(ContainerId containerId,\n      Container container, boolean stopRequest, NMTokenIdentifier identifier)\n      throws YarnException {\n    /*\n     * For get/stop container status; we need to verify that 1) User (NMToken)\n     * application attempt only has started container. 2) Requested containerId\n     * belongs to the same application attempt (NMToken) which was used. (Note:-\n     * This will prevent user in knowing another application's containers).\n     */\n\n    if ((!identifier.getApplicationAttemptId().equals(\n      containerId.getApplicationAttemptId()))\n        || (container != null && !identifier.getApplicationAttemptId().equals(\n          container.getContainerId().getApplicationAttemptId()))) {\n      if (stopRequest) {\n        LOG.warn(identifier.getApplicationAttemptId()\n            + \" attempted to stop non-application container : \"\n            + container.getContainerId().toString());\n        NMAuditLogger.logFailure(\"UnknownUser\", AuditConstants.STOP_CONTAINER,\n          \"ContainerManagerImpl\", \"Trying to stop unknown container!\",\n          identifier.getApplicationAttemptId().getApplicationId(),\n          container.getContainerId());\n      } else {\n        LOG.warn(identifier.getApplicationAttemptId()\n            + \" attempted to get status for non-application container : \"\n            + container.getContainerId().toString());\n      }\n    }\n\n  }","id":23817,"modified_method":"@Private\n  @VisibleForTesting\n  protected void authorizeGetAndStopContainerRequest(ContainerId containerId,\n      Container container, boolean stopRequest, NMTokenIdentifier identifier)\n      throws YarnException {\n    /*\n     * For get/stop container status; we need to verify that 1) User (NMToken)\n     * application attempt only has started container. 2) Requested containerId\n     * belongs to the same application attempt (NMToken) which was used. (Note:-\n     * This will prevent user in knowing another application's containers).\n     */\n    ApplicationId nmTokenAppId =\n        identifier.getApplicationAttemptId().getApplicationId();\n    if ((!nmTokenAppId.equals(containerId.getApplicationAttemptId().getApplicationId()))\n        || (container != null && !nmTokenAppId.equals(container\n          .getContainerId().getApplicationAttemptId().getApplicationId()))) {\n      if (stopRequest) {\n        LOG.warn(identifier.getApplicationAttemptId()\n            + \" attempted to stop non-application container : \"\n            + container.getContainerId());\n        NMAuditLogger.logFailure(\"UnknownUser\", AuditConstants.STOP_CONTAINER,\n          \"ContainerManagerImpl\", \"Trying to stop unknown container!\",\n          nmTokenAppId, container.getContainerId());\n      } else {\n        LOG.warn(identifier.getApplicationAttemptId()\n            + \" attempted to get status for non-application container : \"\n            + container.getContainerId());\n      }\n    }\n  }","commit_id":"d1f54f4f4bed6c5f8e27bc80c3e33081f5c5d63f","url":"https://github.com/apache/hadoop"},{"original_method":"private void testNMTokens(Configuration conf) throws Exception {\n    NMTokenSecretManagerInRM nmTokenSecretManagerRM =\n        yarnCluster.getResourceManager().getRMContext()\n          .getNMTokenSecretManager();\n    NMTokenSecretManagerInNM nmTokenSecretManagerNM =\n        yarnCluster.getNodeManager(0).getNMContext().getNMTokenSecretManager();\n    RMContainerTokenSecretManager containerTokenSecretManager =\n        yarnCluster.getResourceManager().getRMContext().\n            getContainerTokenSecretManager();\n    \n    NodeManager nm = yarnCluster.getNodeManager(0);\n    \n    waitForNMToReceiveNMTokenKey(nmTokenSecretManagerNM, nm);\n    \n    // Both id should be equal.\n    Assert.assertEquals(nmTokenSecretManagerNM.getCurrentKey().getKeyId(),\n        nmTokenSecretManagerRM.getCurrentKey().getKeyId());\n    \n    /*\n     * Below cases should be tested.\n     * 1) If Invalid NMToken is used then it should be rejected.\n     * 2) If valid NMToken but belonging to another Node is used then that\n     * too should be rejected.\n     * 3) NMToken for say appAttempt-1 is used for starting/stopping/retrieving\n     * status for container with containerId for say appAttempt-2 should\n     * be rejected.\n     * 4) After start container call is successful nmtoken should have been\n     * saved in NMTokenSecretManagerInNM.\n     * 5) If start container call was successful (no matter if container is\n     * still running or not), appAttempt->NMToken should be present in\n     * NMTokenSecretManagerInNM's cache. Any future getContainerStatus call\n     * for containerId belonging to that application attempt using\n     * applicationAttempt's older nmToken should not get any invalid\n     * nmToken error. (This can be best tested if we roll over NMToken\n     * master key twice).\n     */\n    YarnRPC rpc = YarnRPC.create(conf);\n    String user = \"test\";\n    Resource r = Resource.newInstance(1024, 1);\n\n    ApplicationId appId = ApplicationId.newInstance(1, 1);\n    ApplicationAttemptId validAppAttemptId =\n        ApplicationAttemptId.newInstance(appId, 1);\n    ApplicationAttemptId invalidAppAttemptId =\n        ApplicationAttemptId.newInstance(appId, 2);\n    \n    ContainerId validContainerId =\n        ContainerId.newInstance(validAppAttemptId, 0);\n    \n    NodeId validNode = yarnCluster.getNodeManager(0).getNMContext().getNodeId();\n    NodeId invalidNode = NodeId.newInstance(\"InvalidHost\", 1234);\n\n    \n    org.apache.hadoop.yarn.api.records.Token validNMToken =\n        nmTokenSecretManagerRM.createNMToken(validAppAttemptId, validNode, user);\n    \n    org.apache.hadoop.yarn.api.records.Token validContainerToken =\n        containerTokenSecretManager.createContainerToken(validContainerId,\n            validNode, user, r, Priority.newInstance(10), 1234);\n    ContainerTokenIdentifier identifier =\n        BuilderUtils.newContainerTokenIdentifier(validContainerToken);\n    Assert.assertEquals(Priority.newInstance(10), identifier.getPriority());\n    Assert.assertEquals(1234, identifier.getCreationTime());\n    \n    StringBuilder sb;\n    // testInvalidNMToken ... creating NMToken using different secret manager.\n    \n    NMTokenSecretManagerInRM tempManager = new NMTokenSecretManagerInRM(conf);\n    tempManager.rollMasterKey();\n    do {\n      tempManager.rollMasterKey();\n      tempManager.activateNextMasterKey();\n      // Making sure key id is different.\n    } while (tempManager.getCurrentKey().getKeyId() == nmTokenSecretManagerRM\n        .getCurrentKey().getKeyId());\n    \n    // Testing that NM rejects the requests when we don't send any token.\n    if (UserGroupInformation.isSecurityEnabled()) {\n      sb = new StringBuilder(\"Client cannot authenticate via:[TOKEN]\");\n    } else {\n      sb =\n          new StringBuilder(\n              \"SIMPLE authentication is not enabled.  Available:[TOKEN]\");\n    }\n    String errorMsg = testStartContainer(rpc, validAppAttemptId, validNode,\n        validContainerToken, null, true);\n    Assert.assertTrue(errorMsg.contains(sb.toString()));\n    \n    org.apache.hadoop.yarn.api.records.Token invalidNMToken =\n        tempManager.createNMToken(validAppAttemptId, validNode, user);\n    sb = new StringBuilder(\"Given NMToken for application : \");\n    sb.append(validAppAttemptId.toString())\n      .append(\" seems to have been generated illegally.\");\n    Assert.assertTrue(sb.toString().contains(\n        testStartContainer(rpc, validAppAttemptId, validNode,\n            validContainerToken, invalidNMToken, true)));\n    \n    // valid NMToken but belonging to other node\n    invalidNMToken =\n        nmTokenSecretManagerRM.createNMToken(validAppAttemptId, invalidNode,\n            user);\n    sb = new StringBuilder(\"Given NMToken for application : \");\n    sb.append(validAppAttemptId)\n      .append(\" is not valid for current node manager.expected : \")\n      .append(validNode.toString())\n      .append(\" found : \").append(invalidNode.toString());\n    Assert.assertTrue(sb.toString().contains(\n        testStartContainer(rpc, validAppAttemptId, validNode,\n            validContainerToken, invalidNMToken, true)));\n    \n    // using appAttempt-2 token for launching container for appAttempt-1.\n    invalidNMToken =\n        nmTokenSecretManagerRM.createNMToken(invalidAppAttemptId, validNode,\n            user);\n    sb = new StringBuilder(\"\\nNMToken for application attempt : \");\n    sb.append(invalidAppAttemptId.toString())\n      .append(\" was used for starting container with container token\")\n      .append(\" issued for application attempt : \")\n      .append(validAppAttemptId.toString());\n    Assert.assertTrue(testStartContainer(rpc, validAppAttemptId, validNode,\n        validContainerToken, invalidNMToken, true).contains(sb.toString()));\n    \n    // using correct tokens. nmtoken for app attempt should get saved.\n    conf.setInt(YarnConfiguration.RM_CONTAINER_ALLOC_EXPIRY_INTERVAL_MS,\n        4 * 60 * 1000);\n    validContainerToken =\n        containerTokenSecretManager.createContainerToken(validContainerId,\n            validNode, user, r, Priority.newInstance(0), 0);\n    testStartContainer(rpc, validAppAttemptId, validNode, validContainerToken,\n        validNMToken, false);\n    Assert.assertTrue(nmTokenSecretManagerNM\n        .isAppAttemptNMTokenKeyPresent(validAppAttemptId));\n    \n    //Now lets wait till container finishes and is removed from node manager.\n    waitForContainerToFinishOnNM(validContainerId);\n    sb = new StringBuilder(\"Attempt to relaunch the same container with id \");\n    sb.append(validContainerId);\n    Assert.assertTrue(testStartContainer(rpc, validAppAttemptId, validNode,\n        validContainerToken, validNMToken, true).contains(sb.toString()));\n    \n    // Container is removed from node manager's memory by this time.\n    // trying to stop the container. It should not throw any exception.\n    testStopContainer(rpc, validAppAttemptId, validNode, validContainerId,\n        validNMToken, false);\n    \n    // Rolling over master key twice so that we can check whether older keys\n    // are used for authentication.\n    rollNMTokenMasterKey(nmTokenSecretManagerRM, nmTokenSecretManagerNM);\n    // Key rolled over once.. rolling over again\n    rollNMTokenMasterKey(nmTokenSecretManagerRM, nmTokenSecretManagerNM);\n    \n    // trying get container status. Now saved nmToken should be used for\n    // authentication... It should complain saying container was recently\n    // stopped.\n    sb = new StringBuilder(\"Container \");\n    sb.append(validContainerId);\n    sb.append(\" was recently stopped on node manager\");\n    Assert.assertTrue(testGetContainer(rpc, validAppAttemptId, validNode,\n        validContainerId, validNMToken, true).contains(sb.toString()));\n    \n    // Now lets remove the container from nm-memory\n    nm.getNodeStatusUpdater().clearFinishedContainersFromCache();\n    \n    // This should fail as container is removed from recently tracked finished\n    // containers.\n    sb = new StringBuilder(\"Container \");\n    sb.append(validContainerId.toString());\n    sb.append(\" is not handled by this NodeManager\");\n    Assert.assertTrue(testGetContainer(rpc, validAppAttemptId, validNode,\n        validContainerId, validNMToken, false).contains(sb.toString()));\n\n  }","id":23818,"modified_method":"private void testNMTokens(Configuration conf) throws Exception {\n    NMTokenSecretManagerInRM nmTokenSecretManagerRM =\n        yarnCluster.getResourceManager().getRMContext()\n          .getNMTokenSecretManager();\n    NMTokenSecretManagerInNM nmTokenSecretManagerNM =\n        yarnCluster.getNodeManager(0).getNMContext().getNMTokenSecretManager();\n    RMContainerTokenSecretManager containerTokenSecretManager =\n        yarnCluster.getResourceManager().getRMContext().\n            getContainerTokenSecretManager();\n    \n    NodeManager nm = yarnCluster.getNodeManager(0);\n    \n    waitForNMToReceiveNMTokenKey(nmTokenSecretManagerNM, nm);\n    \n    // Both id should be equal.\n    Assert.assertEquals(nmTokenSecretManagerNM.getCurrentKey().getKeyId(),\n        nmTokenSecretManagerRM.getCurrentKey().getKeyId());\n    \n    /*\n     * Below cases should be tested.\n     * 1) If Invalid NMToken is used then it should be rejected.\n     * 2) If valid NMToken but belonging to another Node is used then that\n     * too should be rejected.\n     * 3) NMToken for say appAttempt-1 is used for starting/stopping/retrieving\n     * status for container with containerId for say appAttempt-2 should\n     * be rejected.\n     * 4) After start container call is successful nmtoken should have been\n     * saved in NMTokenSecretManagerInNM.\n     * 5) If start container call was successful (no matter if container is\n     * still running or not), appAttempt->NMToken should be present in\n     * NMTokenSecretManagerInNM's cache. Any future getContainerStatus call\n     * for containerId belonging to that application attempt using\n     * applicationAttempt's older nmToken should not get any invalid\n     * nmToken error. (This can be best tested if we roll over NMToken\n     * master key twice).\n     */\n    YarnRPC rpc = YarnRPC.create(conf);\n    String user = \"test\";\n    Resource r = Resource.newInstance(1024, 1);\n\n    ApplicationId appId = ApplicationId.newInstance(1, 1);\n    ApplicationAttemptId validAppAttemptId =\n        ApplicationAttemptId.newInstance(appId, 1);\n    \n    ContainerId validContainerId =\n        ContainerId.newInstance(validAppAttemptId, 0);\n    \n    NodeId validNode = yarnCluster.getNodeManager(0).getNMContext().getNodeId();\n    NodeId invalidNode = NodeId.newInstance(\"InvalidHost\", 1234);\n\n    \n    org.apache.hadoop.yarn.api.records.Token validNMToken =\n        nmTokenSecretManagerRM.createNMToken(validAppAttemptId, validNode, user);\n    \n    org.apache.hadoop.yarn.api.records.Token validContainerToken =\n        containerTokenSecretManager.createContainerToken(validContainerId,\n            validNode, user, r, Priority.newInstance(10), 1234);\n    ContainerTokenIdentifier identifier =\n        BuilderUtils.newContainerTokenIdentifier(validContainerToken);\n    Assert.assertEquals(Priority.newInstance(10), identifier.getPriority());\n    Assert.assertEquals(1234, identifier.getCreationTime());\n    \n    StringBuilder sb;\n    // testInvalidNMToken ... creating NMToken using different secret manager.\n    \n    NMTokenSecretManagerInRM tempManager = new NMTokenSecretManagerInRM(conf);\n    tempManager.rollMasterKey();\n    do {\n      tempManager.rollMasterKey();\n      tempManager.activateNextMasterKey();\n      // Making sure key id is different.\n    } while (tempManager.getCurrentKey().getKeyId() == nmTokenSecretManagerRM\n        .getCurrentKey().getKeyId());\n    \n    // Testing that NM rejects the requests when we don't send any token.\n    if (UserGroupInformation.isSecurityEnabled()) {\n      sb = new StringBuilder(\"Client cannot authenticate via:[TOKEN]\");\n    } else {\n      sb =\n          new StringBuilder(\n              \"SIMPLE authentication is not enabled.  Available:[TOKEN]\");\n    }\n    String errorMsg = testStartContainer(rpc, validAppAttemptId, validNode,\n        validContainerToken, null, true);\n    Assert.assertTrue(errorMsg.contains(sb.toString()));\n    \n    org.apache.hadoop.yarn.api.records.Token invalidNMToken =\n        tempManager.createNMToken(validAppAttemptId, validNode, user);\n    sb = new StringBuilder(\"Given NMToken for application : \");\n    sb.append(validAppAttemptId.toString())\n      .append(\" seems to have been generated illegally.\");\n    Assert.assertTrue(sb.toString().contains(\n        testStartContainer(rpc, validAppAttemptId, validNode,\n            validContainerToken, invalidNMToken, true)));\n    \n    // valid NMToken but belonging to other node\n    invalidNMToken =\n        nmTokenSecretManagerRM.createNMToken(validAppAttemptId, invalidNode,\n            user);\n    sb = new StringBuilder(\"Given NMToken for application : \");\n    sb.append(validAppAttemptId)\n      .append(\" is not valid for current node manager.expected : \")\n      .append(validNode.toString())\n      .append(\" found : \").append(invalidNode.toString());\n    Assert.assertTrue(sb.toString().contains(\n        testStartContainer(rpc, validAppAttemptId, validNode,\n            validContainerToken, invalidNMToken, true)));\n    \n    // using correct tokens. nmtoken for app attempt should get saved.\n    conf.setInt(YarnConfiguration.RM_CONTAINER_ALLOC_EXPIRY_INTERVAL_MS,\n        4 * 60 * 1000);\n    validContainerToken =\n        containerTokenSecretManager.createContainerToken(validContainerId,\n            validNode, user, r, Priority.newInstance(0), 0);\n    Assert.assertTrue(testStartContainer(rpc, validAppAttemptId, validNode,\n      validContainerToken, validNMToken, false).isEmpty());\n    Assert.assertTrue(nmTokenSecretManagerNM\n        .isAppAttemptNMTokenKeyPresent(validAppAttemptId));\n    \n    //Now lets wait till container finishes and is removed from node manager.\n    waitForContainerToFinishOnNM(validContainerId);\n    sb = new StringBuilder(\"Attempt to relaunch the same container with id \");\n    sb.append(validContainerId);\n    Assert.assertTrue(testStartContainer(rpc, validAppAttemptId, validNode,\n        validContainerToken, validNMToken, true).contains(sb.toString()));\n    \n    // Container is removed from node manager's memory by this time.\n    // trying to stop the container. It should not throw any exception.\n    testStopContainer(rpc, validAppAttemptId, validNode, validContainerId,\n        validNMToken, false);\n    \n    // Rolling over master key twice so that we can check whether older keys\n    // are used for authentication.\n    rollNMTokenMasterKey(nmTokenSecretManagerRM, nmTokenSecretManagerNM);\n    // Key rolled over once.. rolling over again\n    rollNMTokenMasterKey(nmTokenSecretManagerRM, nmTokenSecretManagerNM);\n    \n    // trying get container status. Now saved nmToken should be used for\n    // authentication... It should complain saying container was recently\n    // stopped.\n    sb = new StringBuilder(\"Container \");\n    sb.append(validContainerId);\n    sb.append(\" was recently stopped on node manager\");\n    Assert.assertTrue(testGetContainer(rpc, validAppAttemptId, validNode,\n        validContainerId, validNMToken, true).contains(sb.toString()));\n    \n    // Now lets remove the container from nm-memory\n    nm.getNodeStatusUpdater().clearFinishedContainersFromCache();\n    \n    // This should fail as container is removed from recently tracked finished\n    // containers.\n    sb = new StringBuilder(\"Container \");\n    sb.append(validContainerId.toString());\n    sb.append(\" is not handled by this NodeManager\");\n    Assert.assertTrue(testGetContainer(rpc, validAppAttemptId, validNode,\n        validContainerId, validNMToken, false).contains(sb.toString()));\n\n    // using appAttempt-1 NMtoken for launching container for appAttempt-2 should\n    // succeed.\n    ApplicationAttemptId attempt2 = ApplicationAttemptId.newInstance(appId, 2);\n    Token attempt1NMToken =\n        nmTokenSecretManagerRM\n          .createNMToken(validAppAttemptId, validNode, user);\n    org.apache.hadoop.yarn.api.records.Token newContainerToken =\n        containerTokenSecretManager.createContainerToken(\n          ContainerId.newInstance(attempt2, 1), validNode, user, r,\n            Priority.newInstance(0), 0);\n    Assert.assertTrue(testStartContainer(rpc, attempt2, validNode,\n      newContainerToken, attempt1NMToken, false).isEmpty());\n  }","commit_id":"d1f54f4f4bed6c5f8e27bc80c3e33081f5c5d63f","url":"https://github.com/apache/hadoop"},{"original_method":"public void prioritizeArticles() throws PortalException, SystemException {\n\t\tif (_prioritizeUpdatedArticles) {\n\t\t\t_initNonImportedArticles();\n\t\t}\n\n\t\tif (_prioritizeByNumericalPrefix) {\n\t\t\tfor (Map.Entry<String, Double> entry :\n\t\t\t\t\t_importedUrlTitlesPrioritiesMap.entrySet()) {\n\n\t\t\t\tKBArticle kbArticle =\n\t\t\t\t\tKBArticleLocalServiceUtil.getKBArticleByUrlTitle(\n\t\t\t\t\t\t_groupId, _parentKBFolderId, entry.getKey());\n\n\t\t\t\tKBArticleLocalServiceUtil.updatePriority(\n\t\t\t\t\tkbArticle.getResourcePrimKey(), entry.getValue());\n\n\t\t\t\t/*\n\t\t\t\t * Remove articles with numerical prefixes, and their URL\n\t\t\t\t * titles, from lists of imported and new articles. Only\n\t\t\t\t * articles without numerical prefixes need to be\n\t\t\t\t * alphanumerically prioritized.\n\t\t\t\t */\n\n\t\t\t\tremove(_importedArticlesMap, kbArticle);\n\t\t\t\tremove(_importedUrlTitlesMap, kbArticle.getUrlTitle());\n\t\t\t\tremove(_newArticlesMap, kbArticle);\n\t\t\t\tremove(_newUrlTitlesMap, kbArticle.getUrlTitle());\n\t\t\t}\n\t\t}\n\n\t\tif (_prioritizeUpdatedArticles) {\n\n\t\t\t// prioritize all imported articles\n\n\t\t\tMap<String, Double> maxKBArticlePriorityMap =\n\t\t\t\tnew HashMap<String, Double>();\n\n\t\t\tfor (Map.Entry<String, List<KBArticle>> entry :\n\t\t\t\t\t_nonImportedArticlesMap.entrySet()) {\n\n\t\t\t\tdouble maxKBArticlePriority = 0.0;\n\n\t\t\t\tList<KBArticle> kbArticles = entry.getValue();\n\n\t\t\t\tif (kbArticles == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (KBArticle kbArticle : kbArticles) {\n\t\t\t\t\tdouble kbArticlePriority = kbArticle.getPriority();\n\n\t\t\t\t\tif (kbArticlePriority > maxKBArticlePriority) {\n\t\t\t\t\t\tmaxKBArticlePriority = kbArticlePriority;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaxKBArticlePriorityMap.put(\n\t\t\t\t\tentry.getKey(), maxKBArticlePriority);\n\t\t\t}\n\n\t\t\tprioritizeKBArticles(_importedArticlesMap, maxKBArticlePriorityMap);\n\t\t}\n\t\telse {\n\n\t\t\t// prioritize only new articles\n\n\t\t\tMap<String, Double> maxKBArticlePriorityMap =\n\t\t\t\tnew HashMap<String, Double>();\n\n\t\t\tfor (Map.Entry<String, List<KBArticle>> entry :\n\t\t\t\t\t_existingArticlesMap.entrySet()) {\n\n\t\t\t\tdouble maxKBArticlePriority = 0.0;\n\n\t\t\t\tList<KBArticle> kbArticles = entry.getValue();\n\n\t\t\t\tif (kbArticles == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (KBArticle kbArticle : kbArticles) {\n\t\t\t\t\tdouble kbArticlePriority = kbArticle.getPriority();\n\n\t\t\t\t\tif (kbArticlePriority > maxKBArticlePriority) {\n\t\t\t\t\t\tmaxKBArticlePriority = kbArticlePriority;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmaxKBArticlePriorityMap.put(\n\t\t\t\t\tentry.getKey(), maxKBArticlePriority);\n\t\t\t}\n\n\t\t\tprioritizeKBArticles(_newArticlesMap, maxKBArticlePriorityMap);\n\t\t}\n\t}","id":23819,"modified_method":"public void prioritizeArticles() throws PortalException, SystemException {\n\t\tif (_prioritizeUpdatedArticles) {\n\t\t\t_initNonImportedArticles();\n\t\t}\n\n\t\tif (_prioritizeByNumericalPrefix) {\n\t\t\tfor (Map.Entry<String, Double> entry :\n\t\t\t\t\t_importedUrlTitlesPrioritiesMap.entrySet()) {\n\n\t\t\t\tKBArticle kbArticle =\n\t\t\t\t\tKBArticleLocalServiceUtil.getKBArticleByUrlTitle(\n\t\t\t\t\t\t_groupId, _parentKBFolderId, entry.getKey());\n\n\t\t\t\tKBArticleLocalServiceUtil.updatePriority(\n\t\t\t\t\tkbArticle.getResourcePrimKey(), entry.getValue());\n\n\t\t\t\t/*\n\t\t\t\t * Remove articles with numerical prefixes, and their URL\n\t\t\t\t * titles, from lists of imported and new articles. Only\n\t\t\t\t * articles without numerical prefixes need to be\n\t\t\t\t * alphanumerically prioritized.\n\t\t\t\t */\n\n\t\t\t\tremove(_importedArticlesMap, kbArticle);\n\t\t\t\tremove(_importedUrlTitlesMap, kbArticle.getUrlTitle());\n\t\t\t\tremove(_newArticlesMap, kbArticle);\n\t\t\t\tremove(_newUrlTitlesMap, kbArticle.getUrlTitle());\n\t\t\t}\n\t\t}\n\n\t\tif (_prioritizeUpdatedArticles) {\n\n\t\t\t// prioritize all imported articles\n\n\t\t\tMap<String, Double> maxKBArticlePriorityMap =\n\t\t\t\tcomputeMaxKBArticlePriorityMap(_nonImportedArticlesMap);\n\n\t\t\tprioritizeKBArticles(_importedArticlesMap, maxKBArticlePriorityMap);\n\t\t}\n\t\telse {\n\n\t\t\t// prioritize only new articles\n\n\t\t\tMap<String, Double> maxKBArticlePriorityMap =\n\t\t\t\tcomputeMaxKBArticlePriorityMap(_existingArticlesMap);\n\n\t\t\tprioritizeKBArticles(_newArticlesMap, maxKBArticlePriorityMap);\n\t\t}\n\t}","commit_id":"b6ce36dba2d2a97e472eec73b68005ba6bdbe217","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void prioritizeKBArticles() throws PortalException {\n\t\tif (_prioritizeUpdatedKBArticles) {\n\t\t\tinitializeNonImportedKBArticles();\n\t\t}\n\n\t\tif (_prioritizeByNumericalPrefix) {\n\t\t\tfor (Map.Entry<String, Double> entry :\n\t\t\t\t\t_importedKBArticleUrlTitlesPrioritiesMap.entrySet()) {\n\n\t\t\t\tif (entry.getValue() < 1.0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tKBArticle kbArticle =\n\t\t\t\t\tKBArticleLocalServiceUtil.getKBArticleByUrlTitle(\n\t\t\t\t\t\t_groupId, _parentKBFolderId, entry.getKey());\n\n\t\t\t\tKBArticleLocalServiceUtil.updatePriority(\n\t\t\t\t\tkbArticle.getResourcePrimKey(), entry.getValue());\n\n\t\t\t\tremove(_importedKBArticlesMap, kbArticle);\n\t\t\t\tremove(_importedKBArticleUrlTitlesMap, kbArticle.getUrlTitle());\n\t\t\t\tremove(_newKBArticlesMap, kbArticle);\n\t\t\t}\n\t\t}\n\n\t\tif (_prioritizeUpdatedKBArticles) {\n\t\t\tMap<String, Double> maxKBArticlePriorityMap =\n\t\t\t\tcomputeMaxKBArticlePriorityMap(_nonimportedKBArticlesMap);\n\n\t\t\tprioritizeKBArticles(\n\t\t\t\t_importedKBArticlesMap, maxKBArticlePriorityMap);\n\t\t}\n\t\telse {\n\t\t\tMap<String, Double> maxKBArticlePriorityMap =\n\t\t\t\tcomputeMaxKBArticlePriorityMap(_existingKBArticlesMap);\n\n\t\t\tprioritizeKBArticles(_newKBArticlesMap, maxKBArticlePriorityMap);\n\t\t}\n\t}","id":23820,"modified_method":"public void prioritizeKBArticles() throws PortalException {\n\t\tif (_prioritizeUpdatedKBArticles) {\n\t\t\tinitializeNonImportedKBArticles();\n\t\t}\n\n\t\tif (_prioritizeByNumericalPrefix) {\n\t\t\tfor (Map.Entry<String, Double> entry :\n\t\t\t\t\t_importedKBArticleUrlTitlesPrioritiesMap.entrySet()) {\n\n\t\t\t\tif (entry.getValue() < 1.0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tKBArticle kbArticle =\n\t\t\t\t\tKBArticleLocalServiceUtil.getKBArticleByUrlTitle(\n\t\t\t\t\t\t_groupId, _parentKBFolderId, entry.getKey());\n\n\t\t\t\tKBArticleLocalServiceUtil.updatePriority(\n\t\t\t\t\tkbArticle.getResourcePrimKey(), entry.getValue());\n\n\t\t\t\tremove(_importedKBArticlesMap, kbArticle);\n\t\t\t\tremove(_importedKBArticleUrlTitlesMap, kbArticle.getUrlTitle());\n\t\t\t\tremove(_newKBArticlesMap, kbArticle);\n\t\t\t}\n\t\t}\n\n\t\tif (_prioritizeUpdatedKBArticles) {\n\t\t\tprioritizeKBArticles(_importedKBArticlesMap);\n\t\t}\n\t\telse {\n\t\t\tprioritizeKBArticles(_newKBArticlesMap);\n\t\t}\n\t}","commit_id":"7fb0a6c52abe89dea297f7e151f3a117624bcd8a","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void prioritizeKBArticles(\n\t\tMap<String, List<KBArticle>> kbArticlesMap,\n\t\tMap<String, Double> maxKBArticlePriorityMap) {\n\n\t\tfor (Map.Entry<String, List<KBArticle>> entry :\n\t\t\t\tkbArticlesMap.entrySet()) {\n\n\t\t\tList<KBArticle> kbArticles = entry.getValue();\n\n\t\t\tif (kbArticles == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tListUtil.sort(kbArticles, new Comparator<KBArticle>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(KBArticle kbArticle1, KBArticle kbArticle2) {\n\t\t\t\t\tString urlTitle1 = kbArticle1.getUrlTitle();\n\t\t\t\t\tString urlTitle2 = kbArticle2.getUrlTitle();\n\n\t\t\t\t\treturn urlTitle1.compareTo(urlTitle2);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\tString parentKBArticleUrlTitle = entry.getKey();\n\n\t\t\tint size = kbArticles.size();\n\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tKBArticle kbArticle = kbArticles.get(i);\n\n\t\t\t\tdouble maxPriority = 0.0;\n\n\t\t\t\tif (maxKBArticlePriorityMap.containsKey(\n\t\t\t\t\t\tparentKBArticleUrlTitle)) {\n\n\t\t\t\t\tmaxPriority = maxKBArticlePriorityMap.get(\n\t\t\t\t\t\tparentKBArticleUrlTitle);\n\t\t\t\t}\n\n\t\t\t\tmaxPriority++;\n\n\t\t\t\tmaxKBArticlePriorityMap.put(\n\t\t\t\t\tparentKBArticleUrlTitle, maxPriority);\n\n\t\t\t\tKBArticleLocalServiceUtil.updatePriority(\n\t\t\t\t\tkbArticle.getResourcePrimKey(), maxPriority);\n\t\t\t}\n\t\t}\n\t}","id":23821,"modified_method":"protected void prioritizeKBArticles(\n\t\t\tMap<String, List<KBArticle>> kbArticlesMap)\n\t\tthrows PortalException {\n\n\t\tfor (Map.Entry<String, List<KBArticle>> entry :\n\t\t\t\tkbArticlesMap.entrySet()) {\n\n\t\t\tList<KBArticle> kbArticles = entry.getValue();\n\n\t\t\tif (kbArticles == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tList<KBArticle> siblingKBArticles = null;\n\n\t\t\tif (Validator.isNull(entry.getKey())) {\n\n\t\t\t\t// Handle lead articles\n\n\t\t\t\tsiblingKBArticles = KBArticleLocalServiceUtil.getKBArticles(\n\t\t\t\t\t_groupId, _parentKBFolderId, WorkflowConstants.STATUS_ANY,\n\t\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS, null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tKBArticle parentKBArticle =\n\t\t\t\t\tKBArticleLocalServiceUtil.fetchKBArticleByUrlTitle(\n\t\t\t\t\t\t_groupId, _parentKBFolderId, entry.getKey());\n\n\t\t\t\tsiblingKBArticles = KBArticleServiceUtil.getKBArticles(\n\t\t\t\t\t_groupId, parentKBArticle.getResourcePrimKey(),\n\t\t\t\t\tWorkflowConstants.STATUS_ANY, QueryUtil.ALL_POS,\n\t\t\t\t\tQueryUtil.ALL_POS, null);\n\t\t\t}\n\n\t\t\tdouble maxPriority = 0.0;\n\n\t\t\tfor (KBArticle sibling : siblingKBArticles) {\n\t\t\t\tdouble priority = sibling.getPriority();\n\n\t\t\t\tif (priority > maxPriority) {\n\t\t\t\t\tmaxPriority = priority;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint size = kbArticles.size();\n\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tKBArticle kbArticle = kbArticles.get(i);\n\n\t\t\t\tif (kbArticle.getPriority() >= 1.0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmaxPriority++;\n\n\t\t\t\tKBArticleLocalServiceUtil.updatePriority(\n\t\t\t\t\tkbArticle.getResourcePrimKey(), maxPriority);\n\t\t\t}\n\t\t}\n\t}","commit_id":"7fb0a6c52abe89dea297f7e151f3a117624bcd8a","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected long loginUser(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tlong companyId, long userId, String remoteUser)\n\t\tthrows PortalException {\n\n\t\tif ((userId > 0) || (remoteUser == null)) {\n\t\t\treturn userId;\n\t\t}\n\n\t\tuserId = GetterUtil.getLong(remoteUser);\n\n\t\tEventsProcessorUtil.process(\n\t\t\tPropsKeys.LOGIN_EVENTS_PRE, PropsValues.LOGIN_EVENTS_PRE, request,\n\t\t\tresponse);\n\n\t\tUser user = UserLocalServiceUtil.getUserById(userId);\n\n\t\tif (!user.isDefaultUser() &&\n\t\t\t(PropsValues.USERS_UPDATE_LAST_LOGIN ||\n\t\t\t (user.getLastLoginDate() == null))) {\n\n\t\t\tuser = UserLocalServiceUtil.updateLastLogin(\n\t\t\t\tuserId, request.getRemoteAddr());\n\t\t}\n\n\t\tHttpSession session = request.getSession();\n\n\t\tsession.setAttribute(WebKeys.USER, user);\n\t\tsession.setAttribute(WebKeys.USER_ID, Long.valueOf(userId));\n\t\tsession.setAttribute(Globals.LOCALE_KEY, user.getLocale());\n\n\t\tEventsProcessorUtil.process(\n\t\t\tPropsKeys.LOGIN_EVENTS_POST, PropsValues.LOGIN_EVENTS_POST, request,\n\t\t\tresponse);\n\n\t\treturn userId;\n\t}","id":23822,"modified_method":"protected long loginUser(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tlong companyId, long userId, String remoteUser)\n\t\tthrows PortalException {\n\n\t\tif ((userId > 0) || (remoteUser == null)) {\n\t\t\treturn userId;\n\t\t}\n\n\t\tuserId = GetterUtil.getLong(remoteUser);\n\n\t\tUser user = UserLocalServiceUtil.getUserById(userId);\n\n\t\tif (user.isDefaultUser()) {\n\t\t\tHttpSession session = request.getSession();\n\n\t\t\tsession.setAttribute(WebKeys.USER, user);\n\t\t\tsession.setAttribute(WebKeys.USER_ID, Long.valueOf(userId));\n\t\t\tsession.setAttribute(Globals.LOCALE_KEY, user.getLocale());\n\n\t\t\treturn userId;\n\t\t}\n\n\t\tEventsProcessorUtil.process(\n\t\t\tPropsKeys.LOGIN_EVENTS_PRE, PropsValues.LOGIN_EVENTS_PRE, request,\n\t\t\tresponse);\n\n\t\tif (PropsValues.USERS_UPDATE_LAST_LOGIN ||\n\t\t\t(user.getLastLoginDate() == null)) {\n\n\t\t\tuser = UserLocalServiceUtil.updateLastLogin(\n\t\t\t\tuserId, request.getRemoteAddr());\n\t\t}\n\n\t\tHttpSession session = request.getSession();\n\n\t\tsession.setAttribute(WebKeys.USER, user);\n\t\tsession.setAttribute(WebKeys.USER_ID, Long.valueOf(userId));\n\t\tsession.setAttribute(Globals.LOCALE_KEY, user.getLocale());\n\n\t\tEventsProcessorUtil.process(\n\t\t\tPropsKeys.LOGIN_EVENTS_POST, PropsValues.LOGIN_EVENTS_POST, request,\n\t\t\tresponse);\n\n\t\treturn userId;\n\t}","commit_id":"0916bd9aaec361d4795ea3637e32bf74ab712a56","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage addMessage(\n\t\t\tString uuid, long userId, long categoryId, long threadId,\n\t\t\tlong parentMessageId, String subject, String body, List files,\n\t\t\tboolean anonymous, double priority, String[] tagsEntries,\n\t\t\tPortletPreferences prefs, Boolean addCommunityPermissions,\n\t\t\tBoolean addGuestPermissions, String[] communityPermissions,\n\t\t\tString[] guestPermissions, ThemeDisplay themeDisplay)\n\t\tthrows PortalException, SystemException {\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\t// Message\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tcategoryId);\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\t\tanonymous = user.isDefaultUser() ? true : anonymous;\n\n\t\tif (prefs == null) {\n\t\t\tlong ownerId = category.getGroupId();\n\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_GROUP;\n\t\t\tlong plid = PortletKeys.PREFS_PLID_SHARED;\n\t\t\tString portletId = PortletKeys.MESSAGE_BOARDS;\n\t\t\tString defaultPreferences = null;\n\n\t\t\tprefs = portletPreferencesLocalService.getPreferences(\n\t\t\t\tcategory.getCompanyId(), ownerId, ownerType, plid,\n\t\t\t\tportletId, defaultPreferences);\n\t\t}\n\n\t\tif (!MBUtil.getAllowAnonymousPosting(prefs)) {\n\t\t\tanonymous = false;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tlong messageId = counterLocalService.increment();\n\n\t\tlogAddMessage(messageId, stopWatch, 1);\n\n\t\tMBMessage message = mbMessagePersistence.create(messageId);\n\n\t\tmessage.setUuid(uuid);\n\t\tmessage.setCompanyId(user.getCompanyId());\n\t\tmessage.setUserId(user.getUserId());\n\t\tmessage.setUserName(user.getFullName());\n\t\tmessage.setCreateDate(now);\n\t\tmessage.setModifiedDate(now);\n\n\t\t// Thread\n\n\t\tMBMessage parentMessage = mbMessagePersistence.fetchByPrimaryKey(\n\t\t\tparentMessageId);\n\n\t\tif (parentMessage == null) {\n\t\t\tparentMessageId = MBMessageImpl.DEFAULT_PARENT_MESSAGE_ID;\n\t\t}\n\n\t\tMBThread thread = null;\n\n\t\tif (threadId > 0) {\n\t\t\tthread = mbThreadPersistence.fetchByPrimaryKey(threadId);\n\t\t}\n\n\t\tif ((thread == null) ||\n\t\t\t(parentMessageId == MBMessageImpl.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\tthreadId = counterLocalService.increment();\n\n\t\t\tthread = mbThreadPersistence.create(threadId);\n\n\t\t\tthread.setCategoryId(categoryId);\n\t\t\tthread.setRootMessageId(messageId);\n\t\t}\n\n\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\tif (anonymous) {\n\t\t\tthread.setLastPostByUserId(0);\n\t\t}\n\t\telse {\n\t\t\tthread.setLastPostByUserId(userId);\n\t\t}\n\n\t\tthread.setLastPostDate(now);\n\n\t\tif (priority != MBThreadImpl.PRIORITY_NOT_GIVEN) {\n\t\t\tthread.setPriority(priority);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 2);\n\n\t\t// Message\n\n\t\tmessage.setCategoryId(categoryId);\n\t\tmessage.setThreadId(threadId);\n\t\tmessage.setParentMessageId(parentMessageId);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments((files.size() > 0 ? true : false));\n\t\tmessage.setAnonymous(anonymous);\n\n\t\t// File attachments\n\n\t\tif (files.size() > 0) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyImpl.SYSTEM_STRING;\n\t\t\tlong groupId = GroupImpl.DEFAULT_PARENT_GROUP_ID;\n\t\t\tlong repositoryId = CompanyImpl.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\t}\n\n\t\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\n\t\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\t\tObjectValuePair ovp = (ObjectValuePair)files.get(i);\n\n\t\t\t\t\tString fileName = (String)ovp.getKey();\n\t\t\t\t\tbyte[] byteArray = (byte[])ovp.getValue();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\t\t\t\t\tdirName + \"/\" + fileName, StringPool.BLANK,\n\t\t\t\t\t\t\tnew String[0], byteArray);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (RemoteException re) {\n\t\t\t\tthrow new SystemException(re);\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 3);\n\n\t\t// Commit\n\n\t\tmbThreadPersistence.update(thread);\n\t\tmbMessagePersistence.update(message);\n\n\t\tlogAddMessage(messageId, stopWatch, 4);\n\n\t\t// Resources\n\n\t\tif (!category.isDiscussion()) {\n\t\t\tif (user.isDefaultUser()) {\n\t\t\t\taddMessageResources(category, message, true, true);\n\t\t\t}\n\t\t\telse if ((addCommunityPermissions != null) &&\n\t\t\t\t\t (addGuestPermissions != null)) {\n\n\t\t\t\taddMessageResources(\n\t\t\t\t\tcategory, message, addCommunityPermissions.booleanValue(),\n\t\t\t\t\taddGuestPermissions.booleanValue());\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddMessageResources(\n\t\t\t\t\tcategory, message, communityPermissions, guestPermissions);\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 5);\n\n\t\t// Statistics\n\n\t\tif (!category.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tcategory.getGroupId(), userId);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 6);\n\n\t\t// Subscriptions\n\n\t\tnotifySubscribers(category, message, prefs, themeDisplay, false);\n\n\t\tlogAddMessage(messageId, stopWatch, 7);\n\n\t\t// Category\n\n\t\tcategory.setLastPostDate(now);\n\n\t\tmbCategoryPersistence.update(category);\n\n\t\tlogAddMessage(messageId, stopWatch, 8);\n\n\t\t// Tags\n\n\t\tupdateTagsAsset(userId, message, tagsEntries);\n\n\t\tlogAddMessage(messageId, stopWatch, 9);\n\n\t\t// Activity trackers\n\n\t\tif (!message.isDiscussion() && !user.isDefaultUser()) {\n\t\t\t/*long receiverUserId = 0;\n\n\t\t\tif (parentMessage != null) {\n\t\t\t\treceiverUserId = parentMessage.getUserId();\n\t\t\t}\n\n\t\t\tactivityTrackerLocalService.addActivityTracker(\n\t\t\t\tuserId, category.getGroupId(), MBMessage.class.getName(),\n\t\t\t\tmessageId, MBActivityKeys.ADD, StringPool.BLANK,\n\t\t\t\treceiverUserId);*/\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 10);\n\n\t\t// Testing roll back\n\n\t\t/*if (true) {\n\t\t\tthrow new SystemException(\"Testing roll back\");\n\t\t}*/\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tif (!category.isDiscussion()) {\n\t\t\t\tIndexer.addMessage(\n\t\t\t\t\tmessage.getCompanyId(), category.getGroupId(),\n\t\t\t\t\tuser.getFullName(), category.getCategoryId(), threadId,\n\t\t\t\t\tmessageId, subject, body, tagsEntries);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(\"Indexing \" + messageId, ioe);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 11);\n\n\t\treturn message;\n\t}","id":23823,"modified_method":"public MBMessage addMessage(\n\t\t\tString uuid, long userId, long categoryId, long threadId,\n\t\t\tlong parentMessageId, String subject, String body, List files,\n\t\t\tboolean anonymous, double priority, String[] tagsEntries,\n\t\t\tPortletPreferences prefs, Boolean addCommunityPermissions,\n\t\t\tBoolean addGuestPermissions, String[] communityPermissions,\n\t\t\tString[] guestPermissions, ThemeDisplay themeDisplay)\n\t\tthrows PortalException, SystemException {\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\t// Message\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tcategoryId);\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\n\t\tif (prefs != null) {\n\t\t\tif (!MBUtil.isAllowAnonymousPosting(prefs)) {\n\t\t\t\tif (anonymous || user.isDefaultUser()) {\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (user.isDefaultUser()) {\n\t\t\tanonymous = true;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tlong messageId = counterLocalService.increment();\n\n\t\tlogAddMessage(messageId, stopWatch, 1);\n\n\t\tMBMessage message = mbMessagePersistence.create(messageId);\n\n\t\tmessage.setUuid(uuid);\n\t\tmessage.setCompanyId(user.getCompanyId());\n\t\tmessage.setUserId(user.getUserId());\n\t\tmessage.setUserName(user.getFullName());\n\t\tmessage.setCreateDate(now);\n\t\tmessage.setModifiedDate(now);\n\n\t\t// Thread\n\n\t\tMBMessage parentMessage = mbMessagePersistence.fetchByPrimaryKey(\n\t\t\tparentMessageId);\n\n\t\tif (parentMessage == null) {\n\t\t\tparentMessageId = MBMessageImpl.DEFAULT_PARENT_MESSAGE_ID;\n\t\t}\n\n\t\tMBThread thread = null;\n\n\t\tif (threadId > 0) {\n\t\t\tthread = mbThreadPersistence.fetchByPrimaryKey(threadId);\n\t\t}\n\n\t\tif ((thread == null) ||\n\t\t\t(parentMessageId == MBMessageImpl.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\tthreadId = counterLocalService.increment();\n\n\t\t\tthread = mbThreadPersistence.create(threadId);\n\n\t\t\tthread.setCategoryId(categoryId);\n\t\t\tthread.setRootMessageId(messageId);\n\t\t}\n\n\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\tif (anonymous) {\n\t\t\tthread.setLastPostByUserId(0);\n\t\t}\n\t\telse {\n\t\t\tthread.setLastPostByUserId(userId);\n\t\t}\n\n\t\tthread.setLastPostDate(now);\n\n\t\tif (priority != MBThreadImpl.PRIORITY_NOT_GIVEN) {\n\t\t\tthread.setPriority(priority);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 2);\n\n\t\t// Message\n\n\t\tmessage.setCategoryId(categoryId);\n\t\tmessage.setThreadId(threadId);\n\t\tmessage.setParentMessageId(parentMessageId);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments((files.size() > 0 ? true : false));\n\t\tmessage.setAnonymous(anonymous);\n\n\t\t// File attachments\n\n\t\tif (files.size() > 0) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyImpl.SYSTEM_STRING;\n\t\t\tlong groupId = GroupImpl.DEFAULT_PARENT_GROUP_ID;\n\t\t\tlong repositoryId = CompanyImpl.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\t}\n\n\t\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\n\t\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\t\tObjectValuePair ovp = (ObjectValuePair)files.get(i);\n\n\t\t\t\t\tString fileName = (String)ovp.getKey();\n\t\t\t\t\tbyte[] byteArray = (byte[])ovp.getValue();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\t\t\t\t\tdirName + \"/\" + fileName, StringPool.BLANK,\n\t\t\t\t\t\t\tnew String[0], byteArray);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (RemoteException re) {\n\t\t\t\tthrow new SystemException(re);\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 3);\n\n\t\t// Commit\n\n\t\tmbThreadPersistence.update(thread);\n\t\tmbMessagePersistence.update(message);\n\n\t\tlogAddMessage(messageId, stopWatch, 4);\n\n\t\t// Resources\n\n\t\tif (!category.isDiscussion()) {\n\t\t\tif (user.isDefaultUser()) {\n\t\t\t\taddMessageResources(category, message, true, true);\n\t\t\t}\n\t\t\telse if ((addCommunityPermissions != null) &&\n\t\t\t\t\t (addGuestPermissions != null)) {\n\n\t\t\t\taddMessageResources(\n\t\t\t\t\tcategory, message, addCommunityPermissions.booleanValue(),\n\t\t\t\t\taddGuestPermissions.booleanValue());\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddMessageResources(\n\t\t\t\t\tcategory, message, communityPermissions, guestPermissions);\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 5);\n\n\t\t// Statistics\n\n\t\tif (!category.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tcategory.getGroupId(), userId);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 6);\n\n\t\t// Subscriptions\n\n\t\tnotifySubscribers(category, message, prefs, themeDisplay, false);\n\n\t\tlogAddMessage(messageId, stopWatch, 7);\n\n\t\t// Category\n\n\t\tcategory.setLastPostDate(now);\n\n\t\tmbCategoryPersistence.update(category);\n\n\t\tlogAddMessage(messageId, stopWatch, 8);\n\n\t\t// Tags\n\n\t\tupdateTagsAsset(userId, message, tagsEntries);\n\n\t\tlogAddMessage(messageId, stopWatch, 9);\n\n\t\t// Activity trackers\n\n\t\tif (!message.isDiscussion() && !user.isDefaultUser()) {\n\t\t\t/*long receiverUserId = 0;\n\n\t\t\tif (parentMessage != null) {\n\t\t\t\treceiverUserId = parentMessage.getUserId();\n\t\t\t}\n\n\t\t\tactivityTrackerLocalService.addActivityTracker(\n\t\t\t\tuserId, category.getGroupId(), MBMessage.class.getName(),\n\t\t\t\tmessageId, MBActivityKeys.ADD, StringPool.BLANK,\n\t\t\t\treceiverUserId);*/\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 10);\n\n\t\t// Testing roll back\n\n\t\t/*if (true) {\n\t\t\tthrow new SystemException(\"Testing roll back\");\n\t\t}*/\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tif (!category.isDiscussion()) {\n\t\t\t\tIndexer.addMessage(\n\t\t\t\t\tmessage.getCompanyId(), category.getGroupId(),\n\t\t\t\t\tuser.getFullName(), category.getCategoryId(), threadId,\n\t\t\t\t\tmessageId, subject, body, tagsEntries);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(\"Indexing \" + messageId, ioe);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 11);\n\n\t\treturn message;\n\t}","commit_id":"6dabb04dc5887dd3ecf7645dc34c9e6ca80781c8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean getAllowAnonymousPosting(PortletPreferences prefs) {\n\t\tString allowAnonymousPosting = prefs.getValue(\n\t\t\t\"allow-anonymous-posting\", StringPool.BLANK);\n\n\t\tif (Validator.isNotNull(allowAnonymousPosting)) {\n\t\t\treturn GetterUtil.getBoolean(allowAnonymousPosting);\n\t\t}\n\t\telse {\n\t\t\treturn GetterUtil.getBoolean(PropsUtil.get(\n\t\t\t\tPropsUtil.MESSAGE_BOARDS_ALLOW_ANONYMOUS_POSTING));\n\t\t}\n\t}","id":23824,"modified_method":"public static boolean isAllowAnonymousPosting(PortletPreferences prefs) {\n\t\tString allowAnonymousPosting = prefs.getValue(\n\t\t\t\"allow-anonymous-posting\", StringPool.BLANK);\n\n\t\tif (Validator.isNotNull(allowAnonymousPosting)) {\n\t\t\treturn GetterUtil.getBoolean(allowAnonymousPosting);\n\t\t}\n\t\telse {\n\t\t\treturn PropsValues.MESSAGE_BOARDS_ANONYMOUS_POSTING_ENABLED;\n\t\t}\n\t}","commit_id":"6dabb04dc5887dd3ecf7645dc34c9e6ca80781c8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void exportToLDAP(\n\t\t\tContact contact, Map<String, Serializable> contactExpandoAttributes)\n\t\tthrows Exception {\n\n\t\tlong companyId = contact.getCompanyId();\n\n\t\tif (!AuthSettingsUtil.isLDAPAuthEnabled(companyId) ||\n\t\t\t!LDAPSettingsUtil.isExportEnabled(companyId)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tUser user = UserLocalServiceUtil.getUserByContactId(\n\t\t\tcontact.getContactId());\n\n\t\tif (user.isDefaultUser()) {\n\t\t\treturn;\n\t\t}\n\n\t\tlong ldapServerId = PortalLDAPUtil.getLdapServerId(\n\t\t\tcompanyId, user.getScreenName(), user.getEmailAddress());\n\n\t\tLdapContext ldapContext = PortalLDAPUtil.getContext(\n\t\t\tldapServerId, companyId);\n\n\t\ttry {\n\t\t\tif (ldapContext == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tProperties contactMappings = LDAPSettingsUtil.getContactMappings(\n\t\t\t\tldapServerId, companyId);\n\t\t\tProperties contactExpandoMappings =\n\t\t\t\tLDAPSettingsUtil.getContactExpandoMappings(\n\t\t\t\t\tldapServerId, companyId);\n\n\t\t\tBinding binding = PortalLDAPUtil.getUser(\n\t\t\t\tldapServerId, contact.getCompanyId(), user.getScreenName(),\n\t\t\t\tuser.getEmailAddress());\n\n\t\t\tif (binding == null) {\n\t\t\t\tProperties userMappings = LDAPSettingsUtil.getUserMappings(\n\t\t\t\t\tldapServerId, companyId);\n\n\t\t\t\tbinding = addUser(\n\t\t\t\t\tldapServerId, ldapContext, user, userMappings);\n\t\t\t}\n\n\t\t\tName name = new CompositeName();\n\n\t\t\tname.add(\n\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\tldapServerId, companyId, binding));\n\n\t\t\tModifications modifications =\n\t\t\t\t_portalToLDAPConverter.getLDAPContactModifications(\n\t\t\t\t\tcontact, contactExpandoAttributes, contactMappings,\n\t\t\t\t\tcontactExpandoMappings);\n\n\t\t\tif (modifications == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tModificationItem[] modificationItems = modifications.getItems();\n\n\t\t\tldapContext.modifyAttributes(name, modificationItems);\n\t\t}\n\t\tfinally {\n\t\t\tif (ldapContext != null) {\n\t\t\t\tldapContext.close();\n\t\t\t}\n\t\t}\n\t}","id":23825,"modified_method":"@Override\n\tpublic void exportToLDAP(\n\t\t\tContact contact, Map<String, Serializable> contactExpandoAttributes)\n\t\tthrows Exception {\n\n\t\tlong companyId = contact.getCompanyId();\n\n\t\tif (!AuthSettingsUtil.isLDAPAuthEnabled(companyId) ||\n\t\t\t!LDAPSettingsUtil.isExportEnabled(companyId)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tUser user = UserLocalServiceUtil.getUserByContactId(\n\t\t\tcontact.getContactId());\n\n\t\tif (user.isDefaultUser() ||\n\t\t\t(user.getStatus() != WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tlong ldapServerId = PortalLDAPUtil.getLdapServerId(\n\t\t\tcompanyId, user.getScreenName(), user.getEmailAddress());\n\n\t\tLdapContext ldapContext = PortalLDAPUtil.getContext(\n\t\t\tldapServerId, companyId);\n\n\t\ttry {\n\t\t\tif (ldapContext == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tProperties contactMappings = LDAPSettingsUtil.getContactMappings(\n\t\t\t\tldapServerId, companyId);\n\t\t\tProperties contactExpandoMappings =\n\t\t\t\tLDAPSettingsUtil.getContactExpandoMappings(\n\t\t\t\t\tldapServerId, companyId);\n\n\t\t\tBinding binding = PortalLDAPUtil.getUser(\n\t\t\t\tldapServerId, contact.getCompanyId(), user.getScreenName(),\n\t\t\t\tuser.getEmailAddress());\n\n\t\t\tif (binding == null) {\n\t\t\t\tProperties userMappings = LDAPSettingsUtil.getUserMappings(\n\t\t\t\t\tldapServerId, companyId);\n\n\t\t\t\tbinding = addUser(\n\t\t\t\t\tldapServerId, ldapContext, user, userMappings);\n\t\t\t}\n\n\t\t\tName name = new CompositeName();\n\n\t\t\tname.add(\n\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\tldapServerId, companyId, binding));\n\n\t\t\tModifications modifications =\n\t\t\t\t_portalToLDAPConverter.getLDAPContactModifications(\n\t\t\t\t\tcontact, contactExpandoAttributes, contactMappings,\n\t\t\t\t\tcontactExpandoMappings);\n\n\t\t\tif (modifications == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tModificationItem[] modificationItems = modifications.getItems();\n\n\t\t\tldapContext.modifyAttributes(name, modificationItems);\n\t\t}\n\t\tfinally {\n\t\t\tif (ldapContext != null) {\n\t\t\t\tldapContext.close();\n\t\t\t}\n\t\t}\n\t}","commit_id":"0bb79c348827fb3af2b10dcbf3e5b7604bbf412b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void exportToLDAP(\n\t\t\tUser user, Map<String, Serializable> userExpandoAttributes)\n\t\tthrows Exception {\n\n\t\tlong companyId = user.getCompanyId();\n\n\t\tif (!AuthSettingsUtil.isLDAPAuthEnabled(companyId) ||\n\t\t\t!LDAPSettingsUtil.isExportEnabled(companyId)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tlong ldapServerId = PortalLDAPUtil.getLdapServerId(\n\t\t\tcompanyId, user.getScreenName(), user.getEmailAddress());\n\n\t\tLdapContext ldapContext = PortalLDAPUtil.getContext(\n\t\t\tldapServerId, companyId);\n\n\t\ttry {\n\t\t\tif (ldapContext == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tProperties userMappings = LDAPSettingsUtil.getUserMappings(\n\t\t\t\tldapServerId, companyId);\n\t\t\tProperties userExpandoMappings =\n\t\t\t\tLDAPSettingsUtil.getUserExpandoMappings(\n\t\t\t\t\tldapServerId, companyId);\n\n\t\t\tBinding binding = PortalLDAPUtil.getUser(\n\t\t\t\tldapServerId, user.getCompanyId(), user.getScreenName(),\n\t\t\t\tuser.getEmailAddress());\n\n\t\t\tif (binding == null) {\n\t\t\t\tbinding = addUser(\n\t\t\t\t\tldapServerId, ldapContext, user, userMappings);\n\t\t\t}\n\n\t\t\tName name = new CompositeName();\n\n\t\t\tname.add(\n\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\tldapServerId, companyId, binding));\n\n\t\t\tModifications modifications =\n\t\t\t\t_portalToLDAPConverter.getLDAPUserModifications(\n\t\t\t\t\tuser, userExpandoAttributes, userMappings,\n\t\t\t\t\tuserExpandoMappings);\n\n\t\t\tif (modifications == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tModificationItem[] modificationItems = modifications.getItems();\n\n\t\t\tldapContext.modifyAttributes(name, modificationItems);\n\n\t\t\tif (!LDAPSettingsUtil.isExportGroupEnabled(companyId)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tList<UserGroup> userGroups =\n\t\t\t\tUserGroupLocalServiceUtil.getUserUserGroups(user.getUserId());\n\n\t\t\tfor (UserGroup userGroup : userGroups) {\n\t\t\t\texportToLDAP(\n\t\t\t\t\tuser.getUserId(), userGroup.getUserGroupId(),\n\t\t\t\t\tLDAPOperation.ADD);\n\t\t\t}\n\n\t\t\tModifications groupModifications =\n\t\t\t\t_portalToLDAPConverter.getLDAPUserGroupModifications(\n\t\t\t\t\tldapServerId, userGroups, user, userMappings);\n\n\t\t\tModificationItem[] groupModificationItems =\n\t\t\t\tgroupModifications.getItems();\n\n\t\t\tif (groupModificationItems.length > 0) {\n\t\t\t\tldapContext.modifyAttributes(name, groupModificationItems);\n\t\t\t}\n\t\t}\n\t\tcatch (NameNotFoundException nnfe) {\n\t\t\tif (PrefsPropsUtil.getBoolean(\n\t\t\t\t\tcompanyId, PropsKeys.LDAP_AUTH_REQUIRED)) {\n\n\t\t\t\tthrow nnfe;\n\t\t\t}\n\n\t\t\t_log.error(nnfe, nnfe);\n\t\t}\n\t\tfinally {\n\t\t\tif (ldapContext != null) {\n\t\t\t\tldapContext.close();\n\t\t\t}\n\t\t}\n\t}","id":23826,"modified_method":"@Override\n\tpublic void exportToLDAP(\n\t\t\tUser user, Map<String, Serializable> userExpandoAttributes)\n\t\tthrows Exception {\n\n\t\tif (user.isDefaultUser() ||\n\t\t\t(user.getStatus() != WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tlong companyId = user.getCompanyId();\n\n\t\tif (!AuthSettingsUtil.isLDAPAuthEnabled(companyId) ||\n\t\t\t!LDAPSettingsUtil.isExportEnabled(companyId)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tlong ldapServerId = PortalLDAPUtil.getLdapServerId(\n\t\t\tcompanyId, user.getScreenName(), user.getEmailAddress());\n\n\t\tLdapContext ldapContext = PortalLDAPUtil.getContext(\n\t\t\tldapServerId, companyId);\n\n\t\ttry {\n\t\t\tif (ldapContext == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tProperties userMappings = LDAPSettingsUtil.getUserMappings(\n\t\t\t\tldapServerId, companyId);\n\t\t\tProperties userExpandoMappings =\n\t\t\t\tLDAPSettingsUtil.getUserExpandoMappings(\n\t\t\t\t\tldapServerId, companyId);\n\n\t\t\tBinding binding = PortalLDAPUtil.getUser(\n\t\t\t\tldapServerId, user.getCompanyId(), user.getScreenName(),\n\t\t\t\tuser.getEmailAddress());\n\n\t\t\tif (binding == null) {\n\t\t\t\tbinding = addUser(\n\t\t\t\t\tldapServerId, ldapContext, user, userMappings);\n\t\t\t}\n\n\t\t\tName name = new CompositeName();\n\n\t\t\tname.add(\n\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\tldapServerId, companyId, binding));\n\n\t\t\tModifications modifications =\n\t\t\t\t_portalToLDAPConverter.getLDAPUserModifications(\n\t\t\t\t\tuser, userExpandoAttributes, userMappings,\n\t\t\t\t\tuserExpandoMappings);\n\n\t\t\tif (modifications == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tModificationItem[] modificationItems = modifications.getItems();\n\n\t\t\tldapContext.modifyAttributes(name, modificationItems);\n\n\t\t\tif (!LDAPSettingsUtil.isExportGroupEnabled(companyId)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tList<UserGroup> userGroups =\n\t\t\t\tUserGroupLocalServiceUtil.getUserUserGroups(user.getUserId());\n\n\t\t\tfor (UserGroup userGroup : userGroups) {\n\t\t\t\texportToLDAP(\n\t\t\t\t\tuser.getUserId(), userGroup.getUserGroupId(),\n\t\t\t\t\tLDAPOperation.ADD);\n\t\t\t}\n\n\t\t\tModifications groupModifications =\n\t\t\t\t_portalToLDAPConverter.getLDAPUserGroupModifications(\n\t\t\t\t\tldapServerId, userGroups, user, userMappings);\n\n\t\t\tModificationItem[] groupModificationItems =\n\t\t\t\tgroupModifications.getItems();\n\n\t\t\tif (groupModificationItems.length > 0) {\n\t\t\t\tldapContext.modifyAttributes(name, groupModificationItems);\n\t\t\t}\n\t\t}\n\t\tcatch (NameNotFoundException nnfe) {\n\t\t\tif (PrefsPropsUtil.getBoolean(\n\t\t\t\t\tcompanyId, PropsKeys.LDAP_AUTH_REQUIRED)) {\n\n\t\t\t\tthrow nnfe;\n\t\t\t}\n\n\t\t\t_log.error(nnfe, nnfe);\n\t\t}\n\t\tfinally {\n\t\t\tif (ldapContext != null) {\n\t\t\t\tldapContext.close();\n\t\t\t}\n\t\t}\n\t}","commit_id":"0bb79c348827fb3af2b10dcbf3e5b7604bbf412b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeBytesReference(source);\n        out.writeVInt(types.length);\n        for (String type : types) {\n            out.writeString(type);\n        }\n        if (routing != null) {\n            out.writeVInt(routing.size());\n            for (String r : routing) {\n                out.writeString(r);\n            }\n        } else {\n            out.writeVInt(0);\n        }\n        if (filteringAliases != null) {\n            out.writeVInt(filteringAliases.length);\n            for (String alias : filteringAliases) {\n                out.writeString(alias);\n            }\n        } else {\n            out.writeVInt(0);\n        }\n    }","id":23827,"modified_method":"public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeBytesReference(source);\n        out.writeVInt(types.length);\n        for (String type : types) {\n            out.writeString(type);\n        }\n        if (routing != null) {\n            out.writeVInt(routing.size());\n            for (String r : routing) {\n                out.writeString(r);\n            }\n        } else {\n            out.writeVInt(0);\n        }\n        if (filteringAliases != null) {\n            out.writeVInt(filteringAliases.length);\n            for (String alias : filteringAliases) {\n                out.writeString(alias);\n            }\n        } else {\n            out.writeVInt(0);\n        }\n        if (out.getVersion().onOrAfter(Version.V_1_2_0)) {\n            out.writeVLong(nowInMillis);\n        }\n    }","commit_id":"196e3c360261cc4cf25a4d859b41bca3b189c57d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        source = in.readBytesReference();\n        int typesSize = in.readVInt();\n        if (typesSize > 0) {\n            types = new String[typesSize];\n            for (int i = 0; i < typesSize; i++) {\n                types[i] = in.readString();\n            }\n        }\n        int routingSize = in.readVInt();\n        if (routingSize > 0) {\n            routing = new HashSet<String>(routingSize);\n            for (int i = 0; i < routingSize; i++) {\n                routing.add(in.readString());\n            }\n        }\n        int aliasesSize = in.readVInt();\n        if (aliasesSize > 0) {\n            filteringAliases = new String[aliasesSize];\n            for (int i = 0; i < aliasesSize; i++) {\n                filteringAliases[i] = in.readString();\n            }\n        }\n    }","id":23828,"modified_method":"public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        source = in.readBytesReference();\n        int typesSize = in.readVInt();\n        if (typesSize > 0) {\n            types = new String[typesSize];\n            for (int i = 0; i < typesSize; i++) {\n                types[i] = in.readString();\n            }\n        }\n        int routingSize = in.readVInt();\n        if (routingSize > 0) {\n            routing = new HashSet<String>(routingSize);\n            for (int i = 0; i < routingSize; i++) {\n                routing.add(in.readString());\n            }\n        }\n        int aliasesSize = in.readVInt();\n        if (aliasesSize > 0) {\n            filteringAliases = new String[aliasesSize];\n            for (int i = 0; i < aliasesSize; i++) {\n                filteringAliases[i] = in.readString();\n            }\n        }\n        if (in.getVersion().onOrAfter(Version.V_1_2_0)) {\n            nowInMillis = in.readVLong();\n        } else {\n            nowInMillis = System.currentTimeMillis();\n        }\n    }","commit_id":"196e3c360261cc4cf25a4d859b41bca3b189c57d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"IndexDeleteByQueryRequest(DeleteByQueryRequest request, String index, @Nullable Set<String> routing, @Nullable String[] filteringAliases) {\n        this.index = index;\n        this.timeout = request.timeout();\n        this.source = request.source();\n        this.types = request.types();\n        this.replicationType = request.replicationType();\n        this.consistencyLevel = request.consistencyLevel();\n        this.routing = routing;\n        this.filteringAliases = filteringAliases;\n    }","id":23829,"modified_method":"IndexDeleteByQueryRequest(DeleteByQueryRequest request, String index, @Nullable Set<String> routing, @Nullable String[] filteringAliases,\n                              long nowInMillis\n    ) {\n        this.index = index;\n        this.timeout = request.timeout();\n        this.source = request.source();\n        this.types = request.types();\n        this.replicationType = request.replicationType();\n        this.consistencyLevel = request.consistencyLevel();\n        this.routing = routing;\n        this.filteringAliases = filteringAliases;\n        this.nowInMillis = nowInMillis;\n    }","commit_id":"196e3c360261cc4cf25a4d859b41bca3b189c57d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"ShardDeleteByQueryRequest(IndexDeleteByQueryRequest request, int shardId) {\n        super(request);\n        this.index = request.index();\n        this.source = request.source();\n        this.types = request.types();\n        this.shardId = shardId;\n        replicationType(request.replicationType());\n        consistencyLevel(request.consistencyLevel());\n        timeout = request.timeout();\n        this.routing = request.routing();\n        filteringAliases = request.filteringAliases();\n    }","id":23830,"modified_method":"ShardDeleteByQueryRequest(IndexDeleteByQueryRequest request, int shardId) {\n        super(request);\n        this.index = request.index();\n        this.source = request.source();\n        this.types = request.types();\n        this.shardId = shardId;\n        replicationType(request.replicationType());\n        consistencyLevel(request.consistencyLevel());\n        timeout = request.timeout();\n        this.routing = request.routing();\n        filteringAliases = request.filteringAliases();\n        nowInMillis = request.nowInMillis();\n    }","commit_id":"196e3c360261cc4cf25a4d859b41bca3b189c57d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeBytesReference(source);\n        out.writeVInt(shardId);\n        out.writeStringArray(types);\n        if (routing != null) {\n            out.writeVInt(routing.size());\n            for (String r : routing) {\n                out.writeString(r);\n            }\n        } else {\n            out.writeVInt(0);\n        }\n        if (filteringAliases != null) {\n            out.writeVInt(filteringAliases.length);\n            for (String alias : filteringAliases) {\n                out.writeString(alias);\n            }\n        } else {\n            out.writeVInt(0);\n        }\n    }","id":23831,"modified_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeBytesReference(source);\n        out.writeVInt(shardId);\n        out.writeStringArray(types);\n        if (routing != null) {\n            out.writeVInt(routing.size());\n            for (String r : routing) {\n                out.writeString(r);\n            }\n        } else {\n            out.writeVInt(0);\n        }\n        if (filteringAliases != null) {\n            out.writeVInt(filteringAliases.length);\n            for (String alias : filteringAliases) {\n                out.writeString(alias);\n            }\n        } else {\n            out.writeVInt(0);\n        }\n        if (out.getVersion().onOrAfter(Version.V_1_2_0)) {\n            out.writeVLong(nowInMillis);\n        }\n    }","commit_id":"196e3c360261cc4cf25a4d859b41bca3b189c57d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        source = in.readBytesReference();\n        shardId = in.readVInt();\n        types = in.readStringArray();\n        int routingSize = in.readVInt();\n        if (routingSize > 0) {\n            routing = new HashSet<String>(routingSize);\n            for (int i = 0; i < routingSize; i++) {\n                routing.add(in.readString());\n            }\n        }\n        int aliasesSize = in.readVInt();\n        if (aliasesSize > 0) {\n            filteringAliases = new String[aliasesSize];\n            for (int i = 0; i < aliasesSize; i++) {\n                filteringAliases[i] = in.readString();\n            }\n        }\n    }","id":23832,"modified_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        source = in.readBytesReference();\n        shardId = in.readVInt();\n        types = in.readStringArray();\n        int routingSize = in.readVInt();\n        if (routingSize > 0) {\n            routing = new HashSet<String>(routingSize);\n            for (int i = 0; i < routingSize; i++) {\n                routing.add(in.readString());\n            }\n        }\n        int aliasesSize = in.readVInt();\n        if (aliasesSize > 0) {\n            filteringAliases = new String[aliasesSize];\n            for (int i = 0; i < aliasesSize; i++) {\n                filteringAliases[i] = in.readString();\n            }\n        }\n\n        if (in.getVersion().onOrAfter(Version.V_1_2_0)) {\n            nowInMillis = in.readVLong();\n        } else {\n            nowInMillis = System.currentTimeMillis();\n        }\n    }","commit_id":"196e3c360261cc4cf25a4d859b41bca3b189c57d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected IndexDeleteByQueryRequest newIndexRequestInstance(DeleteByQueryRequest request, String index, Set<String> routing) {\n        String[] filteringAliases = clusterService.state().metaData().filteringAliases(index, request.indices());\n        return new IndexDeleteByQueryRequest(request, index, routing, filteringAliases);\n    }","id":23833,"modified_method":"@Override\n    protected IndexDeleteByQueryRequest newIndexRequestInstance(DeleteByQueryRequest request, String index, Set<String> routing, long startTimeInMillis) {\n        String[] filteringAliases = clusterService.state().metaData().filteringAliases(index, request.indices());\n        return new IndexDeleteByQueryRequest(request, index, routing, filteringAliases, startTimeInMillis);\n    }","commit_id":"196e3c360261cc4cf25a4d859b41bca3b189c57d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected abstract IndexRequest newIndexRequestInstance(Request request, String index, Set<String> routing);","id":23834,"modified_method":"protected abstract IndexRequest newIndexRequestInstance(Request request, String index, Set<String> routing, long startTimeInMillis);","commit_id":"196e3c360261cc4cf25a4d859b41bca3b189c57d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void doExecute(final Request request, final ActionListener<Response> listener) {\n        ClusterState clusterState = clusterService.state();\n        ClusterBlockException blockException = checkGlobalBlock(clusterState, request);\n        if (blockException != null) {\n            throw blockException;\n        }\n        // get actual indices\n        String[] concreteIndices = clusterState.metaData().concreteIndices(request.indices(), request.indicesOptions());\n        blockException = checkRequestBlock(clusterState, request, concreteIndices);\n        if (blockException != null) {\n            throw blockException;\n        }\n\n        final AtomicInteger indexCounter = new AtomicInteger();\n        final AtomicInteger completionCounter = new AtomicInteger(concreteIndices.length);\n        final AtomicReferenceArray<Object> indexResponses = new AtomicReferenceArray<Object>(concreteIndices.length);\n\n        Map<String, Set<String>> routingMap = resolveRouting(clusterState, request);\n        if (concreteIndices == null || concreteIndices.length == 0) {\n            listener.onResponse(newResponseInstance(request, indexResponses));\n        } else {\n            for (final String index : concreteIndices) {\n                Set<String> routing = null;\n                if (routingMap != null) {\n                    routing = routingMap.get(index);\n                }\n                IndexRequest indexRequest = newIndexRequestInstance(request, index, routing);\n                // no threading needed, all is done on the index replication one\n                indexRequest.listenerThreaded(false);\n                indexAction.execute(indexRequest, new ActionListener<IndexResponse>() {\n                    @Override\n                    public void onResponse(IndexResponse result) {\n                        indexResponses.set(indexCounter.getAndIncrement(), result);\n                        if (completionCounter.decrementAndGet() == 0) {\n                            listener.onResponse(newResponseInstance(request, indexResponses));\n                        }\n                    }\n    \n                    @Override\n                    public void onFailure(Throwable e) {\n                        int index = indexCounter.getAndIncrement();\n                        if (accumulateExceptions()) {\n                            indexResponses.set(index, e);\n                        }\n                        if (completionCounter.decrementAndGet() == 0) {\n                            listener.onResponse(newResponseInstance(request, indexResponses));\n                        }\n                    }\n                });\n            }\n        }\n    }","id":23835,"modified_method":"@Override\n    protected void doExecute(final Request request, final ActionListener<Response> listener) {\n        ClusterState clusterState = clusterService.state();\n        ClusterBlockException blockException = checkGlobalBlock(clusterState, request);\n        if (blockException != null) {\n            throw blockException;\n        }\n        // get actual indices\n        String[] concreteIndices = clusterState.metaData().concreteIndices(request.indices(), request.indicesOptions());\n        blockException = checkRequestBlock(clusterState, request, concreteIndices);\n        if (blockException != null) {\n            throw blockException;\n        }\n\n        final AtomicInteger indexCounter = new AtomicInteger();\n        final AtomicInteger completionCounter = new AtomicInteger(concreteIndices.length);\n        final AtomicReferenceArray<Object> indexResponses = new AtomicReferenceArray<Object>(concreteIndices.length);\n        final long startTimeInMillis = System.currentTimeMillis();\n\n        Map<String, Set<String>> routingMap = resolveRouting(clusterState, request);\n        if (concreteIndices == null || concreteIndices.length == 0) {\n            listener.onResponse(newResponseInstance(request, indexResponses));\n        } else {\n            for (final String index : concreteIndices) {\n                Set<String> routing = null;\n                if (routingMap != null) {\n                    routing = routingMap.get(index);\n                }\n                IndexRequest indexRequest = newIndexRequestInstance(request, index, routing, startTimeInMillis);\n                // no threading needed, all is done on the index replication one\n                indexRequest.listenerThreaded(false);\n                indexAction.execute(indexRequest, new ActionListener<IndexResponse>() {\n                    @Override\n                    public void onResponse(IndexResponse result) {\n                        indexResponses.set(indexCounter.getAndIncrement(), result);\n                        if (completionCounter.decrementAndGet() == 0) {\n                            listener.onResponse(newResponseInstance(request, indexResponses));\n                        }\n                    }\n    \n                    @Override\n                    public void onFailure(Throwable e) {\n                        int index = indexCounter.getAndIncrement();\n                        if (accumulateExceptions()) {\n                            indexResponses.set(index, e);\n                        }\n                        if (completionCounter.decrementAndGet() == 0) {\n                            listener.onResponse(newResponseInstance(request, indexResponses));\n                        }\n                    }\n                });\n            }\n        }\n    }","commit_id":"196e3c360261cc4cf25a4d859b41bca3b189c57d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void shardOperationOnReplica(ReplicaOperationRequest shardRequest) {\n        ShardDeleteByQueryRequest request = shardRequest.request;\n        IndexService indexService = indicesService.indexServiceSafe(shardRequest.request.index());\n        IndexShard indexShard = indexService.shardSafe(shardRequest.shardId);\n\n        SearchContext.setCurrent(new DefaultSearchContext(0, new ShardSearchRequest().types(request.types()), null,\n                indexShard.acquireSearcher(\"delete_by_query\", IndexShard.Mode.WRITE), indexService, indexShard, scriptService,\n                cacheRecycler, pageCacheRecycler, bigArrays));\n        try {\n            Engine.DeleteByQuery deleteByQuery = indexShard.prepareDeleteByQuery(request.source(), request.filteringAliases(), request.types())\n                    .origin(Engine.Operation.Origin.REPLICA);\n            SearchContext.current().parsedQuery(new ParsedQuery(deleteByQuery.query(), ImmutableMap.<String, Filter>of()));\n            indexShard.deleteByQuery(deleteByQuery);\n        } finally {\n            SearchContext searchContext = SearchContext.current();\n            searchContext.clearAndRelease();\n            SearchContext.removeCurrent();\n        }\n    }","id":23836,"modified_method":"@Override\n    protected void shardOperationOnReplica(ReplicaOperationRequest shardRequest) {\n        ShardDeleteByQueryRequest request = shardRequest.request;\n        IndexService indexService = indicesService.indexServiceSafe(shardRequest.request.index());\n        IndexShard indexShard = indexService.shardSafe(shardRequest.shardId);\n\n        SearchContext.setCurrent(new DefaultSearchContext(0, new ShardSearchRequest().types(request.types()).nowInMillis(request.nowInMillis()), null,\n                indexShard.acquireSearcher(\"delete_by_query\", IndexShard.Mode.WRITE), indexService, indexShard, scriptService,\n                cacheRecycler, pageCacheRecycler, bigArrays));\n        try {\n            Engine.DeleteByQuery deleteByQuery = indexShard.prepareDeleteByQuery(request.source(), request.filteringAliases(), request.types())\n                    .origin(Engine.Operation.Origin.REPLICA);\n            SearchContext.current().parsedQuery(new ParsedQuery(deleteByQuery.query(), ImmutableMap.<String, Filter>of()));\n            indexShard.deleteByQuery(deleteByQuery);\n        } finally {\n            SearchContext searchContext = SearchContext.current();\n            searchContext.clearAndRelease();\n            SearchContext.removeCurrent();\n        }\n    }","commit_id":"196e3c360261cc4cf25a4d859b41bca3b189c57d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected PrimaryResponse<ShardDeleteByQueryResponse, ShardDeleteByQueryRequest> shardOperationOnPrimary(ClusterState clusterState, PrimaryOperationRequest shardRequest) {\n        ShardDeleteByQueryRequest request = shardRequest.request;\n        IndexService indexService = indicesService.indexServiceSafe(shardRequest.request.index());\n        IndexShard indexShard = indexService.shardSafe(shardRequest.shardId);\n\n        SearchContext.setCurrent(new DefaultSearchContext(0, new ShardSearchRequest().types(request.types()), null,\n                indexShard.acquireSearcher(\"delete_by_query\"), indexService, indexShard, scriptService, cacheRecycler,\n                pageCacheRecycler, bigArrays));\n        try {\n            Engine.DeleteByQuery deleteByQuery = indexShard.prepareDeleteByQuery(request.source(), request.filteringAliases(), request.types())\n                    .origin(Engine.Operation.Origin.PRIMARY);\n            SearchContext.current().parsedQuery(new ParsedQuery(deleteByQuery.query(), ImmutableMap.<String, Filter>of()));\n            indexShard.deleteByQuery(deleteByQuery);\n        } finally {\n            SearchContext searchContext = SearchContext.current();\n            searchContext.clearAndRelease();\n            SearchContext.removeCurrent();\n        }\n        return new PrimaryResponse<ShardDeleteByQueryResponse, ShardDeleteByQueryRequest>(shardRequest.request, new ShardDeleteByQueryResponse(), null);\n    }","id":23837,"modified_method":"@Override\n    protected PrimaryResponse<ShardDeleteByQueryResponse, ShardDeleteByQueryRequest> shardOperationOnPrimary(ClusterState clusterState, PrimaryOperationRequest shardRequest) {\n        ShardDeleteByQueryRequest request = shardRequest.request;\n        IndexService indexService = indicesService.indexServiceSafe(shardRequest.request.index());\n        IndexShard indexShard = indexService.shardSafe(shardRequest.shardId);\n\n        SearchContext.setCurrent(new DefaultSearchContext(0, new ShardSearchRequest().types(request.types()).nowInMillis(request.nowInMillis()), null,\n                indexShard.acquireSearcher(\"delete_by_query\"), indexService, indexShard, scriptService, cacheRecycler,\n                pageCacheRecycler, bigArrays));\n        try {\n            Engine.DeleteByQuery deleteByQuery = indexShard.prepareDeleteByQuery(request.source(), request.filteringAliases(), request.types())\n                    .origin(Engine.Operation.Origin.PRIMARY);\n            SearchContext.current().parsedQuery(new ParsedQuery(deleteByQuery.query(), ImmutableMap.<String, Filter>of()));\n            indexShard.deleteByQuery(deleteByQuery);\n        } finally {\n            SearchContext searchContext = SearchContext.current();\n            searchContext.clearAndRelease();\n            SearchContext.removeCurrent();\n        }\n        return new PrimaryResponse<ShardDeleteByQueryResponse, ShardDeleteByQueryRequest>(shardRequest.request, new ShardDeleteByQueryResponse(), null);\n    }","commit_id":"196e3c360261cc4cf25a4d859b41bca3b189c57d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeBytesReference(querySource);\n\n        out.writeVInt(types.length);\n        for (String type : types) {\n            out.writeString(type);\n        }\n        if (filteringAliases != null) {\n            out.writeVInt(filteringAliases.length);\n            for (String alias : filteringAliases) {\n                out.writeString(alias);\n            }\n        } else {\n            out.writeVInt(0);\n        }\n\n        out.writeBoolean(explain);\n    }","id":23838,"modified_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeBytesReference(querySource);\n\n        out.writeVInt(types.length);\n        for (String type : types) {\n            out.writeString(type);\n        }\n        if (filteringAliases != null) {\n            out.writeVInt(filteringAliases.length);\n            for (String alias : filteringAliases) {\n                out.writeString(alias);\n            }\n        } else {\n            out.writeVInt(0);\n        }\n\n        out.writeBoolean(explain);\n\n        if (out.getVersion().onOrAfter(Version.V_0_90_6)) {\n            out.writeVLong(nowInMillis);\n        }\n    }","commit_id":"0d3895533c004cf40d75226efd62ec833981741a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ShardValidateQueryRequest(String index, int shardId, @Nullable String[] filteringAliases, ValidateQueryRequest request) {\n        super(index, shardId, request);\n        this.querySource = request.querySource();\n        this.types = request.types();\n        this.explain = request.explain();\n        this.filteringAliases = filteringAliases;\n    }","id":23839,"modified_method":"public ShardValidateQueryRequest(String index, int shardId, @Nullable String[] filteringAliases, ValidateQueryRequest request) {\n        super(index, shardId, request);\n        this.querySource = request.querySource();\n        this.types = request.types();\n        this.explain = request.explain();\n        this.filteringAliases = filteringAliases;\n        this.nowInMillis = request.nowInMillis;\n    }","commit_id":"0d3895533c004cf40d75226efd62ec833981741a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        querySource = in.readBytesReference();\n\n        int typesSize = in.readVInt();\n        if (typesSize > 0) {\n            types = new String[typesSize];\n            for (int i = 0; i < typesSize; i++) {\n                types[i] = in.readString();\n            }\n        }\n        int aliasesSize = in.readVInt();\n        if (aliasesSize > 0) {\n            filteringAliases = new String[aliasesSize];\n            for (int i = 0; i < aliasesSize; i++) {\n                filteringAliases[i] = in.readString();\n            }\n        }\n\n        explain = in.readBoolean();\n    }","id":23840,"modified_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        querySource = in.readBytesReference();\n\n        int typesSize = in.readVInt();\n        if (typesSize > 0) {\n            types = new String[typesSize];\n            for (int i = 0; i < typesSize; i++) {\n                types[i] = in.readString();\n            }\n        }\n        int aliasesSize = in.readVInt();\n        if (aliasesSize > 0) {\n            filteringAliases = new String[aliasesSize];\n            for (int i = 0; i < aliasesSize; i++) {\n                filteringAliases[i] = in.readString();\n            }\n        }\n\n        explain = in.readBoolean();\n\n        if (in.getVersion().onOrAfter(Version.V_0_90_6)) {\n            nowInMillis = in.readVLong();\n        } else {\n            nowInMillis = System.currentTimeMillis();\n        }\n    }","commit_id":"0d3895533c004cf40d75226efd62ec833981741a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected ShardValidateQueryResponse shardOperation(ShardValidateQueryRequest request) throws ElasticSearchException {\n        IndexQueryParserService queryParserService = indicesService.indexServiceSafe(request.index()).queryParserService();\n        IndexService indexService = indicesService.indexServiceSafe(request.index());\n        IndexShard indexShard = indexService.shardSafe(request.shardId());\n\n        boolean valid;\n        String explanation = null;\n        String error = null;\n        if (request.querySource().length() == 0) {\n            valid = true;\n        } else {\n            SearchContext.setCurrent(new DefaultSearchContext(0,\n                    new ShardSearchRequest().types(request.types()),\n                    null, indexShard.acquireSearcher(), indexService, indexShard,\n                    scriptService, cacheRecycler));\n            try {\n                ParsedQuery parsedQuery = queryParserService.parse(request.querySource());\n                valid = true;\n                if (request.explain()) {\n                    explanation = parsedQuery.query().toString();\n                }\n            } catch (QueryParsingException e) {\n                valid = false;\n                error = e.getDetailedMessage();\n            } catch (AssertionError e) {\n                valid = false;\n                error = e.getMessage();\n            } finally {\n                SearchContext.current().release();\n                SearchContext.removeCurrent();\n            }\n        }\n        return new ShardValidateQueryResponse(request.index(), request.shardId(), valid, explanation, error);\n    }","id":23841,"modified_method":"@Override\n    protected ShardValidateQueryResponse shardOperation(ShardValidateQueryRequest request) throws ElasticSearchException {\n        IndexQueryParserService queryParserService = indicesService.indexServiceSafe(request.index()).queryParserService();\n        IndexService indexService = indicesService.indexServiceSafe(request.index());\n        IndexShard indexShard = indexService.shardSafe(request.shardId());\n\n        boolean valid;\n        String explanation = null;\n        String error = null;\n        if (request.querySource().length() == 0) {\n            valid = true;\n        } else {\n            SearchContext.setCurrent(new DefaultSearchContext(0,\n                    new ShardSearchRequest().types(request.types()).nowInMillis(request.nowInMillis()),\n                    null, indexShard.acquireSearcher(), indexService, indexShard,\n                    scriptService, cacheRecycler));\n            try {\n                ParsedQuery parsedQuery = queryParserService.parse(request.querySource());\n                valid = true;\n                if (request.explain()) {\n                    explanation = parsedQuery.query().toString();\n                }\n            } catch (QueryParsingException e) {\n                valid = false;\n                error = e.getDetailedMessage();\n            } catch (AssertionError e) {\n                valid = false;\n                error = e.getMessage();\n            } finally {\n                SearchContext.current().release();\n                SearchContext.removeCurrent();\n            }\n        }\n        return new ShardValidateQueryResponse(request.index(), request.shardId(), valid, explanation, error);\n    }","commit_id":"0d3895533c004cf40d75226efd62ec833981741a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public Object onCall(UMOEventContext eventContext) throws Exception {\n\n        UMOMessage requestMessage = new MuleMessage(eventContext.getTransformedMessage(), eventContext.getMessage());\n\n        UMOMessage responseMessage = requestMessage;\n        Object builtMessage;\n\n        if(descriptor.getOutboundRouter().hasEndpoints() ) {\n            List endpoints = new ArrayList();\n            for (Iterator iterator = descriptor.getOutboundRouter().getRouters().iterator(); iterator.hasNext();) {\n                UMOOutboundRouter router = (UMOOutboundRouter) iterator.next();\n                endpoints.addAll(router.getEndpoints());\n            }\n            for (Iterator iterator = endpoints.iterator(); iterator.hasNext();) {\n                UMOEndpoint endpoint = (UMOEndpoint) iterator.next();\n                boolean rsync = eventContext.getBooleanProperty(\n                        MuleProperties.MULE_REMOTE_SYNC_PROPERTY, endpoint.isRemoteSync());\n                if(!rsync) {\n                    logger.info(\"Endpoint: \" + endpoint + \" is not remoteSync enabled. Message builder finishing\");\n                    if(eventContext.isSynchronous()) {\n                        responseMessage = eventContext.sendEvent(requestMessage, endpoint);\n                    } else {\n                        eventContext.dispatchEvent(requestMessage, endpoint);\n                        responseMessage=null;\n                    }\n                    break;\n                } else {\n                    responseMessage = eventContext.sendEvent(requestMessage, endpoint);\n                    builtMessage = buildMessage(requestMessage, responseMessage);\n                    responseMessage = new MuleMessage(builtMessage, responseMessage);\n                    requestMessage = responseMessage;\n                }\n            }\n        } else {\n            logger.info(\"There are currently no endpoints configured on component: \" + descriptor.getName());\n        }\n        eventContext.setStopFurtherProcessing(true);\n        return responseMessage;\n    }","id":23842,"modified_method":"public Object onCall(UMOEventContext eventContext) throws Exception {\n\n        UMOMessage requestMessage = new MuleMessage(eventContext.getTransformedMessage(), eventContext.getMessage());\n\n        UMOMessage responseMessage = requestMessage;\n        Object builtMessage;\n\n        if(descriptor.getOutboundRouter().hasEndpoints() ) {\n            List endpoints = new ArrayList();\n            for (Iterator iterator = descriptor.getOutboundRouter().getRouters().iterator(); iterator.hasNext();) {\n                UMOOutboundRouter router = (UMOOutboundRouter) iterator.next();\n                endpoints.addAll(router.getEndpoints());\n            }\n            for (Iterator iterator = endpoints.iterator(); iterator.hasNext();) {\n                UMOEndpoint endpoint = (UMOEndpoint) iterator.next();\n                boolean rsync = eventContext.getMessage().getBooleanProperty(\n                        MuleProperties.MULE_REMOTE_SYNC_PROPERTY, endpoint.isRemoteSync());\n                if(!rsync) {\n                    logger.info(\"Endpoint: \" + endpoint + \" is not remoteSync enabled. Message builder finishing\");\n                    if(eventContext.isSynchronous()) {\n                        responseMessage = eventContext.sendEvent(requestMessage, endpoint);\n                    } else {\n                        eventContext.dispatchEvent(requestMessage, endpoint);\n                        responseMessage=null;\n                    }\n                    break;\n                } else {\n                    responseMessage = eventContext.sendEvent(requestMessage, endpoint);\n                    builtMessage = buildMessage(requestMessage, responseMessage);\n                    responseMessage = new MuleMessage(builtMessage, responseMessage);\n                    requestMessage = responseMessage;\n                }\n            }\n        } else {\n            logger.info(\"There are currently no endpoints configured on component: \" + descriptor.getName());\n        }\n        eventContext.setStopFurtherProcessing(true);\n        return responseMessage;\n    }","commit_id":"f659778f07cc26d6d970061c635faba08bd4672b","url":"https://github.com/mulesoft/mule"},{"original_method":"public final UMOMessage send(UMOEvent event) throws DispatchException\n    {\n        try {\n            event.setSynchronous(true);\n            event.setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint().getEndpointURI().toString());\n            RequestContext.setEvent(event);\n            // Apply Security filter if one is set\n            UMOEndpoint endpoint = event.getEndpoint();\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(event);\n                } catch (org.mule.umo.security.SecurityException e) {\n                    logger.warn(\"Outbound Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.SECURITY_AUTHENTICATION_FAILED));\n                    connector.handleException(e);\n                    return event.getMessage();\n                } catch (UMOException e) {\n                    dispose();\n                    throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n            // the security filter may update the payload so we need to get the\n            // latest event again\n            event = RequestContext.getEvent();\n            try {\n                UMOMessage result = doSend(event);\n                if(connector.isEnableMessageEvents()) {\n                    String component = null;\n                    if(event.getComponent()!=null) {\n                        component = event.getComponent().getDescriptor().getName();\n                    }\n                    connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), component, MessageNotification.MESSAGE_SENT));\n                }\n                //Once a dispatcher has done its work we need to romve this property so that\n                //it is not propagated to the next request\n                if(result!=null) {\n                    result.removeProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY);\n                }\n                return result;\n            } catch (DispatchException e) {\n                dispose();\n                throw e;\n            } catch (Exception e) {\n                dispose();\n                throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n            }\n        } finally {\n            if(connector.isCreateDispatcherPerRequest()) {\n                dispose();\n            }\n        }\n    }","id":23843,"modified_method":"public final UMOMessage send(UMOEvent event) throws DispatchException\n    {\n        try {\n            event.setSynchronous(true);\n            event.getMessage().setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint().getEndpointURI().toString());\n            RequestContext.setEvent(event);\n            // Apply Security filter if one is set\n            UMOEndpoint endpoint = event.getEndpoint();\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(event);\n                } catch (org.mule.umo.security.SecurityException e) {\n                    logger.warn(\"Outbound Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.SECURITY_AUTHENTICATION_FAILED));\n                    connector.handleException(e);\n                    return event.getMessage();\n                } catch (UMOException e) {\n                    dispose();\n                    throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n            // the security filter may update the payload so we need to get the\n            // latest event again\n            event = RequestContext.getEvent();\n            try {\n                UMOMessage result = doSend(event);\n                if(connector.isEnableMessageEvents()) {\n                    String component = null;\n                    if(event.getComponent()!=null) {\n                        component = event.getComponent().getDescriptor().getName();\n                    }\n                    connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), component, MessageNotification.MESSAGE_SENT));\n                }\n                //Once a dispatcher has done its work we need to romve this property so that\n                //it is not propagated to the next request\n                if(result!=null) {\n                    result.removeProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY);\n                }\n                return result;\n            } catch (DispatchException e) {\n                dispose();\n                throw e;\n            } catch (Exception e) {\n                dispose();\n                throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n            }\n        } finally {\n            if(connector.isCreateDispatcherPerRequest()) {\n                dispose();\n            }\n        }\n    }","commit_id":"f659778f07cc26d6d970061c635faba08bd4672b","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * RemoteSync causes the message dispatch to wait for a response to an event on a response channel\n     * after it sends the event.  The following rules apply to RemoteSync\n     * 1.  The connector has to support remoteSync. Some transports do not have the notion of a response channel\n     * 2. Check if the endpoint has been configured for remoteSync\n     * 3. Check if the REMOTE_SYNC message header has been set\n     * 4. Finally, if the current component has a response router configured, that the router will handle the\n     * response channel event and we should not try and receive a response in the Message dispatcher\n     *\n     * If remotesync should not be used we must remove the REMOTE_SYNC header\n     *\n     * Note the MuleClient will automatically set the REMOTE_SYNC header when client.send(..) is called so that\n     * results are returned from remote invocations too.\n     * @param event the current event\n     * @return true if a response channel should be used to get a resposne from the event dispatch.\n     */\n    protected boolean useRemoteSync(UMOEvent event) {\n        boolean remoteSync = false;\n        if(event.getEndpoint().getConnector().isRemoteSyncEnabled()) {\n            remoteSync = event.getEndpoint().isRemoteSync() ||\n                    event.getMessage().getBooleanProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY, false);\n            if(remoteSync) {\n                //component will be null for client calls\n                if(event.getComponent()!=null) {\n                    remoteSync = event.getComponent().getDescriptor().getResponseRouter() == null;\n                }\n            }\n        }\n        if(!remoteSync) {\n            event.removeProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY);\n            event.getMessage().removeProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY);\n        }\n        return remoteSync;\n    }","id":23844,"modified_method":"/**\n     * RemoteSync causes the message dispatch to wait for a response to an event on a response channel\n     * after it sends the event.  The following rules apply to RemoteSync\n     * 1.  The connector has to support remoteSync. Some transports do not have the notion of a response channel\n     * 2. Check if the endpoint has been configured for remoteSync\n     * 3. Check if the REMOTE_SYNC message header has been set\n     * 4. Finally, if the current component has a response router configured, that the router will handle the\n     * response channel event and we should not try and receive a response in the Message dispatcher\n     *\n     * If remotesync should not be used we must remove the REMOTE_SYNC header\n     *\n     * Note the MuleClient will automatically set the REMOTE_SYNC header when client.send(..) is called so that\n     * results are returned from remote invocations too.\n     * @param event the current event\n     * @return true if a response channel should be used to get a resposne from the event dispatch.\n     */\n    protected boolean useRemoteSync(UMOEvent event) {\n        boolean remoteSync = false;\n        UMOMessage msg = event.getMessage();\n        if(event.getEndpoint().getConnector().isRemoteSyncEnabled()) {\n            remoteSync = event.getEndpoint().isRemoteSync() ||\n                    msg.getBooleanProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY, false);\n            if(remoteSync) {\n                //component will be null for client calls\n                if(event.getComponent()!=null) {\n                    remoteSync = event.getComponent().getDescriptor().getResponseRouter() == null;\n                }\n            }\n        }\n        if(!remoteSync) {\n            msg.removeProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY);\n        }\n        return remoteSync;\n    }","commit_id":"f659778f07cc26d6d970061c635faba08bd4672b","url":"https://github.com/mulesoft/mule"},{"original_method":"public final void dispatch(UMOEvent event) throws DispatchException\n    {\n        try {\n            event.setSynchronous(false);\n            event.setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint().getEndpointURI().toString());\n            RequestContext.setEvent(event);\n            // Apply Security filter if one is set\n            UMOEndpoint endpoint = event.getEndpoint();\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(event);\n                } catch (org.mule.umo.security.SecurityException e) {\n                    logger.warn(\"Outbound Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.ADMIN_EVENT_ACTION_START_RANGE));\n                    connector.handleException(e);\n                    return;\n                } catch (UMOException e) {\n                    dispose();\n                    throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n            // the security filter may update the payload so we need to get the\n            // latest event again\n            event = RequestContext.getEvent();\n\n            try {\n                UMOTransaction tx = TransactionCoordination.getInstance().getTransaction();\n                if (doThreading && !event.isSynchronous() && tx == null) {\n                    workManager.scheduleWork(new Worker(event));\n                } else {\n                    doDispatch(event);\n                    if(connector.isEnableMessageEvents()) {\n                        String component = null;\n                        if(event.getComponent()!=null) {\n                            component = event.getComponent().getDescriptor().getName();\n                        }\n                        connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), component, MessageNotification.MESSAGE_DISPATCHED));\n                    }\n                }\n            } catch (DispatchException e) {\n                dispose();\n                throw e;\n            } catch (Exception e) {\n                dispose();\n                throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n            }\n        } finally {\n            if(connector.isCreateDispatcherPerRequest()) {\n                dispose();\n            }\n        }\n    }","id":23845,"modified_method":"public final void dispatch(UMOEvent event) throws DispatchException\n    {\n        try {\n            event.setSynchronous(false);\n            event.getMessage().setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint().getEndpointURI().toString());\n            RequestContext.setEvent(event);\n            // Apply Security filter if one is set\n            UMOEndpoint endpoint = event.getEndpoint();\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(event);\n                } catch (org.mule.umo.security.SecurityException e) {\n                    logger.warn(\"Outbound Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.ADMIN_EVENT_ACTION_START_RANGE));\n                    connector.handleException(e);\n                    return;\n                } catch (UMOException e) {\n                    dispose();\n                    throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n            // the security filter may update the payload so we need to get the\n            // latest event again\n            event = RequestContext.getEvent();\n\n            try {\n                UMOTransaction tx = TransactionCoordination.getInstance().getTransaction();\n                if (doThreading && !event.isSynchronous() && tx == null) {\n                    workManager.scheduleWork(new Worker(event));\n                } else {\n                    doDispatch(event);\n                    if(connector.isEnableMessageEvents()) {\n                        String component = null;\n                        if(event.getComponent()!=null) {\n                            component = event.getComponent().getDescriptor().getName();\n                        }\n                        connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), component, MessageNotification.MESSAGE_DISPATCHED));\n                    }\n                }\n            } catch (DispatchException e) {\n                dispose();\n                throw e;\n            } catch (Exception e) {\n                dispose();\n                throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n            }\n        } finally {\n            if(connector.isCreateDispatcherPerRequest()) {\n                dispose();\n            }\n        }\n    }","commit_id":"f659778f07cc26d6d970061c635faba08bd4672b","url":"https://github.com/mulesoft/mule"},{"original_method":"private void processReplyTo(UMOMessage returnMessage) throws UMOException\n    {\n        if (returnMessage != null && returnMessage.getReplyTo() != null) {\n            logger.info(\"sending reply to: \" + returnMessage.getReplyTo());\n            UMOEndpointURI endpointUri = new MuleEndpointURI(returnMessage.getReplyTo().toString());\n\n            // get the endpointUri for this uri\n            UMOEndpoint endpoint = MuleEndpoint.getOrCreateEndpointForUri(endpointUri, UMOEndpoint.ENDPOINT_TYPE_SENDER);\n\n            // Create the replyTo event asynchronous\n            UMOEvent replyToEvent = new MuleEvent(returnMessage, endpoint, event.getSession(), false);\n            // make sure remove the replyTo property as not cause a a forever\n            // replyto loop\n            replyToEvent.removeProperty(MuleProperties.MULE_REPLY_TO_PROPERTY);\n\n            // queue the event\n            onEvent(queueSession, replyToEvent);\n            logger.info(\"reply to sent: \" + returnMessage.getReplyTo());\n            if (stat.isEnabled()) {\n                stat.incSentReplyToEvent();\n            }\n        }\n    }","id":23846,"modified_method":"private void processReplyTo(UMOMessage returnMessage) throws UMOException\n    {\n        if (returnMessage != null && returnMessage.getReplyTo() != null) {\n            logger.info(\"sending reply to: \" + returnMessage.getReplyTo());\n            UMOEndpointURI endpointUri = new MuleEndpointURI(returnMessage.getReplyTo().toString());\n\n            // get the endpointUri for this uri\n            UMOEndpoint endpoint = MuleEndpoint.getOrCreateEndpointForUri(endpointUri, UMOEndpoint.ENDPOINT_TYPE_SENDER);\n\n            // make sure remove the replyTo property as not cause a a forever\n            // replyto loop\n            returnMessage.removeProperty(MuleProperties.MULE_REPLY_TO_PROPERTY);\n\n            // Create the replyTo event asynchronous\n            UMOEvent replyToEvent = new MuleEvent(returnMessage, endpoint, event.getSession(), false);\n\n            // queue the event\n            onEvent(queueSession, replyToEvent);\n            logger.info(\"reply to sent: \" + returnMessage.getReplyTo());\n            if (stat.isEnabled()) {\n                stat.incSentReplyToEvent();\n            }\n        }\n    }","commit_id":"f659778f07cc26d6d970061c635faba08bd4672b","url":"https://github.com/mulesoft/mule"},{"original_method":"public void processReplyTo(UMOEvent event, UMOMessage returnMessage, Object replyTo) throws UMOException\n    {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"sending reply to: \" + returnMessage.getReplyTo());\n        }\n        String replyToEndpoint = replyTo.toString();\n\n        // get the endpoint for this url\n        UMOEndpoint endpoint = getEndpoint(event, replyToEndpoint);\n        if(transformer==null) {\n            transformer = event.getEndpoint().getResponseTransformer();\n        }\n        if (transformer != null) {\n            endpoint.setTransformer(transformer);\n        }\n\n        // Create the replyTo event asynchronous\n        UMOEvent replyToEvent = new MuleEvent(returnMessage, endpoint, event.getSession(), false);\n\n        // make sure remove the replyTo property as not cause a a forever\n        // replyto loop\n        replyToEvent.removeProperty(MuleProperties.MULE_REPLY_TO_PROPERTY);\n\n        // dispatch the event\n        try {\n            endpoint.getConnector().getDispatcher(replyTo.toString()).dispatch(replyToEvent);\n            if (logger.isInfoEnabled()) {\n                logger.info(\"reply to sent: \" + endpoint);\n            }\n            ((AbstractComponent) event.getComponent()).getStatistics().incSentReplyToEvent();\n        } catch (Exception e) {\n            throw new DispatchException(new Message(Messages.FAILED_TO_DISPATCH_TO_REPLYTO_X, endpoint),\n                                        replyToEvent.getMessage(),\n                                        replyToEvent.getEndpoint(),\n                                        e);\n        }\n\n    }","id":23847,"modified_method":"public void processReplyTo(UMOEvent event, UMOMessage returnMessage, Object replyTo)\n            throws UMOException\n    {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"sending reply to: \" + returnMessage.getReplyTo());\n        }\n        String replyToEndpoint = replyTo.toString();\n\n        // get the endpoint for this url\n        UMOEndpoint endpoint = getEndpoint(event, replyToEndpoint);\n        if (transformer == null) {\n            transformer = event.getEndpoint().getResponseTransformer();\n        }\n        if (transformer != null) {\n            endpoint.setTransformer(transformer);\n        }\n\n        // make sure remove the replyTo property as not cause a a forever\n        // replyto loop\n        returnMessage.removeProperty(MuleProperties.MULE_REPLY_TO_PROPERTY);\n\n        // Create the replyTo event asynchronous\n        UMOEvent replyToEvent = new MuleEvent(returnMessage, endpoint, event.getSession(), false);\n\n        // dispatch the event\n        try {\n            endpoint.getConnector().getDispatcher(replyTo.toString()).dispatch(replyToEvent);\n            if (logger.isInfoEnabled()) {\n                logger.info(\"reply to sent: \" + endpoint);\n            }\n            ((AbstractComponent)event.getComponent()).getStatistics().incSentReplyToEvent();\n        }\n        catch (Exception e) {\n            throw new DispatchException(new Message(Messages.FAILED_TO_DISPATCH_TO_REPLYTO_X, endpoint),\n                    replyToEvent.getMessage(), replyToEvent.getEndpoint(), e);\n        }\n\n    }","commit_id":"f659778f07cc26d6d970061c635faba08bd4672b","url":"https://github.com/mulesoft/mule"},{"original_method":"public void setCredentials(UMOEvent event, Object credentials)\n    {\n        event.setProperty(MuleProperties.MULE_USER_PROPERTY, credentials);\n    }","id":23848,"modified_method":"public void setCredentials(UMOEvent event, Object credentials)\n    {\n        event.getMessage().setProperty(MuleProperties.MULE_USER_PROPERTY, credentials);\n    }","commit_id":"f659778f07cc26d6d970061c635faba08bd4672b","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object getCredentials(UMOEvent event)\n    {\n        return event.getProperty(MuleProperties.MULE_USER_PROPERTY);\n    }","id":23849,"modified_method":"public Object getCredentials(UMOEvent event)\n    {\n        return event.getMessage().getProperty(MuleProperties.MULE_USER_PROPERTY);\n    }","commit_id":"f659778f07cc26d6d970061c635faba08bd4672b","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object onCall(UMOEventContext eventContext) throws Exception\n    {\n        String tempUrl;\n        Object request = eventContext.getTransformedMessage();\n        Object requestBody = request;\n        if(urlFromMessage) {\n            tempUrl = (String)eventContext.getProperty(REST_SERVICE_URL);\n            if(tempUrl==null) {\n                throw new IllegalArgumentException(new Message(Messages.X_PROPERTY_IS_NOT_SET_ON_EVENT, REST_SERVICE_URL).toString());\n            }\n        } else {\n            tempUrl = serviceUrl;\n        }\n        StringBuffer urlBuffer = new StringBuffer(tempUrl);\n\n        if(payloadParameterName!=null) {\n            requestBody = new NullPayload();\n        } else if(request instanceof Map) {\n            requestBody = new NullPayload();\n        }\n\n        setRESTParams(urlBuffer, eventContext.getMessage(), request, reqiredParams, false);\n        setRESTParams(urlBuffer, eventContext.getMessage(), request, optionalParams, true);\n\n        tempUrl = urlBuffer.toString();\n        logger.info(\"Invoking REST service: \" + tempUrl);\n\n        UMOEndpointURI endpointURI = new MuleEndpointURI(tempUrl);\n        eventContext.getMessage().setProperty(\"http.method\", httpMethod);\n\n        UMOMessage result = eventContext.sendEvent(new MuleMessage(requestBody, eventContext.getMessage()), endpointURI);\n\n        if(isErrorPayload(result)) {\n            handleException(new RestServiceException(\n                    new Message(Messages.FAILED_TO_INVOKE_REST_SERVICE_X, tempUrl), result),\n                    result);\n        }\n        return result;\n    }","id":23850,"modified_method":"public Object onCall(UMOEventContext eventContext) throws Exception\n    {\n        String tempUrl;\n        Object request = eventContext.getTransformedMessage();\n        Object requestBody = request;\n        if(urlFromMessage) {\n            tempUrl = eventContext.getMessage().getStringProperty(REST_SERVICE_URL, null);\n            if(tempUrl==null) {\n                throw new IllegalArgumentException(new Message(Messages.X_PROPERTY_IS_NOT_SET_ON_EVENT, REST_SERVICE_URL).toString());\n            }\n        } else {\n            tempUrl = serviceUrl;\n        }\n        StringBuffer urlBuffer = new StringBuffer(tempUrl);\n\n        if(payloadParameterName!=null) {\n            requestBody = new NullPayload();\n        } else if(request instanceof Map) {\n            requestBody = new NullPayload();\n        }\n\n        setRESTParams(urlBuffer, eventContext.getMessage(), request, reqiredParams, false);\n        setRESTParams(urlBuffer, eventContext.getMessage(), request, optionalParams, true);\n\n        tempUrl = urlBuffer.toString();\n        logger.info(\"Invoking REST service: \" + tempUrl);\n\n        UMOEndpointURI endpointURI = new MuleEndpointURI(tempUrl);\n        eventContext.getMessage().setProperty(\"http.method\", httpMethod);\n\n        UMOMessage result = eventContext.sendEvent(new MuleMessage(requestBody, eventContext.getMessage()), endpointURI);\n\n        if(isErrorPayload(result)) {\n            handleException(new RestServiceException(\n                    new Message(Messages.FAILED_TO_INVOKE_REST_SERVICE_X, tempUrl), result),\n                    result);\n        }\n        return result;\n    }","commit_id":"f659778f07cc26d6d970061c635faba08bd4672b","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public int getOnParentVersion() {\n        String opv = node.getString(\"jcr:onParentVersion\", ACTIONNAME_COPY);\n        if (ACTIONNAME_ABORT.equalsIgnoreCase(opv)) {\n            return OnParentVersionAction.ABORT;\n        } else if (ACTIONNAME_COMPUTE.equalsIgnoreCase(opv)) {\n            return OnParentVersionAction.COMPUTE;\n        } else if (ACTIONNAME_IGNORE.equalsIgnoreCase(opv)) {\n            return OnParentVersionAction.IGNORE;\n        } else if (ACTIONNAME_INITIALIZE.equalsIgnoreCase(opv)) {\n            return OnParentVersionAction.INITIALIZE;\n        } else if (ACTIONNAME_VERSION.equalsIgnoreCase(opv)) {\n            return OnParentVersionAction.VERSION;\n        } else {\n            return OnParentVersionAction.COPY;\n        }\n    }","id":23851,"modified_method":"@Override\n    public int getOnParentVersion() {\n        try {\n            return OnParentVersionAction.valueFromName(node.getString(\n                    \"jcr:onParentVersion\",\n                    OnParentVersionAction.ACTIONNAME_COPY));\n        } catch (IllegalArgumentException e) {\n            log.warn(\"Unexpected jcr:onParentVersion value\", e);\n            return OnParentVersionAction.COPY;\n        }\n    }","commit_id":"bfdb8510f3465f659d2ad02b593b543f0b2e2cdc","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void unregisterNamespace(String prefix) throws RepositoryException {\n        try {\n            Root root = session.getCurrentRoot();\n            Tree namespaces = getOrCreate(root, \"jcr:system\", Namespaces.NSMAPNODENAME);\n            if (namespaces.hasProperty(prefix)) {\n                namespaces.removeProperty(prefix);\n            } else {\n                throw new NamespaceException(\n                        \"Namespace mapping from \" + prefix + \" to \"\n                        + getURI(prefix) + \" can not be unregistered\");\n            }\n            root.commit(DefaultConflictHandler.OURS);\n            refresh();\n        } catch (NamespaceValidatorException e) {\n            throw e.getNamespaceException();\n        } catch (CommitFailedException e) {\n            throw new RepositoryException(\n                    \"Failed to unregister namespace mapping for prefix \"\n                    + prefix, e);\n        }\n    }","id":23852,"modified_method":"@Override\n    public void unregisterNamespace(String prefix) throws RepositoryException {\n        Root root = session.getCurrentRoot();\n        Tree namespaces = root.getTree(\"/jcr:system/jcr:namespaces\");\n        if (namespaces == null || !namespaces.hasProperty(prefix)) {\n            throw new NamespaceException(\n                    \"Namespace mapping from \" + prefix + \" to \"\n                    + getURI(prefix) + \" can not be unregistered\");\n        }\n\n        try {\n            namespaces.removeProperty(prefix);\n            root.commit(DefaultConflictHandler.OURS);\n            refresh();\n        } catch (NamespaceValidatorException e) {\n            throw e.getNamespaceException();\n        } catch (CommitFailedException e) {\n            throw new RepositoryException(\n                    \"Failed to unregister namespace mapping for prefix \"\n                    + prefix, e);\n        }\n    }","commit_id":"bfdb8510f3465f659d2ad02b593b543f0b2e2cdc","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private NodeTypeTemplateImpl(NodeTypeManager manager, ValueFactory factory) {\n        this.manager = manager;\n        this.factory = factory;\n    }","id":23853,"modified_method":"public NodeTypeTemplateImpl(NodeTypeManager manager, ValueFactory factory) {\n        this.manager = manager;\n        this.factory = factory;\n    }","commit_id":"bfdb8510f3465f659d2ad02b593b543f0b2e2cdc","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public NodeUtil(NameMapper mapper, Tree tree) {\n        this.mapper = mapper;\n        this.tree = tree;\n    }","id":23854,"modified_method":"public NodeUtil(CoreValueFactory factory, NameMapper mapper, Tree tree) {\n        this.factory = factory;\n        this.mapper = mapper;\n        this.tree = tree;\n    }","commit_id":"bfdb8510f3465f659d2ad02b593b543f0b2e2cdc","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public NodeUtil[] getNodes(String name) {\n        List<NodeUtil> nodes = new ArrayList<NodeUtil>();\n        Tree child = tree.getChild(name);\n        if (child != null) {\n            for (Tree tree : child.getChildren()) {\n                nodes.add(new NodeUtil(mapper, tree));\n            }\n        }\n        return nodes.toArray(new NodeUtil[nodes.size()]);\n    }","id":23855,"modified_method":"public NodeUtil[] getNodes(String name) {\n        List<NodeUtil> nodes = new ArrayList<NodeUtil>();\n        Tree child = tree.getChild(name);\n        if (child != null) {\n            for (Tree tree : child.getChildren()) {\n                nodes.add(new NodeUtil(factory, mapper, tree));\n            }\n        }\n        return nodes.toArray(new NodeUtil[nodes.size()]);\n    }","commit_id":"bfdb8510f3465f659d2ad02b593b543f0b2e2cdc","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public int getRequiredType() {\n        String type = node.getString(\"jcr:requiredType\", TYPENAME_UNDEFINED);\n        if (PropertyType.TYPENAME_BINARY.equalsIgnoreCase(type)) {\n            return PropertyType.BINARY;\n        } else if (PropertyType.TYPENAME_BOOLEAN.equalsIgnoreCase(type)) {\n            return PropertyType.BOOLEAN;\n        } else if (PropertyType.TYPENAME_DATE.equalsIgnoreCase(type)) {\n            return PropertyType.DATE;\n        } else if (PropertyType.TYPENAME_DECIMAL.equalsIgnoreCase(type)) {\n            return PropertyType.DECIMAL;\n        } else if (PropertyType.TYPENAME_DOUBLE.equalsIgnoreCase(type)) {\n            return PropertyType.DOUBLE;\n        } else if (PropertyType.TYPENAME_LONG.equalsIgnoreCase(type)) {\n            return PropertyType.LONG;\n        } else if (PropertyType.TYPENAME_NAME.equalsIgnoreCase(type)) {\n            return PropertyType.NAME;\n        } else if (PropertyType.TYPENAME_PATH.equalsIgnoreCase(type)) {\n            return PropertyType.PATH;\n        } else if (PropertyType.TYPENAME_REFERENCE.equalsIgnoreCase(type)) {\n            return PropertyType.REFERENCE;\n        } else if (PropertyType.TYPENAME_STRING.equalsIgnoreCase(type)) {\n            return PropertyType.STRING;\n        } else if (PropertyType.TYPENAME_URI.equalsIgnoreCase(type)) {\n            return PropertyType.URI;\n        } else if (PropertyType.TYPENAME_WEAKREFERENCE.equalsIgnoreCase(type)) {\n            return PropertyType.WEAKREFERENCE;\n        } else {\n            return PropertyType.UNDEFINED;\n        }\n    }","id":23856,"modified_method":"@Override\n    public int getRequiredType() {\n        try {\n            return PropertyType.valueFromName(node.getString(\n                    \"jcr:requiredType\", PropertyType.TYPENAME_UNDEFINED));\n        } catch (IllegalArgumentException e) {\n            log.warn(\"Unexpected jcr:requiredType value\", e);\n            return PropertyType.UNDEFINED;\n        }\n    }","commit_id":"bfdb8510f3465f659d2ad02b593b543f0b2e2cdc","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private long optimisticMerge(CommitHook hook, CommitInfo info)\n                throws CommitFailedException, InterruptedException {\n            long timeout = 1;\n\n            SegmentNodeState originalBase = base;\n            SegmentNodeState originalHead = head;\n\n            // use exponential backoff in case of concurrent commits\n            for (long backoff = 1; backoff < maximumBackoff; backoff *= 2) {\n                rebase(); // rebase to latest head, a no-op if already there\n\n                long start = System.nanoTime();\n\n                if (base.hasProperty(\"token\")\n                        && base.getLong(\"timeout\") >= System.currentTimeMillis()) {\n                    // someone else has a pessimistic lock on the journal,\n                    // so we should not try to commit anything\n                } else {\n                    // apply commit hooks on the rebased changes\n                    NodeBuilder builder = head.builder();\n                    builder.setChildNode(ROOT, hook.processCommit(\n                            base.getChildNode(ROOT), head.getChildNode(ROOT)));\n                    SegmentNodeState newHead =\n                            store.getWriter().writeNode(builder.getNodeState());\n\n                    // use optimistic locking to update the journal\n                    if (setHead(base, newHead, info)) {\n                        base = newHead;\n                        head = newHead;\n                        return -1;\n                    }\n                }\n\n                // someone else was faster, so restore state and retry later\n                base = originalBase;\n                head = originalHead;\n\n                Thread.sleep(backoff, random.nextInt(1000000));\n\n                long stop = System.nanoTime();\n                if (stop - start > timeout) {\n                    timeout = stop - start;\n                }\n            }\n\n            return MILLISECONDS.convert(timeout, NANOSECONDS);\n        }","id":23857,"modified_method":"private long optimisticMerge()\n                throws CommitFailedException, InterruptedException {\n            long timeout = 1;\n\n            // use exponential backoff in case of concurrent commits\n            for (long backoff = 1; backoff < maximumBackoff; backoff *= 2) {\n                long start = System.nanoTime();\n\n                refreshHead();\n                if (head.hasProperty(\"token\")\n                        && head.getLong(\"timeout\") >= currentTimeMillis()) {\n                    // someone else has a pessimistic lock on the journal,\n                    // so we should not try to commit anything yet\n                } else {\n                    SegmentNodeBuilder builder = prepare();\n                    // use optimistic locking to update the journal\n                    if (setHead(builder)) {\n                        return -1;\n                    }\n                }\n\n                // someone else was faster, so wait a while and retry later\n                Thread.sleep(backoff, random.nextInt(1000000));\n\n                long stop = System.nanoTime();\n                if (stop - start > timeout) {\n                    timeout = stop - start;\n                }\n            }\n\n            return MILLISECONDS.convert(timeout, NANOSECONDS);\n        }","commit_id":"abb82eea19320cb6ea3162d0907a0f725e5526ec","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"Commit(@Nonnull SegmentNodeState base, @Nonnull NodeState head,\n                @Nonnull CommitHook hook, @Nullable CommitInfo info) {\n            this.base = checkNotNull(base);\n            SegmentNodeBuilder builder = base.builder();\n            builder.setChildNode(ROOT, checkNotNull(head));\n            this.head = builder.getNodeState();\n\n            this.hook = checkNotNull(hook);\n            this.info = info;\n        }","id":23858,"modified_method":"Commit(@Nonnull SegmentNodeBuilder builder,\n                @Nonnull CommitHook hook, @Nullable CommitInfo info) {\n            checkNotNull(builder);\n            this.before = builder.getBaseState();\n            this.after = builder.getNodeState();\n\n            this.hook = checkNotNull(hook);\n            this.info = info;\n        }","commit_id":"abb82eea19320cb6ea3162d0907a0f725e5526ec","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n        SegmentRootState execute()\n                throws CommitFailedException, InterruptedException {\n            if (base != head) {\n                long timeout = optimisticMerge(hook, info);\n                if (timeout >= 0) {\n                    pessimisticMerge(hook, timeout, info);\n                }\n            }\n            return new SegmentRootState(head);\n        }","id":23859,"modified_method":"@Nonnull\n        NodeState execute()\n                throws CommitFailedException, InterruptedException {\n            // only do the merge if there are some changes to commit\n            if (!fastEquals(before, after)) {\n                long timeout = optimisticMerge();\n                if (timeout >= 0) {\n                    pessimisticMerge(timeout);\n                }\n            }\n            return head.getChildNode(ROOT);\n        }","commit_id":"abb82eea19320cb6ea3162d0907a0f725e5526ec","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override @Nonnull\n    public NodeState getRoot() {\n        if (commitSemaphore.tryAcquire()) {\n            try {\n                refreshHead();\n            } finally {\n                commitSemaphore.release();\n            }\n        }\n        return new SegmentRootState(head);\n    }","id":23860,"modified_method":"@Override @Nonnull\n    public NodeState getRoot() {\n        if (commitSemaphore.tryAcquire()) {\n            try {\n                refreshHead();\n            } finally {\n                commitSemaphore.release();\n            }\n        }\n        return head.getChildNode(ROOT);\n    }","commit_id":"abb82eea19320cb6ea3162d0907a0f725e5526ec","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeState merge(\n            @Nonnull NodeBuilder builder, @Nonnull CommitHook commitHook,\n            @Nullable CommitInfo info) throws CommitFailedException {\n        checkNotNull(commitHook);\n\n        NodeState base = builder.getBaseState();\n        checkArgument(store.isInstance(base, SegmentRootState.class));\n        SegmentNodeState root = ((SegmentRootState) base).getRootState();\n\n        try {\n            commitSemaphore.acquire();\n            try {\n                Commit commit = new Commit(\n                        root, builder.getNodeState(), commitHook, info);\n                NodeState merged = commit.execute();\n                ((SegmentNodeBuilder) builder).reset(merged);\n                return merged;\n            } finally {\n                commitSemaphore.release();\n            }\n        } catch (InterruptedException e) {\n            throw new CommitFailedException(\n                    \"Segment\", 2, \"Merge interrupted\", e);\n        }\n    }","id":23861,"modified_method":"@Override\n    public NodeState merge(\n            @Nonnull NodeBuilder builder, @Nonnull CommitHook commitHook,\n            @Nullable CommitInfo info) throws CommitFailedException {\n        checkArgument(builder instanceof SegmentNodeBuilder);\n        checkNotNull(commitHook);\n\n        SegmentNodeBuilder snb = (SegmentNodeBuilder) builder;\n        checkArgument(store == snb.getBaseState().getStore());\n\n        try {\n            commitSemaphore.acquire();\n            try {\n                Commit commit = new Commit(snb, commitHook, info);\n                NodeState merged = commit.execute();\n                snb.reset(merged);\n                return merged;\n            } finally {\n                commitSemaphore.release();\n            }\n        } catch (InterruptedException e) {\n            throw new CommitFailedException(\n                    \"Segment\", 2, \"Merge interrupted\", e);\n        }\n    }","commit_id":"abb82eea19320cb6ea3162d0907a0f725e5526ec","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void pessimisticMerge(\n                CommitHook hook, long timeout, CommitInfo info)\n                throws CommitFailedException, InterruptedException {\n            while (true) {\n                SegmentNodeState before = head;\n                long now = System.currentTimeMillis();\n                if (before.hasProperty(\"token\")\n                        && before.getLong(\"timeout\") >= now) {\n                    // locked by someone else, wait until unlocked or expired\n                    Thread.sleep(\n                            Math.min(before.getLong(\"timeout\") - now, 1000),\n                            random.nextInt(1000000));\n                } else {\n                    // attempt to acquire the lock\n                    NodeBuilder builder = before.builder();\n                    builder.setProperty(\"token\", UUID.randomUUID().toString());\n                    builder.setProperty(\"timeout\", now + timeout);\n\n                    SegmentNodeState after =\n                            store.getWriter().writeNode(builder.getNodeState());\n                    if (setHead(before, after, info)) {\n                        SegmentNodeState originalBase = base;\n                        SegmentNodeState originalHead = head;\n\n                        // lock acquired; rebase, apply commit hooks, and unlock\n                        rebase();\n                        builder.setChildNode(ROOT, hook.processCommit(\n                                base.getChildNode(ROOT), head.getChildNode(ROOT)));\n                        builder.removeProperty(\"token\");\n                        builder.removeProperty(\"timeout\");\n\n                        // complete the commit\n                        SegmentNodeState newHead =\n                                store.getWriter().writeNode(builder.getNodeState());\n                        if (setHead(after, newHead, info)) {\n                            base = newHead;\n                            head = newHead;\n                            return;\n                        } else {\n                            // something else happened, perhaps a timeout, so\n                            // undo the previous rebase and try again\n                            base = originalBase;\n                            head = originalHead;\n                        }\n                    }\n                }\n            }\n        }","id":23862,"modified_method":"private void pessimisticMerge(long timeout)\n                throws CommitFailedException, InterruptedException {\n            while (true) {\n                long now = currentTimeMillis();\n                if (head.hasProperty(\"token\")\n                        && head.getLong(\"timeout\") >= now) {\n                    // locked by someone else, wait until unlocked or expired\n                    Thread.sleep(\n                            Math.min(head.getLong(\"timeout\") - now, 1000),\n                            random.nextInt(1000000));\n                } else {\n                    // attempt to acquire the lock\n                    SegmentNodeBuilder builder = head.builder();\n                    builder.setProperty(\"token\", UUID.randomUUID().toString());\n                    builder.setProperty(\"timeout\", now + timeout);\n\n                    if (setHead(builder)) {\n                         // lock acquired; rebase, apply commit hooks, and unlock\n                        builder = prepare();\n                        builder.removeProperty(\"token\");\n                        builder.removeProperty(\"timeout\");\n\n                        // complete the commit\n                        if (setHead(builder)) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }","commit_id":"abb82eea19320cb6ea3162d0907a0f725e5526ec","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private boolean fastEquals(Object a, Object b) {\n        return store.isInstance(a, Record.class)\n                && store.isInstance(b, Record.class)\n                && Objects.equal(\n                        ((Record) a).getRecordId(),\n                        ((Record) b).getRecordId());\n    }","id":23863,"modified_method":"private static boolean fastEquals(Object a, Object b) {\n        return a instanceof Record && fastEquals((Record) a, b);\n    }","commit_id":"abb82eea19320cb6ea3162d0907a0f725e5526ec","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Object onCall(UMOEventContext eventContext) throws Exception {\n\n        UMOMessage requestMessage = new MuleMessage(eventContext.getTransformedMessage(), eventContext.getMessage());\n\n        UMOMessage responseMessage = requestMessage;\n        Object builtMessage;\n\n        if(descriptor.getOutboundRouter().hasEndpoints() ) {\n            List endpoints = new ArrayList();\n            for (Iterator iterator = descriptor.getOutboundRouter().getRouters().iterator(); iterator.hasNext();) {\n                UMOOutboundRouter router = (UMOOutboundRouter) iterator.next();\n                endpoints.addAll(router.getEndpoints());\n            }\n            for (Iterator iterator = endpoints.iterator(); iterator.hasNext();) {\n                UMOEndpoint endpoint = (UMOEndpoint) iterator.next();\n                boolean rsync = eventContext.getBooleanProperty(\n                        MuleProperties.MULE_REMOTE_SYNC_PROPERTY, endpoint.isRemoteSync());\n                if(!rsync) {\n                    logger.info(\"Endpoint: \" + endpoint + \" is not remoteSync enabled. Message builder finishing\");\n                    if(eventContext.isSynchronous()) {\n                        responseMessage = eventContext.sendEvent(requestMessage, endpoint);\n                    } else {\n                        eventContext.dispatchEvent(requestMessage, endpoint);\n                        responseMessage=null;\n                    }\n                    break;\n                } else {\n                    responseMessage = eventContext.sendEvent(requestMessage, endpoint);\n                    builtMessage = buildMessage(requestMessage, responseMessage);\n                    responseMessage = new MuleMessage(builtMessage, responseMessage);\n                    requestMessage = responseMessage;\n                }\n            }\n        } else {\n            logger.info(\"There are currently no endpoints configured on component: \" + descriptor.getName());\n        }\n        eventContext.setStopFurtherProcessing(true);\n        return responseMessage;\n    }","id":23864,"modified_method":"public Object onCall(UMOEventContext eventContext) throws Exception {\n\n        UMOMessage requestMessage = new MuleMessage(eventContext.getTransformedMessage(), eventContext.getMessage());\n\n        UMOMessage responseMessage = requestMessage;\n        Object builtMessage;\n\n        if(descriptor.getOutboundRouter().hasEndpoints() ) {\n            List endpoints = new ArrayList();\n            for (Iterator iterator = descriptor.getOutboundRouter().getRouters().iterator(); iterator.hasNext();) {\n                UMOOutboundRouter router = (UMOOutboundRouter) iterator.next();\n                endpoints.addAll(router.getEndpoints());\n            }\n            for (Iterator iterator = endpoints.iterator(); iterator.hasNext();) {\n                UMOEndpoint endpoint = (UMOEndpoint) iterator.next();\n                boolean rsync = eventContext.getMessage().getBooleanProperty(\n                        MuleProperties.MULE_REMOTE_SYNC_PROPERTY, endpoint.isRemoteSync());\n                if(!rsync) {\n                    logger.info(\"Endpoint: \" + endpoint + \" is not remoteSync enabled. Message builder finishing\");\n                    if(eventContext.isSynchronous()) {\n                        responseMessage = eventContext.sendEvent(requestMessage, endpoint);\n                    } else {\n                        eventContext.dispatchEvent(requestMessage, endpoint);\n                        responseMessage=null;\n                    }\n                    break;\n                } else {\n                    responseMessage = eventContext.sendEvent(requestMessage, endpoint);\n                    builtMessage = buildMessage(requestMessage, responseMessage);\n                    responseMessage = new MuleMessage(builtMessage, responseMessage);\n                    requestMessage = responseMessage;\n                }\n            }\n        } else {\n            logger.info(\"There are currently no endpoints configured on component: \" + descriptor.getName());\n        }\n        eventContext.setStopFurtherProcessing(true);\n        return responseMessage;\n    }","commit_id":"0f1c5486f7d6f57ef0c5d7fc3067e3593ac7e524","url":"https://github.com/mulesoft/mule"},{"original_method":"public final void dispatch(UMOEvent event) throws DispatchException\n    {\n        try {\n            event.setSynchronous(false);\n            event.setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint().getEndpointURI().toString());\n            RequestContext.setEvent(event);\n            // Apply Security filter if one is set\n            UMOEndpoint endpoint = event.getEndpoint();\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(event);\n                } catch (org.mule.umo.security.SecurityException e) {\n                    logger.warn(\"Outbound Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.ADMIN_EVENT_ACTION_START_RANGE));\n                    connector.handleException(e);\n                    return;\n                } catch (UMOException e) {\n                    dispose();\n                    throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n            // the security filter may update the payload so we need to get the\n            // latest event again\n            event = RequestContext.getEvent();\n\n            try {\n                UMOTransaction tx = TransactionCoordination.getInstance().getTransaction();\n                if (doThreading && !event.isSynchronous() && tx == null) {\n                    workManager.scheduleWork(new Worker(event));\n                } else {\n                    doDispatch(event);\n                    if(connector.isEnableMessageEvents()) {\n                        String component = null;\n                        if(event.getComponent()!=null) {\n                            component = event.getComponent().getDescriptor().getName();\n                        }\n                        connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), component, MessageNotification.MESSAGE_DISPATCHED));\n                    }\n                }\n            } catch (DispatchException e) {\n                dispose();\n                throw e;\n            } catch (Exception e) {\n                dispose();\n                throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n            }\n        } finally {\n            if(connector.isCreateDispatcherPerRequest()) {\n                dispose();\n            }\n        }\n    }","id":23865,"modified_method":"public final void dispatch(UMOEvent event) throws DispatchException\n    {\n        try {\n            event.setSynchronous(false);\n            event.getMessage().setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint().getEndpointURI().toString());\n            RequestContext.setEvent(event);\n            // Apply Security filter if one is set\n            UMOEndpoint endpoint = event.getEndpoint();\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(event);\n                } catch (org.mule.umo.security.SecurityException e) {\n                    logger.warn(\"Outbound Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.ADMIN_EVENT_ACTION_START_RANGE));\n                    connector.handleException(e);\n                    return;\n                } catch (UMOException e) {\n                    dispose();\n                    throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n            // the security filter may update the payload so we need to get the\n            // latest event again\n            event = RequestContext.getEvent();\n\n            try {\n                UMOTransaction tx = TransactionCoordination.getInstance().getTransaction();\n                if (doThreading && !event.isSynchronous() && tx == null) {\n                    workManager.scheduleWork(new Worker(event));\n                } else {\n                    doDispatch(event);\n                    if(connector.isEnableMessageEvents()) {\n                        String component = null;\n                        if(event.getComponent()!=null) {\n                            component = event.getComponent().getDescriptor().getName();\n                        }\n                        connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), component, MessageNotification.MESSAGE_DISPATCHED));\n                    }\n                }\n            } catch (DispatchException e) {\n                dispose();\n                throw e;\n            } catch (Exception e) {\n                dispose();\n                throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n            }\n        } finally {\n            if(connector.isCreateDispatcherPerRequest()) {\n                dispose();\n            }\n        }\n    }","commit_id":"0f1c5486f7d6f57ef0c5d7fc3067e3593ac7e524","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * RemoteSync causes the message dispatch to wait for a response to an event on a response channel\n     * after it sends the event.  The following rules apply to RemoteSync\n     * 1.  The connector has to support remoteSync. Some transports do not have the notion of a response channel\n     * 2. Check if the endpoint has been configured for remoteSync\n     * 3. Check if the REMOTE_SYNC message header has been set\n     * 4. Finally, if the current component has a response router configured, that the router will handle the\n     * response channel event and we should not try and receive a response in the Message dispatcher\n     *\n     * If remotesync should not be used we must remove the REMOTE_SYNC header\n     *\n     * Note the MuleClient will automatically set the REMOTE_SYNC header when client.send(..) is called so that\n     * results are returned from remote invocations too.\n     * @param event the current event\n     * @return true if a response channel should be used to get a resposne from the event dispatch.\n     */\n    protected boolean useRemoteSync(UMOEvent event) {\n        boolean remoteSync = false;\n        if(event.getEndpoint().getConnector().isRemoteSyncEnabled()) {\n            remoteSync = event.getEndpoint().isRemoteSync() ||\n                    event.getMessage().getBooleanProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY, false);\n            if(remoteSync) {\n                //component will be null for client calls\n                if(event.getComponent()!=null) {\n                    remoteSync = event.getComponent().getDescriptor().getResponseRouter() == null;\n                }\n            }\n        }\n        if(!remoteSync) {\n            event.removeProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY);\n            event.getMessage().removeProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY);\n        }\n        return remoteSync;\n    }","id":23866,"modified_method":"/**\n     * RemoteSync causes the message dispatch to wait for a response to an event on a response channel\n     * after it sends the event.  The following rules apply to RemoteSync\n     * 1.  The connector has to support remoteSync. Some transports do not have the notion of a response channel\n     * 2. Check if the endpoint has been configured for remoteSync\n     * 3. Check if the REMOTE_SYNC message header has been set\n     * 4. Finally, if the current component has a response router configured, that the router will handle the\n     * response channel event and we should not try and receive a response in the Message dispatcher\n     *\n     * If remotesync should not be used we must remove the REMOTE_SYNC header\n     *\n     * Note the MuleClient will automatically set the REMOTE_SYNC header when client.send(..) is called so that\n     * results are returned from remote invocations too.\n     * @param event the current event\n     * @return true if a response channel should be used to get a resposne from the event dispatch.\n     */\n    protected boolean useRemoteSync(UMOEvent event) {\n        boolean remoteSync = false;\n        UMOMessage msg = event.getMessage();\n        if(event.getEndpoint().getConnector().isRemoteSyncEnabled()) {\n            remoteSync = event.getEndpoint().isRemoteSync() ||\n                    msg.getBooleanProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY, false);\n            if(remoteSync) {\n                //component will be null for client calls\n                if(event.getComponent()!=null) {\n                    remoteSync = event.getComponent().getDescriptor().getResponseRouter() == null;\n                }\n            }\n        }\n        if(!remoteSync) {\n            msg.removeProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY);\n        }\n        return remoteSync;\n    }","commit_id":"0f1c5486f7d6f57ef0c5d7fc3067e3593ac7e524","url":"https://github.com/mulesoft/mule"},{"original_method":"public final UMOMessage send(UMOEvent event) throws DispatchException\n    {\n        try {\n            event.setSynchronous(true);\n            event.setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint().getEndpointURI().toString());\n            RequestContext.setEvent(event);\n            // Apply Security filter if one is set\n            UMOEndpoint endpoint = event.getEndpoint();\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(event);\n                } catch (org.mule.umo.security.SecurityException e) {\n                    logger.warn(\"Outbound Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.SECURITY_AUTHENTICATION_FAILED));\n                    connector.handleException(e);\n                    return event.getMessage();\n                } catch (UMOException e) {\n                    dispose();\n                    throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n            // the security filter may update the payload so we need to get the\n            // latest event again\n            event = RequestContext.getEvent();\n            try {\n                UMOMessage result = doSend(event);\n                if(connector.isEnableMessageEvents()) {\n                    String component = null;\n                    if(event.getComponent()!=null) {\n                        component = event.getComponent().getDescriptor().getName();\n                    }\n                    connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), component, MessageNotification.MESSAGE_SENT));\n                }\n                //Once a dispatcher has done its work we need to romve this property so that\n                //it is not propagated to the next request\n                if(result!=null) {\n                    result.removeProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY);\n                }\n                return result;\n            } catch (DispatchException e) {\n                dispose();\n                throw e;\n            } catch (Exception e) {\n                dispose();\n                throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n            }\n        } finally {\n            if(connector.isCreateDispatcherPerRequest()) {\n                dispose();\n            }\n        }\n    }","id":23867,"modified_method":"public final UMOMessage send(UMOEvent event) throws DispatchException\n    {\n        try {\n            event.setSynchronous(true);\n            event.getMessage().setProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, event.getEndpoint().getEndpointURI().toString());\n            RequestContext.setEvent(event);\n            // Apply Security filter if one is set\n            UMOEndpoint endpoint = event.getEndpoint();\n            if (endpoint.getSecurityFilter() != null) {\n                try {\n                    endpoint.getSecurityFilter().authenticate(event);\n                } catch (org.mule.umo.security.SecurityException e) {\n                    logger.warn(\"Outbound Request was made but was not authenticated: \" + e.getMessage(), e);\n                    connector.fireNotification(new SecurityNotification(e, SecurityNotification.SECURITY_AUTHENTICATION_FAILED));\n                    connector.handleException(e);\n                    return event.getMessage();\n                } catch (UMOException e) {\n                    dispose();\n                    throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n                }\n            }\n            // the security filter may update the payload so we need to get the\n            // latest event again\n            event = RequestContext.getEvent();\n            try {\n                UMOMessage result = doSend(event);\n                if(connector.isEnableMessageEvents()) {\n                    String component = null;\n                    if(event.getComponent()!=null) {\n                        component = event.getComponent().getDescriptor().getName();\n                    }\n                    connector.fireNotification(new MessageNotification(event.getMessage(), event.getEndpoint(), component, MessageNotification.MESSAGE_SENT));\n                }\n                //Once a dispatcher has done its work we need to romve this property so that\n                //it is not propagated to the next request\n                if(result!=null) {\n                    result.removeProperty(MuleProperties.MULE_REMOTE_SYNC_PROPERTY);\n                }\n                return result;\n            } catch (DispatchException e) {\n                dispose();\n                throw e;\n            } catch (Exception e) {\n                dispose();\n                throw new DispatchException(event.getMessage(), event.getEndpoint(), e);\n            }\n        } finally {\n            if(connector.isCreateDispatcherPerRequest()) {\n                dispose();\n            }\n        }\n    }","commit_id":"0f1c5486f7d6f57ef0c5d7fc3067e3593ac7e524","url":"https://github.com/mulesoft/mule"},{"original_method":"private void processReplyTo(UMOMessage returnMessage) throws UMOException\n    {\n        if (returnMessage != null && returnMessage.getReplyTo() != null) {\n            logger.info(\"sending reply to: \" + returnMessage.getReplyTo());\n            UMOEndpointURI endpointUri = new MuleEndpointURI(returnMessage.getReplyTo().toString());\n\n            // get the endpointUri for this uri\n            UMOEndpoint endpoint = MuleEndpoint.getOrCreateEndpointForUri(endpointUri, UMOEndpoint.ENDPOINT_TYPE_SENDER);\n\n            // Create the replyTo event asynchronous\n            UMOEvent replyToEvent = new MuleEvent(returnMessage, endpoint, event.getSession(), false);\n            // make sure remove the replyTo property as not cause a a forever\n            // replyto loop\n            replyToEvent.removeProperty(MuleProperties.MULE_REPLY_TO_PROPERTY);\n\n            // queue the event\n            onEvent(queueSession, replyToEvent);\n            logger.info(\"reply to sent: \" + returnMessage.getReplyTo());\n            if (stat.isEnabled()) {\n                stat.incSentReplyToEvent();\n            }\n        }\n    }","id":23868,"modified_method":"private void processReplyTo(UMOMessage returnMessage) throws UMOException\n    {\n        if (returnMessage != null && returnMessage.getReplyTo() != null) {\n            logger.info(\"sending reply to: \" + returnMessage.getReplyTo());\n            UMOEndpointURI endpointUri = new MuleEndpointURI(returnMessage.getReplyTo().toString());\n\n            // get the endpointUri for this uri\n            UMOEndpoint endpoint = MuleEndpoint.getOrCreateEndpointForUri(endpointUri, UMOEndpoint.ENDPOINT_TYPE_SENDER);\n\n            // make sure remove the replyTo property as not cause a a forever\n            // replyto loop\n            returnMessage.removeProperty(MuleProperties.MULE_REPLY_TO_PROPERTY);\n\n            // Create the replyTo event asynchronous\n            UMOEvent replyToEvent = new MuleEvent(returnMessage, endpoint, event.getSession(), false);\n\n            // queue the event\n            onEvent(queueSession, replyToEvent);\n            logger.info(\"reply to sent: \" + returnMessage.getReplyTo());\n            if (stat.isEnabled()) {\n                stat.incSentReplyToEvent();\n            }\n        }\n    }","commit_id":"0f1c5486f7d6f57ef0c5d7fc3067e3593ac7e524","url":"https://github.com/mulesoft/mule"},{"original_method":"public void processReplyTo(UMOEvent event, UMOMessage returnMessage, Object replyTo) throws UMOException\n    {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"sending reply to: \" + returnMessage.getReplyTo());\n        }\n        String replyToEndpoint = replyTo.toString();\n\n        // get the endpoint for this url\n        UMOEndpoint endpoint = getEndpoint(event, replyToEndpoint);\n        if(transformer==null) {\n            transformer = event.getEndpoint().getResponseTransformer();\n        }\n        if (transformer != null) {\n            endpoint.setTransformer(transformer);\n        }\n\n        // Create the replyTo event asynchronous\n        UMOEvent replyToEvent = new MuleEvent(returnMessage, endpoint, event.getSession(), false);\n\n        // make sure remove the replyTo property as not cause a a forever\n        // replyto loop\n        replyToEvent.removeProperty(MuleProperties.MULE_REPLY_TO_PROPERTY);\n\n        // dispatch the event\n        try {\n            endpoint.getConnector().getDispatcher(replyTo.toString()).dispatch(replyToEvent);\n            if (logger.isInfoEnabled()) {\n                logger.info(\"reply to sent: \" + endpoint);\n            }\n            ((AbstractComponent) event.getComponent()).getStatistics().incSentReplyToEvent();\n        } catch (Exception e) {\n            throw new DispatchException(new Message(Messages.FAILED_TO_DISPATCH_TO_REPLYTO_X, endpoint),\n                                        replyToEvent.getMessage(),\n                                        replyToEvent.getEndpoint(),\n                                        e);\n        }\n\n    }","id":23869,"modified_method":"public void processReplyTo(UMOEvent event, UMOMessage returnMessage, Object replyTo)\n            throws UMOException\n    {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"sending reply to: \" + returnMessage.getReplyTo());\n        }\n        String replyToEndpoint = replyTo.toString();\n\n        // get the endpoint for this url\n        UMOEndpoint endpoint = getEndpoint(event, replyToEndpoint);\n        if (transformer == null) {\n            transformer = event.getEndpoint().getResponseTransformer();\n        }\n        if (transformer != null) {\n            endpoint.setTransformer(transformer);\n        }\n\n        // make sure remove the replyTo property as not cause a a forever\n        // replyto loop\n        returnMessage.removeProperty(MuleProperties.MULE_REPLY_TO_PROPERTY);\n\n        // Create the replyTo event asynchronous\n        UMOEvent replyToEvent = new MuleEvent(returnMessage, endpoint, event.getSession(), false);\n\n        // dispatch the event\n        try {\n            endpoint.getConnector().getDispatcher(replyTo.toString()).dispatch(replyToEvent);\n            if (logger.isInfoEnabled()) {\n                logger.info(\"reply to sent: \" + endpoint);\n            }\n            ((AbstractComponent)event.getComponent()).getStatistics().incSentReplyToEvent();\n        }\n        catch (Exception e) {\n            throw new DispatchException(new Message(Messages.FAILED_TO_DISPATCH_TO_REPLYTO_X, endpoint),\n                    replyToEvent.getMessage(), replyToEvent.getEndpoint(), e);\n        }\n\n    }","commit_id":"0f1c5486f7d6f57ef0c5d7fc3067e3593ac7e524","url":"https://github.com/mulesoft/mule"},{"original_method":"public void setCredentials(UMOEvent event, Object credentials)\n    {\n        event.setProperty(MuleProperties.MULE_USER_PROPERTY, credentials);\n    }","id":23870,"modified_method":"public void setCredentials(UMOEvent event, Object credentials)\n    {\n        event.getMessage().setProperty(MuleProperties.MULE_USER_PROPERTY, credentials);\n    }","commit_id":"0f1c5486f7d6f57ef0c5d7fc3067e3593ac7e524","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object getCredentials(UMOEvent event)\n    {\n        return event.getProperty(MuleProperties.MULE_USER_PROPERTY);\n    }","id":23871,"modified_method":"public Object getCredentials(UMOEvent event)\n    {\n        return event.getMessage().getProperty(MuleProperties.MULE_USER_PROPERTY);\n    }","commit_id":"0f1c5486f7d6f57ef0c5d7fc3067e3593ac7e524","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object onCall(UMOEventContext eventContext) throws Exception\n    {\n        String tempUrl;\n        Object request = eventContext.getTransformedMessage();\n        Object requestBody = request;\n        if(urlFromMessage) {\n            tempUrl = (String)eventContext.getProperty(REST_SERVICE_URL);\n            if(tempUrl==null) {\n                throw new IllegalArgumentException(new Message(Messages.X_PROPERTY_IS_NOT_SET_ON_EVENT, REST_SERVICE_URL).toString());\n            }\n        } else {\n            tempUrl = serviceUrl;\n        }\n        StringBuffer urlBuffer = new StringBuffer(tempUrl);\n\n        if(payloadParameterName!=null) {\n            requestBody = new NullPayload();\n        } else if(request instanceof Map) {\n            requestBody = new NullPayload();\n        }\n\n        setRESTParams(urlBuffer, eventContext.getMessage(), request, reqiredParams, false);\n        setRESTParams(urlBuffer, eventContext.getMessage(), request, optionalParams, true);\n\n        tempUrl = urlBuffer.toString();\n        logger.info(\"Invoking REST service: \" + tempUrl);\n\n        UMOEndpointURI endpointURI = new MuleEndpointURI(tempUrl);\n        eventContext.getMessage().setProperty(\"http.method\", httpMethod);\n\n        UMOMessage result = eventContext.sendEvent(new MuleMessage(requestBody, eventContext.getMessage()), endpointURI);\n\n        if(isErrorPayload(result)) {\n            handleException(new RestServiceException(\n                    new Message(Messages.FAILED_TO_INVOKE_REST_SERVICE_X, tempUrl), result),\n                    result);\n        }\n        return result;\n    }","id":23872,"modified_method":"public Object onCall(UMOEventContext eventContext) throws Exception\n    {\n        String tempUrl;\n        Object request = eventContext.getTransformedMessage();\n        Object requestBody = request;\n        if(urlFromMessage) {\n            tempUrl = eventContext.getMessage().getStringProperty(REST_SERVICE_URL, null);\n            if(tempUrl==null) {\n                throw new IllegalArgumentException(new Message(Messages.X_PROPERTY_IS_NOT_SET_ON_EVENT, REST_SERVICE_URL).toString());\n            }\n        } else {\n            tempUrl = serviceUrl;\n        }\n        StringBuffer urlBuffer = new StringBuffer(tempUrl);\n\n        if(payloadParameterName!=null) {\n            requestBody = new NullPayload();\n        } else if(request instanceof Map) {\n            requestBody = new NullPayload();\n        }\n\n        setRESTParams(urlBuffer, eventContext.getMessage(), request, reqiredParams, false);\n        setRESTParams(urlBuffer, eventContext.getMessage(), request, optionalParams, true);\n\n        tempUrl = urlBuffer.toString();\n        logger.info(\"Invoking REST service: \" + tempUrl);\n\n        UMOEndpointURI endpointURI = new MuleEndpointURI(tempUrl);\n        eventContext.getMessage().setProperty(\"http.method\", httpMethod);\n\n        UMOMessage result = eventContext.sendEvent(new MuleMessage(requestBody, eventContext.getMessage()), endpointURI);\n\n        if(isErrorPayload(result)) {\n            handleException(new RestServiceException(\n                    new Message(Messages.FAILED_TO_INVOKE_REST_SERVICE_X, tempUrl), result),\n                    result);\n        }\n        return result;\n    }","commit_id":"0f1c5486f7d6f57ef0c5d7fc3067e3593ac7e524","url":"https://github.com/mulesoft/mule"},{"original_method":"public static List<Configurable> buildConfigurablesList(final ConfigurableEP<Configurable>[] extensions,\n                                                          final Configurable[] components,\n                                                          @Nullable ConfigurableFilter filter,\n                                                          ExtensionPointName<ConfigurableEP<Configurable>> configurablesExtensionPoint) {\n    List<Configurable> result = new ArrayList<Configurable>();\n    PluginDescriptor descriptor = null;\n    for (ConfigurableEP<Configurable> ep : extensions) {\n      final Configurable configurable = ConfigurableWrapper.wrapConfigurable(ep);\n//      descriptor = dumpConfigurable(configurablesExtensionPoint, descriptor, ep, configurable);\n      ContainerUtil.addIfNotNull(configurable, result);\n    }\n    ContainerUtil.addAll(result, components);\n\n    final Iterator<Configurable> iterator = result.iterator();\n    while (iterator.hasNext()) {\n      Configurable each = iterator.next();\n      if (each instanceof Configurable.Assistant\n          || each instanceof OptionalConfigurable && !((OptionalConfigurable) each).needDisplay()\n          || filter != null && !filter.isIncluded(each)) {\n        iterator.remove();\n      }\n    }\n\n    return result;\n  }","id":23873,"modified_method":"public static List<Configurable> buildConfigurablesList(final ConfigurableEP<Configurable>[] extensions,\n                                                          final Configurable[] components,\n                                                          @Nullable ConfigurableFilter filter,\n                                                          ExtensionPointName<ConfigurableEP<Configurable>> configurablesExtensionPoint) {\n    List<Configurable> result = new ArrayList<Configurable>();\n    Map<String, ConfigurableWrapper> idToConfigurable = new HashMap<String, ConfigurableWrapper>();\n    List<ConfigurableWrapper> orphans = new ArrayList<ConfigurableWrapper>();\n    for (ConfigurableEP<Configurable> ep : extensions) {\n      final Configurable configurable = ConfigurableWrapper.wrapConfigurable(ep);\n      if (configurable instanceof ConfigurableWrapper) {\n        ConfigurableWrapper wrapper = (ConfigurableWrapper)configurable;\n        idToConfigurable.put(wrapper.getId(), wrapper);\n        if (wrapper.getParentId() != null) {\n          orphans.add(wrapper);\n        }\n      }\n      else {\n//        dumpConfigurable(configurablesExtensionPoint, ep, configurable);\n        ContainerUtil.addIfNotNull(configurable, result);\n      }\n    }\n    ContainerUtil.addAll(result, components);\n\n    for (ConfigurableWrapper orphan : orphans) {\n      String parentId = orphan.getParentId();\n      ConfigurableWrapper parent = idToConfigurable.get(parentId);\n      LOG.assertTrue(parent != null, \"Can't find parent for \" + parentId + \" (\" + orphan + \")\");\n      idToConfigurable.put(parentId, parent.addChild(orphan));\n    }\n\n    ContainerUtil.addAll(result, idToConfigurable.values());\n\n    final ListIterator<Configurable> iterator = result.listIterator();\n    while (iterator.hasNext()) {\n      Configurable each = iterator.next();\n      if (each instanceof Configurable.Assistant\n          || each instanceof OptionalConfigurable && !((OptionalConfigurable) each).needDisplay()\n          || filter != null && !filter.isIncluded(each)) {\n        iterator.remove();\n      }\n    }\n\n    return result;\n  }","commit_id":"b250f2304772a6c0dbd728132428b182dffd9cdb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static CompletionResultSet addJavaSorting(final CompletionParameters parameters, CompletionResultSet result) {\n    final PsiElement position = parameters.getPosition();\n    final ExpectedTypeInfo[] expectedTypes = PsiJavaPatterns.psiElement().beforeLeaf(PsiJavaPatterns.psiElement().withText(\".\")).accepts(position) ? ExpectedTypeInfo.EMPTY_ARRAY : JavaSmartCompletionContributor.getExpectedTypes(parameters);\n    final CompletionType type = parameters.getCompletionType();\n    final boolean smart = type == CompletionType.SMART;\n    final boolean afterNew = JavaSmartCompletionContributor.AFTER_NEW.accepts(position);\n\n    List<LookupElementWeigher> afterProximity = new ArrayList<LookupElementWeigher>();\n    afterProximity.add(new PreferContainingSameWords(expectedTypes));\n    afterProximity.add(new PreferShorter(expectedTypes));\n\n    CompletionSorter sorter = CompletionSorter.defaultSorter(parameters, result.getPrefixMatcher());\n    if (!smart && afterNew) {\n      sorter = sorter.weighBefore(\"liftShorter\", new PreferExpected(true, expectedTypes));\n    } else if (PsiTreeUtil.getParentOfType(position, PsiReferenceList.class) == null) {\n      sorter = ((CompletionSorterImpl)sorter).withClassifier(\"liftShorterClasses\", true, new LiftShorterClasses(position));\n    }\n    if (smart) {\n      sorter = sorter.weighAfter(\"priority\", new PreferDefaultTypeWeigher(expectedTypes, parameters));\n    }\n\n    List<LookupElementWeigher> afterPrefix = ContainerUtil.newArrayList();\n    if (!smart) {\n      ContainerUtil.addIfNotNull(afterPrefix, preferStatics(position, expectedTypes));\n    }\n    ContainerUtil.addIfNotNull(afterPrefix, recursion(parameters, expectedTypes));\n    if (!smart && !afterNew) {\n      afterPrefix.add(new PreferExpected(false, expectedTypes));\n    }\n    Collections.addAll(afterPrefix, new PreferByKindWeigher(type, position), new PreferSimilarlyEnding(expectedTypes),\n                       new PreferNonGeneric(), new PreferAccessible(position), new PreferSimple());\n\n    sorter = sorter.weighAfter(\"prefix\", afterPrefix.toArray(new LookupElementWeigher[afterPrefix.size()]));\n    sorter = sorter.weighAfter(\"proximity\", afterProximity.toArray(new LookupElementWeigher[afterProximity.size()]));\n    return result.withRelevanceSorter(sorter);\n  }","id":23874,"modified_method":"public static CompletionResultSet addJavaSorting(final CompletionParameters parameters, CompletionResultSet result) {\n    final PsiElement position = parameters.getPosition();\n    final ExpectedTypeInfo[] expectedTypes = PsiJavaPatterns.psiElement().beforeLeaf(PsiJavaPatterns.psiElement().withText(\".\")).accepts(position) ? ExpectedTypeInfo.EMPTY_ARRAY : JavaSmartCompletionContributor.getExpectedTypes(parameters);\n    final CompletionType type = parameters.getCompletionType();\n    final boolean smart = type == CompletionType.SMART;\n    final boolean afterNew = JavaSmartCompletionContributor.AFTER_NEW.accepts(position);\n\n    List<LookupElementWeigher> afterProximity = new ArrayList<LookupElementWeigher>();\n    afterProximity.add(new PreferContainingSameWords(expectedTypes));\n    afterProximity.add(new PreferShorter(expectedTypes));\n\n    CompletionSorter sorter = CompletionSorter.defaultSorter(parameters, result.getPrefixMatcher());\n    if (!smart && afterNew) {\n      sorter = sorter.weighBefore(\"liftShorter\", new PreferExpected(true, expectedTypes));\n    } else if (PsiTreeUtil.getParentOfType(position, PsiReferenceList.class) == null) {\n      sorter = ((CompletionSorterImpl)sorter).withClassifier(\"liftShorterClasses\", true, new LiftShorterClasses(position));\n    }\n    if (smart) {\n      sorter = sorter.weighAfter(\"priority\", new PreferDefaultTypeWeigher(expectedTypes, parameters));\n    }\n\n    List<LookupElementWeigher> afterPrefix = ContainerUtil.newArrayList();\n    if (!smart) {\n      ContainerUtil.addIfNotNull(afterPrefix, preferStatics(position, expectedTypes));\n    }\n    if (!smart && !afterNew) {\n      afterPrefix.add(new PreferExpected(false, expectedTypes));\n    }\n    afterPrefix.add(new PreferByKindWeigher(type, position));\n    ContainerUtil.addIfNotNull(afterPrefix, recursion(parameters, expectedTypes));\n    Collections.addAll(afterPrefix, new PreferSimilarlyEnding(expectedTypes),\n                       new PreferNonGeneric(), new PreferAccessible(position), new PreferSimple());\n\n    sorter = sorter.weighAfter(\"prefix\", afterPrefix.toArray(new LookupElementWeigher[afterPrefix.size()]));\n    sorter = sorter.weighAfter(\"proximity\", afterProximity.toArray(new LookupElementWeigher[afterProximity.size()]));\n    return result.withRelevanceSorter(sorter);\n  }","commit_id":"9c67ca61703342be7d4e7203ebd0f34682a77355","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected ModelView<M> toView(final MutableModelNode modelNode, final ModelRuleDescriptor ruleDescriptor, final boolean writable) {\n        return new ModelView<M>() {\n\n            private boolean closed;\n            private final Map<String, Object> propertyViews = new HashMap<String, Object>();\n\n            @Override\n            public ModelPath getPath() {\n                return modelNode.getPath();\n            }\n\n            public ModelType<M> getType() {\n                return ManagedModelProjection.this.getType();\n            }\n\n            public M getInstance() {\n                return proxyFactory.createProxy(new State(), schema, bindings, typeConverter);\n            }\n\n            public void close() {\n                closed = true;\n            }\n\n            class State implements ModelElementState {\n                @Override\n                public MutableModelNode getBackingNode() {\n                    return modelNode;\n                }\n\n                @Override\n                public String getDisplayName() {\n                    return String.format(\"%s '%s'\", getType(), modelNode.getPath().toString());\n                }\n\n                @Override\n                public boolean equals(Object obj) {\n                    if (obj == this) {\n                        return true;\n                    }\n                    if (obj == null || obj.getClass() != getClass()) {\n                        return false;\n                    }\n\n                    State other = Cast.uncheckedCast(obj);\n                    return modelNode == other.getBackingNode();\n                }\n\n                @Override\n                public int hashCode() {\n                    return modelNode.hashCode();\n                }\n\n                public Object get(String name) {\n                    if (propertyViews.containsKey(name)) {\n                        return propertyViews.get(name);\n                    }\n\n                    ModelProperty<?> property = schema.getProperty(name);\n\n                    Object value = doGet(property, name);\n                    propertyViews.put(name, value);\n                    return value;\n                }\n\n                private <T> T doGet(ModelProperty<T> property, String propertyName) {\n                    ModelType<T> propertyType = property.getType();\n\n                    // TODO we are relying on the registration having established these links, we should be checking\n                    MutableModelNode propertyNode = modelNode.getLink(propertyName);\n                    propertyNode.ensureUsable();\n\n                    ModelView<? extends T> modelView;\n                    ModelSchema<T> propertySchema = property.getSchema();\n                    if (property.isWritable() && propertySchema instanceof ScalarCollectionSchema) {\n                        Collection<?> instance = ScalarCollectionSchema.get(propertyNode);\n                        if (instance == null) {\n                            return null;\n                        }\n                    }\n                    if (writable) {\n                        modelView = propertyNode.asMutable(propertyType, ruleDescriptor);\n                        if (closed) {\n                            modelView.close();\n                        }\n                    } else {\n                        modelView = propertyNode.asImmutable(propertyType, ruleDescriptor);\n                    }\n                    return modelView.getInstance();\n                }\n\n                @Override\n                public void apply(String name, Closure<?> action) {\n                    ClosureBackedAction.execute(get(name), action);\n                }\n\n                public void set(String name, Object value) {\n                    if (!writable || closed) {\n                        throw new ModelViewClosedException(getType(), ruleDescriptor);\n                    }\n\n                    ModelProperty<?> property = schema.getProperty(name);\n\n                    value = doSet(name, value, property);\n                    propertyViews.put(name, value);\n                }\n\n                private <T> Object doSet(String name, Object value, ModelProperty<T> property) {\n                    ModelSchema<T> propertySchema = property.getSchema();\n\n                    // TODO we are relying on the registration having established these links, we should be checking\n                    MutableModelNode propertyNode = modelNode.getLink(name);\n                    propertyNode.ensureUsable();\n\n                    if (propertySchema instanceof ManagedImplSchema) {\n                        if (value == null) {\n                            if (propertySchema instanceof ScalarCollectionSchema) {\n                                ScalarCollectionSchema.clear(propertyNode);\n                            } else {\n                                propertyNode.setTarget(null);\n                            }\n                        } else if (ManagedInstance.class.isInstance(value)) {\n                            ManagedInstance managedInstance = (ManagedInstance) value;\n                            MutableModelNode targetNode = managedInstance.getBackingNode();\n                            propertyNode.setTarget(targetNode);\n                        } else if (propertySchema instanceof ScalarCollectionSchema && value instanceof Collection) {\n                            ModelView<? extends Collection<?>> modelView = propertyNode.asMutable(COLLECTION_MODEL_TYPE, ruleDescriptor);\n                            Collection<Object> instance = Cast.uncheckedCast(modelView.getInstance());\n                            Collection<Object> values = Cast.uncheckedCast(value);\n                            instance.clear();\n                            instance.addAll(values);\n                            return instance;\n                        } else {\n                            throw new IllegalArgumentException(String.format(\"Only managed model instances can be set as property '%s' of class '%s'\", name, getType()));\n                        }\n                    } else {\n                        T castValue = Cast.uncheckedCast(value);\n                        propertyNode.setPrivateData(property.getType(), castValue);\n                    }\n                    return value;\n                }\n            }\n        };\n    }","id":23875,"modified_method":"@Override\n    protected ModelView<M> toView(final MutableModelNode modelNode, final ModelRuleDescriptor ruleDescriptor, final boolean writable) {\n        return new ModelView<M>() {\n\n            private boolean closed;\n            private final Map<String, Object> propertyViews = new HashMap<String, Object>();\n\n            @Override\n            public ModelPath getPath() {\n                return modelNode.getPath();\n            }\n\n            public ModelType<M> getType() {\n                return ManagedModelProjection.this.getType();\n            }\n\n            public M getInstance() {\n                return proxyFactory.createProxy(new State(), schema, bindings, typeConverter);\n            }\n\n            public void close() {\n                closed = true;\n            }\n\n            class State implements ModelElementState {\n                @Override\n                public MutableModelNode getBackingNode() {\n                    return modelNode;\n                }\n\n                @Override\n                public String getDisplayName() {\n                    return String.format(\"%s '%s'\", getType(), modelNode.getPath().toString());\n                }\n\n                @Override\n                public boolean equals(Object obj) {\n                    if (obj == this) {\n                        return true;\n                    }\n                    if (obj == null || obj.getClass() != getClass()) {\n                        return false;\n                    }\n\n                    State other = Cast.uncheckedCast(obj);\n                    return modelNode == other.getBackingNode();\n                }\n\n                @Override\n                public int hashCode() {\n                    return modelNode.hashCode();\n                }\n\n                public Object get(String name) {\n                    if (propertyViews.containsKey(name)) {\n                        return propertyViews.get(name);\n                    }\n\n                    ModelProperty<?> property = schema.getProperty(name);\n\n                    Object value = doGet(property, name);\n                    propertyViews.put(name, value);\n                    return value;\n                }\n\n                private <T> T doGet(ModelProperty<T> property, String propertyName) {\n                    ModelType<T> propertyType = property.getType();\n\n                    // TODO we are relying on the registration having established these links, we should be checking\n                    MutableModelNode propertyNode = modelNode.getLink(propertyName);\n                    propertyNode.ensureUsable();\n\n                    ModelView<? extends T> modelView;\n                    if (writable) {\n                        modelView = propertyNode.asMutable(propertyType, ruleDescriptor);\n                        if (closed) {\n                            modelView.close();\n                        }\n                    } else {\n                        modelView = propertyNode.asImmutable(propertyType, ruleDescriptor);\n                    }\n                    return modelView.getInstance();\n                }\n\n                @Override\n                public void apply(String name, Closure<?> action) {\n                    ClosureBackedAction.execute(get(name), action);\n                }\n\n                public void set(String name, Object value) {\n                    if (!writable || closed) {\n                        throw new ModelViewClosedException(getType(), ruleDescriptor);\n                    }\n\n                    ModelProperty<?> property = schema.getProperty(name);\n\n                    value = doSet(name, value, property);\n                    propertyViews.put(name, value);\n                }\n\n                private <T> Object doSet(String name, Object value, ModelProperty<T> property) {\n                    ModelSchema<T> propertySchema = property.getSchema();\n\n                    // TODO we are relying on the registration having established these links, we should be checking\n                    MutableModelNode propertyNode = modelNode.getLink(name);\n                    propertyNode.ensureUsable();\n\n                    if (propertySchema instanceof ManagedImplSchema) {\n                        if (propertySchema instanceof ScalarCollectionSchema) {\n                            ModelView<? extends Collection<?>> modelView = propertyNode.asMutable(COLLECTION_MODEL_TYPE, ruleDescriptor);\n                            return ((ScalarCollectionModelView<?, ? extends Collection<?>>) modelView).setValue(value);\n                        } else if (value == null) {\n                            propertyNode.setTarget(null);\n                        } else if (ManagedInstance.class.isInstance(value)) {\n                            ManagedInstance managedInstance = (ManagedInstance) value;\n                            MutableModelNode targetNode = managedInstance.getBackingNode();\n                            propertyNode.setTarget(targetNode);\n                        } else {\n                            throw new IllegalArgumentException(String.format(\"Only managed model instances can be set as property '%s' of class '%s'\", name, getType()));\n                        }\n                    } else {\n                        T castValue = Cast.uncheckedCast(value);\n                        propertyNode.setPrivateData(property.getType(), castValue);\n                    }\n                    return value;\n                }\n            }\n        };\n    }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public ModelView<ModelSet<T>> toView(MutableModelNode modelNode, ModelRuleDescriptor ruleDescriptor, boolean writable) {\n            ModelType<ModelSet<T>> setType = ModelTypes.modelSet(elementType);\n            DefaultModelViewState state = new DefaultModelViewState(modelNode.getPath(), setType, ruleDescriptor, writable, !writable);\n            ChildNodeInitializerStrategy<T> childStrategy = Cast.uncheckedCast(modelNode.getPrivateData(ChildNodeInitializerStrategy.class));\n            NodeBackedModelSet<T> set = new NodeBackedModelSet<T>(setType.toString() + \" '\" + modelNode.getPath() + \"'\", elementType, ruleDescriptor, modelNode, state, childStrategy);\n            return InstanceModelView.of(modelNode.getPath(), setType, set, state.closer());\n        }","id":23876,"modified_method":"@Override\n        public ModelView<ModelSet<T>> toView(MutableModelNode modelNode, ModelRuleDescriptor ruleDescriptor, boolean mutable) {\n            ModelType<ModelSet<T>> setType = ModelTypes.modelSet(elementType);\n            DefaultModelViewState state = new DefaultModelViewState(modelNode.getPath(), setType, ruleDescriptor, mutable, !mutable);\n            ChildNodeInitializerStrategy<T> childStrategy = Cast.uncheckedCast(modelNode.getPrivateData(ChildNodeInitializerStrategy.class));\n            NodeBackedModelSet<T> set = new NodeBackedModelSet<T>(setType.toString() + \" '\" + modelNode.getPath() + \"'\", elementType, ruleDescriptor, modelNode, state, childStrategy);\n            return InstanceModelView.of(modelNode.getPath(), setType, set, state.closer());\n        }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public boolean addAll(int index, Collection<? extends T> c) {\n            validateCollection(c);\n            return getDelegate(true).addAll(index, c);\n        }","id":23877,"modified_method":"@Override\n        public boolean addAll(int index, Collection<? extends T> c) {\n            validateCollection(c);\n            return ((List<T>)getDelegate(true)).addAll(index, c);\n        }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected <T, E> NodeInitializer extractNodeInitializer(CollectionSchema<T, E> schema, NodeInitializerContext<T> context) {\n        ModelType<T> type = schema.getType();\n        Class<? super T> rawClass = type.getRawClass();\n        ModelType<? super T> rawCollectionType = ModelType.of(rawClass);\n        if (TYPES.contains(rawCollectionType) && (schema.getElementTypeSchema() instanceof ScalarValueSchema)) {\n            Optional<NodeInitializerContext.PropertyContext> propertyContext = context.getPropertyContextOptional();\n            boolean writable = !propertyContext.isPresent() || propertyContext.get().isWritable();\n            if (schema.getType().getRawClass() == List.class) {\n                return new ProjectionOnlyNodeInitializer(\n                    ScalarCollectionModelProjection.get(\n                        ModelTypes.list(schema.getElementType()),\n                        new ListViewFactory<E>(schema.getElementType()),\n                        writable\n                    )\n                );\n            } else {\n                return new ProjectionOnlyNodeInitializer(\n                    ScalarCollectionModelProjection.get(\n                        ModelTypes.set(schema.getElementType()),\n                        new SetViewFactory<E>(schema.getElementType()),\n                        writable\n                    )\n                );\n            }\n        }\n        return null;\n    }","id":23878,"modified_method":"@Override\n    protected <T, E> NodeInitializer extractNodeInitializer(CollectionSchema<T, E> schema, NodeInitializerContext<T> context) {\n        ModelType<T> type = schema.getType();\n        Class<? super T> rawClass = type.getRawClass();\n        ModelType<? super T> rawCollectionType = ModelType.of(rawClass);\n        if (TYPES.contains(rawCollectionType) && (schema.getElementTypeSchema() instanceof ScalarValueSchema)) {\n            Optional<NodeInitializerContext.PropertyContext> propertyContext = context.getPropertyContextOptional();\n            boolean writable = !propertyContext.isPresent() || propertyContext.get().isWritable();\n            if (schema.getType().getRawClass() == List.class) {\n                return new ProjectionOnlyNodeInitializer(\n                    ScalarCollectionModelProjection.forList(schema.getElementType(), !writable)\n                );\n            } else {\n                return new ProjectionOnlyNodeInitializer(\n                    ScalarCollectionModelProjection.forSet(schema.getElementType(), !writable)\n                );\n            }\n        }\n        return null;\n    }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"public ScalarCollectionModelProjection(ModelType<E> type, ModelViewFactory<E> viewFactory, boolean writable) {\n            super(type, viewFactory);\n            this.writable = writable;\n        }","id":23879,"modified_method":"public ScalarCollectionModelProjection(ModelType<C> type) {\n            super(type);\n        }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public int indexOf(Object o) {\n            return getDelegate(false).indexOf(o);\n        }","id":23880,"modified_method":"@Override\n        public int indexOf(Object o) {\n            return ((List<T>)getDelegate(false)).indexOf(o);\n        }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"public static <E, U extends Collection<E>> ScalarCollectionModelProjection<U> get(ModelType<U> type, ModelViewFactory<U> viewFactory, boolean writable) {\n            return new ScalarCollectionModelProjection<U>(type, viewFactory, writable);\n        }","id":23881,"modified_method":"public static <E> ScalarCollectionModelProjection<E, Set<E>> forSet(final ModelType<E> elementType, final boolean readOnly) {\n            return new ScalarCollectionModelProjection<E, Set<E>>(ModelTypes.set(elementType)) {\n                @Override\n                protected ScalarCollectionModelView<E, Set<E>> toView(MutableModelNode modelNode, ModelRuleDescriptor ruleDescriptor, boolean mutable) {\n                    return new SetModelView<E>(modelNode.getPath(), elementType, modelNode, ruleDescriptor, readOnly, mutable);\n                }\n            };\n        }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public T set(int index, T element) {\n            validateElementType(element);\n            return getDelegate(true).set(index, element);\n        }","id":23882,"modified_method":"@Override\n        public T set(int index, T element) {\n            validateElementType(element);\n            return ((List<T>)getDelegate(true)).set(index, element);\n        }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public T remove(int index) {\n            return getDelegate(true).remove(index);\n        }","id":23883,"modified_method":"@Override\n        public T remove(int index) {\n            return ((List<T>)getDelegate(true)).remove(index);\n        }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public Optional<String> getValueDescription(MutableModelNode modelNodeInternal) {\n            Collection<?> values = ScalarCollectionSchema.get(modelNodeInternal);\n            if (values == null) {\n                if (writable) {\n                    return Optional.of(\"null\");\n                } else {\n                    return Optional.of(\"[]\");\n                }\n            }\n            return Optional.of(values.toString());\n        }","id":23884,"modified_method":"@Override\n        public Optional<String> getValueDescription(MutableModelNode modelNodeInternal) {\n            Collection<?> values = modelNodeInternal.asImmutable(getType(), null).getInstance();\n            if (values == null) {\n                return Optional.of(\"null\");\n            }\n            return Optional.of(values.toString());\n        }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public T get(int index) {\n            return getDelegate(false).get(index);\n        }","id":23885,"modified_method":"@Override\n        public T get(int index) {\n            return ((List<T>)getDelegate(false)).get(index);\n        }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"public ListBackedCollection(MutableModelNode modelNode, ModelViewState state, ModelType<T> elementType) {\n            super(modelNode, state, elementType);\n        }","id":23886,"modified_method":"public ListBackedCollection(List<T> delegate, ModelViewState state, ModelType<T> elementType) {\n            super(delegate, state, elementType);\n        }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public ListIterator<T> listIterator(int index) {\n            return getDelegate(false).listIterator(index);\n        }","id":23887,"modified_method":"@Override\n        public ListIterator<T> listIterator(int index) {\n            return ((List<T>)getDelegate(false)).listIterator(index);\n        }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public ListIterator<T> listIterator() {\n            return getDelegate(false).listIterator();\n        }","id":23888,"modified_method":"@Override\n        public ListIterator<T> listIterator() {\n            return ((List<T>)getDelegate(false)).listIterator();\n        }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public void add(int index, T element) {\n            validateElementType(element);\n            getDelegate(true).add(index, element);\n        }","id":23889,"modified_method":"@Override\n        public void add(int index, T element) {\n            validateElementType(element);\n            ((List<T>)getDelegate(true)).add(index, element);\n        }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public int lastIndexOf(Object o) {\n            return getDelegate(false).lastIndexOf(o);\n        }","id":23890,"modified_method":"@Override\n        public int lastIndexOf(Object o) {\n            return ((List<T>)getDelegate(false)).lastIndexOf(o);\n        }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"public SetBackedCollection(MutableModelNode modelNode, ModelViewState state, ModelType<T> elementType) {\n            super(modelNode, state, elementType);\n        }","id":23891,"modified_method":"public SetBackedCollection(Set<T> delegate, ModelViewState state, ModelType<T> elementType) {\n            super(delegate, state, elementType);\n        }","commit_id":"4f6e19179367c53b1f3e24cc4d90096d089280d6","url":"https://github.com/gradle/gradle"},{"original_method":"protected RelationshipType getRelationshipType( String name )\n\t{\n\t\t// this.ensureRelTypesInitialized();\n\t\tRelationshipType result = this.getNeoServer().getNeo().\n\t\t\tgetRelationshipType( name );\n\t\tif ( result == null )\n\t\t{\n\t\t\tthrow new RuntimeException( \"No relationship type '\" + name +\n\t\t\t\t\"' found\" );\n\t\t}\n\t\treturn result;\n\t}","id":23892,"modified_method":"protected RelationshipType getRelationshipType( String name )\n\t{\n\t\t// this.ensureRelTypesInitialized();\n\t\tRelationshipType result = ( ( EmbeddedNeo ) this.getNeoServer().\n\t\t\tgetNeo() ).getRelationshipType( name );\n\t\tif ( result == null )\n\t\t{\n\t\t\tthrow new RuntimeException( \"No relationship type '\" + name +\n\t\t\t\t\"' found\" );\n\t\t}\n\t\treturn result;\n\t}","commit_id":"6b32531a1ac0b495c7d5e46115d517cfe3d0b37e","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected RelationshipType getRelationshipType( String name )\n\t{\n\t\t// this.ensureRelTypesInitialized();\n\t\tRelationshipType result = this.getNeoServer().getNeo().\n\t\t\tgetRelationshipType( name );\n\t\tif ( result == null )\n\t\t{\n\t\t\tthrow new RuntimeException( \"No relationship type '\" + name +\n\t\t\t\t\"' found\" );\n\t\t}\n\t\treturn result;\n\t}","id":23893,"modified_method":"protected RelationshipType getRelationshipType( String name )\n\t{\n\t\t// this.ensureRelTypesInitialized();\n\t\tRelationshipType result = ( ( EmbeddedNeo ) this.getNeoServer().\n\t\t\tgetNeo() ).getRelationshipType( name );\n\t\tif ( result == null )\n\t\t{\n\t\t\tthrow new RuntimeException( \"No relationship type '\" + name +\n\t\t\t\t\"' found\" );\n\t\t}\n\t\treturn result;\n\t}","commit_id":"044888b162e80a1b82c324a82f9f2f7635317340","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected RelationshipType getRelationshipType( String name )\n\t{\n\t\t// this.ensureRelTypesInitialized();\n\t\tRelationshipType result = this.getNeoServer().getNeo().\n\t\t\tgetRelationshipType( name );\n\t\tif ( result == null )\n\t\t{\n\t\t\tthrow new RuntimeException( \"No relationship type '\" + name +\n\t\t\t\t\"' found\" );\n\t\t}\n\t\treturn result;\n\t}","id":23894,"modified_method":"protected RelationshipType getRelationshipType( String name )\n\t{\n\t\t// this.ensureRelTypesInitialized();\n\t\tRelationshipType result = ( ( EmbeddedNeo ) this.getNeoServer().\n\t\t\tgetNeo() ).getRelationshipType( name );\n\t\tif ( result == null )\n\t\t{\n\t\t\tthrow new RuntimeException( \"No relationship type '\" + name +\n\t\t\t\t\"' found\" );\n\t\t}\n\t\treturn result;\n\t}","commit_id":"c3e15c856aa27ffa71f1afd75b62bf7cabc47680","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void copyModule(ModuleSpec module, Set<String> artifacts) throws IOException {\n        if (!copiedModules.add(module)) {\n            return;\n        }\n        if (!JDKUtils.isJDKModule(module.getName()) && !JDKUtils.isOracleJDKModule(module.getName())) {\n            Collection<ModuleVersionDetails> versions = getModuleVersions(module.getName(), module.getVersion(), ModuleQuery.Type.ALL, null, null);\n            if (!versions.isEmpty()) {\n                ModuleVersionDetails ver = versions.iterator().next();\n                msg(\"copying.module\", module).newline().flush();\n                ArtifactResult result = null;\n                Set<String> suffixes = new LinkedHashSet<String>(artifacts);\n                while (!suffixes.isEmpty()) {\n                    // Try to get one of the artifacts\n                    String[] sfx = new String[suffixes.size()];\n                    sfx = suffixes.toArray(sfx);\n                    ArtifactContext ac;\n                    if (result == null) {\n                        ac = new ArtifactContext(module.getName(), module.getVersion(), sfx);\n                    } else {\n                        // We re-use the previous result so we can efficiently\n                        // retrieve further artifacts from the same module\n                        ac = result.getSiblingArtifact(sfx);\n                    }\n                    ac.setThrowErrorIfMissing(false);\n                    result = getRepositoryManager().getArtifactResult(ac);\n                    \n                    if (result != null) {\n                        // Set the proper suffix for the copy operation\n                        String suffix = ArtifactContext.getSuffixFromFilename(result.artifact().getName());\n                        ac.setSuffixes(suffix);\n                        \n                        // Perform the actual copying\n                        copyArtifact(ac, result.artifact());\n                        \n                        // make sure we don't try to get the same artifact twice\n                        suffixes.remove(suffix);\n                        \n                        // if we found a car we can skip the jar and module descriptors\n                        if (suffix.equals(ArtifactContext.CAR)) {\n                            suffixes.remove(ArtifactContext.JAR);\n                            suffixes.remove(ArtifactContext.MODULE_PROPERTIES);\n                            suffixes.remove(ArtifactContext.MODULE_XML);\n                        }\n                    } else {\n                        // We didn't find anything (this time),\n                        // we can stop trying more artifact types\n                        break;\n                    }\n                }\n                if (recursive) {\n                    for (ModuleInfo dep : ver.getDependencies()) {\n                        ModuleSpec depModule = new ModuleSpec(dep.getName(), dep.getVersion());\n                        copyModule(depModule, artifacts);\n                    }\n                }\n            } else {\n                String err = getModuleNotFoundErrorMessage(getRepositoryManager(), module.getName(), module.getVersion());\n                errorAppend(err);\n                errorNewline();\n            }\n        }\n    }","id":23895,"modified_method":"private void copyModule(ModuleSpec module, String... artifacts) throws IOException {\n        if (!copiedModules.add(module)) {\n            return;\n        }\n        if (!JDKUtils.isJDKModule(module.getName()) && !JDKUtils.isOracleJDKModule(module.getName())) {\n            Collection<ModuleVersionDetails> versions = getModuleVersions(module.getName(), module.getVersion(), ModuleQuery.Type.ALL, null, null);\n            if (!versions.isEmpty()) {\n                ModuleVersionDetails ver = versions.iterator().next();\n                msg(\"copying.module\", module).newline().flush();\n                ArtifactContext ac = new ArtifactContext(module.getName(), module.getVersion(), artifacts);\n                ArtifactResult results[] = getRepositoryManager().getArtifactResults(ac);\n                for (ArtifactResult r : results) {\n                    copyArtifact(ac, r.artifact());\n                }\n                if (recursive) {\n                    for (ModuleInfo dep : ver.getDependencies()) {\n                        ModuleSpec depModule = new ModuleSpec(dep.getName(), dep.getVersion());\n                        copyModule(depModule, artifacts);\n                    }\n                }\n            } else {\n                String err = getModuleNotFoundErrorMessage(getRepositoryManager(), module.getName(), module.getVersion());\n                errorAppend(err);\n                errorNewline();\n            }\n        }\n    }","commit_id":"9b833b236f5b3d5bc4d5f7e9fc4c89c1f557a78a","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public void run() throws Exception {\n        setSystemProperties();\n        // FIXME: copying is currently very inefficient!\n        // All possible suffix types are tried which will result in numerous\n        // unnecessary roundtrips to external servers\n        Set<String> artifacts = new LinkedHashSet<String>();\n        boolean defaults = js == null \n                && jvm == null\n                && src == null\n                && docs == null\n                && all == null;\n        if (BooleanUtil.isTrue(all)) {\n            artifacts.addAll(ArtifactContext.allSuffixes());\n        }\n        if (BooleanUtil.isTrue(js) || defaults) {\n            artifacts.add(ArtifactContext.JS);\n            artifacts.add(ArtifactContext.JS_MODEL);\n            artifacts.add(ArtifactContext.RESOURCES);\n        } else if (BooleanUtil.isFalse(js)) {\n            artifacts.remove(ArtifactContext.JS);\n            artifacts.remove(ArtifactContext.JS_MODEL);\n            artifacts.remove(ArtifactContext.RESOURCES);\n        }\n        if (BooleanUtil.isTrue(jvm) || defaults) {\n            // put the CAR first since its presence will shortcut the other three\n            artifacts.add(ArtifactContext.CAR);\n            artifacts.add(ArtifactContext.JAR);\n            artifacts.add(ArtifactContext.MODULE_PROPERTIES);\n            artifacts.add(ArtifactContext.MODULE_XML);\n        } else if (BooleanUtil.isFalse(jvm)) {\n            artifacts.remove(ArtifactContext.CAR);\n            artifacts.remove(ArtifactContext.JAR);\n            artifacts.remove(ArtifactContext.MODULE_PROPERTIES);\n            artifacts.remove(ArtifactContext.MODULE_XML);\n        }\n        if (BooleanUtil.isTrue(src)) {\n            artifacts.add(ArtifactContext.SRC);\n        } else if (BooleanUtil.isFalse(src)) {\n            artifacts.remove(ArtifactContext.SRC);\n        }\n        if (BooleanUtil.isTrue(docs)) {\n            artifacts.add(ArtifactContext.DOCS_ZIPPED);\n            artifacts.add(ArtifactContext.DOCS);\n        } else if (BooleanUtil.isFalse(docs)) {\n            artifacts.remove(ArtifactContext.DOCS_ZIPPED);\n            artifacts.remove(ArtifactContext.DOCS);\n        }\n        for (ModuleSpec module : modules) {\n            if (module != ModuleSpec.DEFAULT_MODULE && !module.isVersioned()) {\n                String version = checkModuleVersionsOrShowSuggestions(getRepositoryManager(), module.getName(), null, ModuleQuery.Type.ALL, null, null);\n                module = new ModuleSpec(module.getName(), version);\n            }\n            copyModule(module, artifacts);\n        }\n    }","id":23896,"modified_method":"@Override\n    public void run() throws Exception {\n        setSystemProperties();\n        // FIXME: copying is currently very inefficient!\n        // All possible suffix types are tried which will result in numerous\n        // unnecessary roundtrips to external servers\n        Set<String> artifacts = new LinkedHashSet<String>();\n        boolean defaults = js == null \n                && jvm == null\n                && src == null\n                && docs == null\n                && all == null;\n        if (BooleanUtil.isTrue(all)) {\n            artifacts.addAll(ArtifactContext.allSuffixes());\n        }\n        if (BooleanUtil.isTrue(js) || defaults) {\n            artifacts.add(ArtifactContext.JS);\n            artifacts.add(ArtifactContext.JS_MODEL);\n            artifacts.add(ArtifactContext.RESOURCES);\n        } else if (BooleanUtil.isFalse(js)) {\n            artifacts.remove(ArtifactContext.JS);\n            artifacts.remove(ArtifactContext.JS_MODEL);\n            artifacts.remove(ArtifactContext.RESOURCES);\n        }\n        if (BooleanUtil.isTrue(jvm) || defaults) {\n            // put the CAR first since its presence will shortcut the other three\n            artifacts.add(ArtifactContext.CAR);\n            artifacts.add(ArtifactContext.JAR);\n            artifacts.add(ArtifactContext.MODULE_PROPERTIES);\n            artifacts.add(ArtifactContext.MODULE_XML);\n        } else if (BooleanUtil.isFalse(jvm)) {\n            artifacts.remove(ArtifactContext.CAR);\n            artifacts.remove(ArtifactContext.JAR);\n            artifacts.remove(ArtifactContext.MODULE_PROPERTIES);\n            artifacts.remove(ArtifactContext.MODULE_XML);\n        }\n        if (BooleanUtil.isTrue(src)) {\n            artifacts.add(ArtifactContext.SRC);\n        } else if (BooleanUtil.isFalse(src)) {\n            artifacts.remove(ArtifactContext.SRC);\n        }\n        if (BooleanUtil.isTrue(docs)) {\n            artifacts.add(ArtifactContext.DOCS_ZIPPED);\n            artifacts.add(ArtifactContext.DOCS);\n        } else if (BooleanUtil.isFalse(docs)) {\n            artifacts.remove(ArtifactContext.DOCS_ZIPPED);\n            artifacts.remove(ArtifactContext.DOCS);\n        }\n        for (ModuleSpec module : modules) {\n            if (module != ModuleSpec.DEFAULT_MODULE && !module.isVersioned()) {\n                String version = checkModuleVersionsOrShowSuggestions(getRepositoryManager(), module.getName(), null, ModuleQuery.Type.ALL, null, null);\n                module = new ModuleSpec(module.getName(), version);\n            }\n            String[] tmp = new String[artifacts.size()];\n            copyModule(module, artifacts.toArray(tmp));\n        }\n    }","commit_id":"9b833b236f5b3d5bc4d5f7e9fc4c89c1f557a78a","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void copyArtifact(ArtifactContext ac, File archive) throws RepositoryException, IOException {\n        if (verbose != null && (verbose.contains(\"all\") || verbose.contains(\"files\"))) {\n            append(\"    \").msg(\"copying.artifact\", archive.getName()).newline().flush();\n        }\n        getOutputRepositoryManager().putArtifact(ac, archive);\n        // SHA1 it if required\n        if(!ArtifactContext.isDirectoryName(ac.getSingleSuffix())) {\n            signArtifact(ac, archive);\n        }\n    }","id":23897,"modified_method":"private void copyArtifact(ArtifactContext ac, File archive) throws RepositoryException, IOException {\n        if (verbose != null && (verbose.contains(\"all\") || verbose.contains(\"files\"))) {\n            append(\"    \").msg(\"copying.artifact\", archive.getName()).newline().flush();\n        }\n        // Make sure we set the correct suffix for the put\n        String suffix = ArtifactContext.getSuffixFromFilename(archive.getName());\n        ac.setSuffixes(suffix);\n        // Store the artifact\n        getOutputRepositoryManager().putArtifact(ac, archive);\n        // SHA1 it if required\n        if(!ArtifactContext.isDirectoryName(ac.getSingleSuffix())) {\n            signArtifact(ac, archive);\n        }\n    }","commit_id":"9b833b236f5b3d5bc4d5f7e9fc4c89c1f557a78a","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n     * Preprocesses the list of ArtifactItems. This method defaults the\n     * outputDirectory if not set and creates the output Directory if it doesn't\n     * exist.\n     * \n     * @param removeVersion\n     *            remove the version from the filename.\n     * @return An ArrayList of preprocessed ArtifactItems\n     * \n     * @throws MojoExecutionException\n     *             with a message if an error occurs.\n     * \n     * @see ArtifactItem\n     */\n    protected ArrayList getArtifactItems( boolean removeVersion )\n        throws MojoExecutionException\n    {\n        if (artifactItems == null || artifactItems.size() < 1)\n        {\n            throw new MojoExecutionException(\"There are no artifactItems configured.\");\n        }\n        \n        Iterator iter = artifactItems.iterator();\n        while ( iter.hasNext() )\n        {\n            ArtifactItem artifactItem = (ArtifactItem) iter.next();\n            this.getLog().info( \"Configured Artifact: \" + artifactItem.toString() );\n\n            if ( artifactItem.getOutputDirectory() == null )\n            {\n                artifactItem.setOutputDirectory( this.outputDirectory );\n            }\n            artifactItem.getOutputDirectory().mkdirs();\n\n            //make sure we have a version.\n            if ( StringUtils.isEmpty( artifactItem.getVersion() ) )\n            {\n                fillMissingArtifactVersion( artifactItem );\n            }\n            \n            artifactItem.setArtifact( this.getArtifact( artifactItem ) );\n\n            // TODO:refactor this\n            String overWrite = artifactItem.getOverWrite();\n            if ( StringUtils.isEmpty( overWrite ) )\n            {\n                artifactItem.setDoOverWrite( false );\n            }\n            else\n            {\n                artifactItem.setDoOverWrite( overWrite.equalsIgnoreCase( \"true\" ) );\n            }\n\n            if ( artifactItem.getDestFileName() == null )\n            {\n                artifactItem.setDestFileName( DependencyUtil.getFormattedFileName( artifactItem.getArtifact(),\n                                                                                   removeVersion ) );\n            }\n            \n        }\n        return artifactItems;\n    }","id":23898,"modified_method":"/**\n     * Preprocesses the list of ArtifactItems. This method defaults the\n     * outputDirectory if not set and creates the output Directory if it doesn't\n     * exist.\n     * \n     * @param removeVersion\n     *            remove the version from the filename.\n     * @return An ArrayList of preprocessed ArtifactItems\n     * \n     * @throws MojoExecutionException\n     *             with a message if an error occurs.\n     * \n     * @see ArtifactItem\n     */\n    protected ArrayList getArtifactItems( boolean removeVersion )\n        throws MojoExecutionException\n    {\n        if ( artifactItems == null || artifactItems.size() < 1 )\n        {\n            throw new MojoExecutionException( \"There are no artifactItems configured.\" );\n        }\n\n        Iterator iter = artifactItems.iterator();\n        while ( iter.hasNext() )\n        {\n            ArtifactItem artifactItem = (ArtifactItem) iter.next();\n            this.getLog().info( \"Configured Artifact: \" + artifactItem.toString() );\n\n            if ( artifactItem.getOutputDirectory() == null )\n            {\n                artifactItem.setOutputDirectory( this.outputDirectory );\n            }\n            artifactItem.getOutputDirectory().mkdirs();\n\n            // make sure we have a version.\n            if ( StringUtils.isEmpty( artifactItem.getVersion() ) )\n            {\n                fillMissingArtifactVersion( artifactItem );\n            }\n\n            artifactItem.setArtifact( this.getArtifact( artifactItem ) );\n\n            if ( StringUtils.isEmpty( artifactItem.getDestFileName() ) )\n            {\n                artifactItem.setDestFileName( DependencyUtil.getFormattedFileName( artifactItem.getArtifact(),\n                                                                                   removeVersion ) );\n            }   \n            \n            artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));\n        }\n        return artifactItems;\n    }","commit_id":"a7f75e7d9c39312c69ba405962c1d89c2c493eca","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Tries to find missing version from dependancy list and dependency\n     * management. If found, the artifact is updated with the correct version.\n     * \n     * @param artifact\n     *            representing configured file.\n     * @throws MojoExecutionException\n     */\n    private void fillMissingArtifactVersion( ArtifactItem artifact )\n        throws MojoExecutionException\n    {\n        if ( !findDependencyVersion( artifact, project.getDependencies() ) )\n        {\n            if ( !findDependencyVersion( artifact, project.getDependencyManagement().getDependencies() ) )\n            {\n                throw new MojoExecutionException( \"Unable to find artifact version of \" + artifact.getGroupId() + \":\"\n                    + artifact.getArtifactId() + \" in either dependency list or in project's dependency management.\" );\n            }\n        }\n    }","id":23899,"modified_method":"/**\n     * Tries to find missing version from dependancy list and dependency\n     * management. If found, the artifact is updated with the correct version.\n     * \n     * @param artifact\n     *            representing configured file.\n     * @throws MojoExecutionException\n     */\n    private void fillMissingArtifactVersion( ArtifactItem artifact )\n        throws MojoExecutionException\n    {\n        if ( !findDependencyVersion( artifact, project.getDependencies() )\n            && !findDependencyVersion( artifact, project.getDependencyManagement().getDependencies() ) )\n        {\n            throw new MojoExecutionException( \"Unable to find artifact version of \" + artifact.getGroupId() + \":\"\n                + artifact.getArtifactId() + \" in either dependency list or in project's dependency management.\" );\n        }\n    }","commit_id":"a7f75e7d9c39312c69ba405962c1d89c2c493eca","url":"https://github.com/apache/maven-plugins"},{"original_method":"private final String filterEmptyString(String in)\n    {\n        if (in.equals(\"\"))\n        {\n            return null;\n        }\n        else\n        {\n            return in;\n        }\n    }","id":23900,"modified_method":"private final String filterEmptyString(String in)\n    {\n        if (in == null || in.equals(\"\"))\n        {\n            return null;\n        }\n        else\n        {\n            return in;\n        }\n    }","commit_id":"a7f75e7d9c39312c69ba405962c1d89c2c493eca","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Resolves the artifact from the repository and copies it to the specified\n     * location.\n     * \n     * @param artifactItem\n     *            containing the information about the Artifact to copy.\n     * @throws MojoExecutionException\n     *             with a message if an error occurs.\n     * \n     * @see DependencyUtil#copyFile(File, File, Log)\n     * @see DependencyUtil#getFormattedFileName(Artifact, boolean)\n     */\n    protected void copyArtifact( ArtifactItem artifactItem )\n        throws MojoExecutionException\n    {\n        Artifact artifact = artifactItem.getArtifact();\n\n        File destFile = new File( artifactItem.getOutputDirectory(), artifactItem.getDestFileName() );\n\n        // TODO: refactor this to use the filters.\n        if ( !artifactItem.isDoOverWrite() )\n        {\n            if ( artifactItem.getArtifact().isSnapshot() )\n            {\n                artifactItem.setDoOverWrite( this.overWriteSnapshots );\n            }\n            else\n            {\n                artifactItem.setDoOverWrite( this.overWriteReleases );\n            }\n        }\n\n        File artifactFile = artifact.getFile();\n        if ( artifactItem.isDoOverWrite()\n            || ( !destFile.exists() || ( overWriteIfNewer && artifactFile.lastModified() < destFile.lastModified() ) ) )\n        {\n            copyFile( artifactFile, destFile );\n        }\n        else\n        {\n            this.getLog().info( artifactFile + \" already exists.\" );\n        }\n    }","id":23901,"modified_method":"/**\n     * Resolves the artifact from the repository and copies it to the specified\n     * location.\n     * \n     * @param artifactItem\n     *            containing the information about the Artifact to copy.\n     * @throws MojoExecutionException\n     *             with a message if an error occurs.\n     * \n     * @see DependencyUtil#copyFile(File, File, Log)\n     * @see DependencyUtil#getFormattedFileName(Artifact, boolean)\n     */\n    protected void copyArtifact( ArtifactItem artifactItem )\n        throws MojoExecutionException\n    {\n        File destFile = new File( artifactItem.getOutputDirectory(), artifactItem.getDestFileName() );\n\n        copyFile( artifactItem.getArtifact().getFile(), destFile );\n    }","commit_id":"a7f75e7d9c39312c69ba405962c1d89c2c493eca","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Main entry into mojo. This method gets the ArtifactItems and iterates\n     * through each one passing it to copyArtifact.\n     * \n     * @throws MojoExecutionException\n     *             with a message if an error occurs.\n     * \n     * @see ArtifactItem\n     * @see #getArtifactItems\n     * @see #copyArtifact(ArtifactItem)\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        ArrayList theArtifactItems = getArtifactItems( this.stripVersion );\n        Iterator iter = theArtifactItems.iterator();\n        while ( iter.hasNext() )\n        {\n            ArtifactItem artifactItem = (ArtifactItem) iter.next();\n            copyArtifact( artifactItem);\n        }\n    }","id":23902,"modified_method":"/**\n     * Main entry into mojo. This method gets the ArtifactItems and iterates\n     * through each one passing it to copyArtifact.\n     * \n     * @throws MojoExecutionException\n     *             with a message if an error occurs.\n     * \n     * @see ArtifactItem\n     * @see #getArtifactItems\n     * @see #copyArtifact(ArtifactItem)\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        ArrayList theArtifactItems = getArtifactItems( this.stripVersion );\n        Iterator iter = theArtifactItems.iterator();\n        while ( iter.hasNext() )\n        {\n            ArtifactItem artifactItem = (ArtifactItem) iter.next();\n            if (artifactItem.isNeedsProcessing())\n            {\n                copyArtifact( artifactItem);\n            }\n            else\n            {\n                this.getLog().info(artifactItem+\" already exists in \"+ artifactItem.getOutputDirectory());\n            }\n        }\n    }","commit_id":"a7f75e7d9c39312c69ba405962c1d89c2c493eca","url":"https://github.com/apache/maven-plugins"},{"original_method":"public Set filter( Set artifacts, Log log )\r\n        throws MojoExecutionException\r\n    {\r\n        Set result = new HashSet();\r\n\r\n        Iterator iter = artifacts.iterator();\r\n        // log.debug(\"Artifacts:\"+ artifacts.size());\r\n        while ( iter.hasNext() )\r\n        {\r\n            Artifact artifact = (Artifact) iter.next();\r\n            if ( okToProcess( artifact ) )\r\n            {\r\n                result.add( artifact );\r\n            }\r\n        }\r\n        return result;\r\n    }","id":23903,"modified_method":"public Set filter( Set artifacts, Log log )\r\n        throws MojoExecutionException\r\n    {\r\n        Set result = new HashSet();\r\n\r\n        Iterator iter = artifacts.iterator();\r\n        // log.debug(\"Artifacts:\"+ artifacts.size());\r\n        while ( iter.hasNext() )\r\n        {\r\n            Artifact artifact = (Artifact) iter.next();\r\n            if (okToProcess( new ArtifactItem(artifact) ) )\r\n            {\r\n                result.add( artifact );\r\n            }\r\n        }\r\n        return result;\r\n    }","commit_id":"a7f75e7d9c39312c69ba405962c1d89c2c493eca","url":"https://github.com/apache/maven-plugins"},{"original_method":"public boolean okToProcess( Artifact artifact )\r\n        throws MojoExecutionException\r\n    {\r\n        boolean overWrite = false;\r\n        boolean result = false;\r\n        if ( ( artifact.isSnapshot() && this.overWriteSnapshots )\r\n            || ( !artifact.isSnapshot() && this.overWriteReleases ) )\r\n        {\r\n            overWrite = true;\r\n        }\r\n\r\n        File destFolder = DependencyUtil.getFormattedOutputDirectory( this.useSubDirectoryPerType,\r\n                                                                      this.useSubDirectoryPerArtifact,\r\n                                                                      this.outputFileDirectory, artifact );\r\n        File destFile = new File( destFolder, DependencyUtil.getFormattedFileName( artifact, this.removeVersion ) );\r\n\r\n        if ( overWrite\r\n            || ( !destFile.exists() || ( overWriteIfNewer && artifact.getFile().lastModified() < destFile\r\n                .lastModified() ) ) )\r\n        {\r\n            result = true;\r\n        }\r\n\r\n        return result;\r\n    }","id":23904,"modified_method":"public boolean okToProcess( ArtifactItem item )\r\n    {\r\n        boolean overWrite = false;\r\n        boolean result = false;\r\n        Artifact artifact = item.getArtifact();\r\n        \r\n        if ( ( artifact.isSnapshot() && this.overWriteSnapshots )\r\n            || ( !artifact.isSnapshot() && this.overWriteReleases ) )\r\n        {\r\n            overWrite = true;\r\n        }\r\n\r\n        File destFolder = item.getOutputDirectory();\r\n        if ( destFolder == null )\r\n        {\r\n            destFolder = DependencyUtil.getFormattedOutputDirectory( this.useSubDirectoryPerType, this.useSubDirectoryPerArtifact,\r\n                                                        this.outputFileDirectory, artifact );\r\n        }\r\n        \r\n        File destFile = null;\r\n        if (StringUtils.isEmpty(item.getDestFileName()))\r\n        {\r\n            destFile = new File( destFolder, DependencyUtil.getFormattedFileName( artifact, this.removeVersion ) );\r\n        }\r\n        else\r\n        {\r\n            destFile = new File (destFolder,item.getDestFileName());\r\n        }   \r\n     \r\n        if ( overWrite\r\n            || ( !destFile.exists() || ( overWriteIfNewer && artifact.getFile().lastModified() > destFile\r\n                .lastModified() ) ) )\r\n        {\r\n            result = true;\r\n        }\r\n        return result;\r\n    }","commit_id":"a7f75e7d9c39312c69ba405962c1d89c2c493eca","url":"https://github.com/apache/maven-plugins"},{"original_method":"public Set filter( Set artifacts, Log log )\n        throws MojoExecutionException\n    {\n        Set result = new HashSet();\n\n        Iterator iter = artifacts.iterator();\n        // log.debug(\"Artifacts:\"+ artifacts.size());\n        while ( iter.hasNext() )\n        {\n            Artifact artifact = (Artifact) iter.next();\n            if ( okToProcess( artifact ) )\n            {\n                result.add( artifact );\n            }\n        }\n        return result;\n    }","id":23905,"modified_method":"public Set filter( Set artifacts, Log log )\n        throws MojoExecutionException\n    {\n        Set result = new HashSet();\n\n        Iterator iter = artifacts.iterator();\n        // log.debug(\"Artifacts:\"+ artifacts.size());\n        while ( iter.hasNext() )\n        {\n            Artifact artifact = (Artifact) iter.next();\n            if ( doOverwrite( artifact ) )\n            {\n                result.add( artifact );\n            }\n        }\n        return result;\n    }","commit_id":"a7f75e7d9c39312c69ba405962c1d89c2c493eca","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Main entry into mojo. This method gets the ArtifactItems and iterates\n     * through each one passing it to unpackArtifact.\n     * \n     * @throws MojoExecutionException\n     *             with a message if an error occurs.\n     * \n     * @see ArtifactItem\n     * @see #getArtifactItems\n     * @see #unpackArtifact(ArtifactItem)\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        ArrayList artifactItems = getArtifactItems(false);\n        Iterator iter = artifactItems.iterator();\n        while ( iter.hasNext() )\n        {\n            ArtifactItem artifactItem = (ArtifactItem) iter.next();\n            unpackArtifact( artifactItem );\n        }\n    }","id":23906,"modified_method":"/**\n     * Main entry into mojo. This method gets the ArtifactItems and iterates\n     * through each one passing it to unpackArtifact.\n     * \n     * @throws MojoExecutionException\n     *             with a message if an error occurs.\n     * \n     * @see ArtifactItem\n     * @see #getArtifactItems\n     * @see #unpackArtifact(ArtifactItem)\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        ArrayList artifactItems = getArtifactItems( false );\n        Iterator iter = artifactItems.iterator();\n        while ( iter.hasNext() )\n        {\n            ArtifactItem artifactItem = (ArtifactItem) iter.next();\n            if (artifactItem.isNeedsProcessing())\n            {\n            unpackArtifact( artifactItem );\n            }\n            else\n            {\n                this.getLog().info( artifactItem.getArtifact().getFile().getName() + \" already unpacked.\" );\n            }\n        }\n    }","commit_id":"a7f75e7d9c39312c69ba405962c1d89c2c493eca","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * This method gets the Artifact object and calls DependencyUtil.unpackFile.\n     * \n     * @param artifactItem\n     *            containing the information about the Artifact to unpack.\n     * \n     * @throws MojoExecutionException\n     *             with a message if an error occurs.\n     * \n     * @see #getArtifact\n     * @see DependencyUtil#unpackFile(Artifact, File, File, ArchiverManager,\n     *      Log)\n     */\n    private void unpackArtifact( ArtifactItem artifactItem )\n        throws MojoExecutionException\n    {\n        Artifact artifact = artifactItem.getArtifact();\n\n        MarkerHandler handler = new DefaultFileMarkerHandler( artifact, this.markersDirectory );\n        MarkerFileFilter filter = new MarkerFileFilter( this.overWriteReleases, this.overWriteSnapshots,\n                                                        this.overWriteIfNewer, handler );\n\n        if (artifactItem.isDoOverWrite() || filter.okToProcess(artifact))\n        {\n            unpack(artifact.getFile(),artifactItem.getOutputDirectory());\n            handler.setMarker();\n        }\n        else\n        {\n            this.getLog().info( artifact.getFile().getName() + \" already unpacked.\" );\n        }\n    }","id":23907,"modified_method":"/**\n     * This method gets the Artifact object and calls DependencyUtil.unpackFile.\n     * \n     * @param artifactItem\n     *            containing the information about the Artifact to unpack.\n     * \n     * @throws MojoExecutionException\n     *             with a message if an error occurs.\n     * \n     * @see #getArtifact\n     * @see DependencyUtil#unpackFile(Artifact, File, File, ArchiverManager,\n     *      Log)\n     */\n    private void unpackArtifact( ArtifactItem artifactItem )\n        throws MojoExecutionException\n    {\n        Artifact artifact = artifactItem.getArtifact();\n\n        MarkerHandler handler = new DefaultFileMarkerHandler( artifact, this.markersDirectory );\n\n        unpack( artifact.getFile(), artifactItem.getOutputDirectory() );\n        handler.setMarker();\n\n    }","commit_id":"a7f75e7d9c39312c69ba405962c1d89c2c493eca","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void saveInitialCheckBoxState(boolean state) {\n    PropertiesComponent propertiesComponent = PropertiesComponent.getInstance(myProject);\n    propertiesComponent.setValue(\"GoToAction.allIncluded\", Boolean.toString(state));\n  }","id":23908,"modified_method":"public void saveInitialCheckBoxState(boolean state) {\n    PropertiesComponent propertiesComponent = PropertiesComponent.getInstance(myProject);\n    if (Boolean.TRUE.toString().equals(propertiesComponent.getValue(\"GoToAction.toSaveAllIncluded\"))) {\n      propertiesComponent.setValue(\"GoToAction.allIncluded\", Boolean.toString(state));\n    }\n  }","commit_id":"cc332d65296b9833a75e5911aac4252b660dea9c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean loadInitialCheckBoxState() {\n    PropertiesComponent propertiesComponent = PropertiesComponent.getInstance(myProject);\n    return propertiesComponent.isTrueValue(\"GoToAction.allIncluded\");\n  }","id":23909,"modified_method":"public boolean loadInitialCheckBoxState() {\n    PropertiesComponent propertiesComponent = PropertiesComponent.getInstance(myProject);\n    return Boolean.TRUE.toString().equals(propertiesComponent.getValue(\"GoToAction.toSaveAllIncluded\")) &&\n           propertiesComponent.isTrueValue(\"GoToAction.allIncluded\");\n  }","commit_id":"cc332d65296b9833a75e5911aac4252b660dea9c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void saveInitialCheckBoxState(boolean state) {\n    PropertiesComponent propertiesComponent = PropertiesComponent.getInstance(myProject);\n    propertiesComponent.setValue(\"GoToFile.includeJavaFiles\", Boolean.toString(state));\n  }","id":23910,"modified_method":"@Override\n  public void saveInitialCheckBoxState(boolean state) {\n    PropertiesComponent propertiesComponent = PropertiesComponent.getInstance(myProject);\n    if (propertiesComponent.isTrueValue(\"GoToClass.toSaveIncludeLibraries\")) {\n      propertiesComponent.setValue(\"GoToFile.includeJavaFiles\", Boolean.toString(state));\n    }\n  }","commit_id":"7cf6caad2f6b21e791faa6e242f4660fd46d21d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean loadInitialCheckBoxState() {\n    PropertiesComponent propertiesComponent = PropertiesComponent.getInstance(myProject);\n    return propertiesComponent.isTrueValue(\"GoToFile.includeJavaFiles\");\n  }","id":23911,"modified_method":"@Override\n  public boolean loadInitialCheckBoxState() {\n    PropertiesComponent propertiesComponent = PropertiesComponent.getInstance(myProject);\n    return propertiesComponent.isTrueValue(\"GoToClass.toSaveIncludeLibraries\") &&\n           propertiesComponent.isTrueValue(\"GoToFile.includeJavaFiles\");\n  }","commit_id":"7cf6caad2f6b21e791faa6e242f4660fd46d21d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean loadInitialCheckBoxState() {\n    return getPropertiesStorage().isTrueValue(\"GoToAction.allIncluded\");\n  }","id":23912,"modified_method":"public boolean loadInitialCheckBoxState() {\n    PropertiesComponent propertiesComponent = getPropertiesStorage();\n    return Boolean.TRUE.toString().equals(propertiesComponent.getValue(\"GoToAction.toSaveAllIncluded\")) &&\n           propertiesComponent.isTrueValue(\"GoToAction.allIncluded\");\n  }","commit_id":"a0860fbc954bb7cb3ab8c5f9bf5c84e68bb6a70b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void saveInitialCheckBoxState(boolean state) {\n    getPropertiesStorage().setValue(\"GoToAction.allIncluded\", Boolean.toString(state));\n  }","id":23913,"modified_method":"public void saveInitialCheckBoxState(boolean state) {\n    PropertiesComponent propertiesComponent = getPropertiesStorage();\n    if (Boolean.TRUE.toString().equals(propertiesComponent.getValue(\"GoToAction.toSaveAllIncluded\"))) {\n      propertiesComponent.setValue(\"GoToAction.allIncluded\", Boolean.toString(state));\n    }\n  }","commit_id":"a0860fbc954bb7cb3ab8c5f9bf5c84e68bb6a70b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doPaintDecorated(Graphics2D g) {\n    Icon icon = myIcon;\n    final Color bg = getBackground();\n    g.setPaint(bg);\n    int w = getWidth();\n    int h = getHeight();\n    if (!UIUtil.isUnderAquaLookAndFeel() || myPanel.isInFloatingMode() || (isSelected() && myPanel.hasFocus())) {\n      g.fillRect(0, 0, w - (isLastElement() || !UIUtil.isUnderAquaLookAndFeel() ? 0 : getDecorationOffset()), h);\n    }\n    final int offset = isFirstElement() ? getFirstElementLeftOffset() : 0;\n    final int iconOffset = myPadding.left + offset;\n    icon.paintIcon(this, g, iconOffset, (h - icon.getIconHeight()) / 2);\n    final int textOffset = icon.getIconWidth() + myPadding.width() + offset;    \n    int x = doPaintText(g, textOffset, false);\n    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    \n    g.translate(x, 0);\n    Path2D.Double path;\n    int off = getDecorationOffset();\n    if (isFocused()) {\n      if (isSelected() && !isLastElement()) {\n        path = new Path2D.Double();\n        g.translate(1, 0);\n        path.moveTo(0, 0);\n        path.lineTo(off, h / 2);              // |\\\n        path.lineTo(0, h);                    // |/\n        path.lineTo(0, 0);\n        g.setColor(UIUtil.getListSelectionBackground());\n        g.fill(path);\n        g.translate(-1, 0);\n      }\n\n      if (!UIUtil.isUnderAquaLookAndFeel() || myPanel.isInFloatingMode() || isNextSelected()) {\n        if (! isLastElement()) {\n          path = new Path2D.Double();\n          path.moveTo(0, 0);\n          path.lineTo(off, h / 2);                // ___\n          path.lineTo(0, h);                      // \\ |\n          path.lineTo(off + 2, h);                // /_|\n          path.lineTo(off + 2, 0);\n          path.lineTo(0, 0);\n          g.setColor(isNextSelected() ? UIUtil.getListSelectionBackground() : UIUtil.getListBackground());\n          //if (UIUtil.isUnderAquaLookAndFeel() && isNextSelected() || !UIUtil.isUnderAquaLookAndFeel()) {\n            g.fill(path);\n          //}\n        }\n      }\n    }\n    if (! isLastElement() && ((!isSelected() && !isNextSelected()) || !myPanel.hasFocus())) {\n      Image img;\n      if (UIUtil.isUnderAquaLookAndFeel()) {\n        //img = myPanel.isInFloatingMode() ? SEPARATOR_PASSIVE : SEPARATOR_ACTIVE;\n        img = SEPARATOR_PASSIVE;\n      } else {\n        img = myPanel.isInFloatingMode() && isFocused() ? SEPARATOR_ACTIVE : SEPARATOR_PASSIVE;\n      }\n      g.drawImage(img, null, null);\n    }\n  }","id":23914,"modified_method":"private void doPaintDecorated(Graphics2D g) {\n    Icon icon = myIcon;\n    final Color bg = isSelected() && isFocused()\n                      ? UIUtil.getListSelectionBackground()\n                      : (UIUtil.isUnderGTKLookAndFeel() ? Color.WHITE : UIUtil.getListBackground());\n    final Color c = UIUtil.getListSelectionBackground();\n    final Color selBg = new Color(c.getRed(), c.getGreen(), c.getBlue(), getAlpha());\n    int w = getWidth();\n    int h = getHeight();\n    if (!UIUtil.isUnderAquaLookAndFeel() || myPanel.isInFloatingMode() || (isSelected() && myPanel.hasFocus())) {\n      g.setPaint(isSelected() && isFocused() ? selBg : bg);\n      g.fillRect(0, 0, w - (isLastElement() /*|| !UIUtil.isUnderAquaLookAndFeel()*/ ? 0 : getDecorationOffset()), h);\n    }\n    final int offset = isFirstElement() ? getFirstElementLeftOffset() : 0;\n    final int iconOffset = myPadding.left + offset;\n    icon.paintIcon(this, g, iconOffset, (h - icon.getIconHeight()) / 2);\n    final int textOffset = icon.getIconWidth() + myPadding.width() + offset;    \n    int x = doPaintText(g, textOffset, false);\n    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    \n    g.translate(x, 0);\n    Path2D.Double path;\n    int off = getDecorationOffset();\n    if (isFocused()) {\n      if (isSelected() && !isLastElement()) {\n        path = new Path2D.Double();\n        g.translate(2, 0);\n        path.moveTo(0, 0);\n        path.lineTo(off, h / 2);              // |\\\n        path.lineTo(0, h);                    // |/\n        path.lineTo(0, 0);\n        g.setColor(selBg);\n        g.fill(path);\n        g.translate(-2, 0);\n      }\n\n      if (!UIUtil.isUnderAquaLookAndFeel() || myPanel.isInFloatingMode() || isNextSelected()) {\n        if (! isLastElement()) {\n          path = new Path2D.Double();\n          path.moveTo(0, 0);\n          path.lineTo(off, h / 2);                // ___\n          path.lineTo(0, h);                      // \\ |\n          path.lineTo(off + 2, h);                // /_|\n          path.lineTo(off + 2, 0);\n          path.lineTo(0, 0);\n          g.setColor(isNextSelected() ? selBg : UIUtil.getListBackground());\n          //if (UIUtil.isUnderAquaLookAndFeel() && isNextSelected() || !UIUtil.isUnderAquaLookAndFeel()) {\n            g.fill(path);\n          //}\n        }\n      }\n    }\n    if (! isLastElement() && ((!isSelected() && !isNextSelected()) || !myPanel.hasFocus())) {\n      Image img;\n      //if (UIUtil.isUnderAquaLookAndFeel()) {\n      //  //img = myPanel.isInFloatingMode() ? SEPARATOR_PASSIVE : SEPARATOR_ACTIVE;\n      //  img = SEPARATOR_PASSIVE;\n      //} else {\n      //  img = myPanel.isInFloatingMode() && isFocused() ? SEPARATOR_ACTIVE : SEPARATOR_PASSIVE;\n      //}\n      g.drawImage(SEPARATOR_PASSIVE, null, null);\n    }\n  }","commit_id":"928a31f49a6dff131426fb022cc6b09ad9a44c73","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Component getTableCellRendererComponent(JTable list, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n    if (!(value instanceof UsageNode)) {\n      return new JLabel(\"<html><body><b>\" + value + \"<\/b><\/body><\/html>\", SwingConstants.CENTER);\n    }\n    UsageNode usageNode = (UsageNode)value;\n\n    GroupNode parent = (GroupNode)usageNode.getParent();\n    SimpleColoredComponent textChunks = new SimpleColoredComponent();\n    textChunks.setIpad(new Insets(0,0,0,0));\n    textChunks.setBorder(null);\n    Usage usage = usageNode.getUsage();\n\n    Color fileBgColor = getBackgroundColor(isSelected, usage);\n\n    JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0,0));\n    panel.setBackground(isSelected ? UIUtil.getListSelectionBackground() : fileBgColor == null ? list.getBackground() : fileBgColor);\n    panel.setForeground(isSelected ? UIUtil.getListSelectionForeground() : list.getForeground());\n\n    if (column == 0) {\n      appendGroupText(parent, panel, fileBgColor);\n      if (usage == NullUsage.INSTANCE) {\n          textChunks.append(\"...<\");\n          textChunks.append(\"more usages\", SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES);\n          textChunks.append(\">...\");\n      }\n    }\n    else if (usage != NullUsage.INSTANCE) {\n      UsagePresentation presentation = usage.getPresentation();\n      TextChunk[] text = presentation.getText();\n\n      if (column == 1) {\n        textChunks.setIcon(presentation.getIcon());\n        if (text.length != 0) {\n          SimpleTextAttributes attributes =\n            deriveAttributesWithColor(SimpleTextAttributes.fromTextAttributes(text[0].getAttributes()), fileBgColor);\n          textChunks.append(text[0].getText(), attributes);\n        }\n      }\n      else if (column == 2) {\n        for (int i = 1; i < text.length; i++) {\n          TextChunk textChunk = text[i];\n          final SimpleTextAttributes attrs = SimpleTextAttributes.fromTextAttributes(textChunk.getAttributes());\n          final Color selectedColor = attrs.getStyle() == SimpleTextAttributes.STYLE_BOLD ? Color.WHITE : Color.GRAY;\n          SimpleTextAttributes attributes = isSelected ?\n            new SimpleTextAttributes(UIUtil.getListSelectionBackground(), selectedColor, selectedColor, attrs.getStyle())\n            : deriveAttributesWithColor(attrs, fileBgColor);\n          textChunks.append(textChunk.getText(), attributes);\n        }\n      }\n      else {\n        assert false : column;\n      }\n    }\n    panel.add(textChunks);\n    return panel;\n  }","id":23915,"modified_method":"public Component getTableCellRendererComponent(JTable list, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n    if (!(value instanceof UsageNode)) {\n      return new JLabel(\"<html><body><b>\" + value + \"<\/b><\/body><\/html>\", SwingConstants.CENTER);\n    }\n    UsageNode usageNode = (UsageNode)value;\n\n    GroupNode parent = (GroupNode)usageNode.getParent();\n    SimpleColoredComponent textChunks = new SimpleColoredComponent();\n    textChunks.setIpad(new Insets(0,0,0,0));\n    textChunks.setBorder(null);\n    Usage usage = usageNode.getUsage();\n\n    Color fileBgColor = getBackgroundColor(isSelected, usage);\n\n    JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0,0));\n    panel.setBackground(isSelected ? UIUtil.getListSelectionBackground() : fileBgColor == null ? list.getBackground() : fileBgColor);\n    panel.setForeground(isSelected ? UIUtil.getListSelectionForeground() : list.getForeground());\n\n    if (column == 0) {\n      appendGroupText(parent, panel, fileBgColor);\n      if (usage == NullUsage.INSTANCE) {\n          textChunks.append(\"...<\");\n          textChunks.append(\"more usages\", SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES);\n          textChunks.append(\">...\");\n      }\n    }\n    else if (usage != NullUsage.INSTANCE) {\n      UsagePresentation presentation = usage.getPresentation();\n      TextChunk[] text = presentation.getText();\n\n      if (column == 1) {\n        textChunks.setIcon(presentation.getIcon());\n        if (text.length != 0) {\n          SimpleTextAttributes attributes =\n            deriveAttributesWithColor(SimpleTextAttributes.fromTextAttributes(text[0].getAttributes()), fileBgColor);\n          textChunks.append(text[0].getText(), attributes);\n        }\n      }\n      else if (column == 2) {\n        for (int i = 1; i < text.length; i++) {\n          TextChunk textChunk = text[i];\n          final SimpleTextAttributes attrs = SimpleTextAttributes.fromTextAttributes(textChunk.getAttributes());\n          final Color bg = UIUtil.getListSelectionBackground();\n          final Color fg = UIUtil.getListSelectionForeground();\n          SimpleTextAttributes attributes = isSelected ?\n            new SimpleTextAttributes(bg, fg, fg, attrs.getStyle()) : deriveAttributesWithColor(attrs, fileBgColor);\n          textChunks.append(textChunk.getText(), attributes);\n        }\n      }\n      else {\n        assert false : column;\n      }\n    }\n    panel.add(textChunks);\n    return panel;\n  }","commit_id":"9f572e4a565bdf5a83d553be1a314da8989fc714","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * @see org.opencms.search.CmsSearchIndex#getDocumentFactory(org.opencms.file.CmsResource)\n     */\n    @Override\n    public I_CmsDocumentFactory getDocumentFactory(CmsResource res) {\n\n        if ((res != null) && (m_sources != null)) {\n            // the result can only be null or the type configured for the resource\n            if (CmsResourceTypeXmlContent.isXmlContent(res)) {\n                return OpenCms.getSearchManager().getDocumentFactory(TYPE_XMLCONTENT_GALLERIES, null);\n            } else if (CmsResourceTypeXmlPage.isXmlPage(res)) {\n                return OpenCms.getSearchManager().getDocumentFactory(TYPE_XMLPAGE_GALLERIES, null);\n            } else {\n                return super.getDocumentFactory(res);\n            }\n        }\n        return null;\n    }","id":23916,"modified_method":"/**\n     * @see org.opencms.search.CmsSearchIndex#getDocumentFactory(org.opencms.file.CmsResource)\n     */\n    @Override\n    public I_CmsDocumentFactory getDocumentFactory(CmsResource res) {\n\n        if ((res != null) && (m_sources != null)) {\n            // the result can only be null or the type configured for the resource\n            if (CmsResourceTypeXmlContent.isXmlContent(res) || CmsResourceTypeXmlContainerPage.isContainerPage(res)) {\n                return OpenCms.getSearchManager().getDocumentFactory(TYPE_XMLCONTENT_GALLERIES, null);\n            } else if (CmsResourceTypeXmlPage.isXmlPage(res)) {\n                return OpenCms.getSearchManager().getDocumentFactory(TYPE_XMLPAGE_GALLERIES, null);\n            } else {\n                return super.getDocumentFactory(res);\n            }\n        }\n        return null;\n    }","commit_id":"7483ad49b468ae6d781e17f4177d4e74c36401e3","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n         * @see org.opencms.ade.publish.client.CmsPublishDataModel.I_CmsPublishResourceCheck#check(org.opencms.ade.publish.shared.CmsPublishResource)\n         */\n        public boolean check(CmsPublishResource res) {\n\n            boolean result = res.getInfo() != null;\n            return result;\n        }","id":23917,"modified_method":"/**\n         * @see org.opencms.ade.publish.client.CmsPublishDataModel.I_CmsPublishResourceCheck#check(org.opencms.ade.publish.shared.CmsPublishResource)\n         */\n        public boolean check(CmsPublishResource res) {\n\n            return hasProblems(res);\n        }","commit_id":"aed14b84f75ab135d8764a1a975551b6027ad091","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates and initializes a new publish resource data model from a list of publish groups.<p>\n     *  \n     * @param publishGroups the original publish groups \n     * @param handler the handler which should be notified of state changes \n     */\n    public CmsPublishDataModel(List<CmsPublishGroup> publishGroups, I_CmsPublishItemStatusUpdateHandler handler) {\n\n        m_groups = publishGroups;\n        for (CmsPublishGroup group : publishGroups) {\n            List<CmsUUID> idList = new ArrayList<CmsUUID>();\n            m_idsByGroup.add(idList);\n            for (CmsPublishResource res : group.getResources()) {\n                CmsPublishItemStatus status = new CmsPublishItemStatus(\n                    res.getId(),\n                    State.normal,\n                    res.getInfo() != null,\n                    handler);\n                m_status.put(res.getId(), status);\n                m_publishResources.put(res.getId(), res);\n                m_publishResourcesByPath.put(res.getName(), res);\n                idList.add(res.getId());\n            }\n        }\n    }","id":23918,"modified_method":"/**\n     * Creates and initializes a new publish resource data model from a list of publish groups.<p>\n     *  \n     * @param publishGroups the original publish groups \n     * @param handler the handler which should be notified of state changes \n     */\n    public CmsPublishDataModel(List<CmsPublishGroup> publishGroups, I_CmsPublishItemStatusUpdateHandler handler) {\n\n        m_groups = publishGroups;\n        for (CmsPublishGroup group : publishGroups) {\n            List<CmsUUID> idList = new ArrayList<CmsUUID>();\n            m_idsByGroup.add(idList);\n            for (CmsPublishResource res : group.getResources()) {\n                CmsPublishItemStatus status = new CmsPublishItemStatus(\n                    res.getId(),\n                    State.normal,\n                    hasProblems(res),\n                    handler);\n                m_status.put(res.getId(), status);\n                m_publishResources.put(res.getId(), res);\n                m_publishResourcesByPath.put(res.getName(), res);\n                idList.add(res.getId());\n            }\n        }\n    }","commit_id":"aed14b84f75ab135d8764a1a975551b6027ad091","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Adds the list item for the next publish resource and returns  true on success, while\n     * also incrementing the internal item index.<p>\n     * \n     * @return true if an item was added\n     */\n    public boolean addNextItem() {\n\n        if (m_itemIndex >= m_publishResources.size()) {\n            return false;\n        }\n        CmsPublishResource res = m_publishResources.get(m_itemIndex);\n        m_itemIndex += 1;\n        if ((res.getInfo() == null) && m_showProblemsOnly) {\n            return false;\n        } else {\n            addItem(res);\n            return true;\n        }\n    }","id":23919,"modified_method":"/**\n     * Adds the list item for the next publish resource and returns  true on success, while\n     * also incrementing the internal item index.<p>\n     * \n     * @return true if an item was added\n     */\n    public boolean addNextItem() {\n\n        if (m_itemIndex >= m_publishResources.size()) {\n            return false;\n        }\n        CmsPublishResource res = m_publishResources.get(m_itemIndex);\n        m_itemIndex += 1;\n        if (m_showProblemsOnly && (!CmsPublishDataModel.hasProblems(res))) {\n            return false;\n        } else {\n            addItem(res);\n            return true;\n        }\n    }","commit_id":"aed14b84f75ab135d8764a1a975551b6027ad091","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a widget from resource bean data.<p>\n     * \n     * @param resourceBean the resource bean for which a widget should be constructed\n     * @param status the publish item status\n     * @param isSubItem true if this is not a top-level publish item  \n     * \n     * @return a widget representing the resource bean\n     */\n    private CmsTreeItem buildItem(final CmsPublishResource resourceBean, CmsPublishItemStatus status, boolean isSubItem) {\n\n        CmsListItemWidget itemWidget = createListItemWidget(resourceBean);\n        final CmsStyleVariable styleVar = new CmsStyleVariable(itemWidget);\n        styleVar.setValue(CSS.itemToKeep());\n\n        final CmsCheckBox checkbox = new CmsCheckBox();\n        CmsTreeItem row;\n        row = new CmsTreeItem(false, checkbox, itemWidget);\n        if (isSubItem) {\n            checkbox.getElement().getStyle().setVisibility(Visibility.HIDDEN);\n        }\n\n        row.setOpen(true);\n        row.addStyleName(CSS.publishRow());\n\n        // we do not need most of the interactive elements for the sub-items \n        if (!isSubItem) {\n            ClickHandler checkboxHandler = new ClickHandler() {\n\n                /**\n                 * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n                 */\n                public void onClick(ClickEvent event) {\n\n                    boolean checked = checkbox.isChecked();\n                    m_model.signal(checked ? Signal.publish : Signal.unpublish, resourceBean.getId());\n                    m_selectionChangeHandler.onChangePublishSelection();\n                }\n            };\n            checkbox.addClickHandler(checkboxHandler);\n\n            final boolean hasProblem = (resourceBean.getInfo() != null);\n            if (hasProblem) {\n                // can't select resource with problems\n                checkbox.setChecked(false);\n                checkbox.setEnabled(false);\n            }\n\n            final CmsCheckBox remover = new CmsCheckBox();\n            final CmsPublishItemSelectionController controller = new CmsPublishItemSelectionController(\n                resourceBean.getId(),\n                checkbox,\n                remover,\n                styleVar,\n                hasProblem);\n            m_controllersById.put(resourceBean.getId(), controller);\n\n            remover.setTitle(Messages.get().key(Messages.GUI_PUBLISH_REMOVE_BUTTON_0));\n            remover.addClickHandler(new ClickHandler() {\n\n                /**\n                 * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n                 */\n                public void onClick(ClickEvent e) {\n\n                    boolean remove = remover.isChecked();\n                    m_model.signal(remove ? Signal.remove : Signal.unremove, resourceBean.getId());\n                    m_selectionChangeHandler.onChangePublishSelection();\n                }\n            });\n            itemWidget.addButtonToFront(remover);\n\n            controller.update(status);\n        }\n        return row;\n    }","id":23920,"modified_method":"/**\n     * Creates a widget from resource bean data.<p>\n     * \n     * @param resourceBean the resource bean for which a widget should be constructed\n     * @param status the publish item status\n     * @param isSubItem true if this is not a top-level publish item  \n     * \n     * @return a widget representing the resource bean\n     */\n    private CmsTreeItem buildItem(final CmsPublishResource resourceBean, CmsPublishItemStatus status, boolean isSubItem) {\n\n        CmsListItemWidget itemWidget = createListItemWidget(resourceBean);\n        final CmsStyleVariable styleVar = new CmsStyleVariable(itemWidget);\n        styleVar.setValue(CSS.itemToKeep());\n\n        final CmsCheckBox checkbox = new CmsCheckBox();\n        CmsTreeItem row;\n        row = new CmsTreeItem(false, checkbox, itemWidget);\n        if (isSubItem) {\n            checkbox.getElement().getStyle().setVisibility(Visibility.HIDDEN);\n        }\n\n        row.setOpen(true);\n        row.addStyleName(CSS.publishRow());\n\n        // we do not need most of the interactive elements for the sub-items \n        if (!isSubItem) {\n            ClickHandler checkboxHandler = new ClickHandler() {\n\n                /**\n                 * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n                 */\n                public void onClick(ClickEvent event) {\n\n                    boolean checked = checkbox.isChecked();\n                    m_model.signal(checked ? Signal.publish : Signal.unpublish, resourceBean.getId());\n                    m_selectionChangeHandler.onChangePublishSelection();\n                }\n            };\n            checkbox.addClickHandler(checkboxHandler);\n\n            final boolean hasProblem = CmsPublishDataModel.hasProblems(resourceBean);\n            if (hasProblem) {\n                // can't select resource with problems\n                checkbox.setChecked(false);\n                checkbox.setEnabled(false);\n            }\n\n            final CmsCheckBox remover = new CmsCheckBox();\n            final CmsPublishItemSelectionController controller = new CmsPublishItemSelectionController(\n                resourceBean.getId(),\n                checkbox,\n                remover,\n                styleVar,\n                hasProblem);\n            m_controllersById.put(resourceBean.getId(), controller);\n\n            remover.setTitle(Messages.get().key(Messages.GUI_PUBLISH_REMOVE_BUTTON_0));\n            remover.addClickHandler(new ClickHandler() {\n\n                /**\n                 * @see com.google.gwt.event.dom.client.ClickHandler#onClick(com.google.gwt.event.dom.client.ClickEvent)\n                 */\n                public void onClick(ClickEvent e) {\n\n                    boolean remove = remover.isChecked();\n                    m_model.signal(remove ? Signal.remove : Signal.unremove, resourceBean.getId());\n                    m_selectionChangeHandler.onChangePublishSelection();\n                }\n            });\n            itemWidget.addButtonToFront(remover);\n\n            controller.update(status);\n        }\n        return row;\n    }","commit_id":"aed14b84f75ab135d8764a1a975551b6027ad091","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a basic list item widget for a given publish resource bean.<p>\n     * \n     * @param resourceBean the publish resource bean\n     * \n     * @return the list item widget representing the publish resource bean \n     */\n    public static CmsListItemWidget createListItemWidget(final CmsPublishResource resourceBean) {\n\n        CmsListInfoBean info = new CmsListInfoBean();\n        info.setTitle(getTitle(resourceBean));\n        info.setSubTitle(resourceBean.getName());\n        String stateLabel = org.opencms.gwt.client.Messages.get().key(\n            org.opencms.gwt.client.Messages.GUI_RESOURCE_STATE_0);\n        String stateName = CmsResourceStateUtil.getStateName(resourceBean.getState());\n        // this can be null for the source resources of broken relations in the 'broken links' \n        // panel since these resources don't have to be new or deleted or changed\n        if (stateName != null) {\n            info.addAdditionalInfo(stateLabel, stateName, CmsResourceStateUtil.getStateStyle(resourceBean.getState()));\n        }\n        CmsListItemWidget itemWidget = new CmsListItemWidget(info);\n        if (resourceBean.getInfo() != null) {\n            Image warningImage = new Image(I_CmsImageBundle.INSTANCE.warningSmallImage());\n            warningImage.setTitle(resourceBean.getInfo().getValue());\n            warningImage.addStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().permaVisible());\n            itemWidget.addButton(warningImage);\n        }\n        if (!resourceBean.isFolder()) {\n            CmsPushButton previewButton = new CmsPushButton();\n            previewButton.setImageClass(I_CmsImageBundle.INSTANCE.style().searchIcon());\n            previewButton.setButtonStyle(ButtonStyle.TRANSPARENT, null);\n            previewButton.addClickHandler(new ClickHandler() {\n\n                public void onClick(ClickEvent event) {\n\n                    CmsPushButton button = (CmsPushButton)event.getSource();\n                    CmsDomUtil.ensureMouseOut(button.getElement());\n                    CmsPreviewDialog.showPreviewForResource(resourceBean.getId());\n                }\n            });\n            itemWidget.addButton(previewButton);\n        }\n        itemWidget.setIcon(CmsIconUtil.getResourceIconClasses(resourceBean.getResourceType(), false));\n        return itemWidget;\n    }","id":23921,"modified_method":"/**\n     * Creates a basic list item widget for a given publish resource bean.<p>\n     * \n     * @param resourceBean the publish resource bean\n     * \n     * @return the list item widget representing the publish resource bean \n     */\n    public static CmsListItemWidget createListItemWidget(final CmsPublishResource resourceBean) {\n\n        CmsListInfoBean info = new CmsListInfoBean();\n        info.setTitle(getTitle(resourceBean));\n        info.setSubTitle(resourceBean.getName());\n        String stateLabel = org.opencms.gwt.client.Messages.get().key(\n            org.opencms.gwt.client.Messages.GUI_RESOURCE_STATE_0);\n        String stateName = CmsResourceStateUtil.getStateName(resourceBean.getState());\n        // this can be null for the source resources of broken relations in the 'broken links' \n        // panel since these resources don't have to be new or deleted or changed\n        if (stateName != null) {\n            info.addAdditionalInfo(stateLabel, stateName, CmsResourceStateUtil.getStateStyle(resourceBean.getState()));\n        }\n        CmsListItemWidget itemWidget = new CmsListItemWidget(info);\n        if (CmsPublishDataModel.hasProblems(resourceBean)) {\n            Image warningImage = new Image(I_CmsImageBundle.INSTANCE.warningSmallImage());\n            warningImage.setTitle(resourceBean.getInfo().getValue());\n            warningImage.addStyleName(I_CmsLayoutBundle.INSTANCE.listItemWidgetCss().permaVisible());\n            itemWidget.addButton(warningImage);\n        }\n        String noPreviewReason = resourceBean.getInfo() == null ? null : resourceBean.getInfo().getNoPreviewReason();\n        CmsPushButton previewButton = new CmsPushButton();\n        previewButton.setImageClass(I_CmsImageBundle.INSTANCE.style().searchIcon());\n        previewButton.setButtonStyle(ButtonStyle.TRANSPARENT, null);\n        previewButton.addClickHandler(new ClickHandler() {\n\n            public void onClick(ClickEvent event) {\n\n                CmsPushButton button = (CmsPushButton)event.getSource();\n                CmsDomUtil.ensureMouseOut(button.getElement());\n                CmsPreviewDialog.showPreviewForResource(resourceBean.getId());\n            }\n        });\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(noPreviewReason)) {\n            previewButton.disable(noPreviewReason);\n        }\n        itemWidget.addButton(previewButton);\n\n        itemWidget.setIcon(CmsIconUtil.getResourceIconClasses(resourceBean.getResourceType(), false));\n        return itemWidget;\n    }","commit_id":"aed14b84f75ab135d8764a1a975551b6027ad091","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.ade.publish.shared.rpc.I_CmsPublishService#getResourceGroups(org.opencms.ade.publish.shared.CmsWorkflow,org.opencms.ade.publish.shared.CmsPublishOptions)\n     */\n    public List<CmsPublishGroup> getResourceGroups(CmsWorkflow workflow, CmsPublishOptions options)\n    throws CmsRpcException {\n\n        List<CmsPublishGroup> results = null;\n        CmsObject cms = getCmsObject();\n        try {\n            Locale locale = OpenCms.getWorkplaceManager().getWorkplaceLocale(cms);\n            List<CmsPublishResource> publishResources = OpenCms.getWorkflowManager().getWorkflowPublishResources(\n                cms,\n                workflow,\n                options);\n            A_CmsPublishGroupHelper<CmsPublishResource, CmsPublishGroup> groupHelper = new CmsDefaultPublishGroupHelper(\n                locale);\n            results = groupHelper.getGroups(publishResources);\n            setCachedOptions(options);\n        } catch (Throwable e) {\n            error(e);\n        }\n        return results;\n    }","id":23922,"modified_method":"/**\n     * @see org.opencms.ade.publish.shared.rpc.I_CmsPublishService#getResourceGroups(org.opencms.ade.publish.shared.CmsWorkflow,org.opencms.ade.publish.shared.CmsPublishOptions)\n     */\n    public List<CmsPublishGroup> getResourceGroups(CmsWorkflow workflow, CmsPublishOptions options)\n    throws CmsRpcException {\n\n        List<CmsPublishGroup> results = null;\n        CmsObject cms = getCmsObject();\n        try {\n            Locale locale = OpenCms.getWorkplaceManager().getWorkplaceLocale(cms);\n            List<CmsPublishResource> publishResources = OpenCms.getWorkflowManager().getWorkflowPublishResources(\n                cms,\n                workflow,\n                options);\n            for (CmsPublishResource publishResource : publishResources) {\n                checkPreview(publishResource);\n            }\n            A_CmsPublishGroupHelper<CmsPublishResource, CmsPublishGroup> groupHelper = new CmsDefaultPublishGroupHelper(\n                locale);\n            results = groupHelper.getGroups(publishResources);\n            setCachedOptions(options);\n        } catch (Throwable e) {\n            error(e);\n        }\n        return results;\n    }","commit_id":"aed14b84f75ab135d8764a1a975551b6027ad091","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the preview info for the given resource.<p>\n     * \n     * @param resource the resource\n     * @param locale the requested locale\n     * \n     * @return the preview info\n     */\n    private CmsPreviewInfo getPreviewInfo(CmsResource resource, Locale locale) {\n\n        CmsObject cms = getCmsObject();\n        String title = \"\";\n        try {\n            CmsProperty titleProperty = cms.readPropertyObject(resource, CmsPropertyDefinition.PROPERTY_TITLE, false);\n            title = titleProperty.getValue(\"\");\n        } catch (CmsException e) {\n            LOG.warn(e.getLocalizedMessage(), e);\n        }\n        if (CmsResourceTypeXmlContainerPage.isContainerPage(resource) || CmsResourceTypeXmlPage.isXmlPage(resource)) {\n            return new CmsPreviewInfo(null, OpenCms.getLinkManager().substituteLinkForUnknownTarget(\n                cms,\n                resource.getRootPath())\n                + \"?\"\n                + CmsJspTagEditable.PARAM_DISABLE_DIRECT_EDIT\n                + \"=true\", false, title, cms.getSitePath(resource));\n        }\n        if (CmsResourceTypeImage.getStaticTypeId() == resource.getTypeId()) {\n            CmsImageScaler scaler = new CmsImageScaler(cms, resource);\n            String content = \"<img src=\\\"\"\n                + OpenCms.getLinkManager().substituteLinkForUnknownTarget(cms, resource.getRootPath())\n                + \"\\\" title=\\\"\"\n                + title\n                + \"\\\" style=\\\"display:block\\\" />\";\n            CmsPreviewInfo result = new CmsPreviewInfo(content, null, false, title, cms.getSitePath(resource));\n            result.setHeight(scaler.getHeight());\n            result.setWidth(scaler.getWidth());\n            return result;\n        }\n        if (CmsResourceTypeXmlContent.isXmlContent(resource)) {\n            String previewContent = CmsPreviewService.getPreviewContent(\n                getRequest(),\n                getResponse(),\n                cms,\n                resource,\n                locale);\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(previewContent)) {\n                return new CmsPreviewInfo(previewContent, null, false, title, cms.getSitePath(resource));\n            }\n        }\n        return new CmsPreviewInfo(null, OpenCms.getLinkManager().substituteLinkForUnknownTarget(\n            cms,\n            resource.getRootPath())\n            + \"?\"\n            + CmsJspTagEditable.PARAM_DISABLE_DIRECT_EDIT\n            + \"=true\", true, title, cms.getSitePath(resource));\n    }","id":23923,"modified_method":"/**\n     * Returns the preview info for the given resource.<p>\n     * \n     * @param resource the resource\n     * @param locale the requested locale\n     * \n     * @return the preview info\n     */\n    private CmsPreviewInfo getPreviewInfo(CmsResource resource, Locale locale) {\n\n        CmsObject cms = getCmsObject();\n        String title = \"\";\n        try {\n            CmsProperty titleProperty = cms.readPropertyObject(resource, CmsPropertyDefinition.PROPERTY_TITLE, false);\n            title = titleProperty.getValue(\"\");\n        } catch (CmsException e) {\n            LOG.warn(e.getLocalizedMessage(), e);\n        }\n        String noPreviewReason = getNoPreviewReason(cms, resource);\n        String previewContent = null;\n        int height = 0;\n        int width = 0;\n        if (noPreviewReason != null) {\n            previewContent = \"<div>\" + noPreviewReason + \"<\/div>\";\n            return new CmsPreviewInfo(\n                \"<div>\" + noPreviewReason + \"<\/div>\",\n                null,\n                false,\n                title,\n                cms.getSitePath(resource));\n        } else if (CmsResourceTypeImage.getStaticTypeId() == resource.getTypeId()) {\n            CmsImageScaler scaler = new CmsImageScaler(cms, resource);\n            previewContent = \"<img src=\\\"\"\n                + OpenCms.getLinkManager().substituteLinkForUnknownTarget(cms, resource.getRootPath())\n                + \"\\\" title=\\\"\"\n                + title\n                + \"\\\" style=\\\"display:block\\\" />\";\n            height = scaler.getHeight();\n            width = scaler.getWidth();\n        } else if (CmsResourceTypeXmlContent.isXmlContent(resource)) {\n            previewContent = CmsPreviewService.getPreviewContent(getRequest(), getResponse(), cms, resource, locale);\n\n        } else if (CmsResourceTypePlain.getStaticTypeId() == resource.getTypeId()) {\n            try {\n                previewContent = \"<pre><code>\" + cms.readFile(resource).getContents().toString() + \"<\/code><\/pre>\";\n            } catch (CmsException e) {\n                LOG.warn(e.getLocalizedMessage(), e);\n                previewContent = \"<div>Could not read file content<\/div>\";\n            }\n        }\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(previewContent)) {\n            CmsPreviewInfo result = new CmsPreviewInfo(previewContent, null, false, title, cms.getSitePath(resource));\n            result.setHeight(height);\n            result.setWidth(width);\n            return result;\n        }\n        if (CmsResourceTypeXmlContainerPage.isContainerPage(resource) || CmsResourceTypeXmlPage.isXmlPage(resource)) {\n            return new CmsPreviewInfo(null, OpenCms.getLinkManager().substituteLinkForUnknownTarget(\n                cms,\n                resource.getRootPath())\n                + \"?\"\n                + CmsJspTagEditable.PARAM_DISABLE_DIRECT_EDIT\n                + \"=true\", false, title, cms.getSitePath(resource));\n        }\n        return new CmsPreviewInfo(null, OpenCms.getLinkManager().substituteLinkForUnknownTarget(\n            cms,\n            resource.getRootPath())\n            + \"?\"\n            + CmsJspTagEditable.PARAM_DISABLE_DIRECT_EDIT\n            + \"=true\", true, title, cms.getSitePath(resource));\n    }","commit_id":"aed14b84f75ab135d8764a1a975551b6027ad091","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * The method to update xml contents.<p>\n     *\n     * @param report I_CmsReport\n     * @param resourcePath Path to update xml contents in\n     * @param inclSubFolder true, if also resources in subfolders in the vfs folder shall be updated, otherwise false\n     * @param cmsObject Current CmsObject\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void updateXmlContents(I_CmsReport report, String resourcePath, boolean inclSubFolder, CmsObject cmsObject) {\n\n        // write parameters to report\n        report.println(Messages.get().container(Messages.RPT_UPDATEXML_BEGIN_UPDATE_0), I_CmsReport.FORMAT_NOTE);\n        report.println(Messages.get().container(Messages.RPT_UPDATEXML_PARAMETERS_0), I_CmsReport.FORMAT_HEADLINE);\n        report.println(\n            Messages.get().container(Messages.RPT_UPDATEXML_PARAMETERS_RESOURCE_PATH_1, resourcePath),\n            I_CmsReport.FORMAT_NOTE);\n        report.println(Messages.get().container(\n            Messages.RPT_UPDATEXML_PARAMETERS_INC_SUBFOLDERS_1,\n            new Boolean(inclSubFolder).toString()), I_CmsReport.FORMAT_NOTE);\n\n        // check for valid parameters (vfs folder)\n        if (CmsStringUtil.isEmpty(resourcePath)) {\n            report.println(Messages.get().container(Messages.RPT_UPDATEXML_NO_VFS_FOLDER_0), I_CmsReport.FORMAT_ERROR);\n            return;\n        }\n\n        // read all files in the vfs folder\n        report.println(Messages.get().container(Messages.RPT_UPDATEXML_START_SEARCHING_0), I_CmsReport.FORMAT_HEADLINE);\n        List<CmsResource> allFiles = null;\n        try {\n            allFiles = cmsObject.readResources(resourcePath, CmsResourceFilter.DEFAULT, inclSubFolder);\n        } catch (CmsException e) {\n            m_errorUpdate += 1;\n            report.println(Messages.get().container(Messages.RPT_UPDATEXML_SEARCH_ERROR_0), I_CmsReport.FORMAT_ERROR);\n            if (LOG.isErrorEnabled()) {\n                LOG.error(e.getMessageContainer(), e);\n            }\n            report.println(Messages.get().container(Messages.RPT_UPDATEXML_END_UPDATE_0), I_CmsReport.FORMAT_NOTE);\n            return;\n        }\n\n        // get the files to update\n        List<CmsResource> files2Update = new ArrayList<CmsResource>();\n        Iterator<CmsResource> iter = allFiles.iterator();\n        while (iter.hasNext()) {\n            CmsResource cmsResource = iter.next();\n            // only update Xml contents\n            if (cmsResource.isFile() && CmsResourceTypeXmlContent.isXmlContent(cmsResource)) {\n                files2Update.add(cmsResource);\n            }\n        }\n\n        // number of files to update\n        int nrOfFiles = files2Update.size();\n        report.println(Messages.get().container(\n            Messages.RPT_UPDATEXML_FILES_TO_UPDATE_1,\n            new Integer(nrOfFiles).toString()), I_CmsReport.FORMAT_NOTE);\n        // the file counter\n        int fileCounter = 0;\n        // update the files\n        if (nrOfFiles > 0) {\n            // report entry\n            report.println(\n                Messages.get().container(Messages.RPT_UPDATEXML_START_UPDATING_0),\n                I_CmsReport.FORMAT_HEADLINE);\n            // loop over all files \n            iter = files2Update.iterator();\n            while (iter.hasNext()) {\n                CmsResource cmsResource = iter.next();\n                fileCounter += 1;\n                // report entries\n                report.print(org.opencms.report.Messages.get().container(\n                    org.opencms.report.Messages.RPT_SUCCESSION_2,\n                    String.valueOf(fileCounter),\n                    String.valueOf(nrOfFiles)), I_CmsReport.FORMAT_NOTE);\n                report.print(Messages.get().container(Messages.RPT_UPDATEXML_CURRENT_FILE_0), I_CmsReport.FORMAT_NOTE);\n                report.print(org.opencms.report.Messages.get().container(\n                    org.opencms.report.Messages.RPT_ARGUMENT_1,\n                    report.removeSiteRoot(cmsResource.getRootPath())));\n                report.print(\n                    org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_DOTS_0),\n                    I_CmsReport.FORMAT_DEFAULT);\n\n                // get current lock from file\n                try {\n                    // try to lock the resource\n                    if (!lockResource(cmsObject, cmsResource, report)) {\n                        report.println(Messages.get().container(\n                            Messages.RPT_UPDATEXML_LOCKED_FILE_0,\n                            cmsObject.getSitePath(cmsResource)), I_CmsReport.FORMAT_ERROR);\n                        continue;\n                    }\n                } catch (CmsException e) {\n                    report.println(Messages.get().container(\n                        Messages.RPT_UPDATEXML_LOCKED_FILE_0,\n                        cmsObject.getSitePath(cmsResource)), I_CmsReport.FORMAT_ERROR);\n                    if (LOG.isErrorEnabled()) {\n                        LOG.error(e.getMessageContainer(), e);\n                    }\n                    continue;\n                }\n\n                // write the resource\n                try {\n                    // do not change the date last modified\n                    long lastModified = cmsResource.getDateLastModified();\n                    CmsFile cmsFile = cmsObject.readFile(cmsResource);\n                    cmsFile.setDateLastModified(lastModified);\n                    cmsObject.writeFile(cmsFile);\n                } catch (Exception e) {\n                    m_errorUpdate += 1;\n                    report.println(\n                        org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_FAILED_0),\n                        I_CmsReport.FORMAT_ERROR);\n                    if (LOG.isErrorEnabled()) {\n                        LOG.error(e.toString());\n                    }\n                    continue;\n                }\n\n                // unlock the resource\n                try {\n                    cmsObject.unlockResource(cmsObject.getSitePath(cmsResource));\n                } catch (CmsException e) {\n                    m_errorUpdate += 1;\n                    report.println(\n                        Messages.get().container(Messages.RPT_UPDATEXML_UNLOCK_FILE_0),\n                        I_CmsReport.FORMAT_WARNING);\n                    if (LOG.isErrorEnabled()) {\n                        LOG.error(e.getMessageContainer(), e);\n                    }\n                    continue;\n                }\n                // successfully updated\n                report.println(\n                    org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_OK_0),\n                    I_CmsReport.FORMAT_OK);\n            }\n        } else {\n            // no files to update\n            report.println(Messages.get().container(Messages.RPT_UPDATEXML_NO_FILES_FOUND_0), I_CmsReport.FORMAT_NOTE);\n        }\n\n        // the results are written in the report\n        report.println(Messages.get().container(Messages.RPT_UPDATEXML_RESULT_0), I_CmsReport.FORMAT_HEADLINE);\n        report.println(Messages.get().container(\n            Messages.RPT_UPDATEXML_FILES_TO_UPDATE_1,\n            new Integer(nrOfFiles).toString()), I_CmsReport.FORMAT_NOTE);\n        report.println(Messages.get().container(\n            Messages.RPT_UPDATEXML_UPDATE_NUMBER_ERRORS_1,\n            new Integer(m_errorUpdate).toString()), I_CmsReport.FORMAT_NOTE);\n        report.println(Messages.get().container(\n            Messages.RPT_UPDATEXML_LOCKED_FILES_1,\n            new Integer(m_lockedFiles).toString()), I_CmsReport.FORMAT_NOTE);\n        if (m_lockedFiles > 0) {\n            report.println(Messages.get().container(Messages.RPT_UPDATEXML_UPDATE_FAILED_0), I_CmsReport.FORMAT_ERROR);\n        } else {\n            report.println(Messages.get().container(Messages.RPT_UPDATEXML_UPDATE_SUCCESS_0), I_CmsReport.FORMAT_OK);\n        }\n        report.println(Messages.get().container(Messages.RPT_UPDATEXML_END_UPDATE_0), I_CmsReport.FORMAT_NOTE);\n    }","id":23924,"modified_method":"/**\n     * The method to update xml contents.<p>\n     *\n     * @param report I_CmsReport\n     * @param resourcePath Path to update xml contents in\n     * @param inclSubFolder true, if also resources in subfolders in the vfs folder shall be updated, otherwise false\n     * @param cmsObject Current CmsObject\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void updateXmlContents(I_CmsReport report, String resourcePath, boolean inclSubFolder, CmsObject cmsObject) {\n\n        // write parameters to report\n        report.println(Messages.get().container(Messages.RPT_UPDATEXML_BEGIN_UPDATE_0), I_CmsReport.FORMAT_NOTE);\n        report.println(Messages.get().container(Messages.RPT_UPDATEXML_PARAMETERS_0), I_CmsReport.FORMAT_HEADLINE);\n        report.println(\n            Messages.get().container(Messages.RPT_UPDATEXML_PARAMETERS_RESOURCE_PATH_1, resourcePath),\n            I_CmsReport.FORMAT_NOTE);\n        report.println(Messages.get().container(\n            Messages.RPT_UPDATEXML_PARAMETERS_INC_SUBFOLDERS_1,\n            new Boolean(inclSubFolder).toString()), I_CmsReport.FORMAT_NOTE);\n\n        // check for valid parameters (vfs folder)\n        if (CmsStringUtil.isEmpty(resourcePath)) {\n            report.println(Messages.get().container(Messages.RPT_UPDATEXML_NO_VFS_FOLDER_0), I_CmsReport.FORMAT_ERROR);\n            return;\n        }\n\n        // read all files in the vfs folder\n        report.println(Messages.get().container(Messages.RPT_UPDATEXML_START_SEARCHING_0), I_CmsReport.FORMAT_HEADLINE);\n        List<CmsResource> allFiles = null;\n        try {\n            allFiles = cmsObject.readResources(resourcePath, CmsResourceFilter.DEFAULT, inclSubFolder);\n        } catch (CmsException e) {\n            m_errorUpdate += 1;\n            report.println(Messages.get().container(Messages.RPT_UPDATEXML_SEARCH_ERROR_0), I_CmsReport.FORMAT_ERROR);\n            if (LOG.isErrorEnabled()) {\n                LOG.error(e.getMessageContainer(), e);\n            }\n            report.println(Messages.get().container(Messages.RPT_UPDATEXML_END_UPDATE_0), I_CmsReport.FORMAT_NOTE);\n            return;\n        }\n\n        // get the files to update\n        List<CmsResource> files2Update = new ArrayList<CmsResource>();\n        Iterator<CmsResource> iter = allFiles.iterator();\n        while (iter.hasNext()) {\n            CmsResource cmsResource = iter.next();\n            // only update Xml contents\n            if (cmsResource.isFile()\n                && (CmsResourceTypeXmlContent.isXmlContent(cmsResource) || CmsResourceTypeXmlPage.isXmlPage(cmsResource))) {\n                files2Update.add(cmsResource);\n            }\n        }\n\n        // number of files to update\n        int nrOfFiles = files2Update.size();\n        report.println(Messages.get().container(\n            Messages.RPT_UPDATEXML_FILES_TO_UPDATE_1,\n            new Integer(nrOfFiles).toString()), I_CmsReport.FORMAT_NOTE);\n        // the file counter\n        int fileCounter = 0;\n        // update the files\n        if (nrOfFiles > 0) {\n            // report entry\n            report.println(\n                Messages.get().container(Messages.RPT_UPDATEXML_START_UPDATING_0),\n                I_CmsReport.FORMAT_HEADLINE);\n            // loop over all files \n            iter = files2Update.iterator();\n            while (iter.hasNext()) {\n                CmsResource cmsResource = iter.next();\n                fileCounter += 1;\n                // report entries\n                report.print(org.opencms.report.Messages.get().container(\n                    org.opencms.report.Messages.RPT_SUCCESSION_2,\n                    String.valueOf(fileCounter),\n                    String.valueOf(nrOfFiles)), I_CmsReport.FORMAT_NOTE);\n                report.print(Messages.get().container(Messages.RPT_UPDATEXML_CURRENT_FILE_0), I_CmsReport.FORMAT_NOTE);\n                report.print(org.opencms.report.Messages.get().container(\n                    org.opencms.report.Messages.RPT_ARGUMENT_1,\n                    report.removeSiteRoot(cmsResource.getRootPath())));\n                report.print(\n                    org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_DOTS_0),\n                    I_CmsReport.FORMAT_DEFAULT);\n\n                // get current lock from file\n                try {\n                    // try to lock the resource\n                    if (!lockResource(cmsObject, cmsResource, report)) {\n                        report.println(Messages.get().container(\n                            Messages.RPT_UPDATEXML_LOCKED_FILE_0,\n                            cmsObject.getSitePath(cmsResource)), I_CmsReport.FORMAT_ERROR);\n                        continue;\n                    }\n                } catch (CmsException e) {\n                    report.println(Messages.get().container(\n                        Messages.RPT_UPDATEXML_LOCKED_FILE_0,\n                        cmsObject.getSitePath(cmsResource)), I_CmsReport.FORMAT_ERROR);\n                    if (LOG.isErrorEnabled()) {\n                        LOG.error(e.getMessageContainer(), e);\n                    }\n                    continue;\n                }\n\n                // write the resource\n                try {\n                    // do not change the date last modified\n                    long lastModified = cmsResource.getDateLastModified();\n                    CmsFile cmsFile = cmsObject.readFile(cmsResource);\n                    cmsFile.setDateLastModified(lastModified);\n                    cmsObject.writeFile(cmsFile);\n                } catch (Exception e) {\n                    m_errorUpdate += 1;\n                    report.println(\n                        org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_FAILED_0),\n                        I_CmsReport.FORMAT_ERROR);\n                    if (LOG.isErrorEnabled()) {\n                        LOG.error(e.toString());\n                    }\n                    continue;\n                }\n\n                // unlock the resource\n                try {\n                    cmsObject.unlockResource(cmsObject.getSitePath(cmsResource));\n                } catch (CmsException e) {\n                    m_errorUpdate += 1;\n                    report.println(\n                        Messages.get().container(Messages.RPT_UPDATEXML_UNLOCK_FILE_0),\n                        I_CmsReport.FORMAT_WARNING);\n                    if (LOG.isErrorEnabled()) {\n                        LOG.error(e.getMessageContainer(), e);\n                    }\n                    continue;\n                }\n                // successfully updated\n                report.println(\n                    org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_OK_0),\n                    I_CmsReport.FORMAT_OK);\n            }\n        } else {\n            // no files to update\n            report.println(Messages.get().container(Messages.RPT_UPDATEXML_NO_FILES_FOUND_0), I_CmsReport.FORMAT_NOTE);\n        }\n\n        // the results are written in the report\n        report.println(Messages.get().container(Messages.RPT_UPDATEXML_RESULT_0), I_CmsReport.FORMAT_HEADLINE);\n        report.println(Messages.get().container(\n            Messages.RPT_UPDATEXML_FILES_TO_UPDATE_1,\n            new Integer(nrOfFiles).toString()), I_CmsReport.FORMAT_NOTE);\n        report.println(Messages.get().container(\n            Messages.RPT_UPDATEXML_UPDATE_NUMBER_ERRORS_1,\n            new Integer(m_errorUpdate).toString()), I_CmsReport.FORMAT_NOTE);\n        report.println(Messages.get().container(\n            Messages.RPT_UPDATEXML_LOCKED_FILES_1,\n            new Integer(m_lockedFiles).toString()), I_CmsReport.FORMAT_NOTE);\n        if (m_lockedFiles > 0) {\n            report.println(Messages.get().container(Messages.RPT_UPDATEXML_UPDATE_FAILED_0), I_CmsReport.FORMAT_ERROR);\n        } else {\n            report.println(Messages.get().container(Messages.RPT_UPDATEXML_UPDATE_SUCCESS_0), I_CmsReport.FORMAT_OK);\n        }\n        report.println(Messages.get().container(Messages.RPT_UPDATEXML_END_UPDATE_0), I_CmsReport.FORMAT_NOTE);\n    }","commit_id":"d8032d9c00807bfe137f366dae169359c0d4e877","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the html for the head navigation row.<p>\n     * \n     * This method only creates the head row part, be sure to add the\n     * dhtml menu entries by calling the method buildNavigationHeadMenus(java.lang.String).<p>\n     * \n     * @param homeLabel the label of the \"home\" link\n     * @param styleLink the CSS class name of the link node\n     * @param styleSeparator the CSS class name of the spearator node\n     * @return the html for the head navigation row\n     */\n    public String buildNavigationHead(String homeLabel, String styleLink, String styleSeparator) {\n        StringBuffer result = new StringBuffer(1024);\n            // only create navigation if the template is configured to show it\n            result.append(\"<div class=\\\"bordermain \");\n            result.append(styleLink);\n            result.append(\"\\\">\\n\");\n            result.append(\"\\t<!-- Beginn der Top-Navigation -->\\n\");\n            \n            List navElements = getNavigation().getNavigationForFolder(getHeadNavFolder());   \n            // create the \"home\" link at first position\n            homeLabel = homeLabel.toUpperCase();\n            result.append(\"<a class=\\\"\");\n            result.append(styleLink);\n            result.append(\"\\\" href=\\\"\");\n            result.append(link(getStartFolder()));\n            result.append(\"\\\" title=\\\"\");\n            result.append(homeLabel);\n            result.append(\"\\\">\");\n            result.append(homeLabel);\n            result.append(\"<\/a>\\n\");\n            \n            int count = -1;\n            for (int i=0; i<navElements.size(); i++) {\n                CmsJspNavElement nav = (CmsJspNavElement)navElements.get(i);\n                if (nav.isFolderLink()) {\n                    // create an entry for every folder\n                    count++;\n                    String navText = nav.getNavText().toUpperCase();\n                    result.append(\"<span class=\\\"\");\n                    result.append(styleSeparator);\n                    result.append(\"\\\">|<\/span>\\n\");\n                    result.append(\"<a id=\\\"xbparent\");\n                    result.append(count);\n                    result.append(\"\\\"\");\n                    if (showMenus()) {\n                        result.append(\" onmouseover=\\\"showMenu(\");\n                        result.append(count);\n                        result.append(\");\\\"\");\n                    }\n                    result.append(\" class=\\\"\");\n                    result.append(styleLink);\n                    result.append(\"\\\" title=\\\"\");\n                    result.append(navText);\n                    result.append(\"\\\" href=\\\"\");\n                    result.append(link(nav.getResourceName()));\n                    result.append(\"\\\">\");\n                    result.append(navText);\n                    result.append(\"<\/a>\\n\");        \n                }\n            }\n            result.append(\"\\t<!-- Ende der Top-Navigation -->\\n\");\n            result.append(\"<\/div>\\n\");\n        return result.toString();\n    }","id":23925,"modified_method":"/**\n     * Returns the html for the head navigation row.<p>\n     * \n     * This method only creates the head row part, be sure to add the\n     * dhtml menu entries by calling the method buildNavigationHeadMenus(java.lang.String).<p>\n     * \n     * @param homeLabel the label of the \"home\" link\n     * @param styleLink the CSS class name of the link node\n     * @param styleSeparator the CSS class name of the spearator node\n     * @return the html for the head navigation row\n     */\n    public String buildNavigationHead(String homeLabel, String styleLink, String styleSeparator) {\n        StringBuffer result = new StringBuffer(1024);\n            // only create navigation if the template is configured to show it\n            result.append(\"<div class=\\\"bordermain \");\n            result.append(styleLink);\n            result.append(\"\\\">\\n\");\n            result.append(\"\\t<!-- Beginn der Top-Navigation -->\\n\");\n            \n            List navElements = getNavigation().getNavigationForFolder(getHeadNavFolder());   \n            // create the \"home\" link at first position\n            homeLabel = homeLabel.toUpperCase();\n            result.append(\"<a class=\\\"\");\n            result.append(styleLink);\n            result.append(\"\\\" href=\\\"\");\n            result.append(link(getStartFolder()));\n            result.append(\"\\\" title=\\\"\");\n            result.append(homeLabel);\n            result.append(\"\\\">\");\n            result.append(homeLabel);\n            result.append(\"<\/a>\\n\");\n            \n            int count = -1;\n            String showItemProperty;\n            for (int i=0; i<navElements.size(); i++) {\n                CmsJspNavElement nav = (CmsJspNavElement)navElements.get(i);\n                showItemProperty = property(C_PROPERTY_HEADNAV_USE, nav.getResourceName(), \"true\");\n                boolean showItem = Boolean.valueOf(showItemProperty).booleanValue();\n                if (nav.isFolderLink() && showItem) {\n                    // create an entry for every folder\n                    count++;\n                    String navText = nav.getNavText().toUpperCase();\n                    result.append(\"<span class=\\\"\");\n                    result.append(styleSeparator);\n                    result.append(\"\\\">|<\/span>\\n\");\n                    result.append(\"<a id=\\\"xbparent\");\n                    result.append(count);\n                    result.append(\"\\\"\");\n                    if (showMenus()) {\n                        result.append(\" onmouseover=\\\"showMenu(\");\n                        result.append(count);\n                        result.append(\");\\\"\");\n                    }\n                    result.append(\" class=\\\"\");\n                    result.append(styleLink);\n                    result.append(\"\\\" title=\\\"\");\n                    result.append(navText);\n                    result.append(\"\\\" href=\\\"\");\n                    result.append(link(nav.getResourceName()));\n                    result.append(\"\\\">\");\n                    result.append(navText);\n                    result.append(\"<\/a>\\n\");        \n                }\n            }\n            result.append(\"\\t<!-- Ende der Top-Navigation -->\\n\");\n            result.append(\"<\/div>\\n\");\n        return result.toString();\n    }","commit_id":"f7a6c723e12667be5087631b8aaf2eef22bcf271","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the html for the head navigation menus.<p>\n     * \n     * This method only creates the menu entries, be sure to\n     * build the head row calling the menus, too.<p>\n     * \n     * @param styleClass the CSS class name of the &lt;div&gt; and &lt;a&gt; nodes\n     * @return the html for the head navigation menus\n     */\n    public String buildNavigationHeadMenus(String styleClass) {\n        StringBuffer result = new StringBuffer(4096);\n        // only create navigation if the template is configured to show it\n        List navElements = getNavigation().getNavigationForFolder(getHeadNavFolder());\n \n        int count = -1;\n        for (int i=0; i<navElements.size(); i++) {\n            CmsJspNavElement foldernav = (CmsJspNavElement)navElements.get(i);\n            if (foldernav.isFolderLink()) {\n                // create a menu entry for every found folder\n                count++;\n                String subfolder = foldernav.getResourceName();\n                \n                // get all navigation elements in the sub folder\n                List pages = getNavigation().getNavigationForFolder(subfolder);\n                result.append(\"<div id=\\\"xbmenu\");\n                result.append(count);\n                result.append(\"\\\" class=\\\"\");\n                result.append(styleClass);\n                result.append(\"\\\">\\n\");\n                result.append(\"<table border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"1\\\" width=\\\"150\\\">\\n\");\n                            \n                for (int k=0; k<pages.size(); k++) {\n                    // add the current page to the menu\n                    CmsJspNavElement nav = (CmsJspNavElement)pages.get(k);\n                    String target = nav.getResourceName();\n                    if (nav.isFolderLink()) { \n                        // check folders\n                        if (! (CmsResource.getParentFolder(target).equals(getStartFolder()))) {\n                            target = link(target);\n                        } else {\n                            target = null;\n                        }\n                    } else {\n                        target = link(target);\n                    }   \n                    if (target != null) {\n                        // create the entry\n                        result.append(\"\\t<tr><td><a class=\\\"\");\n                        result.append(styleClass);\n                        result.append(\"\\\" href=\\\"\");\n                        result.append(target);\n                        result.append(\"\\\">\");\n                        result.append(nav.getNavText());\n                        result.append(\"<\/a><\/td><\/tr>\\n\");               \n                    }\n                }\n                result.append(\"<\/table>\\n\");\n                result.append(\"<\/div>\\n\");      \n            }\n        }\n        return result.toString();\n    }","id":23926,"modified_method":"/**\n     * Returns the html for the head navigation menus.<p>\n     * \n     * This method only creates the menu entries, be sure to\n     * build the head row calling the menus, too.<p>\n     * \n     * @param styleClass the CSS class name of the &lt;div&gt; and &lt;a&gt; nodes\n     * @return the html for the head navigation menus\n     */\n    public String buildNavigationHeadMenus(String styleClass) {\n        StringBuffer result = new StringBuffer(4096);\n        // only create navigation if the template is configured to show it\n        List navElements = getNavigation().getNavigationForFolder(getHeadNavFolder());\n \n        int count = -1;\n        String showItemProperty;\n        for (int i=0; i<navElements.size(); i++) {\n            CmsJspNavElement foldernav = (CmsJspNavElement)navElements.get(i);\n            showItemProperty = property(C_PROPERTY_HEADNAV_USE, foldernav.getResourceName(), \"true\");\n            boolean showItem = Boolean.valueOf(showItemProperty).booleanValue();\n            if (foldernav.isFolderLink() && showItem) {\n                // create a menu entry for every found folder\n                count++;\n                String subfolder = foldernav.getResourceName();\n                \n                // get all navigation elements in the sub folder\n                List pages = getNavigation().getNavigationForFolder(subfolder);\n                result.append(\"<div id=\\\"xbmenu\");\n                result.append(count);\n                result.append(\"\\\" class=\\\"\");\n                result.append(styleClass);\n                result.append(\"\\\">\\n\");\n                result.append(\"<table border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"1\\\" width=\\\"150\\\">\\n\");\n                            \n                for (int k=0; k<pages.size(); k++) {\n                    // add the current page to the menu\n                    CmsJspNavElement nav = (CmsJspNavElement)pages.get(k);\n                    String target = nav.getResourceName();\n                    if (nav.isFolderLink()) { \n                        // check folders\n                        if (! (CmsResource.getParentFolder(target).equals(getStartFolder()))) {\n                            target = link(target);\n                        } else {\n                            target = null;\n                        }\n                    } else {\n                        target = link(target);\n                    }   \n                    if (target != null) {\n                        // create the entry\n                        result.append(\"\\t<tr><td><a class=\\\"\");\n                        result.append(styleClass);\n                        result.append(\"\\\" href=\\\"\");\n                        result.append(target);\n                        result.append(\"\\\">\");\n                        result.append(nav.getNavText());\n                        result.append(\"<\/a><\/td><\/tr>\\n\");               \n                    }\n                }\n                result.append(\"<\/table>\\n\");\n                result.append(\"<\/div>\\n\");      \n            }\n        }\n        return result.toString();\n    }","commit_id":"f7a6c723e12667be5087631b8aaf2eef22bcf271","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private int transformAttributeGetSetDeclFlags(TypedDeclaration tdecl, boolean forCompanion) {\n        if (tdecl instanceof Setter) {\n            // Spec says: A setter may not be annotated shared, default or \n            // actual. The visibility and refinement modifiers of an attribute \n            // with a setter are specified by annotating the matching getter.\n            tdecl = ((Setter)tdecl).getGetter();\n        }\n        \n        int result = 0;\n\n        result |= tdecl.isShared() ? PUBLIC : PRIVATE;\n        result |= (tdecl.isFormal() && !tdecl.isDefault() && !forCompanion) ? ABSTRACT : 0;\n        result |= !(tdecl.isFormal() || tdecl.isDefault() || tdecl.getContainer() instanceof Interface) || forCompanion ? FINAL : 0;\n\n        return result;\n    }","id":23927,"modified_method":"private int transformAttributeGetSetDeclFlags(TypedDeclaration tdecl, boolean forCompanion) {\n        if (tdecl instanceof Setter) {\n            // Spec says: A setter may not be annotated shared, default or \n            // actual. The visibility and refinement modifiers of an attribute \n            // with a setter are specified by annotating the matching getter.\n            tdecl = ((Setter)tdecl).getGetter();\n        }\n        \n        int result = 0;\n\n        result |= tdecl.isShared() ? PUBLIC : PRIVATE;\n        result |= ((tdecl.isFormal() && !tdecl.isDefault()) && !forCompanion) ? ABSTRACT : 0;\n        result |= !(tdecl.isFormal() || tdecl.isDefault() || Decl.withinInterface(tdecl)) || forCompanion ? FINAL : 0;\n\n        return result;\n    }","commit_id":"433a9b1a5d0ae89e3b2834dc62b2d4b01f6841ac","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private AttributeDefinitionBuilder makeGetterOrSetter(Tree.AttributeDeclaration decl, boolean forCompanion, AttributeDefinitionBuilder builder, boolean isGetter) {\n        at(decl);\n        if (forCompanion) {\n            if (decl.getSpecifierOrInitializerExpression() != null) {\n                builder.getterBlock(make().Block(0, List.<JCStatement>of(make().Return(makeErroneous()))));\n            } else {\n                JCExpression accessor = naming.makeQualifiedName(\n                        naming.makeQuotedThis(), \n                        decl.getDeclarationModel(), \n                        Naming.NA_MEMBER | (isGetter ? Naming.NA_GETTER : Naming.NA_SETTER));\n                \n                if (isGetter) {\n                    builder.getterBlock(make().Block(0, List.<JCStatement>of(make().Return(\n                            make().Apply(\n                                    null, \n                                    accessor, \n                                    List.<JCExpression>nil())))));\n                } else {\n                    List<JCExpression> args = List.<JCExpression>of(naming.makeName(decl.getDeclarationModel(), Naming.NA_MEMBER | Naming.NA_IDENT));\n                    builder.setterBlock(make().Block(0, List.<JCStatement>of(make().Exec(\n                            make().Apply(\n                                    null, \n                                    accessor, \n                                    args)))));\n                }\n                \n            }\n        }\n        if(forCompanion)\n            builder.notActual();\n        return builder\n            .modifiers(transformAttributeGetSetDeclFlags(decl.getDeclarationModel(), forCompanion))\n            .isFormal(Decl.isFormal(decl) && !forCompanion);\n    }","id":23928,"modified_method":"private AttributeDefinitionBuilder makeGetterOrSetter(Tree.AttributeDeclaration decl, boolean forCompanion, AttributeDefinitionBuilder builder, boolean isGetter) {\n        at(decl);\n        if (forCompanion) {\n            if (decl.getSpecifierOrInitializerExpression() != null) {\n                Value declarationModel = decl.getDeclarationModel();\n                JCExpression expr = expressionGen().transformExpression(decl.getSpecifierOrInitializerExpression().getExpression(), \n                        CodegenUtil.getBoxingStrategy(declarationModel), \n                        declarationModel.getType());\n                builder.getterBlock(make().Block(0, List.<JCStatement>of(make().Return(expr))));\n            } else {\n                JCExpression accessor = naming.makeQualifiedName(\n                        naming.makeQuotedThis(), \n                        decl.getDeclarationModel(), \n                        Naming.NA_MEMBER | (isGetter ? Naming.NA_GETTER : Naming.NA_SETTER));\n                \n                if (isGetter) {\n                    builder.getterBlock(make().Block(0, List.<JCStatement>of(make().Return(\n                            make().Apply(\n                                    null, \n                                    accessor, \n                                    List.<JCExpression>nil())))));\n                } else {\n                    List<JCExpression> args = List.<JCExpression>of(naming.makeName(decl.getDeclarationModel(), Naming.NA_MEMBER | Naming.NA_IDENT));\n                    builder.setterBlock(make().Block(0, List.<JCStatement>of(make().Exec(\n                            make().Apply(\n                                    null, \n                                    accessor, \n                                    args)))));\n                }\n                \n            }\n        }\n        if(forCompanion)\n            builder.notActual();\n        return builder\n            .modifiers(transformAttributeGetSetDeclFlags(decl.getDeclarationModel(), forCompanion))\n            .isFormal((Decl.isFormal(decl) || Decl.withinInterface(decl)) && !forCompanion);\n    }","commit_id":"433a9b1a5d0ae89e3b2834dc62b2d4b01f6841ac","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public void transform(AttributeDeclaration decl, ClassDefinitionBuilder classBuilder) {\n        final Value model = decl.getDeclarationModel();\n        boolean useField = Strategy.useField(model);\n        String attrName = decl.getIdentifier().getText();\n\n        // Only a non-formal attribute has a corresponding field\n        // and if a captured class parameter exists with the same name we skip this part as well\n        Parameter parameter = CodegenUtil.findParamForDecl(decl);\n        boolean createField = Strategy.createField(parameter, model);\n        boolean concrete = Decl.withinInterface(decl)\n                && decl.getSpecifierOrInitializerExpression() != null;\n        if (concrete || \n                (!Decl.isFormal(decl) \n                        && createField)) {\n            JCExpression initialValue = null;\n            if (decl.getSpecifierOrInitializerExpression() != null) {\n                Value declarationModel = model;\n                initialValue = expressionGen().transformExpression(decl.getSpecifierOrInitializerExpression().getExpression(), \n                        CodegenUtil.getBoxingStrategy(declarationModel), \n                        declarationModel.getType());\n            }\n\n            int flags = 0;\n            ProducedTypedReference typedRef = getTypedReference(model);\n            ProducedTypedReference nonWideningTypedRef = nonWideningTypeDecl(typedRef);\n            ProducedType nonWideningType = nonWideningType(typedRef, nonWideningTypedRef);\n            if (!CodegenUtil.isUnBoxed(nonWideningTypedRef.getDeclaration())) {\n                flags |= JT_NO_PRIMITIVES;\n            }\n            JCExpression type = makeJavaType(nonWideningType, flags);\n\n            int modifiers = (useField) ? transformAttributeFieldDeclFlags(decl) : transformLocalDeclFlags(decl);\n            \n            // If the attribute is really from a parameter then don't generate a field\n            // (The ClassDefinitionBuilder does it in that case)\n            if (parameter == null\n                    || ((parameter instanceof ValueParameter) \n                            && ((ValueParameter)parameter).isHidden())) {\n                if (concrete) {\n                    classBuilder.getCompanionBuilder((TypeDeclaration)model.getContainer()).field(modifiers, attrName, type, initialValue, !useField);\n                } else {\n                    classBuilder.field(modifiers, attrName, type, initialValue, !useField);\n                }        \n            }\n        }\n\n        if (useField) {\n            classBuilder.attribute(makeGetter(decl, false));\n            if (Decl.withinInterface(decl)) {\n                classBuilder.getCompanionBuilder((Interface)decl.getDeclarationModel().getContainer()).attribute(makeGetter(decl, true));\n            }\n            if (Decl.isMutable(decl)) {\n                classBuilder.attribute(makeSetter(decl, false));\n                if (Decl.withinInterface(decl)) {\n                    classBuilder.getCompanionBuilder((Interface)decl.getDeclarationModel().getContainer()).attribute(makeSetter(decl, true));\n                }\n            }\n        }\n    }","id":23929,"modified_method":"public void transform(AttributeDeclaration decl, ClassDefinitionBuilder classBuilder) {\n        final Value model = decl.getDeclarationModel();\n        boolean useField = Strategy.useField(model);\n        String attrName = decl.getIdentifier().getText();\n\n        // Only a non-formal or a concrete-non-lazy attribute has a corresponding field\n        // and if a captured class parameter exists with the same name we skip this part as well\n        Parameter parameter = CodegenUtil.findParamForDecl(decl);\n        boolean createField = Strategy.createField(parameter, model);\n        boolean concrete = Decl.withinInterface(decl)\n                && decl.getSpecifierOrInitializerExpression() != null;\n        boolean lazy = decl.getSpecifierOrInitializerExpression() instanceof LazySpecifierExpression;\n        if ((concrete && !lazy) || (!Decl.isFormal(decl) && createField)) {\n            JCExpression initialValue = null;\n            if (decl.getSpecifierOrInitializerExpression() != null) {\n                Value declarationModel = model;\n                initialValue = expressionGen().transformExpression(decl.getSpecifierOrInitializerExpression().getExpression(), \n                        CodegenUtil.getBoxingStrategy(declarationModel), \n                        declarationModel.getType());\n            }\n\n            int flags = 0;\n            ProducedTypedReference typedRef = getTypedReference(model);\n            ProducedTypedReference nonWideningTypedRef = nonWideningTypeDecl(typedRef);\n            ProducedType nonWideningType = nonWideningType(typedRef, nonWideningTypedRef);\n            if (!CodegenUtil.isUnBoxed(nonWideningTypedRef.getDeclaration())) {\n                flags |= JT_NO_PRIMITIVES;\n            }\n            JCExpression type = makeJavaType(nonWideningType, flags);\n\n            int modifiers = (useField) ? transformAttributeFieldDeclFlags(decl) : transformLocalDeclFlags(decl);\n            \n            // If the attribute is really from a parameter then don't generate a field\n            // (The ClassDefinitionBuilder does it in that case)\n            if (parameter == null\n                    || ((parameter instanceof ValueParameter) \n                            && ((ValueParameter)parameter).isHidden())) {\n                if (concrete) {\n                    classBuilder.getCompanionBuilder((TypeDeclaration)model.getContainer()).field(modifiers, attrName, type, initialValue, !useField);\n                } else {\n                    classBuilder.field(modifiers, attrName, type, initialValue, !useField);\n                }        \n            }\n        }\n\n        if (useField || Decl.withinInterface(decl)) {\n            // Generate getter in main class/interface\n            classBuilder.attribute(makeGetter(decl, false));\n            if (Decl.withinInterface(decl)) {\n                // Generate getter in companion class\n                classBuilder.getCompanionBuilder((Interface)decl.getDeclarationModel().getContainer()).attribute(makeGetter(decl, true));\n            }\n            if (Decl.isMutable(decl)) {\n                // Generate setter in main class/interface\n                classBuilder.attribute(makeSetter(decl, false));\n                if (Decl.withinInterface(decl)) {\n                    // Generate setter in companion class\n                    classBuilder.getCompanionBuilder((Interface)decl.getDeclarationModel().getContainer()).attribute(makeSetter(decl, true));\n                }\n            }\n        }\n    }","commit_id":"433a9b1a5d0ae89e3b2834dc62b2d4b01f6841ac","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public static boolean createField(Parameter p, Value v) {\n        return (p == null) || (useField(v) && !p.isCaptured());\n    }","id":23930,"modified_method":"public static boolean createField(Parameter p, Value v) {\n        return !Decl.withinInterface(v) && ((p == null) || (useField(v) && !p.isCaptured()));\n    }","commit_id":"433a9b1a5d0ae89e3b2834dc62b2d4b01f6841ac","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public static boolean useField(Value attr) {\n        return Decl.isCaptured(attr);\n    }","id":23931,"modified_method":"public static boolean useField(Value attr) {\n        return !Decl.withinInterface(attr) && Decl.isCaptured(attr);\n    }","commit_id":"433a9b1a5d0ae89e3b2834dc62b2d4b01f6841ac","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private int convertAttributeGetSetDeclFlags(Tree.AttributeDeclaration cdecl) {\n        int result = 0;\n\n        result |= isShared(cdecl) ? PUBLIC : PRIVATE;\n        result |= isFormal(cdecl) ? ABSTRACT : 0;\n        result |= !(isFormal(cdecl) || isDefault(cdecl)) ? FINAL : 0;\n\n        return result;\n    }","id":23932,"modified_method":"private int convertAttributeGetSetDeclFlags(Tree.TypedDeclaration cdecl) {\n        int result = 0;\n\n        result |= isShared(cdecl) ? PUBLIC : PRIVATE;\n        result |= (isFormal(cdecl) && !isDefault(cdecl)) ? ABSTRACT : 0;\n        result |= !(isFormal(cdecl) || isDefault(cdecl)) ? FINAL : 0;\n\n        return result;\n    }","commit_id":"a3f6c588c5292803c94ff5d01fb238939d9de929","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCTree.JCMethodDecl convert(AttributeSetterDefinition decl) {\n        JCBlock body = gen.statementGen.convert(decl.getBlock());\n        String name = decl.getIdentifier().getText();\n        JCExpression type = gen.makeJavaType(gen.actualType(decl), false);\n        return make().MethodDef(make().Modifiers(0), names().fromString(Util.getSetterName(name)), \n                make().TypeIdent(TypeTags.VOID),\n                List.<JCTree.JCTypeParameter>nil(), \n                List.<JCTree.JCVariableDecl>of(make().VarDef(make().Modifiers(0), names().fromString(name), type, null)), \n                List.<JCTree.JCExpression>nil(), \n                body, null);\n    }","id":23933,"modified_method":"private JCTree.JCMethodDecl convert(AttributeSetterDefinition decl) {\n        JCBlock body = gen.statementGen.convert(decl.getBlock());\n        String name = decl.getIdentifier().getText();\n        JCExpression type = gen.makeJavaType(gen.actualType(decl), false);\n        return make().MethodDef(make().Modifiers(convertAttributeGetSetDeclFlags(decl)), names().fromString(Util.getSetterName(name)), \n                make().TypeIdent(TypeTags.VOID),\n                List.<JCTree.JCTypeParameter>nil(), \n                List.<JCTree.JCVariableDecl>of(make().VarDef(make().Modifiers(0), names().fromString(name), type, null)), \n                List.<JCTree.JCExpression>nil(), \n                body, null);\n    }","commit_id":"a3f6c588c5292803c94ff5d01fb238939d9de929","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private int convertMethodDeclFlags(Tree.AnyMethod def) {\n        int result = 0;\n\n        if (isToplevel(def)) {\n            result |= isShared(def) ? PUBLIC : 0;\n            result |= STATIC;\n        } else if (isInner(def)) {\n            result |= isShared(def) ? PUBLIC : 0;\n        } else {\n            result |= isShared(def) ? PUBLIC : PRIVATE;\n            result |= isFormal(def) ? ABSTRACT : 0;\n            result |= !(isFormal(def) || isDefault(def)) ? FINAL : 0;\n        }\n\n        return result;\n    }","id":23934,"modified_method":"private int convertMethodDeclFlags(Tree.AnyMethod def) {\n        int result = 0;\n\n        if (isToplevel(def)) {\n            result |= isShared(def) ? PUBLIC : 0;\n            result |= STATIC;\n        } else if (isInner(def)) {\n            result |= isShared(def) ? PUBLIC : 0;\n        } else {\n            result |= isShared(def) ? PUBLIC : PRIVATE;\n            result |= (isFormal(def) && !isDefault(def)) ? ABSTRACT : 0;\n            result |= !(isFormal(def) || isDefault(def)) ? FINAL : 0;\n        }\n\n        return result;\n    }","commit_id":"a3f6c588c5292803c94ff5d01fb238939d9de929","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCTree.JCMethodDecl convert(AttributeGetterDefinition decl) {\n        JCBlock body = gen.statementGen.convert(decl.getBlock());\n        List<JCAnnotation> annots = gen.makeJavaTypeAnnotations(decl.getDeclarationModel(), gen.actualType(decl));\n        return make().MethodDef(make().Modifiers(0, annots),\n                names().fromString(Util.getGetterName(decl.getIdentifier().getText())), \n                gen.makeJavaType(gen.actualType(decl), false), \n                List.<JCTree.JCTypeParameter>nil(), \n                List.<JCTree.JCVariableDecl>nil(), \n                List.<JCTree.JCExpression>nil(), \n                body, null);\n    }","id":23935,"modified_method":"public JCTree.JCMethodDecl convert(AttributeGetterDefinition decl) {\n        JCBlock body = gen.statementGen.convert(decl.getBlock());\n        List<JCAnnotation> annots = gen.makeJavaTypeAnnotations(decl.getDeclarationModel(), gen.actualType(decl));\n        return make().MethodDef(make().Modifiers(convertAttributeGetSetDeclFlags(decl), annots),\n                names().fromString(Util.getGetterName(decl.getIdentifier().getText())), \n                gen.makeJavaType(gen.actualType(decl), false), \n                List.<JCTree.JCTypeParameter>nil(), \n                List.<JCTree.JCVariableDecl>nil(), \n                List.<JCTree.JCExpression>nil(), \n                body, null);\n    }","commit_id":"a3f6c588c5292803c94ff5d01fb238939d9de929","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCExpression convert(Tree.BaseMemberExpression member) {\n        Declaration decl = member.getDeclaration();\n        if (decl instanceof Value) {\n            if (decl.isToplevel()) {\n                if (\"null\".equals(decl.getName())) {\n                    // ERASURE\n                    // FIXME this is a pretty brain-dead way to go about erase I think\n                    return at(member).Ident(names().fromString(\"null\"));\n                } else {\n                    // it's a toplevel attribute\n                    return gen.globalGenAt(member).getGlobalValue(\n                            makeIdent(decl.getContainer().getQualifiedName()),\n                            decl.getName());\n                }\n             } else if(Util.isClassAttribute(decl)) {\n                // invoke the getter\n                return at(member).Apply(List.<JCExpression>nil(), \n                        makeIdent(Util.getGetterName(decl.getName())), \n                        List.<JCExpression>nil());\n            }\n        } else if (decl instanceof Method) {\n            if (Util.isInnerMethod(decl)) {\n                java.util.List<String> path = new LinkedList<String>();\n                path.add(decl.getName());\n                path.add(decl.getName());\n                return makeIdent(path);\n            }\n        }\n        return at(member).Ident(names().fromString(gen.substitute(member.getIdentifier().getText())));\n    }","id":23936,"modified_method":"private JCExpression convert(Tree.BaseMemberExpression member) {\n        Declaration decl = member.getDeclaration();\n        if (decl instanceof Value) {\n            if (decl.isToplevel()) {\n                if (\"null\".equals(decl.getName())) {\n                    // ERASURE\n                    // FIXME this is a pretty brain-dead way to go about erase I think\n                    return at(member).Ident(names().fromString(\"null\"));\n                } else {\n                    // it's a toplevel attribute\n                    return gen.globalGenAt(member).getGlobalValue(\n                            makeIdent(decl.getContainer().getQualifiedName()),\n                            decl.getName());\n                }\n             } else if(Util.isClassAttribute(decl)) {\n                // invoke the getter\n                return at(member).Apply(List.<JCExpression>nil(), \n                        makeIdent(Util.getGetterName(decl.getName())), \n                        List.<JCExpression>nil());\n            }\n        } else if (decl instanceof Getter) {\n            // invoke the getter\n            return at(member).Apply(List.<JCExpression>nil(), \n                    makeIdent(Util.getGetterName(decl.getName())), \n                    List.<JCExpression>nil());\n        } else if (decl instanceof Method) {\n            if (Util.isInnerMethod(decl)) {\n                java.util.List<String> path = new LinkedList<String>();\n                path.add(decl.getName());\n                path.add(decl.getName());\n                return makeIdent(path);\n            }\n        }\n        return at(member).Ident(names().fromString(gen.substitute(member.getIdentifier().getText())));\n    }","commit_id":"a3f6c588c5292803c94ff5d01fb238939d9de929","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"JCExpression convertAssignment(Node op, Term leftTerm, Term rightTerm) {\n        // right side is easy\n        JCExpression rhs = convertExpression(rightTerm);\n        // left side depends\n        // FIXME: can this be anything else than a Primary?\n        Declaration decl = ((Tree.Primary)leftTerm).getDeclaration();\n        // FIXME: can this be anything else than a Value or a TypedDeclaration?\n        boolean variable = false;\n        if (decl instanceof Value) {\n            variable = ((Value)decl).isVariable();\n        } else if (decl instanceof TypedDeclaration) {\n            variable = ((TypedDeclaration)decl).isVariable();\n        }\n        if(Util.isClassAttribute(decl) && variable){\n            // must use the setter\n            return at(op).Apply(List.<JCTree.JCExpression>nil(), makeIdent(Util.getSetterName(decl.getName())), \n                    List.<JCTree.JCExpression>of(rhs));\n        } else if(decl.isToplevel()){\n            // must use top level setter\n            return gen.globalGenAt(op).setGlobalValue(\n                    makeIdent(decl.getContainer().getQualifiedName()),\n                    decl.getName(),\n                    rhs);\n        } else\n            return at(op).Assign(make().Ident(names().fromString(decl.getName())), rhs);\n    }","id":23937,"modified_method":"JCExpression convertAssignment(Node op, Term leftTerm, Term rightTerm) {\n        // right side is easy\n        JCExpression rhs = convertExpression(rightTerm);\n        // left side depends\n        // FIXME: can this be anything else than a Primary?\n        Declaration decl = ((Tree.Primary)leftTerm).getDeclaration();\n        // FIXME: can this be anything else than a Value or a TypedDeclaration?\n        boolean variable = false;\n        if (decl instanceof Value) {\n            variable = ((Value)decl).isVariable();\n        } else if (decl instanceof TypedDeclaration) {\n            variable = ((TypedDeclaration)decl).isVariable();\n        }\n        if((decl instanceof Getter) || (Util.isClassAttribute(decl) && variable)){\n            // must use the setter\n            return at(op).Apply(List.<JCTree.JCExpression>nil(), makeIdent(Util.getSetterName(decl.getName())), \n                    List.<JCTree.JCExpression>of(rhs));\n        } else if(decl.isToplevel()){\n            // must use top level setter\n            return gen.globalGenAt(op).setGlobalValue(\n                    makeIdent(decl.getContainer().getQualifiedName()),\n                    decl.getName(),\n                    rhs);\n        } else {\n            return at(op).Assign(make().Ident(names().fromString(decl.getName())), rhs);\n        }\n    }","commit_id":"a3f6c588c5292803c94ff5d01fb238939d9de929","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public Map<String, Object> getValues(String entityReference,\n\t\t\tString localeCode) {\n\t\tMap<String, Object> values = new HashMap<String, Object>();\n\t\tAnnouncementMessage announcement = (AnnouncementMessage) this.sakaiProxy.getEntity(entityReference);\n\t\tResourceLoader rl = new ResourceLoader(\"dash_entity\");\n\t\tif(announcement != null) {\n\t\t\tAnnouncementMessageHeader header = announcement.getAnnouncementHeader();\n\t\t\tResourceProperties props = announcement.getProperties();\n\t\t\t// \"entity-type\": \"assignment\"\n\t\t\tvalues.put(EntityType.VALUE_ENTITY_TYPE, IDENTIFIER);\n\t\t\t// \"news-time\": 1234567890\n\t\t\ttry {\n\t\t\t\tDateFormat df = DateFormat.getDateTimeInstance();\n\t\t\t\tvalues.put(VALUE_NEWS_TIME, df.format(new Date(props.getTimeProperty(ResourceProperties.PROP_CREATION_DATE).getTime())));\n\t\t\t} catch (EntityPropertyNotDefinedException e) {\n\t\t\t\tlogger.warn(\"getValues(\" + entityReference + \",\" + localeCode + \") EntityPropertyNotDefinedException: \" + e);\n\t\t\t} catch (EntityPropertyTypeException e) {\n\t\t\t\tlogger.warn(\"getValues(\" + entityReference + \",\" + localeCode + \") EntityPropertyTypeException: \" + e);\n\t\t\t}\n\t\t\t// \"description\": \"Long thing, markup, escaped\",\n\t\t\tvalues.put(VALUE_DESCRIPTION, announcement.getBody());\n\t\t\t// \"title\": \"Assignment hoedown\"\n\t\t\tvalues.put(VALUE_TITLE, header.getSubject());\n\t\t\t// \"user-name\": \"Creator's Name\"\n\t\t\tUser user = sakaiProxy.getUser(header.getFrom().getDisplayName());\n\t\t\tif(user != null) {\n\t\t\t\tvalues.put(VALUE_USER_NAME, user.getDisplayName());\n\t\t\t}\n\t\t\t\n\t\t\t// more info\n\t\t\tList<Map<String,String>> infoList = new ArrayList<Map<String,String>>();\n\t\t\tMap<String,String> infoItem = new HashMap<String,String>();\n\t\t\tinfoItem.put(VALUE_INFO_LINK_URL, announcement.getUrl());\n\t\t\tinfoItem.put(VALUE_INFO_LINK_TITLE, rl.getString(\"announcement.info.link\"));\n\t\t\tinfoList.add(infoItem);\n\t\t\tvalues.put(VALUE_MORE_INFO, infoList);\n\t\t\t\n\t\t\t// \"attachments\": [ ... ]\n\t\t\tList<Reference> attachments = header.getAttachments();\n\t\t\tif(attachments != null && ! attachments.isEmpty()) {\n\t\t\t\tList<Map<String,String>> attList = new ArrayList<Map<String,String>>();\n\t\t\t\tfor(Reference ref : attachments) {\n\t\t\t\t\tContentResource resource = (ContentResource) ref.getEntity();\n\t\t\t\t\tMap<String, String> attInfo = new HashMap<String, String>();\n\t\t\t\t\tattInfo.put(VALUE_ATTACHMENT_TITLE, resource.getProperties().getProperty(ResourceProperties.PROP_DISPLAY_NAME));\n\t\t\t\t\tattInfo.put(VALUE_ATTACHMENT_URL, resource.getUrl());\n\t\t\t\t\tattInfo.put(VALUE_ATTACHMENT_MIMETYPE, resource.getContentType());\n\t\t\t\t\tattInfo.put(VALUE_ATTACHMENT_SIZE, Long.toString(resource.getContentLength()));\n\t\t\t\t\tattInfo.put(VALUE_ATTACHMENT_TARGET, this.sakaiProxy.getTargetForMimetype(resource.getContentType()));\n\t\t\t\t\tattList.add(attInfo );\n\t\t\t\t}\n\t\t\t\tvalues.put(VALUE_ATTACHMENTS, attList);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn values;\n\t}","id":23938,"modified_method":"public Map<String, Object> getValues(String entityReference,\n\t\t\tString localeCode) {\n\t\tMap<String, Object> values = new HashMap<String, Object>();\n\t\tAnnouncementMessage announcement = (AnnouncementMessage) this.sakaiProxy.getEntity(entityReference);\n\t\tResourceLoader rl = new ResourceLoader(\"dash_entity\");\n\t\tif(announcement != null) {\n\t\t\tAnnouncementMessageHeader header = announcement.getAnnouncementHeader();\n\t\t\tResourceProperties props = announcement.getProperties();\n\t\t\t// \"entity-type\": \"assignment\"\n\t\t\tvalues.put(EntityType.VALUE_ENTITY_TYPE, IDENTIFIER);\n\t\t\t// \"news-time\": 1234567890\n\t\t\tDateFormat df = DateFormat.getDateTimeInstance();\n\t\t\tvalues.put(VALUE_NEWS_TIME, df.format(new Date(header.getDate().getTime())));\n\t\t\t// \"description\": \"Long thing, markup, escaped\",\n\t\t\tvalues.put(VALUE_DESCRIPTION, announcement.getBody());\n\t\t\t// \"title\": \"Assignment hoedown\"\n\t\t\tvalues.put(VALUE_TITLE, header.getSubject());\n\t\t\t// \"user-name\": \"Creator's Name\"\n\t\t\tUser user = header.getFrom();\n\t\t\tif(user != null) {\n\t\t\t\tvalues.put(VALUE_USER_NAME, user.getDisplayName());\n\t\t\t}\n\t\t\t\n\t\t\t// more info\n\t\t\tList<Map<String,String>> infoList = new ArrayList<Map<String,String>>();\n\t\t\tMap<String,String> infoItem = new HashMap<String,String>();\n\t\t\tinfoItem.put(VALUE_INFO_LINK_URL, announcement.getUrl());\n\t\t\tinfoItem.put(VALUE_INFO_LINK_TITLE, rl.getString(\"announcement.info.link\"));\n\t\t\tinfoList.add(infoItem);\n\t\t\tvalues.put(VALUE_MORE_INFO, infoList);\n\t\t\t\n\t\t\t// \"attachments\": [ ... ]\n\t\t\tList<Reference> attachments = header.getAttachments();\n\t\t\tif(attachments != null && ! attachments.isEmpty()) {\n\t\t\t\tList<Map<String,String>> attList = new ArrayList<Map<String,String>>();\n\t\t\t\tfor(Reference ref : attachments) {\n\t\t\t\t\tContentResource resource = (ContentResource) ref.getEntity();\n\t\t\t\t\tMap<String, String> attInfo = new HashMap<String, String>();\n\t\t\t\t\tattInfo.put(VALUE_ATTACHMENT_TITLE, resource.getProperties().getProperty(ResourceProperties.PROP_DISPLAY_NAME));\n\t\t\t\t\tattInfo.put(VALUE_ATTACHMENT_URL, resource.getUrl());\n\t\t\t\t\tattInfo.put(VALUE_ATTACHMENT_MIMETYPE, resource.getContentType());\n\t\t\t\t\tattInfo.put(VALUE_ATTACHMENT_SIZE, Long.toString(resource.getContentLength()));\n\t\t\t\t\tattInfo.put(VALUE_ATTACHMENT_TARGET, this.sakaiProxy.getTargetForMimetype(resource.getContentType()));\n\t\t\t\t\tattList.add(attInfo );\n\t\t\t\t}\n\t\t\t\tvalues.put(VALUE_ATTACHMENTS, attList);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn values;\n\t}","commit_id":"ac7537781f9986b928a058267550caab5b88d175","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public Map<String, String> getProperties(String entityReference,\n\t\t\tString localeCode) {\n\t\tResourceLoader rl = new ResourceLoader(\"dash_entity\");\n\t\tMap<String, String> props = new HashMap<String, String>();\n\t\tprops.put(LABEL_CALENDAR_TIME, rl.getString(\"announcement.news.time\"));\n\t\tprops.put(LABEL_USER_NAME, rl.getString(\"announcement.user.name\"));\n\t\t//props.put(LABEL_ATTACHMENTS, rl.getString(\"announcement.attachments\"));\n\t\treturn props;\n\t}","id":23939,"modified_method":"public Map<String, String> getProperties(String entityReference,\n\t\t\tString localeCode) {\n\t\tResourceLoader rl = new ResourceLoader(\"dash_entity\");\n\t\tMap<String, String> props = new HashMap<String, String>();\n\t\tprops.put(LABEL_NEWS_TIME, rl.getString(\"announcement.news.time\"));\n\t\tprops.put(LABEL_USER_NAME, rl.getString(\"announcement.user.name\"));\n\t\t//props.put(LABEL_ATTACHMENTS, rl.getString(\"announcement.attachments\"));\n\t\treturn props;\n\t}","commit_id":"ac7537781f9986b928a058267550caab5b88d175","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Helper function used to send a message to a contact, with the given\n     * extensions attached.\n     *\n     * @param to The contact to send the message to.\n     * @param toResource The resource to send the message to or null if no\n     * resource has been specified\n     * @param message The message to send.\n     * @param extensions The XMPP extensions that should be attached to the\n     * message before sending.\n     * @return The MessageDeliveryEvent that resulted after attempting to\n     * send this message, so the calling function can modify it if needed.\n     */\n    private MessageDeliveredEvent sendMessage(  Contact to,\n                                                ContactResource toResource,\n                                                Message message,\n                                                PacketExtension[] extensions)\n    {\n        if( !(to instanceof ContactJabberImpl) )\n           throw new IllegalArgumentException(\n               \"The specified contact is not a Jabber contact.\"\n               + to);\n\n        try\n        {\n            assertConnected();\n\n            org.jivesoftware.smack.packet.Message msg =\n                new org.jivesoftware.smack.packet.Message();\n\n            String toJID = null;\n\n            boolean sendToBaseResource = false;\n            if (toResource != null)\n            {\n                if(toResource.equals(ContactResource.BASE_RESOURCE))\n                {\n                    toJID = to.getAddress();\n                    sendToBaseResource = true;\n                }\n                else\n                    toJID =\n                        ((ContactResourceJabberImpl) toResource).getFullJid();\n            }\n\n            if (toJID == null)\n            {\n                TargetAddress ta = getJidForAddress(to.getAddress());\n                if(ta != null)\n                    toJID = ta.jid;\n            }\n\n            if (toJID == null)\n            {\n                sendToBaseResource = true;\n                toJID = to.getAddress();\n            }\n\n            Chat chat = obtainChatInstance(to.getAddress(), toJID);\n\n            msg.setPacketID(message.getMessageUID());\n            msg.setTo(toJID);\n\n            for (PacketExtension ext : extensions)\n            {\n                msg.addExtension(ext);\n            }\n\n            if (logger.isTraceEnabled())\n                logger.trace(\"Will send a message to:\" + toJID\n                            + \" chat.jid=\" + chat.getParticipant()\n                            + \" chat.tid=\" + chat.getThreadID());\n\n            MessageDeliveredEvent msgDeliveryPendingEvt\n                = new MessageDeliveredEvent(message, to, toResource);\n\n            msgDeliveryPendingEvt\n                = messageDeliveryPendingTransform(msgDeliveryPendingEvt);\n\n            if (msgDeliveryPendingEvt == null)\n                return null;\n\n            String content = msgDeliveryPendingEvt\n                                    .getSourceMessage().getContent();\n\n            if(message.getContentType().equals(HTML_MIME_TYPE))\n            {\n                msg.setBody(Html2Text.extractText(content));\n\n                // Check if the other user supports XHTML messages\n                // make sure we use our discovery manager as it caches calls\n                if(jabberProvider.isFeatureListSupported(\n                        chat.getParticipant(),\n                        HTML_NAMESPACE))\n                {\n                    // Add the XHTML text to the message\n                    XHTMLManager.addBody(msg,\n                        OPEN_BODY_TAG + content + CLOSE_BODY_TAG);\n                }\n            }\n            else\n            {\n                // this is plain text so keep it as it is.\n                msg.setBody(content);\n            }\n\n            //msg.addExtension(new Version());\n\n            if(msgDeliveryPendingEvt.isMessageEncrypted())\n            {\n                msg.addExtension(new CarbonPacketExtension.PrivateExtension());\n            }\n\n            MessageEventManager.\n                addNotificationsRequests(msg, true, false, false, true);\n\n            chat.sendMessage(msg);\n\n            putJidForAddress(to.getAddress(), toJID, chat);\n\n            MessageDeliveredEvent msgDeliveredEvt\n                = new MessageDeliveredEvent(message, to, toResource);\n\n            // msgDeliveredEvt = messageDeliveredTransform(msgDeliveredEvt);\n\n            return msgDeliveredEvt;\n        }\n        catch (XMPPException ex)\n        {\n            logger.error(\"message not sent\", ex);\n            return null;\n        }\n    }","id":23940,"modified_method":"/**\n     * Helper function used to send a message to a contact, with the given\n     * extensions attached.\n     *\n     * @param to The contact to send the message to.\n     * @param toResource The resource to send the message to or null if no\n     * resource has been specified\n     * @param message The message to send.\n     * @param extensions The XMPP extensions that should be attached to the\n     * message before sending.\n     * @return The MessageDeliveryEvent that resulted after attempting to\n     * send this message, so the calling function can modify it if needed.\n     */\n    private MessageDeliveredEvent sendMessage(  Contact to,\n                                                ContactResource toResource,\n                                                Message message,\n                                                PacketExtension[] extensions)\n    {\n        if( !(to instanceof ContactJabberImpl) )\n           throw new IllegalArgumentException(\n               \"The specified contact is not a Jabber contact.\"\n               + to);\n\n        assertConnected();\n\n        org.jivesoftware.smack.packet.Message msg =\n            new org.jivesoftware.smack.packet.Message();\n\n        String toJID = null;\n\n        if (toResource != null)\n        {\n            if(toResource.equals(ContactResource.BASE_RESOURCE))\n            {\n                toJID = to.getAddress();\n            }\n            else\n                toJID =\n                    ((ContactResourceJabberImpl) toResource).getFullJid();\n        }\n\n        if (toJID == null)\n        {\n            toJID = to.getAddress();\n        }\n\n        msg.setPacketID(message.getMessageUID());\n        msg.setTo(toJID);\n\n        for (PacketExtension ext : extensions)\n        {\n            msg.addExtension(ext);\n        }\n\n        if (logger.isTraceEnabled())\n            logger.trace(\"Will send a message to:\" + toJID\n                        + \" chat.jid=\" + toJID);\n\n        MessageDeliveredEvent msgDeliveryPendingEvt\n            = new MessageDeliveredEvent(message, to, toResource);\n\n        msgDeliveryPendingEvt\n            = messageDeliveryPendingTransform(msgDeliveryPendingEvt);\n\n        if (msgDeliveryPendingEvt == null)\n            return null;\n\n        String content = msgDeliveryPendingEvt\n                                .getSourceMessage().getContent();\n\n        if(message.getContentType().equals(HTML_MIME_TYPE))\n        {\n            msg.setBody(Html2Text.extractText(content));\n\n            // Check if the other user supports XHTML messages\n            // make sure we use our discovery manager as it caches calls\n            if(jabberProvider.isFeatureListSupported(\n                    toJID,\n                    HTML_NAMESPACE))\n            {\n                // Add the XHTML text to the message\n                XHTMLManager.addBody(msg,\n                    OPEN_BODY_TAG + content + CLOSE_BODY_TAG);\n            }\n        }\n        else\n        {\n            // this is plain text so keep it as it is.\n            msg.setBody(content);\n        }\n\n        //msg.addExtension(new Version());\n\n        if(msgDeliveryPendingEvt.isMessageEncrypted())\n        {\n            msg.addExtension(new CarbonPacketExtension.PrivateExtension());\n        }\n\n        MessageEventManager.\n            addNotificationsRequests(msg, true, false, false, true);\n\n        String threadID = getThreadIDForAddress(toJID);\n        if(threadID == null)\n            threadID = nextThreadID();\n\n        msg.setThread(threadID);\n\n        jabberProvider.getConnection().sendPacket(msg);\n\n        putJidForAddress(toJID, threadID);\n\n        MessageDeliveredEvent msgDeliveredEvt\n            = new MessageDeliveredEvent(message, to, toResource);\n\n        // msgDeliveredEvt = messageDeliveredTransform(msgDeliveredEvt);\n\n        return msgDeliveredEvt;\n    }","commit_id":"2a12abaefeb6601d1f2b4170fcdc4e810422f1a7","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * Handles incoming messages and dispatches whatever events are\n         * necessary.\n         * @param packet the packet that we need to handle (if it is a message).\n         */\n        public void processPacket(Packet packet)\n        {\n            if(!(packet instanceof org.jivesoftware.smack.packet.Message))\n                return;\n\n            org.jivesoftware.smack.packet.Message msg =\n                (org.jivesoftware.smack.packet.Message)packet;\n\n            boolean isForwardedSentMessage = false;\n            if(msg.getBody() == null)\n            {\n\n                CarbonPacketExtension carbonExt\n                    = (CarbonPacketExtension) msg.getExtension(\n                        CarbonPacketExtension.NAMESPACE);\n                if(carbonExt == null)\n                    return;\n\n                isForwardedSentMessage\n                    = (carbonExt.getElementName()\n                        == CarbonPacketExtension.SENT_ELEMENT_NAME);\n                List<ForwardedPacketExtension> extensions\n                    = carbonExt.getChildExtensionsOfType(\n                        ForwardedPacketExtension.class);\n                if(extensions.isEmpty())\n                    return;\n                ForwardedPacketExtension forwardedExt = extensions.get(0);\n                msg = forwardedExt.getMessage();\n                if(msg == null || msg.getBody() == null)\n                    return;\n\n            }\n\n            Object multiChatExtension =\n                msg.getExtension(\"x\", \"http://jabber.org/protocol/muc#user\");\n\n            // its not for us\n            if(multiChatExtension != null)\n                return;\n\n            String userFullId\n                = isForwardedSentMessage? msg.getTo() : msg.getFrom();\n\n            String userBareID = StringUtils.parseBareAddress(userFullId);\n\n            boolean isPrivateMessaging = false;\n            ChatRoom privateContactRoom = ((OperationSetMultiUserChatJabberImpl)\n                jabberProvider.getOperationSet(OperationSetMultiUserChat.class))\n                    .getChatRoom(userBareID);\n            if(privateContactRoom != null)\n            {\n                isPrivateMessaging = true;\n            }\n\n            if(logger.isDebugEnabled())\n            {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Received from \"\n                             + userBareID\n                             + \" the message \"\n                             + msg.toXML());\n            }\n\n            Message newMessage = createMessage(msg.getBody(),\n                    DEFAULT_MIME_TYPE, msg.getPacketID());\n\n            //check if the message is available in xhtml\n            PacketExtension ext = msg.getExtension(\n                            \"http://jabber.org/protocol/xhtml-im\");\n\n            if(ext != null)\n            {\n                XHTMLExtension xhtmlExt\n                    = (XHTMLExtension)ext;\n\n                //parse all bodies\n                Iterator<String> bodies = xhtmlExt.getBodies();\n                StringBuffer messageBuff = new StringBuffer();\n                while (bodies.hasNext())\n                {\n                    String body = bodies.next();\n                    messageBuff.append(body);\n                }\n\n                if (messageBuff.length() > 0)\n                {\n                    // we remove body tags around message cause their\n                    // end body tag is breaking\n                    // the visualization as html in the UI\n                    String receivedMessage =\n                        messageBuff.toString()\n                        // removes body start tag\n                        .replaceAll(\"\\\\<[bB][oO][dD][yY].*?>\",\"\")\n                        // removes body end tag\n                        .replaceAll(\"\\\\<\/[bB][oO][dD][yY].*?>\",\"\");\n\n                    // for some reason &apos; is not rendered correctly\n                    // from our ui, lets use its equivalent. Other\n                    // similar chars(< > & \") seem ok.\n                    receivedMessage =\n                            receivedMessage.replaceAll(\"&apos;\", \"&#39;\");\n\n                    newMessage = createMessage(receivedMessage,\n                            HTML_MIME_TYPE, msg.getPacketID());\n                }\n            }\n\n            PacketExtension correctionExtension =\n                    msg.getExtension(MessageCorrectionExtension.NAMESPACE);\n            String correctedMessageUID = null;\n            if (correctionExtension != null)\n            {\n                correctedMessageUID = ((MessageCorrectionExtension)\n                        correctionExtension).getCorrectedMessageUID();\n            }\n\n            Contact sourceContact\n                = opSetPersPresence.findContactByID(\n                    (isPrivateMessaging? userFullId : userBareID));\n            if(msg.getType()\n                            == org.jivesoftware.smack.packet.Message.Type.error)\n            {\n                // error which is multichat and we don't know about the contact\n                // is a muc message error which is missing muc extension\n                // and is coming from the room, when we try to send message to\n                // room which was deleted or offline on the server\n                if(isPrivateMessaging && sourceContact == null)\n                {\n                    if(privateContactRoom != null)\n                    {\n                        XMPPError error = packet.getError();\n                        int errorResultCode\n                            = ChatRoomMessageDeliveryFailedEvent.UNKNOWN_ERROR;\n\n                        if(error != null && error.getCode() == 403)\n                        {\n                            errorResultCode\n                                = ChatRoomMessageDeliveryFailedEvent.FORBIDDEN;\n                        }\n\n                        String errorReason = error.getMessage();\n\n                        ChatRoomMessageDeliveryFailedEvent evt =\n                            new ChatRoomMessageDeliveryFailedEvent(\n                                privateContactRoom,\n                                null,\n                                errorResultCode,\n                                errorReason,\n                                new Date(),\n                                newMessage);\n                        ((ChatRoomJabberImpl)privateContactRoom)\n                            .fireMessageEvent(evt);\n                    }\n\n                    return;\n                }\n\n                if (logger.isInfoEnabled())\n                    logger.info(\"Message error received from \" + userBareID);\n\n                int errorCode = packet.getError().getCode();\n                int errorResultCode = MessageDeliveryFailedEvent.UNKNOWN_ERROR;\n\n                if(errorCode == 503)\n                {\n                    org.jivesoftware.smackx.packet.MessageEvent msgEvent =\n                        (org.jivesoftware.smackx.packet.MessageEvent)\n                            packet.getExtension(\"x\", \"jabber:x:event\");\n                    if(msgEvent != null && msgEvent.isOffline())\n                    {\n                        errorResultCode =\n                            MessageDeliveryFailedEvent\n                                .OFFLINE_MESSAGES_NOT_SUPPORTED;\n                    }\n                }\n\n                MessageDeliveryFailedEvent ev\n                    = new MessageDeliveryFailedEvent(newMessage,\n                                                     sourceContact,\n                                                     correctedMessageUID,\n                                                     errorResultCode);\n\n                // ev = messageDeliveryFailedTransform(ev);\n\n                if (ev != null)\n                    fireMessageEvent(ev);\n                return;\n            }\n            //cache the jid (resource included) of the contact that's sending us\n            //a message so that all following messages would go to the resource\n            //that they contacted us from.\n            String address = userBareID;\n            if(isPrivateMessaging)\n            {\n                address = JabberActivator.getResources().getI18NString(\n                        \"service.gui.FROM\",\n                        new String[]{\n                            StringUtils.parseResource(msg.getFrom()),\n                            userBareID} );\n            }\n\n            Chat chat =\n                jabberProvider.getConnection().getChatManager()\n                    .getThreadChat(msg.getThread());\n            putJidForAddress(address, userFullId, chat);\n\n            if (logger.isTraceEnabled())\n                logger.trace(\"just mapped: \" + userBareID\n                                + \" to \" + msg.getFrom());\n\n            // In the second condition we filter all group chat messages,\n            // because they are managed by the multi user chat operation set.\n            if(sourceContact == null)\n            {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"received a message from an unknown contact: \"\n                                   + userBareID);\n                //create the volatile contact\n                sourceContact = opSetPersPresence\n                    .createVolatileContact(\n                        userFullId,\n                        isPrivateMessaging);\n            }\n\n            Date timestamp = new Date();\n            //Check for XEP-0091 timestamp (deprecated)\n            PacketExtension delay = msg.getExtension(\"x\", \"jabber:x:delay\");\n            if(delay != null && delay instanceof DelayInformation)\n            {\n                timestamp = ((DelayInformation)delay).getStamp();\n            }\n            //check for XEP-0203 timestamp\n            delay = msg.getExtension(\"delay\", \"urn:xmpp:delay\");\n            if(delay != null && delay instanceof DelayInfo)\n            {\n                timestamp = ((DelayInfo)delay).getStamp();\n            }\n\n            ContactResource resource = ((ContactJabberImpl) sourceContact)\n                    .getResourceFromJid(userFullId);\n\n            EventObject msgEvt = null;\n            if(!isForwardedSentMessage)\n                msgEvt\n                    = new MessageReceivedEvent( newMessage,\n                                                sourceContact,\n                                                resource,\n                                                timestamp,\n                                                correctedMessageUID,\n                                                isPrivateMessaging,\n                                                privateContactRoom);\n            else\n                msgEvt = new MessageDeliveredEvent(newMessage, sourceContact, timestamp);\n            // msgReceivedEvt = messageReceivedTransform(msgReceivedEvt);\n            if (msgEvt != null)\n                fireMessageEvent(msgEvt);\n        }","id":23941,"modified_method":"/**\n         * Handles incoming messages and dispatches whatever events are\n         * necessary.\n         * @param packet the packet that we need to handle (if it is a message).\n         */\n        public void processPacket(Packet packet)\n        {\n            if(!(packet instanceof org.jivesoftware.smack.packet.Message))\n                return;\n\n            org.jivesoftware.smack.packet.Message msg =\n                (org.jivesoftware.smack.packet.Message)packet;\n\n            boolean isForwardedSentMessage = false;\n            if(msg.getBody() == null)\n            {\n\n                CarbonPacketExtension carbonExt\n                    = (CarbonPacketExtension) msg.getExtension(\n                        CarbonPacketExtension.NAMESPACE);\n                if(carbonExt == null)\n                    return;\n\n                isForwardedSentMessage\n                    = (carbonExt.getElementName()\n                        == CarbonPacketExtension.SENT_ELEMENT_NAME);\n                List<ForwardedPacketExtension> extensions\n                    = carbonExt.getChildExtensionsOfType(\n                        ForwardedPacketExtension.class);\n                if(extensions.isEmpty())\n                    return;\n                ForwardedPacketExtension forwardedExt = extensions.get(0);\n                msg = forwardedExt.getMessage();\n                if(msg == null || msg.getBody() == null)\n                    return;\n\n            }\n\n            Object multiChatExtension =\n                msg.getExtension(\"x\", \"http://jabber.org/protocol/muc#user\");\n\n            // its not for us\n            if(multiChatExtension != null)\n                return;\n\n            String userFullId\n                = isForwardedSentMessage? msg.getTo() : msg.getFrom();\n\n            String userBareID = StringUtils.parseBareAddress(userFullId);\n\n            boolean isPrivateMessaging = false;\n            ChatRoom privateContactRoom = ((OperationSetMultiUserChatJabberImpl)\n                jabberProvider.getOperationSet(OperationSetMultiUserChat.class))\n                    .getChatRoom(userBareID);\n            if(privateContactRoom != null)\n            {\n                isPrivateMessaging = true;\n            }\n\n            if(logger.isDebugEnabled())\n            {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Received from \"\n                             + userBareID\n                             + \" the message \"\n                             + msg.toXML());\n            }\n\n            Message newMessage = createMessage(msg.getBody(),\n                    DEFAULT_MIME_TYPE, msg.getPacketID());\n\n            //check if the message is available in xhtml\n            PacketExtension ext = msg.getExtension(\n                            \"http://jabber.org/protocol/xhtml-im\");\n\n            if(ext != null)\n            {\n                XHTMLExtension xhtmlExt\n                    = (XHTMLExtension)ext;\n\n                //parse all bodies\n                Iterator<String> bodies = xhtmlExt.getBodies();\n                StringBuffer messageBuff = new StringBuffer();\n                while (bodies.hasNext())\n                {\n                    String body = bodies.next();\n                    messageBuff.append(body);\n                }\n\n                if (messageBuff.length() > 0)\n                {\n                    // we remove body tags around message cause their\n                    // end body tag is breaking\n                    // the visualization as html in the UI\n                    String receivedMessage =\n                        messageBuff.toString()\n                        // removes body start tag\n                        .replaceAll(\"\\\\<[bB][oO][dD][yY].*?>\",\"\")\n                        // removes body end tag\n                        .replaceAll(\"\\\\<\/[bB][oO][dD][yY].*?>\",\"\");\n\n                    // for some reason &apos; is not rendered correctly\n                    // from our ui, lets use its equivalent. Other\n                    // similar chars(< > & \") seem ok.\n                    receivedMessage =\n                            receivedMessage.replaceAll(\"&apos;\", \"&#39;\");\n\n                    newMessage = createMessage(receivedMessage,\n                            HTML_MIME_TYPE, msg.getPacketID());\n                }\n            }\n\n            PacketExtension correctionExtension =\n                    msg.getExtension(MessageCorrectionExtension.NAMESPACE);\n            String correctedMessageUID = null;\n            if (correctionExtension != null)\n            {\n                correctedMessageUID = ((MessageCorrectionExtension)\n                        correctionExtension).getCorrectedMessageUID();\n            }\n\n            Contact sourceContact\n                = opSetPersPresence.findContactByID(\n                    (isPrivateMessaging? userFullId : userBareID));\n            if(msg.getType()\n                            == org.jivesoftware.smack.packet.Message.Type.error)\n            {\n                // error which is multichat and we don't know about the contact\n                // is a muc message error which is missing muc extension\n                // and is coming from the room, when we try to send message to\n                // room which was deleted or offline on the server\n                if(isPrivateMessaging && sourceContact == null)\n                {\n                    if(privateContactRoom != null)\n                    {\n                        XMPPError error = packet.getError();\n                        int errorResultCode\n                            = ChatRoomMessageDeliveryFailedEvent.UNKNOWN_ERROR;\n\n                        if(error != null && error.getCode() == 403)\n                        {\n                            errorResultCode\n                                = ChatRoomMessageDeliveryFailedEvent.FORBIDDEN;\n                        }\n\n                        String errorReason = error.getMessage();\n\n                        ChatRoomMessageDeliveryFailedEvent evt =\n                            new ChatRoomMessageDeliveryFailedEvent(\n                                privateContactRoom,\n                                null,\n                                errorResultCode,\n                                errorReason,\n                                new Date(),\n                                newMessage);\n                        ((ChatRoomJabberImpl)privateContactRoom)\n                            .fireMessageEvent(evt);\n                    }\n\n                    return;\n                }\n\n                if (logger.isInfoEnabled())\n                    logger.info(\"Message error received from \" + userBareID);\n\n                int errorCode = packet.getError().getCode();\n                int errorResultCode = MessageDeliveryFailedEvent.UNKNOWN_ERROR;\n\n                if(errorCode == 503)\n                {\n                    org.jivesoftware.smackx.packet.MessageEvent msgEvent =\n                        (org.jivesoftware.smackx.packet.MessageEvent)\n                            packet.getExtension(\"x\", \"jabber:x:event\");\n                    if(msgEvent != null && msgEvent.isOffline())\n                    {\n                        errorResultCode =\n                            MessageDeliveryFailedEvent\n                                .OFFLINE_MESSAGES_NOT_SUPPORTED;\n                    }\n                }\n\n                MessageDeliveryFailedEvent ev\n                    = new MessageDeliveryFailedEvent(newMessage,\n                                                     sourceContact,\n                                                     correctedMessageUID,\n                                                     errorResultCode);\n\n                // ev = messageDeliveryFailedTransform(ev);\n\n                if (ev != null)\n                    fireMessageEvent(ev);\n                return;\n            }\n            putJidForAddress(userFullId, msg.getThread());\n\n            // In the second condition we filter all group chat messages,\n            // because they are managed by the multi user chat operation set.\n            if(sourceContact == null)\n            {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"received a message from an unknown contact: \"\n                                   + userBareID);\n                //create the volatile contact\n                sourceContact = opSetPersPresence\n                    .createVolatileContact(\n                        userFullId,\n                        isPrivateMessaging);\n            }\n\n            Date timestamp = new Date();\n            //Check for XEP-0091 timestamp (deprecated)\n            PacketExtension delay = msg.getExtension(\"x\", \"jabber:x:delay\");\n            if(delay != null && delay instanceof DelayInformation)\n            {\n                timestamp = ((DelayInformation)delay).getStamp();\n            }\n            //check for XEP-0203 timestamp\n            delay = msg.getExtension(\"delay\", \"urn:xmpp:delay\");\n            if(delay != null && delay instanceof DelayInfo)\n            {\n                timestamp = ((DelayInfo)delay).getStamp();\n            }\n\n            ContactResource resource = ((ContactJabberImpl) sourceContact)\n                    .getResourceFromJid(userFullId);\n\n            EventObject msgEvt = null;\n            if(!isForwardedSentMessage)\n                msgEvt\n                    = new MessageReceivedEvent( newMessage,\n                                                sourceContact,\n                                                resource,\n                                                timestamp,\n                                                correctedMessageUID,\n                                                isPrivateMessaging,\n                                                privateContactRoom);\n            else\n                msgEvt = new MessageDeliveredEvent(newMessage, sourceContact, timestamp);\n            // msgReceivedEvt = messageReceivedTransform(msgReceivedEvt);\n            if (msgEvt != null)\n                fireMessageEvent(msgEvt);\n        }","commit_id":"2a12abaefeb6601d1f2b4170fcdc4e810422f1a7","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Remove from our <tt>jids<\/tt> map all entries that have not seen any\n     * activity (i.e. neither outgoing nor incoming messags) for more than\n     * JID_INACTIVITY_TIMEOUT. Note that this method is not synchronous and that\n     * it is only meant for use by the {@link #getJidForAddress(String)} and\n     * {@link #putJidForAddress(String, String, Chat)}\n     */\n    private void purgeOldJids()\n    {\n        long currentTime = System.currentTimeMillis();\n\n        Iterator<Map.Entry<String, TargetAddress>> entries\n            = jids.entrySet().iterator();\n\n\n        while( entries.hasNext() )\n        {\n            Map.Entry<String, TargetAddress> entry = entries.next();\n            TargetAddress target = entry.getValue();\n\n            if (currentTime - target.lastUpdatedTime\n                            > JID_INACTIVITY_TIMEOUT)\n                entries.remove();\n        }\n    }","id":23942,"modified_method":"/**\n     * Remove from our <tt>jids<\/tt> map all entries that have not seen any\n     * activity (i.e. neither outgoing nor incoming messags) for more than\n     * JID_INACTIVITY_TIMEOUT. Note that this method is not synchronous and that\n     * it is only meant for use by the {@link #getThreadIDForAddress(String)} and\n     * {@link #putJidForAddress(String, String, Chat)}\n     */\n    private void purgeOldJids()\n    {\n        long currentTime = System.currentTimeMillis();\n\n        Iterator<Map.Entry<String, StoredThreadID>> entries\n            = jids.entrySet().iterator();\n\n\n        while( entries.hasNext() )\n        {\n            Map.Entry<String, StoredThreadID> entry = entries.next();\n            StoredThreadID target = entry.getValue();\n\n            if (currentTime - target.lastUpdatedTime\n                            > JID_INACTIVITY_TIMEOUT)\n                entries.remove();\n        }\n    }","commit_id":"2a12abaefeb6601d1f2b4170fcdc4e810422f1a7","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the last jid that the party with the specified <tt>address<\/tt>\n     * contacted us from or <tt>null<\/tt>(or bare jid) if we don't have a jid\n     * for the specified <tt>address<\/tt> yet. The method would also purge all\n     * entries that haven't seen any activity (i.e. no one has tried to get or\n     * remap it) for a delay longer than <tt>JID_INACTIVITY_TIMEOUT<\/tt>.\n     *\n     * @param address the <tt>address<\/tt> that we'd like to obtain a jid for.\n     *\n     * @return the last jid that the party with the specified <tt>address<\/tt>\n     * contacted us from or <tt>null<\/tt> if we don't have a jid for the\n     * specified <tt>address<\/tt> yet.\n     */\n    TargetAddress getJidForAddress(String address)\n    {\n        synchronized(jids)\n        {\n            purgeOldJids();\n            TargetAddress ta = jids.get(address);\n\n            if (ta == null)\n                return null;\n\n            ta.lastUpdatedTime = System.currentTimeMillis();\n\n            return ta;\n        }\n    }","id":23943,"modified_method":"public String getRecentJIDForAddress(String address)\n    {\n        return recentJIDForAddress.get(address);\n    }","commit_id":"2a12abaefeb6601d1f2b4170fcdc4e810422f1a7","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Determines whether the protocol supports the supplied content type\n     * for the given contact.\n     *\n     * @param contentType the type we want to check\n     * @param contact contact which is checked for supported contentType\n     * @return <tt>true<\/tt> if the contact supports it and\n     * <tt>false<\/tt> otherwise.\n     */\n    @Override\n    public boolean isContentTypeSupported(String contentType, Contact contact)\n    {\n        // by default we support default mime type, for other mimetypes\n        // method must be overriden\n        if(contentType.equals(DEFAULT_MIME_TYPE))\n            return true;\n        else if(contentType.equals(HTML_MIME_TYPE))\n        {\n            String toJID = null;\n\n            TargetAddress ta = getJidForAddress(contact.getAddress());\n            if(ta != null)\n                toJID = ta.jid;\n\n            if (toJID == null)\n                toJID = contact.getAddress();\n\n            return jabberProvider.isFeatureListSupported(\n                        toJID,\n                        HTML_NAMESPACE);\n        }\n\n        return false;\n    }","id":23944,"modified_method":"/**\n     * Determines whether the protocol supports the supplied content type\n     * for the given contact.\n     *\n     * @param contentType the type we want to check\n     * @param contact contact which is checked for supported contentType\n     * @return <tt>true<\/tt> if the contact supports it and\n     * <tt>false<\/tt> otherwise.\n     */\n    @Override\n    public boolean isContentTypeSupported(String contentType, Contact contact)\n    {\n        // by default we support default mime type, for other mimetypes\n        // method must be overriden\n        if(contentType.equals(DEFAULT_MIME_TYPE))\n            return true;\n        else if(contentType.equals(HTML_MIME_TYPE))\n        {\n            String toJID = recentJIDForAddress.get(contact.getAddress());\n\n            if (toJID == null)\n                toJID = contact.getAddress();\n\n            return jabberProvider.isFeatureListSupported(\n                        toJID,\n                        HTML_NAMESPACE);\n        }\n\n        return false;\n    }","commit_id":"2a12abaefeb6601d1f2b4170fcdc4e810422f1a7","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Maps the specified <tt>address<\/tt> to <tt>jid<\/tt>. The point of this\n     * method is to allow us to send all messages destined to the contact with\n     * the specified <tt>address<\/tt> to the <tt>jid<\/tt> that they last\n     * contacted us from.\n     *\n     * @param address the bare address (i.e. no resource included) of the\n     * contact that we'd like to set a jid for.\n     * @param jid the jid (i.e. address/resource) that the contact with the\n     * specified <tt>address<\/tt> last contacted us from.\n     */\n    private void putJidForAddress(String address, String jid, Chat chat)\n    {\n        synchronized(jids)\n        {\n            purgeOldJids();\n\n            TargetAddress ta = jids.get(address);\n\n            if (ta == null)\n            {\n                ta = new TargetAddress();\n                jids.put(address, ta);\n            }\n\n            ta.jid = jid;\n            ta.lastUpdatedTime = System.currentTimeMillis();\n            ta.chat = chat;\n        }\n    }","id":23945,"modified_method":"/**\n     * Maps the specified <tt>address<\/tt> to <tt>jid<\/tt>. The point of this\n     * method is to allow us to send all messages destined to the contact with\n     * the specified <tt>address<\/tt> to the <tt>jid<\/tt> that they last\n     * contacted us from.\n     *\n     * @param address the bare address (i.e. no resource included) of the\n     * contact that we'd like to set a jid for.\n     * @param jid the jid (i.e. address/resource) that the contact with the\n     * specified <tt>address<\/tt> last contacted us from.\n     */\n    private void putJidForAddress(String jid, String threadID)\n    {\n        synchronized(jids)\n        {\n            purgeOldJids();\n\n            StoredThreadID ta = jids.get(jid);\n\n            if (ta == null)\n            {\n                ta = new StoredThreadID();\n                jids.put(jid, ta);\n            }\n\n            recentJIDForAddress.put(StringUtils.parseBareAddress(jid), jid);\n\n            ta.lastUpdatedTime = System.currentTimeMillis();\n            ta.threadID = threadID;\n        }\n    }","commit_id":"2a12abaefeb6601d1f2b4170fcdc4e810422f1a7","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Converts <tt>state<\/tt> into the corresponding smack <tt>ChatState<\/tt>\n     * and sends it to contact.\n     *\n     * @param contact the contact that we'd like to send our state to.\n     * @param state the state we'd like to sent.\n     */\n    private void sendXep85ChatState(Contact contact, int state)\n    {\n        if(opSetBasicIM == null\n            || parentProvider.getConnection() == null)\n            return;\n\n        String toJID = null;\n\n        // find the currently contacted jid to send typing info to him\n        // or if we do not have a jid and we have already sent message to the\n        // bare jid we will also send typing info there\n        OperationSetBasicInstantMessagingJabberImpl.TargetAddress ta\n            = opSetBasicIM.getJidForAddress(contact.getAddress());\n        if (ta != null)\n            toJID = ta.jid;\n\n        // if we haven't sent a message yet, do not send typing notifications\n        if(toJID == null)\n            return;\n\n        if (logger.isTraceEnabled())\n            logger.trace(\"Sending XEP-0085 chat state=\" + state\n                + \" to \" + toJID);\n\n        Chat chat;\n\n        if(ta != null && ta.chat != null)\n            chat = ta.chat;\n        else\n            chat = parentProvider.getConnection()\n                .getChatManager().createChat(toJID, null);\n\n        ChatState chatState = null;\n\n        if(state == STATE_TYPING)\n        {\n            chatState = ChatState.composing;\n        }\n        else if(state == STATE_STOPPED)\n        {\n            chatState = ChatState.inactive;\n        }\n        else if(state == STATE_PAUSED)\n        {\n            chatState = ChatState.paused;\n        }\n        else\n        {\n            chatState = ChatState.gone;\n        }\n\n        try\n        {\n            ChatStateManager.getInstance(parentProvider.getConnection())\n                .setCurrentState(chatState, chat);\n        }\n        catch(XMPPException exc)\n        {\n            //we don't want to bother the user with network exceptions\n            //so let's simply log it.\n            logger.warn(\"Failed to send state [\" + state + \"] to [\"\n                + contact.getAddress() + \"].\", exc);\n        }\n    }","id":23946,"modified_method":"/**\n     * Converts <tt>state<\/tt> into the corresponding smack <tt>ChatState<\/tt>\n     * and sends it to contact.\n     *\n     * @param contact the contact that we'd like to send our state to.\n     * @param state the state we'd like to sent.\n     */\n    private void sendXep85ChatState(Contact contact, int state)\n    {\n        if(opSetBasicIM == null\n            || parentProvider.getConnection() == null)\n            return;\n\n        String toJID = opSetBasicIM.getRecentJIDForAddress(contact.getAddress());\n\n        // find the currently contacted jid to send typing info to him\n        // or if we do not have a jid and we have already sent message to the\n        // bare jid we will also send typing info there\n\n\n        // if we haven't sent a message yet, do not send typing notifications\n        if(toJID == null)\n            return;\n\n        if (logger.isTraceEnabled())\n            logger.trace(\"Sending XEP-0085 chat state=\" + state\n                + \" to \" + toJID);\n\n\n        ChatState chatState = null;\n\n        if(state == STATE_TYPING)\n        {\n            chatState = ChatState.composing;\n        }\n        else if(state == STATE_STOPPED)\n        {\n            chatState = ChatState.inactive;\n        }\n        else if(state == STATE_PAUSED)\n        {\n            chatState = ChatState.paused;\n        }\n        else\n        {\n            chatState = ChatState.gone;\n        }\n\n        setCurrentState(chatState, toJID);\n    }","commit_id":"2a12abaefeb6601d1f2b4170fcdc4e810422f1a7","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * Called by smack when the state of a chat changes.\n         *\n         * @param chat the chat that is concerned by this event.\n         * @param state the new state of the chat.\n         * @param message the message containing the new chat state\n         */\n        public void stateChanged(Chat chat,\n                                 ChatState state,\n                                 org.jivesoftware.smack.packet.Message message)\n        {\n            if (logger.isTraceEnabled())\n                logger.trace(chat.getParticipant() + \" entered the \"\n                + state.name()+ \" state.\");\n\n            String fromID = StringUtils.parseBareAddress(chat.getParticipant());\n\n            List<ChatRoom> chatRooms = parentProvider.getOperationSet(\n                OperationSetMultiUserChat.class).getCurrentlyJoinedChatRooms();\n            boolean isPrivateMessagingAddress = false;\n            for(ChatRoom chatRoom : chatRooms)\n            {\n                if(chatRoom.getName().equals(fromID))\n                {\n                    isPrivateMessagingAddress = true;\n                    break;\n                }\n            }\n\n            Contact sourceContact = opSetPersPresence.findContactByID(\n                (isPrivateMessagingAddress? message.getFrom() : fromID));\n            if(sourceContact == null)\n            {\n                // in private messaging we can receive some errors\n                // when we left room (isPrivateMessagingAddress == false)\n                // and we try to send some message\n                if(message.getError() != null)\n                    sourceContact = opSetPersPresence.findContactByID(\n                        message.getFrom());\n\n                if(sourceContact == null)\n                {\n                    //create the volatile contact\n                    sourceContact = opSetPersPresence.createVolatileContact(\n                        (isPrivateMessagingAddress? message.getFrom() : \n                            chat.getParticipant()), isPrivateMessagingAddress);\n                }\n            }\n\n            int evtCode = STATE_UNKNOWN;\n\n            if (ChatState.composing.equals(state))\n            {\n                evtCode = STATE_TYPING;\n            }\n            else if (ChatState.paused.equals(state)\n                || ChatState.active.equals(state) )\n            {\n                evtCode = STATE_PAUSED;\n            }\n            else if (ChatState.inactive.equals(state)\n                || ChatState.gone.equals(state) )\n            {\n                evtCode = STATE_STOPPED;\n            }\n\n            if(message.getError() != null)\n                fireTypingNotificationsDeliveryFailedEvent(\n                    sourceContact, evtCode);\n            else  if(evtCode != STATE_UNKNOWN)\n                fireTypingNotificationsEvent(sourceContact, evtCode);\n            else\n                logger.warn(\"Unknown typing state!\");\n        }","id":23947,"modified_method":"/**\n         * Called by smack when the state of a chat changes.\n         *\n         * @param chat the chat that is concerned by this event.\n         * @param state the new state of the chat.\n         * @param message the message containing the new chat state\n         */\n        public void stateChanged(ChatState state,\n                                 org.jivesoftware.smack.packet.Message message)\n        {\n            String fromJID = message.getFrom();\n            if (logger.isTraceEnabled())\n                logger.trace(fromJID + \" entered the \"\n                + state.name()+ \" state.\");\n\n\n            String fromID = StringUtils.parseBareAddress(fromJID);\n\n            List<ChatRoom> chatRooms = parentProvider.getOperationSet(\n                OperationSetMultiUserChat.class).getCurrentlyJoinedChatRooms();\n            boolean isPrivateMessagingAddress = false;\n            for(ChatRoom chatRoom : chatRooms)\n            {\n                if(chatRoom.getName().equals(fromID))\n                {\n                    isPrivateMessagingAddress = true;\n                    break;\n                }\n            }\n\n            Contact sourceContact = opSetPersPresence.findContactByID(\n                (isPrivateMessagingAddress? message.getFrom() : fromID));\n            if(sourceContact == null)\n            {\n                // in private messaging we can receive some errors\n                // when we left room (isPrivateMessagingAddress == false)\n                // and we try to send some message\n                if(message.getError() != null)\n                    sourceContact = opSetPersPresence.findContactByID(\n                        message.getFrom());\n\n                if(sourceContact == null)\n                {\n                    //create the volatile contact\n                    sourceContact = opSetPersPresence.createVolatileContact(\n                        message.getFrom(), isPrivateMessagingAddress);\n                }\n            }\n\n            int evtCode = STATE_UNKNOWN;\n\n            if (ChatState.composing.equals(state))\n            {\n                evtCode = STATE_TYPING;\n            }\n            else if (ChatState.paused.equals(state)\n                || ChatState.active.equals(state) )\n            {\n                evtCode = STATE_PAUSED;\n            }\n            else if (ChatState.inactive.equals(state)\n                || ChatState.gone.equals(state) )\n            {\n                evtCode = STATE_STOPPED;\n            }\n\n            if(message.getError() != null)\n                fireTypingNotificationsDeliveryFailedEvent(\n                    sourceContact, evtCode);\n            else  if(evtCode != STATE_UNKNOWN)\n                fireTypingNotificationsEvent(sourceContact, evtCode);\n            else\n                logger.warn(\"Unknown typing state!\");\n        }","commit_id":"2a12abaefeb6601d1f2b4170fcdc4e810422f1a7","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * The method is called by a ProtocolProvider implementation whenver\n         * a change in the registration state of the corresponding provider had\n         * occurred.\n         * @param evt ProviderStatusChangeEvent the event describing the status\n         * change.\n         */\n        public void registrationStateChanged(RegistrationStateChangeEvent evt)\n        {\n            if (logger.isDebugEnabled())\n                logger.debug(\"The provider changed state from: \"\n                         + evt.getOldState()\n                         + \" to: \" + evt.getNewState());\n            if (evt.getNewState() == RegistrationState.REGISTERED)\n            {\n                opSetPersPresence =\n                    (OperationSetPersistentPresenceJabberImpl) parentProvider\n                        .getOperationSet(OperationSetPersistentPresence.class);\n\n                opSetBasicIM =\n                    (OperationSetBasicInstantMessagingJabberImpl)parentProvider\n                        .getOperationSet(\n                            OperationSetBasicInstantMessaging.class);\n\n                messageEventManager =\n                    new MessageEventManager(parentProvider.getConnection());\n\n                messageEventManager.addMessageEventRequestListener(\n                    new JabberMessageEventRequestListener());\n                messageEventManager.addMessageEventNotificationListener(\n                    new IncomingMessageEventsListener());\n\n                //according to the smack api documentation we need to do this\n                //every time we connect in order to reinitialize the chat state\n                //manager (@see http://tinyurl.com/6j9uqs )\n\n                ChatStateManager.getInstance(parentProvider.getConnection());\n\n                if(smackChatManagerListener == null)\n                    smackChatManagerListener = new SmackChatManagerListener();\n\n                parentProvider.getConnection().getChatManager()\n                    .addChatListener(smackChatManagerListener);\n            }\n            else if(evt.getNewState() == RegistrationState.UNREGISTERED\n                 || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED\n                 || evt.getNewState() == RegistrationState.CONNECTION_FAILED)\n            {\n                if(parentProvider.getConnection() != null\n                    && parentProvider.getConnection().getChatManager() != null)\n                {\n                    parentProvider.getConnection().getChatManager()\n                        .removeChatListener(smackChatManagerListener);\n                }\n\n                smackChatManagerListener = null;\n\n                if(messageEventManager != null)\n                {\n                    messageEventManager.destroy();\n                    messageEventManager = null;\n                }\n            }\n        }","id":23948,"modified_method":"/**\n         * The method is called by a ProtocolProvider implementation whenver\n         * a change in the registration state of the corresponding provider had\n         * occurred.\n         * @param evt ProviderStatusChangeEvent the event describing the status\n         * change.\n         */\n        public void registrationStateChanged(RegistrationStateChangeEvent evt)\n        {\n            if (logger.isDebugEnabled())\n                logger.debug(\"The provider changed state from: \"\n                         + evt.getOldState()\n                         + \" to: \" + evt.getNewState());\n            if (evt.getNewState() == RegistrationState.REGISTERED)\n            {\n                opSetPersPresence =\n                    (OperationSetPersistentPresenceJabberImpl) parentProvider\n                        .getOperationSet(OperationSetPersistentPresence.class);\n\n                opSetBasicIM =\n                    (OperationSetBasicInstantMessagingJabberImpl)parentProvider\n                        .getOperationSet(\n                            OperationSetBasicInstantMessaging.class);\n\n                messageEventManager =\n                    new MessageEventManager(parentProvider.getConnection());\n\n                messageEventManager.addMessageEventRequestListener(\n                    new JabberMessageEventRequestListener());\n                messageEventManager.addMessageEventNotificationListener(\n                    new IncomingMessageEventsListener());\n\n\n                if(smackChatStateListener == null)\n                    smackChatStateListener = new SmackChatStateListener();\n\n                parentProvider.getConnection().addPacketListener(\n                    smackChatStateListener, new PacketTypeFilter(Message.class));\n\n\n\n            }\n            else if(evt.getNewState() == RegistrationState.UNREGISTERED\n                 || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED\n                 || evt.getNewState() == RegistrationState.CONNECTION_FAILED)\n            {\n                if(parentProvider.getConnection() != null)\n                {\n                    parentProvider.getConnection()\n                        .removePacketListener(smackChatStateListener);\n                }\n\n                smackChatStateListener = null;\n\n                if(messageEventManager != null)\n                {\n                    messageEventManager.destroy();\n                    messageEventManager = null;\n                }\n            }\n        }","commit_id":"2a12abaefeb6601d1f2b4170fcdc4e810422f1a7","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * Overrides <tt>newMailReceived<\/tt> from <tt>SessionAdapter<\/tt>,\n         * called when yahoo alert us that there is a new message in our mailbox.\n         *\n         * @param ev Event with information on the received email\n         */\n         public void newMailReceived(SessionNewMailEvent ev)\n         {\n             String myEmail = yahooProvider.getAccountID().getAccountAddress();\n             \n             // this was intended to obtain the user server i.e. mail.yahoo.com,\n             // or mail.yahoo.fr so that the login page is in the preferred user\n             // language. but it always gives yahoo.com, even if the account\n             // is registered with yahoo.fr ...\n             // perhaps because the pps always login on yahoo.com ?\n             String yahooMailLogon = \"http://mail.\"\n                     + myEmail.substring(myEmail.indexOf(\"@\") + 1);\n\n             yahooMailLogon = \"<a href=\\\"\"\n                     + yahooMailLogon + \"\\\">\"\n                     + yahooMailLogon + \"<\/a>\";\n\n             String newMail = \"<b>\" + Resources.getString(\"newMail\") + \" : <\/b> \"\n                     + ev.getSubject();\n\n             newMail += \"\\n<br /><b>\" + Resources.getString(\"from\") + \" : <\/b> \"\n                     + ev.getFrom() + \" &lt;\" + ev.getEmailAddress() + \"&gt;\";\n\n             newMail += \"\\n<br />&nbsp;&nbsp;&nbsp;&nbsp;\" + yahooMailLogon;\n\n             Message newMailMessage = new MessageYahooImpl(\n                     newMail,\n                     CONTENT_TYPE_HTML,\n                     DEFAULT_MIME_ENCODING,\n                     null);\n\n             Contact sourceContact = opSetPersPresence.\n                 findContactByID(ev.getEmailAddress());\n\n             if (sourceContact == null)\n             {\n                 logger.debug(\"received a new mail from an unknown contact: \"\n                                    + ev.getFrom());\n                 //create the volatile contact\n                 sourceContact = opSetPersPresence\n                     .createVolatileContact(ev.getEmailAddress());\n             }\n             MessageReceivedEvent msgReceivedEvt\n                 = new MessageReceivedEvent(\n                     newMailMessage, sourceContact, new Date(),\n                     MessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED);\n\n             fireMessageEvent(msgReceivedEvt);\n         }","id":23949,"modified_method":"/**\n         * Overrides <tt>newMailReceived<\/tt> from <tt>SessionAdapter<\/tt>,\n         * called when yahoo alert us that there is a new message in our mailbox.\n         * There is two types of notification, the first one provides only\n         * the number of unread mails and the second gives informations about\n         * a precise new mail. Here, we care about only the second case in which\n         * we should always have the email of the sender of the mail.\n         *\n         * @param ev Event with information on the received email\n         */\n         public void newMailReceived(SessionNewMailEvent ev)\n         {\n             String myEmail = yahooProvider.getAccountID().getAccountAddress();\n\n             // we don't process incoming event without email.\n             if ((ev.getEmailAddress() == null)\n                    || (ev.getEmailAddress().indexOf('@') < 0))\n             {\n                 return;\n             }\n\n             // this was intended to obtain the user server i.e. mail.yahoo.com,\n             // or mail.yahoo.fr so that the login page is in the preferred user\n             // language. but it always gives yahoo.com, even if the account\n             // is registered with yahoo.fr ...\n             // perhaps because the pps always login on yahoo.com ?\n             String yahooMailLogon = \"http://mail.\"\n                     + myEmail.substring(myEmail.indexOf(\"@\") + 1);\n\n             yahooMailLogon = \"<a href=\\\"\"\n                     + yahooMailLogon + \"\\\">\"\n                     + yahooMailLogon + \"<\/a>\";\n\n             String newMail = \"<b>\" + Resources.getString(\"newMail\") + \" : <\/b> \"\n                     + ev.getSubject();\n\n             newMail += \"\\n<br /><b>\" + Resources.getString(\"from\") + \" : <\/b> \"\n                     + ev.getFrom() + \" &lt;\" + ev.getEmailAddress() + \"&gt;\";\n\n             newMail += \"\\n<br />&nbsp;&nbsp;&nbsp;&nbsp;\" + yahooMailLogon;\n\n             Message newMailMessage = new MessageYahooImpl(\n                     newMail,\n                     CONTENT_TYPE_HTML,\n                     DEFAULT_MIME_ENCODING,\n                     null);\n\n             Contact sourceContact = opSetPersPresence.\n                 findContactByID(ev.getEmailAddress());\n\n             if (sourceContact == null)\n             {\n                 logger.debug(\"received a new mail from an unknown contact: \"\n                                    + ev.getFrom()\n                                    + \" &lt;\" + ev.getEmailAddress() + \"&gt;\");\n                 //create the volatile contact\n                 sourceContact = opSetPersPresence\n                     .createVolatileContact(ev.getEmailAddress());\n             }\n             MessageReceivedEvent msgReceivedEvt\n                 = new MessageReceivedEvent(\n                     newMailMessage, sourceContact, new Date(),\n                     MessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED);\n\n             fireMessageEvent(msgReceivedEvt);\n         }","commit_id":"0a4ac6847bd9d402d6250615d80e475a6cda4d6c","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Test\n    @UsingDataSet(locations = \"EsIndexRangeServiceTest.json\", loadStrategy = LoadStrategyEnum.CLEAN_INSERT)\n    public void destroyAllKillsAllIndexRanges() throws Exception {\n        indexRangeService.destroyAll();\n        // Refresh indices\n        final RefreshRequest refreshRequest = client.admin().indices().prepareRefresh().request();\n        final RefreshResponse refreshResponse = client.admin().indices().refresh(refreshRequest).actionGet();\n        assumeTrue(refreshResponse.getFailedShards() == 0);\n\n        assertThat(indexRangeService.getFrom(0)).isEmpty();\n    }","id":23950,"modified_method":"@Test\n    @UsingDataSet(locations = \"EsIndexRangeServiceTest.json\", loadStrategy = LoadStrategyEnum.CLEAN_INSERT)\n    public void destroyAllKillsAllIndexRanges() throws Exception {\n        indexRangeService.destroyAll();\n        // Refresh indices\n        final RefreshRequest refreshRequest = client.admin().indices().prepareRefresh().request();\n        final RefreshResponse refreshResponse = client.admin().indices().refresh(refreshRequest).actionGet();\n        assumeTrue(refreshResponse.getFailedShards() == 0);\n\n        assertThat(indexRangeService.findAll()).isEmpty();\n    }","commit_id":"df174437fc2649fee7e6cd7c4a2bd890aea35fd8","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    @UsingDataSet(locations = \"EsIndexRangeServiceTest.json\", loadStrategy = LoadStrategyEnum.CLEAN_INSERT)\n    public void destroyRemovesIndexRange() throws Exception {\n        indexRangeService.destroy(\"graylog_1\");\n\n        Set<IndexRange> indexRanges = indexRangeService.getFrom(0);\n\n        assertThat(indexRanges).hasSize(1);\n        assertThat(indexRanges.iterator().next().indexName()).isEqualTo(\"graylog_2\");\n    }","id":23951,"modified_method":"@Test\n    @UsingDataSet(locations = \"EsIndexRangeServiceTest.json\", loadStrategy = LoadStrategyEnum.CLEAN_INSERT)\n    public void destroyRemovesIndexRange() throws Exception {\n        indexRangeService.destroy(\"graylog_1\");\n\n        Set<IndexRange> indexRanges = indexRangeService.findAll();\n\n        assertThat(indexRanges).hasSize(1);\n        assertThat(indexRanges.iterator().next().indexName()).isEqualTo(\"graylog_2\");\n    }","commit_id":"df174437fc2649fee7e6cd7c4a2bd890aea35fd8","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public static Set<String> determineAffectedIndices(IndexRangeService indexRangeService,\n                                                       Deflector deflector,\n                                                       TimeRange range) {\n        Set<String> indices = Sets.newHashSet();\n\n        for (IndexRange indexRange : indexRangeService.getFrom((int) (range.getFrom().getMillis() / 1000))) {\n            indices.add(indexRange.indexName());\n        }\n\n        // Always include the most recent index in some cases.\n        final String targetIndex = deflector.getCurrentActualTargetIndex();\n        if (targetIndex != null && (indices.isEmpty() || range instanceof RelativeRange)) {\n            indices.add(targetIndex);\n        }\n\n        return indices;\n    }","id":23952,"modified_method":"public static Set<String> determineAffectedIndices(IndexRangeService indexRangeService,\n                                                       Deflector deflector,\n                                                       TimeRange range) {\n        Set<String> indices = Sets.newHashSet();\n\n        for (IndexRange indexRange : indexRangeService.find(range.getFrom(), range.getTo())) {\n            indices.add(indexRange.indexName());\n        }\n\n        // Always include the most recent index in some cases.\n        final String targetIndex = deflector.getCurrentActualTargetIndex();\n        if (targetIndex != null && (indices.isEmpty() || range instanceof RelativeRange)) {\n            indices.add(targetIndex);\n        }\n\n        return indices;\n    }","commit_id":"df174437fc2649fee7e6cd7c4a2bd890aea35fd8","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public static Set<IndexRange> determineAffectedIndicesWithRanges(IndexRangeService indexRangeService,\n                                                                     Deflector deflector,\n                                                                     TimeRange range) {\n        Set<IndexRange> indices = Sets.newTreeSet(IndexRange.COMPARATOR);\n\n        for (IndexRange indexRange : indexRangeService.getFrom((int) (range.getFrom().getMillis() / 1000))) {\n            indices.add(indexRange);\n        }\n\n        // Always include the most recent index in some cases.\n        final String targetIndex = deflector.getCurrentActualTargetIndex();\n        if (targetIndex != null && (indices.isEmpty() || range instanceof RelativeRange)) {\n            try {\n                final IndexRange deflectorIndexRange = indexRangeService.get(targetIndex);\n                indices.add(deflectorIndexRange);\n            } catch (NotFoundException e) {\n                LOG.warn(\"Couldn't find latest deflector target index\", e);\n            }\n        }\n\n        return indices;\n    }","id":23953,"modified_method":"public static Set<IndexRange> determineAffectedIndicesWithRanges(IndexRangeService indexRangeService,\n                                                                     Deflector deflector,\n                                                                     TimeRange range) {\n        Set<IndexRange> indices = Sets.newTreeSet(IndexRange.COMPARATOR);\n\n        for (IndexRange indexRange : indexRangeService.find(range.getFrom(), range.getTo())) {\n            indices.add(indexRange);\n        }\n\n        // Always include the most recent index in some cases.\n        final String targetIndex = deflector.getCurrentActualTargetIndex();\n        if (targetIndex != null && (indices.isEmpty() || range instanceof RelativeRange)) {\n            try {\n                final IndexRange deflectorIndexRange = indexRangeService.get(targetIndex);\n                indices.add(deflectorIndexRange);\n            } catch (NotFoundException e) {\n                LOG.warn(\"Couldn't find latest deflector target index\", e);\n            }\n        }\n\n        return indices;\n    }","commit_id":"df174437fc2649fee7e6cd7c4a2bd890aea35fd8","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@GET\n    @Timed\n    @ApiOperation(value = \"Get a list of all index ranges\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public IndexRangesResponse list() {\n        final List<IndexRange> ranges = Lists.newArrayList();\n        for (IndexRange range : indexRangeService.getFrom(0)) {\n            if (!isPermitted(RestPermissions.INDEXRANGES_READ, range.indexName())) {\n                continue;\n            }\n            ranges.add(range);\n        }\n\n        return IndexRangesResponse.create(ranges.size(), ranges);\n    }","id":23954,"modified_method":"@GET\n    @Timed\n    @ApiOperation(value = \"Get a list of all index ranges\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public IndexRangesResponse list() {\n        final List<IndexRange> ranges = Lists.newArrayList();\n        for (IndexRange range : indexRangeService.findAll()) {\n            if (!isPermitted(RestPermissions.INDEXRANGES_READ, range.indexName())) {\n                continue;\n            }\n            ranges.add(range);\n        }\n\n        return IndexRangesResponse.create(ranges.size(), ranges);\n    }","commit_id":"df174437fc2649fee7e6cd7c4a2bd890aea35fd8","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    @UsingDataSet(locations = \"IndexRangeServiceImplTest.json\", loadStrategy = LoadStrategyEnum.CLEAN_INSERT)\n    public void destroyRemovesIndexRange() throws Exception {\n        indexRangeService.destroy(\"graylog_1\");\n\n        Set<IndexRange> indexRanges = indexRangeService.getFrom(0);\n\n        assertThat(indexRanges).hasSize(1);\n        assertThat(indexRanges.iterator().next().indexName()).isEqualTo(\"graylog_2\");\n    }","id":23955,"modified_method":"@Test\n    @UsingDataSet(locations = \"IndexRangeServiceImplTest.json\", loadStrategy = LoadStrategyEnum.CLEAN_INSERT)\n    public void destroyRemovesIndexRange() throws Exception {\n        indexRangeService.destroy(\"graylog_1\");\n\n        Set<IndexRange> indexRanges = indexRangeService.findAll();\n\n        assertThat(indexRanges).hasSize(1);\n        assertThat(indexRanges.iterator().next().indexName()).isEqualTo(\"graylog_2\");\n    }","commit_id":"df174437fc2649fee7e6cd7c4a2bd890aea35fd8","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    @UsingDataSet(locations = \"IndexRangeServiceImplTest.json\", loadStrategy = LoadStrategyEnum.CLEAN_INSERT)\n    public void destroyAllKillsAllIndexRanges() throws Exception {\n        indexRangeService.destroyAll();\n\n        assertThat(indexRangeService.getFrom(0)).isEmpty();\n    }","id":23956,"modified_method":"@Test\n    @UsingDataSet(locations = \"IndexRangeServiceImplTest.json\", loadStrategy = LoadStrategyEnum.CLEAN_INSERT)\n    public void destroyAllKillsAllIndexRanges() throws Exception {\n        indexRangeService.destroyAll();\n\n        assertThat(indexRangeService.findAll()).isEmpty();\n    }","commit_id":"df174437fc2649fee7e6cd7c4a2bd890aea35fd8","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        when(indexRangeService.getFrom(anyInt())).thenReturn(INDEX_RANGES);\n        metricRegistry = new MetricRegistry();\n        searches = new Searches(new Configuration(), deflector, indexRangeService, client, metricRegistry);\n    }","id":23957,"modified_method":"@Before\n    public void setUp() throws Exception {\n        when(indexRangeService.find(any(DateTime.class), any(DateTime.class))).thenReturn(INDEX_RANGES);\n        metricRegistry = new MetricRegistry();\n        searches = new Searches(new Configuration(), deflector, indexRangeService, client, metricRegistry);\n    }","commit_id":"df174437fc2649fee7e6cd7c4a2bd890aea35fd8","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private static Library createPubListPackageDirsLibrary(@NotNull final Project project,\n                                                         @NotNull final Collection<String> rootsToAddToLib,\n                                                         @NotNull final Map<String, List<File>> packageMap) {\n    Library library = ProjectLibraryTable.getInstance(project).getLibraryByName(PUB_LIST_PACKAGE_DIRS_LIB_NAME);\n    if (library == null) {\n      final LibraryTableBase.ModifiableModelEx libTableModel =\n        (LibraryTableBase.ModifiableModelEx)ProjectLibraryTable.getInstance(project).getModifiableModel();\n      library = libTableModel.createLibrary(PUB_LIST_PACKAGE_DIRS_LIB_NAME, DartListPackageDirsLibraryType.LIBRARY_KIND);\n      libTableModel.commit();\n    }\n\n    final LibraryEx.ModifiableModelEx libModel = (LibraryEx.ModifiableModelEx)library.getModifiableModel();\n    try {\n      for (String url : libModel.getUrls(OrderRootType.CLASSES)) {\n        libModel.removeRoot(url, OrderRootType.CLASSES);\n      }\n\n      for (String packageDir : rootsToAddToLib) {\n        libModel.addRoot(VfsUtilCore.pathToUrl(packageDir), OrderRootType.CLASSES);\n      }\n\n      final DartListPackageDirsLibraryProperties libraryProperties = new DartListPackageDirsLibraryProperties();\n      libraryProperties.setPackageNameToFileDirsMap(packageMap);\n      libModel.setProperties(libraryProperties);\n      libModel.commit();\n    }\n    finally {\n      if (!Disposer.isDisposed(libModel)) {\n        Disposer.dispose(libModel);\n      }\n    }\n    return library;\n  }","id":23958,"modified_method":"private static Library createPubListPackageDirsLibrary(@NotNull final Project project,\n                                                         @NotNull final Collection<String> rootsToAddToLib,\n                                                         @NotNull final Map<String, List<File>> packageMap) {\n    Library library = ProjectLibraryTable.getInstance(project).getLibraryByName(PUB_LIST_PACKAGE_DIRS_LIB_NAME);\n    if (library == null) {\n      final LibraryTableBase.ModifiableModel libTableModel = ProjectLibraryTable.getInstance(project).getModifiableModel();\n      library = libTableModel.createLibrary(PUB_LIST_PACKAGE_DIRS_LIB_NAME, DartListPackageDirsLibraryType.LIBRARY_KIND);\n      libTableModel.commit();\n    }\n\n    final LibraryEx.ModifiableModelEx libModel = (LibraryEx.ModifiableModelEx)library.getModifiableModel();\n    try {\n      for (String url : libModel.getUrls(OrderRootType.CLASSES)) {\n        libModel.removeRoot(url, OrderRootType.CLASSES);\n      }\n\n      for (String packageDir : rootsToAddToLib) {\n        libModel.addRoot(VfsUtilCore.pathToUrl(packageDir), OrderRootType.CLASSES);\n      }\n\n      final DartListPackageDirsLibraryProperties libraryProperties = new DartListPackageDirsLibraryProperties();\n      libraryProperties.setPackageNameToFileDirsMap(packageMap);\n      libModel.setProperties(libraryProperties);\n      libModel.commit();\n    }\n    finally {\n      if (!Disposer.isDisposed(libModel)) {\n        Disposer.dispose(libModel);\n      }\n    }\n    return library;\n  }","commit_id":"e4d63a2f9956906eecf61ca9da6677a31251a090","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void computeLibraryRoots(@NotNull final Project project,\n                                          @NotNull DartSdk dartSdk,\n                                          @NotNull final String[] libraries,\n                                          @NotNull final Collection<String> rootsToAddToLib) {\n\n    @NotNull final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n    @NotNull String sdkRoot = FileUtil.toSystemIndependentName(dartSdk.getHomePath());\n    if (!sdkRoot.endsWith(\"/\")) {\n      sdkRoot += \"/\";\n    }\n\n    for (final String path : libraries) {\n      if (path == null) continue;\n      @NotNull String libPath = stripOffFileName(FileUtil.toSystemDependentName(path));\n      @Nullable final VirtualFile vFile = LocalFileSystem.getInstance().findFileByPath(libPath);\n      if (!libPath.startsWith(sdkRoot) && (vFile == null || !fileIndex.isInContent(vFile))) {\n        rootsToAddToLib.add(libPath);\n      }\n    }\n  }","id":23959,"modified_method":"private static void computeLibraryRoots(@NotNull final Project project,\n                                          @NotNull final DartSdk dartSdk,\n                                          @NotNull final String[] libraries,\n                                          @NotNull final Collection<String> rootsToAddToLib) {\n\n    @NotNull final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n\n    for (final String path : libraries) {\n      if (path == null) continue;\n\n      final String libRoot = PathUtil.getParentPath(FileUtil.toSystemIndependentName(path));\n      final VirtualFile vFile = LocalFileSystem.getInstance().findFileByPath(libRoot);\n\n      if (!libRoot.startsWith(dartSdk.getHomePath() + \"/\") && (vFile == null || !fileIndex.isInContent(vFile))) {\n        // todo skip nested roots?\n        rootsToAddToLib.add(libRoot);\n      }\n    }\n  }","commit_id":"e4d63a2f9956906eecf61ca9da6677a31251a090","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void actionPerformed(@NotNull final AnActionEvent e) {\n    final Project project = e.getProject();\n    final DartSdk sdk = project == null ? null : DartSdk.getDartSdk(project);\n    if (sdk == null || !DartAnalysisServerAnnotator.isDartSDKVersionSufficient(sdk)) return;\n\n    FileDocumentManager.getInstance().saveAllDocuments();\n\n    @NotNull final Set<Module> affectedModules = new THashSet<Module>();\n    @NotNull final Collection<String> rootsToAddToLib = new THashSet<String>();\n    @NotNull final Map<String, List<File>> packageNameToDirMap = new THashMap<String, List<File>>();\n\n    final Runnable runnable = new Runnable() {\n      public void run() {\n        final ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n        if (indicator != null) {\n          indicator.setIndeterminate(true);\n          indicator.setText(\"pub list-package-dirs\");\n        }\n\n        if (!DartAnalysisServerService.getInstance().serverReadyForRequest(project, sdk)) return;\n\n        DartAnalysisServerService.getInstance().updateFilesContent();\n\n        DartAnalysisServerService.LibraryDependenciesResult libraryDependenciesResult =\n          DartAnalysisServerService.getInstance().analysis_getLibraryDependencies();\n\n        if (libraryDependenciesResult == null) {\n          libraryDependenciesResult = new DartAnalysisServerService.LibraryDependenciesResult(new String[]{}, Collections\n            .<String, Map<String, List<String>>>emptyMap());\n        }\n        String[] libraries = libraryDependenciesResult.getLibraries();\n        if (libraries == null) {\n          libraries = new String[]{};\n        }\n        Map<String, Map<String, List<String>>> packageMapMap = libraryDependenciesResult.getPackageMap();\n        if (packageMapMap == null) {\n          packageMapMap = Collections.emptyMap();\n        }\n\n        @NotNull final Module[] modules = ModuleManager.getInstance(project).getModules();\n        for (@NotNull final Module module : modules) {\n          if (indicator != null) {\n            indicator.checkCanceled();\n            indicator.setText(\"pub list-package-dirs\");\n          }\n\n          if (DartSdkGlobalLibUtil.isDartSdkGlobalLibAttached(module, sdk.getGlobalLibName())) {\n            for (@NotNull final VirtualFile contentRoot : ModuleRootManager.getInstance(module).getContentRoots()) {\n              // if there is a pubspec, skip this contentRoot\n              if (contentRoot.findChild(PubspecYamlUtil.PUBSPEC_YAML) != null) continue;\n\n              affectedModules.add(module);\n            }\n          }\n        }\n\n        computeLibraryRoots(project, sdk, libraries, rootsToAddToLib);\n        computePackageMap(packageMapMap, packageNameToDirMap);\n      }\n    };\n    if (ProgressManager.getInstance().runProcessWithProgressSynchronously(runnable, \"pub list-package-dirs\", true, project)) {\n      @NotNull final DartListPackageDirsDialog dialog = new DartListPackageDirsDialog(project, rootsToAddToLib, packageNameToDirMap);\n      dialog.show();\n\n      if (dialog.getExitCode() == DialogWrapper.OK_EXIT_CODE) {\n        configurePubListPackageDirsLibrary(project, affectedModules, rootsToAddToLib, packageNameToDirMap);\n      }\n\n      if (dialog.getExitCode() == DartListPackageDirsDialog.CONFIGURE_NONE_EXIT_CODE) {\n        removePubListPackageDirsLibrary(project);\n      }\n    }\n  }","id":23960,"modified_method":"public void actionPerformed(@NotNull final AnActionEvent e) {\n    final Project project = e.getProject();\n    final DartSdk sdk = project == null ? null : DartSdk.getDartSdk(project);\n    if (sdk == null || !DartAnalysisServerAnnotator.isDartSDKVersionSufficient(sdk)) return;\n\n    FileDocumentManager.getInstance().saveAllDocuments();\n\n    @NotNull final Set<Module> affectedModules = new THashSet<Module>();\n    @NotNull final Collection<String> rootsToAddToLib = new THashSet<String>();\n    @NotNull final Map<String, List<File>> packageNameToDirMap = new THashMap<String, List<File>>();\n\n    final Runnable runnable = new Runnable() {\n      public void run() {\n        final ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n        if (indicator != null) {\n          indicator.setIndeterminate(true);\n          indicator.setText(\"pub list-package-dirs\");\n        }\n\n        if (!DartAnalysisServerService.getInstance().serverReadyForRequest(project, sdk)) return;\n\n        DartAnalysisServerService.getInstance().updateFilesContent();\n\n        DartAnalysisServerService.LibraryDependenciesResult libraryDependenciesResult =\n          DartAnalysisServerService.getInstance().analysis_getLibraryDependencies();\n\n        if (libraryDependenciesResult == null) {\n          libraryDependenciesResult = new DartAnalysisServerService.LibraryDependenciesResult(new String[]{}, Collections\n            .<String, Map<String, List<String>>>emptyMap());\n        }\n        String[] libraries = libraryDependenciesResult.getLibraries();\n        if (libraries == null) {\n          libraries = new String[]{};\n        }\n        Map<String, Map<String, List<String>>> packageMapMap = libraryDependenciesResult.getPackageMap();\n        if (packageMapMap == null) {\n          packageMapMap = Collections.emptyMap();\n        }\n\n        @NotNull final Module[] modules = ModuleManager.getInstance(project).getModules();\n        for (@NotNull final Module module : modules) {\n          if (DartSdkGlobalLibUtil.isDartSdkGlobalLibAttached(module, sdk.getGlobalLibName())) {\n            for (@NotNull final VirtualFile contentRoot : ModuleRootManager.getInstance(module).getContentRoots()) {\n              // if there is a pubspec, skip this contentRoot\n              if (contentRoot.findChild(PubspecYamlUtil.PUBSPEC_YAML) != null) continue;\n\n              affectedModules.add(module);\n            }\n          }\n        }\n\n        computeLibraryRoots(project, sdk, libraries, rootsToAddToLib);\n        computePackageMap(packageMapMap, packageNameToDirMap);\n      }\n    };\n\n    if (ProgressManager.getInstance().runProcessWithProgressSynchronously(runnable, \"pub list-package-dirs\", true, project)) {\n      @NotNull final DartListPackageDirsDialog dialog = new DartListPackageDirsDialog(project, rootsToAddToLib, packageNameToDirMap);\n      dialog.show();\n\n      if (dialog.getExitCode() == DialogWrapper.OK_EXIT_CODE) {\n        configurePubListPackageDirsLibrary(project, affectedModules, rootsToAddToLib, packageNameToDirMap);\n      }\n\n      if (dialog.getExitCode() == DartListPackageDirsDialog.CONFIGURE_NONE_EXIT_CODE) {\n        removePubListPackageDirsLibrary(project);\n      }\n    }\n  }","commit_id":"e4d63a2f9956906eecf61ca9da6677a31251a090","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private LibraryEditor getLibraryEditor() {\n    return ((LibrariesModifiableModel)myModel.getModifiableModel()).getLibraryEditor(myLibrary);\n  }","id":23961,"modified_method":"private LibraryEditor getLibraryEditor() {\n    return myModel.getModifiableModel().getLibraryEditor(myLibrary);\n  }","commit_id":"471f7b69c243c200e705e88ccecb826a62d5afa1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getDisplayName() {\n    return getLibraryEditor().getName();\n  }","id":23962,"modified_method":"public String getDisplayName() {\n    if (myModel.getModifiableModel().hasLibraryEditor(myLibrary)) {\n      return getLibraryEditor().getName();\n    }\n\n    return myLibrary.getName();\n  }","commit_id":"471f7b69c243c200e705e88ccecb826a62d5afa1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void check(ProjectStructureProblemsHolder problemsHolder) {\n    final LibraryEx library = (LibraryEx)myContext.getLibraryModel(myLibrary);\n    if (library == null) return;\n\n    final String libraryName = library.getName();\n    if (!library.allPathsValid(OrderRootType.CLASSES)) {\n      problemsHolder.registerError(ProjectBundle.message(\"project.roots.tooltip.library.misconfigured\", libraryName));\n    }\n    else if (!library.allPathsValid(JavadocOrderRootType.getInstance()) || !library.allPathsValid(OrderRootType.SOURCES)) {\n      problemsHolder.registerWarning(ProjectBundle.message(\"project.roots.tooltip.library.misconfigured\", libraryName));\n    }\n  }","id":23963,"modified_method":"@Override\n  public void check(ProjectStructureProblemsHolder problemsHolder) {\n    if (((LibraryEx)myLibrary).isDisposed()) return;\n    final LibraryEx library = (LibraryEx)myContext.getLibraryModel(myLibrary);\n    if (library == null || library.isDisposed()) return;\n\n    final String libraryName = library.getName();\n    if (!library.allPathsValid(OrderRootType.CLASSES)) {\n      problemsHolder.registerError(ProjectBundle.message(\"project.roots.tooltip.library.misconfigured\", libraryName));\n    }\n    else if (!library.allPathsValid(JavadocOrderRootType.getInstance()) || !library.allPathsValid(OrderRootType.SOURCES)) {\n      problemsHolder.registerWarning(ProjectBundle.message(\"project.roots.tooltip.library.misconfigured\", libraryName));\n    }\n  }","commit_id":"471f7b69c243c200e705e88ccecb826a62d5afa1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void removePaths(final TreePath... paths) {\n    MyNode parentNode = null;\n    int idx = -1;\n    for (TreePath path : paths) {\n      final MyNode node = (MyNode)path.getLastPathComponent();\n      final NamedConfigurable namedConfigurable = node.getConfigurable();\n      final Object editableObject = namedConfigurable.getEditableObject();\n      parentNode = (MyNode)node.getParent();\n      idx = parentNode.getIndex(node);\n      parentNode.remove(node);\n      myHasDeletedItems |= wasObjectStored(editableObject);\n      fireItemsChangeListener(editableObject);\n      onItemDeleted(editableObject);\n      namedConfigurable.disposeUIResources();\n    }\n    ((DefaultTreeModel)myTree.getModel()).reload();\n    if (parentNode != null && idx != -1) {\n      TreeUtil\n        .selectInTree((DefaultMutableTreeNode)(idx < parentNode.getChildCount() ? parentNode.getChildAt(idx) : parentNode), true, myTree);\n    }\n    else {\n      TreeUtil.selectFirstNode(myTree);\n    }\n  }","id":23964,"modified_method":"protected void removePaths(final TreePath... paths) {\n    MyNode parentNode = null;\n    int idx = -1;\n    for (TreePath path : paths) {\n      final MyNode node = (MyNode)path.getLastPathComponent();\n      final NamedConfigurable namedConfigurable = node.getConfigurable();\n      final Object editableObject = namedConfigurable.getEditableObject();\n      parentNode = (MyNode)node.getParent();\n      idx = parentNode.getIndex(node);\n      ((DefaultTreeModel)myTree.getModel()).removeNodeFromParent(node);\n      myHasDeletedItems |= wasObjectStored(editableObject);\n      fireItemsChangeListener(editableObject);\n      onItemDeleted(editableObject);\n      namedConfigurable.disposeUIResources();\n    }\n\n    if (parentNode != null && idx != -1) {\n      TreeUtil\n        .selectInTree((DefaultMutableTreeNode)(idx < parentNode.getChildCount() ? parentNode.getChildAt(idx) : parentNode), true, myTree);\n    }\n    else {\n      TreeUtil.selectFirstNode(myTree);\n    }\n  }","commit_id":"471f7b69c243c200e705e88ccecb826a62d5afa1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected Library doCopy(LibraryEx library) {\n    final VirtualFile baseDir = getBaseDir();\n    final String libPath = baseDir != null ? baseDir.getPath() + \"/lib\" : \"\";\n    final VirtualFile[] classesRoots = library.getFiles(OrderRootType.CLASSES);\n    boolean allowEmptyName = isConvertingToModuleLibrary() && classesRoots.length == 1;\n    final String libraryName =\n      allowEmptyName ? \"\" : StringUtil.notNullize(library.getName(), LibraryTypeServiceImpl.suggestLibraryName(classesRoots));\n    final LibraryTableModifiableModelProvider provider = getModifiableTableModelProvider();\n    final ChangeLibraryLevelDialog dialog = new ChangeLibraryLevelDialog(getParentComponent(), myProject, myCopy,\n                                                                         libraryName, libPath, allowEmptyName, provider);\n    if (!dialog.showAndGet()) {\n      return null;\n    }\n\n    final Set<File> fileToCopy = new LinkedHashSet<File>();\n    final Map<String, String> copiedFiles = new HashMap<String, String>();\n    final String targetDirectoryPath = dialog.getDirectoryForFilesPath();\n    if (targetDirectoryPath != null) {\n      for (OrderRootType type : OrderRootType.getAllTypes()) {\n        for (VirtualFile root : library.getFiles(type)) {\n          fileToCopy.add(VfsUtil.virtualToIoFile(PathUtil.getLocalFile(root)));\n        }\n      }\n      if (!copyOrMoveFiles(fileToCopy, targetDirectoryPath, copiedFiles)) {\n        return null;\n      }\n    }\n\n    final Library copied = ((LibraryTableBase.ModifiableModelEx)provider.getModifiableModel())\n      .createLibrary(StringUtil.nullize(dialog.getLibraryName()), library.getKind());\n    final LibraryEx.ModifiableModelEx model = (LibraryEx.ModifiableModelEx)copied.getModifiableModel();\n    LibraryEditingUtil.copyLibrary(library, copiedFiles, model);\n\n    AccessToken token = WriteAction.start();\n    try {\n      model.commit();\n    }\n    finally {\n      token.finish();\n    }\n    return copied;\n  }","id":23965,"modified_method":"@Nullable\n  protected Library doCopy(LibraryEx library) {\n    final VirtualFile baseDir = getBaseDir();\n    final String libPath = baseDir != null ? baseDir.getPath() + \"/lib\" : \"\";\n    final VirtualFile[] classesRoots = library.getFiles(OrderRootType.CLASSES);\n    boolean allowEmptyName = isConvertingToModuleLibrary() && classesRoots.length == 1;\n    final String libraryName =\n      allowEmptyName ? \"\" : StringUtil.notNullize(library.getName(), LibraryTypeServiceImpl.suggestLibraryName(classesRoots));\n    final LibraryTableModifiableModelProvider provider = getModifiableTableModelProvider();\n    final ChangeLibraryLevelDialog dialog = new ChangeLibraryLevelDialog(getParentComponent(), myProject, myCopy,\n                                                                         libraryName, libPath, allowEmptyName, provider);\n    if (!dialog.showAndGet()) {\n      return null;\n    }\n\n    final Set<File> fileToCopy = new LinkedHashSet<File>();\n    final Map<String, String> copiedFiles = new HashMap<String, String>();\n    final String targetDirectoryPath = dialog.getDirectoryForFilesPath();\n    if (targetDirectoryPath != null) {\n      for (OrderRootType type : OrderRootType.getAllTypes()) {\n        for (VirtualFile root : library.getFiles(type)) {\n          fileToCopy.add(VfsUtil.virtualToIoFile(PathUtil.getLocalFile(root)));\n        }\n      }\n      if (!copyOrMoveFiles(fileToCopy, targetDirectoryPath, copiedFiles)) {\n        return null;\n      }\n    }\n\n    final Library copied = provider.getModifiableModel().createLibrary(StringUtil.nullize(dialog.getLibraryName()), library.getKind());\n    final LibraryEx.ModifiableModelEx model = (LibraryEx.ModifiableModelEx)copied.getModifiableModel();\n    LibraryEditingUtil.copyLibrary(library, copiedFiles, model);\n\n    AccessToken token = WriteAction.start();\n    try {\n      model.commit();\n    }\n    finally {\n      token.finish();\n    }\n    return copied;\n  }","commit_id":"1e162904a2a46b9b363bfd8d062499b504a6ac8a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Library createLibraryFromRoots(List<OrderRoot> roots, @Nullable final LibraryType libraryType) {\n    final PersistentLibraryKind kind = libraryType == null ? null : libraryType.getKind();\n    final Library library = ((LibraryTableBase.ModifiableModelEx)myModuleLibrariesModel).createLibrary(null, kind);\n    final LibraryEx.ModifiableModelEx libModel = (LibraryEx.ModifiableModelEx)library.getModifiableModel();\n    if (myDefaultPropertiesFactory != null) {\n      libModel.setProperties(myDefaultPropertiesFactory.fun(libraryType));\n    }\n    for (OrderRoot root : roots) {\n      if (root.isJarDirectory()) {\n        libModel.addJarDirectory(root.getFile(), false, root.getType());\n      }\n      else {\n        libModel.addRoot(root.getFile(), root.getType());\n      }\n    }\n    libModel.commit();\n    return library;\n  }","id":23966,"modified_method":"private Library createLibraryFromRoots(List<OrderRoot> roots, @Nullable final LibraryType libraryType) {\n    final PersistentLibraryKind kind = libraryType == null ? null : libraryType.getKind();\n    final Library library = myModuleLibrariesModel.createLibrary(null, kind);\n    final LibraryEx.ModifiableModelEx libModel = (LibraryEx.ModifiableModelEx)library.getModifiableModel();\n    if (myDefaultPropertiesFactory != null) {\n      libModel.setProperties(myDefaultPropertiesFactory.fun(libraryType));\n    }\n    for (OrderRoot root : roots) {\n      if (root.isJarDirectory()) {\n        libModel.addJarDirectory(root.getFile(), false, root.getType());\n      }\n      else {\n        libModel.addRoot(root.getFile(), root.getType());\n      }\n    }\n    libModel.commit();\n    return library;\n  }","commit_id":"1e162904a2a46b9b363bfd8d062499b504a6ac8a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Library createLibrary() {\n    final LibraryTableBase.ModifiableModelEx modifiableModel = (LibraryTableBase.ModifiableModelEx)getTableModifiableModel();\n    final LibraryType<?> type = myLibraryEditor.getType();\n    final Library library = modifiableModel.createLibrary(myLibraryEditor.getName(), type != null ? type.getKind() : null);\n    final LibraryEx.ModifiableModelEx model = (LibraryEx.ModifiableModelEx)library.getModifiableModel();\n    myLibraryEditor.applyTo(model);\n    new WriteAction() {\n      @Override\n      protected void run(@NotNull final Result result) {\n        model.commit();\n      }\n    }.execute();\n    return library;\n  }","id":23967,"modified_method":"@NotNull\n  public Library createLibrary() {\n    final LibraryTable.ModifiableModel modifiableModel = getTableModifiableModel();\n    final LibraryType<?> type = myLibraryEditor.getType();\n    final Library library = modifiableModel.createLibrary(myLibraryEditor.getName(), type != null ? type.getKind() : null);\n    final LibraryEx.ModifiableModelEx model = (LibraryEx.ModifiableModelEx)library.getModifiableModel();\n    myLibraryEditor.applyTo(model);\n    new WriteAction() {\n      @Override\n      protected void run(@NotNull final Result result) {\n        model.commit();\n      }\n    }.execute();\n    return library;\n  }","commit_id":"1e162904a2a46b9b363bfd8d062499b504a6ac8a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void attachPythonLibrary(final Module module,\n                                         @Nullable final ModifiableRootModel existingModel,\n                                         final String libraryName,\n                                         final List<String> paths) {\n    final ModifiableModelsProvider modelsProvider = ModifiableModelsProvider.SERVICE.getInstance();\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        // add all paths to library\n        final ModifiableRootModel model = existingModel != null ? existingModel : modelsProvider.getModuleModifiableModel(module);\n        final LibraryOrderEntry orderEntry = OrderEntryUtil.findLibraryOrderEntry(model, libraryName);\n        if (orderEntry != null) {\n          // update existing\n          Library lib = orderEntry.getLibrary();\n          if (lib != null) {\n            if (lib instanceof LibraryImpl && ((LibraryImpl)lib).getKind() == null) {   // replace old python libraries with python specific ones\n              model.removeOrderEntry(orderEntry);\n              ProjectLibraryTable.getInstance(model.getProject()).removeLibrary(lib);\n              createNewLibrary(model);\n              return;\n            }\n            fillLibrary(module.getProject(), lib, paths);\n            if (existingModel == null) {\n              modelsProvider.commitModuleModifiableModel(model);\n            }\n            return;\n          }\n        }\n        // create new\n        createNewLibrary(model);\n      }\n\n      private void createNewLibrary(ModifiableRootModel model) {\n        final LibraryTableBase.ModifiableModelEx projectLibrariesModel =\n          (LibraryTableBase.ModifiableModelEx)modelsProvider.getLibraryTableModifiableModel(model.getProject());\n        Library lib = projectLibrariesModel.createLibrary(libraryName, PythonLibraryType.getInstance().getKind());\n        fillLibrary(module.getProject(), lib, paths);\n        projectLibrariesModel.commit();\n        model.addLibraryEntry(lib);\n        if (existingModel == null) {\n          modelsProvider.commitModuleModifiableModel(model);\n        }\n      }\n    });\n  }","id":23968,"modified_method":"public static void attachPythonLibrary(final Module module,\n                                         @Nullable final ModifiableRootModel existingModel,\n                                         final String libraryName,\n                                         final List<String> paths) {\n    final ModifiableModelsProvider modelsProvider = ModifiableModelsProvider.SERVICE.getInstance();\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        // add all paths to library\n        final ModifiableRootModel model = existingModel != null ? existingModel : modelsProvider.getModuleModifiableModel(module);\n        final LibraryOrderEntry orderEntry = OrderEntryUtil.findLibraryOrderEntry(model, libraryName);\n        if (orderEntry != null) {\n          // update existing\n          Library lib = orderEntry.getLibrary();\n          if (lib != null) {\n            if (lib instanceof LibraryImpl && ((LibraryImpl)lib).getKind() == null) {   // replace old python libraries with python specific ones\n              model.removeOrderEntry(orderEntry);\n              ProjectLibraryTable.getInstance(model.getProject()).removeLibrary(lib);\n              createNewLibrary(model);\n              return;\n            }\n            fillLibrary(module.getProject(), lib, paths);\n            if (existingModel == null) {\n              modelsProvider.commitModuleModifiableModel(model);\n            }\n            return;\n          }\n        }\n        // create new\n        createNewLibrary(model);\n      }\n\n      private void createNewLibrary(ModifiableRootModel model) {\n        final LibraryTable.ModifiableModel projectLibrariesModel = modelsProvider.getLibraryTableModifiableModel(model.getProject());\n        Library lib = projectLibrariesModel.createLibrary(libraryName, PythonLibraryType.getInstance().getKind());\n        fillLibrary(module.getProject(), lib, paths);\n        projectLibrariesModel.commit();\n        model.addLibraryEntry(lib);\n        if (existingModel == null) {\n          modelsProvider.commitModuleModifiableModel(model);\n        }\n      }\n    });\n  }","commit_id":"1e162904a2a46b9b363bfd8d062499b504a6ac8a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static Library createLibraryInTable(final @NotNull NewLibraryEditor editor, final LibraryTable table) {\n    LibraryTableBase.ModifiableModelEx modifiableModel = (LibraryTableBase.ModifiableModelEx) table.getModifiableModel();\n    final String name = StringUtil.isEmpty(editor.getName()) ? null : getUniqueLibraryName(editor.getName(), modifiableModel);\n    final LibraryType<?> type = editor.getType();\n    Library library = modifiableModel.createLibrary(name, type == null ? null : type.getKind());\n    final LibraryEx.ModifiableModelEx model = (LibraryEx.ModifiableModelEx)library.getModifiableModel();\n    editor.applyTo(model);\n    model.commit();\n    modifiableModel.commit();\n    return library;\n  }","id":23969,"modified_method":"@NotNull\n  private static Library createLibraryInTable(final @NotNull NewLibraryEditor editor, final LibraryTable table) {\n    LibraryTable.ModifiableModel modifiableModel = table.getModifiableModel();\n    final String name = StringUtil.isEmpty(editor.getName()) ? null : getUniqueLibraryName(editor.getName(), modifiableModel);\n    final LibraryType<?> type = editor.getType();\n    Library library = modifiableModel.createLibrary(name, type == null ? null : type.getKind());\n    final LibraryEx.ModifiableModelEx model = (LibraryEx.ModifiableModelEx)library.getModifiableModel();\n    editor.applyTo(model);\n    model.commit();\n    modifiableModel.commit();\n    return library;\n  }","commit_id":"1e162904a2a46b9b363bfd8d062499b504a6ac8a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public Library createLibrary(@NotNull NewLibraryEditor libraryEditor,\n                                 @NotNull LibraryLevel level) {\n      LibraryTableModifiableModelProvider provider = getProvider(level);\n      if (provider == null) {\n        LOG.error(\"cannot create module library in this context\");\n      }\n\n      LibraryTableBase.ModifiableModelEx model = (LibraryTableBase.ModifiableModelEx)provider.getModifiableModel();\n      final LibraryType<?> type = libraryEditor.getType();\n      Library library = model.createLibrary(getUniqueLibraryName(libraryEditor.getName(), model), type == null ? null : type.getKind());\n      ExistingLibraryEditor createdLibraryEditor = ((LibrariesModifiableModel)model).getLibraryEditor(library);\n      createdLibraryEditor.setProperties(libraryEditor.getProperties());\n      libraryEditor.applyTo(createdLibraryEditor);\n      return library;\n    }","id":23970,"modified_method":"@Override\n    public Library createLibrary(@NotNull NewLibraryEditor libraryEditor,\n                                 @NotNull LibraryLevel level) {\n      LibraryTableModifiableModelProvider provider = getProvider(level);\n      if (provider == null) {\n        LOG.error(\"cannot create module library in this context\");\n      }\n\n      LibraryTable.ModifiableModel model = provider.getModifiableModel();\n      final LibraryType<?> type = libraryEditor.getType();\n      Library library = model.createLibrary(getUniqueLibraryName(libraryEditor.getName(), model), type == null ? null : type.getKind());\n      ExistingLibraryEditor createdLibraryEditor = ((LibrariesModifiableModel)model).getLibraryEditor(library);\n      createdLibraryEditor.setProperties(libraryEditor.getProperties());\n      libraryEditor.applyTo(createdLibraryEditor);\n      return library;\n    }","commit_id":"1e162904a2a46b9b363bfd8d062499b504a6ac8a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Library createLibrary(String name, @Nullable PersistentLibraryKind type) {\n    final Library library = ((LibraryTableBase.ModifiableModelEx)getLibrariesModifiableModel()).createLibrary(name, type);\n    //createLibraryEditor(library);                     \\\n    final BaseLibrariesConfigurable configurable = ProjectStructureConfigurable.getInstance(myProject).getConfigurableFor(library);\n    configurable.createLibraryNode(library);\n    return library;\n  }","id":23971,"modified_method":"@Override\n  public Library createLibrary(String name, @Nullable PersistentLibraryKind type) {\n    final Library library = getLibrariesModifiableModel().createLibrary(name, type);\n    //createLibraryEditor(library);                     \\\n    final BaseLibrariesConfigurable configurable = ProjectStructureConfigurable.getInstance(myProject).getConfigurableFor(library);\n    configurable.createLibraryNode(library);\n    return library;\n  }","commit_id":"1e162904a2a46b9b363bfd8d062499b504a6ac8a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(final AnActionEvent e) {\n      final Object o = getSelectedObject();\n      if (o instanceof LibraryImpl) {\n        myPathTf.addBrowseFolderListener(\"Choose directory\",\n                                         ProjectBundle.message(\"directory.roots.copy.label\"),\n                                         myProject, BrowseFilesListener.SINGLE_DIRECTORY_DESCRIPTOR);\n        mySaveAsCb.addActionListener(new ActionListener() {\n          public void actionPerformed(final ActionEvent e) {\n            myPathTf.setEnabled(mySaveAsCb.isSelected());\n          }\n        });\n        mySaveAsCb.setText(ProjectBundle.message(\"save.as.library.checkbox\", getOppositeGroup().myLevel));\n        mySaveAsCb.setSelected(false);\n        myPathTf.setEnabled(false);\n\n        final DialogWrapper dlg = new DialogWrapper(myTree, false) {\n          {\n            setTitle(\"Copy\");\n            init();\n          }\n\n          @Nullable\n          protected JComponent createCenterPanel() {\n            return myWholePanel;\n          }\n\n          public JComponent getPreferredFocusedComponent() {\n            return myNameTf;\n          }\n\n          protected void doOKAction() {\n            if (myNameTf.getText().length() == 0) {\n              Messages.showErrorDialog(\"Enter library copy name\", CommonBundle.message(\"title.error\"));\n              return;\n            }\n            super.doOKAction();\n          }\n        };\n        dlg.show();\n        if (!dlg.isOK()) return;\n\n        BaseLibrariesConfigurable configurable = mySaveAsCb.isSelected() ? getOppositeGroup() : BaseLibrariesConfigurable.this;\n\n        final LibraryImpl library = (LibraryImpl)myContext.getLibrary(((LibraryImpl)o).getName(), myLevel);\n\n        LOG.assertTrue(library != null);\n\n        final Library lib = configurable.getModelProvider(true).getModifiableModel().createLibrary(myNameTf.getText());\n\n        final LibraryImpl model = (LibraryImpl)lib.getModifiableModel();\n\n        for (OrderRootType type : OrderRootType.getAllTypes()) {\n          final VirtualFile[] files = library.getFiles(type);\n          for (VirtualFile file : files) {\n            if (mySaveAsCb.isSelected()) {\n              final File copy = new File(new File(myPathTf.getText()), file.getName());\n              if (copy.mkdirs()) {\n                try {\n                  final File fromFile = VfsUtil.virtualToIoFile(file);\n                  if (fromFile.isFile()) {\n                    FileUtil.copy(fromFile, copy);\n                  } else {\n                    FileUtil.copyDir(fromFile, copy);\n                  }\n                  model.addRoot(LocalFileSystem.getInstance().refreshAndFindFileByIoFile(copy), type);\n                }\n                catch (IOException e1) {\n                  //skip\n                }\n                continue;\n              }\n            }\n\n            model.addRoot(file, type);\n          }\n        }\n\n      }\n    }","id":23972,"modified_method":"public void actionPerformed(final AnActionEvent e) {\n      final Object o = getSelectedObject();\n      if (o instanceof LibraryImpl) {\n        myPathTf.addBrowseFolderListener(\"Choose directory\",\n                                         ProjectBundle.message(\"directory.roots.copy.label\"),\n                                         myProject, BrowseFilesListener.SINGLE_DIRECTORY_DESCRIPTOR);\n        mySaveAsCb.addActionListener(new ActionListener() {\n          public void actionPerformed(final ActionEvent e) {\n            myPathTf.setEnabled(mySaveAsCb.isSelected());\n          }\n        });\n        mySaveAsCb.setText(ProjectBundle.message(\"save.as.library.checkbox\", getOppositeGroup().myLevel));\n        mySaveAsCb.setSelected(false);\n        myPathTf.setEnabled(false);\n\n        final DialogWrapper dlg = new DialogWrapper(myTree, false) {\n          {\n            setTitle(\"Copy\");\n            init();\n          }\n\n          @Nullable\n          protected JComponent createCenterPanel() {\n            return myWholePanel;\n          }\n\n          public JComponent getPreferredFocusedComponent() {\n            return myNameTf;\n          }\n\n          protected void doOKAction() {\n            if (myNameTf.getText().length() == 0) {\n              Messages.showErrorDialog(\"Enter library copy name\", CommonBundle.message(\"title.error\"));\n              return;\n            }\n            super.doOKAction();\n          }\n        };\n        dlg.show();\n        if (!dlg.isOK()) return;\n\n        BaseLibrariesConfigurable configurable = mySaveAsCb.isSelected() ? getOppositeGroup() : BaseLibrariesConfigurable.this;\n\n        final LibraryImpl library = (LibraryImpl)myContext.getLibrary(((LibraryImpl)o).getName(), myLevel);\n\n        LOG.assertTrue(library != null);\n\n        final LibraryTable.ModifiableModel libsModel = configurable.getModelProvider(true).getModifiableModel();\n        final Library lib = libsModel.createLibrary(myNameTf.getText());\n        final Library.ModifiableModel model = ((LibrariesModifiableModel)libsModel).getLibraryEditor(lib).getModel();\n        for (OrderRootType type : OrderRootType.getAllTypes()) {\n          final VirtualFile[] files = library.getFiles(type);\n          for (VirtualFile file : files) {\n            if (mySaveAsCb.isSelected() && myPathTf.getText().trim().length() > 0) {\n              final File copy = new File(new File(myPathTf.getText()), file.getName());\n              if (copy.mkdirs()) {\n                try {\n                  final File fromFile = VfsUtil.virtualToIoFile(file);\n                  if (fromFile.isFile()) {\n                    FileUtil.copy(fromFile, copy);\n                  } else {\n                    FileUtil.copyDir(fromFile, copy);\n                  }\n                  model.addRoot(LocalFileSystem.getInstance().refreshAndFindFileByIoFile(copy), type);\n                }\n                catch (IOException e1) {\n                  //skip\n                }\n                continue;\n              }\n            }\n\n            model.addRoot(file, type);\n          }\n        }\n\n      }\n    }","commit_id":"5a515fc960095afecebe97fd0431a89d983bbc8f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public TachyonURI createDirectory(TachyonURI path, CreateDirectoryOptions options)\n      throws FileAlreadyExistsException, InvalidPathException, IOException, TachyonException {\n    FileSystemMasterClient masterClient = FileSystemContext.INSTANCE.acquireMasterClient();\n    try {\n      return masterClient.createDirectory(path, options);\n    } finally {\n      FileSystemContext.INSTANCE.releaseMasterClient(masterClient);\n    }\n  }","id":23973,"modified_method":"@Override\n  public void createDirectory(TachyonURI path, CreateDirectoryOptions options)\n      throws FileAlreadyExistsException, InvalidPathException, IOException, TachyonException {\n    FileSystemMasterClient masterClient = FileSystemContext.INSTANCE.acquireMasterClient();\n    try {\n      masterClient.createDirectory(path, options);\n    } finally {\n      FileSystemContext.INSTANCE.releaseMasterClient(masterClient);\n    }\n  }","commit_id":"db129aa9143c1245ee5b7c14a4c71e18ae1a057d","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public TachyonURI createDirectory(TachyonURI path)\n      throws FileAlreadyExistsException, InvalidPathException, IOException, TachyonException {\n    return createDirectory(path, CreateDirectoryOptions.defaults());\n  }","id":23974,"modified_method":"@Override\n  public void createDirectory(TachyonURI path)\n      throws FileAlreadyExistsException, InvalidPathException, IOException, TachyonException {\n    createDirectory(path, CreateDirectoryOptions.defaults());\n  }","commit_id":"db129aa9143c1245ee5b7c14a4c71e18ae1a057d","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public TachyonURI loadMetadata(TachyonURI path)\n      throws FileDoesNotExistException, IOException, TachyonException {\n    return loadMetadata(path, LoadMetadataOptions.defaults());\n  }","id":23975,"modified_method":"@Override\n  public void loadMetadata(TachyonURI path)\n      throws FileDoesNotExistException, IOException, TachyonException {\n    loadMetadata(path, LoadMetadataOptions.defaults());\n  }","commit_id":"db129aa9143c1245ee5b7c14a4c71e18ae1a057d","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public TachyonURI loadMetadata(TachyonURI path, LoadMetadataOptions options)\n      throws FileDoesNotExistException, IOException, TachyonException {\n    FileSystemMasterClient masterClient = FileSystemContext.INSTANCE.acquireMasterClient();\n    try {\n      return masterClient.loadMetadata(path, options);\n    } finally {\n      FileSystemContext.INSTANCE.releaseMasterClient(masterClient);\n    }\n  }","id":23976,"modified_method":"@Override\n  public void loadMetadata(TachyonURI path, LoadMetadataOptions options)\n      throws FileDoesNotExistException, IOException, TachyonException {\n    FileSystemMasterClient masterClient = FileSystemContext.INSTANCE.acquireMasterClient();\n    try {\n      masterClient.loadMetadata(path, options);\n    } finally {\n      FileSystemContext.INSTANCE.releaseMasterClient(masterClient);\n    }\n  }","commit_id":"db129aa9143c1245ee5b7c14a4c71e18ae1a057d","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new directory.\n   *\n   * @param path the directory path\n   * @param options method options\n   * @return the uri referencing the newly created directory\n   * @throws IOException if an I/O error occurs\n   * @throws TachyonException if a Tachyon error occurs\n   */\n  public synchronized TachyonURI createDirectory(final TachyonURI path,\n      final CreateDirectoryOptions options) throws IOException, TachyonException {\n    return retryRPC(new RpcCallableThrowsTachyonTException<TachyonURI>() {\n      @Override\n      public TachyonURI call() throws TachyonTException, TException {\n        mClient.mkdir(path.getPath(), options.toThrift());\n        // TODO(calvin): Look into changing the master side implementation to return a uri\n        return path;\n      }\n    });\n  }","id":23977,"modified_method":"/**\n   * Creates a new directory.\n   *\n   * @param path the directory path\n   * @param options method options\n   * @throws IOException if an I/O error occurs\n   * @throws TachyonException if a Tachyon error occurs\n   */\n  public synchronized void createDirectory(final TachyonURI path,\n      final CreateDirectoryOptions options) throws IOException, TachyonException {\n    retryRPC(new RpcCallableThrowsTachyonTException<Boolean>() {\n      @Override\n      public Boolean call() throws TachyonTException, TException {\n        return mClient.mkdir(path.getPath(), options.toThrift());\n      }\n    });\n  }","commit_id":"db129aa9143c1245ee5b7c14a4c71e18ae1a057d","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Loads the metadata of a file from the under file system.\n   *\n   * @param path the path of the file to load metadata for\n   * @param options method options\n   * @return the path of the loaded file\n   * @throws TachyonException if a Tachyon error occurs\n   * @throws IOException if an I/O error occurs\n   */\n  public synchronized TachyonURI loadMetadata(final TachyonURI path,\n      final LoadMetadataOptions options) throws IOException, TachyonException {\n    retryRPC(new RpcCallableThrowsTachyonTException<Long>() {\n      @Override\n      public Long call() throws TachyonTException, TException {\n        return mClient.loadMetadata(path.toString(), options.isRecursive());\n      }\n    });\n    // TODO(calvin): Look into changing the master side implementation to return a uri\n    return path;\n  }","id":23978,"modified_method":"/**\n   * Loads the metadata of a file from the under file system.\n   *\n   * @param path the path of the file to load metadata for\n   * @param options method options\n   * @throws TachyonException if a Tachyon error occurs\n   * @throws IOException if an I/O error occurs\n   */\n  public synchronized void loadMetadata(final TachyonURI path,\n      final LoadMetadataOptions options) throws IOException, TachyonException {\n    retryRPC(new RpcCallableThrowsTachyonTException<Long>() {\n      @Override\n      public Long call() throws TachyonTException, TException {\n        return mClient.loadMetadata(path.toString(), options.isRecursive());\n      }\n    });\n  }","commit_id":"db129aa9143c1245ee5b7c14a4c71e18ae1a057d","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Helper method to checkAndAdvanceBlockInStream and seekBlockInStream. The current\n   * BlockInStream will be closed and a new BlockInStream for the given blockId will be opened at\n   * position 0.\n   *\n   * @param blockId blockId to set the mCurrentBlockInStream to read\n   * @throws IOException if the next BlockInStream cannot be obtained\n   */\n  private void updateBlockInStream(long blockId) throws IOException {\n    if (mCurrentBlockInStream != null) {\n      mCurrentBlockInStream.close();\n    }\n    try {\n      mCurrentBlockInStream = mContext.getTachyonBlockStore().getInStream(blockId);\n      mShouldCacheCurrentBlock =\n          !(mCurrentBlockInStream instanceof LocalBlockInStream) && mShouldCache;\n    } catch (IOException ioe) {\n      if (mUfsPath == null || mUfsPath.isEmpty()) {\n        // TODO(yupeng): Maybe debug log here.\n        throw ioe;\n      }\n      long blockStart = BlockId.getSequenceNumber(blockId) * mBlockSize;\n      mCurrentBlockInStream = new UnderStoreFileInStream(blockStart, mBlockSize, mUfsPath);\n      mShouldCacheCurrentBlock = mShouldCache;\n    }\n  }","id":23979,"modified_method":"/**\n   * Helper method to checkAndAdvanceBlockInStream and seekBlockInStream. The current\n   * BlockInStream will be closed and a new BlockInStream for the given blockId will be opened at\n   * position 0.\n   *\n   * @param blockId blockId to set the mCurrentBlockInStream to read\n   * @throws IOException if the next BlockInStream cannot be obtained\n   */\n  private void updateBlockInStream(long blockId) throws IOException {\n    if (mCurrentBlockInStream != null) {\n      mCurrentBlockInStream.close();\n    }\n    try {\n      mCurrentBlockInStream = mContext.getTachyonBlockStore().getInStream(blockId);\n      mShouldCacheCurrentBlock =\n          !(mCurrentBlockInStream instanceof LocalBlockInStream) && mShouldCache;\n    } catch (IOException ioe) {\n      LOG.info(\"Failed to get BlockInStream: \" + ioe.getMessage());\n      if (mUfsPath == null || mUfsPath.isEmpty()) {\n        throw ioe;\n      }\n      long blockStart = BlockId.getSequenceNumber(blockId) * mBlockSize;\n      mCurrentBlockInStream = new UnderStoreFileInStream(blockStart, mBlockSize, mUfsPath);\n      mShouldCacheCurrentBlock = mShouldCache;\n    }\n  }","commit_id":"ffe368aa90678a792ac419eccd28c80d3a17f49b","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    Preconditions.checkArgument(b != null, \"Buffer is null\");\n    Preconditions.checkArgument(off >= 0 && len >= 0 && len + off <= b.length,\n        String.format(\"Buffer length (%d), offset(%d), len(%d)\", b.length, off, len));\n    if (len == 0) {\n      return 0;\n    } else if (mPos >= mFileLength) {\n      return -1;\n    }\n\n    int currentOffset = off;\n    int bytesLeftToRead = len;\n\n    while (bytesLeftToRead > 0 && mPos < mFileLength) {\n      checkAndAdvanceBlockInStream();\n\n      int bytesToRead = (int) Math.min(bytesLeftToRead, mCurrentBlockInStream.remaining());\n\n      int bytesRead = mCurrentBlockInStream.read(b, currentOffset, bytesToRead);\n      if (bytesRead > 0 && mShouldCacheCurrentBlock) {\n        try {\n          mCurrentCacheStream.write(b, currentOffset, bytesRead);\n        } catch (IOException ioe) {\n          // TODO(yupeng): Log debug maybe?\n          mShouldCacheCurrentBlock = false;\n        }\n      }\n      if (bytesRead == -1) {\n        // mCurrentBlockInStream has reached its block boundary\n        continue;\n      }\n\n      mPos += bytesRead;\n      bytesLeftToRead -= bytesRead;\n      currentOffset += bytesRead;\n    }\n\n    return len - bytesLeftToRead;\n  }","id":23980,"modified_method":"@Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    Preconditions.checkArgument(b != null, \"Buffer is null\");\n    Preconditions.checkArgument(off >= 0 && len >= 0 && len + off <= b.length,\n        String.format(\"Buffer length (%d), offset(%d), len(%d)\", b.length, off, len));\n    if (len == 0) {\n      return 0;\n    } else if (mPos >= mFileLength) {\n      return -1;\n    }\n\n    int currentOffset = off;\n    int bytesLeftToRead = len;\n\n    while (bytesLeftToRead > 0 && mPos < mFileLength) {\n      checkAndAdvanceBlockInStream();\n\n      int bytesToRead = (int) Math.min(bytesLeftToRead, mCurrentBlockInStream.remaining());\n\n      int bytesRead = mCurrentBlockInStream.read(b, currentOffset, bytesToRead);\n      if (bytesRead > 0 && mShouldCacheCurrentBlock) {\n        try {\n          mCurrentCacheStream.write(b, currentOffset, bytesRead);\n        } catch (IOException ioe) {\n          LOG.error(\"Failed to write into buffer: \" + ioe.getMessage());\n          mShouldCacheCurrentBlock = false;\n        }\n      }\n      if (bytesRead == -1) {\n        // mCurrentBlockInStream has reached its block boundary\n        continue;\n      }\n\n      mPos += bytesRead;\n      bytesLeftToRead -= bytesRead;\n      currentOffset += bytesRead;\n    }\n\n    return len - bytesLeftToRead;\n  }","commit_id":"ffe368aa90678a792ac419eccd28c80d3a17f49b","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Similar to checkAndAdvanceBlockInStream, but a specific position can be specified and the\n   * stream pointer will be at that offset after this method completes.\n   *\n   * @param newPos the new position to set the stream to\n   * @throws IOException if the stream at the specified position cannot be opened\n   */\n  private void seekBlockInStream(long newPos) throws IOException {\n    long oldBlockId = getBlockCurrentBlockId();\n    mPos = newPos;\n    closeCacheStream();\n    long currentBlockId = getBlockCurrentBlockId();\n\n    if (oldBlockId != currentBlockId) {\n      updateBlockInStream(currentBlockId);\n      // Reading next block entirely.\n      if (mPos % mBlockSize == 0 && mShouldCacheCurrentBlock) {\n        try {\n          mCurrentCacheStream =\n              mContext.getTachyonBlockStore().getOutStream(currentBlockId, -1, null);\n        } catch (IOException ioe) {\n          // TODO(yupeng): Maybe debug log here.\n          mShouldCacheCurrentBlock = false;\n        }\n      } else {\n        mShouldCacheCurrentBlock = false;\n      }\n    }\n  }","id":23981,"modified_method":"/**\n   * Similar to checkAndAdvanceBlockInStream, but a specific position can be specified and the\n   * stream pointer will be at that offset after this method completes.\n   *\n   * @param newPos the new position to set the stream to\n   * @throws IOException if the stream at the specified position cannot be opened\n   */\n  private void seekBlockInStream(long newPos) throws IOException {\n    long oldBlockId = getBlockCurrentBlockId();\n    mPos = newPos;\n    closeCacheStream();\n    long currentBlockId = getBlockCurrentBlockId();\n\n    if (oldBlockId != currentBlockId) {\n      updateBlockInStream(currentBlockId);\n      // Reading next block entirely.\n      if (mPos % mBlockSize == 0 && mShouldCacheCurrentBlock) {\n        try {\n          mCurrentCacheStream =\n              mContext.getTachyonBlockStore().getOutStream(currentBlockId, -1, null);\n        } catch (IOException ioe) {\n          LOG.info(\"Failed to get BufferedBlockOutStream: \" + ioe.getMessage());\n          mShouldCacheCurrentBlock = false;\n        }\n      } else {\n        mShouldCacheCurrentBlock = false;\n      }\n    }\n  }","commit_id":"ffe368aa90678a792ac419eccd28c80d3a17f49b","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Convenience method for updating mCurrentBlockInStream, mShouldCacheCurrentBlock, and\n   * mCurrentCacheStream. If the block boundary has been reached, the current BlockInStream is\n   * closed and a the next one is opened. mShouldCacheCurrent block is reset to the original\n   * mShouldCache. mCurrentCacheStream is also closed and a new one is created for the next block.\n   *\n   * @throws IOException if the next BlockInStream cannot be obtained\n   */\n  private void checkAndAdvanceBlockInStream() throws IOException {\n    long currentBlockId = getBlockCurrentBlockId();\n    if (mCurrentBlockInStream == null || mCurrentBlockInStream.remaining() == 0) {\n      updateBlockInStream(currentBlockId);\n      closeCacheStream();\n      if (mShouldCacheCurrentBlock) {\n        try {\n          // TODO(calvin): Specify the location to be local.\n          mCurrentCacheStream =\n              mContext.getTachyonBlockStore().getOutStream(currentBlockId, -1, null);\n        } catch (IOException ioe) {\n          // TODO(yupeng): Maybe debug log here.\n          mShouldCacheCurrentBlock = false;\n        }\n      }\n    }\n  }","id":23982,"modified_method":"/**\n   * Convenience method for updating mCurrentBlockInStream, mShouldCacheCurrentBlock, and\n   * mCurrentCacheStream. If the block boundary has been reached, the current BlockInStream is\n   * closed and a the next one is opened. mShouldCacheCurrent block is reset to the original\n   * mShouldCache. mCurrentCacheStream is also closed and a new one is created for the next block.\n   *\n   * @throws IOException if the next BlockInStream cannot be obtained\n   */\n  private void checkAndAdvanceBlockInStream() throws IOException {\n    long currentBlockId = getBlockCurrentBlockId();\n    if (mCurrentBlockInStream == null || mCurrentBlockInStream.remaining() == 0) {\n      updateBlockInStream(currentBlockId);\n      closeCacheStream();\n      if (mShouldCacheCurrentBlock) {\n        try {\n          // TODO(calvin): Specify the location to be local.\n          mCurrentCacheStream =\n              mContext.getTachyonBlockStore().getOutStream(currentBlockId, -1, null);\n        } catch (IOException ioe) {\n          LOG.info(\"Failed to get BufferedBlockOutStream: \" + ioe.getMessage());\n          mShouldCacheCurrentBlock = false;\n        }\n      }\n    }\n  }","commit_id":"ffe368aa90678a792ac419eccd28c80d3a17f49b","url":"https://github.com/amplab/tachyon"},{"original_method":"private void handleCacheWriteException(IOException ioe) throws IOException {\n    if (!mUnderStorageType.isPersist()) {\n      // TODO(yupeng): Handle this exception better.\n      throw new IOException(\"Fail to cache: \" + ioe.getMessage(), ioe);\n    }\n    // TODO(yupeng): Handle this error.\n    if (mCurrentBlockOutStream != null) {\n      mShouldCacheCurrentBlock = false;\n      mCurrentBlockOutStream.cancel();\n    }\n  }","id":23983,"modified_method":"private void handleCacheWriteException(IOException ioe) throws IOException {\n    if (!mUnderStorageType.isPersist()) {\n      // TODO(yupeng): Handle this exception better.\n      throw new IOException(\"Fail to cache: \" + ioe.getMessage(), ioe);\n    }\n\n    LOG.info(\"Failed to write into cache:\" + ioe.getMessage());\n    if (mCurrentBlockOutStream != null) {\n      mShouldCacheCurrentBlock = false;\n      mCurrentBlockOutStream.cancel();\n    }\n  }","commit_id":"ffe368aa90678a792ac419eccd28c80d3a17f49b","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Closes this TachyonFS instance. The next call to get will create a new TachyonFS instance.\n   * Other references to the old client may still be used.\n   */\n  // TODO(calvin): Evaluate the necessity of this method.\n  @Override\n  public synchronized void close() {\n    sClient = null;\n  }","id":23984,"modified_method":"/**\n   * Closes this TachyonFS instance. The next call to get will create a new TachyonFS instance.\n   * Other references to the old client may still be used.\n   */\n  // TODO(calvin): Evaluate the necessity of this method.\n  @Override\n  public synchronized void close() {\n    LOG.info(\"Tachyon File System Client is closed\");\n    sClient = null;\n  }","commit_id":"ffe368aa90678a792ac419eccd28c80d3a17f49b","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Deletes a file. If the file is a folder, its contents will be deleted recursively. The delete\n   * will abort on a failure, but previous deletes that occurred will still be effective. The delete\n   * will only synchronously be propagated to the master. The file metadata will not be available\n   * after this call, but the data in Tachyon or under storage space may still reside until the\n   * delete is propagated.\n   *\n   * @param file the handler of the file to delete.\n   * @throws IOException if the master is unable to delete the file\n   */\n  @Override\n  public void delete(TachyonFile file) throws IOException {\n    FileSystemMasterClient masterClient = mContext.acquireMasterClient();\n    try {\n      masterClient.deleteFile(file.getFileId(), true);\n    } finally {\n      mContext.releaseMasterClient(masterClient);\n    }\n  }","id":23985,"modified_method":"/**\n   * Deletes a file. If the file is a folder, its contents will be deleted recursively. The delete\n   * will abort on a failure, but previous deletes that occurred will still be effective. The delete\n   * will only synchronously be propagated to the master. The file metadata will not be available\n   * after this call, but the data in Tachyon or under storage space may still reside until the\n   * delete is propagated.\n   *\n   * @param file the handler of the file to delete.\n   * @throws IOException if the master is unable to delete the file\n   */\n  @Override\n  public void delete(TachyonFile file) throws IOException {\n    FileSystemMasterClient masterClient = mContext.acquireMasterClient();\n    try {\n      masterClient.deleteFile(file.getFileId(), true);\n      LOG.info(\"Deleted file \" + file.getFileId());\n    } finally {\n      mContext.releaseMasterClient(masterClient);\n    }\n  }","commit_id":"ffe368aa90678a792ac419eccd28c80d3a17f49b","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Adds metadata about a file in the under storage system to Tachyon. Only metadata will be\n   * updated and no data will be transferred. The data can be added to Tachyon space by doing an\n   * operation with the cache option specified, for example reading.\n   *\n   * @param path the path to create the file in Tachyon\n   * @param ufsPath the under storage system path of the file that will back the Tachyon file\n   * @param recursive if true, the parent directories to the file in Tachyon will be created\n   * @return the file id of the resulting file in Tachyon\n   * @throws IOException if the Tachyon path is invalid or the ufsPath does not exist\n   */\n  public long loadFileInfoFromUfs(TachyonURI path, TachyonURI ufsPath, boolean recursive)\n      throws IOException {\n    FileSystemMasterClient masterClient = mContext.acquireMasterClient();\n    try {\n      return masterClient.loadFileInfoFromUfs(path.getPath(), ufsPath.toString(), -1L, recursive);\n    } finally {\n      mContext.releaseMasterClient(masterClient);\n    }\n  }","id":23986,"modified_method":"/**\n   * Adds metadata about a file in the under storage system to Tachyon. Only metadata will be\n   * updated and no data will be transferred. The data can be added to Tachyon space by doing an\n   * operation with the cache option specified, for example reading.\n   *\n   * @param path the path to create the file in Tachyon\n   * @param ufsPath the under storage system path of the file that will back the Tachyon file\n   * @param recursive if true, the parent directories to the file in Tachyon will be created\n   * @return the file id of the resulting file in Tachyon\n   * @throws IOException if the Tachyon path is invalid or the ufsPath does not exist\n   */\n  public long loadFileInfoFromUfs(TachyonURI path, TachyonURI ufsPath, boolean recursive)\n      throws IOException {\n    FileSystemMasterClient masterClient = mContext.acquireMasterClient();\n    try {\n      long fileId =\n          masterClient.loadFileInfoFromUfs(path.getPath(), ufsPath.toString(), -1L, recursive);\n      LOG.info(\n          \"Loaded file \" + path.getPath() + \" from \" + ufsPath + (recursive ? \" recursively\" : \"\"));\n      return fileId;\n    } finally {\n      mContext.releaseMasterClient(masterClient);\n    }\n  }","commit_id":"ffe368aa90678a792ac419eccd28c80d3a17f49b","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a folder. If the parent folders do not exist, they will be created automatically.\n   *\n   * @param path the handler for the file\n   * @return true if the folder is created successfully or already existing, false otherwise.\n   * @throws IOException if the master cannot create the folder under the specified path\n   */\n  @Override\n  public boolean mkdirs(TachyonURI path) throws IOException {\n    FileSystemMasterClient masterClient = mContext.acquireMasterClient();\n    try {\n      // TODO: Change this RPC's arguments\n      return masterClient.createDirectory(path.getPath(), true);\n    } finally {\n      mContext.releaseMasterClient(masterClient);\n    }\n  }","id":23987,"modified_method":"/**\n   * Creates a folder. If the parent folders do not exist, they will be created automatically.\n   *\n   * @param path the handler for the file\n   * @return true if the folder is created successfully or already existing, false otherwise.\n   * @throws IOException if the master cannot create the folder under the specified path\n   */\n  @Override\n  public boolean mkdirs(TachyonURI path) throws IOException {\n    FileSystemMasterClient masterClient = mContext.acquireMasterClient();\n    try {\n      // TODO: Change this RPC's arguments\n      boolean result = masterClient.createDirectory(path.getPath(), true);\n      if (result) {\n        LOG.info(\"Created directory \" + path.getPath());\n      }\n      return result;\n    } finally {\n      mContext.releaseMasterClient(masterClient);\n    }\n  }","commit_id":"ffe368aa90678a792ac419eccd28c80d3a17f49b","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Sets the pin status of a file. A pinned file will never be evicted for any reason. The pin\n   * status is propagated asynchronously from this method call on the worker heartbeats.\n   *\n   * @param file the file handler for the file to pin\n   * @param pinned true to pin the file, false to unpin it\n   * @throws IOException if an error occurs during the pin operation\n   */\n  @Override\n  public void setPin(TachyonFile file, boolean pinned) throws IOException {\n    FileSystemMasterClient masterClient = mContext.acquireMasterClient();\n    try {\n      masterClient.setPinned(file.getFileId(), pinned);\n    } finally {\n      mContext.releaseMasterClient(masterClient);\n    }\n  }","id":23988,"modified_method":"/**\n   * Sets the pin status of a file. A pinned file will never be evicted for any reason. The pin\n   * status is propagated asynchronously from this method call on the worker heartbeats.\n   *\n   * @param file the file handler for the file to pin\n   * @param pinned true to pin the file, false to unpin it\n   * @throws IOException if an error occurs during the pin operation\n   */\n  @Override\n  public void setPin(TachyonFile file, boolean pinned) throws IOException {\n    FileSystemMasterClient masterClient = mContext.acquireMasterClient();\n    try {\n      masterClient.setPinned(file.getFileId(), pinned);\n      LOG.info(pinned ? \"Pinned\" : \"Unpinned\" + \" file \" + file.getFileId());\n    } finally {\n      mContext.releaseMasterClient(masterClient);\n    }\n  }","commit_id":"ffe368aa90678a792ac419eccd28c80d3a17f49b","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Renames an existing file in Tachyon space to another path in Tachyon space.\n   *\n   * @param src The file handler for the source file\n   * @param dst The path of the destination file, this path should not exist\n   * @return true if successful, false otherwise\n   * @throws IOException if the destination already exists or is invalid\n   */\n  @Override\n  public boolean rename(TachyonFile src, TachyonURI dst) throws IOException {\n    FileSystemMasterClient masterClient = mContext.acquireMasterClient();\n    try {\n      return masterClient.renameFile(src.getFileId(), dst.getPath());\n    } finally {\n      mContext.releaseMasterClient(masterClient);\n    }\n  }","id":23989,"modified_method":"/**\n   * Renames an existing file in Tachyon space to another path in Tachyon space.\n   *\n   * @param src The file handler for the source file\n   * @param dst The path of the destination file, this path should not exist\n   * @return true if successful, false otherwise\n   * @throws IOException if the destination already exists or is invalid\n   */\n  @Override\n  public boolean rename(TachyonFile src, TachyonURI dst) throws IOException {\n    FileSystemMasterClient masterClient = mContext.acquireMasterClient();\n    try {\n      boolean result = masterClient.renameFile(src.getFileId(), dst.getPath());\n      if (result) {\n        LOG.info(\"Renamed file \" + src.getFileId() + \" to \" + dst.getPath());\n      }\n      return result;\n    } finally {\n      mContext.releaseMasterClient(masterClient);\n    }\n  }","commit_id":"ffe368aa90678a792ac419eccd28c80d3a17f49b","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Removes the file from Tachyon Storage. The underlying under storage system file will not be\n   * removed. If the file is a folder, its contents will be freed recursively. This method is\n   * asynchronous and will be propagated to the workers through their heartbeats.\n   *\n   * @param file the handler for the file\n   * @throws IOException if the master is unable to free the file\n   */\n  @Override\n  public void free(TachyonFile file) throws IOException {\n    FileSystemMasterClient masterClient = mContext.acquireMasterClient();\n    try {\n      masterClient.free(file.getFileId(), true);\n    } finally {\n      mContext.releaseMasterClient(masterClient);\n    }\n  }","id":23990,"modified_method":"/**\n   * Removes the file from Tachyon Storage. The underlying under storage system file will not be\n   * removed. If the file is a folder, its contents will be freed recursively. This method is\n   * asynchronous and will be propagated to the workers through their heartbeats.\n   *\n   * @param file the handler for the file\n   * @throws IOException if the master is unable to free the file\n   */\n  @Override\n  public void free(TachyonFile file) throws IOException {\n    FileSystemMasterClient masterClient = mContext.acquireMasterClient();\n    try {\n      masterClient.free(file.getFileId(), true);\n      LOG.info(\"Removed file \" + file.getFileId() + \" from Tachyon Storage\");\n    } finally {\n      mContext.releaseMasterClient(masterClient);\n    }\n  }","commit_id":"ffe368aa90678a792ac419eccd28c80d3a17f49b","url":"https://github.com/amplab/tachyon"},{"original_method":"protected void execute( MavenProject currentProject, Map originalInstructions, Properties properties,\n        Jar[] classpath ) throws MojoExecutionException\n    {\n        final String artifactId = getProject().getArtifactId();\n        final String baseDir = getProject().getBasedir().getPath();\n\n        try\n        {\n            // assemble bundle as usual, but don't save it - this way we have all the instructions we need\n            Builder builder = buildOSGiBundle( currentProject, originalInstructions, properties, classpath );\n            Properties bndProperties = builder.getProperties();\n\n            // cleanup and remove all non-strings from the builder properties\n            for ( Iterator i = bndProperties.values().iterator(); i.hasNext(); )\n            {\n                if ( !( i.next() instanceof String ) )\n                {\n                    i.remove();\n                }\n            }\n\n            // save the BND generated bundle to the same output directory that maven uses\n            bndProperties.setProperty( \"-output\", \"${maven.build.dir}/${maven.build.finalName}.jar\" );\n\n            OutputStream out = new FileOutputStream( baseDir + BUILD_BND );\n            bndProperties.store( out, \" Merged BND Instructions\" );\n            IOUtil.close( out );\n\n            // modify build template\n            String buildXml = IOUtil.toString( getClass().getResourceAsStream( BUILD_XML ) );\n            buildXml = StringUtils.replace( buildXml, \"BND_VERSION\", builder.getVersion() );\n            buildXml = StringUtils.replace( buildXml, \"ARTIFACT_ID\", artifactId );\n\n            FileUtils.fileWrite( baseDir + BUILD_XML, buildXml );\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Problem creating Ant script\", e );\n        }\n\n        getLog().info( \"Wrote Ant bundle project for \" + artifactId + \" to \" + baseDir );\n    }","id":23991,"modified_method":"protected void execute( MavenProject currentProject, Map originalInstructions, Properties properties,\n        Jar[] classpath ) throws MojoExecutionException\n    {\n        final String artifactId = getProject().getArtifactId();\n        final String baseDir = getProject().getBasedir().getPath();\n\n        try\n        {\n            // assemble bundle as usual, but don't save it - this way we have all the instructions we need\n            Builder builder = buildOSGiBundle( currentProject, originalInstructions, properties, classpath );\n            Properties bndProperties = builder.getProperties();\n\n            // cleanup and remove all non-strings from the builder properties\n            for ( Iterator i = bndProperties.values().iterator(); i.hasNext(); )\n            {\n                if ( !( i.next() instanceof String ) )\n                {\n                    i.remove();\n                }\n            }\n\n            // save the BND generated bundle to the same output directory that maven uses\n            bndProperties.setProperty( \"-output\", \"${maven.build.dir}/${maven.build.finalName}.jar\" );\n\n            OutputStream out = new FileOutputStream( baseDir + BUILD_BND );\n            bndProperties.store( out, \" Merged BND Instructions\" );\n            IOUtil.close( out );\n\n            // modify build template\n            String buildXml = IOUtil.toString( getClass().getResourceAsStream( BUILD_XML ) );\n            buildXml = StringUtils.replace( buildXml, \"BND_VERSION\", builder.getVersion() );\n            buildXml = StringUtils.replace( buildXml, \"ARTIFACT_ID\", artifactId );\n\n            FileUtils.fileWrite( baseDir + BUILD_XML, buildXml );\n\n            // cleanup...\n            builder.close();\n        }\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Problem creating Ant script\", e );\n        }\n\n        getLog().info( \"Wrote Ant bundle project for \" + artifactId + \" to \" + baseDir );\n    }","commit_id":"d8a04c55cd2e3eb64570f8d2fb71117afe897e61","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Bundle one project only without building its childre\n     * \n     * @param project\n     * @throws MojoExecutionException\n     */\n    protected BundleInfo bundle( MavenProject project ) throws MojoExecutionException\n    {\n        Artifact artifact = project.getArtifact();\n        getLog().info( \"Bundling \" + artifact );\n\n        try\n        {\n            Map instructions = new HashMap();\n            instructions.put( Analyzer.IMPORT_PACKAGE, wrapImportPackage );\n\n            project.getArtifact().setFile( getFile( artifact ) );\n            File outputFile = getOutputFile( artifact );\n\n            if ( project.getArtifact().getFile().equals( outputFile ) )\n            {\n                /* TODO find the cause why it's getting here */\n                return null;\n                //                getLog().error(\n                //                                \"Trying to read and write \" + artifact + \" to the same file, try cleaning: \"\n                //                                    + outputFile );\n                //                throw new IllegalStateException( \"Trying to read and write \" + artifact\n                //                    + \" to the same file, try cleaning: \" + outputFile );\n            }\n\n            Analyzer analyzer = getAnalyzer( project, instructions, new Properties(), getClasspath( project ) );\n\n            Jar osgiJar = new Jar( project.getArtifactId(), project.getArtifact().getFile() );\n\n            outputFile.getAbsoluteFile().getParentFile().mkdirs();\n\n            Collection exportedPackages;\n            if ( isOsgi( osgiJar ) )\n            {\n                /* if it is already an OSGi jar copy it as is */\n                getLog().info(\n                    \"Using existing OSGi bundle for \" + project.getGroupId() + \":\" + project.getArtifactId() + \":\"\n                        + project.getVersion() );\n                String exportHeader = osgiJar.getManifest().getMainAttributes().getValue( Analyzer.EXPORT_PACKAGE );\n                exportedPackages = analyzer.parseHeader( exportHeader ).keySet();\n                FileUtils.copyFile( project.getArtifact().getFile(), outputFile );\n            }\n            else\n            {\n                /* else generate the manifest from the packages */\n                exportedPackages = analyzer.getExports().keySet();\n                Manifest manifest = analyzer.getJar().getManifest();\n                osgiJar.setManifest( manifest );\n                osgiJar.write( outputFile );\n            }\n\n            BundleInfo bundleInfo = addExportedPackages( project, exportedPackages );\n\n            return bundleInfo;\n        }\n        /* too bad Jar.write throws Exception */\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Error generating OSGi bundle for project \"\n                + getArtifactKey( project.getArtifact() ), e );\n        }\n    }","id":23992,"modified_method":"/**\n     * Bundle one project only without building its childre\n     * \n     * @param project\n     * @throws MojoExecutionException\n     */\n    protected BundleInfo bundle( MavenProject project ) throws MojoExecutionException\n    {\n        Artifact artifact = project.getArtifact();\n        getLog().info( \"Bundling \" + artifact );\n\n        try\n        {\n            Map instructions = new HashMap();\n            instructions.put( Analyzer.IMPORT_PACKAGE, wrapImportPackage );\n\n            project.getArtifact().setFile( getFile( artifact ) );\n            File outputFile = getOutputFile( artifact );\n\n            if ( project.getArtifact().getFile().equals( outputFile ) )\n            {\n                /* TODO find the cause why it's getting here */\n                return null;\n                //                getLog().error(\n                //                                \"Trying to read and write \" + artifact + \" to the same file, try cleaning: \"\n                //                                    + outputFile );\n                //                throw new IllegalStateException( \"Trying to read and write \" + artifact\n                //                    + \" to the same file, try cleaning: \" + outputFile );\n            }\n\n            Analyzer analyzer = getAnalyzer( project, instructions, new Properties(), getClasspath( project ) );\n\n            Jar osgiJar = new Jar( project.getArtifactId(), project.getArtifact().getFile() );\n\n            outputFile.getAbsoluteFile().getParentFile().mkdirs();\n\n            Collection exportedPackages;\n            if ( isOsgi( osgiJar ) )\n            {\n                /* if it is already an OSGi jar copy it as is */\n                getLog().info(\n                    \"Using existing OSGi bundle for \" + project.getGroupId() + \":\" + project.getArtifactId() + \":\"\n                        + project.getVersion() );\n                String exportHeader = osgiJar.getManifest().getMainAttributes().getValue( Analyzer.EXPORT_PACKAGE );\n                exportedPackages = analyzer.parseHeader( exportHeader ).keySet();\n                FileUtils.copyFile( project.getArtifact().getFile(), outputFile );\n            }\n            else\n            {\n                /* else generate the manifest from the packages */\n                exportedPackages = analyzer.getExports().keySet();\n                Manifest manifest = analyzer.getJar().getManifest();\n                osgiJar.setManifest( manifest );\n                osgiJar.write( outputFile );\n            }\n\n            BundleInfo bundleInfo = addExportedPackages( project, exportedPackages );\n\n            // cleanup...\n            analyzer.close();\n            osgiJar.close();\n\n            return bundleInfo;\n        }\n        /* too bad Jar.write throws Exception */\n        catch ( Exception e )\n        {\n            throw new MojoExecutionException( \"Error generating OSGi bundle for project \"\n                + getArtifactKey( project.getArtifact() ), e );\n        }\n    }","commit_id":"d8a04c55cd2e3eb64570f8d2fb71117afe897e61","url":"https://github.com/apache/felix"},{"original_method":"protected void execute( MavenProject currentProject, Map originalInstructions, Properties properties,\n        Jar[] classpath ) throws MojoExecutionException\n    {\n        try\n        {\n            File jarFile = new File( getBuildDirectory(), getBundleName( currentProject ) );\n\n            Builder builder = buildOSGiBundle( currentProject, originalInstructions, properties, classpath );\n\n            List errors = builder.getErrors();\n            List warnings = builder.getWarnings();\n\n            for ( Iterator w = warnings.iterator(); w.hasNext(); )\n            {\n                String msg = ( String ) w.next();\n                getLog().warn( \"Warning building bundle \" + currentProject.getArtifact() + \" : \" + msg );\n            }\n            for ( Iterator e = errors.iterator(); e.hasNext(); )\n            {\n                String msg = ( String ) e.next();\n                getLog().error( \"Error building bundle \" + currentProject.getArtifact() + \" : \" + msg );\n            }\n\n            if ( errors.size() > 0 )\n            {\n                String failok = properties.getProperty( \"-failok\" );\n                if ( null == failok || \"false\".equalsIgnoreCase( failok ) )\n                {\n                    jarFile.delete();\n\n                    throw new MojoFailureException( \"Error(s) found in bundle configuration\" );\n                }\n            }\n\n            // attach bundle to maven project\n            jarFile.getParentFile().mkdirs();\n            builder.getJar().write( jarFile );\n\n            Artifact mainArtifact = currentProject.getArtifact();\n\n            // workaround for MNG-1682: force maven to install artifact using the \"jar\" handler\n            mainArtifact.setArtifactHandler( m_artifactHandlerManager.getArtifactHandler( \"jar\" ) );\n\n            if ( null == classifier || classifier.trim().length() == 0 )\n            {\n                mainArtifact.setFile( jarFile );\n            }\n            else\n            {\n                m_projectHelper.attachArtifact( currentProject, jarFile, classifier );\n            }\n\n            if ( unpackBundle )\n            {\n                unpackBundle( jarFile );\n            }\n\n            if ( manifestLocation != null )\n            {\n                File outputFile = new File( manifestLocation, \"MANIFEST.MF\" );\n\n                try\n                {\n                    Manifest manifest = builder.getJar().getManifest();\n                    ManifestPlugin.writeManifest( manifest, outputFile );\n                }\n                catch ( IOException e )\n                {\n                    getLog().error( \"Error trying to write Manifest to file \" + outputFile, e );\n                }\n            }\n        }\n        catch ( MojoFailureException e )\n        {\n            getLog().error( e.getLocalizedMessage() );\n            throw new MojoExecutionException( \"Error(s) found in bundle configuration\", e );\n        }\n        catch ( Exception e )\n        {\n            getLog().error( \"An internal error occurred\", e );\n            throw new MojoExecutionException( \"Internal error in maven-bundle-plugin\", e );\n        }\n    }","id":23993,"modified_method":"protected void execute( MavenProject currentProject, Map originalInstructions, Properties properties,\n        Jar[] classpath ) throws MojoExecutionException\n    {\n        try\n        {\n            File jarFile = new File( getBuildDirectory(), getBundleName( currentProject ) );\n\n            Builder builder = buildOSGiBundle( currentProject, originalInstructions, properties, classpath );\n\n            List errors = builder.getErrors();\n            List warnings = builder.getWarnings();\n\n            for ( Iterator w = warnings.iterator(); w.hasNext(); )\n            {\n                String msg = ( String ) w.next();\n                getLog().warn( \"Warning building bundle \" + currentProject.getArtifact() + \" : \" + msg );\n            }\n            for ( Iterator e = errors.iterator(); e.hasNext(); )\n            {\n                String msg = ( String ) e.next();\n                getLog().error( \"Error building bundle \" + currentProject.getArtifact() + \" : \" + msg );\n            }\n\n            if ( errors.size() > 0 )\n            {\n                String failok = properties.getProperty( \"-failok\" );\n                if ( null == failok || \"false\".equalsIgnoreCase( failok ) )\n                {\n                    jarFile.delete();\n\n                    throw new MojoFailureException( \"Error(s) found in bundle configuration\" );\n                }\n            }\n\n            // attach bundle to maven project\n            jarFile.getParentFile().mkdirs();\n            builder.getJar().write( jarFile );\n\n            Artifact mainArtifact = currentProject.getArtifact();\n\n            // workaround for MNG-1682: force maven to install artifact using the \"jar\" handler\n            mainArtifact.setArtifactHandler( m_artifactHandlerManager.getArtifactHandler( \"jar\" ) );\n\n            if ( null == classifier || classifier.trim().length() == 0 )\n            {\n                mainArtifact.setFile( jarFile );\n            }\n            else\n            {\n                m_projectHelper.attachArtifact( currentProject, jarFile, classifier );\n            }\n\n            if ( unpackBundle )\n            {\n                unpackBundle( jarFile );\n            }\n\n            if ( manifestLocation != null )\n            {\n                File outputFile = new File( manifestLocation, \"MANIFEST.MF\" );\n\n                try\n                {\n                    Manifest manifest = builder.getJar().getManifest();\n                    ManifestPlugin.writeManifest( manifest, outputFile );\n                }\n                catch ( IOException e )\n                {\n                    getLog().error( \"Error trying to write Manifest to file \" + outputFile, e );\n                }\n            }\n\n            // cleanup...\n            builder.close();\n        }\n        catch ( MojoFailureException e )\n        {\n            getLog().error( e.getLocalizedMessage() );\n            throw new MojoExecutionException( \"Error(s) found in bundle configuration\", e );\n        }\n        catch ( Exception e )\n        {\n            getLog().error( \"An internal error occurred\", e );\n            throw new MojoExecutionException( \"Internal error in maven-bundle-plugin\", e );\n        }\n    }","commit_id":"d8a04c55cd2e3eb64570f8d2fb71117afe897e61","url":"https://github.com/apache/felix"},{"original_method":"public void testReadExportedModules() throws Exception\n    {\n        File osgiBundleFile = getTestBundle();\n\n        assertTrue( osgiBundleFile.exists() );\n\n        MavenProject project = new MavenProjectStub();\n        project.setGroupId( \"group\" );\n        project.setArtifactId( \"artifact\" );\n        project.setVersion( \"1.1.0.0\" );\n\n        PackageVersionAnalyzer analyzer = new PackageVersionAnalyzer();\n        Jar jar = new Jar( \"name\", osgiBundleFile );\n        analyzer.setJar( jar );\n        analyzer.setClasspath( new Jar[]\n            { jar } );\n\n        analyzer.setProperty( Analyzer.EXPORT_PACKAGE, \"*\" );\n        analyzer.calcManifest();\n\n        assertEquals( 3, analyzer.getExports().size() );\n    }","id":23994,"modified_method":"public void testReadExportedModules() throws Exception\n    {\n        File osgiBundleFile = getTestBundle();\n\n        assertTrue( osgiBundleFile.exists() );\n\n        MavenProject project = new MavenProjectStub();\n        project.setGroupId( \"group\" );\n        project.setArtifactId( \"artifact\" );\n        project.setVersion( \"1.1.0.0\" );\n\n        PackageVersionAnalyzer analyzer = new PackageVersionAnalyzer();\n        Jar jar = new Jar( \"name\", osgiBundleFile );\n        analyzer.setJar( jar );\n        analyzer.setClasspath( new Jar[]\n            { jar } );\n\n        analyzer.setProperty( Analyzer.EXPORT_PACKAGE, \"*\" );\n        analyzer.calcManifest();\n\n        assertEquals( 3, analyzer.getExports().size() );\n\n        analyzer.close();\n    }","commit_id":"d8a04c55cd2e3eb64570f8d2fb71117afe897e61","url":"https://github.com/apache/felix"},{"original_method":"public Manifest getManifest( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws IOException, MojoFailureException, MojoExecutionException\n    {\n        Analyzer analyzer = getAnalyzer( project, instructions, properties, classpath );\n\n        List errors = analyzer.getErrors();\n        List warnings = analyzer.getWarnings();\n\n        for ( Iterator w = warnings.iterator(); w.hasNext(); )\n        {\n            String msg = ( String ) w.next();\n            getLog().warn( \"Warning in manifest for \" + project.getArtifact() + \" : \" + msg );\n        }\n        for ( Iterator e = errors.iterator(); e.hasNext(); )\n        {\n            String msg = ( String ) e.next();\n            getLog().error( \"Error in manifest for \" + project.getArtifact() + \" : \" + msg );\n        }\n\n        if ( errors.size() > 0 )\n        {\n            String failok = properties.getProperty( \"-failok\" );\n            if ( null == failok || \"false\".equalsIgnoreCase( failok ) )\n            {\n                throw new MojoFailureException( \"Error(s) found in manifest configuration\" );\n            }\n        }\n\n        return analyzer.getJar().getManifest();\n    }","id":23995,"modified_method":"public Manifest getManifest( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws IOException, MojoFailureException, MojoExecutionException\n    {\n        Analyzer analyzer = getAnalyzer( project, instructions, properties, classpath );\n\n        List errors = analyzer.getErrors();\n        List warnings = analyzer.getWarnings();\n\n        for ( Iterator w = warnings.iterator(); w.hasNext(); )\n        {\n            String msg = ( String ) w.next();\n            getLog().warn( \"Warning in manifest for \" + project.getArtifact() + \" : \" + msg );\n        }\n        for ( Iterator e = errors.iterator(); e.hasNext(); )\n        {\n            String msg = ( String ) e.next();\n            getLog().error( \"Error in manifest for \" + project.getArtifact() + \" : \" + msg );\n        }\n\n        if ( errors.size() > 0 )\n        {\n            String failok = properties.getProperty( \"-failok\" );\n            if ( null == failok || \"false\".equalsIgnoreCase( failok ) )\n            {\n                throw new MojoFailureException( \"Error(s) found in manifest configuration\" );\n            }\n        }\n\n        Manifest manifest = analyzer.getJar().getManifest();\n\n        // cleanup...\n        analyzer.close();\n\n        return manifest;\n    }","commit_id":"d8a04c55cd2e3eb64570f8d2fb71117afe897e61","url":"https://github.com/apache/felix"},{"original_method":"protected void execute( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws MojoExecutionException\n    {\n        Manifest manifest;\n        try\n        {\n            if ( \"bundle\".equals( project.getPackaging() ) )\n            {\n                manifest = buildOSGiBundle( project, instructions, properties, classpath ).getJar().getManifest();\n            }\n            else\n            {\n                manifest = getManifest( project, instructions, properties, classpath );\n            }\n        }\n        catch ( FileNotFoundException e )\n        {\n            throw new MojoExecutionException( \"Cannot find \" + e.getMessage()\n                + \" (manifest goal must be run after compile phase)\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error trying to generate Manifest\", e );\n        }\n        catch ( MojoFailureException e )\n        {\n            getLog().error( e.getLocalizedMessage() );\n            throw new MojoExecutionException( \"Error(s) found in manifest configuration\", e );\n        }\n        catch ( Exception e )\n        {\n            getLog().error( \"An internal error occurred\", e );\n            throw new MojoExecutionException( \"Internal error in maven-bundle-plugin\", e );\n        }\n\n        File outputFile = new File( manifestLocation, \"MANIFEST.MF\" );\n\n        try\n        {\n            writeManifest( manifest, outputFile );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error trying to write Manifest to file \" + outputFile, e );\n        }\n    }","id":23996,"modified_method":"protected void execute( MavenProject project, Map instructions, Properties properties, Jar[] classpath )\n        throws MojoExecutionException\n    {\n        Manifest manifest;\n        try\n        {\n            if ( \"bundle\".equals( project.getPackaging() ) )\n            {\n                Builder builder = buildOSGiBundle( project, instructions, properties, classpath );\n                manifest = builder.getJar().getManifest();\n                builder.close();\n            }\n            else\n            {\n                manifest = getManifest( project, instructions, properties, classpath );\n            }\n        }\n        catch ( FileNotFoundException e )\n        {\n            throw new MojoExecutionException( \"Cannot find \" + e.getMessage()\n                + \" (manifest goal must be run after compile phase)\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error trying to generate Manifest\", e );\n        }\n        catch ( MojoFailureException e )\n        {\n            getLog().error( e.getLocalizedMessage() );\n            throw new MojoExecutionException( \"Error(s) found in manifest configuration\", e );\n        }\n        catch ( Exception e )\n        {\n            getLog().error( \"An internal error occurred\", e );\n            throw new MojoExecutionException( \"Internal error in maven-bundle-plugin\", e );\n        }\n\n        File outputFile = new File( manifestLocation, \"MANIFEST.MF\" );\n\n        try\n        {\n            writeManifest( manifest, outputFile );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error trying to write Manifest to file \" + outputFile, e );\n        }\n    }","commit_id":"d8a04c55cd2e3eb64570f8d2fb71117afe897e61","url":"https://github.com/apache/felix"},{"original_method":"protected boolean isValidOSGiBundle() {\n\t\tManifest manifest = null;\n\n\t\ttry {\n\t\t\tmanifest = getManifest();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\treturn false;\n\t\t}\n\n\t\tAttributes attributes = manifest.getMainAttributes();\n\n\t\tString bundleSymbolicName = GetterUtil.getString(\n\t\t\tattributes.getValue(Constants.BUNDLE_SYMBOLICNAME));\n\n\t\treturn Validator.isNotNull(bundleSymbolicName);\n\t}","id":23997,"modified_method":"protected boolean isValidOSGiBundle() {\n\t\ttry {\n\t\t\treturn ManifestUtil.isValidOSGiBundle(getManifest());\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"7fe4cfe397e0de0582359a3e9177bfa69c43ebd1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic URL transform(URL artifact) throws Exception {\n\t\tString path = artifact.getPath();\n\n\t\tint x = path.lastIndexOf(\"/\");\n\t\tint y = path.lastIndexOf(\".war\");\n\n\t\tString contextName = path.substring(x + 1, y);\n\n\t\tMatcher matcher = _pattern.matcher(contextName);\n\n\t\tif (matcher.matches()) {\n\t\t\tcontextName = matcher.group(1);\n\t\t}\n\n\t\tString pathWithQueryString =\n\t\t\tartifact.getPath() + \"?Web-ContextPath=/\" + contextName;\n\n\t\tURL url = new URL(\"file\", null, pathWithQueryString);\n\n\t\turl = new URL(\"webbundle\", null, url.toString());\n\n\t\treturn url;\n\t}","id":23998,"modified_method":"@Override\n\tpublic URL transform(URL artifact) throws Exception {\n\t\tif (\"file\".equals(artifact.getProtocol()) &&\n\t\t\tManifestUtil.isValidOSGiBundle(artifact.getPath())) {\n\n\t\t\treturn artifact;\n\t\t}\n\n\t\tString path = artifact.getPath();\n\n\t\tint x = path.lastIndexOf(\"/\");\n\t\tint y = path.lastIndexOf(\".war\");\n\n\t\tString contextName = path.substring(x + 1, y);\n\n\t\tMatcher matcher = _pattern.matcher(contextName);\n\n\t\tif (matcher.matches()) {\n\t\t\tcontextName = matcher.group(1);\n\t\t}\n\n\t\tString pathWithQueryString =\n\t\t\tartifact.getPath() + \"?Web-ContextPath=/\" + contextName;\n\n\t\tURL url = new URL(\"file\", null, pathWithQueryString);\n\n\t\turl = new URL(\"webbundle\", null, url.toString());\n\n\t\treturn url;\n\t}","commit_id":"7fe4cfe397e0de0582359a3e9177bfa69c43ebd1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static File createManifestFileIfNecessary(File targetDirectory) throws IOException\n    {\n        File manifestFile = new File(targetDirectory.getPath(), \"MANIFEST.MF\");\n        if (!manifestFile.exists())\n        {\n            Manifest manifest = new Manifest(MuleManifest.getManifest());\n            try (FileOutputStream fileOutputStream = new FileOutputStream(manifestFile))\n            {\n                manifest.write(fileOutputStream);\n            }\n        }\n        return manifestFile;\n    }","id":23999,"modified_method":"public static File createManifestFileIfNecessary(File targetDirectory) throws IOException\n    {\n        return createManifestFileIfNecessary(targetDirectory, MuleManifest.getManifest());\n    }","commit_id":"0e5b6c68be2d56370645e4fa9c4a573c8c85cf18","url":"https://github.com/mulesoft/mule"}]