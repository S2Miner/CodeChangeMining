[{"original_method":"@Test(timeout = 300000)\n  public void testMetaRecoveryInZK() throws Exception {\n    LOG.info(\"testMetaRecoveryInZK\");\n    Configuration curConf = HBaseConfiguration.create();\n    curConf.setBoolean(HConstants.DISTRIBUTED_LOG_REPLAY_KEY, true);\n    startCluster(NUM_RS, curConf);\n\n    // turn off load balancing to prevent regions from moving around otherwise\n    // they will consume recovered.edits\n    master.balanceSwitch(false);\n    final ZooKeeperWatcher zkw = new ZooKeeperWatcher(curConf, \"table-creation\", null);\n    List<RegionServerThread> rsts = cluster.getLiveRegionServerThreads();\n\n    installTable(zkw, \"table\", \"family\", 40);\n    List<HRegionInfo> regions = null;\n    HRegionServer hrs = null;\n    for (int i = 0; i < NUM_RS; i++) {\n      boolean isCarryingMeta = false;\n      hrs = rsts.get(i).getRegionServer();\n      regions = ProtobufUtil.getOnlineRegions(hrs);\n      for (HRegionInfo region : regions) {\n        if (region.isMetaRegion()) {\n          isCarryingMeta = true;\n          break;\n        }\n      }\n      if (!isCarryingMeta) {\n        continue;\n      }\n      break;\n    }\n\n    LOG.info(\"#regions = \" + regions.size());\n    Set<HRegionInfo> tmpRegions = new HashSet<HRegionInfo>();\n    tmpRegions.add(HRegionInfo.FIRST_META_REGIONINFO);\n    master.getMasterFileSystem().prepareMetaLogReplay(hrs.getServerName(), tmpRegions);\n    Set<ServerName> failedServers = new HashSet<ServerName>();\n    failedServers.add(hrs.getServerName());\n    master.getMasterFileSystem().prepareLogReplay(failedServers);\n    boolean isMetaRegionInRecovery = false;\n    List<String> recoveringRegions =\n        zkw.getRecoverableZooKeeper().getChildren(zkw.recoveringRegionsZNode, false);\n    for (String curEncodedRegionName : recoveringRegions) {\n      if (curEncodedRegionName.equals(HRegionInfo.FIRST_META_REGIONINFO.getEncodedName())) {\n        isMetaRegionInRecovery = true;\n        break;\n      }\n    }\n    assertTrue(isMetaRegionInRecovery);\n\n    master.getMasterFileSystem().splitMetaLog(hrs.getServerName());\n    \n    isMetaRegionInRecovery = false;\n    recoveringRegions =\n        zkw.getRecoverableZooKeeper().getChildren(zkw.recoveringRegionsZNode, false);\n    for (String curEncodedRegionName : recoveringRegions) {\n      if (curEncodedRegionName.equals(HRegionInfo.FIRST_META_REGIONINFO.getEncodedName())) {\n        isMetaRegionInRecovery = true;\n        break;\n      }\n    }\n    // meta region should be recovered\n    assertFalse(isMetaRegionInRecovery);\n  }","id":49000,"modified_method":"@Test(timeout = 300000)\n  public void testMetaRecoveryInZK() throws Exception {\n    LOG.info(\"testMetaRecoveryInZK\");\n    Configuration curConf = HBaseConfiguration.create();\n    curConf.setBoolean(HConstants.DISTRIBUTED_LOG_REPLAY_KEY, true);\n    startCluster(NUM_RS, curConf);\n\n    // turn off load balancing to prevent regions from moving around otherwise\n    // they will consume recovered.edits\n    master.balanceSwitch(false);\n    final ZooKeeperWatcher zkw = new ZooKeeperWatcher(curConf, \"table-creation\", null);\n    List<RegionServerThread> rsts = cluster.getLiveRegionServerThreads();\n\n    // only testing meta recovery in ZK operation\n    HRegionServer hrs = findRSToKill(true, null);\n    List<HRegionInfo> regions = ProtobufUtil.getOnlineRegions(hrs);\n\n    LOG.info(\"#regions = \" + regions.size());\n    Set<HRegionInfo> tmpRegions = new HashSet<HRegionInfo>();\n    tmpRegions.add(HRegionInfo.FIRST_META_REGIONINFO);\n    master.getMasterFileSystem().prepareMetaLogReplay(hrs.getServerName(), tmpRegions);\n    Set<ServerName> failedServers = new HashSet<ServerName>();\n    failedServers.add(hrs.getServerName());\n    master.getMasterFileSystem().prepareLogReplay(failedServers);\n    boolean isMetaRegionInRecovery = false;\n    List<String> recoveringRegions =\n        zkw.getRecoverableZooKeeper().getChildren(zkw.recoveringRegionsZNode, false);\n    for (String curEncodedRegionName : recoveringRegions) {\n      if (curEncodedRegionName.equals(HRegionInfo.FIRST_META_REGIONINFO.getEncodedName())) {\n        isMetaRegionInRecovery = true;\n        break;\n      }\n    }\n    assertTrue(isMetaRegionInRecovery);\n\n    master.getMasterFileSystem().splitMetaLog(hrs.getServerName());\n    \n    isMetaRegionInRecovery = false;\n    recoveringRegions =\n        zkw.getRecoverableZooKeeper().getChildren(zkw.recoveringRegionsZNode, false);\n    for (String curEncodedRegionName : recoveringRegions) {\n      if (curEncodedRegionName.equals(HRegionInfo.FIRST_META_REGIONINFO.getEncodedName())) {\n        isMetaRegionInRecovery = true;\n        break;\n      }\n    }\n    // meta region should be recovered\n    assertFalse(isMetaRegionInRecovery);\n    zkw.close();\n  }","commit_id":"4a6de45f7655363fc8a0bf656d282a0ae1c73aff","url":"https://github.com/apache/hbase"},{"original_method":"@Test(timeout = 300000)\n  public void testLogReplayWithMetaRSDown() throws Exception {\n    LOG.info(\"testRecoveredEditsReplayWithMetaRSDown\");\n    Configuration curConf = HBaseConfiguration.create();\n    curConf.setBoolean(HConstants.DISTRIBUTED_LOG_REPLAY_KEY, true);\n    startCluster(NUM_RS, curConf);\n    final int NUM_REGIONS_TO_CREATE = 40;\n    final int NUM_LOG_LINES = 1000;\n    // turn off load balancing to prevent regions from moving around otherwise\n    // they will consume recovered.edits\n    master.balanceSwitch(false);\n\n    List<RegionServerThread> rsts = cluster.getLiveRegionServerThreads();\n    final ZooKeeperWatcher zkw = new ZooKeeperWatcher(conf, \"table-creation\", null);\n    HTable ht = installTable(zkw, \"table\", \"family\", NUM_REGIONS_TO_CREATE);\n\n    List<HRegionInfo> regions = null;\n    HRegionServer hrs = null;\n    for (int i = 0; i < NUM_RS; i++) {\n      boolean isCarryingMeta = false;\n      hrs = rsts.get(i).getRegionServer();\n      regions = ProtobufUtil.getOnlineRegions(hrs);\n      for (HRegionInfo region : regions) {\n        if (region.isMetaRegion()) {\n          isCarryingMeta = true;\n          break;\n        }\n      }\n      if (!isCarryingMeta) {\n        continue;\n      }\n      break;\n    }\n\n    LOG.info(\"#regions = \" + regions.size());\n    Iterator<HRegionInfo> it = regions.iterator();\n    while (it.hasNext()) {\n      HRegionInfo region = it.next();\n      if (region.isMetaTable()) {\n        it.remove();\n      }\n    }\n    makeHLog(hrs.getWAL(), regions, \"table\", \"family\", NUM_LOG_LINES, 100);\n\n    this.abortRSAndVerifyRecovery(hrs, ht, zkw, NUM_REGIONS_TO_CREATE, NUM_LOG_LINES);\n    ht.close();\n  }","id":49001,"modified_method":"@Test(timeout = 300000)\n  public void testLogReplayWithMetaRSDown() throws Exception {\n    LOG.info(\"testRecoveredEditsReplayWithMetaRSDown\");\n    Configuration curConf = HBaseConfiguration.create();\n    curConf.setBoolean(HConstants.DISTRIBUTED_LOG_REPLAY_KEY, true);\n    startCluster(NUM_RS, curConf);\n    final int NUM_REGIONS_TO_CREATE = 40;\n    final int NUM_LOG_LINES = 1000;\n    // turn off load balancing to prevent regions from moving around otherwise\n    // they will consume recovered.edits\n    master.balanceSwitch(false);\n\n    List<RegionServerThread> rsts = cluster.getLiveRegionServerThreads();\n    final ZooKeeperWatcher zkw = new ZooKeeperWatcher(conf, \"table-creation\", null);\n    HTable ht = installTable(zkw, \"table\", \"family\", NUM_REGIONS_TO_CREATE);\n\n    HRegionServer hrs = findRSToKill(true, \"table\");\n    List<HRegionInfo> regions = ProtobufUtil.getOnlineRegions(hrs);\n    makeHLog(hrs.getWAL(), regions, \"table\", \"family\", NUM_LOG_LINES, 100);\n\n    this.abortRSAndVerifyRecovery(hrs, ht, zkw, NUM_REGIONS_TO_CREATE, NUM_LOG_LINES);\n    ht.close();\n    zkw.close();\n  }","commit_id":"4a6de45f7655363fc8a0bf656d282a0ae1c73aff","url":"https://github.com/apache/hbase"},{"original_method":"@Test(timeout = 300000)\n  public void testLogReplayWithNonMetaRSDown() throws Exception {\n    LOG.info(\"testLogReplayWithNonMetaRSDown\");\n    Configuration curConf = HBaseConfiguration.create();\n    curConf.setLong(\"hbase.regionserver.hlog.blocksize\", 100*1024);\n    curConf.setBoolean(HConstants.DISTRIBUTED_LOG_REPLAY_KEY, true);\n    startCluster(NUM_RS, curConf);\n    final int NUM_REGIONS_TO_CREATE = 40;\n    final int NUM_LOG_LINES = 1000;\n    // turn off load balancing to prevent regions from moving around otherwise\n    // they will consume recovered.edits\n    master.balanceSwitch(false);\n\n    List<RegionServerThread> rsts = cluster.getLiveRegionServerThreads();\n    final ZooKeeperWatcher zkw = new ZooKeeperWatcher(conf, \"table-creation\", null);\n    HTable ht = installTable(zkw, \"table\", \"family\", NUM_REGIONS_TO_CREATE);\n\n    List<HRegionInfo> regions = null;\n    HRegionServer hrs = null;\n    for (int i = 0; i < NUM_RS; i++) {\n      boolean isCarryingMeta = false;\n      hrs = rsts.get(i).getRegionServer();\n      regions = ProtobufUtil.getOnlineRegions(hrs);\n      for (HRegionInfo region : regions) {\n        if (region.isMetaRegion()) {\n          isCarryingMeta = true;\n          break;\n        }\n      }\n      if (isCarryingMeta) {\n        continue;\n      }\n      break;\n    }\n\n    LOG.info(\"#regions = \" + regions.size());\n    Iterator<HRegionInfo> it = regions.iterator();\n    while (it.hasNext()) {\n      HRegionInfo region = it.next();\n      if (region.isMetaTable()) {\n        it.remove();\n      }\n    }\n    makeHLog(hrs.getWAL(), regions, \"table\", \"family\", NUM_LOG_LINES, 100);\n\n    // wait for abort completes\n    this.abortRSAndVerifyRecovery(hrs, ht, zkw, NUM_REGIONS_TO_CREATE, NUM_LOG_LINES);\n    ht.close();\n  }","id":49002,"modified_method":"@Test(timeout = 300000)\n  public void testLogReplayWithNonMetaRSDown() throws Exception {\n    LOG.info(\"testLogReplayWithNonMetaRSDown\");\n    Configuration curConf = HBaseConfiguration.create();\n    curConf.setLong(\"hbase.regionserver.hlog.blocksize\", 100*1024);\n    curConf.setBoolean(HConstants.DISTRIBUTED_LOG_REPLAY_KEY, true);\n    startCluster(NUM_RS, curConf);\n    final int NUM_REGIONS_TO_CREATE = 40;\n    final int NUM_LOG_LINES = 1000;\n    // turn off load balancing to prevent regions from moving around otherwise\n    // they will consume recovered.edits\n    master.balanceSwitch(false);\n\n    List<RegionServerThread> rsts = cluster.getLiveRegionServerThreads();\n    final ZooKeeperWatcher zkw = new ZooKeeperWatcher(conf, \"table-creation\", null);\n    HTable ht = installTable(zkw, \"table\", \"family\", NUM_REGIONS_TO_CREATE);\n\n    HRegionServer hrs = findRSToKill(false, \"table\");\n    List<HRegionInfo> regions = ProtobufUtil.getOnlineRegions(hrs);\n    makeHLog(hrs.getWAL(), regions, \"table\", \"family\", NUM_LOG_LINES, 100);\n\n    // wait for abort completes\n    this.abortRSAndVerifyRecovery(hrs, ht, zkw, NUM_REGIONS_TO_CREATE, NUM_LOG_LINES);\n    ht.close();\n    zkw.close();\n  }","commit_id":"4a6de45f7655363fc8a0bf656d282a0ae1c73aff","url":"https://github.com/apache/hbase"},{"original_method":"@Test(timeout = 300000)\n  public void testLogReplayForDisablingTable() throws Exception {\n    LOG.info(\"testLogReplayWithNonMetaRSDown\");\n    Configuration curConf = HBaseConfiguration.create();\n    curConf.setBoolean(HConstants.DISTRIBUTED_LOG_REPLAY_KEY, true);\n    startCluster(NUM_RS, curConf);\n    final int NUM_REGIONS_TO_CREATE = 40;\n    final int NUM_LOG_LINES = 1000;\n\n    List<RegionServerThread> rsts = cluster.getLiveRegionServerThreads();\n    final ZooKeeperWatcher zkw = new ZooKeeperWatcher(conf, \"table-creation\", null);\n    HTable disablingHT = installTable(zkw, \"disableTable\", \"family\", NUM_REGIONS_TO_CREATE);\n    HTable ht = installTable(zkw, \"table\", \"family\", NUM_REGIONS_TO_CREATE, NUM_REGIONS_TO_CREATE);\n\n    // turn off load balancing to prevent regions from moving around otherwise\n    // they will consume recovered.edits\n    master.balanceSwitch(false);\n\n    List<HRegionInfo> regions = null;\n    HRegionServer hrs = null;\n    boolean hasRegionsForBothTables = false;\n    String tableName = null;\n    for (int i = 0; i < NUM_RS; i++) {\n      tableName = null;\n      hasRegionsForBothTables = false;\n      boolean isCarryingMeta = false;\n      hrs = rsts.get(i).getRegionServer();\n      regions = ProtobufUtil.getOnlineRegions(hrs);\n      for (HRegionInfo region : regions) {\n        if (region.isMetaRegion()) {\n          isCarryingMeta = true;\n          break;\n        }\n        if (tableName != null && !tableName.equalsIgnoreCase(region.getTableNameAsString())) {\n          // make sure that we find a RS has online regions for both \"table\" and \"disableTable\"\n          hasRegionsForBothTables = true;\n          break;\n        } else if (tableName == null) {\n          tableName = region.getTableNameAsString();\n        }\n      }\n      if (isCarryingMeta) {\n        continue;\n      }\n      if (hasRegionsForBothTables) {\n        break;\n      }\n    }\n\n    // make sure we found a good RS\n    Assert.assertTrue(hasRegionsForBothTables);\n\n    LOG.info(\"#regions = \" + regions.size());\n    Iterator<HRegionInfo> it = regions.iterator();\n    while (it.hasNext()) {\n      HRegionInfo region = it.next();\n      if (region.isMetaTable()) {\n        it.remove();\n      }\n    }\n    makeHLog(hrs.getWAL(), regions, \"disableTable\", \"family\", NUM_LOG_LINES, 100, false);\n    makeHLog(hrs.getWAL(), regions, \"table\", \"family\", NUM_LOG_LINES, 100);\n    \n    LOG.info(\"Disabling table\\n\");\n    TEST_UTIL.getHBaseAdmin().disableTable(Bytes.toBytes(\"disableTable\"));\n    \n    // abort RS\n    LOG.info(\"Aborting region server: \" + hrs.getServerName());\n    hrs.abort(\"testing\");\n\n    // wait for abort completes\n    TEST_UTIL.waitFor(120000, 200, new Waiter.Predicate<Exception>() {\n      @Override\n      public boolean evaluate() throws Exception {\n        return (cluster.getLiveRegionServerThreads().size() <= (NUM_RS - 1));\n      }\n    });\n\n    // wait for regions come online\n    TEST_UTIL.waitFor(180000, 200, new Waiter.Predicate<Exception>() {\n      @Override\n      public boolean evaluate() throws Exception {\n        return (getAllOnlineRegions(cluster).size() >= (NUM_REGIONS_TO_CREATE + 1));\n      }\n    });\n\n    // wait for all regions are fully recovered\n    TEST_UTIL.waitFor(180000, 200, new Waiter.Predicate<Exception>() {\n      @Override\n      public boolean evaluate() throws Exception {\n        List<String> recoveringRegions = zkw.getRecoverableZooKeeper().getChildren(\n          zkw.recoveringRegionsZNode, false);\n        return (recoveringRegions != null && recoveringRegions.size() == 0);\n      }\n    });\n\n    int count = 0;\n    FileSystem fs = master.getMasterFileSystem().getFileSystem();\n    Path rootdir = FSUtils.getRootDir(conf);\n    Path tdir = HTableDescriptor.getTableDir(rootdir, Bytes.toBytes(\"disableTable\"));\n    for (HRegionInfo hri : regions) {\n      @SuppressWarnings(\"deprecation\")\n      Path editsdir =\n        HLogUtil.getRegionDirRecoveredEditsDir(HRegion.getRegionDir(tdir, hri.getEncodedName()));\n      LOG.debug(\"checking edits dir \" + editsdir);\n      if(!fs.exists(editsdir)) continue;\n      FileStatus[] files = fs.listStatus(editsdir);\n      if(files != null) {\n        for(FileStatus file : files) {\n          int c = countHLog(file.getPath(), fs, conf);\n          count += c;\n          LOG.info(c + \" edits in \" + file.getPath());\n        }\n      }\n    }\n\n    LOG.info(\"Verify edits in recovered.edits files\");\n    assertEquals(NUM_LOG_LINES, count);\n    LOG.info(\"Verify replayed edits\");\n    assertEquals(NUM_LOG_LINES, TEST_UTIL.countRows(ht));\n    \n    // clean up\n    for (HRegionInfo hri : regions) {\n      @SuppressWarnings(\"deprecation\")\n      Path editsdir =\n        HLogUtil.getRegionDirRecoveredEditsDir(HRegion.getRegionDir(tdir, hri.getEncodedName()));\n      fs.delete(editsdir, true);\n    }\n    disablingHT.close();\n    ht.close();\n  }","id":49003,"modified_method":"@Test(timeout = 300000)\n  public void testLogReplayForDisablingTable() throws Exception {\n    LOG.info(\"testLogReplayWithNonMetaRSDown\");\n    Configuration curConf = HBaseConfiguration.create();\n    curConf.setBoolean(HConstants.DISTRIBUTED_LOG_REPLAY_KEY, true);\n    startCluster(NUM_RS, curConf);\n    final int NUM_REGIONS_TO_CREATE = 40;\n    final int NUM_LOG_LINES = 1000;\n\n    List<RegionServerThread> rsts = cluster.getLiveRegionServerThreads();\n    final ZooKeeperWatcher zkw = new ZooKeeperWatcher(conf, \"table-creation\", null);\n    HTable disablingHT = installTable(zkw, \"disableTable\", \"family\", NUM_REGIONS_TO_CREATE);\n    HTable ht = installTable(zkw, \"table\", \"family\", NUM_REGIONS_TO_CREATE, NUM_REGIONS_TO_CREATE);\n\n    // turn off load balancing to prevent regions from moving around otherwise\n    // they will consume recovered.edits\n    master.balanceSwitch(false);\n\n    List<HRegionInfo> regions = null;\n    HRegionServer hrs = null;\n    boolean hasRegionsForBothTables = false;\n    String tableName = null;\n    for (int i = 0; i < NUM_RS; i++) {\n      tableName = null;\n      hasRegionsForBothTables = false;\n      boolean isCarryingMeta = false;\n      hrs = rsts.get(i).getRegionServer();\n      regions = ProtobufUtil.getOnlineRegions(hrs);\n      for (HRegionInfo region : regions) {\n        if (region.isMetaRegion()) {\n          isCarryingMeta = true;\n          break;\n        }\n        if (tableName != null && !tableName.equalsIgnoreCase(region.getTableNameAsString())) {\n          // make sure that we find a RS has online regions for both \"table\" and \"disableTable\"\n          hasRegionsForBothTables = true;\n          break;\n        } else if (tableName == null) {\n          tableName = region.getTableNameAsString();\n        }\n      }\n      if (isCarryingMeta) {\n        continue;\n      }\n      if (hasRegionsForBothTables) {\n        break;\n      }\n    }\n\n    // make sure we found a good RS\n    Assert.assertTrue(hasRegionsForBothTables);\n\n    LOG.info(\"#regions = \" + regions.size());\n    Iterator<HRegionInfo> it = regions.iterator();\n    while (it.hasNext()) {\n      HRegionInfo region = it.next();\n      if (region.isMetaTable()) {\n        it.remove();\n      }\n    }\n    makeHLog(hrs.getWAL(), regions, \"disableTable\", \"family\", NUM_LOG_LINES, 100, false);\n    makeHLog(hrs.getWAL(), regions, \"table\", \"family\", NUM_LOG_LINES, 100);\n    \n    LOG.info(\"Disabling table\\n\");\n    TEST_UTIL.getHBaseAdmin().disableTable(Bytes.toBytes(\"disableTable\"));\n    \n    // abort RS\n    LOG.info(\"Aborting region server: \" + hrs.getServerName());\n    hrs.abort(\"testing\");\n\n    // wait for abort completes\n    TEST_UTIL.waitFor(120000, 200, new Waiter.Predicate<Exception>() {\n      @Override\n      public boolean evaluate() throws Exception {\n        return (cluster.getLiveRegionServerThreads().size() <= (NUM_RS - 1));\n      }\n    });\n\n    // wait for regions come online\n    TEST_UTIL.waitFor(180000, 200, new Waiter.Predicate<Exception>() {\n      @Override\n      public boolean evaluate() throws Exception {\n        return (getAllOnlineRegions(cluster).size() >= (NUM_REGIONS_TO_CREATE + 1));\n      }\n    });\n\n    // wait for all regions are fully recovered\n    TEST_UTIL.waitFor(180000, 200, new Waiter.Predicate<Exception>() {\n      @Override\n      public boolean evaluate() throws Exception {\n        List<String> recoveringRegions = zkw.getRecoverableZooKeeper().getChildren(\n          zkw.recoveringRegionsZNode, false);\n        return (recoveringRegions != null && recoveringRegions.size() == 0);\n      }\n    });\n\n    int count = 0;\n    FileSystem fs = master.getMasterFileSystem().getFileSystem();\n    Path rootdir = FSUtils.getRootDir(conf);\n    Path tdir = HTableDescriptor.getTableDir(rootdir, Bytes.toBytes(\"disableTable\"));\n    for (HRegionInfo hri : regions) {\n      @SuppressWarnings(\"deprecation\")\n      Path editsdir =\n        HLogUtil.getRegionDirRecoveredEditsDir(HRegion.getRegionDir(tdir, hri.getEncodedName()));\n      LOG.debug(\"checking edits dir \" + editsdir);\n      if(!fs.exists(editsdir)) continue;\n      FileStatus[] files = fs.listStatus(editsdir);\n      if(files != null) {\n        for(FileStatus file : files) {\n          int c = countHLog(file.getPath(), fs, conf);\n          count += c;\n          LOG.info(c + \" edits in \" + file.getPath());\n        }\n      }\n    }\n\n    LOG.info(\"Verify edits in recovered.edits files\");\n    assertEquals(NUM_LOG_LINES, count);\n    LOG.info(\"Verify replayed edits\");\n    assertEquals(NUM_LOG_LINES, TEST_UTIL.countRows(ht));\n    \n    // clean up\n    for (HRegionInfo hri : regions) {\n      @SuppressWarnings(\"deprecation\")\n      Path editsdir =\n        HLogUtil.getRegionDirRecoveredEditsDir(HRegion.getRegionDir(tdir, hri.getEncodedName()));\n      fs.delete(editsdir, true);\n    }\n    disablingHT.close();\n    ht.close();\n    zkw.close();\n  }","commit_id":"4a6de45f7655363fc8a0bf656d282a0ae1c73aff","url":"https://github.com/apache/hbase"},{"original_method":"private String getSuitableIpForRancid(OnmsNode node){\n        OnmsIpInterface primaryInterface = node.getPrimaryInterface();\n        \n        if (primaryInterface == null) {\n            Set<OnmsIpInterface> ipInterfaces = node.getIpInterfaces();\n            for (OnmsIpInterface onmsIpInterface : ipInterfaces) {\n                    return onmsIpInterface.getIpAddress();\n            }\n        }\n        return primaryInterface.getIpAddress();\n    }","id":49004,"modified_method":"private String getSuitableIpForRancid(OnmsNode node){\n        log().debug(\"getSuitableIpForRancid: node: \" + node.getNodeId() + \" Foreign Source: \" + node.getForeignSource());\n        OnmsIpInterface primaryInterface = node.getPrimaryInterface();\n        String ipaddr = \"127.0.0.1\";\n        if (primaryInterface == null) {\n            log().debug(\"getSuitableIpForRancid: found null Snmp Primary Interface, getting interfaces\");\n            Set<OnmsIpInterface> ipInterfaces = node.getIpInterfaces();\n            for (OnmsIpInterface onmsIpInterface : ipInterfaces) {\n                log().debug(\"getSuitableIpForRancid: trying Interface with id: \" + onmsIpInterface.getId());\n                if (onmsIpInterface.getIpAddress() != null) \n                    ipaddr = onmsIpInterface.getIpAddress();\n                else \n                    log().debug(\"getSuitableIpForRancid: found null ip address on Interface with id: \" + onmsIpInterface.getId());\n\n            }\n        } else {        \n            log().debug(\"getSuitableIpForRancid: found Snmp Primary Interface\");\n            if (primaryInterface.getIpAddress() != null )\n                ipaddr = primaryInterface.getIpAddress();\n            else \n                log().debug(\"getSuitableIpForRancid: found null ip address on Primary Interface\");\n        }\n        return ipaddr;\n    }","commit_id":"fd6f3e1e9c1b2e193c797055d1d5ae34706d562a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getSuitableIpForRancid(OnmsNode node){\n        OnmsIpInterface primaryInterface = node.getPrimaryInterface();\n        \n        if (primaryInterface == null) {\n            Set<OnmsIpInterface> ipInterfaces = node.getIpInterfaces();\n            for (OnmsIpInterface onmsIpInterface : ipInterfaces) {\n                    return onmsIpInterface.getIpAddress();\n            }\n        }\n        return primaryInterface.getIpAddress();\n    }","id":49005,"modified_method":"private String getSuitableIpForRancid(OnmsNode node){\n        log().debug(\"getSuitableIpForRancid: node: \" + node.getNodeId() + \" Foreign Source: \" + node.getForeignSource());\n        OnmsIpInterface primaryInterface = node.getPrimaryInterface();\n        String ipaddr = \"127.0.0.1\";\n        if (primaryInterface == null) {\n            log().debug(\"getSuitableIpForRancid: found null Snmp Primary Interface, getting interfaces\");\n            Set<OnmsIpInterface> ipInterfaces = node.getIpInterfaces();\n            for (OnmsIpInterface onmsIpInterface : ipInterfaces) {\n                log().debug(\"getSuitableIpForRancid: trying Interface with id: \" + onmsIpInterface.getId());\n                if (onmsIpInterface.getIpAddress() != null) \n                    ipaddr = onmsIpInterface.getIpAddress();\n                else \n                    log().debug(\"getSuitableIpForRancid: found null ip address on Interface with id: \" + onmsIpInterface.getId());\n\n            }\n        } else {        \n            log().debug(\"getSuitableIpForRancid: found Snmp Primary Interface\");\n            if (primaryInterface.getIpAddress() != null )\n                ipaddr = primaryInterface.getIpAddress();\n            else \n                log().debug(\"getSuitableIpForRancid: found null ip address on Primary Interface\");\n        }\n        return ipaddr;\n    }","commit_id":"47bdf22b2b7cc557bb4301f1e1c0d18528033d0b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getSuitableIpForRancid(OnmsNode node){\n        OnmsIpInterface primaryInterface = node.getPrimaryInterface();\n        \n        if (primaryInterface == null) {\n            Set<OnmsIpInterface> ipInterfaces = node.getIpInterfaces();\n            for (OnmsIpInterface onmsIpInterface : ipInterfaces) {\n                    return onmsIpInterface.getIpAddress();\n            }\n        }\n        return primaryInterface.getIpAddress();\n    }","id":49006,"modified_method":"private String getSuitableIpForRancid(OnmsNode node){\n        log().debug(\"getSuitableIpForRancid: node: \" + node.getNodeId() + \" Foreign Source: \" + node.getForeignSource());\n        OnmsIpInterface primaryInterface = node.getPrimaryInterface();\n        String ipaddr = \"127.0.0.1\";\n        if (primaryInterface == null) {\n            log().debug(\"getSuitableIpForRancid: found null Snmp Primary Interface, getting interfaces\");\n            Set<OnmsIpInterface> ipInterfaces = node.getIpInterfaces();\n            for (OnmsIpInterface onmsIpInterface : ipInterfaces) {\n                log().debug(\"getSuitableIpForRancid: trying Interface with id: \" + onmsIpInterface.getId());\n                if (onmsIpInterface.getIpAddress() != null) \n                    ipaddr = onmsIpInterface.getIpAddress();\n                else \n                    log().debug(\"getSuitableIpForRancid: found null ip address on Interface with id: \" + onmsIpInterface.getId());\n\n            }\n        } else {        \n            log().debug(\"getSuitableIpForRancid: found Snmp Primary Interface\");\n            if (primaryInterface.getIpAddress() != null )\n                ipaddr = primaryInterface.getIpAddress();\n            else \n                log().debug(\"getSuitableIpForRancid: found null ip address on Primary Interface\");\n        }\n        return ipaddr;\n    }","commit_id":"2bde133d6aaa77ec58525616983a26158af594fa","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n      primeNext();\n    }","id":49007,"modified_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n    }","commit_id":"bdf94768c2d2061ca6f244ac02a4595aff1e123c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void remove() {\n      throw new UnsupportedOperationException();\n    }","id":49008,"modified_method":"public void remove() {\n      edgeIterator.remove();\n    }","commit_id":"bdf94768c2d2061ca6f244ac02a4595aff1e123c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean hasNext() {\n      return next != null;\n    }","id":49009,"modified_method":"public boolean hasNext() {\n      primeIterator();\n      return hasNext;\n    }","commit_id":"bdf94768c2d2061ca6f244ac02a4595aff1e123c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public E next() {\n      if (next == null) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      E value = next;\n      primeNext();\n      return value;\n    }","id":49010,"modified_method":"public E next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      return edgeIterator.next();\n    }","commit_id":"bdf94768c2d2061ca6f244ac02a4595aff1e123c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap(graph.outgoingEdges);\n    incomingEdges = Generics.newHashMap(graph.incomingEdges);\n  }","id":49011,"modified_method":"/**\n   * Creates a copy of the given graph. This will copy the entire data structure (this may be slow!), but will not copy\n   * any of the edge or vertex objects.\n   *\n   * @param graph The graph to copy into this object.\n   */\n  public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap();\n    incomingEdges = Generics.newHashMap();\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.outgoingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.outgoingEdges.put(map.getKey(), edgesCopy);\n    }\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.incomingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.incomingEdges.put(map.getKey(), edgesCopy);\n    }\n  }","commit_id":"bdf94768c2d2061ca6f244ac02a4595aff1e123c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      connectionIterator = neighbors.values().iterator();\n      primeNext();\n    }","id":49012,"modified_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      vertexIterator = null;\n      connectionIterator = neighbors.values().iterator();\n    }","commit_id":"bdf94768c2d2061ca6f244ac02a4595aff1e123c","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public int getOutDegree(V vertex) {\n    int result = 0;\n    Map<V, List<E>> outgoing = outgoingEdges.get(vertex);\n    if (outgoing == null) {\n      throw new IllegalArgumentException(\"Unknown vertex \" + vertex);\n    }\n    for (List<E> edges : outgoing.values()) {\n      result += edges.size();\n    }\n    return result;\n  }","id":49013,"modified_method":"public int getOutDegree(V vertex) {\n    int result = 0;\n    Map<V, List<E>> outgoing = outgoingEdges.get(vertex);\n    if (outgoing == null) {\n      return 0;\n    }\n    for (List<E> edges : outgoing.values()) {\n      result += edges.size();\n    }\n    return result;\n  }","commit_id":"824082170ba8b8592b80e444e78f3a2dd5241c20","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean removeEdge(V source, V dest, E data) {\n    if (!outgoingEdges.containsKey(source)) {\n      return false;\n    }\n    if (!incomingEdges.containsKey(dest)) {\n      return false;\n    }\n    if (!outgoingEdges.get(source).containsKey(dest)) {\n      return false;\n    }\n    boolean foundOut = outgoingEdges.get(source).get(dest).remove(data);\n    boolean foundIn = incomingEdges.get(dest).get(source).remove(data);\n    if (foundOut && !foundIn) {\n      throw new AssertionError(\"Edge found in outgoing but not incoming\");\n    }\n    if (foundIn && !foundOut) {\n      throw new AssertionError(\"Edge found in incoming but not outgoing\");\n    }\n    // TODO: cut down the number of .get calls\n    if (outgoingEdges.get(source).get(dest).size() == 0) {\n      outgoingEdges.get(source).remove(dest);\n    }\n    if (incomingEdges.get(dest).get(source).size() == 0) {\n      incomingEdges.get(dest).remove(source);\n    }\n    return foundOut;\n  }","id":49014,"modified_method":"public boolean removeEdge(V source, V dest, E data) {\n    if (!outgoingEdges.containsKey(source)) {\n      return false;\n    }\n    if (!incomingEdges.containsKey(dest)) {\n      return false;\n    }\n    if (!outgoingEdges.get(source).containsKey(dest)) {\n      return false;\n    }\n    boolean foundOut = outgoingEdges.containsKey(source) && outgoingEdges.get(source).containsKey(dest) &&\n        outgoingEdges.get(source).get(dest).remove(data);\n    boolean foundIn = incomingEdges.containsKey(dest) && incomingEdges.get(dest).containsKey(source) &&\n        incomingEdges.get(dest).get(source).remove(data);\n    if (foundOut && !foundIn) {\n      throw new AssertionError(\"Edge found in outgoing but not incoming\");\n    }\n    if (foundIn && !foundOut) {\n      throw new AssertionError(\"Edge found in incoming but not outgoing\");\n    }\n    // TODO: cut down the number of .get calls\n    if (outgoingEdges.containsKey(source) && (!outgoingEdges.get(source).containsKey(dest) || outgoingEdges.get(source).get(dest).size() == 0)) {\n      outgoingEdges.get(source).remove(dest);\n    }\n    if (incomingEdges.containsKey(dest) && (!incomingEdges.get(dest).containsKey(source) || incomingEdges.get(dest).get(source).size() == 0)) {\n      incomingEdges.get(dest).remove(source);\n    }\n    return foundOut;\n  }","commit_id":"824082170ba8b8592b80e444e78f3a2dd5241c20","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void remove() {\n      throw new UnsupportedOperationException();\n    }","id":49015,"modified_method":"public void remove() {\n      edgeIterator.remove();\n    }","commit_id":"824082170ba8b8592b80e444e78f3a2dd5241c20","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n      primeNext();\n    }","id":49016,"modified_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n    }","commit_id":"824082170ba8b8592b80e444e78f3a2dd5241c20","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean hasNext() {\n      return next != null;\n    }","id":49017,"modified_method":"public boolean hasNext() {\n      primeIterator();\n      return hasNext;\n    }","commit_id":"824082170ba8b8592b80e444e78f3a2dd5241c20","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public List<E> getOutgoingEdges(V v) {\n    return CollectionUtils.flatten(outgoingEdges.get(v).values());\n  }","id":49018,"modified_method":"public List<E> getOutgoingEdges(V v) {\n    if (!outgoingEdges.containsKey(v)) { //noinspection unchecked\n      return Collections.EMPTY_LIST;\n    }\n    return CollectionUtils.flatten(outgoingEdges.get(v).values());\n  }","commit_id":"824082170ba8b8592b80e444e78f3a2dd5241c20","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      connectionIterator = neighbors.values().iterator();\n      primeNext();\n    }","id":49019,"modified_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      vertexIterator = null;\n      connectionIterator = neighbors.values().iterator();\n    }","commit_id":"824082170ba8b8592b80e444e78f3a2dd5241c20","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public E next() {\n      if (next == null) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      E value = next;\n      primeNext();\n      return value;\n    }","id":49020,"modified_method":"public E next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      return edgeIterator.next();\n    }","commit_id":"824082170ba8b8592b80e444e78f3a2dd5241c20","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap(graph.outgoingEdges);\n    incomingEdges = Generics.newHashMap(graph.incomingEdges);\n  }","id":49021,"modified_method":"/**\n   * Creates a copy of the given graph. This will copy the entire data structure (this may be slow!), but will not copy\n   * any of the edge or vertex objects.\n   *\n   * @param graph The graph to copy into this object.\n   */\n  public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap();\n    incomingEdges = Generics.newHashMap();\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.outgoingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.outgoingEdges.put(map.getKey(), edgesCopy);\n    }\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.incomingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.incomingEdges.put(map.getKey(), edgesCopy);\n    }\n  }","commit_id":"824082170ba8b8592b80e444e78f3a2dd5241c20","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public int getInDegree(V vertex) {\n    if (!containsVertex(vertex)) {\n      throw new IllegalArgumentException(\"Unknown vertex \" + vertex);\n    }\n    int result = 0;\n    Map<V, List<E>> incoming = incomingEdges.get(vertex);\n    for (List<E> edges : incoming.values()) {\n      result += edges.size();\n    }\n    return result;\n  }","id":49022,"modified_method":"public int getInDegree(V vertex) {\n    if (!containsVertex(vertex)) {\n      return 0;\n    }\n    int result = 0;\n    Map<V, List<E>> incoming = incomingEdges.get(vertex);\n    for (List<E> edges : incoming.values()) {\n      result += edges.size();\n    }\n    return result;\n  }","commit_id":"824082170ba8b8592b80e444e78f3a2dd5241c20","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public List<E> getIncomingEdges(V v) {\n    return CollectionUtils.flatten(incomingEdges.get(v).values());\n  }","id":49023,"modified_method":"public List<E> getIncomingEdges(V v) {\n    if (!incomingEdges.containsKey(v)) { //noinspection unchecked\n      return Collections.EMPTY_LIST;\n    }\n    return CollectionUtils.flatten(incomingEdges.get(v).values());\n  }","commit_id":"824082170ba8b8592b80e444e78f3a2dd5241c20","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n      primeNext();\n    }","id":49024,"modified_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n    }","commit_id":"06e29dd8645a221811673510bc14c5ccb0f398e1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public E next() {\n      if (next == null) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      E value = next;\n      primeNext();\n      return value;\n    }","id":49025,"modified_method":"public E next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      return edgeIterator.next();\n    }","commit_id":"06e29dd8645a221811673510bc14c5ccb0f398e1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void remove() {\n      throw new UnsupportedOperationException();\n    }","id":49026,"modified_method":"public void remove() {\n      edgeIterator.remove();\n    }","commit_id":"06e29dd8645a221811673510bc14c5ccb0f398e1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean hasNext() {\n      return next != null;\n    }","id":49027,"modified_method":"public boolean hasNext() {\n      primeIterator();\n      return hasNext;\n    }","commit_id":"06e29dd8645a221811673510bc14c5ccb0f398e1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      connectionIterator = neighbors.values().iterator();\n      primeNext();\n    }","id":49028,"modified_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      vertexIterator = null;\n      connectionIterator = neighbors.values().iterator();\n    }","commit_id":"06e29dd8645a221811673510bc14c5ccb0f398e1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap(graph.outgoingEdges);\n    incomingEdges = Generics.newHashMap(graph.incomingEdges);\n  }","id":49029,"modified_method":"/**\n   * Creates a copy of the given graph. This will copy the entire data structure (this may be slow!), but will not copy\n   * any of the edge or vertex objects.\n   *\n   * @param graph The graph to copy into this object.\n   */\n  public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap();\n    incomingEdges = Generics.newHashMap();\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.outgoingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.outgoingEdges.put(map.getKey(), edgesCopy);\n    }\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.incomingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.incomingEdges.put(map.getKey(), edgesCopy);\n    }\n  }","commit_id":"06e29dd8645a221811673510bc14c5ccb0f398e1","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public E next() {\n      if (next == null) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      E value = next;\n      primeNext();\n      return value;\n    }","id":49030,"modified_method":"public E next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      return edgeIterator.next();\n    }","commit_id":"498e1f56f6b80d4c447deec5a04a1580b2e74c43","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap(graph.outgoingEdges);\n    incomingEdges = Generics.newHashMap(graph.incomingEdges);\n  }","id":49031,"modified_method":"/**\n   * Creates a copy of the given graph. This will copy the entire data structure (this may be slow!), but will not copy\n   * any of the edge or vertex objects.\n   *\n   * @param graph The graph to copy into this object.\n   */\n  public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap();\n    incomingEdges = Generics.newHashMap();\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.outgoingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.outgoingEdges.put(map.getKey(), edgesCopy);\n    }\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.incomingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.incomingEdges.put(map.getKey(), edgesCopy);\n    }\n  }","commit_id":"498e1f56f6b80d4c447deec5a04a1580b2e74c43","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n      primeNext();\n    }","id":49032,"modified_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n    }","commit_id":"498e1f56f6b80d4c447deec5a04a1580b2e74c43","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean hasNext() {\n      return next != null;\n    }","id":49033,"modified_method":"public boolean hasNext() {\n      primeIterator();\n      return hasNext;\n    }","commit_id":"498e1f56f6b80d4c447deec5a04a1580b2e74c43","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      connectionIterator = neighbors.values().iterator();\n      primeNext();\n    }","id":49034,"modified_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      vertexIterator = null;\n      connectionIterator = neighbors.values().iterator();\n    }","commit_id":"498e1f56f6b80d4c447deec5a04a1580b2e74c43","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void remove() {\n      throw new UnsupportedOperationException();\n    }","id":49035,"modified_method":"public void remove() {\n      edgeIterator.remove();\n    }","commit_id":"498e1f56f6b80d4c447deec5a04a1580b2e74c43","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n      primeNext();\n    }","id":49036,"modified_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n    }","commit_id":"a29cfd421907d438b7d5ef3810da04d2a94d5340","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean hasNext() {\n      return next != null;\n    }","id":49037,"modified_method":"public boolean hasNext() {\n      primeIterator();\n      return hasNext;\n    }","commit_id":"a29cfd421907d438b7d5ef3810da04d2a94d5340","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public E next() {\n      if (next == null) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      E value = next;\n      primeNext();\n      return value;\n    }","id":49038,"modified_method":"public E next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      return edgeIterator.next();\n    }","commit_id":"a29cfd421907d438b7d5ef3810da04d2a94d5340","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap(graph.outgoingEdges);\n    incomingEdges = Generics.newHashMap(graph.incomingEdges);\n  }","id":49039,"modified_method":"/**\n   * Creates a copy of the given graph. This will copy the entire data structure (this may be slow!), but will not copy\n   * any of the edge or vertex objects.\n   *\n   * @param graph The graph to copy into this object.\n   */\n  public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap();\n    incomingEdges = Generics.newHashMap();\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.outgoingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.outgoingEdges.put(map.getKey(), edgesCopy);\n    }\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.incomingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.incomingEdges.put(map.getKey(), edgesCopy);\n    }\n  }","commit_id":"a29cfd421907d438b7d5ef3810da04d2a94d5340","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      connectionIterator = neighbors.values().iterator();\n      primeNext();\n    }","id":49040,"modified_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      vertexIterator = null;\n      connectionIterator = neighbors.values().iterator();\n    }","commit_id":"a29cfd421907d438b7d5ef3810da04d2a94d5340","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void remove() {\n      throw new UnsupportedOperationException();\n    }","id":49041,"modified_method":"public void remove() {\n      edgeIterator.remove();\n    }","commit_id":"a29cfd421907d438b7d5ef3810da04d2a94d5340","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public List<E> getIncomingEdges(V v) {\n    return CollectionUtils.flatten(incomingEdges.get(v).values());\n  }","id":49042,"modified_method":"public List<E> getIncomingEdges(V v) {\n    if (!incomingEdges.containsKey(v)) { //noinspection unchecked\n      return Collections.EMPTY_LIST;\n    }\n    return CollectionUtils.flatten(incomingEdges.get(v).values());\n  }","commit_id":"18c03e37caef932f09e37089c44c5e272b3f86e3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      connectionIterator = neighbors.values().iterator();\n      primeNext();\n    }","id":49043,"modified_method":"public EdgeIterator(Map<V, Map<V, List<E>>> source, V startVertex) {\n      Map<V, List<E>> neighbors = source.get(startVertex);\n      if (neighbors == null) {\n        return;\n      }\n      vertexIterator = null;\n      connectionIterator = neighbors.values().iterator();\n    }","commit_id":"18c03e37caef932f09e37089c44c5e272b3f86e3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n      primeNext();\n    }","id":49044,"modified_method":"public EdgeIterator(DirectedMultiGraph<V, E> graph) {\n      vertexIterator = graph.outgoingEdges.values().iterator();\n    }","commit_id":"18c03e37caef932f09e37089c44c5e272b3f86e3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap(graph.outgoingEdges);\n    incomingEdges = Generics.newHashMap(graph.incomingEdges);\n  }","id":49045,"modified_method":"/**\n   * Creates a copy of the given graph. This will copy the entire data structure (this may be slow!), but will not copy\n   * any of the edge or vertex objects.\n   *\n   * @param graph The graph to copy into this object.\n   */\n  public DirectedMultiGraph(DirectedMultiGraph<V,E> graph) {\n    outgoingEdges = Generics.newHashMap();\n    incomingEdges = Generics.newHashMap();\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.outgoingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.outgoingEdges.put(map.getKey(), edgesCopy);\n    }\n    for (Map.Entry<V, Map<V, List<E>>> map : graph.incomingEdges.entrySet()) {\n      Map<V, List<E>> edgesCopy = Generics.newHashMap();\n      for (Map.Entry<V, List<E>> entry : map.getValue().entrySet()) {\n        edgesCopy.put(entry.getKey(), Generics.newArrayList(entry.getValue()));\n      }\n      this.incomingEdges.put(map.getKey(), edgesCopy);\n    }\n  }","commit_id":"18c03e37caef932f09e37089c44c5e272b3f86e3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public int getInDegree(V vertex) {\n    if (!containsVertex(vertex)) {\n      throw new IllegalArgumentException(\"Unknown vertex \" + vertex);\n    }\n    int result = 0;\n    Map<V, List<E>> incoming = incomingEdges.get(vertex);\n    for (List<E> edges : incoming.values()) {\n      result += edges.size();\n    }\n    return result;\n  }","id":49046,"modified_method":"public int getInDegree(V vertex) {\n    if (!containsVertex(vertex)) {\n      return 0;\n    }\n    int result = 0;\n    Map<V, List<E>> incoming = incomingEdges.get(vertex);\n    for (List<E> edges : incoming.values()) {\n      result += edges.size();\n    }\n    return result;\n  }","commit_id":"18c03e37caef932f09e37089c44c5e272b3f86e3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean removeEdge(V source, V dest, E data) {\n    if (!outgoingEdges.containsKey(source)) {\n      return false;\n    }\n    if (!incomingEdges.containsKey(dest)) {\n      return false;\n    }\n    if (!outgoingEdges.get(source).containsKey(dest)) {\n      return false;\n    }\n    boolean foundOut = outgoingEdges.get(source).get(dest).remove(data);\n    boolean foundIn = incomingEdges.get(dest).get(source).remove(data);\n    if (foundOut && !foundIn) {\n      throw new AssertionError(\"Edge found in outgoing but not incoming\");\n    }\n    if (foundIn && !foundOut) {\n      throw new AssertionError(\"Edge found in incoming but not outgoing\");\n    }\n    // TODO: cut down the number of .get calls\n    if (outgoingEdges.get(source).get(dest).size() == 0) {\n      outgoingEdges.get(source).remove(dest);\n    }\n    if (incomingEdges.get(dest).get(source).size() == 0) {\n      incomingEdges.get(dest).remove(source);\n    }\n    return foundOut;\n  }","id":49047,"modified_method":"public boolean removeEdge(V source, V dest, E data) {\n    if (!outgoingEdges.containsKey(source)) {\n      return false;\n    }\n    if (!incomingEdges.containsKey(dest)) {\n      return false;\n    }\n    if (!outgoingEdges.get(source).containsKey(dest)) {\n      return false;\n    }\n    boolean foundOut = outgoingEdges.containsKey(source) && outgoingEdges.get(source).containsKey(dest) &&\n        outgoingEdges.get(source).get(dest).remove(data);\n    boolean foundIn = incomingEdges.containsKey(dest) && incomingEdges.get(dest).containsKey(source) &&\n        incomingEdges.get(dest).get(source).remove(data);\n    if (foundOut && !foundIn) {\n      throw new AssertionError(\"Edge found in outgoing but not incoming\");\n    }\n    if (foundIn && !foundOut) {\n      throw new AssertionError(\"Edge found in incoming but not outgoing\");\n    }\n    // TODO: cut down the number of .get calls\n    if (outgoingEdges.containsKey(source) && (!outgoingEdges.get(source).containsKey(dest) || outgoingEdges.get(source).get(dest).size() == 0)) {\n      outgoingEdges.get(source).remove(dest);\n    }\n    if (incomingEdges.containsKey(dest) && (!incomingEdges.get(dest).containsKey(source) || incomingEdges.get(dest).get(source).size() == 0)) {\n      incomingEdges.get(dest).remove(source);\n    }\n    return foundOut;\n  }","commit_id":"18c03e37caef932f09e37089c44c5e272b3f86e3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public boolean hasNext() {\n      return next != null;\n    }","id":49048,"modified_method":"public boolean hasNext() {\n      primeIterator();\n      return hasNext;\n    }","commit_id":"18c03e37caef932f09e37089c44c5e272b3f86e3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public E next() {\n      if (next == null) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      E value = next;\n      primeNext();\n      return value;\n    }","id":49049,"modified_method":"public E next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException(\"Graph edge iterator exhausted.\");\n      }\n      return edgeIterator.next();\n    }","commit_id":"18c03e37caef932f09e37089c44c5e272b3f86e3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void remove() {\n      throw new UnsupportedOperationException();\n    }","id":49050,"modified_method":"public void remove() {\n      edgeIterator.remove();\n    }","commit_id":"18c03e37caef932f09e37089c44c5e272b3f86e3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public List<E> getOutgoingEdges(V v) {\n    return CollectionUtils.flatten(outgoingEdges.get(v).values());\n  }","id":49051,"modified_method":"public List<E> getOutgoingEdges(V v) {\n    if (!outgoingEdges.containsKey(v)) { //noinspection unchecked\n      return Collections.EMPTY_LIST;\n    }\n    return CollectionUtils.flatten(outgoingEdges.get(v).values());\n  }","commit_id":"18c03e37caef932f09e37089c44c5e272b3f86e3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public int getOutDegree(V vertex) {\n    int result = 0;\n    Map<V, List<E>> outgoing = outgoingEdges.get(vertex);\n    if (outgoing == null) {\n      throw new IllegalArgumentException(\"Unknown vertex \" + vertex);\n    }\n    for (List<E> edges : outgoing.values()) {\n      result += edges.size();\n    }\n    return result;\n  }","id":49052,"modified_method":"public int getOutDegree(V vertex) {\n    int result = 0;\n    Map<V, List<E>> outgoing = outgoingEdges.get(vertex);\n    if (outgoing == null) {\n      return 0;\n    }\n    for (List<E> edges : outgoing.values()) {\n      result += edges.size();\n    }\n    return result;\n  }","commit_id":"18c03e37caef932f09e37089c44c5e272b3f86e3","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private int scanForTxEnds( ChannelBuffer buffer )\n    {\n        int positionBeforeScanning = buffer.readerIndex();\n        try\n        {\n            int result = 0;\n            while ( buffer.readableBytes() > 10 /*Transaction header + 1 block header*/ )\n            {\n                readTransactionHeader( buffer );\n                while ( buffer.readable() )\n                {\n                    int blockSize = buffer.readUnsignedByte();\n                    boolean fullBlock = blockSize == BlockLogBuffer.FULL_BLOCK_AND_MORE;\n                    if ( !fullBlock && buffer.readableBytes() >= blockSize )\n                    {\n                        // This means that there's a block which isn't full. If there's <blockSize>\n                        // more bytes in this buffer then that's a tx ending, right there.\n                        result++;\n                    }\n                    buffer.skipBytes( Math.min( fullBlock ? BlockLogBuffer.DATA_SIZE : blockSize,\n                            buffer.readableBytes() ) );\n                    if ( !fullBlock )\n                    {\n                        break;\n                    }\n                }\n            }\n            return result;\n        }\n        finally\n        {\n            buffer.readerIndex( positionBeforeScanning );\n        }\n    }","id":49053,"modified_method":"private int scanForTxEnds( ChannelBuffer buffer )\n    {\n        buffer.markReaderIndex();\n        try\n        {\n            int result = 0;\n            while ( buffer.readableBytes() > 10 /*Transaction header + 1 block header*/ )\n            {\n                readTransactionHeader( buffer );\n                while ( buffer.readableBytes() > 0 )\n                {\n                    int blockSize = buffer.readUnsignedByte();\n                    boolean fullBlock = blockSize == BlockLogBuffer.FULL_BLOCK_AND_MORE;\n                    if ( !fullBlock && buffer.readableBytes() >= blockSize )\n                    {\n                        // This means that there's a block which isn't full. If there's <blockSize>\n                        // more bytes in this buffer then that's a tx ending, right there.\n                        result++;\n                    }\n                    buffer.skipBytes( Math.min( fullBlock ? BlockLogBuffer.DATA_SIZE : blockSize,\n                            buffer.readableBytes() ) );\n                    if ( !fullBlock )\n                    {\n                        break;\n                    }\n                }\n            }\n            return result;\n        }\n        finally\n        {\n            buffer.resetReaderIndex();\n        }\n    }","commit_id":"47f01c8e7ca269f8b9aa0b59f0a100324f01d7c7","url":"https://github.com/neo4j/neo4j"},{"original_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        // TODO Refactor, break into smaller methods\n        Triplet<Channel, ChannelBuffer, ByteBuffer> channelContext = null;\n        try\n        {\n            // Send 'em over the wire\n            channelContext = getChannel();\n            Channel channel = channelContext.first();\n            ChannelBuffer buffer = channelContext.second();\n            buffer.clear();\n            buffer = new ChunkingChannelBuffer( buffer, channel, MAX_FRAME_LENGTH );\n            buffer.writeByte( type.ordinal() );\n            if ( type.includesSlaveContext() )\n            {\n                writeSlaveContext( buffer, slaveContext );\n            }\n            serializer.write( buffer, channelContext.third() );\n            if ( buffer.writerIndex() > 0 )\n            {\n                channel.write( buffer );\n            }\n\n            // Read the response\n            @SuppressWarnings( \"unchecked\" )\n            BlockingReadHandler<ChannelBuffer> reader = (BlockingReadHandler<ChannelBuffer>)\n                    channel.getPipeline().get( \"blockingHandler\" );\n            Pair<ChannelBuffer, Boolean> messageContext = readNextMessage( channelContext, reader );\n            ChannelBuffer message = messageContext.first();\n            T response = deserializer.read( message );\n            String[] datasources = type.includesSlaveContext() ? readTransactionStreamHeader( message ) : null;\n            if ( messageContext.other() )\n            {\n                // This message consists of multiple chunks, apply transactions as early as possible\n                message = createDynamicBufferFrom( message );\n                boolean more = true;\n                while ( more )\n                {\n                    Pair<ChannelBuffer, Boolean> followingMessage = readNextMessage( channelContext, reader );\n                    more = followingMessage.other();\n                    message.writeBytes( followingMessage.first() );\n                    message = applyFullyAvailableTransactions( datasources, message );\n                }\n            }\n            \n            // Here's the remaining transactions if the message consisted of multiple chunks,\n            // or all transactions if it only consisted of one chunk.\n            TransactionStream txStreams = type.includesSlaveContext() ?\n                    readTransactionStreams( datasources, message ) : TransactionStream.EMPTY;\n            return new Response<T>( response, txStreams );\n        }\n        catch ( ClosedChannelException e )\n        {\n            channelPool.dispose( channelContext );\n            throw new HaCommunicationException( e );\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( Exception e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","id":49054,"modified_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        // TODO Refactor, break into smaller methods\n        Triplet<Channel, ChannelBuffer, ByteBuffer> channelContext = null;\n        try\n        {\n            // Send 'em over the wire\n            channelContext = getChannel();\n            Channel channel = channelContext.first();\n            ChannelBuffer buffer = channelContext.second();\n            buffer.clear();\n            buffer = new ChunkingChannelBuffer( buffer, channel, MAX_FRAME_LENGTH );\n            buffer.writeByte( type.ordinal() );\n            if ( type.includesSlaveContext() )\n            {\n                writeSlaveContext( buffer, slaveContext );\n            }\n            serializer.write( buffer, channelContext.third() );\n            if ( buffer.writerIndex() > 0 )\n            {\n                channel.write( buffer );\n            }\n\n            // Read the response\n            @SuppressWarnings( \"unchecked\" )\n            BlockingReadHandler<ChannelBuffer> reader = (BlockingReadHandler<ChannelBuffer>)\n                    channel.getPipeline().get( \"blockingHandler\" );\n            final Triplet<Channel, ChannelBuffer, ByteBuffer> finalChannelContext = channelContext;\n            DechunkingChannelBuffer dechunkingBuffer = new DechunkingChannelBuffer( ChannelBuffers.dynamicBuffer(), reader )\n            {\n                @Override\n                protected ChannelBuffer readNext()\n                {\n                    ChannelBuffer result = super.readNext();\n                    if ( result == null )\n                    {\n                        channelPool.dispose( finalChannelContext );\n                        throw new HaCommunicationException( \"Channel has been closed\" );\n                    }\n                    return result;\n                }\n            };\n            T response = deserializer.read( dechunkingBuffer );\n            String[] datasources = type.includesSlaveContext() ? readTransactionStreamHeader( dechunkingBuffer ) : null;\n            while ( dechunkingBuffer.expectsMoreChunks() )\n            {\n                applyFullyAvailableTransactions( datasources, dechunkingBuffer );\n                if ( dechunkingBuffer.expectsMoreChunks() )\n                {\n                    dechunkingBuffer.forceReadNextChunk();\n                }\n            }\n            \n            // Here's the remaining transactions if the message consisted of multiple chunks,\n            // or all transactions if it only consisted of one chunk.\n            TransactionStream txStreams = type.includesSlaveContext() ?\n                    readTransactionStreams( datasources, dechunkingBuffer ) : TransactionStream.EMPTY;\n            return new Response<T>( response, txStreams );\n        }\n        catch ( ClosedChannelException e )\n        {\n            channelPool.dispose( channelContext );\n            throw new HaCommunicationException( e );\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( Exception e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","commit_id":"47f01c8e7ca269f8b9aa0b59f0a100324f01d7c7","url":"https://github.com/neo4j/neo4j"},{"original_method":"private int scanForTxEnds( ChannelBuffer buffer )\n    {\n        int positionBeforeScanning = buffer.readerIndex();\n        try\n        {\n            int result = 0;\n            while ( buffer.readableBytes() > 10 /*Transaction header + 1 block header*/ )\n            {\n                readTransactionHeader( buffer );\n                while ( buffer.readable() )\n                {\n                    int blockSize = buffer.readUnsignedByte();\n                    boolean fullBlock = blockSize == BlockLogBuffer.FULL_BLOCK_AND_MORE;\n                    if ( !fullBlock && buffer.readableBytes() >= blockSize )\n                    {\n                        // This means that there's a block which isn't full. If there's <blockSize>\n                        // more bytes in this buffer then that's a tx ending, right there.\n                        result++;\n                    }\n                    buffer.skipBytes( Math.min( fullBlock ? BlockLogBuffer.DATA_SIZE : blockSize,\n                            buffer.readableBytes() ) );\n                    if ( !fullBlock )\n                    {\n                        break;\n                    }\n                }\n            }\n            return result;\n        }\n        finally\n        {\n            buffer.readerIndex( positionBeforeScanning );\n        }\n    }","id":49055,"modified_method":"private int scanForTxEnds( ChannelBuffer buffer )\n    {\n        buffer.markReaderIndex();\n        try\n        {\n            int result = 0;\n            while ( buffer.readableBytes() > 10 /*Transaction header + 1 block header*/ )\n            {\n                readTransactionHeader( buffer );\n                while ( buffer.readableBytes() > 0 )\n                {\n                    int blockSize = buffer.readUnsignedByte();\n                    boolean fullBlock = blockSize == BlockLogBuffer.FULL_BLOCK_AND_MORE;\n                    if ( !fullBlock && buffer.readableBytes() >= blockSize )\n                    {\n                        // This means that there's a block which isn't full. If there's <blockSize>\n                        // more bytes in this buffer then that's a tx ending, right there.\n                        result++;\n                    }\n                    buffer.skipBytes( Math.min( fullBlock ? BlockLogBuffer.DATA_SIZE : blockSize,\n                            buffer.readableBytes() ) );\n                    if ( !fullBlock )\n                    {\n                        break;\n                    }\n                }\n            }\n            return result;\n        }\n        finally\n        {\n            buffer.resetReaderIndex();\n        }\n    }","commit_id":"f1b219336039c676790418a45ca5ee5260a1e979","url":"https://github.com/neo4j/neo4j"},{"original_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        // TODO Refactor, break into smaller methods\n        Triplet<Channel, ChannelBuffer, ByteBuffer> channelContext = null;\n        try\n        {\n            // Send 'em over the wire\n            channelContext = getChannel();\n            Channel channel = channelContext.first();\n            ChannelBuffer buffer = channelContext.second();\n            buffer.clear();\n            buffer = new ChunkingChannelBuffer( buffer, channel, MAX_FRAME_LENGTH );\n            buffer.writeByte( type.ordinal() );\n            if ( type.includesSlaveContext() )\n            {\n                writeSlaveContext( buffer, slaveContext );\n            }\n            serializer.write( buffer, channelContext.third() );\n            if ( buffer.writerIndex() > 0 )\n            {\n                channel.write( buffer );\n            }\n\n            // Read the response\n            @SuppressWarnings( \"unchecked\" )\n            BlockingReadHandler<ChannelBuffer> reader = (BlockingReadHandler<ChannelBuffer>)\n                    channel.getPipeline().get( \"blockingHandler\" );\n            Pair<ChannelBuffer, Boolean> messageContext = readNextMessage( channelContext, reader );\n            ChannelBuffer message = messageContext.first();\n            T response = deserializer.read( message );\n            String[] datasources = type.includesSlaveContext() ? readTransactionStreamHeader( message ) : null;\n            if ( messageContext.other() )\n            {\n                // This message consists of multiple chunks, apply transactions as early as possible\n                message = createDynamicBufferFrom( message );\n                boolean more = true;\n                while ( more )\n                {\n                    Pair<ChannelBuffer, Boolean> followingMessage = readNextMessage( channelContext, reader );\n                    more = followingMessage.other();\n                    message.writeBytes( followingMessage.first() );\n                    message = applyFullyAvailableTransactions( datasources, message );\n                }\n            }\n            \n            // Here's the remaining transactions if the message consisted of multiple chunks,\n            // or all transactions if it only consisted of one chunk.\n            TransactionStream txStreams = type.includesSlaveContext() ?\n                    readTransactionStreams( datasources, message ) : TransactionStream.EMPTY;\n            return new Response<T>( response, txStreams );\n        }\n        catch ( ClosedChannelException e )\n        {\n            channelPool.dispose( channelContext );\n            throw new HaCommunicationException( e );\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( Exception e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","id":49056,"modified_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        // TODO Refactor, break into smaller methods\n        Triplet<Channel, ChannelBuffer, ByteBuffer> channelContext = null;\n        try\n        {\n            // Send 'em over the wire\n            channelContext = getChannel();\n            Channel channel = channelContext.first();\n            ChannelBuffer buffer = channelContext.second();\n            buffer.clear();\n            buffer = new ChunkingChannelBuffer( buffer, channel, MAX_FRAME_LENGTH );\n            buffer.writeByte( type.ordinal() );\n            if ( type.includesSlaveContext() )\n            {\n                writeSlaveContext( buffer, slaveContext );\n            }\n            serializer.write( buffer, channelContext.third() );\n            if ( buffer.writerIndex() > 0 )\n            {\n                channel.write( buffer );\n            }\n\n            // Read the response\n            @SuppressWarnings( \"unchecked\" )\n            BlockingReadHandler<ChannelBuffer> reader = (BlockingReadHandler<ChannelBuffer>)\n                    channel.getPipeline().get( \"blockingHandler\" );\n            final Triplet<Channel, ChannelBuffer, ByteBuffer> finalChannelContext = channelContext;\n            DechunkingChannelBuffer dechunkingBuffer = new DechunkingChannelBuffer( ChannelBuffers.dynamicBuffer(), reader )\n            {\n                @Override\n                protected ChannelBuffer readNext()\n                {\n                    ChannelBuffer result = super.readNext();\n                    if ( result == null )\n                    {\n                        channelPool.dispose( finalChannelContext );\n                        throw new HaCommunicationException( \"Channel has been closed\" );\n                    }\n                    return result;\n                }\n            };\n            T response = deserializer.read( dechunkingBuffer );\n            String[] datasources = type.includesSlaveContext() ? readTransactionStreamHeader( dechunkingBuffer ) : null;\n            while ( dechunkingBuffer.expectsMoreChunks() )\n            {\n                applyFullyAvailableTransactions( datasources, dechunkingBuffer );\n                if ( dechunkingBuffer.expectsMoreChunks() )\n                {\n                    dechunkingBuffer.forceReadNextChunk();\n                }\n            }\n            \n            // Here's the remaining transactions if the message consisted of multiple chunks,\n            // or all transactions if it only consisted of one chunk.\n            TransactionStream txStreams = type.includesSlaveContext() ?\n                    readTransactionStreams( datasources, dechunkingBuffer ) : TransactionStream.EMPTY;\n            return new Response<T>( response, txStreams );\n        }\n        catch ( ClosedChannelException e )\n        {\n            channelPool.dispose( channelContext );\n            throw new HaCommunicationException( e );\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( Exception e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","commit_id":"f1b219336039c676790418a45ca5ee5260a1e979","url":"https://github.com/neo4j/neo4j"},{"original_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        // TODO Refactor, break into smaller methods\n        Triplet<Channel, ChannelBuffer, ByteBuffer> channelContext = null;\n        try\n        {\n            // Send 'em over the wire\n            channelContext = getChannel();\n            Channel channel = channelContext.first();\n            ChannelBuffer buffer = channelContext.second();\n            buffer.clear();\n            buffer = new ChunkingChannelBuffer( buffer, channel, MAX_FRAME_LENGTH );\n            buffer.writeByte( type.ordinal() );\n            if ( type.includesSlaveContext() )\n            {\n                writeSlaveContext( buffer, slaveContext );\n            }\n            serializer.write( buffer, channelContext.third() );\n            if ( buffer.writerIndex() > 0 )\n            {\n                channel.write( buffer );\n            }\n\n            // Read the response\n            @SuppressWarnings( \"unchecked\" )\n            BlockingReadHandler<ChannelBuffer> reader = (BlockingReadHandler<ChannelBuffer>)\n                    channel.getPipeline().get( \"blockingHandler\" );\n            Pair<ChannelBuffer, Boolean> messageContext = readNextMessage( channelContext, reader );\n            ChannelBuffer message = messageContext.first();\n            T response = deserializer.read( message );\n            String[] datasources = type.includesSlaveContext() ? readTransactionStreamHeader( message ) : null;\n            if ( messageContext.other() )\n            {\n                // This message consists of multiple chunks, apply transactions as early as possible\n                message = createDynamicBufferFrom( message );\n                boolean more = true;\n                while ( more )\n                {\n                    Pair<ChannelBuffer, Boolean> followingMessage = readNextMessage( channelContext, reader );\n                    more = followingMessage.other();\n                    message.writeBytes( followingMessage.first() );\n                    message = applyFullyAvailableTransactions( datasources, message );\n                }\n            }\n            \n            // Here's the remaining transactions if the message consisted of multiple chunks,\n            // or all transactions if it only consisted of one chunk.\n            TransactionStream txStreams = type.includesSlaveContext() ?\n                    readTransactionStreams( datasources, message ) : TransactionStream.EMPTY;\n            return new Response<T>( response, txStreams );\n        }\n        catch ( ClosedChannelException e )\n        {\n            channelPool.dispose( channelContext );\n            throw new HaCommunicationException( e );\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( Exception e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","id":49057,"modified_method":"private <T> Response<T> sendRequest( RequestType type,\n            SlaveContext slaveContext, Serializer serializer, Deserializer<T> deserializer )\n    {\n        // TODO Refactor, break into smaller methods\n        Triplet<Channel, ChannelBuffer, ByteBuffer> channelContext = null;\n        try\n        {\n            // Send 'em over the wire\n            channelContext = getChannel();\n            Channel channel = channelContext.first();\n            ChannelBuffer buffer = channelContext.second();\n            buffer.clear();\n            buffer = new ChunkingChannelBuffer( buffer, channel, MAX_FRAME_LENGTH );\n            buffer.writeByte( type.ordinal() );\n            if ( type.includesSlaveContext() )\n            {\n                writeSlaveContext( buffer, slaveContext );\n            }\n            serializer.write( buffer, channelContext.third() );\n            if ( buffer.writerIndex() > 0 )\n            {\n                channel.write( buffer );\n            }\n\n            // Read the response\n            @SuppressWarnings( \"unchecked\" )\n            BlockingReadHandler<ChannelBuffer> reader = (BlockingReadHandler<ChannelBuffer>)\n                    channel.getPipeline().get( \"blockingHandler\" );\n            final Triplet<Channel, ChannelBuffer, ByteBuffer> finalChannelContext = channelContext;\n            DechunkingChannelBuffer dechunkingBuffer = new DechunkingChannelBuffer( ChannelBuffers.dynamicBuffer(), reader )\n            {\n                @Override\n                protected ChannelBuffer readNext()\n                {\n                    ChannelBuffer result = super.readNext();\n                    if ( result == null )\n                    {\n                        channelPool.dispose( finalChannelContext );\n                        throw new HaCommunicationException( \"Channel has been closed\" );\n                    }\n                    return result;\n                }\n            };\n            T response = deserializer.read( dechunkingBuffer );\n            String[] datasources = type.includesSlaveContext() ? readTransactionStreamHeader( dechunkingBuffer ) : null;\n            while ( dechunkingBuffer.expectsMoreChunks() )\n            {\n                applyFullyAvailableTransactions( datasources, dechunkingBuffer );\n                if ( dechunkingBuffer.expectsMoreChunks() )\n                {\n                    dechunkingBuffer.forceReadNextChunk();\n                }\n            }\n            \n            // Here's the remaining transactions if the message consisted of multiple chunks,\n            // or all transactions if it only consisted of one chunk.\n            TransactionStream txStreams = type.includesSlaveContext() ?\n                    readTransactionStreams( datasources, dechunkingBuffer ) : TransactionStream.EMPTY;\n            return new Response<T>( response, txStreams );\n        }\n        catch ( ClosedChannelException e )\n        {\n            channelPool.dispose( channelContext );\n            throw new HaCommunicationException( e );\n        }\n        catch ( IOException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( InterruptedException e )\n        {\n            throw new HaCommunicationException( e );\n        }\n        catch ( Exception e )\n        {\n            throw new HaCommunicationException( e );\n        }\n    }","commit_id":"3760bf9cc3f9ad948486e706d21e724656a34e15","url":"https://github.com/neo4j/neo4j"},{"original_method":"private int scanForTxEnds( ChannelBuffer buffer )\n    {\n        int positionBeforeScanning = buffer.readerIndex();\n        try\n        {\n            int result = 0;\n            while ( buffer.readableBytes() > 10 /*Transaction header + 1 block header*/ )\n            {\n                readTransactionHeader( buffer );\n                while ( buffer.readable() )\n                {\n                    int blockSize = buffer.readUnsignedByte();\n                    boolean fullBlock = blockSize == BlockLogBuffer.FULL_BLOCK_AND_MORE;\n                    if ( !fullBlock && buffer.readableBytes() >= blockSize )\n                    {\n                        // This means that there's a block which isn't full. If there's <blockSize>\n                        // more bytes in this buffer then that's a tx ending, right there.\n                        result++;\n                    }\n                    buffer.skipBytes( Math.min( fullBlock ? BlockLogBuffer.DATA_SIZE : blockSize,\n                            buffer.readableBytes() ) );\n                    if ( !fullBlock )\n                    {\n                        break;\n                    }\n                }\n            }\n            return result;\n        }\n        finally\n        {\n            buffer.readerIndex( positionBeforeScanning );\n        }\n    }","id":49058,"modified_method":"private int scanForTxEnds( ChannelBuffer buffer )\n    {\n        buffer.markReaderIndex();\n        try\n        {\n            int result = 0;\n            while ( buffer.readableBytes() > 10 /*Transaction header + 1 block header*/ )\n            {\n                readTransactionHeader( buffer );\n                while ( buffer.readableBytes() > 0 )\n                {\n                    int blockSize = buffer.readUnsignedByte();\n                    boolean fullBlock = blockSize == BlockLogBuffer.FULL_BLOCK_AND_MORE;\n                    if ( !fullBlock && buffer.readableBytes() >= blockSize )\n                    {\n                        // This means that there's a block which isn't full. If there's <blockSize>\n                        // more bytes in this buffer then that's a tx ending, right there.\n                        result++;\n                    }\n                    buffer.skipBytes( Math.min( fullBlock ? BlockLogBuffer.DATA_SIZE : blockSize,\n                            buffer.readableBytes() ) );\n                    if ( !fullBlock )\n                    {\n                        break;\n                    }\n                }\n            }\n            return result;\n        }\n        finally\n        {\n            buffer.resetReaderIndex();\n        }\n    }","commit_id":"3760bf9cc3f9ad948486e706d21e724656a34e15","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void installMessageSelectors() {\n        // Add the EventListeners for the UEIs in which this service is\n        // interested\n        List<String> ueiList = new ArrayList<String>();\n\n        // nodeGainedService\n        ueiList.add(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI);\n\n        // primarySnmpInterfaceChanged\n        ueiList.add(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI);\n\n        // reinitializePrimarySnmpInterface\n        ueiList.add(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI);\n        \n        // nodeScanComplete\n        ueiList.add(EventConstants.PROVISION_SCAN_COMPLETE_UEI);\n        \n        // interfaceReparented\n        ueiList.add(EventConstants.INTERFACE_REPARENTED_EVENT_UEI);\n\n        // nodeDeleted\n        ueiList.add(EventConstants.NODE_DELETED_EVENT_UEI);\n\n        // duplicateNodeDeleted\n        ueiList.add(EventConstants.DUP_NODE_DELETED_EVENT_UEI);\n\n        // interfaceDeleted\n        ueiList.add(EventConstants.INTERFACE_DELETED_EVENT_UEI);\n\n        // serviceDeleted\n        ueiList.add(EventConstants.SERVICE_DELETED_EVENT_UEI);\n\n        // outageConfigurationChanged\n        ueiList.add(EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI);\n\n        // configureSNMP\n        ueiList.add(EventConstants.CONFIGURE_SNMP_EVENT_UEI);\n        \n        //thresholds configuration change\n        ueiList.add(EventConstants.THRESHOLDCONFIG_CHANGED_EVENT_UEI);\n\n        getEventIpcManager().addEventListener(this, ueiList);\n    }","id":49059,"modified_method":"private void installMessageSelectors() {\n        // Add the EventListeners for the UEIs in which this service is\n        // interested\n        List<String> ueiList = new ArrayList<String>();\n\n        // nodeGainedService\n        ueiList.add(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI);\n\n        // primarySnmpInterfaceChanged\n        ueiList.add(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI);\n\n        // reinitializePrimarySnmpInterface\n        ueiList.add(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI);\n        \n        // interfaceReparented\n        ueiList.add(EventConstants.INTERFACE_REPARENTED_EVENT_UEI);\n\n        // nodeDeleted\n        ueiList.add(EventConstants.NODE_DELETED_EVENT_UEI);\n\n        // duplicateNodeDeleted\n        ueiList.add(EventConstants.DUP_NODE_DELETED_EVENT_UEI);\n\n        // interfaceDeleted\n        ueiList.add(EventConstants.INTERFACE_DELETED_EVENT_UEI);\n\n        // serviceDeleted\n        ueiList.add(EventConstants.SERVICE_DELETED_EVENT_UEI);\n\n        // outageConfigurationChanged\n        ueiList.add(EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI);\n\n        // configureSNMP\n        ueiList.add(EventConstants.CONFIGURE_SNMP_EVENT_UEI);\n        \n        //thresholds configuration change\n        ueiList.add(EventConstants.THRESHOLDCONFIG_CHANGED_EVENT_UEI);\n\n        getEventIpcManager().addEventListener(this, ueiList);\n    }","commit_id":"e54aa8e6077a96510ad58d2acc3150e2e9ea76ad","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void onEventInTransaction(Event event) {\n        // print out the uei\n        //\n        log().debug(\"received event, uei = \" + event.getUei());\n\n        try {\n            if (event.getUei().equals(EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI)) {\n                handleScheduledOutagesChanged(event);\n            } else if (event.getUei().equals(EventConstants.CONFIGURE_SNMP_EVENT_UEI)) {\n                handleConfigureSNMP(event);\n            } else if (event.getUei().equals(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI)) {\n                handleNodeGainedService(event);\n            } else if (event.getUei().equals(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI)) {\n                handlePrimarySnmpInterfaceChanged(event);\n            } else if (event.getUei().equals(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI)) {\n                handleReinitializePrimarySnmpInterface(event);\n            } else if (event.getUei().equals(EventConstants.PROVISION_SCAN_COMPLETE_UEI)) {\n                handleNodeScanCompleted(event);\n            } else if (event.getUei().equals(EventConstants.INTERFACE_REPARENTED_EVENT_UEI)) {\n                handleInterfaceReparented(event);\n            } else if (event.getUei().equals(EventConstants.NODE_DELETED_EVENT_UEI)) {\n                handleNodeDeleted(event);\n            } else if (event.getUei().equals(EventConstants.DUP_NODE_DELETED_EVENT_UEI)) {\n                handleDupNodeDeleted(event);\n            } else if (event.getUei().equals(EventConstants.INTERFACE_DELETED_EVENT_UEI)) {\n                handleInterfaceDeleted(event);\n            } else if (event.getUei().equals(EventConstants.SERVICE_DELETED_EVENT_UEI)) {\n                handleServiceDeleted(event);\n            } else if (event.getUei().equals(EventConstants.THRESHOLDCONFIG_CHANGED_EVENT_UEI)) {\n                handleThresholdConfigurationChanged(event);\n            }\n        } catch (InsufficientInformationException e) {\n            handleInsufficientInfo(e);\n        }\n    }","id":49060,"modified_method":"private void onEventInTransaction(Event event) {\n        // print out the uei\n        //\n        log().debug(\"received event, uei = \" + event.getUei());\n\n        try {\n            if (event.getUei().equals(EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI)) {\n                handleScheduledOutagesChanged(event);\n            } else if (event.getUei().equals(EventConstants.CONFIGURE_SNMP_EVENT_UEI)) {\n                handleConfigureSNMP(event);\n            } else if (event.getUei().equals(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI)) {\n                handleNodeGainedService(event);\n            } else if (event.getUei().equals(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI)) {\n                handlePrimarySnmpInterfaceChanged(event);\n            } else if (event.getUei().equals(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI)) {\n                handleReinitializePrimarySnmpInterface(event);\n            } else if (event.getUei().equals(EventConstants.INTERFACE_REPARENTED_EVENT_UEI)) {\n                handleInterfaceReparented(event);\n            } else if (event.getUei().equals(EventConstants.NODE_DELETED_EVENT_UEI)) {\n                handleNodeDeleted(event);\n            } else if (event.getUei().equals(EventConstants.DUP_NODE_DELETED_EVENT_UEI)) {\n                handleDupNodeDeleted(event);\n            } else if (event.getUei().equals(EventConstants.INTERFACE_DELETED_EVENT_UEI)) {\n                handleInterfaceDeleted(event);\n            } else if (event.getUei().equals(EventConstants.SERVICE_DELETED_EVENT_UEI)) {\n                handleServiceDeleted(event);\n            } else if (event.getUei().equals(EventConstants.THRESHOLDCONFIG_CHANGED_EVENT_UEI)) {\n                handleThresholdConfigurationChanged(event);\n            }\n        } catch (InsufficientInformationException e) {\n            handleInsufficientInfo(e);\n        }\n    }","commit_id":"e54aa8e6077a96510ad58d2acc3150e2e9ea76ad","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Process the event. This event is generated when a managed node which\n     * supports SNMP gains a new interface. In this situation the\n     * CollectableService object representing the primary SNMP interface of\n     * the node must be reinitialized. The CollectableService object\n     * associated with the primary SNMP interface for the node will be marked\n     * for reinitialization. Reinitializing the CollectableService object\n     * consists of calling the ServiceCollector.release() method followed by\n     * the ServiceCollector.initialize() method which will refresh attributes\n     * such as the interface key list and number of interfaces (both of which\n     * most likely have changed). Reinitialization will take place the next\n     * time the CollectableService is popped from an interval queue for\n     * collection. If any errors occur scheduling the service no error is\n     * returned.\n     * \n     * @param event\n     *            The event to process.\n     * @throws InsufficientInformationException\n     */\n    private void handleReinitializePrimarySnmpInterface(Event event)\n            throws InsufficientInformationException {\n        EventUtils.checkNodeId(event);\n        EventUtils.checkInterface(event);\n\n        int nodeid = (int) event.getNodeid();\n        String ipAddress = event.getInterface();\n\n        reinitializeCollectable(nodeid, ipAddress);\n    }","id":49061,"modified_method":"/**\n     * Process the event. This event is generated when a managed node which\n     * supports SNMP gains a new interface. In this situation the\n     * CollectableService object representing the primary SNMP interface of\n     * the node must be reinitialized. The CollectableService object\n     * associated with the primary SNMP interface for the node will be marked\n     * for reinitialization. Reinitializing the CollectableService object\n     * consists of calling the ServiceCollector.release() method followed by\n     * the ServiceCollector.initialize() method which will refresh attributes\n     * such as the interface key list and number of interfaces (both of which\n     * most likely have changed). Reinitialization will take place the next\n     * time the CollectableService is popped from an interval queue for\n     * collection. If any errors occur scheduling the service no error is\n     * returned.\n     * \n     * @param event\n     *            The event to process.\n     * @throws InsufficientInformationException\n     */\n    private void handleReinitializePrimarySnmpInterface(Event event)\n            throws InsufficientInformationException {\n        EventUtils.checkNodeId(event);\n        EventUtils.checkInterface(event);\n\n        int nodeid = (int) event.getNodeid();\n        String ipAddress = event.getInterface();\n\n        // Mark the primary SNMP interface for reinitialization in\n        // order to update any modified attributes associated with\n        // the collectable service..\n        //\n        // Iterate over the CollectableService objects in the\n        // updates map and mark any which have the same interface\n        // address for reinitialization\n        //\n        Category log = log();\n        \n        OnmsIpInterface iface = null;\n        synchronized (getCollectableServices()) {\n            Iterator<CollectableService> iter = getCollectableServices().iterator();\n            while (iter.hasNext()) {\n                CollectableService cSvc = iter.next();\n        \n                InetAddress addr = (InetAddress) cSvc.getAddress();\n                if (log.isDebugEnabled())\n                    log.debug(\"Comparing CollectableService ip address = \"\n                            + addr.getHostAddress()\n                            + \" and event ip interface = \"\n                            + ipAddress);\n                if (addr.getHostAddress().equals(ipAddress)) {\n                    synchronized (cSvc) {\n                    \tif (iface == null) {\n                            iface = getIpInterface(nodeid, ipAddress);\n                    \t}\n                        // Got a match! Retrieve the CollectorUpdates object\n                        // associated\n                        // with this CollectableService.\n                        CollectorUpdates updates = cSvc.getCollectorUpdates();\n        \n                        // Now set the reinitialization flag\n                        updates.markForReinitialization(iface);\n                        if (log.isDebugEnabled())\n                            log.debug(\"reinitializePrimarySnmpInterfaceHandler: marking \"\n                                    + ipAddress\n                                    + \" for reinitialization for service SNMP.\");\n                    }\n                }\n            }\n        }\n    }","commit_id":"e54aa8e6077a96510ad58d2acc3150e2e9ea76ad","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void onEventInTransaction(Event event) {\n        // print out the uei\n        //\n        log().debug(\"received event, uei = \" + event.getUei());\n\n        try {\n            if (event.getUei().equals(EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI)) {\n                handleScheduledOutagesChanged(event);\n            } else if (event.getUei().equals(EventConstants.CONFIGURE_SNMP_EVENT_UEI)) {\n                handleConfigureSNMP(event);\n            } else if (event.getUei().equals(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI)) {\n                handleNodeGainedService(event);\n            } else if (event.getUei().equals(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI)) {\n                handlePrimarySnmpInterfaceChanged(event);\n            } else if (event.getUei().equals(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI)) {\n                handleReinitializePrimarySnmpInterface(event);\n            } else if (event.getUei().equals(EventConstants.PROVISION_SCAN_COMPLETE_UEI)) {\n                handleNodeScanCompleted(event);\n            } else if (event.getUei().equals(EventConstants.INTERFACE_REPARENTED_EVENT_UEI)) {\n                handleInterfaceReparented(event);\n            } else if (event.getUei().equals(EventConstants.NODE_DELETED_EVENT_UEI)) {\n                handleNodeDeleted(event);\n            } else if (event.getUei().equals(EventConstants.DUP_NODE_DELETED_EVENT_UEI)) {\n                handleDupNodeDeleted(event);\n            } else if (event.getUei().equals(EventConstants.INTERFACE_DELETED_EVENT_UEI)) {\n                handleInterfaceDeleted(event);\n            } else if (event.getUei().equals(EventConstants.SERVICE_DELETED_EVENT_UEI)) {\n                handleServiceDeleted(event);\n            } else if (event.getUei().equals(EventConstants.THRESHOLDCONFIG_CHANGED_EVENT_UEI)) {\n                handleThresholdConfigurationChanged(event);\n            }\n        } catch (InsufficientInformationException e) {\n            handleInsufficientInfo(e);\n        }\n    }","id":49062,"modified_method":"private void onEventInTransaction(Event event) {\n        // print out the uei\n        //\n        log().debug(\"received event, uei = \" + event.getUei());\n\n        try {\n            if (event.getUei().equals(EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI)) {\n                handleScheduledOutagesChanged(event);\n            } else if (event.getUei().equals(EventConstants.CONFIGURE_SNMP_EVENT_UEI)) {\n                handleConfigureSNMP(event);\n            } else if (event.getUei().equals(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI)) {\n                handleNodeGainedService(event);\n            } else if (event.getUei().equals(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI)) {\n                handlePrimarySnmpInterfaceChanged(event);\n            } else if (event.getUei().equals(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI)) {\n                handleReinitializePrimarySnmpInterface(event);\n            } else if (event.getUei().equals(EventConstants.INTERFACE_REPARENTED_EVENT_UEI)) {\n                handleInterfaceReparented(event);\n            } else if (event.getUei().equals(EventConstants.NODE_DELETED_EVENT_UEI)) {\n                handleNodeDeleted(event);\n            } else if (event.getUei().equals(EventConstants.DUP_NODE_DELETED_EVENT_UEI)) {\n                handleDupNodeDeleted(event);\n            } else if (event.getUei().equals(EventConstants.INTERFACE_DELETED_EVENT_UEI)) {\n                handleInterfaceDeleted(event);\n            } else if (event.getUei().equals(EventConstants.SERVICE_DELETED_EVENT_UEI)) {\n                handleServiceDeleted(event);\n            } else if (event.getUei().equals(EventConstants.THRESHOLDCONFIG_CHANGED_EVENT_UEI)) {\n                handleThresholdConfigurationChanged(event);\n            }\n        } catch (InsufficientInformationException e) {\n            handleInsufficientInfo(e);\n        }\n    }","commit_id":"06d2130b3a5d1d7d4840d484d292a764e708f984","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Process the event. This event is generated when a managed node which\n     * supports SNMP gains a new interface. In this situation the\n     * CollectableService object representing the primary SNMP interface of\n     * the node must be reinitialized. The CollectableService object\n     * associated with the primary SNMP interface for the node will be marked\n     * for reinitialization. Reinitializing the CollectableService object\n     * consists of calling the ServiceCollector.release() method followed by\n     * the ServiceCollector.initialize() method which will refresh attributes\n     * such as the interface key list and number of interfaces (both of which\n     * most likely have changed). Reinitialization will take place the next\n     * time the CollectableService is popped from an interval queue for\n     * collection. If any errors occur scheduling the service no error is\n     * returned.\n     * \n     * @param event\n     *            The event to process.\n     * @throws InsufficientInformationException\n     */\n    private void handleReinitializePrimarySnmpInterface(Event event)\n            throws InsufficientInformationException {\n        EventUtils.checkNodeId(event);\n        EventUtils.checkInterface(event);\n\n        int nodeid = (int) event.getNodeid();\n        String ipAddress = event.getInterface();\n\n        reinitializeCollectable(nodeid, ipAddress);\n    }","id":49063,"modified_method":"/**\n     * Process the event. This event is generated when a managed node which\n     * supports SNMP gains a new interface. In this situation the\n     * CollectableService object representing the primary SNMP interface of\n     * the node must be reinitialized. The CollectableService object\n     * associated with the primary SNMP interface for the node will be marked\n     * for reinitialization. Reinitializing the CollectableService object\n     * consists of calling the ServiceCollector.release() method followed by\n     * the ServiceCollector.initialize() method which will refresh attributes\n     * such as the interface key list and number of interfaces (both of which\n     * most likely have changed). Reinitialization will take place the next\n     * time the CollectableService is popped from an interval queue for\n     * collection. If any errors occur scheduling the service no error is\n     * returned.\n     * \n     * @param event\n     *            The event to process.\n     * @throws InsufficientInformationException\n     */\n    private void handleReinitializePrimarySnmpInterface(Event event)\n            throws InsufficientInformationException {\n        EventUtils.checkNodeId(event);\n        EventUtils.checkInterface(event);\n\n        int nodeid = (int) event.getNodeid();\n        String ipAddress = event.getInterface();\n\n        // Mark the primary SNMP interface for reinitialization in\n        // order to update any modified attributes associated with\n        // the collectable service..\n        //\n        // Iterate over the CollectableService objects in the\n        // updates map and mark any which have the same interface\n        // address for reinitialization\n        //\n        Category log = log();\n        \n        OnmsIpInterface iface = null;\n        synchronized (getCollectableServices()) {\n            Iterator<CollectableService> iter = getCollectableServices().iterator();\n            while (iter.hasNext()) {\n                CollectableService cSvc = iter.next();\n        \n                InetAddress addr = (InetAddress) cSvc.getAddress();\n                if (log.isDebugEnabled())\n                    log.debug(\"Comparing CollectableService ip address = \"\n                            + addr.getHostAddress()\n                            + \" and event ip interface = \"\n                            + ipAddress);\n                if (addr.getHostAddress().equals(ipAddress)) {\n                    synchronized (cSvc) {\n                    \tif (iface == null) {\n                            iface = getIpInterface(nodeid, ipAddress);\n                    \t}\n                        // Got a match! Retrieve the CollectorUpdates object\n                        // associated\n                        // with this CollectableService.\n                        CollectorUpdates updates = cSvc.getCollectorUpdates();\n        \n                        // Now set the reinitialization flag\n                        updates.markForReinitialization(iface);\n                        if (log.isDebugEnabled())\n                            log.debug(\"reinitializePrimarySnmpInterfaceHandler: marking \"\n                                    + ipAddress\n                                    + \" for reinitialization for service SNMP.\");\n                    }\n                }\n            }\n        }\n    }","commit_id":"06d2130b3a5d1d7d4840d484d292a764e708f984","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void installMessageSelectors() {\n        // Add the EventListeners for the UEIs in which this service is\n        // interested\n        List<String> ueiList = new ArrayList<String>();\n\n        // nodeGainedService\n        ueiList.add(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI);\n\n        // primarySnmpInterfaceChanged\n        ueiList.add(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI);\n\n        // reinitializePrimarySnmpInterface\n        ueiList.add(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI);\n        \n        // nodeScanComplete\n        ueiList.add(EventConstants.PROVISION_SCAN_COMPLETE_UEI);\n        \n        // interfaceReparented\n        ueiList.add(EventConstants.INTERFACE_REPARENTED_EVENT_UEI);\n\n        // nodeDeleted\n        ueiList.add(EventConstants.NODE_DELETED_EVENT_UEI);\n\n        // duplicateNodeDeleted\n        ueiList.add(EventConstants.DUP_NODE_DELETED_EVENT_UEI);\n\n        // interfaceDeleted\n        ueiList.add(EventConstants.INTERFACE_DELETED_EVENT_UEI);\n\n        // serviceDeleted\n        ueiList.add(EventConstants.SERVICE_DELETED_EVENT_UEI);\n\n        // outageConfigurationChanged\n        ueiList.add(EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI);\n\n        // configureSNMP\n        ueiList.add(EventConstants.CONFIGURE_SNMP_EVENT_UEI);\n        \n        //thresholds configuration change\n        ueiList.add(EventConstants.THRESHOLDCONFIG_CHANGED_EVENT_UEI);\n\n        getEventIpcManager().addEventListener(this, ueiList);\n    }","id":49064,"modified_method":"private void installMessageSelectors() {\n        // Add the EventListeners for the UEIs in which this service is\n        // interested\n        List<String> ueiList = new ArrayList<String>();\n\n        // nodeGainedService\n        ueiList.add(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI);\n\n        // primarySnmpInterfaceChanged\n        ueiList.add(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI);\n\n        // reinitializePrimarySnmpInterface\n        ueiList.add(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI);\n        \n        // interfaceReparented\n        ueiList.add(EventConstants.INTERFACE_REPARENTED_EVENT_UEI);\n\n        // nodeDeleted\n        ueiList.add(EventConstants.NODE_DELETED_EVENT_UEI);\n\n        // duplicateNodeDeleted\n        ueiList.add(EventConstants.DUP_NODE_DELETED_EVENT_UEI);\n\n        // interfaceDeleted\n        ueiList.add(EventConstants.INTERFACE_DELETED_EVENT_UEI);\n\n        // serviceDeleted\n        ueiList.add(EventConstants.SERVICE_DELETED_EVENT_UEI);\n\n        // outageConfigurationChanged\n        ueiList.add(EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI);\n\n        // configureSNMP\n        ueiList.add(EventConstants.CONFIGURE_SNMP_EVENT_UEI);\n        \n        //thresholds configuration change\n        ueiList.add(EventConstants.THRESHOLDCONFIG_CHANGED_EVENT_UEI);\n\n        getEventIpcManager().addEventListener(this, ueiList);\n    }","commit_id":"06d2130b3a5d1d7d4840d484d292a764e708f984","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void onEventInTransaction(Event event) {\n        // print out the uei\n        //\n        log().debug(\"received event, uei = \" + event.getUei());\n\n        try {\n            if (event.getUei().equals(EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI)) {\n                handleScheduledOutagesChanged(event);\n            } else if (event.getUei().equals(EventConstants.CONFIGURE_SNMP_EVENT_UEI)) {\n                handleConfigureSNMP(event);\n            } else if (event.getUei().equals(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI)) {\n                handleNodeGainedService(event);\n            } else if (event.getUei().equals(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI)) {\n                handlePrimarySnmpInterfaceChanged(event);\n            } else if (event.getUei().equals(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI)) {\n                handleReinitializePrimarySnmpInterface(event);\n            } else if (event.getUei().equals(EventConstants.PROVISION_SCAN_COMPLETE_UEI)) {\n                handleNodeScanCompleted(event);\n            } else if (event.getUei().equals(EventConstants.INTERFACE_REPARENTED_EVENT_UEI)) {\n                handleInterfaceReparented(event);\n            } else if (event.getUei().equals(EventConstants.NODE_DELETED_EVENT_UEI)) {\n                handleNodeDeleted(event);\n            } else if (event.getUei().equals(EventConstants.DUP_NODE_DELETED_EVENT_UEI)) {\n                handleDupNodeDeleted(event);\n            } else if (event.getUei().equals(EventConstants.INTERFACE_DELETED_EVENT_UEI)) {\n                handleInterfaceDeleted(event);\n            } else if (event.getUei().equals(EventConstants.SERVICE_DELETED_EVENT_UEI)) {\n                handleServiceDeleted(event);\n            } else if (event.getUei().equals(EventConstants.THRESHOLDCONFIG_CHANGED_EVENT_UEI)) {\n                handleThresholdConfigurationChanged(event);\n            }\n        } catch (InsufficientInformationException e) {\n            handleInsufficientInfo(e);\n        }\n    }","id":49065,"modified_method":"private void onEventInTransaction(Event event) {\n        // print out the uei\n        //\n        log().debug(\"received event, uei = \" + event.getUei());\n\n        try {\n            if (event.getUei().equals(EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI)) {\n                handleScheduledOutagesChanged(event);\n            } else if (event.getUei().equals(EventConstants.CONFIGURE_SNMP_EVENT_UEI)) {\n                handleConfigureSNMP(event);\n            } else if (event.getUei().equals(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI)) {\n                handleNodeGainedService(event);\n            } else if (event.getUei().equals(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI)) {\n                handlePrimarySnmpInterfaceChanged(event);\n            } else if (event.getUei().equals(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI)) {\n                handleReinitializePrimarySnmpInterface(event);\n            } else if (event.getUei().equals(EventConstants.INTERFACE_REPARENTED_EVENT_UEI)) {\n                handleInterfaceReparented(event);\n            } else if (event.getUei().equals(EventConstants.NODE_DELETED_EVENT_UEI)) {\n                handleNodeDeleted(event);\n            } else if (event.getUei().equals(EventConstants.DUP_NODE_DELETED_EVENT_UEI)) {\n                handleDupNodeDeleted(event);\n            } else if (event.getUei().equals(EventConstants.INTERFACE_DELETED_EVENT_UEI)) {\n                handleInterfaceDeleted(event);\n            } else if (event.getUei().equals(EventConstants.SERVICE_DELETED_EVENT_UEI)) {\n                handleServiceDeleted(event);\n            } else if (event.getUei().equals(EventConstants.THRESHOLDCONFIG_CHANGED_EVENT_UEI)) {\n                handleThresholdConfigurationChanged(event);\n            }\n        } catch (InsufficientInformationException e) {\n            handleInsufficientInfo(e);\n        }\n    }","commit_id":"3051ff390b44a35a6959463649e3772b3f5e3eb8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void installMessageSelectors() {\n        // Add the EventListeners for the UEIs in which this service is\n        // interested\n        List<String> ueiList = new ArrayList<String>();\n\n        // nodeGainedService\n        ueiList.add(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI);\n\n        // primarySnmpInterfaceChanged\n        ueiList.add(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI);\n\n        // reinitializePrimarySnmpInterface\n        ueiList.add(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI);\n        \n        // nodeScanComplete\n        ueiList.add(EventConstants.PROVISION_SCAN_COMPLETE_UEI);\n        \n        // interfaceReparented\n        ueiList.add(EventConstants.INTERFACE_REPARENTED_EVENT_UEI);\n\n        // nodeDeleted\n        ueiList.add(EventConstants.NODE_DELETED_EVENT_UEI);\n\n        // duplicateNodeDeleted\n        ueiList.add(EventConstants.DUP_NODE_DELETED_EVENT_UEI);\n\n        // interfaceDeleted\n        ueiList.add(EventConstants.INTERFACE_DELETED_EVENT_UEI);\n\n        // serviceDeleted\n        ueiList.add(EventConstants.SERVICE_DELETED_EVENT_UEI);\n\n        // outageConfigurationChanged\n        ueiList.add(EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI);\n\n        // configureSNMP\n        ueiList.add(EventConstants.CONFIGURE_SNMP_EVENT_UEI);\n        \n        //thresholds configuration change\n        ueiList.add(EventConstants.THRESHOLDCONFIG_CHANGED_EVENT_UEI);\n\n        getEventIpcManager().addEventListener(this, ueiList);\n    }","id":49066,"modified_method":"private void installMessageSelectors() {\n        // Add the EventListeners for the UEIs in which this service is\n        // interested\n        List<String> ueiList = new ArrayList<String>();\n\n        // nodeGainedService\n        ueiList.add(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI);\n\n        // primarySnmpInterfaceChanged\n        ueiList.add(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI);\n\n        // reinitializePrimarySnmpInterface\n        ueiList.add(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI);\n        \n        // interfaceReparented\n        ueiList.add(EventConstants.INTERFACE_REPARENTED_EVENT_UEI);\n\n        // nodeDeleted\n        ueiList.add(EventConstants.NODE_DELETED_EVENT_UEI);\n\n        // duplicateNodeDeleted\n        ueiList.add(EventConstants.DUP_NODE_DELETED_EVENT_UEI);\n\n        // interfaceDeleted\n        ueiList.add(EventConstants.INTERFACE_DELETED_EVENT_UEI);\n\n        // serviceDeleted\n        ueiList.add(EventConstants.SERVICE_DELETED_EVENT_UEI);\n\n        // outageConfigurationChanged\n        ueiList.add(EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI);\n\n        // configureSNMP\n        ueiList.add(EventConstants.CONFIGURE_SNMP_EVENT_UEI);\n        \n        //thresholds configuration change\n        ueiList.add(EventConstants.THRESHOLDCONFIG_CHANGED_EVENT_UEI);\n\n        getEventIpcManager().addEventListener(this, ueiList);\n    }","commit_id":"3051ff390b44a35a6959463649e3772b3f5e3eb8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Process the event. This event is generated when a managed node which\n     * supports SNMP gains a new interface. In this situation the\n     * CollectableService object representing the primary SNMP interface of\n     * the node must be reinitialized. The CollectableService object\n     * associated with the primary SNMP interface for the node will be marked\n     * for reinitialization. Reinitializing the CollectableService object\n     * consists of calling the ServiceCollector.release() method followed by\n     * the ServiceCollector.initialize() method which will refresh attributes\n     * such as the interface key list and number of interfaces (both of which\n     * most likely have changed). Reinitialization will take place the next\n     * time the CollectableService is popped from an interval queue for\n     * collection. If any errors occur scheduling the service no error is\n     * returned.\n     * \n     * @param event\n     *            The event to process.\n     * @throws InsufficientInformationException\n     */\n    private void handleReinitializePrimarySnmpInterface(Event event)\n            throws InsufficientInformationException {\n        EventUtils.checkNodeId(event);\n        EventUtils.checkInterface(event);\n\n        int nodeid = (int) event.getNodeid();\n        String ipAddress = event.getInterface();\n\n        reinitializeCollectable(nodeid, ipAddress);\n    }","id":49067,"modified_method":"/**\n     * Process the event. This event is generated when a managed node which\n     * supports SNMP gains a new interface. In this situation the\n     * CollectableService object representing the primary SNMP interface of\n     * the node must be reinitialized. The CollectableService object\n     * associated with the primary SNMP interface for the node will be marked\n     * for reinitialization. Reinitializing the CollectableService object\n     * consists of calling the ServiceCollector.release() method followed by\n     * the ServiceCollector.initialize() method which will refresh attributes\n     * such as the interface key list and number of interfaces (both of which\n     * most likely have changed). Reinitialization will take place the next\n     * time the CollectableService is popped from an interval queue for\n     * collection. If any errors occur scheduling the service no error is\n     * returned.\n     * \n     * @param event\n     *            The event to process.\n     * @throws InsufficientInformationException\n     */\n    private void handleReinitializePrimarySnmpInterface(Event event)\n            throws InsufficientInformationException {\n        EventUtils.checkNodeId(event);\n        EventUtils.checkInterface(event);\n\n        int nodeid = (int) event.getNodeid();\n        String ipAddress = event.getInterface();\n\n        // Mark the primary SNMP interface for reinitialization in\n        // order to update any modified attributes associated with\n        // the collectable service..\n        //\n        // Iterate over the CollectableService objects in the\n        // updates map and mark any which have the same interface\n        // address for reinitialization\n        //\n        Category log = log();\n        \n        OnmsIpInterface iface = null;\n        synchronized (getCollectableServices()) {\n            Iterator<CollectableService> iter = getCollectableServices().iterator();\n            while (iter.hasNext()) {\n                CollectableService cSvc = iter.next();\n        \n                InetAddress addr = (InetAddress) cSvc.getAddress();\n                if (log.isDebugEnabled())\n                    log.debug(\"Comparing CollectableService ip address = \"\n                            + addr.getHostAddress()\n                            + \" and event ip interface = \"\n                            + ipAddress);\n                if (addr.getHostAddress().equals(ipAddress)) {\n                    synchronized (cSvc) {\n                    \tif (iface == null) {\n                            iface = getIpInterface(nodeid, ipAddress);\n                    \t}\n                        // Got a match! Retrieve the CollectorUpdates object\n                        // associated\n                        // with this CollectableService.\n                        CollectorUpdates updates = cSvc.getCollectorUpdates();\n        \n                        // Now set the reinitialization flag\n                        updates.markForReinitialization(iface);\n                        if (log.isDebugEnabled())\n                            log.debug(\"reinitializePrimarySnmpInterfaceHandler: marking \"\n                                    + ipAddress\n                                    + \" for reinitialization for service SNMP.\");\n                    }\n                }\n            }\n        }\n    }","commit_id":"3051ff390b44a35a6959463649e3772b3f5e3eb8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public TenantPort createTenantPort(String tenantNetworkUuid) {\n        TenantPort req = new TenantPort();\n        req.networkUuid = tenantNetworkUuid;\n        req.attachmentType = \"NoAttachment\";\n\n        HttpPost method = new HttpPost();\n        method.setEntity(new StringEntity(new Gson().toJson(req), ContentType.APPLICATION_JSON));\n        HttpResponse res = executeMethod(method, \"/ssp.v1/tenant-ports\");\n\n        if (res == null || res.getStatusLine().getStatusCode() != HttpStatus.SC_CREATED) {\n            return null;\n        }\n        try {\n            return new Gson().fromJson(new InputStreamReader(res.getEntity().getContent(), \"UTF-8\"),\n                    TenantPort.class);\n        } catch (JsonSyntaxException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (JsonIOException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (IllegalStateException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (IOException e) {\n            s_logger.error(\"reading response body failed\", e);\n        }\n        return null;\n    }","id":49068,"modified_method":"public TenantPort createTenantPort(String tenantNetworkUuid) {\n        TenantPort req = new TenantPort();\n        req.networkUuid = tenantNetworkUuid;\n        req.attachmentType = \"NoAttachment\";\n\n        HttpPost method = new HttpPost();\n        method.setEntity(new StringEntity(new Gson().toJson(req), ContentType.APPLICATION_JSON));\n        return new Gson().fromJson(\n                executeMethod(method, \"/ssp.v1/tenant-ports\"),\n                TenantPort.class);\n    }","commit_id":"0d222b14a156f9ec60c137b83ef3cc7e78c90133","url":"https://github.com/apache/cloudstack"},{"original_method":"public boolean deleteTenantNetwork(String tenantNetworkUuid) {\n        HttpDelete method = new HttpDelete();\n        HttpResponse res = executeMethod(method, \"/ssp.v1/tenant-networks/\" + tenantNetworkUuid);\n        if (res != null && res.getStatusLine().getStatusCode() == HttpStatus.SC_NO_CONTENT) {\n            return true;\n        }\n        return false;\n    }","id":49069,"modified_method":"public boolean deleteTenantNetwork(String tenantNetworkUuid) {\n        HttpDelete method = new HttpDelete();\n        if (executeMethod(method, \"/ssp.v1/tenant-networks/\" + tenantNetworkUuid) != null) {\n            return true;\n        }\n        return false;\n    }","commit_id":"0d222b14a156f9ec60c137b83ef3cc7e78c90133","url":"https://github.com/apache/cloudstack"},{"original_method":"public boolean login() {\n        HttpPost method = new HttpPost();\n        try {\n            method.setEntity(new UrlEncodedFormEntity(Arrays.asList(\n                    new BasicNameValuePair(\"username\", username),\n                    new BasicNameValuePair(\"password\", password))));\n        } catch (UnsupportedEncodingException e) {\n            s_logger.error(\"invalid username or password\", e);\n            return false;\n        }\n\n        HttpResponse res = this.innerExecuteMethod(method, \"/ws.v1/login\");\n        if (res != null && res.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n            return true;\n        }\n        return false;\n    }","id":49070,"modified_method":"public boolean login() {\n        HttpPost method = new HttpPost();\n        try {\n            method.setEntity(new UrlEncodedFormEntity(Arrays.asList(\n                    new BasicNameValuePair(\"username\", username),\n                    new BasicNameValuePair(\"password\", password))));\n        } catch (UnsupportedEncodingException e) {\n            s_logger.error(\"invalid username or password\", e);\n            return false;\n        }\n        if (executeMethod(method, \"/ws.v1/login\") != null) {\n            return true;\n        }\n        return false;\n    }","commit_id":"0d222b14a156f9ec60c137b83ef3cc7e78c90133","url":"https://github.com/apache/cloudstack"},{"original_method":"public TenantPort updateTenantVifBinding(String portUuid, String hypervisorIpAddress) {\n        TenantPort req = new TenantPort();\n        if (hypervisorIpAddress != null) {\n            req.attachmentType = \"VifAttachment\";\n            req.hypervisorIpAddress = hypervisorIpAddress;\n        } else {\n            req.attachmentType = \"NoAttachment\";\n        }\n\n        HttpPut method = new HttpPut();\n        method.setEntity(new StringEntity(new Gson().toJson(req), ContentType.APPLICATION_JSON));\n        HttpResponse res = executeMethod(method, \"/ssp.v1/tenant-ports/\" + portUuid);\n        if (res == null || res.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {\n            return null;\n        }\n        try {\n            return new Gson().fromJson(new InputStreamReader(res.getEntity().getContent(), \"UTF-8\"),\n                    TenantPort.class);\n        } catch (JsonSyntaxException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (JsonIOException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (IllegalStateException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (IOException e) {\n            s_logger.error(\"reading response body failed\", e);\n        }\n        return null;\n    }","id":49071,"modified_method":"public TenantPort updateTenantVifBinding(String portUuid, String hypervisorIpAddress) {\n        TenantPort req = new TenantPort();\n        if (hypervisorIpAddress != null) {\n            req.attachmentType = \"VifAttachment\";\n            req.hypervisorIpAddress = hypervisorIpAddress;\n        } else {\n            req.attachmentType = \"NoAttachment\";\n        }\n\n        HttpPut method = new HttpPut();\n        method.setEntity(new StringEntity(new Gson().toJson(req), ContentType.APPLICATION_JSON));\n        return new Gson().fromJson(\n                executeMethod(method, \"/ssp.v1/tenant-ports/\" + portUuid),\n                TenantPort.class);\n    }","commit_id":"0d222b14a156f9ec60c137b83ef3cc7e78c90133","url":"https://github.com/apache/cloudstack"},{"original_method":"public boolean deleteTenantPort(String tenantPortUuid) {\n        HttpDelete method = new HttpDelete();\n        HttpResponse res = executeMethod(method, \"/ssp.v1/tenant-ports/\" + tenantPortUuid);\n\n        if (res != null && res.getStatusLine().getStatusCode() == HttpStatus.SC_NO_CONTENT) {\n            return true;\n        }\n        return false;\n    }","id":49072,"modified_method":"public boolean deleteTenantPort(String tenantPortUuid) {\n        HttpDelete method = new HttpDelete();\n        if (executeMethod(method, \"/ssp.v1/tenant-ports/\" + tenantPortUuid) != null) {\n            return true;\n        }\n        return false;\n    }","commit_id":"0d222b14a156f9ec60c137b83ef3cc7e78c90133","url":"https://github.com/apache/cloudstack"},{"original_method":"public TenantNetwork createTenantNetwork(String tenantUuid, String networkName) {\n        TenantNetwork req = new TenantNetwork();\n        req.name = networkName;\n        req.tenantUuid = tenantUuid;\n\n        HttpPost method = new HttpPost();\n        method.setEntity(new StringEntity(new Gson().toJson(req), ContentType.APPLICATION_JSON));\n        HttpResponse res = executeMethod(method, \"/ssp.v1/tenant-networks\");\n        if (res == null || res.getStatusLine().getStatusCode() != HttpStatus.SC_CREATED) {\n            return null;\n        }\n        try {\n            return new Gson().fromJson(new InputStreamReader(res.getEntity().getContent(), \"UTF-8\"),\n                    TenantNetwork.class);\n        } catch (JsonSyntaxException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (JsonIOException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (IllegalStateException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (IOException e) {\n            s_logger.error(\"reading response body failed\", e);\n        }\n        return null;\n    }","id":49073,"modified_method":"public TenantNetwork createTenantNetwork(String tenantUuid, String networkName) {\n        TenantNetwork req = new TenantNetwork();\n        req.name = networkName;\n        req.tenantUuid = tenantUuid;\n\n        HttpPost method = new HttpPost();\n        method.setEntity(new StringEntity(new Gson().toJson(req), ContentType.APPLICATION_JSON));\n        return new Gson().fromJson(\n                executeMethod(method, \"/ssp.v1/tenant-networks\"),\n                TenantNetwork.class);\n    }","commit_id":"0d222b14a156f9ec60c137b83ef3cc7e78c90133","url":"https://github.com/apache/cloudstack"},{"original_method":"private HttpResponse executeMethod(HttpRequestBase req, String path) {\n        HttpResponse res = innerExecuteMethod(req, path);\n        if (res.getStatusLine().getStatusCode() == HttpStatus.SC_UNAUTHORIZED && login()) {\n            req.reset();\n            res = innerExecuteMethod(req, path);\n        }\n        return res;\n    }","id":49074,"modified_method":"private String executeMethod(HttpRequestBase req, String path) {\n        try {\n            URI base = new URI(apiUrl);\n            req.setURI(new URI(base.getScheme(), base.getUserInfo(), base.getHost(),\n                    base.getPort(), path, null, null));\n        } catch (URISyntaxException e) {\n            s_logger.error(\"invalid API URL \" + apiUrl + \" path \" + path, e);\n            return null;\n        }\n        try {\n            String content = null;\n            try {\n                content = getHttpClient().execute(req, new BasicResponseHandler());\n                s_logger.info(\"ssp api call: \" + req);\n            } catch (HttpResponseException e) {\n                s_logger.info(\"ssp api call failed: \" + req, e);\n                if (e.getStatusCode() == HttpStatus.SC_UNAUTHORIZED && login()) {\n                    req.reset();\n                    content = getHttpClient().execute(req, new BasicResponseHandler());\n                    s_logger.info(\"ssp api retry call: \" + req);\n                }\n            }\n            return content;\n        } catch (ClientProtocolException e) { // includes HttpResponseException\n            s_logger.error(\"ssp api call failed: \" + req, e);\n        } catch (IOException e) {\n            s_logger.error(\"ssp api call failed: \" + req, e);\n        }\n        return null;\n    }","commit_id":"0d222b14a156f9ec60c137b83ef3cc7e78c90133","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void loginTest() throws Exception {\n        SspClient sspClient = spy(new SspClient(apiUrl, username, password));\n\n        HttpClient client = mock(HttpClient.class);\n        HttpResponse res = mock(HttpResponse.class, RETURNS_DEEP_STUBS);\n        doReturn(client).when(sspClient).getHttpClient();\n        when(client.execute(any(HttpUriRequest.class))).thenReturn(res);\n        when(res.getStatusLine().getStatusCode()).thenReturn(HttpStatus.SC_OK);\n\n        assertTrue(sspClient.login());\n        assertTrue(sspClient.login());\n        assertTrue(sspClient.login());\n    }","id":49075,"modified_method":"@Test\n    public void loginTest() throws Exception {\n        SspClient sspClient = spy(new SspClient(apiUrl, username, password));\n\n        HttpClient client = mock(HttpClient.class);\n        doReturn(client).when(sspClient).getHttpClient();\n        when(client.execute(any(HttpUriRequest.class), any(BasicResponseHandler.class))).thenReturn(\"\");\n\n        assertTrue(sspClient.login());\n        assertTrue(sspClient.login());\n        assertTrue(sspClient.login());\n    }","commit_id":"0d222b14a156f9ec60c137b83ef3cc7e78c90133","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void createNetworkTest() throws Exception {\n        String networkName = \"example network 1\";\n        String tenant_net_uuid = UUID.randomUUID().toString();\n        SspClient sspClient = spy(new SspClient(apiUrl, username, password));\n\n        HttpClient client = mock(HttpClient.class);\n        HttpResponse res = mock(HttpResponse.class, RETURNS_DEEP_STUBS);\n        doReturn(client).when(sspClient).getHttpClient();\n        when(client.execute(any(HttpUriRequest.class))).thenReturn(res);\n        when(res.getStatusLine().getStatusCode()).thenReturn(HttpStatus.SC_CREATED);\n        String body = \"{\\\"uuid\\\":\\\"\" + tenant_net_uuid + \"\\\",\\\"name\\\":\\\"\" + networkName\n                + \"\\\",\\\"tenant_uuid\\\":\\\"\" + uuid + \"\\\"}\";\n        when(res.getEntity().getContent()).thenReturn(\n                new ByteArrayInputStream(body.getBytes(\"UTF-8\")));\n\n        SspClient.TenantNetwork tnet = sspClient.createTenantNetwork(uuid, networkName);\n        assertEquals(tnet.name, networkName);\n        assertEquals(tnet.uuid, tenant_net_uuid);\n        assertEquals(tnet.tenantUuid, uuid);\n    }","id":49076,"modified_method":"@Test\n    public void createNetworkTest() throws Exception {\n        String networkName = \"example network 1\";\n        String tenant_net_uuid = UUID.randomUUID().toString();\n        SspClient sspClient = spy(new SspClient(apiUrl, username, password));\n\n        HttpClient client = mock(HttpClient.class);\n        doReturn(client).when(sspClient).getHttpClient();\n        String body = \"{\\\"uuid\\\":\\\"\" + tenant_net_uuid + \"\\\",\\\"name\\\":\\\"\" + networkName\n                + \"\\\",\\\"tenant_uuid\\\":\\\"\" + uuid + \"\\\"}\";\n        when(client.execute(any(HttpUriRequest.class), any(BasicResponseHandler.class))).thenReturn(body);\n\n        SspClient.TenantNetwork tnet = sspClient.createTenantNetwork(uuid, networkName);\n        assertEquals(tnet.name, networkName);\n        assertEquals(tnet.uuid, tenant_net_uuid);\n        assertEquals(tnet.tenantUuid, uuid);\n    }","commit_id":"0d222b14a156f9ec60c137b83ef3cc7e78c90133","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void deleteNetworkTest() throws Exception {\n        String tenant_net_uuid = UUID.randomUUID().toString();\n        SspClient sspClient = spy(new SspClient(apiUrl, username, password));\n\n        HttpClient client = mock(HttpClient.class);\n        HttpResponse res = mock(HttpResponse.class, RETURNS_DEEP_STUBS);\n        doReturn(client).when(sspClient).getHttpClient();\n        when(client.execute(any(HttpUriRequest.class))).thenReturn(res);\n        when(res.getStatusLine().getStatusCode()).thenReturn(HttpStatus.SC_NO_CONTENT);\n\n        sspClient.deleteTenantNetwork(tenant_net_uuid);\n    }","id":49077,"modified_method":"@Test\n    public void deleteNetworkTest() throws Exception {\n        String tenant_net_uuid = UUID.randomUUID().toString();\n        SspClient sspClient = spy(new SspClient(apiUrl, username, password));\n\n        HttpClient client = mock(HttpClient.class);\n        doReturn(client).when(sspClient).getHttpClient();\n        when(client.execute(any(HttpUriRequest.class), any(BasicResponseHandler.class))).thenReturn(\"\");\n\n        sspClient.deleteTenantNetwork(tenant_net_uuid);\n    }","commit_id":"0d222b14a156f9ec60c137b83ef3cc7e78c90133","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n  public void testFlow() throws Exception {\n    final CConfiguration configuration = CConfiguration.create();\n    configuration.set(Constants.CFG_APP_FABRIC_TEMP_DIR, System.getProperty(\"java.io.tmpdir\") + \"/app/temp\");\n    configuration.set(Constants.CFG_APP_FABRIC_OUTPUT_DIR, System.getProperty(\"java.io.tmpdir\")\n                                                              + \"/app/archive\" + UUID.randomUUID());\n\n    Injector injector = Guice.createInjector(new DataFabricModules().getInMemoryModules(),\n                                             new BigMamaModule(configuration));\n\n    injector.getInstance(DiscoveryService.class).startAndWait();\n\n    LocalLocationFactory lf = new LocalLocationFactory();\n\n    Location deployedJar = lf.create(\n      JarFinder.getJar(WordCountApp.class, TestHelper.getManifestWithMainClass(WordCountApp.class))\n    );\n    deployedJar.deleteOnExit();\n\n    ListenableFuture<?> p = TestHelper.getLocalManager(configuration).deploy(DefaultId.ACCOUNT, deployedJar);\n    ProgramRunnerFactory runnerFactory = injector.getInstance(ProgramRunnerFactory.class);\n    final ApplicationWithPrograms app = (ApplicationWithPrograms)p.get();\n    List<ProgramController> controllers = Lists.newArrayList();\n    for (final Program program : app.getPrograms()) {\n      ProgramRunner runner = runnerFactory.create(ProgramRunnerFactory.Type.valueOf(program.getProcessorType().name()));\n      controllers.add(runner.run(program, new ProgramOptions() {\n        @Override\n        public String getName() {\n          return program.getProgramName();\n        }\n\n        @Override\n        public Arguments getArguments() {\n          return new BasicArguments();\n        }\n\n        @Override\n        public Arguments getUserArguments() {\n          return new BasicArguments();\n        }\n      }));\n    }\n\n    TimeUnit.SECONDS.sleep(1);\n    OperationExecutor opex = injector.getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    QueueProducer queueProducer = new QueueProducer(\"Testing\");\n    QueueName queueName = QueueName.fromStream(DefaultId.ACCOUNT, \"text\");\n    StreamEventCodec codec = new StreamEventCodec();\n    for (int i = 0; i < 10; i++) {\n      String msg = \"Testing message \" + i;\n      StreamEvent event = new DefaultStreamEvent(ImmutableMap.<String, String>of(),\n                                                 ByteBuffer.wrap(msg.getBytes(Charsets.UTF_8)));\n      QueueEnqueue enqueue = new QueueEnqueue(queueProducer, queueName.toBytes(),\n                                              new QueueEntry(codec.encodePayload(event)));\n      opex.commit(opCtx, enqueue);\n    }\n\n    TimeUnit.SECONDS.sleep(10);\n\n    // Query\n    Gson gson = new Gson();\n    DiscoveryServiceClient discoveryServiceClient = injector.getInstance(DiscoveryServiceClient.class);\n    discoveryServiceClient.startAndWait();\n    Discoverable discoverable = discoveryServiceClient.discover(\n      String.format(\"procedure.%s.%s.%s\",\n                    DefaultId.ACCOUNT.getId(), \"WordCountApp\", \"WordFrequency\")).iterator().next();\n\n    HttpClient client = new DefaultHttpClient();\n    HttpPost post = new HttpPost(String.format(\"http://%s:%d/apps/%s/procedures/%s/%s\",\n                                               discoverable.getSocketAddress().getHostName(),\n                                               discoverable.getSocketAddress().getPort(),\n                                               \"WordCountApp\",\n                                               \"WordFrequency\",\n                                               \"wordfreq\"));\n    post.setEntity(new StringEntity(gson.toJson(ImmutableMap.of(\"word\", \"text:Testing\"))));\n    HttpResponse response = client.execute(post);\n    Map<String, Long> responseContent = gson.fromJson(\n      new InputStreamReader(response.getEntity().getContent(), Charsets.UTF_8),\n      new TypeToken<Map<String, Long>>(){}.getType());\n\n    LOG.info(\"Procedure response: \" + responseContent);\n    Assert.assertEquals(ImmutableMap.of(\"text:Testing\", 10L), responseContent);\n\n    client.getConnectionManager().shutdown();\n\n    for (ProgramController controller : controllers) {\n      controller.stop().get();\n    }\n  }","id":49078,"modified_method":"@Test\n  public void testFlow() throws Exception {\n    TestHelper.getInjector().getInstance(DiscoveryService.class).startAndWait();\n    final ApplicationWithPrograms app = TestHelper.deployApplicationWithManager(WordCountApp.class);\n    ProgramRunnerFactory runnerFactory = TestHelper.getInjector().getInstance(ProgramRunnerFactory.class);\n    List<ProgramController> controllers = Lists.newArrayList();\n    for (final Program program : app.getPrograms()) {\n      ProgramRunner runner = runnerFactory.create(ProgramRunnerFactory.Type.valueOf(program.getProcessorType().name()));\n      controllers.add(runner.run(program, new ProgramOptions() {\n        @Override\n        public String getName() {\n          return program.getProgramName();\n        }\n\n        @Override\n        public Arguments getArguments() {\n          return new BasicArguments();\n        }\n\n        @Override\n        public Arguments getUserArguments() {\n          return new BasicArguments();\n        }\n      }));\n    }\n\n    TimeUnit.SECONDS.sleep(1);\n    OperationExecutor opex = TestHelper.getInjector().getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    QueueProducer queueProducer = new QueueProducer(\"Testing\");\n    QueueName queueName = QueueName.fromStream(DefaultId.ACCOUNT, \"text\");\n    StreamEventCodec codec = new StreamEventCodec();\n    for (int i = 0; i < 10; i++) {\n      String msg = \"Testing message \" + i;\n      StreamEvent event = new DefaultStreamEvent(ImmutableMap.<String, String>of(),\n                                                 ByteBuffer.wrap(msg.getBytes(Charsets.UTF_8)));\n      QueueEnqueue enqueue = new QueueEnqueue(queueProducer, queueName.toBytes(),\n                                              new QueueEntry(codec.encodePayload(event)));\n      opex.commit(opCtx, enqueue);\n    }\n\n    TimeUnit.SECONDS.sleep(10);\n\n    // Query\n    Gson gson = new Gson();\n    DiscoveryServiceClient discoveryServiceClient = TestHelper.getInjector().getInstance(DiscoveryServiceClient.class);\n    discoveryServiceClient.startAndWait();\n    Discoverable discoverable = discoveryServiceClient.discover(\n      String.format(\"procedure.%s.%s.%s\",\n                    DefaultId.ACCOUNT.getId(), \"WordCountApp\", \"WordFrequency\")).iterator().next();\n\n    HttpClient client = new DefaultHttpClient();\n    HttpPost post = new HttpPost(String.format(\"http://%s:%d/apps/%s/procedures/%s/%s\",\n                                               discoverable.getSocketAddress().getHostName(),\n                                               discoverable.getSocketAddress().getPort(),\n                                               \"WordCountApp\",\n                                               \"WordFrequency\",\n                                               \"wordfreq\"));\n    post.setEntity(new StringEntity(gson.toJson(ImmutableMap.of(\"word\", \"text:Testing\"))));\n    HttpResponse response = client.execute(post);\n    Map<String, Long> responseContent = gson.fromJson(\n      new InputStreamReader(response.getEntity().getContent(), Charsets.UTF_8),\n      new TypeToken<Map<String, Long>>(){}.getType());\n\n    LOG.info(\"Procedure response: \" + responseContent);\n    Assert.assertEquals(ImmutableMap.of(\"text:Testing\", 10L), responseContent);\n\n    client.getConnectionManager().shutdown();\n\n    for (ProgramController controller : controllers) {\n      controller.stop().get();\n    }\n  }","commit_id":"35da6a50868b33cca0bbcaf351e5770f6d821ab4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testCountRandomApp() throws Exception {\n    final CConfiguration configuration = CConfiguration.create();\n    configuration.set(Constants.CFG_APP_FABRIC_TEMP_DIR, System.getProperty(\"java.io.tmpdir\") + \"/app/temp\");\n    configuration.set(Constants.CFG_APP_FABRIC_OUTPUT_DIR, System.getProperty(\"java.io.tmpdir\")\n                                                            + \"/app/archive\" + UUID.randomUUID());\n\n    Injector injector = Guice.createInjector(new DataFabricModules().getInMemoryModules(),\n                                             new BigMamaModule(configuration));\n\n    LocalLocationFactory lf = new LocalLocationFactory();\n\n    Location deployedJar = lf.create(\n      JarFinder.getJar(TestCountRandomApp.class, TestHelper.getManifestWithMainClass(TestCountRandomApp.class))\n    );\n    deployedJar.deleteOnExit();\n\n    ListenableFuture<?> p = TestHelper.getLocalManager(configuration).deploy(DefaultId.ACCOUNT, deployedJar);\n    final ApplicationWithPrograms app = (ApplicationWithPrograms)p.get();\n    ProgramController controller = null;\n    for (final Program program : app.getPrograms()) {\n      if (program.getProcessorType() == Type.FLOW) {\n        ProgramRunner runner = injector.getInstance(FlowProgramRunner.class);\n        controller = runner.run(program, new ProgramOptions() {\n          @Override\n          public String getName() {\n            return program.getProgramName();\n          }\n\n          @Override\n          public Arguments getArguments() {\n            return new BasicArguments();\n          }\n\n          @Override\n          public Arguments getUserArguments() {\n            return new BasicArguments();\n          }\n        });\n      }\n    }\n\n    TimeUnit.SECONDS.sleep(10);\n    controller.stop().get();\n  }","id":49079,"modified_method":"@Test\n  public void testCountRandomApp() throws Exception {\n    TestHelper.getInjector().getInstance(DiscoveryService.class).startAndWait();\n    final ApplicationWithPrograms app = TestHelper.deployApplicationWithManager(TestCountRandomApp.class);\n    ProgramController controller = null;\n    for (final Program program : app.getPrograms()) {\n      if (program.getProcessorType() == Type.FLOW) {\n        ProgramRunner runner = TestHelper.getInjector().getInstance(FlowProgramRunner.class);\n        controller = runner.run(program, new ProgramOptions() {\n          @Override\n          public String getName() {\n            return program.getProgramName();\n          }\n\n          @Override\n          public Arguments getArguments() {\n            return new BasicArguments();\n          }\n\n          @Override\n          public Arguments getUserArguments() {\n            return new BasicArguments();\n          }\n        });\n      }\n    }\n\n    TimeUnit.SECONDS.sleep(10);\n    controller.stop().get();\n  }","commit_id":"35da6a50868b33cca0bbcaf351e5770f6d821ab4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testCountAndFilterWord() throws Exception {\n    final CConfiguration configuration = CConfiguration.create();\n    configuration.set(Constants.CFG_APP_FABRIC_TEMP_DIR, System.getProperty(\"java.io.tmpdir\") + \"/app/temp\");\n    configuration.set(Constants.CFG_APP_FABRIC_OUTPUT_DIR, System.getProperty(\"java.io.tmpdir\") + \"/app/archive\" + UUID.randomUUID());\n\n    Injector injector = Guice.createInjector(new DataFabricModules().getInMemoryModules(),\n                                             new BigMamaModule(configuration));\n\n    LocalLocationFactory lf = new LocalLocationFactory();\n\n    Location deployedJar = lf.create(\n      JarFinder.getJar(CountAndFilterWord.class, TestHelper.getManifestWithMainClass(CountAndFilterWord.class))\n    );\n    deployedJar.deleteOnExit();\n\n    ListenableFuture<?> p = TestHelper.getLocalManager(configuration).deploy(DefaultId.ACCOUNT, deployedJar);\n    final ApplicationWithPrograms app = (ApplicationWithPrograms)p.get();\n    ProgramController controller = null;\n    for (final Program program : app.getPrograms()) {\n      if (program.getProcessorType() == Type.FLOW) {\n        ProgramRunner runner = injector.getInstance(FlowProgramRunner.class);\n        controller = runner.run(program, new ProgramOptions() {\n          @Override\n          public String getName() {\n            return program.getProgramName();\n          }\n\n          @Override\n          public Arguments getArguments() {\n            return new BasicArguments();\n          }\n\n          @Override\n          public Arguments getUserArguments() {\n            return new BasicArguments();\n          }\n        });\n      }\n    }\n\n    TimeUnit.SECONDS.sleep(1);\n    OperationExecutor opex = injector.getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    QueueProducer queueProducer = new QueueProducer(\"Testing\");\n    QueueName queueName = QueueName.fromStream(DefaultId.ACCOUNT, \"text\");\n    StreamEventCodec codec = new StreamEventCodec();\n    for (int i = 0; i < 1; i++) {\n      String msg = \"Testing message \" + i;\n      StreamEvent event = new DefaultStreamEvent(ImmutableMap.<String, String>of(\"title\", \"test\"),\n                                                 ByteBuffer.wrap(msg.getBytes(Charsets.UTF_8)));\n      QueueEnqueue enqueue = new QueueEnqueue(queueProducer, queueName.toBytes(),\n                                              new QueueEntry(codec.encodePayload(event)));\n      opex.commit(opCtx, enqueue);\n    }\n\n    TimeUnit.SECONDS.sleep(5);\n\n    controller.stop().get();\n  }","id":49080,"modified_method":"@Test\n  public void testCountAndFilterWord() throws Exception {\n    TestHelper.getInjector().getInstance(DiscoveryService.class).startAndWait();\n    final ApplicationWithPrograms app = TestHelper.deployApplicationWithManager(CountAndFilterWord.class);\n    ProgramController controller = null;\n    for (final Program program : app.getPrograms()) {\n      if (program.getProcessorType() == Type.FLOW) {\n        ProgramRunner runner = TestHelper.getInjector().getInstance(FlowProgramRunner.class);\n        controller = runner.run(program, new ProgramOptions() {\n          @Override\n          public String getName() {\n            return program.getProgramName();\n          }\n\n          @Override\n          public Arguments getArguments() {\n            return new BasicArguments();\n          }\n\n          @Override\n          public Arguments getUserArguments() {\n            return new BasicArguments();\n          }\n        });\n      }\n    }\n\n    TimeUnit.SECONDS.sleep(1);\n    OperationExecutor opex = TestHelper.getInjector().getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    QueueProducer queueProducer = new QueueProducer(\"Testing\");\n    QueueName queueName = QueueName.fromStream(DefaultId.ACCOUNT, \"text\");\n    StreamEventCodec codec = new StreamEventCodec();\n    for (int i = 0; i < 1; i++) {\n      String msg = \"Testing message \" + i;\n      StreamEvent event = new DefaultStreamEvent(ImmutableMap.<String, String>of(\"title\", \"test\"),\n                                                 ByteBuffer.wrap(msg.getBytes(Charsets.UTF_8)));\n      QueueEnqueue enqueue = new QueueEnqueue(queueProducer, queueName.toBytes(),\n                                              new QueueEntry(codec.encodePayload(event)));\n      opex.commit(opCtx, enqueue);\n    }\n\n    TimeUnit.SECONDS.sleep(5);\n\n    controller.stop().get();\n  }","commit_id":"35da6a50868b33cca0bbcaf351e5770f6d821ab4","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Good pipeline with good tests.\n   */\n  @Test\n  public void testGoodPipeline() throws Exception {\n    Location deployedJar = lf.create(\n      JarFinder.getJar(ToyApp.class, TestHelper.getManifestWithMainClass(ToyApp.class))\n    );\n\n    ListenableFuture<?> p = TestHelper.getLocalManager(configuration).deploy(DefaultId.ACCOUNT, deployedJar);\n    ApplicationWithPrograms input = (ApplicationWithPrograms)p.get();\n\n    Assert.assertEquals(input.getAppSpecLoc().getArchive(), deployedJar);\n    Assert.assertEquals(input.getPrograms().iterator().next().getProcessorType(), Type.FLOW);\n    Assert.assertEquals(input.getPrograms().iterator().next().getProgramName(), \"ToyFlow\");\n  }","id":49081,"modified_method":"/**\n   * Good pipeline with good tests.\n   */\n  @Test\n  public void testGoodPipeline() throws Exception {\n    Location deployedJar = lf.create(\n      JarFinder.getJar(ToyApp.class, TestHelper.getManifestWithMainClass(ToyApp.class))\n    );\n\n    ListenableFuture<?> p = TestHelper.getLocalManager().deploy(DefaultId.ACCOUNT, deployedJar);\n    ApplicationWithPrograms input = (ApplicationWithPrograms)p.get();\n\n    Assert.assertEquals(input.getAppSpecLoc().getArchive(), deployedJar);\n    Assert.assertEquals(input.getPrograms().iterator().next().getProcessorType(), Type.FLOW);\n    Assert.assertEquals(input.getPrograms().iterator().next().getProgramName(), \"ToyFlow\");\n  }","commit_id":"35da6a50868b33cca0bbcaf351e5770f6d821ab4","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void before() throws Exception {\n    lf = new LocalLocationFactory();\n    configuration = CConfiguration.create();\n    configuration.set(Constants.CFG_APP_FABRIC_TEMP_DIR, System.getProperty(\"java.io.tmpdir\"));\n    configuration.set(Constants.CFG_APP_FABRIC_OUTPUT_DIR, System.getProperty(\"java.io.tmpdir\")\n                                                                      + \"/\" + UUID.randomUUID());\n  }","id":49082,"modified_method":"@BeforeClass\n  public static void before() throws Exception {\n    lf = new LocalLocationFactory();\n  }","commit_id":"35da6a50868b33cca0bbcaf351e5770f6d821ab4","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Improper Manifest file should throw an exception.\n   */\n  @Test(expected = ExecutionException.class)\n  public void testImproperOrNoManifestFile() throws Exception {\n    String jar = JarFinder.getJar(WebCrawlApp.class, new Manifest());\n    Location deployedJar = lf.create(jar);\n    deployedJar.deleteOnExit();\n    TestHelper.getLocalManager(configuration).deploy(DefaultId.ACCOUNT, deployedJar);\n  }","id":49083,"modified_method":"/**\n   * Improper Manifest file should throw an exception.\n   */\n  @Test(expected = ExecutionException.class)\n  public void testImproperOrNoManifestFile() throws Exception {\n    String jar = JarFinder.getJar(WebCrawlApp.class, new Manifest());\n    Location deployedJar = lf.create(jar);\n    deployedJar.deleteOnExit();\n    TestHelper.getLocalManager().deploy(DefaultId.ACCOUNT, deployedJar);\n  }","commit_id":"35da6a50868b33cca0bbcaf351e5770f6d821ab4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testWordCount() throws Exception {\n    final ApplicationWithPrograms app = deployApp(AppWithMapReduce.class);\n\n    OperationExecutor opex = injector.getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    String inputPath = createInput();\n    File outputDir = new File(FileUtils.getTempDirectory().getPath() + \"/out_\" + System.currentTimeMillis());\n    outputDir.deleteOnExit();\n\n    KeyValueTable jobConfigTable = (KeyValueTable) getTable(opex, opCtx, \"jobConfig\");\n    jobConfigTable.write(tb(\"inputPath\"), tb(inputPath));\n    jobConfigTable.write(tb(\"outputPath\"), tb(outputDir.getPath()));\n\n    runProgram(app, AppWithMapReduce.ClassicWordCount.class);\n\n    File outputFile = outputDir.listFiles()[0];\n    int lines = 0;\n    BufferedReader reader = new BufferedReader(new FileReader(outputFile));\n    try {\n      while (true) {\n        String line = reader.readLine();\n        if (line == null) {\n          break;\n        }\n        lines++;\n      }\n    } finally {\n      reader.close();\n    }\n    // dummy check that output file is not empty\n    Assert.assertTrue(lines > 0);\n  }","id":49084,"modified_method":"@Test\n  public void testWordCount() throws Exception {\n    final ApplicationWithPrograms app = TestHelper.deployApplicationWithManager(AppWithMapReduce.class);\n\n    OperationExecutor opex = injector.getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    String inputPath = createInput();\n    File outputDir = new File(FileUtils.getTempDirectory().getPath() + \"/out_\" + System.currentTimeMillis());\n    outputDir.deleteOnExit();\n\n    KeyValueTable jobConfigTable = (KeyValueTable) getTable(opex, opCtx, \"jobConfig\");\n    jobConfigTable.write(tb(\"inputPath\"), tb(inputPath));\n    jobConfigTable.write(tb(\"outputPath\"), tb(outputDir.getPath()));\n\n    runProgram(app, AppWithMapReduce.ClassicWordCount.class);\n\n    File outputFile = outputDir.listFiles()[0];\n    int lines = 0;\n    BufferedReader reader = new BufferedReader(new FileReader(outputFile));\n    try {\n      while (true) {\n        String line = reader.readLine();\n        if (line == null) {\n          break;\n        }\n        lines++;\n      }\n    } finally {\n      reader.close();\n    }\n    // dummy check that output file is not empty\n    Assert.assertTrue(lines > 0);\n  }","commit_id":"35da6a50868b33cca0bbcaf351e5770f6d821ab4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testTimeSeriesRecordsCount() throws Exception {\n    final ApplicationWithPrograms app = deployApp(AppWithMapReduce.class);\n\n    OperationExecutor opex = injector.getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    TimeseriesTable table = (TimeseriesTable) getTable(opex, opCtx, \"timeSeries\");\n\n    fillTestInputData(table);\n\n    Thread.sleep(2);\n\n    long start = System.currentTimeMillis();\n    runProgram(app, AppWithMapReduce.AggregateTimeseriesByTag.class);\n    long stop = System.currentTimeMillis();\n\n    Map<String, Long> expected = Maps.newHashMap();\n    // note: not all records add to the sum since filter by tag=\"tag1\" and ts={1..3} is used\n    expected.put(\"tag1\", 18L);\n    expected.put(\"tag2\", 3L);\n    expected.put(\"tag3\", 18L);\n    List<TimeseriesTable.Entry> agg = table.read(AggregateMetricsByTag.BY_TAGS, start, stop);\n    Assert.assertEquals(expected.size(), agg.size());\n    for (TimeseriesTable.Entry entry : agg) {\n      String tag = Bytes.toString(entry.getTags()[0]);\n      Assert.assertEquals((long) expected.get(tag), Bytes.toLong(entry.getValue()));\n    }\n  }","id":49085,"modified_method":"@Test\n  public void testTimeSeriesRecordsCount() throws Exception {\n    final ApplicationWithPrograms app = TestHelper.deployApplicationWithManager(AppWithMapReduce.class);\n\n    OperationExecutor opex = injector.getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    TimeseriesTable table = (TimeseriesTable) getTable(opex, opCtx, \"timeSeries\");\n\n    fillTestInputData(table);\n\n    Thread.sleep(2);\n\n    long start = System.currentTimeMillis();\n    runProgram(app, AppWithMapReduce.AggregateTimeseriesByTag.class);\n    long stop = System.currentTimeMillis();\n\n    Map<String, Long> expected = Maps.newHashMap();\n    // note: not all records add to the sum since filter by tag=\"tag1\" and ts={1..3} is used\n    expected.put(\"tag1\", 18L);\n    expected.put(\"tag2\", 3L);\n    expected.put(\"tag3\", 18L);\n    List<TimeseriesTable.Entry> agg = table.read(AggregateMetricsByTag.BY_TAGS, start, stop);\n    Assert.assertEquals(expected.size(), agg.size());\n    for (TimeseriesTable.Entry entry : agg) {\n      String tag = Bytes.toString(entry.getTags()[0]);\n      Assert.assertEquals((long) expected.get(tag), Bytes.toLong(entry.getValue()));\n    }\n  }","commit_id":"35da6a50868b33cca0bbcaf351e5770f6d821ab4","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void beforeClass() {\n    configuration = CConfiguration.create();\n    configuration.set(Constants.CFG_APP_FABRIC_TEMP_DIR, \"/tmp/app/temp\");\n    configuration.set(Constants.CFG_APP_FABRIC_OUTPUT_DIR, \"/tmp/app/archive\" + UUID.randomUUID());\n\n    injector = Guice.createInjector(new DataFabricLevelDBModule(configuration),\n                                             new BigMamaModule(configuration));\n  }","id":49086,"modified_method":"@BeforeClass\n  public static void beforeClass() {\n    injector = Guice.createInjector(new DataFabricLevelDBModule(TestHelper.configuration),\n                                             new BigMamaModule(TestHelper.configuration));\n  }","commit_id":"35da6a50868b33cca0bbcaf351e5770f6d821ab4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testMulti() throws Exception {\n    // TODO: Fix this test case to really test with numGroups settings.\n    final CConfiguration configuration = CConfiguration.create();\n    configuration.set(Constants.CFG_APP_FABRIC_TEMP_DIR, System.getProperty(\"java.io.tmpdir\") + \"/app/temp\");\n    configuration.set(Constants.CFG_APP_FABRIC_OUTPUT_DIR, System.getProperty(\"java.io.tmpdir\")\n                                                            + \"/app/archive\" + UUID.randomUUID());\n\n    Injector injector = Guice.createInjector(new DataFabricModules().getInMemoryModules(),\n                                             new BigMamaModule(configuration));\n\n    injector.getInstance(DiscoveryService.class).startAndWait();\n\n    LocalLocationFactory lf = new LocalLocationFactory();\n\n    Location deployedJar = lf.create(\n      JarFinder.getJar(MultiApp.class, TestHelper.getManifestWithMainClass(MultiApp.class))\n    );\n    deployedJar.deleteOnExit();\n\n    ListenableFuture<?> p = TestHelper.getLocalManager(configuration).deploy(DefaultId.ACCOUNT, deployedJar);\n    ProgramRunnerFactory runnerFactory = injector.getInstance(ProgramRunnerFactory.class);\n    final ApplicationWithPrograms app = (ApplicationWithPrograms)p.get();\n    List<ProgramController> controllers = Lists.newArrayList();\n    for (final Program program : app.getPrograms()) {\n      ProgramRunner runner = runnerFactory.create(ProgramRunnerFactory.Type.valueOf(program.getProcessorType().name()));\n      controllers.add(runner.run(program, new ProgramOptions() {\n        @Override\n        public String getName() {\n          return program.getProgramName();\n        }\n\n        @Override\n        public Arguments getArguments() {\n          return new BasicArguments();\n        }\n\n        @Override\n        public Arguments getUserArguments() {\n          return new BasicArguments();\n        }\n      }));\n    }\n\n    TimeUnit.SECONDS.sleep(4);\n\n    OperationExecutor opex = injector.getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    TransactionProxy proxy = new TransactionProxy();\n    proxy.setTransactionAgent(new SynchronousTransactionAgent(opex, opCtx));\n    DataSetInstantiator dataSetInstantiator = new DataSetInstantiator(new DataFabricImpl(opex, opCtx), proxy,\n                                                                      getClass().getClassLoader());\n    dataSetInstantiator.setDataSets(ImmutableList.copyOf(new MultiApp().configure().getDataSets().values()));\n\n    KeyValueTable accumulated = dataSetInstantiator.getDataSet(\"accumulated\");\n    byte[] value = accumulated.read(KEY);\n\n    Assert.assertEquals(14850L, Longs.fromByteArray(value));\n\n    for (ProgramController controller : controllers) {\n      controller.stop().get();\n    }\n  }","id":49087,"modified_method":"@Test\n  public void testMulti() throws Exception {\n    // TODO: Fix this test case to really test with numGroups settings.\n    final ApplicationWithPrograms app = TestHelper.deployApplicationWithManager(MultiApp.class);\n    ProgramRunnerFactory runnerFactory = TestHelper.getInjector().getInstance(ProgramRunnerFactory.class);\n    List<ProgramController> controllers = Lists.newArrayList();\n    for (final Program program : app.getPrograms()) {\n      ProgramRunner runner = runnerFactory.create(ProgramRunnerFactory.Type.valueOf(program.getProcessorType().name()));\n      controllers.add(runner.run(program, new ProgramOptions() {\n        @Override\n        public String getName() {\n          return program.getProgramName();\n        }\n\n        @Override\n        public Arguments getArguments() {\n          return new BasicArguments();\n        }\n\n        @Override\n        public Arguments getUserArguments() {\n          return new BasicArguments();\n        }\n      }));\n    }\n\n    TimeUnit.SECONDS.sleep(4);\n\n    OperationExecutor opex = TestHelper.getInjector().getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    TransactionProxy proxy = new TransactionProxy();\n    proxy.setTransactionAgent(new SynchronousTransactionAgent(opex, opCtx));\n    DataSetInstantiator dataSetInstantiator = new DataSetInstantiator(new DataFabricImpl(opex, opCtx), proxy,\n                                                                      getClass().getClassLoader());\n    dataSetInstantiator.setDataSets(ImmutableList.copyOf(new MultiApp().configure().getDataSets().values()));\n\n    KeyValueTable accumulated = dataSetInstantiator.getDataSet(\"accumulated\");\n    byte[] value = accumulated.read(KEY);\n\n    Assert.assertEquals(14850L, Longs.fromByteArray(value));\n\n    for (ProgramController controller : controllers) {\n      controller.stop().get();\n    }\n  }","commit_id":"35da6a50868b33cca0bbcaf351e5770f6d821ab4","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * @return Returns an instance of {@link LocalManager}\n   */\n  public static Manager<Location, ApplicationWithPrograms> getLocalManager(CConfiguration configuration) {\n    injector = Guice.createInjector(new BigMamaModule(configuration),\n                                                   new DataFabricModules().getInMemoryModules());\n\n\n    ManagerFactory factory = injector.getInstance(ManagerFactory.class);\n    return (Manager<Location, ApplicationWithPrograms>)factory.create();\n  }","id":49088,"modified_method":"/**\n   * @return Returns an instance of {@link LocalManager}\n   */\n  public static Manager<Location, ApplicationWithPrograms> getLocalManager() {\n    ManagerFactory factory = injector.getInstance(ManagerFactory.class);\n    return (Manager<Location, ApplicationWithPrograms>)factory.create();\n  }","commit_id":"35da6a50868b33cca0bbcaf351e5770f6d821ab4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testCountAndFilterWord() throws Exception {\n    final CConfiguration configuration = CConfiguration.create();\n    configuration.set(Constants.CFG_APP_FABRIC_TEMP_DIR, System.getProperty(\"java.io.tmpdir\") + \"/app/temp\");\n    configuration.set(Constants.CFG_APP_FABRIC_OUTPUT_DIR, System.getProperty(\"java.io.tmpdir\") + \"/app/archive\" + UUID.randomUUID());\n\n    Injector injector = Guice.createInjector(new DataFabricModules().getInMemoryModules(),\n                                             new BigMamaModule(configuration));\n\n    LocalLocationFactory lf = new LocalLocationFactory();\n\n    Location deployedJar = lf.create(\n      JarFinder.getJar(CountAndFilterWord.class, TestHelper.getManifestWithMainClass(CountAndFilterWord.class))\n    );\n    deployedJar.deleteOnExit();\n\n    ListenableFuture<?> p = TestHelper.getLocalManager(configuration).deploy(DefaultId.ACCOUNT, deployedJar);\n    final ApplicationWithPrograms app = (ApplicationWithPrograms)p.get();\n    ProgramController controller = null;\n    for (final Program program : app.getPrograms()) {\n      if (program.getProcessorType() == Type.FLOW) {\n        ProgramRunner runner = injector.getInstance(FlowProgramRunner.class);\n        controller = runner.run(program, new ProgramOptions() {\n          @Override\n          public String getName() {\n            return program.getProgramName();\n          }\n\n          @Override\n          public Arguments getArguments() {\n            return new BasicArguments();\n          }\n\n          @Override\n          public Arguments getUserArguments() {\n            return new BasicArguments();\n          }\n        });\n      }\n    }\n\n    TimeUnit.SECONDS.sleep(1);\n    OperationExecutor opex = injector.getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    QueueProducer queueProducer = new QueueProducer(\"Testing\");\n    QueueName queueName = QueueName.fromStream(DefaultId.ACCOUNT, \"text\");\n    StreamEventCodec codec = new StreamEventCodec();\n    for (int i = 0; i < 1; i++) {\n      String msg = \"Testing message \" + i;\n      StreamEvent event = new DefaultStreamEvent(ImmutableMap.<String, String>of(\"title\", \"test\"),\n                                                 ByteBuffer.wrap(msg.getBytes(Charsets.UTF_8)));\n      QueueEnqueue enqueue = new QueueEnqueue(queueProducer, queueName.toBytes(),\n                                              new QueueEntry(codec.encodePayload(event)));\n      opex.commit(opCtx, enqueue);\n    }\n\n    TimeUnit.SECONDS.sleep(5);\n\n    controller.stop().get();\n  }","id":49089,"modified_method":"@Test\n  public void testCountAndFilterWord() throws Exception {\n    TestHelper.getInjector().getInstance(DiscoveryService.class).startAndWait();\n    final ApplicationWithPrograms app = TestHelper.deployApplicationWithManager(CountAndFilterWord.class);\n    ProgramController controller = null;\n    for (final Program program : app.getPrograms()) {\n      if (program.getProcessorType() == Type.FLOW) {\n        ProgramRunner runner = TestHelper.getInjector().getInstance(FlowProgramRunner.class);\n        controller = runner.run(program, new ProgramOptions() {\n          @Override\n          public String getName() {\n            return program.getProgramName();\n          }\n\n          @Override\n          public Arguments getArguments() {\n            return new BasicArguments();\n          }\n\n          @Override\n          public Arguments getUserArguments() {\n            return new BasicArguments();\n          }\n        });\n      }\n    }\n\n    TimeUnit.SECONDS.sleep(1);\n    OperationExecutor opex = TestHelper.getInjector().getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    QueueProducer queueProducer = new QueueProducer(\"Testing\");\n    QueueName queueName = QueueName.fromStream(DefaultId.ACCOUNT, \"text\");\n    StreamEventCodec codec = new StreamEventCodec();\n    for (int i = 0; i < 1; i++) {\n      String msg = \"Testing message \" + i;\n      StreamEvent event = new DefaultStreamEvent(ImmutableMap.<String, String>of(\"title\", \"test\"),\n                                                 ByteBuffer.wrap(msg.getBytes(Charsets.UTF_8)));\n      QueueEnqueue enqueue = new QueueEnqueue(queueProducer, queueName.toBytes(),\n                                              new QueueEntry(codec.encodePayload(event)));\n      opex.commit(opCtx, enqueue);\n    }\n\n    TimeUnit.SECONDS.sleep(5);\n\n    controller.stop().get();\n  }","commit_id":"0fed4d43bd36dfa9e250fcf5c02d02c1ae36b13b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testFlow() throws Exception {\n    final CConfiguration configuration = CConfiguration.create();\n    configuration.set(Constants.CFG_APP_FABRIC_TEMP_DIR, System.getProperty(\"java.io.tmpdir\") + \"/app/temp\");\n    configuration.set(Constants.CFG_APP_FABRIC_OUTPUT_DIR, System.getProperty(\"java.io.tmpdir\")\n                                                              + \"/app/archive\" + UUID.randomUUID());\n\n    Injector injector = Guice.createInjector(new DataFabricModules().getInMemoryModules(),\n                                             new BigMamaModule(configuration));\n\n    injector.getInstance(DiscoveryService.class).startAndWait();\n\n    LocalLocationFactory lf = new LocalLocationFactory();\n\n    Location deployedJar = lf.create(\n      JarFinder.getJar(WordCountApp.class, TestHelper.getManifestWithMainClass(WordCountApp.class))\n    );\n    deployedJar.deleteOnExit();\n\n    ListenableFuture<?> p = TestHelper.getLocalManager(configuration).deploy(DefaultId.ACCOUNT, deployedJar);\n    ProgramRunnerFactory runnerFactory = injector.getInstance(ProgramRunnerFactory.class);\n    final ApplicationWithPrograms app = (ApplicationWithPrograms)p.get();\n    List<ProgramController> controllers = Lists.newArrayList();\n    for (final Program program : app.getPrograms()) {\n      ProgramRunner runner = runnerFactory.create(ProgramRunnerFactory.Type.valueOf(program.getProcessorType().name()));\n      controllers.add(runner.run(program, new ProgramOptions() {\n        @Override\n        public String getName() {\n          return program.getProgramName();\n        }\n\n        @Override\n        public Arguments getArguments() {\n          return new BasicArguments();\n        }\n\n        @Override\n        public Arguments getUserArguments() {\n          return new BasicArguments();\n        }\n      }));\n    }\n\n    TimeUnit.SECONDS.sleep(1);\n    OperationExecutor opex = injector.getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    QueueProducer queueProducer = new QueueProducer(\"Testing\");\n    QueueName queueName = QueueName.fromStream(DefaultId.ACCOUNT, \"text\");\n    StreamEventCodec codec = new StreamEventCodec();\n    for (int i = 0; i < 10; i++) {\n      String msg = \"Testing message \" + i;\n      StreamEvent event = new DefaultStreamEvent(ImmutableMap.<String, String>of(),\n                                                 ByteBuffer.wrap(msg.getBytes(Charsets.UTF_8)));\n      QueueEnqueue enqueue = new QueueEnqueue(queueProducer, queueName.toBytes(),\n                                              new QueueEntry(codec.encodePayload(event)));\n      opex.commit(opCtx, enqueue);\n    }\n\n    TimeUnit.SECONDS.sleep(10);\n\n    // Query\n    Gson gson = new Gson();\n    DiscoveryServiceClient discoveryServiceClient = injector.getInstance(DiscoveryServiceClient.class);\n    discoveryServiceClient.startAndWait();\n    Discoverable discoverable = discoveryServiceClient.discover(\n      String.format(\"procedure.%s.%s.%s\",\n                    DefaultId.ACCOUNT.getId(), \"WordCountApp\", \"WordFrequency\")).iterator().next();\n\n    HttpClient client = new DefaultHttpClient();\n    HttpPost post = new HttpPost(String.format(\"http://%s:%d/apps/%s/procedures/%s/%s\",\n                                               discoverable.getSocketAddress().getHostName(),\n                                               discoverable.getSocketAddress().getPort(),\n                                               \"WordCountApp\",\n                                               \"WordFrequency\",\n                                               \"wordfreq\"));\n    post.setEntity(new StringEntity(gson.toJson(ImmutableMap.of(\"word\", \"text:Testing\"))));\n    HttpResponse response = client.execute(post);\n    Map<String, Long> responseContent = gson.fromJson(\n      new InputStreamReader(response.getEntity().getContent(), Charsets.UTF_8),\n      new TypeToken<Map<String, Long>>(){}.getType());\n\n    LOG.info(\"Procedure response: \" + responseContent);\n    Assert.assertEquals(ImmutableMap.of(\"text:Testing\", 10L), responseContent);\n\n    client.getConnectionManager().shutdown();\n\n    for (ProgramController controller : controllers) {\n      controller.stop().get();\n    }\n  }","id":49090,"modified_method":"@Test\n  public void testFlow() throws Exception {\n    TestHelper.getInjector().getInstance(DiscoveryService.class).startAndWait();\n    final ApplicationWithPrograms app = TestHelper.deployApplicationWithManager(WordCountApp.class);\n    ProgramRunnerFactory runnerFactory = TestHelper.getInjector().getInstance(ProgramRunnerFactory.class);\n    List<ProgramController> controllers = Lists.newArrayList();\n    for (final Program program : app.getPrograms()) {\n      ProgramRunner runner = runnerFactory.create(ProgramRunnerFactory.Type.valueOf(program.getProcessorType().name()));\n      controllers.add(runner.run(program, new ProgramOptions() {\n        @Override\n        public String getName() {\n          return program.getProgramName();\n        }\n\n        @Override\n        public Arguments getArguments() {\n          return new BasicArguments();\n        }\n\n        @Override\n        public Arguments getUserArguments() {\n          return new BasicArguments();\n        }\n      }));\n    }\n\n    TimeUnit.SECONDS.sleep(1);\n    OperationExecutor opex = TestHelper.getInjector().getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    QueueProducer queueProducer = new QueueProducer(\"Testing\");\n    QueueName queueName = QueueName.fromStream(DefaultId.ACCOUNT, \"text\");\n    StreamEventCodec codec = new StreamEventCodec();\n    for (int i = 0; i < 10; i++) {\n      String msg = \"Testing message \" + i;\n      StreamEvent event = new DefaultStreamEvent(ImmutableMap.<String, String>of(),\n                                                 ByteBuffer.wrap(msg.getBytes(Charsets.UTF_8)));\n      QueueEnqueue enqueue = new QueueEnqueue(queueProducer, queueName.toBytes(),\n                                              new QueueEntry(codec.encodePayload(event)));\n      opex.commit(opCtx, enqueue);\n    }\n\n    TimeUnit.SECONDS.sleep(10);\n\n    // Query\n    Gson gson = new Gson();\n    DiscoveryServiceClient discoveryServiceClient = TestHelper.getInjector().getInstance(DiscoveryServiceClient.class);\n    discoveryServiceClient.startAndWait();\n    Discoverable discoverable = discoveryServiceClient.discover(\n      String.format(\"procedure.%s.%s.%s\",\n                    DefaultId.ACCOUNT.getId(), \"WordCountApp\", \"WordFrequency\")).iterator().next();\n\n    HttpClient client = new DefaultHttpClient();\n    HttpPost post = new HttpPost(String.format(\"http://%s:%d/apps/%s/procedures/%s/%s\",\n                                               discoverable.getSocketAddress().getHostName(),\n                                               discoverable.getSocketAddress().getPort(),\n                                               \"WordCountApp\",\n                                               \"WordFrequency\",\n                                               \"wordfreq\"));\n    post.setEntity(new StringEntity(gson.toJson(ImmutableMap.of(\"word\", \"text:Testing\"))));\n    HttpResponse response = client.execute(post);\n    Map<String, Long> responseContent = gson.fromJson(\n      new InputStreamReader(response.getEntity().getContent(), Charsets.UTF_8),\n      new TypeToken<Map<String, Long>>(){}.getType());\n\n    LOG.info(\"Procedure response: \" + responseContent);\n    Assert.assertEquals(ImmutableMap.of(\"text:Testing\", 10L), responseContent);\n\n    client.getConnectionManager().shutdown();\n\n    for (ProgramController controller : controllers) {\n      controller.stop().get();\n    }\n  }","commit_id":"0fed4d43bd36dfa9e250fcf5c02d02c1ae36b13b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testCountRandomApp() throws Exception {\n    final CConfiguration configuration = CConfiguration.create();\n    configuration.set(Constants.CFG_APP_FABRIC_TEMP_DIR, System.getProperty(\"java.io.tmpdir\") + \"/app/temp\");\n    configuration.set(Constants.CFG_APP_FABRIC_OUTPUT_DIR, System.getProperty(\"java.io.tmpdir\")\n                                                            + \"/app/archive\" + UUID.randomUUID());\n\n    Injector injector = Guice.createInjector(new DataFabricModules().getInMemoryModules(),\n                                             new BigMamaModule(configuration));\n\n    LocalLocationFactory lf = new LocalLocationFactory();\n\n    Location deployedJar = lf.create(\n      JarFinder.getJar(TestCountRandomApp.class, TestHelper.getManifestWithMainClass(TestCountRandomApp.class))\n    );\n    deployedJar.deleteOnExit();\n\n    ListenableFuture<?> p = TestHelper.getLocalManager(configuration).deploy(DefaultId.ACCOUNT, deployedJar);\n    final ApplicationWithPrograms app = (ApplicationWithPrograms)p.get();\n    ProgramController controller = null;\n    for (final Program program : app.getPrograms()) {\n      if (program.getProcessorType() == Type.FLOW) {\n        ProgramRunner runner = injector.getInstance(FlowProgramRunner.class);\n        controller = runner.run(program, new ProgramOptions() {\n          @Override\n          public String getName() {\n            return program.getProgramName();\n          }\n\n          @Override\n          public Arguments getArguments() {\n            return new BasicArguments();\n          }\n\n          @Override\n          public Arguments getUserArguments() {\n            return new BasicArguments();\n          }\n        });\n      }\n    }\n\n    TimeUnit.SECONDS.sleep(10);\n    controller.stop().get();\n  }","id":49091,"modified_method":"@Test\n  public void testCountRandomApp() throws Exception {\n    TestHelper.getInjector().getInstance(DiscoveryService.class).startAndWait();\n    final ApplicationWithPrograms app = TestHelper.deployApplicationWithManager(TestCountRandomApp.class);\n    ProgramController controller = null;\n    for (final Program program : app.getPrograms()) {\n      if (program.getProcessorType() == Type.FLOW) {\n        ProgramRunner runner = TestHelper.getInjector().getInstance(FlowProgramRunner.class);\n        controller = runner.run(program, new ProgramOptions() {\n          @Override\n          public String getName() {\n            return program.getProgramName();\n          }\n\n          @Override\n          public Arguments getArguments() {\n            return new BasicArguments();\n          }\n\n          @Override\n          public Arguments getUserArguments() {\n            return new BasicArguments();\n          }\n        });\n      }\n    }\n\n    TimeUnit.SECONDS.sleep(10);\n    controller.stop().get();\n  }","commit_id":"0fed4d43bd36dfa9e250fcf5c02d02c1ae36b13b","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Improper Manifest file should throw an exception.\n   */\n  @Test(expected = ExecutionException.class)\n  public void testImproperOrNoManifestFile() throws Exception {\n    String jar = JarFinder.getJar(WebCrawlApp.class, new Manifest());\n    Location deployedJar = lf.create(jar);\n    deployedJar.deleteOnExit();\n    TestHelper.getLocalManager(configuration).deploy(DefaultId.ACCOUNT, deployedJar);\n  }","id":49092,"modified_method":"/**\n   * Improper Manifest file should throw an exception.\n   */\n  @Test(expected = ExecutionException.class)\n  public void testImproperOrNoManifestFile() throws Exception {\n    String jar = JarFinder.getJar(WebCrawlApp.class, new Manifest());\n    Location deployedJar = lf.create(jar);\n    deployedJar.deleteOnExit();\n    TestHelper.getLocalManager().deploy(DefaultId.ACCOUNT, deployedJar);\n  }","commit_id":"0fed4d43bd36dfa9e250fcf5c02d02c1ae36b13b","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void before() throws Exception {\n    lf = new LocalLocationFactory();\n    configuration = CConfiguration.create();\n    configuration.set(Constants.CFG_APP_FABRIC_TEMP_DIR, System.getProperty(\"java.io.tmpdir\"));\n    configuration.set(Constants.CFG_APP_FABRIC_OUTPUT_DIR, System.getProperty(\"java.io.tmpdir\")\n                                                                      + \"/\" + UUID.randomUUID());\n  }","id":49093,"modified_method":"@BeforeClass\n  public static void before() throws Exception {\n    lf = new LocalLocationFactory();\n  }","commit_id":"0fed4d43bd36dfa9e250fcf5c02d02c1ae36b13b","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Good pipeline with good tests.\n   */\n  @Test\n  public void testGoodPipeline() throws Exception {\n    Location deployedJar = lf.create(\n      JarFinder.getJar(ToyApp.class, TestHelper.getManifestWithMainClass(ToyApp.class))\n    );\n\n    ListenableFuture<?> p = TestHelper.getLocalManager(configuration).deploy(DefaultId.ACCOUNT, deployedJar);\n    ApplicationWithPrograms input = (ApplicationWithPrograms)p.get();\n\n    Assert.assertEquals(input.getAppSpecLoc().getArchive(), deployedJar);\n    Assert.assertEquals(input.getPrograms().iterator().next().getProcessorType(), Type.FLOW);\n    Assert.assertEquals(input.getPrograms().iterator().next().getProgramName(), \"ToyFlow\");\n  }","id":49094,"modified_method":"/**\n   * Good pipeline with good tests.\n   */\n  @Test\n  public void testGoodPipeline() throws Exception {\n    Location deployedJar = lf.create(\n      JarFinder.getJar(ToyApp.class, TestHelper.getManifestWithMainClass(ToyApp.class))\n    );\n\n    ListenableFuture<?> p = TestHelper.getLocalManager().deploy(DefaultId.ACCOUNT, deployedJar);\n    ApplicationWithPrograms input = (ApplicationWithPrograms)p.get();\n\n    Assert.assertEquals(input.getAppSpecLoc().getArchive(), deployedJar);\n    Assert.assertEquals(input.getPrograms().iterator().next().getProcessorType(), Type.FLOW);\n    Assert.assertEquals(input.getPrograms().iterator().next().getProgramName(), \"ToyFlow\");\n  }","commit_id":"0fed4d43bd36dfa9e250fcf5c02d02c1ae36b13b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Before\n  public void before() {\n    final Injector injector = Guice.createInjector(new DataFabricModules().getInMemoryModules(),\n                                                   new BigMamaModule(configuration));\n\n    metadataService = injector.getInstance(MetadataService.Iface.class);\n    store = injector.getInstance(MDSBasedStore.class);\n  }","id":49095,"modified_method":"@Before\n  public void before() throws OperationException {\n    metadataService = TestHelper.getInjector().getInstance(MetadataService.Iface.class);\n    store = TestHelper.getInjector().getInstance(MDSBasedStore.class);\n    // cleanups data\n    TestHelper.getInjector().getInstance(OperationExecutor.class).execute(OperationUtil.DEFAULT, new ClearFabric());\n  }","commit_id":"0fed4d43bd36dfa9e250fcf5c02d02c1ae36b13b","url":"https://github.com/caskdata/cdap"},{"original_method":"public void set(BasicMapReduceContext context, CConfiguration conf) {\n    setRunId(context.getRunId().getId());\n    setConf(conf);\n    setInputDataSet(((DataSet)context.getInputDataset()).getName());\n    setInputSelection(context.getInputDataSelection());\n    setOutputDataSet(((DataSet)context.getInputDataset()).getName());\n  }","id":49096,"modified_method":"public void set(BasicMapReduceContext context, CConfiguration conf) {\n    setRunId(context.getRunId().getId());\n    setConf(conf);\n    if (context.getInputDataset() != null) {\n      setInputDataSet(((DataSet)context.getInputDataset()).getName());\n      if (context.getInputDataSelection() != null) {\n        setInputSelection(context.getInputDataSelection());\n      }\n    }\n\n    if (context.getOutputDataset() != null) {\n      setOutputDataSet(((DataSet)context.getOutputDataset()).getName());\n    }\n  }","commit_id":"0fed4d43bd36dfa9e250fcf5c02d02c1ae36b13b","url":"https://github.com/caskdata/cdap"},{"original_method":"private List<Split> getInputSelection() {\n    String splitClassName = jobContext.getConfiguration().get(HCONF_ATTR_INPUT_SPLIT_CLASS);\n    String splitsJson = jobContext.getConfiguration().get(HCONF_ATTR_INPUT_SPLITS);\n\n    try {\n      // Yes, we know that it implements Split\n      @SuppressWarnings(\"unchecked\")\n      Class<? extends Split> splitClass =\n        (Class<? extends Split>) jobContext.getConfiguration().getClassLoader().loadClass(splitClassName);\n      return new Gson().fromJson(splitsJson, new ListSplitType(splitClass));\n    } catch (ClassNotFoundException e) {\n      //todo\n      throw Throwables.propagate(e);\n    }\n  }","id":49097,"modified_method":"private List<Split> getInputSelection() {\n    String splitClassName = jobContext.getConfiguration().get(HCONF_ATTR_INPUT_SPLIT_CLASS);\n    if (splitClassName == null) {\n      return Collections.emptyList();\n    }\n    String splitsJson = jobContext.getConfiguration().get(HCONF_ATTR_INPUT_SPLITS);\n\n    try {\n      // Yes, we know that it implements Split\n      @SuppressWarnings(\"unchecked\")\n      Class<? extends Split> splitClass =\n        (Class<? extends Split>) jobContext.getConfiguration().getClassLoader().loadClass(splitClassName);\n      return new Gson().fromJson(splitsJson, new ListSplitType(splitClass));\n    } catch (ClassNotFoundException e) {\n      //todo\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"0fed4d43bd36dfa9e250fcf5c02d02c1ae36b13b","url":"https://github.com/caskdata/cdap"},{"original_method":"private void submit(final MapReduce job, Location jobJarLocation, final BasicMapReduceContext context)\n    throws Exception {\n    jobConf = Job.getInstance(hConf);\n    context.setJob(jobConf);\n    // additional mapreduce job initialization at run-time\n    job.beforeSubmit(context);\n\n    // replace user's Mapper & Reducer's with our wrappers in job config\n    wrapMapperClassIfNeeded(jobConf);\n    wrapReducerClassIfNeeded(jobConf);\n\n    // set input/output datasets info\n    DataSet inputDataset = setInputDataSetIfNeeded(jobConf, context);\n    DataSet outputDataset = setOutputDataSetIfNeeded(jobConf, context);\n\n    boolean useDataSetAsInputOrOutput = inputDataset != null || outputDataset != null;\n    if (useDataSetAsInputOrOutput) {\n      MapReduceContextProvider contextProvider = new MapReduceContextProvider(jobConf);\n      contextProvider.set(context, cConf);\n    }\n\n    // TODO: consider using approach that Weave uses: package all jars with submitted job all the time\n    // adding continuuity jars to classpath (which are located/cached on hdfs to avoid redundant copying with every job)\n    addContinuuityJarsToClasspath(jobConf);\n\n    jobConf.setJar(jobJarLocation.toURI().getPath());\n    jobConf.getConfiguration().setClassLoader(context.getProgram().getClassLoader());\n\n    new Thread() {\n      @Override\n      public void run() {\n        boolean success = false;\n        try {\n          // note: this sets logging context on the thread level\n          LoggingContextAccessor.setLoggingContext(context.getLoggingContext());\n          try {\n            LOG.info(\"Submitting mapreduce job {}\", context.toString());\n            success = jobConf.waitForCompletion(true);\n          } catch (InterruptedException e) {\n            // nothing we can do now: we simply stopped watching for job completion...\n            throw Throwables.propagate(e);\n          } catch (Exception e) {\n            throw Throwables.propagate(e);\n          }\n\n          job.onFinish(success, context);\n        } catch (Exception e) {\n          throw Throwables.propagate(e);\n        } finally {\n          // stopping controller when mapreduce job is finished\n          // (also that should finish transaction, but that might change after integration with \"long running txs\")\n          stopController(success);\n        }\n      }\n    }.start();\n  }","id":49098,"modified_method":"private void submit(final MapReduce job, Location jobJarLocation, final BasicMapReduceContext context)\n    throws Exception {\n    jobConf = Job.getInstance(hConf);\n    context.setJob(jobConf);\n    // additional mapreduce job initialization at run-time\n    job.beforeSubmit(context);\n\n    // replace user's Mapper & Reducer's with our wrappers in job config\n    wrapMapperClassIfNeeded(jobConf);\n    wrapReducerClassIfNeeded(jobConf);\n\n    // set input/output datasets info\n    setInputDataSetIfNeeded(jobConf, context);\n    setOutputDataSetIfNeeded(jobConf, context);\n\n    MapReduceContextProvider contextProvider = new MapReduceContextProvider(jobConf);\n    contextProvider.set(context, cConf);\n\n    // TODO: consider using approach that Weave uses: package all jars with submitted job all the time\n    // adding continuuity jars to classpath (which are located/cached on hdfs to avoid redundant copying with every job)\n    addContinuuityJarsToClasspath(jobConf);\n\n    jobConf.setJar(jobJarLocation.toURI().getPath());\n    jobConf.getConfiguration().setClassLoader(context.getProgram().getClassLoader());\n\n    new Thread() {\n      @Override\n      public void run() {\n        boolean success = false;\n        try {\n          // note: this sets logging context on the thread level\n          LoggingContextAccessor.setLoggingContext(context.getLoggingContext());\n          try {\n            LOG.info(\"Submitting mapreduce job {}\", context.toString());\n            success = jobConf.waitForCompletion(true);\n          } catch (InterruptedException e) {\n            // nothing we can do now: we simply stopped watching for job completion...\n            throw Throwables.propagate(e);\n          } catch (Exception e) {\n            throw Throwables.propagate(e);\n          }\n\n          job.onFinish(success, context);\n        } catch (Exception e) {\n          throw Throwables.propagate(e);\n        } finally {\n          // stopping controller when mapreduce job is finished\n          // (also that should finish transaction, but that might change after integration with \"long running txs\")\n          stopController(success);\n        }\n      }\n    }.start();\n  }","commit_id":"0fed4d43bd36dfa9e250fcf5c02d02c1ae36b13b","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void beforeClass() {\n    configuration = CConfiguration.create();\n    configuration.set(Constants.CFG_APP_FABRIC_TEMP_DIR, \"/tmp/app/temp\");\n    configuration.set(Constants.CFG_APP_FABRIC_OUTPUT_DIR, \"/tmp/app/archive\" + UUID.randomUUID());\n\n    final Configuration hConf = new Configuration();\n    hConf.addResource(\"mapred-site-local.xml\");\n    hConf.reloadConfiguration();\n\n    injector = Guice.createInjector(new DataFabricModules().getSingleNodeModules(),\n                                    new BigMamaModule(configuration),\n                                    new Module() {\n                                      @Override\n                                      public void configure(Binder binder) {\n                                        binder.bind(Configuration.class).toInstance(hConf);\n                                      }\n                                    });\n  }","id":49099,"modified_method":"@BeforeClass\n  public static void beforeClass() {\n    final Configuration hConf = new Configuration();\n    hConf.addResource(\"mapred-site-local.xml\");\n    hConf.reloadConfiguration();\n\n    injector = Guice.createInjector(new DataFabricModules().getInMemoryModules(),\n                                    new BigMamaModule(TestHelper.configuration),\n                                    new Module() {\n                                      @Override\n                                      public void configure(Binder binder) {\n                                        binder.bind(Configuration.class).toInstance(hConf);\n                                      }\n                                    });\n  }","commit_id":"0fed4d43bd36dfa9e250fcf5c02d02c1ae36b13b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testTimeSeriesRecordsCount() throws Exception {\n    final ApplicationWithPrograms app = deployApp(AppWithMapReduce.class);\n\n    OperationExecutor opex = injector.getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    TimeseriesTable table = (TimeseriesTable) getTable(opex, opCtx, \"timeSeries\");\n\n    fillTestInputData(table);\n\n    Thread.sleep(2);\n\n    long start = System.currentTimeMillis();\n    runProgram(app, AppWithMapReduce.AggregateTimeseriesByTag.class);\n    long stop = System.currentTimeMillis();\n\n    Map<String, Long> expected = Maps.newHashMap();\n    // note: not all records add to the sum since filter by tag=\"tag1\" and ts={1..3} is used\n    expected.put(\"tag1\", 18L);\n    expected.put(\"tag2\", 3L);\n    expected.put(\"tag3\", 18L);\n    // this is a hack for making writes of MR visible here. Should go away when integrated with long-running tx\n    // TODO: is the fact that we have to do this hack actually means there's a bug? With SynchronousTransactionAgent\n    //       all should be visible right away\n    table.write(new TimeseriesTable.Entry(Bytes.toBytes(\"foo\"), Bytes.toBytes(\"bar\"), 0L));\n    List<TimeseriesTable.Entry> agg = table.read(AggregateMetricsByTag.BY_TAGS, start, stop);\n    Assert.assertEquals(expected.size(), agg.size());\n    for (TimeseriesTable.Entry entry : agg) {\n      String tag = Bytes.toString(entry.getTags()[0]);\n      Assert.assertEquals((long) expected.get(tag), Bytes.toLong(entry.getValue()));\n    }\n  }","id":49100,"modified_method":"@Test\n  public void testTimeSeriesRecordsCount() throws Exception {\n    final ApplicationWithPrograms app = TestHelper.deployApplicationWithManager(AppWithMapReduce.class);\n\n    OperationExecutor opex = injector.getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    TimeseriesTable table = (TimeseriesTable) getTable(opex, opCtx, \"timeSeries\");\n\n    fillTestInputData(table);\n\n    Thread.sleep(2);\n\n    long start = System.currentTimeMillis();\n    runProgram(app, AppWithMapReduce.AggregateTimeseriesByTag.class);\n    long stop = System.currentTimeMillis();\n\n    Map<String, Long> expected = Maps.newHashMap();\n    // note: not all records add to the sum since filter by tag=\"tag1\" and ts={1..3} is used\n    expected.put(\"tag1\", 18L);\n    expected.put(\"tag2\", 3L);\n    expected.put(\"tag3\", 18L);\n    // this is a hack for making writes of MR visible here. Should go away when integrated with long-running tx\n    // TODO: is the fact that we have to do this hack actually means there's a bug? With SynchronousTransactionAgent\n    //       all should be visible right away\n    table.write(new TimeseriesTable.Entry(Bytes.toBytes(\"foo\"), Bytes.toBytes(\"bar\"), 0L));\n    List<TimeseriesTable.Entry> agg = table.read(AggregateMetricsByTag.BY_TAGS, start, stop);\n    Assert.assertEquals(expected.size(), agg.size());\n    for (TimeseriesTable.Entry entry : agg) {\n      String tag = Bytes.toString(entry.getTags()[0]);\n      Assert.assertEquals((long) expected.get(tag), Bytes.toLong(entry.getValue()));\n    }\n  }","commit_id":"0fed4d43bd36dfa9e250fcf5c02d02c1ae36b13b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testWordCount() throws Exception {\n    final ApplicationWithPrograms app = deployApp(AppWithMapReduce.class);\n\n    OperationExecutor opex = injector.getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    String inputPath = createInput();\n    File outputDir = new File(FileUtils.getTempDirectory().getPath() + \"/out_\" + System.currentTimeMillis());\n    outputDir.deleteOnExit();\n\n    KeyValueTable jobConfigTable = (KeyValueTable) getTable(opex, opCtx, \"jobConfig\");\n    jobConfigTable.write(tb(\"inputPath\"), tb(inputPath));\n    jobConfigTable.write(tb(\"outputPath\"), tb(outputDir.getPath()));\n\n    runProgram(app, AppWithMapReduce.ClassicWordCount.class);\n\n    File outputFile = outputDir.listFiles()[0];\n    int lines = 0;\n    BufferedReader reader = new BufferedReader(new FileReader(outputFile));\n    try {\n      while (true) {\n        String line = reader.readLine();\n        if (line == null) {\n          break;\n        }\n        lines++;\n      }\n    } finally {\n      reader.close();\n    }\n    // dummy check that output file is not empty\n    Assert.assertTrue(lines > 0);\n  }","id":49101,"modified_method":"@Test\n  public void testWordCount() throws Exception {\n    final ApplicationWithPrograms app = TestHelper.deployApplicationWithManager(AppWithMapReduce.class);\n\n    OperationExecutor opex = injector.getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    String inputPath = createInput();\n    File outputDir = new File(FileUtils.getTempDirectory().getPath() + \"/out_\" + System.currentTimeMillis());\n    outputDir.deleteOnExit();\n\n    KeyValueTable jobConfigTable = (KeyValueTable) getTable(opex, opCtx, \"jobConfig\");\n    jobConfigTable.write(tb(\"inputPath\"), tb(inputPath));\n    jobConfigTable.write(tb(\"outputPath\"), tb(outputDir.getPath()));\n\n    runProgram(app, AppWithMapReduce.ClassicWordCount.class);\n\n    File outputFile = outputDir.listFiles()[0];\n    int lines = 0;\n    BufferedReader reader = new BufferedReader(new FileReader(outputFile));\n    try {\n      while (true) {\n        String line = reader.readLine();\n        if (line == null) {\n          break;\n        }\n        lines++;\n      }\n    } finally {\n      reader.close();\n    }\n    // dummy check that output file is not empty\n    Assert.assertTrue(lines > 0);\n  }","commit_id":"0fed4d43bd36dfa9e250fcf5c02d02c1ae36b13b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testMulti() throws Exception {\n    // TODO: Fix this test case to really test with numGroups settings.\n    final CConfiguration configuration = CConfiguration.create();\n    configuration.set(Constants.CFG_APP_FABRIC_TEMP_DIR, System.getProperty(\"java.io.tmpdir\") + \"/app/temp\");\n    configuration.set(Constants.CFG_APP_FABRIC_OUTPUT_DIR, System.getProperty(\"java.io.tmpdir\")\n                                                            + \"/app/archive\" + UUID.randomUUID());\n\n    Injector injector = Guice.createInjector(new DataFabricModules().getInMemoryModules(),\n                                             new BigMamaModule(configuration));\n\n    injector.getInstance(DiscoveryService.class).startAndWait();\n\n    LocalLocationFactory lf = new LocalLocationFactory();\n\n    Location deployedJar = lf.create(\n      JarFinder.getJar(MultiApp.class, TestHelper.getManifestWithMainClass(MultiApp.class))\n    );\n    deployedJar.deleteOnExit();\n\n    ListenableFuture<?> p = TestHelper.getLocalManager(configuration).deploy(DefaultId.ACCOUNT, deployedJar);\n    ProgramRunnerFactory runnerFactory = injector.getInstance(ProgramRunnerFactory.class);\n    final ApplicationWithPrograms app = (ApplicationWithPrograms)p.get();\n    List<ProgramController> controllers = Lists.newArrayList();\n    for (final Program program : app.getPrograms()) {\n      ProgramRunner runner = runnerFactory.create(ProgramRunnerFactory.Type.valueOf(program.getProcessorType().name()));\n      controllers.add(runner.run(program, new ProgramOptions() {\n        @Override\n        public String getName() {\n          return program.getProgramName();\n        }\n\n        @Override\n        public Arguments getArguments() {\n          return new BasicArguments();\n        }\n\n        @Override\n        public Arguments getUserArguments() {\n          return new BasicArguments();\n        }\n      }));\n    }\n\n    TimeUnit.SECONDS.sleep(4);\n\n    OperationExecutor opex = injector.getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    TransactionProxy proxy = new TransactionProxy();\n    proxy.setTransactionAgent(new SynchronousTransactionAgent(opex, opCtx));\n    DataSetInstantiator dataSetInstantiator = new DataSetInstantiator(new DataFabricImpl(opex, opCtx), proxy,\n                                                                      getClass().getClassLoader());\n    dataSetInstantiator.setDataSets(ImmutableList.copyOf(new MultiApp().configure().getDataSets().values()));\n\n    KeyValueTable accumulated = dataSetInstantiator.getDataSet(\"accumulated\");\n    byte[] value = accumulated.read(KEY);\n\n    Assert.assertEquals(14850L, Longs.fromByteArray(value));\n\n    for (ProgramController controller : controllers) {\n      controller.stop().get();\n    }\n  }","id":49102,"modified_method":"@Test\n  public void testMulti() throws Exception {\n    // TODO: Fix this test case to really test with numGroups settings.\n    final ApplicationWithPrograms app = TestHelper.deployApplicationWithManager(MultiApp.class);\n    ProgramRunnerFactory runnerFactory = TestHelper.getInjector().getInstance(ProgramRunnerFactory.class);\n    List<ProgramController> controllers = Lists.newArrayList();\n    for (final Program program : app.getPrograms()) {\n      ProgramRunner runner = runnerFactory.create(ProgramRunnerFactory.Type.valueOf(program.getProcessorType().name()));\n      controllers.add(runner.run(program, new ProgramOptions() {\n        @Override\n        public String getName() {\n          return program.getProgramName();\n        }\n\n        @Override\n        public Arguments getArguments() {\n          return new BasicArguments();\n        }\n\n        @Override\n        public Arguments getUserArguments() {\n          return new BasicArguments();\n        }\n      }));\n    }\n\n    TimeUnit.SECONDS.sleep(4);\n\n    OperationExecutor opex = TestHelper.getInjector().getInstance(OperationExecutor.class);\n    OperationContext opCtx = new OperationContext(DefaultId.ACCOUNT.getId(),\n                                                  app.getAppSpecLoc().getSpecification().getName());\n\n    TransactionProxy proxy = new TransactionProxy();\n    proxy.setTransactionAgent(new SynchronousTransactionAgent(opex, opCtx));\n    DataSetInstantiator dataSetInstantiator = new DataSetInstantiator(new DataFabricImpl(opex, opCtx), proxy,\n                                                                      getClass().getClassLoader());\n    dataSetInstantiator.setDataSets(ImmutableList.copyOf(new MultiApp().configure().getDataSets().values()));\n\n    KeyValueTable accumulated = dataSetInstantiator.getDataSet(\"accumulated\");\n    byte[] value = accumulated.read(KEY);\n\n    Assert.assertEquals(14850L, Longs.fromByteArray(value));\n\n    for (ProgramController controller : controllers) {\n      controller.stop().get();\n    }\n  }","commit_id":"0fed4d43bd36dfa9e250fcf5c02d02c1ae36b13b","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * @return Returns an instance of {@link LocalManager}\n   */\n  public static Manager<Location, ApplicationWithPrograms> getLocalManager( CConfiguration configuration) {\n    if (injector == null) {\n      injector = Guice.createInjector(new BigMamaModule(configuration),\n                                      new DataFabricModules().getInMemoryModules());\n\n    }\n\n    ManagerFactory factory = injector.getInstance(ManagerFactory.class);\n    return (Manager<Location, ApplicationWithPrograms>)factory.create();\n  }","id":49103,"modified_method":"/**\n   * @return Returns an instance of {@link LocalManager}\n   */\n  public static Manager<Location, ApplicationWithPrograms> getLocalManager() {\n    ManagerFactory factory = injector.getInstance(ManagerFactory.class);\n    return (Manager<Location, ApplicationWithPrograms>)factory.create();\n  }","commit_id":"0fed4d43bd36dfa9e250fcf5c02d02c1ae36b13b","url":"https://github.com/caskdata/cdap"},{"original_method":"public void testRegexEval3() throws Exception\r\n    {\r\n        TransMeta transMeta = new TransMeta();\r\n        transMeta.setName(\"regexeval2\");\r\n        \r\n        RegexEvalMeta regexEvalMeta = new RegexEvalMeta();\r\n        \r\n        regexEvalMeta.setScript(\"((a)|([A1]))([B2]?).*\");\r\n        regexEvalMeta.setMatcher(\"field1\");\r\n        regexEvalMeta.setResultFieldName(\"res\");\r\n        regexEvalMeta.setAllowCaptureGroupsFlag(true);\r\n        \r\n        regexEvalMeta.allocate(4);\r\n        \r\n        regexEvalMeta.getFieldName()[0] = \"cap\";\r\n        regexEvalMeta.getFieldType()[0] = ValueMeta.TYPE_STRING;\r\n        \r\n        regexEvalMeta.getFieldName()[1] = \"capIfNull\";\r\n        regexEvalMeta.getFieldType()[1] = ValueMeta.TYPE_STRING;\r\n        regexEvalMeta.getFieldIfNull()[1] = \"x\";\r\n        \r\n        regexEvalMeta.getFieldName()[2] = \"capNullIf\";\r\n        regexEvalMeta.getFieldType()[2] = ValueMeta.TYPE_STRING;\r\n        regexEvalMeta.getFieldNullIf()[2] = \"1\";\r\n        \r\n        regexEvalMeta.getFieldName()[3] = \"capIfNullNullIf\";\r\n        regexEvalMeta.getFieldType()[3] = ValueMeta.TYPE_INTEGER;\r\n        regexEvalMeta.getFieldIfNull()[3] = \"0\";\r\n        regexEvalMeta.getFieldNullIf()[3] = \"B\";\r\n        \r\n        StepMeta injectorStep = createInjectorStepForTrans(\"injector step\", transMeta);\r\n        StepMeta dummyStep = createConnectedDummyStepForTrans(\"dummy step\", transMeta, injectorStep);\r\n        StepMeta regexEvalStep = createConnectedStepForTrans(\"regexeval step\", regexEvalMeta, transMeta, dummyStep);\r\n\r\n        Trans trans = new Trans(transMeta);\r\n        trans.prepareExecution(null);\r\n               \r\n        RowProducer rp = trans.addRowProducer(injectorStep.getName(), 0);\r\n        RowStepCollector rc = new RowStepCollector();\r\n        trans.getStepInterface(regexEvalStep.getName(), 0).addRowListener(rc);\r\n\r\n        trans.startThreads();\r\n        \r\n        feedSourceRows(rp, createSourceData());\r\n\r\n        trans.waitUntilFinished();   \r\n        \r\n        checkRows(createResultData3(), rc.getRowsWritten());\r\n    }","id":49104,"modified_method":"public void testRegexEval3() throws Exception\r\n    {\r\n        String regexStepName = \"regexeval\";\r\n        RegexEvalMeta regexEvalMeta = new RegexEvalMeta();\r\n        \r\n        regexEvalMeta.setScript(\"((a)|([A1]))([B2]?).*\");\r\n        regexEvalMeta.setMatcher(\"field1\");\r\n        regexEvalMeta.setResultFieldName(\"res\");\r\n        regexEvalMeta.setAllowCaptureGroupsFlag(true);\r\n        \r\n        regexEvalMeta.allocate(4);\r\n        \r\n        regexEvalMeta.getFieldName()[0] = \"cap\";\r\n        regexEvalMeta.getFieldType()[0] = ValueMeta.TYPE_STRING;\r\n        \r\n        regexEvalMeta.getFieldName()[1] = \"capIfNull\";\r\n        regexEvalMeta.getFieldType()[1] = ValueMeta.TYPE_STRING;\r\n        regexEvalMeta.getFieldIfNull()[1] = \"x\";\r\n        \r\n        regexEvalMeta.getFieldName()[2] = \"capNullIf\";\r\n        regexEvalMeta.getFieldType()[2] = ValueMeta.TYPE_STRING;\r\n        regexEvalMeta.getFieldNullIf()[2] = \"1\";\r\n        \r\n        regexEvalMeta.getFieldName()[3] = \"capIfNullNullIf\";\r\n        regexEvalMeta.getFieldType()[3] = ValueMeta.TYPE_INTEGER;\r\n        regexEvalMeta.getFieldIfNull()[3] = \"0\";\r\n        regexEvalMeta.getFieldNullIf()[3] = \"B\";\r\n        \r\n        TransMeta transMeta = TransTestFactory.generateTestTransformation(new Variables(), regexEvalMeta, regexStepName);\r\n        \r\n        // Now execute the transformation and get the result from the dummy step.\r\n        //\r\n        List<RowMetaAndData> result = TransTestFactory.executeTestTransformation\r\n                (\r\n                    transMeta, \r\n                    TransTestFactory.INJECTOR_STEPNAME, \r\n                    regexStepName, \r\n                    TransTestFactory.DUMMY_STEPNAME, \r\n                    createSourceData()\r\n                );\r\n\r\n        checkRows(createResultData3(), result);\r\n    }","commit_id":"b9269da7630de142a3474db0ae530c588c3ff26c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void testRegexEval2() throws Exception\r\n    {\r\n        TransMeta transMeta = new TransMeta();\r\n        transMeta.setName(\"regexeval2\");\r\n        \r\n        RegexEvalMeta regexEvalMeta = new RegexEvalMeta();\r\n        \r\n        regexEvalMeta.setScript(\"\\\\d(\\\\d)\\\\d\");\r\n        regexEvalMeta.setMatcher(\"field1\");\r\n        regexEvalMeta.setResultFieldName(\"res\");\r\n        regexEvalMeta.setAllowCaptureGroupsFlag(true);\r\n        regexEvalMeta.allocate(1);\r\n        regexEvalMeta.getFieldName()[0] = \"cap\";\r\n        regexEvalMeta.getFieldType()[0] = ValueMeta.TYPE_INTEGER;\r\n        \r\n\r\n        StepMeta injectorStep = createInjectorStepForTrans(\"injector step\", transMeta);\r\n        StepMeta dummyStep = createConnectedDummyStepForTrans(\"dummy step\", transMeta, injectorStep);\r\n        StepMeta regexEvalStep = createConnectedStepForTrans(\"regexeval step\", regexEvalMeta, transMeta, dummyStep);\r\n\r\n        Trans trans = new Trans(transMeta);\r\n        trans.prepareExecution(null);\r\n               \r\n        RowProducer rp = trans.addRowProducer(injectorStep.getName(), 0);\r\n        RowStepCollector rc = new RowStepCollector();\r\n        trans.getStepInterface(regexEvalStep.getName(), 0).addRowListener(rc);\r\n\r\n        trans.startThreads();\r\n        \r\n        feedSourceRows(rp, createSourceData());\r\n\r\n        trans.waitUntilFinished();   \r\n        \r\n        checkRows(createResultData2(), rc.getRowsWritten());\r\n    }","id":49105,"modified_method":"public void testRegexEval2() throws Exception\r\n    {\r\n        String regexStepName = \"regexeval\";\r\n        RegexEvalMeta regexEvalMeta = new RegexEvalMeta();\r\n        \r\n        regexEvalMeta.setScript(\"\\\\d(\\\\d)\\\\d\");\r\n        regexEvalMeta.setMatcher(\"field1\");\r\n        regexEvalMeta.setResultFieldName(\"res\");\r\n        regexEvalMeta.setAllowCaptureGroupsFlag(true);\r\n        regexEvalMeta.allocate(1);\r\n        regexEvalMeta.getFieldName()[0] = \"cap\";\r\n        regexEvalMeta.getFieldType()[0] = ValueMeta.TYPE_INTEGER;\r\n        \r\n        TransMeta transMeta = TransTestFactory.generateTestTransformation(new Variables(), regexEvalMeta, regexStepName);\r\n        \r\n        // Now execute the transformation and get the result from the dummy step.\r\n        //\r\n        List<RowMetaAndData> result = TransTestFactory.executeTestTransformation\r\n                (\r\n                    transMeta, \r\n                    TransTestFactory.INJECTOR_STEPNAME, \r\n                    regexStepName, \r\n                    TransTestFactory.DUMMY_STEPNAME, \r\n                    createSourceData()\r\n                );\r\n\r\n        checkRows(createResultData2(), result);\r\n    }","commit_id":"b9269da7630de142a3474db0ae530c588c3ff26c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void testRegexEval1() throws Exception\r\n    {\r\n        TransMeta transMeta = new TransMeta();\r\n        transMeta.setName(\"regexeval1\");\r\n    \t\r\n        RegexEvalMeta regexEvalMeta = new RegexEvalMeta();\r\n        \r\n        regexEvalMeta.setScript(\"[abc]*\");\r\n        regexEvalMeta.setMatcher(\"field1\");\r\n        regexEvalMeta.setResultFieldName(\"res\");\r\n\r\n        StepMeta injectorStep = createInjectorStepForTrans(\"injector step\", transMeta);\r\n        StepMeta dummyStep = createConnectedDummyStepForTrans(\"dummy step\", transMeta, injectorStep);\r\n        StepMeta regexEvalStep = createConnectedStepForTrans(\"regexeval step\", regexEvalMeta, transMeta, dummyStep);\r\n\r\n        Trans trans = new Trans(transMeta);\r\n        trans.prepareExecution(null);\r\n               \r\n        RowProducer rp = trans.addRowProducer(injectorStep.getName(), 0);\r\n        RowStepCollector rc = new RowStepCollector();\r\n        trans.getStepInterface(regexEvalStep.getName(), 0).addRowListener(rc);\r\n\r\n        trans.startThreads();\r\n        \r\n        feedSourceRows(rp, createSourceData());\r\n\r\n        trans.waitUntilFinished();   \r\n        \r\n        checkRows(createResultData1(), rc.getRowsWritten());\r\n    }","id":49106,"modified_method":"public void testRegexEval1() throws Exception\r\n    {\r\n        String regexStepName = \"regexeval\";\r\n        RegexEvalMeta regexEvalMeta = new RegexEvalMeta();\r\n\r\n        regexEvalMeta.setScript(\"[abc]*\");\r\n        regexEvalMeta.setMatcher(\"field1\");\r\n        regexEvalMeta.setResultFieldName(\"res\");\r\n\r\n        TransMeta transMeta = TransTestFactory.generateTestTransformation(new Variables(), regexEvalMeta, regexStepName);\r\n        \r\n        // Now execute the transformation and get the result from the dummy step.\r\n        //\r\n        List<RowMetaAndData> result = TransTestFactory.executeTestTransformation\r\n                (\r\n                    transMeta, \r\n                    TransTestFactory.INJECTOR_STEPNAME, \r\n                    regexStepName, \r\n                    TransTestFactory.DUMMY_STEPNAME, \r\n                    createSourceData()\r\n                );\r\n        \r\n        checkRows(createResultData1(), result);\r\n    }","commit_id":"b9269da7630de142a3474db0ae530c588c3ff26c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\r\n\tpublic int compareTo (TextureDescriptor<T> o) {\r\n\t\tif (o == this) return 0;\r\n\t\tif (texture.glTarget != o.texture.glTarget)\r\n\t\t\treturn texture.glTarget - o.texture.glTarget;\r\n\t\tif (texture.getTextureObjectHandle() != o.texture.getTextureObjectHandle())\r\n\t\t\treturn texture.getTextureObjectHandle() - o.texture.getTextureObjectHandle();\r\n\t\tif (minFilter != o.minFilter) return minFilter.getGLEnum() - o.minFilter.getGLEnum();\r\n\t\tif (magFilter != o.magFilter) return magFilter.getGLEnum() - o.magFilter.getGLEnum();\r\n\t\tif (uWrap != o.uWrap) return uWrap.getGLEnum() - o.uWrap.getGLEnum();\r\n\t\tif (vWrap != o.vWrap) return vWrap.getGLEnum() - o.vWrap.getGLEnum();\r\n\t\treturn 0;\r\n\t}","id":49107,"modified_method":"@Override\r\n\tpublic int compareTo (TextureDescriptor<T> o) {\r\n\t\tif (o == this) return 0;\r\n\t\tint t1 = texture == null ? 0 : texture.glTarget;\r\n\t\tint t2 = o.texture == null ? 0 : o.texture.glTarget;\r\n\t\tif (t1 != t2) return t1 - t2;\r\n\t\tint h1 = texture == null ? 0 : texture.getTextureObjectHandle();\r\n\t\tint h2 = o.texture == null ? 0 : o.texture.getTextureObjectHandle();\r\n\t\tif (h1 != h2) return h1 - h2;\r\n\t\tif (minFilter != o.minFilter)\r\n\t\t\treturn (minFilter == null ? 0 : minFilter.getGLEnum()) - (o.minFilter == null ? 0 : o.minFilter.getGLEnum());\r\n\t\tif (magFilter != o.magFilter)\r\n\t\t\treturn (magFilter == null ? 0 : magFilter.getGLEnum()) - (o.magFilter == null ? 0 : o.magFilter.getGLEnum());\r\n\t\tif (uWrap != o.uWrap) return (uWrap == null ? 0 : uWrap.getGLEnum()) - (o.uWrap == null ? 0 : o.uWrap.getGLEnum());\r\n\t\tif (vWrap != o.vWrap) return (vWrap == null ? 0 : vWrap.getGLEnum()) - (o.vWrap == null ? 0 : o.vWrap.getGLEnum());\r\n\t\treturn 0;\r\n\t}","commit_id":"65596c84ceb067b19f4ba4a37c38e575c3a3d54f","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic int hashCode () {\r\n\t\tlong result = texture.glTarget;\r\n\t\tresult = 811 * result + texture.getTextureObjectHandle();\r\n\t\tresult = 811 * result + minFilter.getGLEnum();\r\n\t\tresult = 811 * result + magFilter.getGLEnum();\r\n\t\tresult = 811 * result + uWrap.getGLEnum();\r\n\t\tresult = 811 * result + vWrap.getGLEnum();\r\n\t\treturn (int)(result ^ (result >> 32));\r\n\t}","id":49108,"modified_method":"@Override\r\n\tpublic int hashCode () {\r\n\t\tlong result = (texture == null ? 0 : texture.glTarget);\r\n\t\tresult = 811 * result + (texture == null ? 0 : texture.getTextureObjectHandle());\r\n\t\tresult = 811 * result + (minFilter == null ? 0 : minFilter.getGLEnum());\r\n\t\tresult = 811 * result + (magFilter == null ? 0 : magFilter.getGLEnum());\r\n\t\tresult = 811 * result + (uWrap == null ? 0 : uWrap.getGLEnum());\r\n\t\tresult = 811 * result + (vWrap == null ? 0 : vWrap.getGLEnum());\r\n\t\treturn (int)(result ^ (result >> 32));\r\n\t}","commit_id":"65596c84ceb067b19f4ba4a37c38e575c3a3d54f","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n     * Check the arguments from the STSProvider and parse the request.\n     */\n    protected RequestParser parseRequest(\n        RequestSecurityTokenType request,\n        WebServiceContext context\n    ) {\n        if (context == null || context.getMessageContext() == null) {\n            throw new STSException(\"No message context found\");\n        }\n        \n        if (stsProperties == null) {\n            throw new STSException(\"No STSProperties object found\");\n        }\n        stsProperties.configureProperties();\n        \n        RequestParser requestParser = new RequestParser();\n        requestParser.parseRequest(request, context, stsProperties);\n        \n        return requestParser;\n    }","id":49109,"modified_method":"/**\n     * Check the arguments from the STSProvider and parse the request.\n     */\n    protected RequestParser parseRequest(\n        RequestSecurityTokenType request,\n        WebServiceContext context\n    ) {\n        if (context == null || context.getMessageContext() == null) {\n            throw new STSException(\"No message context found\");\n        }\n        \n        if (stsProperties == null) {\n            throw new STSException(\"No STSProperties object found\");\n        }\n        stsProperties.configureProperties();\n        \n        RequestParser requestParser = new RequestParser();\n        requestParser.parseRequest(request, context, stsProperties, claimsManager.getClaimParsers());\n        \n        return requestParser;\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"public ClaimCollection retrieveClaimValues(\n            RequestClaimCollection claims, ClaimsParameters parameters) {\n      \n        if (claims != null && claims.size() > 0) {\n            ClaimCollection claimCollection = new ClaimCollection();\n            for (RequestClaim requestClaim : claims) {\n                Claim claim = new Claim();\n                claim.setClaimType(requestClaim.getClaimType());\n                if (ClaimTypes.FIRSTNAME.equals(requestClaim.getClaimType())) {\n                    claim.setValue(\"alice\");\n                } else if (ClaimTypes.LASTNAME.equals(requestClaim.getClaimType())) {\n                    claim.setValue(\"doe\");\n                } else if (ClaimTypes.EMAILADDRESS.equals(requestClaim.getClaimType())) {\n                    claim.setValue(\"alice@cxf.apache.org\");\n                }\n                claimCollection.add(claim);\n            }\n            return claimCollection;\n        }\n        \n        return null;\n    }","id":49110,"modified_method":"public ClaimCollection retrieveClaimValues(\n            RequestClaimCollection claims, ClaimsParameters parameters) {\n      \n        if (claims != null && claims.size() > 0) {\n            ClaimCollection claimCollection = new ClaimCollection();\n            for (RequestClaim requestClaim : claims) {\n                Claim claim = new Claim();\n                claim.setClaimType(requestClaim.getClaimType());\n                if (ClaimTypes.FIRSTNAME.equals(requestClaim.getClaimType())) {\n                    if (requestClaim instanceof CustomRequestClaim) {\n                        CustomRequestClaim customClaim = (CustomRequestClaim) requestClaim;\n                        String customName = customClaim.getClaimValue() + \"@\" + customClaim.getScope();\n                        claim.setValue(customName);\n                    } else {\n                        claim.setValue(\"alice\");\n                    }\n                } else if (ClaimTypes.LASTNAME.equals(requestClaim.getClaimType())) {\n                    claim.setValue(\"doe\");\n                } else if (ClaimTypes.EMAILADDRESS.equals(requestClaim.getClaimType())) {\n                    claim.setValue(\"alice@cxf.apache.org\");\n                } else if (ROLE_CLAIM.equals(requestClaim.getClaimType())) {\n                    String requestedRole = requestClaim.getClaimValue();\n                    if (isUserInRole(parameters.getPrincipal(), requestedRole)) {\n                        claim.setValue(requestedRole);\n                    } else {\n                        continue;\n                    }\n                }                \n                claimCollection.add(claim);\n            }\n            return claimCollection;\n        }\n        \n        return null;\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"private Element createSecondaryParameters() {\n        Document doc = DOMUtils.createDocument();\n        Element secondary = doc.createElementNS(STSConstants.WST_NS_05_12, \"SecondaryParameters\");\n        secondary.setAttributeNS(WSConstants.XMLNS_NS, \"xmlns\", STSConstants.WST_NS_05_12);\n        \n        Element claims = doc.createElementNS(STSConstants.WST_NS_05_12, \"Claims\");\n        claims.setAttributeNS(null, \"Dialect\", STSConstants.IDT_NS_05_05);\n        \n        Element claimType = createClaimsType(doc);\n        \n        claims.appendChild(claimType);\n        secondary.appendChild(claims);\n\n        return secondary;\n    }","id":49111,"modified_method":"private Element createSecondaryParameters() {\n        Document doc = DOMUtils.createDocument();\n        Element secondary = doc.createElementNS(STSConstants.WST_NS_05_12, \"SecondaryParameters\");\n        secondary.setAttributeNS(WSConstants.XMLNS_NS, \"xmlns\", STSConstants.WST_NS_05_12);\n        \n        Element claims = doc.createElementNS(STSConstants.WST_NS_05_12, \"Claims\");\n        claims.setAttributeNS(null, \"Dialect\", STSConstants.IDT_NS_05_05);\n        \n        Element claimType = createClaimsType(doc);\n        claims.appendChild(claimType);\n        Element claimValue = createClaimValue(doc);\n        claims.appendChild(claimValue);\n        secondary.appendChild(claims);\n\n        return secondary;\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Test to successfully issue a Saml 2 token.\n     */\n    @org.junit.Test\n    public void testIssueSaml2Token() throws Exception {\n        TokenIssueOperation issueOperation = new TokenIssueOperation();\n        \n        // Add Token Provider\n        List<TokenProvider> providerList = new ArrayList<TokenProvider>();\n        \n        List<AttributeStatementProvider> customProviderList = \n            new ArrayList<AttributeStatementProvider>();\n        customProviderList.add(new CustomAttributeProvider());\n        SAMLTokenProvider samlTokenProvider = new SAMLTokenProvider();\n        samlTokenProvider.setAttributeStatementProviders(customProviderList);\n        providerList.add(samlTokenProvider);\n        issueOperation.setTokenProviders(providerList);\n        \n        // Add Service\n        ServiceMBean service = new StaticService();\n        service.setEndpoints(Collections.singletonList(\"http://dummy-service.com/dummy\"));\n        issueOperation.setServices(Collections.singletonList(service));\n        \n        // Add STSProperties object\n        STSPropertiesMBean stsProperties = new StaticSTSProperties();\n        Crypto crypto = CryptoFactory.getInstance(getEncryptionProperties());\n        stsProperties.setEncryptionCrypto(crypto);\n        stsProperties.setSignatureCrypto(crypto);\n        stsProperties.setEncryptionUsername(\"myservicekey\");\n        stsProperties.setSignatureUsername(\"mystskey\");\n        stsProperties.setCallbackHandler(new PasswordCallbackHandler());\n        stsProperties.setIssuer(\"STS\");\n        issueOperation.setStsProperties(stsProperties);\n        \n        // Set the ClaimsManager\n        ClaimsManager claimsManager = new ClaimsManager();\n        ClaimsHandler claimsHandler = new CustomClaimsHandler();\n        claimsManager.setClaimHandlers(Collections.singletonList(claimsHandler));\n        issueOperation.setClaimsManager(claimsManager);\n        \n        // Mock up a request\n        RequestSecurityTokenType request = new RequestSecurityTokenType();\n        JAXBElement<String> tokenType = \n            new JAXBElement<String>(\n                QNameConstants.TOKEN_TYPE, String.class, WSConstants.WSS_SAML2_TOKEN_TYPE\n            );\n        request.getAny().add(tokenType);\n        Element secondaryParameters = createSecondaryParameters();\n        request.getAny().add(secondaryParameters);\n        request.getAny().add(createAppliesToElement(\"http://dummy-service.com/dummy\"));\n        \n        // Mock up message context\n        MessageImpl msg = new MessageImpl();\n        WrappedMessageContext msgCtx = new WrappedMessageContext(msg);\n        msgCtx.put(\n            SecurityContext.class.getName(), \n            createSecurityContext(new CustomTokenPrincipal(\"alice\"))\n        );\n        WebServiceContextImpl webServiceContext = new WebServiceContextImpl(msgCtx);\n        \n        // Issue a token\n        RequestSecurityTokenResponseCollectionType response = \n            issueOperation.issue(request, webServiceContext);\n        List<RequestSecurityTokenResponseType> securityTokenResponse = \n            response.getRequestSecurityTokenResponse();\n        assertTrue(!securityTokenResponse.isEmpty());\n        \n        // Test the generated token.\n        Element assertion = null;\n        for (Object tokenObject : securityTokenResponse.get(0).getAny()) {\n            if (tokenObject instanceof JAXBElement<?>\n                && REQUESTED_SECURITY_TOKEN.equals(((JAXBElement<?>)tokenObject).getName())) {\n                RequestedSecurityTokenType rstType = \n                    (RequestedSecurityTokenType)((JAXBElement<?>)tokenObject).getValue();\n                assertion = (Element)rstType.getAny();\n                break;\n            }\n        }\n        \n        assertNotNull(assertion);\n        String tokenString = DOM2Writer.nodeToString(assertion);\n        assertTrue(tokenString.contains(\"AttributeStatement\"));\n        assertTrue(tokenString.contains(\"alice\"));\n        assertTrue(tokenString.contains(SAML2Constants.CONF_BEARER));\n        assertTrue(tokenString.contains(ClaimTypes.LASTNAME.toString()));\n    }","id":49112,"modified_method":"/**\n     * Test to successfully issue a Saml 2 token.\n     */\n    @org.junit.Test\n    public void testIssueSaml2Token() throws Exception {\n        TokenIssueOperation issueOperation = new TokenIssueOperation();\n        \n        // Add Token Provider\n        addTokenProvider(issueOperation);\n        \n        // Add Service\n        addService(issueOperation);\n        \n        // Add STSProperties object\n        addSTSProperties(issueOperation);\n        \n        // Set the ClaimsManager\n        ClaimsManager claimsManager = new ClaimsManager();\n        ClaimsHandler claimsHandler = new CustomClaimsHandler();\n        claimsManager.setClaimHandlers(Collections.singletonList(claimsHandler));\n        issueOperation.setClaimsManager(claimsManager);\n        \n        // Mock up a request\n        RequestSecurityTokenType request = new RequestSecurityTokenType();\n        JAXBElement<String> tokenType = \n            new JAXBElement<String>(\n                QNameConstants.TOKEN_TYPE, String.class, WSConstants.WSS_SAML2_TOKEN_TYPE\n            );\n        request.getAny().add(tokenType);\n        Element secondaryParameters = createSecondaryParameters();\n        request.getAny().add(secondaryParameters);\n        request.getAny().add(createAppliesToElement(\"http://dummy-service.com/dummy\"));\n        \n        WebServiceContextImpl webServiceContext = setupMessageContext();\n        \n        List<RequestSecurityTokenResponseType> securityTokenResponse = issueToken(issueOperation, request,\n                webServiceContext);\n        \n        // Test the generated token.\n        Element assertion = null;\n        for (Object tokenObject : securityTokenResponse.get(0).getAny()) {\n            if (tokenObject instanceof JAXBElement<?>\n                && REQUESTED_SECURITY_TOKEN.equals(((JAXBElement<?>)tokenObject).getName())) {\n                RequestedSecurityTokenType rstType = \n                    (RequestedSecurityTokenType)((JAXBElement<?>)tokenObject).getValue();\n                assertion = (Element)rstType.getAny();\n                break;\n            }\n        }\n        \n        assertNotNull(assertion);\n        String tokenString = DOM2Writer.nodeToString(assertion);\n        assertTrue(tokenString.contains(\"AttributeStatement\"));\n        assertTrue(tokenString.contains(\"alice\"));\n        assertTrue(tokenString.contains(SAML2Constants.CONF_BEARER));\n        assertTrue(tokenString.contains(ClaimTypes.LASTNAME.toString()));\n        assertTrue(tokenString.contains(ROLE_CLAIM.toString()));\n        assertTrue(tokenString.contains(\"administrator\"));\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Test to successfully issue a SAML 2 token (realm \"B\") on-behalf-of a SAML 2 token\n     * which was issued by realm \"A\".\n     * The relationship type between realm A and B is: FederateClaims\n     */\n    @org.junit.Test\n    public void testIssueSaml2TokenOnBehalfOfSaml2DifferentRealmFederateClaims() throws Exception {\n        TokenIssueOperation issueOperation = new TokenIssueOperation();\n        \n        Map<String, SAMLRealm> realms = createSamlRealms();\n        \n        // Add Token Provider\n        List<TokenProvider> providerList = new ArrayList<TokenProvider>();\n        SAMLTokenProvider samlTokenProvider = new SAMLTokenProvider();\n        samlTokenProvider.setRealmMap(realms);\n        List<AttributeStatementProvider> customProviderList = \n            new ArrayList<AttributeStatementProvider>();\n        customProviderList.add(new ClaimsAttributeStatementProvider());\n        samlTokenProvider.setAttributeStatementProviders(customProviderList);\n        providerList.add(samlTokenProvider);\n        issueOperation.setTokenProviders(providerList);\n        \n        // Add Token Validator\n        List<TokenValidator> validatorList = new ArrayList<TokenValidator>();\n        SAMLTokenValidator samlTokenValidator = new SAMLTokenValidator();\n        samlTokenValidator.setSamlRealmCodec(new IssuerSAMLRealmCodec());\n        validatorList.add(samlTokenValidator);\n        issueOperation.setTokenValidators(validatorList);\n\n        // Add Service\n        ServiceMBean service = new StaticService();\n        service.setEndpoints(Collections.singletonList(\"http://dummy-service.com/dummy\"));\n        issueOperation.setServices(Collections.singletonList(service));\n        \n        // Add Relationship list\n        List<Relationship> relationshipList = new ArrayList<Relationship>();\n        Relationship rs = createRelationship();\n        relationshipList.add(rs);\n        \n        // Add STSProperties object\n        Crypto crypto = CryptoFactory.getInstance(getEncryptionProperties());\n        STSPropertiesMBean stsProperties = createSTSPropertiesMBean(crypto);\n        stsProperties.setRealmParser(new CustomRealmParser());\n        stsProperties.setIdentityMapper(new CustomIdentityMapper());\n        stsProperties.setRelationships(relationshipList);\n        issueOperation.setStsProperties(stsProperties);\n        \n        // Set the ClaimsManager\n        ClaimsManager claimsManager = new ClaimsManager();\n        ClaimsHandler claimsHandler = new CustomClaimsHandler();\n        claimsManager.setClaimHandlers(Collections.singletonList(claimsHandler));\n        issueOperation.setClaimsManager(claimsManager);\n        \n        // Mock up a request\n        RequestSecurityTokenType request = new RequestSecurityTokenType();\n        JAXBElement<String> tokenType = \n            new JAXBElement<String>(\n                QNameConstants.TOKEN_TYPE, String.class, WSConstants.WSS_SAML2_TOKEN_TYPE\n            );\n        request.getAny().add(tokenType);\n        \n        // Add a ClaimsType\n        ClaimsType claimsType = new ClaimsType();\n        claimsType.setDialect(STSConstants.IDT_NS_05_05);\n        \n        Document doc = DOMUtils.createDocument();\n        Element claimType = createClaimsType(doc);\n        claimsType.getAny().add(claimType);\n        \n        JAXBElement<ClaimsType> claimsTypeJaxb = \n            new JAXBElement<ClaimsType>(\n                QNameConstants.CLAIMS, ClaimsType.class, claimsType\n            );\n        request.getAny().add(claimsTypeJaxb);\n        \n        //request.getAny().add(createAppliesToElement(\"http://dummy-service.com/dummy\"));\n        \n        // create a SAML Token via the SAMLTokenProvider which contains claims\n        CallbackHandler callbackHandler = new PasswordCallbackHandler();\n        Element samlToken = \n            createSAMLAssertion(WSConstants.WSS_SAML2_TOKEN_TYPE, crypto, \"mystskey\",\n                    callbackHandler, realms);\n        Document docToken = samlToken.getOwnerDocument();\n        samlToken = (Element)docToken.appendChild(samlToken);\n        String samlString = DOM2Writer.nodeToString(samlToken);\n        assertTrue(samlString.contains(\"AttributeStatement\"));\n        assertTrue(samlString.contains(\"alice\"));\n        assertTrue(samlString.contains(\"doe\"));\n        assertTrue(samlString.contains(SAML2Constants.CONF_BEARER));\n        \n        // add SAML token as On-Behalf-Of element\n        OnBehalfOfType onbehalfof = new OnBehalfOfType();\n        onbehalfof.setAny(samlToken);\n        JAXBElement<OnBehalfOfType> onbehalfofType = \n            new JAXBElement<OnBehalfOfType>(\n                    QNameConstants.ON_BEHALF_OF, OnBehalfOfType.class, onbehalfof\n            );\n        request.getAny().add(onbehalfofType);\n        \n        // Mock up message context\n        MessageImpl msg = new MessageImpl();\n        WrappedMessageContext msgCtx = new WrappedMessageContext(msg);\n        msgCtx.put(\"url\", \"https\");\n        WebServiceContextImpl webServiceContext = new WebServiceContextImpl(msgCtx);\n        \n        // run the test\n        RequestSecurityTokenResponseCollectionType response = \n            issueOperation.issue(request, webServiceContext);\n        List<RequestSecurityTokenResponseType> securityTokenResponseList = \n            response.getRequestSecurityTokenResponse();\n\n        assertTrue(!securityTokenResponseList.isEmpty());       \n        RequestSecurityTokenResponseType securityTokenResponse = securityTokenResponseList.get(0);\n        \n        // Test the generated token.\n        Element assertion = null;\n        for (Object tokenObject : securityTokenResponse.getAny()) {\n            if (tokenObject instanceof JAXBElement<?>\n                && REQUESTED_SECURITY_TOKEN.equals(((JAXBElement<?>)tokenObject).getName())) {\n                RequestedSecurityTokenType rstType = \n                    (RequestedSecurityTokenType)((JAXBElement<?>)tokenObject).getValue();\n                assertion = (Element)rstType.getAny();\n                break;\n            }\n        }\n        \n        assertNotNull(assertion);\n        String tokenString = DOM2Writer.nodeToString(assertion);\n        assertTrue(tokenString.contains(\"AttributeStatement\"));\n        assertTrue(tokenString.contains(\"alice\"));  //subject unchanged\n        assertTrue(tokenString.contains(\"DOE\")); //transformed claim (to uppercase)\n        assertTrue(tokenString.contains(SAML2Constants.CONF_BEARER));\n    }","id":49113,"modified_method":"/**\n     * Test to successfully issue a SAML 2 token (realm \"B\") on-behalf-of a SAML 2 token\n     * which was issued by realm \"A\".\n     * The relationship type between realm A and B is: FederateClaims\n     */\n    @org.junit.Test\n    public void testIssueSaml2TokenOnBehalfOfSaml2DifferentRealmFederateClaims() \n        throws Exception {\n        TokenIssueOperation issueOperation = new TokenIssueOperation();\n        \n        Map<String, SAMLRealm> realms = createSamlRealms();\n        \n        // Add Token Provider\n        List<TokenProvider> providerList = new ArrayList<TokenProvider>();\n        SAMLTokenProvider samlTokenProvider = new SAMLTokenProvider();\n        samlTokenProvider.setRealmMap(realms);\n        List<AttributeStatementProvider> customProviderList = \n            new ArrayList<AttributeStatementProvider>();\n        customProviderList.add(new ClaimsAttributeStatementProvider());\n        samlTokenProvider.setAttributeStatementProviders(customProviderList);\n        providerList.add(samlTokenProvider);\n        issueOperation.setTokenProviders(providerList);\n        \n        // Add Token Validator\n        List<TokenValidator> validatorList = new ArrayList<TokenValidator>();\n        SAMLTokenValidator samlTokenValidator = new SAMLTokenValidator();\n        samlTokenValidator.setSamlRealmCodec(new IssuerSAMLRealmCodec());\n        validatorList.add(samlTokenValidator);\n        issueOperation.setTokenValidators(validatorList);\n\n        addService(issueOperation);\n        \n        // Add Relationship list\n        List<Relationship> relationshipList = new ArrayList<Relationship>();\n        Relationship rs = createRelationship();\n        relationshipList.add(rs);\n        \n        // Add STSProperties object\n        Crypto crypto = CryptoFactory.getInstance(getEncryptionProperties());\n        STSPropertiesMBean stsProperties = createSTSPropertiesMBean(crypto);\n        stsProperties.setRealmParser(new CustomRealmParser());\n        stsProperties.setIdentityMapper(new CustomIdentityMapper());\n        stsProperties.setRelationships(relationshipList);\n        issueOperation.setStsProperties(stsProperties);\n        \n        // Set the ClaimsManager\n        ClaimsManager claimsManager = new ClaimsManager();\n        ClaimsHandler claimsHandler = new CustomClaimsHandler();\n        claimsManager.setClaimHandlers(Collections.singletonList(claimsHandler));\n        issueOperation.setClaimsManager(claimsManager);\n        \n        // Mock up a request\n        RequestSecurityTokenType request = new RequestSecurityTokenType();\n        JAXBElement<String> tokenType = \n            new JAXBElement<String>(\n                QNameConstants.TOKEN_TYPE, String.class, WSConstants.WSS_SAML2_TOKEN_TYPE\n            );\n        request.getAny().add(tokenType);\n        \n        // Add a ClaimsType\n        ClaimsType claimsType = new ClaimsType();\n        claimsType.setDialect(STSConstants.IDT_NS_05_05);\n        \n        Document doc = DOMUtils.createDocument();\n        Element claimType = createClaimsType(doc);\n        claimsType.getAny().add(claimType);\n        \n        JAXBElement<ClaimsType> claimsTypeJaxb = \n            new JAXBElement<ClaimsType>(\n                QNameConstants.CLAIMS, ClaimsType.class, claimsType\n            );\n        request.getAny().add(claimsTypeJaxb);\n        \n        //request.getAny().add(createAppliesToElement(\"http://dummy-service.com/dummy\"));\n        \n        // create a SAML Token via the SAMLTokenProvider which contains claims\n        CallbackHandler callbackHandler = new PasswordCallbackHandler();\n        Element samlToken = \n            createSAMLAssertion(WSConstants.WSS_SAML2_TOKEN_TYPE, crypto, \"mystskey\",\n                    callbackHandler, realms);\n        Document docToken = samlToken.getOwnerDocument();\n        samlToken = (Element)docToken.appendChild(samlToken);\n        String samlString = DOM2Writer.nodeToString(samlToken);\n        assertTrue(samlString.contains(\"AttributeStatement\"));\n        assertTrue(samlString.contains(\"alice\"));\n        assertTrue(samlString.contains(\"doe\"));\n        assertTrue(samlString.contains(SAML2Constants.CONF_BEARER));\n        \n        // add SAML token as On-Behalf-Of element\n        OnBehalfOfType onbehalfof = new OnBehalfOfType();\n        onbehalfof.setAny(samlToken);\n        JAXBElement<OnBehalfOfType> onbehalfofType = \n            new JAXBElement<OnBehalfOfType>(\n                    QNameConstants.ON_BEHALF_OF, OnBehalfOfType.class, onbehalfof\n            );\n        request.getAny().add(onbehalfofType);\n        \n        // Mock up message context\n        MessageImpl msg = new MessageImpl();\n        WrappedMessageContext msgCtx = new WrappedMessageContext(msg);\n        msgCtx.put(\"url\", \"https\");\n        WebServiceContextImpl webServiceContext = new WebServiceContextImpl(msgCtx);\n        \n        List<RequestSecurityTokenResponseType> securityTokenResponseList = issueToken(issueOperation,\n                request, webServiceContext);       \n        RequestSecurityTokenResponseType securityTokenResponse = securityTokenResponseList.get(0);\n        \n        // Test the generated token.\n        Element assertion = null;\n        for (Object tokenObject : securityTokenResponse.getAny()) {\n            if (tokenObject instanceof JAXBElement<?>\n                && REQUESTED_SECURITY_TOKEN.equals(((JAXBElement<?>)tokenObject).getName())) {\n                RequestedSecurityTokenType rstType = \n                    (RequestedSecurityTokenType)((JAXBElement<?>)tokenObject).getValue();\n                assertion = (Element)rstType.getAny();\n                break;\n            }\n        }\n        assertNotNull(assertion);\n        String tokenString = DOM2Writer.nodeToString(assertion);\n        assertTrue(tokenString.contains(\"AttributeStatement\"));\n        assertTrue(tokenString.contains(\"alice\"));  //subject unchanged\n        assertTrue(tokenString.contains(\"DOE\")); //transformed claim (to uppercase)\n        assertTrue(tokenString.contains(SAML2Constants.CONF_BEARER));\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"private void runIssueSaml2TokenOnBehalfOfSaml2DifferentRealmFederateIdentity(\n            boolean useGlobalIdentityMapper) throws WSSecurityException {\n        TokenIssueOperation issueOperation = new TokenIssueOperation();\n        \n        Map<String, SAMLRealm> realms = createSamlRealms();\n        \n        // Add Token Provider\n        List<TokenProvider> providerList = new ArrayList<TokenProvider>();\n        SAMLTokenProvider samlTokenProvider = new SAMLTokenProvider();\n        samlTokenProvider.setRealmMap(realms);\n        List<AttributeStatementProvider> customProviderList = \n            new ArrayList<AttributeStatementProvider>();\n        customProviderList.add(new ClaimsAttributeStatementProvider());\n        samlTokenProvider.setAttributeStatementProviders(customProviderList);\n        providerList.add(samlTokenProvider);\n        issueOperation.setTokenProviders(providerList);\n        \n        // Add Token Validator\n        List<TokenValidator> validatorList = new ArrayList<TokenValidator>();\n        SAMLTokenValidator samlTokenValidator = new SAMLTokenValidator();\n        samlTokenValidator.setSamlRealmCodec(new IssuerSAMLRealmCodec());\n        validatorList.add(samlTokenValidator);\n        issueOperation.setTokenValidators(validatorList);\n\n        // Add Service\n        ServiceMBean service = new StaticService();\n        service.setEndpoints(Collections.singletonList(\"http://dummy-service.com/dummy\"));\n        issueOperation.setServices(Collections.singletonList(service));\n        \n        // Add Relationship list\n        List<Relationship> relationshipList = new ArrayList<Relationship>();\n        Relationship rs = createRelationship();\n        rs.setType(Relationship.FED_TYPE_IDENTITY);\n        rs.setIdentityMapper(new CustomIdentityMapper());\n        relationshipList.add(rs);\n        \n        // Add STSProperties object\n        Crypto crypto = CryptoFactory.getInstance(getEncryptionProperties());\n        STSPropertiesMBean stsProperties = createSTSPropertiesMBean(crypto);\n        stsProperties.setRealmParser(new CustomRealmParser());\n        \n        if (useGlobalIdentityMapper) {\n            stsProperties.setIdentityMapper(new CustomIdentityMapper());\n        } else { \n            stsProperties.setRelationships(relationshipList);\n        }  \n\n        issueOperation.setStsProperties(stsProperties);\n        \n        // Set the ClaimsManager\n        ClaimsManager claimsManager = new ClaimsManager();\n        claimsManager.setClaimHandlers(Collections.singletonList((ClaimsHandler)new CustomClaimsHandler()));\n        issueOperation.setClaimsManager(claimsManager);\n        \n        // Mock up a request\n        RequestSecurityTokenType request = new RequestSecurityTokenType();\n        JAXBElement<String> tokenType = \n            new JAXBElement<String>(\n                QNameConstants.TOKEN_TYPE, String.class, WSConstants.WSS_SAML2_TOKEN_TYPE\n            );\n        request.getAny().add(tokenType);\n        \n        // Add a ClaimsType\n        ClaimsType claimsType = new ClaimsType();\n        claimsType.setDialect(STSConstants.IDT_NS_05_05);\n        \n        Document doc = DOMUtils.createDocument();\n        Element claimType = createClaimsType(doc);\n        claimsType.getAny().add(claimType);\n        \n        JAXBElement<ClaimsType> claimsTypeJaxb = \n            new JAXBElement<ClaimsType>(\n                QNameConstants.CLAIMS, ClaimsType.class, claimsType\n            );\n        request.getAny().add(claimsTypeJaxb);\n        \n        //request.getAny().add(createAppliesToElement(\"http://dummy-service.com/dummy\"));\n        \n        // create a SAML Token via the SAMLTokenProvider which contains claims\n        CallbackHandler callbackHandler = new PasswordCallbackHandler();\n        Element samlToken = \n            createSAMLAssertion(WSConstants.WSS_SAML2_TOKEN_TYPE, crypto, \"mystskey\",\n                    callbackHandler, realms);\n        Document docToken = samlToken.getOwnerDocument();\n        samlToken = (Element)docToken.appendChild(samlToken);\n        String samlString = DOM2Writer.nodeToString(samlToken);\n        assertTrue(samlString.contains(\"AttributeStatement\"));\n        assertTrue(samlString.contains(\"alice\"));\n        assertTrue(samlString.contains(\"doe\"));\n        assertTrue(samlString.contains(SAML2Constants.CONF_BEARER));\n        \n        // add SAML token as On-Behalf-Of element\n        OnBehalfOfType onbehalfof = new OnBehalfOfType();\n        onbehalfof.setAny(samlToken);\n        JAXBElement<OnBehalfOfType> onbehalfofType = \n            new JAXBElement<OnBehalfOfType>(\n                    QNameConstants.ON_BEHALF_OF, OnBehalfOfType.class, onbehalfof\n            );\n        request.getAny().add(onbehalfofType);\n        \n        // Mock up message context\n        MessageImpl msg = new MessageImpl();\n        WrappedMessageContext msgCtx = new WrappedMessageContext(msg);\n        msgCtx.put(\"url\", \"https\");\n        WebServiceContextImpl webServiceContext = new WebServiceContextImpl(msgCtx);\n        \n        // run the test\n        RequestSecurityTokenResponseCollectionType response = \n            issueOperation.issue(request, webServiceContext);\n        List<RequestSecurityTokenResponseType> securityTokenResponseList = \n            response.getRequestSecurityTokenResponse();\n\n        assertTrue(!securityTokenResponseList.isEmpty());       \n        RequestSecurityTokenResponseType securityTokenResponse = securityTokenResponseList.get(0);\n        \n        // Test the generated token.\n        Element assertion = null;\n        for (Object tokenObject : securityTokenResponse.getAny()) {\n            if (tokenObject instanceof JAXBElement<?>\n                && REQUESTED_SECURITY_TOKEN.equals(((JAXBElement<?>)tokenObject).getName())) {\n                RequestedSecurityTokenType rstType = \n                    (RequestedSecurityTokenType)((JAXBElement<?>)tokenObject).getValue();\n                assertion = (Element)rstType.getAny();\n                break;\n            }\n        }\n        \n        assertNotNull(assertion);\n        String tokenString = DOM2Writer.nodeToString(assertion);\n        assertTrue(tokenString.contains(\"AttributeStatement\"));\n        assertTrue(tokenString.contains(\"ALICE\"));  //subject changed (to uppercase)\n        assertTrue(tokenString.contains(\"doe\"));  //claim unchanged but requested\n        assertTrue(tokenString.contains(SAML2Constants.CONF_BEARER));\n    }","id":49114,"modified_method":"private void runIssueSaml2TokenOnBehalfOfSaml2DifferentRealmFederateIdentity(\n            boolean useGlobalIdentityMapper) throws WSSecurityException {\n        TokenIssueOperation issueOperation = new TokenIssueOperation();\n        \n        Map<String, SAMLRealm> realms = createSamlRealms();\n        \n        // Add Token Provider\n        List<TokenProvider> providerList = new ArrayList<TokenProvider>();\n        SAMLTokenProvider samlTokenProvider = new SAMLTokenProvider();\n        samlTokenProvider.setRealmMap(realms);\n        List<AttributeStatementProvider> customProviderList = \n            new ArrayList<AttributeStatementProvider>();\n        customProviderList.add(new ClaimsAttributeStatementProvider());\n        samlTokenProvider.setAttributeStatementProviders(customProviderList);\n        providerList.add(samlTokenProvider);\n        issueOperation.setTokenProviders(providerList);\n        \n        // Add Token Validator\n        List<TokenValidator> validatorList = new ArrayList<TokenValidator>();\n        SAMLTokenValidator samlTokenValidator = new SAMLTokenValidator();\n        samlTokenValidator.setSamlRealmCodec(new IssuerSAMLRealmCodec());\n        validatorList.add(samlTokenValidator);\n        issueOperation.setTokenValidators(validatorList);\n\n        addService(issueOperation);\n        \n        // Add Relationship list\n        List<Relationship> relationshipList = new ArrayList<Relationship>();\n        Relationship rs = createRelationship();\n        rs.setType(Relationship.FED_TYPE_IDENTITY);\n        rs.setIdentityMapper(new CustomIdentityMapper());\n        relationshipList.add(rs);\n        \n        // Add STSProperties object\n        Crypto crypto = CryptoFactory.getInstance(getEncryptionProperties());\n        STSPropertiesMBean stsProperties = createSTSPropertiesMBean(crypto);\n        stsProperties.setRealmParser(new CustomRealmParser());\n        \n        if (useGlobalIdentityMapper) {\n            stsProperties.setIdentityMapper(new CustomIdentityMapper());\n        } else { \n            stsProperties.setRelationships(relationshipList);\n        }  \n\n        issueOperation.setStsProperties(stsProperties);\n        \n        // Set the ClaimsManager\n        ClaimsManager claimsManager = new ClaimsManager();\n        claimsManager.setClaimHandlers(Collections.singletonList((ClaimsHandler)new CustomClaimsHandler()));\n        issueOperation.setClaimsManager(claimsManager);\n        \n        // Mock up a request\n        RequestSecurityTokenType request = new RequestSecurityTokenType();\n        JAXBElement<String> tokenType = \n            new JAXBElement<String>(\n                QNameConstants.TOKEN_TYPE, String.class, WSConstants.WSS_SAML2_TOKEN_TYPE\n            );\n        request.getAny().add(tokenType);\n        \n        // Add a ClaimsType\n        ClaimsType claimsType = new ClaimsType();\n        claimsType.setDialect(STSConstants.IDT_NS_05_05);\n        \n        Document doc = DOMUtils.createDocument();\n        Element claimType = createClaimsType(doc);\n        claimsType.getAny().add(claimType);\n        \n        JAXBElement<ClaimsType> claimsTypeJaxb = \n            new JAXBElement<ClaimsType>(\n                QNameConstants.CLAIMS, ClaimsType.class, claimsType\n            );\n        request.getAny().add(claimsTypeJaxb);\n        \n        //request.getAny().add(createAppliesToElement(\"http://dummy-service.com/dummy\"));\n        \n        // create a SAML Token via the SAMLTokenProvider which contains claims\n        CallbackHandler callbackHandler = new PasswordCallbackHandler();\n        Element samlToken = \n            createSAMLAssertion(WSConstants.WSS_SAML2_TOKEN_TYPE, crypto, \"mystskey\",\n                    callbackHandler, realms);\n        Document docToken = samlToken.getOwnerDocument();\n        samlToken = (Element)docToken.appendChild(samlToken);\n        String samlString = DOM2Writer.nodeToString(samlToken);\n        assertTrue(samlString.contains(\"AttributeStatement\"));\n        assertTrue(samlString.contains(\"alice\"));\n        assertTrue(samlString.contains(\"doe\"));\n        assertTrue(samlString.contains(SAML2Constants.CONF_BEARER));\n        \n        // add SAML token as On-Behalf-Of element\n        OnBehalfOfType onbehalfof = new OnBehalfOfType();\n        onbehalfof.setAny(samlToken);\n        JAXBElement<OnBehalfOfType> onbehalfofType = \n            new JAXBElement<OnBehalfOfType>(\n                    QNameConstants.ON_BEHALF_OF, OnBehalfOfType.class, onbehalfof\n            );\n        request.getAny().add(onbehalfofType);\n        \n        // Mock up message context\n        MessageImpl msg = new MessageImpl();\n        WrappedMessageContext msgCtx = new WrappedMessageContext(msg);\n        msgCtx.put(\"url\", \"https\");\n        WebServiceContextImpl webServiceContext = new WebServiceContextImpl(msgCtx);\n        \n        List<RequestSecurityTokenResponseType> securityTokenResponseList = issueToken(issueOperation,\n                request, webServiceContext);       \n        RequestSecurityTokenResponseType securityTokenResponse = securityTokenResponseList.get(0);\n        \n        // Test the generated token.\n        Element assertion = null;\n        for (Object tokenObject : securityTokenResponse.getAny()) {\n            if (tokenObject instanceof JAXBElement<?>\n                && REQUESTED_SECURITY_TOKEN.equals(((JAXBElement<?>)tokenObject).getName())) {\n                RequestedSecurityTokenType rstType = \n                    (RequestedSecurityTokenType)((JAXBElement<?>)tokenObject).getValue();\n                assertion = (Element)rstType.getAny();\n                break;\n            }\n        }\n        \n        assertNotNull(assertion);\n        String tokenString = DOM2Writer.nodeToString(assertion);\n        assertTrue(tokenString.contains(\"AttributeStatement\"));\n        assertTrue(tokenString.contains(\"ALICE\"));  //subject changed (to uppercase)\n        assertTrue(tokenString.contains(\"doe\"));  //claim unchanged but requested\n        assertTrue(tokenString.contains(SAML2Constants.CONF_BEARER));\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Test to successfully issue a Saml 1.1 token. The claims information is included as a \n     * JAXB Element under RequestSecurityToken, rather than as a child of SecondaryParameters.\n     */\n    @org.junit.Test\n    public void testIssueJaxbSaml1Token() throws Exception {\n        TokenIssueOperation issueOperation = new TokenIssueOperation();\n        \n        // Add Token Provider\n        List<TokenProvider> providerList = new ArrayList<TokenProvider>();\n        \n        List<AttributeStatementProvider> customProviderList = \n            new ArrayList<AttributeStatementProvider>();\n        customProviderList.add(new CustomAttributeProvider());\n        SAMLTokenProvider samlTokenProvider = new SAMLTokenProvider();\n        samlTokenProvider.setAttributeStatementProviders(customProviderList);\n        providerList.add(samlTokenProvider);\n        issueOperation.setTokenProviders(providerList);\n        \n        // Add Service\n        ServiceMBean service = new StaticService();\n        service.setEndpoints(Collections.singletonList(\"http://dummy-service.com/dummy\"));\n        issueOperation.setServices(Collections.singletonList(service));\n        \n        // Add STSProperties object\n        STSPropertiesMBean stsProperties = new StaticSTSProperties();\n        Crypto crypto = CryptoFactory.getInstance(getEncryptionProperties());\n        stsProperties.setEncryptionCrypto(crypto);\n        stsProperties.setSignatureCrypto(crypto);\n        stsProperties.setEncryptionUsername(\"myservicekey\");\n        stsProperties.setSignatureUsername(\"mystskey\");\n        stsProperties.setCallbackHandler(new PasswordCallbackHandler());\n        stsProperties.setIssuer(\"STS\");\n        issueOperation.setStsProperties(stsProperties);\n        \n        // Set the ClaimsManager\n        ClaimsManager claimsManager = new ClaimsManager();\n        ClaimsHandler claimsHandler = new CustomClaimsHandler();\n        claimsManager.setClaimHandlers(Collections.singletonList(claimsHandler));\n        issueOperation.setClaimsManager(claimsManager);\n        \n        // Mock up a request\n        RequestSecurityTokenType request = new RequestSecurityTokenType();\n        JAXBElement<String> tokenType = \n            new JAXBElement<String>(\n                QNameConstants.TOKEN_TYPE, String.class, WSConstants.WSS_SAML_TOKEN_TYPE\n            );\n        request.getAny().add(tokenType);\n        \n        // Add a ClaimsType\n        ClaimsType claimsType = new ClaimsType();\n        claimsType.setDialect(STSConstants.IDT_NS_05_05);\n        Document doc = DOMUtils.createDocument();\n        Element claimType = createClaimsType(doc);\n        claimsType.getAny().add(claimType);\n        \n        JAXBElement<ClaimsType> claimsTypeJaxb = \n            new JAXBElement<ClaimsType>(\n                QNameConstants.CLAIMS, ClaimsType.class, claimsType\n            );\n        request.getAny().add(claimsTypeJaxb);\n        \n        request.getAny().add(createAppliesToElement(\"http://dummy-service.com/dummy\"));\n        \n        // Mock up message context\n        MessageImpl msg = new MessageImpl();\n        WrappedMessageContext msgCtx = new WrappedMessageContext(msg);\n        msgCtx.put(\n            SecurityContext.class.getName(), \n            createSecurityContext(new CustomTokenPrincipal(\"alice\"))\n        );\n        WebServiceContextImpl webServiceContext = new WebServiceContextImpl(msgCtx);\n        \n        // Issue a token\n        RequestSecurityTokenResponseCollectionType response = \n            issueOperation.issue(request, webServiceContext);\n        List<RequestSecurityTokenResponseType> securityTokenResponse = \n            response.getRequestSecurityTokenResponse();\n        assertTrue(!securityTokenResponse.isEmpty());\n        \n        // Test the generated token.\n        Element assertion = null;\n        for (Object tokenObject : securityTokenResponse.get(0).getAny()) {\n            if (tokenObject instanceof JAXBElement<?>\n                && REQUESTED_SECURITY_TOKEN.equals(((JAXBElement<?>)tokenObject).getName())) {\n                RequestedSecurityTokenType rstType = \n                    (RequestedSecurityTokenType)((JAXBElement<?>)tokenObject).getValue();\n                assertion = (Element)rstType.getAny();\n                break;\n            }\n        }\n        \n        assertNotNull(assertion);\n        String tokenString = DOM2Writer.nodeToString(assertion);\n        assertTrue(tokenString.contains(\"AttributeStatement\"));\n        assertTrue(tokenString.contains(\"alice\"));\n        assertTrue(tokenString.contains(SAML1Constants.CONF_BEARER));\n        assertTrue(tokenString.contains(ClaimTypes.LASTNAME.toString()));\n    }","id":49115,"modified_method":"/**\n     * Test to successfully issue a Saml 1.1 token. The claims information is included as a \n     * JAXB Element under RequestSecurityToken, rather than as a child of SecondaryParameters.\n     */\n    @org.junit.Test\n    public void testIssueJaxbSaml1Token() throws Exception {\n        TokenIssueOperation issueOperation = new TokenIssueOperation();\n        \n        addTokenProvider(issueOperation);\n        \n        addService(issueOperation);\n        \n        addSTSProperties(issueOperation);\n        \n        // Set the ClaimsManager\n        ClaimsManager claimsManager = new ClaimsManager();\n        ClaimsHandler claimsHandler = new CustomClaimsHandler();\n        claimsManager.setClaimHandlers(Collections.singletonList(claimsHandler));\n        issueOperation.setClaimsManager(claimsManager);\n        \n        // Mock up a request\n        RequestSecurityTokenType request = new RequestSecurityTokenType();\n        JAXBElement<String> tokenType = \n            new JAXBElement<String>(\n                QNameConstants.TOKEN_TYPE, String.class, WSConstants.WSS_SAML_TOKEN_TYPE\n            );\n        request.getAny().add(tokenType);\n        \n        // Add a ClaimsType\n        ClaimsType claimsType = new ClaimsType();\n        claimsType.setDialect(STSConstants.IDT_NS_05_05);\n        Document doc = DOMUtils.createDocument();\n        Element claimType = createClaimsType(doc);\n        claimsType.getAny().add(claimType);\n        \n        JAXBElement<ClaimsType> claimsTypeJaxb = \n            new JAXBElement<ClaimsType>(\n                QNameConstants.CLAIMS, ClaimsType.class, claimsType\n            );\n        request.getAny().add(claimsTypeJaxb);\n        \n        request.getAny().add(createAppliesToElement(\"http://dummy-service.com/dummy\"));\n        \n        WebServiceContextImpl webServiceContext = setupMessageContext();\n        \n        List<RequestSecurityTokenResponseType> securityTokenResponse = issueToken(issueOperation, request,\n                webServiceContext);\n        \n        // Test the generated token.\n        Element assertion = null;\n        for (Object tokenObject : securityTokenResponse.get(0).getAny()) {\n            if (tokenObject instanceof JAXBElement<?>\n                && REQUESTED_SECURITY_TOKEN.equals(((JAXBElement<?>)tokenObject).getName())) {\n                RequestedSecurityTokenType rstType = \n                    (RequestedSecurityTokenType)((JAXBElement<?>)tokenObject).getValue();\n                assertion = (Element)rstType.getAny();\n                break;\n            }\n        }\n        \n        assertNotNull(assertion);\n        String tokenString = DOM2Writer.nodeToString(assertion);\n        assertTrue(tokenString.contains(\"AttributeStatement\"));\n        assertTrue(tokenString.contains(\"alice\"));\n        assertTrue(tokenString.contains(SAML1Constants.CONF_BEARER));\n        assertTrue(tokenString.contains(ClaimTypes.LASTNAME.toString()));\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Test to successfully issue a Saml 1.1 token.\n     */\n    @org.junit.Test\n    public void testIssueSaml1Token() throws Exception {\n        TokenIssueOperation issueOperation = new TokenIssueOperation();\n        \n        // Add Token Provider\n        List<TokenProvider> providerList = new ArrayList<TokenProvider>();\n        \n        List<AttributeStatementProvider> customProviderList = \n            new ArrayList<AttributeStatementProvider>();\n        customProviderList.add(new CustomAttributeProvider());\n        SAMLTokenProvider samlTokenProvider = new SAMLTokenProvider();\n        samlTokenProvider.setAttributeStatementProviders(customProviderList);\n        providerList.add(samlTokenProvider);\n        issueOperation.setTokenProviders(providerList);\n        \n        // Add Service\n        ServiceMBean service = new StaticService();\n        service.setEndpoints(Collections.singletonList(\"http://dummy-service.com/dummy\"));\n        issueOperation.setServices(Collections.singletonList(service));\n        \n        // Add STSProperties object\n        STSPropertiesMBean stsProperties = new StaticSTSProperties();\n        Crypto crypto = CryptoFactory.getInstance(getEncryptionProperties());\n        stsProperties.setEncryptionCrypto(crypto);\n        stsProperties.setSignatureCrypto(crypto);\n        stsProperties.setEncryptionUsername(\"myservicekey\");\n        stsProperties.setSignatureUsername(\"mystskey\");\n        stsProperties.setCallbackHandler(new PasswordCallbackHandler());\n        stsProperties.setIssuer(\"STS\");\n        issueOperation.setStsProperties(stsProperties);\n        \n        // Set the ClaimsManager\n        ClaimsManager claimsManager = new ClaimsManager();\n        ClaimsHandler claimsHandler = new CustomClaimsHandler();\n        claimsManager.setClaimHandlers(Collections.singletonList(claimsHandler));\n        issueOperation.setClaimsManager(claimsManager);\n        \n        // Mock up a request\n        RequestSecurityTokenType request = new RequestSecurityTokenType();\n        JAXBElement<String> tokenType = \n            new JAXBElement<String>(\n                QNameConstants.TOKEN_TYPE, String.class, WSConstants.WSS_SAML_TOKEN_TYPE\n            );\n        request.getAny().add(tokenType);\n        Element secondaryParameters = createSecondaryParameters();\n        request.getAny().add(secondaryParameters);\n        request.getAny().add(createAppliesToElement(\"http://dummy-service.com/dummy\"));\n        \n        // Mock up message context\n        MessageImpl msg = new MessageImpl();\n        WrappedMessageContext msgCtx = new WrappedMessageContext(msg);\n        msgCtx.put(\n            SecurityContext.class.getName(), \n            createSecurityContext(new CustomTokenPrincipal(\"alice\"))\n        );\n        WebServiceContextImpl webServiceContext = new WebServiceContextImpl(msgCtx);\n        \n        // Issue a token\n        RequestSecurityTokenResponseCollectionType response = \n            issueOperation.issue(request, webServiceContext);\n        List<RequestSecurityTokenResponseType> securityTokenResponse = \n            response.getRequestSecurityTokenResponse();\n        assertTrue(!securityTokenResponse.isEmpty());\n        \n        // Test the generated token.\n        Element assertion = null;\n        for (Object tokenObject : securityTokenResponse.get(0).getAny()) {\n            if (tokenObject instanceof JAXBElement<?>\n                && REQUESTED_SECURITY_TOKEN.equals(((JAXBElement<?>)tokenObject).getName())) {\n                RequestedSecurityTokenType rstType = \n                    (RequestedSecurityTokenType)((JAXBElement<?>)tokenObject).getValue();\n                assertion = (Element)rstType.getAny();\n                break;\n            }\n        }\n        \n        assertNotNull(assertion);\n        String tokenString = DOM2Writer.nodeToString(assertion);\n        assertTrue(tokenString.contains(\"AttributeStatement\"));\n        assertTrue(tokenString.contains(\"alice\"));\n        assertTrue(tokenString.contains(SAML1Constants.CONF_BEARER));\n        assertTrue(tokenString.contains(ClaimTypes.LASTNAME.toString()));\n    }","id":49116,"modified_method":"/**\n     * Test to successfully issue a Saml 1.1 token.\n     */\n    @org.junit.Test\n    public void testIssueSaml1Token() throws Exception {\n        TokenIssueOperation issueOperation = new TokenIssueOperation();\n        \n        addTokenProvider(issueOperation);\n        \n        addService(issueOperation);\n        \n        addSTSProperties(issueOperation);\n        \n        // Set the ClaimsManager\n        ClaimsManager claimsManager = new ClaimsManager();\n        ClaimsHandler claimsHandler = new CustomClaimsHandler();\n        claimsManager.setClaimHandlers(Collections.singletonList(claimsHandler));\n        issueOperation.setClaimsManager(claimsManager);\n        \n        // Mock up a request\n        RequestSecurityTokenType request = new RequestSecurityTokenType();\n        JAXBElement<String> tokenType = \n            new JAXBElement<String>(\n                QNameConstants.TOKEN_TYPE, String.class, WSConstants.WSS_SAML_TOKEN_TYPE\n            );\n        request.getAny().add(tokenType);\n        Element secondaryParameters = createSecondaryParameters();\n        request.getAny().add(secondaryParameters);\n        request.getAny().add(createAppliesToElement(\"http://dummy-service.com/dummy\"));\n        \n        WebServiceContextImpl webServiceContext = setupMessageContext();\n        \n        List<RequestSecurityTokenResponseType> securityTokenResponse = issueToken(issueOperation, request,\n                webServiceContext);\n        \n        // Test the generated token.\n        Element assertion = null;\n        for (Object tokenObject : securityTokenResponse.get(0).getAny()) {\n            if (tokenObject instanceof JAXBElement<?>\n                && REQUESTED_SECURITY_TOKEN.equals(((JAXBElement<?>)tokenObject).getName())) {\n                RequestedSecurityTokenType rstType = \n                    (RequestedSecurityTokenType)((JAXBElement<?>)tokenObject).getValue();\n                assertion = (Element)rstType.getAny();\n                break;\n            }\n        }\n        \n        assertNotNull(assertion);\n        String tokenString = DOM2Writer.nodeToString(assertion);\n        assertTrue(tokenString.contains(\"AttributeStatement\"));\n        assertTrue(tokenString.contains(\"alice\"));\n        assertTrue(tokenString.contains(SAML1Constants.CONF_BEARER));\n        assertTrue(tokenString.contains(ClaimTypes.LASTNAME.toString()));\n        assertTrue(tokenString.contains(ROLE_CLAIM.toString()));\n        assertTrue(tokenString.contains(\"administrator\"));\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Parse the Token requirements into the TokenRequirements argument.\n     */\n    private static boolean parseTokenRequirements(\n        JAXBElement<?> jaxbElement, \n        TokenRequirements tokenRequirements,\n        WebServiceContext wsContext\n    ) {\n        if (QNameConstants.TOKEN_TYPE.equals(jaxbElement.getName())) {\n            String tokenType = (String)jaxbElement.getValue();\n            tokenRequirements.setTokenType(tokenType);\n            LOG.fine(\"Found TokenType: \" + tokenType);\n        } else if (QNameConstants.ON_BEHALF_OF.equals(jaxbElement.getName())) {\n            OnBehalfOfType onBehalfOfType = (OnBehalfOfType)jaxbElement.getValue();\n            ReceivedToken onBehalfOf = new ReceivedToken(onBehalfOfType.getAny());\n            tokenRequirements.setOnBehalfOf(onBehalfOf);\n            LOG.fine(\"Found OnBehalfOf token\");\n        } else if (QNameConstants.ACT_AS.equals(jaxbElement.getName())) {\n            ActAsType actAsType = (ActAsType)jaxbElement.getValue();\n            ReceivedToken actAs = new ReceivedToken(actAsType.getAny());\n            tokenRequirements.setActAs(actAs);\n            LOG.fine(\"Found ActAs token\");\n        } else if (QNameConstants.LIFETIME.equals(jaxbElement.getName())) {\n            LifetimeType lifetimeType = (LifetimeType)jaxbElement.getValue();\n            Lifetime lifetime = new Lifetime();\n            if (lifetimeType.getCreated() != null) {\n                lifetime.setCreated(lifetimeType.getCreated().getValue());\n            }\n            if (lifetimeType.getExpires() != null) {\n                lifetime.setExpires(lifetimeType.getExpires().getValue());\n            }\n            tokenRequirements.setLifetime(lifetime);\n            LOG.fine(\"Found Lifetime element\");\n        } else if (QNameConstants.VALIDATE_TARGET.equals(jaxbElement.getName())) {\n            ValidateTargetType validateTargetType = (ValidateTargetType)jaxbElement.getValue();\n            ReceivedToken validateTarget = new ReceivedToken(validateTargetType.getAny());\n            if (isTokenReferenced(validateTarget.getToken())) {\n                Element target = fetchTokenElementFromReference(validateTarget.getToken(), wsContext);\n                validateTarget = new ReceivedToken(target);\n            }  \n            tokenRequirements.setValidateTarget(validateTarget);\n            LOG.fine(\"Found ValidateTarget token\");\n        } else if (QNameConstants.CANCEL_TARGET.equals(jaxbElement.getName())) {\n            CancelTargetType cancelTargetType = (CancelTargetType)jaxbElement.getValue();\n            ReceivedToken cancelTarget = new ReceivedToken(cancelTargetType.getAny());\n            if (isTokenReferenced(cancelTarget.getToken())) {\n                Element target = fetchTokenElementFromReference(cancelTarget.getToken(), wsContext);\n                cancelTarget = new ReceivedToken(target);\n            }          \n            tokenRequirements.setCancelTarget(cancelTarget);\n            LOG.fine(\"Found CancelTarget token\");\n        } else if (QNameConstants.RENEW_TARGET.equals(jaxbElement.getName())) {\n            RenewTargetType renewTargetType = (RenewTargetType)jaxbElement.getValue();\n            ReceivedToken renewTarget = new ReceivedToken(renewTargetType.getAny());\n            if (isTokenReferenced(renewTarget.getToken())) {\n                Element target = fetchTokenElementFromReference(renewTarget.getToken(), wsContext);\n                renewTarget = new ReceivedToken(target);\n            }          \n            tokenRequirements.setRenewTarget(renewTarget);\n            LOG.fine(\"Found CancelTarget token\");\n        } else if (QNameConstants.CLAIMS.equals(jaxbElement.getName())) {\n            ClaimsType claimsType = (ClaimsType)jaxbElement.getValue();\n            RequestClaimCollection requestedClaims = parseClaims(claimsType);\n            tokenRequirements.setClaims(requestedClaims);\n            LOG.fine(\"Found Claims token\");\n        } else {\n            return false;\n        }\n        return true;\n    }","id":49117,"modified_method":"/**\n     * Parse the Token requirements into the TokenRequirements argument.\n     */\n    private static boolean parseTokenRequirements(\n        JAXBElement<?> jaxbElement, \n        TokenRequirements tokenRequirements,\n        WebServiceContext wsContext,\n        List<ClaimsParser> claimsParsers\n    ) {\n        if (QNameConstants.TOKEN_TYPE.equals(jaxbElement.getName())) {\n            String tokenType = (String)jaxbElement.getValue();\n            tokenRequirements.setTokenType(tokenType);\n            LOG.fine(\"Found TokenType: \" + tokenType);\n        } else if (QNameConstants.ON_BEHALF_OF.equals(jaxbElement.getName())) {\n            OnBehalfOfType onBehalfOfType = (OnBehalfOfType)jaxbElement.getValue();\n            ReceivedToken onBehalfOf = new ReceivedToken(onBehalfOfType.getAny());\n            tokenRequirements.setOnBehalfOf(onBehalfOf);\n            LOG.fine(\"Found OnBehalfOf token\");\n        } else if (QNameConstants.ACT_AS.equals(jaxbElement.getName())) {\n            ActAsType actAsType = (ActAsType)jaxbElement.getValue();\n            ReceivedToken actAs = new ReceivedToken(actAsType.getAny());\n            tokenRequirements.setActAs(actAs);\n            LOG.fine(\"Found ActAs token\");\n        } else if (QNameConstants.LIFETIME.equals(jaxbElement.getName())) {\n            LifetimeType lifetimeType = (LifetimeType)jaxbElement.getValue();\n            Lifetime lifetime = new Lifetime();\n            if (lifetimeType.getCreated() != null) {\n                lifetime.setCreated(lifetimeType.getCreated().getValue());\n            }\n            if (lifetimeType.getExpires() != null) {\n                lifetime.setExpires(lifetimeType.getExpires().getValue());\n            }\n            tokenRequirements.setLifetime(lifetime);\n            LOG.fine(\"Found Lifetime element\");\n        } else if (QNameConstants.VALIDATE_TARGET.equals(jaxbElement.getName())) {\n            ValidateTargetType validateTargetType = (ValidateTargetType)jaxbElement.getValue();\n            ReceivedToken validateTarget = new ReceivedToken(validateTargetType.getAny());\n            if (isTokenReferenced(validateTarget.getToken())) {\n                Element target = fetchTokenElementFromReference(validateTarget.getToken(), wsContext);\n                validateTarget = new ReceivedToken(target);\n            }  \n            tokenRequirements.setValidateTarget(validateTarget);\n            LOG.fine(\"Found ValidateTarget token\");\n        } else if (QNameConstants.CANCEL_TARGET.equals(jaxbElement.getName())) {\n            CancelTargetType cancelTargetType = (CancelTargetType)jaxbElement.getValue();\n            ReceivedToken cancelTarget = new ReceivedToken(cancelTargetType.getAny());\n            if (isTokenReferenced(cancelTarget.getToken())) {\n                Element target = fetchTokenElementFromReference(cancelTarget.getToken(), wsContext);\n                cancelTarget = new ReceivedToken(target);\n            }          \n            tokenRequirements.setCancelTarget(cancelTarget);\n            LOG.fine(\"Found CancelTarget token\");\n        } else if (QNameConstants.RENEW_TARGET.equals(jaxbElement.getName())) {\n            RenewTargetType renewTargetType = (RenewTargetType)jaxbElement.getValue();\n            ReceivedToken renewTarget = new ReceivedToken(renewTargetType.getAny());\n            if (isTokenReferenced(renewTarget.getToken())) {\n                Element target = fetchTokenElementFromReference(renewTarget.getToken(), wsContext);\n                renewTarget = new ReceivedToken(target);\n            }          \n            tokenRequirements.setRenewTarget(renewTarget);\n            LOG.fine(\"Found CancelTarget token\");\n        } else if (QNameConstants.CLAIMS.equals(jaxbElement.getName())) {\n            ClaimsType claimsType = (ClaimsType)jaxbElement.getValue();\n            RequestClaimCollection requestedClaims = parseClaims(claimsType, claimsParsers);\n            tokenRequirements.setClaims(requestedClaims);\n            LOG.fine(\"Found Claims token\");\n        } else {\n            return false;\n        }\n        return true;\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Create a RequestClaimCollection from a JAXB ClaimsType object\n     */\n    private static RequestClaimCollection parseClaims(ClaimsType claimsType) {\n        String dialectAttr = null;\n        RequestClaimCollection requestedClaims = new RequestClaimCollection();\n        try {\n            dialectAttr = claimsType.getDialect();\n            if (dialectAttr != null && !\"\".equals(dialectAttr)) {\n                requestedClaims.setDialect(new URI(dialectAttr));\n            }\n        } catch (URISyntaxException e1) {\n            LOG.log(\n                Level.WARNING, \n                \"Cannot create URI from the given Dialect attribute value \" + dialectAttr, \n                e1\n            );\n        }\n        \n        for (Object claim : claimsType.getAny()) {\n            if (claim instanceof Element) {\n                RequestClaim requestClaim = parseChildClaimType((Element)claim);\n                if (requestClaim != null) {\n                    requestedClaims.add(requestClaim);\n                }\n            }\n        }\n        \n        return requestedClaims;\n    }","id":49118,"modified_method":"/**\n     * Create a RequestClaimCollection from a JAXB ClaimsType object\n     */\n    private static RequestClaimCollection parseClaims(\n        ClaimsType claimsType, List<ClaimsParser> claimsParsers\n    ) {\n        String dialectAttr = null;\n        RequestClaimCollection requestedClaims = new RequestClaimCollection();\n        try {\n            dialectAttr = claimsType.getDialect();\n            if (dialectAttr != null && !\"\".equals(dialectAttr)) {\n                requestedClaims.setDialect(new URI(dialectAttr));\n            }\n        } catch (URISyntaxException e1) {\n            LOG.log(\n                Level.WARNING, \n                \"Cannot create URI from the given Dialect attribute value \" + dialectAttr, \n                e1\n            );\n        }\n        \n        for (Object claim : claimsType.getAny()) {\n            if (claim instanceof Element) {\n                RequestClaim requestClaim = parseChildClaimType((Element)claim, dialectAttr, claimsParsers);\n                if (requestClaim != null) {\n                    requestedClaims.add(requestClaim);\n                }\n            }\n        }\n        \n        return requestedClaims;\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Parse a child ClaimType into a RequestClaim object.\n     */\n    private static RequestClaim parseChildClaimType(Element childClaimType) {\n        String claimLocalName = childClaimType.getLocalName();\n        String claimNS = childClaimType.getNamespaceURI();\n        if (\"ClaimType\".equals(claimLocalName)) {\n            String claimTypeUri = childClaimType.getAttribute(\"Uri\");\n            String claimTypeOptional = childClaimType.getAttribute(\"Optional\");\n            RequestClaim requestClaim = new RequestClaim();\n            try {\n                requestClaim.setClaimType(new URI(claimTypeUri));\n            } catch (URISyntaxException e) {\n                LOG.log(\n                    Level.WARNING, \n                    \"Cannot create URI from the given ClaimType attribute value \" + claimTypeUri,\n                    e\n                );\n            }\n            requestClaim.setOptional(Boolean.parseBoolean(claimTypeOptional));\n            return requestClaim;\n        } else if (\"ClaimValue\".equals(claimLocalName)) {\n            String claimTypeUri = childClaimType.getAttribute(\"Uri\");\n            String claimTypeOptional = childClaimType.getAttribute(\"Optional\");\n            RequestClaim requestClaim = new RequestClaim();\n            try {\n                requestClaim.setClaimType(new URI(claimTypeUri));\n            } catch (URISyntaxException e) {\n                LOG.log(\n                    Level.WARNING, \n                    \"Cannot create URI from the given ClaimTye attribute value \" + claimTypeUri,\n                    e\n                );\n            }\n            \n            Node valueNode = childClaimType.getFirstChild();\n            if (valueNode != null) {\n                if (\"Value\".equals(valueNode.getLocalName())) {\n                    requestClaim.setClaimValue(valueNode.getTextContent());\n                } else {\n                    LOG.warning(\"Unsupported child element of ClaimValue element \"\n                            + valueNode.getLocalName());\n                    return null;\n                }\n            } else {\n                LOG.warning(\"No child element of ClaimValue element available\");\n                return null;\n            }\n             \n            requestClaim.setOptional(Boolean.parseBoolean(claimTypeOptional));\n            \n            return requestClaim;\n        }\n        \n        LOG.fine(\"Found unknown element: \" + claimLocalName + \" \" + claimNS);\n        return null;\n    }","id":49119,"modified_method":"/**\n     * Parse a child ClaimType into a RequestClaim object.\n     */\n    private static RequestClaim parseChildClaimType(\n        Element childClaimType, String dialect, List<ClaimsParser> claimsParsers\n    ) {\n        if (claimsParsers != null) {\n            for (ClaimsParser parser : claimsParsers) {\n                if (parser != null && dialect.equals(parser.getSupportedDialect())) {\n                    return parser.parse(childClaimType);\n                }\n            }\n        }\n        if (IdentityClaimsParser.IDENTITY_CLAIMS_DIALECT.equals(dialect)) {\n            return IdentityClaimsParser.parseClaimType(childClaimType);\n        }\n        \n        LOG.log(Level.WARNING, \"No ClaimsParser is registered for dialect \" + dialect);\n        throw new STSException(\n            \"No ClaimsParser is registered for dialect \" + dialect, STSException.BAD_REQUEST\n        );\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"public void parseRequest(\n        RequestSecurityTokenType request, WebServiceContext wsContext, STSPropertiesMBean stsProperties\n    ) throws STSException {\n        LOG.fine(\"Parsing RequestSecurityToken\");\n        keyRequirements = new KeyRequirements();\n        tokenRequirements = new TokenRequirements();\n        \n        for (Object requestObject : request.getAny()) {\n            // JAXB types\n            if (requestObject instanceof JAXBElement<?>) {\n                JAXBElement<?> jaxbElement = (JAXBElement<?>) requestObject;\n                boolean found = parseTokenRequirements(jaxbElement, tokenRequirements, wsContext);\n                if (!found) {\n                    found = parseKeyRequirements(jaxbElement, keyRequirements, wsContext, stsProperties);\n                }\n                if (!found) {\n                    LOG.log(Level.WARNING, \"Found a JAXB object of unknown type: \" + jaxbElement.getName());\n                    throw new STSException(\n                        \"An unknown element was received\", STSException.BAD_REQUEST\n                    );\n                }\n            // SecondaryParameters/AppliesTo\n            } else if (requestObject instanceof Element) {\n                Element element = (Element)requestObject;\n                if (STSConstants.WST_NS_05_12.equals(element.getNamespaceURI())\n                    && \"SecondaryParameters\".equals(element.getLocalName())) {\n                    parseSecondaryParameters(element);\n                } else if (\"AppliesTo\".equals(element.getLocalName())\n                    && (STSConstants.WSP_NS.equals(element.getNamespaceURI())\n                        || STSConstants.WSP_NS_04.equals(element.getNamespaceURI()))) {\n                    tokenRequirements.setAppliesTo(element);\n                    LOG.fine(\"Found AppliesTo element\");\n                } else {\n                    LOG.log(\n                        Level.WARNING, \n                        \"An unknown (DOM) element was received: \" + element.getLocalName()\n                    );\n                    throw new STSException(\n                        \"An unknown element was received\", STSException.BAD_REQUEST\n                    );\n                }\n            } else {\n                LOG.log(Level.WARNING, \"An unknown element was received\");\n                throw new STSException(\n                    \"An unknown element was received\", STSException.BAD_REQUEST\n                );\n            }\n        }\n        String context = request.getContext();\n        tokenRequirements.setContext(context);\n        LOG.fine(\"Received Context attribute: \" + context);\n    }","id":49120,"modified_method":"public void parseRequest(\n        RequestSecurityTokenType request, WebServiceContext wsContext, STSPropertiesMBean stsProperties, \n        List<ClaimsParser> claimsParsers\n    ) throws STSException {\n        LOG.fine(\"Parsing RequestSecurityToken\");\n        \n        keyRequirements = new KeyRequirements();\n        tokenRequirements = new TokenRequirements();\n        \n        for (Object requestObject : request.getAny()) {\n            // JAXB types\n            if (requestObject instanceof JAXBElement<?>) {\n                JAXBElement<?> jaxbElement = (JAXBElement<?>) requestObject;\n                boolean found = \n                    parseTokenRequirements(jaxbElement, tokenRequirements, wsContext, claimsParsers);\n                if (!found) {\n                    found = parseKeyRequirements(jaxbElement, keyRequirements, wsContext, stsProperties);\n                }\n                if (!found) {\n                    LOG.log(Level.WARNING, \"Found a JAXB object of unknown type: \" + jaxbElement.getName());\n                    throw new STSException(\n                        \"An unknown element was received\", STSException.BAD_REQUEST\n                    );\n                }\n            // SecondaryParameters/AppliesTo\n            } else if (requestObject instanceof Element) {\n                Element element = (Element)requestObject;\n                if (STSConstants.WST_NS_05_12.equals(element.getNamespaceURI())\n                    && \"SecondaryParameters\".equals(element.getLocalName())) {\n                    parseSecondaryParameters(element, claimsParsers);\n                } else if (\"AppliesTo\".equals(element.getLocalName())\n                    && (STSConstants.WSP_NS.equals(element.getNamespaceURI())\n                        || STSConstants.WSP_NS_04.equals(element.getNamespaceURI()))) {\n                    tokenRequirements.setAppliesTo(element);\n                    LOG.fine(\"Found AppliesTo element\");\n                } else {\n                    LOG.log(\n                        Level.WARNING, \n                        \"An unknown (DOM) element was received: \" + element.getLocalName()\n                    );\n                    throw new STSException(\n                        \"An unknown element was received\", STSException.BAD_REQUEST\n                    );\n                }\n            } else {\n                LOG.log(Level.WARNING, \"An unknown element was received\");\n                throw new STSException(\n                    \"An unknown element was received\", STSException.BAD_REQUEST\n                );\n            }\n        }\n        String context = request.getContext();\n        tokenRequirements.setContext(context);\n        LOG.fine(\"Received Context attribute: \" + context);\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Create a RequestClaimCollection from a DOM Element\n     */\n    private RequestClaimCollection parseClaims(Element claimsElement) {\n        String dialectAttr = null;\n        RequestClaimCollection requestedClaims = new RequestClaimCollection();\n        try {\n            dialectAttr = claimsElement.getAttribute(\"Dialect\");\n            if (dialectAttr != null && !\"\".equals(dialectAttr)) {\n                requestedClaims.setDialect(new URI(dialectAttr));\n            }\n        } catch (URISyntaxException e1) {\n            LOG.log(\n                Level.WARNING, \n                \"Cannot create URI from the given Dialect attribute value \" + dialectAttr, \n                e1\n            );\n        }\n        \n        Element childClaimType = DOMUtils.getFirstElement(claimsElement);\n        while (childClaimType != null) {\n            RequestClaim requestClaim = parseChildClaimType(childClaimType);\n            if (requestClaim != null) {\n                requestedClaims.add(requestClaim);\n            }\n            childClaimType = DOMUtils.getNextElement(childClaimType);\n        }\n        \n        return requestedClaims;\n    }","id":49121,"modified_method":"/**\n     * Create a RequestClaimCollection from a DOM Element\n     */\n    private RequestClaimCollection parseClaims(Element claimsElement, List<ClaimsParser> claimsParsers) {\n        String dialectAttr = null;\n        RequestClaimCollection requestedClaims = new RequestClaimCollection();\n        try {\n            dialectAttr = claimsElement.getAttribute(\"Dialect\");\n            if (dialectAttr != null && !\"\".equals(dialectAttr)) {\n                requestedClaims.setDialect(new URI(dialectAttr));\n            }\n        } catch (URISyntaxException e1) {\n            LOG.log(\n                Level.WARNING, \n                \"Cannot create URI from the given Dialect attribute value \" + dialectAttr, \n                e1\n            );\n        }\n        \n        Element childClaimType = DOMUtils.getFirstElement(claimsElement);\n        while (childClaimType != null) {\n            RequestClaim requestClaim = parseChildClaimType(childClaimType, dialectAttr, claimsParsers);\n            if (requestClaim != null) {\n                requestedClaims.add(requestClaim);\n            }\n            childClaimType = DOMUtils.getNextElement(childClaimType);\n        }\n        \n        return requestedClaims;\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Parse the secondaryParameters element. Precedence goes to values that are specified as\n     * direct children of the RequestSecurityToken element. \n     * @param secondaryParameters the secondaryParameters element to parse\n     */\n    private void parseSecondaryParameters(Element secondaryParameters) {\n        LOG.fine(\"Found SecondaryParameters element\");\n        Element child = DOMUtils.getFirstElement(secondaryParameters);\n        while (child != null) {\n            String localName = child.getLocalName();\n            String namespace = child.getNamespaceURI();\n            if (keyRequirements.getKeySize() == 0 && \"KeySize\".equals(localName) \n                && STSConstants.WST_NS_05_12.equals(namespace)) {\n                long keySize = Integer.parseInt(child.getTextContent());\n                keyRequirements.setKeySize(keySize);\n                LOG.fine(\"Found KeySize: \" + keySize);\n            } else if (tokenRequirements.getTokenType() == null \n                && \"TokenType\".equals(localName) && STSConstants.WST_NS_05_12.equals(namespace)) {\n                String tokenType = child.getTextContent();\n                tokenRequirements.setTokenType(tokenType);\n                LOG.fine(\"Found TokenType: \" + tokenType);\n            } else if (keyRequirements.getKeyType() == null \n                && \"KeyType\".equals(localName) && STSConstants.WST_NS_05_12.equals(namespace)) {\n                String keyType = child.getTextContent();\n                LOG.fine(\"Found KeyType: \" + keyType);\n                keyRequirements.setKeyType(keyType);\n            } else if (tokenRequirements.getClaims() == null \n                && \"Claims\".equals(localName) && STSConstants.WST_NS_05_12.equals(namespace)) {\n                LOG.fine(\"Found Claims element\");\n                RequestClaimCollection requestedClaims = parseClaims(child);\n                tokenRequirements.setClaims(requestedClaims);\n            } else {\n                LOG.fine(\"Found unknown element: \" + localName + \" \" + namespace);\n            }\n            child = DOMUtils.getNextElement(child);\n        }\n    }","id":49122,"modified_method":"/**\n     * Parse the secondaryParameters element. Precedence goes to values that are specified as\n     * direct children of the RequestSecurityToken element. \n     * @param secondaryParameters the secondaryParameters element to parse\n     */\n    private void parseSecondaryParameters(Element secondaryParameters, List<ClaimsParser> claimsParsers) {\n        LOG.fine(\"Found SecondaryParameters element\");\n        Element child = DOMUtils.getFirstElement(secondaryParameters);\n        while (child != null) {\n            String localName = child.getLocalName();\n            String namespace = child.getNamespaceURI();\n            if (keyRequirements.getKeySize() == 0 && \"KeySize\".equals(localName) \n                && STSConstants.WST_NS_05_12.equals(namespace)) {\n                long keySize = Integer.parseInt(child.getTextContent());\n                keyRequirements.setKeySize(keySize);\n                LOG.fine(\"Found KeySize: \" + keySize);\n            } else if (tokenRequirements.getTokenType() == null \n                && \"TokenType\".equals(localName) && STSConstants.WST_NS_05_12.equals(namespace)) {\n                String tokenType = child.getTextContent();\n                tokenRequirements.setTokenType(tokenType);\n                LOG.fine(\"Found TokenType: \" + tokenType);\n            } else if (keyRequirements.getKeyType() == null \n                && \"KeyType\".equals(localName) && STSConstants.WST_NS_05_12.equals(namespace)) {\n                String keyType = child.getTextContent();\n                LOG.fine(\"Found KeyType: \" + keyType);\n                keyRequirements.setKeyType(keyType);\n            } else if (tokenRequirements.getClaims() == null \n                && \"Claims\".equals(localName) && STSConstants.WST_NS_05_12.equals(namespace)) {\n                LOG.fine(\"Found Claims element\");\n                RequestClaimCollection requestedClaims = parseClaims(child, claimsParsers);\n                tokenRequirements.setClaims(requestedClaims);\n            } else {\n                LOG.fine(\"Found unknown element: \" + localName + \" \" + namespace);\n            }\n            child = DOMUtils.getNextElement(child);\n        }\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Test for fetching (and cancelling) a referenced SecurityContextToken.\n     */\n    @org.junit.Test\n    public void testCancelSCT() throws Exception {\n        Element secHeaderElement = (Element) parseStringToElement(SECURITY_HEADER).getFirstChild();\n        RequestSecurityTokenType request = createJaxbObject(CANCEL_SCT_REFERENCE);\n        RequestParser parser = new RequestParser();\n        \n        // Mock up message context\n        MessageImpl msg = new MessageImpl();\n        WrappedMessageContext msgContext = new WrappedMessageContext(msg);\n        WebServiceContextImpl wsContext = new WebServiceContextImpl(msgContext);\n        \n        // Process the security header and store the results in the message context\n        WSSecurityEngine securityEngine = new WSSecurityEngine();\n        RequestData reqData = new RequestData();\n        reqData.setCallbackHandler(new PasswordCallbackHandler());\n        \n        List<WSSecurityEngineResult> engineResultList = \n            securityEngine.processSecurityHeader(secHeaderElement, reqData);\n        List<WSHandlerResult> resultsList = new ArrayList<WSHandlerResult>();\n        resultsList.add(new WSHandlerResult(\"actor\", engineResultList));\n        msgContext.put(WSHandlerConstants.RECV_RESULTS, resultsList);\n        \n        parser.parseRequest(request, wsContext, null);\n        \n        SCTCanceller sctCanceller = new SCTCanceller();\n        assertTrue(sctCanceller.canHandleToken(parser.getTokenRequirements().getCancelTarget()));\n    }","id":49123,"modified_method":"/**\n     * Test for fetching (and cancelling) a referenced SecurityContextToken.\n     */\n    @org.junit.Test\n    public void testCancelSCT() throws Exception {\n        Element secHeaderElement = (Element) parseStringToElement(SECURITY_HEADER).getFirstChild();\n        RequestSecurityTokenType request = createJaxbObject(CANCEL_SCT_REFERENCE);\n        RequestParser parser = new RequestParser();\n        \n        // Mock up message context\n        MessageImpl msg = new MessageImpl();\n        WrappedMessageContext msgContext = new WrappedMessageContext(msg);\n        WebServiceContextImpl wsContext = new WebServiceContextImpl(msgContext);\n        \n        // Process the security header and store the results in the message context\n        WSSecurityEngine securityEngine = new WSSecurityEngine();\n        RequestData reqData = new RequestData();\n        reqData.setCallbackHandler(new PasswordCallbackHandler());\n        \n        List<WSSecurityEngineResult> engineResultList = \n            securityEngine.processSecurityHeader(secHeaderElement, reqData);\n        List<WSHandlerResult> resultsList = new ArrayList<WSHandlerResult>();\n        resultsList.add(new WSHandlerResult(\"actor\", engineResultList));\n        msgContext.put(WSHandlerConstants.RECV_RESULTS, resultsList);\n        \n        parser.parseRequest(request, wsContext, null, null);\n        \n        SCTCanceller sctCanceller = new SCTCanceller();\n        assertTrue(sctCanceller.canHandleToken(parser.getTokenRequirements().getCancelTarget()));\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Test for fetching (and validating) a referenced BinarySecurityToken from a UseKey Element.\n     */\n    @org.junit.Test\n    public void testUseKeyX509() throws Exception {\n        Element secHeaderElement = (Element) parseStringToElement(SECURITY_HEADER_X509).getFirstChild();\n        RequestSecurityTokenType request = createJaxbObject(USE_KEY_X509_REFERENCE);\n        RequestParser parser = new RequestParser();\n        \n        // Mock up message context\n        MessageImpl msg = new MessageImpl();\n        WrappedMessageContext msgContext = new WrappedMessageContext(msg);\n        WebServiceContextImpl wsContext = new WebServiceContextImpl(msgContext);\n        \n        // Process the security header and store the results in the message context\n        WSSecurityEngine securityEngine = new WSSecurityEngine();\n        RequestData reqData = new RequestData();\n        reqData.setSigCrypto(getCrypto());\n        reqData.setCallbackHandler(new PasswordCallbackHandler());\n        \n        List<WSSecurityEngineResult> engineResultList = \n            securityEngine.processSecurityHeader(secHeaderElement, reqData);\n        List<WSHandlerResult> resultsList = new ArrayList<WSHandlerResult>();\n        resultsList.add(new WSHandlerResult(\"actor\", engineResultList));\n        msgContext.put(WSHandlerConstants.RECV_RESULTS, resultsList);\n        \n        parser.parseRequest(request, wsContext, null);\n        \n        assertNotNull(parser.getKeyRequirements().getReceivedKey().getX509Cert());\n    }","id":49124,"modified_method":"/**\n     * Test for fetching (and validating) a referenced BinarySecurityToken from a UseKey Element.\n     */\n    @org.junit.Test\n    public void testUseKeyX509() throws Exception {\n        Element secHeaderElement = (Element) parseStringToElement(SECURITY_HEADER_X509).getFirstChild();\n        RequestSecurityTokenType request = createJaxbObject(USE_KEY_X509_REFERENCE);\n        RequestParser parser = new RequestParser();\n        \n        // Mock up message context\n        MessageImpl msg = new MessageImpl();\n        WrappedMessageContext msgContext = new WrappedMessageContext(msg);\n        WebServiceContextImpl wsContext = new WebServiceContextImpl(msgContext);\n        \n        // Process the security header and store the results in the message context\n        WSSecurityEngine securityEngine = new WSSecurityEngine();\n        RequestData reqData = new RequestData();\n        reqData.setSigCrypto(getCrypto());\n        reqData.setCallbackHandler(new PasswordCallbackHandler());\n        \n        List<WSSecurityEngineResult> engineResultList = \n            securityEngine.processSecurityHeader(secHeaderElement, reqData);\n        List<WSHandlerResult> resultsList = new ArrayList<WSHandlerResult>();\n        resultsList.add(new WSHandlerResult(\"actor\", engineResultList));\n        msgContext.put(WSHandlerConstants.RECV_RESULTS, resultsList);\n        \n        parser.parseRequest(request, wsContext, null, null);\n        \n        assertNotNull(parser.getKeyRequirements().getReceivedKey().getX509Cert());\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Test for fetching (and validating) a referenced SecurityContextToken.\n     */\n    @org.junit.Test\n    public void testValidateSCT() throws Exception {\n        Element secHeaderElement = (Element) parseStringToElement(SECURITY_HEADER).getFirstChild();\n        RequestSecurityTokenType request = createJaxbObject(VALIDATE_SCT_REFERENCE);\n        RequestParser parser = new RequestParser();\n        \n        // Mock up message context\n        MessageImpl msg = new MessageImpl();\n        WrappedMessageContext msgContext = new WrappedMessageContext(msg);\n        WebServiceContextImpl wsContext = new WebServiceContextImpl(msgContext);\n        \n        // Process the security header and store the results in the message context\n        WSSecurityEngine securityEngine = new WSSecurityEngine();\n        RequestData reqData = new RequestData();\n        reqData.setCallbackHandler(new PasswordCallbackHandler());\n        \n        List<WSSecurityEngineResult> engineResultList = \n            securityEngine.processSecurityHeader(secHeaderElement, reqData);\n        List<WSHandlerResult> resultsList = new ArrayList<WSHandlerResult>();\n        resultsList.add(new WSHandlerResult(\"actor\", engineResultList));\n        msgContext.put(WSHandlerConstants.RECV_RESULTS, resultsList);\n        \n        parser.parseRequest(request, wsContext, null);\n        \n        SCTValidator sctValidator = new SCTValidator();\n        assertTrue(sctValidator.canHandleToken(parser.getTokenRequirements().getValidateTarget()));\n    }","id":49125,"modified_method":"/**\n     * Test for fetching (and validating) a referenced SecurityContextToken.\n     */\n    @org.junit.Test\n    public void testValidateSCT() throws Exception {\n        Element secHeaderElement = (Element) parseStringToElement(SECURITY_HEADER).getFirstChild();\n        RequestSecurityTokenType request = createJaxbObject(VALIDATE_SCT_REFERENCE);\n        RequestParser parser = new RequestParser();\n        \n        // Mock up message context\n        MessageImpl msg = new MessageImpl();\n        WrappedMessageContext msgContext = new WrappedMessageContext(msg);\n        WebServiceContextImpl wsContext = new WebServiceContextImpl(msgContext);\n        \n        // Process the security header and store the results in the message context\n        WSSecurityEngine securityEngine = new WSSecurityEngine();\n        RequestData reqData = new RequestData();\n        reqData.setCallbackHandler(new PasswordCallbackHandler());\n        \n        List<WSSecurityEngineResult> engineResultList = \n            securityEngine.processSecurityHeader(secHeaderElement, reqData);\n        List<WSHandlerResult> resultsList = new ArrayList<WSHandlerResult>();\n        resultsList.add(new WSHandlerResult(\"actor\", engineResultList));\n        msgContext.put(WSHandlerConstants.RECV_RESULTS, resultsList);\n        \n        parser.parseRequest(request, wsContext, null, null);\n        \n        SCTValidator sctValidator = new SCTValidator();\n        assertTrue(sctValidator.canHandleToken(parser.getTokenRequirements().getValidateTarget()));\n    }","commit_id":"9fc65f774dca095ffec517b4e3cf5d0997f26825","url":"https://github.com/apache/cxf"},{"original_method":"public void run() {        \n        if (getParent().polling()) {\n            log().warn(\"run: polling snmp interfaces on package/interface \" + getParent().getPackageName()+ \"/\" + getName() + \"on primary address: \" + getParent().getIpaddress());\n            log().debug(\"run: polling snmp interfaces first run = \" + firstrun);\n            if (m_snmpinterfaces == null || m_snmpinterfaces.isEmpty()) {\n                log().info(\"No Interface found. Doing nothing\");\n            } else {\n                log().info(m_snmpinterfaces.size() + \" Interfaces found. Getting Statutes....\");\n            \tSnmpPollInterfaceMonitor pollMonitor = new SnmpPollInterfaceMonitor();\n        \t\tint maxiface = getMaxInterfacePerPdu();\n        \t\tif (maxiface == 0) maxiface=m_snmpinterfaces.size();\n        \t\tlog().debug(\"Max Interface Per Pdu is: \" + maxiface);\n        \t\tList<SnmpMinimalPollInterface> mifaces = getSnmpMinimalPollInterface();\n        \t\tint start =0;\n        \t\twhile (start + maxiface< m_snmpinterfaces.size()) {\n            \t\tdoPoll(pollMonitor,mifaces.subList(start, start+maxiface));\n            \t\tstart += maxiface;\n        \t\t}\n        \t\tdoPoll(pollMonitor,mifaces.subList(start, m_snmpinterfaces.size()));\n            }\n            \n        }  else {\n            log().info(\"not polling: \" + getParent().getIpaddress());\n        } // End if polling\n    }","id":49126,"modified_method":"public void run() {        \n        if (getParent().polling()) {\n            log().warn(\"run: polling snmp interfaces on package/interface \" + getParent().getPackageName()+ \"/\" + getName() + \"on primary address: \" + getParent().getIpaddress());\n            if (m_snmpinterfaces == null || m_snmpinterfaces.isEmpty()) {\n                log().info(\"No Interface found. Doing nothing\");\n            } else {\n                log().info(m_snmpinterfaces.size() + \" Interfaces found. Getting Statutes....\");\n            \tSnmpPollInterfaceMonitor pollMonitor = new SnmpPollInterfaceMonitor();\n        \t\tint maxiface = getMaxInterfacePerPdu();\n        \t\tif (maxiface == 0) maxiface=m_snmpinterfaces.size();\n        \t\tlog().debug(\"Max Interface Per Pdu is: \" + maxiface);\n        \t\tList<SnmpMinimalPollInterface> mifaces = getSnmpMinimalPollInterface();\n        \t\tint start =0;\n        \t\twhile (start + maxiface< m_snmpinterfaces.size()) {\n            \t\tdoPoll(pollMonitor,mifaces.subList(start, start+maxiface));\n            \t\tstart += maxiface;\n        \t\t}\n        \t\tdoPoll(pollMonitor,mifaces.subList(start, m_snmpinterfaces.size()));\n                firstrun=false;\n            }\n            \n        }  else {\n            log().info(\"not polling: \" + getParent().getIpaddress());\n        } // End if polling\n    }","commit_id":"a755b7746a30adcec18d89d34faa7a030ac57da5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private SnmpMinimalPollInterface getMinimalFromOnmsSnmpInterface(OnmsSnmpInterface iface) {\n        return new SnmpMinimalPollInterface(iface.getIfIndex().intValue(),iface.getIfAdminStatus().intValue(), iface.getIfOperStatus().intValue());\n    }","id":49127,"modified_method":"private SnmpMinimalPollInterface getMinimalFromOnmsSnmpInterface(OnmsSnmpInterface iface) {\n        int adminStatus = SnmpMinimalPollInterface.IF_UP;\n        int operStatus = SnmpMinimalPollInterface.IF_UP;\n        if (iface.getIfAdminStatus() != null) {\n            adminStatus = iface.getIfAdminStatus().intValue();\n        } else {\n            iface.setIfAdminStatus(SnmpMinimalPollInterface.IF_UNKNOWN);\n        }\n        if (iface.getIfOperStatus() != null) {\n            operStatus = iface.getIfOperStatus().intValue();\n        } else {\n            iface.setIfOperStatus(SnmpMinimalPollInterface.IF_UNKNOWN);\n        }\n        \n        return new SnmpMinimalPollInterface(iface.getIfIndex().intValue(),adminStatus, operStatus);\n    }","commit_id":"a755b7746a30adcec18d89d34faa7a030ac57da5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void doPoll(SnmpPollInterfaceMonitor pollMonitor, List<SnmpMinimalPollInterface> mifaces) {\n        \n        log().info(\"doPoll: input interfaces number: \" + mifaces.size());\n    \t\n        mifaces = pollMonitor.poll(getAgentConfig(), mifaces);\n        \n        if (mifaces != null) {\n            log().info(\"doPoll: PollerMonitor return interfaces number: \" + mifaces.size());\n            Iterator<SnmpMinimalPollInterface> ite = mifaces.iterator();\n            while (ite.hasNext()) {\n                SnmpMinimalPollInterface miface = ite.next();\n                log().debug(\"Working on interface with ifindex: \" + miface.getIfindex());\n                log().debug(\"Interface PollStatus is \" + miface.getStatus().getStatusName());\n                if (miface.getStatus().isUp()) {\n                    OnmsSnmpInterface iface = m_snmpinterfaces.get(new Integer(miface.getIfindex()));\n                    boolean changed = false;\n                    log().debug(\"Previuos status Admin/Oper: \" + iface.getIfAdminStatus() + \"/\" + iface.getIfOperStatus());\n                    log().debug(\"Current status Admin/Oper: \" + miface.getAdminstatus() + \"/\" + miface.getOperstatus());\n                    \n                    \n                    // first run send all down events if suppressAdminDownEvent is false otherwise\n                    // send all down events only for interface whose admin status is up\n                    if (suppressAdminDownEvent()) {\n                        if (firstrun && miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP && miface.getOperstatus() == SnmpMinimalPollInterface.IF_DOWN)\n                    \t\tsendOperDownEvent(iface);\n                    } else {\n                        if (firstrun && miface.getAdminstatus() == SnmpMinimalPollInterface.IF_DOWN) sendAdminDownEvent(iface);\n                        if (firstrun && miface.getOperstatus() == SnmpMinimalPollInterface.IF_DOWN) sendOperDownEvent(iface);\n                    }\n                    // OperStatus management\n                    if (iface.getIfOperStatus() != miface.getOperstatus()) {\n                        changed = true;\n                        iface.setIfOperStatus(new Integer(miface.getOperstatus()));\n                        if (!firstrun) {\n                            if (miface.getOperstatus() == SnmpMinimalPollInterface.IF_DOWN) {\n                                sendOperDownEvent(iface);\n                            }   \n                            if (miface.getOperstatus() == SnmpMinimalPollInterface.IF_UP) {\n                                sendOperUpEvent(iface);\n                            }   \n                        }\n                    }\n                    \n                    //Admin status management\n                    if (iface.getIfAdminStatus() != miface.getAdminstatus()) {\n                        changed = true;\n                        iface.setIfAdminStatus(new Integer(miface.getAdminstatus()));\n                        if (!firstrun) {\n                            if (miface.getAdminstatus() == SnmpMinimalPollInterface.IF_DOWN) {\n                                sendAdminDownEvent(iface);\n                            }   \n                            if (miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP) {\n                                sendAdminUpEvent(iface);\n                            }   \n                        }\n                    }\n                    log().debug(\"Interface changed = \" + changed);\n                    \n                    // Save Data to Database\n                    if (changed) {\n                        update(iface);\n                    }\n                } else {\n                    log().warn(\"run: \" + getContext().getServiceName() + \" not available, doing nothing.....\");\n                } //End if status OK\n            } //end while on interface\n            firstrun=false;\n        } else {\n            log().error(\"the monitor return null object\");\n        } //end If not null\n\n    }","id":49128,"modified_method":"private void doPoll(SnmpPollInterfaceMonitor pollMonitor, List<SnmpMinimalPollInterface> mifaces) {\n        \n        log().info(\"doPoll: input interfaces number: \" + mifaces.size());\n    \t\n        mifaces = pollMonitor.poll(getAgentConfig(), mifaces);\n        \n        if (mifaces != null) {\n            log().info(\"doPoll: PollerMonitor return interfaces number: \" + mifaces.size());\n            Iterator<SnmpMinimalPollInterface> ite = mifaces.iterator();\n            while (ite.hasNext()) {\n                SnmpMinimalPollInterface miface = ite.next();\n                log().debug(\"Working on interface with ifindex: \" + miface.getIfindex());\n                log().debug(\"Interface PollStatus is \" + miface.getStatus().getStatusName());\n                if (miface.getStatus().isUp()) {\n                    OnmsSnmpInterface iface = m_snmpinterfaces.get(new Integer(miface.getIfindex()));\n                    boolean changed = false;\n                    log().debug(\"Previuos status Admin/Oper: \" + iface.getIfAdminStatus() + \"/\" + iface.getIfOperStatus());\n                    log().debug(\"Current status Admin/Oper: \" + miface.getAdminstatus() + \"/\" + miface.getOperstatus());\n                    \n                    if (firstrun) {\n                        // If the interface is Admin Up, and the interface is Operational Down, we generate an alarm\n                        // if no alarm exist in alarm table.\n                        if ( miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP\n                          && miface.getOperstatus() == SnmpMinimalPollInterface.IF_DOWN \n                          && !hasOperDownAlarm(miface.getIfindex())) {\n                                sendOperDownEvent(iface);\n                        } \n                        \n                        // If the interface is Admin Up, and the interface is Operational Up, we generate a clean alarm\n                        // if exist an alarm in alarm table\n                        if ( miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP\n                                && miface.getOperstatus() == SnmpMinimalPollInterface.IF_UP \n                                && hasOperDownAlarm(miface.getIfindex())) {\n                                      sendOperUpEvent(iface);\n                        } \n                        \n                        \n                        if (!suppressAdminDownEvent() && miface.getAdminstatus() == SnmpMinimalPollInterface.IF_DOWN \n                                && ! hasAdminDownAlarm(miface.getIfindex())) {\n                                sendAdminDownEvent(iface);\n                        }\n\n                        if (!suppressAdminDownEvent() && miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP \n                                && hasAdminDownAlarm(miface.getIfindex())) {\n                                sendAdminUpEvent(iface);\n                        }\n\n                    } // end firstrun\n                    \n                    if (iface.getIfAdminStatus() != miface.getAdminstatus()) {\n                        changed = true;\n                        iface.setIfAdminStatus(new Integer(miface.getAdminstatus()));\n                        // We create event if and only if status changes from first run\n                        // and suppressAdminDownEvent is false\n                        if (!firstrun && !suppressAdminDownEvent()) {\n                            if (miface.getAdminstatus() == SnmpMinimalPollInterface.IF_DOWN)\n                                sendAdminDownEvent(iface);\n                            if (miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP)\n                                sendAdminUpEvent(iface);\n                        }\n                    }\n                                        \n                    if (iface.getIfOperStatus() != miface.getOperstatus()) {\n                        changed = true;\n                        iface.setIfOperStatus(new Integer(miface.getOperstatus()));\n                        // We create event if and only if status changes from first run\n                        // and the interface is administratevely up\n                        if (!firstrun && (miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP)) {\n                            if (miface.getOperstatus() == SnmpMinimalPollInterface.IF_DOWN)\n                                sendOperDownEvent(iface);\n                            if (miface.getOperstatus() == SnmpMinimalPollInterface.IF_UP)\n                                sendOperUpEvent(iface);\n                        }\n                    }\n                    \n                    //Admin status management\n                    log().debug(\"Interface changed = \" + changed);\n                    \n                    // Save Data to Database\n                    if (changed) {\n                        update(iface);\n                    }\n                } else {\n                    log().warn(\"run: \" + getContext().getServiceName() + \" not available, doing nothing.....\");\n                } //End if status OK\n            } //end while on interface\n        } else {\n            log().error(\"the monitor return null object\");\n        } //end If not null\n\n    }","commit_id":"a755b7746a30adcec18d89d34faa7a030ac57da5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void deleteExistingSnmpPollAlarms() {\n        String sql = \"delete from alarms where eventuei like 'uei.opennms.org/nodes/snmp/interface%'\";\n        Updater updater = new Updater(m_dataSource, sql);\n        updater.execute();\n    }","id":49129,"modified_method":"protected void selectExistingSnmpPollAlarms() {\n        m_nodeAlarmStatusMap = new HashMap<Integer, Map<Integer,AlarmStatus>>();\n        String sql = \"select nodeid, ifindex, eventuei from alarms where eventuei like 'uei.opennms.org/nodes/snmp/interface%'\";\n        Querier querier = new Querier(m_dataSource, sql) {\n\n            public void processRow(ResultSet rs) throws SQLException {\n                   setAlarmStatus(rs.getInt(\"nodeid\"), rs.getInt(\"ifindex\"), rs.getString(\"eventuei\"));\n            }\n       \n        };\n       querier.execute();  \n    }","commit_id":"a755b7746a30adcec18d89d34faa7a030ac57da5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    protected void onInit() {\n        \n        // reset the alarm table\n        //\n        try {\n            log().debug(\"start: Deleting snmppoll alarms from alarm table\");\n\n            deleteExistingSnmpPollAlarms();\n        } catch (Exception sqlE) {\n            log().error(\"start: Failed to delete existing snmppoll alarms\", sqlE);\n        }\n        createScheduler();\n        \n        // Schedule the interfaces currently in the database\n        //\n        try {\n            log().debug(\"start: Scheduling existing snmp interfaces polling\");\n\n            scheduleExistingSnmpInterface();\n        } catch (Exception sqlE) {\n            log().error(\"start: Failed to schedule existing interfaces\", sqlE);\n        }\n\n        // Create an event receiver. The receiver will\n        // receive events, process them, creates network\n        // interfaces, and schedulers them.\n        //\n        try {\n            log().debug(\"start: Creating event broadcast event processor\");\n\n            setEventProcessor(new SnmpInterfacePollerEventProcessor(this));\n        } catch (Throwable t) {\n            log().fatal(\"start: Failed to initialized the broadcast event receiver\", t);\n\n            throw new UndeclaredThrowableException(t);\n        }\n\n        m_initialized = true;\n        \n    }","id":49130,"modified_method":"@Override\n    protected void onInit() {\n        \n        // reset the alarm table\n        //\n        \n        try {\n            log().debug(\"start: select snmppoll alarms from alarm table\");\n\n            selectExistingSnmpPollAlarms();\n        } catch (Exception sqlE) {\n            log().error(\"start: Failed to delete existing snmppoll alarms\", sqlE);\n        }\n        createScheduler();\n        \n        // Schedule the interfaces currently in the database\n        //\n        try {\n            log().debug(\"start: Scheduling existing snmp interfaces polling\");\n\n            scheduleExistingSnmpInterface();\n        } catch (Exception sqlE) {\n            log().error(\"start: Failed to schedule existing interfaces\", sqlE);\n        }\n\n        // Create an event receiver. The receiver will\n        // receive events, process them, creates network\n        // interfaces, and schedulers them.\n        //\n        try {\n            log().debug(\"start: Creating event broadcast event processor\");\n\n            setEventProcessor(new SnmpInterfacePollerEventProcessor(this));\n        } catch (Throwable t) {\n            log().fatal(\"start: Failed to initialized the broadcast event receiver\", t);\n\n            throw new UndeclaredThrowableException(t);\n        }\n\n        m_initialized = true;\n        \n    }","commit_id":"a755b7746a30adcec18d89d34faa7a030ac57da5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void scheduleSnmpCollection(PollableSnmpInterface node, String criteria, long interval) {\n        criteria = criteria + \" and nodeid = \" + node.getParent().getNodeid();\n        node.setSnmpinterfaces(getQueryManager().getSnmpInterfaces(criteria));\n        PollableSnmpInterfaceConfig nodeconfig = new PollableSnmpInterfaceConfig(getScheduler(),interval);\n\n        node.setSnmppollableconfig(nodeconfig);\n\n        synchronized(node) {\n            if (node.getSchedule() == null) {\n                log().debug(\"Scheduling node: \" + node.getParent().getIpaddress());\n                Schedule schedule = new Schedule(node, nodeconfig, getScheduler());\n                node.setSchedule(schedule);\n            }\n        }\n        \n        node.schedule();\n    }","id":49131,"modified_method":"private void scheduleSnmpCollection(PollableSnmpInterface node, String criteria, long interval) {\n        criteria = criteria + \" and nodeid = \" + node.getParent().getNodeid();\n        List<OnmsSnmpInterface> snmpinterfacelist = getQueryManager().getSnmpInterfaces(criteria);\n        if (snmpinterfacelist !=  null && snmpinterfacelist.size() > 0) {\n            node.setSnmpinterfaces(snmpinterfacelist);\n            if (m_nodeAlarmStatusMap.containsKey(node.getParent().getNodeid()))\n                node.setAlarmStatus(m_nodeAlarmStatusMap.get(node.getParent().getNodeid()));\n            else \n                node.setAlarmStatus(new HashMap<Integer,AlarmStatus>());\n            \n            PollableSnmpInterfaceConfig nodeconfig = new PollableSnmpInterfaceConfig(getScheduler(),interval);\n\n            node.setSnmppollableconfig(nodeconfig);\n\n            synchronized(node) {\n                if (node.getSchedule() == null) {\n                    log().debug(\"Scheduling node: \" + node.getParent().getIpaddress());\n                    Schedule schedule = new Schedule(node, nodeconfig, getScheduler());\n                    node.setSchedule(schedule);\n                }\n            }\n        \n            node.schedule();\n        } else {\n            log().info(\"no interface found for node/criteria:\" + node.getParent().getNodeid() + \"/\" + criteria);\n        }\n    }","commit_id":"a755b7746a30adcec18d89d34faa7a030ac57da5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void run() {        \n        if (getParent().polling()) {\n            log().warn(\"run: polling snmp interfaces on package/interface \" + getParent().getPackageName()+ \"/\" + getName() + \"on primary address: \" + getParent().getIpaddress());\n            log().debug(\"run: polling snmp interfaces first run = \" + firstrun);\n            if (m_snmpinterfaces == null || m_snmpinterfaces.isEmpty()) {\n                log().info(\"No Interface found. Doing nothing\");\n            } else {\n                log().info(m_snmpinterfaces.size() + \" Interfaces found. Getting Statutes....\");\n            \tSnmpPollInterfaceMonitor pollMonitor = new SnmpPollInterfaceMonitor();\n        \t\tint maxiface = getMaxInterfacePerPdu();\n        \t\tif (maxiface == 0) maxiface=m_snmpinterfaces.size();\n        \t\tlog().debug(\"Max Interface Per Pdu is: \" + maxiface);\n        \t\tList<SnmpMinimalPollInterface> mifaces = getSnmpMinimalPollInterface();\n        \t\tint start =0;\n        \t\twhile (start + maxiface< m_snmpinterfaces.size()) {\n            \t\tdoPoll(pollMonitor,mifaces.subList(start, start+maxiface));\n            \t\tstart += maxiface;\n        \t\t}\n        \t\tdoPoll(pollMonitor,mifaces.subList(start, m_snmpinterfaces.size()));\n            }\n            \n        }  else {\n            log().info(\"not polling: \" + getParent().getIpaddress());\n        } // End if polling\n    }","id":49132,"modified_method":"public void run() {        \n        if (getParent().polling()) {\n            log().warn(\"run: polling snmp interfaces on package/interface \" + getParent().getPackageName()+ \"/\" + getName() + \"on primary address: \" + getParent().getIpaddress());\n            if (m_snmpinterfaces == null || m_snmpinterfaces.isEmpty()) {\n                log().info(\"No Interface found. Doing nothing\");\n            } else {\n                log().info(m_snmpinterfaces.size() + \" Interfaces found. Getting Statutes....\");\n            \tSnmpPollInterfaceMonitor pollMonitor = new SnmpPollInterfaceMonitor();\n        \t\tint maxiface = getMaxInterfacePerPdu();\n        \t\tif (maxiface == 0) maxiface=m_snmpinterfaces.size();\n        \t\tlog().debug(\"Max Interface Per Pdu is: \" + maxiface);\n        \t\tList<SnmpMinimalPollInterface> mifaces = getSnmpMinimalPollInterface();\n        \t\tint start =0;\n        \t\twhile (start + maxiface< m_snmpinterfaces.size()) {\n            \t\tdoPoll(pollMonitor,mifaces.subList(start, start+maxiface));\n            \t\tstart += maxiface;\n        \t\t}\n        \t\tdoPoll(pollMonitor,mifaces.subList(start, m_snmpinterfaces.size()));\n                firstrun=false;\n            }\n            \n        }  else {\n            log().info(\"not polling: \" + getParent().getIpaddress());\n        } // End if polling\n    }","commit_id":"5d5aba8b8985f8aef9e036ed4d683446d1716d2f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void doPoll(SnmpPollInterfaceMonitor pollMonitor, List<SnmpMinimalPollInterface> mifaces) {\n        \n        log().info(\"doPoll: input interfaces number: \" + mifaces.size());\n    \t\n        mifaces = pollMonitor.poll(getAgentConfig(), mifaces);\n        \n        if (mifaces != null) {\n            log().info(\"doPoll: PollerMonitor return interfaces number: \" + mifaces.size());\n            Iterator<SnmpMinimalPollInterface> ite = mifaces.iterator();\n            while (ite.hasNext()) {\n                SnmpMinimalPollInterface miface = ite.next();\n                log().debug(\"Working on interface with ifindex: \" + miface.getIfindex());\n                log().debug(\"Interface PollStatus is \" + miface.getStatus().getStatusName());\n                if (miface.getStatus().isUp()) {\n                    OnmsSnmpInterface iface = m_snmpinterfaces.get(new Integer(miface.getIfindex()));\n                    boolean changed = false;\n                    log().debug(\"Previuos status Admin/Oper: \" + iface.getIfAdminStatus() + \"/\" + iface.getIfOperStatus());\n                    log().debug(\"Current status Admin/Oper: \" + miface.getAdminstatus() + \"/\" + miface.getOperstatus());\n                    \n                    \n                    // first run send all down events if suppressAdminDownEvent is false otherwise\n                    // send all down events only for interface whose admin status is up\n                    if (suppressAdminDownEvent()) {\n                        if (firstrun && miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP && miface.getOperstatus() == SnmpMinimalPollInterface.IF_DOWN)\n                    \t\tsendOperDownEvent(iface);\n                    } else {\n                        if (firstrun && miface.getAdminstatus() == SnmpMinimalPollInterface.IF_DOWN) sendAdminDownEvent(iface);\n                        if (firstrun && miface.getOperstatus() == SnmpMinimalPollInterface.IF_DOWN) sendOperDownEvent(iface);\n                    }\n                    // OperStatus management\n                    if (iface.getIfOperStatus() != miface.getOperstatus()) {\n                        changed = true;\n                        iface.setIfOperStatus(new Integer(miface.getOperstatus()));\n                        if (!firstrun) {\n                            if (miface.getOperstatus() == SnmpMinimalPollInterface.IF_DOWN) {\n                                sendOperDownEvent(iface);\n                            }   \n                            if (miface.getOperstatus() == SnmpMinimalPollInterface.IF_UP) {\n                                sendOperUpEvent(iface);\n                            }   \n                        }\n                    }\n                    \n                    //Admin status management\n                    if (iface.getIfAdminStatus() != miface.getAdminstatus()) {\n                        changed = true;\n                        iface.setIfAdminStatus(new Integer(miface.getAdminstatus()));\n                        if (!firstrun) {\n                            if (miface.getAdminstatus() == SnmpMinimalPollInterface.IF_DOWN) {\n                                sendAdminDownEvent(iface);\n                            }   \n                            if (miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP) {\n                                sendAdminUpEvent(iface);\n                            }   \n                        }\n                    }\n                    log().debug(\"Interface changed = \" + changed);\n                    \n                    // Save Data to Database\n                    if (changed) {\n                        update(iface);\n                    }\n                } else {\n                    log().warn(\"run: \" + getContext().getServiceName() + \" not available, doing nothing.....\");\n                } //End if status OK\n            } //end while on interface\n            firstrun=false;\n        } else {\n            log().error(\"the monitor return null object\");\n        } //end If not null\n\n    }","id":49133,"modified_method":"private void doPoll(SnmpPollInterfaceMonitor pollMonitor, List<SnmpMinimalPollInterface> mifaces) {\n        \n        log().info(\"doPoll: input interfaces number: \" + mifaces.size());\n    \t\n        mifaces = pollMonitor.poll(getAgentConfig(), mifaces);\n        \n        if (mifaces != null) {\n            log().info(\"doPoll: PollerMonitor return interfaces number: \" + mifaces.size());\n            Iterator<SnmpMinimalPollInterface> ite = mifaces.iterator();\n            while (ite.hasNext()) {\n                SnmpMinimalPollInterface miface = ite.next();\n                log().debug(\"Working on interface with ifindex: \" + miface.getIfindex());\n                log().debug(\"Interface PollStatus is \" + miface.getStatus().getStatusName());\n                if (miface.getStatus().isUp()) {\n                    OnmsSnmpInterface iface = m_snmpinterfaces.get(new Integer(miface.getIfindex()));\n                    boolean changed = false;\n                    log().debug(\"Previuos status Admin/Oper: \" + iface.getIfAdminStatus() + \"/\" + iface.getIfOperStatus());\n                    log().debug(\"Current status Admin/Oper: \" + miface.getAdminstatus() + \"/\" + miface.getOperstatus());\n                    \n                    if (firstrun) {\n                        // If the interface is Admin Up, and the interface is Operational Down, we generate an alarm\n                        // if no alarm exist in alarm table.\n                        if ( miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP\n                          && miface.getOperstatus() == SnmpMinimalPollInterface.IF_DOWN \n                          && !hasOperDownAlarm(miface.getIfindex())) {\n                                sendOperDownEvent(iface);\n                        } \n                        \n                        // If the interface is Admin Up, and the interface is Operational Up, we generate a clean alarm\n                        // if exist an alarm in alarm table\n                        if ( miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP\n                                && miface.getOperstatus() == SnmpMinimalPollInterface.IF_UP \n                                && hasOperDownAlarm(miface.getIfindex())) {\n                                      sendOperUpEvent(iface);\n                        } \n                        \n                        \n                        if (!suppressAdminDownEvent() && miface.getAdminstatus() == SnmpMinimalPollInterface.IF_DOWN \n                                && ! hasAdminDownAlarm(miface.getIfindex())) {\n                                sendAdminDownEvent(iface);\n                        }\n\n                        if (!suppressAdminDownEvent() && miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP \n                                && hasAdminDownAlarm(miface.getIfindex())) {\n                                sendAdminUpEvent(iface);\n                        }\n\n                    } // end firstrun\n                    \n                    if (iface.getIfAdminStatus() != miface.getAdminstatus()) {\n                        changed = true;\n                        iface.setIfAdminStatus(new Integer(miface.getAdminstatus()));\n                        // We create event if and only if status changes from first run\n                        // and suppressAdminDownEvent is false\n                        if (!firstrun && !suppressAdminDownEvent()) {\n                            if (miface.getAdminstatus() == SnmpMinimalPollInterface.IF_DOWN)\n                                sendAdminDownEvent(iface);\n                            if (miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP)\n                                sendAdminUpEvent(iface);\n                        }\n                    }\n                                        \n                    if (iface.getIfOperStatus() != miface.getOperstatus()) {\n                        changed = true;\n                        iface.setIfOperStatus(new Integer(miface.getOperstatus()));\n                        // We create event if and only if status changes from first run\n                        // and the interface is administratevely up\n                        if (!firstrun && (miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP)) {\n                            if (miface.getOperstatus() == SnmpMinimalPollInterface.IF_DOWN)\n                                sendOperDownEvent(iface);\n                            if (miface.getOperstatus() == SnmpMinimalPollInterface.IF_UP)\n                                sendOperUpEvent(iface);\n                        }\n                    }\n                    \n                    //Admin status management\n                    log().debug(\"Interface changed = \" + changed);\n                    \n                    // Save Data to Database\n                    if (changed) {\n                        update(iface);\n                    }\n                } else {\n                    log().warn(\"run: \" + getContext().getServiceName() + \" not available, doing nothing.....\");\n                } //End if status OK\n            } //end while on interface\n        } else {\n            log().error(\"the monitor return null object\");\n        } //end If not null\n\n    }","commit_id":"5d5aba8b8985f8aef9e036ed4d683446d1716d2f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private SnmpMinimalPollInterface getMinimalFromOnmsSnmpInterface(OnmsSnmpInterface iface) {\n        return new SnmpMinimalPollInterface(iface.getIfIndex().intValue(),iface.getIfAdminStatus().intValue(), iface.getIfOperStatus().intValue());\n    }","id":49134,"modified_method":"private SnmpMinimalPollInterface getMinimalFromOnmsSnmpInterface(OnmsSnmpInterface iface) {\n        int adminStatus = SnmpMinimalPollInterface.IF_UP;\n        int operStatus = SnmpMinimalPollInterface.IF_UP;\n        if (iface.getIfAdminStatus() != null) {\n            adminStatus = iface.getIfAdminStatus().intValue();\n        } else {\n            iface.setIfAdminStatus(SnmpMinimalPollInterface.IF_UNKNOWN);\n        }\n        if (iface.getIfOperStatus() != null) {\n            operStatus = iface.getIfOperStatus().intValue();\n        } else {\n            iface.setIfOperStatus(SnmpMinimalPollInterface.IF_UNKNOWN);\n        }\n        \n        return new SnmpMinimalPollInterface(iface.getIfIndex().intValue(),adminStatus, operStatus);\n    }","commit_id":"5d5aba8b8985f8aef9e036ed4d683446d1716d2f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void deleteExistingSnmpPollAlarms() {\n        String sql = \"delete from alarms where eventuei like 'uei.opennms.org/nodes/snmp/interface%'\";\n        Updater updater = new Updater(m_dataSource, sql);\n        updater.execute();\n    }","id":49135,"modified_method":"protected void selectExistingSnmpPollAlarms() {\n        m_nodeAlarmStatusMap = new HashMap<Integer, Map<Integer,AlarmStatus>>();\n        String sql = \"select nodeid, ifindex, eventuei from alarms where eventuei like 'uei.opennms.org/nodes/snmp/interface%'\";\n        Querier querier = new Querier(m_dataSource, sql) {\n\n            public void processRow(ResultSet rs) throws SQLException {\n                   setAlarmStatus(rs.getInt(\"nodeid\"), rs.getInt(\"ifindex\"), rs.getString(\"eventuei\"));\n            }\n       \n        };\n       querier.execute();  \n    }","commit_id":"5d5aba8b8985f8aef9e036ed4d683446d1716d2f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    protected void onInit() {\n        \n        // reset the alarm table\n        //\n        try {\n            log().debug(\"start: Deleting snmppoll alarms from alarm table\");\n\n            deleteExistingSnmpPollAlarms();\n        } catch (Exception sqlE) {\n            log().error(\"start: Failed to delete existing snmppoll alarms\", sqlE);\n        }\n        createScheduler();\n        \n        // Schedule the interfaces currently in the database\n        //\n        try {\n            log().debug(\"start: Scheduling existing snmp interfaces polling\");\n\n            scheduleExistingSnmpInterface();\n        } catch (Exception sqlE) {\n            log().error(\"start: Failed to schedule existing interfaces\", sqlE);\n        }\n\n        // Create an event receiver. The receiver will\n        // receive events, process them, creates network\n        // interfaces, and schedulers them.\n        //\n        try {\n            log().debug(\"start: Creating event broadcast event processor\");\n\n            setEventProcessor(new SnmpInterfacePollerEventProcessor(this));\n        } catch (Throwable t) {\n            log().fatal(\"start: Failed to initialized the broadcast event receiver\", t);\n\n            throw new UndeclaredThrowableException(t);\n        }\n\n        m_initialized = true;\n        \n    }","id":49136,"modified_method":"@Override\n    protected void onInit() {\n        \n        // reset the alarm table\n        //\n        \n        try {\n            log().debug(\"start: select snmppoll alarms from alarm table\");\n\n            selectExistingSnmpPollAlarms();\n        } catch (Exception sqlE) {\n            log().error(\"start: Failed to delete existing snmppoll alarms\", sqlE);\n        }\n        createScheduler();\n        \n        // Schedule the interfaces currently in the database\n        //\n        try {\n            log().debug(\"start: Scheduling existing snmp interfaces polling\");\n\n            scheduleExistingSnmpInterface();\n        } catch (Exception sqlE) {\n            log().error(\"start: Failed to schedule existing interfaces\", sqlE);\n        }\n\n        // Create an event receiver. The receiver will\n        // receive events, process them, creates network\n        // interfaces, and schedulers them.\n        //\n        try {\n            log().debug(\"start: Creating event broadcast event processor\");\n\n            setEventProcessor(new SnmpInterfacePollerEventProcessor(this));\n        } catch (Throwable t) {\n            log().fatal(\"start: Failed to initialized the broadcast event receiver\", t);\n\n            throw new UndeclaredThrowableException(t);\n        }\n\n        m_initialized = true;\n        \n    }","commit_id":"5d5aba8b8985f8aef9e036ed4d683446d1716d2f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void scheduleSnmpCollection(PollableSnmpInterface node, String criteria, long interval) {\n        criteria = criteria + \" and nodeid = \" + node.getParent().getNodeid();\n        node.setSnmpinterfaces(getQueryManager().getSnmpInterfaces(criteria));\n        PollableSnmpInterfaceConfig nodeconfig = new PollableSnmpInterfaceConfig(getScheduler(),interval);\n\n        node.setSnmppollableconfig(nodeconfig);\n\n        synchronized(node) {\n            if (node.getSchedule() == null) {\n                log().debug(\"Scheduling node: \" + node.getParent().getIpaddress());\n                Schedule schedule = new Schedule(node, nodeconfig, getScheduler());\n                node.setSchedule(schedule);\n            }\n        }\n        \n        node.schedule();\n    }","id":49137,"modified_method":"private void scheduleSnmpCollection(PollableSnmpInterface node, String criteria, long interval) {\n        criteria = criteria + \" and nodeid = \" + node.getParent().getNodeid();\n        List<OnmsSnmpInterface> snmpinterfacelist = getQueryManager().getSnmpInterfaces(criteria);\n        if (snmpinterfacelist !=  null && snmpinterfacelist.size() > 0) {\n            node.setSnmpinterfaces(snmpinterfacelist);\n            if (m_nodeAlarmStatusMap.containsKey(node.getParent().getNodeid()))\n                node.setAlarmStatus(m_nodeAlarmStatusMap.get(node.getParent().getNodeid()));\n            else \n                node.setAlarmStatus(new HashMap<Integer,AlarmStatus>());\n            \n            PollableSnmpInterfaceConfig nodeconfig = new PollableSnmpInterfaceConfig(getScheduler(),interval);\n\n            node.setSnmppollableconfig(nodeconfig);\n\n            synchronized(node) {\n                if (node.getSchedule() == null) {\n                    log().debug(\"Scheduling node: \" + node.getParent().getIpaddress());\n                    Schedule schedule = new Schedule(node, nodeconfig, getScheduler());\n                    node.setSchedule(schedule);\n                }\n            }\n        \n            node.schedule();\n        } else {\n            log().info(\"no interface found for node/criteria:\" + node.getParent().getNodeid() + \"/\" + criteria);\n        }\n    }","commit_id":"5d5aba8b8985f8aef9e036ed4d683446d1716d2f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void run() {        \n        if (getParent().polling()) {\n            log().warn(\"run: polling snmp interfaces on package/interface \" + getParent().getPackageName()+ \"/\" + getName() + \"on primary address: \" + getParent().getIpaddress());\n            log().debug(\"run: polling snmp interfaces first run = \" + firstrun);\n            if (m_snmpinterfaces == null || m_snmpinterfaces.isEmpty()) {\n                log().info(\"No Interface found. Doing nothing\");\n            } else {\n                log().info(m_snmpinterfaces.size() + \" Interfaces found. Getting Statutes....\");\n            \tSnmpPollInterfaceMonitor pollMonitor = new SnmpPollInterfaceMonitor();\n        \t\tint maxiface = getMaxInterfacePerPdu();\n        \t\tif (maxiface == 0) maxiface=m_snmpinterfaces.size();\n        \t\tlog().debug(\"Max Interface Per Pdu is: \" + maxiface);\n        \t\tList<SnmpMinimalPollInterface> mifaces = getSnmpMinimalPollInterface();\n        \t\tint start =0;\n        \t\twhile (start + maxiface< m_snmpinterfaces.size()) {\n            \t\tdoPoll(pollMonitor,mifaces.subList(start, start+maxiface));\n            \t\tstart += maxiface;\n        \t\t}\n        \t\tdoPoll(pollMonitor,mifaces.subList(start, m_snmpinterfaces.size()));\n            }\n            \n        }  else {\n            log().info(\"not polling: \" + getParent().getIpaddress());\n        } // End if polling\n    }","id":49138,"modified_method":"public void run() {        \n        if (getParent().polling()) {\n            log().warn(\"run: polling snmp interfaces on package/interface \" + getParent().getPackageName()+ \"/\" + getName() + \"on primary address: \" + getParent().getIpaddress());\n            if (m_snmpinterfaces == null || m_snmpinterfaces.isEmpty()) {\n                log().info(\"No Interface found. Doing nothing\");\n            } else {\n                log().info(m_snmpinterfaces.size() + \" Interfaces found. Getting Statutes....\");\n            \tSnmpPollInterfaceMonitor pollMonitor = new SnmpPollInterfaceMonitor();\n        \t\tint maxiface = getMaxInterfacePerPdu();\n        \t\tif (maxiface == 0) maxiface=m_snmpinterfaces.size();\n        \t\tlog().debug(\"Max Interface Per Pdu is: \" + maxiface);\n        \t\tList<SnmpMinimalPollInterface> mifaces = getSnmpMinimalPollInterface();\n        \t\tint start =0;\n        \t\twhile (start + maxiface< m_snmpinterfaces.size()) {\n            \t\tdoPoll(pollMonitor,mifaces.subList(start, start+maxiface));\n            \t\tstart += maxiface;\n        \t\t}\n        \t\tdoPoll(pollMonitor,mifaces.subList(start, m_snmpinterfaces.size()));\n                firstrun=false;\n            }\n            \n        }  else {\n            log().info(\"not polling: \" + getParent().getIpaddress());\n        } // End if polling\n    }","commit_id":"4dcf82080edc9b406d1365e61699855a3308d7a1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void doPoll(SnmpPollInterfaceMonitor pollMonitor, List<SnmpMinimalPollInterface> mifaces) {\n        \n        log().info(\"doPoll: input interfaces number: \" + mifaces.size());\n    \t\n        mifaces = pollMonitor.poll(getAgentConfig(), mifaces);\n        \n        if (mifaces != null) {\n            log().info(\"doPoll: PollerMonitor return interfaces number: \" + mifaces.size());\n            Iterator<SnmpMinimalPollInterface> ite = mifaces.iterator();\n            while (ite.hasNext()) {\n                SnmpMinimalPollInterface miface = ite.next();\n                log().debug(\"Working on interface with ifindex: \" + miface.getIfindex());\n                log().debug(\"Interface PollStatus is \" + miface.getStatus().getStatusName());\n                if (miface.getStatus().isUp()) {\n                    OnmsSnmpInterface iface = m_snmpinterfaces.get(new Integer(miface.getIfindex()));\n                    boolean changed = false;\n                    log().debug(\"Previuos status Admin/Oper: \" + iface.getIfAdminStatus() + \"/\" + iface.getIfOperStatus());\n                    log().debug(\"Current status Admin/Oper: \" + miface.getAdminstatus() + \"/\" + miface.getOperstatus());\n                    \n                    \n                    // first run send all down events if suppressAdminDownEvent is false otherwise\n                    // send all down events only for interface whose admin status is up\n                    if (suppressAdminDownEvent()) {\n                        if (firstrun && miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP && miface.getOperstatus() == SnmpMinimalPollInterface.IF_DOWN)\n                    \t\tsendOperDownEvent(iface);\n                    } else {\n                        if (firstrun && miface.getAdminstatus() == SnmpMinimalPollInterface.IF_DOWN) sendAdminDownEvent(iface);\n                        if (firstrun && miface.getOperstatus() == SnmpMinimalPollInterface.IF_DOWN) sendOperDownEvent(iface);\n                    }\n                    // OperStatus management\n                    if (iface.getIfOperStatus() != miface.getOperstatus()) {\n                        changed = true;\n                        iface.setIfOperStatus(new Integer(miface.getOperstatus()));\n                        if (!firstrun) {\n                            if (miface.getOperstatus() == SnmpMinimalPollInterface.IF_DOWN) {\n                                sendOperDownEvent(iface);\n                            }   \n                            if (miface.getOperstatus() == SnmpMinimalPollInterface.IF_UP) {\n                                sendOperUpEvent(iface);\n                            }   \n                        }\n                    }\n                    \n                    //Admin status management\n                    if (iface.getIfAdminStatus() != miface.getAdminstatus()) {\n                        changed = true;\n                        iface.setIfAdminStatus(new Integer(miface.getAdminstatus()));\n                        if (!firstrun) {\n                            if (miface.getAdminstatus() == SnmpMinimalPollInterface.IF_DOWN) {\n                                sendAdminDownEvent(iface);\n                            }   \n                            if (miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP) {\n                                sendAdminUpEvent(iface);\n                            }   \n                        }\n                    }\n                    log().debug(\"Interface changed = \" + changed);\n                    \n                    // Save Data to Database\n                    if (changed) {\n                        update(iface);\n                    }\n                } else {\n                    log().warn(\"run: \" + getContext().getServiceName() + \" not available, doing nothing.....\");\n                } //End if status OK\n            } //end while on interface\n            firstrun=false;\n        } else {\n            log().error(\"the monitor return null object\");\n        } //end If not null\n\n    }","id":49139,"modified_method":"private void doPoll(SnmpPollInterfaceMonitor pollMonitor, List<SnmpMinimalPollInterface> mifaces) {\n        \n        log().info(\"doPoll: input interfaces number: \" + mifaces.size());\n    \t\n        mifaces = pollMonitor.poll(getAgentConfig(), mifaces);\n        \n        if (mifaces != null) {\n            log().info(\"doPoll: PollerMonitor return interfaces number: \" + mifaces.size());\n            Iterator<SnmpMinimalPollInterface> ite = mifaces.iterator();\n            while (ite.hasNext()) {\n                SnmpMinimalPollInterface miface = ite.next();\n                log().debug(\"Working on interface with ifindex: \" + miface.getIfindex());\n                log().debug(\"Interface PollStatus is \" + miface.getStatus().getStatusName());\n                if (miface.getStatus().isUp()) {\n                    OnmsSnmpInterface iface = m_snmpinterfaces.get(new Integer(miface.getIfindex()));\n                    boolean changed = false;\n                    log().debug(\"Previuos status Admin/Oper: \" + iface.getIfAdminStatus() + \"/\" + iface.getIfOperStatus());\n                    log().debug(\"Current status Admin/Oper: \" + miface.getAdminstatus() + \"/\" + miface.getOperstatus());\n                    \n                    if (firstrun) {\n                        // If the interface is Admin Up, and the interface is Operational Down, we generate an alarm\n                        // if no alarm exist in alarm table.\n                        if ( miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP\n                          && miface.getOperstatus() == SnmpMinimalPollInterface.IF_DOWN \n                          && !hasOperDownAlarm(miface.getIfindex())) {\n                                sendOperDownEvent(iface);\n                        } \n                        \n                        // If the interface is Admin Up, and the interface is Operational Up, we generate a clean alarm\n                        // if exist an alarm in alarm table\n                        if ( miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP\n                                && miface.getOperstatus() == SnmpMinimalPollInterface.IF_UP \n                                && hasOperDownAlarm(miface.getIfindex())) {\n                                      sendOperUpEvent(iface);\n                        } \n                        \n                        \n                        if (!suppressAdminDownEvent() && miface.getAdminstatus() == SnmpMinimalPollInterface.IF_DOWN \n                                && ! hasAdminDownAlarm(miface.getIfindex())) {\n                                sendAdminDownEvent(iface);\n                        }\n\n                        if (!suppressAdminDownEvent() && miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP \n                                && hasAdminDownAlarm(miface.getIfindex())) {\n                                sendAdminUpEvent(iface);\n                        }\n\n                    } // end firstrun\n                    \n                    if (iface.getIfAdminStatus() != miface.getAdminstatus()) {\n                        changed = true;\n                        iface.setIfAdminStatus(new Integer(miface.getAdminstatus()));\n                        // We create event if and only if status changes from first run\n                        // and suppressAdminDownEvent is false\n                        if (!firstrun && !suppressAdminDownEvent()) {\n                            if (miface.getAdminstatus() == SnmpMinimalPollInterface.IF_DOWN)\n                                sendAdminDownEvent(iface);\n                            if (miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP)\n                                sendAdminUpEvent(iface);\n                        }\n                    }\n                                        \n                    if (iface.getIfOperStatus() != miface.getOperstatus()) {\n                        changed = true;\n                        iface.setIfOperStatus(new Integer(miface.getOperstatus()));\n                        // We create event if and only if status changes from first run\n                        // and the interface is administratevely up\n                        if (!firstrun && (miface.getAdminstatus() == SnmpMinimalPollInterface.IF_UP)) {\n                            if (miface.getOperstatus() == SnmpMinimalPollInterface.IF_DOWN)\n                                sendOperDownEvent(iface);\n                            if (miface.getOperstatus() == SnmpMinimalPollInterface.IF_UP)\n                                sendOperUpEvent(iface);\n                        }\n                    }\n                    \n                    //Admin status management\n                    log().debug(\"Interface changed = \" + changed);\n                    \n                    // Save Data to Database\n                    if (changed) {\n                        update(iface);\n                    }\n                } else {\n                    log().warn(\"run: \" + getContext().getServiceName() + \" not available, doing nothing.....\");\n                } //End if status OK\n            } //end while on interface\n        } else {\n            log().error(\"the monitor return null object\");\n        } //end If not null\n\n    }","commit_id":"4dcf82080edc9b406d1365e61699855a3308d7a1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private SnmpMinimalPollInterface getMinimalFromOnmsSnmpInterface(OnmsSnmpInterface iface) {\n        return new SnmpMinimalPollInterface(iface.getIfIndex().intValue(),iface.getIfAdminStatus().intValue(), iface.getIfOperStatus().intValue());\n    }","id":49140,"modified_method":"private SnmpMinimalPollInterface getMinimalFromOnmsSnmpInterface(OnmsSnmpInterface iface) {\n        int adminStatus = SnmpMinimalPollInterface.IF_UP;\n        int operStatus = SnmpMinimalPollInterface.IF_UP;\n        if (iface.getIfAdminStatus() != null) {\n            adminStatus = iface.getIfAdminStatus().intValue();\n        } else {\n            iface.setIfAdminStatus(SnmpMinimalPollInterface.IF_UNKNOWN);\n        }\n        if (iface.getIfOperStatus() != null) {\n            operStatus = iface.getIfOperStatus().intValue();\n        } else {\n            iface.setIfOperStatus(SnmpMinimalPollInterface.IF_UNKNOWN);\n        }\n        \n        return new SnmpMinimalPollInterface(iface.getIfIndex().intValue(),adminStatus, operStatus);\n    }","commit_id":"4dcf82080edc9b406d1365e61699855a3308d7a1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void scheduleSnmpCollection(PollableSnmpInterface node, String criteria, long interval) {\n        criteria = criteria + \" and nodeid = \" + node.getParent().getNodeid();\n        node.setSnmpinterfaces(getQueryManager().getSnmpInterfaces(criteria));\n        PollableSnmpInterfaceConfig nodeconfig = new PollableSnmpInterfaceConfig(getScheduler(),interval);\n\n        node.setSnmppollableconfig(nodeconfig);\n\n        synchronized(node) {\n            if (node.getSchedule() == null) {\n                log().debug(\"Scheduling node: \" + node.getParent().getIpaddress());\n                Schedule schedule = new Schedule(node, nodeconfig, getScheduler());\n                node.setSchedule(schedule);\n            }\n        }\n        \n        node.schedule();\n    }","id":49141,"modified_method":"private void scheduleSnmpCollection(PollableSnmpInterface node, String criteria, long interval) {\n        criteria = criteria + \" and nodeid = \" + node.getParent().getNodeid();\n        List<OnmsSnmpInterface> snmpinterfacelist = getQueryManager().getSnmpInterfaces(criteria);\n        if (snmpinterfacelist !=  null && snmpinterfacelist.size() > 0) {\n            node.setSnmpinterfaces(snmpinterfacelist);\n            if (m_nodeAlarmStatusMap.containsKey(node.getParent().getNodeid()))\n                node.setAlarmStatus(m_nodeAlarmStatusMap.get(node.getParent().getNodeid()));\n            else \n                node.setAlarmStatus(new HashMap<Integer,AlarmStatus>());\n            \n            PollableSnmpInterfaceConfig nodeconfig = new PollableSnmpInterfaceConfig(getScheduler(),interval);\n\n            node.setSnmppollableconfig(nodeconfig);\n\n            synchronized(node) {\n                if (node.getSchedule() == null) {\n                    log().debug(\"Scheduling node: \" + node.getParent().getIpaddress());\n                    Schedule schedule = new Schedule(node, nodeconfig, getScheduler());\n                    node.setSchedule(schedule);\n                }\n            }\n        \n            node.schedule();\n        } else {\n            log().info(\"no interface found for node/criteria:\" + node.getParent().getNodeid() + \"/\" + criteria);\n        }\n    }","commit_id":"4dcf82080edc9b406d1365e61699855a3308d7a1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void deleteExistingSnmpPollAlarms() {\n        String sql = \"delete from alarms where eventuei like 'uei.opennms.org/nodes/snmp/interface%'\";\n        Updater updater = new Updater(m_dataSource, sql);\n        updater.execute();\n    }","id":49142,"modified_method":"protected void selectExistingSnmpPollAlarms() {\n        m_nodeAlarmStatusMap = new HashMap<Integer, Map<Integer,AlarmStatus>>();\n        String sql = \"select nodeid, ifindex, eventuei from alarms where eventuei like 'uei.opennms.org/nodes/snmp/interface%'\";\n        Querier querier = new Querier(m_dataSource, sql) {\n\n            public void processRow(ResultSet rs) throws SQLException {\n                   setAlarmStatus(rs.getInt(\"nodeid\"), rs.getInt(\"ifindex\"), rs.getString(\"eventuei\"));\n            }\n       \n        };\n       querier.execute();  \n    }","commit_id":"4dcf82080edc9b406d1365e61699855a3308d7a1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    protected void onInit() {\n        \n        // reset the alarm table\n        //\n        try {\n            log().debug(\"start: Deleting snmppoll alarms from alarm table\");\n\n            deleteExistingSnmpPollAlarms();\n        } catch (Exception sqlE) {\n            log().error(\"start: Failed to delete existing snmppoll alarms\", sqlE);\n        }\n        createScheduler();\n        \n        // Schedule the interfaces currently in the database\n        //\n        try {\n            log().debug(\"start: Scheduling existing snmp interfaces polling\");\n\n            scheduleExistingSnmpInterface();\n        } catch (Exception sqlE) {\n            log().error(\"start: Failed to schedule existing interfaces\", sqlE);\n        }\n\n        // Create an event receiver. The receiver will\n        // receive events, process them, creates network\n        // interfaces, and schedulers them.\n        //\n        try {\n            log().debug(\"start: Creating event broadcast event processor\");\n\n            setEventProcessor(new SnmpInterfacePollerEventProcessor(this));\n        } catch (Throwable t) {\n            log().fatal(\"start: Failed to initialized the broadcast event receiver\", t);\n\n            throw new UndeclaredThrowableException(t);\n        }\n\n        m_initialized = true;\n        \n    }","id":49143,"modified_method":"@Override\n    protected void onInit() {\n        \n        // reset the alarm table\n        //\n        \n        try {\n            log().debug(\"start: select snmppoll alarms from alarm table\");\n\n            selectExistingSnmpPollAlarms();\n        } catch (Exception sqlE) {\n            log().error(\"start: Failed to delete existing snmppoll alarms\", sqlE);\n        }\n        createScheduler();\n        \n        // Schedule the interfaces currently in the database\n        //\n        try {\n            log().debug(\"start: Scheduling existing snmp interfaces polling\");\n\n            scheduleExistingSnmpInterface();\n        } catch (Exception sqlE) {\n            log().error(\"start: Failed to schedule existing interfaces\", sqlE);\n        }\n\n        // Create an event receiver. The receiver will\n        // receive events, process them, creates network\n        // interfaces, and schedulers them.\n        //\n        try {\n            log().debug(\"start: Creating event broadcast event processor\");\n\n            setEventProcessor(new SnmpInterfacePollerEventProcessor(this));\n        } catch (Throwable t) {\n            log().fatal(\"start: Failed to initialized the broadcast event receiver\", t);\n\n            throw new UndeclaredThrowableException(t);\n        }\n\n        m_initialized = true;\n        \n    }","commit_id":"4dcf82080edc9b406d1365e61699855a3308d7a1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Clear the welcome files for the given context.\n     *\n     * @param hostName\n     * @param contextPath\n     */\n    public void clearWelcomeFiles(String hostName, String contextPath,\n            String version) {\n        MappedHost[] hosts = this.hosts;\n        int pos = find(hosts, hostName);\n        if (pos < 0) {\n            return;\n        }\n        MappedHost host = hosts[pos];\n        if (host.name.equals(hostName)) {\n            MappedContext[] contexts = host.contextList.contexts;\n            int pos2 = find(contexts, contextPath);\n            if (pos2 < 0) {\n                log.error(\"No context found: \" + contextPath );\n                return;\n            }\n            MappedContext context = contexts[pos2];\n            if (context.name.equals(contextPath)) {\n                ContextVersion[] contextVersions = context.versions;\n                int pos3 = find(contextVersions, version);\n                if( pos3<0 ) {\n                    log.error(\"No context version found: \" + contextPath + \" \" +\n                            version);\n                    return;\n                }\n                ContextVersion contextVersion = contextVersions[pos3];\n                if (contextVersion.name.equals(version)) {\n                    contextVersion.welcomeResources = new String[0];\n                }\n            }\n        }\n    }","id":49144,"modified_method":"/**\n     * Clear the welcome files for the given context.\n     *\n     * @param hostName\n     * @param contextPath\n     */\n    public void clearWelcomeFiles(String hostName, String contextPath,\n            String version) {\n        MappedHost[] hosts = this.hosts;\n        MappedHost host = exactFind(hosts, hostName);\n        if (host == null) {\n            return;\n        }\n        MappedContext[] contexts = host.contextList.contexts;\n        MappedContext context = exactFind(contexts, contextPath);\n        if (context == null) {\n            log.error(\"No context found: \" + contextPath);\n            return;\n        }\n        ContextVersion[] contextVersions = context.versions;\n        ContextVersion contextVersion = exactFind(contextVersions, version);\n        if (contextVersion == null) {\n            log.error(\"No context version found: \" + contextPath + \" \"\n                    + version);\n            return;\n        }\n        contextVersion.welcomeResources = new String[0];\n    }","commit_id":"4a333449a56163c5c66f0eaf34393e654b7547fa","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Map the specified URI.\n     */\n    private final void internalMap(CharChunk host, CharChunk uri,\n            String version, MappingData mappingData) throws Exception {\n\n        uri.setLimit(-1);\n\n        MappedContext[] contexts = null;\n        MappedContext context = null;\n        ContextVersion contextVersion = null;\n\n        int nesting = 0;\n\n        // Virtual host mapping\n        if (mappingData.host == null) {\n            MappedHost[] hosts = this.hosts;\n            int pos = findIgnoreCase(hosts, host);\n            if ((pos != -1) && (host.equalsIgnoreCase(hosts[pos].name))) {\n                mappingData.host = hosts[pos].object;\n                contexts = hosts[pos].contextList.contexts;\n                nesting = hosts[pos].contextList.nesting;\n            } else {\n                if (defaultHostName == null) {\n                    return;\n                }\n                pos = find(hosts, defaultHostName);\n                if ((pos != -1) && (defaultHostName.equals(hosts[pos].name))) {\n                    mappingData.host = hosts[pos].object;\n                    contexts = hosts[pos].contextList.contexts;\n                    nesting = hosts[pos].contextList.nesting;\n                } else {\n                    return;\n                }\n            }\n        }\n\n        // Context mapping\n        if (mappingData.context == null && contexts != null) {\n            int pos = find(contexts, uri);\n            if (pos == -1) {\n                return;\n            }\n\n            int lastSlash = -1;\n            int uriEnd = uri.getEnd();\n            int length = -1;\n            boolean found = false;\n            while (pos >= 0) {\n                if (uri.startsWith(contexts[pos].name)) {\n                    length = contexts[pos].name.length();\n                    if (uri.getLength() == length) {\n                        found = true;\n                        break;\n                    } else if (uri.startsWithIgnoreCase(\"/\", length)) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (lastSlash == -1) {\n                    lastSlash = nthSlash(uri, nesting + 1);\n                } else {\n                    lastSlash = lastSlash(uri);\n                }\n                uri.setEnd(lastSlash);\n                pos = find(contexts, uri);\n            }\n            uri.setEnd(uriEnd);\n\n            if (!found) {\n                if (contexts[0].name.equals(\"\")) {\n                    context = contexts[0];\n                }\n            } else {\n                context = contexts[pos];\n            }\n            if (context != null) {\n                mappingData.contextPath.setString(context.name);\n            }\n        }\n\n        if (context != null) {\n            ContextVersion[] contextVersions = context.versions;\n            int versionCount = contextVersions.length;\n            if (versionCount > 1) {\n                Context[] contextObjects = new Context[contextVersions.length];\n                for (int i = 0; i < contextObjects.length; i++) {\n                    contextObjects[i] = contextVersions[i].object;\n                }\n                mappingData.contexts = contextObjects;\n            }\n\n            if (version == null) {\n                // Return the latest version\n                contextVersion = contextVersions[versionCount - 1];\n            } else {\n                int pos = find(contextVersions, version);\n                if (pos < 0 || !contextVersions[pos].name.equals(version)) {\n                    // Return the latest version\n                    contextVersion = contextVersions[versionCount - 1];\n                } else {\n                    contextVersion = contextVersions[pos];\n                }\n            }\n            mappingData.context = contextVersion.object;\n            mappingData.contextSlashCount = contextVersion.slashCount;\n        }\n\n        // Wrapper mapping\n        if ((contextVersion != null) && (mappingData.wrapper == null)) {\n            internalMapWrapper(contextVersion, uri, mappingData);\n        }\n\n    }","id":49145,"modified_method":"/**\n     * Map the specified URI.\n     */\n    private final void internalMap(CharChunk host, CharChunk uri,\n            String version, MappingData mappingData) throws Exception {\n\n        uri.setLimit(-1);\n\n        MappedContext[] contexts = null;\n        MappedContext context = null;\n        ContextVersion contextVersion = null;\n\n        int nesting = 0;\n\n        // Virtual host mapping\n        if (mappingData.host == null) {\n            MappedHost[] hosts = this.hosts;\n            MappedHost mappedHost = exactFindIgnoreCase(hosts, host);\n            if (mappedHost == null) {\n                if (defaultHostName == null) {\n                    return;\n                }\n                mappedHost = exactFind(hosts, defaultHostName);\n                if (mappedHost == null) {\n                    return;\n                }\n            }\n            mappingData.host = mappedHost.object;\n            contexts = mappedHost.contextList.contexts;\n            nesting = mappedHost.contextList.nesting;\n        }\n\n        // Context mapping\n        if (mappingData.context == null && contexts != null) {\n            int pos = find(contexts, uri);\n            if (pos == -1) {\n                return;\n            }\n\n            int lastSlash = -1;\n            int uriEnd = uri.getEnd();\n            int length = -1;\n            boolean found = false;\n            while (pos >= 0) {\n                if (uri.startsWith(contexts[pos].name)) {\n                    length = contexts[pos].name.length();\n                    if (uri.getLength() == length) {\n                        found = true;\n                        break;\n                    } else if (uri.startsWithIgnoreCase(\"/\", length)) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (lastSlash == -1) {\n                    lastSlash = nthSlash(uri, nesting + 1);\n                } else {\n                    lastSlash = lastSlash(uri);\n                }\n                uri.setEnd(lastSlash);\n                pos = find(contexts, uri);\n            }\n            uri.setEnd(uriEnd);\n\n            if (found) {\n                context = contexts[pos];\n            } else if (contexts[0].name.equals(\"\")) {\n                context = contexts[0];\n            }\n\n            if (context != null) {\n                mappingData.contextPath.setString(context.name);\n            }\n        }\n\n        if (context != null) {\n            ContextVersion[] contextVersions = context.versions;\n            int versionCount = contextVersions.length;\n            if (versionCount > 1) {\n                Context[] contextObjects = new Context[contextVersions.length];\n                for (int i = 0; i < contextObjects.length; i++) {\n                    contextObjects[i] = contextVersions[i].object;\n                }\n                mappingData.contexts = contextObjects;\n            }\n\n            if (version != null) {\n                contextVersion = exactFind(contextVersions, version);\n            }\n            if (contextVersion == null) {\n                // Return the latest version\n                contextVersion = contextVersions[versionCount - 1];\n            }\n            mappingData.context = contextVersion.object;\n            mappingData.contextSlashCount = contextVersion.slashCount;\n        }\n\n        // Wrapper mapping\n        if ((contextVersion != null) && (mappingData.wrapper == null)) {\n            internalMapWrapper(contextVersion, uri, mappingData);\n        }\n\n    }","commit_id":"4a333449a56163c5c66f0eaf34393e654b7547fa","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Add a new host to the mapper.\n     *\n     * @param name Virtual host name\n     * @param host Host object\n     */\n    public synchronized void addHost(String name, String[] aliases,\n                                     Host host) {\n        MappedHost[] newHosts = new MappedHost[hosts.length + 1];\n        MappedHost newHost = new MappedHost();\n        ContextList contextList = new ContextList();\n        newHost.name = name;\n        newHost.contextList = contextList;\n        newHost.object = host;\n        if (insertMap(hosts, newHosts, newHost)) {\n            hosts = newHosts;\n        }\n        for (int i = 0; i < aliases.length; i++) {\n            newHosts = new MappedHost[hosts.length + 1];\n            newHost = new MappedHost();\n            newHost.name = aliases[i];\n            newHost.contextList = contextList;\n            newHost.object = host;\n            if (insertMap(hosts, newHosts, newHost)) {\n                hosts = newHosts;\n            }\n        }\n    }","id":49146,"modified_method":"/**\n     * Add a new host to the mapper.\n     *\n     * @param name Virtual host name\n     * @param host Host object\n     */\n    public synchronized void addHost(String name, String[] aliases,\n                                     Host host) {\n        MappedHost[] newHosts = new MappedHost[hosts.length + 1];\n        MappedHost newHost = new MappedHost();\n        ContextList contextList = new ContextList();\n        newHost.name = name;\n        newHost.contextList = contextList;\n        newHost.object = host;\n        if (insertMap(hosts, newHosts, newHost)) {\n            hosts = newHosts;\n        } else {\n            MappedHost duplicate = hosts[find(hosts, name)];\n            String duplicateHostName = duplicate.object.getName();\n            log.error(sm.getString(\"mapper.duplicateHost\", name,\n                    duplicateHostName));\n            // Do not add aliases, as removeHost(hostName) won't be able to remove them\n            return;\n        }\n        for (String alias : aliases) {\n            addHostAliasImpl(newHost, alias);\n        }\n    }","commit_id":"4a333449a56163c5c66f0eaf34393e654b7547fa","url":"https://github.com/apache/tomcat"},{"original_method":"public void addWrapper(String hostName, String contextPath, String version,\n                           String path, Wrapper wrapper, boolean jspWildCard,\n                           boolean resourceOnly) {\n        MappedHost[] hosts = this.hosts;\n        int pos = find(hosts, hostName);\n        if (pos < 0) {\n            return;\n        }\n        MappedHost host = hosts[pos];\n        if (host.name.equals(hostName)) {\n            MappedContext[] contexts = host.contextList.contexts;\n            int pos2 = find(contexts, contextPath);\n            if (pos2 < 0) {\n                log.error(\"No context found: \" + contextPath );\n                return;\n            }\n            MappedContext context = contexts[pos2];\n            if (context.name.equals(contextPath)) {\n                ContextVersion[] contextVersions = context.versions;\n                int pos3 = find(contextVersions, version);\n                if( pos3<0 ) {\n                    log.error(\"No context version found: \" + contextPath + \" \" +\n                            version);\n                    return;\n                }\n                ContextVersion contextVersion = contextVersions[pos3];\n                if (contextVersion.name.equals(version)) {\n                    addWrapper(contextVersion, path, wrapper, jspWildCard,\n                            resourceOnly);\n                }\n            }\n        }\n    }","id":49147,"modified_method":"public void addWrapper(String hostName, String contextPath, String version,\n                           String path, Wrapper wrapper, boolean jspWildCard,\n                           boolean resourceOnly) {\n        MappedHost[] hosts = this.hosts;\n        MappedHost host = exactFind(hosts, hostName);\n        if (host == null) {\n            return;\n        }\n        MappedContext[] contexts = host.contextList.contexts;\n        MappedContext context = exactFind(contexts, contextPath);\n        if (context == null) {\n            log.error(\"No context found: \" + contextPath );\n            return;\n        }\n        ContextVersion[] contextVersions = context.versions;\n        ContextVersion contextVersion = exactFind(contextVersions, version);\n        if (contextVersion == null) {\n            log.error(\"No context version found: \" + contextPath + \" \" +\n                    version);\n            return;\n        }\n        addWrapper(contextVersion, path, wrapper, jspWildCard, resourceOnly);\n    }","commit_id":"4a333449a56163c5c66f0eaf34393e654b7547fa","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Add a new Context to an existing Host.\n     *\n     * @param hostName Virtual host name this context belongs to\n     * @param host Host object\n     * @param path Context path\n     * @param version Context version\n     * @param context Context object\n     * @param welcomeResources Welcome files defined for this context\n     * @param resources Static resources of the context\n     */\n    public void addContextVersion(String hostName, Host host, String path,\n            String version, Context context, String[] welcomeResources,\n            WebResourceRoot resources) {\n\n        MappedHost[] hosts = this.hosts;\n        int pos = find(hosts, hostName);\n        if( pos <0 ) {\n            addHost(hostName, new String[0], host);\n            hosts = this.hosts;\n            pos = find(hosts, hostName);\n        }\n        if (pos < 0) {\n            log.error(\"No host found: \" + hostName);\n        }\n        MappedHost mappedHost = hosts[pos];\n        if (mappedHost.name.equals(hostName)) {\n            int slashCount = slashCount(path);\n            synchronized (mappedHost) {\n                MappedContext[] contexts = mappedHost.contextList.contexts;\n                // Update nesting\n                if (slashCount > mappedHost.contextList.nesting) {\n                    mappedHost.contextList.nesting = slashCount;\n                }\n                int pos2 = find(contexts, path);\n                if (pos2 < 0 || !path.equals(contexts[pos2].name)) {\n                    MappedContext newContext = new MappedContext();\n                    newContext.name = path;\n                    MappedContext[] newContexts = new MappedContext[contexts.length + 1];\n                    if (insertMap(contexts, newContexts, newContext)) {\n                        mappedHost.contextList.contexts = newContexts;\n                    }\n                    pos2 = find(newContexts, path);\n                }\n\n                MappedContext mappedContext = mappedHost.contextList.contexts[pos2];\n\n                ContextVersion[] contextVersions = mappedContext.versions;\n                ContextVersion[] newContextVersions =\n                    new ContextVersion[contextVersions.length + 1];\n                ContextVersion newContextVersion = new ContextVersion();\n                newContextVersion.path = path;\n                newContextVersion.slashCount = slashCount;\n                newContextVersion.name = version;\n                newContextVersion.object = context;\n                newContextVersion.welcomeResources = welcomeResources;\n                newContextVersion.resources = resources;\n                if (insertMap(contextVersions, newContextVersions, newContextVersion)) {\n                    mappedContext.versions = newContextVersions;\n                    contextObjectToContextVersionMap.put(\n                            context, newContextVersion);\n                }\n            }\n        }\n\n    }","id":49148,"modified_method":"/**\n     * Add a new Context to an existing Host.\n     *\n     * @param hostName Virtual host name this context belongs to\n     * @param host Host object\n     * @param path Context path\n     * @param version Context version\n     * @param context Context object\n     * @param welcomeResources Welcome files defined for this context\n     * @param resources Static resources of the context\n     */\n    public void addContextVersion(String hostName, Host host, String path,\n            String version, Context context, String[] welcomeResources,\n            WebResourceRoot resources) {\n\n        MappedHost[] hosts = this.hosts;\n        MappedHost mappedHost = exactFind(hosts, hostName);\n        if (mappedHost == null) {\n            addHost(hostName, new String[0], host);\n            hosts = this.hosts;\n            mappedHost = exactFind(hosts, hostName);\n            if (mappedHost == null) {\n                log.error(\"No host found: \" + hostName);\n                return;\n            }\n        }\n        int slashCount = slashCount(path);\n        synchronized (mappedHost) {\n            // Update nesting\n            if (slashCount > mappedHost.contextList.nesting) {\n                mappedHost.contextList.nesting = slashCount;\n            }\n            MappedContext mappedContext;\n            {\n                MappedContext[] contexts = mappedHost.contextList.contexts;\n                mappedContext = exactFind(contexts, path);\n                if (mappedContext == null) {\n                    mappedContext = new MappedContext();\n                    mappedContext.name = path;\n                    MappedContext[] newContexts = new MappedContext[contexts.length + 1];\n                    if (insertMap(contexts, newContexts, mappedContext)) {\n                        mappedHost.contextList.contexts = newContexts;\n                        // contexts = newContexts;\n                    }\n                }\n            }\n\n            ContextVersion[] contextVersions = mappedContext.versions;\n            ContextVersion[] newContextVersions =\n                new ContextVersion[contextVersions.length + 1];\n            ContextVersion newContextVersion = new ContextVersion();\n            newContextVersion.path = path;\n            newContextVersion.slashCount = slashCount;\n            newContextVersion.name = version;\n            newContextVersion.object = context;\n            newContextVersion.welcomeResources = welcomeResources;\n            newContextVersion.resources = resources;\n            if (insertMap(contextVersions, newContextVersions, newContextVersion)) {\n                mappedContext.versions = newContextVersions;\n                contextObjectToContextVersionMap.put(\n                        context, newContextVersion);\n            }\n        }\n\n    }","commit_id":"4a333449a56163c5c66f0eaf34393e654b7547fa","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Remove a host alias\n     * @param alias The alias to remove\n     */\n    public synchronized void removeHostAlias(String alias) {\n        // Find and remove the alias\n        int pos = find(hosts, alias);\n        if (pos < 0) {\n            return;\n        }\n        MappedHost[] newHosts = new MappedHost[hosts.length - 1];\n        if (removeMap(hosts, newHosts, alias)) {\n            hosts = newHosts;\n        }\n\n    }","id":49149,"modified_method":"/**\n     * Remove a host alias\n     * @param alias The alias to remove\n     */\n    public synchronized void removeHostAlias(String alias) {\n        // Find and remove the alias\n        if (exactFind(hosts, alias) == null) {\n            return;\n        }\n        MappedHost[] newHosts = new MappedHost[hosts.length - 1];\n        if (removeMap(hosts, newHosts, alias)) {\n            hosts = newHosts;\n        }\n\n    }","commit_id":"4a333449a56163c5c66f0eaf34393e654b7547fa","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Remove a welcome file from the given context.\n     *\n     * @param hostName\n     * @param contextPath\n     * @param welcomeFile\n     */\n    public void removeWelcomeFile(String hostName, String contextPath,\n            String version, String welcomeFile) {\n        MappedHost[] hosts = this.hosts;\n        int pos = find(hosts, hostName);\n        if (pos < 0) {\n            return;\n        }\n        MappedHost host = hosts[pos];\n        if (host.name.equals(hostName)) {\n            MappedContext[] contexts = host.contextList.contexts;\n            int pos2 = find(contexts, contextPath);\n            if (pos2 < 0) {\n                log.error(\"No context found: \" + contextPath );\n                return;\n            }\n            MappedContext context = contexts[pos2];\n            if (context.name.equals(contextPath)) {\n                ContextVersion[] contextVersions = context.versions;\n                int pos3 = find(contextVersions, version);\n                if( pos3<0 ) {\n                    log.error(\"No context version found: \" + contextPath + \" \" +\n                            version);\n                    return;\n                }\n                ContextVersion contextVersion = contextVersions[pos3];\n                if (contextVersion.name.equals(version)) {\n                    int match = -1;\n                    for (int i = 0; i < contextVersion.welcomeResources.length; i++) {\n                        if (welcomeFile.equals(contextVersion.welcomeResources[i])) {\n                            match = i;\n                            break;\n                        }\n                    }\n                    if (match > -1) {\n                        int len = contextVersion.welcomeResources.length - 1;\n                        String[] newWelcomeResources = new String[len];\n                        System.arraycopy(contextVersion.welcomeResources, 0,\n                                newWelcomeResources, 0, match);\n                        if (match < len) {\n                            System.arraycopy(contextVersion.welcomeResources, match + 1,\n                                    newWelcomeResources, match, len - match);\n                        }\n                        contextVersion.welcomeResources = newWelcomeResources;\n                    }\n                }\n            }\n        }\n    }","id":49150,"modified_method":"/**\n     * Remove a welcome file from the given context.\n     *\n     * @param hostName\n     * @param contextPath\n     * @param welcomeFile\n     */\n    public void removeWelcomeFile(String hostName, String contextPath,\n            String version, String welcomeFile) {\n        MappedHost[] hosts = this.hosts;\n        MappedHost host = exactFind(hosts, hostName);\n        if (host == null) {\n            return;\n        }\n        MappedContext[] contexts = host.contextList.contexts;\n        MappedContext context = exactFind(contexts, contextPath);\n        if (context == null) {\n            log.error(\"No context found: \" + contextPath);\n            return;\n        }\n        ContextVersion[] contextVersions = context.versions;\n        ContextVersion contextVersion = exactFind(contextVersions, version);\n        if (contextVersion == null) {\n            log.error(\"No context version found: \" + contextPath + \" \"\n                    + version);\n            return;\n        }\n        int match = -1;\n        for (int i = 0; i < contextVersion.welcomeResources.length; i++) {\n            if (welcomeFile.equals(contextVersion.welcomeResources[i])) {\n                match = i;\n                break;\n            }\n        }\n        if (match > -1) {\n            int len = contextVersion.welcomeResources.length - 1;\n            String[] newWelcomeResources = new String[len];\n            System.arraycopy(contextVersion.welcomeResources, 0,\n                    newWelcomeResources, 0, match);\n            if (match < len) {\n                System.arraycopy(contextVersion.welcomeResources, match + 1,\n                        newWelcomeResources, match, len - match);\n            }\n            contextVersion.welcomeResources = newWelcomeResources;\n        }\n    }","commit_id":"4a333449a56163c5c66f0eaf34393e654b7547fa","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Remove a wrapper from an existing context.\n     *\n     * @param hostName Virtual host name this wrapper belongs to\n     * @param contextPath Context path this wrapper belongs to\n     * @param path Wrapper mapping\n     */\n    public void removeWrapper\n        (String hostName, String contextPath, String version, String path) {\n        MappedHost[] hosts = this.hosts;\n        int pos = find(hosts, hostName);\n        if (pos < 0) {\n            return;\n        }\n        MappedHost host = hosts[pos];\n        if (host.name.equals(hostName)) {\n            MappedContext[] contexts = host.contextList.contexts;\n            int pos2 = find(contexts, contextPath);\n            if (pos2 < 0) {\n                return;\n            }\n            MappedContext context = contexts[pos2];\n            if (context.name.equals(contextPath)) {\n                ContextVersion[] contextVersions = context.versions;\n                int pos3 = find(contextVersions, version);\n                if( pos3<0 ) {\n                    return;\n                }\n                ContextVersion contextVersion = contextVersions[pos3];\n                if (contextVersion.name.equals(version)) {\n                    removeWrapper(contextVersion, path);\n                }\n            }\n        }\n    }","id":49151,"modified_method":"/**\n     * Remove a wrapper from an existing context.\n     *\n     * @param hostName Virtual host name this wrapper belongs to\n     * @param contextPath Context path this wrapper belongs to\n     * @param path Wrapper mapping\n     */\n    public void removeWrapper(String hostName, String contextPath,\n            String version, String path) {\n        MappedHost[] hosts = this.hosts;\n        MappedHost host = exactFind(hosts, hostName);\n        if (host == null) {\n            return;\n        }\n        MappedContext[] contexts = host.contextList.contexts;\n        MappedContext context = exactFind(contexts, contextPath);\n        if (context == null) {\n            return;\n        }\n        ContextVersion[] contextVersions = context.versions;\n        ContextVersion contextVersion = exactFind(contextVersions, version);\n        if (contextVersion == null) {\n            return;\n        }\n        removeWrapper(contextVersion, path);\n    }","commit_id":"4a333449a56163c5c66f0eaf34393e654b7547fa","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Extension mappings.\n     *\n     * @param wrappers          Set of wrappers to check for matches\n     * @param path              Path to map\n     * @param mappingData       Mapping data for result\n     * @param resourceExpected  Is this mapping expecting to find a resource\n     */\n    private final void internalMapExtensionWrapper(MappedWrapper[] wrappers,\n            CharChunk path, MappingData mappingData, boolean resourceExpected) {\n        char[] buf = path.getBuffer();\n        int pathEnd = path.getEnd();\n        int servletPath = path.getOffset();\n        int slash = -1;\n        for (int i = pathEnd - 1; i >= servletPath; i--) {\n            if (buf[i] == '/') {\n                slash = i;\n                break;\n            }\n        }\n        if (slash >= 0) {\n            int period = -1;\n            for (int i = pathEnd - 1; i > slash; i--) {\n                if (buf[i] == '.') {\n                    period = i;\n                    break;\n                }\n            }\n            if (period >= 0) {\n                path.setOffset(period + 1);\n                path.setEnd(pathEnd);\n                int pos = find(wrappers, path);\n                if ((pos != -1) && (path.equals(wrappers[pos].name)) &&\n                        (resourceExpected || !wrappers[pos].resourceOnly)) {\n                    mappingData.wrapperPath.setChars\n                        (buf, servletPath, pathEnd - servletPath);\n                    mappingData.requestPath.setChars\n                        (buf, servletPath, pathEnd - servletPath);\n                    mappingData.wrapper = wrappers[pos].object;\n                }\n                path.setOffset(servletPath);\n                path.setEnd(pathEnd);\n            }\n        }\n    }","id":49152,"modified_method":"/**\n     * Extension mappings.\n     *\n     * @param wrappers          Set of wrappers to check for matches\n     * @param path              Path to map\n     * @param mappingData       Mapping data for result\n     * @param resourceExpected  Is this mapping expecting to find a resource\n     */\n    private final void internalMapExtensionWrapper(MappedWrapper[] wrappers,\n            CharChunk path, MappingData mappingData, boolean resourceExpected) {\n        char[] buf = path.getBuffer();\n        int pathEnd = path.getEnd();\n        int servletPath = path.getOffset();\n        int slash = -1;\n        for (int i = pathEnd - 1; i >= servletPath; i--) {\n            if (buf[i] == '/') {\n                slash = i;\n                break;\n            }\n        }\n        if (slash >= 0) {\n            int period = -1;\n            for (int i = pathEnd - 1; i > slash; i--) {\n                if (buf[i] == '.') {\n                    period = i;\n                    break;\n                }\n            }\n            if (period >= 0) {\n                path.setOffset(period + 1);\n                path.setEnd(pathEnd);\n                MappedWrapper wrapper = exactFind(wrappers, path);\n                if (wrapper != null\n                        && (resourceExpected || !wrapper.resourceOnly)) {\n                    mappingData.wrapperPath.setChars(buf, servletPath, pathEnd\n                            - servletPath);\n                    mappingData.requestPath.setChars(buf, servletPath, pathEnd\n                            - servletPath);\n                    mappingData.wrapper = wrapper.object;\n                }\n                path.setOffset(servletPath);\n                path.setEnd(pathEnd);\n            }\n        }\n    }","commit_id":"4a333449a56163c5c66f0eaf34393e654b7547fa","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Remove a context from an existing host.\n     *\n     * @param ctxt      The actual context\n     * @param hostName  Virtual host name this context belongs to\n     * @param path      Context path\n     * @param version   Context version\n     */\n    public void removeContextVersion(Context ctxt, String hostName,\n            String path, String version) {\n\n        contextObjectToContextVersionMap.remove(ctxt);\n\n        MappedHost[] hosts = this.hosts;\n        int pos = find(hosts, hostName);\n        if (pos < 0) {\n            return;\n        }\n        MappedHost host = hosts[pos];\n        if (host.name.equals(hostName)) {\n            synchronized (host) {\n                MappedContext[] contexts = host.contextList.contexts;\n                if (contexts.length == 0 ){\n                    return;\n                }\n\n                int pos2 = find(contexts, path);\n                if (pos2 < 0 || !path.equals(contexts[pos2].name)) {\n                    return;\n                }\n                MappedContext context = contexts[pos2];\n\n                ContextVersion[] contextVersions = context.versions;\n                ContextVersion[] newContextVersions =\n                    new ContextVersion[contextVersions.length - 1];\n                if (removeMap(contextVersions, newContextVersions, version)) {\n                    context.versions = newContextVersions;\n\n                    if (context.versions.length == 0) {\n                        // Remove the context\n                        MappedContext[] newContexts = new MappedContext[contexts.length -1];\n                        if (removeMap(contexts, newContexts, path)) {\n                            host.contextList.contexts = newContexts;\n                            // Recalculate nesting\n                            host.contextList.nesting = 0;\n                            for (int i = 0; i < newContexts.length; i++) {\n                                int slashCount = slashCount(newContexts[i].name);\n                                if (slashCount > host.contextList.nesting) {\n                                    host.contextList.nesting = slashCount;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","id":49153,"modified_method":"/**\n     * Remove a context from an existing host.\n     *\n     * @param ctxt      The actual context\n     * @param hostName  Virtual host name this context belongs to\n     * @param path      Context path\n     * @param version   Context version\n     */\n    public void removeContextVersion(Context ctxt, String hostName,\n            String path, String version) {\n\n        contextObjectToContextVersionMap.remove(ctxt);\n\n        MappedHost host = exactFind(this.hosts, hostName);\n        if (host == null) {\n            return;\n        }\n\n        synchronized (host) {\n            MappedContext[] contexts = host.contextList.contexts;\n            if (contexts.length == 0 ){\n                return;\n            }\n\n            MappedContext context = exactFind(contexts, path);\n            if (context == null) {\n                return;\n            }\n\n            ContextVersion[] contextVersions = context.versions;\n            ContextVersion[] newContextVersions =\n                new ContextVersion[contextVersions.length - 1];\n            if (removeMap(contextVersions, newContextVersions, version)) {\n                context.versions = newContextVersions;\n\n                if (context.versions.length == 0) {\n                    // Remove the context\n                    MappedContext[] newContexts = new MappedContext[contexts.length -1];\n                    if (removeMap(contexts, newContexts, path)) {\n                        host.contextList.contexts = newContexts;\n                        // Recalculate nesting\n                        host.contextList.nesting = 0;\n                        for (int i = 0; i < newContexts.length; i++) {\n                            int slashCount = slashCount(newContexts[i].name);\n                            if (slashCount > host.contextList.nesting) {\n                                host.contextList.nesting = slashCount;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"4a333449a56163c5c66f0eaf34393e654b7547fa","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Exact mapping.\n     */\n    private final void internalMapExactWrapper\n        (MappedWrapper[] wrappers, CharChunk path, MappingData mappingData) {\n        int pos = find(wrappers, path);\n        if ((pos != -1) && (path.equals(wrappers[pos].name))) {\n            mappingData.requestPath.setString(wrappers[pos].name);\n            mappingData.wrapper = wrappers[pos].object;\n            if (path.equals(\"/\")) {\n                // Special handling for Context Root mapped servlet\n                mappingData.pathInfo.setString(\"/\");\n                mappingData.wrapperPath.setString(\"\");\n                // This seems wrong but it is what the spec says...\n                mappingData.contextPath.setString(\"\");\n            } else {\n                mappingData.wrapperPath.setString(wrappers[pos].name);\n            }\n        }\n    }","id":49154,"modified_method":"/**\n     * Exact mapping.\n     */\n    private final void internalMapExactWrapper\n        (MappedWrapper[] wrappers, CharChunk path, MappingData mappingData) {\n        MappedWrapper wrapper = exactFind(wrappers, path);\n        if (wrapper != null) {\n            mappingData.requestPath.setString(wrapper.name);\n            mappingData.wrapper = wrapper.object;\n            if (path.equals(\"/\")) {\n                // Special handling for Context Root mapped servlet\n                mappingData.pathInfo.setString(\"/\");\n                mappingData.wrapperPath.setString(\"\");\n                // This seems wrong but it is what the spec says...\n                mappingData.contextPath.setString(\"\");\n            } else {\n                mappingData.wrapperPath.setString(wrapper.name);\n            }\n        }\n    }","commit_id":"4a333449a56163c5c66f0eaf34393e654b7547fa","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Find a map element given its name in a sorted array of map elements.\n     * This will return the index for the closest inferior or equal item in the\n     * given array.\n     */\n    private static final <T> int find(MapElement<T>[] map, String name) {\n\n        int a = 0;\n        int b = map.length - 1;\n\n        // Special cases: -1 and 0\n        if (b == -1) {\n            return -1;\n        }\n\n        if (name.compareTo(map[0].name) < 0) {\n            return -1;\n        }\n        if (b == 0) {\n            return 0;\n        }\n\n        int i = 0;\n        while (true) {\n            i = (b + a) / 2;\n            int result = name.compareTo(map[i].name);\n            if (result > 0) {\n                a = i;\n            } else if (result == 0) {\n                return i;\n            } else {\n                b = i;\n            }\n            if ((b - a) == 1) {\n                int result2 = name.compareTo(map[b].name);\n                if (result2 < 0) {\n                    return a;\n                } else {\n                    return b;\n                }\n            }\n        }\n\n    }","id":49155,"modified_method":"/**\n     * Find a map element given its name in a sorted array of map elements.\n     * This will return the index for the closest inferior or equal item in the\n     * given array.\n     * @see #exactFind(MapElement[], String)\n     */\n    private static final <T> int find(MapElement<T>[] map, String name) {\n\n        int a = 0;\n        int b = map.length - 1;\n\n        // Special cases: -1 and 0\n        if (b == -1) {\n            return -1;\n        }\n\n        if (name.compareTo(map[0].name) < 0) {\n            return -1;\n        }\n        if (b == 0) {\n            return 0;\n        }\n\n        int i = 0;\n        while (true) {\n            i = (b + a) / 2;\n            int result = name.compareTo(map[i].name);\n            if (result > 0) {\n                a = i;\n            } else if (result == 0) {\n                return i;\n            } else {\n                b = i;\n            }\n            if ((b - a) == 1) {\n                int result2 = name.compareTo(map[b].name);\n                if (result2 < 0) {\n                    return a;\n                } else {\n                    return b;\n                }\n            }\n        }\n\n    }","commit_id":"4a333449a56163c5c66f0eaf34393e654b7547fa","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Add a welcome file to the given context.\n     *\n     * @param hostName\n     * @param contextPath\n     * @param welcomeFile\n     */\n    public void addWelcomeFile(String hostName, String contextPath,\n            String version, String welcomeFile) {\n        MappedHost[] hosts = this.hosts;\n        int pos = find(hosts, hostName);\n        if (pos < 0) {\n            return;\n        }\n        MappedHost host = hosts[pos];\n        if (host.name.equals(hostName)) {\n            MappedContext[] contexts = host.contextList.contexts;\n            int pos2 = find(contexts, contextPath);\n            if (pos2 < 0) {\n                log.error(\"No context found: \" + contextPath );\n                return;\n            }\n            MappedContext context = contexts[pos2];\n            if (context.name.equals(contextPath)) {\n                ContextVersion[] contextVersions = context.versions;\n                int pos3 = find(contextVersions, version);\n                if( pos3<0 ) {\n                    log.error(\"No context version found: \" + contextPath + \" \" +\n                            version);\n                    return;\n                }\n                ContextVersion contextVersion = contextVersions[pos3];\n                if (contextVersion.name.equals(version)) {\n                    int len = contextVersion.welcomeResources.length + 1;\n                    String[] newWelcomeResources = new String[len];\n                    System.arraycopy(contextVersion.welcomeResources, 0,\n                            newWelcomeResources, 0, len - 1);\n                    newWelcomeResources[len - 1] = welcomeFile;\n                    contextVersion.welcomeResources = newWelcomeResources;\n                }\n            }\n        }\n    }","id":49156,"modified_method":"/**\n     * Add a welcome file to the given context.\n     *\n     * @param hostName\n     * @param contextPath\n     * @param welcomeFile\n     */\n    public void addWelcomeFile(String hostName, String contextPath,\n            String version, String welcomeFile) {\n        MappedHost[] hosts = this.hosts;\n        MappedHost host = exactFind(hosts, hostName);\n        if (host == null) {\n            return;\n        }\n        MappedContext[] contexts = host.contextList.contexts;\n        MappedContext context = exactFind(contexts, contextPath);\n        if (context == null) {\n            log.error(\"No context found: \" + contextPath);\n            return;\n        }\n        ContextVersion[] contextVersions = context.versions;\n        ContextVersion contextVersion = exactFind(contextVersions, version);\n        if (contextVersion == null) {\n            log.error(\"No context version found: \" + contextPath + \" \"\n                    + version);\n            return;\n        }\n        int len = contextVersion.welcomeResources.length + 1;\n        String[] newWelcomeResources = new String[len];\n        System.arraycopy(contextVersion.welcomeResources, 0,\n                newWelcomeResources, 0, len - 1);\n        newWelcomeResources[len - 1] = welcomeFile;\n        contextVersion.welcomeResources = newWelcomeResources;\n    }","commit_id":"4a333449a56163c5c66f0eaf34393e654b7547fa","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Remove a host from the mapper.\n     *\n     * @param name Virtual host name\n     */\n    public synchronized void removeHost(String name) {\n        // Find and remove the old host\n        int pos = find(hosts, name);\n        if (pos < 0) {\n            return;\n        }\n        Host host = hosts[pos].object;\n        MappedHost[] newHosts = new MappedHost[hosts.length - 1];\n        if (removeMap(hosts, newHosts, name)) {\n            hosts = newHosts;\n        }\n        // Remove all aliases (they will map to the same host object)\n        for (int i = 0; i < newHosts.length; i++) {\n            if (newHosts[i].object == host) {\n                MappedHost[] newHosts2 = new MappedHost[hosts.length - 1];\n                if (removeMap(hosts, newHosts2, newHosts[i].name)) {\n                    hosts = newHosts2;\n                }\n            }\n        }\n    }","id":49157,"modified_method":"/**\n     * Remove a host from the mapper.\n     *\n     * @param name Virtual host name\n     */\n    public synchronized void removeHost(String name) {\n        // Find and remove the old host\n        MappedHost mappedHost = exactFind(hosts, name);\n        if (mappedHost == null) {\n            return;\n        }\n        Host host = mappedHost.object;\n        MappedHost[] newHosts = new MappedHost[hosts.length - 1];\n        if (removeMap(hosts, newHosts, name)) {\n            hosts = newHosts;\n        }\n\n        // Remove all aliases (they will map to the same host object)\n        for (int i = 0; i < newHosts.length; i++) {\n            if (newHosts[i].object == host) {\n                MappedHost[] newHosts2 = new MappedHost[hosts.length - 1];\n                if (removeMap(hosts, newHosts2, newHosts[i].name)) {\n                    hosts = newHosts2;\n                }\n            }\n        }\n    }","commit_id":"4a333449a56163c5c66f0eaf34393e654b7547fa","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Add an alias to an existing host.\n     * @param name  The name of the host\n     * @param alias The alias to add\n     */\n    public synchronized void addHostAlias(String name, String alias) {\n        int pos = find(hosts, name);\n        if (pos < 0) {\n            // Should not be adding an alias for a host that doesn't exist but\n            // just in case...\n            return;\n        }\n        MappedHost realHost = hosts[pos];\n\n        MappedHost[] newHosts = new MappedHost[hosts.length + 1];\n        MappedHost newHost = new MappedHost();\n        newHost.name = alias;\n        newHost.contextList = realHost.contextList;\n        newHost.object = realHost.object;\n        if (insertMap(hosts, newHosts, newHost)) {\n            hosts = newHosts;\n        }\n    }","id":49158,"modified_method":"/**\n     * Add an alias to an existing host.\n     * @param name  The name of the host\n     * @param alias The alias to add\n     */\n    public synchronized void addHostAlias(String name, String alias) {\n        MappedHost realHost = exactFind(hosts, name);\n        if (realHost == null) {\n            // Should not be adding an alias for a host that doesn't exist but\n            // just in case...\n            return;\n        }\n        addHostAliasImpl(realHost, alias);\n    }","commit_id":"4a333449a56163c5c66f0eaf34393e654b7547fa","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n  public ByteBuffer readRemoteBlock(InetSocketAddress address, long blockId, long offset,\n      long length, long lockId, long sessionId) throws IOException {\n    SingleResponseListener listener = null;\n    Channel channel = null;\n    Metrics.NETTY_BLOCK_READ_OPS.inc();\n    try {\n      channel = BlockStoreContext.acquireNettyChannel(address, mClientBootstrap);\n      listener = new SingleResponseListener();\n      ((ClientHandler) channel.pipeline().last()).addListener(listener);\n      ChannelFuture channelFuture = channel\n          .writeAndFlush(new RPCBlockReadRequest(blockId, offset, length, lockId, sessionId));\n      channelFuture = channelFuture.sync();\n      if (channelFuture.isDone() && !channelFuture.isSuccess()) {\n        LOG.error(\"Failed to write to %s for block %d with error %s.\", address.toString(), blockId,\n            channelFuture.cause());\n        throw new IOException(channelFuture.cause());\n      }\n\n      RPCResponse response = listener.get(NettyClient.TIMEOUT_MS, TimeUnit.MILLISECONDS);\n\n      switch (response.getType()) {\n        case RPC_BLOCK_READ_RESPONSE:\n          RPCBlockReadResponse blockResponse = (RPCBlockReadResponse) response;\n          LOG.debug(\"Data {} from remote machine {} received\", blockId, address);\n\n          RPCResponse.Status status = blockResponse.getStatus();\n          if (status == RPCResponse.Status.SUCCESS) {\n            // always clear the previous response before reading another one\n            close();\n            mReadResponse = blockResponse;\n            return blockResponse.getPayloadDataBuffer().getReadOnlyByteBuffer();\n          }\n          throw new IOException(status.getMessage() + \" response: \" + blockResponse);\n        case RPC_ERROR_RESPONSE:\n          RPCErrorResponse error = (RPCErrorResponse) response;\n          Metrics.NETTY_BLOCK_READ_FAILURES.inc();\n          throw new IOException(error.getStatus().getMessage());\n        default:\n          throw new IOException(ExceptionMessage.UNEXPECTED_RPC_RESPONSE\n              .getMessage(response.getType(), RPCMessage.Type.RPC_BLOCK_READ_RESPONSE));\n      }\n    } catch (Exception e) {\n      Metrics.NETTY_BLOCK_READ_FAILURES.inc();\n      throw new IOException(e);\n    } finally {\n      if (channel != null && listener != null) {\n        ((ClientHandler) channel.pipeline().last()).removeListener(listener);\n      }\n      if (channel != null) {\n        BlockStoreContext.releaseNettyChannel(address, channel);\n      }\n    }\n  }","id":49159,"modified_method":"@Override\n  public ByteBuffer readRemoteBlock(InetSocketAddress address, long blockId, long offset,\n      long length, long lockId, long sessionId) throws IOException {\n    SingleResponseListener listener = null;\n    Channel channel = null;\n    Metrics.NETTY_BLOCK_READ_OPS.inc();\n    try {\n      channel = BlockStoreContext.acquireNettyChannel(address, mClientBootstrap);\n      listener = new SingleResponseListener();\n      ((ClientHandler) channel.pipeline().last()).addListener(listener);\n      ChannelFuture channelFuture = channel\n          .writeAndFlush(new RPCBlockReadRequest(blockId, offset, length, lockId, sessionId));\n      channelFuture = channelFuture.sync();\n      if (channelFuture.isDone() && !channelFuture.isSuccess()) {\n        LOG.error(\"Failed to write to %s for block %d with error %s.\", address.toString(), blockId,\n            channelFuture.cause());\n        throw new IOException(channelFuture.cause());\n      }\n\n      RPCResponse response = listener.get(NettyClient.TIMEOUT_MS, TimeUnit.MILLISECONDS);\n\n      switch (response.getType()) {\n        case RPC_BLOCK_READ_RESPONSE:\n          RPCBlockReadResponse blockResponse = (RPCBlockReadResponse) response;\n          LOG.debug(\"Data {} from remote machine {} received\", blockId, address);\n\n          RPCResponse.Status status = blockResponse.getStatus();\n          if (status == RPCResponse.Status.SUCCESS) {\n            // always clear the previous response before reading another one\n            close();\n            mReadResponse = blockResponse;\n            return blockResponse.getPayloadDataBuffer().getReadOnlyByteBuffer();\n          }\n          throw new IOException(status.getMessage() + \" response: \" + blockResponse);\n        case RPC_ERROR_RESPONSE:\n          RPCErrorResponse error = (RPCErrorResponse) response;\n          throw new IOException(error.getStatus().getMessage());\n        default:\n          throw new IOException(ExceptionMessage.UNEXPECTED_RPC_RESPONSE\n              .getMessage(response.getType(), RPCMessage.Type.RPC_BLOCK_READ_RESPONSE));\n      }\n    } catch (Exception e) {\n      Metrics.NETTY_BLOCK_READ_FAILURES.inc();\n      throw new IOException(e);\n    } finally {\n      if (channel != null && listener != null) {\n        ((ClientHandler) channel.pipeline().last()).removeListener(listener);\n      }\n      if (channel != null) {\n        BlockStoreContext.releaseNettyChannel(address, channel);\n      }\n    }\n  }","commit_id":"6cd7cdf94c7dfddc3602c26bdec3fc401cd66cc4","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void write(byte[] bytes, int offset, int length) throws IOException {\n    SingleResponseListener listener = null;\n    Channel channel = null;\n    Metrics.NETTY_BLOCK_WRITE_OPS.inc();\n    try {\n      channel = BlockStoreContext.acquireNettyChannel(mAddress, mClientBootstrap);\n      listener = new SingleResponseListener();\n      ((ClientHandler) channel.pipeline().last()).addListener(listener);\n      ChannelFuture channelFuture = channel.writeAndFlush(\n          new RPCBlockWriteRequest(mSessionId, mBlockId, mWrittenBytes, length,\n              new DataByteArrayChannel(bytes, offset, length))).sync();\n      if (channelFuture.isDone() && !channelFuture.isSuccess()) {\n        LOG.error(\"Failed to write to %s for block %d with error %s.\", mAddress.toString(),\n            mBlockId, channelFuture.cause());\n        throw new IOException(channelFuture.cause());\n      }\n\n      RPCResponse response = listener.get(NettyClient.TIMEOUT_MS, TimeUnit.MILLISECONDS);\n\n      switch (response.getType()) {\n        case RPC_BLOCK_WRITE_RESPONSE:\n          RPCBlockWriteResponse resp = (RPCBlockWriteResponse) response;\n          RPCResponse.Status status = resp.getStatus();\n          LOG.debug(\"status: {} from remote machine {} received\", status, mAddress);\n\n          if (status != RPCResponse.Status.SUCCESS) {\n            Metrics.NETTY_BLOCK_WRITE_FAILURES.inc();\n            throw new IOException(ExceptionMessage.BLOCK_WRITE_ERROR.getMessage(mBlockId,\n                mSessionId, mAddress, status.getMessage()));\n          }\n          mWrittenBytes += length;\n          break;\n        case RPC_ERROR_RESPONSE:\n          RPCErrorResponse error = (RPCErrorResponse) response;\n          throw new IOException(error.getStatus().getMessage());\n        default:\n          throw new IOException(ExceptionMessage.UNEXPECTED_RPC_RESPONSE\n              .getMessage(response.getType(), RPCMessage.Type.RPC_BLOCK_WRITE_RESPONSE));\n      }\n    } catch (Exception e) {\n      Metrics.NETTY_BLOCK_WRITE_FAILURES.inc();\n      throw new IOException(e);\n    } finally {\n      if (channel != null && listener != null) {\n        ((ClientHandler) channel.pipeline().last()).removeListener(listener);\n      }\n      if (channel != null) {\n        BlockStoreContext.releaseNettyChannel(mAddress, channel);\n      }\n    }\n  }","id":49160,"modified_method":"@Override\n  public void write(byte[] bytes, int offset, int length) throws IOException {\n    SingleResponseListener listener = null;\n    Channel channel = null;\n    Metrics.NETTY_BLOCK_WRITE_OPS.inc();\n    try {\n      channel = BlockStoreContext.acquireNettyChannel(mAddress, mClientBootstrap);\n      listener = new SingleResponseListener();\n      ((ClientHandler) channel.pipeline().last()).addListener(listener);\n      ChannelFuture channelFuture = channel.writeAndFlush(\n          new RPCBlockWriteRequest(mSessionId, mBlockId, mWrittenBytes, length,\n              new DataByteArrayChannel(bytes, offset, length))).sync();\n      if (channelFuture.isDone() && !channelFuture.isSuccess()) {\n        LOG.error(\"Failed to write to %s for block %d with error %s.\", mAddress.toString(),\n            mBlockId, channelFuture.cause());\n        throw new IOException(channelFuture.cause());\n      }\n\n      RPCResponse response = listener.get(NettyClient.TIMEOUT_MS, TimeUnit.MILLISECONDS);\n\n      switch (response.getType()) {\n        case RPC_BLOCK_WRITE_RESPONSE:\n          RPCBlockWriteResponse resp = (RPCBlockWriteResponse) response;\n          RPCResponse.Status status = resp.getStatus();\n          LOG.debug(\"status: {} from remote machine {} received\", status, mAddress);\n\n          if (status != RPCResponse.Status.SUCCESS) {\n            throw new IOException(ExceptionMessage.BLOCK_WRITE_ERROR.getMessage(mBlockId,\n                mSessionId, mAddress, status.getMessage()));\n          }\n          mWrittenBytes += length;\n          break;\n        case RPC_ERROR_RESPONSE:\n          RPCErrorResponse error = (RPCErrorResponse) response;\n          throw new IOException(error.getStatus().getMessage());\n        default:\n          throw new IOException(ExceptionMessage.UNEXPECTED_RPC_RESPONSE\n              .getMessage(response.getType(), RPCMessage.Type.RPC_BLOCK_WRITE_RESPONSE));\n      }\n    } catch (Exception e) {\n      Metrics.NETTY_BLOCK_WRITE_FAILURES.inc();\n      throw new IOException(e);\n    } finally {\n      if (channel != null && listener != null) {\n        ((ClientHandler) channel.pipeline().last()).removeListener(listener);\n      }\n      if (channel != null) {\n        BlockStoreContext.releaseNettyChannel(mAddress, channel);\n      }\n    }\n  }","commit_id":"6cd7cdf94c7dfddc3602c26bdec3fc401cd66cc4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new reader for a file in an under file system through a worker's data server.\n   */\n  public NettyUnderFileSystemFileReader() {\n    mHandler = new ClientHandler();\n    mClientBootstrap = NettyClient.createClientBootstrap(mHandler);\n  }","id":49161,"modified_method":"/**\n   * Creates a new reader for a file in an under file system through a worker's data server.\n   */\n  public NettyUnderFileSystemFileReader() {\n    mClientBootstrap = NettyClient.createClientBootstrap(new ClientHandler());\n  }","commit_id":"6cd7cdf94c7dfddc3602c26bdec3fc401cd66cc4","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public ByteBuffer read(InetSocketAddress address, long ufsFileId, long offset, long length)\n      throws IOException {\n    // For a zero length read, directly return without trying the Netty call.\n    if (length == 0) {\n      return ByteBuffer.allocate(0);\n    }\n    SingleResponseListener listener = null;\n    try {\n      ChannelFuture f = mClientBootstrap.connect(address).sync();\n\n      LOG.debug(\"Connected to remote machine {}\", address);\n      Channel channel = f.channel();\n      listener = new SingleResponseListener();\n      mHandler.addListener(listener);\n      channel.writeAndFlush(new RPCFileReadRequest(ufsFileId, offset, length));\n\n      RPCResponse response = listener.get(NettyClient.TIMEOUT_MS, TimeUnit.MILLISECONDS);\n      channel.close().sync();\n\n      switch (response.getType()) {\n        case RPC_FILE_READ_RESPONSE:\n          RPCFileReadResponse resp = (RPCFileReadResponse) response;\n          LOG.debug(\"Data for ufs file id {} from machine {} received\", ufsFileId, address);\n          RPCResponse.Status status = resp.getStatus();\n          if (status == RPCResponse.Status.SUCCESS) {\n            // always clear the previous response before reading another one\n            cleanup();\n            // End of file reached\n            if (resp.isEOF()) {\n              return null;\n            }\n            mReadResponse = resp;\n            return resp.getPayloadDataBuffer().getReadOnlyByteBuffer();\n          }\n          throw new IOException(status.getMessage() + \" response: \" + resp);\n        case RPC_ERROR_RESPONSE:\n          RPCErrorResponse error = (RPCErrorResponse) response;\n          throw new IOException(error.getStatus().getMessage());\n        default:\n          throw new IOException(ExceptionMessage.UNEXPECTED_RPC_RESPONSE.getMessage(\n              response.getType(), RPCMessage.Type.RPC_FILE_READ_RESPONSE));\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    } finally {\n      if (listener != null) {\n        mHandler.removeListener(listener);\n      }\n    }\n  }","id":49162,"modified_method":"@Override\n  public ByteBuffer read(InetSocketAddress address, long ufsFileId, long offset, long length)\n      throws IOException {\n    // For a zero length read, directly return without trying the Netty call.\n    if (length == 0) {\n      return ByteBuffer.allocate(0);\n    }\n\n    Metrics.NETTY_UFS_READ_OPS.inc();\n    SingleResponseListener listener = null;\n    Channel channel = null;\n    try {\n      channel = BlockStoreContext.acquireNettyChannel(address, mClientBootstrap);\n      listener = new SingleResponseListener();\n      ((ClientHandler) channel.pipeline().last()).addListener(listener);\n      ChannelFuture channelFuture =\n          channel.writeAndFlush(new RPCFileReadRequest(ufsFileId, offset, length)).sync();\n\n      if (channelFuture.isDone() && !channelFuture.isSuccess()) {\n        LOG.error(\"Failed to read ufs file from %s for ufsFilId %d with error %s.\",\n            address.toString(), ufsFileId, channelFuture.cause());\n        throw new IOException(channelFuture.cause());\n      }\n\n      RPCResponse response = listener.get(NettyClient.TIMEOUT_MS, TimeUnit.MILLISECONDS);\n\n      switch (response.getType()) {\n        case RPC_FILE_READ_RESPONSE:\n          RPCFileReadResponse resp = (RPCFileReadResponse) response;\n          LOG.debug(\"Data for ufs file id {} from machine {} received\", ufsFileId, address);\n          RPCResponse.Status status = resp.getStatus();\n          if (status == RPCResponse.Status.SUCCESS) {\n            // always clear the previous response before reading another one\n            cleanup();\n            // End of file reached\n            if (resp.isEOF()) {\n              return null;\n            }\n            mReadResponse = resp;\n            return resp.getPayloadDataBuffer().getReadOnlyByteBuffer();\n          }\n          throw new IOException(status.getMessage() + \" response: \" + resp);\n        case RPC_ERROR_RESPONSE:\n          RPCErrorResponse error = (RPCErrorResponse) response;\n          throw new IOException(error.getStatus().getMessage());\n        default:\n          throw new IOException(ExceptionMessage.UNEXPECTED_RPC_RESPONSE.getMessage(\n              response.getType(), RPCMessage.Type.RPC_FILE_READ_RESPONSE));\n      }\n    } catch (Exception e) {\n      Metrics.NETTY_UFS_READ_FAILURES.inc();\n      throw new IOException(e);\n    } finally {\n      if (channel != null && listener != null) {\n        ((ClientHandler) channel.pipeline().last()).removeListener(listener);\n      }\n      if (channel != null) {\n        BlockStoreContext.releaseNettyChannel(address, channel);\n      }\n    }\n  }","commit_id":"6cd7cdf94c7dfddc3602c26bdec3fc401cd66cc4","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void write(InetSocketAddress address, long ufsFileId, long fileOffset, byte[] source,\n      int offset, int length) throws IOException {\n    SingleResponseListener listener = null;\n    try {\n      ChannelFuture f = mClientBootstrap.connect(address).sync();\n\n      LOG.debug(\"Connected to remote machine {}\", address);\n      Channel channel = f.channel();\n      listener = new SingleResponseListener();\n      mHandler.addListener(listener);\n      channel.writeAndFlush(new RPCFileWriteRequest(ufsFileId, fileOffset, length,\n          new DataByteArrayChannel(source, offset, length)));\n\n      RPCResponse response = listener.get(NettyClient.TIMEOUT_MS, TimeUnit.MILLISECONDS);\n      channel.close().sync();\n\n      switch (response.getType()) {\n        case RPC_FILE_WRITE_RESPONSE:\n          RPCFileWriteResponse resp = (RPCFileWriteResponse) response;\n          RPCResponse.Status status = resp.getStatus();\n          LOG.debug(\"status: {} from remote machine {} received\", status, address);\n\n          if (status != RPCResponse.Status.SUCCESS) {\n            throw new IOException(ExceptionMessage.UNDER_FILE_WRITE_ERROR.getMessage(ufsFileId,\n                address, status.getMessage()));\n          }\n          break;\n        case RPC_ERROR_RESPONSE:\n          RPCErrorResponse error = (RPCErrorResponse) response;\n          throw new IOException(error.getStatus().getMessage());\n        default:\n          throw new IOException(ExceptionMessage.UNEXPECTED_RPC_RESPONSE\n              .getMessage(response.getType(), RPCMessage.Type.RPC_FILE_WRITE_RESPONSE));\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    } finally {\n      if (listener != null) {\n        mHandler.removeListener(listener);\n      }\n    }\n  }","id":49163,"modified_method":"@Override\n  public void write(InetSocketAddress address, long ufsFileId, long fileOffset, byte[] source,\n      int offset, int length) throws IOException {\n    SingleResponseListener listener = null;\n    Channel channel = null;\n    Metrics.NETTY_UFS_WRITE_OPS.inc();\n    try {\n      channel = BlockStoreContext.acquireNettyChannel(address, mClientBootstrap) ;\n      listener = new SingleResponseListener();\n      ((ClientHandler) channel.pipeline().last()).addListener(listener);\n      ChannelFuture channelFuture = channel.writeAndFlush(\n          new RPCFileWriteRequest(ufsFileId, fileOffset, length,\n              new DataByteArrayChannel(source, offset, length))).sync();\n\n      if (channelFuture.isDone() && !channelFuture.isSuccess()) {\n        LOG.error(\"Failed to read ufs file from %s for ufsFilId %d with error %s.\",\n            address.toString(), ufsFileId, channelFuture.cause());\n        throw new IOException(channelFuture.cause());\n      }\n\n      RPCResponse response = listener.get(NettyClient.TIMEOUT_MS, TimeUnit.MILLISECONDS);\n\n      switch (response.getType()) {\n        case RPC_FILE_WRITE_RESPONSE:\n          RPCFileWriteResponse resp = (RPCFileWriteResponse) response;\n          RPCResponse.Status status = resp.getStatus();\n          LOG.debug(\"status: {} from remote machine {} received\", status, address);\n\n          if (status != RPCResponse.Status.SUCCESS) {\n            throw new IOException(ExceptionMessage.UNDER_FILE_WRITE_ERROR.getMessage(ufsFileId,\n                address, status.getMessage()));\n          }\n          break;\n        case RPC_ERROR_RESPONSE:\n          RPCErrorResponse error = (RPCErrorResponse) response;\n          throw new IOException(error.getStatus().getMessage());\n        default:\n          throw new IOException(ExceptionMessage.UNEXPECTED_RPC_RESPONSE\n              .getMessage(response.getType(), RPCMessage.Type.RPC_FILE_WRITE_RESPONSE));\n      }\n    } catch (Exception e) {\n      Metrics.NETTY_UFS_WRITE_FAILURES.inc();\n      throw new IOException(e);\n    } finally {\n      if (channel != null && listener != null) {\n        ((ClientHandler) channel.pipeline().last()).removeListener(listener);\n      }\n      if (channel != null) {\n        BlockStoreContext.releaseNettyChannel(address, channel);\n      }\n    }\n  }","commit_id":"6cd7cdf94c7dfddc3602c26bdec3fc401cd66cc4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Constructor for a Netty based writer to an under file system file on a worker.\n   */\n  public NettyUnderFileSystemFileWriter() {\n    mHandler = new ClientHandler();\n    mClientBootstrap = NettyClient.createClientBootstrap(mHandler);\n  }","id":49164,"modified_method":"/**\n   * Constructor for a Netty based writer to an under file system file on a worker.\n   */\n  public NettyUnderFileSystemFileWriter() {\n    mClientBootstrap = NettyClient.createClientBootstrap(new ClientHandler());\n  }","commit_id":"6cd7cdf94c7dfddc3602c26bdec3fc401cd66cc4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Handles a {@link RPCFileReadRequest} by reading the data through an input stream provided by\n   * the file worker. This method assumes the length to read is less than or equal to the unread\n   * data in the file.\n   *\n   * @param ctx The context of this request which handles the result of this operation\n   * @param req The initiating {@link RPCFileReadRequest}\n   * @throws IOException if an I/O error occurs when interacting with the UFS\n   */\n  public void handleFileReadRequest(ChannelHandlerContext ctx, RPCFileReadRequest req)\n      throws IOException {\n    req.validate();\n\n    long ufsFileId = req.getTempUfsFileId();\n    long offset = req.getOffset();\n    long length = req.getLength();\n    byte[] data = new byte[(int) length];\n\n    try {\n      InputStream in = mWorker.getUfsInputStream(ufsFileId, offset);\n      int bytesRead = 0;\n      if (in != null) { // if we have not reached the end of the file\n        while (bytesRead < length) {\n          int read = in.read(data, bytesRead, (int) length - bytesRead);\n          if (read == -1) {\n            break;\n          }\n          bytesRead += read;\n        }\n      }\n      DataBuffer buf =\n          bytesRead != 0 ? new DataByteBuffer(ByteBuffer.wrap(data, 0, bytesRead), bytesRead)\n              : null;\n      RPCFileReadResponse resp =\n          new RPCFileReadResponse(ufsFileId, offset, bytesRead, buf, RPCResponse.Status.SUCCESS);\n      ChannelFuture future = ctx.writeAndFlush(resp);\n      future.addListener(ChannelFutureListener.CLOSE);\n    } catch (Exception e) {\n      LOG.error(\"Failed to read ufs file, may have been closed due to a client timeout.\", e);\n      RPCFileReadResponse resp =\n          RPCFileReadResponse.createErrorResponse(req, RPCResponse.Status.UFS_READ_FAILED);\n      ChannelFuture future = ctx.writeAndFlush(resp);\n      future.addListener(ChannelFutureListener.CLOSE);\n    }\n  }","id":49165,"modified_method":"/**\n   * Handles a {@link RPCFileReadRequest} by reading the data through an input stream provided by\n   * the file worker. This method assumes the length to read is less than or equal to the unread\n   * data in the file.\n   *\n   * @param ctx The context of this request which handles the result of this operation\n   * @param req The initiating {@link RPCFileReadRequest}\n   * @throws IOException if an I/O error occurs when interacting with the UFS\n   */\n  public void handleFileReadRequest(ChannelHandlerContext ctx, RPCFileReadRequest req)\n      throws IOException {\n    req.validate();\n\n    long ufsFileId = req.getTempUfsFileId();\n    long offset = req.getOffset();\n    long length = req.getLength();\n    byte[] data = new byte[(int) length];\n\n    try {\n      InputStream in = mWorker.getUfsInputStream(ufsFileId, offset);\n      int bytesRead = 0;\n      if (in != null) { // if we have not reached the end of the file\n        while (bytesRead < length) {\n          // TODO(peis): Fix this. It is not recommended to do heavy blocking IO operation\n          // in Netty's IO event group. We should do it in another threadpool.\n          int read = in.read(data, bytesRead, (int) length - bytesRead);\n          if (read == -1) {\n            break;\n          }\n          bytesRead += read;\n        }\n      }\n      DataBuffer buf =\n          bytesRead != 0 ? new DataByteBuffer(ByteBuffer.wrap(data, 0, bytesRead), bytesRead)\n              : null;\n      RPCFileReadResponse resp =\n          new RPCFileReadResponse(ufsFileId, offset, bytesRead, buf, RPCResponse.Status.SUCCESS);\n      ctx.writeAndFlush(resp);\n    } catch (Exception e) {\n      // TODO(peis): Fix this. The exception here should never be caused netty related issue.\n      LOG.error(\"Failed to read ufs file, may have been closed due to a client timeout.\", e);\n      RPCFileReadResponse resp =\n          RPCFileReadResponse.createErrorResponse(req, RPCResponse.Status.UFS_READ_FAILED);\n      ChannelFuture future = ctx.writeAndFlush(resp);\n      future.addListener(ChannelFutureListener.CLOSE);\n    }\n  }","commit_id":"6cd7cdf94c7dfddc3602c26bdec3fc401cd66cc4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Handles a {@link RPCFileWriteRequest} by writing the data through an output stream provided\n   * by the file worker. This method only allows appending data to the file and does not support\n   * writing at arbitrary offsets.\n   *\n   * @param ctx The context of this request which handles the result of this operation\n   * @param req The initiating {@link RPCFileWriteRequest}\n   * @throws IOException if an I/O error occurs when interacting with the UFS\n   */\n  public void handleFileWriteRequest(ChannelHandlerContext ctx, RPCFileWriteRequest req)\n      throws IOException {\n    long ufsFileId = req.getTempUfsFileId();\n    // Currently unused as only sequential write is supported\n    long offset = req.getOffset();\n    long length = req.getLength();\n    final DataBuffer data = req.getPayloadDataBuffer();\n\n    try {\n      OutputStream out = mWorker.getUfsOutputStream(ufsFileId);\n      // This channel will not be closed because the underlying stream should not be closed, the\n      // channel will be cleaned up when the underlying stream is closed.\n      WritableByteChannel channel = Channels.newChannel(out);\n      channel.write(data.getReadOnlyByteBuffer());\n      RPCFileWriteResponse resp =\n          new RPCFileWriteResponse(ufsFileId, offset, length, RPCResponse.Status.SUCCESS);\n      ChannelFuture future = ctx.writeAndFlush(resp);\n      future.addListener(ChannelFutureListener.CLOSE);\n    } catch (Exception e) {\n      LOG.error(\"Failed to write ufs file.\", e);\n      RPCFileWriteResponse resp =\n          RPCFileWriteResponse.createErrorResponse(req, RPCResponse.Status.UFS_WRITE_FAILED);\n      ChannelFuture future = ctx.writeAndFlush(resp);\n      future.addListener(ChannelFutureListener.CLOSE);\n    }\n  }","id":49166,"modified_method":"/**\n   * Handles a {@link RPCFileWriteRequest} by writing the data through an output stream provided\n   * by the file worker. This method only allows appending data to the file and does not support\n   * writing at arbitrary offsets.\n   *\n   * @param ctx The context of this request which handles the result of this operation\n   * @param req The initiating {@link RPCFileWriteRequest}\n   * @throws IOException if an I/O error occurs when interacting with the UFS\n   */\n  public void handleFileWriteRequest(ChannelHandlerContext ctx, RPCFileWriteRequest req)\n      throws IOException {\n    long ufsFileId = req.getTempUfsFileId();\n    // Currently unused as only sequential write is supported\n    long offset = req.getOffset();\n    long length = req.getLength();\n    final DataBuffer data = req.getPayloadDataBuffer();\n\n    try {\n      OutputStream out = mWorker.getUfsOutputStream(ufsFileId);\n      // This channel will not be closed because the underlying stream should not be closed, the\n      // channel will be cleaned up when the underlying stream is closed.\n      WritableByteChannel channel = Channels.newChannel(out);\n      channel.write(data.getReadOnlyByteBuffer());\n      RPCFileWriteResponse resp =\n          new RPCFileWriteResponse(ufsFileId, offset, length, RPCResponse.Status.SUCCESS);\n      ctx.writeAndFlush(resp);\n    } catch (Exception e) {\n      // TODO(peis): Fix this. The exception here should never be caused netty related issue.\n      LOG.error(\"Failed to write ufs file.\", e);\n      RPCFileWriteResponse resp =\n          RPCFileWriteResponse.createErrorResponse(req, RPCResponse.Status.UFS_WRITE_FAILED);\n      ChannelFuture future = ctx.writeAndFlush(resp);\n      future.addListener(ChannelFutureListener.CLOSE);\n    }\n  }","commit_id":"6cd7cdf94c7dfddc3602c26bdec3fc401cd66cc4","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Gets a stream to read the data of a block. The stream is backed by Alluxio storage.\n   *\n   * @param blockId the block to read from\n   * @return a {@link BlockInStream} which can be used to read the data in a streaming fashion\n   * @throws IOException if the block does not exist\n   */\n  public BufferedBlockInStream getInStream(long blockId) throws IOException {\n    BlockInfo blockInfo;\n    try (CloseableResource<BlockMasterClient> masterClientResource =\n        mContext.acquireMasterClientResource()) {\n      blockInfo = masterClientResource.get().getBlockInfo(blockId);\n    } catch (AlluxioException e) {\n      throw new IOException(e);\n    }\n\n    if (blockInfo.getLocations().isEmpty()) {\n      throw new IOException(\"Block \" + blockId + \" is not available in Alluxio\");\n    }\n    // TODO(calvin): Get location via a policy.\n    // Although blockInfo.locations are sorted by tier, we prefer reading from the local worker.\n    // But when there is no local worker or there are no local blocks, we prefer the first\n    // location in blockInfo.locations that is nearest to memory tier.\n    // Assuming if there is no local worker, there are no local blocks in blockInfo.locations.\n    // TODO(cc): Check mContext.hasLocalWorker before finding for a local block when the TODO\n    // for hasLocalWorker is fixed.\n    for (BlockLocation location : blockInfo.getLocations()) {\n      WorkerNetAddress workerNetAddress = location.getWorkerAddress();\n      if (workerNetAddress.getHost().equals(mLocalHostName)) {\n        // There is a local worker and the block is local.\n        try {\n          return new LocalBlockInStream(blockId, blockInfo.getLength(), workerNetAddress, mContext);\n        } catch (IOException e) {\n          LOG.warn(\"Failed to open local stream for block \" + blockId + \". \" + e.getMessage());\n          // Getting a local stream failed, do not try again\n          break;\n        }\n      }\n    }\n    // No local worker/block, get the first location since it's nearest to memory tier.\n    WorkerNetAddress workerNetAddress = blockInfo.getLocations().get(0).getWorkerAddress();\n    return new RemoteBlockInStream(blockId, blockInfo.getLength(), workerNetAddress, mContext);\n  }","id":49167,"modified_method":"/**\n   * Gets a stream to read the data of a block. The stream is backed by Alluxio storage.\n   *\n   * @param blockId the block to read from\n   * @return a {@link BlockInStream} which can be used to read the data in a streaming fashion\n   * @throws IOException if the block does not exist\n   */\n  public BufferedBlockInStream getInStream(long blockId) throws IOException {\n    BlockInfo blockInfo;\n    try (CloseableResource<BlockMasterClient> masterClientResource =\n        mContext.acquireMasterClientResource()) {\n      blockInfo = masterClientResource.get().getBlockInfo(blockId);\n    } catch (AlluxioException e) {\n      throw new IOException(e);\n    }\n\n    if (blockInfo.getLocations().isEmpty()) {\n      throw new IOException(\"Block \" + blockId + \" is not available in Alluxio\");\n    }\n    // TODO(calvin): Get location via a policy.\n    // Although blockInfo.locations are sorted by tier, we prefer reading from the local worker.\n    // But when there is no local worker or there are no local blocks, we prefer the first\n    // location in blockInfo.locations that is nearest to memory tier.\n    // Assuming if there is no local worker, there are no local blocks in blockInfo.locations.\n    // TODO(cc): Check mContext.hasLocalWorker before finding for a local block when the TODO\n    // for hasLocalWorker is fixed.\n    for (BlockLocation location : blockInfo.getLocations()) {\n      /*\n      WorkerNetAddress workerNetAddress = location.getWorkerAddress();\n      if (workerNetAddress.getHost().equals(mLocalHostName)) {\n        // There is a local worker and the block is local.\n        try {\n          return new LocalBlockInStream(blockId, blockInfo.getLength(), workerNetAddress, mContext);\n        } catch (IOException e) {\n          LOG.warn(\"Failed to open local stream for block \" + blockId + \". \" + e.getMessage());\n          // Getting a local stream failed, do not try again\n          break;\n        }\n      }\n      */\n    }\n    // No local worker/block, get the first location since it's nearest to memory tier.\n    WorkerNetAddress workerNetAddress = blockInfo.getLocations().get(0).getWorkerAddress();\n    return new RemoteBlockInStream(blockId, blockInfo.getLength(), workerNetAddress, mContext);\n  }","commit_id":"73ddec52d3e75b66d384cff3c1e280062c4fe345","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Handles a {@link RPCBlockWriteRequest} by writing the data through a {@link BlockWriter}\n   * provided by the block worker. This method takes care of requesting space and creating the\n   * block if necessary.\n   *\n   * @param ctx The context of this request which handles the result of this operation\n   * @param req The initiating {@link RPCBlockWriteRequest}\n   * @throws IOException if an I/O exception occurs when writing the data\n   */\n  // TODO(hy): This write request handler is very simple in order to be stateless. Therefore, the\n  // block file is opened and closed for every request. If this is too slow, then this handler\n  // should be optimized to keep state.\n  void handleBlockWriteRequest(final ChannelHandlerContext ctx, final RPCBlockWriteRequest req)\n      throws IOException {\n    final long sessionId = req.getSessionId();\n    final long blockId = req.getBlockId();\n    final long offset = req.getOffset();\n    final long length = req.getLength();\n    final DataBuffer data = req.getPayloadDataBuffer();\n\n    BlockWriter writer = null;\n    try {\n      req.validate();\n      ByteBuffer buffer = data.getReadOnlyByteBuffer();\n\n      if (offset == 0) {\n        // This is the first write to the block, so create the temp block file. The file will only\n        // be created if the first write starts at offset 0. This allocates enough space for the\n        // write.\n        mWorker.createBlockRemote(sessionId, blockId, mStorageTierAssoc.getAlias(0), length);\n      } else {\n        // Allocate enough space in the existing temporary block for the write.\n        mWorker.requestSpace(sessionId, blockId, length);\n      }\n      writer = mWorker.getTempBlockWriterRemote(sessionId, blockId);\n      writer.append(buffer);\n\n      Metrics.BYTES_WRITTEN_REMOTE.inc(data.getLength());\n      RPCBlockWriteResponse resp =\n          new RPCBlockWriteResponse(sessionId, blockId, offset, length, RPCResponse.Status.SUCCESS);\n      ChannelFuture future = ctx.writeAndFlush(resp);\n      future.addListener(ChannelFutureListener.CLOSE);\n      future.addListener(new ClosableResourceChannelListener(writer));\n    } catch (Exception e) {\n      LOG.error(\"Error writing remote block : {}\", e.getMessage(), e);\n      RPCBlockWriteResponse resp =\n          RPCBlockWriteResponse.createErrorResponse(req, RPCResponse.Status.WRITE_ERROR);\n      ChannelFuture future = ctx.writeAndFlush(resp);\n      future.addListener(ChannelFutureListener.CLOSE);\n      if (writer != null) {\n        writer.close();\n      }\n    }\n  }","id":49168,"modified_method":"/**\n   * Handles a {@link RPCBlockWriteRequest} by writing the data through a {@link BlockWriter}\n   * provided by the block worker. This method takes care of requesting space and creating the\n   * block if necessary.\n   *\n   * @param ctx The context of this request which handles the result of this operation\n   * @param req The initiating {@link RPCBlockWriteRequest}\n   * @throws IOException if an I/O exception occurs when writing the data\n   */\n  // TODO(hy): This write request handler is very simple in order to be stateless. Therefore, the\n  // block file is opened and closed for every request. If this is too slow, then this handler\n  // should be optimized to keep state.\n  void handleBlockWriteRequest(final ChannelHandlerContext ctx, final RPCBlockWriteRequest req)\n      throws IOException {\n    final long sessionId = req.getSessionId();\n    final long blockId = req.getBlockId();\n    final long offset = req.getOffset();\n    final long length = req.getLength();\n    final DataBuffer data = req.getPayloadDataBuffer();\n\n    BlockWriter writer = null;\n    try {\n      req.validate();\n      ByteBuffer buffer = data.getReadOnlyByteBuffer();\n\n      if (offset == 0) {\n        // This is the first write to the block, so create the temp block file. The file will only\n        // be created if the first write starts at offset 0. This allocates enough space for the\n        // write.\n        mWorker.createBlockRemote(sessionId, blockId, mStorageTierAssoc.getAlias(0), length);\n      } else {\n        // Allocate enough space in the existing temporary block for the write.\n        mWorker.requestSpace(sessionId, blockId, length);\n      }\n      writer = mWorker.getTempBlockWriterRemote(sessionId, blockId);\n      writer.append(buffer);\n\n      Metrics.BYTES_WRITTEN_REMOTE.inc(data.getLength());\n      RPCBlockWriteResponse resp =\n          new RPCBlockWriteResponse(sessionId, blockId, offset, length, RPCResponse.Status.SUCCESS);\n      ChannelFuture future = ctx.writeAndFlush(resp);\n      future.addListener(new ClosableResourceChannelListener(writer));\n    } catch (Exception e) {\n      LOG.error(\"Error writing remote block : {}\", e.getMessage(), e);\n      RPCBlockWriteResponse resp =\n          RPCBlockWriteResponse.createErrorResponse(req, RPCResponse.Status.WRITE_ERROR);\n      ChannelFuture future = ctx.writeAndFlush(resp);\n      future.addListener(ChannelFutureListener.CLOSE);\n      if (writer != null) {\n        writer.close();\n      }\n    }\n  }","commit_id":"73ddec52d3e75b66d384cff3c1e280062c4fe345","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Handles a {@link RPCBlockReadRequest} by reading the data through a {@link BlockReader}\n   * provided by the block worker. This method assumes the data is available in the local storage\n   * of the worker and returns an error status if the data is not available.\n   *\n   * @param ctx The context of this request which handles the result of this operation\n   * @param req The initiating {@link RPCBlockReadRequest}\n   * @throws IOException if an I/O error occurs when reading the data requested\n   */\n  void handleBlockReadRequest(final ChannelHandlerContext ctx, final RPCBlockReadRequest req)\n      throws IOException {\n    final long blockId = req.getBlockId();\n    final long offset = req.getOffset();\n    final long len = req.getLength();\n    final long lockId = req.getLockId();\n    final long sessionId = req.getSessionId();\n\n    BlockReader reader = null;\n    DataBuffer buffer;\n    try {\n      req.validate();\n      reader = mWorker.readBlockRemote(sessionId, blockId, lockId);\n      final long fileLength = reader.getLength();\n      validateBounds(req, fileLength);\n      final long readLength = returnLength(offset, len, fileLength);\n      buffer = getDataBuffer(req, reader, readLength);\n      Metrics.BYTES_READ_REMOTE.inc(buffer.getLength());\n      RPCBlockReadResponse resp =\n          new RPCBlockReadResponse(blockId, offset, readLength, buffer, RPCResponse.Status.SUCCESS);\n      ChannelFuture future = ctx.writeAndFlush(resp);\n      future.addListener(ChannelFutureListener.CLOSE);\n      future.addListener(new ClosableResourceChannelListener(reader));\n      future.addListener(new ReleasableResourceChannelListener(buffer));\n      mWorker.accessBlock(sessionId, blockId);\n      LOG.info(\"Preparation for responding to remote block request for: {} done.\", blockId);\n    } catch (Exception e) {\n      LOG.error(\"Exception reading block {}\", blockId, e);\n      RPCBlockReadResponse resp;\n      if (e instanceof BlockDoesNotExistException) {\n        resp = RPCBlockReadResponse.createErrorResponse(req, RPCResponse.Status.FILE_DNE);\n      } else {\n        resp = RPCBlockReadResponse.createErrorResponse(req, RPCResponse.Status.UFS_READ_FAILED);\n      }\n      ChannelFuture future = ctx.writeAndFlush(resp);\n      future.addListener(ChannelFutureListener.CLOSE);\n      if (reader != null) {\n        reader.close();\n      }\n    }\n  }","id":49169,"modified_method":"/**\n   * Handles a {@link RPCBlockReadRequest} by reading the data through a {@link BlockReader}\n   * provided by the block worker. This method assumes the data is available in the local storage\n   * of the worker and returns an error status if the data is not available.\n   *\n   * @param ctx The context of this request which handles the result of this operation\n   * @param req The initiating {@link RPCBlockReadRequest}\n   * @throws IOException if an I/O error occurs when reading the data requested\n   */\n  void handleBlockReadRequest(final ChannelHandlerContext ctx, final RPCBlockReadRequest req)\n      throws IOException {\n    final long blockId = req.getBlockId();\n    final long offset = req.getOffset();\n    final long len = req.getLength();\n    final long lockId = req.getLockId();\n    final long sessionId = req.getSessionId();\n\n    BlockReader reader = null;\n    DataBuffer buffer;\n    try {\n      req.validate();\n      reader = mWorker.readBlockRemote(sessionId, blockId, lockId);\n      final long fileLength = reader.getLength();\n      validateBounds(req, fileLength);\n      final long readLength = returnLength(offset, len, fileLength);\n      buffer = getDataBuffer(req, reader, readLength);\n      Metrics.BYTES_READ_REMOTE.inc(buffer.getLength());\n      RPCBlockReadResponse resp =\n          new RPCBlockReadResponse(blockId, offset, readLength, buffer, RPCResponse.Status.SUCCESS);\n      ChannelFuture future = ctx.writeAndFlush(resp);\n      future.addListener(new ClosableResourceChannelListener(reader));\n      future.addListener(new ReleasableResourceChannelListener(buffer));\n      mWorker.accessBlock(sessionId, blockId);\n      LOG.info(\"Preparation for responding to remote block request for: {} done.\", blockId);\n    } catch (Exception e) {\n      LOG.error(\"Exception reading block {}\", blockId, e);\n      RPCBlockReadResponse resp;\n      if (e instanceof BlockDoesNotExistException) {\n        resp = RPCBlockReadResponse.createErrorResponse(req, RPCResponse.Status.FILE_DNE);\n      } else {\n        resp = RPCBlockReadResponse.createErrorResponse(req, RPCResponse.Status.UFS_READ_FAILED);\n      }\n      ChannelFuture future = ctx.writeAndFlush(resp);\n      future.addListener(ChannelFutureListener.CLOSE);\n      if (reader != null) {\n        reader.close();\n      }\n    }\n  }","commit_id":"73ddec52d3e75b66d384cff3c1e280062c4fe345","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  void runCommand(AlluxioURI path, CommandLine cl) throws AlluxioException, IOException {\n    URIStatus status = mFileSystem.getStatus(path);\n\n    if (status.isFolder()) {\n      throw new FileDoesNotExistException(ExceptionMessage.PATH_MUST_BE_FILE.getMessage(path));\n    }\n    OpenFileOptions options = OpenFileOptions.defaults().setReadType(ReadType.NO_CACHE);\n    byte[] buf = new byte[512];\n    try (FileInStream is = mFileSystem.openFile(path, options)) {\n      int read = is.read(buf);\n      while (read != -1) {\n        System.out.write(buf, 0, read);\n        read = is.read(buf);\n      }\n    }\n  }","id":49170,"modified_method":"@Override\n  void runCommand(AlluxioURI path, CommandLine cl) throws AlluxioException, IOException {\n    URIStatus status = mFileSystem.getStatus(path);\n\n    if (status.isFolder()) {\n      throw new FileDoesNotExistException(ExceptionMessage.PATH_MUST_BE_FILE.getMessage(path));\n    }\n    for (;;) {\n      OpenFileOptions options = OpenFileOptions.defaults().setReadType(ReadType.NO_CACHE);\n      byte[] buf = new byte[512];\n      try (FileInStream is = mFileSystem.openFile(path, options)) {\n        int read = is.read(buf);\n        while (read != -1) {\n          System.out.write(buf, 0, read);\n          read = is.read(buf);\n        }\n      }\n      try {\n        Thread.sleep(1000 * 36001);\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n    }\n  }","commit_id":"73ddec52d3e75b66d384cff3c1e280062c4fe345","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n    LOG.warn(\"Exception thrown while processing request\", cause);\n    ctx.close();\n  }","id":49171,"modified_method":"@Override\n  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n    LOG.warn(\"Exception thrown while processing request\", cause);\n    for (ResponseListener listener : mListeners) {\n      listener.onExceptionCaught(cause);\n    }\n    ctx.close();\n  }","commit_id":"73ddec52d3e75b66d384cff3c1e280062c4fe345","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  protected void closeConnectionSync(Channel channel) {\n    channel.close().syncUninterruptibly();\n  }","id":49172,"modified_method":"/**\n   * Creates a netty channel pool instance with a minimum capacity of 1.\n   *\n   * @param bootstrap the netty bootstrap used to create netty channel\n   * @param maxCapacity the maximum capacity of the pool\n   * @param gcThresholdInSecs when a channel is older than this threshold and the pool's capacity\n   *        is above the minimum capaicty (1), it is closed and removed from the pool.\n   */\n  public NettyChannelPool(Bootstrap bootstrap, int maxCapacity, int gcThresholdInSecs) {\n    super(maxCapacity, 1);\n    mBootstrap = bootstrap;\n    mGcThresholdInSecs = gcThresholdInSecs;\n  }","commit_id":"73ddec52d3e75b66d384cff3c1e280062c4fe345","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public ByteBuffer readRemoteBlock(InetSocketAddress address, long blockId, long offset,\n      long length, long lockId, long sessionId) throws IOException {\n    SingleResponseListener listener = null;\n    try {\n      ChannelFuture f = mClientBootstrap.connect(address).sync();\n\n      LOG.info(\"Connected to remote machine {}\", address);\n      Channel channel = f.channel();\n      listener = new SingleResponseListener();\n      mHandler.addListener(listener);\n      channel.writeAndFlush(new RPCBlockReadRequest(blockId, offset, length, lockId, sessionId));\n\n      RPCResponse response = listener.get(NettyClient.TIMEOUT_MS, TimeUnit.MILLISECONDS);\n      channel.close().sync();\n\n      switch (response.getType()) {\n        case RPC_BLOCK_READ_RESPONSE:\n          RPCBlockReadResponse blockResponse = (RPCBlockReadResponse) response;\n          LOG.info(\"Data {} from remote machine {} received\", blockId, address);\n\n          RPCResponse.Status status = blockResponse.getStatus();\n          if (status == RPCResponse.Status.SUCCESS) {\n            // always clear the previous response before reading another one\n            close();\n            mReadResponse = blockResponse;\n            return blockResponse.getPayloadDataBuffer().getReadOnlyByteBuffer();\n          }\n          throw new IOException(status.getMessage() + \" response: \" + blockResponse);\n        case RPC_ERROR_RESPONSE:\n          RPCErrorResponse error = (RPCErrorResponse) response;\n          throw new IOException(error.getStatus().getMessage());\n        default:\n          throw new IOException(ExceptionMessage.UNEXPECTED_RPC_RESPONSE\n              .getMessage(response.getType(), RPCMessage.Type.RPC_BLOCK_READ_RESPONSE));\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    } finally {\n      if (listener != null) {\n        mHandler.removeListener(listener);\n      }\n    }\n  }","id":49173,"modified_method":"@Override\n  public ByteBuffer readRemoteBlock(InetSocketAddress address, long blockId, long offset,\n      long length, long lockId, long sessionId) throws IOException {\n    SingleResponseListener listener = null;\n    Channel channel = null;\n    Metrics.NETTY_BLOCK_READ_OPS.inc();\n    try {\n      channel = BlockStoreContext.acquireNettyChannel(address, mClientBootstrap);\n      listener = new SingleResponseListener();\n      ((ClientHandler) channel.pipeline().last()).addListener(listener);\n      ChannelFuture channelFuture =\n          channel.writeAndFlush(new RPCBlockReadRequest(blockId, offset, length, lockId, sessionId))\n              .sync();\n      if (channelFuture.isDone() && !channelFuture.isSuccess()) {\n        LOG.error(\"Failed to write to %s for block %d with error %s.\", address.toString(), blockId,\n            channelFuture.cause());\n        throw new IOException(channelFuture.cause());\n      }\n\n      RPCResponse response = listener.get(NettyClient.TIMEOUT_MS, TimeUnit.MILLISECONDS);\n\n      switch (response.getType()) {\n        case RPC_BLOCK_READ_RESPONSE:\n          RPCBlockReadResponse blockResponse = (RPCBlockReadResponse) response;\n          LOG.debug(\"Data {} from remote machine {} received\", blockId, address);\n\n          RPCResponse.Status status = blockResponse.getStatus();\n          if (status == RPCResponse.Status.SUCCESS) {\n            // always clear the previous response before reading another one\n            close();\n            mReadResponse = blockResponse;\n            return blockResponse.getPayloadDataBuffer().getReadOnlyByteBuffer();\n          }\n          throw new IOException(status.getMessage() + \" response: \" + blockResponse);\n        case RPC_ERROR_RESPONSE:\n          RPCErrorResponse error = (RPCErrorResponse) response;\n          Metrics.NETTY_BLOCK_READ_FAILURES.inc();\n          throw new IOException(error.getStatus().getMessage());\n        default:\n          throw new IOException(ExceptionMessage.UNEXPECTED_RPC_RESPONSE\n              .getMessage(response.getType(), RPCMessage.Type.RPC_BLOCK_READ_RESPONSE));\n      }\n    } catch (Exception e) {\n      Metrics.NETTY_BLOCK_READ_FAILURES.inc();\n      throw new IOException(e);\n    } finally {\n      if (channel != null && listener != null) {\n        ((ClientHandler) channel.pipeline().last()).removeListener(listener);\n      }\n      if (channel != null) {\n        BlockStoreContext.releaseNettyChannel(address, channel);\n      }\n    }\n  }","commit_id":"73ddec52d3e75b66d384cff3c1e280062c4fe345","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new {@link NettyRemoteBlockReader}.\n   *\n   * TODO(gene): Creating a new remote block reader may be expensive, so consider a connection pool.\n   */\n  public NettyRemoteBlockReader() {\n    mHandler = new ClientHandler();\n    mClientBootstrap = NettyClient.createClientBootstrap(mHandler);\n  }","id":49174,"modified_method":"/**\n   * Creates a new {@link NettyRemoteBlockReader}.\n   */\n  public NettyRemoteBlockReader() {\n    mClientBootstrap = NettyClient.createClientBootstrap(new ClientHandler());\n  }","commit_id":"73ddec52d3e75b66d384cff3c1e280062c4fe345","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Constructor.\n   *\n   * @param clientBootstrap bootstrap class of the client channel\n   * @param clientHandler handler of the client channel\n   */\n  public NettyRemoteBlockReader(Bootstrap clientBootstrap, ClientHandler clientHandler) {\n    mClientBootstrap = clientBootstrap;\n    mHandler = clientHandler;\n  }","id":49175,"modified_method":"/**\n   * Constructor.\n   *\n   * @param clientBootstrap bootstrap class of the client channel\n   * @param clientHandler handler of the client channel\n   */\n  public NettyRemoteBlockReader(Bootstrap clientBootstrap, ClientHandler clientHandler) {\n    mClientBootstrap = clientBootstrap;\n  }","commit_id":"73ddec52d3e75b66d384cff3c1e280062c4fe345","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new {@link NettyRemoteBlockWriter}.\n   */\n  public NettyRemoteBlockWriter() {\n    mHandler = new ClientHandler();\n    mClientBootstrap = NettyClient.createClientBootstrap(mHandler);\n    mOpen = false;\n  }","id":49176,"modified_method":"/**\n   * Creates a new {@link NettyRemoteBlockWriter}.\n   */\n  public NettyRemoteBlockWriter() {\n    mClientBootstrap = NettyClient.createClientBootstrap(new ClientHandler());\n    mOpen = false;\n  }","commit_id":"73ddec52d3e75b66d384cff3c1e280062c4fe345","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void write(byte[] bytes, int offset, int length) throws IOException {\n    SingleResponseListener listener = null;\n    try {\n      // TODO(hy): keep connection open across multiple write calls.\n      ChannelFuture f = mClientBootstrap.connect(mAddress).sync();\n\n      LOG.info(\"Connected to remote machine {}\", mAddress);\n      Channel channel = f.channel();\n      listener = new SingleResponseListener();\n      mHandler.addListener(listener);\n      channel.writeAndFlush(new RPCBlockWriteRequest(mSessionId, mBlockId, mWrittenBytes, length,\n          new DataByteArrayChannel(bytes, offset, length)));\n\n      RPCResponse response = listener.get(NettyClient.TIMEOUT_MS, TimeUnit.MILLISECONDS);\n      channel.close().sync();\n\n      switch (response.getType()) {\n        case RPC_BLOCK_WRITE_RESPONSE:\n          RPCBlockWriteResponse resp = (RPCBlockWriteResponse) response;\n          RPCResponse.Status status = resp.getStatus();\n          LOG.info(\"status: {} from remote machine {} received\", status, mAddress);\n\n          if (status != RPCResponse.Status.SUCCESS) {\n            throw new IOException(ExceptionMessage.BLOCK_WRITE_ERROR.getMessage(mBlockId,\n                mSessionId, mAddress, status.getMessage()));\n          }\n          mWrittenBytes += length;\n          break;\n        case RPC_ERROR_RESPONSE:\n          RPCErrorResponse error = (RPCErrorResponse) response;\n          throw new IOException(error.getStatus().getMessage());\n        default:\n          throw new IOException(ExceptionMessage.UNEXPECTED_RPC_RESPONSE\n              .getMessage(response.getType(), RPCMessage.Type.RPC_BLOCK_WRITE_RESPONSE));\n      }\n    } catch (Exception e) {\n      throw new IOException(e);\n    } finally {\n      if (listener != null) {\n        mHandler.removeListener(listener);\n      }\n    }\n  }","id":49177,"modified_method":"@Override\n  public void write(byte[] bytes, int offset, int length) throws IOException {\n    SingleResponseListener listener = null;\n    Channel channel = null;\n    Metrics.NETTY_BLOCK_WRITE_OPS.inc();\n    try {\n      channel = BlockStoreContext.acquireNettyChannel(mAddress, mClientBootstrap);\n      listener = new SingleResponseListener();\n      ((ClientHandler) channel.pipeline().last()).addListener(listener);\n      ChannelFuture channelFuture = channel.writeAndFlush(\n          new RPCBlockWriteRequest(mSessionId, mBlockId, mWrittenBytes, length,\n              new DataByteArrayChannel(bytes, offset, length))).sync();\n      if (channelFuture.isDone() && !channelFuture.isSuccess()) {\n        LOG.error(\"Failed to write to %s for block %d with error %s.\", mAddress.toString(),\n            mBlockId, channelFuture.cause());\n        throw new IOException(channelFuture.cause());\n      }\n\n      RPCResponse response = listener.get(NettyClient.TIMEOUT_MS, TimeUnit.MILLISECONDS);\n\n      switch (response.getType()) {\n        case RPC_BLOCK_WRITE_RESPONSE:\n          RPCBlockWriteResponse resp = (RPCBlockWriteResponse) response;\n          RPCResponse.Status status = resp.getStatus();\n          LOG.debug(\"status: {} from remote machine {} received\", status, mAddress);\n\n          if (status != RPCResponse.Status.SUCCESS) {\n            Metrics.NETTY_BLOCK_WRITE_FAILURES.inc();\n            throw new IOException(ExceptionMessage.BLOCK_WRITE_ERROR.getMessage(mBlockId,\n                mSessionId, mAddress, status.getMessage()));\n          }\n          mWrittenBytes += length;\n          break;\n        case RPC_ERROR_RESPONSE:\n          RPCErrorResponse error = (RPCErrorResponse) response;\n          throw new IOException(error.getStatus().getMessage());\n        default:\n          throw new IOException(ExceptionMessage.UNEXPECTED_RPC_RESPONSE\n              .getMessage(response.getType(), RPCMessage.Type.RPC_BLOCK_WRITE_RESPONSE));\n      }\n    } catch (Exception e) {\n      Metrics.NETTY_BLOCK_WRITE_FAILURES.inc();\n      throw new IOException(e);\n    } finally {\n      if (channel != null && listener != null) {\n        ((ClientHandler) channel.pipeline().last()).removeListener(listener);\n      }\n      if (channel != null) {\n        BlockStoreContext.releaseNettyChannel(mAddress, channel);\n      }\n    }\n  }","commit_id":"73ddec52d3e75b66d384cff3c1e280062c4fe345","url":"https://github.com/amplab/tachyon"},{"original_method":"public boolean isServiceDetected(InetAddress address, DetectorMonitor detectorMonitor) {\n        int port = getPort();\n        int retries = getRetries();\n        int timeout = getTimeout();\n        System.out.printf(\"Address: %s || port: %s || \\n\", address, getPort());\n        detectorMonitor.start(this, \"Checking address: %s for %s capability\", address, getServiceName());\n                \n        Client<Request, Response> client = getClient();\n        for (int attempts = 0; attempts <= retries; attempts++) {\n\n            try {\n                \n                client.connect(address, port, timeout);\n                \n                detectorMonitor.attempt(this, attempts, \"Attempting to connect to address: %s attempt #%s\",address.getHostAddress(),attempts);\n                \n                if (attemptConversation(client)) {\n                    return true;\n                }\n                \n            } catch (ConnectException cE) {\n                // Connection refused!! Continue to retry.\n                System.out.println(\"put before\");\n                cE.printStackTrace();\n                detectorMonitor.info(this, cE, \"Attempting to connect to address: %s attempt #%s\",address.getHostAddress(),attempts);\n            } catch (NoRouteToHostException e) {\n                // No Route to host!!!\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: No route to address %s was available\", getServiceName(), address.getHostAddress());\n                throw new UndeclaredThrowableException(e);\n            } catch (InterruptedIOException e) {\n                // Expected exception\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: Did not connect to to address within timeout: %d attempt: %d\", getServiceName(), timeout, attempts);\n            } catch (IOException e) {\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: An unexpected I/O exception occured contacting address %s\",getServiceName(), address.getHostAddress());\n            } catch (Throwable t) {\n                t.printStackTrace();\n                detectorMonitor.failure(this, \"%s: Failed to detect %s on address %s\", getServiceName(), getServiceName(), address.getHostAddress());\n                detectorMonitor.error(this, t, \"%s: An undeclared throwable exception was caught contating address %s\", getServiceName(), address.getHostAddress());\n            } finally {\n                client.close();\n            }\n        }\n        return false;\n    }","id":49178,"modified_method":"public boolean isServiceDetected(InetAddress address, DetectorMonitor detectorMonitor) {\n        String ipAddr = address.getHostAddress();\n        int port = getPort();\n        int retries = getRetries();\n        int timeout = getTimeout();\n        System.out.printf(\"Address: %s || port: %s || \\n\", address, getPort());\n        detectorMonitor.start(this, \"Checking address: %s for %s capability\", address, getServiceName());\n                \n        Client<Request, Response> client = getClient();\n        for (int attempts = 0; attempts <= retries; attempts++) {\n\n            try {\n                \n                client.connect(address, port, timeout);\n                \n                detectorMonitor.attempt(this, attempts, \"Attempting to connect to address: %s port %d attempt #%s\",ipAddr,port,attempts);\n                \n                if (attemptConversation(client)) {\n                    return true;\n                }\n                \n            } catch (ConnectException cE) {\n                // Connection refused!! Continue to retry.\n                System.out.println(\"put before\");\n                cE.printStackTrace();\n                detectorMonitor.info(this, cE, \"%s: Excpetion attempting to connect to address: %s port %d, attempt #%s\",getServiceName(), ipAddr,port, attempts);\n            } catch (NoRouteToHostException e) {\n                // No Route to host!!!\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: No route to address %s was available\", getServiceName(), ipAddr);\n                throw new UndeclaredThrowableException(e);\n            } catch (InterruptedIOException e) {\n                // Expected exception\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: Did not connect to to address %s port %d within timeout: %d attempt: %d\", getServiceName(), ipAddr, port, timeout, attempts);\n            } catch (IOException e) {\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: An unexpected I/O exception occured contacting address %s port %d\",getServiceName(), ipAddr, port);\n            } catch (Throwable t) {\n                t.printStackTrace();\n                detectorMonitor.failure(this, \"%s: Failed to detect %s on address %s port %d\", getServiceName(), getServiceName(), ipAddr, port);\n                detectorMonitor.error(this, t, \"%s: An undeclared throwable exception was caught contating address %s port %d\", getServiceName(), ipAddr, port);\n            } finally {\n                client.close();\n            }\n        }\n        return false;\n    }","commit_id":"ecef0252c0f9fba2fae189e138c663096e2b4275","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean isServiceDetected(InetAddress address, DetectorMonitor detectorMonitor) {\n        int port = getPort();\n        int retries = getRetries();\n        int timeout = getTimeout();\n        System.out.printf(\"Address: %s || port: %s || \\n\", address, getPort());\n        detectorMonitor.start(this, \"Checking address: %s for %s capability\", address, getServiceName());\n                \n        Client<Request, Response> client = getClient();\n        for (int attempts = 0; attempts <= retries; attempts++) {\n\n            try {\n                \n                client.connect(address, port, timeout);\n                \n                detectorMonitor.attempt(this, attempts, \"Attempting to connect to address: %s attempt #%s\",address.getHostAddress(),attempts);\n                \n                if (attemptConversation(client)) {\n                    return true;\n                }\n                \n            } catch (ConnectException cE) {\n                // Connection refused!! Continue to retry.\n                System.out.println(\"put before\");\n                cE.printStackTrace();\n                detectorMonitor.info(this, cE, \"Attempting to connect to address: %s attempt #%s\",address.getHostAddress(),attempts);\n            } catch (NoRouteToHostException e) {\n                // No Route to host!!!\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: No route to address %s was available\", getServiceName(), address.getHostAddress());\n                throw new UndeclaredThrowableException(e);\n            } catch (InterruptedIOException e) {\n                // Expected exception\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: Did not connect to to address within timeout: %d attempt: %d\", getServiceName(), timeout, attempts);\n            } catch (IOException e) {\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: An unexpected I/O exception occured contacting address %s\",getServiceName(), address.getHostAddress());\n            } catch (Throwable t) {\n                t.printStackTrace();\n                detectorMonitor.failure(this, \"%s: Failed to detect %s on address %s\", getServiceName(), getServiceName(), address.getHostAddress());\n                detectorMonitor.error(this, t, \"%s: An undeclared throwable exception was caught contating address %s\", getServiceName(), address.getHostAddress());\n            } finally {\n                client.close();\n            }\n        }\n        return false;\n    }","id":49179,"modified_method":"public boolean isServiceDetected(InetAddress address, DetectorMonitor detectorMonitor) {\n        String ipAddr = address.getHostAddress();\n        int port = getPort();\n        int retries = getRetries();\n        int timeout = getTimeout();\n        System.out.printf(\"Address: %s || port: %s || \\n\", address, getPort());\n        detectorMonitor.start(this, \"Checking address: %s for %s capability\", address, getServiceName());\n                \n        Client<Request, Response> client = getClient();\n        for (int attempts = 0; attempts <= retries; attempts++) {\n\n            try {\n                \n                client.connect(address, port, timeout);\n                \n                detectorMonitor.attempt(this, attempts, \"Attempting to connect to address: %s port %d attempt #%s\",ipAddr,port,attempts);\n                \n                if (attemptConversation(client)) {\n                    return true;\n                }\n                \n            } catch (ConnectException cE) {\n                // Connection refused!! Continue to retry.\n                System.out.println(\"put before\");\n                cE.printStackTrace();\n                detectorMonitor.info(this, cE, \"%s: Excpetion attempting to connect to address: %s port %d, attempt #%s\",getServiceName(), ipAddr,port, attempts);\n            } catch (NoRouteToHostException e) {\n                // No Route to host!!!\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: No route to address %s was available\", getServiceName(), ipAddr);\n                throw new UndeclaredThrowableException(e);\n            } catch (InterruptedIOException e) {\n                // Expected exception\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: Did not connect to to address %s port %d within timeout: %d attempt: %d\", getServiceName(), ipAddr, port, timeout, attempts);\n            } catch (IOException e) {\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: An unexpected I/O exception occured contacting address %s port %d\",getServiceName(), ipAddr, port);\n            } catch (Throwable t) {\n                t.printStackTrace();\n                detectorMonitor.failure(this, \"%s: Failed to detect %s on address %s port %d\", getServiceName(), getServiceName(), ipAddr, port);\n                detectorMonitor.error(this, t, \"%s: An undeclared throwable exception was caught contating address %s port %d\", getServiceName(), ipAddr, port);\n            } finally {\n                client.close();\n            }\n        }\n        return false;\n    }","commit_id":"201c00d2d86c04e876aa3a1d0e5b381daff0bcae","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public boolean isServiceDetected(InetAddress address, DetectorMonitor detectorMonitor) {\n        int port = getPort();\n        int retries = getRetries();\n        int timeout = getTimeout();\n        System.out.printf(\"Address: %s || port: %s || \\n\", address, getPort());\n        detectorMonitor.start(this, \"Checking address: %s for %s capability\", address, getServiceName());\n                \n        Client<Request, Response> client = getClient();\n        for (int attempts = 0; attempts <= retries; attempts++) {\n\n            try {\n                \n                client.connect(address, port, timeout);\n                \n                detectorMonitor.attempt(this, attempts, \"Attempting to connect to address: %s attempt #%s\",address.getHostAddress(),attempts);\n                \n                if (attemptConversation(client)) {\n                    return true;\n                }\n                \n            } catch (ConnectException cE) {\n                // Connection refused!! Continue to retry.\n                System.out.println(\"put before\");\n                cE.printStackTrace();\n                detectorMonitor.info(this, cE, \"Attempting to connect to address: %s attempt #%s\",address.getHostAddress(),attempts);\n            } catch (NoRouteToHostException e) {\n                // No Route to host!!!\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: No route to address %s was available\", getServiceName(), address.getHostAddress());\n                throw new UndeclaredThrowableException(e);\n            } catch (InterruptedIOException e) {\n                // Expected exception\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: Did not connect to to address within timeout: %d attempt: %d\", getServiceName(), timeout, attempts);\n            } catch (IOException e) {\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: An unexpected I/O exception occured contacting address %s\",getServiceName(), address.getHostAddress());\n            } catch (Throwable t) {\n                t.printStackTrace();\n                detectorMonitor.failure(this, \"%s: Failed to detect %s on address %s\", getServiceName(), getServiceName(), address.getHostAddress());\n                detectorMonitor.error(this, t, \"%s: An undeclared throwable exception was caught contating address %s\", getServiceName(), address.getHostAddress());\n            } finally {\n                client.close();\n            }\n        }\n        return false;\n    }","id":49180,"modified_method":"public boolean isServiceDetected(InetAddress address, DetectorMonitor detectorMonitor) {\n        String ipAddr = address.getHostAddress();\n        int port = getPort();\n        int retries = getRetries();\n        int timeout = getTimeout();\n        System.out.printf(\"Address: %s || port: %s || \\n\", address, getPort());\n        detectorMonitor.start(this, \"Checking address: %s for %s capability\", address, getServiceName());\n                \n        Client<Request, Response> client = getClient();\n        for (int attempts = 0; attempts <= retries; attempts++) {\n\n            try {\n                \n                client.connect(address, port, timeout);\n                \n                detectorMonitor.attempt(this, attempts, \"Attempting to connect to address: %s port %d attempt #%s\",ipAddr,port,attempts);\n                \n                if (attemptConversation(client)) {\n                    return true;\n                }\n                \n            } catch (ConnectException cE) {\n                // Connection refused!! Continue to retry.\n                System.out.println(\"put before\");\n                cE.printStackTrace();\n                detectorMonitor.info(this, cE, \"%s: Excpetion attempting to connect to address: %s port %d, attempt #%s\",getServiceName(), ipAddr,port, attempts);\n            } catch (NoRouteToHostException e) {\n                // No Route to host!!!\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: No route to address %s was available\", getServiceName(), ipAddr);\n                throw new UndeclaredThrowableException(e);\n            } catch (InterruptedIOException e) {\n                // Expected exception\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: Did not connect to to address %s port %d within timeout: %d attempt: %d\", getServiceName(), ipAddr, port, timeout, attempts);\n            } catch (IOException e) {\n                e.printStackTrace();\n                detectorMonitor.info(this, e, \"%s: An unexpected I/O exception occured contacting address %s port %d\",getServiceName(), ipAddr, port);\n            } catch (Throwable t) {\n                t.printStackTrace();\n                detectorMonitor.failure(this, \"%s: Failed to detect %s on address %s port %d\", getServiceName(), getServiceName(), ipAddr, port);\n                detectorMonitor.error(this, t, \"%s: An undeclared throwable exception was caught contating address %s port %d\", getServiceName(), ipAddr, port);\n            } finally {\n                client.close();\n            }\n        }\n        return false;\n    }","commit_id":"77387643cfdd1815fb71f81f057b77bb702a1262","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public ForeignSource saveForeignSource(String name, ForeignSource fs) {\n        m_pendingForeignSourceRepository.save(fs);\n        return fs;\n    }","id":49181,"modified_method":"public ForeignSource saveForeignSource(String name, ForeignSource fs) {\n        normalizePluginConfigs(fs);\n        m_pendingForeignSourceRepository.save(fs);\n        return fs;\n    }","commit_id":"1aeca271bc796bbd7c23c50ffff714f9e049d6c0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    protected Map referenceData(HttpServletRequest request) throws Exception {\n        final Map<String, Object> map = new HashMap<String, Object>();\n        int width = 50;\n\n        final Map<String,Set<String>> classParameters = new TreeMap<String,Set<String>>();\n\n        final Map<String,String> detectorTypes = m_foreignSourceService.getDetectorTypes();\n        map.put(\"detectorTypes\", detectorTypes);\n        for (String key : detectorTypes.keySet()) {\n            classParameters.put(key, getParametersForClass(key));\n            width = Math.max(width, key.length());\n        }\n\n        final Map<String, String> policyTypes = m_foreignSourceService.getPolicyTypes();\n        map.put(\"policyTypes\", policyTypes);\n        for (String key : policyTypes.keySet()) {\n            classParameters.put(key, getParametersForClass(key));\n            width = Math.max(width, key.length());\n        }\n\n        final Map<String, PluginWrapper> wrappers = new TreeMap<String, PluginWrapper>();\n        for (String key : policyTypes.keySet()) {\n            PluginWrapper wrapper = new PluginWrapper(key);\n            wrappers.put(key, wrapper);\n        }\n\n        map.put(\"pluginInfo\", wrappers);\n        map.put(\"classParameters\", classParameters);\n        map.put(\"fieldWidth\", width);\n        \n        return map;\n    }","id":49182,"modified_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    protected Map referenceData(HttpServletRequest request) throws Exception {\n        final Map<String, Object> map = new HashMap<String, Object>();\n        int classFieldWidth = 20;\n        int valueFieldWidth = 20;\n\n        final Map<String,Set<String>> classParameters = new TreeMap<String,Set<String>>();\n\n        final Map<String,String> detectorTypes = m_foreignSourceService.getDetectorTypes();\n        map.put(\"detectorTypes\", detectorTypes);\n        for (String key : detectorTypes.keySet()) {\n            classParameters.put(key, getParametersForClass(key));\n            classFieldWidth = Math.max(classFieldWidth, key.length());\n        }\n\n        final Map<String, String> policyTypes = m_foreignSourceService.getPolicyTypes();\n        map.put(\"policyTypes\", policyTypes);\n        for (String key : policyTypes.keySet()) {\n            classParameters.put(key, getParametersForClass(key));\n            classFieldWidth = Math.max(classFieldWidth, key.length());\n        }\n\n        map.put(\"pluginInfo\", m_foreignSourceService.getWrappers());\n        map.put(\"classParameters\", classParameters);\n        map.put(\"classFieldWidth\", classFieldWidth);\n        map.put(\"valueFieldWidth\", valueFieldWidth);\n        \n        return map;\n    }","commit_id":"1aeca271bc796bbd7c23c50ffff714f9e049d6c0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Set<String> getParametersForClass(String clazz) {\n        if (m_pluginParameters.containsKey(clazz)) {\n            return m_pluginParameters.get(clazz);\n        }\n        Set<String> parameters = new TreeSet<String>();\n        try {\n            BeanWrapper wrapper = new BeanWrapperImpl(Class.forName(clazz));\n            for (PropertyDescriptor pd : wrapper.getPropertyDescriptors()) {\n                parameters.add(pd.getName());\n            }\n            m_pluginParameters.put(clazz, parameters);\n            return parameters;\n        } catch (ClassNotFoundException e) {\n            log().warn(\"unable to wrap class \" + clazz, e);\n        }\n        return null;\n    }","id":49183,"modified_method":"private Set<String> getParametersForClass(String clazz) {\n        if (m_pluginParameters.containsKey(clazz)) {\n            return m_pluginParameters.get(clazz);\n        }\n        Set<String> parameters = new TreeSet<String>();\n        try {\n            BeanWrapper wrapper = new BeanWrapperImpl(Class.forName(clazz));\n            for (PropertyDescriptor pd : wrapper.getPropertyDescriptors()) {\n                if (!pd.getName().equals(\"class\")) {\n                    parameters.add(pd.getName());\n                }\n            }\n            m_pluginParameters.put(clazz, parameters);\n            return parameters;\n        } catch (ClassNotFoundException e) {\n            log().warn(\"unable to wrap class \" + clazz, e);\n        }\n        return null;\n    }","commit_id":"1aeca271bc796bbd7c23c50ffff714f9e049d6c0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public PluginWrapper(String className) throws ClassNotFoundException {\n        m_className = className;\n        BeanWrapper wrapper = new BeanWrapperImpl(Class.forName(m_className));\n        for (PropertyDescriptor pd : wrapper.getPropertyDescriptors()) {\n            m_parameterNames.add(pd.getName());\n            Set<String> choices = null;\n            if (pd.getPropertyType().isEnum()) {\n                choices = new TreeSet<String>();\n                for (Object o : pd.getPropertyType().getEnumConstants()) {\n                    choices.add(o.toString());\n                }\n            }\n            m_choices.put(pd.getName(), choices);\n        }\n    }","id":49184,"modified_method":"public PluginWrapper(String className) throws ClassNotFoundException {\n        m_className = className;\n        BeanWrapper wrapper = new BeanWrapperImpl(Class.forName(m_className));\n\n        for (PropertyDescriptor pd : wrapper.getPropertyDescriptors()) {\n            if (pd.getName().equals(\"class\")) {\n                continue;\n            }\n            Method m = pd.getReadMethod();\n            if (m.isAnnotationPresent(Allow.class)) {\n                Set<String> values = new TreeSet<String>();\n                Allow a = m.getAnnotation(Allow.class);\n                for (String key: a.value()) {\n                    values.add(key);\n                }\n                m_required.put(pd.getName(), values);\n            } else {\n                m_optional.put(pd.getName(), null);\n            }\n        }\n    }","commit_id":"1aeca271bc796bbd7c23c50ffff714f9e049d6c0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testChoices() throws Exception {\n        String policyClass = MatchingSnmpInterfacePolicy.class.getName();\n        \n        PluginWrapper wrapper = new PluginWrapper(policyClass);\n        System.err.println(wrapper.getChoices().get(\"action\"));\n        \n        \n    }","id":49185,"modified_method":"@Test\n    public void testChoices() throws Exception {\n        String policyClass = MatchingSnmpInterfacePolicy.class.getName();\n        \n        PluginWrapper wrapper = new PluginWrapper(policyClass);\n        assertTrue(\"required keys must contain matchBehavior\", wrapper.getRequired().containsKey(\"matchBehavior\"));\n        assertTrue(\"action must contain DISABLE_COLLECTION\", wrapper.getRequired().get(\"action\").contains(\"DISABLE_COLLECTION\"));\n    }","commit_id":"1aeca271bc796bbd7c23c50ffff714f9e049d6c0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public ForeignSource saveForeignSource(String name, ForeignSource fs) {\n        m_pendingForeignSourceRepository.save(fs);\n        return fs;\n    }","id":49186,"modified_method":"public ForeignSource saveForeignSource(String name, ForeignSource fs) {\n        normalizePluginConfigs(fs);\n        m_pendingForeignSourceRepository.save(fs);\n        return fs;\n    }","commit_id":"e237cda7081c49b06ab517bd37fbebeefafd3b2a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    protected Map referenceData(HttpServletRequest request) throws Exception {\n        final Map<String, Object> map = new HashMap<String, Object>();\n        int width = 50;\n\n        final Map<String,Set<String>> classParameters = new TreeMap<String,Set<String>>();\n\n        final Map<String,String> detectorTypes = m_foreignSourceService.getDetectorTypes();\n        map.put(\"detectorTypes\", detectorTypes);\n        for (String key : detectorTypes.keySet()) {\n            classParameters.put(key, getParametersForClass(key));\n            width = Math.max(width, key.length());\n        }\n\n        final Map<String, String> policyTypes = m_foreignSourceService.getPolicyTypes();\n        map.put(\"policyTypes\", policyTypes);\n        for (String key : policyTypes.keySet()) {\n            classParameters.put(key, getParametersForClass(key));\n            width = Math.max(width, key.length());\n        }\n\n        final Map<String, PluginWrapper> wrappers = new TreeMap<String, PluginWrapper>();\n        for (String key : policyTypes.keySet()) {\n            PluginWrapper wrapper = new PluginWrapper(key);\n            wrappers.put(key, wrapper);\n        }\n\n        map.put(\"pluginInfo\", wrappers);\n        map.put(\"classParameters\", classParameters);\n        map.put(\"fieldWidth\", width);\n        \n        return map;\n    }","id":49187,"modified_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    protected Map referenceData(HttpServletRequest request) throws Exception {\n        final Map<String, Object> map = new HashMap<String, Object>();\n        int classFieldWidth = 20;\n        int valueFieldWidth = 20;\n\n        final Map<String,Set<String>> classParameters = new TreeMap<String,Set<String>>();\n\n        final Map<String,String> detectorTypes = m_foreignSourceService.getDetectorTypes();\n        map.put(\"detectorTypes\", detectorTypes);\n        for (String key : detectorTypes.keySet()) {\n            classParameters.put(key, getParametersForClass(key));\n            classFieldWidth = Math.max(classFieldWidth, key.length());\n        }\n\n        final Map<String, String> policyTypes = m_foreignSourceService.getPolicyTypes();\n        map.put(\"policyTypes\", policyTypes);\n        for (String key : policyTypes.keySet()) {\n            classParameters.put(key, getParametersForClass(key));\n            classFieldWidth = Math.max(classFieldWidth, key.length());\n        }\n\n        map.put(\"pluginInfo\", m_foreignSourceService.getWrappers());\n        map.put(\"classParameters\", classParameters);\n        map.put(\"classFieldWidth\", classFieldWidth);\n        map.put(\"valueFieldWidth\", valueFieldWidth);\n        \n        return map;\n    }","commit_id":"e237cda7081c49b06ab517bd37fbebeefafd3b2a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Set<String> getParametersForClass(String clazz) {\n        if (m_pluginParameters.containsKey(clazz)) {\n            return m_pluginParameters.get(clazz);\n        }\n        Set<String> parameters = new TreeSet<String>();\n        try {\n            BeanWrapper wrapper = new BeanWrapperImpl(Class.forName(clazz));\n            for (PropertyDescriptor pd : wrapper.getPropertyDescriptors()) {\n                parameters.add(pd.getName());\n            }\n            m_pluginParameters.put(clazz, parameters);\n            return parameters;\n        } catch (ClassNotFoundException e) {\n            log().warn(\"unable to wrap class \" + clazz, e);\n        }\n        return null;\n    }","id":49188,"modified_method":"private Set<String> getParametersForClass(String clazz) {\n        if (m_pluginParameters.containsKey(clazz)) {\n            return m_pluginParameters.get(clazz);\n        }\n        Set<String> parameters = new TreeSet<String>();\n        try {\n            BeanWrapper wrapper = new BeanWrapperImpl(Class.forName(clazz));\n            for (PropertyDescriptor pd : wrapper.getPropertyDescriptors()) {\n                if (!pd.getName().equals(\"class\")) {\n                    parameters.add(pd.getName());\n                }\n            }\n            m_pluginParameters.put(clazz, parameters);\n            return parameters;\n        } catch (ClassNotFoundException e) {\n            log().warn(\"unable to wrap class \" + clazz, e);\n        }\n        return null;\n    }","commit_id":"e237cda7081c49b06ab517bd37fbebeefafd3b2a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public PluginWrapper(String className) throws ClassNotFoundException {\n        m_className = className;\n        BeanWrapper wrapper = new BeanWrapperImpl(Class.forName(m_className));\n        for (PropertyDescriptor pd : wrapper.getPropertyDescriptors()) {\n            m_parameterNames.add(pd.getName());\n            Set<String> choices = null;\n            if (pd.getPropertyType().isEnum()) {\n                choices = new TreeSet<String>();\n                for (Object o : pd.getPropertyType().getEnumConstants()) {\n                    choices.add(o.toString());\n                }\n            }\n            m_choices.put(pd.getName(), choices);\n        }\n    }","id":49189,"modified_method":"public PluginWrapper(String className) throws ClassNotFoundException {\n        m_className = className;\n        BeanWrapper wrapper = new BeanWrapperImpl(Class.forName(m_className));\n\n        for (PropertyDescriptor pd : wrapper.getPropertyDescriptors()) {\n            if (pd.getName().equals(\"class\")) {\n                continue;\n            }\n            Method m = pd.getReadMethod();\n            if (m.isAnnotationPresent(Allow.class)) {\n                Set<String> values = new TreeSet<String>();\n                Allow a = m.getAnnotation(Allow.class);\n                for (String key: a.value()) {\n                    values.add(key);\n                }\n                m_required.put(pd.getName(), values);\n            } else {\n                m_optional.put(pd.getName(), null);\n            }\n        }\n    }","commit_id":"e237cda7081c49b06ab517bd37fbebeefafd3b2a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testChoices() throws Exception {\n        String policyClass = MatchingSnmpInterfacePolicy.class.getName();\n        \n        PluginWrapper wrapper = new PluginWrapper(policyClass);\n        System.err.println(wrapper.getChoices().get(\"action\"));\n        \n        \n    }","id":49190,"modified_method":"@Test\n    public void testChoices() throws Exception {\n        String policyClass = MatchingSnmpInterfacePolicy.class.getName();\n        \n        PluginWrapper wrapper = new PluginWrapper(policyClass);\n        assertTrue(\"required keys must contain matchBehavior\", wrapper.getRequired().containsKey(\"matchBehavior\"));\n        assertTrue(\"action must contain DISABLE_COLLECTION\", wrapper.getRequired().get(\"action\").contains(\"DISABLE_COLLECTION\"));\n    }","commit_id":"e237cda7081c49b06ab517bd37fbebeefafd3b2a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public ForeignSource saveForeignSource(String name, ForeignSource fs) {\n        m_pendingForeignSourceRepository.save(fs);\n        return fs;\n    }","id":49191,"modified_method":"public ForeignSource saveForeignSource(String name, ForeignSource fs) {\n        normalizePluginConfigs(fs);\n        m_pendingForeignSourceRepository.save(fs);\n        return fs;\n    }","commit_id":"075b6bc3bfa279f0a4e03d0e66f46e56674c2bcf","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Set<String> getParametersForClass(String clazz) {\n        if (m_pluginParameters.containsKey(clazz)) {\n            return m_pluginParameters.get(clazz);\n        }\n        Set<String> parameters = new TreeSet<String>();\n        try {\n            BeanWrapper wrapper = new BeanWrapperImpl(Class.forName(clazz));\n            for (PropertyDescriptor pd : wrapper.getPropertyDescriptors()) {\n                parameters.add(pd.getName());\n            }\n            m_pluginParameters.put(clazz, parameters);\n            return parameters;\n        } catch (ClassNotFoundException e) {\n            log().warn(\"unable to wrap class \" + clazz, e);\n        }\n        return null;\n    }","id":49192,"modified_method":"private Set<String> getParametersForClass(String clazz) {\n        if (m_pluginParameters.containsKey(clazz)) {\n            return m_pluginParameters.get(clazz);\n        }\n        Set<String> parameters = new TreeSet<String>();\n        try {\n            BeanWrapper wrapper = new BeanWrapperImpl(Class.forName(clazz));\n            for (PropertyDescriptor pd : wrapper.getPropertyDescriptors()) {\n                if (!pd.getName().equals(\"class\")) {\n                    parameters.add(pd.getName());\n                }\n            }\n            m_pluginParameters.put(clazz, parameters);\n            return parameters;\n        } catch (ClassNotFoundException e) {\n            log().warn(\"unable to wrap class \" + clazz, e);\n        }\n        return null;\n    }","commit_id":"075b6bc3bfa279f0a4e03d0e66f46e56674c2bcf","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    protected Map referenceData(HttpServletRequest request) throws Exception {\n        final Map<String, Object> map = new HashMap<String, Object>();\n        int width = 50;\n\n        final Map<String,Set<String>> classParameters = new TreeMap<String,Set<String>>();\n\n        final Map<String,String> detectorTypes = m_foreignSourceService.getDetectorTypes();\n        map.put(\"detectorTypes\", detectorTypes);\n        for (String key : detectorTypes.keySet()) {\n            classParameters.put(key, getParametersForClass(key));\n            width = Math.max(width, key.length());\n        }\n\n        final Map<String, String> policyTypes = m_foreignSourceService.getPolicyTypes();\n        map.put(\"policyTypes\", policyTypes);\n        for (String key : policyTypes.keySet()) {\n            classParameters.put(key, getParametersForClass(key));\n            width = Math.max(width, key.length());\n        }\n\n        final Map<String, PluginWrapper> wrappers = new TreeMap<String, PluginWrapper>();\n        for (String key : policyTypes.keySet()) {\n            PluginWrapper wrapper = new PluginWrapper(key);\n            wrappers.put(key, wrapper);\n        }\n\n        map.put(\"pluginInfo\", wrappers);\n        map.put(\"classParameters\", classParameters);\n        map.put(\"fieldWidth\", width);\n        \n        return map;\n    }","id":49193,"modified_method":"@SuppressWarnings(\"unchecked\")\n    @Override\n    protected Map referenceData(HttpServletRequest request) throws Exception {\n        final Map<String, Object> map = new HashMap<String, Object>();\n        int classFieldWidth = 20;\n        int valueFieldWidth = 20;\n\n        final Map<String,Set<String>> classParameters = new TreeMap<String,Set<String>>();\n\n        final Map<String,String> detectorTypes = m_foreignSourceService.getDetectorTypes();\n        map.put(\"detectorTypes\", detectorTypes);\n        for (String key : detectorTypes.keySet()) {\n            classParameters.put(key, getParametersForClass(key));\n            classFieldWidth = Math.max(classFieldWidth, key.length());\n        }\n\n        final Map<String, String> policyTypes = m_foreignSourceService.getPolicyTypes();\n        map.put(\"policyTypes\", policyTypes);\n        for (String key : policyTypes.keySet()) {\n            classParameters.put(key, getParametersForClass(key));\n            classFieldWidth = Math.max(classFieldWidth, key.length());\n        }\n\n        map.put(\"pluginInfo\", m_foreignSourceService.getWrappers());\n        map.put(\"classParameters\", classParameters);\n        map.put(\"classFieldWidth\", classFieldWidth);\n        map.put(\"valueFieldWidth\", valueFieldWidth);\n        \n        return map;\n    }","commit_id":"075b6bc3bfa279f0a4e03d0e66f46e56674c2bcf","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public PluginWrapper(String className) throws ClassNotFoundException {\n        m_className = className;\n        BeanWrapper wrapper = new BeanWrapperImpl(Class.forName(m_className));\n        for (PropertyDescriptor pd : wrapper.getPropertyDescriptors()) {\n            m_parameterNames.add(pd.getName());\n            Set<String> choices = null;\n            if (pd.getPropertyType().isEnum()) {\n                choices = new TreeSet<String>();\n                for (Object o : pd.getPropertyType().getEnumConstants()) {\n                    choices.add(o.toString());\n                }\n            }\n            m_choices.put(pd.getName(), choices);\n        }\n    }","id":49194,"modified_method":"public PluginWrapper(String className) throws ClassNotFoundException {\n        m_className = className;\n        BeanWrapper wrapper = new BeanWrapperImpl(Class.forName(m_className));\n\n        for (PropertyDescriptor pd : wrapper.getPropertyDescriptors()) {\n            if (pd.getName().equals(\"class\")) {\n                continue;\n            }\n            Method m = pd.getReadMethod();\n            if (m.isAnnotationPresent(Allow.class)) {\n                Set<String> values = new TreeSet<String>();\n                Allow a = m.getAnnotation(Allow.class);\n                for (String key: a.value()) {\n                    values.add(key);\n                }\n                m_required.put(pd.getName(), values);\n            } else {\n                m_optional.put(pd.getName(), null);\n            }\n        }\n    }","commit_id":"075b6bc3bfa279f0a4e03d0e66f46e56674c2bcf","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testChoices() throws Exception {\n        String policyClass = MatchingSnmpInterfacePolicy.class.getName();\n        \n        PluginWrapper wrapper = new PluginWrapper(policyClass);\n        System.err.println(wrapper.getChoices().get(\"action\"));\n        \n        \n    }","id":49195,"modified_method":"@Test\n    public void testChoices() throws Exception {\n        String policyClass = MatchingSnmpInterfacePolicy.class.getName();\n        \n        PluginWrapper wrapper = new PluginWrapper(policyClass);\n        assertTrue(\"required keys must contain matchBehavior\", wrapper.getRequired().containsKey(\"matchBehavior\"));\n        assertTrue(\"action must contain DISABLE_COLLECTION\", wrapper.getRequired().get(\"action\").contains(\"DISABLE_COLLECTION\"));\n    }","commit_id":"075b6bc3bfa279f0a4e03d0e66f46e56674c2bcf","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t\t * <p>getCdpCacheDeviceId<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t */\n\t\tpublic String getCdpCacheDeviceId() {\n\t\t\treturn getValue(CDP_CACHE_DEVICE_ID).toDisplayString();\n\t\t}","id":49196,"modified_method":"/**\n\t\t * <p>getCdpCacheDeviceId<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t */\n\t\tpublic String getCdpCacheDeviceId() {\n\t\t    if (getValue(CDP_CACHE_DEVICE_ID).isDisplayable())\n\t\t\treturn getValue(CDP_CACHE_DEVICE_ID).toDisplayString();\n\t\t    return getValue(CDP_CACHE_DEVICE_ID).toHexString();\n\t\t}","commit_id":"e3944b33b84d680b11b1d08dc243708b09ae290a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t\t * <p>getCdpCacheDevicePort<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t */\n\t\tpublic String getCdpCacheDevicePort() {\n\t\t\treturn \tgetValue(CDP_CACHE_DEVICE_PORT).toDisplayString();\n\t\t}","id":49197,"modified_method":"/**\n\t\t * <p>getCdpCacheDevicePort<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t */\n\t\tpublic String getCdpCacheDevicePort() {\n\t\t    if (getValue(CDP_CACHE_DEVICE_PORT).isDisplayable())\n\t\t\treturn \tgetValue(CDP_CACHE_DEVICE_PORT).toDisplayString();\n\t\t    return getValue(CDP_CACHE_DEVICE_PORT).toHexString();\n\t\t}","commit_id":"e3944b33b84d680b11b1d08dc243708b09ae290a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    @JUnitSnmpAgents(value={\n            @JUnitSnmpAgent(host=SWITCH02_IP, port=161, resource=SWITCH02_SNMP_RESOURCE)\n    })\n    public void testSwitch02Links() throws Exception {\n        \n        m_nodeDao.save(builder.getSwitch02());\n        m_nodeDao.flush();\n\n        m_linkdConfig.getConfiguration().setUseBridgeDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseOspfDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseIsisDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseLldpDiscovery(false);\n        \n        assertTrue(!m_linkdConfig.useIsisDiscovery());\n        assertTrue(!m_linkdConfig.useBridgeDiscovery());\n        assertTrue(!m_linkdConfig.useOspfDiscovery());\n        assertTrue(!m_linkdConfig.useLldpDiscovery());\n        assertTrue(m_linkdConfig.useCdpDiscovery());\n        \n        final OnmsNode switch02 = m_nodeDao.findByForeignId(\"linkd\", SWITCH02_NAME);\n        \n        assertTrue(m_linkd.scheduleNodeCollection(switch02.getId()));\n\n        assertTrue(m_linkd.runSingleSnmpCollection(switch02.getId()));\n\n        for (final OnmsNode node: m_nodeDao.findAll()) {\n            assertNotNull(node.getCdpElement());\n            printCdpElement(node.getCdpElement());\n            assertEquals(TruthValue.TRUE, node.getCdpElement().getCdpGlobalRun());\n            assertEquals(SWITCH02_CDP_GLOBAL_DEVICE_ID,node.getCdpElement().getCdpGlobalDeviceId());\n        }\n\n        assertEquals(3, m_cdpLinkDao.countAll());\n        for (CdpLink link: m_cdpLinkDao.findAll())\n            printCdpLink(link);                \n    }","id":49198,"modified_method":"@Test\n    @JUnitSnmpAgents(value={\n            @JUnitSnmpAgent(host=SWITCH02_IP, port=161, resource=SWITCH02_SNMP_RESOURCE)\n    })\n    public void testSwitch02Links() throws Exception {\n        \n        m_nodeDao.save(builder.getSwitch02());\n        m_nodeDao.flush();\n\n        m_linkdConfig.getConfiguration().setUseBridgeDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseOspfDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseIsisDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseLldpDiscovery(false);\n        \n        assertTrue(!m_linkdConfig.useIsisDiscovery());\n        assertTrue(!m_linkdConfig.useBridgeDiscovery());\n        assertTrue(!m_linkdConfig.useOspfDiscovery());\n        assertTrue(!m_linkdConfig.useLldpDiscovery());\n        assertTrue(m_linkdConfig.useCdpDiscovery());\n        \n        final OnmsNode switch02 = m_nodeDao.findByForeignId(\"linkd\", SWITCH02_NAME);\n        \n        assertTrue(m_linkd.scheduleNodeCollection(switch02.getId()));\n\n        assertTrue(m_linkd.runSingleSnmpCollection(switch02.getId()));\n\n        for (final OnmsNode node: m_nodeDao.findAll()) {\n            assertNotNull(node.getCdpElement());\n            printCdpElement(node.getCdpElement());\n            assertEquals(TruthValue.TRUE, node.getCdpElement().getCdpGlobalRun());\n            assertEquals(SWITCH02_CDP_GLOBAL_DEVICE_ID,node.getCdpElement().getCdpGlobalDeviceId());\n        }\n\n        assertEquals(3, m_cdpLinkDao.countAll());\n        for (CdpLink link: m_cdpLinkDao.findAll()) {\n            printCdpLink(link);\n            if (link.getCdpCacheIfIndex().intValue() == 7 && link.getCdpCacheDeviceIndex().intValue() == 1 ) {\n                assertNull(link.getCdpInterfaceName());\n                assertEquals(CiscoNetworkProtocolType.ip, link.getCdpCacheAddressType());\n                // here the ip address is associated to wlan0 but the mac is associated to eth0\n                // clearly the link is with eth0.\n                assertEquals(\"192.168.87.16\", link.getCdpCacheAddress());\n                assertEquals(HOMESERVER_CDP_GLOBAL_DEVICE_ID, link.getCdpCacheDeviceId());\n                assertEquals(\"Debian GNU/Linux 7 (wheezy) Linux 3.2.0-4-amd64 #1 SMP Debian 3.2.65-1+deb7u2 x86_64\",link.getCdpCacheVersion());\n                assertEquals(\"Debian GNU/Linux 7 (wheezy) Linux 3.2.0-4-amd64 #1 SMP Debian 3.2.65-1+deb7u2 x86_64\",link.getCdpCacheDevicePlatform());\n                assertEquals(HOMESERVER_IF_MAC_MAP.get(2), link.getCdpCacheDevicePort());\n            } else if (link.getCdpCacheIfIndex().intValue() == 24 && link.getCdpCacheDeviceIndex().intValue() == 1 ) {\n                // This is a link to cisco01 port fastethernet0/8\n                assertNull(link.getCdpInterfaceName());\n                assertEquals(CiscoNetworkProtocolType.ip, link.getCdpCacheAddressType());\n                assertEquals(\"192.168.88.240\", link.getCdpCacheAddress());\n                assertEquals(CISCO01_CDP_GLOBAL_DEVICE_ID, link.getCdpCacheDeviceId());\n                assertEquals(\"Cisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 15.0(2)SE4, RELEASE SOFTWARE (fc1) Technical Support: http://www.cisco.com/techsupport Copyrighcisco WS-C2960-8TC-L\",link.getCdpCacheVersion());\n                assertEquals(\"Cisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 15.0(2)SE4, RELEASE SOFTWARE (fc1) Technical Support: http://www.cisco.com/techsupport Copyrighcisco WS-C2960-8TC-L\",link.getCdpCacheDevicePlatform());\n                assertEquals(CISCO01_IF_IFDESCR_MAP.get(10008), link.getCdpCacheDevicePort());\n            } else if (link.getCdpCacheIfIndex().intValue() == 24 && link.getCdpCacheDeviceIndex().intValue() == 2 ) {\n                // This is a link to cisco01 port fastethernet0/8 with different data also\n                // the cdpcacheversion is always different from the cdpcacheplatform.\n                assertNull(link.getCdpInterfaceName());\n                assertEquals(CiscoNetworkProtocolType.ip, link.getCdpCacheAddressType());\n                assertEquals(\"192.168.88.240\", link.getCdpCacheAddress());\n                assertEquals(CISCO01_LLDP_CHASSID_ID, link.getCdpCacheDeviceId());\n                assertEquals(\"Cisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 15.0(2)SE4, RELEASE SOFTWARE (fc1) Technical Support: http://www.cisco.com/techsupport Copyright (c) 1986-2013 by Cisco Systems, Inc.  Compiled Wed 26-Jun-13 02:49 by prod_rel_team\",link.getCdpCacheVersion());\n                assertEquals(\"Cisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 15.0(2)SE4, RELEASE SOFTWARE (fc1) Technical Support: http://www.cisco.com/techsupport Copyright (c) 1986-2013 by Cisco Systems, Inc.  Compiled Wed 26-Jun-13 02:49 by prod_rel_team\",link.getCdpCacheDevicePlatform());\n                assertEquals(CISCO01_IF_IFNAME_MAP.get(10008), link.getCdpCacheDevicePort());                \n            } else {\n                assertTrue(false);\n            }\n        }\n    }","commit_id":"e3944b33b84d680b11b1d08dc243708b09ae290a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t\t * <p>getCdpCacheDeviceId<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t */\n\t\tpublic String getCdpCacheDeviceId() {\n\t\t\treturn getValue(CDP_CACHE_DEVICE_ID).toDisplayString();\n\t\t}","id":49199,"modified_method":"/**\n\t\t * <p>getCdpCacheDeviceId<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t */\n\t\tpublic String getCdpCacheDeviceId() {\n\t\t    if (getValue(CDP_CACHE_DEVICE_ID).isDisplayable())\n\t\t\treturn getValue(CDP_CACHE_DEVICE_ID).toDisplayString();\n\t\t    return getValue(CDP_CACHE_DEVICE_ID).toHexString();\n\t\t}","commit_id":"c35986e9447b1798029bcdfdeeb1cb430669a31a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t\t * <p>getCdpCacheDevicePort<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t */\n\t\tpublic String getCdpCacheDevicePort() {\n\t\t\treturn \tgetValue(CDP_CACHE_DEVICE_PORT).toDisplayString();\n\t\t}","id":49200,"modified_method":"/**\n\t\t * <p>getCdpCacheDevicePort<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t */\n\t\tpublic String getCdpCacheDevicePort() {\n\t\t    if (getValue(CDP_CACHE_DEVICE_PORT).isDisplayable())\n\t\t\treturn \tgetValue(CDP_CACHE_DEVICE_PORT).toDisplayString();\n\t\t    return getValue(CDP_CACHE_DEVICE_PORT).toHexString();\n\t\t}","commit_id":"c35986e9447b1798029bcdfdeeb1cb430669a31a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    @JUnitSnmpAgents(value={\n            @JUnitSnmpAgent(host=SWITCH02_IP, port=161, resource=SWITCH02_SNMP_RESOURCE)\n    })\n    public void testSwitch02Links() throws Exception {\n        \n        m_nodeDao.save(builder.getSwitch02());\n        m_nodeDao.flush();\n\n        m_linkdConfig.getConfiguration().setUseBridgeDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseOspfDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseIsisDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseLldpDiscovery(false);\n        \n        assertTrue(!m_linkdConfig.useIsisDiscovery());\n        assertTrue(!m_linkdConfig.useBridgeDiscovery());\n        assertTrue(!m_linkdConfig.useOspfDiscovery());\n        assertTrue(!m_linkdConfig.useLldpDiscovery());\n        assertTrue(m_linkdConfig.useCdpDiscovery());\n        \n        final OnmsNode switch02 = m_nodeDao.findByForeignId(\"linkd\", SWITCH02_NAME);\n        \n        assertTrue(m_linkd.scheduleNodeCollection(switch02.getId()));\n\n        assertTrue(m_linkd.runSingleSnmpCollection(switch02.getId()));\n\n        for (final OnmsNode node: m_nodeDao.findAll()) {\n            assertNotNull(node.getCdpElement());\n            printCdpElement(node.getCdpElement());\n            assertEquals(TruthValue.TRUE, node.getCdpElement().getCdpGlobalRun());\n            assertEquals(SWITCH02_CDP_GLOBAL_DEVICE_ID,node.getCdpElement().getCdpGlobalDeviceId());\n        }\n\n        assertEquals(3, m_cdpLinkDao.countAll());\n        for (CdpLink link: m_cdpLinkDao.findAll())\n            printCdpLink(link);                \n    }","id":49201,"modified_method":"@Test\n    @JUnitSnmpAgents(value={\n            @JUnitSnmpAgent(host=SWITCH02_IP, port=161, resource=SWITCH02_SNMP_RESOURCE)\n    })\n    public void testSwitch02Links() throws Exception {\n        \n        m_nodeDao.save(builder.getSwitch02());\n        m_nodeDao.flush();\n\n        m_linkdConfig.getConfiguration().setUseBridgeDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseOspfDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseIsisDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseLldpDiscovery(false);\n        \n        assertTrue(!m_linkdConfig.useIsisDiscovery());\n        assertTrue(!m_linkdConfig.useBridgeDiscovery());\n        assertTrue(!m_linkdConfig.useOspfDiscovery());\n        assertTrue(!m_linkdConfig.useLldpDiscovery());\n        assertTrue(m_linkdConfig.useCdpDiscovery());\n        \n        final OnmsNode switch02 = m_nodeDao.findByForeignId(\"linkd\", SWITCH02_NAME);\n        \n        assertTrue(m_linkd.scheduleNodeCollection(switch02.getId()));\n\n        assertTrue(m_linkd.runSingleSnmpCollection(switch02.getId()));\n\n        for (final OnmsNode node: m_nodeDao.findAll()) {\n            assertNotNull(node.getCdpElement());\n            printCdpElement(node.getCdpElement());\n            assertEquals(TruthValue.TRUE, node.getCdpElement().getCdpGlobalRun());\n            assertEquals(SWITCH02_CDP_GLOBAL_DEVICE_ID,node.getCdpElement().getCdpGlobalDeviceId());\n        }\n\n        assertEquals(3, m_cdpLinkDao.countAll());\n        for (CdpLink link: m_cdpLinkDao.findAll()) {\n            printCdpLink(link);\n            if (link.getCdpCacheIfIndex().intValue() == 7 && link.getCdpCacheDeviceIndex().intValue() == 1 ) {\n                assertNull(link.getCdpInterfaceName());\n                assertEquals(CiscoNetworkProtocolType.ip, link.getCdpCacheAddressType());\n                // here the ip address is associated to wlan0 but the mac is associated to eth0\n                // clearly the link is with eth0.\n                assertEquals(\"192.168.87.16\", link.getCdpCacheAddress());\n                assertEquals(HOMESERVER_CDP_GLOBAL_DEVICE_ID, link.getCdpCacheDeviceId());\n                assertEquals(\"Debian GNU/Linux 7 (wheezy) Linux 3.2.0-4-amd64 #1 SMP Debian 3.2.65-1+deb7u2 x86_64\",link.getCdpCacheVersion());\n                assertEquals(\"Debian GNU/Linux 7 (wheezy) Linux 3.2.0-4-amd64 #1 SMP Debian 3.2.65-1+deb7u2 x86_64\",link.getCdpCacheDevicePlatform());\n                assertEquals(HOMESERVER_IF_MAC_MAP.get(2), link.getCdpCacheDevicePort());\n            } else if (link.getCdpCacheIfIndex().intValue() == 24 && link.getCdpCacheDeviceIndex().intValue() == 1 ) {\n                // This is a link to cisco01 port fastethernet0/8\n                assertNull(link.getCdpInterfaceName());\n                assertEquals(CiscoNetworkProtocolType.ip, link.getCdpCacheAddressType());\n                assertEquals(\"192.168.88.240\", link.getCdpCacheAddress());\n                assertEquals(CISCO01_CDP_GLOBAL_DEVICE_ID, link.getCdpCacheDeviceId());\n                assertEquals(\"Cisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 15.0(2)SE4, RELEASE SOFTWARE (fc1) Technical Support: http://www.cisco.com/techsupport Copyrighcisco WS-C2960-8TC-L\",link.getCdpCacheVersion());\n                assertEquals(\"Cisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 15.0(2)SE4, RELEASE SOFTWARE (fc1) Technical Support: http://www.cisco.com/techsupport Copyrighcisco WS-C2960-8TC-L\",link.getCdpCacheDevicePlatform());\n                assertEquals(CISCO01_IF_IFDESCR_MAP.get(10008), link.getCdpCacheDevicePort());\n            } else if (link.getCdpCacheIfIndex().intValue() == 24 && link.getCdpCacheDeviceIndex().intValue() == 2 ) {\n                // This is a link to cisco01 port fastethernet0/8 with different data also\n                // the cdpcacheversion is always different from the cdpcacheplatform.\n                assertNull(link.getCdpInterfaceName());\n                assertEquals(CiscoNetworkProtocolType.ip, link.getCdpCacheAddressType());\n                assertEquals(\"192.168.88.240\", link.getCdpCacheAddress());\n                assertEquals(CISCO01_LLDP_CHASSID_ID, link.getCdpCacheDeviceId());\n                assertEquals(\"Cisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 15.0(2)SE4, RELEASE SOFTWARE (fc1) Technical Support: http://www.cisco.com/techsupport Copyright (c) 1986-2013 by Cisco Systems, Inc.  Compiled Wed 26-Jun-13 02:49 by prod_rel_team\",link.getCdpCacheVersion());\n                assertEquals(\"Cisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 15.0(2)SE4, RELEASE SOFTWARE (fc1) Technical Support: http://www.cisco.com/techsupport Copyright (c) 1986-2013 by Cisco Systems, Inc.  Compiled Wed 26-Jun-13 02:49 by prod_rel_team\",link.getCdpCacheDevicePlatform());\n                assertEquals(CISCO01_IF_IFNAME_MAP.get(10008), link.getCdpCacheDevicePort());                \n            } else {\n                assertTrue(false);\n            }\n        }\n    }","commit_id":"c35986e9447b1798029bcdfdeeb1cb430669a31a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t\t * <p>getCdpCacheDeviceId<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t */\n\t\tpublic String getCdpCacheDeviceId() {\n\t\t\treturn getValue(CDP_CACHE_DEVICE_ID).toDisplayString();\n\t\t}","id":49202,"modified_method":"/**\n\t\t * <p>getCdpCacheDeviceId<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t */\n\t\tpublic String getCdpCacheDeviceId() {\n\t\t    if (getValue(CDP_CACHE_DEVICE_ID).isDisplayable())\n\t\t\treturn getValue(CDP_CACHE_DEVICE_ID).toDisplayString();\n\t\t    return getValue(CDP_CACHE_DEVICE_ID).toHexString();\n\t\t}","commit_id":"7079ae93babb0f775a7d7968b2a459ba275b5e58","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t\t * <p>getCdpCacheDevicePort<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t */\n\t\tpublic String getCdpCacheDevicePort() {\n\t\t\treturn \tgetValue(CDP_CACHE_DEVICE_PORT).toDisplayString();\n\t\t}","id":49203,"modified_method":"/**\n\t\t * <p>getCdpCacheDevicePort<\/p>\n\t\t *\n\t\t * @return a {@link java.lang.String} object.\n\t\t */\n\t\tpublic String getCdpCacheDevicePort() {\n\t\t    if (getValue(CDP_CACHE_DEVICE_PORT).isDisplayable())\n\t\t\treturn \tgetValue(CDP_CACHE_DEVICE_PORT).toDisplayString();\n\t\t    return getValue(CDP_CACHE_DEVICE_PORT).toHexString();\n\t\t}","commit_id":"7079ae93babb0f775a7d7968b2a459ba275b5e58","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    @JUnitSnmpAgents(value={\n            @JUnitSnmpAgent(host=SWITCH02_IP, port=161, resource=SWITCH02_SNMP_RESOURCE)\n    })\n    public void testSwitch02Links() throws Exception {\n        \n        m_nodeDao.save(builder.getSwitch02());\n        m_nodeDao.flush();\n\n        m_linkdConfig.getConfiguration().setUseBridgeDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseOspfDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseIsisDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseLldpDiscovery(false);\n        \n        assertTrue(!m_linkdConfig.useIsisDiscovery());\n        assertTrue(!m_linkdConfig.useBridgeDiscovery());\n        assertTrue(!m_linkdConfig.useOspfDiscovery());\n        assertTrue(!m_linkdConfig.useLldpDiscovery());\n        assertTrue(m_linkdConfig.useCdpDiscovery());\n        \n        final OnmsNode switch02 = m_nodeDao.findByForeignId(\"linkd\", SWITCH02_NAME);\n        \n        assertTrue(m_linkd.scheduleNodeCollection(switch02.getId()));\n\n        assertTrue(m_linkd.runSingleSnmpCollection(switch02.getId()));\n\n        for (final OnmsNode node: m_nodeDao.findAll()) {\n            assertNotNull(node.getCdpElement());\n            printCdpElement(node.getCdpElement());\n            assertEquals(TruthValue.TRUE, node.getCdpElement().getCdpGlobalRun());\n            assertEquals(SWITCH02_CDP_GLOBAL_DEVICE_ID,node.getCdpElement().getCdpGlobalDeviceId());\n        }\n\n        assertEquals(3, m_cdpLinkDao.countAll());\n        for (CdpLink link: m_cdpLinkDao.findAll())\n            printCdpLink(link);                \n    }","id":49204,"modified_method":"@Test\n    @JUnitSnmpAgents(value={\n            @JUnitSnmpAgent(host=SWITCH02_IP, port=161, resource=SWITCH02_SNMP_RESOURCE)\n    })\n    public void testSwitch02Links() throws Exception {\n        \n        m_nodeDao.save(builder.getSwitch02());\n        m_nodeDao.flush();\n\n        m_linkdConfig.getConfiguration().setUseBridgeDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseOspfDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseIsisDiscovery(false);\n        m_linkdConfig.getConfiguration().setUseLldpDiscovery(false);\n        \n        assertTrue(!m_linkdConfig.useIsisDiscovery());\n        assertTrue(!m_linkdConfig.useBridgeDiscovery());\n        assertTrue(!m_linkdConfig.useOspfDiscovery());\n        assertTrue(!m_linkdConfig.useLldpDiscovery());\n        assertTrue(m_linkdConfig.useCdpDiscovery());\n        \n        final OnmsNode switch02 = m_nodeDao.findByForeignId(\"linkd\", SWITCH02_NAME);\n        \n        assertTrue(m_linkd.scheduleNodeCollection(switch02.getId()));\n\n        assertTrue(m_linkd.runSingleSnmpCollection(switch02.getId()));\n\n        for (final OnmsNode node: m_nodeDao.findAll()) {\n            assertNotNull(node.getCdpElement());\n            printCdpElement(node.getCdpElement());\n            assertEquals(TruthValue.TRUE, node.getCdpElement().getCdpGlobalRun());\n            assertEquals(SWITCH02_CDP_GLOBAL_DEVICE_ID,node.getCdpElement().getCdpGlobalDeviceId());\n        }\n\n        assertEquals(3, m_cdpLinkDao.countAll());\n        for (CdpLink link: m_cdpLinkDao.findAll()) {\n            printCdpLink(link);\n            if (link.getCdpCacheIfIndex().intValue() == 7 && link.getCdpCacheDeviceIndex().intValue() == 1 ) {\n                assertNull(link.getCdpInterfaceName());\n                assertEquals(CiscoNetworkProtocolType.ip, link.getCdpCacheAddressType());\n                // here the ip address is associated to wlan0 but the mac is associated to eth0\n                // clearly the link is with eth0.\n                assertEquals(\"192.168.87.16\", link.getCdpCacheAddress());\n                assertEquals(HOMESERVER_CDP_GLOBAL_DEVICE_ID, link.getCdpCacheDeviceId());\n                assertEquals(\"Debian GNU/Linux 7 (wheezy) Linux 3.2.0-4-amd64 #1 SMP Debian 3.2.65-1+deb7u2 x86_64\",link.getCdpCacheVersion());\n                assertEquals(\"Debian GNU/Linux 7 (wheezy) Linux 3.2.0-4-amd64 #1 SMP Debian 3.2.65-1+deb7u2 x86_64\",link.getCdpCacheDevicePlatform());\n                assertEquals(HOMESERVER_IF_MAC_MAP.get(2), link.getCdpCacheDevicePort());\n            } else if (link.getCdpCacheIfIndex().intValue() == 24 && link.getCdpCacheDeviceIndex().intValue() == 1 ) {\n                // This is a link to cisco01 port fastethernet0/8\n                assertNull(link.getCdpInterfaceName());\n                assertEquals(CiscoNetworkProtocolType.ip, link.getCdpCacheAddressType());\n                assertEquals(\"192.168.88.240\", link.getCdpCacheAddress());\n                assertEquals(CISCO01_CDP_GLOBAL_DEVICE_ID, link.getCdpCacheDeviceId());\n                assertEquals(\"Cisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 15.0(2)SE4, RELEASE SOFTWARE (fc1) Technical Support: http://www.cisco.com/techsupport Copyrighcisco WS-C2960-8TC-L\",link.getCdpCacheVersion());\n                assertEquals(\"Cisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 15.0(2)SE4, RELEASE SOFTWARE (fc1) Technical Support: http://www.cisco.com/techsupport Copyrighcisco WS-C2960-8TC-L\",link.getCdpCacheDevicePlatform());\n                assertEquals(CISCO01_IF_IFDESCR_MAP.get(10008), link.getCdpCacheDevicePort());\n            } else if (link.getCdpCacheIfIndex().intValue() == 24 && link.getCdpCacheDeviceIndex().intValue() == 2 ) {\n                // This is a link to cisco01 port fastethernet0/8 with different data also\n                // the cdpcacheversion is always different from the cdpcacheplatform.\n                assertNull(link.getCdpInterfaceName());\n                assertEquals(CiscoNetworkProtocolType.ip, link.getCdpCacheAddressType());\n                assertEquals(\"192.168.88.240\", link.getCdpCacheAddress());\n                assertEquals(CISCO01_LLDP_CHASSID_ID, link.getCdpCacheDeviceId());\n                assertEquals(\"Cisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 15.0(2)SE4, RELEASE SOFTWARE (fc1) Technical Support: http://www.cisco.com/techsupport Copyright (c) 1986-2013 by Cisco Systems, Inc.  Compiled Wed 26-Jun-13 02:49 by prod_rel_team\",link.getCdpCacheVersion());\n                assertEquals(\"Cisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 15.0(2)SE4, RELEASE SOFTWARE (fc1) Technical Support: http://www.cisco.com/techsupport Copyright (c) 1986-2013 by Cisco Systems, Inc.  Compiled Wed 26-Jun-13 02:49 by prod_rel_team\",link.getCdpCacheDevicePlatform());\n                assertEquals(CISCO01_IF_IFNAME_MAP.get(10008), link.getCdpCacheDevicePort());                \n            } else {\n                assertTrue(false);\n            }\n        }\n    }","commit_id":"7079ae93babb0f775a7d7968b2a459ba275b5e58","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public final void releaseAccessToken(String userId, OAuth2Adapter connector) throws Exception\n    {\n        if (logger.isDebugEnabled())\n        {\n            StringBuilder messageStringBuilder = new StringBuilder();\n            messageStringBuilder.append(\"Pool Statistics before releasing [key \");\n            messageStringBuilder.append(userId);\n            messageStringBuilder.append(\"] [active=\");\n            messageStringBuilder.append(accessTokenPool.getNumActive(userId));\n            messageStringBuilder.append(\"] [idle=\");\n            messageStringBuilder.append(accessTokenPool.getNumIdle(userId));\n            messageStringBuilder.append(\"]\");\n            logger.debug(messageStringBuilder.toString());\n        }\n        accessTokenPool.returnObject(userId, connector);\n        if (logger.isDebugEnabled())\n        {\n            StringBuilder messageStringBuilder = new StringBuilder();\n            messageStringBuilder.append(\"Pool Statistics after releasing [key \");\n            messageStringBuilder.append(userId);\n            messageStringBuilder.append(\"] [active=\");\n            messageStringBuilder.append(accessTokenPool.getNumActive(userId));\n            messageStringBuilder.append(\"] [idle=\");\n            messageStringBuilder.append(accessTokenPool.getNumIdle(userId));\n            messageStringBuilder.append(\"]\");\n            logger.debug(messageStringBuilder.toString());\n        }\n    }","id":49205,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void releaseAccessToken(String userId, OAuth2Adapter connector) throws Exception\n    {\n        if (getLogger().isDebugEnabled())\n        {\n            getLogger().debug(String.format(\"Pool Statistics before releasing [key %s] [active=%d] [idle=%d]\",\n                userId, accessTokenPool.getNumActive(userId), accessTokenPool.getNumIdle(userId)));\n        }\n\n        accessTokenPool.returnObject(userId, connector);\n\n        if (getLogger().isDebugEnabled())\n        {\n            getLogger().debug(String.format(\"Pool Statistics after releasing [key %s] [active=%d] [idle=%d]\",\n                userId, accessTokenPool.getNumActive(userId), accessTokenPool.getNumIdle(userId)));\n        }\n    }","commit_id":"6f10fed438202814ce23f75645e89066fb0d5ef0","url":"https://github.com/mulesoft/mule"},{"original_method":"private void fetchAndExtract(OAuth2Adapter adapter, String requestBody)\n        throws UnableToAcquireAccessTokenException\n    {\n        this.restoreAccessToken(adapter);\n\n        if (adapter.getAccessToken() != null)\n        {\n            return;\n        }\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Retrieving access token...\");\n        }\n\n        String accessTokenUrl = adapter.getAccessTokenUrl() != null\n                                                                   ? adapter.getAccessTokenUrl()\n                                                                   : this.accessTokenUrl;\n\n        String response = this.httpUtil.post(accessTokenUrl, requestBody);\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(String.format(\"Received response [%s]\", response));\n        }\n\n        adapter.setAccessToken(this.oauthResponseParser.extractAccessCode(adapter.getAccessCodePattern(),\n            response));\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(String.format(\"Access token retrieved successfully [accessToken = %s]\",\n                adapter.getAccessToken()));\n        }\n\n        this.saveAccessToken(adapter);\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(String.format(\n                \"Attempting to extract expiration time using [expirationPattern = %s]\",\n                adapter.getExpirationTimePattern().pattern()));\n        }\n\n        Date expiration = this.oauthResponseParser.extractExpirationTime(adapter.getExpirationTimePattern(),\n            response);\n        if (expiration != null)\n        {\n\n            adapter.setExpiration(expiration);\n\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(String.format(\"Token expiration extracted successfully [expiration = %s]\",\n                    expiration));\n            }\n        }\n        else\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(String.format(\"Token expiration could not be extracted from [response = %s]\",\n                    response));\n            }\n        }\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Attempting to extract refresh token time using [refreshTokenPattern = \\\"refresh_token\\\":\\\"([^&]+?)\\\"]\");\n        }\n\n        String refreshToken = this.oauthResponseParser.extractRefreshToken(adapter.getRefreshTokenPattern(),\n            response);\n\n        if (refreshToken != null)\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(String.format(\"Refresh token extracted successfully [refresh token = %s]\",\n                    refreshToken));\n            }\n        }\n        else\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(String.format(\"Refresh token could not be extracted from [response = %s]\",\n                    response));\n            }\n        }\n\n        this.fetchCallbackParameters(adapter, response);\n        adapter.postAuth();\n    }","id":49206,"modified_method":"private void fetchAndExtract(OAuth2Adapter adapter, String requestBody)\n        throws UnableToAcquireAccessTokenException\n    {\n        this.restoreAccessToken(adapter);\n\n        if (adapter.getAccessToken() != null)\n        {\n            return;\n        }\n\n        if (getLogger().isDebugEnabled())\n        {\n            getLogger().debug(\"Retrieving access token...\");\n        }\n\n        String accessTokenUrl = adapter.getAccessTokenUrl() != null\n                                                                   ? adapter.getAccessTokenUrl()\n                                                                   : this.accessTokenUrl;\n\n        String response = this.httpUtil.post(accessTokenUrl, requestBody);\n\n        if (getLogger().isDebugEnabled())\n        {\n            getLogger().debug(String.format(\"Received response [%s]\", response));\n        }\n\n        adapter.setAccessToken(this.oauthResponseParser.extractAccessCode(adapter.getAccessCodePattern(),\n            response));\n        if (getLogger().isDebugEnabled())\n        {\n            getLogger().debug(String.format(\"Access token retrieved successfully [accessToken = %s]\",\n                adapter.getAccessToken()));\n        }\n\n        this.saveAccessToken(adapter);\n\n        if (getLogger().isDebugEnabled())\n        {\n            getLogger().debug(String.format(\n                \"Attempting to extract expiration time using [expirationPattern = %s]\",\n                adapter.getExpirationTimePattern().pattern()));\n        }\n\n        Date expiration = this.oauthResponseParser.extractExpirationTime(adapter.getExpirationTimePattern(),\n            response);\n        if (expiration != null)\n        {\n\n            adapter.setExpiration(expiration);\n\n            if (getLogger().isDebugEnabled())\n            {\n                getLogger().debug(String.format(\"Token expiration extracted successfully [expiration = %s]\",\n                    expiration));\n            }\n        }\n        else\n        {\n            if (getLogger().isDebugEnabled())\n            {\n                getLogger().debug(String.format(\"Token expiration could not be extracted from [response = %s]\",\n                    response));\n            }\n        }\n\n        if (getLogger().isDebugEnabled())\n        {\n            getLogger().debug(\"Attempting to extract refresh token time using [refreshTokenPattern = \\\"refresh_token\\\":\\\"([^&]+?)\\\"]\");\n        }\n\n        String refreshToken = this.oauthResponseParser.extractRefreshToken(adapter.getRefreshTokenPattern(),\n            response);\n\n        if (refreshToken != null)\n        {\n            \n            adapter.setRefreshToken(refreshToken);\n            \n            if (getLogger().isDebugEnabled())\n            {\n                getLogger().debug(String.format(\"Refresh token extracted successfully [refresh token = %s]\",\n                    refreshToken));\n            }\n        }\n        else\n        {\n            if (getLogger().isDebugEnabled())\n            {\n                getLogger().debug(String.format(\"Refresh token could not be extracted from [response = %s]\",\n                    response));\n            }\n        }\n\n        this.fetchCallbackParameters(adapter, response);\n        adapter.postAuth();\n    }","commit_id":"6f10fed438202814ce23f75645e89066fb0d5ef0","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean restoreAccessToken(OAuth2Adapter adapter)\n    {\n        RestoreAccessTokenCallback callback = adapter.getOauthRestoreAccessToken();\n        if (callback != null)\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Attempting to restore access token...\");\n            }\n\n            try\n            {\n                callback.restoreAccessToken();\n                String accessToken = callback.getAccessToken();\n                adapter.setAccessToken(accessToken);\n\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(String.format(\n                        \"Access token and secret has been restored successfully [accessToken = %s]\",\n                        accessToken));\n                }\n                return true;\n            }\n            catch (Exception e)\n            {\n                logger.error(\"Cannot restore access token, an unexpected error occurred\", e);\n            }\n        }\n        return false;\n    }","id":49207,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean restoreAccessToken(OAuth2Adapter adapter)\n    {\n        RestoreAccessTokenCallback callback = adapter.getOauthRestoreAccessToken();\n        if (callback != null)\n        {\n            if (getLogger().isDebugEnabled())\n            {\n                getLogger().debug(\"Attempting to restore access token...\");\n            }\n\n            try\n            {\n                callback.restoreAccessToken();\n                String accessToken = callback.getAccessToken();\n                adapter.setAccessToken(accessToken);\n\n                if (getLogger().isDebugEnabled())\n                {\n                    getLogger().debug(String.format(\n                        \"Access token and secret has been restored successfully [accessToken = %s]\",\n                        accessToken));\n                }\n                return true;\n            }\n            catch (Exception e)\n            {\n                getLogger().error(\"Cannot restore access token, an unexpected error occurred\", e);\n            }\n        }\n        return false;\n    }","commit_id":"6f10fed438202814ce23f75645e89066fb0d5ef0","url":"https://github.com/mulesoft/mule"},{"original_method":"public final void destroyAccessToken(String userId, OAuth2Adapter connector) throws Exception\n    {\n        if (logger.isDebugEnabled())\n        {\n            StringBuilder messageStringBuilder = new StringBuilder();\n            messageStringBuilder.append(\"Pool Statistics before destroying [key \");\n            messageStringBuilder.append(userId);\n            messageStringBuilder.append(\"] [active=\");\n            messageStringBuilder.append(accessTokenPool.getNumActive(userId));\n            messageStringBuilder.append(\"] [idle=\");\n            messageStringBuilder.append(accessTokenPool.getNumIdle(userId));\n            messageStringBuilder.append(\"]\");\n            logger.debug(messageStringBuilder.toString());\n        }\n        accessTokenPool.invalidateObject(userId, connector);\n        if (logger.isDebugEnabled())\n        {\n            StringBuilder messageStringBuilder = new StringBuilder();\n            messageStringBuilder.append(\"Pool Statistics after destroying [key \");\n            messageStringBuilder.append(userId);\n            messageStringBuilder.append(\"] [active=\");\n            messageStringBuilder.append(accessTokenPool.getNumActive(userId));\n            messageStringBuilder.append(\"] [idle=\");\n            messageStringBuilder.append(accessTokenPool.getNumIdle(userId));\n            messageStringBuilder.append(\"]\");\n            logger.debug(messageStringBuilder.toString());\n        }\n    }","id":49208,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void destroyAccessToken(String userId, OAuth2Adapter connector) throws Exception\n    {\n        if (getLogger().isDebugEnabled())\n        {\n            getLogger().debug(String.format(\"Pool Statistics before destroying [key %s] [active=%d] [idle=%d]\",\n                userId, accessTokenPool.getNumActive(userId), accessTokenPool.getNumIdle(userId)));\n        }\n\n        accessTokenPool.invalidateObject(userId, connector);\n\n        if (getLogger().isDebugEnabled())\n        {\n            getLogger().debug(String.format(\"Pool Statistics after destroying [key %s] [active=%d] [idle=%d]\",\n                userId, accessTokenPool.getNumActive(userId), accessTokenPool.getNumIdle(userId)));\n        }\n    }","commit_id":"6f10fed438202814ce23f75645e89066fb0d5ef0","url":"https://github.com/mulesoft/mule"},{"original_method":"public final OAuth2Adapter createAccessToken(String verifier) throws Exception\n    {\n        OAuth2Adapter connector = this.instantiateAdapter();\n        connector.setOauthVerifier(verifier);\n        connector.setAuthorizationUrl(getAuthorizationUrl());\n        connector.setAccessTokenUrl(getAccessTokenUrl());\n        connector.setConsumerKey(getConsumerKey());\n        connector.setConsumerSecret(getConsumerSecret());\n\n        this.setCustomProperties(connector);\n\n        if (connector instanceof MuleContextAware)\n        {\n            ((MuleContextAware) connector).setMuleContext(muleContext);\n        }\n        if (connector instanceof Initialisable)\n        {\n            ((Initialisable) connector).initialise();\n        }\n        if (connector instanceof Startable)\n        {\n            ((Startable) connector).start();\n        }\n        return connector;\n    }","id":49209,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public final OAuth2Adapter createAdapter(String verifier) throws Exception\n    {\n        OAuth2Adapter connector = this.instantiateAdapter();\n        connector.setOauthVerifier(verifier);\n        connector.setAuthorizationUrl(getAuthorizationUrl());\n        connector.setAccessTokenUrl(getAccessTokenUrl());\n        connector.setConsumerKey(getConsumerKey());\n        connector.setConsumerSecret(getConsumerSecret());\n\n        this.setCustomProperties(connector);\n\n        if (connector instanceof MuleContextAware)\n        {\n            ((MuleContextAware) connector).setMuleContext(muleContext);\n        }\n        if (connector instanceof Initialisable)\n        {\n            ((Initialisable) connector).initialise();\n        }\n        if (connector instanceof Startable)\n        {\n            ((Startable) connector).start();\n        }\n        return connector;\n    }","commit_id":"6f10fed438202814ce23f75645e89066fb0d5ef0","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public final String buildAuthorizeUrl(Map<String, String> extraParameters,\n                                          String authorizationUrl,\n                                          String redirectUri)\n    {\n        StringBuilder urlBuilder = new StringBuilder();\n        if (authorizationUrl != null)\n        {\n            urlBuilder.append(authorizationUrl);\n        }\n        else\n        {\n            urlBuilder.append(this.authorizationUrl);\n        }\n        urlBuilder.append(\"?\");\n        urlBuilder.append(\"response_type=code&\");\n        urlBuilder.append(\"client_id=\");\n        urlBuilder.append(getConsumerKey());\n        urlBuilder.append(\"&redirect_uri=\");\n        urlBuilder.append(redirectUri);\n        for (String parameter : extraParameters.keySet())\n        {\n            urlBuilder.append(\"&\");\n            urlBuilder.append(parameter);\n            urlBuilder.append(\"=\");\n            urlBuilder.append(extraParameters.get(parameter));\n        }\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug((\"Authorization URL has been generated as follows: \" + urlBuilder));\n        }\n\n        return urlBuilder.toString();\n    }","id":49210,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public final String buildAuthorizeUrl(Map<String, String> extraParameters,\n                                          String authorizationUrl,\n                                          String redirectUri)\n    {\n        StringBuilder urlBuilder = new StringBuilder();\n        if (authorizationUrl != null)\n        {\n            urlBuilder.append(authorizationUrl);\n        }\n        else\n        {\n            urlBuilder.append(this.authorizationUrl);\n        }\n        urlBuilder.append(\"?\");\n        urlBuilder.append(\"response_type=code&\");\n        urlBuilder.append(\"client_id=\");\n        urlBuilder.append(getConsumerKey());\n        urlBuilder.append(\"&redirect_uri=\");\n        urlBuilder.append(redirectUri);\n        for (String parameter : extraParameters.keySet())\n        {\n            urlBuilder.append(\"&\");\n            urlBuilder.append(parameter);\n            urlBuilder.append(\"=\");\n            urlBuilder.append(extraParameters.get(parameter));\n        }\n\n        if (getLogger().isDebugEnabled())\n        {\n            getLogger().debug((\"Authorization URL has been generated as follows: \" + urlBuilder));\n        }\n\n        return urlBuilder.toString();\n    }","commit_id":"6f10fed438202814ce23f75645e89066fb0d5ef0","url":"https://github.com/mulesoft/mule"},{"original_method":"public final OAuth2Adapter acquireAccessToken(String userId) throws Exception\n    {\n        if (logger.isDebugEnabled())\n        {\n            StringBuilder messageStringBuilder = new StringBuilder();\n            messageStringBuilder.append(\"Pool Statistics before acquiring [key \");\n            messageStringBuilder.append(userId);\n            messageStringBuilder.append(\"] [active=\");\n            messageStringBuilder.append(accessTokenPool.getNumActive(userId));\n            messageStringBuilder.append(\"] [idle=\");\n            messageStringBuilder.append(accessTokenPool.getNumIdle(userId));\n            messageStringBuilder.append(\"]\");\n            logger.debug(messageStringBuilder.toString());\n        }\n        OAuth2Adapter object = ((OAuth2Adapter) accessTokenPool.borrowObject(userId));\n        if (logger.isDebugEnabled())\n        {\n            StringBuilder messageStringBuilder = new StringBuilder();\n            messageStringBuilder.append(\"Pool Statistics after acquiring [key \");\n            messageStringBuilder.append(userId);\n            messageStringBuilder.append(\"] [active=\");\n            messageStringBuilder.append(accessTokenPool.getNumActive(userId));\n            messageStringBuilder.append(\"] [idle=\");\n            messageStringBuilder.append(accessTokenPool.getNumIdle(userId));\n            messageStringBuilder.append(\"]\");\n            logger.debug(messageStringBuilder.toString());\n        }\n        return object;\n    }","id":49211,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public final OAuth2Adapter acquireAccessToken(String userId) throws Exception\n    {\n        if (getLogger().isDebugEnabled())\n        {\n            getLogger().debug(String.format(\"Pool Statistics before acquiring [key %s] [active=%d] [idle=%d]\",\n                userId, accessTokenPool.getNumActive(userId), accessTokenPool.getNumIdle(userId)));\n        }\n\n        OAuth2Adapter object = ((OAuth2Adapter) accessTokenPool.borrowObject(userId));\n\n        if (getLogger().isDebugEnabled())\n        {\n            getLogger().debug(String.format(\"Pool Statistics after acquiring [key %s] [active=%d] [idle=%d]\",\n                userId, accessTokenPool.getNumActive(userId), accessTokenPool.getNumIdle(userId)));\n        }\n        return object;\n    }","commit_id":"6f10fed438202814ce23f75645e89066fb0d5ef0","url":"https://github.com/mulesoft/mule"},{"original_method":"private void saveAccessToken(OAuth2Adapter adapter)\n    {\n        SaveAccessTokenCallback saveCallback = adapter.getOauthSaveAccessToken();\n\n        if (saveCallback != null)\n        {\n            try\n            {\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(String.format(\"Attempting to save access token...[accessToken = %s]\",\n                        adapter.getAccessToken()));\n                }\n                saveCallback.saveAccessToken(adapter.getAccessToken(), null);\n            }\n            catch (Exception e)\n            {\n                logger.error(\"Cannot save access token, an unexpected error occurred\", e);\n            }\n        }\n    }","id":49212,"modified_method":"private void saveAccessToken(OAuth2Adapter adapter)\n    {\n        SaveAccessTokenCallback saveCallback = adapter.getOauthSaveAccessToken();\n\n        if (saveCallback != null)\n        {\n            try\n            {\n                if (getLogger().isDebugEnabled())\n                {\n                    getLogger().debug(String.format(\"Attempting to save access token...[accessToken = %s]\",\n                        adapter.getAccessToken()));\n                }\n                saveCallback.saveAccessToken(adapter.getAccessToken(), null);\n            }\n            catch (Exception e)\n            {\n                getLogger().error(\"Cannot save access token, an unexpected error occurred\", e);\n            }\n        }\n    }","commit_id":"6f10fed438202814ce23f75645e89066fb0d5ef0","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void refreshAccessToken(OAuth2Adapter adapter) throws UnableToAcquireAccessTokenException\n    {\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Trying to refresh access token...\");\n        }\n        if (adapter.getRefreshToken() == null)\n        {\n            throw new IllegalStateException(\"Cannot refresh access token since refresh token is null\");\n        }\n\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"grant_type=refresh_token\");\n        builder.append(\"&client_id=\");\n        builder.append(getConsumerKey());\n        builder.append(\"&client_secret=\");\n        builder.append(getConsumerSecret());\n        builder.append(\"&refresh_token=\");\n        builder.append(adapter.getRefreshToken());\n\n        adapter.setAccessToken(null);\n        this.fetchAndExtract(adapter, builder.toString());\n    }","id":49213,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public final void refreshAccessToken(OAuth2Adapter adapter) throws UnableToAcquireAccessTokenException\n    {\n        if (getLogger().isDebugEnabled())\n        {\n            getLogger().debug(\"Trying to refresh access token...\");\n        }\n        if (adapter.getRefreshToken() == null)\n        {\n            throw new IllegalStateException(\"Cannot refresh access token since refresh token is null\");\n        }\n\n        StringBuilder builder = new StringBuilder();\n        builder.append(\"grant_type=refresh_token\");\n        builder.append(\"&client_id=\");\n        builder.append(adapter.getConsumerKey());\n        builder.append(\"&client_secret=\");\n        builder.append(adapter.getConsumerSecret());\n        builder.append(\"&refresh_token=\");\n        builder.append(adapter.getRefreshToken());\n\n        adapter.setAccessToken(null);\n        this.fetchAndExtract(adapter, builder.toString());\n    }","commit_id":"6f10fed438202814ce23f75645e89066fb0d5ef0","url":"https://github.com/mulesoft/mule"},{"original_method":"public MuleEvent process(MuleEvent event) throws MuleException\n    {\n        try\n        {\n            OAuth2Adapter oauthAdapter = this.oauthManager.createAccessToken(((String) event.getMessage()\n                .getInvocationProperty(\"_oauthVerifier\")));\n            if (oauthAdapter.getAccessTokenUrl() == null)\n            {\n                oauthAdapter.setAccessTokenUrl(this.getAccessTokenUrl());\n            }\n            oauthAdapter.fetchAccessToken(this.getRedirectUri());\n            oauthManager.getAccessTokenPoolFactory().passivateObject(oauthAdapter.getAccessTokenId(),\n                oauthAdapter);\n            event.getMessage().setInvocationProperty(\"OAuthAccessTokenId\", oauthAdapter.getAccessTokenId());\n        }\n        catch (Exception e)\n        {\n            throw new MessagingException(MessageFactory.createStaticMessage(\"Unable to fetch access token\"),\n                event, e);\n        }\n        return event;\n    }","id":49214,"modified_method":"public MuleEvent process(MuleEvent event) throws MuleException\n    {\n        try\n        {\n            OAuth2Adapter oauthAdapter = this.oauthManager.createAdapter(((String) event.getMessage()\n                .getInvocationProperty(\"_oauthVerifier\")));\n            if (oauthAdapter.getAccessTokenUrl() == null)\n            {\n                oauthAdapter.setAccessTokenUrl(this.getAccessTokenUrl());\n            }\n            oauthAdapter.fetchAccessToken(this.getRedirectUri());\n            oauthManager.getAccessTokenPoolFactory().passivateObject(oauthAdapter.getAccessTokenId(),\n                oauthAdapter);\n            event.getMessage().setInvocationProperty(\"OAuthAccessTokenId\", oauthAdapter.getAccessTokenId());\n        }\n        catch (Exception e)\n        {\n            throw new MessagingException(MessageFactory.createStaticMessage(\"Unable to fetch access token\"),\n                event, e);\n        }\n        return event;\n    }","commit_id":"6f10fed438202814ce23f75645e89066fb0d5ef0","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Echo 128 byte text message (uses medium 2 byte payload length)\n     */\n    @Test\n    public void testCase1_1_5() throws Exception\n    {\n        BlockheadClient client = new BlockheadClient(server.getServerUri());\n        try\n        {\n            client.connect();\n            client.sendStandardRequest();\n            client.expectUpgradeResponse();\n\n            byte msg[] = new byte[128];\n            Arrays.fill(msg,(byte)'*');\n\n            ByteBuffer buf = ByteBuffer.allocate(msg.length + Generator.OVERHEAD);\n            BufferUtil.clearToFill(buf);\n\n            buf.put((byte)(0x00 | FIN | OpCode.TEXT.getCode()));\n            putPayloadLength(buf,msg.length);\n            putMask(buf);\n            buf.put(masked(msg));\n\n            BufferUtil.flipToFlush(buf,0);\n            client.writeRaw(buf);\n\n            // Read frame\n            Queue<WebSocketFrame> frames = client.readFrames(1,TimeUnit.MILLISECONDS,500);\n            WebSocketFrame frame = frames.remove();\n            Assert.assertThat(\"frame should be TEXT frame\",frame.getOpCode(),is(OpCode.TEXT));\n            Assert.assertThat(\"Text.payloadLength\",frame.getPayloadLength(),is(msg.length));\n            ByteBufferAssert.assertEquals(\"Text.payload\",msg,frame.getPayload());\n        }\n        finally\n        {\n            client.close();\n        }\n    }","id":49215,"modified_method":"/**\n     * Echo 128 byte TEXT message (uses medium 2 byte payload length)\n     */\n    @Test\n    public void testCase1_1_5() throws Exception\n    {\n        byte payload[] = new byte[128];\n        Arrays.fill(payload,(byte)'*');\n\n        assertEchoFrame(OpCode.TEXT,payload);\n    }","commit_id":"99afabdf925fa88d250ce3d915667f59475c636f","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Echo 0 byte text message\n     */\n    @Test\n    public void testCase1_1_1() throws Exception\n    {\n        BlockheadClient client = new BlockheadClient(server.getServerUri());\n        try\n        {\n            client.connect();\n            client.sendStandardRequest();\n            client.expectUpgradeResponse();\n\n            ByteBuffer buf = ByteBuffer.allocate(16);\n            BufferUtil.clearToFill(buf);\n\n            buf.put((byte)(0x00 | FIN | OpCode.TEXT.getCode()));\n            putPayloadLength(buf,0);\n            putMask(buf);\n\n            BufferUtil.flipToFlush(buf,0);\n            client.writeRaw(buf);\n\n            // Read frame\n            Queue<WebSocketFrame> frames = client.readFrames(1,TimeUnit.MILLISECONDS,500);\n            WebSocketFrame frame = frames.remove();\n            Assert.assertThat(\"frame should be TEXT frame\",frame.getOpCode(),is(OpCode.TEXT));\n            Assert.assertThat(\"Text.payloadLength\",frame.getPayloadLength(),is(0));\n        }\n        finally\n        {\n            client.close();\n        }\n    }","id":49216,"modified_method":"/**\n     * Echo 0 byte TEXT message\n     */\n    @Test\n    public void testCase1_1_1() throws Exception\n    {\n        assertEchoEmptyFrame(OpCode.TEXT);\n    }","commit_id":"99afabdf925fa88d250ce3d915667f59475c636f","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Echo 126 byte text message (uses medium 2 byte payload length)\n     */\n    @Test\n    public void testCase1_1_3() throws Exception\n    {\n        BlockheadClient client = new BlockheadClient(server.getServerUri());\n        try\n        {\n            client.connect();\n            client.sendStandardRequest();\n            client.expectUpgradeResponse();\n\n            byte msg[] = new byte[126];\n            Arrays.fill(msg,(byte)'*');\n\n            ByteBuffer buf = ByteBuffer.allocate(msg.length + Generator.OVERHEAD);\n            BufferUtil.clearToFill(buf);\n\n            buf.put((byte)(0x00 | FIN | OpCode.TEXT.getCode()));\n            putPayloadLength(buf,msg.length);\n            putMask(buf);\n            buf.put(masked(msg));\n\n            BufferUtil.flipToFlush(buf,0);\n            client.writeRaw(buf);\n\n            // Read frame\n            Queue<WebSocketFrame> frames = client.readFrames(1,TimeUnit.MILLISECONDS,500);\n            WebSocketFrame frame = frames.remove();\n            Assert.assertThat(\"frame should be TEXT frame\",frame.getOpCode(),is(OpCode.TEXT));\n            Assert.assertThat(\"Text.payloadLength\",frame.getPayloadLength(),is(msg.length));\n            ByteBufferAssert.assertEquals(\"Text.payload\",msg,frame.getPayload());\n        }\n        finally\n        {\n            client.close();\n        }\n    }","id":49217,"modified_method":"/**\n     * Echo 126 byte TEXT message (uses medium 2 byte payload length)\n     */\n    @Test\n    public void testCase1_1_3() throws Exception\n    {\n        byte payload[] = new byte[126];\n        Arrays.fill(payload,(byte)'*');\n\n        assertEchoFrame(OpCode.TEXT,payload);\n    }","commit_id":"99afabdf925fa88d250ce3d915667f59475c636f","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Echo 65535 byte text message (uses medium 2 byte payload length)\n     */\n    @Test\n    public void testCase1_1_6() throws Exception\n    {\n        BlockheadClient client = new BlockheadClient(server.getServerUri());\n        try\n        {\n            client.connect();\n            client.sendStandardRequest();\n            client.expectUpgradeResponse();\n\n            byte msg[] = new byte[65535];\n            Arrays.fill(msg,(byte)'*');\n\n            ByteBuffer buf = ByteBuffer.allocate(msg.length + Generator.OVERHEAD);\n            BufferUtil.clearToFill(buf);\n\n            buf.put((byte)(0x00 | FIN | OpCode.TEXT.getCode()));\n            putPayloadLength(buf,msg.length);\n            putMask(buf);\n            buf.put(masked(msg));\n\n            BufferUtil.flipToFlush(buf,0);\n            client.writeRaw(buf);\n\n            // Read frame\n            Queue<WebSocketFrame> frames = client.readFrames(1,TimeUnit.MILLISECONDS,500);\n            WebSocketFrame frame = frames.remove();\n            Assert.assertThat(\"frame should be TEXT frame\",frame.getOpCode(),is(OpCode.TEXT));\n            Assert.assertThat(\"Text.payloadLength\",frame.getPayloadLength(),is(msg.length));\n            ByteBufferAssert.assertEquals(\"Text.payload\",msg,frame.getPayload());\n        }\n        finally\n        {\n            client.close();\n        }\n    }","id":49218,"modified_method":"/**\n     * Echo 65535 byte TEXT message (uses medium 2 byte payload length)\n     */\n    @Test\n    public void testCase1_1_6() throws Exception\n    {\n        byte payload[] = new byte[65535];\n        Arrays.fill(payload,(byte)'*');\n\n        assertEchoFrame(OpCode.TEXT,payload);\n    }","commit_id":"99afabdf925fa88d250ce3d915667f59475c636f","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Echo 65536 byte text message (uses large 8 byte payload length)\n     */\n    @Test\n    public void testCase1_1_7() throws Exception\n    {\n        BlockheadClient client = new BlockheadClient(server.getServerUri());\n        try\n        {\n            client.connect();\n            client.sendStandardRequest();\n            client.expectUpgradeResponse();\n\n            byte msg[] = new byte[65536];\n            Arrays.fill(msg,(byte)'*');\n\n            ByteBuffer buf = ByteBuffer.allocate(msg.length + Generator.OVERHEAD);\n            BufferUtil.clearToFill(buf);\n\n            buf.put((byte)(0x00 | FIN | OpCode.TEXT.getCode()));\n            putPayloadLength(buf,msg.length);\n            putMask(buf);\n            buf.put(masked(msg));\n\n            BufferUtil.flipToFlush(buf,0);\n            client.writeRaw(buf);\n\n            // Read frame\n            Queue<WebSocketFrame> frames = client.readFrames(1,TimeUnit.MILLISECONDS,500);\n            WebSocketFrame frame = frames.remove();\n            Assert.assertThat(\"frame should be TEXT frame\",frame.getOpCode(),is(OpCode.TEXT));\n            Assert.assertThat(\"Text.payloadLength\",frame.getPayloadLength(),is(msg.length));\n            ByteBufferAssert.assertEquals(\"Text.payload\",msg,frame.getPayload());\n        }\n        finally\n        {\n            client.close();\n        }\n    }","id":49219,"modified_method":"/**\n     * Echo 65536 byte TEXT message (uses large 8 byte payload length)\n     */\n    @Test\n    public void testCase1_1_7() throws Exception\n    {\n        byte payload[] = new byte[65536];\n        Arrays.fill(payload,(byte)'*');\n\n        assertEchoFrame(OpCode.TEXT,payload);\n    }","commit_id":"99afabdf925fa88d250ce3d915667f59475c636f","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Echo 127 byte text message (uses medium 2 byte payload length)\n     */\n    @Test\n    public void testCase1_1_4() throws Exception\n    {\n        BlockheadClient client = new BlockheadClient(server.getServerUri());\n        try\n        {\n            client.connect();\n            client.sendStandardRequest();\n            client.expectUpgradeResponse();\n\n            byte msg[] = new byte[127];\n            Arrays.fill(msg,(byte)'*');\n\n            ByteBuffer buf = ByteBuffer.allocate(msg.length + Generator.OVERHEAD);\n            BufferUtil.clearToFill(buf);\n\n            buf.put((byte)(0x00 | FIN | OpCode.TEXT.getCode()));\n            putPayloadLength(buf,msg.length);\n            putMask(buf);\n            buf.put(masked(msg));\n\n            BufferUtil.flipToFlush(buf,0);\n            client.writeRaw(buf);\n\n            // Read frame\n            Queue<WebSocketFrame> frames = client.readFrames(1,TimeUnit.MILLISECONDS,500);\n            WebSocketFrame frame = frames.remove();\n            Assert.assertThat(\"frame should be TEXT frame\",frame.getOpCode(),is(OpCode.TEXT));\n            Assert.assertThat(\"Text.payloadLength\",frame.getPayloadLength(),is(msg.length));\n            ByteBufferAssert.assertEquals(\"Text.payload\",msg,frame.getPayload());\n        }\n        finally\n        {\n            client.close();\n        }\n    }","id":49220,"modified_method":"/**\n     * Echo 127 byte TEXT message (uses medium 2 byte payload length)\n     */\n    @Test\n    public void testCase1_1_4() throws Exception\n    {\n        byte payload[] = new byte[127];\n        Arrays.fill(payload,(byte)'*');\n\n        assertEchoFrame(OpCode.TEXT,payload);\n    }","commit_id":"99afabdf925fa88d250ce3d915667f59475c636f","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Echo 125 byte text message (uses small 7-bit payload length)\n     */\n    @Test\n    public void testCase1_1_2() throws Exception\n    {\n        BlockheadClient client = new BlockheadClient(server.getServerUri());\n        try\n        {\n            client.connect();\n            client.sendStandardRequest();\n            client.expectUpgradeResponse();\n\n            byte msg[] = new byte[125];\n            Arrays.fill(msg,(byte)'*');\n\n            ByteBuffer buf = ByteBuffer.allocate(msg.length + Generator.OVERHEAD);\n            BufferUtil.clearToFill(buf);\n\n            buf.put((byte)(0x00 | FIN | OpCode.TEXT.getCode()));\n            putPayloadLength(buf,msg.length);\n            putMask(buf);\n            buf.put(masked(msg));\n\n            BufferUtil.flipToFlush(buf,0);\n            client.writeRaw(buf);\n\n            // Read frame\n            Queue<WebSocketFrame> frames = client.readFrames(1,TimeUnit.MILLISECONDS,500);\n            WebSocketFrame frame = frames.remove();\n            Assert.assertThat(\"frame should be TEXT frame\",frame.getOpCode(),is(OpCode.TEXT));\n            Assert.assertThat(\"Text.payloadLength\",frame.getPayloadLength(),is(msg.length));\n            ByteBufferAssert.assertEquals(\"Text.payload\",msg,frame.getPayload());\n        }\n        finally\n        {\n            client.close();\n        }\n    }","id":49221,"modified_method":"/**\n     * Echo 125 byte TEXT message (uses small 7-bit payload length)\n     */\n    @Test\n    public void testCase1_1_2() throws Exception\n    {\n        byte payload[] = new byte[125];\n        Arrays.fill(payload,(byte)'*');\n\n        assertEchoFrame(OpCode.TEXT,payload);\n    }","commit_id":"99afabdf925fa88d250ce3d915667f59475c636f","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * This method is used to verify if each interface on a node stored in the\n     * database is in the specified SNMP data collection.\n     * \n     * @param dbInterfaces\n     *            the ipInterfaces on a node stored in the database\n     * @param snmpc\n     *            IfSnmpCollector object containing SNMP collected ipAddrTable\n     *            information.\n     * \n     * @return True if each ipInterface is contained in the ipAddrTable of the\n     *         specified SNMP collection.\n     * \n     */\n    private boolean areDbInterfacesInSnmpCollection(DbIpInterfaceEntry[] dbInterfaces, IfSnmpCollector snmpc) {\n        // Sanity check...null parms?\n        if (dbInterfaces == null || snmpc == null) {\n            log().error(\"areDbInterfacesInSnmpCollection: empty dbInterfaces or IfSnmpCollector.\");\n            return false;\n        }\n\n        // SNMP collection successful?\n        if (!snmpc.hasIpAddrTable()) {\n            log().error(\"areDbInterfacesInSnmpCollection: Snmp Collector failed.\");\n            return false;\n        }\n\n        // Verify that SNMP collection contains ipAddrTable entries\n        IpAddrTable ipAddrTable = null;\n\n        if (snmpc.hasIpAddrTable()) {\n            ipAddrTable = snmpc.getIpAddrTable();\n        }\n\n        if (ipAddrTable == null) {\n            log().error(\"areDbInterfacesInSnmpCollection: null ipAddrTable in the snmp collection\");\n            return false;\n        }\n\n        List<InetAddress> ipAddrList = ipAddrTable.getIpAddresses();\n\n        /*\n         * Loop through the interface table entries until there are no more\n         * entries or we've found a match\n         */\n        for (int i = 0; i < dbInterfaces.length; i++) {\n            InetAddress ipaddr = dbInterfaces[i].getIfAddress();\n            // Skip non-IP or loopback interfaces\n            if (ipaddr.getHostAddress().equals(\"0.0.0.0\") || ipaddr.getHostAddress().startsWith(\"127.\")) {\n                continue;\n            }\n\n            boolean found = false;\n            for(InetAddress addr : ipAddrList) {\n\n                // Skip non-IP or loopback interfaces\n                if (addr.getHostAddress().equals(\"0.0.0.0\") || addr.getHostAddress().startsWith(\"127.\")) {\n                    continue;\n                }\n\n                if (ipaddr.getHostAddress().equals(addr.getHostAddress())) {\n                    found = true;\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"areDbInterfacesInSnmpCollection: found match for ipaddress: \" + ipaddr.getHostAddress());\n                    }\n                    break;\n                }\n            }\n            if (!found) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"areDbInterfacesInSnmpCollection: ipaddress : \" + ipaddr.getHostAddress() + \" not in the snmp collection. Snmp collection may not be usable.\");\n                }\n                return false;\n            }\n        }\n\n        return true;\n    }","id":49222,"modified_method":"/**\n     * This method is used to verify if each interface on a node stored in the\n     * database is in the specified SNMP data collection.\n     * \n     * @param dbInterfaces\n     *            the ipInterfaces on a node stored in the database\n     * @param snmpc\n     *            IfSnmpCollector object containing SNMP collected ipAddrTable\n     *            information.\n     * \n     * @return True if each ipInterface is contained in the ipAddrTable of the\n     *         specified SNMP collection.\n     * \n     */\n    private boolean areDbInterfacesInSnmpCollection(DbIpInterfaceEntry[] dbInterfaces, IfSnmpCollector snmpc) {\n        // Sanity check...null parms?\n        if (dbInterfaces == null || snmpc == null) {\n            log().error(\"areDbInterfacesInSnmpCollection: empty dbInterfaces or IfSnmpCollector.\");\n            return false;\n        }\n\n        // SNMP collection successful?\n        if (!snmpc.hasIpAddrTable()) {\n            log().error(\"areDbInterfacesInSnmpCollection: Snmp Collector failed.\");\n            return false;\n        }\n\n        // Verify that SNMP collection contains ipAddrTable entries\n        IpAddrTable ipAddrTable = null;\n\n        if (snmpc.hasIpAddrTable()) {\n            ipAddrTable = snmpc.getIpAddrTable();\n        }\n\n        if (ipAddrTable == null) {\n            log().error(\"areDbInterfacesInSnmpCollection: null ipAddrTable in the snmp collection\");\n            return false;\n        }\n\n        List<InetAddress> ipAddrList = ipAddrTable.getIpAddresses();\n\n        /*\n         * Loop through the interface table entries until there are no more\n         * entries or we've found a match\n         */\n        for (DbIpInterfaceEntry dbInterface : dbInterfaces) {\n            InetAddress ipaddr = dbInterface.getIfAddress();\n            \n            // Skip non-IP or loopback interfaces\n            if (ipaddr.getHostAddress().equals(\"0.0.0.0\") || ipaddr.getHostAddress().startsWith(\"127.\")) {\n                continue;\n            }\n\n            boolean found = false;\n            for (InetAddress addr : ipAddrList) {\n                // Skip non-IP or loopback interfaces\n                if (addr.getHostAddress().equals(\"0.0.0.0\") || addr.getHostAddress().startsWith(\"127.\")) {\n                    continue;\n                }\n\n                if (ipaddr.getHostAddress().equals(addr.getHostAddress())) {\n                    found = true;\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"areDbInterfacesInSnmpCollection: found match for ipaddress: \" + ipaddr.getHostAddress());\n                    }\n                    break;\n                }\n            }\n            \n            if (!found) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"areDbInterfacesInSnmpCollection: ipaddress : \" + ipaddr.getHostAddress() + \" not in the snmp collection. Snmp collection may not be usable.\");\n                }\n                return false;\n            }\n        }\n\n        return true;\n    }","commit_id":"83de62051456417e7b5dfdff2093858a23e10877","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public RescanProcessor(int nodeId, boolean forceRescan, CapsdDbSyncer capsdDbSyncer, PluginManager pluginManager) {\n        m_nodeId = nodeId;\n        m_forceRescan = forceRescan;\n        m_capsdDbSyncer = capsdDbSyncer;\n        m_pluginManager = pluginManager;\n\n        m_eventList = new ArrayList<Event>();\n\n    }","id":49223,"modified_method":"public RescanProcessor(int nodeId, boolean forceRescan, CapsdDbSyncer capsdDbSyncer, PluginManager pluginManager) {\n        m_nodeId = nodeId;\n        m_forceRescan = forceRescan;\n        m_capsdDbSyncer = capsdDbSyncer;\n        m_pluginManager = pluginManager;\n    }","commit_id":"83de62051456417e7b5dfdff2093858a23e10877","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for updating the node table using the most\n     * recent data collected from the node's managed interfaces.\n     * \n     * @param dbc\n     *            Database connection\n     * @param now\n     *            Date object representing the time of the rescan.\n     * @param dbNodeEntry\n     *            DbNodeEntry object representing existing values in the\n     *            database\n     * @param currPrimarySnmpIf\n     *            Primary SNMP interface address based on latest collection\n     * @param dbIpInterfaces\n     *            Array of DbIpInterfaceEntry objects representing all the\n     *            interfaces retrieved from the database for this node.\n     * @param collectorMap\n     *            Map of IfCollector objects...one per managed interface.\n     * \n     * @return DbNodeEntry object representing the updated values from the node\n     *         table in the database.\n     * \n     * @throws SQLException\n     *             if there is a problem updating the node table.\n     */\n    private DbNodeEntry updateNode(Connection dbc, Date now, DbNodeEntry dbNodeEntry, InetAddress currPrimarySnmpIf, DbIpInterfaceEntry[] dbIpInterfaces, Map<String, IfCollector> collectorMap) throws SQLException {\n        if (log().isDebugEnabled())\n            log().debug(\"updateNode: updating node id \" + dbNodeEntry.getNodeId());\n\n        /*\n         * Clone the existing dbNodeEntry so we have all the original\n         * values of the 'node' table fields in case we need to generate\n         * 'node***Changed' events following the update.\n         */\n        DbNodeEntry originalDbNodeEntry = DbNodeEntry.clone(dbNodeEntry);\n\n        /*\n         * Create node which represents the most recently retrieved\n         * information in the collector for this node\n         */\n        DbNodeEntry currNodeEntry = DbNodeEntry.create();\n        currNodeEntry.setNodeType(DbNodeEntry.NODE_TYPE_ACTIVE);\n\n        // Set node label and SMB info based on latest collection\n        setNodeLabelAndSmbInfo(collectorMap, dbNodeEntry, currNodeEntry, currPrimarySnmpIf);\n\n        // Set SNMP info\n        if (currPrimarySnmpIf != null) {\n            /*\n             * We prefer to use the collector for the primary SNMP interface\n             * to update SNMP data in the node table. However a collector\n             * for the primary SNMP interface may not exist in the map if\n             * a node has only recently had SNMP support enabled or if the\n             * new primary SNMP interface was only recently added to the\n             * node. At any rate if it exists use it, if not use the\n             * first collector which supports SNMP.\n             */\n            IfCollector primaryIfc = collectorMap.get(currPrimarySnmpIf.getHostAddress());\n            if (primaryIfc == null) {\n                Collection<IfCollector> collectors = collectorMap.values();\n                Iterator<IfCollector> iter = collectors.iterator();\n                while (iter.hasNext()) {\n                    primaryIfc = iter.next();\n                    if (primaryIfc.getSnmpCollector() != null)\n                        break;\n                }\n            }\n\n            /*\n             * Sanity check...should always have a primary interface\n             * collector at this point\n             */\n            if (primaryIfc == null) {\n                log().error(\"updateNode: failed to determine primary interface collector for node \" + dbNodeEntry.getNodeId());\n                throw new RuntimeException(\"Update node failed for node \" + dbNodeEntry.getNodeId() + \", unable to determine primary interface collector.\");\n            }\n\n            IfSnmpCollector snmpc = primaryIfc.getSnmpCollector();\n\n            if (snmpc != null && snmpc.hasSystemGroup()) {\n                SystemGroup sysgrp = snmpc.getSystemGroup();\n\n                // sysObjectId\n                currNodeEntry.setSystemOID(sysgrp.getSysObjectID());\n\n                // sysName\n                String str = sysgrp.getSysName();\n                if (str != null && str.length() > 0)\n                    currNodeEntry.setSystemName(str);\n\n                // sysDescription\n                str = sysgrp.getSysDescr();\n                if (str != null && str.length() > 0)\n                    currNodeEntry.setSystemDescription(str);\n\n                // sysLocation\n                str = sysgrp.getSysLocation();\n                if (str != null && str.length() > 0)\n                    currNodeEntry.setSystemLocation(str);\n\n                // sysContact\n                str = sysgrp.getSysContact();\n                if (str != null && str.length() > 0)\n                    currNodeEntry.setSystemContact(str);\n            }\n        }\n\n        /*\n         * Currently, we do not use the ParentId except in mapping.\n         * Unfortunately, this is never\n         * set in the currNodeEntry so it gets reset here. As a workaround,\n         * setting it to the old value.\n         */\n\n        currNodeEntry.updateParentId(dbNodeEntry.getParentId());\n\n        // Update any fields which have changed\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateNode: -------dumping old node-------: \" + dbNodeEntry);\n            log().debug(\"updateNode: -------dumping new node-------: \" + currNodeEntry);\n        }\n        dbNodeEntry.updateParentId(currNodeEntry.getParentId());\n        dbNodeEntry.updateNodeType(currNodeEntry.getNodeType());\n        dbNodeEntry.updateSystemOID(currNodeEntry.getSystemOID());\n        dbNodeEntry.updateSystemName(currNodeEntry.getSystemName());\n        dbNodeEntry.updateSystemDescription(currNodeEntry.getSystemDescription());\n        dbNodeEntry.updateSystemLocation(currNodeEntry.getSystemLocation());\n        dbNodeEntry.updateSystemContact(currNodeEntry.getSystemContact());\n        dbNodeEntry.updateNetBIOSName(currNodeEntry.getNetBIOSName());\n        dbNodeEntry.updateDomainName(currNodeEntry.getDomainName());\n        dbNodeEntry.updateOS(currNodeEntry.getOS());\n        dbNodeEntry.setLastPoll(now);\n\n        /*\n         * Only update node label/source if original node entry is\n         * not set to user-defined.\n         */\n        if (dbNodeEntry.getLabelSource() != DbNodeEntry.LABEL_SOURCE_USER) {\n            dbNodeEntry.updateLabel(currNodeEntry.getLabel());\n            dbNodeEntry.updateLabelSource(currNodeEntry.getLabelSource());\n        }\n\n        // Set event flags\n        boolean nodeLabelChangedFlag = false;\n        boolean nodeInfoChangedFlag = false;\n\n        if (dbNodeEntry.hasLabelChanged() || dbNodeEntry.hasLabelSourceChanged()) {\n            nodeLabelChangedFlag = true;\n        }\n\n        if (dbNodeEntry.hasSystemOIDChanged() || dbNodeEntry.hasSystemNameChanged() || dbNodeEntry.hasSystemDescriptionChanged() || dbNodeEntry.hasSystemLocationChanged() || dbNodeEntry.hasSystemContactChanged() || dbNodeEntry.hasNetBIOSNameChanged() || dbNodeEntry.hasDomainNameChanged() || dbNodeEntry.hasOSChanged()) {\n            nodeInfoChangedFlag = true;\n        }\n\n        // Call store to update the database\n        dbNodeEntry.store(dbc);\n\n        // Create nodeLabelChanged event if necessary\n        if (nodeLabelChangedFlag) {\n            createNodeLabelChangedEvent(dbNodeEntry, originalDbNodeEntry);\n        }\n\n        // Create nodeInfoChangedEvent if necessary\n        if (nodeInfoChangedFlag) {\n            createNodeInfoChangedEvent(dbNodeEntry, originalDbNodeEntry);\n        }\n\n        return dbNodeEntry;\n    }","id":49224,"modified_method":"/**\n     * This method is responsible for updating the node table using the most\n     * recent data collected from the node's managed interfaces.\n     * \n     * @param dbc\n     *            Database connection\n     * @param now\n     *            Date object representing the time of the rescan.\n     * @param dbNodeEntry\n     *            DbNodeEntry object representing existing values in the\n     *            database\n     * @param currPrimarySnmpIf\n     *            Primary SNMP interface address based on latest collection\n     * @param dbIpInterfaces\n     *            Array of DbIpInterfaceEntry objects representing all the\n     *            interfaces retrieved from the database for this node.\n     * @param collectorMap\n     *            Map of IfCollector objects...one per managed interface.\n     * \n     * @return DbNodeEntry object representing the updated values from the node\n     *         table in the database.\n     * \n     * @throws SQLException\n     *             if there is a problem updating the node table.\n     */\n    private DbNodeEntry updateNode(Connection dbc, Date now, DbNodeEntry dbNodeEntry, InetAddress currPrimarySnmpIf, DbIpInterfaceEntry[] dbIpInterfaces, Map<String, IfCollector> collectorMap) throws SQLException {\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateNode: updating node id \" + dbNodeEntry.getNodeId());\n        }\n\n        /*\n         * Clone the existing dbNodeEntry so we have all the original\n         * values of the 'node' table fields in case we need to generate\n         * 'node***Changed' events following the update.\n         */\n        DbNodeEntry originalDbNodeEntry = DbNodeEntry.clone(dbNodeEntry);\n\n        /*\n         * Create node which represents the most recently retrieved\n         * information in the collector for this node\n         */\n        DbNodeEntry currNodeEntry = DbNodeEntry.create();\n        currNodeEntry.setNodeType(DbNodeEntry.NODE_TYPE_ACTIVE);\n\n        // Set node label and SMB info based on latest collection\n        setNodeLabelAndSmbInfo(collectorMap, dbNodeEntry, currNodeEntry, currPrimarySnmpIf);\n\n        // Set SNMP info\n        if (currPrimarySnmpIf != null) {\n            /*\n             * We prefer to use the collector for the primary SNMP interface\n             * to update SNMP data in the node table. However a collector\n             * for the primary SNMP interface may not exist in the map if\n             * a node has only recently had SNMP support enabled or if the\n             * new primary SNMP interface was only recently added to the\n             * node. At any rate if it exists use it, if not use the\n             * first collector which supports SNMP.\n             */\n            IfCollector primaryIfc = collectorMap.get(currPrimarySnmpIf.getHostAddress());\n            if (primaryIfc == null) {\n                for (IfCollector tmp : collectorMap.values()) {\n                    if (tmp.getSnmpCollector() != null) {\n                        primaryIfc = tmp;\n                        break;\n                    }\n                }\n            }\n\n            /*\n             * Sanity check...should always have a primary interface\n             * collector at this point\n             */\n            if (primaryIfc == null) {\n                log().error(\"updateNode: failed to determine primary interface collector for node \" + dbNodeEntry.getNodeId());\n                throw new RuntimeException(\"Update node failed for node \" + dbNodeEntry.getNodeId() + \", unable to determine primary interface collector.\");\n            }\n\n            IfSnmpCollector snmpc = primaryIfc.getSnmpCollector();\n            if (snmpc != null && snmpc.hasSystemGroup()) {\n                SystemGroup sysgrp = snmpc.getSystemGroup();\n\n                // sysObjectId\n                currNodeEntry.setSystemOID(sysgrp.getSysObjectID());\n\n                // sysName\n                String sysName = sysgrp.getSysName();\n                if (sysName != null && sysName.length() > 0) {\n                    currNodeEntry.setSystemName(sysName);\n                }\n\n                // sysDescription\n                String sysDescr = sysgrp.getSysDescr();\n                if (sysDescr != null && sysDescr.length() > 0) {\n                    currNodeEntry.setSystemDescription(sysDescr);\n                }\n\n                // sysLocation\n                String sysLocation = sysgrp.getSysLocation();\n                if (sysLocation != null && sysLocation.length() > 0) {\n                    currNodeEntry.setSystemLocation(sysLocation);\n                }\n\n                // sysContact\n                String sysContact = sysgrp.getSysContact();\n                if (sysContact != null && sysContact.length() > 0) {\n                    currNodeEntry.setSystemContact(sysContact);\n                }\n            }\n        }\n\n        /*\n         * Currently, we do not use the ParentId except in mapping.\n         * Unfortunately, this is never\n         * set in the currNodeEntry so it gets reset here. As a workaround,\n         * setting it to the old value.\n         */\n\n        currNodeEntry.updateParentId(dbNodeEntry.getParentId());\n\n        // Update any fields which have changed\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateNode: -------dumping old node-------: \" + dbNodeEntry);\n            log().debug(\"updateNode: -------dumping new node-------: \" + currNodeEntry);\n        }\n        dbNodeEntry.updateParentId(currNodeEntry.getParentId());\n        dbNodeEntry.updateNodeType(currNodeEntry.getNodeType());\n        dbNodeEntry.updateSystemOID(currNodeEntry.getSystemOID());\n        dbNodeEntry.updateSystemName(currNodeEntry.getSystemName());\n        dbNodeEntry.updateSystemDescription(currNodeEntry.getSystemDescription());\n        dbNodeEntry.updateSystemLocation(currNodeEntry.getSystemLocation());\n        dbNodeEntry.updateSystemContact(currNodeEntry.getSystemContact());\n        dbNodeEntry.updateNetBIOSName(currNodeEntry.getNetBIOSName());\n        dbNodeEntry.updateDomainName(currNodeEntry.getDomainName());\n        dbNodeEntry.updateOS(currNodeEntry.getOS());\n        dbNodeEntry.setLastPoll(now);\n\n        /*\n         * Only update node label/source if original node entry is\n         * not set to user-defined.\n         */\n        if (dbNodeEntry.getLabelSource() != DbNodeEntry.LABEL_SOURCE_USER) {\n            dbNodeEntry.updateLabel(currNodeEntry.getLabel());\n            dbNodeEntry.updateLabelSource(currNodeEntry.getLabelSource());\n        }\n\n        // Set event flags\n        boolean nodeLabelChangedFlag = false;\n        boolean nodeInfoChangedFlag = false;\n\n        if (dbNodeEntry.hasLabelChanged() || dbNodeEntry.hasLabelSourceChanged()) {\n            nodeLabelChangedFlag = true;\n        }\n\n        if (dbNodeEntry.hasSystemOIDChanged() || dbNodeEntry.hasSystemNameChanged() || dbNodeEntry.hasSystemDescriptionChanged() || dbNodeEntry.hasSystemLocationChanged() || dbNodeEntry.hasSystemContactChanged() || dbNodeEntry.hasNetBIOSNameChanged() || dbNodeEntry.hasDomainNameChanged() || dbNodeEntry.hasOSChanged()) {\n            nodeInfoChangedFlag = true;\n        }\n\n        // Call store to update the database\n        dbNodeEntry.store(dbc);\n\n        // Create nodeLabelChanged event if necessary\n        if (nodeLabelChangedFlag) {\n            createNodeLabelChangedEvent(dbNodeEntry, originalDbNodeEntry);\n        }\n\n        // Create nodeInfoChangedEvent if necessary\n        if (nodeInfoChangedFlag) {\n            createNodeInfoChangedEvent(dbNodeEntry, originalDbNodeEntry);\n        }\n\n        return dbNodeEntry;\n    }","commit_id":"83de62051456417e7b5dfdff2093858a23e10877","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void updateSpeed(int ifIndex, IfTableEntry ifte, DbSnmpInterfaceEntry dbSnmpIfEntry) {\n        // speed\n        Long uint;\n        try {\n            uint = ifte.getIfSpeed();   \n        } catch (Exception e) {\n            log().warn(\"updateNonIpInterface: ifSpeed '\" + ifte.getDisplayString(IfTableEntry.IF_SPEED) + \"' for ifIndex \" + ifIndex + \" is invalid, inserting 0: \" + e, e);\n            uint = null;\n        }\n        if (uint == null) {\n            dbSnmpIfEntry.updateSpeed(0);\n        } else {\n            dbSnmpIfEntry.updateSpeed(uint.longValue());\n        }\n    }","id":49225,"modified_method":"void updateSpeed(int ifIndex, IfTableEntry ifte, DbSnmpInterfaceEntry dbSnmpIfEntry) {\n        Long uint;\n        try {\n            uint = ifte.getIfSpeed();   \n        } catch (Exception e) {\n            log().warn(\"updateNonIpInterface: ifSpeed '\" + ifte.getDisplayString(IfTableEntry.IF_SPEED) + \"' for ifIndex \" + ifIndex + \" is invalid, inserting 0: \" + e, e);\n            uint = null;\n        }\n        if (uint == null) {\n            dbSnmpIfEntry.updateSpeed(0);\n        } else {\n            dbSnmpIfEntry.updateSpeed(uint.longValue());\n        }\n    }","commit_id":"83de62051456417e7b5dfdff2093858a23e10877","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to verify if each interface on a node stored in the\n     * database is in the specified SNMP data collection.\n     * \n     * @param dbInterfaces\n     *            the ipInterfaces on a node stored in the database\n     * @param snmpc\n     *            IfSnmpCollector object containing SNMP collected ipAddrTable\n     *            information.\n     * \n     * @return True if each ipInterface is contained in the ipAddrTable of the\n     *         specified SNMP collection.\n     * \n     */\n    private boolean areDbInterfacesInSnmpCollection(DbIpInterfaceEntry[] dbInterfaces, IfSnmpCollector snmpc) {\n        // Sanity check...null parms?\n        if (dbInterfaces == null || snmpc == null) {\n            log().error(\"areDbInterfacesInSnmpCollection: empty dbInterfaces or IfSnmpCollector.\");\n            return false;\n        }\n\n        // SNMP collection successful?\n        if (!snmpc.hasIpAddrTable()) {\n            log().error(\"areDbInterfacesInSnmpCollection: Snmp Collector failed.\");\n            return false;\n        }\n\n        // Verify that SNMP collection contains ipAddrTable entries\n        IpAddrTable ipAddrTable = null;\n\n        if (snmpc.hasIpAddrTable()) {\n            ipAddrTable = snmpc.getIpAddrTable();\n        }\n\n        if (ipAddrTable == null) {\n            log().error(\"areDbInterfacesInSnmpCollection: null ipAddrTable in the snmp collection\");\n            return false;\n        }\n\n        List<InetAddress> ipAddrList = ipAddrTable.getIpAddresses();\n\n        /*\n         * Loop through the interface table entries until there are no more\n         * entries or we've found a match\n         */\n        for (int i = 0; i < dbInterfaces.length; i++) {\n            InetAddress ipaddr = dbInterfaces[i].getIfAddress();\n            // Skip non-IP or loopback interfaces\n            if (ipaddr.getHostAddress().equals(\"0.0.0.0\") || ipaddr.getHostAddress().startsWith(\"127.\")) {\n                continue;\n            }\n\n            boolean found = false;\n            for(InetAddress addr : ipAddrList) {\n\n                // Skip non-IP or loopback interfaces\n                if (addr.getHostAddress().equals(\"0.0.0.0\") || addr.getHostAddress().startsWith(\"127.\")) {\n                    continue;\n                }\n\n                if (ipaddr.getHostAddress().equals(addr.getHostAddress())) {\n                    found = true;\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"areDbInterfacesInSnmpCollection: found match for ipaddress: \" + ipaddr.getHostAddress());\n                    }\n                    break;\n                }\n            }\n            if (!found) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"areDbInterfacesInSnmpCollection: ipaddress : \" + ipaddr.getHostAddress() + \" not in the snmp collection. Snmp collection may not be usable.\");\n                }\n                return false;\n            }\n        }\n\n        return true;\n    }","id":49226,"modified_method":"/**\n     * This method is used to verify if each interface on a node stored in the\n     * database is in the specified SNMP data collection.\n     * \n     * @param dbInterfaces\n     *            the ipInterfaces on a node stored in the database\n     * @param snmpc\n     *            IfSnmpCollector object containing SNMP collected ipAddrTable\n     *            information.\n     * \n     * @return True if each ipInterface is contained in the ipAddrTable of the\n     *         specified SNMP collection.\n     * \n     */\n    private boolean areDbInterfacesInSnmpCollection(DbIpInterfaceEntry[] dbInterfaces, IfSnmpCollector snmpc) {\n        // Sanity check...null parms?\n        if (dbInterfaces == null || snmpc == null) {\n            log().error(\"areDbInterfacesInSnmpCollection: empty dbInterfaces or IfSnmpCollector.\");\n            return false;\n        }\n\n        // SNMP collection successful?\n        if (!snmpc.hasIpAddrTable()) {\n            log().error(\"areDbInterfacesInSnmpCollection: Snmp Collector failed.\");\n            return false;\n        }\n\n        // Verify that SNMP collection contains ipAddrTable entries\n        IpAddrTable ipAddrTable = null;\n\n        if (snmpc.hasIpAddrTable()) {\n            ipAddrTable = snmpc.getIpAddrTable();\n        }\n\n        if (ipAddrTable == null) {\n            log().error(\"areDbInterfacesInSnmpCollection: null ipAddrTable in the snmp collection\");\n            return false;\n        }\n\n        List<InetAddress> ipAddrList = ipAddrTable.getIpAddresses();\n\n        /*\n         * Loop through the interface table entries until there are no more\n         * entries or we've found a match\n         */\n        for (DbIpInterfaceEntry dbInterface : dbInterfaces) {\n            InetAddress ipaddr = dbInterface.getIfAddress();\n            \n            // Skip non-IP or loopback interfaces\n            if (ipaddr.getHostAddress().equals(\"0.0.0.0\") || ipaddr.getHostAddress().startsWith(\"127.\")) {\n                continue;\n            }\n\n            boolean found = false;\n            for (InetAddress addr : ipAddrList) {\n                // Skip non-IP or loopback interfaces\n                if (addr.getHostAddress().equals(\"0.0.0.0\") || addr.getHostAddress().startsWith(\"127.\")) {\n                    continue;\n                }\n\n                if (ipaddr.getHostAddress().equals(addr.getHostAddress())) {\n                    found = true;\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"areDbInterfacesInSnmpCollection: found match for ipaddress: \" + ipaddr.getHostAddress());\n                    }\n                    break;\n                }\n            }\n            \n            if (!found) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"areDbInterfacesInSnmpCollection: ipaddress : \" + ipaddr.getHostAddress() + \" not in the snmp collection. Snmp collection may not be usable.\");\n                }\n                return false;\n            }\n        }\n\n        return true;\n    }","commit_id":"cc2fc021facd61db50bd74c9696ef291f291af17","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void updateSpeed(int ifIndex, IfTableEntry ifte, DbSnmpInterfaceEntry dbSnmpIfEntry) {\n        // speed\n        Long uint;\n        try {\n            uint = ifte.getIfSpeed();   \n        } catch (Exception e) {\n            log().warn(\"updateNonIpInterface: ifSpeed '\" + ifte.getDisplayString(IfTableEntry.IF_SPEED) + \"' for ifIndex \" + ifIndex + \" is invalid, inserting 0: \" + e, e);\n            uint = null;\n        }\n        if (uint == null) {\n            dbSnmpIfEntry.updateSpeed(0);\n        } else {\n            dbSnmpIfEntry.updateSpeed(uint.longValue());\n        }\n    }","id":49227,"modified_method":"void updateSpeed(int ifIndex, IfTableEntry ifte, DbSnmpInterfaceEntry dbSnmpIfEntry) {\n        Long uint;\n        try {\n            uint = ifte.getIfSpeed();   \n        } catch (Exception e) {\n            log().warn(\"updateNonIpInterface: ifSpeed '\" + ifte.getDisplayString(IfTableEntry.IF_SPEED) + \"' for ifIndex \" + ifIndex + \" is invalid, inserting 0: \" + e, e);\n            uint = null;\n        }\n        if (uint == null) {\n            dbSnmpIfEntry.updateSpeed(0);\n        } else {\n            dbSnmpIfEntry.updateSpeed(uint.longValue());\n        }\n    }","commit_id":"cc2fc021facd61db50bd74c9696ef291f291af17","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public RescanProcessor(int nodeId, boolean forceRescan, CapsdDbSyncer capsdDbSyncer, PluginManager pluginManager) {\n        m_nodeId = nodeId;\n        m_forceRescan = forceRescan;\n        m_capsdDbSyncer = capsdDbSyncer;\n        m_pluginManager = pluginManager;\n\n        m_eventList = new ArrayList<Event>();\n\n    }","id":49228,"modified_method":"public RescanProcessor(int nodeId, boolean forceRescan, CapsdDbSyncer capsdDbSyncer, PluginManager pluginManager) {\n        m_nodeId = nodeId;\n        m_forceRescan = forceRescan;\n        m_capsdDbSyncer = capsdDbSyncer;\n        m_pluginManager = pluginManager;\n    }","commit_id":"cc2fc021facd61db50bd74c9696ef291f291af17","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for updating the node table using the most\n     * recent data collected from the node's managed interfaces.\n     * \n     * @param dbc\n     *            Database connection\n     * @param now\n     *            Date object representing the time of the rescan.\n     * @param dbNodeEntry\n     *            DbNodeEntry object representing existing values in the\n     *            database\n     * @param currPrimarySnmpIf\n     *            Primary SNMP interface address based on latest collection\n     * @param dbIpInterfaces\n     *            Array of DbIpInterfaceEntry objects representing all the\n     *            interfaces retrieved from the database for this node.\n     * @param collectorMap\n     *            Map of IfCollector objects...one per managed interface.\n     * \n     * @return DbNodeEntry object representing the updated values from the node\n     *         table in the database.\n     * \n     * @throws SQLException\n     *             if there is a problem updating the node table.\n     */\n    private DbNodeEntry updateNode(Connection dbc, Date now, DbNodeEntry dbNodeEntry, InetAddress currPrimarySnmpIf, DbIpInterfaceEntry[] dbIpInterfaces, Map<String, IfCollector> collectorMap) throws SQLException {\n        if (log().isDebugEnabled())\n            log().debug(\"updateNode: updating node id \" + dbNodeEntry.getNodeId());\n\n        /*\n         * Clone the existing dbNodeEntry so we have all the original\n         * values of the 'node' table fields in case we need to generate\n         * 'node***Changed' events following the update.\n         */\n        DbNodeEntry originalDbNodeEntry = DbNodeEntry.clone(dbNodeEntry);\n\n        /*\n         * Create node which represents the most recently retrieved\n         * information in the collector for this node\n         */\n        DbNodeEntry currNodeEntry = DbNodeEntry.create();\n        currNodeEntry.setNodeType(DbNodeEntry.NODE_TYPE_ACTIVE);\n\n        // Set node label and SMB info based on latest collection\n        setNodeLabelAndSmbInfo(collectorMap, dbNodeEntry, currNodeEntry, currPrimarySnmpIf);\n\n        // Set SNMP info\n        if (currPrimarySnmpIf != null) {\n            /*\n             * We prefer to use the collector for the primary SNMP interface\n             * to update SNMP data in the node table. However a collector\n             * for the primary SNMP interface may not exist in the map if\n             * a node has only recently had SNMP support enabled or if the\n             * new primary SNMP interface was only recently added to the\n             * node. At any rate if it exists use it, if not use the\n             * first collector which supports SNMP.\n             */\n            IfCollector primaryIfc = collectorMap.get(currPrimarySnmpIf.getHostAddress());\n            if (primaryIfc == null) {\n                Collection<IfCollector> collectors = collectorMap.values();\n                Iterator<IfCollector> iter = collectors.iterator();\n                while (iter.hasNext()) {\n                    primaryIfc = iter.next();\n                    if (primaryIfc.getSnmpCollector() != null)\n                        break;\n                }\n            }\n\n            /*\n             * Sanity check...should always have a primary interface\n             * collector at this point\n             */\n            if (primaryIfc == null) {\n                log().error(\"updateNode: failed to determine primary interface collector for node \" + dbNodeEntry.getNodeId());\n                throw new RuntimeException(\"Update node failed for node \" + dbNodeEntry.getNodeId() + \", unable to determine primary interface collector.\");\n            }\n\n            IfSnmpCollector snmpc = primaryIfc.getSnmpCollector();\n\n            if (snmpc != null && snmpc.hasSystemGroup()) {\n                SystemGroup sysgrp = snmpc.getSystemGroup();\n\n                // sysObjectId\n                currNodeEntry.setSystemOID(sysgrp.getSysObjectID());\n\n                // sysName\n                String str = sysgrp.getSysName();\n                if (str != null && str.length() > 0)\n                    currNodeEntry.setSystemName(str);\n\n                // sysDescription\n                str = sysgrp.getSysDescr();\n                if (str != null && str.length() > 0)\n                    currNodeEntry.setSystemDescription(str);\n\n                // sysLocation\n                str = sysgrp.getSysLocation();\n                if (str != null && str.length() > 0)\n                    currNodeEntry.setSystemLocation(str);\n\n                // sysContact\n                str = sysgrp.getSysContact();\n                if (str != null && str.length() > 0)\n                    currNodeEntry.setSystemContact(str);\n            }\n        }\n\n        /*\n         * Currently, we do not use the ParentId except in mapping.\n         * Unfortunately, this is never\n         * set in the currNodeEntry so it gets reset here. As a workaround,\n         * setting it to the old value.\n         */\n\n        currNodeEntry.updateParentId(dbNodeEntry.getParentId());\n\n        // Update any fields which have changed\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateNode: -------dumping old node-------: \" + dbNodeEntry);\n            log().debug(\"updateNode: -------dumping new node-------: \" + currNodeEntry);\n        }\n        dbNodeEntry.updateParentId(currNodeEntry.getParentId());\n        dbNodeEntry.updateNodeType(currNodeEntry.getNodeType());\n        dbNodeEntry.updateSystemOID(currNodeEntry.getSystemOID());\n        dbNodeEntry.updateSystemName(currNodeEntry.getSystemName());\n        dbNodeEntry.updateSystemDescription(currNodeEntry.getSystemDescription());\n        dbNodeEntry.updateSystemLocation(currNodeEntry.getSystemLocation());\n        dbNodeEntry.updateSystemContact(currNodeEntry.getSystemContact());\n        dbNodeEntry.updateNetBIOSName(currNodeEntry.getNetBIOSName());\n        dbNodeEntry.updateDomainName(currNodeEntry.getDomainName());\n        dbNodeEntry.updateOS(currNodeEntry.getOS());\n        dbNodeEntry.setLastPoll(now);\n\n        /*\n         * Only update node label/source if original node entry is\n         * not set to user-defined.\n         */\n        if (dbNodeEntry.getLabelSource() != DbNodeEntry.LABEL_SOURCE_USER) {\n            dbNodeEntry.updateLabel(currNodeEntry.getLabel());\n            dbNodeEntry.updateLabelSource(currNodeEntry.getLabelSource());\n        }\n\n        // Set event flags\n        boolean nodeLabelChangedFlag = false;\n        boolean nodeInfoChangedFlag = false;\n\n        if (dbNodeEntry.hasLabelChanged() || dbNodeEntry.hasLabelSourceChanged()) {\n            nodeLabelChangedFlag = true;\n        }\n\n        if (dbNodeEntry.hasSystemOIDChanged() || dbNodeEntry.hasSystemNameChanged() || dbNodeEntry.hasSystemDescriptionChanged() || dbNodeEntry.hasSystemLocationChanged() || dbNodeEntry.hasSystemContactChanged() || dbNodeEntry.hasNetBIOSNameChanged() || dbNodeEntry.hasDomainNameChanged() || dbNodeEntry.hasOSChanged()) {\n            nodeInfoChangedFlag = true;\n        }\n\n        // Call store to update the database\n        dbNodeEntry.store(dbc);\n\n        // Create nodeLabelChanged event if necessary\n        if (nodeLabelChangedFlag) {\n            createNodeLabelChangedEvent(dbNodeEntry, originalDbNodeEntry);\n        }\n\n        // Create nodeInfoChangedEvent if necessary\n        if (nodeInfoChangedFlag) {\n            createNodeInfoChangedEvent(dbNodeEntry, originalDbNodeEntry);\n        }\n\n        return dbNodeEntry;\n    }","id":49229,"modified_method":"/**\n     * This method is responsible for updating the node table using the most\n     * recent data collected from the node's managed interfaces.\n     * \n     * @param dbc\n     *            Database connection\n     * @param now\n     *            Date object representing the time of the rescan.\n     * @param dbNodeEntry\n     *            DbNodeEntry object representing existing values in the\n     *            database\n     * @param currPrimarySnmpIf\n     *            Primary SNMP interface address based on latest collection\n     * @param dbIpInterfaces\n     *            Array of DbIpInterfaceEntry objects representing all the\n     *            interfaces retrieved from the database for this node.\n     * @param collectorMap\n     *            Map of IfCollector objects...one per managed interface.\n     * \n     * @return DbNodeEntry object representing the updated values from the node\n     *         table in the database.\n     * \n     * @throws SQLException\n     *             if there is a problem updating the node table.\n     */\n    private DbNodeEntry updateNode(Connection dbc, Date now, DbNodeEntry dbNodeEntry, InetAddress currPrimarySnmpIf, DbIpInterfaceEntry[] dbIpInterfaces, Map<String, IfCollector> collectorMap) throws SQLException {\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateNode: updating node id \" + dbNodeEntry.getNodeId());\n        }\n\n        /*\n         * Clone the existing dbNodeEntry so we have all the original\n         * values of the 'node' table fields in case we need to generate\n         * 'node***Changed' events following the update.\n         */\n        DbNodeEntry originalDbNodeEntry = DbNodeEntry.clone(dbNodeEntry);\n\n        /*\n         * Create node which represents the most recently retrieved\n         * information in the collector for this node\n         */\n        DbNodeEntry currNodeEntry = DbNodeEntry.create();\n        currNodeEntry.setNodeType(DbNodeEntry.NODE_TYPE_ACTIVE);\n\n        // Set node label and SMB info based on latest collection\n        setNodeLabelAndSmbInfo(collectorMap, dbNodeEntry, currNodeEntry, currPrimarySnmpIf);\n\n        // Set SNMP info\n        if (currPrimarySnmpIf != null) {\n            /*\n             * We prefer to use the collector for the primary SNMP interface\n             * to update SNMP data in the node table. However a collector\n             * for the primary SNMP interface may not exist in the map if\n             * a node has only recently had SNMP support enabled or if the\n             * new primary SNMP interface was only recently added to the\n             * node. At any rate if it exists use it, if not use the\n             * first collector which supports SNMP.\n             */\n            IfCollector primaryIfc = collectorMap.get(currPrimarySnmpIf.getHostAddress());\n            if (primaryIfc == null) {\n                for (IfCollector tmp : collectorMap.values()) {\n                    if (tmp.getSnmpCollector() != null) {\n                        primaryIfc = tmp;\n                        break;\n                    }\n                }\n            }\n\n            /*\n             * Sanity check...should always have a primary interface\n             * collector at this point\n             */\n            if (primaryIfc == null) {\n                log().error(\"updateNode: failed to determine primary interface collector for node \" + dbNodeEntry.getNodeId());\n                throw new RuntimeException(\"Update node failed for node \" + dbNodeEntry.getNodeId() + \", unable to determine primary interface collector.\");\n            }\n\n            IfSnmpCollector snmpc = primaryIfc.getSnmpCollector();\n            if (snmpc != null && snmpc.hasSystemGroup()) {\n                SystemGroup sysgrp = snmpc.getSystemGroup();\n\n                // sysObjectId\n                currNodeEntry.setSystemOID(sysgrp.getSysObjectID());\n\n                // sysName\n                String sysName = sysgrp.getSysName();\n                if (sysName != null && sysName.length() > 0) {\n                    currNodeEntry.setSystemName(sysName);\n                }\n\n                // sysDescription\n                String sysDescr = sysgrp.getSysDescr();\n                if (sysDescr != null && sysDescr.length() > 0) {\n                    currNodeEntry.setSystemDescription(sysDescr);\n                }\n\n                // sysLocation\n                String sysLocation = sysgrp.getSysLocation();\n                if (sysLocation != null && sysLocation.length() > 0) {\n                    currNodeEntry.setSystemLocation(sysLocation);\n                }\n\n                // sysContact\n                String sysContact = sysgrp.getSysContact();\n                if (sysContact != null && sysContact.length() > 0) {\n                    currNodeEntry.setSystemContact(sysContact);\n                }\n            }\n        }\n\n        /*\n         * Currently, we do not use the ParentId except in mapping.\n         * Unfortunately, this is never\n         * set in the currNodeEntry so it gets reset here. As a workaround,\n         * setting it to the old value.\n         */\n\n        currNodeEntry.updateParentId(dbNodeEntry.getParentId());\n\n        // Update any fields which have changed\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateNode: -------dumping old node-------: \" + dbNodeEntry);\n            log().debug(\"updateNode: -------dumping new node-------: \" + currNodeEntry);\n        }\n        dbNodeEntry.updateParentId(currNodeEntry.getParentId());\n        dbNodeEntry.updateNodeType(currNodeEntry.getNodeType());\n        dbNodeEntry.updateSystemOID(currNodeEntry.getSystemOID());\n        dbNodeEntry.updateSystemName(currNodeEntry.getSystemName());\n        dbNodeEntry.updateSystemDescription(currNodeEntry.getSystemDescription());\n        dbNodeEntry.updateSystemLocation(currNodeEntry.getSystemLocation());\n        dbNodeEntry.updateSystemContact(currNodeEntry.getSystemContact());\n        dbNodeEntry.updateNetBIOSName(currNodeEntry.getNetBIOSName());\n        dbNodeEntry.updateDomainName(currNodeEntry.getDomainName());\n        dbNodeEntry.updateOS(currNodeEntry.getOS());\n        dbNodeEntry.setLastPoll(now);\n\n        /*\n         * Only update node label/source if original node entry is\n         * not set to user-defined.\n         */\n        if (dbNodeEntry.getLabelSource() != DbNodeEntry.LABEL_SOURCE_USER) {\n            dbNodeEntry.updateLabel(currNodeEntry.getLabel());\n            dbNodeEntry.updateLabelSource(currNodeEntry.getLabelSource());\n        }\n\n        // Set event flags\n        boolean nodeLabelChangedFlag = false;\n        boolean nodeInfoChangedFlag = false;\n\n        if (dbNodeEntry.hasLabelChanged() || dbNodeEntry.hasLabelSourceChanged()) {\n            nodeLabelChangedFlag = true;\n        }\n\n        if (dbNodeEntry.hasSystemOIDChanged() || dbNodeEntry.hasSystemNameChanged() || dbNodeEntry.hasSystemDescriptionChanged() || dbNodeEntry.hasSystemLocationChanged() || dbNodeEntry.hasSystemContactChanged() || dbNodeEntry.hasNetBIOSNameChanged() || dbNodeEntry.hasDomainNameChanged() || dbNodeEntry.hasOSChanged()) {\n            nodeInfoChangedFlag = true;\n        }\n\n        // Call store to update the database\n        dbNodeEntry.store(dbc);\n\n        // Create nodeLabelChanged event if necessary\n        if (nodeLabelChangedFlag) {\n            createNodeLabelChangedEvent(dbNodeEntry, originalDbNodeEntry);\n        }\n\n        // Create nodeInfoChangedEvent if necessary\n        if (nodeInfoChangedFlag) {\n            createNodeInfoChangedEvent(dbNodeEntry, originalDbNodeEntry);\n        }\n\n        return dbNodeEntry;\n    }","commit_id":"cc2fc021facd61db50bd74c9696ef291f291af17","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public RescanProcessor(int nodeId, boolean forceRescan, CapsdDbSyncer capsdDbSyncer, PluginManager pluginManager) {\n        m_nodeId = nodeId;\n        m_forceRescan = forceRescan;\n        m_capsdDbSyncer = capsdDbSyncer;\n        m_pluginManager = pluginManager;\n\n        m_eventList = new ArrayList<Event>();\n\n    }","id":49230,"modified_method":"public RescanProcessor(int nodeId, boolean forceRescan, CapsdDbSyncer capsdDbSyncer, PluginManager pluginManager) {\n        m_nodeId = nodeId;\n        m_forceRescan = forceRescan;\n        m_capsdDbSyncer = capsdDbSyncer;\n        m_pluginManager = pluginManager;\n    }","commit_id":"98f979a84d0aba7524b10eb0d2e9d7c657daa506","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to verify if each interface on a node stored in the\n     * database is in the specified SNMP data collection.\n     * \n     * @param dbInterfaces\n     *            the ipInterfaces on a node stored in the database\n     * @param snmpc\n     *            IfSnmpCollector object containing SNMP collected ipAddrTable\n     *            information.\n     * \n     * @return True if each ipInterface is contained in the ipAddrTable of the\n     *         specified SNMP collection.\n     * \n     */\n    private boolean areDbInterfacesInSnmpCollection(DbIpInterfaceEntry[] dbInterfaces, IfSnmpCollector snmpc) {\n        // Sanity check...null parms?\n        if (dbInterfaces == null || snmpc == null) {\n            log().error(\"areDbInterfacesInSnmpCollection: empty dbInterfaces or IfSnmpCollector.\");\n            return false;\n        }\n\n        // SNMP collection successful?\n        if (!snmpc.hasIpAddrTable()) {\n            log().error(\"areDbInterfacesInSnmpCollection: Snmp Collector failed.\");\n            return false;\n        }\n\n        // Verify that SNMP collection contains ipAddrTable entries\n        IpAddrTable ipAddrTable = null;\n\n        if (snmpc.hasIpAddrTable()) {\n            ipAddrTable = snmpc.getIpAddrTable();\n        }\n\n        if (ipAddrTable == null) {\n            log().error(\"areDbInterfacesInSnmpCollection: null ipAddrTable in the snmp collection\");\n            return false;\n        }\n\n        List<InetAddress> ipAddrList = ipAddrTable.getIpAddresses();\n\n        /*\n         * Loop through the interface table entries until there are no more\n         * entries or we've found a match\n         */\n        for (int i = 0; i < dbInterfaces.length; i++) {\n            InetAddress ipaddr = dbInterfaces[i].getIfAddress();\n            // Skip non-IP or loopback interfaces\n            if (ipaddr.getHostAddress().equals(\"0.0.0.0\") || ipaddr.getHostAddress().startsWith(\"127.\")) {\n                continue;\n            }\n\n            boolean found = false;\n            for(InetAddress addr : ipAddrList) {\n\n                // Skip non-IP or loopback interfaces\n                if (addr.getHostAddress().equals(\"0.0.0.0\") || addr.getHostAddress().startsWith(\"127.\")) {\n                    continue;\n                }\n\n                if (ipaddr.getHostAddress().equals(addr.getHostAddress())) {\n                    found = true;\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"areDbInterfacesInSnmpCollection: found match for ipaddress: \" + ipaddr.getHostAddress());\n                    }\n                    break;\n                }\n            }\n            if (!found) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"areDbInterfacesInSnmpCollection: ipaddress : \" + ipaddr.getHostAddress() + \" not in the snmp collection. Snmp collection may not be usable.\");\n                }\n                return false;\n            }\n        }\n\n        return true;\n    }","id":49231,"modified_method":"/**\n     * This method is used to verify if each interface on a node stored in the\n     * database is in the specified SNMP data collection.\n     * \n     * @param dbInterfaces\n     *            the ipInterfaces on a node stored in the database\n     * @param snmpc\n     *            IfSnmpCollector object containing SNMP collected ipAddrTable\n     *            information.\n     * \n     * @return True if each ipInterface is contained in the ipAddrTable of the\n     *         specified SNMP collection.\n     * \n     */\n    private boolean areDbInterfacesInSnmpCollection(DbIpInterfaceEntry[] dbInterfaces, IfSnmpCollector snmpc) {\n        // Sanity check...null parms?\n        if (dbInterfaces == null || snmpc == null) {\n            log().error(\"areDbInterfacesInSnmpCollection: empty dbInterfaces or IfSnmpCollector.\");\n            return false;\n        }\n\n        // SNMP collection successful?\n        if (!snmpc.hasIpAddrTable()) {\n            log().error(\"areDbInterfacesInSnmpCollection: Snmp Collector failed.\");\n            return false;\n        }\n\n        // Verify that SNMP collection contains ipAddrTable entries\n        IpAddrTable ipAddrTable = null;\n\n        if (snmpc.hasIpAddrTable()) {\n            ipAddrTable = snmpc.getIpAddrTable();\n        }\n\n        if (ipAddrTable == null) {\n            log().error(\"areDbInterfacesInSnmpCollection: null ipAddrTable in the snmp collection\");\n            return false;\n        }\n\n        List<InetAddress> ipAddrList = ipAddrTable.getIpAddresses();\n\n        /*\n         * Loop through the interface table entries until there are no more\n         * entries or we've found a match\n         */\n        for (DbIpInterfaceEntry dbInterface : dbInterfaces) {\n            InetAddress ipaddr = dbInterface.getIfAddress();\n            \n            // Skip non-IP or loopback interfaces\n            if (ipaddr.getHostAddress().equals(\"0.0.0.0\") || ipaddr.getHostAddress().startsWith(\"127.\")) {\n                continue;\n            }\n\n            boolean found = false;\n            for (InetAddress addr : ipAddrList) {\n                // Skip non-IP or loopback interfaces\n                if (addr.getHostAddress().equals(\"0.0.0.0\") || addr.getHostAddress().startsWith(\"127.\")) {\n                    continue;\n                }\n\n                if (ipaddr.getHostAddress().equals(addr.getHostAddress())) {\n                    found = true;\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"areDbInterfacesInSnmpCollection: found match for ipaddress: \" + ipaddr.getHostAddress());\n                    }\n                    break;\n                }\n            }\n            \n            if (!found) {\n                if (log().isDebugEnabled()) {\n                    log().debug(\"areDbInterfacesInSnmpCollection: ipaddress : \" + ipaddr.getHostAddress() + \" not in the snmp collection. Snmp collection may not be usable.\");\n                }\n                return false;\n            }\n        }\n\n        return true;\n    }","commit_id":"98f979a84d0aba7524b10eb0d2e9d7c657daa506","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void updateSpeed(int ifIndex, IfTableEntry ifte, DbSnmpInterfaceEntry dbSnmpIfEntry) {\n        // speed\n        Long uint;\n        try {\n            uint = ifte.getIfSpeed();   \n        } catch (Exception e) {\n            log().warn(\"updateNonIpInterface: ifSpeed '\" + ifte.getDisplayString(IfTableEntry.IF_SPEED) + \"' for ifIndex \" + ifIndex + \" is invalid, inserting 0: \" + e, e);\n            uint = null;\n        }\n        if (uint == null) {\n            dbSnmpIfEntry.updateSpeed(0);\n        } else {\n            dbSnmpIfEntry.updateSpeed(uint.longValue());\n        }\n    }","id":49232,"modified_method":"void updateSpeed(int ifIndex, IfTableEntry ifte, DbSnmpInterfaceEntry dbSnmpIfEntry) {\n        Long uint;\n        try {\n            uint = ifte.getIfSpeed();   \n        } catch (Exception e) {\n            log().warn(\"updateNonIpInterface: ifSpeed '\" + ifte.getDisplayString(IfTableEntry.IF_SPEED) + \"' for ifIndex \" + ifIndex + \" is invalid, inserting 0: \" + e, e);\n            uint = null;\n        }\n        if (uint == null) {\n            dbSnmpIfEntry.updateSpeed(0);\n        } else {\n            dbSnmpIfEntry.updateSpeed(uint.longValue());\n        }\n    }","commit_id":"98f979a84d0aba7524b10eb0d2e9d7c657daa506","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is responsible for updating the node table using the most\n     * recent data collected from the node's managed interfaces.\n     * \n     * @param dbc\n     *            Database connection\n     * @param now\n     *            Date object representing the time of the rescan.\n     * @param dbNodeEntry\n     *            DbNodeEntry object representing existing values in the\n     *            database\n     * @param currPrimarySnmpIf\n     *            Primary SNMP interface address based on latest collection\n     * @param dbIpInterfaces\n     *            Array of DbIpInterfaceEntry objects representing all the\n     *            interfaces retrieved from the database for this node.\n     * @param collectorMap\n     *            Map of IfCollector objects...one per managed interface.\n     * \n     * @return DbNodeEntry object representing the updated values from the node\n     *         table in the database.\n     * \n     * @throws SQLException\n     *             if there is a problem updating the node table.\n     */\n    private DbNodeEntry updateNode(Connection dbc, Date now, DbNodeEntry dbNodeEntry, InetAddress currPrimarySnmpIf, DbIpInterfaceEntry[] dbIpInterfaces, Map<String, IfCollector> collectorMap) throws SQLException {\n        if (log().isDebugEnabled())\n            log().debug(\"updateNode: updating node id \" + dbNodeEntry.getNodeId());\n\n        /*\n         * Clone the existing dbNodeEntry so we have all the original\n         * values of the 'node' table fields in case we need to generate\n         * 'node***Changed' events following the update.\n         */\n        DbNodeEntry originalDbNodeEntry = DbNodeEntry.clone(dbNodeEntry);\n\n        /*\n         * Create node which represents the most recently retrieved\n         * information in the collector for this node\n         */\n        DbNodeEntry currNodeEntry = DbNodeEntry.create();\n        currNodeEntry.setNodeType(DbNodeEntry.NODE_TYPE_ACTIVE);\n\n        // Set node label and SMB info based on latest collection\n        setNodeLabelAndSmbInfo(collectorMap, dbNodeEntry, currNodeEntry, currPrimarySnmpIf);\n\n        // Set SNMP info\n        if (currPrimarySnmpIf != null) {\n            /*\n             * We prefer to use the collector for the primary SNMP interface\n             * to update SNMP data in the node table. However a collector\n             * for the primary SNMP interface may not exist in the map if\n             * a node has only recently had SNMP support enabled or if the\n             * new primary SNMP interface was only recently added to the\n             * node. At any rate if it exists use it, if not use the\n             * first collector which supports SNMP.\n             */\n            IfCollector primaryIfc = collectorMap.get(currPrimarySnmpIf.getHostAddress());\n            if (primaryIfc == null) {\n                Collection<IfCollector> collectors = collectorMap.values();\n                Iterator<IfCollector> iter = collectors.iterator();\n                while (iter.hasNext()) {\n                    primaryIfc = iter.next();\n                    if (primaryIfc.getSnmpCollector() != null)\n                        break;\n                }\n            }\n\n            /*\n             * Sanity check...should always have a primary interface\n             * collector at this point\n             */\n            if (primaryIfc == null) {\n                log().error(\"updateNode: failed to determine primary interface collector for node \" + dbNodeEntry.getNodeId());\n                throw new RuntimeException(\"Update node failed for node \" + dbNodeEntry.getNodeId() + \", unable to determine primary interface collector.\");\n            }\n\n            IfSnmpCollector snmpc = primaryIfc.getSnmpCollector();\n\n            if (snmpc != null && snmpc.hasSystemGroup()) {\n                SystemGroup sysgrp = snmpc.getSystemGroup();\n\n                // sysObjectId\n                currNodeEntry.setSystemOID(sysgrp.getSysObjectID());\n\n                // sysName\n                String str = sysgrp.getSysName();\n                if (str != null && str.length() > 0)\n                    currNodeEntry.setSystemName(str);\n\n                // sysDescription\n                str = sysgrp.getSysDescr();\n                if (str != null && str.length() > 0)\n                    currNodeEntry.setSystemDescription(str);\n\n                // sysLocation\n                str = sysgrp.getSysLocation();\n                if (str != null && str.length() > 0)\n                    currNodeEntry.setSystemLocation(str);\n\n                // sysContact\n                str = sysgrp.getSysContact();\n                if (str != null && str.length() > 0)\n                    currNodeEntry.setSystemContact(str);\n            }\n        }\n\n        /*\n         * Currently, we do not use the ParentId except in mapping.\n         * Unfortunately, this is never\n         * set in the currNodeEntry so it gets reset here. As a workaround,\n         * setting it to the old value.\n         */\n\n        currNodeEntry.updateParentId(dbNodeEntry.getParentId());\n\n        // Update any fields which have changed\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateNode: -------dumping old node-------: \" + dbNodeEntry);\n            log().debug(\"updateNode: -------dumping new node-------: \" + currNodeEntry);\n        }\n        dbNodeEntry.updateParentId(currNodeEntry.getParentId());\n        dbNodeEntry.updateNodeType(currNodeEntry.getNodeType());\n        dbNodeEntry.updateSystemOID(currNodeEntry.getSystemOID());\n        dbNodeEntry.updateSystemName(currNodeEntry.getSystemName());\n        dbNodeEntry.updateSystemDescription(currNodeEntry.getSystemDescription());\n        dbNodeEntry.updateSystemLocation(currNodeEntry.getSystemLocation());\n        dbNodeEntry.updateSystemContact(currNodeEntry.getSystemContact());\n        dbNodeEntry.updateNetBIOSName(currNodeEntry.getNetBIOSName());\n        dbNodeEntry.updateDomainName(currNodeEntry.getDomainName());\n        dbNodeEntry.updateOS(currNodeEntry.getOS());\n        dbNodeEntry.setLastPoll(now);\n\n        /*\n         * Only update node label/source if original node entry is\n         * not set to user-defined.\n         */\n        if (dbNodeEntry.getLabelSource() != DbNodeEntry.LABEL_SOURCE_USER) {\n            dbNodeEntry.updateLabel(currNodeEntry.getLabel());\n            dbNodeEntry.updateLabelSource(currNodeEntry.getLabelSource());\n        }\n\n        // Set event flags\n        boolean nodeLabelChangedFlag = false;\n        boolean nodeInfoChangedFlag = false;\n\n        if (dbNodeEntry.hasLabelChanged() || dbNodeEntry.hasLabelSourceChanged()) {\n            nodeLabelChangedFlag = true;\n        }\n\n        if (dbNodeEntry.hasSystemOIDChanged() || dbNodeEntry.hasSystemNameChanged() || dbNodeEntry.hasSystemDescriptionChanged() || dbNodeEntry.hasSystemLocationChanged() || dbNodeEntry.hasSystemContactChanged() || dbNodeEntry.hasNetBIOSNameChanged() || dbNodeEntry.hasDomainNameChanged() || dbNodeEntry.hasOSChanged()) {\n            nodeInfoChangedFlag = true;\n        }\n\n        // Call store to update the database\n        dbNodeEntry.store(dbc);\n\n        // Create nodeLabelChanged event if necessary\n        if (nodeLabelChangedFlag) {\n            createNodeLabelChangedEvent(dbNodeEntry, originalDbNodeEntry);\n        }\n\n        // Create nodeInfoChangedEvent if necessary\n        if (nodeInfoChangedFlag) {\n            createNodeInfoChangedEvent(dbNodeEntry, originalDbNodeEntry);\n        }\n\n        return dbNodeEntry;\n    }","id":49233,"modified_method":"/**\n     * This method is responsible for updating the node table using the most\n     * recent data collected from the node's managed interfaces.\n     * \n     * @param dbc\n     *            Database connection\n     * @param now\n     *            Date object representing the time of the rescan.\n     * @param dbNodeEntry\n     *            DbNodeEntry object representing existing values in the\n     *            database\n     * @param currPrimarySnmpIf\n     *            Primary SNMP interface address based on latest collection\n     * @param dbIpInterfaces\n     *            Array of DbIpInterfaceEntry objects representing all the\n     *            interfaces retrieved from the database for this node.\n     * @param collectorMap\n     *            Map of IfCollector objects...one per managed interface.\n     * \n     * @return DbNodeEntry object representing the updated values from the node\n     *         table in the database.\n     * \n     * @throws SQLException\n     *             if there is a problem updating the node table.\n     */\n    private DbNodeEntry updateNode(Connection dbc, Date now, DbNodeEntry dbNodeEntry, InetAddress currPrimarySnmpIf, DbIpInterfaceEntry[] dbIpInterfaces, Map<String, IfCollector> collectorMap) throws SQLException {\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateNode: updating node id \" + dbNodeEntry.getNodeId());\n        }\n\n        /*\n         * Clone the existing dbNodeEntry so we have all the original\n         * values of the 'node' table fields in case we need to generate\n         * 'node***Changed' events following the update.\n         */\n        DbNodeEntry originalDbNodeEntry = DbNodeEntry.clone(dbNodeEntry);\n\n        /*\n         * Create node which represents the most recently retrieved\n         * information in the collector for this node\n         */\n        DbNodeEntry currNodeEntry = DbNodeEntry.create();\n        currNodeEntry.setNodeType(DbNodeEntry.NODE_TYPE_ACTIVE);\n\n        // Set node label and SMB info based on latest collection\n        setNodeLabelAndSmbInfo(collectorMap, dbNodeEntry, currNodeEntry, currPrimarySnmpIf);\n\n        // Set SNMP info\n        if (currPrimarySnmpIf != null) {\n            /*\n             * We prefer to use the collector for the primary SNMP interface\n             * to update SNMP data in the node table. However a collector\n             * for the primary SNMP interface may not exist in the map if\n             * a node has only recently had SNMP support enabled or if the\n             * new primary SNMP interface was only recently added to the\n             * node. At any rate if it exists use it, if not use the\n             * first collector which supports SNMP.\n             */\n            IfCollector primaryIfc = collectorMap.get(currPrimarySnmpIf.getHostAddress());\n            if (primaryIfc == null) {\n                for (IfCollector tmp : collectorMap.values()) {\n                    if (tmp.getSnmpCollector() != null) {\n                        primaryIfc = tmp;\n                        break;\n                    }\n                }\n            }\n\n            /*\n             * Sanity check...should always have a primary interface\n             * collector at this point\n             */\n            if (primaryIfc == null) {\n                log().error(\"updateNode: failed to determine primary interface collector for node \" + dbNodeEntry.getNodeId());\n                throw new RuntimeException(\"Update node failed for node \" + dbNodeEntry.getNodeId() + \", unable to determine primary interface collector.\");\n            }\n\n            IfSnmpCollector snmpc = primaryIfc.getSnmpCollector();\n            if (snmpc != null && snmpc.hasSystemGroup()) {\n                SystemGroup sysgrp = snmpc.getSystemGroup();\n\n                // sysObjectId\n                currNodeEntry.setSystemOID(sysgrp.getSysObjectID());\n\n                // sysName\n                String sysName = sysgrp.getSysName();\n                if (sysName != null && sysName.length() > 0) {\n                    currNodeEntry.setSystemName(sysName);\n                }\n\n                // sysDescription\n                String sysDescr = sysgrp.getSysDescr();\n                if (sysDescr != null && sysDescr.length() > 0) {\n                    currNodeEntry.setSystemDescription(sysDescr);\n                }\n\n                // sysLocation\n                String sysLocation = sysgrp.getSysLocation();\n                if (sysLocation != null && sysLocation.length() > 0) {\n                    currNodeEntry.setSystemLocation(sysLocation);\n                }\n\n                // sysContact\n                String sysContact = sysgrp.getSysContact();\n                if (sysContact != null && sysContact.length() > 0) {\n                    currNodeEntry.setSystemContact(sysContact);\n                }\n            }\n        }\n\n        /*\n         * Currently, we do not use the ParentId except in mapping.\n         * Unfortunately, this is never\n         * set in the currNodeEntry so it gets reset here. As a workaround,\n         * setting it to the old value.\n         */\n\n        currNodeEntry.updateParentId(dbNodeEntry.getParentId());\n\n        // Update any fields which have changed\n        if (log().isDebugEnabled()) {\n            log().debug(\"updateNode: -------dumping old node-------: \" + dbNodeEntry);\n            log().debug(\"updateNode: -------dumping new node-------: \" + currNodeEntry);\n        }\n        dbNodeEntry.updateParentId(currNodeEntry.getParentId());\n        dbNodeEntry.updateNodeType(currNodeEntry.getNodeType());\n        dbNodeEntry.updateSystemOID(currNodeEntry.getSystemOID());\n        dbNodeEntry.updateSystemName(currNodeEntry.getSystemName());\n        dbNodeEntry.updateSystemDescription(currNodeEntry.getSystemDescription());\n        dbNodeEntry.updateSystemLocation(currNodeEntry.getSystemLocation());\n        dbNodeEntry.updateSystemContact(currNodeEntry.getSystemContact());\n        dbNodeEntry.updateNetBIOSName(currNodeEntry.getNetBIOSName());\n        dbNodeEntry.updateDomainName(currNodeEntry.getDomainName());\n        dbNodeEntry.updateOS(currNodeEntry.getOS());\n        dbNodeEntry.setLastPoll(now);\n\n        /*\n         * Only update node label/source if original node entry is\n         * not set to user-defined.\n         */\n        if (dbNodeEntry.getLabelSource() != DbNodeEntry.LABEL_SOURCE_USER) {\n            dbNodeEntry.updateLabel(currNodeEntry.getLabel());\n            dbNodeEntry.updateLabelSource(currNodeEntry.getLabelSource());\n        }\n\n        // Set event flags\n        boolean nodeLabelChangedFlag = false;\n        boolean nodeInfoChangedFlag = false;\n\n        if (dbNodeEntry.hasLabelChanged() || dbNodeEntry.hasLabelSourceChanged()) {\n            nodeLabelChangedFlag = true;\n        }\n\n        if (dbNodeEntry.hasSystemOIDChanged() || dbNodeEntry.hasSystemNameChanged() || dbNodeEntry.hasSystemDescriptionChanged() || dbNodeEntry.hasSystemLocationChanged() || dbNodeEntry.hasSystemContactChanged() || dbNodeEntry.hasNetBIOSNameChanged() || dbNodeEntry.hasDomainNameChanged() || dbNodeEntry.hasOSChanged()) {\n            nodeInfoChangedFlag = true;\n        }\n\n        // Call store to update the database\n        dbNodeEntry.store(dbc);\n\n        // Create nodeLabelChanged event if necessary\n        if (nodeLabelChangedFlag) {\n            createNodeLabelChangedEvent(dbNodeEntry, originalDbNodeEntry);\n        }\n\n        // Create nodeInfoChangedEvent if necessary\n        if (nodeInfoChangedFlag) {\n            createNodeInfoChangedEvent(dbNodeEntry, originalDbNodeEntry);\n        }\n\n        return dbNodeEntry;\n    }","commit_id":"98f979a84d0aba7524b10eb0d2e9d7c657daa506","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    @SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        Backup backupComp = new Neo4jBackup( graphDb, location,\n            new ArrayList<String>()\n            {\n                {\n                    add( \"nioneodb\" );\n                    add( \"lucene\" );\n                }\n            } );\n        backupComp.doBackup();\n    }","id":49234,"modified_method":"@Override\n    @SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        Backup backupComp = Neo4jBackup.customDataSources( graphDb, location,\n                Arrays.asList( \"nioneodb\", \"lucene\" ) );\n        backupComp.doBackup();\n    }","commit_id":"645c23f107759bf27570bdae276717c67afa4807","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        IndexService bIndexService = new LuceneIndexService( bDb );\n        LuceneFulltextIndexService bFulltextIndex = new LuceneFulltextIndexService(\n                bDb );\n\n        Backup backupComp = new Neo4jBackup( graphDb, bDb, new ArrayList<String>()\n                {\n                    {\n                        add( \"nioneodb\" );\n                        add( \"lucene\" );\n                        add( \"lucene-fulltext\" );\n                    }\n                } );\n        backupComp.enableFileLogger();\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb, bIndexService, bFulltextIndex );\n    }","id":49235,"modified_method":"@SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        IndexService bIndexService = new LuceneIndexService( bDb );\n        LuceneFulltextIndexService bFulltextIndex = new LuceneFulltextIndexService(\n                bDb );\n\n        Backup backupComp = Neo4jBackup.allDataSources( graphDb, bDb );\n        backupComp.enableFileLogger();\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb, bIndexService, bFulltextIndex );\n    }","commit_id":"645c23f107759bf27570bdae276717c67afa4807","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        IndexService bIndexService = new LuceneIndexService( bDb );\n        Backup backupComp = new Neo4jBackup( graphDb, bDb, new ArrayList<String>()\n        {\n            {\n                add( \"nioneodb\" );\n                add( \"lucene\" );\n            }\n        } );\n        backupComp.enableFileLogger();\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb, bIndexService );\n    }","id":49236,"modified_method":"@SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        IndexService bIndexService = new LuceneIndexService( bDb );\n        Backup backupComp = Neo4jBackup.customDataSources( graphDb, bDb, \n                Arrays.asList( \"nioneodb\", \"lucene\" ) );\n        backupComp.enableFileLogger();\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb, bIndexService );\n    }","commit_id":"645c23f107759bf27570bdae276717c67afa4807","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Backup multiple data sources.\n     * \n     * @param srcResource backup source\n     * @param dstResource backup destination\n     * @throws IOException\n     */\n    private void runMultiBackup( final Neo4jResource srcResource,\n            final Neo4jResource dstResource ) throws IOException\n    {\n        List<Neo4jBackupTask> tasks = new ArrayList<Neo4jBackupTask>();\n        logger.info( \"Checking and preparing \" + xaNames.toString()\n                     + \" data sources.\" );\n        for ( String xaName : xaNames )\n        {\n            // check source\n            XaDataSourceResource srcDataSource = srcResource.getDataSource( xaName );\n            if ( srcDataSource == null )\n            {\n                String message = \"XaDataSource not found in backup source: [\"\n                                 + xaName + \"]\";\n                logger.severe( message );\n                throw new RuntimeException( message );\n            }\n            else\n            {\n                // check destination\n                XaDataSourceResource dstDataSource = dstResource.getDataSource( xaName );\n                if ( dstDataSource == null )\n                {\n                    String message = \"XaDataSource not found in backup destination: [\"\n                                     + xaName + \"]\";\n                    logger.severe( message );\n                    throw new RuntimeException( message );\n                }\n                else\n                {\n                    Neo4jBackupTask task = new Neo4jBackupTask( srcDataSource,\n                            dstDataSource );\n                    task.prepare();\n                    tasks.add( task );\n                }\n            }\n        }\n        if ( tasks.size() == 0 )\n        {\n            String message = \"No data sources to backup were found.\";\n            logger.severe( message );\n            throw new RuntimeException( message );\n        }\n        else\n        {\n            for ( Neo4jBackupTask task : tasks )\n            {\n                task.run();\n            }\n            logger.info( \"Completed backup of \" + tasks + \" data sources.\" );\n        }\n    }","id":49237,"modified_method":"/**\n     * Backup multiple data sources.\n     * \n     * @param srcResource backup source\n     * @param dstResource backup destination\n     * @throws IOException\n     */\n    private void runMultiBackup( final Neo4jResource srcResource,\n            final Neo4jResource dstResource ) throws IOException\n    {\n        List<Neo4jBackupTask> tasks = new ArrayList<Neo4jBackupTask>();\n        logger.info( \"Checking and preparing \" + xaNames + \" data sources.\" );\n        for ( String xaName : xaNames )\n        {\n            // check source\n            XaDataSourceResource srcDataSource = srcResource.getDataSource( xaName );\n            if ( srcDataSource == null )\n            {\n                String message = \"XaDataSource not found in backup source: [\" + xaName + \"]\";\n                logger.severe( message );\n                throw new RuntimeException( message );\n            }\n            else\n            {\n                // check destination\n                XaDataSourceResource dstDataSource = dstResource.getDataSource( xaName );\n                if ( dstDataSource == null )\n                {\n                    String message = \"XaDataSource not found in backup destination: [\"\n                                     + xaName + \"]\";\n                    logger.severe( message );\n                    throw new RuntimeException( message );\n                }\n                else\n                {\n                    Neo4jBackupTask task = new Neo4jBackupTask( srcDataSource, dstDataSource );\n                    task.prepare();\n                    tasks.add( task );\n                }\n            }\n        }\n        if ( tasks.size() == 0 )\n        {\n            String message = \"No data sources to backup were found.\";\n            logger.severe( message );\n            throw new RuntimeException( message );\n        }\n        else\n        {\n            for ( Neo4jBackupTask task : tasks )\n            {\n                task.run();\n            }\n            logger.info( \"Completed backup of \" + tasks + \" data sources.\" );\n        }\n    }","commit_id":"645c23f107759bf27570bdae276717c67afa4807","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Check if logical logs are kept for a data source.\n     * \n     * @param sourceGraphDb\n     * @param xaDataSourceNames\n     * @throws IllegalStateException if logical logs are not kept\n     */\n    private void checkLogicalLogConfig(\n            final EmbeddedGraphDatabase sourceGraphDb,\n            final List<String> xaDataSourceNames )\n    {\n        if ( xaDataSourceNames == null )\n        {\n            throw new IllegalArgumentException( \"xaDataSourceNames is null.\" );\n        }\n        if ( xaDataSourceNames.size() < 1 )\n        {\n            throw new IllegalArgumentException(\n                    \"xaDataSourceNames list is empty.\" );\n        }\n\n        XaDataSourceManager xaDataSourceManager = sourceGraphDb.getConfig().getTxModule().getXaDataSourceManager();\n\n        for ( String xaDataSourceName : xaDataSourceNames )\n        {\n            XaDataSource xaDataSource = xaDataSourceManager.getXaDataSource( xaDataSourceName );\n            if ( !xaDataSource.isLogicalLogKept() )\n            {\n                throw new IllegalStateException(\n                        \"Backup cannot be run, as the data source [\"\n                                + xaDataSourceName\n                                + \"] is not configured to keep logical logs.\" );\n            }\n        }\n    }","id":49238,"modified_method":"/**\n     * Backup from a running {@link EmbeddedGraphDatabase} to another running\n     * {@link EmbeddedGraphDatabase}. Which XA data sources to include in the\n     * backup can here be explicitly specified. This is considered to be more\n     * of an \"expert-mode\". If any of the specified data sources isn't set to\n     * keep its logical logs an {@link IllegalStateException} will be thrown.\n     * \n     * @param sourceGraphDb running database as backup source\n     * @param destGraphDb running database as backup destination\n     * @param xaDataSourceNames names of data sources to backup\n     */\n    public static Backup customDataSources( EmbeddedGraphDatabase source,\n            EmbeddedGraphDatabase destination, List<String> xaDataSourceNames )\n    {\n        return new Neo4jBackup( source, new GraphDbResourceFetcher( destination ),\n                new ArrayList<String>( xaDataSourceNames ) );\n    }","commit_id":"645c23f107759bf27570bdae276717c67afa4807","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void doBackup() throws IOException\n    {\n        logger.info( \"Initializing backup.\" );\n        Neo4jResource srcResource = new EmbeddedGraphDatabaseResource(\n                onlineGraphDb );\n        if ( xaNames == null )\n        {\n            if ( backupGraphDb == null )\n            {\n                Neo4jResource dstResource = LocalGraphDatabaseResource.getInstance( destDir );\n                runSimpleBackup( srcResource, dstResource );\n                dstResource.close();\n            }\n            else\n            {\n                Neo4jResource dstResource = new EmbeddedGraphDatabaseResource(\n                        backupGraphDb );\n                runSimpleBackup( srcResource, dstResource );\n            }\n        }\n        else\n        {\n            if ( backupGraphDb == null )\n            {\n                // TODO this is a temporary fix until we can restore services\n                Neo4jResource dstResource = LocalLuceneIndexResource.getInstance( destDir );\n                runMultiBackup( srcResource, dstResource );\n                dstResource.close();\n            }\n            else\n            {\n                Neo4jResource dstResource = new EmbeddedGraphDatabaseResource(\n                        backupGraphDb );\n                runMultiBackup( srcResource, dstResource );\n            }\n        }\n    }","id":49239,"modified_method":"public void doBackup() throws IOException\n    {\n        logger.info( \"Initializing backup.\" );\n        Neo4jResource srcResource = new EmbeddedGraphDatabaseResource( onlineGraphDb );\n        Neo4jResource dstResource = this.destinationResourceFetcher.fetch();\n        if ( xaNames.size() == 1 )\n        {\n            runSimpleBackup( srcResource, dstResource );\n        }\n        else\n        {\n            runMultiBackup( srcResource, dstResource );\n        }\n        this.destinationResourceFetcher.close( dstResource );\n    }","commit_id":"645c23f107759bf27570bdae276717c67afa4807","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Backup from a running {@link EmbeddedGraphDatabase} to another running\n     * {@link EmbeddedGraphDatabase} including other data sources. Common data\n     * source names are \"nioneodb\" and \"lucene\".\n     * \n     * @param sourceGraphDb running database as backup source\n     * @param destGraphDb running database as backup destination\n     * @param xaDataSourceNames names of data sources to backup\n     */\n    public Neo4jBackup( final EmbeddedGraphDatabase sourceGraphDb,\n            final EmbeddedGraphDatabase destGraphDb,\n            final List<String> xaDataSourceNames )\n    {\n        this( sourceGraphDb, destGraphDb );\n        checkLogicalLogConfig( sourceGraphDb, xaDataSourceNames );\n        this.xaNames = xaDataSourceNames;\n    }","id":49240,"modified_method":"private Neo4jBackup( EmbeddedGraphDatabase source,\n            ResourceFetcher destination, List<String> xaDataSources )\n    {\n        if ( source == null )\n        {\n            throw new IllegalArgumentException( \"The source graph db instance is null.\" );\n        }\n        if ( xaDataSources == null )\n        {\n            throw new IllegalArgumentException( \"XA data source name list is null\" );\n        }\n        this.onlineGraphDb = source;\n        this.destinationResourceFetcher = destination;\n        this.xaNames = xaDataSources;\n        assertLogicalLogsAreKept();\n    }","commit_id":"645c23f107759bf27570bdae276717c67afa4807","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void tryBackup( EmbeddedGraphDatabase graphDb,\n            String location, int relCount ) throws IOException\n    {\n        System.out.println( \"backing up to backup location\" );\n        Backup backupComp = new Neo4jBackup( graphDb, location );\n        backupComp.doBackup();\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        Transaction bTx = bDb.beginTx();\n        try\n        {\n            List<Relationship> rels = new ArrayList<Relationship>();\n            for ( Relationship rel : bDb.getReferenceNode().getRelationships() )\n            {\n                rels.add( rel );\n            }\n            assertEquals( relCount, rels.size() );\n            bTx.success();\n        }\n        finally\n        {\n            bTx.finish();\n        }\n        Util.stopGraphDb( bDb );\n    }","id":49241,"modified_method":"@Override\n    protected void tryBackup( EmbeddedGraphDatabase graphDb,\n            String location, int relCount ) throws IOException\n    {\n        System.out.println( \"backing up to backup location\" );\n        Backup backupComp = Neo4jBackup.neo4jDataSource( graphDb, location );\n        backupComp.doBackup();\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        Transaction bTx = bDb.beginTx();\n        try\n        {\n            List<Relationship> rels = new ArrayList<Relationship>();\n            for ( Relationship rel : bDb.getReferenceNode().getRelationships() )\n            {\n                rels.add( rel );\n            }\n            assertEquals( relCount, rels.size() );\n            bTx.success();\n        }\n        finally\n        {\n            bTx.finish();\n        }\n        Util.stopGraphDb( bDb );\n    }","commit_id":"645c23f107759bf27570bdae276717c67afa4807","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void tryBackup( EmbeddedGraphDatabase graphDb, String location,\n            int relCount )\n        throws IOException\n    {\n        System.out.println( \"backing up to running EmbeddedGraphDatabase instance\" );\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        Backup backupComp = new Neo4jBackup( graphDb, bDb );\n        configureBackup( backupComp );\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb );\n        bDb = Util.startGraphDbInstance( location );\n        Transaction bTx = bDb.beginTx();\n        try\n        {\n            List<Relationship> rels = new ArrayList<Relationship>();\n            for ( Relationship rel : bDb.getReferenceNode().getRelationships() )\n            {\n                rels.add( rel );\n            }\n            assertEquals( relCount, rels.size() );\n            bTx.success();\n        }\n        finally\n        {\n            bTx.finish();\n        }\n        Util.stopGraphDb( bDb );\n    }","id":49242,"modified_method":"protected void tryBackup( EmbeddedGraphDatabase graphDb, String location,\n            int relCount )\n        throws IOException\n    {\n        System.out.println( \"backing up to running EmbeddedGraphDatabase instance\" );\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        Backup backupComp = Neo4jBackup.neo4jDataSource( graphDb, bDb );\n        configureBackup( backupComp );\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb );\n        bDb = Util.startGraphDbInstance( location );\n        Transaction bTx = bDb.beginTx();\n        try\n        {\n            List<Relationship> rels = new ArrayList<Relationship>();\n            for ( Relationship rel : bDb.getReferenceNode().getRelationships() )\n            {\n                rels.add( rel );\n            }\n            assertEquals( relCount, rels.size() );\n            bTx.success();\n        }\n        finally\n        {\n            bTx.finish();\n        }\n        Util.stopGraphDb( bDb );\n    }","commit_id":"645c23f107759bf27570bdae276717c67afa4807","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    @SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        Backup backupComp = new Neo4jBackup( graphDb, location,\n            new ArrayList<String>()\n            {\n                {\n                    add( \"nioneodb\" );\n                    add( \"lucene\" );\n                }\n            } );\n        backupComp.doBackup();\n    }","id":49243,"modified_method":"@Override\n    @SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        Backup backupComp = Neo4jBackup.customDataSources( graphDb, location,\n                Arrays.asList( \"nioneodb\", \"lucene\" ) );\n        backupComp.doBackup();\n    }","commit_id":"12fe5c78e7db8c28d616359dd24c51fe51aed3d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        IndexService bIndexService = new LuceneIndexService( bDb );\n        LuceneFulltextIndexService bFulltextIndex = new LuceneFulltextIndexService(\n                bDb );\n\n        Backup backupComp = new Neo4jBackup( graphDb, bDb, new ArrayList<String>()\n                {\n                    {\n                        add( \"nioneodb\" );\n                        add( \"lucene\" );\n                        add( \"lucene-fulltext\" );\n                    }\n                } );\n        backupComp.enableFileLogger();\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb, bIndexService, bFulltextIndex );\n    }","id":49244,"modified_method":"@SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        IndexService bIndexService = new LuceneIndexService( bDb );\n        LuceneFulltextIndexService bFulltextIndex = new LuceneFulltextIndexService(\n                bDb );\n\n        Backup backupComp = Neo4jBackup.allDataSources( graphDb, bDb );\n        backupComp.enableFileLogger();\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb, bIndexService, bFulltextIndex );\n    }","commit_id":"12fe5c78e7db8c28d616359dd24c51fe51aed3d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        IndexService bIndexService = new LuceneIndexService( bDb );\n        Backup backupComp = new Neo4jBackup( graphDb, bDb, new ArrayList<String>()\n        {\n            {\n                add( \"nioneodb\" );\n                add( \"lucene\" );\n            }\n        } );\n        backupComp.enableFileLogger();\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb, bIndexService );\n    }","id":49245,"modified_method":"@SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        IndexService bIndexService = new LuceneIndexService( bDb );\n        Backup backupComp = Neo4jBackup.customDataSources( graphDb, bDb, \n                Arrays.asList( \"nioneodb\", \"lucene\" ) );\n        backupComp.enableFileLogger();\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb, bIndexService );\n    }","commit_id":"12fe5c78e7db8c28d616359dd24c51fe51aed3d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Backup from a running {@link EmbeddedGraphDatabase} to another running\n     * {@link EmbeddedGraphDatabase} including other data sources. Common data\n     * source names are \"nioneodb\" and \"lucene\".\n     * \n     * @param sourceGraphDb running database as backup source\n     * @param destGraphDb running database as backup destination\n     * @param xaDataSourceNames names of data sources to backup\n     */\n    public Neo4jBackup( final EmbeddedGraphDatabase sourceGraphDb,\n            final EmbeddedGraphDatabase destGraphDb,\n            final List<String> xaDataSourceNames )\n    {\n        this( sourceGraphDb, destGraphDb );\n        checkLogicalLogConfig( sourceGraphDb, xaDataSourceNames );\n        this.xaNames = xaDataSourceNames;\n    }","id":49246,"modified_method":"private Neo4jBackup( EmbeddedGraphDatabase source,\n            ResourceFetcher destination, List<String> xaDataSources )\n    {\n        if ( source == null )\n        {\n            throw new IllegalArgumentException( \"The source graph db instance is null.\" );\n        }\n        if ( xaDataSources == null )\n        {\n            throw new IllegalArgumentException( \"XA data source name list is null\" );\n        }\n        this.onlineGraphDb = source;\n        this.destinationResourceFetcher = destination;\n        this.xaNames = xaDataSources;\n        assertLogicalLogsAreKept();\n    }","commit_id":"12fe5c78e7db8c28d616359dd24c51fe51aed3d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Backup multiple data sources.\n     * \n     * @param srcResource backup source\n     * @param dstResource backup destination\n     * @throws IOException\n     */\n    private void runMultiBackup( final Neo4jResource srcResource,\n            final Neo4jResource dstResource ) throws IOException\n    {\n        List<Neo4jBackupTask> tasks = new ArrayList<Neo4jBackupTask>();\n        logger.info( \"Checking and preparing \" + xaNames.toString()\n                     + \" data sources.\" );\n        for ( String xaName : xaNames )\n        {\n            // check source\n            XaDataSourceResource srcDataSource = srcResource.getDataSource( xaName );\n            if ( srcDataSource == null )\n            {\n                String message = \"XaDataSource not found in backup source: [\"\n                                 + xaName + \"]\";\n                logger.severe( message );\n                throw new RuntimeException( message );\n            }\n            else\n            {\n                // check destination\n                XaDataSourceResource dstDataSource = dstResource.getDataSource( xaName );\n                if ( dstDataSource == null )\n                {\n                    String message = \"XaDataSource not found in backup destination: [\"\n                                     + xaName + \"]\";\n                    logger.severe( message );\n                    throw new RuntimeException( message );\n                }\n                else\n                {\n                    Neo4jBackupTask task = new Neo4jBackupTask( srcDataSource,\n                            dstDataSource );\n                    task.prepare();\n                    tasks.add( task );\n                }\n            }\n        }\n        if ( tasks.size() == 0 )\n        {\n            String message = \"No data sources to backup were found.\";\n            logger.severe( message );\n            throw new RuntimeException( message );\n        }\n        else\n        {\n            for ( Neo4jBackupTask task : tasks )\n            {\n                task.run();\n            }\n            logger.info( \"Completed backup of \" + tasks + \" data sources.\" );\n        }\n    }","id":49247,"modified_method":"/**\n     * Backup multiple data sources.\n     * \n     * @param srcResource backup source\n     * @param dstResource backup destination\n     * @throws IOException\n     */\n    private void runMultiBackup( final Neo4jResource srcResource,\n            final Neo4jResource dstResource ) throws IOException\n    {\n        List<Neo4jBackupTask> tasks = new ArrayList<Neo4jBackupTask>();\n        logger.info( \"Checking and preparing \" + xaNames + \" data sources.\" );\n        for ( String xaName : xaNames )\n        {\n            // check source\n            XaDataSourceResource srcDataSource = srcResource.getDataSource( xaName );\n            if ( srcDataSource == null )\n            {\n                String message = \"XaDataSource not found in backup source: [\" + xaName + \"]\";\n                logger.severe( message );\n                throw new RuntimeException( message );\n            }\n            else\n            {\n                // check destination\n                XaDataSourceResource dstDataSource = dstResource.getDataSource( xaName );\n                if ( dstDataSource == null )\n                {\n                    String message = \"XaDataSource not found in backup destination: [\"\n                                     + xaName + \"]\";\n                    logger.severe( message );\n                    throw new RuntimeException( message );\n                }\n                else\n                {\n                    Neo4jBackupTask task = new Neo4jBackupTask( srcDataSource, dstDataSource );\n                    task.prepare();\n                    tasks.add( task );\n                }\n            }\n        }\n        if ( tasks.size() == 0 )\n        {\n            String message = \"No data sources to backup were found.\";\n            logger.severe( message );\n            throw new RuntimeException( message );\n        }\n        else\n        {\n            for ( Neo4jBackupTask task : tasks )\n            {\n                task.run();\n            }\n            logger.info( \"Completed backup of \" + tasks + \" data sources.\" );\n        }\n    }","commit_id":"12fe5c78e7db8c28d616359dd24c51fe51aed3d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Check if logical logs are kept for a data source.\n     * \n     * @param sourceGraphDb\n     * @param xaDataSourceNames\n     * @throws IllegalStateException if logical logs are not kept\n     */\n    private void checkLogicalLogConfig(\n            final EmbeddedGraphDatabase sourceGraphDb,\n            final List<String> xaDataSourceNames )\n    {\n        if ( xaDataSourceNames == null )\n        {\n            throw new IllegalArgumentException( \"xaDataSourceNames is null.\" );\n        }\n        if ( xaDataSourceNames.size() < 1 )\n        {\n            throw new IllegalArgumentException(\n                    \"xaDataSourceNames list is empty.\" );\n        }\n\n        XaDataSourceManager xaDataSourceManager = sourceGraphDb.getConfig().getTxModule().getXaDataSourceManager();\n\n        for ( String xaDataSourceName : xaDataSourceNames )\n        {\n            XaDataSource xaDataSource = xaDataSourceManager.getXaDataSource( xaDataSourceName );\n            if ( !xaDataSource.isLogicalLogKept() )\n            {\n                throw new IllegalStateException(\n                        \"Backup cannot be run, as the data source [\"\n                                + xaDataSourceName\n                                + \"] is not configured to keep logical logs.\" );\n            }\n        }\n    }","id":49248,"modified_method":"/**\n     * Backup from a running {@link EmbeddedGraphDatabase} to another running\n     * {@link EmbeddedGraphDatabase}. Which XA data sources to include in the\n     * backup can here be explicitly specified. This is considered to be more\n     * of an \"expert-mode\". If any of the specified data sources isn't set to\n     * keep its logical logs an {@link IllegalStateException} will be thrown.\n     * \n     * @param sourceGraphDb running database as backup source\n     * @param destGraphDb running database as backup destination\n     * @param xaDataSourceNames names of data sources to backup\n     */\n    public static Backup customDataSources( EmbeddedGraphDatabase source,\n            EmbeddedGraphDatabase destination, List<String> xaDataSourceNames )\n    {\n        return new Neo4jBackup( source, new GraphDbResourceFetcher( destination ),\n                new ArrayList<String>( xaDataSourceNames ) );\n    }","commit_id":"12fe5c78e7db8c28d616359dd24c51fe51aed3d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void doBackup() throws IOException\n    {\n        logger.info( \"Initializing backup.\" );\n        Neo4jResource srcResource = new EmbeddedGraphDatabaseResource(\n                onlineGraphDb );\n        if ( xaNames == null )\n        {\n            if ( backupGraphDb == null )\n            {\n                Neo4jResource dstResource = LocalGraphDatabaseResource.getInstance( destDir );\n                runSimpleBackup( srcResource, dstResource );\n                dstResource.close();\n            }\n            else\n            {\n                Neo4jResource dstResource = new EmbeddedGraphDatabaseResource(\n                        backupGraphDb );\n                runSimpleBackup( srcResource, dstResource );\n            }\n        }\n        else\n        {\n            if ( backupGraphDb == null )\n            {\n                // TODO this is a temporary fix until we can restore services\n                Neo4jResource dstResource = LocalLuceneIndexResource.getInstance( destDir );\n                runMultiBackup( srcResource, dstResource );\n                dstResource.close();\n            }\n            else\n            {\n                Neo4jResource dstResource = new EmbeddedGraphDatabaseResource(\n                        backupGraphDb );\n                runMultiBackup( srcResource, dstResource );\n            }\n        }\n    }","id":49249,"modified_method":"public void doBackup() throws IOException\n    {\n        logger.info( \"Initializing backup.\" );\n        Neo4jResource srcResource = new EmbeddedGraphDatabaseResource( onlineGraphDb );\n        Neo4jResource dstResource = this.destinationResourceFetcher.fetch();\n        if ( xaNames.size() == 1 )\n        {\n            runSimpleBackup( srcResource, dstResource );\n        }\n        else\n        {\n            runMultiBackup( srcResource, dstResource );\n        }\n        this.destinationResourceFetcher.close( dstResource );\n    }","commit_id":"12fe5c78e7db8c28d616359dd24c51fe51aed3d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void tryBackup( EmbeddedGraphDatabase graphDb,\n            String location, int relCount ) throws IOException\n    {\n        System.out.println( \"backing up to backup location\" );\n        Backup backupComp = new Neo4jBackup( graphDb, location );\n        backupComp.doBackup();\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        Transaction bTx = bDb.beginTx();\n        try\n        {\n            List<Relationship> rels = new ArrayList<Relationship>();\n            for ( Relationship rel : bDb.getReferenceNode().getRelationships() )\n            {\n                rels.add( rel );\n            }\n            assertEquals( relCount, rels.size() );\n            bTx.success();\n        }\n        finally\n        {\n            bTx.finish();\n        }\n        Util.stopGraphDb( bDb );\n    }","id":49250,"modified_method":"@Override\n    protected void tryBackup( EmbeddedGraphDatabase graphDb,\n            String location, int relCount ) throws IOException\n    {\n        System.out.println( \"backing up to backup location\" );\n        Backup backupComp = Neo4jBackup.neo4jDataSource( graphDb, location );\n        backupComp.doBackup();\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        Transaction bTx = bDb.beginTx();\n        try\n        {\n            List<Relationship> rels = new ArrayList<Relationship>();\n            for ( Relationship rel : bDb.getReferenceNode().getRelationships() )\n            {\n                rels.add( rel );\n            }\n            assertEquals( relCount, rels.size() );\n            bTx.success();\n        }\n        finally\n        {\n            bTx.finish();\n        }\n        Util.stopGraphDb( bDb );\n    }","commit_id":"12fe5c78e7db8c28d616359dd24c51fe51aed3d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void tryBackup( EmbeddedGraphDatabase graphDb, String location,\n            int relCount )\n        throws IOException\n    {\n        System.out.println( \"backing up to running EmbeddedGraphDatabase instance\" );\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        Backup backupComp = new Neo4jBackup( graphDb, bDb );\n        configureBackup( backupComp );\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb );\n        bDb = Util.startGraphDbInstance( location );\n        Transaction bTx = bDb.beginTx();\n        try\n        {\n            List<Relationship> rels = new ArrayList<Relationship>();\n            for ( Relationship rel : bDb.getReferenceNode().getRelationships() )\n            {\n                rels.add( rel );\n            }\n            assertEquals( relCount, rels.size() );\n            bTx.success();\n        }\n        finally\n        {\n            bTx.finish();\n        }\n        Util.stopGraphDb( bDb );\n    }","id":49251,"modified_method":"protected void tryBackup( EmbeddedGraphDatabase graphDb, String location,\n            int relCount )\n        throws IOException\n    {\n        System.out.println( \"backing up to running EmbeddedGraphDatabase instance\" );\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        Backup backupComp = Neo4jBackup.neo4jDataSource( graphDb, bDb );\n        configureBackup( backupComp );\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb );\n        bDb = Util.startGraphDbInstance( location );\n        Transaction bTx = bDb.beginTx();\n        try\n        {\n            List<Relationship> rels = new ArrayList<Relationship>();\n            for ( Relationship rel : bDb.getReferenceNode().getRelationships() )\n            {\n                rels.add( rel );\n            }\n            assertEquals( relCount, rels.size() );\n            bTx.success();\n        }\n        finally\n        {\n            bTx.finish();\n        }\n        Util.stopGraphDb( bDb );\n    }","commit_id":"12fe5c78e7db8c28d616359dd24c51fe51aed3d9","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    @SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        Backup backupComp = new Neo4jBackup( graphDb, location,\n            new ArrayList<String>()\n            {\n                {\n                    add( \"nioneodb\" );\n                    add( \"lucene\" );\n                }\n            } );\n        backupComp.doBackup();\n    }","id":49252,"modified_method":"@Override\n    @SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        Backup backupComp = Neo4jBackup.customDataSources( graphDb, location,\n                Arrays.asList( \"nioneodb\", \"lucene\" ) );\n        backupComp.doBackup();\n    }","commit_id":"a506a57b395cc27499f6134bba37e98d5a3aac3b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        IndexService bIndexService = new LuceneIndexService( bDb );\n        LuceneFulltextIndexService bFulltextIndex = new LuceneFulltextIndexService(\n                bDb );\n\n        Backup backupComp = new Neo4jBackup( graphDb, bDb, new ArrayList<String>()\n                {\n                    {\n                        add( \"nioneodb\" );\n                        add( \"lucene\" );\n                        add( \"lucene-fulltext\" );\n                    }\n                } );\n        backupComp.enableFileLogger();\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb, bIndexService, bFulltextIndex );\n    }","id":49253,"modified_method":"@SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        IndexService bIndexService = new LuceneIndexService( bDb );\n        LuceneFulltextIndexService bFulltextIndex = new LuceneFulltextIndexService(\n                bDb );\n\n        Backup backupComp = Neo4jBackup.allDataSources( graphDb, bDb );\n        backupComp.enableFileLogger();\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb, bIndexService, bFulltextIndex );\n    }","commit_id":"a506a57b395cc27499f6134bba37e98d5a3aac3b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        IndexService bIndexService = new LuceneIndexService( bDb );\n        Backup backupComp = new Neo4jBackup( graphDb, bDb, new ArrayList<String>()\n        {\n            {\n                add( \"nioneodb\" );\n                add( \"lucene\" );\n            }\n        } );\n        backupComp.enableFileLogger();\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb, bIndexService );\n    }","id":49254,"modified_method":"@SuppressWarnings( \"serial\" )\n    protected void setupBackup( EmbeddedGraphDatabase graphDb, String location )\n        throws IOException\n    {\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        IndexService bIndexService = new LuceneIndexService( bDb );\n        Backup backupComp = Neo4jBackup.customDataSources( graphDb, bDb, \n                Arrays.asList( \"nioneodb\", \"lucene\" ) );\n        backupComp.enableFileLogger();\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb, bIndexService );\n    }","commit_id":"a506a57b395cc27499f6134bba37e98d5a3aac3b","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Check if logical logs are kept for a data source.\n     * \n     * @param sourceGraphDb\n     * @param xaDataSourceNames\n     * @throws IllegalStateException if logical logs are not kept\n     */\n    private void checkLogicalLogConfig(\n            final EmbeddedGraphDatabase sourceGraphDb,\n            final List<String> xaDataSourceNames )\n    {\n        if ( xaDataSourceNames == null )\n        {\n            throw new IllegalArgumentException( \"xaDataSourceNames is null.\" );\n        }\n        if ( xaDataSourceNames.size() < 1 )\n        {\n            throw new IllegalArgumentException(\n                    \"xaDataSourceNames list is empty.\" );\n        }\n\n        XaDataSourceManager xaDataSourceManager = sourceGraphDb.getConfig().getTxModule().getXaDataSourceManager();\n\n        for ( String xaDataSourceName : xaDataSourceNames )\n        {\n            XaDataSource xaDataSource = xaDataSourceManager.getXaDataSource( xaDataSourceName );\n            if ( !xaDataSource.isLogicalLogKept() )\n            {\n                throw new IllegalStateException(\n                        \"Backup cannot be run, as the data source [\"\n                                + xaDataSourceName\n                                + \"] is not configured to keep logical logs.\" );\n            }\n        }\n    }","id":49255,"modified_method":"/**\n     * Backup from a running {@link EmbeddedGraphDatabase} to another running\n     * {@link EmbeddedGraphDatabase}. Which XA data sources to include in the\n     * backup can here be explicitly specified. This is considered to be more\n     * of an \"expert-mode\". If any of the specified data sources isn't set to\n     * keep its logical logs an {@link IllegalStateException} will be thrown.\n     * \n     * @param sourceGraphDb running database as backup source\n     * @param destGraphDb running database as backup destination\n     * @param xaDataSourceNames names of data sources to backup\n     */\n    public static Backup customDataSources( EmbeddedGraphDatabase source,\n            EmbeddedGraphDatabase destination, List<String> xaDataSourceNames )\n    {\n        return new Neo4jBackup( source, new GraphDbResourceFetcher( destination ),\n                new ArrayList<String>( xaDataSourceNames ) );\n    }","commit_id":"a506a57b395cc27499f6134bba37e98d5a3aac3b","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Backup multiple data sources.\n     * \n     * @param srcResource backup source\n     * @param dstResource backup destination\n     * @throws IOException\n     */\n    private void runMultiBackup( final Neo4jResource srcResource,\n            final Neo4jResource dstResource ) throws IOException\n    {\n        List<Neo4jBackupTask> tasks = new ArrayList<Neo4jBackupTask>();\n        logger.info( \"Checking and preparing \" + xaNames.toString()\n                     + \" data sources.\" );\n        for ( String xaName : xaNames )\n        {\n            // check source\n            XaDataSourceResource srcDataSource = srcResource.getDataSource( xaName );\n            if ( srcDataSource == null )\n            {\n                String message = \"XaDataSource not found in backup source: [\"\n                                 + xaName + \"]\";\n                logger.severe( message );\n                throw new RuntimeException( message );\n            }\n            else\n            {\n                // check destination\n                XaDataSourceResource dstDataSource = dstResource.getDataSource( xaName );\n                if ( dstDataSource == null )\n                {\n                    String message = \"XaDataSource not found in backup destination: [\"\n                                     + xaName + \"]\";\n                    logger.severe( message );\n                    throw new RuntimeException( message );\n                }\n                else\n                {\n                    Neo4jBackupTask task = new Neo4jBackupTask( srcDataSource,\n                            dstDataSource );\n                    task.prepare();\n                    tasks.add( task );\n                }\n            }\n        }\n        if ( tasks.size() == 0 )\n        {\n            String message = \"No data sources to backup were found.\";\n            logger.severe( message );\n            throw new RuntimeException( message );\n        }\n        else\n        {\n            for ( Neo4jBackupTask task : tasks )\n            {\n                task.run();\n            }\n            logger.info( \"Completed backup of \" + tasks + \" data sources.\" );\n        }\n    }","id":49256,"modified_method":"/**\n     * Backup multiple data sources.\n     * \n     * @param srcResource backup source\n     * @param dstResource backup destination\n     * @throws IOException\n     */\n    private void runMultiBackup( final Neo4jResource srcResource,\n            final Neo4jResource dstResource ) throws IOException\n    {\n        List<Neo4jBackupTask> tasks = new ArrayList<Neo4jBackupTask>();\n        logger.info( \"Checking and preparing \" + xaNames + \" data sources.\" );\n        for ( String xaName : xaNames )\n        {\n            // check source\n            XaDataSourceResource srcDataSource = srcResource.getDataSource( xaName );\n            if ( srcDataSource == null )\n            {\n                String message = \"XaDataSource not found in backup source: [\" + xaName + \"]\";\n                logger.severe( message );\n                throw new RuntimeException( message );\n            }\n            else\n            {\n                // check destination\n                XaDataSourceResource dstDataSource = dstResource.getDataSource( xaName );\n                if ( dstDataSource == null )\n                {\n                    String message = \"XaDataSource not found in backup destination: [\"\n                                     + xaName + \"]\";\n                    logger.severe( message );\n                    throw new RuntimeException( message );\n                }\n                else\n                {\n                    Neo4jBackupTask task = new Neo4jBackupTask( srcDataSource, dstDataSource );\n                    task.prepare();\n                    tasks.add( task );\n                }\n            }\n        }\n        if ( tasks.size() == 0 )\n        {\n            String message = \"No data sources to backup were found.\";\n            logger.severe( message );\n            throw new RuntimeException( message );\n        }\n        else\n        {\n            for ( Neo4jBackupTask task : tasks )\n            {\n                task.run();\n            }\n            logger.info( \"Completed backup of \" + tasks + \" data sources.\" );\n        }\n    }","commit_id":"a506a57b395cc27499f6134bba37e98d5a3aac3b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void doBackup() throws IOException\n    {\n        logger.info( \"Initializing backup.\" );\n        Neo4jResource srcResource = new EmbeddedGraphDatabaseResource(\n                onlineGraphDb );\n        if ( xaNames == null )\n        {\n            if ( backupGraphDb == null )\n            {\n                Neo4jResource dstResource = LocalGraphDatabaseResource.getInstance( destDir );\n                runSimpleBackup( srcResource, dstResource );\n                dstResource.close();\n            }\n            else\n            {\n                Neo4jResource dstResource = new EmbeddedGraphDatabaseResource(\n                        backupGraphDb );\n                runSimpleBackup( srcResource, dstResource );\n            }\n        }\n        else\n        {\n            if ( backupGraphDb == null )\n            {\n                // TODO this is a temporary fix until we can restore services\n                Neo4jResource dstResource = LocalLuceneIndexResource.getInstance( destDir );\n                runMultiBackup( srcResource, dstResource );\n                dstResource.close();\n            }\n            else\n            {\n                Neo4jResource dstResource = new EmbeddedGraphDatabaseResource(\n                        backupGraphDb );\n                runMultiBackup( srcResource, dstResource );\n            }\n        }\n    }","id":49257,"modified_method":"public void doBackup() throws IOException\n    {\n        logger.info( \"Initializing backup.\" );\n        Neo4jResource srcResource = new EmbeddedGraphDatabaseResource( onlineGraphDb );\n        Neo4jResource dstResource = this.destinationResourceFetcher.fetch();\n        if ( xaNames.size() == 1 )\n        {\n            runSimpleBackup( srcResource, dstResource );\n        }\n        else\n        {\n            runMultiBackup( srcResource, dstResource );\n        }\n        this.destinationResourceFetcher.close( dstResource );\n    }","commit_id":"a506a57b395cc27499f6134bba37e98d5a3aac3b","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Backup from a running {@link EmbeddedGraphDatabase} to another running\n     * {@link EmbeddedGraphDatabase} including other data sources. Common data\n     * source names are \"nioneodb\" and \"lucene\".\n     * \n     * @param sourceGraphDb running database as backup source\n     * @param destGraphDb running database as backup destination\n     * @param xaDataSourceNames names of data sources to backup\n     */\n    public Neo4jBackup( final EmbeddedGraphDatabase sourceGraphDb,\n            final EmbeddedGraphDatabase destGraphDb,\n            final List<String> xaDataSourceNames )\n    {\n        this( sourceGraphDb, destGraphDb );\n        checkLogicalLogConfig( sourceGraphDb, xaDataSourceNames );\n        this.xaNames = xaDataSourceNames;\n    }","id":49258,"modified_method":"private Neo4jBackup( EmbeddedGraphDatabase source,\n            ResourceFetcher destination, List<String> xaDataSources )\n    {\n        if ( source == null )\n        {\n            throw new IllegalArgumentException( \"The source graph db instance is null.\" );\n        }\n        if ( xaDataSources == null )\n        {\n            throw new IllegalArgumentException( \"XA data source name list is null\" );\n        }\n        this.onlineGraphDb = source;\n        this.destinationResourceFetcher = destination;\n        this.xaNames = xaDataSources;\n        assertLogicalLogsAreKept();\n    }","commit_id":"a506a57b395cc27499f6134bba37e98d5a3aac3b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void tryBackup( EmbeddedGraphDatabase graphDb,\n            String location, int relCount ) throws IOException\n    {\n        System.out.println( \"backing up to backup location\" );\n        Backup backupComp = new Neo4jBackup( graphDb, location );\n        backupComp.doBackup();\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        Transaction bTx = bDb.beginTx();\n        try\n        {\n            List<Relationship> rels = new ArrayList<Relationship>();\n            for ( Relationship rel : bDb.getReferenceNode().getRelationships() )\n            {\n                rels.add( rel );\n            }\n            assertEquals( relCount, rels.size() );\n            bTx.success();\n        }\n        finally\n        {\n            bTx.finish();\n        }\n        Util.stopGraphDb( bDb );\n    }","id":49259,"modified_method":"@Override\n    protected void tryBackup( EmbeddedGraphDatabase graphDb,\n            String location, int relCount ) throws IOException\n    {\n        System.out.println( \"backing up to backup location\" );\n        Backup backupComp = Neo4jBackup.neo4jDataSource( graphDb, location );\n        backupComp.doBackup();\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        Transaction bTx = bDb.beginTx();\n        try\n        {\n            List<Relationship> rels = new ArrayList<Relationship>();\n            for ( Relationship rel : bDb.getReferenceNode().getRelationships() )\n            {\n                rels.add( rel );\n            }\n            assertEquals( relCount, rels.size() );\n            bTx.success();\n        }\n        finally\n        {\n            bTx.finish();\n        }\n        Util.stopGraphDb( bDb );\n    }","commit_id":"a506a57b395cc27499f6134bba37e98d5a3aac3b","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void tryBackup( EmbeddedGraphDatabase graphDb, String location,\n            int relCount )\n        throws IOException\n    {\n        System.out.println( \"backing up to running EmbeddedGraphDatabase instance\" );\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        Backup backupComp = new Neo4jBackup( graphDb, bDb );\n        configureBackup( backupComp );\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb );\n        bDb = Util.startGraphDbInstance( location );\n        Transaction bTx = bDb.beginTx();\n        try\n        {\n            List<Relationship> rels = new ArrayList<Relationship>();\n            for ( Relationship rel : bDb.getReferenceNode().getRelationships() )\n            {\n                rels.add( rel );\n            }\n            assertEquals( relCount, rels.size() );\n            bTx.success();\n        }\n        finally\n        {\n            bTx.finish();\n        }\n        Util.stopGraphDb( bDb );\n    }","id":49260,"modified_method":"protected void tryBackup( EmbeddedGraphDatabase graphDb, String location,\n            int relCount )\n        throws IOException\n    {\n        System.out.println( \"backing up to running EmbeddedGraphDatabase instance\" );\n        EmbeddedGraphDatabase bDb = Util.startGraphDbInstance( location );\n        Backup backupComp = Neo4jBackup.neo4jDataSource( graphDb, bDb );\n        configureBackup( backupComp );\n        backupComp.doBackup();\n        Util.stopGraphDb( bDb );\n        bDb = Util.startGraphDbInstance( location );\n        Transaction bTx = bDb.beginTx();\n        try\n        {\n            List<Relationship> rels = new ArrayList<Relationship>();\n            for ( Relationship rel : bDb.getReferenceNode().getRelationships() )\n            {\n                rels.add( rel );\n            }\n            assertEquals( relCount, rels.size() );\n            bTx.success();\n        }\n        finally\n        {\n            bTx.finish();\n        }\n        Util.stopGraphDb( bDb );\n    }","commit_id":"a506a57b395cc27499f6134bba37e98d5a3aac3b","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Poll the specified address for FTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port (by\n     * default TCP port 21). If the connection request is successful, the banner\n     * line generated by the interface is parsed and if the extracted return\n     * code indicates that we are talking to an FTP server we continue. Next, an\n     * FTP 'QUIT' command is sent. Provided that the interface's response is\n     * valid we set the service status to SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // check the interface type\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        // Get the category logger\n        //\n        Category log = ThreadCategory.getInstance(getClass());\n\n        // get the parameters\n        //\n        \n        TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n\n        int port = ParameterMap.getKeyedInteger(parameters, \"port\", DEFAULT_PORT);\n        String userid = ParameterMap.getKeyedString(parameters, \"userid\", null);\n        String password = ParameterMap.getKeyedString(parameters, \"password\", null);\n\n        // Extract the address\n        //\n        InetAddress ipv4Addr = (InetAddress) iface.getAddress();\n\n        if (log.isDebugEnabled())\n            log.debug(\"FtpMonitor.poll: Polling interface: \" + ipv4Addr.getHostAddress() + tracker);\n\n        PollStatus serviceStatus = PollStatus.unavailable();\n        for (tracker.reset(); tracker.shouldRetry() && !serviceStatus.isAvailable(); tracker.nextAttempt()) {\n            Socket socket = null;\n            try {\n                //\n                // create a connected socket\n                //\n                tracker.startAttempt();\n\n                socket = new Socket();\n                socket.connect(new InetSocketAddress(ipv4Addr, port), tracker.getConnectionTimeout());\n                socket.setSoTimeout(tracker.getSoTimeout());\n\n                log.debug(\"FtpMonitor: connected to host: \" + ipv4Addr + \" on port: \" + port);\n                // We're connected, so upgrade status to unresponsive\n                serviceStatus = PollStatus.unresponsive();\n\n                BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n                // Tokenize the Banner Line, and check the first\n                // line for a valid return.\n                //\n                String banner = lineRdr.readLine();\n                double responseTime = tracker.elapsedTimeInMillis();\n\n                if (banner == null)\n                    continue;\n                if (MULTILINE.match(banner)) {\n                    // Ok we have a multi-line response...first three\n                    // chars of the response line are the return code.\n                    // The last line of the response will start with\n                    // return code followed by a space.\n                    String multiLineRC = new String(banner.getBytes(), 0, 3) + \" \";\n\n                    // Create new regExp to look for last line\n                    // of this mutli line response\n                    try {\n                        ENDMULTILINE = new RE(multiLineRC);\n                    } catch (RESyntaxException ex) {\n                        throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                    }\n\n                    // read until we hit the last line of the multi-line\n                    // response\n                    do {\n                        banner = lineRdr.readLine();\n                    } while (banner != null && !ENDMULTILINE.match(banner));\n                    if (banner == null)\n                        continue;\n                }\n\n                StringTokenizer t = new StringTokenizer(banner);\n\n                int rc = -1;\n                try {\n                    rc = Integer.parseInt(t.nextToken());\n                } catch (NumberFormatException nfE) {\n                    nfE.fillInStackTrace();\n                    log.warn(\"Banner page returned invalid result code\", nfE);\n                }\n\n                // Verify that return code is in proper range.\n                //\n                if (rc >= 200 && rc <= 299) {\n                    // \n                    // Attempt to login if userid and password available\n                    //\n                    boolean bLoginOk = false;\n                    if (userid == null || userid.length() == 0 || password == null || password.length() == 0) {\n                        bLoginOk = true;\n                    } else {\n                        // send the use string\n                        //\n                        String cmd = \"user \" + userid + \"\\r\\n\";\n                        socket.getOutputStream().write(cmd.getBytes());\n\n                        // get the response code.\n                        //\n                        String response = null;\n                        do {\n                            response = lineRdr.readLine();\n                        } while (response != null && MULTILINE.match(response));\n                        if (response == null)\n                            continue;\n\n                        t = new StringTokenizer(response);\n                        rc = Integer.parseInt(t.nextToken());\n\n                        // Verify that return code is in proper range.\n                        //\n                        if (rc >= 200 && rc <= 399) {\n                            // send the password\n                            //\n                            cmd = \"pass \" + password + \"\\r\\n\";\n                            socket.getOutputStream().write(cmd.getBytes());\n\n                            // get the response...check for multi-line response\n                            //\n                            response = lineRdr.readLine();\n                            if (response == null)\n                                continue;\n\n                            if (MULTILINE.match(response)) {\n                                // Ok we have a multi-line response...first\n                                // three\n                                // chars of the response line are the return\n                                // code.\n                                // The last line of the response will start with\n                                // return code followed by a space.\n                                String multiLineRC = new String(response.getBytes(), 0, 3) + \" \";\n\n                                // Create new regExp to look for last line\n                                // of this mutli line response\n                                try {\n                                    ENDMULTILINE = new RE(multiLineRC);\n                                } catch (RESyntaxException ex) {\n                                    throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                                }\n\n                                // read until we hit the last line of the\n                                // multi-line\n                                // response\n                                do {\n                                    response = lineRdr.readLine();\n                                } while (response != null && !ENDMULTILINE.match(response));\n                                if (response == null)\n                                    continue;\n                            }\n\n                            // Verify that return code is in proper range.\n                            //\n                            if (log.isDebugEnabled())\n                                log.debug(\"FtpMonitor.poll: tokenizing respone to check for return code: \" + response);\n                            t = new StringTokenizer(response);\n                            rc = Integer.parseInt(t.nextToken());\n                            if (rc >= 200 && rc <= 299) {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"FtpMonitor.poll: Login successful, parsed return code: \" + rc);\n                                bLoginOk = true;\n                            } else {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"FtpMonitor.poll: Login failed, parsed return code: \" + rc);\n                                bLoginOk = false;\n                            }\n                        }\n                    }\n\n                    if (bLoginOk) {\n                        // FTP should recognize the QUIT command\n                        //\n                        String cmd = \"QUIT\\r\\n\";\n                        socket.getOutputStream().write(cmd.getBytes());\n\n                        // get the returned string, tokenize, and\n                        // verify the correct output.\n                        //\n                        String response = lineRdr.readLine();\n                        if (response == null)\n                            continue;\n                        if (MULTILINE.match(response)) {\n                            // Ok we have a multi-line response...first three\n                            // chars of the response line are the return code.\n                            // The last line of the response will start with\n                            // return code followed by a space.\n                            String multiLineRC = new String(response.getBytes(), 0, 3) + \" \";\n\n                            // Create new regExp to look for last line\n                            // of this mutli line response\n                            try {\n                                ENDMULTILINE = new RE(multiLineRC);\n                            } catch (RESyntaxException ex) {\n                                throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                            }\n\n                            // read until we hit the last line of the multi-line\n                            // response\n                            do {\n                                response = lineRdr.readLine();\n                            } while (response != null && !ENDMULTILINE.match(response));\n\n                            if (response == null)\n                                continue;\n                        }\n\n                        t = new StringTokenizer(response);\n                        rc = Integer.parseInt(t.nextToken());\n\n                        // Verify that return code is in proper range.\n                        //\n\n                        if (rc >= 200 && rc <= 299) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                        // Special Case: Also want to accept the following ERROR\n                        // message\n                        // generated by some FTP servers following a QUIT\n                        // command without\n                        // a previously successful login:\n                        //\n                        // \"530 QUIT : User not logged in. Please login with\n                        // USER and PASS\n                        // first.\"\n                        //\n                        else if (rc == 530 && ( response.indexOf(FTP_ERROR_530_TEXT) != -1 ) ||( response.indexOf(FTP_ERROR_530_TEXT2) != -1 ) ) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                        // Special Case: Also want to accept the following ERROR\n                        // message\n                        // generated by some FTP servers following a QUIT\n                        // command without\n                        // a previously successful login:\n                        //\n                        // \"425 Session is disconnected.\"\n                        //\n                        else if (rc == 425 && response.indexOf(FTP_ERROR_425_TEXT) != -1) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                    }\n                }\n\n                // If we get this far and the status has not been set\n                // to available, then something didn't verify during\n                // the banner checking or login/QUIT command process.\n                if (!serviceStatus.isAvailable()) {\n                    serviceStatus = PollStatus.unavailable();\n                }\n            } catch (NumberFormatException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"NumberFormatException while polling address: \" + ipv4Addr, e);\n            \t\n            } catch (NoRouteToHostException e) {\n            \t\n            \tserviceStatus = logDown(Level.WARN, \"No route to host exception for address: \" + ipv4Addr, e);\n\n            } catch (InterruptedIOException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"did not connect to host with \" + tracker);\n\n            } catch (ConnectException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"Connection exception for address: \" + ipv4Addr, e);\n            \t\n            } catch (IOException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"IOException while polling address: \" + ipv4Addr, e);\n            \t\n            } finally {\n                try {\n                    // Close the socket\n                    if (socket != null)\n                        socket.close();\n                } catch (IOException e) {\n                    e.fillInStackTrace();\n                    log.debug(\"FtpMonitor.poll: Error closing socket.\", e);\n                }\n            }\n        }\n\n        //\n        // return the status of the service\n        //\n        return serviceStatus;\n    }","id":49261,"modified_method":"/**\n     * Poll the specified address for FTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port (by\n     * default TCP port 21). If the connection request is successful, the banner\n     * line generated by the interface is parsed and if the extracted return\n     * code indicates that we are talking to an FTP server we continue. Next, an\n     * FTP 'QUIT' command is sent. Provided that the interface's response is\n     * valid we set the service status to SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // check the interface type\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        // Get the category logger\n        //\n        Category log = ThreadCategory.getInstance(getClass());\n\n        // get the parameters\n        //\n        \n        TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n\n        int port = ParameterMap.getKeyedInteger(parameters, \"port\", DEFAULT_PORT);\n        String userid = ParameterMap.getKeyedString(parameters, \"userid\", null);\n        String password = ParameterMap.getKeyedString(parameters, \"password\", null);\n\n        // Extract the address\n        //\n        InetAddress ipv4Addr = (InetAddress) iface.getAddress();\n\n        if (log.isDebugEnabled())\n            log.debug(\"FtpMonitor.poll: Polling interface: \" + ipv4Addr.getHostAddress() + tracker);\n\n        PollStatus serviceStatus = PollStatus.unavailable();\n        for (tracker.reset(); tracker.shouldRetry() && !serviceStatus.isAvailable(); tracker.nextAttempt()) {\n            Socket socket = null;\n            try {\n                //\n                // create a connected socket\n                //\n                tracker.startAttempt();\n\n                socket = new Socket();\n                socket.connect(new InetSocketAddress(ipv4Addr, port), tracker.getConnectionTimeout());\n                socket.setSoTimeout(tracker.getSoTimeout());\n\n                log.debug(\"FtpMonitor: connected to host: \" + ipv4Addr + \" on port: \" + port);\n                // We're connected, so upgrade status to unresponsive\n                serviceStatus = PollStatus.unresponsive();\n\n                BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n                // Tokenize the Banner Line, and check the first\n                // line for a valid return.\n                //\n                String banner = lineRdr.readLine();\n                double responseTime = tracker.elapsedTimeInMillis();\n\n                if (banner == null)\n                    continue;\n                if (MULTILINE.match(banner)) {\n                    // Ok we have a multi-line response...first three\n                    // chars of the response line are the return code.\n                    // The last line of the response will start with\n                    // return code followed by a space.\n                    String multiLineRC = \"^\" + new String(banner.getBytes(), 0, 3) + \" \";\n\n                    /**\n                     * Used to check for the end of a multiline response. The end of a multiline\n                     * response is the same 3 digit response code followed by a space\n                     */\n                    RE endMultiLineRe;\n\n                    // Create new regExp to look for last line\n                    // of this mutli line response\n                    try {\n                        endMultiLineRe = new RE(multiLineRC);\n                    } catch (RESyntaxException ex) {\n                        throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                    }\n\n                    // read until we hit the last line of the multi-line\n                    // response\n                    do {\n                        banner = lineRdr.readLine();\n                    } while (banner != null && !endMultiLineRe.match(banner));\n                    if (banner == null)\n                        continue;\n                }\n\n                StringTokenizer t = new StringTokenizer(banner);\n\n                int rc = -1;\n                try {\n                    rc = Integer.parseInt(t.nextToken());\n                } catch (NumberFormatException nfE) {\n                    nfE.fillInStackTrace();\n                    log.warn(\"Banner page returned invalid result code\", nfE);\n                }\n\n                // Verify that return code is in proper range.\n                //\n                if (rc >= 200 && rc <= 299) {\n                    // \n                    // Attempt to login if userid and password available\n                    //\n                    boolean bLoginOk = false;\n                    if (userid == null || userid.length() == 0 || password == null || password.length() == 0) {\n                        bLoginOk = true;\n                    } else {\n                        // send the user string\n                        //\n                        String cmd = \"user \" + userid + \"\\r\\n\";\n                        socket.getOutputStream().write(cmd.getBytes());\n\n                        // get the response code.\n                        //\n                        String response = lineRdr.readLine();\n\n                        if (MULTILINE.match(response)) {\n                            // Ok we have a multi-line response...first three\n                            // chars of the response line are the return code.\n                            // The last line of the response will start with\n                            // return code followed by a space.\n                            String multiLineRC = new String(response.getBytes(), 0, 3) + \" \";\n\n                            /**\n                             * Used to check for the end of a multiline response. The end of a multiline\n                             * response is the same 3 digit response code followed by a space\n                             */\n                            RE endMultiLineRe;\n\n                            // Create new regExp to look for last line\n                            // of this mutli line response\n                            try {\n                                endMultiLineRe = new RE(multiLineRC);\n                            } catch (RESyntaxException ex) {\n                                throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                            }\n\n                            // read until we hit the last line of the multi-line\n                            // response\n                            do {\n                                response = lineRdr.readLine();\n                            } while (response != null && !endMultiLineRe.match(response));\n                        }\n\n                        if (response == null)\n                            continue;\n\n                        t = new StringTokenizer(response);\n                        rc = Integer.parseInt(t.nextToken());\n\n                        // Verify that return code is in proper range.\n                        //\n                        if (rc >= 200 && rc <= 399) {\n                            // send the password\n                            //\n                            cmd = \"pass \" + password + \"\\r\\n\";\n                            socket.getOutputStream().write(cmd.getBytes());\n\n                            // get the response...check for multi-line response\n                            //\n                            response = lineRdr.readLine();\n                            if (response == null)\n                                continue;\n\n                            if (MULTILINE.match(response)) {\n                                // Ok we have a multi-line response...first\n                                // three\n                                // chars of the response line are the return\n                                // code.\n                                // The last line of the response will start with\n                                // return code followed by a space.\n                                String multiLineRC = \"^\" + new String(response.getBytes(), 0, 3) + \" \";\n\n                                /**\n                                 * Used to check for the end of a multiline response. The end of a multiline\n                                 * response is the same 3 digit response code followed by a space\n                                 */\n                                RE endMultiLineRe;\n\n                                // Create new regExp to look for last line\n                                // of this mutli line response\n                                try {\n                                    endMultiLineRe = new RE(multiLineRC);\n                                } catch (RESyntaxException ex) {\n                                    throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                                }\n\n                                // read until we hit the last line of the\n                                // multi-line\n                                // response\n                                do {\n                                    response = lineRdr.readLine();\n                                } while (response != null && !endMultiLineRe.match(response));\n                                if (response == null)\n                                    continue;\n                            }\n\n                            // Verify that return code is in proper range.\n                            //\n                            if (log.isDebugEnabled())\n                                log.debug(\"FtpMonitor.poll: tokenizing respone to check for return code: \" + response);\n                            t = new StringTokenizer(response);\n                            rc = Integer.parseInt(t.nextToken());\n                            if (rc >= 200 && rc <= 299) {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"FtpMonitor.poll: Login successful, parsed return code: \" + rc);\n                                bLoginOk = true;\n                            } else {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"FtpMonitor.poll: Login failed, parsed return code: \" + rc);\n                                bLoginOk = false;\n                            }\n                        }\n                    }\n\n                    if (bLoginOk) {\n                        // FTP should recognize the QUIT command\n                        //\n                        String cmd = \"QUIT\\r\\n\";\n                        socket.getOutputStream().write(cmd.getBytes());\n\n                        // get the returned string, tokenize, and\n                        // verify the correct output.\n                        //\n                        String response = lineRdr.readLine();\n                        if (response == null)\n                            continue;\n                        if (MULTILINE.match(response)) {\n                            // Ok we have a multi-line response...first three\n                            // chars of the response line are the return code.\n                            // The last line of the response will start with\n                            // return code followed by a space.\n                            String multiLineRC = new String(response.getBytes(), 0, 3) + \" \";\n\n                            /**\n                             * Used to check for the end of a multiline response. The end of a multiline\n                             * response is the same 3 digit response code followed by a space\n                             */\n                            RE endMultiLineRe;\n\n                            // Create new regExp to look for last line\n                            // of this mutli line response\n                            try {\n                                endMultiLineRe = new RE(multiLineRC);\n                            } catch (RESyntaxException ex) {\n                                throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                            }\n\n                            // read until we hit the last line of the multi-line\n                            // response\n                            do {\n                                response = lineRdr.readLine();\n                            } while (response != null && !endMultiLineRe.match(response));\n\n                            if (response == null)\n                                continue;\n                        }\n\n                        t = new StringTokenizer(response);\n                        rc = Integer.parseInt(t.nextToken());\n\n                        // Verify that return code is in proper range.\n                        //\n\n                        if (rc >= 200 && rc <= 299) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                        // Special Case: Also want to accept the following ERROR\n                        // message\n                        // generated by some FTP servers following a QUIT\n                        // command without\n                        // a previously successful login:\n                        //\n                        // \"530 QUIT : User not logged in. Please login with\n                        // USER and PASS\n                        // first.\"\n                        //\n                        else if (rc == 530 && ( response.indexOf(FTP_ERROR_530_TEXT) != -1 ) ||( response.indexOf(FTP_ERROR_530_TEXT2) != -1 ) ) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                        // Special Case: Also want to accept the following ERROR\n                        // message\n                        // generated by some FTP servers following a QUIT\n                        // command without\n                        // a previously successful login:\n                        //\n                        // \"425 Session is disconnected.\"\n                        //\n                        else if (rc == 425 && response.indexOf(FTP_ERROR_425_TEXT) != -1) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                    }\n                }\n\n                // If we get this far and the status has not been set\n                // to available, then something didn't verify during\n                // the banner checking or login/QUIT command process.\n                if (!serviceStatus.isAvailable()) {\n                    serviceStatus = PollStatus.unavailable();\n                }\n            } catch (NumberFormatException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"NumberFormatException while polling address: \" + ipv4Addr, e);\n            \t\n            } catch (NoRouteToHostException e) {\n            \t\n            \tserviceStatus = logDown(Level.WARN, \"No route to host exception for address: \" + ipv4Addr, e);\n\n            } catch (InterruptedIOException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"did not connect to host with \" + tracker);\n\n            } catch (ConnectException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"Connection exception for address: \" + ipv4Addr, e);\n            \t\n            } catch (IOException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"IOException while polling address: \" + ipv4Addr, e);\n            \t\n            } finally {\n                try {\n                    // Close the socket\n                    if (socket != null)\n                        socket.close();\n                } catch (IOException e) {\n                    e.fillInStackTrace();\n                    log.debug(\"FtpMonitor.poll: Error closing socket.\", e);\n                }\n            }\n        }\n\n        //\n        // return the status of the service\n        //\n        return serviceStatus;\n    }","commit_id":"44bbc79873d4990c5050836e7ffbaf10dce09360","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param socket\n     * @param config\n     * @param log\n     * @param isAServer\n     * @return\n     * @throws IOException\n     */\n    protected boolean checkProtocol(Socket socket, ConnectionConfig config) throws IOException {\n\n        boolean isAServer = false;\n\n        Category log = ThreadCategory.getInstance(getClass());\n\n        try {\n\n            BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Read responses from the server. The initial line should just\n            // be a banner, but go ahead and check for multiline response\n            // in the form of:\n            //\n            // 221-You have transferred 0 bytes in 0 files.\n            // 221-Total traffic for this session was 102 bytes in 0 transfers.\n            // 221 Thank you for using the FTP service on nethost0.\n            //\n            String result = null;\n            do {\n                result = lineRdr.readLine();\n\n            } while (result != null && result.length() > 0 && MULTILINE_RESULT.match(result));\n\n            if (result == null || result.length() == 0) {\n                log.info(\"Received truncated response from ftp server \" + config.getInetAddress().getHostAddress());\n                return isAServer;\n            }\n\n            // Tokenize the last line result\n            //\n            StringTokenizer t = new StringTokenizer(result);\n            int rc = Integer.parseInt(t.nextToken());\n            if (rc > 99 && rc < 600) {\n                //\n                // FTP should recoginize the QUIT command\n                //\n                String cmd = \"QUIT\\r\\n\";\n                socket.getOutputStream().write(cmd.getBytes());\n\n                // Response from QUIT command may be a multi-line response.\n                // We are expecting to get a response with an integer return\n                // code in the first token. We can't ge sure that the first\n                // response will give us what we want. Consider the following\n                // reponse for example:\n                //\n                // 221-You have transferred 0 bytes in 0 files.\n                // 221-Total traffic for this session was 102 bytes in 0\n                // transfers.\n                // 221 Thank you for using the FTP service on nethost0.\n                //\n                // In this case the final line of the response contains the\n                // return\n                // code we are looking for.\n                do {\n                    result = lineRdr.readLine();\n\n                } while (result != null && result.length() > 0 && MULTILINE_RESULT.match(result));\n\n                if (result == null || result.length() == 0) {\n                    log.info(\"Received truncated response from ftp server \" + config.getInetAddress().getHostAddress());\n                    return isAServer;\n                }\n\n                t = new StringTokenizer(result);\n                rc = Integer.parseInt(t.nextToken());\n                if (rc > 99 && rc < 600)\n                    isAServer = true;\n\n            }\n\n        } catch (NumberFormatException e) {\n            log.info(\"FtpPlugin: received invalid result code from server \" + config.getInetAddress().getHostAddress(), e);\n            isAServer = false;\n\n        }\n\n        return isAServer;\n    }","id":49262,"modified_method":"/**\n     * @param socket\n     * @param config\n     * @param log\n     * @param isAServer\n     * @return\n     * @throws IOException\n     */\n    protected boolean checkProtocol(Socket socket, ConnectionConfig config) throws IOException {\n\n        boolean isAServer = false;\n\n        Category log = ThreadCategory.getInstance(getClass());\n\n        try {\n\n            BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Read responses from the server. The initial line should just\n            // be a banner, but go ahead and check for multiline response\n            // in the form of:\n            //\n            // 221-You have transferred 0 bytes in 0 files.\n            // 221-Total traffic for this session was 102 bytes in 0 transfers.\n            // 221 Thank you for using the FTP service on nethost0.\n            //\n            // Or:\n            //\n            // 221-Start of header\n            // This could be anything\n            // 221 End of header\n            //\n            String result = lineRdr.readLine();\n\n            if (MULTILINE_RESULT.match(result)) {\n\t        // Ok we have a multi-line response...first three\n                // chars of the response line are the return code.\n                // The last line of the response will start with\n                // return code followed by a space.\n                String multiLineRC = \"^\" + new String(result.getBytes(), 0, 3) + \" \";\n\n                /** \n                 * Used to check for the end of a multiline response. The end of a multiline\n                 * response is the same 3 digit response code followed by a space\n                 */\n                RE endMultiLineRe;\n\n                // Create new regExp to look for last line\n                // of this mutli line response\n                try {\n                    endMultiLineRe = new RE(multiLineRC);\n                } catch (RESyntaxException ex) {\n                    throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                }\n\n                do {\n                    result = lineRdr.readLine();\n                } while (result != null && !endMultiLineRe.match(result));\n            }\n\n            if (result == null || result.length() == 0) {\n                log.info(\"Received truncated response from ftp server \" + config.getInetAddress().getHostAddress());\n                return isAServer;\n            }\n\n            // Tokenize the last line result\n            //\n            StringTokenizer t = new StringTokenizer(result);\n            int rc = Integer.parseInt(t.nextToken());\n            if (rc > 99 && rc < 600) {\n                //\n                // FTP should recoginize the QUIT command\n                //\n                String cmd = \"QUIT\\r\\n\";\n                socket.getOutputStream().write(cmd.getBytes());\n\n                // Response from QUIT command may be a multi-line response.\n                // We are expecting to get a response with an integer return\n                // code in the first token. We can't ge sure that the first\n                // response will give us what we want. Consider the following\n                // reponse for example:\n                //\n                // 221-You have transferred 0 bytes in 0 files.\n                // 221-Total traffic for this session was 102 bytes in 0\n                // transfers.\n                // 221 Thank you for using the FTP service on nethost0.\n                //\n                // In this case the final line of the response contains the\n                // return\n                // code we are looking for.\n                result = lineRdr.readLine();\n\n                if (MULTILINE_RESULT.match(result)) {\n\t            // Ok we have a multi-line response...first three\n                    // chars of the response line are the return code.\n                    // The last line of the response will start with\n                    // return code followed by a space.\n                    String multiLineRC = \"^\" + new String(result.getBytes(), 0, 3) + \" \";\n\n                    /** \n                     * Used to check for the end of a multiline response. The end of a multiline\n                     * response is the same 3 digit response code followed by a space\n                     */\n                    RE endMultiLineRe;\n    \n                    // Create new regExp to look for last line\n                    // of this mutli line response\n                    try {\n                        endMultiLineRe = new RE(multiLineRC);\n                    } catch (RESyntaxException ex) {\n                        throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                    }\n    \n                    do {\n                        result = lineRdr.readLine();\n                    } while (result != null && !endMultiLineRe.match(result));\n                }\n\n                if (result == null || result.length() == 0) {\n                    log.info(\"Received truncated response from ftp server \" + config.getInetAddress().getHostAddress());\n                    return isAServer;\n                }\n\n                t = new StringTokenizer(result);\n                rc = Integer.parseInt(t.nextToken());\n                if (rc > 99 && rc < 600)\n                    isAServer = true;\n\n            }\n\n        } catch (NumberFormatException e) {\n            log.info(\"FtpPlugin: received invalid result code from server \" + config.getInetAddress().getHostAddress(), e);\n            isAServer = false;\n\n        }\n\n        return isAServer;\n    }","commit_id":"44bbc79873d4990c5050836e7ffbaf10dce09360","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Poll the specified address for FTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port (by\n     * default TCP port 21). If the connection request is successful, the banner\n     * line generated by the interface is parsed and if the extracted return\n     * code indicates that we are talking to an FTP server we continue. Next, an\n     * FTP 'QUIT' command is sent. Provided that the interface's response is\n     * valid we set the service status to SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // check the interface type\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        // Get the category logger\n        //\n        Category log = ThreadCategory.getInstance(getClass());\n\n        // get the parameters\n        //\n        \n        TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n\n        int port = ParameterMap.getKeyedInteger(parameters, \"port\", DEFAULT_PORT);\n        String userid = ParameterMap.getKeyedString(parameters, \"userid\", null);\n        String password = ParameterMap.getKeyedString(parameters, \"password\", null);\n\n        // Extract the address\n        //\n        InetAddress ipv4Addr = (InetAddress) iface.getAddress();\n\n        if (log.isDebugEnabled())\n            log.debug(\"FtpMonitor.poll: Polling interface: \" + ipv4Addr.getHostAddress() + tracker);\n\n        PollStatus serviceStatus = PollStatus.unavailable();\n        for (tracker.reset(); tracker.shouldRetry() && !serviceStatus.isAvailable(); tracker.nextAttempt()) {\n            Socket socket = null;\n            try {\n                //\n                // create a connected socket\n                //\n                tracker.startAttempt();\n\n                socket = new Socket();\n                socket.connect(new InetSocketAddress(ipv4Addr, port), tracker.getConnectionTimeout());\n                socket.setSoTimeout(tracker.getSoTimeout());\n\n                log.debug(\"FtpMonitor: connected to host: \" + ipv4Addr + \" on port: \" + port);\n                // We're connected, so upgrade status to unresponsive\n                serviceStatus = PollStatus.unresponsive();\n\n                BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n                // Tokenize the Banner Line, and check the first\n                // line for a valid return.\n                //\n                String banner = lineRdr.readLine();\n                double responseTime = tracker.elapsedTimeInMillis();\n\n                if (banner == null)\n                    continue;\n                if (MULTILINE.match(banner)) {\n                    // Ok we have a multi-line response...first three\n                    // chars of the response line are the return code.\n                    // The last line of the response will start with\n                    // return code followed by a space.\n                    String multiLineRC = new String(banner.getBytes(), 0, 3) + \" \";\n\n                    // Create new regExp to look for last line\n                    // of this mutli line response\n                    try {\n                        ENDMULTILINE = new RE(multiLineRC);\n                    } catch (RESyntaxException ex) {\n                        throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                    }\n\n                    // read until we hit the last line of the multi-line\n                    // response\n                    do {\n                        banner = lineRdr.readLine();\n                    } while (banner != null && !ENDMULTILINE.match(banner));\n                    if (banner == null)\n                        continue;\n                }\n\n                StringTokenizer t = new StringTokenizer(banner);\n\n                int rc = -1;\n                try {\n                    rc = Integer.parseInt(t.nextToken());\n                } catch (NumberFormatException nfE) {\n                    nfE.fillInStackTrace();\n                    log.warn(\"Banner page returned invalid result code\", nfE);\n                }\n\n                // Verify that return code is in proper range.\n                //\n                if (rc >= 200 && rc <= 299) {\n                    // \n                    // Attempt to login if userid and password available\n                    //\n                    boolean bLoginOk = false;\n                    if (userid == null || userid.length() == 0 || password == null || password.length() == 0) {\n                        bLoginOk = true;\n                    } else {\n                        // send the use string\n                        //\n                        String cmd = \"user \" + userid + \"\\r\\n\";\n                        socket.getOutputStream().write(cmd.getBytes());\n\n                        // get the response code.\n                        //\n                        String response = null;\n                        do {\n                            response = lineRdr.readLine();\n                        } while (response != null && MULTILINE.match(response));\n                        if (response == null)\n                            continue;\n\n                        t = new StringTokenizer(response);\n                        rc = Integer.parseInt(t.nextToken());\n\n                        // Verify that return code is in proper range.\n                        //\n                        if (rc >= 200 && rc <= 399) {\n                            // send the password\n                            //\n                            cmd = \"pass \" + password + \"\\r\\n\";\n                            socket.getOutputStream().write(cmd.getBytes());\n\n                            // get the response...check for multi-line response\n                            //\n                            response = lineRdr.readLine();\n                            if (response == null)\n                                continue;\n\n                            if (MULTILINE.match(response)) {\n                                // Ok we have a multi-line response...first\n                                // three\n                                // chars of the response line are the return\n                                // code.\n                                // The last line of the response will start with\n                                // return code followed by a space.\n                                String multiLineRC = new String(response.getBytes(), 0, 3) + \" \";\n\n                                // Create new regExp to look for last line\n                                // of this mutli line response\n                                try {\n                                    ENDMULTILINE = new RE(multiLineRC);\n                                } catch (RESyntaxException ex) {\n                                    throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                                }\n\n                                // read until we hit the last line of the\n                                // multi-line\n                                // response\n                                do {\n                                    response = lineRdr.readLine();\n                                } while (response != null && !ENDMULTILINE.match(response));\n                                if (response == null)\n                                    continue;\n                            }\n\n                            // Verify that return code is in proper range.\n                            //\n                            if (log.isDebugEnabled())\n                                log.debug(\"FtpMonitor.poll: tokenizing respone to check for return code: \" + response);\n                            t = new StringTokenizer(response);\n                            rc = Integer.parseInt(t.nextToken());\n                            if (rc >= 200 && rc <= 299) {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"FtpMonitor.poll: Login successful, parsed return code: \" + rc);\n                                bLoginOk = true;\n                            } else {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"FtpMonitor.poll: Login failed, parsed return code: \" + rc);\n                                bLoginOk = false;\n                            }\n                        }\n                    }\n\n                    if (bLoginOk) {\n                        // FTP should recognize the QUIT command\n                        //\n                        String cmd = \"QUIT\\r\\n\";\n                        socket.getOutputStream().write(cmd.getBytes());\n\n                        // get the returned string, tokenize, and\n                        // verify the correct output.\n                        //\n                        String response = lineRdr.readLine();\n                        if (response == null)\n                            continue;\n                        if (MULTILINE.match(response)) {\n                            // Ok we have a multi-line response...first three\n                            // chars of the response line are the return code.\n                            // The last line of the response will start with\n                            // return code followed by a space.\n                            String multiLineRC = new String(response.getBytes(), 0, 3) + \" \";\n\n                            // Create new regExp to look for last line\n                            // of this mutli line response\n                            try {\n                                ENDMULTILINE = new RE(multiLineRC);\n                            } catch (RESyntaxException ex) {\n                                throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                            }\n\n                            // read until we hit the last line of the multi-line\n                            // response\n                            do {\n                                response = lineRdr.readLine();\n                            } while (response != null && !ENDMULTILINE.match(response));\n\n                            if (response == null)\n                                continue;\n                        }\n\n                        t = new StringTokenizer(response);\n                        rc = Integer.parseInt(t.nextToken());\n\n                        // Verify that return code is in proper range.\n                        //\n\n                        if (rc >= 200 && rc <= 299) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                        // Special Case: Also want to accept the following ERROR\n                        // message\n                        // generated by some FTP servers following a QUIT\n                        // command without\n                        // a previously successful login:\n                        //\n                        // \"530 QUIT : User not logged in. Please login with\n                        // USER and PASS\n                        // first.\"\n                        //\n                        else if (rc == 530 && ( response.indexOf(FTP_ERROR_530_TEXT) != -1 ) ||( response.indexOf(FTP_ERROR_530_TEXT2) != -1 ) ) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                        // Special Case: Also want to accept the following ERROR\n                        // message\n                        // generated by some FTP servers following a QUIT\n                        // command without\n                        // a previously successful login:\n                        //\n                        // \"425 Session is disconnected.\"\n                        //\n                        else if (rc == 425 && response.indexOf(FTP_ERROR_425_TEXT) != -1) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                    }\n                }\n\n                // If we get this far and the status has not been set\n                // to available, then something didn't verify during\n                // the banner checking or login/QUIT command process.\n                if (!serviceStatus.isAvailable()) {\n                    serviceStatus = PollStatus.unavailable();\n                }\n            } catch (NumberFormatException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"NumberFormatException while polling address: \" + ipv4Addr, e);\n            \t\n            } catch (NoRouteToHostException e) {\n            \t\n            \tserviceStatus = logDown(Level.WARN, \"No route to host exception for address: \" + ipv4Addr, e);\n\n            } catch (InterruptedIOException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"did not connect to host with \" + tracker);\n\n            } catch (ConnectException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"Connection exception for address: \" + ipv4Addr, e);\n            \t\n            } catch (IOException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"IOException while polling address: \" + ipv4Addr, e);\n            \t\n            } finally {\n                try {\n                    // Close the socket\n                    if (socket != null)\n                        socket.close();\n                } catch (IOException e) {\n                    e.fillInStackTrace();\n                    log.debug(\"FtpMonitor.poll: Error closing socket.\", e);\n                }\n            }\n        }\n\n        //\n        // return the status of the service\n        //\n        return serviceStatus;\n    }","id":49263,"modified_method":"/**\n     * Poll the specified address for FTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port (by\n     * default TCP port 21). If the connection request is successful, the banner\n     * line generated by the interface is parsed and if the extracted return\n     * code indicates that we are talking to an FTP server we continue. Next, an\n     * FTP 'QUIT' command is sent. Provided that the interface's response is\n     * valid we set the service status to SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // check the interface type\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        // Get the category logger\n        //\n        Category log = ThreadCategory.getInstance(getClass());\n\n        // get the parameters\n        //\n        \n        TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n\n        int port = ParameterMap.getKeyedInteger(parameters, \"port\", DEFAULT_PORT);\n        String userid = ParameterMap.getKeyedString(parameters, \"userid\", null);\n        String password = ParameterMap.getKeyedString(parameters, \"password\", null);\n\n        // Extract the address\n        //\n        InetAddress ipv4Addr = (InetAddress) iface.getAddress();\n\n        if (log.isDebugEnabled())\n            log.debug(\"FtpMonitor.poll: Polling interface: \" + ipv4Addr.getHostAddress() + tracker);\n\n        PollStatus serviceStatus = PollStatus.unavailable();\n        for (tracker.reset(); tracker.shouldRetry() && !serviceStatus.isAvailable(); tracker.nextAttempt()) {\n            Socket socket = null;\n            try {\n                //\n                // create a connected socket\n                //\n                tracker.startAttempt();\n\n                socket = new Socket();\n                socket.connect(new InetSocketAddress(ipv4Addr, port), tracker.getConnectionTimeout());\n                socket.setSoTimeout(tracker.getSoTimeout());\n\n                log.debug(\"FtpMonitor: connected to host: \" + ipv4Addr + \" on port: \" + port);\n                // We're connected, so upgrade status to unresponsive\n                serviceStatus = PollStatus.unresponsive();\n\n                BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n                // Tokenize the Banner Line, and check the first\n                // line for a valid return.\n                //\n                String banner = lineRdr.readLine();\n                double responseTime = tracker.elapsedTimeInMillis();\n\n                if (banner == null)\n                    continue;\n                if (MULTILINE.match(banner)) {\n                    // Ok we have a multi-line response...first three\n                    // chars of the response line are the return code.\n                    // The last line of the response will start with\n                    // return code followed by a space.\n                    String multiLineRC = \"^\" + new String(banner.getBytes(), 0, 3) + \" \";\n\n                    /**\n                     * Used to check for the end of a multiline response. The end of a multiline\n                     * response is the same 3 digit response code followed by a space\n                     */\n                    RE endMultiLineRe;\n\n                    // Create new regExp to look for last line\n                    // of this mutli line response\n                    try {\n                        endMultiLineRe = new RE(multiLineRC);\n                    } catch (RESyntaxException ex) {\n                        throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                    }\n\n                    // read until we hit the last line of the multi-line\n                    // response\n                    do {\n                        banner = lineRdr.readLine();\n                    } while (banner != null && !endMultiLineRe.match(banner));\n                    if (banner == null)\n                        continue;\n                }\n\n                StringTokenizer t = new StringTokenizer(banner);\n\n                int rc = -1;\n                try {\n                    rc = Integer.parseInt(t.nextToken());\n                } catch (NumberFormatException nfE) {\n                    nfE.fillInStackTrace();\n                    log.warn(\"Banner page returned invalid result code\", nfE);\n                }\n\n                // Verify that return code is in proper range.\n                //\n                if (rc >= 200 && rc <= 299) {\n                    // \n                    // Attempt to login if userid and password available\n                    //\n                    boolean bLoginOk = false;\n                    if (userid == null || userid.length() == 0 || password == null || password.length() == 0) {\n                        bLoginOk = true;\n                    } else {\n                        // send the user string\n                        //\n                        String cmd = \"user \" + userid + \"\\r\\n\";\n                        socket.getOutputStream().write(cmd.getBytes());\n\n                        // get the response code.\n                        //\n                        String response = lineRdr.readLine();\n\n                        if (MULTILINE.match(response)) {\n                            // Ok we have a multi-line response...first three\n                            // chars of the response line are the return code.\n                            // The last line of the response will start with\n                            // return code followed by a space.\n                            String multiLineRC = new String(response.getBytes(), 0, 3) + \" \";\n\n                            /**\n                             * Used to check for the end of a multiline response. The end of a multiline\n                             * response is the same 3 digit response code followed by a space\n                             */\n                            RE endMultiLineRe;\n\n                            // Create new regExp to look for last line\n                            // of this mutli line response\n                            try {\n                                endMultiLineRe = new RE(multiLineRC);\n                            } catch (RESyntaxException ex) {\n                                throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                            }\n\n                            // read until we hit the last line of the multi-line\n                            // response\n                            do {\n                                response = lineRdr.readLine();\n                            } while (response != null && !endMultiLineRe.match(response));\n                        }\n\n                        if (response == null)\n                            continue;\n\n                        t = new StringTokenizer(response);\n                        rc = Integer.parseInt(t.nextToken());\n\n                        // Verify that return code is in proper range.\n                        //\n                        if (rc >= 200 && rc <= 399) {\n                            // send the password\n                            //\n                            cmd = \"pass \" + password + \"\\r\\n\";\n                            socket.getOutputStream().write(cmd.getBytes());\n\n                            // get the response...check for multi-line response\n                            //\n                            response = lineRdr.readLine();\n                            if (response == null)\n                                continue;\n\n                            if (MULTILINE.match(response)) {\n                                // Ok we have a multi-line response...first\n                                // three\n                                // chars of the response line are the return\n                                // code.\n                                // The last line of the response will start with\n                                // return code followed by a space.\n                                String multiLineRC = \"^\" + new String(response.getBytes(), 0, 3) + \" \";\n\n                                /**\n                                 * Used to check for the end of a multiline response. The end of a multiline\n                                 * response is the same 3 digit response code followed by a space\n                                 */\n                                RE endMultiLineRe;\n\n                                // Create new regExp to look for last line\n                                // of this mutli line response\n                                try {\n                                    endMultiLineRe = new RE(multiLineRC);\n                                } catch (RESyntaxException ex) {\n                                    throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                                }\n\n                                // read until we hit the last line of the\n                                // multi-line\n                                // response\n                                do {\n                                    response = lineRdr.readLine();\n                                } while (response != null && !endMultiLineRe.match(response));\n                                if (response == null)\n                                    continue;\n                            }\n\n                            // Verify that return code is in proper range.\n                            //\n                            if (log.isDebugEnabled())\n                                log.debug(\"FtpMonitor.poll: tokenizing respone to check for return code: \" + response);\n                            t = new StringTokenizer(response);\n                            rc = Integer.parseInt(t.nextToken());\n                            if (rc >= 200 && rc <= 299) {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"FtpMonitor.poll: Login successful, parsed return code: \" + rc);\n                                bLoginOk = true;\n                            } else {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"FtpMonitor.poll: Login failed, parsed return code: \" + rc);\n                                bLoginOk = false;\n                            }\n                        }\n                    }\n\n                    if (bLoginOk) {\n                        // FTP should recognize the QUIT command\n                        //\n                        String cmd = \"QUIT\\r\\n\";\n                        socket.getOutputStream().write(cmd.getBytes());\n\n                        // get the returned string, tokenize, and\n                        // verify the correct output.\n                        //\n                        String response = lineRdr.readLine();\n                        if (response == null)\n                            continue;\n                        if (MULTILINE.match(response)) {\n                            // Ok we have a multi-line response...first three\n                            // chars of the response line are the return code.\n                            // The last line of the response will start with\n                            // return code followed by a space.\n                            String multiLineRC = new String(response.getBytes(), 0, 3) + \" \";\n\n                            /**\n                             * Used to check for the end of a multiline response. The end of a multiline\n                             * response is the same 3 digit response code followed by a space\n                             */\n                            RE endMultiLineRe;\n\n                            // Create new regExp to look for last line\n                            // of this mutli line response\n                            try {\n                                endMultiLineRe = new RE(multiLineRC);\n                            } catch (RESyntaxException ex) {\n                                throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                            }\n\n                            // read until we hit the last line of the multi-line\n                            // response\n                            do {\n                                response = lineRdr.readLine();\n                            } while (response != null && !endMultiLineRe.match(response));\n\n                            if (response == null)\n                                continue;\n                        }\n\n                        t = new StringTokenizer(response);\n                        rc = Integer.parseInt(t.nextToken());\n\n                        // Verify that return code is in proper range.\n                        //\n\n                        if (rc >= 200 && rc <= 299) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                        // Special Case: Also want to accept the following ERROR\n                        // message\n                        // generated by some FTP servers following a QUIT\n                        // command without\n                        // a previously successful login:\n                        //\n                        // \"530 QUIT : User not logged in. Please login with\n                        // USER and PASS\n                        // first.\"\n                        //\n                        else if (rc == 530 && ( response.indexOf(FTP_ERROR_530_TEXT) != -1 ) ||( response.indexOf(FTP_ERROR_530_TEXT2) != -1 ) ) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                        // Special Case: Also want to accept the following ERROR\n                        // message\n                        // generated by some FTP servers following a QUIT\n                        // command without\n                        // a previously successful login:\n                        //\n                        // \"425 Session is disconnected.\"\n                        //\n                        else if (rc == 425 && response.indexOf(FTP_ERROR_425_TEXT) != -1) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                    }\n                }\n\n                // If we get this far and the status has not been set\n                // to available, then something didn't verify during\n                // the banner checking or login/QUIT command process.\n                if (!serviceStatus.isAvailable()) {\n                    serviceStatus = PollStatus.unavailable();\n                }\n            } catch (NumberFormatException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"NumberFormatException while polling address: \" + ipv4Addr, e);\n            \t\n            } catch (NoRouteToHostException e) {\n            \t\n            \tserviceStatus = logDown(Level.WARN, \"No route to host exception for address: \" + ipv4Addr, e);\n\n            } catch (InterruptedIOException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"did not connect to host with \" + tracker);\n\n            } catch (ConnectException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"Connection exception for address: \" + ipv4Addr, e);\n            \t\n            } catch (IOException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"IOException while polling address: \" + ipv4Addr, e);\n            \t\n            } finally {\n                try {\n                    // Close the socket\n                    if (socket != null)\n                        socket.close();\n                } catch (IOException e) {\n                    e.fillInStackTrace();\n                    log.debug(\"FtpMonitor.poll: Error closing socket.\", e);\n                }\n            }\n        }\n\n        //\n        // return the status of the service\n        //\n        return serviceStatus;\n    }","commit_id":"78063aada8285a0616cddd2df54a5b54b9176997","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param socket\n     * @param config\n     * @param log\n     * @param isAServer\n     * @return\n     * @throws IOException\n     */\n    protected boolean checkProtocol(Socket socket, ConnectionConfig config) throws IOException {\n\n        boolean isAServer = false;\n\n        Category log = ThreadCategory.getInstance(getClass());\n\n        try {\n\n            BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Read responses from the server. The initial line should just\n            // be a banner, but go ahead and check for multiline response\n            // in the form of:\n            //\n            // 221-You have transferred 0 bytes in 0 files.\n            // 221-Total traffic for this session was 102 bytes in 0 transfers.\n            // 221 Thank you for using the FTP service on nethost0.\n            //\n            String result = null;\n            do {\n                result = lineRdr.readLine();\n\n            } while (result != null && result.length() > 0 && MULTILINE_RESULT.match(result));\n\n            if (result == null || result.length() == 0) {\n                log.info(\"Received truncated response from ftp server \" + config.getInetAddress().getHostAddress());\n                return isAServer;\n            }\n\n            // Tokenize the last line result\n            //\n            StringTokenizer t = new StringTokenizer(result);\n            int rc = Integer.parseInt(t.nextToken());\n            if (rc > 99 && rc < 600) {\n                //\n                // FTP should recoginize the QUIT command\n                //\n                String cmd = \"QUIT\\r\\n\";\n                socket.getOutputStream().write(cmd.getBytes());\n\n                // Response from QUIT command may be a multi-line response.\n                // We are expecting to get a response with an integer return\n                // code in the first token. We can't ge sure that the first\n                // response will give us what we want. Consider the following\n                // reponse for example:\n                //\n                // 221-You have transferred 0 bytes in 0 files.\n                // 221-Total traffic for this session was 102 bytes in 0\n                // transfers.\n                // 221 Thank you for using the FTP service on nethost0.\n                //\n                // In this case the final line of the response contains the\n                // return\n                // code we are looking for.\n                do {\n                    result = lineRdr.readLine();\n\n                } while (result != null && result.length() > 0 && MULTILINE_RESULT.match(result));\n\n                if (result == null || result.length() == 0) {\n                    log.info(\"Received truncated response from ftp server \" + config.getInetAddress().getHostAddress());\n                    return isAServer;\n                }\n\n                t = new StringTokenizer(result);\n                rc = Integer.parseInt(t.nextToken());\n                if (rc > 99 && rc < 600)\n                    isAServer = true;\n\n            }\n\n        } catch (NumberFormatException e) {\n            log.info(\"FtpPlugin: received invalid result code from server \" + config.getInetAddress().getHostAddress(), e);\n            isAServer = false;\n\n        }\n\n        return isAServer;\n    }","id":49264,"modified_method":"/**\n     * @param socket\n     * @param config\n     * @param log\n     * @param isAServer\n     * @return\n     * @throws IOException\n     */\n    protected boolean checkProtocol(Socket socket, ConnectionConfig config) throws IOException {\n\n        boolean isAServer = false;\n\n        Category log = ThreadCategory.getInstance(getClass());\n\n        try {\n\n            BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Read responses from the server. The initial line should just\n            // be a banner, but go ahead and check for multiline response\n            // in the form of:\n            //\n            // 221-You have transferred 0 bytes in 0 files.\n            // 221-Total traffic for this session was 102 bytes in 0 transfers.\n            // 221 Thank you for using the FTP service on nethost0.\n            //\n            // Or:\n            //\n            // 221-Start of header\n            // This could be anything\n            // 221 End of header\n            //\n            String result = lineRdr.readLine();\n\n            if (MULTILINE_RESULT.match(result)) {\n\t        // Ok we have a multi-line response...first three\n                // chars of the response line are the return code.\n                // The last line of the response will start with\n                // return code followed by a space.\n                String multiLineRC = \"^\" + new String(result.getBytes(), 0, 3) + \" \";\n\n                /** \n                 * Used to check for the end of a multiline response. The end of a multiline\n                 * response is the same 3 digit response code followed by a space\n                 */\n                RE endMultiLineRe;\n\n                // Create new regExp to look for last line\n                // of this mutli line response\n                try {\n                    endMultiLineRe = new RE(multiLineRC);\n                } catch (RESyntaxException ex) {\n                    throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                }\n\n                do {\n                    result = lineRdr.readLine();\n                } while (result != null && !endMultiLineRe.match(result));\n            }\n\n            if (result == null || result.length() == 0) {\n                log.info(\"Received truncated response from ftp server \" + config.getInetAddress().getHostAddress());\n                return isAServer;\n            }\n\n            // Tokenize the last line result\n            //\n            StringTokenizer t = new StringTokenizer(result);\n            int rc = Integer.parseInt(t.nextToken());\n            if (rc > 99 && rc < 600) {\n                //\n                // FTP should recoginize the QUIT command\n                //\n                String cmd = \"QUIT\\r\\n\";\n                socket.getOutputStream().write(cmd.getBytes());\n\n                // Response from QUIT command may be a multi-line response.\n                // We are expecting to get a response with an integer return\n                // code in the first token. We can't ge sure that the first\n                // response will give us what we want. Consider the following\n                // reponse for example:\n                //\n                // 221-You have transferred 0 bytes in 0 files.\n                // 221-Total traffic for this session was 102 bytes in 0\n                // transfers.\n                // 221 Thank you for using the FTP service on nethost0.\n                //\n                // In this case the final line of the response contains the\n                // return\n                // code we are looking for.\n                result = lineRdr.readLine();\n\n                if (MULTILINE_RESULT.match(result)) {\n\t            // Ok we have a multi-line response...first three\n                    // chars of the response line are the return code.\n                    // The last line of the response will start with\n                    // return code followed by a space.\n                    String multiLineRC = \"^\" + new String(result.getBytes(), 0, 3) + \" \";\n\n                    /** \n                     * Used to check for the end of a multiline response. The end of a multiline\n                     * response is the same 3 digit response code followed by a space\n                     */\n                    RE endMultiLineRe;\n    \n                    // Create new regExp to look for last line\n                    // of this mutli line response\n                    try {\n                        endMultiLineRe = new RE(multiLineRC);\n                    } catch (RESyntaxException ex) {\n                        throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                    }\n    \n                    do {\n                        result = lineRdr.readLine();\n                    } while (result != null && !endMultiLineRe.match(result));\n                }\n\n                if (result == null || result.length() == 0) {\n                    log.info(\"Received truncated response from ftp server \" + config.getInetAddress().getHostAddress());\n                    return isAServer;\n                }\n\n                t = new StringTokenizer(result);\n                rc = Integer.parseInt(t.nextToken());\n                if (rc > 99 && rc < 600)\n                    isAServer = true;\n\n            }\n\n        } catch (NumberFormatException e) {\n            log.info(\"FtpPlugin: received invalid result code from server \" + config.getInetAddress().getHostAddress(), e);\n            isAServer = false;\n\n        }\n\n        return isAServer;\n    }","commit_id":"78063aada8285a0616cddd2df54a5b54b9176997","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Poll the specified address for FTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port (by\n     * default TCP port 21). If the connection request is successful, the banner\n     * line generated by the interface is parsed and if the extracted return\n     * code indicates that we are talking to an FTP server we continue. Next, an\n     * FTP 'QUIT' command is sent. Provided that the interface's response is\n     * valid we set the service status to SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // check the interface type\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        // Get the category logger\n        //\n        Category log = ThreadCategory.getInstance(getClass());\n\n        // get the parameters\n        //\n        \n        TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n\n        int port = ParameterMap.getKeyedInteger(parameters, \"port\", DEFAULT_PORT);\n        String userid = ParameterMap.getKeyedString(parameters, \"userid\", null);\n        String password = ParameterMap.getKeyedString(parameters, \"password\", null);\n\n        // Extract the address\n        //\n        InetAddress ipv4Addr = (InetAddress) iface.getAddress();\n\n        if (log.isDebugEnabled())\n            log.debug(\"FtpMonitor.poll: Polling interface: \" + ipv4Addr.getHostAddress() + tracker);\n\n        PollStatus serviceStatus = PollStatus.unavailable();\n        for (tracker.reset(); tracker.shouldRetry() && !serviceStatus.isAvailable(); tracker.nextAttempt()) {\n            Socket socket = null;\n            try {\n                //\n                // create a connected socket\n                //\n                tracker.startAttempt();\n\n                socket = new Socket();\n                socket.connect(new InetSocketAddress(ipv4Addr, port), tracker.getConnectionTimeout());\n                socket.setSoTimeout(tracker.getSoTimeout());\n\n                log.debug(\"FtpMonitor: connected to host: \" + ipv4Addr + \" on port: \" + port);\n                // We're connected, so upgrade status to unresponsive\n                serviceStatus = PollStatus.unresponsive();\n\n                BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n                // Tokenize the Banner Line, and check the first\n                // line for a valid return.\n                //\n                String banner = lineRdr.readLine();\n                double responseTime = tracker.elapsedTimeInMillis();\n\n                if (banner == null)\n                    continue;\n                if (MULTILINE.match(banner)) {\n                    // Ok we have a multi-line response...first three\n                    // chars of the response line are the return code.\n                    // The last line of the response will start with\n                    // return code followed by a space.\n                    String multiLineRC = new String(banner.getBytes(), 0, 3) + \" \";\n\n                    // Create new regExp to look for last line\n                    // of this mutli line response\n                    try {\n                        ENDMULTILINE = new RE(multiLineRC);\n                    } catch (RESyntaxException ex) {\n                        throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                    }\n\n                    // read until we hit the last line of the multi-line\n                    // response\n                    do {\n                        banner = lineRdr.readLine();\n                    } while (banner != null && !ENDMULTILINE.match(banner));\n                    if (banner == null)\n                        continue;\n                }\n\n                StringTokenizer t = new StringTokenizer(banner);\n\n                int rc = -1;\n                try {\n                    rc = Integer.parseInt(t.nextToken());\n                } catch (NumberFormatException nfE) {\n                    nfE.fillInStackTrace();\n                    log.warn(\"Banner page returned invalid result code\", nfE);\n                }\n\n                // Verify that return code is in proper range.\n                //\n                if (rc >= 200 && rc <= 299) {\n                    // \n                    // Attempt to login if userid and password available\n                    //\n                    boolean bLoginOk = false;\n                    if (userid == null || userid.length() == 0 || password == null || password.length() == 0) {\n                        bLoginOk = true;\n                    } else {\n                        // send the use string\n                        //\n                        String cmd = \"user \" + userid + \"\\r\\n\";\n                        socket.getOutputStream().write(cmd.getBytes());\n\n                        // get the response code.\n                        //\n                        String response = null;\n                        do {\n                            response = lineRdr.readLine();\n                        } while (response != null && MULTILINE.match(response));\n                        if (response == null)\n                            continue;\n\n                        t = new StringTokenizer(response);\n                        rc = Integer.parseInt(t.nextToken());\n\n                        // Verify that return code is in proper range.\n                        //\n                        if (rc >= 200 && rc <= 399) {\n                            // send the password\n                            //\n                            cmd = \"pass \" + password + \"\\r\\n\";\n                            socket.getOutputStream().write(cmd.getBytes());\n\n                            // get the response...check for multi-line response\n                            //\n                            response = lineRdr.readLine();\n                            if (response == null)\n                                continue;\n\n                            if (MULTILINE.match(response)) {\n                                // Ok we have a multi-line response...first\n                                // three\n                                // chars of the response line are the return\n                                // code.\n                                // The last line of the response will start with\n                                // return code followed by a space.\n                                String multiLineRC = new String(response.getBytes(), 0, 3) + \" \";\n\n                                // Create new regExp to look for last line\n                                // of this mutli line response\n                                try {\n                                    ENDMULTILINE = new RE(multiLineRC);\n                                } catch (RESyntaxException ex) {\n                                    throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                                }\n\n                                // read until we hit the last line of the\n                                // multi-line\n                                // response\n                                do {\n                                    response = lineRdr.readLine();\n                                } while (response != null && !ENDMULTILINE.match(response));\n                                if (response == null)\n                                    continue;\n                            }\n\n                            // Verify that return code is in proper range.\n                            //\n                            if (log.isDebugEnabled())\n                                log.debug(\"FtpMonitor.poll: tokenizing respone to check for return code: \" + response);\n                            t = new StringTokenizer(response);\n                            rc = Integer.parseInt(t.nextToken());\n                            if (rc >= 200 && rc <= 299) {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"FtpMonitor.poll: Login successful, parsed return code: \" + rc);\n                                bLoginOk = true;\n                            } else {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"FtpMonitor.poll: Login failed, parsed return code: \" + rc);\n                                bLoginOk = false;\n                            }\n                        }\n                    }\n\n                    if (bLoginOk) {\n                        // FTP should recognize the QUIT command\n                        //\n                        String cmd = \"QUIT\\r\\n\";\n                        socket.getOutputStream().write(cmd.getBytes());\n\n                        // get the returned string, tokenize, and\n                        // verify the correct output.\n                        //\n                        String response = lineRdr.readLine();\n                        if (response == null)\n                            continue;\n                        if (MULTILINE.match(response)) {\n                            // Ok we have a multi-line response...first three\n                            // chars of the response line are the return code.\n                            // The last line of the response will start with\n                            // return code followed by a space.\n                            String multiLineRC = new String(response.getBytes(), 0, 3) + \" \";\n\n                            // Create new regExp to look for last line\n                            // of this mutli line response\n                            try {\n                                ENDMULTILINE = new RE(multiLineRC);\n                            } catch (RESyntaxException ex) {\n                                throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                            }\n\n                            // read until we hit the last line of the multi-line\n                            // response\n                            do {\n                                response = lineRdr.readLine();\n                            } while (response != null && !ENDMULTILINE.match(response));\n\n                            if (response == null)\n                                continue;\n                        }\n\n                        t = new StringTokenizer(response);\n                        rc = Integer.parseInt(t.nextToken());\n\n                        // Verify that return code is in proper range.\n                        //\n\n                        if (rc >= 200 && rc <= 299) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                        // Special Case: Also want to accept the following ERROR\n                        // message\n                        // generated by some FTP servers following a QUIT\n                        // command without\n                        // a previously successful login:\n                        //\n                        // \"530 QUIT : User not logged in. Please login with\n                        // USER and PASS\n                        // first.\"\n                        //\n                        else if (rc == 530 && ( response.indexOf(FTP_ERROR_530_TEXT) != -1 ) ||( response.indexOf(FTP_ERROR_530_TEXT2) != -1 ) ) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                        // Special Case: Also want to accept the following ERROR\n                        // message\n                        // generated by some FTP servers following a QUIT\n                        // command without\n                        // a previously successful login:\n                        //\n                        // \"425 Session is disconnected.\"\n                        //\n                        else if (rc == 425 && response.indexOf(FTP_ERROR_425_TEXT) != -1) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                    }\n                }\n\n                // If we get this far and the status has not been set\n                // to available, then something didn't verify during\n                // the banner checking or login/QUIT command process.\n                if (!serviceStatus.isAvailable()) {\n                    serviceStatus = PollStatus.unavailable();\n                }\n            } catch (NumberFormatException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"NumberFormatException while polling address: \" + ipv4Addr, e);\n            \t\n            } catch (NoRouteToHostException e) {\n            \t\n            \tserviceStatus = logDown(Level.WARN, \"No route to host exception for address: \" + ipv4Addr, e);\n\n            } catch (InterruptedIOException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"did not connect to host with \" + tracker);\n\n            } catch (ConnectException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"Connection exception for address: \" + ipv4Addr, e);\n            \t\n            } catch (IOException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"IOException while polling address: \" + ipv4Addr, e);\n            \t\n            } finally {\n                try {\n                    // Close the socket\n                    if (socket != null)\n                        socket.close();\n                } catch (IOException e) {\n                    e.fillInStackTrace();\n                    log.debug(\"FtpMonitor.poll: Error closing socket.\", e);\n                }\n            }\n        }\n\n        //\n        // return the status of the service\n        //\n        return serviceStatus;\n    }","id":49265,"modified_method":"/**\n     * Poll the specified address for FTP service availability.\n     * \n     * During the poll an attempt is made to connect on the specified port (by\n     * default TCP port 21). If the connection request is successful, the banner\n     * line generated by the interface is parsed and if the extracted return\n     * code indicates that we are talking to an FTP server we continue. Next, an\n     * FTP 'QUIT' command is sent. Provided that the interface's response is\n     * valid we set the service status to SERVICE_AVAILABLE and return.\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // check the interface type\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        // Get the category logger\n        //\n        Category log = ThreadCategory.getInstance(getClass());\n\n        // get the parameters\n        //\n        \n        TimeoutTracker tracker = new TimeoutTracker(parameters, DEFAULT_RETRY, DEFAULT_TIMEOUT);\n\n        int port = ParameterMap.getKeyedInteger(parameters, \"port\", DEFAULT_PORT);\n        String userid = ParameterMap.getKeyedString(parameters, \"userid\", null);\n        String password = ParameterMap.getKeyedString(parameters, \"password\", null);\n\n        // Extract the address\n        //\n        InetAddress ipv4Addr = (InetAddress) iface.getAddress();\n\n        if (log.isDebugEnabled())\n            log.debug(\"FtpMonitor.poll: Polling interface: \" + ipv4Addr.getHostAddress() + tracker);\n\n        PollStatus serviceStatus = PollStatus.unavailable();\n        for (tracker.reset(); tracker.shouldRetry() && !serviceStatus.isAvailable(); tracker.nextAttempt()) {\n            Socket socket = null;\n            try {\n                //\n                // create a connected socket\n                //\n                tracker.startAttempt();\n\n                socket = new Socket();\n                socket.connect(new InetSocketAddress(ipv4Addr, port), tracker.getConnectionTimeout());\n                socket.setSoTimeout(tracker.getSoTimeout());\n\n                log.debug(\"FtpMonitor: connected to host: \" + ipv4Addr + \" on port: \" + port);\n                // We're connected, so upgrade status to unresponsive\n                serviceStatus = PollStatus.unresponsive();\n\n                BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n                // Tokenize the Banner Line, and check the first\n                // line for a valid return.\n                //\n                String banner = lineRdr.readLine();\n                double responseTime = tracker.elapsedTimeInMillis();\n\n                if (banner == null)\n                    continue;\n                if (MULTILINE.match(banner)) {\n                    // Ok we have a multi-line response...first three\n                    // chars of the response line are the return code.\n                    // The last line of the response will start with\n                    // return code followed by a space.\n                    String multiLineRC = \"^\" + new String(banner.getBytes(), 0, 3) + \" \";\n\n                    /**\n                     * Used to check for the end of a multiline response. The end of a multiline\n                     * response is the same 3 digit response code followed by a space\n                     */\n                    RE endMultiLineRe;\n\n                    // Create new regExp to look for last line\n                    // of this mutli line response\n                    try {\n                        endMultiLineRe = new RE(multiLineRC);\n                    } catch (RESyntaxException ex) {\n                        throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                    }\n\n                    // read until we hit the last line of the multi-line\n                    // response\n                    do {\n                        banner = lineRdr.readLine();\n                    } while (banner != null && !endMultiLineRe.match(banner));\n                    if (banner == null)\n                        continue;\n                }\n\n                StringTokenizer t = new StringTokenizer(banner);\n\n                int rc = -1;\n                try {\n                    rc = Integer.parseInt(t.nextToken());\n                } catch (NumberFormatException nfE) {\n                    nfE.fillInStackTrace();\n                    log.warn(\"Banner page returned invalid result code\", nfE);\n                }\n\n                // Verify that return code is in proper range.\n                //\n                if (rc >= 200 && rc <= 299) {\n                    // \n                    // Attempt to login if userid and password available\n                    //\n                    boolean bLoginOk = false;\n                    if (userid == null || userid.length() == 0 || password == null || password.length() == 0) {\n                        bLoginOk = true;\n                    } else {\n                        // send the user string\n                        //\n                        String cmd = \"user \" + userid + \"\\r\\n\";\n                        socket.getOutputStream().write(cmd.getBytes());\n\n                        // get the response code.\n                        //\n                        String response = lineRdr.readLine();\n\n                        if (MULTILINE.match(response)) {\n                            // Ok we have a multi-line response...first three\n                            // chars of the response line are the return code.\n                            // The last line of the response will start with\n                            // return code followed by a space.\n                            String multiLineRC = new String(response.getBytes(), 0, 3) + \" \";\n\n                            /**\n                             * Used to check for the end of a multiline response. The end of a multiline\n                             * response is the same 3 digit response code followed by a space\n                             */\n                            RE endMultiLineRe;\n\n                            // Create new regExp to look for last line\n                            // of this mutli line response\n                            try {\n                                endMultiLineRe = new RE(multiLineRC);\n                            } catch (RESyntaxException ex) {\n                                throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                            }\n\n                            // read until we hit the last line of the multi-line\n                            // response\n                            do {\n                                response = lineRdr.readLine();\n                            } while (response != null && !endMultiLineRe.match(response));\n                        }\n\n                        if (response == null)\n                            continue;\n\n                        t = new StringTokenizer(response);\n                        rc = Integer.parseInt(t.nextToken());\n\n                        // Verify that return code is in proper range.\n                        //\n                        if (rc >= 200 && rc <= 399) {\n                            // send the password\n                            //\n                            cmd = \"pass \" + password + \"\\r\\n\";\n                            socket.getOutputStream().write(cmd.getBytes());\n\n                            // get the response...check for multi-line response\n                            //\n                            response = lineRdr.readLine();\n                            if (response == null)\n                                continue;\n\n                            if (MULTILINE.match(response)) {\n                                // Ok we have a multi-line response...first\n                                // three\n                                // chars of the response line are the return\n                                // code.\n                                // The last line of the response will start with\n                                // return code followed by a space.\n                                String multiLineRC = \"^\" + new String(response.getBytes(), 0, 3) + \" \";\n\n                                /**\n                                 * Used to check for the end of a multiline response. The end of a multiline\n                                 * response is the same 3 digit response code followed by a space\n                                 */\n                                RE endMultiLineRe;\n\n                                // Create new regExp to look for last line\n                                // of this mutli line response\n                                try {\n                                    endMultiLineRe = new RE(multiLineRC);\n                                } catch (RESyntaxException ex) {\n                                    throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                                }\n\n                                // read until we hit the last line of the\n                                // multi-line\n                                // response\n                                do {\n                                    response = lineRdr.readLine();\n                                } while (response != null && !endMultiLineRe.match(response));\n                                if (response == null)\n                                    continue;\n                            }\n\n                            // Verify that return code is in proper range.\n                            //\n                            if (log.isDebugEnabled())\n                                log.debug(\"FtpMonitor.poll: tokenizing respone to check for return code: \" + response);\n                            t = new StringTokenizer(response);\n                            rc = Integer.parseInt(t.nextToken());\n                            if (rc >= 200 && rc <= 299) {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"FtpMonitor.poll: Login successful, parsed return code: \" + rc);\n                                bLoginOk = true;\n                            } else {\n                                if (log.isDebugEnabled())\n                                    log.debug(\"FtpMonitor.poll: Login failed, parsed return code: \" + rc);\n                                bLoginOk = false;\n                            }\n                        }\n                    }\n\n                    if (bLoginOk) {\n                        // FTP should recognize the QUIT command\n                        //\n                        String cmd = \"QUIT\\r\\n\";\n                        socket.getOutputStream().write(cmd.getBytes());\n\n                        // get the returned string, tokenize, and\n                        // verify the correct output.\n                        //\n                        String response = lineRdr.readLine();\n                        if (response == null)\n                            continue;\n                        if (MULTILINE.match(response)) {\n                            // Ok we have a multi-line response...first three\n                            // chars of the response line are the return code.\n                            // The last line of the response will start with\n                            // return code followed by a space.\n                            String multiLineRC = new String(response.getBytes(), 0, 3) + \" \";\n\n                            /**\n                             * Used to check for the end of a multiline response. The end of a multiline\n                             * response is the same 3 digit response code followed by a space\n                             */\n                            RE endMultiLineRe;\n\n                            // Create new regExp to look for last line\n                            // of this mutli line response\n                            try {\n                                endMultiLineRe = new RE(multiLineRC);\n                            } catch (RESyntaxException ex) {\n                                throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                            }\n\n                            // read until we hit the last line of the multi-line\n                            // response\n                            do {\n                                response = lineRdr.readLine();\n                            } while (response != null && !endMultiLineRe.match(response));\n\n                            if (response == null)\n                                continue;\n                        }\n\n                        t = new StringTokenizer(response);\n                        rc = Integer.parseInt(t.nextToken());\n\n                        // Verify that return code is in proper range.\n                        //\n\n                        if (rc >= 200 && rc <= 299) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                        // Special Case: Also want to accept the following ERROR\n                        // message\n                        // generated by some FTP servers following a QUIT\n                        // command without\n                        // a previously successful login:\n                        //\n                        // \"530 QUIT : User not logged in. Please login with\n                        // USER and PASS\n                        // first.\"\n                        //\n                        else if (rc == 530 && ( response.indexOf(FTP_ERROR_530_TEXT) != -1 ) ||( response.indexOf(FTP_ERROR_530_TEXT2) != -1 ) ) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                        // Special Case: Also want to accept the following ERROR\n                        // message\n                        // generated by some FTP servers following a QUIT\n                        // command without\n                        // a previously successful login:\n                        //\n                        // \"425 Session is disconnected.\"\n                        //\n                        else if (rc == 425 && response.indexOf(FTP_ERROR_425_TEXT) != -1) {\n                            serviceStatus = PollStatus.available(responseTime);\n                        }\n                    }\n                }\n\n                // If we get this far and the status has not been set\n                // to available, then something didn't verify during\n                // the banner checking or login/QUIT command process.\n                if (!serviceStatus.isAvailable()) {\n                    serviceStatus = PollStatus.unavailable();\n                }\n            } catch (NumberFormatException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"NumberFormatException while polling address: \" + ipv4Addr, e);\n            \t\n            } catch (NoRouteToHostException e) {\n            \t\n            \tserviceStatus = logDown(Level.WARN, \"No route to host exception for address: \" + ipv4Addr, e);\n\n            } catch (InterruptedIOException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"did not connect to host with \" + tracker);\n\n            } catch (ConnectException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"Connection exception for address: \" + ipv4Addr, e);\n            \t\n            } catch (IOException e) {\n            \t\n            \tserviceStatus = logDown(Level.DEBUG, \"IOException while polling address: \" + ipv4Addr, e);\n            \t\n            } finally {\n                try {\n                    // Close the socket\n                    if (socket != null)\n                        socket.close();\n                } catch (IOException e) {\n                    e.fillInStackTrace();\n                    log.debug(\"FtpMonitor.poll: Error closing socket.\", e);\n                }\n            }\n        }\n\n        //\n        // return the status of the service\n        //\n        return serviceStatus;\n    }","commit_id":"dedf8e9bde8e201ef0bda54091e3e21fe94772af","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * @param socket\n     * @param config\n     * @param log\n     * @param isAServer\n     * @return\n     * @throws IOException\n     */\n    protected boolean checkProtocol(Socket socket, ConnectionConfig config) throws IOException {\n\n        boolean isAServer = false;\n\n        Category log = ThreadCategory.getInstance(getClass());\n\n        try {\n\n            BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Read responses from the server. The initial line should just\n            // be a banner, but go ahead and check for multiline response\n            // in the form of:\n            //\n            // 221-You have transferred 0 bytes in 0 files.\n            // 221-Total traffic for this session was 102 bytes in 0 transfers.\n            // 221 Thank you for using the FTP service on nethost0.\n            //\n            String result = null;\n            do {\n                result = lineRdr.readLine();\n\n            } while (result != null && result.length() > 0 && MULTILINE_RESULT.match(result));\n\n            if (result == null || result.length() == 0) {\n                log.info(\"Received truncated response from ftp server \" + config.getInetAddress().getHostAddress());\n                return isAServer;\n            }\n\n            // Tokenize the last line result\n            //\n            StringTokenizer t = new StringTokenizer(result);\n            int rc = Integer.parseInt(t.nextToken());\n            if (rc > 99 && rc < 600) {\n                //\n                // FTP should recoginize the QUIT command\n                //\n                String cmd = \"QUIT\\r\\n\";\n                socket.getOutputStream().write(cmd.getBytes());\n\n                // Response from QUIT command may be a multi-line response.\n                // We are expecting to get a response with an integer return\n                // code in the first token. We can't ge sure that the first\n                // response will give us what we want. Consider the following\n                // reponse for example:\n                //\n                // 221-You have transferred 0 bytes in 0 files.\n                // 221-Total traffic for this session was 102 bytes in 0\n                // transfers.\n                // 221 Thank you for using the FTP service on nethost0.\n                //\n                // In this case the final line of the response contains the\n                // return\n                // code we are looking for.\n                do {\n                    result = lineRdr.readLine();\n\n                } while (result != null && result.length() > 0 && MULTILINE_RESULT.match(result));\n\n                if (result == null || result.length() == 0) {\n                    log.info(\"Received truncated response from ftp server \" + config.getInetAddress().getHostAddress());\n                    return isAServer;\n                }\n\n                t = new StringTokenizer(result);\n                rc = Integer.parseInt(t.nextToken());\n                if (rc > 99 && rc < 600)\n                    isAServer = true;\n\n            }\n\n        } catch (NumberFormatException e) {\n            log.info(\"FtpPlugin: received invalid result code from server \" + config.getInetAddress().getHostAddress(), e);\n            isAServer = false;\n\n        }\n\n        return isAServer;\n    }","id":49266,"modified_method":"/**\n     * @param socket\n     * @param config\n     * @param log\n     * @param isAServer\n     * @return\n     * @throws IOException\n     */\n    protected boolean checkProtocol(Socket socket, ConnectionConfig config) throws IOException {\n\n        boolean isAServer = false;\n\n        Category log = ThreadCategory.getInstance(getClass());\n\n        try {\n\n            BufferedReader lineRdr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            // Read responses from the server. The initial line should just\n            // be a banner, but go ahead and check for multiline response\n            // in the form of:\n            //\n            // 221-You have transferred 0 bytes in 0 files.\n            // 221-Total traffic for this session was 102 bytes in 0 transfers.\n            // 221 Thank you for using the FTP service on nethost0.\n            //\n            // Or:\n            //\n            // 221-Start of header\n            // This could be anything\n            // 221 End of header\n            //\n            String result = lineRdr.readLine();\n\n            if (MULTILINE_RESULT.match(result)) {\n\t        // Ok we have a multi-line response...first three\n                // chars of the response line are the return code.\n                // The last line of the response will start with\n                // return code followed by a space.\n                String multiLineRC = \"^\" + new String(result.getBytes(), 0, 3) + \" \";\n\n                /** \n                 * Used to check for the end of a multiline response. The end of a multiline\n                 * response is the same 3 digit response code followed by a space\n                 */\n                RE endMultiLineRe;\n\n                // Create new regExp to look for last line\n                // of this mutli line response\n                try {\n                    endMultiLineRe = new RE(multiLineRC);\n                } catch (RESyntaxException ex) {\n                    throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                }\n\n                do {\n                    result = lineRdr.readLine();\n                } while (result != null && !endMultiLineRe.match(result));\n            }\n\n            if (result == null || result.length() == 0) {\n                log.info(\"Received truncated response from ftp server \" + config.getInetAddress().getHostAddress());\n                return isAServer;\n            }\n\n            // Tokenize the last line result\n            //\n            StringTokenizer t = new StringTokenizer(result);\n            int rc = Integer.parseInt(t.nextToken());\n            if (rc > 99 && rc < 600) {\n                //\n                // FTP should recoginize the QUIT command\n                //\n                String cmd = \"QUIT\\r\\n\";\n                socket.getOutputStream().write(cmd.getBytes());\n\n                // Response from QUIT command may be a multi-line response.\n                // We are expecting to get a response with an integer return\n                // code in the first token. We can't ge sure that the first\n                // response will give us what we want. Consider the following\n                // reponse for example:\n                //\n                // 221-You have transferred 0 bytes in 0 files.\n                // 221-Total traffic for this session was 102 bytes in 0\n                // transfers.\n                // 221 Thank you for using the FTP service on nethost0.\n                //\n                // In this case the final line of the response contains the\n                // return\n                // code we are looking for.\n                result = lineRdr.readLine();\n\n                if (MULTILINE_RESULT.match(result)) {\n\t            // Ok we have a multi-line response...first three\n                    // chars of the response line are the return code.\n                    // The last line of the response will start with\n                    // return code followed by a space.\n                    String multiLineRC = \"^\" + new String(result.getBytes(), 0, 3) + \" \";\n\n                    /** \n                     * Used to check for the end of a multiline response. The end of a multiline\n                     * response is the same 3 digit response code followed by a space\n                     */\n                    RE endMultiLineRe;\n    \n                    // Create new regExp to look for last line\n                    // of this mutli line response\n                    try {\n                        endMultiLineRe = new RE(multiLineRC);\n                    } catch (RESyntaxException ex) {\n                        throw new java.lang.reflect.UndeclaredThrowableException(ex);\n                    }\n    \n                    do {\n                        result = lineRdr.readLine();\n                    } while (result != null && !endMultiLineRe.match(result));\n                }\n\n                if (result == null || result.length() == 0) {\n                    log.info(\"Received truncated response from ftp server \" + config.getInetAddress().getHostAddress());\n                    return isAServer;\n                }\n\n                t = new StringTokenizer(result);\n                rc = Integer.parseInt(t.nextToken());\n                if (rc > 99 && rc < 600)\n                    isAServer = true;\n\n            }\n\n        } catch (NumberFormatException e) {\n            log.info(\"FtpPlugin: received invalid result code from server \" + config.getInetAddress().getHostAddress(), e);\n            isAServer = false;\n\n        }\n\n        return isAServer;\n    }","commit_id":"dedf8e9bde8e201ef0bda54091e3e21fe94772af","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses an AspectService annotation.\n     * @param annotation\n     */\n    private void parseAspectService(Annotation annotation)\n    {\n        Info info = new Info(EntryTypes.AspectService);\n        m_infos.add(info);        \n\n        // Register previously parsed Init/Start/Stop/Destroy/Composition annotations\n        addCommonServiceParams(info);\n        \n        // factory attribute\n        info.addClassParam(annotation, Params.factory, null);\n\n        // factoryMethod attribute\n        info.addParam(annotation, Params.factoryMethod, null);\n        \n        // Parse service filter\n        String filter = annotation.get(Params.filter.toString());\n        if (filter != null) {\n            Verifier.verifyFilter(filter, 0);\n            info.addParam(Params.filter, filter);\n        }\n        \n        // Parse service aspect ranking\n        Integer ranking = annotation.get(Params.ranking.toString());\n        info.addParam(Params.ranking, ranking.toString());\n                \n        // Generate Aspect Implementation\n        info.addParam(Params.impl, m_className);\n        \n        // Parse Aspect properties.\n        parseParameters(annotation, Params.properties, info);\n        \n        // Parse service interface this aspect is applying to\n        Object service = annotation.get(Params.service.toString());\n        if (service == null) {\n            if (m_interfaces == null)\n            {\n                throw new IllegalStateException(\"Invalid AspectService annotation: \" +\n                    \"the service attribute has not been set and the class \" + m_className + \" does not implement any interfaces\");\n            }\n            if (m_interfaces.length != 1) \n            {\n                throw new IllegalStateException(\"Invalid AspectService annotation: \" +\n                    \"the service attribute has not been set and the class \" + m_className + \" implements more than one interface\");\n            }\n            \n            info.addParam(Params.service, m_interfaces[0]);\n        } else\n        {\n            checkClassImplements(annotation, Params.service);\n            info.addClassParam(annotation, Params.service, null);\n        }\n    }","id":49267,"modified_method":"/**\n     * Parses an AspectService annotation.\n     * @param annotation\n     */\n    private void parseAspectService(Annotation annotation)\n    {\n        Info info = new Info(EntryTypes.AspectService);\n        m_infos.add(info);        \n\n        // Register previously parsed Init/Start/Stop/Destroy/Composition annotations\n        addCommonServiceParams(info);\n        \n        // factory attribute\n        info.addClassParam(annotation, Params.factory, null);\n\n        // factoryMethod attribute\n        info.addParam(annotation, Params.factoryMethod, null);\n        \n        // Parse service filter\n        String filter = annotation.get(Params.filter.toString());\n        if (filter != null) {\n            Verifier.verifyFilter(filter, 0);\n            info.addParam(Params.filter, filter);\n        }\n        \n        // Parse service aspect ranking\n        Integer ranking = annotation.get(Params.ranking.toString());\n        info.addParam(Params.ranking, ranking.toString());\n                \n        // Generate Aspect Implementation\n        info.addParam(Params.impl, m_className);\n        \n        // Parse Aspect properties.\n        parseParameters(annotation, Params.properties, info);\n        \n        // Parse service interface this aspect is applying to\n        Object service = annotation.get(Params.service.toString());\n        if (service == null) {\n            if (m_interfaces == null)\n            {\n                throw new IllegalStateException(\"Invalid AspectService annotation: \" +\n                    \"the service attribute has not been set and the class \" + m_className + \" does not implement any interfaces\");\n            }\n            if (m_interfaces.length != 1) \n            {\n                throw new IllegalStateException(\"Invalid AspectService annotation: \" +\n                    \"the service attribute has not been set and the class \" + m_className + \" implements more than one interface\");\n            }\n            \n            info.addParam(Params.service, m_interfaces[0]);\n        } else\n        {\n            info.addClassParam(annotation, Params.service, null);\n        }\n    }","commit_id":"24f48b2e6cfdeb5882738b1797c88233742dba59","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Parses a BundleAdapterService annotation.\n     * @param annotation\n     */\n    private void parseResourceAdapterService(Annotation annotation)\n    {\n        Info info = new Info(EntryTypes.ResourceAdapterService);\n        m_infos.add(info);\n        \n        // Register previously parsed Init/Start/Stop/Destroy/Composition annotations\n        addCommonServiceParams(info);\n        \n        // Generate Adapter Implementation\n        info.addParam(Params.impl, m_className);\n      \n        // Parse resource filter\n        String filter = annotation.get(Params.filter.toString());\n        if (filter != null)\n        {\n            Verifier.verifyFilter(filter, 0);\n            info.addParam(Params.filter, filter);\n        }\n                \n        // Parse Adapter properties.\n        parseParameters(annotation, Params.properties, info);\n\n        // Parse the optional adapter service (use directly implemented interface by default).\n        Object service = annotation.get(Params.service.toString());\n        if (service == null) {\n            if (m_interfaces == null)\n            {\n                throw new IllegalStateException(\"Invalid ResourceAdapterService annotation: \" +\n                    \"the service attribute has not been set and the class \" + m_className + \n                    \" does not implement any interfaces\");\n            }\n            if (m_interfaces.length != 1) \n            {\n                throw new IllegalStateException(\"Invalid ResourceAdapterService annotation: \" +\n                    \"the service attribute has not been set and the class \" + m_className +\n                    \" implements more than one interface\");\n            }\n            \n            info.addParam(Params.service, m_interfaces[0]);\n        } else \n        {\n            checkClassImplements(annotation, Params.service);\n            info.addClassParam(annotation, Params.service, null);\n        }\n        \n        // Parse propagate attribute\n        info.addParam(annotation, Params.propagate, Boolean.FALSE);\n    }","id":49268,"modified_method":"/**\n     * Parses a BundleAdapterService annotation.\n     * @param annotation\n     */\n    private void parseResourceAdapterService(Annotation annotation)\n    {\n        Info info = new Info(EntryTypes.ResourceAdapterService);\n        m_infos.add(info);\n        \n        // Register previously parsed Init/Start/Stop/Destroy/Composition annotations\n        addCommonServiceParams(info);\n        \n        // Generate Adapter Implementation\n        info.addParam(Params.impl, m_className);\n      \n        // Parse resource filter\n        String filter = annotation.get(Params.filter.toString());\n        if (filter != null)\n        {\n            Verifier.verifyFilter(filter, 0);\n            info.addParam(Params.filter, filter);\n        }\n                \n        // Parse Adapter properties.\n        parseParameters(annotation, Params.properties, info);\n\n        // Parse the optional adapter service (use directly implemented interface by default).\n        info.addClassParam(annotation, Params.service, m_interfaces);\n        \n        // Parse propagate attribute\n        info.addParam(annotation, Params.propagate, Boolean.FALSE);\n    }","commit_id":"24f48b2e6cfdeb5882738b1797c88233742dba59","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Parses a BundleAdapterService annotation.\n     * @param annotation\n     */\n    private void parseBundleAdapterService(Annotation annotation)\n    {\n        Info info = new Info(EntryTypes.BundleAdapterService);\n        m_infos.add(info);\n        \n        // Register previously parsed Init/Start/Stop/Destroy/Composition annotations\n        addCommonServiceParams(info);\n        \n        // Generate Adapter Implementation\n        info.addParam(Params.impl, m_className);\n      \n        // Parse bundle filter\n        String filter = annotation.get(Params.filter.toString());\n        if (filter != null)\n        {\n            Verifier.verifyFilter(filter, 0);\n            info.addParam(Params.filter, filter);\n        }\n        \n        // Parse stateMask attribute\n        info.addParam(annotation, Params.stateMask, Integer.valueOf(Bundle.INSTALLED | Bundle.RESOLVED | Bundle.ACTIVE));\n        \n        // Parse Adapter properties.\n        parseParameters(annotation, Params.properties, info);\n\n        // Parse the optional adapter service (use directly implemented interface by default).\n        Object service = annotation.get(Params.service.toString());\n        if (service == null) {\n            if (m_interfaces == null)\n            {\n                throw new IllegalStateException(\"Invalid BundleAdapterService annotation: \" +\n                    \"the service attribute has not been set and the class \" + m_className + \n                    \" does not implement any interfaces\");\n            }\n            if (m_interfaces.length != 1) \n            {\n                throw new IllegalStateException(\"Invalid AdapterService annotation: \" +\n                    \"the service attribute has not been set and the class \" + m_className +\n                    \" implements more than one interface\");\n            }\n            \n            info.addParam(Params.service, m_interfaces[0]);\n        } else \n        {\n            checkClassImplements(annotation, Params.service);\n            info.addClassParam(annotation, Params.service, null);\n        }\n        \n        // Parse propagate attribute\n        info.addParam(annotation, Params.propagate, Boolean.FALSE);\n    }","id":49269,"modified_method":"/**\n     * Parses a BundleAdapterService annotation.\n     * @param annotation\n     */\n    private void parseBundleAdapterService(Annotation annotation)\n    {\n        Info info = new Info(EntryTypes.BundleAdapterService);\n        m_infos.add(info);\n        \n        // Register previously parsed Init/Start/Stop/Destroy/Composition annotations\n        addCommonServiceParams(info);\n        \n        // Generate Adapter Implementation\n        info.addParam(Params.impl, m_className);\n      \n        // Parse bundle filter\n        String filter = annotation.get(Params.filter.toString());\n        if (filter != null)\n        {\n            Verifier.verifyFilter(filter, 0);\n            info.addParam(Params.filter, filter);\n        }\n        \n        // Parse stateMask attribute\n        info.addParam(annotation, Params.stateMask, Integer.valueOf(Bundle.INSTALLED | Bundle.RESOLVED | Bundle.ACTIVE));\n        \n        // Parse Adapter properties.\n        parseParameters(annotation, Params.properties, info);\n\n        // Parse the optional adapter service (use directly implemented interface by default).\n        info.addClassParam(annotation, Params.service, m_interfaces);\n        \n        // Parse propagate attribute\n        info.addParam(annotation, Params.propagate, Boolean.FALSE);\n    }","commit_id":"24f48b2e6cfdeb5882738b1797c88233742dba59","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Parses an AspectService annotation.\n     * @param annotation\n     */\n    private void parseAdapterService(Annotation annotation) \n    {\n        Info info = new Info(EntryTypes.AdapterService);\n        m_infos.add(info);\n        \n        // Register previously parsed Init/Start/Stop/Destroy/Composition annotations\n        addCommonServiceParams(info);\n        \n        // Generate Adapter Implementation\n        info.addParam(Params.impl, m_className);\n      \n        // Parse adaptee filter\n        String adapteeFilter = annotation.get(Params.adapteeFilter.toString());\n        if (adapteeFilter != null)\n        {\n            Verifier.verifyFilter(adapteeFilter, 0);\n            info.addParam(Params.adapteeFilter, adapteeFilter);\n        }\n        \n        // Parse the mandatory adapted service interface.\n        info.addClassParam(annotation, Params.adapteeService, null);\n        \n        // Parse Adapter properties.\n        parseParameters(annotation, Params.adapterProperties, info);\n\n        // Parse the optional adapter service (use directly implemented interface by default).\n        Object adapterService = annotation.get(Params.adapterService.toString());\n        if (adapterService == null) {\n            if (m_interfaces == null)\n            {\n                throw new IllegalStateException(\"Invalid AdapterService annotation: \" +\n                    \"the adapterService attribute has not been set and the class \" + m_className + \n                    \" does not implement any interfaces\");\n            }\n            if (m_interfaces.length != 1) \n            {\n                throw new IllegalStateException(\"Invalid AdapterService annotation: \" +\n                    \"the adapterService attribute has not been set and the class \" + m_className +\n                    \" implements more than one interface\");\n            }\n            \n            info.addParam(Params.adapterService, m_interfaces[0]);\n        } else \n        {\n            checkClassImplements(annotation, Params.adapterService);\n            info.addClassParam(annotation, Params.adapterService, null);\n        }\n    }","id":49270,"modified_method":"/**\n     * Parses an AspectService annotation.\n     * @param annotation\n     */\n    private void parseAdapterService(Annotation annotation) \n    {\n        Info info = new Info(EntryTypes.AdapterService);\n        m_infos.add(info);\n        \n        // Register previously parsed Init/Start/Stop/Destroy/Composition annotations\n        addCommonServiceParams(info);\n        \n        // Generate Adapter Implementation\n        info.addParam(Params.impl, m_className);\n      \n        // Parse adaptee filter\n        String adapteeFilter = annotation.get(Params.adapteeFilter.toString());\n        if (adapteeFilter != null)\n        {\n            Verifier.verifyFilter(adapteeFilter, 0);\n            info.addParam(Params.adapteeFilter, adapteeFilter);\n        }\n        \n        // Parse the mandatory adapted service interface.\n        info.addClassParam(annotation, Params.adapteeService, null);\n        \n        // Parse Adapter properties.\n        parseParameters(annotation, Params.adapterProperties, info);\n\n        // Parse the optional adapter service (use directly implemented interface by default).\n        info.addClassParam(annotation, Params.adapterService, m_interfaces);\n    }","commit_id":"24f48b2e6cfdeb5882738b1797c88233742dba59","url":"https://github.com/apache/felix"},{"original_method":"protected String formatInfo(final List<String> messages) {\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\t\tif (messages.size() > 1) {\n\t\t\tbuffer.append(XtextUIMessages.AbstractHover_MultipleMarkers);\n\t\t\tfinal Iterator<String> e = messages.iterator();\n\t\t\twhile (e.hasNext()) {\n\t\t\t\tsplitInfo(\"- \" + e.next() + \"\\n\", buffer);\n\t\t\t}\n\t\t}\n\t\telse if (messages.size() == 1) {\n\t\t\tsplitInfo(messages.get(0), buffer);\n\t\t}\n\t\treturn buffer.toString();\n\t}","id":49271,"modified_method":"protected String formatInfo(final Collection<String> messages) {\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\t\tif (messages.size() > 1) {\n\t\t\tbuffer.append(XtextUIMessages.AbstractHover_MultipleMarkers);\n\t\t\tfinal Iterator<String> e = messages.iterator();\n\t\t\twhile (e.hasNext()) {\n\t\t\t\tsplitInfo(\"- \" + e.next() + \"\\n\", buffer);\n\t\t\t}\n\t\t}\n\t\telse if (messages.size() == 1) {\n\t\t\tsplitInfo(messages.iterator().next(), buffer);\n\t\t}\n\t\treturn buffer.toString();\n\t}","commit_id":"e312aae7c4df7d45f77d9a896957e2c0c01e609d","url":"https://github.com/eclipse/xtext"},{"original_method":"private void updateMarkerAnnotations(Multimap<Position, Annotation> positionToAnnotations, IProgressMonitor monitor) {\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn;\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<Annotation> annotationIterator = annotationModel.getAnnotationIterator();\n\t\twhile (annotationIterator.hasNext()) {\n\t\t\tif (monitor.isCanceled()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAnnotation annotation = annotationIterator.next();\n\t\t\tif (isRelevantAnnotationType(annotation.getType()) && (annotation instanceof MarkerAnnotation)) {\n\t\t\t\tPosition markerAnnotationPosition = annotationModel.getPosition(annotation);\n\t\t\t\tfinal MarkerAnnotation markerAnnotation = (MarkerAnnotation) annotation;\n\t\t\t\tCollection<Annotation> sourceAnnotations = positionToAnnotations.get(markerAnnotationPosition);\n\t\t\t\tboolean markAsDeleted = true;\n\t\t\t\tif (null != sourceAnnotations) {\n\t\t\t\t\tmarkAsDeleted = filter(sourceAnnotations, new Predicate<Annotation>() {\n\t\t\t\t\t\tpublic boolean apply(Annotation sourceAnnotation) {\n\t\t\t\t\t\t\treturn sourceAnnotation.getText().equals(markerAnnotation.getText())\n\t\t\t\t\t\t\t\t\t&& sourceAnnotation.getType().equals(markerAnnotation.getType());\n\t\t\t\t\t\t}\n\t\t\t\t\t}).isEmpty();\n\t\t\t\t}\n\t\t\t\tmarkerAnnotation.markDeleted(markAsDeleted);\n\t\t\t}\n\t\t}\n\t}","id":49272,"modified_method":"private void updateMarkerAnnotations(Multimap<Position, Annotation> positionToAnnotations, IProgressMonitor monitor) {\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn;\n\t\t}\n\t\tIterator<MarkerAnnotation> annotationIterator = Iterators.filter(annotationModel.getAnnotationIterator(), MarkerAnnotation.class);\n\t\t\n\t\t// every marker produced by fast validation can be marked as deleted.\n\t\t// If its predicate still holds, the validation annotation will covered anyway.\n\t\twhile (annotationIterator.hasNext() && !monitor.isCanceled()) {\n\t\t\tfinal MarkerAnnotation annotation = annotationIterator.next();\n\t\t\ttry {\n\t\t\t\tif(isRelevantAnnotationType(annotation.getType()))\n\t\t\t\t\tannotation.markDeleted(annotation.getMarker().isSubtypeOf(MarkerTypes.FAST_VALIDATION));\n\t\t\t} catch (CoreException e) {\n\t\t\t\t// marker type cannot be resolved - keep state of annotation\n\t\t\t}\n\t\t}\n\t}","commit_id":"e312aae7c4df7d45f77d9a896957e2c0c01e609d","url":"https://github.com/eclipse/xtext"},{"original_method":"public void convertValidatorDiagnostic(org.eclipse.emf.common.util.Diagnostic diagnostic,\n\t\t\tIDiagnosticConverter.Acceptor acceptor) {\n\t\tif (diagnostic.getSeverity() == org.eclipse.emf.common.util.Diagnostic.OK)\n\t\t\treturn;\n\t\tIssueImpl issue = new Issue.IssueImpl();\n\t\tissue.setSeverity(Severity.ERROR);\n\t\tswitch (diagnostic.getSeverity()) {\n\t\t\tcase org.eclipse.emf.common.util.Diagnostic.WARNING:\n\t\t\t\tissue.setSeverity(Severity.WARNING);\n\t\t\t\tbreak;\n\t\t\tcase org.eclipse.emf.common.util.Diagnostic.INFO:\n\t\t\t\tissue.setSeverity(Severity.INFO);\n\t\t\t\tbreak;\n\t\t}\n\t\tTriple<Integer, Integer, Integer> locationData = getLocationData(diagnostic);\n\t\tif (locationData != null) {\n\t\t\tissue.setLineNumber(locationData.getFirst());\n\t\t\tissue.setOffset(locationData.getSecond());\n\t\t\tissue.setLength(locationData.getThird() - issue.getOffset());\n\t\t}\n\t\tfinal EObject causer = getCauser(diagnostic);\n\t\tif (causer != null)\n\t\t\tissue.setUriToProblem(EcoreUtil.getURI(causer));\n\t\tfinal Integer code = diagnostic.getCode();\n\t\tif (code != null)\n\t\t\tissue.setCode(code);\n\t\t//\t\tmarker.put(IXtextResourceChecker.DIAGNOSTIC_KEY, diagnostic);\n\t\tissue.setMessage(diagnostic.getMessage());\n\t\t//\t\tmarker.put(IMarker.PRIORITY, Integer.valueOf(IMarker.PRIORITY_LOW));\n\t\tacceptor.accept(issue);\n\t}","id":49273,"modified_method":"public void convertValidatorDiagnostic(org.eclipse.emf.common.util.Diagnostic diagnostic,\n\t\t\tIDiagnosticConverter.Acceptor acceptor) {\n\t\tif (diagnostic.getSeverity() == org.eclipse.emf.common.util.Diagnostic.OK)\n\t\t\treturn;\n\t\tIssueImpl issue = new Issue.IssueImpl();\n\t\tissue.setSeverity(Severity.ERROR);\n\t\tswitch (diagnostic.getSeverity()) {\n\t\t\tcase org.eclipse.emf.common.util.Diagnostic.WARNING:\n\t\t\t\tissue.setSeverity(Severity.WARNING);\n\t\t\t\tbreak;\n\t\t\tcase org.eclipse.emf.common.util.Diagnostic.INFO:\n\t\t\t\tissue.setSeverity(Severity.INFO);\n\t\t\t\tbreak;\n\t\t}\n\t\tTriple<Integer, Integer, Integer> locationData = getLocationData(diagnostic);\n\t\tif (locationData != null) {\n\t\t\tissue.setLineNumber(locationData.getFirst());\n\t\t\tissue.setOffset(locationData.getSecond());\n\t\t\tissue.setLength(locationData.getThird() - issue.getOffset());\n\t\t}\n\t\tfinal EObject causer = getCauser(diagnostic);\n\t\tif (causer != null)\n\t\t\tissue.setUriToProblem(EcoreUtil.getURI(causer));\n\t\tfinal Integer code = diagnostic.getCode();\n\t\tif (code != null)\n\t\t\tissue.setCode(code);\n\t\tif (diagnostic instanceof DiagnosticImpl)\n\t\t\tissue.setType( ((DiagnosticImpl) diagnostic).getCheckType() );\n\t\t\n\t\t//\t\tmarker.put(IXtextResourceChecker.DIAGNOSTIC_KEY, diagnostic);\n\t\tissue.setMessage(diagnostic.getMessage());\n\t\t//\t\tmarker.put(IMarker.PRIORITY, Integer.valueOf(IMarker.PRIORITY_LOW));\n\t\tacceptor.accept(issue);\n\t}","commit_id":"e312aae7c4df7d45f77d9a896957e2c0c01e609d","url":"https://github.com/eclipse/xtext"},{"original_method":"public void convertResourceDiagnostic(Diagnostic diagnostic, Severity severity,\n\t\t\tIDiagnosticConverter.Acceptor acceptor) {\n\t\tIssueImpl issue = new Issue.IssueImpl();\n\t\tissue.setSyntaxError(true);\n\t\tissue.setSeverity(severity);\n\t\tissue.setLineNumber(diagnostic.getLine());\n\t\tissue.setMessage(diagnostic.getMessage());\n\t\t//\t\tissue.setmarker.put(IMarker.PRIORITY, Integer.valueOf(IMarker.PRIORITY_LOW));\n\n\t\tif (diagnostic instanceof org.eclipse.xtext.diagnostics.Diagnostic) {\n\t\t\torg.eclipse.xtext.diagnostics.Diagnostic xtextDiagnostic = (org.eclipse.xtext.diagnostics.Diagnostic) diagnostic;\n\t\t\tissue.setOffset(xtextDiagnostic.getOffset());\n\t\t\tissue.setLength(xtextDiagnostic.getLength());\n\t\t}\n\t\tif (diagnostic instanceof AbstractDiagnostic) {\n\t\t\tissue.setUriToProblem(((AbstractDiagnostic)diagnostic).getUriToProblem());\n\t\t}\n\t\tacceptor.accept(issue);\n\t}","id":49274,"modified_method":"public void convertResourceDiagnostic(Diagnostic diagnostic, Severity severity,\n\t\t\tIDiagnosticConverter.Acceptor acceptor) {\n\t\tIssueImpl issue = new Issue.IssueImpl();\n\t\tissue.setSyntaxError(true);\n\t\tissue.setSeverity(severity);\n\t\tissue.setLineNumber(diagnostic.getLine());\n\t\tissue.setMessage(diagnostic.getMessage());\n\t\t//\t\tissue.setmarker.put(IMarker.PRIORITY, Integer.valueOf(IMarker.PRIORITY_LOW));\n\n\t\tif (diagnostic instanceof org.eclipse.xtext.diagnostics.Diagnostic) {\n\t\t\torg.eclipse.xtext.diagnostics.Diagnostic xtextDiagnostic = (org.eclipse.xtext.diagnostics.Diagnostic) diagnostic;\n\t\t\tissue.setOffset(xtextDiagnostic.getOffset());\n\t\t\tissue.setLength(xtextDiagnostic.getLength());\n\t\t}\n\t\tif (diagnostic instanceof AbstractDiagnostic) {\n\t\t\tissue.setUriToProblem(((AbstractDiagnostic)diagnostic).getUriToProblem());\n\t\t}\n\t\tissue.setType(CheckType.FAST);\n\t\tacceptor.accept(issue);\n\t}","commit_id":"e312aae7c4df7d45f77d9a896957e2c0c01e609d","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected String getHoverInfoInternal(final int lineNumber,\n\t\t\tfinal int offset) {\n\t\tfinal IAnnotationModel model = sourceViewer.getAnnotationModel();\n\t\tfinal List<String> messages = new ArrayList<String>();\n\n\t\tfinal Iterator<?> iterator = model.getAnnotationIterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tfinal Annotation annotation = (Annotation) iterator.next();\n\t\t\tif (annotation instanceof MarkerAnnotation) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPosition position = model.getPosition(annotation);\n\t\t\tfinal int start = position.getOffset();\n\t\t\tfinal int end = start + position.getLength();\n\n\t\t\tif (offset > 0 && !(start <= offset && offset <= end)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (lineNumber != sourceViewer.getDocument().getLineOfOffset(\n\t\t\t\t\t\tstart)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} catch (final Exception x) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmessages.add(annotation.getText().trim());\n\t\t}\n\t\treturn formatInfo(messages);\n\t}","id":49275,"modified_method":"@Override\n\tprotected String getHoverInfoInternal(final int lineNumber,\n\t\t\tfinal int offset) {\n\t\tfinal IAnnotationModel model = sourceViewer.getAnnotationModel();\n\t\tfinal Set<String> messages = new LinkedHashSet<String>();\n\n\t\tfinal Iterator<?> iterator = model.getAnnotationIterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tfinal Annotation annotation = (Annotation) iterator.next();\n\t\t\tPosition position = model.getPosition(annotation);\n\t\t\tfinal int start = position.getOffset();\n\t\t\tfinal int end = start + position.getLength();\n\n\t\t\tif (offset > 0 && !(start <= offset && offset <= end)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (lineNumber != sourceViewer.getDocument().getLineOfOffset(\n\t\t\t\t\t\tstart)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} catch (final Exception x) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmessages.add(annotation.getText().trim());\n\t\t}\n\t\treturn formatInfo(messages);\n\t}","commit_id":"e312aae7c4df7d45f77d9a896957e2c0c01e609d","url":"https://github.com/eclipse/xtext"},{"original_method":"public AnnotationIssueProcessor(IXtextDocument xtextDocument, IAnnotationModel annotationModel) {\n\t\tsuper();\n\t\tthis.annotationModel = annotationModel;\n\t\tthis.xtextDocument = xtextDocument;\n\t}","id":49276,"modified_method":"public AnnotationIssueProcessor(IXtextDocument xtextDocument, IAnnotationModel annotationModel) {\n\t\tsuper();\n\t\tthis.annotationModel = annotationModel;\n\t\tannotationModel.addAnnotationModelListener(this);\n\t\tthis.xtextDocument = xtextDocument;\n\t}","commit_id":"5018cba2cd676fa0487eae85598e6758b5d75dec","url":"https://github.com/eclipse/xtext"},{"original_method":"private void updateMarkerAnnotations(Multimap<Position, Annotation> positionToAnnotations, IProgressMonitor monitor) {\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn;\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<Annotation> annotationIterator = annotationModel.getAnnotationIterator();\n\t\twhile (annotationIterator.hasNext()) {\n\t\t\tif (monitor.isCanceled()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAnnotation annotation = annotationIterator.next();\n\t\t\tif (isRelevantAnnotationType(annotation.getType()) && (annotation instanceof MarkerAnnotation)) {\n\t\t\t\tPosition markerAnnotationPosition = annotationModel.getPosition(annotation);\n\t\t\t\tfinal MarkerAnnotation markerAnnotation = (MarkerAnnotation) annotation;\n\t\t\t\tCollection<Annotation> sourceAnnotations = positionToAnnotations.get(markerAnnotationPosition);\n\t\t\t\tboolean markAsDeleted = true;\n\t\t\t\tif (null != sourceAnnotations) {\n\t\t\t\t\tmarkAsDeleted = filter(sourceAnnotations, new Predicate<Annotation>() {\n\t\t\t\t\t\tpublic boolean apply(Annotation sourceAnnotation) {\n\t\t\t\t\t\t\treturn sourceAnnotation.getText().equals(markerAnnotation.getText())\n\t\t\t\t\t\t\t\t\t&& sourceAnnotation.getType().equals(markerAnnotation.getType());\n\t\t\t\t\t\t}\n\t\t\t\t\t}).isEmpty();\n\t\t\t\t}\n\t\t\t\tmarkerAnnotation.markDeleted(markAsDeleted);\n\t\t\t}\n\t\t}\n\t}","id":49277,"modified_method":"private void updateMarkerAnnotations(IProgressMonitor monitor) {\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn;\n\t\t}\n\t\tIterator<MarkerAnnotation> annotationIterator = Iterators.filter(annotationModel.getAnnotationIterator(), MarkerAnnotation.class);\n\t\t\n\t\t// every markerAnnotation produced by fast validation can be marked as deleted.\n\t\t// If its predicate still holds, the validation annotation will covered anyway.\n\t\twhile (annotationIterator.hasNext() && !monitor.isCanceled()) {\n\t\t\tfinal MarkerAnnotation annotation = annotationIterator.next();\n\t\t\ttry {\n\t\t\t\tif(isRelevantAnnotationType(annotation.getType()))\n\t\t\t\t\tannotation.markDeleted(annotation.getMarker().isSubtypeOf(MarkerTypes.FAST_VALIDATION));\n\t\t\t} catch (CoreException e) {\n\t\t\t\t// marker type cannot be resolved - keep state of annotation\n\t\t\t}\n\t\t}\n\t}","commit_id":"5018cba2cd676fa0487eae85598e6758b5d75dec","url":"https://github.com/eclipse/xtext"},{"original_method":"public void processIssues(List<Issue> issues, IProgressMonitor monitor) {\n\t\tList<Annotation> toBeRemoved = getAnnotationsToRemove(monitor);\n\t\tMultimap<Position, Annotation> positionToAnnotations = Multimaps.newArrayListMultimap();\n\t\tMap<Annotation, Position> annotationToPosition = getAnnotationsToAdd(positionToAnnotations, issues, monitor);\n\t\tupdateMarkerAnnotations(positionToAnnotations, monitor);\n\t\tupdateAnnotations(monitor, toBeRemoved, annotationToPosition);\n\t}","id":49278,"modified_method":"public void processIssues(List<Issue> issues, IProgressMonitor monitor) {\n\t\tupdateMarkersOnModelChange = false;\n\t\tList<Annotation> toBeRemoved = getAnnotationsToRemove(monitor);\n\t\tMultimap<Position, Annotation> positionToAnnotations = Multimaps.newArrayListMultimap();\n\t\tMap<Annotation, Position> annotationToPosition = getAnnotationsToAdd(positionToAnnotations, issues, monitor);\n\t\tupdateMarkerAnnotations(monitor);\n\t\tupdateAnnotations(monitor, toBeRemoved, annotationToPosition);\n\t\tupdateMarkersOnModelChange = true;\n\t}","commit_id":"5018cba2cd676fa0487eae85598e6758b5d75dec","url":"https://github.com/eclipse/xtext"},{"original_method":"private Issue createIssueFromAnnotation(Annotation annotation, IAnnotationModel amodel, IXtextDocument document) {\n\t\t\tif (annotation instanceof XtextAnnotation) {\n\t\t\t\tXtextAnnotation xtextAnnotation = (XtextAnnotation) annotation;\n\t\t\t\treturn xtextAnnotation.getIssue();\n\t\t\t} else if(annotation instanceof MarkerAnnotation) {\n\t\t\t\tMarkerAnnotation markerAnnotation = (MarkerAnnotation)annotation;\n\t\t\t\tIssue.IssueImpl issue = new Issue.IssueImpl();\n\t\t\t\tissue.setMessage(annotation.getText());\n\t\t\t\tPosition pos = amodel.getPosition(annotation);\n\t\t\t\ttry {\n\t\t\t\t\tissue.setLineNumber(document.getLineOfOffset(pos.getOffset()));\n\t\t\t\t\tissue.setOffset(pos.getOffset());\n\t\t\t\t\tissue.setLength(pos.getLength());\n\t\t\t\t} catch (BadLocationException e) {\n\t\t\t\t}\n\n\t\t\t\tissue.setCode(getCode(markerAnnotation));\n\t\t\t\tissue.setUriToProblem(getUriToProblem(markerAnnotation));\n\t\t\t\tissue.setSeverity(getSeverityFromMarker(markerAnnotation.getMarker()));\n\t\t\t\t\n\t\t\t\t// Note, isSyntaxError is unset, but currently the api does not allow fixing\n\t\t\t\t// syntax errors anyway.\n\t\t\t\treturn issue;\n\t\t\t} else\n\t\t\t\treturn null;\n\t\t}","id":49279,"modified_method":"private Issue getIssueFromAnnotation(Annotation annotation, IAnnotationModel amodel, IXtextDocument document) {\n\t\t\tif (annotation instanceof XtextAnnotation) {\n\t\t\t\tXtextAnnotation xtextAnnotation = (XtextAnnotation) annotation;\n\t\t\t\treturn xtextAnnotation.getIssue();\n\t\t\t} else if(annotation instanceof MarkerAnnotation) {\n\t\t\t\tMarkerAnnotation markerAnnotation = (MarkerAnnotation)annotation;\n\t\t\t\tIssue.IssueImpl issue = new Issue.IssueImpl();\n\t\t\t\tissue.setMessage(annotation.getText());\n\t\t\t\tPosition pos = amodel.getPosition(annotation);\n\t\t\t\ttry {\n\t\t\t\t\tissue.setLineNumber(document.getLineOfOffset(pos.getOffset()));\n\t\t\t\t\tissue.setOffset(pos.getOffset());\n\t\t\t\t\tissue.setLength(pos.getLength());\n\t\t\t\t} catch (BadLocationException e) {\n\t\t\t\t}\n\n\t\t\t\tissue.setCode(getCode(markerAnnotation));\n\t\t\t\tissue.setUriToProblem(getUriToProblem(markerAnnotation));\n\t\t\t\tissue.setSeverity(getSeverityFromMarker(markerAnnotation.getMarker()));\n\t\t\t\t\n\t\t\t\t// Note, isSyntaxError is unset, but currently the api does not allow fixing\n\t\t\t\t// syntax errors anyway.\n\t\t\t\treturn issue;\n\t\t\t} else\n\t\t\t\treturn null;\n\t\t}","commit_id":"5018cba2cd676fa0487eae85598e6758b5d75dec","url":"https://github.com/eclipse/xtext"},{"original_method":"public ICompletionProposal[] computeQuickAssistProposals(IQuickAssistInvocationContext invocationContext) {\n\t\t\tfinal IDocument d = invocationContext.getSourceViewer().getDocument();\n\t\t\tif(!(d instanceof IXtextDocument))\n\t\t\t\treturn new ICompletionProposal[0];\n\t\t\tfinal IXtextDocument document = (IXtextDocument)d;\n\t\t\t\n\t\t\tfinal IAnnotationModel amodel = invocationContext.getSourceViewer().getAnnotationModel();\n\t\t\t\n\t\t\tList<ICompletionProposal> result = new ArrayList<ICompletionProposal>();\n\t\t\tfinal int offset = invocationContext.getOffset();\n\t\t\tfor (Iterator<?> it = amodel.getAnnotationIterator(); it.hasNext();) {\n\t\t\t\tObject key = it.next();\n\t\t\t\tif(!(key instanceof Annotation))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tAnnotation annotation = (Annotation) key;\n\t\t\t\tif(!canFix(annotation))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tIterable<IssueResolution> resolutions = getResolutions(annotation, amodel, document);\n\t\t\t\tif(!resolutions.iterator().hasNext())\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tPosition pos = amodel.getPosition(annotation);\n\t\t\t\ttry {\n\t\t\t\t\tint line = document.getLineOfOffset(pos.getOffset());\n\t\t\t\t\tint start = pos.getOffset();\n\t\t\t\t\tString delim = document.getLineDelimiter(line);\n\t\t\t\t\tint delimLength = delim != null ? delim.length() : 0;\n\t\t\t\t\tint end = document.getLineLength(line) + start - delimLength;\n\t\t\t\t\tif (offset >= start && offset <= end) {\n\t\t\t\t\t\tfor(IssueResolution resolution : resolutions)\n\t\t\t\t\t\t\tresult.add(new XtextCompletionProposal(pos, annotation, resolution));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (BadLocationException e) {\n\t\t\t\t\terrorMessage = e.getMessage();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result.toArray(new ICompletionProposal[result.size()]);\n\t\t}","id":49280,"modified_method":"public ICompletionProposal[] computeQuickAssistProposals(IQuickAssistInvocationContext invocationContext) {\n\t\t\tfinal IDocument d = invocationContext.getSourceViewer().getDocument();\n\t\t\tif(!(d instanceof IXtextDocument))\n\t\t\t\treturn new ICompletionProposal[0];\n\t\t\tfinal IXtextDocument document = (IXtextDocument)d;\n\t\t\t\n\t\t\tfinal IAnnotationModel amodel = invocationContext.getSourceViewer().getAnnotationModel();\n\t\t\t\n\t\t\tList<ICompletionProposal> result = new ArrayList<ICompletionProposal>();\n\t\t\tfinal int offset = invocationContext.getOffset();\n\t\t\tfor (Iterator<?> it = amodel.getAnnotationIterator(); it.hasNext();) {\n\t\t\t\tObject key = it.next();\n\t\t\t\tif(!(key instanceof Annotation))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tAnnotation annotation = (Annotation) key;\n\t\t\t\tif(!canFix(annotation))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tfinal Issue issue = getIssueFromAnnotation(annotation, amodel, document);\n\t\t\t\tif(issue == null)\n\t\t\t\t\tcontinue;\n\t\t\n\t\t\t\tIterable<IssueResolution> resolutions = getResolutions(issue, document);\n\t\t\t\tif(!resolutions.iterator().hasNext())\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tPosition pos = amodel.getPosition(annotation);\n\t\t\t\ttry {\n\t\t\t\t\tint line = document.getLineOfOffset(pos.getOffset());\n\t\t\t\t\tint start = pos.getOffset();\n\t\t\t\t\tString delim = document.getLineDelimiter(line);\n\t\t\t\t\tint delimLength = delim != null ? delim.length() : 0;\n\t\t\t\t\tint end = document.getLineLength(line) + start - delimLength;\n\t\t\t\t\tif (offset >= start && offset <= end) {\n\t\t\t\t\t\tfor(IssueResolution resolution : resolutions)\n\t\t\t\t\t\t\tresult.add(new XtextCompletionProposal(pos, resolution));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (BadLocationException e) {\n\t\t\t\t\terrorMessage = e.getMessage();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result.toArray(new ICompletionProposal[result.size()]);\n\t\t}","commit_id":"5018cba2cd676fa0487eae85598e6758b5d75dec","url":"https://github.com/eclipse/xtext"},{"original_method":"private Severity getSeverityFromMarker(IMarker marker) {\n\t\t\tswitch (marker.getAttribute(IMarker.SEVERITY, 0)) {\n\t\t\t\tcase IMarker.SEVERITY_ERROR:\n\t\t\t\t\treturn Severity.ERROR;\n\t\t\t\tcase IMarker.SEVERITY_WARNING:\n\t\t\t\t\treturn Severity.WARNING;\n\t\t\t\tdefault:\n\t\t\t\t\treturn Severity.INFO;\n\t\t\t}\n\t\t}","id":49281,"modified_method":"private Iterable<IssueResolution> getResolutions(final Issue issue, IXtextDocument document) {\n\t\t\tfinal String content = document.get();\n\t\t\t\n\t\t\tIUnitOfWork<List<IssueResolution>, XtextResource> uow = new IUnitOfWork<List<IssueResolution>, XtextResource>() {\n\n\t\t\t\tpublic List<IssueResolution> exec(XtextResource state) throws Exception {\n\t\t\t\t\tEObject model = state.getContents().isEmpty() ? null : state.getContents().get(0);\n\t\t\t\t\tEObject contextObject = (model == null) ? null : model.eResource().getEObject(issue.getUriToProblem().fragment());\n\t\t\t\t\tIssueContext context = new IssueContext.IssueContextImpl(contextObject, issue, content);\n\t\t\t\t\t\n\t\t\t\t\treturn issueResolutionProvider.getResolutions(context);\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\tIterable<IssueResolution> result = document.readOnly(uow);\n\t\t\treturn modifyResolutions(document, result);\t\t\t\n\t\t}","commit_id":"5018cba2cd676fa0487eae85598e6758b5d75dec","url":"https://github.com/eclipse/xtext"},{"original_method":"public XtextCompletionProposal(Position pos, Annotation annotation, IssueResolution resolution) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.annotation = annotation;\n\t\t\tthis.resolution = resolution;\n\t\t}","id":49282,"modified_method":"public XtextCompletionProposal(Position pos, IssueResolution resolution) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.resolution = resolution;\n\t\t}","commit_id":"5018cba2cd676fa0487eae85598e6758b5d75dec","url":"https://github.com/eclipse/xtext"},{"original_method":"protected String formatInfo(final List<String> messages) {\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\t\tif (messages.size() > 1) {\n\t\t\tbuffer.append(XtextUIMessages.AbstractHover_MultipleMarkers);\n\t\t\tfinal Iterator<String> e = messages.iterator();\n\t\t\twhile (e.hasNext()) {\n\t\t\t\tsplitInfo(\"- \" + e.next() + \"\\n\", buffer);\n\t\t\t}\n\t\t}\n\t\telse if (messages.size() == 1) {\n\t\t\tsplitInfo(messages.get(0), buffer);\n\t\t}\n\t\treturn buffer.toString();\n\t}","id":49283,"modified_method":"protected String formatInfo(final Collection<String> messages) {\n\t\tfinal StringBuffer buffer = new StringBuffer();\n\t\tif (messages.size() > 1) {\n\t\t\tbuffer.append(XtextUIMessages.AbstractHover_MultipleMarkers);\n\t\t\tfinal Iterator<String> e = messages.iterator();\n\t\t\twhile (e.hasNext()) {\n\t\t\t\tsplitInfo(\"- \" + e.next() + \"\\n\", buffer);\n\t\t\t}\n\t\t}\n\t\telse if (messages.size() == 1) {\n\t\t\tsplitInfo(messages.iterator().next(), buffer);\n\t\t}\n\t\treturn buffer.toString();\n\t}","commit_id":"8cd99d50e32c82905cbf0a6f146bae5fa52722c6","url":"https://github.com/eclipse/xtext"},{"original_method":"private void updateMarkerAnnotations(Multimap<Position, Annotation> positionToAnnotations, IProgressMonitor monitor) {\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn;\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<Annotation> annotationIterator = annotationModel.getAnnotationIterator();\n\t\twhile (annotationIterator.hasNext()) {\n\t\t\tif (monitor.isCanceled()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAnnotation annotation = annotationIterator.next();\n\t\t\tif (isRelevantAnnotationType(annotation.getType()) && (annotation instanceof MarkerAnnotation)) {\n\t\t\t\tPosition markerAnnotationPosition = annotationModel.getPosition(annotation);\n\t\t\t\tfinal MarkerAnnotation markerAnnotation = (MarkerAnnotation) annotation;\n\t\t\t\tCollection<Annotation> sourceAnnotations = positionToAnnotations.get(markerAnnotationPosition);\n\t\t\t\tboolean markAsDeleted = true;\n\t\t\t\tif (null != sourceAnnotations) {\n\t\t\t\t\tmarkAsDeleted = filter(sourceAnnotations, new Predicate<Annotation>() {\n\t\t\t\t\t\tpublic boolean apply(Annotation sourceAnnotation) {\n\t\t\t\t\t\t\treturn sourceAnnotation.getText().equals(markerAnnotation.getText())\n\t\t\t\t\t\t\t\t\t&& sourceAnnotation.getType().equals(markerAnnotation.getType());\n\t\t\t\t\t\t}\n\t\t\t\t\t}).isEmpty();\n\t\t\t\t}\n\t\t\t\tmarkerAnnotation.markDeleted(markAsDeleted);\n\t\t\t}\n\t\t}\n\t}","id":49284,"modified_method":"private void updateMarkerAnnotations(Multimap<Position, Annotation> positionToAnnotations, IProgressMonitor monitor) {\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn;\n\t\t}\n\t\tIterator<MarkerAnnotation> annotationIterator = Iterators.filter(annotationModel.getAnnotationIterator(), MarkerAnnotation.class);\n\t\t\n\t\t// every marker produced by fast validation can be marked as deleted.\n\t\t// If its predicate still holds, the validation annotation will covered anyway.\n\t\twhile (annotationIterator.hasNext() && !monitor.isCanceled()) {\n\t\t\tfinal MarkerAnnotation annotation = annotationIterator.next();\n\t\t\ttry {\n\t\t\t\tif(isRelevantAnnotationType(annotation.getType()))\n\t\t\t\t\tannotation.markDeleted(annotation.getMarker().isSubtypeOf(MarkerTypes.FAST_VALIDATION));\n\t\t\t} catch (CoreException e) {\n\t\t\t\t// marker type cannot be resolved - keep state of annotation\n\t\t\t}\n\t\t}\n\t}","commit_id":"8cd99d50e32c82905cbf0a6f146bae5fa52722c6","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected String getHoverInfoInternal(final int lineNumber,\n\t\t\tfinal int offset) {\n\t\tfinal IAnnotationModel model = sourceViewer.getAnnotationModel();\n\t\tfinal List<String> messages = new ArrayList<String>();\n\n\t\tfinal Iterator<?> iterator = model.getAnnotationIterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tfinal Annotation annotation = (Annotation) iterator.next();\n\t\t\tif (annotation instanceof MarkerAnnotation) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPosition position = model.getPosition(annotation);\n\t\t\tfinal int start = position.getOffset();\n\t\t\tfinal int end = start + position.getLength();\n\n\t\t\tif (offset > 0 && !(start <= offset && offset <= end)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (lineNumber != sourceViewer.getDocument().getLineOfOffset(\n\t\t\t\t\t\tstart)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} catch (final Exception x) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmessages.add(annotation.getText().trim());\n\t\t}\n\t\treturn formatInfo(messages);\n\t}","id":49285,"modified_method":"@Override\n\tprotected String getHoverInfoInternal(final int lineNumber,\n\t\t\tfinal int offset) {\n\t\tfinal IAnnotationModel model = sourceViewer.getAnnotationModel();\n\t\tfinal Set<String> messages = new LinkedHashSet<String>();\n\n\t\tfinal Iterator<?> iterator = model.getAnnotationIterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tfinal Annotation annotation = (Annotation) iterator.next();\n\t\t\tPosition position = model.getPosition(annotation);\n\t\t\tfinal int start = position.getOffset();\n\t\t\tfinal int end = start + position.getLength();\n\n\t\t\tif (offset > 0 && !(start <= offset && offset <= end)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (lineNumber != sourceViewer.getDocument().getLineOfOffset(\n\t\t\t\t\t\tstart)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} catch (final Exception x) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmessages.add(annotation.getText().trim());\n\t\t}\n\t\treturn formatInfo(messages);\n\t}","commit_id":"8cd99d50e32c82905cbf0a6f146bae5fa52722c6","url":"https://github.com/eclipse/xtext"},{"original_method":"public void processIssues(List<Issue> issues, IProgressMonitor monitor) {\n\t\tList<Annotation> toBeRemoved = getAnnotationsToRemove(monitor);\n\t\tMultimap<Position, Annotation> positionToAnnotations = Multimaps.newArrayListMultimap();\n\t\tMap<Annotation, Position> annotationToPosition = getAnnotationsToAdd(positionToAnnotations, issues, monitor);\n\t\tupdateMarkerAnnotations(positionToAnnotations, monitor);\n\t\tupdateAnnotations(monitor, toBeRemoved, annotationToPosition);\n\t}","id":49286,"modified_method":"public void processIssues(List<Issue> issues, IProgressMonitor monitor) {\n\t\tupdateMarkersOnModelChange = false;\n\t\tList<Annotation> toBeRemoved = getAnnotationsToRemove(monitor);\n\t\tMultimap<Position, Annotation> positionToAnnotations = Multimaps.newArrayListMultimap();\n\t\tMap<Annotation, Position> annotationToPosition = getAnnotationsToAdd(positionToAnnotations, issues, monitor);\n\t\tupdateMarkerAnnotations(monitor);\n\t\tupdateAnnotations(monitor, toBeRemoved, annotationToPosition);\n\t\tupdateMarkersOnModelChange = true;\n\t}","commit_id":"5444cf3fd1f0d356805398e30ad8bf689810e2e5","url":"https://github.com/eclipse/xtext"},{"original_method":"private void updateMarkerAnnotations(Multimap<Position, Annotation> positionToAnnotations, IProgressMonitor monitor) {\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn;\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<Annotation> annotationIterator = annotationModel.getAnnotationIterator();\n\t\twhile (annotationIterator.hasNext()) {\n\t\t\tif (monitor.isCanceled()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAnnotation annotation = annotationIterator.next();\n\t\t\tif (isRelevantAnnotationType(annotation.getType()) && (annotation instanceof MarkerAnnotation)) {\n\t\t\t\tPosition markerAnnotationPosition = annotationModel.getPosition(annotation);\n\t\t\t\tfinal MarkerAnnotation markerAnnotation = (MarkerAnnotation) annotation;\n\t\t\t\tCollection<Annotation> sourceAnnotations = positionToAnnotations.get(markerAnnotationPosition);\n\t\t\t\tboolean markAsDeleted = true;\n\t\t\t\tif (null != sourceAnnotations) {\n\t\t\t\t\tmarkAsDeleted = filter(sourceAnnotations, new Predicate<Annotation>() {\n\t\t\t\t\t\tpublic boolean apply(Annotation sourceAnnotation) {\n\t\t\t\t\t\t\treturn sourceAnnotation.getText().equals(markerAnnotation.getText())\n\t\t\t\t\t\t\t\t\t&& sourceAnnotation.getType().equals(markerAnnotation.getType());\n\t\t\t\t\t\t}\n\t\t\t\t\t}).isEmpty();\n\t\t\t\t}\n\t\t\t\tmarkerAnnotation.markDeleted(markAsDeleted);\n\t\t\t}\n\t\t}\n\t}","id":49287,"modified_method":"private void updateMarkerAnnotations(IProgressMonitor monitor) {\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn;\n\t\t}\n\t\tIterator<MarkerAnnotation> annotationIterator = Iterators.filter(annotationModel.getAnnotationIterator(), MarkerAnnotation.class);\n\t\t\n\t\t// every markerAnnotation produced by fast validation can be marked as deleted.\n\t\t// If its predicate still holds, the validation annotation will covered anyway.\n\t\twhile (annotationIterator.hasNext() && !monitor.isCanceled()) {\n\t\t\tfinal MarkerAnnotation annotation = annotationIterator.next();\n\t\t\ttry {\n\t\t\t\tif(isRelevantAnnotationType(annotation.getType()))\n\t\t\t\t\tannotation.markDeleted(annotation.getMarker().isSubtypeOf(MarkerTypes.FAST_VALIDATION));\n\t\t\t} catch (CoreException e) {\n\t\t\t\t// marker type cannot be resolved - keep state of annotation\n\t\t\t}\n\t\t}\n\t}","commit_id":"5444cf3fd1f0d356805398e30ad8bf689810e2e5","url":"https://github.com/eclipse/xtext"},{"original_method":"public AnnotationIssueProcessor(IXtextDocument xtextDocument, IAnnotationModel annotationModel) {\n\t\tsuper();\n\t\tthis.annotationModel = annotationModel;\n\t\tthis.xtextDocument = xtextDocument;\n\t}","id":49288,"modified_method":"public AnnotationIssueProcessor(IXtextDocument xtextDocument, IAnnotationModel annotationModel) {\n\t\tsuper();\n\t\tthis.annotationModel = annotationModel;\n\t\tannotationModel.addAnnotationModelListener(this);\n\t\tthis.xtextDocument = xtextDocument;\n\t}","commit_id":"5444cf3fd1f0d356805398e30ad8bf689810e2e5","url":"https://github.com/eclipse/xtext"},{"original_method":"private Issue createIssueFromAnnotation(Annotation annotation, IAnnotationModel amodel, IXtextDocument document) {\n\t\t\tif (annotation instanceof XtextAnnotation) {\n\t\t\t\tXtextAnnotation xtextAnnotation = (XtextAnnotation) annotation;\n\t\t\t\treturn xtextAnnotation.getIssue();\n\t\t\t} else if(annotation instanceof MarkerAnnotation) {\n\t\t\t\tMarkerAnnotation markerAnnotation = (MarkerAnnotation)annotation;\n\t\t\t\tIssue.IssueImpl issue = new Issue.IssueImpl();\n\t\t\t\tissue.setMessage(annotation.getText());\n\t\t\t\tPosition pos = amodel.getPosition(annotation);\n\t\t\t\ttry {\n\t\t\t\t\tissue.setLineNumber(document.getLineOfOffset(pos.getOffset()));\n\t\t\t\t\tissue.setOffset(pos.getOffset());\n\t\t\t\t\tissue.setLength(pos.getLength());\n\t\t\t\t} catch (BadLocationException e) {\n\t\t\t\t}\n\n\t\t\t\tissue.setCode(getCode(markerAnnotation));\n\t\t\t\tissue.setUriToProblem(getUriToProblem(markerAnnotation));\n\t\t\t\tissue.setSeverity(getSeverityFromMarker(markerAnnotation.getMarker()));\n\t\t\t\t\n\t\t\t\t// Note, isSyntaxError is unset, but currently the api does not allow fixing\n\t\t\t\t// syntax errors anyway.\n\t\t\t\treturn issue;\n\t\t\t} else\n\t\t\t\treturn null;\n\t\t}","id":49289,"modified_method":"private Issue getIssueFromAnnotation(Annotation annotation, IAnnotationModel amodel, IXtextDocument document) {\n\t\t\tif (annotation instanceof XtextAnnotation) {\n\t\t\t\tXtextAnnotation xtextAnnotation = (XtextAnnotation) annotation;\n\t\t\t\treturn xtextAnnotation.getIssue();\n\t\t\t} else if(annotation instanceof MarkerAnnotation) {\n\t\t\t\tMarkerAnnotation markerAnnotation = (MarkerAnnotation)annotation;\n\t\t\t\tIssue.IssueImpl issue = new Issue.IssueImpl();\n\t\t\t\tissue.setMessage(annotation.getText());\n\t\t\t\tPosition pos = amodel.getPosition(annotation);\n\t\t\t\ttry {\n\t\t\t\t\tissue.setLineNumber(document.getLineOfOffset(pos.getOffset()));\n\t\t\t\t\tissue.setOffset(pos.getOffset());\n\t\t\t\t\tissue.setLength(pos.getLength());\n\t\t\t\t} catch (BadLocationException e) {\n\t\t\t\t}\n\n\t\t\t\tissue.setCode(getCode(markerAnnotation));\n\t\t\t\tissue.setUriToProblem(getUriToProblem(markerAnnotation));\n\t\t\t\tissue.setSeverity(getSeverityFromMarker(markerAnnotation.getMarker()));\n\t\t\t\t\n\t\t\t\t// Note, isSyntaxError is unset, but currently the api does not allow fixing\n\t\t\t\t// syntax errors anyway.\n\t\t\t\treturn issue;\n\t\t\t} else\n\t\t\t\treturn null;\n\t\t}","commit_id":"5444cf3fd1f0d356805398e30ad8bf689810e2e5","url":"https://github.com/eclipse/xtext"},{"original_method":"public XtextCompletionProposal(Position pos, Annotation annotation, IssueResolution resolution) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.annotation = annotation;\n\t\t\tthis.resolution = resolution;\n\t\t}","id":49290,"modified_method":"public XtextCompletionProposal(Position pos, IssueResolution resolution) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.resolution = resolution;\n\t\t}","commit_id":"5444cf3fd1f0d356805398e30ad8bf689810e2e5","url":"https://github.com/eclipse/xtext"},{"original_method":"public ICompletionProposal[] computeQuickAssistProposals(IQuickAssistInvocationContext invocationContext) {\n\t\t\tfinal IDocument d = invocationContext.getSourceViewer().getDocument();\n\t\t\tif(!(d instanceof IXtextDocument))\n\t\t\t\treturn new ICompletionProposal[0];\n\t\t\tfinal IXtextDocument document = (IXtextDocument)d;\n\t\t\t\n\t\t\tfinal IAnnotationModel amodel = invocationContext.getSourceViewer().getAnnotationModel();\n\t\t\t\n\t\t\tList<ICompletionProposal> result = new ArrayList<ICompletionProposal>();\n\t\t\tfinal int offset = invocationContext.getOffset();\n\t\t\tfor (Iterator<?> it = amodel.getAnnotationIterator(); it.hasNext();) {\n\t\t\t\tObject key = it.next();\n\t\t\t\tif(!(key instanceof Annotation))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tAnnotation annotation = (Annotation) key;\n\t\t\t\tif(!canFix(annotation))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tIterable<IssueResolution> resolutions = getResolutions(annotation, amodel, document);\n\t\t\t\tif(!resolutions.iterator().hasNext())\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tPosition pos = amodel.getPosition(annotation);\n\t\t\t\ttry {\n\t\t\t\t\tint line = document.getLineOfOffset(pos.getOffset());\n\t\t\t\t\tint start = pos.getOffset();\n\t\t\t\t\tString delim = document.getLineDelimiter(line);\n\t\t\t\t\tint delimLength = delim != null ? delim.length() : 0;\n\t\t\t\t\tint end = document.getLineLength(line) + start - delimLength;\n\t\t\t\t\tif (offset >= start && offset <= end) {\n\t\t\t\t\t\tfor(IssueResolution resolution : resolutions)\n\t\t\t\t\t\t\tresult.add(new XtextCompletionProposal(pos, annotation, resolution));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (BadLocationException e) {\n\t\t\t\t\terrorMessage = e.getMessage();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result.toArray(new ICompletionProposal[result.size()]);\n\t\t}","id":49291,"modified_method":"public ICompletionProposal[] computeQuickAssistProposals(IQuickAssistInvocationContext invocationContext) {\n\t\t\tfinal IDocument d = invocationContext.getSourceViewer().getDocument();\n\t\t\tif(!(d instanceof IXtextDocument))\n\t\t\t\treturn new ICompletionProposal[0];\n\t\t\tfinal IXtextDocument document = (IXtextDocument)d;\n\t\t\t\n\t\t\tfinal IAnnotationModel amodel = invocationContext.getSourceViewer().getAnnotationModel();\n\t\t\t\n\t\t\tList<ICompletionProposal> result = new ArrayList<ICompletionProposal>();\n\t\t\tfinal int offset = invocationContext.getOffset();\n\t\t\tfor (Iterator<?> it = amodel.getAnnotationIterator(); it.hasNext();) {\n\t\t\t\tObject key = it.next();\n\t\t\t\tif(!(key instanceof Annotation))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tAnnotation annotation = (Annotation) key;\n\t\t\t\tif(!canFix(annotation))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tfinal Issue issue = getIssueFromAnnotation(annotation, amodel, document);\n\t\t\t\tif(issue == null)\n\t\t\t\t\tcontinue;\n\t\t\n\t\t\t\tIterable<IssueResolution> resolutions = getResolutions(issue, document);\n\t\t\t\tif(!resolutions.iterator().hasNext())\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tPosition pos = amodel.getPosition(annotation);\n\t\t\t\ttry {\n\t\t\t\t\tint line = document.getLineOfOffset(pos.getOffset());\n\t\t\t\t\tint start = pos.getOffset();\n\t\t\t\t\tString delim = document.getLineDelimiter(line);\n\t\t\t\t\tint delimLength = delim != null ? delim.length() : 0;\n\t\t\t\t\tint end = document.getLineLength(line) + start - delimLength;\n\t\t\t\t\tif (offset >= start && offset <= end) {\n\t\t\t\t\t\tfor(IssueResolution resolution : resolutions)\n\t\t\t\t\t\t\tresult.add(new XtextCompletionProposal(pos, resolution));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (BadLocationException e) {\n\t\t\t\t\terrorMessage = e.getMessage();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result.toArray(new ICompletionProposal[result.size()]);\n\t\t}","commit_id":"5444cf3fd1f0d356805398e30ad8bf689810e2e5","url":"https://github.com/eclipse/xtext"},{"original_method":"private Severity getSeverityFromMarker(IMarker marker) {\n\t\t\tswitch (marker.getAttribute(IMarker.SEVERITY, 0)) {\n\t\t\t\tcase IMarker.SEVERITY_ERROR:\n\t\t\t\t\treturn Severity.ERROR;\n\t\t\t\tcase IMarker.SEVERITY_WARNING:\n\t\t\t\t\treturn Severity.WARNING;\n\t\t\t\tdefault:\n\t\t\t\t\treturn Severity.INFO;\n\t\t\t}\n\t\t}","id":49292,"modified_method":"private Iterable<IssueResolution> getResolutions(final Issue issue, IXtextDocument document) {\n\t\t\tfinal String content = document.get();\n\t\t\t\n\t\t\tIUnitOfWork<List<IssueResolution>, XtextResource> uow = new IUnitOfWork<List<IssueResolution>, XtextResource>() {\n\n\t\t\t\tpublic List<IssueResolution> exec(XtextResource state) throws Exception {\n\t\t\t\t\tEObject model = state.getContents().isEmpty() ? null : state.getContents().get(0);\n\t\t\t\t\tEObject contextObject = (model == null) ? null : model.eResource().getEObject(issue.getUriToProblem().fragment());\n\t\t\t\t\tIssueContext context = new IssueContext.IssueContextImpl(contextObject, issue, content);\n\t\t\t\t\t\n\t\t\t\t\treturn issueResolutionProvider.getResolutions(context);\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\tIterable<IssueResolution> result = document.readOnly(uow);\n\t\t\treturn modifyResolutions(document, result);\t\t\t\n\t\t}","commit_id":"5444cf3fd1f0d356805398e30ad8bf689810e2e5","url":"https://github.com/eclipse/xtext"},{"original_method":"private void setFacets(IssueQuery query, QueryContext options, Map<String, FilterBuilder> filters, QueryBuilder esQuery, SearchRequestBuilder esSearch) {\n    if (options.isFacet()) {\n      // Execute Term aggregations\n      if (options.facets().contains(IssueFilterParameters.SEVERITIES)) {\n        esSearch.addAggregation(stickyFacetBuilder(esQuery, filters, IssueNormalizer.IssueField.SEVERITY.field(), IssueFilterParameters.SEVERITIES));\n      }\n      if (options.facets().contains(IssueFilterParameters.STATUSES)) {\n        esSearch.addAggregation(stickyFacetBuilder(esQuery, filters, IssueNormalizer.IssueField.STATUS.field(), IssueFilterParameters.STATUSES));\n      }\n      if (options.facets().contains(IssueFilterParameters.RESOLUTIONS)) {\n        esSearch.addAggregation(getResolutionFacet(query, options, filters, esQuery));\n      }\n      if (options.facets().contains(IssueFilterParameters.ACTION_PLANS)) {\n        esSearch.addAggregation(stickyFacetBuilder(esQuery, filters, IssueNormalizer.IssueField.ACTION_PLAN.field(), IssueFilterParameters.ACTION_PLANS));\n      }\n      if (options.facets().contains(IssueFilterParameters.COMPONENT_ROOTS)) {\n        esSearch.addAggregation(stickyFacetBuilder(esQuery, filters, IssueNormalizer.IssueField.PROJECT.field(), IssueFilterParameters.COMPONENT_ROOTS,\n          query.componentRoots().toArray()));\n      }\n      if (options.facets().contains(IssueFilterParameters.RULES)) {\n        esSearch.addAggregation(stickyFacetBuilder(esQuery, filters, IssueNormalizer.IssueField.RULE_KEY.field(), IssueFilterParameters.RULES,\n          query.rules().toArray()));\n      }\n      if (options.facets().contains(IssueFilterParameters.ASSIGNEES)) {\n        esSearch.addAggregation(getAssigneesFacet(query, options, filters, esQuery));\n      }\n      if (options.facets().contains(IssueFilterParameters.COMPONENTS)) {\n        esSearch.addAggregation(stickyFacetBuilder(esQuery, filters, IssueNormalizer.IssueField.COMPONENT.field(), IssueFilterParameters.COMPONENTS,\n          query.components().toArray()));\n      }\n      if (options.facets().contains(IssueFilterParameters.LANGUAGES)) {\n        esSearch.addAggregation(stickyFacetBuilder(esQuery, filters, IssueNormalizer.IssueField.LANGUAGE.field(), IssueFilterParameters.LANGUAGES,\n          query.languages().toArray()));\n      }\n    }\n  }","id":49293,"modified_method":"private void setFacets(IssueQuery query, QueryContext options, Map<String, FilterBuilder> filters, QueryBuilder esQuery, SearchRequestBuilder esSearch) {\n    if (options.isFacet()) {\n      // Execute Term aggregations\n      addSimpleStickyFacetIfNeeded(query, options, filters, esQuery, esSearch,\n        IssueFilterParameters.SEVERITIES, IssueNormalizer.IssueField.SEVERITY.field());\n      addSimpleStickyFacetIfNeeded(query, options, filters, esQuery, esSearch,\n        IssueFilterParameters.STATUSES, IssueNormalizer.IssueField.STATUS.field());\n      addSimpleStickyFacetIfNeeded(query, options, filters, esQuery, esSearch,\n        IssueFilterParameters.ACTION_PLANS, IssueNormalizer.IssueField.ACTION_PLAN.field(), query.actionPlans().toArray());\n      addSimpleStickyFacetIfNeeded(query, options, filters, esQuery, esSearch,\n        IssueFilterParameters.COMPONENT_ROOTS, IssueNormalizer.IssueField.PROJECT.field(), query.componentRoots().toArray());\n      addSimpleStickyFacetIfNeeded(query, options, filters, esQuery, esSearch,\n        IssueFilterParameters.COMPONENTS, IssueNormalizer.IssueField.COMPONENT.field(), query.components().toArray());\n      addSimpleStickyFacetIfNeeded(query, options, filters, esQuery, esSearch,\n        IssueFilterParameters.LANGUAGES, IssueNormalizer.IssueField.LANGUAGE.field(), query.languages().toArray());\n      addSimpleStickyFacetIfNeeded(query, options, filters, esQuery, esSearch,\n        IssueFilterParameters.RULES, IssueNormalizer.IssueField.RULE_KEY.field(), query.rules().toArray());\n\n      if (options.facets().contains(IssueFilterParameters.RESOLUTIONS)) {\n        esSearch.addAggregation(getResolutionFacet(query, options, filters, esQuery));\n      }\n      if (options.facets().contains(IssueFilterParameters.ASSIGNEES)) {\n        esSearch.addAggregation(getAssigneesFacet(query, options, filters, esQuery));\n      }\n    }\n  }","commit_id":"1be34454a932cef88b2527287f9a13e66702aa56","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void handle(Request request, Response response) {\n    RuleQuery query = createRuleQuery(ruleService.newRuleQuery(), request);\n    SearchOptions searchOptions = SearchOptions.create(request);\n    QueryContext queryContext = mapping.newQueryOptions(searchOptions);\n    if (Boolean.valueOf(request.paramAsBoolean(\"facets\"))) {\n      queryContext.addFacets(Arrays.asList(\"languages\", \"repositories\", \"tags\"));\n    }\n\n    Result<Rule> results = ruleService.search(query, queryContext);\n\n    JsonWriter json = response.newJsonWriter().beginObject();\n    searchOptions.writeStatistics(json, results);\n    writeRules(results, json, searchOptions);\n    if (searchOptions.hasField(\"actives\")) {\n      activeRuleCompleter.completeSearch(query, results.getHits(), json);\n    }\n    if (queryContext.isFacet()) {\n      writeFacets(results, json);\n    }\n    json.endObject().close();\n  }","id":49294,"modified_method":"@Override\n  public void handle(Request request, Response response) {\n    RuleQuery query = createRuleQuery(ruleService.newRuleQuery(), request);\n    SearchOptions searchOptions = SearchOptions.create(request);\n    QueryContext queryContext = mapping.newQueryOptions(searchOptions);\n    Boolean facets = request.paramAsBoolean(\"facets\");\n    if (facets != null && facets) {\n      queryContext.addFacets(Arrays.asList(\"languages\", \"repositories\", \"tags\"));\n    }\n\n    Result<Rule> results = ruleService.search(query, queryContext);\n\n    JsonWriter json = response.newJsonWriter().beginObject();\n    searchOptions.writeStatistics(json, results);\n    writeRules(results, json, searchOptions);\n    if (searchOptions.hasField(\"actives\")) {\n      activeRuleCompleter.completeSearch(query, results.getHits(), json);\n    }\n    if (queryContext.isFacet()) {\n      writeFacets(results, json);\n    }\n    json.endObject().close();\n  }","commit_id":"1be34454a932cef88b2527287f9a13e66702aa56","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void executeGet(Tree statement)\n            throws TException, NotFoundException, InvalidRequestException, UnavailableException, TimedOutException, IllegalAccessException, InstantiationException, ClassNotFoundException, NoSuchFieldException\n    {\n        if (!CliMain.isConnected() || !hasKeySpace())\n            return;\n\n        Tree columnFamilySpec = statement.getChild(0);\n        String columnFamily = CliCompiler.getColumnFamily(columnFamilySpec, keyspacesMap.get(keySpace).cf_defs);\n        ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));\n        int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);\n        CfDef cfDef = getCfDef(columnFamily);\n        boolean isSuper = cfDef.column_type.equals(\"Super\");\n        \n        byte[] superColumnName = null;\n        ByteBuffer columnName;\n\n        // table.cf['key'] -- row slice\n        if (columnSpecCnt == 0)\n        {\n            doSlice(keySpace, key, columnFamily, superColumnName);\n            return;\n        }\n        // table.cf['key']['column'] -- slice of a super, or get of a standard\n        else if (columnSpecCnt == 1)\n        {\n            columnName = getColumnName(columnFamily, columnFamilySpec.getChild(2));\n\n            if (isSuper)\n            {\n                superColumnName = columnName.array();\n                doSlice(keySpace, key, columnFamily, superColumnName);\n                return;\n            }\n        }\n        // table.cf['key']['column']['column'] -- get of a sub-column\n        else if (columnSpecCnt == 2)\n        {\n            superColumnName = getColumnName(columnFamily, columnFamilySpec.getChild(2)).array();\n            columnName = getSubColumnName(columnFamily, columnFamilySpec.getChild(3));\n        }\n        // The parser groks an arbitrary number of these so it is possible to get here.\n        else\n        {\n            sessionState.out.println(\"Invalid row, super column, or column specification.\");\n            return;\n        }\n\n        AbstractType validator = getValidatorForValue(cfDef, TBaseHelper.byteBufferToByteArray(columnName));\n\n        // Perform a get()\n        ColumnPath path = new ColumnPath(columnFamily);\n        if(superColumnName != null) path.setSuper_column(superColumnName);\n        path.setColumn(columnName);\n\n        if (isCounterCF(cfDef))\n        {\n            doGetCounter(key, path);\n            return;\n        }\n\n        Column column;\n        try\n        {\n            column = thriftClient.get(key, path, consistencyLevel).column;\n        }\n        catch (NotFoundException e)\n        {\n            sessionState.out.println(\"Value was not found\");\n            return;\n        }\n\n        byte[] columnValue = column.getValue();       \n        String valueAsString;\n        \n        // we have ^(CONVERT_TO_TYPE <type>) inside of GET statement\n        // which means that we should try to represent byte[] value according\n        // to specified type\n        if (statement.getChildCount() == 2)\n        {\n            // getting ^(CONVERT_TO_TYPE <type>) tree \n            Tree typeTree = statement.getChild(1).getChild(0);\n            // .getText() will give us <type>\n            String typeName = CliUtils.unescapeSQLString(typeTree.getText());\n            // building AbstractType from <type>\n            AbstractType valueValidator = getFormatType(typeName);\n\n            // setting value for output\n            valueAsString = valueValidator.getString(ByteBuffer.wrap(columnValue));\n            // updating column value validator class\n            updateColumnMetaData(cfDef, columnName, valueValidator.toString());\n        }\n        else\n        {\n            valueAsString = (validator == null) ? new String(columnValue, Charsets.UTF_8) : validator.getString(ByteBuffer.wrap(columnValue));\n        }\n\n        String formattedColumnName = isSuper\n                                     ? formatSubcolumnName(keySpace, columnFamily, column.name)\n                                     : formatColumnName(keySpace, columnFamily, column.name);\n\n        // print results\n        sessionState.out.printf(\"=> (column=%s, value=%s, timestamp=%d%s)%n\",\n                                formattedColumnName,\n                                valueAsString,\n                                column.timestamp,\n                                column.isSetTtl() ? String.format(\", ttl=%d\", column.getTtl()) : \"\");\n    }","id":49295,"modified_method":"private void executeGet(Tree statement)\n            throws TException, NotFoundException, InvalidRequestException, UnavailableException, TimedOutException, IllegalAccessException, InstantiationException, ClassNotFoundException, NoSuchFieldException\n    {\n        if (!CliMain.isConnected() || !hasKeySpace())\n            return;\n\n        Tree columnFamilySpec = statement.getChild(0);\n        String columnFamily = CliCompiler.getColumnFamily(columnFamilySpec, keyspacesMap.get(keySpace).cf_defs);\n        ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));\n        int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);\n        CfDef cfDef = getCfDef(columnFamily);\n        boolean isSuper = cfDef.column_type.equals(\"Super\");\n        \n        byte[] superColumnName = null;\n        ByteBuffer columnName;\n\n        Tree typeTree = null;\n        Tree limitTree = null;\n\n        int limit = 1000000;\n\n        if (statement.getChildCount() >= 2)\n        {\n            if (statement.getChild(1).getType() == CliParser.CONVERT_TO_TYPE)\n            {\n                typeTree = statement.getChild(1).getChild(0);\n                if (statement.getChildCount() == 3)\n                    limitTree = statement.getChild(2).getChild(0);\n            }\n            else\n            {\n                limitTree = statement.getChild(1).getChild(0);\n            }\n        }\n\n        if (limitTree != null)\n        {\n            limit = Integer.parseInt(limitTree.getText());\n\n            if (limit == 0)\n            {\n                throw new IllegalArgumentException(\"LIMIT should be greater than zero.\");\n            }\n        }\n\n        // table.cf['key'] -- row slice\n        if (columnSpecCnt == 0)\n        {\n            doSlice(keySpace, key, columnFamily, superColumnName, limit);\n            return;\n        }\n        // table.cf['key']['column'] -- slice of a super, or get of a standard\n        else if (columnSpecCnt == 1)\n        {\n            columnName = getColumnName(columnFamily, columnFamilySpec.getChild(2));\n\n            if (isSuper)\n            {\n                superColumnName = columnName.array();\n                doSlice(keySpace, key, columnFamily, superColumnName, limit);\n                return;\n            }\n        }\n        // table.cf['key']['column']['column'] -- get of a sub-column\n        else if (columnSpecCnt == 2)\n        {\n            superColumnName = getColumnName(columnFamily, columnFamilySpec.getChild(2)).array();\n            columnName = getSubColumnName(columnFamily, columnFamilySpec.getChild(3));\n        }\n        // The parser groks an arbitrary number of these so it is possible to get here.\n        else\n        {\n            sessionState.out.println(\"Invalid row, super column, or column specification.\");\n            return;\n        }\n\n        AbstractType validator = getValidatorForValue(cfDef, TBaseHelper.byteBufferToByteArray(columnName));\n\n        // Perform a get()\n        ColumnPath path = new ColumnPath(columnFamily);\n        if(superColumnName != null) path.setSuper_column(superColumnName);\n        path.setColumn(columnName);\n\n        if (isCounterCF(cfDef))\n        {\n            doGetCounter(key, path);\n            return;\n        }\n\n        Column column;\n        try\n        {\n            column = thriftClient.get(key, path, consistencyLevel).column;\n        }\n        catch (NotFoundException e)\n        {\n            sessionState.out.println(\"Value was not found\");\n            return;\n        }\n\n        byte[] columnValue = column.getValue();       \n        String valueAsString;\n\n        // we have ^(CONVERT_TO_TYPE <type>) inside of GET statement\n        // which means that we should try to represent byte[] value according\n        // to specified type\n        if (typeTree != null)\n        {\n            // .getText() will give us <type>\n            String typeName = CliUtils.unescapeSQLString(typeTree.getText());\n            // building AbstractType from <type>\n            AbstractType valueValidator = getFormatType(typeName);\n\n            // setting value for output\n            valueAsString = valueValidator.getString(ByteBuffer.wrap(columnValue));\n            // updating column value validator class\n            updateColumnMetaData(cfDef, columnName, valueValidator.toString());\n        }\n        else\n        {\n            valueAsString = (validator == null) ? new String(columnValue, Charsets.UTF_8) : validator.getString(ByteBuffer.wrap(columnValue));\n        }\n\n        String formattedColumnName = isSuper\n                                     ? formatSubcolumnName(keySpace, columnFamily, column.name)\n                                     : formatColumnName(keySpace, columnFamily, column.name);\n\n        // print results\n        sessionState.out.printf(\"=> (column=%s, value=%s, timestamp=%d%s)%n\",\n                                formattedColumnName,\n                                valueAsString,\n                                column.timestamp,\n                                column.isSetTtl() ? String.format(\", ttl=%d\", column.getTtl()) : \"\");\n    }","commit_id":"e23fff1d73a017cd0e0a95295721e73b8034846a","url":"https://github.com/apache/cassandra"},{"original_method":"private void doSlice(String keyspace, ByteBuffer key, String columnFamily, byte[] superColumnName)\n            throws InvalidRequestException, UnavailableException, TimedOutException, TException, IllegalAccessException, NotFoundException, InstantiationException, NoSuchFieldException\n    {\n        \n        ColumnParent parent = new ColumnParent(columnFamily);\n        if(superColumnName != null)\n            parent.setSuper_column(superColumnName);\n\n        SliceRange range = new SliceRange(ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1000000);\n        SlicePredicate predicate = new SlicePredicate().setColumn_names(null).setSlice_range(range);\n\n        CfDef cfDef = getCfDef(columnFamily);\n        boolean isSuperCF = cfDef.column_type.equals(\"Super\");\n\n        List<ColumnOrSuperColumn> columns = thriftClient.get_slice(key, parent, predicate, consistencyLevel);\n        AbstractType validator;\n\n        // Print out super columns or columns.\n        for (ColumnOrSuperColumn cosc : columns)\n        {\n            if (cosc.isSetSuper_column())\n            {\n                SuperColumn superColumn = cosc.super_column;\n\n                sessionState.out.printf(\"=> (super_column=%s,\", formatColumnName(keyspace, columnFamily, superColumn.name));\n                for (Column col : superColumn.getColumns())\n                {\n                    validator = getValidatorForValue(cfDef, col.getName());\n                    sessionState.out.printf(\"%n     (column=%s, value=%s, timestamp=%d%s)\", formatSubcolumnName(keyspace, columnFamily, col.name),\n                                                    validator.getString(col.value), col.timestamp,\n                                                    col.isSetTtl() ? String.format(\", ttl=%d\", col.getTtl()) : \"\");\n                }\n                \n                sessionState.out.println(\")\");\n            }\n            else if (cosc.isSetColumn())\n            {\n                Column column = cosc.column;\n                validator = getValidatorForValue(cfDef, column.getName());\n\n                String formattedName = isSuperCF\n                                       ? formatSubcolumnName(keyspace, columnFamily, column.name)\n                                       : formatColumnName(keyspace, columnFamily, column.name);\n\n                sessionState.out.printf(\"=> (column=%s, value=%s, timestamp=%d%s)%n\",\n                                        formattedName,\n                                        validator.getString(column.value),\n                                        column.timestamp,\n                                        column.isSetTtl() ? String.format(\", ttl=%d\", column.getTtl()) : \"\");\n            }\n            else if (cosc.isSetCounter_super_column())\n            {\n                CounterSuperColumn superColumn = cosc.counter_super_column;\n\n                sessionState.out.printf(\"=> (super_column=%s,\", formatColumnName(keyspace, columnFamily, superColumn.name));\n                for (CounterColumn col : superColumn.getColumns())\n                {\n                    sessionState.out.printf(\"%n     (counter=%s, value=%s)\", formatSubcolumnName(keyspace, columnFamily, col.name), col.value);\n                }\n                sessionState.out.println(\")\");\n            }\n            else // cosc.isSetCounter_column()\n            {\n                CounterColumn column = cosc.counter_column;\n                String formattedName = isSuperCF\n                                       ? formatSubcolumnName(keyspace, columnFamily, column.name)\n                                       : formatColumnName(keyspace, columnFamily, column.name);\n\n                sessionState.out.printf(\"=> (counter=%s, value=%s)%n\", formattedName, column.value);\n            }\n        }\n        \n        sessionState.out.println(\"Returned \" + columns.size() + \" results.\");\n    }","id":49296,"modified_method":"private void doSlice(String keyspace, ByteBuffer key, String columnFamily, byte[] superColumnName, int limit)\n            throws InvalidRequestException, UnavailableException, TimedOutException, TException, IllegalAccessException, NotFoundException, InstantiationException, NoSuchFieldException\n    {\n        \n        ColumnParent parent = new ColumnParent(columnFamily);\n        if(superColumnName != null)\n            parent.setSuper_column(superColumnName);\n\n        SliceRange range = new SliceRange(ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, limit);\n        SlicePredicate predicate = new SlicePredicate().setColumn_names(null).setSlice_range(range);\n\n        CfDef cfDef = getCfDef(columnFamily);\n        boolean isSuperCF = cfDef.column_type.equals(\"Super\");\n\n        List<ColumnOrSuperColumn> columns = thriftClient.get_slice(key, parent, predicate, consistencyLevel);\n        AbstractType validator;\n\n        // Print out super columns or columns.\n        for (ColumnOrSuperColumn cosc : columns)\n        {\n            if (cosc.isSetSuper_column())\n            {\n                SuperColumn superColumn = cosc.super_column;\n\n                sessionState.out.printf(\"=> (super_column=%s,\", formatColumnName(keyspace, columnFamily, superColumn.name));\n                for (Column col : superColumn.getColumns())\n                {\n                    validator = getValidatorForValue(cfDef, col.getName());\n                    sessionState.out.printf(\"%n     (column=%s, value=%s, timestamp=%d%s)\", formatSubcolumnName(keyspace, columnFamily, col.name),\n                                                    validator.getString(col.value), col.timestamp,\n                                                    col.isSetTtl() ? String.format(\", ttl=%d\", col.getTtl()) : \"\");\n                }\n                \n                sessionState.out.println(\")\");\n            }\n            else if (cosc.isSetColumn())\n            {\n                Column column = cosc.column;\n                validator = getValidatorForValue(cfDef, column.getName());\n\n                String formattedName = isSuperCF\n                                       ? formatSubcolumnName(keyspace, columnFamily, column.name)\n                                       : formatColumnName(keyspace, columnFamily, column.name);\n\n                sessionState.out.printf(\"=> (column=%s, value=%s, timestamp=%d%s)%n\",\n                                        formattedName,\n                                        validator.getString(column.value),\n                                        column.timestamp,\n                                        column.isSetTtl() ? String.format(\", ttl=%d\", column.getTtl()) : \"\");\n            }\n            else if (cosc.isSetCounter_super_column())\n            {\n                CounterSuperColumn superColumn = cosc.counter_super_column;\n\n                sessionState.out.printf(\"=> (super_column=%s,\", formatColumnName(keyspace, columnFamily, superColumn.name));\n                for (CounterColumn col : superColumn.getColumns())\n                {\n                    sessionState.out.printf(\"%n     (counter=%s, value=%s)\", formatSubcolumnName(keyspace, columnFamily, col.name), col.value);\n                }\n                sessionState.out.println(\")\");\n            }\n            else // cosc.isSetCounter_column()\n            {\n                CounterColumn column = cosc.counter_column;\n                String formattedName = isSuperCF\n                                       ? formatSubcolumnName(keyspace, columnFamily, column.name)\n                                       : formatColumnName(keyspace, columnFamily, column.name);\n\n                sessionState.out.printf(\"=> (counter=%s, value=%s)%n\", formattedName, column.value);\n            }\n        }\n        \n        sessionState.out.println(\"Returned \" + columns.size() + \" results.\");\n    }","commit_id":"e23fff1d73a017cd0e0a95295721e73b8034846a","url":"https://github.com/apache/cassandra"},{"original_method":"private void executeGet(Tree statement)\n            throws TException, NotFoundException, InvalidRequestException, UnavailableException, TimedOutException, IllegalAccessException, InstantiationException, ClassNotFoundException, NoSuchFieldException\n    {\n        if (!CliMain.isConnected() || !hasKeySpace())\n            return;\n\n        Tree columnFamilySpec = statement.getChild(0);\n        String columnFamily = CliCompiler.getColumnFamily(columnFamilySpec, keyspacesMap.get(keySpace).cf_defs);\n        ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));\n        int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);\n        CfDef cfDef = getCfDef(columnFamily);\n        boolean isSuper = cfDef.column_type.equals(\"Super\");\n        \n        byte[] superColumnName = null;\n        ByteBuffer columnName;\n\n        // table.cf['key'] -- row slice\n        if (columnSpecCnt == 0)\n        {\n            doSlice(keySpace, key, columnFamily, superColumnName);\n            return;\n        }\n        // table.cf['key']['column'] -- slice of a super, or get of a standard\n        else if (columnSpecCnt == 1)\n        {\n            columnName = getColumnName(columnFamily, columnFamilySpec.getChild(2));\n\n            if (isSuper)\n            {\n                superColumnName = columnName.array();\n                doSlice(keySpace, key, columnFamily, superColumnName);\n                return;\n            }\n        }\n        // table.cf['key']['column']['column'] -- get of a sub-column\n        else if (columnSpecCnt == 2)\n        {\n            superColumnName = getColumnName(columnFamily, columnFamilySpec.getChild(2)).array();\n            columnName = getSubColumnName(columnFamily, columnFamilySpec.getChild(3));\n        }\n        // The parser groks an arbitrary number of these so it is possible to get here.\n        else\n        {\n            sessionState.out.println(\"Invalid row, super column, or column specification.\");\n            return;\n        }\n\n        AbstractType validator = getValidatorForValue(cfDef, TBaseHelper.byteBufferToByteArray(columnName));\n\n        // Perform a get()\n        ColumnPath path = new ColumnPath(columnFamily);\n        if(superColumnName != null) path.setSuper_column(superColumnName);\n        path.setColumn(columnName);\n\n        if (isCounterCF(cfDef))\n        {\n            doGetCounter(key, path);\n            return;\n        }\n\n        Column column;\n        try\n        {\n            column = thriftClient.get(key, path, consistencyLevel).column;\n        }\n        catch (NotFoundException e)\n        {\n            sessionState.out.println(\"Value was not found\");\n            return;\n        }\n\n        byte[] columnValue = column.getValue();       \n        String valueAsString;\n        \n        // we have ^(CONVERT_TO_TYPE <type>) inside of GET statement\n        // which means that we should try to represent byte[] value according\n        // to specified type\n        if (statement.getChildCount() == 2)\n        {\n            // getting ^(CONVERT_TO_TYPE <type>) tree \n            Tree typeTree = statement.getChild(1).getChild(0);\n            // .getText() will give us <type>\n            String typeName = CliUtils.unescapeSQLString(typeTree.getText());\n            // building AbstractType from <type>\n            AbstractType valueValidator = getFormatType(typeName);\n\n            // setting value for output\n            valueAsString = valueValidator.getString(ByteBuffer.wrap(columnValue));\n            // updating column value validator class\n            updateColumnMetaData(cfDef, columnName, valueValidator.getClass().getName());\n        }\n        else\n        {\n            valueAsString = (validator == null) ? new String(columnValue, Charsets.UTF_8) : validator.getString(ByteBuffer.wrap(columnValue));\n        }\n\n        String formattedColumnName = isSuper\n                                     ? formatSubcolumnName(keySpace, columnFamily, column.name)\n                                     : formatColumnName(keySpace, columnFamily, column.name);\n\n        // print results\n        sessionState.out.printf(\"=> (column=%s, value=%s, timestamp=%d%s)%n\",\n                                formattedColumnName,\n                                valueAsString,\n                                column.timestamp,\n                                column.isSetTtl() ? String.format(\", ttl=%d\", column.getTtl()) : \"\");\n    }","id":49297,"modified_method":"private void executeGet(Tree statement)\n            throws TException, NotFoundException, InvalidRequestException, UnavailableException, TimedOutException, IllegalAccessException, InstantiationException, ClassNotFoundException, NoSuchFieldException\n    {\n        if (!CliMain.isConnected() || !hasKeySpace())\n            return;\n\n        Tree columnFamilySpec = statement.getChild(0);\n        String columnFamily = CliCompiler.getColumnFamily(columnFamilySpec, keyspacesMap.get(keySpace).cf_defs);\n        ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));\n        int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);\n        CfDef cfDef = getCfDef(columnFamily);\n        boolean isSuper = cfDef.column_type.equals(\"Super\");\n        \n        byte[] superColumnName = null;\n        ByteBuffer columnName;\n\n        Tree typeTree = null;\n        Tree limitTree = null;\n\n        int limit = 1000000;\n\n        if (statement.getChildCount() >= 2)\n        {\n            if (statement.getChild(1).getType() == CliParser.CONVERT_TO_TYPE)\n            {\n                typeTree = statement.getChild(1).getChild(0);\n                if (statement.getChildCount() == 3)\n                    limitTree = statement.getChild(2).getChild(0);\n            }\n            else\n            {\n                limitTree = statement.getChild(1).getChild(0);\n            }\n        }\n\n        if (limitTree != null)\n        {\n            limit = Integer.parseInt(limitTree.getText());\n\n            if (limit == 0)\n            {\n                throw new IllegalArgumentException(\"LIMIT should be greater than zero.\");\n            }\n        }\n\n        // table.cf['key'] -- row slice\n        if (columnSpecCnt == 0)\n        {\n            doSlice(keySpace, key, columnFamily, superColumnName, limit);\n            return;\n        }\n        // table.cf['key']['column'] -- slice of a super, or get of a standard\n        else if (columnSpecCnt == 1)\n        {\n            columnName = getColumnName(columnFamily, columnFamilySpec.getChild(2));\n\n            if (isSuper)\n            {\n                superColumnName = columnName.array();\n                doSlice(keySpace, key, columnFamily, superColumnName, limit);\n                return;\n            }\n        }\n        // table.cf['key']['column']['column'] -- get of a sub-column\n        else if (columnSpecCnt == 2)\n        {\n            superColumnName = getColumnName(columnFamily, columnFamilySpec.getChild(2)).array();\n            columnName = getSubColumnName(columnFamily, columnFamilySpec.getChild(3));\n        }\n        // The parser groks an arbitrary number of these so it is possible to get here.\n        else\n        {\n            sessionState.out.println(\"Invalid row, super column, or column specification.\");\n            return;\n        }\n\n        AbstractType validator = getValidatorForValue(cfDef, TBaseHelper.byteBufferToByteArray(columnName));\n\n        // Perform a get()\n        ColumnPath path = new ColumnPath(columnFamily);\n        if(superColumnName != null) path.setSuper_column(superColumnName);\n        path.setColumn(columnName);\n\n        if (isCounterCF(cfDef))\n        {\n            doGetCounter(key, path);\n            return;\n        }\n\n        Column column;\n        try\n        {\n            column = thriftClient.get(key, path, consistencyLevel).column;\n        }\n        catch (NotFoundException e)\n        {\n            sessionState.out.println(\"Value was not found\");\n            return;\n        }\n\n        byte[] columnValue = column.getValue();       \n        String valueAsString;\n\n        // we have ^(CONVERT_TO_TYPE <type>) inside of GET statement\n        // which means that we should try to represent byte[] value according\n        // to specified type\n        if (typeTree != null)\n        {\n            // .getText() will give us <type>\n            String typeName = CliUtils.unescapeSQLString(typeTree.getText());\n            // building AbstractType from <type>\n            AbstractType valueValidator = getFormatType(typeName);\n\n            // setting value for output\n            valueAsString = valueValidator.getString(ByteBuffer.wrap(columnValue));\n            // updating column value validator class\n            updateColumnMetaData(cfDef, columnName, valueValidator.getClass().getName());\n        }\n        else\n        {\n            valueAsString = (validator == null) ? new String(columnValue, Charsets.UTF_8) : validator.getString(ByteBuffer.wrap(columnValue));\n        }\n\n        String formattedColumnName = isSuper\n                                     ? formatSubcolumnName(keySpace, columnFamily, column.name)\n                                     : formatColumnName(keySpace, columnFamily, column.name);\n\n        // print results\n        sessionState.out.printf(\"=> (column=%s, value=%s, timestamp=%d%s)%n\",\n                                formattedColumnName,\n                                valueAsString,\n                                column.timestamp,\n                                column.isSetTtl() ? String.format(\", ttl=%d\", column.getTtl()) : \"\");\n    }","commit_id":"0db8b6407654f9cdf297569c17cebd6b07643d74","url":"https://github.com/apache/cassandra"},{"original_method":"private void doSlice(String keyspace, ByteBuffer key, String columnFamily, byte[] superColumnName)\n            throws InvalidRequestException, UnavailableException, TimedOutException, TException, IllegalAccessException, NotFoundException, InstantiationException, NoSuchFieldException\n    {\n        \n        ColumnParent parent = new ColumnParent(columnFamily);\n        if(superColumnName != null)\n            parent.setSuper_column(superColumnName);\n\n        SliceRange range = new SliceRange(ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1000000);\n        SlicePredicate predicate = new SlicePredicate().setColumn_names(null).setSlice_range(range);\n\n        CfDef cfDef = getCfDef(columnFamily);\n        boolean isSuperCF = cfDef.column_type.equals(\"Super\");\n\n        List<ColumnOrSuperColumn> columns = thriftClient.get_slice(key, parent, predicate, consistencyLevel);\n        AbstractType validator;\n\n        // Print out super columns or columns.\n        for (ColumnOrSuperColumn cosc : columns)\n        {\n            if (cosc.isSetSuper_column())\n            {\n                SuperColumn superColumn = cosc.super_column;\n\n                sessionState.out.printf(\"=> (super_column=%s,\", formatColumnName(keyspace, columnFamily, superColumn.name));\n                for (Column col : superColumn.getColumns())\n                {\n                    validator = getValidatorForValue(cfDef, col.getName());\n                    sessionState.out.printf(\"%n     (column=%s, value=%s, timestamp=%d%s)\", formatSubcolumnName(keyspace, columnFamily, col.name),\n                                                    validator.getString(col.value), col.timestamp,\n                                                    col.isSetTtl() ? String.format(\", ttl=%d\", col.getTtl()) : \"\");\n                }\n                \n                sessionState.out.println(\")\");\n            }\n            else if (cosc.isSetColumn())\n            {\n                Column column = cosc.column;\n                validator = getValidatorForValue(cfDef, column.getName());\n\n                String formattedName = isSuperCF\n                                       ? formatSubcolumnName(keyspace, columnFamily, column.name)\n                                       : formatColumnName(keyspace, columnFamily, column.name);\n\n                sessionState.out.printf(\"=> (column=%s, value=%s, timestamp=%d%s)%n\",\n                                        formattedName,\n                                        validator.getString(column.value),\n                                        column.timestamp,\n                                        column.isSetTtl() ? String.format(\", ttl=%d\", column.getTtl()) : \"\");\n            }\n            else if (cosc.isSetCounter_super_column())\n            {\n                CounterSuperColumn superColumn = cosc.counter_super_column;\n\n                sessionState.out.printf(\"=> (super_column=%s,\", formatColumnName(keyspace, columnFamily, superColumn.name));\n                for (CounterColumn col : superColumn.getColumns())\n                {\n                    sessionState.out.printf(\"%n     (counter=%s, value=%s)\", formatSubcolumnName(keyspace, columnFamily, col.name), col.value);\n                }\n                sessionState.out.println(\")\");\n            }\n            else // cosc.isSetCounter_column()\n            {\n                CounterColumn column = cosc.counter_column;\n                String formattedName = isSuperCF\n                                       ? formatSubcolumnName(keyspace, columnFamily, column.name)\n                                       : formatColumnName(keyspace, columnFamily, column.name);\n\n                sessionState.out.printf(\"=> (counter=%s, value=%s)%n\", formattedName, column.value);\n            }\n        }\n        \n        sessionState.out.println(\"Returned \" + columns.size() + \" results.\");\n    }","id":49298,"modified_method":"private void doSlice(String keyspace, ByteBuffer key, String columnFamily, byte[] superColumnName, int limit)\n            throws InvalidRequestException, UnavailableException, TimedOutException, TException, IllegalAccessException, NotFoundException, InstantiationException, NoSuchFieldException\n    {\n        \n        ColumnParent parent = new ColumnParent(columnFamily);\n        if(superColumnName != null)\n            parent.setSuper_column(superColumnName);\n\n        SliceRange range = new SliceRange(ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, limit);\n        SlicePredicate predicate = new SlicePredicate().setColumn_names(null).setSlice_range(range);\n\n        CfDef cfDef = getCfDef(columnFamily);\n        boolean isSuperCF = cfDef.column_type.equals(\"Super\");\n\n        List<ColumnOrSuperColumn> columns = thriftClient.get_slice(key, parent, predicate, consistencyLevel);\n        AbstractType validator;\n\n        // Print out super columns or columns.\n        for (ColumnOrSuperColumn cosc : columns)\n        {\n            if (cosc.isSetSuper_column())\n            {\n                SuperColumn superColumn = cosc.super_column;\n\n                sessionState.out.printf(\"=> (super_column=%s,\", formatColumnName(keyspace, columnFamily, superColumn.name));\n                for (Column col : superColumn.getColumns())\n                {\n                    validator = getValidatorForValue(cfDef, col.getName());\n                    sessionState.out.printf(\"%n     (column=%s, value=%s, timestamp=%d%s)\", formatSubcolumnName(keyspace, columnFamily, col.name),\n                                                    validator.getString(col.value), col.timestamp,\n                                                    col.isSetTtl() ? String.format(\", ttl=%d\", col.getTtl()) : \"\");\n                }\n                \n                sessionState.out.println(\")\");\n            }\n            else if (cosc.isSetColumn())\n            {\n                Column column = cosc.column;\n                validator = getValidatorForValue(cfDef, column.getName());\n\n                String formattedName = isSuperCF\n                                       ? formatSubcolumnName(keyspace, columnFamily, column.name)\n                                       : formatColumnName(keyspace, columnFamily, column.name);\n\n                sessionState.out.printf(\"=> (column=%s, value=%s, timestamp=%d%s)%n\",\n                                        formattedName,\n                                        validator.getString(column.value),\n                                        column.timestamp,\n                                        column.isSetTtl() ? String.format(\", ttl=%d\", column.getTtl()) : \"\");\n            }\n            else if (cosc.isSetCounter_super_column())\n            {\n                CounterSuperColumn superColumn = cosc.counter_super_column;\n\n                sessionState.out.printf(\"=> (super_column=%s,\", formatColumnName(keyspace, columnFamily, superColumn.name));\n                for (CounterColumn col : superColumn.getColumns())\n                {\n                    sessionState.out.printf(\"%n     (counter=%s, value=%s)\", formatSubcolumnName(keyspace, columnFamily, col.name), col.value);\n                }\n                sessionState.out.println(\")\");\n            }\n            else // cosc.isSetCounter_column()\n            {\n                CounterColumn column = cosc.counter_column;\n                String formattedName = isSuperCF\n                                       ? formatSubcolumnName(keyspace, columnFamily, column.name)\n                                       : formatColumnName(keyspace, columnFamily, column.name);\n\n                sessionState.out.printf(\"=> (counter=%s, value=%s)%n\", formattedName, column.value);\n            }\n        }\n        \n        sessionState.out.println(\"Returned \" + columns.size() + \" results.\");\n    }","commit_id":"0db8b6407654f9cdf297569c17cebd6b07643d74","url":"https://github.com/apache/cassandra"},{"original_method":"private void executeGet(Tree statement)\n            throws TException, NotFoundException, InvalidRequestException, UnavailableException, TimedOutException, IllegalAccessException, InstantiationException, ClassNotFoundException, NoSuchFieldException\n    {\n        if (!CliMain.isConnected() || !hasKeySpace())\n            return;\n\n        Tree columnFamilySpec = statement.getChild(0);\n        String columnFamily = CliCompiler.getColumnFamily(columnFamilySpec, keyspacesMap.get(keySpace).cf_defs);\n        ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));\n        int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);\n        CfDef cfDef = getCfDef(columnFamily);\n        boolean isSuper = cfDef.column_type.equals(\"Super\");\n        \n        byte[] superColumnName = null;\n        ByteBuffer columnName;\n\n        // table.cf['key'] -- row slice\n        if (columnSpecCnt == 0)\n        {\n            doSlice(keySpace, key, columnFamily, superColumnName);\n            return;\n        }\n        // table.cf['key']['column'] -- slice of a super, or get of a standard\n        else if (columnSpecCnt == 1)\n        {\n            columnName = getColumnName(columnFamily, columnFamilySpec.getChild(2));\n\n            if (isSuper)\n            {\n                superColumnName = columnName.array();\n                doSlice(keySpace, key, columnFamily, superColumnName);\n                return;\n            }\n        }\n        // table.cf['key']['column']['column'] -- get of a sub-column\n        else if (columnSpecCnt == 2)\n        {\n            superColumnName = getColumnName(columnFamily, columnFamilySpec.getChild(2)).array();\n            columnName = getSubColumnName(columnFamily, columnFamilySpec.getChild(3));\n        }\n        // The parser groks an arbitrary number of these so it is possible to get here.\n        else\n        {\n            sessionState.out.println(\"Invalid row, super column, or column specification.\");\n            return;\n        }\n\n        AbstractType validator = getValidatorForValue(cfDef, TBaseHelper.byteBufferToByteArray(columnName));\n\n        // Perform a get()\n        ColumnPath path = new ColumnPath(columnFamily);\n        if(superColumnName != null) path.setSuper_column(superColumnName);\n        path.setColumn(columnName);\n\n        if (isCounterCF(cfDef))\n        {\n            doGetCounter(key, path);\n            return;\n        }\n\n        Column column;\n        try\n        {\n            column = thriftClient.get(key, path, consistencyLevel).column;\n        }\n        catch (NotFoundException e)\n        {\n            sessionState.out.println(\"Value was not found\");\n            return;\n        }\n\n        byte[] columnValue = column.getValue();       \n        String valueAsString;\n        \n        // we have ^(CONVERT_TO_TYPE <type>) inside of GET statement\n        // which means that we should try to represent byte[] value according\n        // to specified type\n        if (statement.getChildCount() == 2)\n        {\n            // getting ^(CONVERT_TO_TYPE <type>) tree \n            Tree typeTree = statement.getChild(1).getChild(0);\n            // .getText() will give us <type>\n            String typeName = CliUtils.unescapeSQLString(typeTree.getText());\n            // building AbstractType from <type>\n            AbstractType valueValidator = getFormatType(typeName);\n\n            // setting value for output\n            valueAsString = valueValidator.getString(ByteBuffer.wrap(columnValue));\n            // updating column value validator class\n            updateColumnMetaData(cfDef, columnName, valueValidator.toString());\n        }\n        else\n        {\n            valueAsString = (validator == null) ? new String(columnValue, Charsets.UTF_8) : validator.getString(ByteBuffer.wrap(columnValue));\n        }\n\n        String formattedColumnName = isSuper\n                                     ? formatSubcolumnName(keySpace, columnFamily, column.name)\n                                     : formatColumnName(keySpace, columnFamily, column.name);\n\n        // print results\n        sessionState.out.printf(\"=> (column=%s, value=%s, timestamp=%d%s)%n\",\n                                formattedColumnName,\n                                valueAsString,\n                                column.timestamp,\n                                column.isSetTtl() ? String.format(\", ttl=%d\", column.getTtl()) : \"\");\n    }","id":49299,"modified_method":"private void executeGet(Tree statement)\n            throws TException, NotFoundException, InvalidRequestException, UnavailableException, TimedOutException, IllegalAccessException, InstantiationException, ClassNotFoundException, NoSuchFieldException\n    {\n        if (!CliMain.isConnected() || !hasKeySpace())\n            return;\n\n        Tree columnFamilySpec = statement.getChild(0);\n        String columnFamily = CliCompiler.getColumnFamily(columnFamilySpec, keyspacesMap.get(keySpace).cf_defs);\n        ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));\n        int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);\n        CfDef cfDef = getCfDef(columnFamily);\n        boolean isSuper = cfDef.column_type.equals(\"Super\");\n        \n        byte[] superColumnName = null;\n        ByteBuffer columnName;\n\n        Tree typeTree = null;\n        Tree limitTree = null;\n\n        int limit = 1000000;\n\n        if (statement.getChildCount() >= 2)\n        {\n            if (statement.getChild(1).getType() == CliParser.CONVERT_TO_TYPE)\n            {\n                typeTree = statement.getChild(1).getChild(0);\n                if (statement.getChildCount() == 3)\n                    limitTree = statement.getChild(2).getChild(0);\n            }\n            else\n            {\n                limitTree = statement.getChild(1).getChild(0);\n            }\n        }\n\n        if (limitTree != null)\n        {\n            limit = Integer.parseInt(limitTree.getText());\n\n            if (limit == 0)\n            {\n                throw new IllegalArgumentException(\"LIMIT should be greater than zero.\");\n            }\n        }\n\n        // table.cf['key'] -- row slice\n        if (columnSpecCnt == 0)\n        {\n            doSlice(keySpace, key, columnFamily, superColumnName, limit);\n            return;\n        }\n        // table.cf['key']['column'] -- slice of a super, or get of a standard\n        else if (columnSpecCnt == 1)\n        {\n            columnName = getColumnName(columnFamily, columnFamilySpec.getChild(2));\n\n            if (isSuper)\n            {\n                superColumnName = columnName.array();\n                doSlice(keySpace, key, columnFamily, superColumnName, limit);\n                return;\n            }\n        }\n        // table.cf['key']['column']['column'] -- get of a sub-column\n        else if (columnSpecCnt == 2)\n        {\n            superColumnName = getColumnName(columnFamily, columnFamilySpec.getChild(2)).array();\n            columnName = getSubColumnName(columnFamily, columnFamilySpec.getChild(3));\n        }\n        // The parser groks an arbitrary number of these so it is possible to get here.\n        else\n        {\n            sessionState.out.println(\"Invalid row, super column, or column specification.\");\n            return;\n        }\n\n        AbstractType validator = getValidatorForValue(cfDef, TBaseHelper.byteBufferToByteArray(columnName));\n\n        // Perform a get()\n        ColumnPath path = new ColumnPath(columnFamily);\n        if(superColumnName != null) path.setSuper_column(superColumnName);\n        path.setColumn(columnName);\n\n        if (isCounterCF(cfDef))\n        {\n            doGetCounter(key, path);\n            return;\n        }\n\n        Column column;\n        try\n        {\n            column = thriftClient.get(key, path, consistencyLevel).column;\n        }\n        catch (NotFoundException e)\n        {\n            sessionState.out.println(\"Value was not found\");\n            return;\n        }\n\n        byte[] columnValue = column.getValue();       \n        String valueAsString;\n\n        // we have ^(CONVERT_TO_TYPE <type>) inside of GET statement\n        // which means that we should try to represent byte[] value according\n        // to specified type\n        if (typeTree != null)\n        {\n            // .getText() will give us <type>\n            String typeName = CliUtils.unescapeSQLString(typeTree.getText());\n            // building AbstractType from <type>\n            AbstractType valueValidator = getFormatType(typeName);\n\n            // setting value for output\n            valueAsString = valueValidator.getString(ByteBuffer.wrap(columnValue));\n            // updating column value validator class\n            updateColumnMetaData(cfDef, columnName, valueValidator.toString());\n        }\n        else\n        {\n            valueAsString = (validator == null) ? new String(columnValue, Charsets.UTF_8) : validator.getString(ByteBuffer.wrap(columnValue));\n        }\n\n        String formattedColumnName = isSuper\n                                     ? formatSubcolumnName(keySpace, columnFamily, column.name)\n                                     : formatColumnName(keySpace, columnFamily, column.name);\n\n        // print results\n        sessionState.out.printf(\"=> (column=%s, value=%s, timestamp=%d%s)%n\",\n                                formattedColumnName,\n                                valueAsString,\n                                column.timestamp,\n                                column.isSetTtl() ? String.format(\", ttl=%d\", column.getTtl()) : \"\");\n    }","commit_id":"8aeead39036eafd09c8748b4e9d52492ae9dc59f","url":"https://github.com/apache/cassandra"},{"original_method":"private void doSlice(String keyspace, ByteBuffer key, String columnFamily, byte[] superColumnName)\n            throws InvalidRequestException, UnavailableException, TimedOutException, TException, IllegalAccessException, NotFoundException, InstantiationException, NoSuchFieldException\n    {\n        \n        ColumnParent parent = new ColumnParent(columnFamily);\n        if(superColumnName != null)\n            parent.setSuper_column(superColumnName);\n\n        SliceRange range = new SliceRange(ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1000000);\n        SlicePredicate predicate = new SlicePredicate().setColumn_names(null).setSlice_range(range);\n\n        CfDef cfDef = getCfDef(columnFamily);\n        boolean isSuperCF = cfDef.column_type.equals(\"Super\");\n\n        List<ColumnOrSuperColumn> columns = thriftClient.get_slice(key, parent, predicate, consistencyLevel);\n        AbstractType validator;\n\n        // Print out super columns or columns.\n        for (ColumnOrSuperColumn cosc : columns)\n        {\n            if (cosc.isSetSuper_column())\n            {\n                SuperColumn superColumn = cosc.super_column;\n\n                sessionState.out.printf(\"=> (super_column=%s,\", formatColumnName(keyspace, columnFamily, superColumn.name));\n                for (Column col : superColumn.getColumns())\n                {\n                    validator = getValidatorForValue(cfDef, col.getName());\n                    sessionState.out.printf(\"%n     (column=%s, value=%s, timestamp=%d%s)\", formatSubcolumnName(keyspace, columnFamily, col.name),\n                                                    validator.getString(col.value), col.timestamp,\n                                                    col.isSetTtl() ? String.format(\", ttl=%d\", col.getTtl()) : \"\");\n                }\n                \n                sessionState.out.println(\")\");\n            }\n            else if (cosc.isSetColumn())\n            {\n                Column column = cosc.column;\n                validator = getValidatorForValue(cfDef, column.getName());\n\n                String formattedName = isSuperCF\n                                       ? formatSubcolumnName(keyspace, columnFamily, column.name)\n                                       : formatColumnName(keyspace, columnFamily, column.name);\n\n                sessionState.out.printf(\"=> (column=%s, value=%s, timestamp=%d%s)%n\",\n                                        formattedName,\n                                        validator.getString(column.value),\n                                        column.timestamp,\n                                        column.isSetTtl() ? String.format(\", ttl=%d\", column.getTtl()) : \"\");\n            }\n            else if (cosc.isSetCounter_super_column())\n            {\n                CounterSuperColumn superColumn = cosc.counter_super_column;\n\n                sessionState.out.printf(\"=> (super_column=%s,\", formatColumnName(keyspace, columnFamily, superColumn.name));\n                for (CounterColumn col : superColumn.getColumns())\n                {\n                    sessionState.out.printf(\"%n     (counter=%s, value=%s)\", formatSubcolumnName(keyspace, columnFamily, col.name), col.value);\n                }\n                sessionState.out.println(\")\");\n            }\n            else // cosc.isSetCounter_column()\n            {\n                CounterColumn column = cosc.counter_column;\n                String formattedName = isSuperCF\n                                       ? formatSubcolumnName(keyspace, columnFamily, column.name)\n                                       : formatColumnName(keyspace, columnFamily, column.name);\n\n                sessionState.out.printf(\"=> (counter=%s, value=%s)%n\", formattedName, column.value);\n            }\n        }\n        \n        sessionState.out.println(\"Returned \" + columns.size() + \" results.\");\n    }","id":49300,"modified_method":"private void doSlice(String keyspace, ByteBuffer key, String columnFamily, byte[] superColumnName, int limit)\n            throws InvalidRequestException, UnavailableException, TimedOutException, TException, IllegalAccessException, NotFoundException, InstantiationException, NoSuchFieldException\n    {\n        \n        ColumnParent parent = new ColumnParent(columnFamily);\n        if(superColumnName != null)\n            parent.setSuper_column(superColumnName);\n\n        SliceRange range = new SliceRange(ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, limit);\n        SlicePredicate predicate = new SlicePredicate().setColumn_names(null).setSlice_range(range);\n\n        CfDef cfDef = getCfDef(columnFamily);\n        boolean isSuperCF = cfDef.column_type.equals(\"Super\");\n\n        List<ColumnOrSuperColumn> columns = thriftClient.get_slice(key, parent, predicate, consistencyLevel);\n        AbstractType validator;\n\n        // Print out super columns or columns.\n        for (ColumnOrSuperColumn cosc : columns)\n        {\n            if (cosc.isSetSuper_column())\n            {\n                SuperColumn superColumn = cosc.super_column;\n\n                sessionState.out.printf(\"=> (super_column=%s,\", formatColumnName(keyspace, columnFamily, superColumn.name));\n                for (Column col : superColumn.getColumns())\n                {\n                    validator = getValidatorForValue(cfDef, col.getName());\n                    sessionState.out.printf(\"%n     (column=%s, value=%s, timestamp=%d%s)\", formatSubcolumnName(keyspace, columnFamily, col.name),\n                                                    validator.getString(col.value), col.timestamp,\n                                                    col.isSetTtl() ? String.format(\", ttl=%d\", col.getTtl()) : \"\");\n                }\n                \n                sessionState.out.println(\")\");\n            }\n            else if (cosc.isSetColumn())\n            {\n                Column column = cosc.column;\n                validator = getValidatorForValue(cfDef, column.getName());\n\n                String formattedName = isSuperCF\n                                       ? formatSubcolumnName(keyspace, columnFamily, column.name)\n                                       : formatColumnName(keyspace, columnFamily, column.name);\n\n                sessionState.out.printf(\"=> (column=%s, value=%s, timestamp=%d%s)%n\",\n                                        formattedName,\n                                        validator.getString(column.value),\n                                        column.timestamp,\n                                        column.isSetTtl() ? String.format(\", ttl=%d\", column.getTtl()) : \"\");\n            }\n            else if (cosc.isSetCounter_super_column())\n            {\n                CounterSuperColumn superColumn = cosc.counter_super_column;\n\n                sessionState.out.printf(\"=> (super_column=%s,\", formatColumnName(keyspace, columnFamily, superColumn.name));\n                for (CounterColumn col : superColumn.getColumns())\n                {\n                    sessionState.out.printf(\"%n     (counter=%s, value=%s)\", formatSubcolumnName(keyspace, columnFamily, col.name), col.value);\n                }\n                sessionState.out.println(\")\");\n            }\n            else // cosc.isSetCounter_column()\n            {\n                CounterColumn column = cosc.counter_column;\n                String formattedName = isSuperCF\n                                       ? formatSubcolumnName(keyspace, columnFamily, column.name)\n                                       : formatColumnName(keyspace, columnFamily, column.name);\n\n                sessionState.out.printf(\"=> (counter=%s, value=%s)%n\", formattedName, column.value);\n            }\n        }\n        \n        sessionState.out.println(\"Returned \" + columns.size() + \" results.\");\n    }","commit_id":"8aeead39036eafd09c8748b4e9d52492ae9dc59f","url":"https://github.com/apache/cassandra"},{"original_method":"private void executeGet(Tree statement)\n            throws TException, NotFoundException, InvalidRequestException, UnavailableException, TimedOutException, IllegalAccessException, InstantiationException, ClassNotFoundException, NoSuchFieldException\n    {\n        if (!CliMain.isConnected() || !hasKeySpace())\n            return;\n\n        Tree columnFamilySpec = statement.getChild(0);\n        String columnFamily = CliCompiler.getColumnFamily(columnFamilySpec, keyspacesMap.get(keySpace).cf_defs);\n        ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));\n        int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);\n        CfDef cfDef = getCfDef(columnFamily);\n        boolean isSuper = cfDef.column_type.equals(\"Super\");\n        \n        byte[] superColumnName = null;\n        ByteBuffer columnName;\n\n        // table.cf['key'] -- row slice\n        if (columnSpecCnt == 0)\n        {\n            doSlice(keySpace, key, columnFamily, superColumnName);\n            return;\n        }\n        // table.cf['key']['column'] -- slice of a super, or get of a standard\n        else if (columnSpecCnt == 1)\n        {\n            columnName = getColumnName(columnFamily, columnFamilySpec.getChild(2));\n\n            if (isSuper)\n            {\n                superColumnName = columnName.array();\n                doSlice(keySpace, key, columnFamily, superColumnName);\n                return;\n            }\n        }\n        // table.cf['key']['column']['column'] -- get of a sub-column\n        else if (columnSpecCnt == 2)\n        {\n            superColumnName = getColumnName(columnFamily, columnFamilySpec.getChild(2)).array();\n            columnName = getSubColumnName(columnFamily, columnFamilySpec.getChild(3));\n        }\n        // The parser groks an arbitrary number of these so it is possible to get here.\n        else\n        {\n            sessionState.out.println(\"Invalid row, super column, or column specification.\");\n            return;\n        }\n\n        AbstractType validator = getValidatorForValue(cfDef, TBaseHelper.byteBufferToByteArray(columnName));\n        \n        // Perform a get()\n        ColumnPath path = new ColumnPath(columnFamily);\n        if(superColumnName != null) path.setSuper_column(superColumnName);\n        path.setColumn(columnName);\n        Column column;\n        try\n        {\n            column = thriftClient.get(key, path, consistencyLevel).column;\n        }\n        catch (NotFoundException e)\n        {\n            sessionState.out.println(\"Value was not found\");\n            return;\n        }\n\n        byte[] columnValue = column.getValue();       \n        String valueAsString;\n        \n        // we have ^(CONVERT_TO_TYPE <type>) inside of GET statement\n        // which means that we should try to represent byte[] value according\n        // to specified type\n        if (statement.getChildCount() == 2)\n        {\n            // getting ^(CONVERT_TO_TYPE <type>) tree \n            Tree typeTree = statement.getChild(1).getChild(0);\n            // .getText() will give us <type>\n            String typeName = CliUtils.unescapeSQLString(typeTree.getText());\n            // building AbstractType from <type>\n            AbstractType valueValidator = getFormatTypeForColumn(typeName);\n\n            // setting value for output\n            valueAsString = valueValidator.getString(ByteBuffer.wrap(columnValue));\n            // updating column value validator class\n            updateColumnMetaData(cfDef, columnName, valueValidator.getClass().getName());\n        }\n        else\n        {\n            valueAsString = (validator == null) ? new String(columnValue, Charsets.UTF_8) : validator.getString(ByteBuffer.wrap(columnValue));\n        }\n\n        String formattedColumnName = isSuper\n                                     ? formatSubcolumnName(keySpace, columnFamily, column)\n                                     : formatColumnName(keySpace, columnFamily, column);\n\n        // print results\n        sessionState.out.printf(\"=> (column=%s, value=%s, timestamp=%d%s)%n\",\n                                formattedColumnName,\n                                valueAsString,\n                                column.timestamp,\n                                column.isSetTtl() ? String.format(\", ttl=%d\", column.getTtl()) : \"\");\n    }","id":49301,"modified_method":"private void executeGet(Tree statement)\n            throws TException, NotFoundException, InvalidRequestException, UnavailableException, TimedOutException, IllegalAccessException, InstantiationException, ClassNotFoundException, NoSuchFieldException\n    {\n        if (!CliMain.isConnected() || !hasKeySpace())\n            return;\n\n        Tree columnFamilySpec = statement.getChild(0);\n        String columnFamily = CliCompiler.getColumnFamily(columnFamilySpec, keyspacesMap.get(keySpace).cf_defs);\n        ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));\n        int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);\n        CfDef cfDef = getCfDef(columnFamily);\n        boolean isSuper = cfDef.column_type.equals(\"Super\");\n        \n        byte[] superColumnName = null;\n        ByteBuffer columnName;\n\n        Tree typeTree = null;\n        Tree limitTree = null;\n\n        int limit = 1000000;\n\n        if (statement.getChildCount() >= 2)\n        {\n            if (statement.getChild(1).getType() == CliParser.CONVERT_TO_TYPE)\n            {\n                typeTree = statement.getChild(1).getChild(0);\n                if (statement.getChildCount() == 3)\n                    limitTree = statement.getChild(2).getChild(0);\n            }\n            else\n            {\n                limitTree = statement.getChild(1).getChild(0);\n            }\n        }\n\n        if (limitTree != null)\n        {\n            limit = Integer.parseInt(limitTree.getText());\n\n            if (limit == 0)\n            {\n                throw new IllegalArgumentException(\"LIMIT should be greater than zero.\");\n            }\n        }\n\n        // table.cf['key'] -- row slice\n        if (columnSpecCnt == 0)\n        {\n            doSlice(keySpace, key, columnFamily, superColumnName, limit);\n            return;\n        }\n        // table.cf['key']['column'] -- slice of a super, or get of a standard\n        else if (columnSpecCnt == 1)\n        {\n            columnName = getColumnName(columnFamily, columnFamilySpec.getChild(2));\n\n            if (isSuper)\n            {\n                superColumnName = columnName.array();\n                doSlice(keySpace, key, columnFamily, superColumnName, limit);\n                return;\n            }\n        }\n        // table.cf['key']['column']['column'] -- get of a sub-column\n        else if (columnSpecCnt == 2)\n        {\n            superColumnName = getColumnName(columnFamily, columnFamilySpec.getChild(2)).array();\n            columnName = getSubColumnName(columnFamily, columnFamilySpec.getChild(3));\n        }\n        // The parser groks an arbitrary number of these so it is possible to get here.\n        else\n        {\n            sessionState.out.println(\"Invalid row, super column, or column specification.\");\n            return;\n        }\n\n        AbstractType validator = getValidatorForValue(cfDef, TBaseHelper.byteBufferToByteArray(columnName));\n\n        // Perform a get()\n        ColumnPath path = new ColumnPath(columnFamily);\n        if(superColumnName != null) path.setSuper_column(superColumnName);\n        path.setColumn(columnName);\n        Column column;\n        try\n        {\n            column = thriftClient.get(key, path, consistencyLevel).column;\n        }\n        catch (NotFoundException e)\n        {\n            sessionState.out.println(\"Value was not found\");\n            return;\n        }\n\n        byte[] columnValue = column.getValue();       \n        String valueAsString;\n\n        // we have ^(CONVERT_TO_TYPE <type>) inside of GET statement\n        // which means that we should try to represent byte[] value according\n        // to specified type\n        if (typeTree != null)\n        {\n            // .getText() will give us <type>\n            String typeName = CliUtils.unescapeSQLString(typeTree.getText());\n            // building AbstractType from <type>\n            AbstractType valueValidator = getFormatTypeForColumn(typeName);\n\n            // setting value for output\n            valueAsString = valueValidator.getString(ByteBuffer.wrap(columnValue));\n            // updating column value validator class\n            updateColumnMetaData(cfDef, columnName, valueValidator.getClass().getName());\n        }\n        else\n        {\n            valueAsString = (validator == null) ? new String(columnValue, Charsets.UTF_8) : validator.getString(ByteBuffer.wrap(columnValue));\n        }\n\n        String formattedColumnName = isSuper\n                                     ? formatSubcolumnName(keySpace, columnFamily, column)\n                                     : formatColumnName(keySpace, columnFamily, column);\n\n        // print results\n        sessionState.out.printf(\"=> (column=%s, value=%s, timestamp=%d%s)%n\",\n                                formattedColumnName,\n                                valueAsString,\n                                column.timestamp,\n                                column.isSetTtl() ? String.format(\", ttl=%d\", column.getTtl()) : \"\");\n    }","commit_id":"4e6c0f6c6bc51ab0e35dbdd0b07017085682bc95","url":"https://github.com/apache/cassandra"},{"original_method":"private void doSlice(String keyspace, ByteBuffer key, String columnFamily, byte[] superColumnName)\n            throws InvalidRequestException, UnavailableException, TimedOutException, TException, IllegalAccessException, NotFoundException, InstantiationException, NoSuchFieldException\n    {\n        \n        ColumnParent parent = new ColumnParent(columnFamily);\n        if(superColumnName != null)\n            parent.setSuper_column(superColumnName);\n\n        SliceRange range = new SliceRange(ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1000000);\n        List<ColumnOrSuperColumn> columns = thriftClient.get_slice(key, parent, new SlicePredicate().setColumn_names(null).setSlice_range(range), consistencyLevel);\n\n        AbstractType validator;\n        CfDef cfDef = getCfDef(columnFamily);\n        boolean isSuperCF = cfDef.column_type.equals(\"Super\");\n\n        // Print out super columns or columns.\n        for (ColumnOrSuperColumn cosc : columns)\n        {\n            if (cosc.isSetSuper_column())\n            {\n                SuperColumn superColumn = cosc.super_column;\n\n                sessionState.out.printf(\"=> (super_column=%s,\", formatSuperColumnName(keyspace, columnFamily, superColumn));\n                for (Column col : superColumn.getColumns())\n                {\n                    validator = getValidatorForValue(cfDef, col.getName());\n                    sessionState.out.printf(\"%n     (column=%s, value=%s, timestamp=%d%s)\", formatSubcolumnName(keyspace, columnFamily, col),\n                                                    validator.getString(col.value), col.timestamp,\n                                                    col.isSetTtl() ? String.format(\", ttl=%d\", col.getTtl()) : \"\");\n                }\n                \n                sessionState.out.println(\")\");\n            }\n            else\n            {\n                Column column = cosc.column;\n                validator = getValidatorForValue(cfDef, column.getName());\n\n                String formattedName = isSuperCF\n                                       ? formatSubcolumnName(keyspace, columnFamily, column)\n                                       : formatColumnName(keyspace, columnFamily, column);\n\n                sessionState.out.printf(\"=> (column=%s, value=%s, timestamp=%d%s)%n\",\n                                        formattedName,\n                                        validator.getString(column.value),\n                                        column.timestamp,\n                                        column.isSetTtl() ? String.format(\", ttl=%d\", column.getTtl()) : \"\");\n            }\n        }\n        \n        sessionState.out.println(\"Returned \" + columns.size() + \" results.\");\n    }","id":49302,"modified_method":"private void doSlice(String keyspace, ByteBuffer key, String columnFamily, byte[] superColumnName, int limit)\n            throws InvalidRequestException, UnavailableException, TimedOutException, TException, IllegalAccessException, NotFoundException, InstantiationException, NoSuchFieldException\n    {\n        \n        ColumnParent parent = new ColumnParent(columnFamily);\n        if(superColumnName != null)\n            parent.setSuper_column(superColumnName);\n\n        SliceRange range = new SliceRange(ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, limit);\n        List<ColumnOrSuperColumn> columns = thriftClient.get_slice(key, parent, new SlicePredicate().setColumn_names(null).setSlice_range(range), consistencyLevel);\n\n        AbstractType validator;\n        CfDef cfDef = getCfDef(columnFamily);\n        boolean isSuperCF = cfDef.column_type.equals(\"Super\");\n\n        // Print out super columns or columns.\n        for (ColumnOrSuperColumn cosc : columns)\n        {\n            if (cosc.isSetSuper_column())\n            {\n                SuperColumn superColumn = cosc.super_column;\n\n                sessionState.out.printf(\"=> (super_column=%s,\", formatSuperColumnName(keyspace, columnFamily, superColumn));\n                for (Column col : superColumn.getColumns())\n                {\n                    validator = getValidatorForValue(cfDef, col.getName());\n                    sessionState.out.printf(\"%n     (column=%s, value=%s, timestamp=%d%s)\", formatSubcolumnName(keyspace, columnFamily, col),\n                                                    validator.getString(col.value), col.timestamp,\n                                                    col.isSetTtl() ? String.format(\", ttl=%d\", col.getTtl()) : \"\");\n                }\n                \n                sessionState.out.println(\")\");\n            }\n            else\n            {\n                Column column = cosc.column;\n                validator = getValidatorForValue(cfDef, column.getName());\n\n                String formattedName = isSuperCF\n                                       ? formatSubcolumnName(keyspace, columnFamily, column)\n                                       : formatColumnName(keyspace, columnFamily, column);\n\n                sessionState.out.printf(\"=> (column=%s, value=%s, timestamp=%d%s)%n\",\n                                        formattedName,\n                                        validator.getString(column.value),\n                                        column.timestamp,\n                                        column.isSetTtl() ? String.format(\", ttl=%d\", column.getTtl()) : \"\");\n            }\n        }\n        \n        sessionState.out.println(\"Returned \" + columns.size() + \" results.\");\n    }","commit_id":"4e6c0f6c6bc51ab0e35dbdd0b07017085682bc95","url":"https://github.com/apache/cassandra"},{"original_method":"protected Pair<Master, Machine> getMasterFromZooKeeper( boolean wait )\n    {\n        Machine master = getMasterBasedOn( getAllMachines( wait ).values() );\n        invalidateMaster();\n        MasterClient masterClient = master == Machine.NO_MACHINE || master.getMachineId() == getMyMachineId() ? null :\n                new MasterClient( master );\n        cachedMaster = new Pair<Master, Machine>( masterClient, master );\n        return cachedMaster;\n    }","id":49303,"modified_method":"protected Pair<Master, Machine> getMasterFromZooKeeper( boolean wait )\n    {\n        Machine master = getMasterBasedOn( getAllMachines( wait ).values() );\n        invalidateMaster();\n        MasterClient masterClient = null;\n        if ( master != Machine.NO_MACHINE && \n                master.getMachineId() != getMyMachineId() )\n        {\n            masterClient = new MasterClient( master );\n        }\n        cachedMaster = new Pair<Master, Machine>( masterClient, master );\n        return cachedMaster;\n    }","commit_id":"1c0b9cc99d0947810416c604a44f00ebc4d30f90","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n        {\n            return;\n        }\n        \n        try\n        {\n            System.out.println( \"reevaluateMyself \" + master );\n            if ( master == null )\n            {\n                System.out.println( \"looked up master \" + master );\n                master = broker.getMasterReally();\n            }\n            boolean iAmCurrentlyMaster = masterServer != null;\n            boolean restarted = false;\n            if ( cachedMaster.getMachineId() != master.other().getMachineId() )\n            {\n                // New master\n                if ( master.other().getMachineId() == machineId )\n                {\n                    // The new master is me, make sure I run as master\n                    if ( this.localGraph == null || !iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsMaster();\n                        restarted = true;\n                    }\n                }\n                else\n                {\n                    // Someone else got to be master, make sure I run as slave\n                    // The correct MasterClient has been provided to me from the broker\n                    if ( this.localGraph == null || iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsSlave();\n                        tryToEnsureIAmNotABrokenMachine( master );\n                        restarted = true;\n                    }\n                }\n            }\n            if ( masterServer != null )\n            {\n                broker.rebindMaster();\n            }\n            \n            if ( restarted )\n            {\n                for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n                {\n                    this.localGraph.registerTransactionEventHandler( handler );\n                }\n                for ( KernelEventHandler handler : kernelEventHandlers )\n                {\n                    this.localGraph.registerKernelEventHandler( handler );\n                }\n                this.localDataSourceManager =\n                        localGraph.getConfig().getTxModule().getXaDataSourceManager();\n            }\n            cachedMaster = master.other();\n            started = true;\n        }\n        finally\n        {\n            reevaluatingMyself.set( false );\n        }\n    }","id":49304,"modified_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n        {\n            return;\n        }\n        \n        try\n        {\n            System.out.println( \"reevaluateMyself machineId[\" + machineId + \"] with master[\" + master + \"]\" );\n            if ( master == null )\n            {\n                System.out.println( \"looked up master \" + master );\n                master = broker.getMasterReally();\n            }\n\n            boolean restarted = false;\n            boolean iAmCurrentlyMaster = masterServer != null;\n            if ( master.other().getMachineId() == machineId )\n            {\n                // I am master\n                if ( this.localGraph == null || !iAmCurrentlyMaster )\n                {\n                    internalShutdown();\n                    startAsMaster();\n                    restarted = true;\n                }\n                // fire rebound event\n                broker.rebindMaster();\n            }\n            else\n            {\n                if ( this.localGraph == null || iAmCurrentlyMaster )\n                {\n                    internalShutdown();\n                    startAsSlave();\n                    tryToEnsureIAmNotABrokenMachine( master );\n                    restarted = true;\n                }\n            }\n            \n            if ( restarted )\n            {\n                for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n                {\n                    this.localGraph.registerTransactionEventHandler( handler );\n                }\n                for ( KernelEventHandler handler : kernelEventHandlers )\n                {\n                    this.localGraph.registerKernelEventHandler( handler );\n                }\n                this.localDataSourceManager =\n                        localGraph.getConfig().getTxModule().getXaDataSourceManager();\n            }\n        }\n        finally\n        {\n            reevaluatingMyself.set( false );\n        }\n    }","commit_id":"1c0b9cc99d0947810416c604a44f00ebc4d30f90","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void startUp()\n    {\n//        broker.getMaster();\n//        long startTime = System.currentTimeMillis();\n//        while ( !started && System.currentTimeMillis()-startTime < 10000 )\n//        {\n//            try\n//            {\n//                Thread.sleep( 100 );\n//            }\n//            catch ( InterruptedException e )\n//            {\n//                Thread.interrupted();\n//            }\n//        }\n//        reevaluateMyself();\n    }","id":49305,"modified_method":"private void startUp()\n    {\n        for( int i = 0; i < 5 && localGraph == null; i++ )\n        {\n            try\n            {\n                Thread.sleep( 1000 );\n            }\n            catch ( InterruptedException e )\n            {\n                Thread.interrupted();\n            }\n        }\n    }","commit_id":"1c0b9cc99d0947810416c604a44f00ebc4d30f90","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n//        e.printStackTrace();\n//        new Thread()\n//        {\n//            @Override\n//            public void run()\n//            {\n                for ( int i = 0; i < 5; i++ )\n                {\n                    try\n                    {\n                        reevaluateMyself( master );\n                        break;\n                    }\n                    catch ( ZooKeeperException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( HaCommunicationException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( Throwable t )\n                    {\n                        t.printStackTrace();\n                        System.out.println( \"Reevaluation ended in unknown exception \" + t\n                                + \" so shutting down\" );\n                        shutdown();\n                    }\n                }\n//            }\n//        }.start();\n    }","id":49306,"modified_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n        try\n        {\n            reevaluateMyself( master );\n        }\n        catch ( ZooKeeperException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( HaCommunicationException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( Throwable t )\n        {\n            t.printStackTrace();\n            System.out.println( \"Reevaluation ended in unknown exception \" + t\n                    + \" so shutting down\" );\n            shutdown();\n        }\n    }","commit_id":"1c0b9cc99d0947810416c604a44f00ebc4d30f90","url":"https://github.com/neo4j/neo4j"},{"original_method":"public MasterClient( String hostNameOrIp, int port )\n    {\n        new Exception( \"Bg\" ).printStackTrace();\n        this.hostNameOrIp = hostNameOrIp;\n        this.port = port;\n        ExecutorService executor = Executors.newCachedThreadPool();\n        bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        bootstrap.setPipelineFactory( this );\n        System.out.println( \"Client connected to \" + hostNameOrIp + \":\" + port );\n    }","id":49307,"modified_method":"public MasterClient( String hostNameOrIp, int port )\n    {\n        this.hostNameOrIp = hostNameOrIp;\n        this.port = port;\n        ExecutorService executor = Executors.newCachedThreadPool();\n        bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        bootstrap.setPipelineFactory( this );\n        System.out.println( \"Client connected to \" + hostNameOrIp + \":\" + port );\n    }","commit_id":"1c0b9cc99d0947810416c604a44f00ebc4d30f90","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void shutdown()\n    {\n        // Close all open connections\n        deadConnectionsPoller.shutdown();\n        channelGroup.close().awaitUninterruptibly();\n        \n        // TODO This should work, but blocks with busy wait sometimes\n//        channelFactory.releaseExternalResources();\n    }","id":49308,"modified_method":"public void shutdown()\n    {\n        // Close all open connections\n        deadConnectionsPoller.shutdown();\n        System.out.println( \"Master server shutdown, closing all channels\" );\n        channelGroup.close().awaitUninterruptibly();\n        \n        // TODO This should work, but blocks with busy wait sometimes\n//        channelFactory.releaseExternalResources();\n    }","commit_id":"1c0b9cc99d0947810416c604a44f00ebc4d30f90","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ZooClient( String servers, int machineId, long storeCreationTime, \n        long storeId, long committedTx, ResponseReceiver receiver, String haServer )\n    {\n        super( servers );\n        this.rootPath = \"/\" + storeCreationTime + \"_\" + storeId;\n        this.haServer = haServer;\n        this.zooKeeper = instantiateZooKeeper();\n        this.receiver = receiver;\n        this.machineId = machineId;\n        this.committedTx = committedTx;\n        this.sequenceNr = \"not initialized yet\";\n    }","id":49309,"modified_method":"public ZooClient( String servers, int machineId, long storeCreationTime, \n        long storeId, long committedTx, ResponseReceiver receiver, String haServer )\n    {\n        super( servers );\n        this.rootPath = \"/\" + storeCreationTime + \"_\" + storeId;\n        this.haServer = haServer;\n        this.receiver = receiver;\n        this.machineId = machineId;\n        this.committedTx = committedTx;\n        this.sequenceNr = \"not initialized yet\";\n        this.zooKeeper = instantiateZooKeeper();\n    }","commit_id":"1c0b9cc99d0947810416c604a44f00ebc4d30f90","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                Pair<Master, Machine> cachedMaster = getCachedMaster();\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                System.out.println( \"Get master before write:\" + masterBeforeIWrite );\n                sequenceNr = setup();\n                System.out.println( \"did setup\" );\n                keeperState = KeeperState.SyncConnected;\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( false );\n                System.out.println( \"current master \" + currentMaster );\n                \n                // Master has changed since last time I checked and it's not me\n                if ( (cachedMaster.other().getMachineId() == -1 || currentMaster.other().getMachineId() != masterBeforeIWrite.other().getMachineId()) &&\n                        currentMaster.other().getMachineId() != machineId )\n                {\n                    System.out.println( \"Master changed and it's not me\" );\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, currentMaster.other().getMachineId() );\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n                else if ( /*masterBeforeIWrite.other().getMachineId() == -1  && */\n                        currentMaster.other().getMachineId() == machineId )\n                {\n                    System.out.println( \"2\" );\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    System.out.println( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            e.printStackTrace();\n            throw e;\n        }\n    }","id":49310,"modified_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                System.out.println( \"Get master before write:\" + masterBeforeIWrite );\n                sequenceNr = setup();\n                System.out.println( \"did setup\" );\n                keeperState = KeeperState.SyncConnected;\n                Pair<Master, Machine> masterAfterIWrote = getMasterFromZooKeeper( false );\n                System.out.println( \"Get master after write:\" + masterAfterIWrote );\n                int masterId = masterAfterIWrote.other().getMachineId();\n                if ( masterBeforeIWrite.other().getMachineId() != masterId && masterId != machineId )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, masterId );\n                }\n                receiver.newMaster( masterAfterIWrote, new Exception() );\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    System.out.println( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            e.printStackTrace();\n            throw e;\n        }\n    }","commit_id":"1c0b9cc99d0947810416c604a44f00ebc4d30f90","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected Pair<Master, Machine> getMasterFromZooKeeper( boolean wait )\n    {\n        Machine master = getMasterBasedOn( getAllMachines( wait ).values() );\n        invalidateMaster();\n        MasterClient masterClient = master == Machine.NO_MACHINE || master.getMachineId() == getMyMachineId() ? null :\n                new MasterClient( master );\n        cachedMaster = new Pair<Master, Machine>( masterClient, master );\n        return cachedMaster;\n    }","id":49311,"modified_method":"protected Pair<Master, Machine> getMasterFromZooKeeper( boolean wait )\n    {\n        Machine master = getMasterBasedOn( getAllMachines( wait ).values() );\n        invalidateMaster();\n        MasterClient masterClient = null;\n        if ( master != Machine.NO_MACHINE && \n                master.getMachineId() != getMyMachineId() )\n        {\n            masterClient = new MasterClient( master );\n        }\n        cachedMaster = new Pair<Master, Machine>( masterClient, master );\n        return cachedMaster;\n    }","commit_id":"43b9fa007c83d9d65d00883bb85c62fe5a250d1a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n//        e.printStackTrace();\n//        new Thread()\n//        {\n//            @Override\n//            public void run()\n//            {\n                for ( int i = 0; i < 5; i++ )\n                {\n                    try\n                    {\n                        reevaluateMyself( master );\n                        break;\n                    }\n                    catch ( ZooKeeperException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( HaCommunicationException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( Throwable t )\n                    {\n                        t.printStackTrace();\n                        System.out.println( \"Reevaluation ended in unknown exception \" + t\n                                + \" so shutting down\" );\n                        shutdown();\n                    }\n                }\n//            }\n//        }.start();\n    }","id":49312,"modified_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n        try\n        {\n            reevaluateMyself( master );\n        }\n        catch ( ZooKeeperException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( HaCommunicationException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( Throwable t )\n        {\n            t.printStackTrace();\n            System.out.println( \"Reevaluation ended in unknown exception \" + t\n                    + \" so shutting down\" );\n            shutdown();\n        }\n    }","commit_id":"43b9fa007c83d9d65d00883bb85c62fe5a250d1a","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n        {\n            return;\n        }\n        \n        try\n        {\n            System.out.println( \"reevaluateMyself \" + master );\n            if ( master == null )\n            {\n                System.out.println( \"looked up master \" + master );\n                master = broker.getMasterReally();\n            }\n            boolean iAmCurrentlyMaster = masterServer != null;\n            boolean restarted = false;\n            if ( cachedMaster.getMachineId() != master.other().getMachineId() )\n            {\n                // New master\n                if ( master.other().getMachineId() == machineId )\n                {\n                    // The new master is me, make sure I run as master\n                    if ( this.localGraph == null || !iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsMaster();\n                        restarted = true;\n                    }\n                }\n                else\n                {\n                    // Someone else got to be master, make sure I run as slave\n                    // The correct MasterClient has been provided to me from the broker\n                    if ( this.localGraph == null || iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsSlave();\n                        tryToEnsureIAmNotABrokenMachine( master );\n                        restarted = true;\n                    }\n                }\n            }\n            if ( masterServer != null )\n            {\n                broker.rebindMaster();\n            }\n            \n            if ( restarted )\n            {\n                for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n                {\n                    this.localGraph.registerTransactionEventHandler( handler );\n                }\n                for ( KernelEventHandler handler : kernelEventHandlers )\n                {\n                    this.localGraph.registerKernelEventHandler( handler );\n                }\n                this.localDataSourceManager =\n                        localGraph.getConfig().getTxModule().getXaDataSourceManager();\n            }\n            cachedMaster = master.other();\n            started = true;\n        }\n        finally\n        {\n            reevaluatingMyself.set( false );\n        }\n    }","id":49313,"modified_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n        {\n            return;\n        }\n        \n        try\n        {\n            System.out.println( \"reevaluateMyself machineId[\" + machineId + \"] with master[\" + master + \"]\" );\n            if ( master == null )\n            {\n                System.out.println( \"looked up master \" + master );\n                master = broker.getMasterReally();\n            }\n\n            boolean restarted = false;\n            boolean iAmCurrentlyMaster = masterServer != null;\n            if ( master.other().getMachineId() == machineId )\n            {\n                // I am master\n                if ( this.localGraph == null || !iAmCurrentlyMaster )\n                {\n                    internalShutdown();\n                    startAsMaster();\n                    restarted = true;\n                }\n                // fire rebound event\n                broker.rebindMaster();\n            }\n            else\n            {\n                if ( this.localGraph == null || iAmCurrentlyMaster )\n                {\n                    internalShutdown();\n                    startAsSlave();\n                    tryToEnsureIAmNotABrokenMachine( master );\n                    restarted = true;\n                }\n            }\n            \n            if ( restarted )\n            {\n                for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n                {\n                    this.localGraph.registerTransactionEventHandler( handler );\n                }\n                for ( KernelEventHandler handler : kernelEventHandlers )\n                {\n                    this.localGraph.registerKernelEventHandler( handler );\n                }\n                this.localDataSourceManager =\n                        localGraph.getConfig().getTxModule().getXaDataSourceManager();\n            }\n        }\n        finally\n        {\n            reevaluatingMyself.set( false );\n        }\n    }","commit_id":"43b9fa007c83d9d65d00883bb85c62fe5a250d1a","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void startUp()\n    {\n//        broker.getMaster();\n//        long startTime = System.currentTimeMillis();\n//        while ( !started && System.currentTimeMillis()-startTime < 10000 )\n//        {\n//            try\n//            {\n//                Thread.sleep( 100 );\n//            }\n//            catch ( InterruptedException e )\n//            {\n//                Thread.interrupted();\n//            }\n//        }\n//        reevaluateMyself();\n    }","id":49314,"modified_method":"private void startUp()\n    {\n        for( int i = 0; i < 5 && localGraph == null; i++ )\n        {\n            try\n            {\n                Thread.sleep( 1000 );\n            }\n            catch ( InterruptedException e )\n            {\n                Thread.interrupted();\n            }\n        }\n    }","commit_id":"43b9fa007c83d9d65d00883bb85c62fe5a250d1a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public MasterClient( String hostNameOrIp, int port )\n    {\n        new Exception( \"Bg\" ).printStackTrace();\n        this.hostNameOrIp = hostNameOrIp;\n        this.port = port;\n        ExecutorService executor = Executors.newCachedThreadPool();\n        bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        bootstrap.setPipelineFactory( this );\n        System.out.println( \"Client connected to \" + hostNameOrIp + \":\" + port );\n    }","id":49315,"modified_method":"public MasterClient( String hostNameOrIp, int port )\n    {\n        this.hostNameOrIp = hostNameOrIp;\n        this.port = port;\n        ExecutorService executor = Executors.newCachedThreadPool();\n        bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        bootstrap.setPipelineFactory( this );\n        System.out.println( \"Client connected to \" + hostNameOrIp + \":\" + port );\n    }","commit_id":"43b9fa007c83d9d65d00883bb85c62fe5a250d1a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void shutdown()\n    {\n        // Close all open connections\n        deadConnectionsPoller.shutdown();\n        channelGroup.close().awaitUninterruptibly();\n        \n        // TODO This should work, but blocks with busy wait sometimes\n//        channelFactory.releaseExternalResources();\n    }","id":49316,"modified_method":"public void shutdown()\n    {\n        // Close all open connections\n        deadConnectionsPoller.shutdown();\n        System.out.println( \"Master server shutdown, closing all channels\" );\n        channelGroup.close().awaitUninterruptibly();\n        \n        // TODO This should work, but blocks with busy wait sometimes\n//        channelFactory.releaseExternalResources();\n    }","commit_id":"43b9fa007c83d9d65d00883bb85c62fe5a250d1a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ZooClient( String servers, int machineId, long storeCreationTime, \n        long storeId, long committedTx, ResponseReceiver receiver, String haServer )\n    {\n        super( servers );\n        this.rootPath = \"/\" + storeCreationTime + \"_\" + storeId;\n        this.haServer = haServer;\n        this.zooKeeper = instantiateZooKeeper();\n        this.receiver = receiver;\n        this.machineId = machineId;\n        this.committedTx = committedTx;\n        this.sequenceNr = \"not initialized yet\";\n    }","id":49317,"modified_method":"public ZooClient( String servers, int machineId, long storeCreationTime, \n        long storeId, long committedTx, ResponseReceiver receiver, String haServer )\n    {\n        super( servers );\n        this.rootPath = \"/\" + storeCreationTime + \"_\" + storeId;\n        this.haServer = haServer;\n        this.receiver = receiver;\n        this.machineId = machineId;\n        this.committedTx = committedTx;\n        this.sequenceNr = \"not initialized yet\";\n        this.zooKeeper = instantiateZooKeeper();\n    }","commit_id":"43b9fa007c83d9d65d00883bb85c62fe5a250d1a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                Pair<Master, Machine> cachedMaster = getCachedMaster();\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                System.out.println( \"Get master before write:\" + masterBeforeIWrite );\n                sequenceNr = setup();\n                System.out.println( \"did setup\" );\n                keeperState = KeeperState.SyncConnected;\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( false );\n                System.out.println( \"current master \" + currentMaster );\n                \n                // Master has changed since last time I checked and it's not me\n                if ( (cachedMaster.other().getMachineId() == -1 || currentMaster.other().getMachineId() != masterBeforeIWrite.other().getMachineId()) &&\n                        currentMaster.other().getMachineId() != machineId )\n                {\n                    System.out.println( \"Master changed and it's not me\" );\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, currentMaster.other().getMachineId() );\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n                else if ( /*masterBeforeIWrite.other().getMachineId() == -1  && */\n                        currentMaster.other().getMachineId() == machineId )\n                {\n                    System.out.println( \"2\" );\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    System.out.println( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            e.printStackTrace();\n            throw e;\n        }\n    }","id":49318,"modified_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                System.out.println( \"Get master before write:\" + masterBeforeIWrite );\n                sequenceNr = setup();\n                System.out.println( \"did setup\" );\n                keeperState = KeeperState.SyncConnected;\n                Pair<Master, Machine> masterAfterIWrote = getMasterFromZooKeeper( false );\n                System.out.println( \"Get master after write:\" + masterAfterIWrote );\n                int masterId = masterAfterIWrote.other().getMachineId();\n                if ( masterBeforeIWrite.other().getMachineId() != masterId && masterId != machineId )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, masterId );\n                }\n                receiver.newMaster( masterAfterIWrote, new Exception() );\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    System.out.println( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            e.printStackTrace();\n            throw e;\n        }\n    }","commit_id":"43b9fa007c83d9d65d00883bb85c62fe5a250d1a","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected Pair<Master, Machine> getMasterFromZooKeeper( boolean wait )\n    {\n        Machine master = getMasterBasedOn( getAllMachines( wait ).values() );\n        invalidateMaster();\n        MasterClient masterClient = master == Machine.NO_MACHINE || master.getMachineId() == getMyMachineId() ? null :\n                new MasterClient( master );\n        cachedMaster = new Pair<Master, Machine>( masterClient, master );\n        return cachedMaster;\n    }","id":49319,"modified_method":"protected Pair<Master, Machine> getMasterFromZooKeeper( boolean wait )\n    {\n        Machine master = getMasterBasedOn( getAllMachines( wait ).values() );\n        invalidateMaster();\n        MasterClient masterClient = null;\n        if ( master != Machine.NO_MACHINE && \n                master.getMachineId() != getMyMachineId() )\n        {\n            masterClient = new MasterClient( master );\n        }\n        cachedMaster = new Pair<Master, Machine>( masterClient, master );\n        return cachedMaster;\n    }","commit_id":"a00f9747d5d2a2c45a559699b0a46e6de0890420","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void startUp()\n    {\n//        broker.getMaster();\n//        long startTime = System.currentTimeMillis();\n//        while ( !started && System.currentTimeMillis()-startTime < 10000 )\n//        {\n//            try\n//            {\n//                Thread.sleep( 100 );\n//            }\n//            catch ( InterruptedException e )\n//            {\n//                Thread.interrupted();\n//            }\n//        }\n//        reevaluateMyself();\n    }","id":49320,"modified_method":"private void startUp()\n    {\n        for( int i = 0; i < 5 && localGraph == null; i++ )\n        {\n            try\n            {\n                Thread.sleep( 1000 );\n            }\n            catch ( InterruptedException e )\n            {\n                Thread.interrupted();\n            }\n        }\n    }","commit_id":"a00f9747d5d2a2c45a559699b0a46e6de0890420","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n//        e.printStackTrace();\n//        new Thread()\n//        {\n//            @Override\n//            public void run()\n//            {\n                for ( int i = 0; i < 5; i++ )\n                {\n                    try\n                    {\n                        reevaluateMyself( master );\n                        break;\n                    }\n                    catch ( ZooKeeperException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( HaCommunicationException ee )\n                    {\n                        ee.printStackTrace();\n                    }\n                    catch ( Throwable t )\n                    {\n                        t.printStackTrace();\n                        System.out.println( \"Reevaluation ended in unknown exception \" + t\n                                + \" so shutting down\" );\n                        shutdown();\n                    }\n                }\n//            }\n//        }.start();\n    }","id":49321,"modified_method":"public void newMaster( Pair<Master, Machine> master, Exception e )\n    {\n        try\n        {\n            reevaluateMyself( master );\n        }\n        catch ( ZooKeeperException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( HaCommunicationException ee )\n        {\n            ee.printStackTrace();\n        }\n        catch ( Throwable t )\n        {\n            t.printStackTrace();\n            System.out.println( \"Reevaluation ended in unknown exception \" + t\n                    + \" so shutting down\" );\n            shutdown();\n        }\n    }","commit_id":"a00f9747d5d2a2c45a559699b0a46e6de0890420","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n        {\n            return;\n        }\n        \n        try\n        {\n            System.out.println( \"reevaluateMyself \" + master );\n            if ( master == null )\n            {\n                System.out.println( \"looked up master \" + master );\n                master = broker.getMasterReally();\n            }\n            boolean iAmCurrentlyMaster = masterServer != null;\n            boolean restarted = false;\n            if ( cachedMaster.getMachineId() != master.other().getMachineId() )\n            {\n                // New master\n                if ( master.other().getMachineId() == machineId )\n                {\n                    // The new master is me, make sure I run as master\n                    if ( this.localGraph == null || !iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsMaster();\n                        restarted = true;\n                    }\n                }\n                else\n                {\n                    // Someone else got to be master, make sure I run as slave\n                    // The correct MasterClient has been provided to me from the broker\n                    if ( this.localGraph == null || iAmCurrentlyMaster )\n                    {\n                        internalShutdown();\n                        startAsSlave();\n                        tryToEnsureIAmNotABrokenMachine( master );\n                        restarted = true;\n                    }\n                }\n            }\n            if ( masterServer != null )\n            {\n                broker.rebindMaster();\n            }\n            \n            if ( restarted )\n            {\n                for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n                {\n                    this.localGraph.registerTransactionEventHandler( handler );\n                }\n                for ( KernelEventHandler handler : kernelEventHandlers )\n                {\n                    this.localGraph.registerKernelEventHandler( handler );\n                }\n                this.localDataSourceManager =\n                        localGraph.getConfig().getTxModule().getXaDataSourceManager();\n            }\n            cachedMaster = master.other();\n            started = true;\n        }\n        finally\n        {\n            reevaluatingMyself.set( false );\n        }\n    }","id":49322,"modified_method":"protected synchronized void reevaluateMyself( Pair<Master, Machine> master )\n    {\n        if ( !reevaluatingMyself.compareAndSet( false, true ) )\n        {\n            return;\n        }\n        \n        try\n        {\n            System.out.println( \"reevaluateMyself machineId[\" + machineId + \"] with master[\" + master + \"]\" );\n            if ( master == null )\n            {\n                System.out.println( \"looked up master \" + master );\n                master = broker.getMasterReally();\n            }\n\n            boolean restarted = false;\n            boolean iAmCurrentlyMaster = masterServer != null;\n            if ( master.other().getMachineId() == machineId )\n            {\n                // I am master\n                if ( this.localGraph == null || !iAmCurrentlyMaster )\n                {\n                    internalShutdown();\n                    startAsMaster();\n                    restarted = true;\n                }\n                // fire rebound event\n                broker.rebindMaster();\n            }\n            else\n            {\n                if ( this.localGraph == null || iAmCurrentlyMaster )\n                {\n                    internalShutdown();\n                    startAsSlave();\n                    tryToEnsureIAmNotABrokenMachine( master );\n                    restarted = true;\n                }\n            }\n            \n            if ( restarted )\n            {\n                for ( TransactionEventHandler<?> handler : transactionEventHandlers )\n                {\n                    this.localGraph.registerTransactionEventHandler( handler );\n                }\n                for ( KernelEventHandler handler : kernelEventHandlers )\n                {\n                    this.localGraph.registerKernelEventHandler( handler );\n                }\n                this.localDataSourceManager =\n                        localGraph.getConfig().getTxModule().getXaDataSourceManager();\n            }\n        }\n        finally\n        {\n            reevaluatingMyself.set( false );\n        }\n    }","commit_id":"a00f9747d5d2a2c45a559699b0a46e6de0890420","url":"https://github.com/neo4j/neo4j"},{"original_method":"public MasterClient( String hostNameOrIp, int port )\n    {\n        new Exception( \"Bg\" ).printStackTrace();\n        this.hostNameOrIp = hostNameOrIp;\n        this.port = port;\n        ExecutorService executor = Executors.newCachedThreadPool();\n        bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        bootstrap.setPipelineFactory( this );\n        System.out.println( \"Client connected to \" + hostNameOrIp + \":\" + port );\n    }","id":49323,"modified_method":"public MasterClient( String hostNameOrIp, int port )\n    {\n        this.hostNameOrIp = hostNameOrIp;\n        this.port = port;\n        ExecutorService executor = Executors.newCachedThreadPool();\n        bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        bootstrap.setPipelineFactory( this );\n        System.out.println( \"Client connected to \" + hostNameOrIp + \":\" + port );\n    }","commit_id":"a00f9747d5d2a2c45a559699b0a46e6de0890420","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void shutdown()\n    {\n        // Close all open connections\n        deadConnectionsPoller.shutdown();\n        channelGroup.close().awaitUninterruptibly();\n        \n        // TODO This should work, but blocks with busy wait sometimes\n//        channelFactory.releaseExternalResources();\n    }","id":49324,"modified_method":"public void shutdown()\n    {\n        // Close all open connections\n        deadConnectionsPoller.shutdown();\n        System.out.println( \"Master server shutdown, closing all channels\" );\n        channelGroup.close().awaitUninterruptibly();\n        \n        // TODO This should work, but blocks with busy wait sometimes\n//        channelFactory.releaseExternalResources();\n    }","commit_id":"a00f9747d5d2a2c45a559699b0a46e6de0890420","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ZooClient( String servers, int machineId, long storeCreationTime, \n        long storeId, long committedTx, ResponseReceiver receiver, String haServer )\n    {\n        super( servers );\n        this.rootPath = \"/\" + storeCreationTime + \"_\" + storeId;\n        this.haServer = haServer;\n        this.zooKeeper = instantiateZooKeeper();\n        this.receiver = receiver;\n        this.machineId = machineId;\n        this.committedTx = committedTx;\n        this.sequenceNr = \"not initialized yet\";\n    }","id":49325,"modified_method":"public ZooClient( String servers, int machineId, long storeCreationTime, \n        long storeId, long committedTx, ResponseReceiver receiver, String haServer )\n    {\n        super( servers );\n        this.rootPath = \"/\" + storeCreationTime + \"_\" + storeId;\n        this.haServer = haServer;\n        this.receiver = receiver;\n        this.machineId = machineId;\n        this.committedTx = committedTx;\n        this.sequenceNr = \"not initialized yet\";\n        this.zooKeeper = instantiateZooKeeper();\n    }","commit_id":"a00f9747d5d2a2c45a559699b0a46e6de0890420","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                Pair<Master, Machine> cachedMaster = getCachedMaster();\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                System.out.println( \"Get master before write:\" + masterBeforeIWrite );\n                sequenceNr = setup();\n                System.out.println( \"did setup\" );\n                keeperState = KeeperState.SyncConnected;\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( false );\n                System.out.println( \"current master \" + currentMaster );\n                \n                // Master has changed since last time I checked and it's not me\n                if ( (cachedMaster.other().getMachineId() == -1 || currentMaster.other().getMachineId() != masterBeforeIWrite.other().getMachineId()) &&\n                        currentMaster.other().getMachineId() != machineId )\n                {\n                    System.out.println( \"Master changed and it's not me\" );\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, currentMaster.other().getMachineId() );\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n                else if ( /*masterBeforeIWrite.other().getMachineId() == -1  && */\n                        currentMaster.other().getMachineId() == machineId )\n                {\n                    System.out.println( \"2\" );\n                    receiver.newMaster( currentMaster, new Exception() );\n                }\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    System.out.println( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            e.printStackTrace();\n            throw e;\n        }\n    }","id":49326,"modified_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            System.out.println( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                System.out.println( \"Get master before write:\" + masterBeforeIWrite );\n                sequenceNr = setup();\n                System.out.println( \"did setup\" );\n                keeperState = KeeperState.SyncConnected;\n                Pair<Master, Machine> masterAfterIWrote = getMasterFromZooKeeper( false );\n                System.out.println( \"Get master after write:\" + masterAfterIWrote );\n                int masterId = masterAfterIWrote.other().getMachineId();\n                if ( masterBeforeIWrite.other().getMachineId() != masterId && masterId != machineId )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, masterId );\n                }\n                receiver.newMaster( masterAfterIWrote, new Exception() );\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    System.out.println( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            e.printStackTrace();\n            throw e;\n        }\n    }","commit_id":"a00f9747d5d2a2c45a559699b0a46e6de0890420","url":"https://github.com/neo4j/neo4j"},{"original_method":"public LocalCluster(String jarFileName,\n                        int siteCount,\n                        int hostCount,\n                        int kfactor,\n                        BackendTarget target,\n                        FailureState failureState,\n                        boolean debug,\n                        boolean isRejoinTest,\n                        Map<String, String> env)\n    {\n        assert (jarFileName != null);\n        assert (siteCount > 0);\n        assert (hostCount > 0);\n\n        m_additionalProcessEnv = env;\n        // get the name of the calling class\n        StackTraceElement[] traces = Thread.currentThread().getStackTrace();\n        m_callingClassName = \"UnknownClass\";\n        m_callingMethodName = \"unknownMethod\";\n        //ArrayUtils.reverse(traces);\n        int i;\n        // skip all stack frames below this method\n        for (i = 0; traces[i].getClassName().equals(getClass().getName()) == false; i++);\n        // skip all stack frames from localcluster itself\n        for (;      traces[i].getClassName().equals(getClass().getName()); i++);\n        // skip the package name\n        int dot = traces[i].getClassName().lastIndexOf('.');\n        m_callingClassName = traces[i].getClassName().substring(dot + 1);\n        m_callingMethodName = traces[i].getMethodName();\n\n        log.info(\"Instantiating LocalCluster for \" + jarFileName + \" with class.method: \" +\n                m_callingClassName + \".\" + m_callingMethodName);\n        log.info(\"Sites: \" + siteCount + \" hosts: \" + hostCount + \" replication factor: \" + kfactor);\n\n        m_cluster.ensureCapacity(hostCount);\n\n        m_siteCount = siteCount;\n        m_hostCount = hostCount;\n        if (kfactor > 0 && !MiscUtils.isPro()) {\n            m_kfactor = 0;\n        } else {\n            m_kfactor = kfactor;\n        }\n        m_debug = debug;\n        m_jarFileName = jarFileName;\n        m_failureState = m_kfactor < 1 ? FailureState.ALL_RUNNING : failureState;\n        m_pipes = new ArrayList<PipeToFile>();\n        m_cmdLines = new ArrayList<CommandLine>();\n\n        // if the user wants valgrind and it makes sense, give it to 'em\n        // For now only one host works.\n        if (isMemcheckDefined() && (target == BackendTarget.NATIVE_EE_JNI) && m_hostCount == 1) {\n            m_target = BackendTarget.NATIVE_EE_VALGRIND_IPC;\n        }\n        else {\n            m_target = target;\n        }\n\n        String buildDir = System.getenv(\"VOLTDB_BUILD_DIR\");  // via build.xml\n        if (buildDir == null) {\n            buildDir = System.getProperty(\"user.dir\") + \"/obj/release\";\n        }\n\n        String classPath = System.getProperty(\"java.class.path\") + \":\" +\n            buildDir + File.separator + m_jarFileName;\n\n        String javaLibraryPath = null;\n        if (m_additionalProcessEnv != null && m_additionalProcessEnv.containsKey(EELibraryLoader.USE_JAVA_LIBRARY_PATH)) {\n            if (Boolean.parseBoolean(m_additionalProcessEnv.get(EELibraryLoader.USE_JAVA_LIBRARY_PATH))) {\n                // set the java lib path to the one for this process - Add obj/release/nativelibs\n                javaLibraryPath = System.getProperty(\"java.library.path\");\n                if (javaLibraryPath == null || javaLibraryPath.trim().length() == 0) {\n                    javaLibraryPath = buildDir + \"/nativelibs\";\n                } else {\n                    javaLibraryPath += \":\" + buildDir + \"/nativelibs\";\n                }\n            }\n        }\n\n        if (javaLibraryPath==null) {\n            // need this in classpath to find native library. Otherwise, don't add it to classpath to\n            // test override of loading EE lib from jar.\n            classPath = classPath + \":\" + buildDir + File.separator + \"prod\";\n        }\n\n        // Remove the stored procedures from the classpath.  Out-of-process nodes will\n        // only be able to find procedures and dependent classes in the catalog, as intended\n        classPath = classPath.replace(buildDir + File.separator + \"testprocs:\", \"\");\n\n        // First try 'ant' syntax and then 'eclipse' syntax...\n        String log4j = System.getProperty(\"log4j.configuration\");\n        if (log4j == null) {\n            log4j = \"file://\" + System.getProperty(\"user.dir\") + \"/tests/log4j-allconsole.xml\";\n        }\n\n        m_procBuilder = new ProcessBuilder();\n\n        // set the working directory to obj/release/prod\n        //m_procBuilder.directory(new File(m_buildDir + File.separator + \"prod\"));\n        m_procBuilder.redirectErrorStream(true);\n\n        Thread shutdownThread = new Thread(new ShutDownHookThread());\n        java.lang.Runtime.getRuntime().addShutdownHook(shutdownThread);\n\n        // Create the base command line that each process can makeCopy and modify\n        this.templateCmdLine.\n            addTestOptions(true).\n            leader(\"\").\n            target(m_target).\n            startCommand(\"create\").\n            jarFileName(VoltDB.Configuration.getPathToCatalogForTest(m_jarFileName)).\n            buildDir(buildDir).\n            classPath(classPath).\n            pathToLicense(ServerThread.getTestLicensePath()).\n            log4j(log4j);\n        if (javaLibraryPath!=null) {\n            templateCmdLine.javaLibraryPath(javaLibraryPath);\n        }\n        this.templateCmdLine.m_noLoadLibVOLTDB = m_target == BackendTarget.HSQLDB_BACKEND;\n        // \"tag\" this command line so it's clear which test started it\n        this.templateCmdLine.m_tag = m_callingClassName + \":\" + m_callingMethodName;\n    }","id":49327,"modified_method":"public LocalCluster(String jarFileName,\n                        int siteCount,\n                        int hostCount,\n                        int kfactor,\n                        BackendTarget target,\n                        FailureState failureState,\n                        boolean debug,\n                        boolean isRejoinTest,\n                        Map<String, String> env)\n    {\n        assert (jarFileName != null);\n        assert (siteCount > 0);\n        assert (hostCount > 0);\n\n        m_additionalProcessEnv = env==null ? new HashMap<String, String>() : env;\n        if (Boolean.getBoolean(EELibraryLoader.USE_JAVA_LIBRARY_PATH)) {\n            // set use.javalib for LocalCluster so that Eclipse runs will be OK.\n            m_additionalProcessEnv.put(EELibraryLoader.USE_JAVA_LIBRARY_PATH, \"true\");\n        }\n        // get the name of the calling class\n        StackTraceElement[] traces = Thread.currentThread().getStackTrace();\n        m_callingClassName = \"UnknownClass\";\n        m_callingMethodName = \"unknownMethod\";\n        //ArrayUtils.reverse(traces);\n        int i;\n        // skip all stack frames below this method\n        for (i = 0; traces[i].getClassName().equals(getClass().getName()) == false; i++);\n        // skip all stack frames from localcluster itself\n        for (;      traces[i].getClassName().equals(getClass().getName()); i++);\n        // skip the package name\n        int dot = traces[i].getClassName().lastIndexOf('.');\n        m_callingClassName = traces[i].getClassName().substring(dot + 1);\n        m_callingMethodName = traces[i].getMethodName();\n\n        log.info(\"Instantiating LocalCluster for \" + jarFileName + \" with class.method: \" +\n                m_callingClassName + \".\" + m_callingMethodName);\n        log.info(\"Sites: \" + siteCount + \" hosts: \" + hostCount + \" replication factor: \" + kfactor);\n\n        m_cluster.ensureCapacity(hostCount);\n\n        m_siteCount = siteCount;\n        m_hostCount = hostCount;\n        if (kfactor > 0 && !MiscUtils.isPro()) {\n            m_kfactor = 0;\n        } else {\n            m_kfactor = kfactor;\n        }\n        m_debug = debug;\n        m_jarFileName = jarFileName;\n        m_failureState = m_kfactor < 1 ? FailureState.ALL_RUNNING : failureState;\n        m_pipes = new ArrayList<PipeToFile>();\n        m_cmdLines = new ArrayList<CommandLine>();\n\n        // if the user wants valgrind and it makes sense, give it to 'em\n        // For now only one host works.\n        if (isMemcheckDefined() && (target == BackendTarget.NATIVE_EE_JNI) && m_hostCount == 1) {\n            m_target = BackendTarget.NATIVE_EE_VALGRIND_IPC;\n        }\n        else {\n            m_target = target;\n        }\n\n        String buildDir = System.getenv(\"VOLTDB_BUILD_DIR\");  // via build.xml\n        if (buildDir == null) {\n            buildDir = System.getProperty(\"user.dir\") + \"/obj/release\";\n        }\n\n        String classPath = System.getProperty(\"java.class.path\") + \":\" +\n                buildDir + File.separator + m_jarFileName + \":\" + buildDir + File.separator + \"prod\";\n\n        // set the java lib path to the one for this process - Add obj/release/nativelibs\n        String javaLibraryPath = System.getProperty(\"java.library.path\");\n        if (javaLibraryPath == null || javaLibraryPath.trim().length() == 0) {\n            javaLibraryPath = buildDir + \"/nativelibs\";\n        } else {\n            javaLibraryPath += \":\" + buildDir + \"/nativelibs\";\n        }\n\n        // Remove the stored procedures from the classpath.  Out-of-process nodes will\n        // only be able to find procedures and dependent classes in the catalog, as intended\n        classPath = classPath.replace(buildDir + File.separator + \"testprocs:\", \"\");\n\n        // First try 'ant' syntax and then 'eclipse' syntax...\n        String log4j = System.getProperty(\"log4j.configuration\");\n        if (log4j == null) {\n            log4j = \"file://\" + System.getProperty(\"user.dir\") + \"/tests/log4j-allconsole.xml\";\n        }\n\n        m_procBuilder = new ProcessBuilder();\n\n        // set the working directory to obj/release/prod\n        //m_procBuilder.directory(new File(m_buildDir + File.separator + \"prod\"));\n        m_procBuilder.redirectErrorStream(true);\n\n        Thread shutdownThread = new Thread(new ShutDownHookThread());\n        java.lang.Runtime.getRuntime().addShutdownHook(shutdownThread);\n\n        // Create the base command line that each process can makeCopy and modify\n        this.templateCmdLine.\n            addTestOptions(true).\n            leader(\"\").\n            target(m_target).\n            startCommand(\"create\").\n            jarFileName(VoltDB.Configuration.getPathToCatalogForTest(m_jarFileName)).\n            buildDir(buildDir).\n            classPath(classPath).\n            pathToLicense(ServerThread.getTestLicensePath()).\n            log4j(log4j);\n        if (javaLibraryPath!=null) {\n            templateCmdLine.javaLibraryPath(javaLibraryPath);\n        }\n        this.templateCmdLine.m_noLoadLibVOLTDB = m_target == BackendTarget.HSQLDB_BACKEND;\n        // \"tag\" this command line so it's clear which test started it\n        this.templateCmdLine.m_tag = m_callingClassName + \":\" + m_callingMethodName;\n    }","commit_id":"f273ebeeec0ed652df15b794af33717f46fe7cfd","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private boolean recoverOne(boolean logtime, long startTime, int hostId, Integer rejoinHostId,\n                               String rejoinHost, StartAction startAction) {\n        // Lookup the client interface port of the rejoin host\n        // I have no idea why this code ignores the user's input\n        // based on other state in this class except to say that whoever wrote\n        // it this way originally probably eats kittens and hates cake.\n        if (rejoinHostId == null || m_hasLocalServer) {\n            rejoinHostId = 0;\n        }\n\n        int portNoToRejoin = m_cmdLines.get(rejoinHostId).internalPort();\n\n        if (hostId == 0 && m_hasLocalServer) {\n            templateCmdLine.leaderPort(portNoToRejoin);\n            startLocalServer(rejoinHostId, false, StartAction.REJOIN);\n            return true;\n        }\n\n        log.info(\"Rejoining \" + hostId + \" to hostID: \" + rejoinHostId);\n\n        // rebuild the EE proc set.\n        EEProcess eeProc = m_eeProcs.get(hostId);\n        try {\n            eeProc.waitForShutdown();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        if (templateCmdLine.target().isIPC) {\n            String logfile = \"LocalCluster_host_\" + hostId + \".log\";\n            m_eeProcs.set(hostId, new EEProcess(templateCmdLine.target(), m_siteCount, logfile));\n        }\n\n        PipeToFile ptf = null;\n        long start = 0;\n        try {\n            CommandLine rejoinCmdLn = m_cmdLines.get(hostId);\n            // some tests need this\n            rejoinCmdLn.javaProperties = templateCmdLine.javaProperties;\n            rejoinCmdLn.startCommand(startAction);\n\n            // This shouldn't collide but apparently it sucks.\n            // Bump it to avoid collisions on rejoin.\n            if (m_debug) {\n                rejoinCmdLn.debugPort(portGenerator.next());\n            }\n            rejoinCmdLn.leader(rejoinHost + \":\" + String.valueOf(portNoToRejoin));\n\n            rejoinCmdLn.m_port = portGenerator.nextClient();\n            rejoinCmdLn.m_adminPort = portGenerator.nextAdmin();\n            rejoinCmdLn.m_httpPort = portGenerator.nextHttp();\n            rejoinCmdLn.m_zkInterface = \"127.0.0.1:\" + portGenerator.next();\n            rejoinCmdLn.m_internalPort = portGenerator.nextInternalPort();\n            setPortsFromConfig(hostId, rejoinCmdLn);\n\n            if ((m_versionOverrides != null) && (m_versionOverrides.length > hostId)) {\n                assert(m_versionOverrides[hostId] != null);\n                assert(m_versionCheckRegexOverrides[hostId] != null);\n                rejoinCmdLn.m_versionStringOverrideForTest = m_versionOverrides[hostId];\n                rejoinCmdLn.m_versionCompatibilityRegexOverrideForTest = m_versionCheckRegexOverrides[hostId];\n                if ((m_buildStringOverrides != null) && (m_buildStringOverrides.length > hostId)) {\n                    assert(m_buildStringOverrides[hostId] != null);\n                    rejoinCmdLn.m_buildStringOverrideForTest = m_buildStringOverrides[hostId];\n                }\n            }\n\n            List<String> rejoinCmdLnStr = rejoinCmdLn.createCommandLine();\n            String cmdLineFull = \"Rejoin cmd line:\";\n            for (String element : rejoinCmdLnStr) {\n                cmdLineFull += \" \" + element;\n            }\n            log.info(cmdLineFull);\n\n            m_procBuilder.command().clear();\n            m_procBuilder.command().addAll(rejoinCmdLnStr);\n            Process proc = m_procBuilder.start();\n            start = System.currentTimeMillis();\n\n            // write output to obj/release/testoutput/<test name>-n.txt\n            // this may need to be more unique? Also very useful to just\n            // set this to a hardcoded path and use \"tail -f\" to debug.\n            String testoutputdir = rejoinCmdLn.buildDir() + File.separator + \"testoutput\";\n            // make sure the directory exists\n            File dir = new File(testoutputdir);\n            if (dir.exists()) {\n                assert(dir.isDirectory());\n            }\n            else {\n                boolean status = dir.mkdirs();\n                assert(status);\n            }\n\n            ptf = new PipeToFile(\n                    testoutputdir +\n                    File.separator +\n                    \"LC-\" +\n                    getFileName() + \"-\" +\n                    hostId + \"-\" +\n                    \"idx\" + String.valueOf(perLocalClusterExtProcessIndex++) +\n                    \".rejoined.txt\",\n                    proc.getInputStream(),\n                    PipeToFile.m_rejoinToken, true, proc);\n            synchronized (this) {\n                m_pipes.set(hostId, ptf);\n                // replace the existing dead proc\n                m_cluster.set(hostId, proc);\n                m_cmdLines.set(hostId, rejoinCmdLn);\n            }\n            Thread t = new Thread(ptf);\n            t.setName(\"ClusterPipe:\" + String.valueOf(hostId));\n            t.start();\n        }\n        catch (IOException ex) {\n            log.error(\"Failed to start recovering cluster process:\" + ex.getMessage(), ex);\n            assert (false);\n        }\n\n        return waitOnPTFReady(ptf, logtime, startTime, start, hostId);\n    }","id":49328,"modified_method":"private boolean recoverOne(boolean logtime, long startTime, int hostId, Integer rejoinHostId,\n                               String rejoinHost, StartAction startAction) {\n        // Lookup the client interface port of the rejoin host\n        // I have no idea why this code ignores the user's input\n        // based on other state in this class except to say that whoever wrote\n        // it this way originally probably eats kittens and hates cake.\n        if (rejoinHostId == null || m_hasLocalServer) {\n            rejoinHostId = 0;\n        }\n\n        int portNoToRejoin = m_cmdLines.get(rejoinHostId).internalPort();\n\n        if (hostId == 0 && m_hasLocalServer) {\n            templateCmdLine.leaderPort(portNoToRejoin);\n            startLocalServer(rejoinHostId, false, StartAction.REJOIN);\n            return true;\n        }\n\n        log.info(\"Rejoining \" + hostId + \" to hostID: \" + rejoinHostId);\n\n        // rebuild the EE proc set.\n        EEProcess eeProc = m_eeProcs.get(hostId);\n        try {\n            eeProc.waitForShutdown();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        if (templateCmdLine.target().isIPC) {\n            String logfile = \"LocalCluster_host_\" + hostId + \".log\";\n            m_eeProcs.set(hostId, new EEProcess(templateCmdLine.target(), m_siteCount, logfile));\n        }\n\n        PipeToFile ptf = null;\n        long start = 0;\n        try {\n            CommandLine rejoinCmdLn = m_cmdLines.get(hostId);\n            // some tests need this\n            rejoinCmdLn.javaProperties = templateCmdLine.javaProperties;\n            rejoinCmdLn.startCommand(startAction);\n\n            // This shouldn't collide but apparently it sucks.\n            // Bump it to avoid collisions on rejoin.\n            if (m_debug) {\n                rejoinCmdLn.debugPort(portGenerator.next());\n            }\n            rejoinCmdLn.leader(rejoinHost + \":\" + String.valueOf(portNoToRejoin));\n\n            rejoinCmdLn.m_port = portGenerator.nextClient();\n            rejoinCmdLn.m_adminPort = portGenerator.nextAdmin();\n            rejoinCmdLn.m_httpPort = portGenerator.nextHttp();\n            rejoinCmdLn.m_zkInterface = \"127.0.0.1:\" + portGenerator.next();\n            rejoinCmdLn.m_internalPort = portGenerator.nextInternalPort();\n            setPortsFromConfig(hostId, rejoinCmdLn);\n            if (this.m_additionalProcessEnv != null) {\n                for (String name : this.m_additionalProcessEnv.keySet()) {\n                    rejoinCmdLn.setJavaProperty(name, this.m_additionalProcessEnv.get(name));\n                }\n            }\n\n            if ((m_versionOverrides != null) && (m_versionOverrides.length > hostId)) {\n                assert(m_versionOverrides[hostId] != null);\n                assert(m_versionCheckRegexOverrides[hostId] != null);\n                rejoinCmdLn.m_versionStringOverrideForTest = m_versionOverrides[hostId];\n                rejoinCmdLn.m_versionCompatibilityRegexOverrideForTest = m_versionCheckRegexOverrides[hostId];\n                if ((m_buildStringOverrides != null) && (m_buildStringOverrides.length > hostId)) {\n                    assert(m_buildStringOverrides[hostId] != null);\n                    rejoinCmdLn.m_buildStringOverrideForTest = m_buildStringOverrides[hostId];\n                }\n            }\n\n            List<String> rejoinCmdLnStr = rejoinCmdLn.createCommandLine();\n            String cmdLineFull = \"Rejoin cmd line:\";\n            for (String element : rejoinCmdLnStr) {\n                cmdLineFull += \" \" + element;\n            }\n            log.info(cmdLineFull);\n\n            m_procBuilder.command().clear();\n            m_procBuilder.command().addAll(rejoinCmdLnStr);\n            Process proc = m_procBuilder.start();\n            start = System.currentTimeMillis();\n\n            // write output to obj/release/testoutput/<test name>-n.txt\n            // this may need to be more unique? Also very useful to just\n            // set this to a hardcoded path and use \"tail -f\" to debug.\n            String testoutputdir = rejoinCmdLn.buildDir() + File.separator + \"testoutput\";\n            // make sure the directory exists\n            File dir = new File(testoutputdir);\n            if (dir.exists()) {\n                assert(dir.isDirectory());\n            }\n            else {\n                boolean status = dir.mkdirs();\n                assert(status);\n            }\n\n            ptf = new PipeToFile(\n                    testoutputdir +\n                    File.separator +\n                    \"LC-\" +\n                    getFileName() + \"-\" +\n                    hostId + \"-\" +\n                    \"idx\" + String.valueOf(perLocalClusterExtProcessIndex++) +\n                    \".rejoined.txt\",\n                    proc.getInputStream(),\n                    PipeToFile.m_rejoinToken, true, proc);\n            synchronized (this) {\n                m_pipes.set(hostId, ptf);\n                // replace the existing dead proc\n                m_cluster.set(hostId, proc);\n                m_cmdLines.set(hostId, rejoinCmdLn);\n            }\n            Thread t = new Thread(ptf);\n            t.setName(\"ClusterPipe:\" + String.valueOf(hostId));\n            t.start();\n        }\n        catch (IOException ex) {\n            log.error(\"Failed to start recovering cluster process:\" + ex.getMessage(), ex);\n            assert (false);\n        }\n\n        return waitOnPTFReady(ptf, logtime, startTime, start, hostId);\n    }","commit_id":"f273ebeeec0ed652df15b794af33717f46fe7cfd","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private boolean recoverOne(boolean logtime, long startTime, int hostId, Integer rejoinHostId,\n                               String rejoinHost, StartAction startAction) {\n        // Lookup the client interface port of the rejoin host\n        // I have no idea why this code ignores the user's input\n        // based on other state in this class except to say that whoever wrote\n        // it this way originally probably eats kittens and hates cake.\n        if (rejoinHostId == null || m_hasLocalServer) {\n            rejoinHostId = 0;\n        }\n\n        int portNoToRejoin = m_cmdLines.get(rejoinHostId).internalPort();\n\n        if (hostId == 0 && m_hasLocalServer) {\n            templateCmdLine.leaderPort(portNoToRejoin);\n            startLocalServer(rejoinHostId, false, StartAction.REJOIN);\n            return true;\n        }\n\n        log.info(\"Rejoining \" + hostId + \" to hostID: \" + rejoinHostId);\n\n        // rebuild the EE proc set.\n        EEProcess eeProc = m_eeProcs.get(hostId);\n        try {\n            eeProc.waitForShutdown();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        if (templateCmdLine.target().isIPC) {\n            String logfile = \"LocalCluster_host_\" + hostId + \".log\";\n            m_eeProcs.set(hostId, new EEProcess(templateCmdLine.target(), m_siteCount, logfile));\n        }\n\n        PipeToFile ptf = null;\n        long start = 0;\n        try {\n            CommandLine rejoinCmdLn = m_cmdLines.get(hostId);\n            // some tests need this\n            rejoinCmdLn.javaProperties = templateCmdLine.javaProperties;\n            rejoinCmdLn.startCommand(startAction);\n\n            // This shouldn't collide but apparently it sucks.\n            // Bump it to avoid collisions on rejoin.\n            if (m_debug) {\n                rejoinCmdLn.debugPort(portGenerator.next());\n            }\n            rejoinCmdLn.leader(rejoinHost + \":\" + String.valueOf(portNoToRejoin));\n\n            rejoinCmdLn.m_port = portGenerator.nextClient();\n            rejoinCmdLn.m_adminPort = portGenerator.nextAdmin();\n            rejoinCmdLn.m_httpPort = portGenerator.nextHttp();\n            rejoinCmdLn.m_zkInterface = \"127.0.0.1:\" + portGenerator.next();\n            rejoinCmdLn.m_internalPort = portGenerator.nextInternalPort();\n            setPortsFromConfig(hostId, rejoinCmdLn);\n\n            if ((m_versionOverrides != null) && (m_versionOverrides.length > hostId)) {\n                assert(m_versionOverrides[hostId] != null);\n                assert(m_versionCheckRegexOverrides[hostId] != null);\n                rejoinCmdLn.m_versionStringOverrideForTest = m_versionOverrides[hostId];\n                rejoinCmdLn.m_versionCompatibilityRegexOverrideForTest = m_versionCheckRegexOverrides[hostId];\n                if ((m_buildStringOverrides != null) && (m_buildStringOverrides.length > hostId)) {\n                    assert(m_buildStringOverrides[hostId] != null);\n                    rejoinCmdLn.m_buildStringOverrideForTest = m_buildStringOverrides[hostId];\n                }\n            }\n\n            List<String> rejoinCmdLnStr = rejoinCmdLn.createCommandLine();\n            String cmdLineFull = \"Rejoin cmd line:\";\n            for (String element : rejoinCmdLnStr) {\n                cmdLineFull += \" \" + element;\n            }\n            log.info(cmdLineFull);\n\n            m_procBuilder.command().clear();\n            m_procBuilder.command().addAll(rejoinCmdLnStr);\n            Process proc = m_procBuilder.start();\n            start = System.currentTimeMillis();\n\n            // write output to obj/release/testoutput/<test name>-n.txt\n            // this may need to be more unique? Also very useful to just\n            // set this to a hardcoded path and use \"tail -f\" to debug.\n            String testoutputdir = rejoinCmdLn.buildDir() + File.separator + \"testoutput\";\n            // make sure the directory exists\n            File dir = new File(testoutputdir);\n            if (dir.exists()) {\n                assert(dir.isDirectory());\n            }\n            else {\n                boolean status = dir.mkdirs();\n                assert(status);\n            }\n\n            ptf = new PipeToFile(\n                    testoutputdir +\n                    File.separator +\n                    \"LC-\" +\n                    getFileName() + \"-\" +\n                    hostId + \"-\" +\n                    \"idx\" + String.valueOf(perLocalClusterExtProcessIndex++) +\n                    \".rejoined.txt\",\n                    proc.getInputStream(),\n                    PipeToFile.m_rejoinToken, true, proc);\n            synchronized (this) {\n                m_pipes.set(hostId, ptf);\n                // replace the existing dead proc\n                m_cluster.set(hostId, proc);\n                m_cmdLines.set(hostId, rejoinCmdLn);\n            }\n            Thread t = new Thread(ptf);\n            t.setName(\"ClusterPipe:\" + String.valueOf(hostId));\n            t.start();\n        }\n        catch (IOException ex) {\n            log.error(\"Failed to start recovering cluster process:\" + ex.getMessage(), ex);\n            assert (false);\n        }\n\n        return waitOnPTFReady(ptf, logtime, startTime, start, hostId);\n    }","id":49329,"modified_method":"private boolean recoverOne(boolean logtime, long startTime, int hostId, Integer rejoinHostId,\n                               String rejoinHost, StartAction startAction) {\n        // Lookup the client interface port of the rejoin host\n        // I have no idea why this code ignores the user's input\n        // based on other state in this class except to say that whoever wrote\n        // it this way originally probably eats kittens and hates cake.\n        if (rejoinHostId == null || m_hasLocalServer) {\n            rejoinHostId = 0;\n        }\n\n        int portNoToRejoin = m_cmdLines.get(rejoinHostId).internalPort();\n\n        if (hostId == 0 && m_hasLocalServer) {\n            templateCmdLine.leaderPort(portNoToRejoin);\n            startLocalServer(rejoinHostId, false, StartAction.REJOIN);\n            return true;\n        }\n\n        log.info(\"Rejoining \" + hostId + \" to hostID: \" + rejoinHostId);\n\n        // rebuild the EE proc set.\n        EEProcess eeProc = m_eeProcs.get(hostId);\n        try {\n            eeProc.waitForShutdown();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        if (templateCmdLine.target().isIPC) {\n            String logfile = \"LocalCluster_host_\" + hostId + \".log\";\n            m_eeProcs.set(hostId, new EEProcess(templateCmdLine.target(), m_siteCount, logfile));\n        }\n\n        PipeToFile ptf = null;\n        long start = 0;\n        try {\n            CommandLine rejoinCmdLn = m_cmdLines.get(hostId);\n            // some tests need this\n            rejoinCmdLn.javaProperties = templateCmdLine.javaProperties;\n            rejoinCmdLn.startCommand(startAction);\n\n            // This shouldn't collide but apparently it sucks.\n            // Bump it to avoid collisions on rejoin.\n            if (m_debug) {\n                rejoinCmdLn.debugPort(portGenerator.next());\n            }\n            rejoinCmdLn.leader(rejoinHost + \":\" + String.valueOf(portNoToRejoin));\n\n            rejoinCmdLn.m_port = portGenerator.nextClient();\n            rejoinCmdLn.m_adminPort = portGenerator.nextAdmin();\n            rejoinCmdLn.m_httpPort = portGenerator.nextHttp();\n            rejoinCmdLn.m_zkInterface = \"127.0.0.1:\" + portGenerator.next();\n            rejoinCmdLn.m_internalPort = portGenerator.nextInternalPort();\n            setPortsFromConfig(hostId, rejoinCmdLn);\n            if (this.m_additionalProcessEnv != null) {\n                for (String name : this.m_additionalProcessEnv.keySet()) {\n                    rejoinCmdLn.setJavaProperty(name, this.m_additionalProcessEnv.get(name));\n                }\n            }\n\n            if ((m_versionOverrides != null) && (m_versionOverrides.length > hostId)) {\n                assert(m_versionOverrides[hostId] != null);\n                assert(m_versionCheckRegexOverrides[hostId] != null);\n                rejoinCmdLn.m_versionStringOverrideForTest = m_versionOverrides[hostId];\n                rejoinCmdLn.m_versionCompatibilityRegexOverrideForTest = m_versionCheckRegexOverrides[hostId];\n                if ((m_buildStringOverrides != null) && (m_buildStringOverrides.length > hostId)) {\n                    assert(m_buildStringOverrides[hostId] != null);\n                    rejoinCmdLn.m_buildStringOverrideForTest = m_buildStringOverrides[hostId];\n                }\n            }\n\n            List<String> rejoinCmdLnStr = rejoinCmdLn.createCommandLine();\n            String cmdLineFull = \"Rejoin cmd line:\";\n            for (String element : rejoinCmdLnStr) {\n                cmdLineFull += \" \" + element;\n            }\n            log.info(cmdLineFull);\n\n            m_procBuilder.command().clear();\n            m_procBuilder.command().addAll(rejoinCmdLnStr);\n            Process proc = m_procBuilder.start();\n            start = System.currentTimeMillis();\n\n            // write output to obj/release/testoutput/<test name>-n.txt\n            // this may need to be more unique? Also very useful to just\n            // set this to a hardcoded path and use \"tail -f\" to debug.\n            String testoutputdir = rejoinCmdLn.buildDir() + File.separator + \"testoutput\";\n            // make sure the directory exists\n            File dir = new File(testoutputdir);\n            if (dir.exists()) {\n                assert(dir.isDirectory());\n            }\n            else {\n                boolean status = dir.mkdirs();\n                assert(status);\n            }\n\n            ptf = new PipeToFile(\n                    testoutputdir +\n                    File.separator +\n                    \"LC-\" +\n                    getFileName() + \"-\" +\n                    hostId + \"-\" +\n                    \"idx\" + String.valueOf(perLocalClusterExtProcessIndex++) +\n                    \".rejoined.txt\",\n                    proc.getInputStream(),\n                    PipeToFile.m_rejoinToken, true, proc);\n            synchronized (this) {\n                m_pipes.set(hostId, ptf);\n                // replace the existing dead proc\n                m_cluster.set(hostId, proc);\n                m_cmdLines.set(hostId, rejoinCmdLn);\n            }\n            Thread t = new Thread(ptf);\n            t.setName(\"ClusterPipe:\" + String.valueOf(hostId));\n            t.start();\n        }\n        catch (IOException ex) {\n            log.error(\"Failed to start recovering cluster process:\" + ex.getMessage(), ex);\n            assert (false);\n        }\n\n        return waitOnPTFReady(ptf, logtime, startTime, start, hostId);\n    }","commit_id":"73cd25650b9e7e245411a34daf3989958ef10c14","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public LocalCluster(String jarFileName,\n                        int siteCount,\n                        int hostCount,\n                        int kfactor,\n                        BackendTarget target,\n                        FailureState failureState,\n                        boolean debug,\n                        boolean isRejoinTest,\n                        Map<String, String> env)\n    {\n        assert (jarFileName != null);\n        assert (siteCount > 0);\n        assert (hostCount > 0);\n\n        m_additionalProcessEnv = env;\n        // get the name of the calling class\n        StackTraceElement[] traces = Thread.currentThread().getStackTrace();\n        m_callingClassName = \"UnknownClass\";\n        m_callingMethodName = \"unknownMethod\";\n        //ArrayUtils.reverse(traces);\n        int i;\n        // skip all stack frames below this method\n        for (i = 0; traces[i].getClassName().equals(getClass().getName()) == false; i++);\n        // skip all stack frames from localcluster itself\n        for (;      traces[i].getClassName().equals(getClass().getName()); i++);\n        // skip the package name\n        int dot = traces[i].getClassName().lastIndexOf('.');\n        m_callingClassName = traces[i].getClassName().substring(dot + 1);\n        m_callingMethodName = traces[i].getMethodName();\n\n        log.info(\"Instantiating LocalCluster for \" + jarFileName + \" with class.method: \" +\n                m_callingClassName + \".\" + m_callingMethodName);\n        log.info(\"Sites: \" + siteCount + \" hosts: \" + hostCount + \" replication factor: \" + kfactor);\n\n        m_cluster.ensureCapacity(hostCount);\n\n        m_siteCount = siteCount;\n        m_hostCount = hostCount;\n        if (kfactor > 0 && !MiscUtils.isPro()) {\n            m_kfactor = 0;\n        } else {\n            m_kfactor = kfactor;\n        }\n        m_debug = debug;\n        m_jarFileName = jarFileName;\n        m_failureState = m_kfactor < 1 ? FailureState.ALL_RUNNING : failureState;\n        m_pipes = new ArrayList<PipeToFile>();\n        m_cmdLines = new ArrayList<CommandLine>();\n\n        // if the user wants valgrind and it makes sense, give it to 'em\n        // For now only one host works.\n        if (isMemcheckDefined() && (target == BackendTarget.NATIVE_EE_JNI) && m_hostCount == 1) {\n            m_target = BackendTarget.NATIVE_EE_VALGRIND_IPC;\n        }\n        else {\n            m_target = target;\n        }\n\n        String buildDir = System.getenv(\"VOLTDB_BUILD_DIR\");  // via build.xml\n        if (buildDir == null) {\n            buildDir = System.getProperty(\"user.dir\") + \"/obj/release\";\n        }\n\n        String classPath = System.getProperty(\"java.class.path\") + \":\" +\n            buildDir + File.separator + m_jarFileName;\n\n        String javaLibraryPath = null;\n        if (m_additionalProcessEnv != null && m_additionalProcessEnv.containsKey(EELibraryLoader.USE_JAVA_LIBRARY_PATH)) {\n            if (Boolean.parseBoolean(m_additionalProcessEnv.get(EELibraryLoader.USE_JAVA_LIBRARY_PATH))) {\n                // set the java lib path to the one for this process - Add obj/release/nativelibs\n                javaLibraryPath = System.getProperty(\"java.library.path\");\n                if (javaLibraryPath == null || javaLibraryPath.trim().length() == 0) {\n                    javaLibraryPath = buildDir + \"/nativelibs\";\n                } else {\n                    javaLibraryPath += \":\" + buildDir + \"/nativelibs\";\n                }\n            }\n        }\n\n        if (javaLibraryPath==null) {\n            // need this in classpath to find native library. Otherwise, don't add it to classpath to\n            // test override of loading EE lib from jar.\n            classPath = classPath + \":\" + buildDir + File.separator + \"prod\";\n        }\n\n        // Remove the stored procedures from the classpath.  Out-of-process nodes will\n        // only be able to find procedures and dependent classes in the catalog, as intended\n        classPath = classPath.replace(buildDir + File.separator + \"testprocs:\", \"\");\n\n        // First try 'ant' syntax and then 'eclipse' syntax...\n        String log4j = System.getProperty(\"log4j.configuration\");\n        if (log4j == null) {\n            log4j = \"file://\" + System.getProperty(\"user.dir\") + \"/tests/log4j-allconsole.xml\";\n        }\n\n        m_procBuilder = new ProcessBuilder();\n\n        // set the working directory to obj/release/prod\n        //m_procBuilder.directory(new File(m_buildDir + File.separator + \"prod\"));\n        m_procBuilder.redirectErrorStream(true);\n\n        Thread shutdownThread = new Thread(new ShutDownHookThread());\n        java.lang.Runtime.getRuntime().addShutdownHook(shutdownThread);\n\n        // Create the base command line that each process can makeCopy and modify\n        this.templateCmdLine.\n            addTestOptions(true).\n            leader(\"\").\n            target(m_target).\n            startCommand(\"create\").\n            jarFileName(VoltDB.Configuration.getPathToCatalogForTest(m_jarFileName)).\n            buildDir(buildDir).\n            classPath(classPath).\n            pathToLicense(ServerThread.getTestLicensePath()).\n            log4j(log4j);\n        if (javaLibraryPath!=null) {\n            templateCmdLine.javaLibraryPath(javaLibraryPath);\n        }\n        this.templateCmdLine.m_noLoadLibVOLTDB = m_target == BackendTarget.HSQLDB_BACKEND;\n        // \"tag\" this command line so it's clear which test started it\n        this.templateCmdLine.m_tag = m_callingClassName + \":\" + m_callingMethodName;\n    }","id":49330,"modified_method":"public LocalCluster(String jarFileName,\n                        int siteCount,\n                        int hostCount,\n                        int kfactor,\n                        BackendTarget target,\n                        FailureState failureState,\n                        boolean debug,\n                        boolean isRejoinTest,\n                        Map<String, String> env)\n    {\n        assert (jarFileName != null);\n        assert (siteCount > 0);\n        assert (hostCount > 0);\n\n        m_additionalProcessEnv = env==null ? new HashMap<String, String>() : env;\n        if (Boolean.getBoolean(EELibraryLoader.USE_JAVA_LIBRARY_PATH)) {\n            // set use.javalib for LocalCluster so that Eclipse runs will be OK.\n            m_additionalProcessEnv.put(EELibraryLoader.USE_JAVA_LIBRARY_PATH, \"true\");\n        }\n        // get the name of the calling class\n        StackTraceElement[] traces = Thread.currentThread().getStackTrace();\n        m_callingClassName = \"UnknownClass\";\n        m_callingMethodName = \"unknownMethod\";\n        //ArrayUtils.reverse(traces);\n        int i;\n        // skip all stack frames below this method\n        for (i = 0; traces[i].getClassName().equals(getClass().getName()) == false; i++);\n        // skip all stack frames from localcluster itself\n        for (;      traces[i].getClassName().equals(getClass().getName()); i++);\n        // skip the package name\n        int dot = traces[i].getClassName().lastIndexOf('.');\n        m_callingClassName = traces[i].getClassName().substring(dot + 1);\n        m_callingMethodName = traces[i].getMethodName();\n\n        log.info(\"Instantiating LocalCluster for \" + jarFileName + \" with class.method: \" +\n                m_callingClassName + \".\" + m_callingMethodName);\n        log.info(\"Sites: \" + siteCount + \" hosts: \" + hostCount + \" replication factor: \" + kfactor);\n\n        m_cluster.ensureCapacity(hostCount);\n\n        m_siteCount = siteCount;\n        m_hostCount = hostCount;\n        if (kfactor > 0 && !MiscUtils.isPro()) {\n            m_kfactor = 0;\n        } else {\n            m_kfactor = kfactor;\n        }\n        m_debug = debug;\n        m_jarFileName = jarFileName;\n        m_failureState = m_kfactor < 1 ? FailureState.ALL_RUNNING : failureState;\n        m_pipes = new ArrayList<PipeToFile>();\n        m_cmdLines = new ArrayList<CommandLine>();\n\n        // if the user wants valgrind and it makes sense, give it to 'em\n        // For now only one host works.\n        if (isMemcheckDefined() && (target == BackendTarget.NATIVE_EE_JNI) && m_hostCount == 1) {\n            m_target = BackendTarget.NATIVE_EE_VALGRIND_IPC;\n        }\n        else {\n            m_target = target;\n        }\n\n        String buildDir = System.getenv(\"VOLTDB_BUILD_DIR\");  // via build.xml\n        if (buildDir == null) {\n            buildDir = System.getProperty(\"user.dir\") + \"/obj/release\";\n        }\n\n        String classPath = System.getProperty(\"java.class.path\") + \":\" +\n                buildDir + File.separator + m_jarFileName + \":\" + buildDir + File.separator + \"prod\";\n\n        // set the java lib path to the one for this process - Add obj/release/nativelibs\n        String javaLibraryPath = System.getProperty(\"java.library.path\");\n        if (javaLibraryPath == null || javaLibraryPath.trim().length() == 0) {\n            javaLibraryPath = buildDir + \"/nativelibs\";\n        } else {\n            javaLibraryPath += \":\" + buildDir + \"/nativelibs\";\n        }\n\n        // Remove the stored procedures from the classpath.  Out-of-process nodes will\n        // only be able to find procedures and dependent classes in the catalog, as intended\n        classPath = classPath.replace(buildDir + File.separator + \"testprocs:\", \"\");\n\n        // First try 'ant' syntax and then 'eclipse' syntax...\n        String log4j = System.getProperty(\"log4j.configuration\");\n        if (log4j == null) {\n            log4j = \"file://\" + System.getProperty(\"user.dir\") + \"/tests/log4j-allconsole.xml\";\n        }\n\n        m_procBuilder = new ProcessBuilder();\n\n        // set the working directory to obj/release/prod\n        //m_procBuilder.directory(new File(m_buildDir + File.separator + \"prod\"));\n        m_procBuilder.redirectErrorStream(true);\n\n        Thread shutdownThread = new Thread(new ShutDownHookThread());\n        java.lang.Runtime.getRuntime().addShutdownHook(shutdownThread);\n\n        // Create the base command line that each process can makeCopy and modify\n        this.templateCmdLine.\n            addTestOptions(true).\n            leader(\"\").\n            target(m_target).\n            startCommand(\"create\").\n            jarFileName(VoltDB.Configuration.getPathToCatalogForTest(m_jarFileName)).\n            buildDir(buildDir).\n            classPath(classPath).\n            pathToLicense(ServerThread.getTestLicensePath()).\n            log4j(log4j);\n        if (javaLibraryPath!=null) {\n            templateCmdLine.javaLibraryPath(javaLibraryPath);\n        }\n        this.templateCmdLine.m_noLoadLibVOLTDB = m_target == BackendTarget.HSQLDB_BACKEND;\n        // \"tag\" this command line so it's clear which test started it\n        this.templateCmdLine.m_tag = m_callingClassName + \":\" + m_callingMethodName;\n    }","commit_id":"73cd25650b9e7e245411a34daf3989958ef10c14","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public LocalCluster(String jarFileName,\n                        int siteCount,\n                        int hostCount,\n                        int kfactor,\n                        BackendTarget target,\n                        FailureState failureState,\n                        boolean debug,\n                        boolean isRejoinTest,\n                        Map<String, String> env)\n    {\n        assert (jarFileName != null);\n        assert (siteCount > 0);\n        assert (hostCount > 0);\n\n        m_additionalProcessEnv = env;\n        // get the name of the calling class\n        StackTraceElement[] traces = Thread.currentThread().getStackTrace();\n        m_callingClassName = \"UnknownClass\";\n        m_callingMethodName = \"unknownMethod\";\n        //ArrayUtils.reverse(traces);\n        int i;\n        // skip all stack frames below this method\n        for (i = 0; traces[i].getClassName().equals(getClass().getName()) == false; i++);\n        // skip all stack frames from localcluster itself\n        for (;      traces[i].getClassName().equals(getClass().getName()); i++);\n        // skip the package name\n        int dot = traces[i].getClassName().lastIndexOf('.');\n        m_callingClassName = traces[i].getClassName().substring(dot + 1);\n        m_callingMethodName = traces[i].getMethodName();\n\n        log.info(\"Instantiating LocalCluster for \" + jarFileName + \" with class.method: \" +\n                m_callingClassName + \".\" + m_callingMethodName);\n        log.info(\"Sites: \" + siteCount + \" hosts: \" + hostCount + \" replication factor: \" + kfactor);\n\n        m_cluster.ensureCapacity(hostCount);\n\n        m_siteCount = siteCount;\n        m_hostCount = hostCount;\n        if (kfactor > 0 && !MiscUtils.isPro()) {\n            m_kfactor = 0;\n        } else {\n            m_kfactor = kfactor;\n        }\n        m_debug = debug;\n        m_jarFileName = jarFileName;\n        m_failureState = m_kfactor < 1 ? FailureState.ALL_RUNNING : failureState;\n        m_pipes = new ArrayList<PipeToFile>();\n        m_cmdLines = new ArrayList<CommandLine>();\n\n        // if the user wants valgrind and it makes sense, give it to 'em\n        // For now only one host works.\n        if (isMemcheckDefined() && (target == BackendTarget.NATIVE_EE_JNI) && m_hostCount == 1) {\n            m_target = BackendTarget.NATIVE_EE_VALGRIND_IPC;\n        }\n        else {\n            m_target = target;\n        }\n\n        String buildDir = System.getenv(\"VOLTDB_BUILD_DIR\");  // via build.xml\n        if (buildDir == null) {\n            buildDir = System.getProperty(\"user.dir\") + \"/obj/release\";\n        }\n\n        String classPath = System.getProperty(\"java.class.path\") + \":\" +\n            buildDir + File.separator + m_jarFileName;\n\n        String javaLibraryPath = null;\n        if (m_additionalProcessEnv != null && m_additionalProcessEnv.containsKey(EELibraryLoader.USE_JAVA_LIBRARY_PATH)) {\n            if (Boolean.parseBoolean(m_additionalProcessEnv.get(EELibraryLoader.USE_JAVA_LIBRARY_PATH))) {\n                // set the java lib path to the one for this process - Add obj/release/nativelibs\n                javaLibraryPath = System.getProperty(\"java.library.path\");\n                if (javaLibraryPath == null || javaLibraryPath.trim().length() == 0) {\n                    javaLibraryPath = buildDir + \"/nativelibs\";\n                } else {\n                    javaLibraryPath += \":\" + buildDir + \"/nativelibs\";\n                }\n            }\n        }\n\n        if (javaLibraryPath==null) {\n            // need this in classpath to find native library. Otherwise, don't add it to classpath to\n            // test override of loading EE lib from jar.\n            classPath = classPath + \":\" + buildDir + File.separator + \"prod\";\n        }\n\n        // Remove the stored procedures from the classpath.  Out-of-process nodes will\n        // only be able to find procedures and dependent classes in the catalog, as intended\n        classPath = classPath.replace(buildDir + File.separator + \"testprocs:\", \"\");\n\n        // First try 'ant' syntax and then 'eclipse' syntax...\n        String log4j = System.getProperty(\"log4j.configuration\");\n        if (log4j == null) {\n            log4j = \"file://\" + System.getProperty(\"user.dir\") + \"/tests/log4j-allconsole.xml\";\n        }\n\n        m_procBuilder = new ProcessBuilder();\n\n        // set the working directory to obj/release/prod\n        //m_procBuilder.directory(new File(m_buildDir + File.separator + \"prod\"));\n        m_procBuilder.redirectErrorStream(true);\n\n        Thread shutdownThread = new Thread(new ShutDownHookThread());\n        java.lang.Runtime.getRuntime().addShutdownHook(shutdownThread);\n\n        // Create the base command line that each process can makeCopy and modify\n        this.templateCmdLine.\n            addTestOptions(true).\n            leader(\"\").\n            target(m_target).\n            startCommand(\"create\").\n            jarFileName(VoltDB.Configuration.getPathToCatalogForTest(m_jarFileName)).\n            buildDir(buildDir).\n            classPath(classPath).\n            pathToLicense(ServerThread.getTestLicensePath()).\n            log4j(log4j);\n        if (javaLibraryPath!=null) {\n            templateCmdLine.javaLibraryPath(javaLibraryPath);\n        }\n        this.templateCmdLine.m_noLoadLibVOLTDB = m_target == BackendTarget.HSQLDB_BACKEND;\n        // \"tag\" this command line so it's clear which test started it\n        this.templateCmdLine.m_tag = m_callingClassName + \":\" + m_callingMethodName;\n    }","id":49331,"modified_method":"public LocalCluster(String jarFileName,\n                        int siteCount,\n                        int hostCount,\n                        int kfactor,\n                        BackendTarget target,\n                        FailureState failureState,\n                        boolean debug,\n                        boolean isRejoinTest,\n                        Map<String, String> env)\n    {\n        assert (jarFileName != null);\n        assert (siteCount > 0);\n        assert (hostCount > 0);\n\n        m_additionalProcessEnv = env==null ? new HashMap<String, String>() : env;\n        if (Boolean.getBoolean(EELibraryLoader.USE_JAVA_LIBRARY_PATH)) {\n            // set use.javalib for LocalCluster so that Eclipse runs will be OK.\n            m_additionalProcessEnv.put(EELibraryLoader.USE_JAVA_LIBRARY_PATH, \"true\");\n        }\n        // get the name of the calling class\n        StackTraceElement[] traces = Thread.currentThread().getStackTrace();\n        m_callingClassName = \"UnknownClass\";\n        m_callingMethodName = \"unknownMethod\";\n        //ArrayUtils.reverse(traces);\n        int i;\n        // skip all stack frames below this method\n        for (i = 0; traces[i].getClassName().equals(getClass().getName()) == false; i++);\n        // skip all stack frames from localcluster itself\n        for (;      traces[i].getClassName().equals(getClass().getName()); i++);\n        // skip the package name\n        int dot = traces[i].getClassName().lastIndexOf('.');\n        m_callingClassName = traces[i].getClassName().substring(dot + 1);\n        m_callingMethodName = traces[i].getMethodName();\n\n        log.info(\"Instantiating LocalCluster for \" + jarFileName + \" with class.method: \" +\n                m_callingClassName + \".\" + m_callingMethodName);\n        log.info(\"Sites: \" + siteCount + \" hosts: \" + hostCount + \" replication factor: \" + kfactor);\n\n        m_cluster.ensureCapacity(hostCount);\n\n        m_siteCount = siteCount;\n        m_hostCount = hostCount;\n        if (kfactor > 0 && !MiscUtils.isPro()) {\n            m_kfactor = 0;\n        } else {\n            m_kfactor = kfactor;\n        }\n        m_debug = debug;\n        m_jarFileName = jarFileName;\n        m_failureState = m_kfactor < 1 ? FailureState.ALL_RUNNING : failureState;\n        m_pipes = new ArrayList<PipeToFile>();\n        m_cmdLines = new ArrayList<CommandLine>();\n\n        // if the user wants valgrind and it makes sense, give it to 'em\n        // For now only one host works.\n        if (isMemcheckDefined() && (target == BackendTarget.NATIVE_EE_JNI) && m_hostCount == 1) {\n            m_target = BackendTarget.NATIVE_EE_VALGRIND_IPC;\n        }\n        else {\n            m_target = target;\n        }\n\n        String buildDir = System.getenv(\"VOLTDB_BUILD_DIR\");  // via build.xml\n        if (buildDir == null) {\n            buildDir = System.getProperty(\"user.dir\") + \"/obj/release\";\n        }\n\n        String classPath = System.getProperty(\"java.class.path\") + \":\" +\n                buildDir + File.separator + m_jarFileName + \":\" + buildDir + File.separator + \"prod\";\n\n        // set the java lib path to the one for this process - Add obj/release/nativelibs\n        String javaLibraryPath = System.getProperty(\"java.library.path\");\n        if (javaLibraryPath == null || javaLibraryPath.trim().length() == 0) {\n            javaLibraryPath = buildDir + \"/nativelibs\";\n        } else {\n            javaLibraryPath += \":\" + buildDir + \"/nativelibs\";\n        }\n\n        // Remove the stored procedures from the classpath.  Out-of-process nodes will\n        // only be able to find procedures and dependent classes in the catalog, as intended\n        classPath = classPath.replace(buildDir + File.separator + \"testprocs:\", \"\");\n\n        // First try 'ant' syntax and then 'eclipse' syntax...\n        String log4j = System.getProperty(\"log4j.configuration\");\n        if (log4j == null) {\n            log4j = \"file://\" + System.getProperty(\"user.dir\") + \"/tests/log4j-allconsole.xml\";\n        }\n\n        m_procBuilder = new ProcessBuilder();\n\n        // set the working directory to obj/release/prod\n        //m_procBuilder.directory(new File(m_buildDir + File.separator + \"prod\"));\n        m_procBuilder.redirectErrorStream(true);\n\n        Thread shutdownThread = new Thread(new ShutDownHookThread());\n        java.lang.Runtime.getRuntime().addShutdownHook(shutdownThread);\n\n        // Create the base command line that each process can makeCopy and modify\n        this.templateCmdLine.\n            addTestOptions(true).\n            leader(\"\").\n            target(m_target).\n            startCommand(\"create\").\n            jarFileName(VoltDB.Configuration.getPathToCatalogForTest(m_jarFileName)).\n            buildDir(buildDir).\n            classPath(classPath).\n            pathToLicense(ServerThread.getTestLicensePath()).\n            log4j(log4j);\n        if (javaLibraryPath!=null) {\n            templateCmdLine.javaLibraryPath(javaLibraryPath);\n        }\n        this.templateCmdLine.m_noLoadLibVOLTDB = m_target == BackendTarget.HSQLDB_BACKEND;\n        // \"tag\" this command line so it's clear which test started it\n        this.templateCmdLine.m_tag = m_callingClassName + \":\" + m_callingMethodName;\n    }","commit_id":"0b4dc644eaa93687023844e6579ee7699ddede69","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private boolean recoverOne(boolean logtime, long startTime, int hostId, Integer rejoinHostId,\n                               String rejoinHost, StartAction startAction) {\n        // Lookup the client interface port of the rejoin host\n        // I have no idea why this code ignores the user's input\n        // based on other state in this class except to say that whoever wrote\n        // it this way originally probably eats kittens and hates cake.\n        if (rejoinHostId == null || m_hasLocalServer) {\n            rejoinHostId = 0;\n        }\n\n        int portNoToRejoin = m_cmdLines.get(rejoinHostId).internalPort();\n\n        if (hostId == 0 && m_hasLocalServer) {\n            templateCmdLine.leaderPort(portNoToRejoin);\n            startLocalServer(rejoinHostId, false, StartAction.REJOIN);\n            return true;\n        }\n\n        log.info(\"Rejoining \" + hostId + \" to hostID: \" + rejoinHostId);\n\n        // rebuild the EE proc set.\n        EEProcess eeProc = m_eeProcs.get(hostId);\n        try {\n            eeProc.waitForShutdown();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        if (templateCmdLine.target().isIPC) {\n            String logfile = \"LocalCluster_host_\" + hostId + \".log\";\n            m_eeProcs.set(hostId, new EEProcess(templateCmdLine.target(), m_siteCount, logfile));\n        }\n\n        PipeToFile ptf = null;\n        long start = 0;\n        try {\n            CommandLine rejoinCmdLn = m_cmdLines.get(hostId);\n            // some tests need this\n            rejoinCmdLn.javaProperties = templateCmdLine.javaProperties;\n            rejoinCmdLn.startCommand(startAction);\n\n            // This shouldn't collide but apparently it sucks.\n            // Bump it to avoid collisions on rejoin.\n            if (m_debug) {\n                rejoinCmdLn.debugPort(portGenerator.next());\n            }\n            rejoinCmdLn.leader(rejoinHost + \":\" + String.valueOf(portNoToRejoin));\n\n            rejoinCmdLn.m_port = portGenerator.nextClient();\n            rejoinCmdLn.m_adminPort = portGenerator.nextAdmin();\n            rejoinCmdLn.m_httpPort = portGenerator.nextHttp();\n            rejoinCmdLn.m_zkInterface = \"127.0.0.1:\" + portGenerator.next();\n            rejoinCmdLn.m_internalPort = portGenerator.nextInternalPort();\n            setPortsFromConfig(hostId, rejoinCmdLn);\n\n            if ((m_versionOverrides != null) && (m_versionOverrides.length > hostId)) {\n                assert(m_versionOverrides[hostId] != null);\n                assert(m_versionCheckRegexOverrides[hostId] != null);\n                rejoinCmdLn.m_versionStringOverrideForTest = m_versionOverrides[hostId];\n                rejoinCmdLn.m_versionCompatibilityRegexOverrideForTest = m_versionCheckRegexOverrides[hostId];\n                if ((m_buildStringOverrides != null) && (m_buildStringOverrides.length > hostId)) {\n                    assert(m_buildStringOverrides[hostId] != null);\n                    rejoinCmdLn.m_buildStringOverrideForTest = m_buildStringOverrides[hostId];\n                }\n            }\n\n            List<String> rejoinCmdLnStr = rejoinCmdLn.createCommandLine();\n            String cmdLineFull = \"Rejoin cmd line:\";\n            for (String element : rejoinCmdLnStr) {\n                cmdLineFull += \" \" + element;\n            }\n            log.info(cmdLineFull);\n\n            m_procBuilder.command().clear();\n            m_procBuilder.command().addAll(rejoinCmdLnStr);\n            Process proc = m_procBuilder.start();\n            start = System.currentTimeMillis();\n\n            // write output to obj/release/testoutput/<test name>-n.txt\n            // this may need to be more unique? Also very useful to just\n            // set this to a hardcoded path and use \"tail -f\" to debug.\n            String testoutputdir = rejoinCmdLn.buildDir() + File.separator + \"testoutput\";\n            // make sure the directory exists\n            File dir = new File(testoutputdir);\n            if (dir.exists()) {\n                assert(dir.isDirectory());\n            }\n            else {\n                boolean status = dir.mkdirs();\n                assert(status);\n            }\n\n            ptf = new PipeToFile(\n                    testoutputdir +\n                    File.separator +\n                    \"LC-\" +\n                    getFileName() + \"-\" +\n                    hostId + \"-\" +\n                    \"idx\" + String.valueOf(perLocalClusterExtProcessIndex++) +\n                    \".rejoined.txt\",\n                    proc.getInputStream(),\n                    PipeToFile.m_rejoinToken, true, proc);\n            synchronized (this) {\n                m_pipes.set(hostId, ptf);\n                // replace the existing dead proc\n                m_cluster.set(hostId, proc);\n                m_cmdLines.set(hostId, rejoinCmdLn);\n            }\n            Thread t = new Thread(ptf);\n            t.setName(\"ClusterPipe:\" + String.valueOf(hostId));\n            t.start();\n        }\n        catch (IOException ex) {\n            log.error(\"Failed to start recovering cluster process:\" + ex.getMessage(), ex);\n            assert (false);\n        }\n\n        return waitOnPTFReady(ptf, logtime, startTime, start, hostId);\n    }","id":49332,"modified_method":"private boolean recoverOne(boolean logtime, long startTime, int hostId, Integer rejoinHostId,\n                               String rejoinHost, StartAction startAction) {\n        // Lookup the client interface port of the rejoin host\n        // I have no idea why this code ignores the user's input\n        // based on other state in this class except to say that whoever wrote\n        // it this way originally probably eats kittens and hates cake.\n        if (rejoinHostId == null || m_hasLocalServer) {\n            rejoinHostId = 0;\n        }\n\n        int portNoToRejoin = m_cmdLines.get(rejoinHostId).internalPort();\n\n        if (hostId == 0 && m_hasLocalServer) {\n            templateCmdLine.leaderPort(portNoToRejoin);\n            startLocalServer(rejoinHostId, false, StartAction.REJOIN);\n            return true;\n        }\n\n        log.info(\"Rejoining \" + hostId + \" to hostID: \" + rejoinHostId);\n\n        // rebuild the EE proc set.\n        EEProcess eeProc = m_eeProcs.get(hostId);\n        try {\n            eeProc.waitForShutdown();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        if (templateCmdLine.target().isIPC) {\n            String logfile = \"LocalCluster_host_\" + hostId + \".log\";\n            m_eeProcs.set(hostId, new EEProcess(templateCmdLine.target(), m_siteCount, logfile));\n        }\n\n        PipeToFile ptf = null;\n        long start = 0;\n        try {\n            CommandLine rejoinCmdLn = m_cmdLines.get(hostId);\n            // some tests need this\n            rejoinCmdLn.javaProperties = templateCmdLine.javaProperties;\n            rejoinCmdLn.startCommand(startAction);\n\n            // This shouldn't collide but apparently it sucks.\n            // Bump it to avoid collisions on rejoin.\n            if (m_debug) {\n                rejoinCmdLn.debugPort(portGenerator.next());\n            }\n            rejoinCmdLn.leader(rejoinHost + \":\" + String.valueOf(portNoToRejoin));\n\n            rejoinCmdLn.m_port = portGenerator.nextClient();\n            rejoinCmdLn.m_adminPort = portGenerator.nextAdmin();\n            rejoinCmdLn.m_httpPort = portGenerator.nextHttp();\n            rejoinCmdLn.m_zkInterface = \"127.0.0.1:\" + portGenerator.next();\n            rejoinCmdLn.m_internalPort = portGenerator.nextInternalPort();\n            setPortsFromConfig(hostId, rejoinCmdLn);\n            if (this.m_additionalProcessEnv != null) {\n                for (String name : this.m_additionalProcessEnv.keySet()) {\n                    rejoinCmdLn.setJavaProperty(name, this.m_additionalProcessEnv.get(name));\n                }\n            }\n\n            if ((m_versionOverrides != null) && (m_versionOverrides.length > hostId)) {\n                assert(m_versionOverrides[hostId] != null);\n                assert(m_versionCheckRegexOverrides[hostId] != null);\n                rejoinCmdLn.m_versionStringOverrideForTest = m_versionOverrides[hostId];\n                rejoinCmdLn.m_versionCompatibilityRegexOverrideForTest = m_versionCheckRegexOverrides[hostId];\n                if ((m_buildStringOverrides != null) && (m_buildStringOverrides.length > hostId)) {\n                    assert(m_buildStringOverrides[hostId] != null);\n                    rejoinCmdLn.m_buildStringOverrideForTest = m_buildStringOverrides[hostId];\n                }\n            }\n\n            List<String> rejoinCmdLnStr = rejoinCmdLn.createCommandLine();\n            String cmdLineFull = \"Rejoin cmd line:\";\n            for (String element : rejoinCmdLnStr) {\n                cmdLineFull += \" \" + element;\n            }\n            log.info(cmdLineFull);\n\n            m_procBuilder.command().clear();\n            m_procBuilder.command().addAll(rejoinCmdLnStr);\n            Process proc = m_procBuilder.start();\n            start = System.currentTimeMillis();\n\n            // write output to obj/release/testoutput/<test name>-n.txt\n            // this may need to be more unique? Also very useful to just\n            // set this to a hardcoded path and use \"tail -f\" to debug.\n            String testoutputdir = rejoinCmdLn.buildDir() + File.separator + \"testoutput\";\n            // make sure the directory exists\n            File dir = new File(testoutputdir);\n            if (dir.exists()) {\n                assert(dir.isDirectory());\n            }\n            else {\n                boolean status = dir.mkdirs();\n                assert(status);\n            }\n\n            ptf = new PipeToFile(\n                    testoutputdir +\n                    File.separator +\n                    \"LC-\" +\n                    getFileName() + \"-\" +\n                    hostId + \"-\" +\n                    \"idx\" + String.valueOf(perLocalClusterExtProcessIndex++) +\n                    \".rejoined.txt\",\n                    proc.getInputStream(),\n                    PipeToFile.m_rejoinToken, true, proc);\n            synchronized (this) {\n                m_pipes.set(hostId, ptf);\n                // replace the existing dead proc\n                m_cluster.set(hostId, proc);\n                m_cmdLines.set(hostId, rejoinCmdLn);\n            }\n            Thread t = new Thread(ptf);\n            t.setName(\"ClusterPipe:\" + String.valueOf(hostId));\n            t.start();\n        }\n        catch (IOException ex) {\n            log.error(\"Failed to start recovering cluster process:\" + ex.getMessage(), ex);\n            assert (false);\n        }\n\n        return waitOnPTFReady(ptf, logtime, startTime, start, hostId);\n    }","commit_id":"0b4dc644eaa93687023844e6579ee7699ddede69","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n   public Set<String> findDocNames(File srcDir, AndFileFilter fileFilter) throws IOException\n   {\n      Set<String> localDocNames = new HashSet<String>();\n      // populate localDocNames by looking in pot directory\n      String[] srcFiles = PublicanUtil.findPotFiles(srcDir, fileFilter);\n      for (String potName : srcFiles)\n      {\n         String docName = StringUtil.removeFileExtension(potName, \".pot\");\n         localDocNames.add(docName);\n      }\n      return localDocNames;\n   }","id":49333,"modified_method":"public Set<String> findDocNames(File srcDir, List<String> includes, List<String> excludes) throws IOException\n   {\n      Set<String> localDocNames = new HashSet<String>();\n      includes.add(\"**/*.pot\");\n      // populate localDocNames by looking in pot directory\n      DirectoryScanner dirScanner = new DirectoryScanner();\n      dirScanner.setBasedir(srcDir);\n      dirScanner.setCaseSensitive(false);\n      dirScanner.setExcludes((String[]) excludes.toArray(new String[excludes.size()]));\n      dirScanner.setIncludes((String[]) includes.toArray(new String[includes.size()]));\n      dirScanner.scan();\n      String[] srcFiles = dirScanner.getIncludedFiles();\n\n      for (String potName : srcFiles)\n      {\n         String docName = FilenameUtils.removeExtension(potName);\n         localDocNames.add(docName);\n      }\n      return localDocNames;\n   }","commit_id":"85e091a44009ac1c5c490eae58fbd886a1214ab4","url":"https://github.com/zanata/zanata-server"},{"original_method":"private String docNameToFilename(String docName, LocaleMapping locale)\n   {\n      return docName + \"_\" + locale.getJavaLocale() + \".properties\";\n   }","id":49334,"modified_method":"@Override\n   public Set<String> findDocNames(File srcDir, List<String> includes, List<String> excludes) throws IOException\n   {\n      Set<String> localDocNames = new HashSet<String>();\n\n      includes.add(\"**/*.properties\");\n      for (LocaleMapping locMap : opts.getLocales())\n      {\n         String loc = locMap.getJavaLocale().toLowerCase();\n         excludes.add(\"**/*_\" + loc + \".properties\");\n      }\n\n      DirectoryScanner dirScanner = new DirectoryScanner();\n      dirScanner.setBasedir(srcDir);\n      dirScanner.setCaseSensitive(false);\n      dirScanner.setExcludes((String[]) excludes.toArray(new String[excludes.size()]));\n      dirScanner.setIncludes((String[]) includes.toArray(new String[includes.size()]));\n      dirScanner.scan();\n      String[] files = dirScanner.getIncludedFiles();\n\n      for (String relativeFilePath : files)\n      {\n         String baseName = FilenameUtils.removeExtension(relativeFilePath);\n         localDocNames.add(baseName);\n      }\n      return localDocNames;\n   }","commit_id":"85e091a44009ac1c5c490eae58fbd886a1214ab4","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void run() throws Exception\n   {\n      log.info(\"Server: {}\", opts.getUrl());\n      log.info(\"Project: {}\", opts.getProj());\n      log.info(\"Version: {}\", opts.getProjectVersion());\n      log.info(\"Username: {}\", opts.getUsername());\n      log.info(\"Project type: {}\", opts.getProjectType());\n      log.info(\"Source language: {}\", opts.getSourceLang());\n      log.info(\"Copy previous translations: {}\", opts.getCopyTrans());\n      log.info(\"Merge type: {}\", opts.getMergeType());\n      log.info(\"Include file pattern: {}\", opts.getIncludeFilePattern());\n      log.info(\"Exclude file pattern: {}\", opts.getExcludeFilePattern());\n\n      if (opts.getPushTrans())\n      {\n         log.info(\"Pushing source and target documents\");\n      }\n      else\n      {\n         log.info(\"Pushing source documents only\");\n      }\n      log.info(\"Source directory (originals): {}\", opts.getSrcDir());\n      if (opts.getPushTrans())\n      {\n         log.info(\"Target base directory (translations): {}\", opts.getTransDir());\n      }\n      File sourceDir = opts.getSrcDir();\n\n      if (!sourceDir.exists())\n      {\n         throw new RuntimeException(\"directory '\" + sourceDir + \"' does not exist - check sourceDir option\");\n      }\n\n      if (opts.getPushTrans())\n      {\n         if (opts.getLocales() == null)\n            throw new ConfigException(\"pushTrans option set, but zanata.xml contains no <locales>\");\n         log.warn(\"pushTrans option is set: existing translations on server may be overwritten/deleted\");\n         confirmWithUser(\"This will overwrite/delete any existing documents AND TRANSLATIONS on the server.\\n\");\n      }\n      else\n      {\n         confirmWithUser(\"This will overwrite/delete any existing documents on the server.\\n\");\n      }\n\n      PushStrategy strat = getStrategy(opts.getProjectType());\n\n      JAXBContext jc = null;\n      if (opts.isDebugSet()) // || opts.getValidate())\n      {\n         jc = JAXBContext.newInstance(Resource.class, TranslationsResource.class);\n      }\n      if (opts.isDebugSet())\n      {\n         m = jc.createMarshaller();\n         m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n      }\n\n      // NB we don't load all the docs into a HashMap, because that would waste\n      // memory\n      AndFileFilter fileFilter = new AndFileFilter();\n\n      WildcardFileFilter includeFilter = new WildcardFileFilter(opts.getIncludeFilePattern());\n      fileFilter.addFileFilter(includeFilter);\n\n      if (!StringUtils.isEmpty(opts.getExcludeFilePattern()))\n      {\n         NotFileFilter excludeFilter = new NotFileFilter(new WildcardFileFilter(opts.getExcludeFilePattern()));\n         fileFilter.addFileFilter(excludeFilter);\n      }\n\n      Set<String> localDocNames = strat.findDocNames(sourceDir, fileFilter);\n      deleteObsoleteDocsFromServer(localDocNames);\n\n      for (String docName : localDocNames)\n      {\n         final String docUri = RestUtil.convertToDocumentURIId(docName);\n         final Resource srcDoc = strat.loadSrcDoc(sourceDir, docName);\n         debug(srcDoc);\n         // if (opts.getValidate())\n         // {\n         // JaxbUtil.validateXml(srcDoc, jc);\n         // }\n\n         final StringSet extensions = strat.getExtensions();\n         log.info(\"pushing source document [name={}] to server\", srcDoc.getName());\n         boolean copyTrans = opts.getCopyTrans();\n         ClientResponse<String> putResponse = translationResources.putResource(docUri, srcDoc, extensions, copyTrans);\n         ClientUtility.checkResult(putResponse, uri);\n\n         if (opts.getPushTrans())\n         {\n            strat.visitTranslationResources(docName, srcDoc, new TranslationResourcesVisitor()\n            {\n               @Override\n               public void visit(LocaleMapping locale, TranslationsResource targetDoc)\n               {\n                  debug(targetDoc);\n                  // if (opts.getValidate())\n                  // {\n                  // JaxbUtil.validateXml(targetDoc, jc);\n                  // }\n                  log.info(\"pushing target document [name={} client-locale={}] to server [locale={}]\", new Object[] { srcDoc.getName(), locale.getLocalLocale(), locale.getLocale() });\n                  ClientResponse<String> putTransResponse = translationResources.putTranslations(docUri, new LocaleId(locale.getLocale()), targetDoc, extensions, opts.getMergeType());\n                  ClientUtility.checkResult(putTransResponse, uri);\n                  String entity = putTransResponse.getEntity(String.class);\n                  if (entity != null && !entity.isEmpty())\n                  {\n                     log.warn(\"{}\", entity);\n                  }\n               }\n            });\n         }\n      }\n   }","id":49335,"modified_method":"@Override\n   public void run() throws Exception\n   {\n      log.info(\"Server: {}\", opts.getUrl());\n      log.info(\"Project: {}\", opts.getProj());\n      log.info(\"Version: {}\", opts.getProjectVersion());\n      log.info(\"Username: {}\", opts.getUsername());\n      log.info(\"Project type: {}\", opts.getProjectType());\n      log.info(\"Source language: {}\", opts.getSourceLang());\n      log.info(\"Copy previous translations: {}\", opts.getCopyTrans());\n      log.info(\"Merge type: {}\", opts.getMergeType());\n\n      if (!opts.getIncludes().isEmpty())\n      {\n         StringBuilder sb = new StringBuilder();\n         for (String pattern : opts.getIncludes())\n         {\n            sb.append(pattern);\n            sb.append(\" \");\n         }\n         log.info(\"Include patterns: {}\", sb.toString());\n      }\n\n      if (!opts.getExcludes().isEmpty())\n      {\n         StringBuilder sb = new StringBuilder();\n         for(String pattern:opts.getExcludes())\n         {\n            sb.append(pattern);\n            sb.append(\" \");\n         }\n         log.info(\"Exclude patterns: {}\", sb.toString());\n      }\n\n\n      if (opts.getPushTrans())\n      {\n         log.info(\"Pushing source and target documents\");\n      }\n      else\n      {\n         log.info(\"Pushing source documents only\");\n      }\n      log.info(\"Source directory (originals): {}\", opts.getSrcDir());\n      if (opts.getPushTrans())\n      {\n         log.info(\"Target base directory (translations): {}\", opts.getTransDir());\n      }\n      File sourceDir = opts.getSrcDir();\n\n      if (!sourceDir.exists())\n      {\n         throw new RuntimeException(\"directory '\" + sourceDir + \"' does not exist - check sourceDir option\");\n      }\n\n      if (opts.getPushTrans())\n      {\n         if (opts.getLocales() == null)\n            throw new ConfigException(\"pushTrans option set, but zanata.xml contains no <locales>\");\n         log.warn(\"pushTrans option is set: existing translations on server may be overwritten/deleted\");\n         confirmWithUser(\"This will overwrite/delete any existing documents AND TRANSLATIONS on the server.\\n\");\n      }\n      else\n      {\n         confirmWithUser(\"This will overwrite/delete any existing documents on the server.\\n\");\n      }\n\n      PushStrategy strat = getStrategy(opts.getProjectType());\n\n      JAXBContext jc = null;\n      if (opts.isDebugSet()) // || opts.getValidate())\n      {\n         jc = JAXBContext.newInstance(Resource.class, TranslationsResource.class);\n      }\n      if (opts.isDebugSet())\n      {\n         m = jc.createMarshaller();\n         m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n      }\n\n      // NB we don't load all the docs into a HashMap, because that would waste\n      // memory\n\n      Set<String> localDocNames = strat.findDocNames(sourceDir, opts.getIncludes(), opts.getExcludes());\n      for (String docName : localDocNames)\n      {\n         log.info(\"Source file to be uploaded: {}\", docName);\n      }\n      deleteObsoleteDocsFromServer(localDocNames);\n\n      for (String docName : localDocNames)\n      {\n         final String docUri = RestUtil.convertToDocumentURIId(docName);\n         final Resource srcDoc = strat.loadSrcDoc(sourceDir, docName);\n         debug(srcDoc);\n         // if (opts.getValidate())\n         // {\n         // JaxbUtil.validateXml(srcDoc, jc);\n         // }\n\n         final StringSet extensions = strat.getExtensions();\n         log.info(\"pushing source document [name={}] to server\", srcDoc.getName());\n         boolean copyTrans = opts.getCopyTrans();\n         ClientResponse<String> putResponse = translationResources.putResource(docUri, srcDoc, extensions, copyTrans);\n         ClientUtility.checkResult(putResponse, uri);\n\n         if (opts.getPushTrans())\n         {\n            strat.visitTranslationResources(docName, srcDoc, new TranslationResourcesVisitor()\n            {\n               @Override\n               public void visit(LocaleMapping locale, TranslationsResource targetDoc)\n               {\n                  debug(targetDoc);\n                  // if (opts.getValidate())\n                  // {\n                  // JaxbUtil.validateXml(targetDoc, jc);\n                  // }\n                  log.info(\"pushing target document [name={} client-locale={}] to server [locale={}]\", new Object[] { srcDoc.getName(), locale.getLocalLocale(), locale.getLocale() });\n                  ClientResponse<String> putTransResponse = translationResources.putTranslations(docUri, new LocaleId(locale.getLocale()), targetDoc, extensions, opts.getMergeType());\n                  ClientUtility.checkResult(putTransResponse, uri);\n                  String entity = putTransResponse.getEntity(String.class);\n                  if (entity != null && !entity.isEmpty())\n                  {\n                     log.warn(\"{}\", entity);\n                  }\n               }\n            });\n         }\n      }\n   }","commit_id":"85e091a44009ac1c5c490eae58fbd886a1214ab4","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public Resource loadSrcDoc(File sourceDir, String docName) throws IOException\n   {\n      File srcFile = null;\n\t   for(String file:sourceFiles){\n\t      if(file.startsWith(docName) && file.endsWith(XML_EXTENSION)){\n\t         srcFile = new File(sourceDir, file);\n\t         break;\n\t      }\n\t   }\n      InputSource srcInputSource = new InputSource(new FileInputStream(srcFile));\n      return reader.extractTemplate(srcInputSource, new LocaleId(opts.getSourceLang()), docName);\n   }","id":49336,"modified_method":"@Override\n   public Resource loadSrcDoc(File sourceDir, String docName) throws IOException\n   {\n      File srcFile = null;\n\t   for(String file:sourceFiles){\n         if (file.startsWith(docName) && file.endsWith(\".xml\"))\n         {\n\t         srcFile = new File(sourceDir, file);\n\t         break;\n\t      }\n\t   }\n      InputSource srcInputSource = new InputSource(new FileInputStream(srcFile));\n      return reader.extractTemplate(srcInputSource, new LocaleId(opts.getSourceLang()), docName);\n   }","commit_id":"85e091a44009ac1c5c490eae58fbd886a1214ab4","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void visitTranslationResources(String docName, Resource srcDoc, TranslationResourcesVisitor visitor) throws FileNotFoundException\n   {\n      for (LocaleMapping locale : opts.getLocales())\n      {\n         File transFile = new File(opts.getTransDir(), docName + \"_\" + locale.getJavaLocale() + XML_EXTENSION);\n         if (transFile.exists())\n         {\n            InputSource inputSource = new InputSource(new FileInputStream(transFile));\n            inputSource.setEncoding(\"utf8\");\n            // TODO opts.getUseSourceOrder()\n            TranslationsResource targetDoc = reader.extractTarget(inputSource);\n            visitor.visit(locale, targetDoc);\n         }\n      }\n   }","id":49337,"modified_method":"@Override\n   public void visitTranslationResources(String docName, Resource srcDoc, TranslationResourcesVisitor visitor) throws FileNotFoundException\n   {\n      for (LocaleMapping locale : opts.getLocales())\n      {\n         File transFile = new File(opts.getTransDir(), docName + \"_\" + locale.getJavaLocale() + \".xml\");\n         if (transFile.exists())\n         {\n            InputSource inputSource = new InputSource(new FileInputStream(transFile));\n            inputSource.setEncoding(\"utf8\");\n            // TODO opts.getUseSourceOrder()\n            TranslationsResource targetDoc = reader.extractTarget(inputSource);\n            visitor.visit(locale, targetDoc);\n         }\n      }\n   }","commit_id":"85e091a44009ac1c5c490eae58fbd886a1214ab4","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void setPushOptions(PushOptions opts)\n   {\n      this.opts = opts;\n\n   }","id":49338,"modified_method":"@Override\n   public Set<String> findDocNames(File srcDir, List<String> includes, List<String> excludes) throws IOException\n   {\n      sourceFiles = new HashSet<String>();\n      Set<String> localDocNames = new HashSet<String>();\n\n      includes.add(\"**/*.xml\");\n      for (LocaleMapping locMap : opts.getLocales())\n      {\n         String loc = locMap.getJavaLocale().toLowerCase();\n         excludes.add(\"**/*_\" + loc + \".xml\");\n      }\n\n      DirectoryScanner dirScanner = new DirectoryScanner();\n      dirScanner.setBasedir(srcDir);\n      dirScanner.setCaseSensitive(false);\n      dirScanner.setExcludes((String[]) excludes.toArray(new String[excludes.size()]));\n      dirScanner.setIncludes((String[]) includes.toArray(new String[includes.size()]));\n      dirScanner.scan();\n      String[] files = dirScanner.getIncludedFiles();\n\n      for (String relativeFilePath : files)\n      {\n         sourceFiles.add(relativeFilePath);\n         String baseName = FilenameUtils.removeExtension(relativeFilePath);\n         baseName = trimLocaleFromFile(baseName);\n         localDocNames.add(baseName);\n      }\n      return localDocNames;\n   }","commit_id":"85e091a44009ac1c5c490eae58fbd886a1214ab4","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void loadSrcDocTestWithExcludeOption() throws IOException\n   {\n      XliffStrategy xliffStrategy = new XliffStrategy();\n\n      mockPushOption = createMock(\"mockPushOption\", PushOptions.class);\n      EasyMock.expect(mockPushOption.getIncludeFilePattern()).andReturn(\"*StringResource_en_US*\");\n      EasyMock.expect(mockPushOption.getTransDir()).andReturn(sourceDir).anyTimes();\n      EasyMock.expect(mockPushOption.getLocales()).andReturn(locales).anyTimes();\n      EasyMock.expect(mockPushOption.getSourceLang()).andReturn(\"en-US\").anyTimes();\n      EasyMock.expect(mockPushOption.getExcludeFilePattern()).andReturn(\"*StringResource*\").anyTimes();\n\n      xliffStrategy.setPushOptions(mockPushOption);\n      EasyMock.replay(mockPushOption);\n\n      AndFileFilter fileFilter = new AndFileFilter();\n      WildcardFileFilter includeFilter = new WildcardFileFilter(mockPushOption.getIncludeFilePattern());\n      fileFilter.addFileFilter(includeFilter);\n\n      NotFileFilter excludeFilter = new NotFileFilter(new WildcardFileFilter(mockPushOption.getExcludeFilePattern()));\n      fileFilter.addFileFilter(excludeFilter);\n\n      Set<String> localDocNames = xliffStrategy.findDocNames(sourceDir, fileFilter);\n      List<Resource> resourceList = new ArrayList<Resource>();\n      for (String docName : localDocNames)\n      {\n         Resource srcDoc = xliffStrategy.loadSrcDoc(sourceDir, docName);\n         resourceList.add(srcDoc);\n\n         TranslationResourcesVisitor visitor = EasyMock.createMock(\"visitor\" + resourceList.size(), TranslationResourcesVisitor.class);\n         LocaleMapping loc;\n         // each src file in test has one trans file ('de' or 'fr'):\n         if (srcDoc.getName().equals(\"dir1/StringResource\"))\n         {\n            loc = new LocaleMapping(\"de\");\n         }\n         else\n         {\n            loc = new LocaleMapping(\"fr\");\n         }\n         visitor.visit(eq(loc), EasyMock.anyObject(TranslationsResource.class));\n         EasyMock.replay(visitor);\n         xliffStrategy.visitTranslationResources(docName, srcDoc, visitor);\n         EasyMock.verify(visitor);\n      }\n      System.out.println(\"loadSrcDocTestWithExclude || Total source docs:\" + localDocNames.size());\n      control.verify();\n\n      Assert.assertEquals(0, resourceList.size());\n   }","id":49339,"modified_method":"@Test\n   public void loadSrcDocTestWithExcludeOption() throws IOException\n   {\n      XliffStrategy xliffStrategy = new XliffStrategy();\n\n      mockPushOption = createMock(\"mockPushOption\", PushOptions.class);\n      List<String> include = new ArrayList<String>();\n      include.add(\"*StringResource_en_US*\");\n\n      // EasyMock.expect(mockPushOption.getIncludes()).andReturn(include);\n      EasyMock.expect(mockPushOption.getTransDir()).andReturn(sourceDir).anyTimes();\n      EasyMock.expect(mockPushOption.getLocales()).andReturn(locales).anyTimes();\n      EasyMock.expect(mockPushOption.getSourceLang()).andReturn(\"en-US\").anyTimes();\n\n      List<String> exclude = new ArrayList<String>();\n      exclude.add(\"**/dir2/*\");\n      // EasyMock.expect(mockPushOption.getExcludes()).andReturn(exclude).anyTimes();\n\n      xliffStrategy.setPushOptions(mockPushOption);\n      EasyMock.replay(mockPushOption);\n\n      Set<String> localDocNames = xliffStrategy.findDocNames(sourceDir, include, exclude);\n      List<Resource> resourceList = new ArrayList<Resource>();\n      for (String docName : localDocNames)\n      {\n         Resource srcDoc = xliffStrategy.loadSrcDoc(sourceDir, docName);\n         resourceList.add(srcDoc);\n\n         TranslationResourcesVisitor visitor = EasyMock.createMock(\"visitor\" + resourceList.size(), TranslationResourcesVisitor.class);\n         LocaleMapping loc;\n         // each src file in test has one trans file ('de' or 'fr'):\n         if (srcDoc.getName().equals(\"dir1/StringResource\"))\n         {\n            loc = new LocaleMapping(\"de\");\n         }\n         else\n         {\n            loc = new LocaleMapping(\"fr\");\n         }\n         visitor.visit(eq(loc), EasyMock.anyObject(TranslationsResource.class));\n         EasyMock.replay(visitor);\n         xliffStrategy.visitTranslationResources(docName, srcDoc, visitor);\n         EasyMock.verify(visitor);\n      }\n      System.out.println(\"loadSrcDocTestWithExcludeDirOption || Total source docs:\" + localDocNames.size());\n      control.verify();\n\n      Assert.assertEquals(1, resourceList.size());\n   }","commit_id":"85e091a44009ac1c5c490eae58fbd886a1214ab4","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void loadSrcDocTest() throws IOException\n   {\n      XliffStrategy xliffStrategy = new XliffStrategy();\n\n      mockPushOption = createMock(\"mockPushOption\", PushOptions.class);\n      EasyMock.expect(mockPushOption.getIncludeFilePattern()).andReturn(\"*StringResource_en_US*\");\n      EasyMock.expect(mockPushOption.getTransDir()).andReturn(sourceDir).anyTimes();\n      EasyMock.expect(mockPushOption.getLocales()).andReturn(locales).anyTimes();\n      EasyMock.expect(mockPushOption.getSourceLang()).andReturn(\"en-US\").anyTimes();\n\n      xliffStrategy.setPushOptions(mockPushOption);\n      EasyMock.replay(mockPushOption);\n\n      AndFileFilter fileFilter = new AndFileFilter();\n      WildcardFileFilter includeFilter = new WildcardFileFilter(mockPushOption.getIncludeFilePattern());\n      fileFilter.addFileFilter(includeFilter);\n\n      Set<String> localDocNames = xliffStrategy.findDocNames(sourceDir, fileFilter);\n      List<Resource> resourceList = new ArrayList<Resource>();\n      for (String docName : localDocNames)\n      {\n         Resource srcDoc = xliffStrategy.loadSrcDoc(sourceDir, docName);\n         resourceList.add(srcDoc);\n\n         TranslationResourcesVisitor visitor = EasyMock.createMock(\"visitor\" + resourceList.size(), TranslationResourcesVisitor.class);\n         LocaleMapping loc;\n         // each src file in test has one trans file ('de' or 'fr'):\n         if (srcDoc.getName().equals(\"dir1/StringResource\"))\n         {\n            loc = new LocaleMapping(\"de\");\n         }\n         else\n         {\n            loc = new LocaleMapping(\"fr\");\n         }\n         visitor.visit(eq(loc), EasyMock.anyObject(TranslationsResource.class));\n         EasyMock.replay(visitor);\n         xliffStrategy.visitTranslationResources(docName, srcDoc, visitor);\n         EasyMock.verify(visitor);\n      }\n      System.out.println(\"loadSrcDocTest || Total source docs:\" + localDocNames.size());\n      control.verify();\n\n      Assert.assertEquals(2, resourceList.size());\n   }","id":49340,"modified_method":"@Test\n   public void loadSrcDocTest() throws IOException\n   {\n      XliffStrategy xliffStrategy = new XliffStrategy();\n\n      mockPushOption = createMock(\"mockPushOption\", PushOptions.class);\n      List<String> include = new ArrayList<String>();\n      include.add(\"*StringResource_en_US*\");\n\n      // EasyMock.expect(mockPushOption.getIncludes()).andReturn(include);\n      EasyMock.expect(mockPushOption.getTransDir()).andReturn(sourceDir).anyTimes();\n      EasyMock.expect(mockPushOption.getLocales()).andReturn(locales).anyTimes();\n      EasyMock.expect(mockPushOption.getSourceLang()).andReturn(\"en-US\").anyTimes();\n\n      xliffStrategy.setPushOptions(mockPushOption);\n      EasyMock.replay(mockPushOption);\n\n      Set<String> localDocNames = xliffStrategy.findDocNames(sourceDir, include, new ArrayList<String>());\n      List<Resource> resourceList = new ArrayList<Resource>();\n      for (String docName : localDocNames)\n      {\n         Resource srcDoc = xliffStrategy.loadSrcDoc(sourceDir, docName);\n         resourceList.add(srcDoc);\n\n         TranslationResourcesVisitor visitor = EasyMock.createMock(\"visitor\" + resourceList.size(), TranslationResourcesVisitor.class);\n         LocaleMapping loc;\n         // each src file in test has one trans file ('de' or 'fr'):\n         if (srcDoc.getName().equals(\"dir1/StringResource\"))\n         {\n            loc = new LocaleMapping(\"de\");\n         }\n         else\n         {\n            loc = new LocaleMapping(\"fr\");\n         }\n         visitor.visit(eq(loc), EasyMock.anyObject(TranslationsResource.class));\n         EasyMock.replay(visitor);\n         xliffStrategy.visitTranslationResources(docName, srcDoc, visitor);\n         EasyMock.verify(visitor);\n      }\n      System.out.println(\"loadSrcDocTest || Total source docs:\" + localDocNames.size());\n      control.verify();\n\n      Assert.assertEquals(3, resourceList.size());\n   }","commit_id":"85e091a44009ac1c5c490eae58fbd886a1214ab4","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void findDocNamesTest() throws IOException\n   {\n      XliffStrategy xliffStrategy = new XliffStrategy();\n\n      mockPushOption = createMock(\"mockPushOption\", PushOptions.class);\n      EasyMock.expect(mockPushOption.getIncludeFilePattern()).andReturn(\"*StringResource_en_US*\");\n      EasyMock.expect(mockPushOption.getLocales()).andReturn(locales).anyTimes();\n      EasyMock.expect(mockPushOption.getSourceLang()).andReturn(\"en-US\").anyTimes();\n\n      xliffStrategy.setPushOptions(mockPushOption);\n      EasyMock.replay(mockPushOption);\n     \n      AndFileFilter fileFilter = new AndFileFilter();\n      WildcardFileFilter includeFilter = new WildcardFileFilter(mockPushOption.getIncludeFilePattern());\n      fileFilter.addFileFilter(includeFilter);\n\n      Set<String> localDocNames = xliffStrategy.findDocNames(sourceDir, fileFilter);\n\n      control.verify();\n      for (String docName : localDocNames)\n         System.out.println(\"findDocNamesTest || Source doc name || \" + docName);\n      System.out.println(\"findDocNamesTest || Total source docs || \" + localDocNames.size());\n      Assert.assertEquals(2, localDocNames.size());\n   }","id":49341,"modified_method":"@Test\n   public void findDocNamesTest() throws IOException\n   {\n      XliffStrategy xliffStrategy = new XliffStrategy();\n\n      mockPushOption = createMock(\"mockPushOption\", PushOptions.class);\n      List<String> include = new ArrayList<String>();\n      include.add(\"*StringResource*\");\n\n      // EasyMock.expect(mockPushOption.getIncludes()).andReturn(include);\n      EasyMock.expect(mockPushOption.getLocales()).andReturn(locales).anyTimes();\n      EasyMock.expect(mockPushOption.getSourceLang()).andReturn(\"en-US\").anyTimes();\n\n      xliffStrategy.setPushOptions(mockPushOption);\n      EasyMock.replay(mockPushOption);\n\n      Set<String> localDocNames = xliffStrategy.findDocNames(sourceDir, include, new ArrayList<String>());\n\n      control.verify();\n      for (String docName : localDocNames)\n         System.out.println(\"findDocNamesTest || Source doc name:\" + docName);\n      System.out.println(\"findDocNamesTest || Total source docs:\" + localDocNames.size());\n      Assert.assertEquals(3, localDocNames.size());\n   }","commit_id":"85e091a44009ac1c5c490eae58fbd886a1214ab4","url":"https://github.com/zanata/zanata-server"},{"original_method":"private String docNameToFilename(String docName, LocaleMapping locale)\n   {\n      return docName + \"_\" + locale.getJavaLocale() + \".xml\";\n   }","id":49342,"modified_method":"@Override\n   public Set<String> findDocNames(File srcDir, List<String> includes, List<String> excludes) throws IOException\n   {\n      Set<String> localDocNames = new HashSet<String>();\n\n      includes.add(\"**/*.xml\");\n      for (LocaleMapping locMap : pushOptions.getLocales())\n      {\n         String loc = locMap.getJavaLocale().toLowerCase();\n         excludes.add(\"**/*_\" + loc + \".xml\");\n      }\n\n      DirectoryScanner dirScanner = new DirectoryScanner();\n      dirScanner.setBasedir(srcDir);\n      dirScanner.setCaseSensitive(false);\n      dirScanner.setExcludes((String[]) excludes.toArray(new String[excludes.size()]));\n      dirScanner.setIncludes((String[]) includes.toArray(new String[includes.size()]));\n      dirScanner.scan();\n      String[] files = dirScanner.getIncludedFiles();\n\n      for (String relativeFilePath : files)\n      {\n         String baseName = FilenameUtils.removeExtension(relativeFilePath);\n         localDocNames.add(baseName);\n      }\n      return localDocNames;\n   }","commit_id":"85e091a44009ac1c5c490eae58fbd886a1214ab4","url":"https://github.com/zanata/zanata-server"},{"original_method":"public boolean login() {\n        PostMethod method = postMethod;\n        method.setPath(\"/ws.v1/login\"); // NOTE: /ws.v1/login is correct\n        method.addParameter(\"username\", username);\n        method.addParameter(\"password\", password);\n\n        try {\n            client.executeMethod(method);\n        } catch (HttpException e) {\n            s_logger.info(\"Login \" + username + \" to \" + apiUrl + \" failed\", e);\n            return false;\n        } catch (IOException e) {\n            s_logger.info(\"Login \" + username + \" to \" + apiUrl + \" failed\", e);\n            return false;\n        } finally {\n            method.releaseConnection();\n        }\n        String apiCallPath = null;\n        try {\n            apiCallPath = method.getName() + \" \" + method.getURI().toString();\n        } catch (URIException e) {\n            s_logger.error(\"method getURI failed\", e);\n        }\n        s_logger.info(\"ssp api call:\" + apiCallPath + \" user=\" + username + \" status=\" + method.getStatusLine());\n        if (method.getStatusCode() == HttpStatus.SC_OK) {\n            return true;\n        }\n        return false;\n    }","id":49343,"modified_method":"public boolean login() {\n        HttpPost method = new HttpPost();\n        try {\n            method.setEntity(new UrlEncodedFormEntity(Arrays.asList(\n                    new BasicNameValuePair(\"username\", username),\n                    new BasicNameValuePair(\"password\", password))));\n        } catch (UnsupportedEncodingException e) {\n            s_logger.error(\"invalid username or password\", e);\n            return false;\n        }\n\n        HttpResponse res = this.innerExecuteMethod(method, \"/ws.v1/login\");\n        if (res != null && res.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n            return true;\n        }\n        return false;\n    }","commit_id":"cb048f4108b53dd811803abaa0b613e86b33d607","url":"https://github.com/apache/cloudstack"},{"original_method":"public TenantPort createTenantPort(String tenantNetworkUuid) {\n        TenantPort req = new TenantPort();\n        req.networkUuid = tenantNetworkUuid;\n        req.attachmentType = \"NoAttachment\";\n\n        PostMethod method = postMethod;\n        method.setPath(\"/ssp.v1/tenant-ports\");\n        StringRequestEntity entity = null;\n        try {\n            entity = new StringRequestEntity(new Gson().toJson(req), \"application/json\", \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            s_logger.error(\"failed creating http request body\", e);\n            return null;\n        }\n        method.setRequestEntity(entity);\n\n        String response = executeMethod(method);\n        if (response != null && method.getStatusCode() == HttpStatus.SC_CREATED) {\n            return new Gson().fromJson(response, TenantPort.class);\n        }\n        return null;\n    }","id":49344,"modified_method":"public TenantPort createTenantPort(String tenantNetworkUuid) {\n        TenantPort req = new TenantPort();\n        req.networkUuid = tenantNetworkUuid;\n        req.attachmentType = \"NoAttachment\";\n\n        HttpPost method = new HttpPost();\n        method.setEntity(new StringEntity(new Gson().toJson(req), ContentType.APPLICATION_JSON));\n        HttpResponse res = executeMethod(method, \"/ssp.v1/tenant-ports\");\n\n        if (res == null || res.getStatusLine().getStatusCode() != HttpStatus.SC_CREATED) {\n            return null;\n        }\n        try {\n            return new Gson().fromJson(new InputStreamReader(res.getEntity().getContent()),\n                    TenantPort.class);\n        } catch (JsonSyntaxException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (JsonIOException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (IllegalStateException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (IOException e) {\n            s_logger.error(\"reading response body failed\", e);\n        }\n        return null;\n    }","commit_id":"cb048f4108b53dd811803abaa0b613e86b33d607","url":"https://github.com/apache/cloudstack"},{"original_method":"public TenantPort updateTenantVifBinding(String portUuid, String hypervisorIpAddress) {\n        TenantPort req = new TenantPort();\n        if (hypervisorIpAddress != null) {\n            req.attachmentType = \"VifAttachment\";\n            req.hypervisorIpAddress = hypervisorIpAddress;\n        } else {\n            req.attachmentType = \"NoAttachment\";\n        }\n\n        PutMethod method = putMethod;\n        method.setPath(\"/ssp.v1/tenant-ports/\" + portUuid);\n        StringRequestEntity entity = null;\n        try {\n            entity = new StringRequestEntity(new Gson().toJson(req), \"application/json\", \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            s_logger.error(\"failed creating http request body\", e);\n            return null;\n        }\n        method.setRequestEntity(entity);\n\n        String response = executeMethod(method);\n        if (response != null && method.getStatusCode() == HttpStatus.SC_OK) {\n            return new Gson().fromJson(response, TenantPort.class);\n        }\n        return null;\n    }","id":49345,"modified_method":"public TenantPort updateTenantVifBinding(String portUuid, String hypervisorIpAddress) {\n        TenantPort req = new TenantPort();\n        if (hypervisorIpAddress != null) {\n            req.attachmentType = \"VifAttachment\";\n            req.hypervisorIpAddress = hypervisorIpAddress;\n        } else {\n            req.attachmentType = \"NoAttachment\";\n        }\n\n        HttpPut method = new HttpPut();\n        method.setEntity(new StringEntity(new Gson().toJson(req), ContentType.APPLICATION_JSON));\n        HttpResponse res = executeMethod(method, \"/ssp.v1/tenant-ports/\" + portUuid);\n        if (res == null || res.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {\n            return null;\n        }\n        try {\n            return new Gson().fromJson(new InputStreamReader(res.getEntity().getContent()),\n                    TenantPort.class);\n        } catch (JsonSyntaxException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (JsonIOException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (IllegalStateException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (IOException e) {\n            s_logger.error(\"reading response body failed\", e);\n        }\n        return null;\n    }","commit_id":"cb048f4108b53dd811803abaa0b613e86b33d607","url":"https://github.com/apache/cloudstack"},{"original_method":"private String executeMethod(HttpMethod method) {\n        String apiCallPath = null;\n        try {\n            apiCallPath = method.getName() + \" \" + method.getURI().toString();\n        } catch (URIException e) {\n            s_logger.error(\"method getURI failed\", e);\n        }\n\n        String response = null;\n        try {\n            client.executeMethod(method);\n            response = method.getResponseBodyAsString();\n        } catch (HttpException e) {\n            s_logger.error(\"ssp api call failed \" + apiCallPath, e);\n            return null;\n        } catch (IOException e) {\n            s_logger.error(\"ssp api call failed \" + apiCallPath, e);\n            return null;\n        } finally {\n            method.releaseConnection();\n        }\n\n        if (method.getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {\n            if (!login()) {\n                return null;\n            }\n\n            try {\n                client.executeMethod(method);\n                response = method.getResponseBodyAsString();\n            } catch (HttpException e) {\n                s_logger.error(\"ssp api call failed \" + apiCallPath, e);\n                return null;\n            } catch (IOException e) {\n                s_logger.error(\"ssp api call failed \" + apiCallPath, e);\n                return null;\n            } finally {\n                method.releaseConnection();\n            }\n        }\n        s_logger.info(\"ssp api call:\" + apiCallPath + \" user=\" + username + \" status=\" + method.getStatusLine());\n        if (method instanceof EntityEnclosingMethod) {\n            EntityEnclosingMethod emethod = (EntityEnclosingMethod)method;\n            RequestEntity reqEntity = emethod.getRequestEntity();\n            if (reqEntity instanceof StringRequestEntity) {\n                StringRequestEntity strReqEntity = (StringRequestEntity)reqEntity;\n                s_logger.debug(\"ssp api request body:\" + strReqEntity.getContent());\n            } else {\n                s_logger.debug(\"ssp api request body:\" + emethod.getRequestEntity());\n            }\n        }\n        s_logger.debug(\"ssp api response body:\" + response);\n        return response;\n    }","id":49346,"modified_method":"private HttpResponse executeMethod(HttpRequestBase req, String path) {\n        HttpResponse res = innerExecuteMethod(req, path);\n        if (res.getStatusLine().getStatusCode() == HttpStatus.SC_UNAUTHORIZED && login()) {\n            req.reset();\n            res = innerExecuteMethod(req, path);\n        }\n        return res;\n    }","commit_id":"cb048f4108b53dd811803abaa0b613e86b33d607","url":"https://github.com/apache/cloudstack"},{"original_method":"public SspClient(String apiUrl, String username, String password) {\n        super();\n        this.apiUrl = apiUrl;\n        this.username = username;\n        this.password = password;\n        client = new HttpClient(s_httpclient_params, s_httpclient_manager);\n        postMethod = new PostMethod(apiUrl);\n        deleteMethod = new DeleteMethod(apiUrl);\n        putMethod = new PutMethod(apiUrl);\n    }","id":49347,"modified_method":"public SspClient(String apiUrl, String username, String password) {\n        super();\n        this.apiUrl = apiUrl;\n        this.username = username;\n        this.password = password;\n    }","commit_id":"cb048f4108b53dd811803abaa0b613e86b33d607","url":"https://github.com/apache/cloudstack"},{"original_method":"public boolean deleteTenantNetwork(String tenantNetworkUuid) {\n        DeleteMethod method = deleteMethod;\n        method.setPath(\"/ssp.v1/tenant-networks/\" + tenantNetworkUuid);\n\n        executeMethod(method);\n        if (method.getStatusCode() == HttpStatus.SC_NO_CONTENT) {\n            return true;\n        }\n        return false;\n    }","id":49348,"modified_method":"public boolean deleteTenantNetwork(String tenantNetworkUuid) {\n        HttpDelete method = new HttpDelete();\n        HttpResponse res = executeMethod(method, \"/ssp.v1/tenant-networks/\" + tenantNetworkUuid);\n        if (res != null && res.getStatusLine().getStatusCode() == HttpStatus.SC_NO_CONTENT) {\n            return true;\n        }\n        return false;\n    }","commit_id":"cb048f4108b53dd811803abaa0b613e86b33d607","url":"https://github.com/apache/cloudstack"},{"original_method":"public boolean deleteTenantPort(String tenantPortUuid) {\n        DeleteMethod method = deleteMethod;\n        method.setPath(\"/ssp.v1/tenant-ports/\" + tenantPortUuid);\n\n        executeMethod(method);\n        if (method.getStatusCode() == HttpStatus.SC_NO_CONTENT) {\n            return true;\n        }\n        return false;\n    }","id":49349,"modified_method":"public boolean deleteTenantPort(String tenantPortUuid) {\n        HttpDelete method = new HttpDelete();\n        HttpResponse res = executeMethod(method, \"/ssp.v1/tenant-ports/\" + tenantPortUuid);\n\n        if (res != null && res.getStatusLine().getStatusCode() == HttpStatus.SC_NO_CONTENT) {\n            return true;\n        }\n        return false;\n    }","commit_id":"cb048f4108b53dd811803abaa0b613e86b33d607","url":"https://github.com/apache/cloudstack"},{"original_method":"public TenantNetwork createTenantNetwork(String tenantUuid, String networkName) {\n        TenantNetwork req = new TenantNetwork();\n        req.name = networkName;\n        req.tenantUuid = tenantUuid;\n\n        PostMethod method = postMethod;\n        method.setPath(\"/ssp.v1/tenant-networks\");\n        StringRequestEntity entity = null;\n        try {\n            entity = new StringRequestEntity(new Gson().toJson(req), \"application/json\", \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            s_logger.error(\"failed creating http request body\", e);\n            return null;\n        }\n        method.setRequestEntity(entity);\n\n        String response = executeMethod(method);\n        if (response != null && method.getStatusCode() == HttpStatus.SC_CREATED) {\n            return new Gson().fromJson(response, TenantNetwork.class);\n        }\n        return null;\n    }","id":49350,"modified_method":"public TenantNetwork createTenantNetwork(String tenantUuid, String networkName) {\n        TenantNetwork req = new TenantNetwork();\n        req.name = networkName;\n        req.tenantUuid = tenantUuid;\n\n        HttpPost method = new HttpPost();\n        method.setEntity(new StringEntity(new Gson().toJson(req), ContentType.APPLICATION_JSON));\n        HttpResponse res = executeMethod(method, \"/ssp.v1/tenant-networks\");\n        if (res == null || res.getStatusLine().getStatusCode() != HttpStatus.SC_CREATED) {\n            return null;\n        }\n        try {\n            return new Gson().fromJson(new InputStreamReader(res.getEntity().getContent()),\n                    TenantNetwork.class);\n        } catch (JsonSyntaxException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (JsonIOException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (IllegalStateException e) {\n            s_logger.error(\"reading response body failed\", e);\n        } catch (IOException e) {\n            s_logger.error(\"reading response body failed\", e);\n        }\n        return null;\n    }","commit_id":"cb048f4108b53dd811803abaa0b613e86b33d607","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void deleteNetworkTest() throws Exception {\n        String tenant_net_uuid = UUID.randomUUID().toString();\n\n        when(_deleteMethod.getURI()).thenReturn(getUri());\n        when(_deleteMethod.getStatusCode()).thenReturn(HttpStatus.SC_NO_CONTENT);\n\n        sspClient.deleteTenantNetwork(tenant_net_uuid);\n    }","id":49351,"modified_method":"@Test\n    public void deleteNetworkTest() throws Exception {\n        String tenant_net_uuid = UUID.randomUUID().toString();\n        SspClient sspClient = spy(new SspClient(apiUrl, username, password));\n\n        HttpClient client = mock(HttpClient.class);\n        HttpResponse res = mock(HttpResponse.class, RETURNS_DEEP_STUBS);\n        doReturn(client).when(sspClient).getHttpClient();\n        when(client.execute(any(HttpUriRequest.class))).thenReturn(res);\n        when(res.getStatusLine().getStatusCode()).thenReturn(HttpStatus.SC_NO_CONTENT);\n\n        sspClient.deleteTenantNetwork(tenant_net_uuid);\n    }","commit_id":"cb048f4108b53dd811803abaa0b613e86b33d607","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void createNetworkTest() throws Exception {\n        String networkName = \"example network 1\";\n        String tenant_net_uuid = UUID.randomUUID().toString();\n\n        when(_postMethod.getURI()).thenReturn(getUri());\n        when(_postMethod.getStatusCode()).thenReturn(HttpStatus.SC_CREATED);\n        when(_postMethod.getResponseBodyAsString()).thenReturn(\"{\\\"uuid\\\":\\\"\" + tenant_net_uuid + \"\\\",\\\"name\\\":\\\"\" + networkName + \"\\\",\\\"tenant_uuid\\\":\\\"\" + uuid + \"\\\"}\");\n        SspClient.TenantNetwork tnet = sspClient.createTenantNetwork(uuid, networkName);\n        assertEquals(tnet.name, networkName);\n        assertEquals(tnet.uuid, tenant_net_uuid);\n        assertEquals(tnet.tenantUuid, uuid);\n    }","id":49352,"modified_method":"@Test\n    public void createNetworkTest() throws Exception {\n        String networkName = \"example network 1\";\n        String tenant_net_uuid = UUID.randomUUID().toString();\n        SspClient sspClient = spy(new SspClient(apiUrl, username, password));\n\n        HttpClient client = mock(HttpClient.class);\n        HttpResponse res = mock(HttpResponse.class, RETURNS_DEEP_STUBS);\n        doReturn(client).when(sspClient).getHttpClient();\n        when(client.execute(any(HttpUriRequest.class))).thenReturn(res);\n        when(res.getStatusLine().getStatusCode()).thenReturn(HttpStatus.SC_CREATED);\n        String body = \"{\\\"uuid\\\":\\\"\" + tenant_net_uuid + \"\\\",\\\"name\\\":\\\"\" + networkName\n                + \"\\\",\\\"tenant_uuid\\\":\\\"\" + uuid + \"\\\"}\";\n        when(res.getEntity().getContent()).thenReturn(\n                new ByteArrayInputStream(body.getBytes(\"UTF-8\")));\n\n        SspClient.TenantNetwork tnet = sspClient.createTenantNetwork(uuid, networkName);\n        assertEquals(tnet.name, networkName);\n        assertEquals(tnet.uuid, tenant_net_uuid);\n        assertEquals(tnet.tenantUuid, uuid);\n    }","commit_id":"cb048f4108b53dd811803abaa0b613e86b33d607","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void loginTest() throws Exception {\n        when(_postMethod.getURI()).thenReturn(getUri());\n        when(_postMethod.getStatusCode()).thenReturn(HttpStatus.SC_OK);\n        assertTrue(sspClient.login());\n        assertTrue(sspClient.login());\n        assertTrue(sspClient.login());\n    }","id":49353,"modified_method":"@Test\n    public void loginTest() throws Exception {\n        SspClient sspClient = spy(new SspClient(apiUrl, username, password));\n\n        HttpClient client = mock(HttpClient.class);\n        HttpResponse res = mock(HttpResponse.class, RETURNS_DEEP_STUBS);\n        doReturn(client).when(sspClient).getHttpClient();\n        when(client.execute(any(HttpUriRequest.class))).thenReturn(res);\n        when(res.getStatusLine().getStatusCode()).thenReturn(HttpStatus.SC_OK);\n\n        assertTrue(sspClient.login());\n        assertTrue(sspClient.login());\n        assertTrue(sspClient.login());\n    }","commit_id":"cb048f4108b53dd811803abaa0b613e86b33d607","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean isReady(PhysicalNetworkServiceProvider provider) {\n        PhysicalNetwork physicalNetwork = _physicalNetworkDao.findById(provider.getPhysicalNetworkId());\n        assert (physicalNetwork != null);\n        if (physicalNetwork != null) {\n            if (fetchSspClients(physicalNetwork.getId(), physicalNetwork.getDataCenterId(), false).size() > 0) {\n                return true;\n            }\n            s_logger.warn(\"Ssp api endpoint not found. \" + physicalNetwork.toString());\n        } else {\n            s_logger.warn(\"PhysicalNetwork is NULL.\");\n        }\n        return false;\n    }","id":49354,"modified_method":"@Override\n    public boolean isReady(PhysicalNetworkServiceProvider provider) {\n        PhysicalNetwork physicalNetwork = _physicalNetworkDao.findById(provider.getPhysicalNetworkId());\n        assert (physicalNetwork != null);\n        if (fetchSspClients(physicalNetwork.getId(), physicalNetwork.getDataCenterId(), false).size() > 0) {\n            return true;\n        }\n        s_logger.warn(\"Ssp api endpoint not found. \" + physicalNetwork.toString());\n        return false;\n    }","commit_id":"cb048f4108b53dd811803abaa0b613e86b33d607","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public Provider getProvider() {\n        Provider provider = null;\n        synchronized (s_SSP_NAME) {\n            provider = Provider.getProvider(s_SSP_NAME);\n            if (provider == null) {\n                provider = new Provider(s_SSP_NAME, true);\n                s_logger.debug(\"registering Network.Provider \" + s_SSP_NAME);\n            }\n        }\n        return provider;\n    }","id":49355,"modified_method":"@Override\n    public Provider getProvider() {\n        return s_ssp_provider;\n    }","commit_id":"cb048f4108b53dd811803abaa0b613e86b33d607","url":"https://github.com/apache/cloudstack"},{"original_method":"private synchronized void cleanActiveSessions(){\n\t\tsynchronized (activeSessions){\n\t\t\tIterator<InsSession> it = activeSessions.iterator();\n\t\t\twhile(it.hasNext()){\n\t\t\t\tInsSession insSession = it.next();\n\t\t\t\tif(insSession==null || !insSession.isAlive()){\n\t\t\t\t\tlog.debug(\"removing \"+insSession);\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlog.debug(\"active sessions are: \"+activeSessions);\n\t}","id":49356,"modified_method":"private synchronized void cleanActiveSessions(){\n        Category log = getLog();\n\t\tsynchronized (activeSessions){\n\t\t\tIterator<InsSession> it = activeSessions.iterator();\n\t\t\twhile(it.hasNext()){\n\t\t\t\tInsSession insSession = it.next();\n\t\t\t\tif(insSession==null || !insSession.isAlive()){\n\t\t\t\t\tlog.debug(\"removing \"+insSession);\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlog.debug(\"active sessions are: \"+activeSessions);\n\t}","commit_id":"25fba45dbd5201ed1325167ea108db66cf483ed2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * listens for incoming connection on defined port (default is 8154)\n\t */\n\tpublic void run() {\n        ThreadCategory.setPrefix(\"OpenNMS.InsProxy\");\n\t\tlog=ThreadCategory.getInstance(this.getClass());\n\t\tif(criteriaRestriction ==null)\n\t\t\tthrow new IllegalStateException(\"The property criteriaRestriction cannot be null!\");\n\t\tlog.info(\"InsServerListener started: listening on port \"+listeningPort);\n\t\ttry {\n\t\t\tlistener = new ServerSocket(listeningPort);\n\t\t\tSocket server;\n\n\t\t\twhile (true) {\n\t\t\t\t// when accepts an incoming connection, create an InsSession for\n\t\t\t\t// alarms exchange\n\t\t\t\tserver = listener.accept();\n\t\t\t\tInsSession session = new InsSession(server);\n\t\t\t\t//only if the sharedASCIIString is valorized, requires authentication\n\t\t\t\tif(sharedAuthAsciiString!=null)\n\t\t\t\t\tsession.setSharedASCIIString(sharedAuthAsciiString);\n\t\t\t\tsession.setCriteriaRestriction(criteriaRestriction);\n\t\t\t\tsession.start();\n\t\t\t\tactiveSessions.add(session);\n\t\t\t}\n\t\t} catch (IOException ioe) {\n\t\t\tlog.info(\"Socket closed.\" );\n\t\t}\n\t}","id":49357,"modified_method":"/**\n\t * listens for incoming connection on defined port (default is 8154)\n\t */\n\tpublic void run() {\n\t    Category log = getLog();\n\t\tif(criteriaRestriction ==null)\n\t\t\tthrow new IllegalStateException(\"The property criteriaRestriction cannot be null!\");\n\t\tlog.info(\"InsServerListener started: listening on port \"+listeningPort);\n\t\ttry {\n\t\t\tlistener = new ServerSocket(listeningPort);\n\t\t\tSocket server;\n\n\t\t\twhile (true) {\n\t\t\t\t// when accepts an incoming connection, create an InsSession for\n\t\t\t\t// alarms exchange\n\t\t\t\tserver = listener.accept();\n\t\t\t\tInsSession session = new InsSession(server);\n\t\t\t\t//only if the sharedASCIIString is valorized, requires authentication\n\t\t\t\tif(sharedAuthAsciiString!=null)\n\t\t\t\t\tsession.setSharedASCIIString(sharedAuthAsciiString);\n\t\t\t\tsession.setCriteriaRestriction(criteriaRestriction);\n\t\t\t\tsession.start();\n\t\t\t\tactiveSessions.add(session);\n\t\t\t}\n\t\t} catch (IOException ioe) {\n\t\t\tlog.info(\"Socket closed.\" );\n\t\t}\n\t}","commit_id":"25fba45dbd5201ed1325167ea108db66cf483ed2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\t/**\n\t * Stops the listener\n\t */\n\tpublic void interrupt() {\n\t\tlog.info(\"InsServerListener Interrupted!\");\n\t\ttry {\n\t\t\tlistener.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tsuper.interrupt();\n\t}","id":49358,"modified_method":"@Override\n\t/**\n\t * Stops the listener\n\t */\n\tpublic void interrupt() {\n        Category log = getLog();\n\t\tlog.info(\"InsServerListener Interrupted!\");\n\t\ttry {\n\t\t\tlistener.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tsuper.interrupt();\n\t}","commit_id":"25fba45dbd5201ed1325167ea108db66cf483ed2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Flushes the event in input to all active sessions with clients\n\t * @param event\n\t */\n\tpublic void flushEvent(Event event){\n\t\tlog.debug(\"Flushing \"+event.getUei());\n\t\t\n\t\tsynchronized (activeSessions){\n\t\t\tcleanActiveSessions();\n\t\t\tIterator<InsSession> it = activeSessions.iterator();\n\t\t\twhile(it.hasNext()){\t\t\t\n\t\t\t\tInsSession insSession = it.next();\n\t\t\t\tPrintStream ps = insSession.getStreamToClient();\n\t\t\t\tsynchronized (ps) {\n\t\t\t\t\tif(ps!=null){\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tevent.marshal(new PrintWriter(ps));\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tlog.error(\"Error while sending current event to client\"+e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}","id":49359,"modified_method":"/**\n\t * Flushes the event in input to all active sessions with clients\n\t * @param event\n\t */\n\tpublic void flushEvent(Event event){\n\t      Category log = getLog();\n\t      log.debug(\"Flushing \"+event.getUei());\n          int nodeid = (int) event.getNodeid();\n\n          if (event.getIfIndex() > 0 ) {\n              event.setIfAlias(getIfAlias(nodeid,event.getIfIndex()));\n          } else if (!event.getInterface().equals(\"0.0.0.0\")) {\n              OnmsSnmpInterface iface = getIfAlias(nodeid,event.getInterface()); \n              if (iface != null ) {\n                  event.setIfIndex(iface.getIfIndex());\n                  event.setIfAlias(iface.getIfAlias());\n              } else {\n                  event.setIfIndex(-1);\n                  event.setIfAlias(\"-1\");\n              }\n          } else {\n              event.setIfIndex(-1);\n              event.setIfAlias(\"-1\");\n          }\n\t         \n\t\tsynchronized (activeSessions){\n\t\t\tcleanActiveSessions();\n\t\t\tIterator<InsSession> it = activeSessions.iterator();\n\t\t\twhile(it.hasNext()){\t\t\t\n\t\t\t\tInsSession insSession = it.next();\n\t\t\t\tPrintStream ps = insSession.getStreamToClient();\n\t\t\t\tsynchronized (ps) {\n\t\t\t\t\tif(ps!=null){\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tevent.marshal(new PrintWriter(ps));\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tlog.error(\"Error while sending current event to client\"+e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}","commit_id":"25fba45dbd5201ed1325167ea108db66cf483ed2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Event getXMLEvent(OnmsEvent ev) {\n        log.info(\"Working on XML Event for id: \" + ev.getId()); \n        log.debug(\"Setting Event id: \" + ev.getId()); \n        Event e = new Event();\n        e.setDbid(ev.getId());\n\n        //UEI\n        if (ev.getEventUei() != null ) {\n            log.debug(\"Setting Event uei: \" + ev.getEventUei()); \n            e.setUei(ev.getEventUei());\n        } else {\n            log.warn(\"No Event uei found: skipping event....\");\n            return null;\n        }\n\n        // Source\n        if (ev.getEventSource() != null ) {\n            log.debug(\"Setting Event source: \" + ev.getEventSource()); \n            e.setSource(ev.getEventSource());\n        } else {\n            log.info(\"No Event source found.\"); \n        }\n\n        //nodeid\n        if (ev.getNode() != null) {\n            log.debug(\"Setting Event nodeid: \" + ev.getNode().getId()); \n            e.setNodeid(ev.getNode().getId());\n        } else {\n            log.info(\"No Event node found.\"); \n        }\n\n\n        // timestamp\n        if (ev.getEventTime() != null) {\n            log.debug(\"Setting event date timestamp to GMT\");\n            DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL);\n            dateFormat.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n            log.debug(\"Setting Event Time: \" + ev.getEventTime()); \n            e.setTime(dateFormat.format(ev.getEventTime()));\n        } else {\n            log.info(\"No Event time found.\"); \n        }\n        \n        // host\n        if (ev.getEventHost() != null) {\n            log.debug(\"Setting Event Host: \" + ev.getEventHost());\n            e.setHost(ev.getEventHost());\n        } else {\n            log.info(\"No Event host found.\");\n        }\n        \n        // interface\n        if (ev.getIpAddr() != null) {\n            log.debug(\"Setting Event Interface/ipaddress: \" + ev.getIpAddr());\n            e.setInterface(ev\n                           .getIpAddr());\n        } else {\n            log.info(\"No Event ip address found.\");\n        }\n        \n        // Service Name\n        if (ev.getServiceType() != null) {\n            log.debug(\"Setting Event Service Name: \" + ev.getServiceType().getName());\n            e.setService(ev.getServiceType().getName());\n        } else {\n            log.info(\"No Event service name found.\");\n        }\n\n        // Description\n        if (ev.getEventDescr() != null ) {\n            log.debug(\"Setting Event Description\");\n            e.setDescr(ev.getEventDescr());\n        } else {\n            log.info(\"No Event ip address found.\");\n        }\n        \n        // Log message\n        if (ev.getEventLogMsg() != null) {\n            Logmsg msg = new Logmsg();\n            log.debug(\"Setting Event Log Message\");\n            msg.setContent(ev.getEventLogMsg());\n            e.setLogmsg(msg);\n        } else {\n            log.info(\"No Event log Message found.\");\n        }\n\n        // severity\n        if (ev.getEventSeverity() != null) {\n            log.debug(\"Setting Event Severity\");\n            e.setSeverity(Constants.getSeverityString(ev.getEventSeverity()));\n        } else {\n            log.info(\"No Event severity found.\");\n        }\n\n        //TODO FIXME SEND IFINDEX and IFALIAS To INS                                                        \n//          if (ev.getIfIndex() != null) \n//              e.setIfIndex(ev.getIfIndex().toString());\n        e.setIfIndex(-1);\n//          if (ev.getIfAlias() != null)\n//              e.setIfAlias(ev.getIfAlias());\n        e.setIfAlias(\"ifalias\");\n        \n        // operator Instruction\n        if (ev.getEventOperInstruct() != null) {\n            log.debug(\"Setting Event Operator Instruction\");\n            e.setOperinstruct(ev.getEventOperInstruct());\n        } else {\n            log.info(\"No Event operator Instruction found.\");\n        }\n\n        // parms\n        if (ev.getEventParms() != null ) {\n            Parms parms = Parameter.decode(ev.getEventParms());\n        \n            if (parms != null ) e.setParms(parms);\n        }\n\n        AlarmData ad = new AlarmData();\n        OnmsAlarm onmsAlarm = ev\n                .getAlarm();\n        try {\n            if (onmsAlarm != null) {\n                ad\n                        .setReductionKey(onmsAlarm\n                                .getReductionKey());\n                ad\n                        .setAlarmType(onmsAlarm\n                                .getAlarmType());\n                ad\n                        .setClearKey(onmsAlarm\n                                .getClearKey());\n                e\n                        .setAlarmData(ad);\n            }\n        } catch (ObjectNotFoundException e1) {\n            log\n                    .warn(\"correlated alarm data not found \"\n                            + e1);\n        }\n        log\n        .info(\"return Event with id: \" + ev.getId()); \n        return e;\n    }","id":49360,"modified_method":"private Event getXMLEvent(OnmsEvent ev) {\n        Category log = getLog();\n        log.info(\"Working on XML Event for id: \" + ev.getId()); \n        log.debug(\"Setting Event id: \" + ev.getId()); \n        Event e = new Event();\n        e.setDbid(ev.getId());\n\n        //UEI\n        if (ev.getEventUei() != null ) {\n            log.debug(\"Setting Event uei: \" + ev.getEventUei()); \n            e.setUei(ev.getEventUei());\n        } else {\n            log.warn(\"No Event uei found: skipping event....\");\n            return null;\n        }\n\n        // Source\n        if (ev.getEventSource() != null ) {\n            log.debug(\"Setting Event source: \" + ev.getEventSource()); \n            e.setSource(ev.getEventSource());\n        } else {\n            log.info(\"No Event source found.\"); \n        }\n\n        //nodeid\n        if (ev.getNode() != null) {\n            log.debug(\"Setting Event nodeid: \" + ev.getNode().getId()); \n            e.setNodeid(ev.getNode().getId());\n        } else {\n            log.info(\"No Event node found.\"); \n        }\n\n\n        // timestamp\n        if (ev.getEventTime() != null) {\n            log.debug(\"Setting event date timestamp to GMT\");\n            DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL);\n            dateFormat.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n            log.debug(\"Setting Event Time: \" + ev.getEventTime()); \n            e.setTime(dateFormat.format(ev.getEventTime()));\n        } else {\n            log.info(\"No Event time found.\"); \n        }\n        \n        // host\n        if (ev.getEventHost() != null) {\n            log.debug(\"Setting Event Host: \" + ev.getEventHost());\n            e.setHost(ev.getEventHost());\n        } else {\n            log.info(\"No Event host found.\");\n        }\n        \n        // interface\n        if (ev.getIpAddr() != null) {\n            log.debug(\"Setting Event Interface/ipaddress: \" + ev.getIpAddr());\n            e.setInterface(ev\n                           .getIpAddr());\n        } else {\n            log.info(\"No Event ip address found.\");\n        }\n        \n        // Service Name\n        if (ev.getServiceType() != null) {\n            log.debug(\"Setting Event Service Name: \" + ev.getServiceType().getName());\n            e.setService(ev.getServiceType().getName());\n        } else {\n            log.info(\"No Event service name found.\");\n        }\n\n        // Description\n        if (ev.getEventDescr() != null ) {\n            log.debug(\"Setting Event Description\");\n            e.setDescr(ev.getEventDescr());\n        } else {\n            log.info(\"No Event ip address found.\");\n        }\n        \n        // Log message\n        if (ev.getEventLogMsg() != null) {\n            Logmsg msg = new Logmsg();\n            log.debug(\"Setting Event Log Message\");\n            msg.setContent(ev.getEventLogMsg());\n            e.setLogmsg(msg);\n        } else {\n            log.info(\"No Event log Message found.\");\n        }\n\n        // severity\n        if (ev.getEventSeverity() != null) {\n            log.debug(\"Setting Event Severity\");\n            e.setSeverity(Constants.getSeverityString(ev.getEventSeverity()));\n        } else {\n            log.info(\"No Event severity found.\");\n        }\n\n          if (ev.getIfIndex() != null) {\n              e.setIfIndex(ev.getIfIndex());\n              e.setIfAlias(getIfAlias(ev.getNode().getId(),ev.getIfIndex()));\n          } else if (!ev.getIpAddr().equals(\"0.0.0.0\")) {\n              OnmsSnmpInterface iface = getIfAlias(ev.getNode().getId(), ev.getIpAddr());\n              if (iface != null) {\n                  e.setIfIndex(iface.getIfIndex());\n                  e.setIfAlias(iface.getIfAlias());\n              } else {\n                  e.setIfIndex(-1);\n                  e.setIfAlias(\"-1\");\n              }\n          } else {\n              e.setIfIndex(-1);\n              e.setIfAlias(\"-1\");\n          }\n\n        \n        // operator Instruction\n        if (ev.getEventOperInstruct() != null) {\n            log.debug(\"Setting Event Operator Instruction\");\n            e.setOperinstruct(ev.getEventOperInstruct());\n        } else {\n            log.info(\"No Event operator Instruction found.\");\n        }\n\n        // parms\n        if (ev.getEventParms() != null ) {\n            log.debug(\"Setting Event Parms: \" + ev.getEventParms());\n            Parms parms = Parameter.decode(ev.getEventParms());\n            if (parms != null ) e.setParms(parms);\n        } else {\n            log.info(\"No Event parms found.\");\n        }\n\n        AlarmData ad = new AlarmData();\n        OnmsAlarm onmsAlarm = ev\n                .getAlarm();\n        try {\n            if (onmsAlarm != null) {\n                ad\n                        .setReductionKey(onmsAlarm\n                                .getReductionKey());\n                ad\n                        .setAlarmType(onmsAlarm\n                                .getAlarmType());\n                ad\n                        .setClearKey(onmsAlarm\n                                .getClearKey());\n                e\n                        .setAlarmData(ad);\n            }\n        } catch (ObjectNotFoundException e1) {\n            log\n                    .warn(\"correlated alarm data not found \"\n                            + e1);\n        }\n        log\n        .info(\"return Event with id: \" + ev.getId()); \n        return e;\n    }","commit_id":"25fba45dbd5201ed1325167ea108db66cf483ed2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void run() {\n\t\tinput = \"\";\n\n\t\ttry {\n\t\t\t// Get input from the client\n\t\t\tBufferedReader in = new BufferedReader(new InputStreamReader(server\n\t\t\t\t\t.getInputStream()));\n\n\t\t\treadingFromClient: while ((line = in.readLine()) != null) {\n\t\t\t\tinput = input + \"\\n\" + line;\n\t\t\t\tlog.debug(\"Client wrote: \" + line + \" from \"\n\t\t\t\t\t\t+ server.getInetAddress());\n\n\t\t\t\tif (status == STARTING_SESSION_STATUS) {\n\t\t\t\t\tif (line.equalsIgnoreCase(START_AUTHENTICATION_REQUEST)) {\n\t\t\t\t\t\tif (sharedAuthAsciiString != null) {\n\t\t\t\t\t\t\t// authorization required\n\t\t\t\t\t\t\tstreamToClient.println(AUTH_REQUIRED_ACK);\n\t\t\t\t\t\t\tlog.debug(\"Starting authentication, sending \"\n\t\t\t\t\t\t\t\t\t+ AUTH_REQUIRED_ACK + \" to the client\");\n\t\t\t\t\t\t\tstatus = AUTHENTICATING_STATUS;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// authorization not required\n\t\t\t\t\t\t\tstreamToClient.println(AUTH_NOT_REQUIRED_ACK);\n\t\t\t\t\t\t\tlog.debug(\"Starting authentication, sending \"\n\t\t\t\t\t\t\t\t\t+ AUTH_NOT_REQUIRED_ACK + \" to the client\");\n\t\t\t\t\t\t\tstatus = AUTHENTICATED_STATUS;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// security reset (a malicious user may use DOS attack\n\t\t\t\t\t\t// before authentication)\n\t\t\t\t\t\tlog.warn(\"Wrong client request\");\n\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (status == AUTHENTICATING_STATUS) {\n\t\t\t\t\tif (sharedAuthAsciiString != null) {\n\t\t\t\t\t\t// authentication required (security check)\n\t\t\t\t\t\tif (line.equals(sharedAuthAsciiString)) {\n\t\t\t\t\t\t\tstatus = AUTHENTICATED_STATUS;\n\t\t\t\t\t\t\tlog.debug(\"Authentication success!\");\n\t\t\t\t\t\t\tstreamToClient.println(AUTHENTICATION_SUCCESS);\n\t\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstreamToClient.println(RESET_SIGNAL);\n\t\t\t\t\t\t\tlog\n\t\t\t\t\t\t\t\t\t.warn(\"Authentication failure! Resetting session.\");\n\t\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (status == AUTHENTICATED_STATUS || status == DATAFLOW_STATUS) {\n\t\t\t\t\tif (line.equalsIgnoreCase(LIST_CURRENT_ALARM_REQUEST)) {\n\t\t\t\t\t\tlog.debug(\"Sending alarms to the client\");\n\t\t\t\t\t\trefreshAlarms();\n\t\t\t\t\t\tstatus = DATAFLOW_STATUS;\n\t\t\t\t\t\tsynchronized (streamToClient) {\n\t\t\t\t\t\t\tstreamToClient.println(ACTIVE_ALARM_BEGIN);\n\t\t\t\t\t\t\tList<Event> events = getEvents();\n\t\t\t\t\t\t\tif (events != null && events.size() > 0) {\n                                Iterator<Event> ite = events.iterator();\n                                while (ite.hasNext()) {\n                                    StringWriter sw = new StringWriter();\n                                    Event xmlEvent = ite.next();\n                                    try {\n                                        log.info(\"Marshal Event with id: \" + xmlEvent.getDbid()); \n                                        xmlEvent.marshal(sw);\n                                        log.info(\"Flushing Event with id: \" + xmlEvent.getDbid()); \n                                        sw.flush();\n                                        log.info(\"String Writer:\" + sw.getBuffer().toString()); \n                                        if (sw != null) {\n                                            streamToClient.print(sw.toString());\n                                        } else {\n                                            log.warn(\"String Writer is null\");\n//                                          break readingFromClient;\n                                        }\n                                    } catch (MarshalException e) {\n                                        log.error(\"Marshall Exception: \" + e);\n                                    } catch (ValidationException e) {\n                                        log.error(\"Validation Exception: \" + e);\n                                    }\n                                }\n\t\t\t\t\t\t\t}\n                            streamToClient.println(ACTIVE_ALARM_END);\n                            continue readingFromClient;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (line.equalsIgnoreCase(STOP_ALARM_REQUEST)) {\n\t\t\t\t\t\t\tlog.debug(\"Closing session due client request.\");\n\t\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlog.warn(\"Wrong client request\");\n\t\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlog.debug(\"Overall message from \" + server.getInetAddress()\n\t\t\t\t\t+ \" is:\" + input);\n\t\t\tlog.debug(\"\\nClosing session with \" + server.getInetAddress()\n\t\t\t\t\t+ \"...\\n\\n\");\n\t\t\tserver.close();\n\t\t} catch (IOException ioe) {\n\t\t\tlog.warn(\"IOException on socket listen: \" + ioe, ioe);\n\t\t}\n\t}","id":49361,"modified_method":"public void run() {\n        Category log = getLog();\n\t\tinput = \"\";\n\n\t\ttry {\n\t\t\t// Get input from the client\n\t\t\tBufferedReader in = new BufferedReader(new InputStreamReader(server\n\t\t\t\t\t.getInputStream()));\n\n\t\t\treadingFromClient: while ((line = in.readLine()) != null) {\n\t\t\t\tinput = input + \"\\n\" + line;\n\t\t\t\tlog.debug(\"Client wrote: \" + line + \" from \"\n\t\t\t\t\t\t+ server.getInetAddress());\n\n\t\t\t\tif (status == STARTING_SESSION_STATUS) {\n\t\t\t\t\tif (line.equalsIgnoreCase(START_AUTHENTICATION_REQUEST)) {\n\t\t\t\t\t\tif (sharedAuthAsciiString != null) {\n\t\t\t\t\t\t\t// authorization required\n\t\t\t\t\t\t\tstreamToClient.println(AUTH_REQUIRED_ACK);\n\t\t\t\t\t\t\tlog.debug(\"Starting authentication, sending \"\n\t\t\t\t\t\t\t\t\t+ AUTH_REQUIRED_ACK + \" to the client\");\n\t\t\t\t\t\t\tstatus = AUTHENTICATING_STATUS;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// authorization not required\n\t\t\t\t\t\t\tstreamToClient.println(AUTH_NOT_REQUIRED_ACK);\n\t\t\t\t\t\t\tlog.debug(\"Starting authentication, sending \"\n\t\t\t\t\t\t\t\t\t+ AUTH_NOT_REQUIRED_ACK + \" to the client\");\n\t\t\t\t\t\t\tstatus = AUTHENTICATED_STATUS;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// security reset (a malicious user may use DOS attack\n\t\t\t\t\t\t// before authentication)\n\t\t\t\t\t\tlog.warn(\"Wrong client request\");\n\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (status == AUTHENTICATING_STATUS) {\n\t\t\t\t\tif (sharedAuthAsciiString != null) {\n\t\t\t\t\t\t// authentication required (security check)\n\t\t\t\t\t\tif (line.equals(sharedAuthAsciiString)) {\n\t\t\t\t\t\t\tstatus = AUTHENTICATED_STATUS;\n\t\t\t\t\t\t\tlog.debug(\"Authentication success!\");\n\t\t\t\t\t\t\tstreamToClient.println(AUTHENTICATION_SUCCESS);\n\t\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstreamToClient.println(RESET_SIGNAL);\n\t\t\t\t\t\t\tlog\n\t\t\t\t\t\t\t\t\t.warn(\"Authentication failure! Resetting session.\");\n\t\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (status == AUTHENTICATED_STATUS || status == DATAFLOW_STATUS) {\n\t\t\t\t\tif (line.equalsIgnoreCase(LIST_CURRENT_ALARM_REQUEST)) {\n\t\t\t\t        log.debug(\"Fetching Events from Database\");\n\t\t\t\t\t    getEventsByCriteria();\n\t\t\t\t\t\tstatus = DATAFLOW_STATUS;\n\t\t\t\t\t\tsynchronized (streamToClient) {\n\t\t\t\t\t\t\t streamToClient.println(ACTIVE_ALARM_BEGIN);\n\t                         StringWriter sw = getOutput();\n  \t\t                     if (sw != null) {\n   \t\t                        log.info(\"String Writer:\" + sw.getBuffer().toString()); \n\t\t                        streamToClient.print(sw.toString());\n\t\t                     } else {\n\t\t                        log.error(\"String Writer is null\");\n//\t\t\t                      break readingFromClient;\n\t\t                     }\n                             streamToClient.println(ACTIVE_ALARM_END);\n                             continue readingFromClient;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (line.equalsIgnoreCase(STOP_ALARM_REQUEST)) {\n\t\t\t\t\t\t\tlog.debug(\"Closing session due client request.\");\n\t\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlog.warn(\"Wrong client request\");\n\t\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlog.debug(\"Overall message from \" + server.getInetAddress()\n\t\t\t\t\t+ \" is:\" + input);\n\t\t\tlog.debug(\"\\nClosing session with \" + server.getInetAddress()\n\t\t\t\t\t+ \"...\\n\\n\");\n\t\t\tserver.close();\n\t\t} catch (IOException ioe) {\n\t\t\tlog.warn(\"IOException on socket listen: \" + ioe, ioe);\n\t\t}\n\t}","commit_id":"25fba45dbd5201ed1325167ea108db66cf483ed2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"InsSession(Socket server) throws IOException {\n\t    ThreadCategory.setPrefix(\"OpenNMS.InsProxy\");\n\t\tlog = ThreadCategory.getInstance(this.getClass());\n\t\tthis.server = server;\n\t\tstreamToClient = new PrintStream(server.getOutputStream());\n\t}","id":49362,"modified_method":"InsSession(Socket server) throws IOException {\n\t\tthis.server = server;\n\t\tstreamToClient = new PrintStream(server.getOutputStream());\n\t}","commit_id":"25fba45dbd5201ed1325167ea108db66cf483ed2","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized void cleanActiveSessions(){\n\t\tsynchronized (activeSessions){\n\t\t\tIterator<InsSession> it = activeSessions.iterator();\n\t\t\twhile(it.hasNext()){\n\t\t\t\tInsSession insSession = it.next();\n\t\t\t\tif(insSession==null || !insSession.isAlive()){\n\t\t\t\t\tlog.debug(\"removing \"+insSession);\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlog.debug(\"active sessions are: \"+activeSessions);\n\t}","id":49363,"modified_method":"private synchronized void cleanActiveSessions(){\n        Category log = getLog();\n\t\tsynchronized (activeSessions){\n\t\t\tIterator<InsSession> it = activeSessions.iterator();\n\t\t\twhile(it.hasNext()){\n\t\t\t\tInsSession insSession = it.next();\n\t\t\t\tif(insSession==null || !insSession.isAlive()){\n\t\t\t\t\tlog.debug(\"removing \"+insSession);\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlog.debug(\"active sessions are: \"+activeSessions);\n\t}","commit_id":"135a53ab28d61d0bd0f572be4fff745ddb4210f3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * listens for incoming connection on defined port (default is 8154)\n\t */\n\tpublic void run() {\n        ThreadCategory.setPrefix(\"OpenNMS.InsProxy\");\n\t\tlog=ThreadCategory.getInstance(this.getClass());\n\t\tif(criteriaRestriction ==null)\n\t\t\tthrow new IllegalStateException(\"The property criteriaRestriction cannot be null!\");\n\t\tlog.info(\"InsServerListener started: listening on port \"+listeningPort);\n\t\ttry {\n\t\t\tlistener = new ServerSocket(listeningPort);\n\t\t\tSocket server;\n\n\t\t\twhile (true) {\n\t\t\t\t// when accepts an incoming connection, create an InsSession for\n\t\t\t\t// alarms exchange\n\t\t\t\tserver = listener.accept();\n\t\t\t\tInsSession session = new InsSession(server);\n\t\t\t\t//only if the sharedASCIIString is valorized, requires authentication\n\t\t\t\tif(sharedAuthAsciiString!=null)\n\t\t\t\t\tsession.setSharedASCIIString(sharedAuthAsciiString);\n\t\t\t\tsession.setCriteriaRestriction(criteriaRestriction);\n\t\t\t\tsession.start();\n\t\t\t\tactiveSessions.add(session);\n\t\t\t}\n\t\t} catch (IOException ioe) {\n\t\t\tlog.info(\"Socket closed.\" );\n\t\t}\n\t}","id":49364,"modified_method":"/**\n\t * listens for incoming connection on defined port (default is 8154)\n\t */\n\tpublic void run() {\n\t    Category log = getLog();\n\t\tif(criteriaRestriction ==null)\n\t\t\tthrow new IllegalStateException(\"The property criteriaRestriction cannot be null!\");\n\t\tlog.info(\"InsServerListener started: listening on port \"+listeningPort);\n\t\ttry {\n\t\t\tlistener = new ServerSocket(listeningPort);\n\t\t\tSocket server;\n\n\t\t\twhile (true) {\n\t\t\t\t// when accepts an incoming connection, create an InsSession for\n\t\t\t\t// alarms exchange\n\t\t\t\tserver = listener.accept();\n\t\t\t\tInsSession session = new InsSession(server);\n\t\t\t\t//only if the sharedASCIIString is valorized, requires authentication\n\t\t\t\tif(sharedAuthAsciiString!=null)\n\t\t\t\t\tsession.setSharedASCIIString(sharedAuthAsciiString);\n\t\t\t\tsession.setCriteriaRestriction(criteriaRestriction);\n\t\t\t\tsession.start();\n\t\t\t\tactiveSessions.add(session);\n\t\t\t}\n\t\t} catch (IOException ioe) {\n\t\t\tlog.info(\"Socket closed.\" );\n\t\t}\n\t}","commit_id":"135a53ab28d61d0bd0f572be4fff745ddb4210f3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\t/**\n\t * Stops the listener\n\t */\n\tpublic void interrupt() {\n\t\tlog.info(\"InsServerListener Interrupted!\");\n\t\ttry {\n\t\t\tlistener.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tsuper.interrupt();\n\t}","id":49365,"modified_method":"@Override\n\t/**\n\t * Stops the listener\n\t */\n\tpublic void interrupt() {\n        Category log = getLog();\n\t\tlog.info(\"InsServerListener Interrupted!\");\n\t\ttry {\n\t\t\tlistener.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tsuper.interrupt();\n\t}","commit_id":"135a53ab28d61d0bd0f572be4fff745ddb4210f3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Flushes the event in input to all active sessions with clients\n\t * @param event\n\t */\n\tpublic void flushEvent(Event event){\n\t\tlog.debug(\"Flushing \"+event.getUei());\n\t\t\n\t\tsynchronized (activeSessions){\n\t\t\tcleanActiveSessions();\n\t\t\tIterator<InsSession> it = activeSessions.iterator();\n\t\t\twhile(it.hasNext()){\t\t\t\n\t\t\t\tInsSession insSession = it.next();\n\t\t\t\tPrintStream ps = insSession.getStreamToClient();\n\t\t\t\tsynchronized (ps) {\n\t\t\t\t\tif(ps!=null){\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tevent.marshal(new PrintWriter(ps));\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tlog.error(\"Error while sending current event to client\"+e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}","id":49366,"modified_method":"/**\n\t * Flushes the event in input to all active sessions with clients\n\t * @param event\n\t */\n\tpublic void flushEvent(Event event){\n\t      Category log = getLog();\n\t      log.debug(\"Flushing \"+event.getUei());\n          int nodeid = (int) event.getNodeid();\n\n          if (event.getIfIndex() > 0 ) {\n              event.setIfAlias(getIfAlias(nodeid,event.getIfIndex()));\n          } else if (!event.getInterface().equals(\"0.0.0.0\")) {\n              OnmsSnmpInterface iface = getIfAlias(nodeid,event.getInterface()); \n              if (iface != null ) {\n                  event.setIfIndex(iface.getIfIndex());\n                  event.setIfAlias(iface.getIfAlias());\n              } else {\n                  event.setIfIndex(-1);\n                  event.setIfAlias(\"-1\");\n              }\n          } else {\n              event.setIfIndex(-1);\n              event.setIfAlias(\"-1\");\n          }\n\t         \n\t\tsynchronized (activeSessions){\n\t\t\tcleanActiveSessions();\n\t\t\tIterator<InsSession> it = activeSessions.iterator();\n\t\t\twhile(it.hasNext()){\t\t\t\n\t\t\t\tInsSession insSession = it.next();\n\t\t\t\tPrintStream ps = insSession.getStreamToClient();\n\t\t\t\tsynchronized (ps) {\n\t\t\t\t\tif(ps!=null){\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tevent.marshal(new PrintWriter(ps));\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tlog.error(\"Error while sending current event to client\"+e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}","commit_id":"135a53ab28d61d0bd0f572be4fff745ddb4210f3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"InsSession(Socket server) throws IOException {\n\t    ThreadCategory.setPrefix(\"OpenNMS.InsProxy\");\n\t\tlog = ThreadCategory.getInstance(this.getClass());\n\t\tthis.server = server;\n\t\tstreamToClient = new PrintStream(server.getOutputStream());\n\t}","id":49367,"modified_method":"InsSession(Socket server) throws IOException {\n\t\tthis.server = server;\n\t\tstreamToClient = new PrintStream(server.getOutputStream());\n\t}","commit_id":"135a53ab28d61d0bd0f572be4fff745ddb4210f3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void run() {\n\t\tinput = \"\";\n\n\t\ttry {\n\t\t\t// Get input from the client\n\t\t\tBufferedReader in = new BufferedReader(new InputStreamReader(server\n\t\t\t\t\t.getInputStream()));\n\n\t\t\treadingFromClient: while ((line = in.readLine()) != null) {\n\t\t\t\tinput = input + \"\\n\" + line;\n\t\t\t\tlog.debug(\"Client wrote: \" + line + \" from \"\n\t\t\t\t\t\t+ server.getInetAddress());\n\n\t\t\t\tif (status == STARTING_SESSION_STATUS) {\n\t\t\t\t\tif (line.equalsIgnoreCase(START_AUTHENTICATION_REQUEST)) {\n\t\t\t\t\t\tif (sharedAuthAsciiString != null) {\n\t\t\t\t\t\t\t// authorization required\n\t\t\t\t\t\t\tstreamToClient.println(AUTH_REQUIRED_ACK);\n\t\t\t\t\t\t\tlog.debug(\"Starting authentication, sending \"\n\t\t\t\t\t\t\t\t\t+ AUTH_REQUIRED_ACK + \" to the client\");\n\t\t\t\t\t\t\tstatus = AUTHENTICATING_STATUS;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// authorization not required\n\t\t\t\t\t\t\tstreamToClient.println(AUTH_NOT_REQUIRED_ACK);\n\t\t\t\t\t\t\tlog.debug(\"Starting authentication, sending \"\n\t\t\t\t\t\t\t\t\t+ AUTH_NOT_REQUIRED_ACK + \" to the client\");\n\t\t\t\t\t\t\tstatus = AUTHENTICATED_STATUS;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// security reset (a malicious user may use DOS attack\n\t\t\t\t\t\t// before authentication)\n\t\t\t\t\t\tlog.warn(\"Wrong client request\");\n\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (status == AUTHENTICATING_STATUS) {\n\t\t\t\t\tif (sharedAuthAsciiString != null) {\n\t\t\t\t\t\t// authentication required (security check)\n\t\t\t\t\t\tif (line.equals(sharedAuthAsciiString)) {\n\t\t\t\t\t\t\tstatus = AUTHENTICATED_STATUS;\n\t\t\t\t\t\t\tlog.debug(\"Authentication success!\");\n\t\t\t\t\t\t\tstreamToClient.println(AUTHENTICATION_SUCCESS);\n\t\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstreamToClient.println(RESET_SIGNAL);\n\t\t\t\t\t\t\tlog\n\t\t\t\t\t\t\t\t\t.warn(\"Authentication failure! Resetting session.\");\n\t\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (status == AUTHENTICATED_STATUS || status == DATAFLOW_STATUS) {\n\t\t\t\t\tif (line.equalsIgnoreCase(LIST_CURRENT_ALARM_REQUEST)) {\n\t\t\t\t\t\tlog.debug(\"Sending alarms to the client\");\n\t\t\t\t\t\trefreshAlarms();\n\t\t\t\t\t\tstatus = DATAFLOW_STATUS;\n\t\t\t\t\t\tsynchronized (streamToClient) {\n\t\t\t\t\t\t\tstreamToClient.println(ACTIVE_ALARM_BEGIN);\n\t\t\t\t\t\t\tList<Event> events = getEvents();\n\t\t\t\t\t\t\tif (events != null && events.size() > 0) {\n                                Iterator<Event> ite = events.iterator();\n                                while (ite.hasNext()) {\n                                    StringWriter sw = new StringWriter();\n                                    Event xmlEvent = ite.next();\n                                    try {\n                                        log.info(\"Marshal Event with id: \" + xmlEvent.getDbid()); \n                                        xmlEvent.marshal(sw);\n                                        log.info(\"Flushing Event with id: \" + xmlEvent.getDbid()); \n                                        sw.flush();\n                                        log.info(\"String Writer:\" + sw.getBuffer().toString()); \n                                        if (sw != null) {\n                                            streamToClient.print(sw.toString());\n                                        } else {\n                                            log.warn(\"String Writer is null\");\n//                                          break readingFromClient;\n                                        }\n                                    } catch (MarshalException e) {\n                                        log.error(\"Marshall Exception: \" + e);\n                                    } catch (ValidationException e) {\n                                        log.error(\"Validation Exception: \" + e);\n                                    }\n                                }\n\t\t\t\t\t\t\t}\n                            streamToClient.println(ACTIVE_ALARM_END);\n                            continue readingFromClient;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (line.equalsIgnoreCase(STOP_ALARM_REQUEST)) {\n\t\t\t\t\t\t\tlog.debug(\"Closing session due client request.\");\n\t\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlog.warn(\"Wrong client request\");\n\t\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlog.debug(\"Overall message from \" + server.getInetAddress()\n\t\t\t\t\t+ \" is:\" + input);\n\t\t\tlog.debug(\"\\nClosing session with \" + server.getInetAddress()\n\t\t\t\t\t+ \"...\\n\\n\");\n\t\t\tserver.close();\n\t\t} catch (IOException ioe) {\n\t\t\tlog.warn(\"IOException on socket listen: \" + ioe, ioe);\n\t\t}\n\t}","id":49368,"modified_method":"public void run() {\n        Category log = getLog();\n\t\tinput = \"\";\n\n\t\ttry {\n\t\t\t// Get input from the client\n\t\t\tBufferedReader in = new BufferedReader(new InputStreamReader(server\n\t\t\t\t\t.getInputStream()));\n\n\t\t\treadingFromClient: while ((line = in.readLine()) != null) {\n\t\t\t\tinput = input + \"\\n\" + line;\n\t\t\t\tlog.debug(\"Client wrote: \" + line + \" from \"\n\t\t\t\t\t\t+ server.getInetAddress());\n\n\t\t\t\tif (status == STARTING_SESSION_STATUS) {\n\t\t\t\t\tif (line.equalsIgnoreCase(START_AUTHENTICATION_REQUEST)) {\n\t\t\t\t\t\tif (sharedAuthAsciiString != null) {\n\t\t\t\t\t\t\t// authorization required\n\t\t\t\t\t\t\tstreamToClient.println(AUTH_REQUIRED_ACK);\n\t\t\t\t\t\t\tlog.debug(\"Starting authentication, sending \"\n\t\t\t\t\t\t\t\t\t+ AUTH_REQUIRED_ACK + \" to the client\");\n\t\t\t\t\t\t\tstatus = AUTHENTICATING_STATUS;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// authorization not required\n\t\t\t\t\t\t\tstreamToClient.println(AUTH_NOT_REQUIRED_ACK);\n\t\t\t\t\t\t\tlog.debug(\"Starting authentication, sending \"\n\t\t\t\t\t\t\t\t\t+ AUTH_NOT_REQUIRED_ACK + \" to the client\");\n\t\t\t\t\t\t\tstatus = AUTHENTICATED_STATUS;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// security reset (a malicious user may use DOS attack\n\t\t\t\t\t\t// before authentication)\n\t\t\t\t\t\tlog.warn(\"Wrong client request\");\n\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (status == AUTHENTICATING_STATUS) {\n\t\t\t\t\tif (sharedAuthAsciiString != null) {\n\t\t\t\t\t\t// authentication required (security check)\n\t\t\t\t\t\tif (line.equals(sharedAuthAsciiString)) {\n\t\t\t\t\t\t\tstatus = AUTHENTICATED_STATUS;\n\t\t\t\t\t\t\tlog.debug(\"Authentication success!\");\n\t\t\t\t\t\t\tstreamToClient.println(AUTHENTICATION_SUCCESS);\n\t\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstreamToClient.println(RESET_SIGNAL);\n\t\t\t\t\t\t\tlog\n\t\t\t\t\t\t\t\t\t.warn(\"Authentication failure! Resetting session.\");\n\t\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (status == AUTHENTICATED_STATUS || status == DATAFLOW_STATUS) {\n\t\t\t\t\tif (line.equalsIgnoreCase(LIST_CURRENT_ALARM_REQUEST)) {\n\t\t\t\t        log.debug(\"Fetching Events from Database\");\n\t\t\t\t\t    getEventsByCriteria();\n\t\t\t\t\t\tstatus = DATAFLOW_STATUS;\n\t\t\t\t\t\tsynchronized (streamToClient) {\n\t\t\t\t\t\t\t streamToClient.println(ACTIVE_ALARM_BEGIN);\n\t                         StringWriter sw = getOutput();\n  \t\t                     if (sw != null) {\n   \t\t                        log.info(\"String Writer:\" + sw.getBuffer().toString()); \n\t\t                        streamToClient.print(sw.toString());\n\t\t                     } else {\n\t\t                        log.error(\"String Writer is null\");\n//\t\t\t                      break readingFromClient;\n\t\t                     }\n                             streamToClient.println(ACTIVE_ALARM_END);\n                             continue readingFromClient;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (line.equalsIgnoreCase(STOP_ALARM_REQUEST)) {\n\t\t\t\t\t\t\tlog.debug(\"Closing session due client request.\");\n\t\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlog.warn(\"Wrong client request\");\n\t\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlog.debug(\"Overall message from \" + server.getInetAddress()\n\t\t\t\t\t+ \" is:\" + input);\n\t\t\tlog.debug(\"\\nClosing session with \" + server.getInetAddress()\n\t\t\t\t\t+ \"...\\n\\n\");\n\t\t\tserver.close();\n\t\t} catch (IOException ioe) {\n\t\t\tlog.warn(\"IOException on socket listen: \" + ioe, ioe);\n\t\t}\n\t}","commit_id":"135a53ab28d61d0bd0f572be4fff745ddb4210f3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Event getXMLEvent(OnmsEvent ev) {\n        log.info(\"Working on XML Event for id: \" + ev.getId()); \n        log.debug(\"Setting Event id: \" + ev.getId()); \n        Event e = new Event();\n        e.setDbid(ev.getId());\n\n        //UEI\n        if (ev.getEventUei() != null ) {\n            log.debug(\"Setting Event uei: \" + ev.getEventUei()); \n            e.setUei(ev.getEventUei());\n        } else {\n            log.warn(\"No Event uei found: skipping event....\");\n            return null;\n        }\n\n        // Source\n        if (ev.getEventSource() != null ) {\n            log.debug(\"Setting Event source: \" + ev.getEventSource()); \n            e.setSource(ev.getEventSource());\n        } else {\n            log.info(\"No Event source found.\"); \n        }\n\n        //nodeid\n        if (ev.getNode() != null) {\n            log.debug(\"Setting Event nodeid: \" + ev.getNode().getId()); \n            e.setNodeid(ev.getNode().getId());\n        } else {\n            log.info(\"No Event node found.\"); \n        }\n\n\n        // timestamp\n        if (ev.getEventTime() != null) {\n            log.debug(\"Setting event date timestamp to GMT\");\n            DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL);\n            dateFormat.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n            log.debug(\"Setting Event Time: \" + ev.getEventTime()); \n            e.setTime(dateFormat.format(ev.getEventTime()));\n        } else {\n            log.info(\"No Event time found.\"); \n        }\n        \n        // host\n        if (ev.getEventHost() != null) {\n            log.debug(\"Setting Event Host: \" + ev.getEventHost());\n            e.setHost(ev.getEventHost());\n        } else {\n            log.info(\"No Event host found.\");\n        }\n        \n        // interface\n        if (ev.getIpAddr() != null) {\n            log.debug(\"Setting Event Interface/ipaddress: \" + ev.getIpAddr());\n            e.setInterface(ev\n                           .getIpAddr());\n        } else {\n            log.info(\"No Event ip address found.\");\n        }\n        \n        // Service Name\n        if (ev.getServiceType() != null) {\n            log.debug(\"Setting Event Service Name: \" + ev.getServiceType().getName());\n            e.setService(ev.getServiceType().getName());\n        } else {\n            log.info(\"No Event service name found.\");\n        }\n\n        // Description\n        if (ev.getEventDescr() != null ) {\n            log.debug(\"Setting Event Description\");\n            e.setDescr(ev.getEventDescr());\n        } else {\n            log.info(\"No Event ip address found.\");\n        }\n        \n        // Log message\n        if (ev.getEventLogMsg() != null) {\n            Logmsg msg = new Logmsg();\n            log.debug(\"Setting Event Log Message\");\n            msg.setContent(ev.getEventLogMsg());\n            e.setLogmsg(msg);\n        } else {\n            log.info(\"No Event log Message found.\");\n        }\n\n        // severity\n        if (ev.getEventSeverity() != null) {\n            log.debug(\"Setting Event Severity\");\n            e.setSeverity(Constants.getSeverityString(ev.getEventSeverity()));\n        } else {\n            log.info(\"No Event severity found.\");\n        }\n\n        //TODO FIXME SEND IFINDEX and IFALIAS To INS                                                        \n//          if (ev.getIfIndex() != null) \n//              e.setIfIndex(ev.getIfIndex().toString());\n        e.setIfIndex(-1);\n//          if (ev.getIfAlias() != null)\n//              e.setIfAlias(ev.getIfAlias());\n        e.setIfAlias(\"ifalias\");\n        \n        // operator Instruction\n        if (ev.getEventOperInstruct() != null) {\n            log.debug(\"Setting Event Operator Instruction\");\n            e.setOperinstruct(ev.getEventOperInstruct());\n        } else {\n            log.info(\"No Event operator Instruction found.\");\n        }\n\n        // parms\n        if (ev.getEventParms() != null ) {\n            Parms parms = Parameter.decode(ev.getEventParms());\n        \n            if (parms != null ) e.setParms(parms);\n        }\n\n        AlarmData ad = new AlarmData();\n        OnmsAlarm onmsAlarm = ev\n                .getAlarm();\n        try {\n            if (onmsAlarm != null) {\n                ad\n                        .setReductionKey(onmsAlarm\n                                .getReductionKey());\n                ad\n                        .setAlarmType(onmsAlarm\n                                .getAlarmType());\n                ad\n                        .setClearKey(onmsAlarm\n                                .getClearKey());\n                e\n                        .setAlarmData(ad);\n            }\n        } catch (ObjectNotFoundException e1) {\n            log\n                    .warn(\"correlated alarm data not found \"\n                            + e1);\n        }\n        log\n        .info(\"return Event with id: \" + ev.getId()); \n        return e;\n    }","id":49369,"modified_method":"private Event getXMLEvent(OnmsEvent ev) {\n        Category log = getLog();\n        log.info(\"Working on XML Event for id: \" + ev.getId()); \n        log.debug(\"Setting Event id: \" + ev.getId()); \n        Event e = new Event();\n        e.setDbid(ev.getId());\n\n        //UEI\n        if (ev.getEventUei() != null ) {\n            log.debug(\"Setting Event uei: \" + ev.getEventUei()); \n            e.setUei(ev.getEventUei());\n        } else {\n            log.warn(\"No Event uei found: skipping event....\");\n            return null;\n        }\n\n        // Source\n        if (ev.getEventSource() != null ) {\n            log.debug(\"Setting Event source: \" + ev.getEventSource()); \n            e.setSource(ev.getEventSource());\n        } else {\n            log.info(\"No Event source found.\"); \n        }\n\n        //nodeid\n        if (ev.getNode() != null) {\n            log.debug(\"Setting Event nodeid: \" + ev.getNode().getId()); \n            e.setNodeid(ev.getNode().getId());\n        } else {\n            log.info(\"No Event node found.\"); \n        }\n\n\n        // timestamp\n        if (ev.getEventTime() != null) {\n            log.debug(\"Setting event date timestamp to GMT\");\n            DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL);\n            dateFormat.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n            log.debug(\"Setting Event Time: \" + ev.getEventTime()); \n            e.setTime(dateFormat.format(ev.getEventTime()));\n        } else {\n            log.info(\"No Event time found.\"); \n        }\n        \n        // host\n        if (ev.getEventHost() != null) {\n            log.debug(\"Setting Event Host: \" + ev.getEventHost());\n            e.setHost(ev.getEventHost());\n        } else {\n            log.info(\"No Event host found.\");\n        }\n        \n        // interface\n        if (ev.getIpAddr() != null) {\n            log.debug(\"Setting Event Interface/ipaddress: \" + ev.getIpAddr());\n            e.setInterface(ev\n                           .getIpAddr());\n        } else {\n            log.info(\"No Event ip address found.\");\n        }\n        \n        // Service Name\n        if (ev.getServiceType() != null) {\n            log.debug(\"Setting Event Service Name: \" + ev.getServiceType().getName());\n            e.setService(ev.getServiceType().getName());\n        } else {\n            log.info(\"No Event service name found.\");\n        }\n\n        // Description\n        if (ev.getEventDescr() != null ) {\n            log.debug(\"Setting Event Description\");\n            e.setDescr(ev.getEventDescr());\n        } else {\n            log.info(\"No Event ip address found.\");\n        }\n        \n        // Log message\n        if (ev.getEventLogMsg() != null) {\n            Logmsg msg = new Logmsg();\n            log.debug(\"Setting Event Log Message\");\n            msg.setContent(ev.getEventLogMsg());\n            e.setLogmsg(msg);\n        } else {\n            log.info(\"No Event log Message found.\");\n        }\n\n        // severity\n        if (ev.getEventSeverity() != null) {\n            log.debug(\"Setting Event Severity\");\n            e.setSeverity(Constants.getSeverityString(ev.getEventSeverity()));\n        } else {\n            log.info(\"No Event severity found.\");\n        }\n\n          if (ev.getIfIndex() != null) {\n              e.setIfIndex(ev.getIfIndex());\n              e.setIfAlias(getIfAlias(ev.getNode().getId(),ev.getIfIndex()));\n          } else if (!ev.getIpAddr().equals(\"0.0.0.0\")) {\n              OnmsSnmpInterface iface = getIfAlias(ev.getNode().getId(), ev.getIpAddr());\n              if (iface != null) {\n                  e.setIfIndex(iface.getIfIndex());\n                  e.setIfAlias(iface.getIfAlias());\n              } else {\n                  e.setIfIndex(-1);\n                  e.setIfAlias(\"-1\");\n              }\n          } else {\n              e.setIfIndex(-1);\n              e.setIfAlias(\"-1\");\n          }\n\n        \n        // operator Instruction\n        if (ev.getEventOperInstruct() != null) {\n            log.debug(\"Setting Event Operator Instruction\");\n            e.setOperinstruct(ev.getEventOperInstruct());\n        } else {\n            log.info(\"No Event operator Instruction found.\");\n        }\n\n        // parms\n        if (ev.getEventParms() != null ) {\n            log.debug(\"Setting Event Parms: \" + ev.getEventParms());\n            Parms parms = Parameter.decode(ev.getEventParms());\n            if (parms != null ) e.setParms(parms);\n        } else {\n            log.info(\"No Event parms found.\");\n        }\n\n        AlarmData ad = new AlarmData();\n        OnmsAlarm onmsAlarm = ev\n                .getAlarm();\n        try {\n            if (onmsAlarm != null) {\n                ad\n                        .setReductionKey(onmsAlarm\n                                .getReductionKey());\n                ad\n                        .setAlarmType(onmsAlarm\n                                .getAlarmType());\n                ad\n                        .setClearKey(onmsAlarm\n                                .getClearKey());\n                e\n                        .setAlarmData(ad);\n            }\n        } catch (ObjectNotFoundException e1) {\n            log\n                    .warn(\"correlated alarm data not found \"\n                            + e1);\n        }\n        log\n        .info(\"return Event with id: \" + ev.getId()); \n        return e;\n    }","commit_id":"135a53ab28d61d0bd0f572be4fff745ddb4210f3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized void cleanActiveSessions(){\n\t\tsynchronized (activeSessions){\n\t\t\tIterator<InsSession> it = activeSessions.iterator();\n\t\t\twhile(it.hasNext()){\n\t\t\t\tInsSession insSession = it.next();\n\t\t\t\tif(insSession==null || !insSession.isAlive()){\n\t\t\t\t\tlog.debug(\"removing \"+insSession);\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlog.debug(\"active sessions are: \"+activeSessions);\n\t}","id":49370,"modified_method":"private synchronized void cleanActiveSessions(){\n        Category log = getLog();\n\t\tsynchronized (activeSessions){\n\t\t\tIterator<InsSession> it = activeSessions.iterator();\n\t\t\twhile(it.hasNext()){\n\t\t\t\tInsSession insSession = it.next();\n\t\t\t\tif(insSession==null || !insSession.isAlive()){\n\t\t\t\t\tlog.debug(\"removing \"+insSession);\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlog.debug(\"active sessions are: \"+activeSessions);\n\t}","commit_id":"9aa9ffa35b5557363f0948ffffd9b8b2058ea537","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Flushes the event in input to all active sessions with clients\n\t * @param event\n\t */\n\tpublic void flushEvent(Event event){\n\t\tlog.debug(\"Flushing \"+event.getUei());\n\t\t\n\t\tsynchronized (activeSessions){\n\t\t\tcleanActiveSessions();\n\t\t\tIterator<InsSession> it = activeSessions.iterator();\n\t\t\twhile(it.hasNext()){\t\t\t\n\t\t\t\tInsSession insSession = it.next();\n\t\t\t\tPrintStream ps = insSession.getStreamToClient();\n\t\t\t\tsynchronized (ps) {\n\t\t\t\t\tif(ps!=null){\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tevent.marshal(new PrintWriter(ps));\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tlog.error(\"Error while sending current event to client\"+e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}","id":49371,"modified_method":"/**\n\t * Flushes the event in input to all active sessions with clients\n\t * @param event\n\t */\n\tpublic void flushEvent(Event event){\n\t      Category log = getLog();\n\t      log.debug(\"Flushing \"+event.getUei());\n          int nodeid = (int) event.getNodeid();\n\n          if (event.getIfIndex() > 0 ) {\n              event.setIfAlias(getIfAlias(nodeid,event.getIfIndex()));\n          } else if (!event.getInterface().equals(\"0.0.0.0\")) {\n              OnmsSnmpInterface iface = getIfAlias(nodeid,event.getInterface()); \n              if (iface != null ) {\n                  event.setIfIndex(iface.getIfIndex());\n                  event.setIfAlias(iface.getIfAlias());\n              } else {\n                  event.setIfIndex(-1);\n                  event.setIfAlias(\"-1\");\n              }\n          } else {\n              event.setIfIndex(-1);\n              event.setIfAlias(\"-1\");\n          }\n\t         \n\t\tsynchronized (activeSessions){\n\t\t\tcleanActiveSessions();\n\t\t\tIterator<InsSession> it = activeSessions.iterator();\n\t\t\twhile(it.hasNext()){\t\t\t\n\t\t\t\tInsSession insSession = it.next();\n\t\t\t\tPrintStream ps = insSession.getStreamToClient();\n\t\t\t\tsynchronized (ps) {\n\t\t\t\t\tif(ps!=null){\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tevent.marshal(new PrintWriter(ps));\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tlog.error(\"Error while sending current event to client\"+e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}","commit_id":"9aa9ffa35b5557363f0948ffffd9b8b2058ea537","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\t/**\n\t * Stops the listener\n\t */\n\tpublic void interrupt() {\n\t\tlog.info(\"InsServerListener Interrupted!\");\n\t\ttry {\n\t\t\tlistener.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tsuper.interrupt();\n\t}","id":49372,"modified_method":"@Override\n\t/**\n\t * Stops the listener\n\t */\n\tpublic void interrupt() {\n        Category log = getLog();\n\t\tlog.info(\"InsServerListener Interrupted!\");\n\t\ttry {\n\t\t\tlistener.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tsuper.interrupt();\n\t}","commit_id":"9aa9ffa35b5557363f0948ffffd9b8b2058ea537","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * listens for incoming connection on defined port (default is 8154)\n\t */\n\tpublic void run() {\n        ThreadCategory.setPrefix(\"OpenNMS.InsProxy\");\n\t\tlog=ThreadCategory.getInstance(this.getClass());\n\t\tif(criteriaRestriction ==null)\n\t\t\tthrow new IllegalStateException(\"The property criteriaRestriction cannot be null!\");\n\t\tlog.info(\"InsServerListener started: listening on port \"+listeningPort);\n\t\ttry {\n\t\t\tlistener = new ServerSocket(listeningPort);\n\t\t\tSocket server;\n\n\t\t\twhile (true) {\n\t\t\t\t// when accepts an incoming connection, create an InsSession for\n\t\t\t\t// alarms exchange\n\t\t\t\tserver = listener.accept();\n\t\t\t\tInsSession session = new InsSession(server);\n\t\t\t\t//only if the sharedASCIIString is valorized, requires authentication\n\t\t\t\tif(sharedAuthAsciiString!=null)\n\t\t\t\t\tsession.setSharedASCIIString(sharedAuthAsciiString);\n\t\t\t\tsession.setCriteriaRestriction(criteriaRestriction);\n\t\t\t\tsession.start();\n\t\t\t\tactiveSessions.add(session);\n\t\t\t}\n\t\t} catch (IOException ioe) {\n\t\t\tlog.info(\"Socket closed.\" );\n\t\t}\n\t}","id":49373,"modified_method":"/**\n\t * listens for incoming connection on defined port (default is 8154)\n\t */\n\tpublic void run() {\n\t    Category log = getLog();\n\t\tif(criteriaRestriction ==null)\n\t\t\tthrow new IllegalStateException(\"The property criteriaRestriction cannot be null!\");\n\t\tlog.info(\"InsServerListener started: listening on port \"+listeningPort);\n\t\ttry {\n\t\t\tlistener = new ServerSocket(listeningPort);\n\t\t\tSocket server;\n\n\t\t\twhile (true) {\n\t\t\t\t// when accepts an incoming connection, create an InsSession for\n\t\t\t\t// alarms exchange\n\t\t\t\tserver = listener.accept();\n\t\t\t\tInsSession session = new InsSession(server);\n\t\t\t\t//only if the sharedASCIIString is valorized, requires authentication\n\t\t\t\tif(sharedAuthAsciiString!=null)\n\t\t\t\t\tsession.setSharedASCIIString(sharedAuthAsciiString);\n\t\t\t\tsession.setCriteriaRestriction(criteriaRestriction);\n\t\t\t\tsession.start();\n\t\t\t\tactiveSessions.add(session);\n\t\t\t}\n\t\t} catch (IOException ioe) {\n\t\t\tlog.info(\"Socket closed.\" );\n\t\t}\n\t}","commit_id":"9aa9ffa35b5557363f0948ffffd9b8b2058ea537","url":"https://github.com/OpenNMS/opennms"},{"original_method":"InsSession(Socket server) throws IOException {\n\t    ThreadCategory.setPrefix(\"OpenNMS.InsProxy\");\n\t\tlog = ThreadCategory.getInstance(this.getClass());\n\t\tthis.server = server;\n\t\tstreamToClient = new PrintStream(server.getOutputStream());\n\t}","id":49374,"modified_method":"InsSession(Socket server) throws IOException {\n\t\tthis.server = server;\n\t\tstreamToClient = new PrintStream(server.getOutputStream());\n\t}","commit_id":"9aa9ffa35b5557363f0948ffffd9b8b2058ea537","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Event getXMLEvent(OnmsEvent ev) {\n        log.info(\"Working on XML Event for id: \" + ev.getId()); \n        log.debug(\"Setting Event id: \" + ev.getId()); \n        Event e = new Event();\n        e.setDbid(ev.getId());\n\n        //UEI\n        if (ev.getEventUei() != null ) {\n            log.debug(\"Setting Event uei: \" + ev.getEventUei()); \n            e.setUei(ev.getEventUei());\n        } else {\n            log.warn(\"No Event uei found: skipping event....\");\n            return null;\n        }\n\n        // Source\n        if (ev.getEventSource() != null ) {\n            log.debug(\"Setting Event source: \" + ev.getEventSource()); \n            e.setSource(ev.getEventSource());\n        } else {\n            log.info(\"No Event source found.\"); \n        }\n\n        //nodeid\n        if (ev.getNode() != null) {\n            log.debug(\"Setting Event nodeid: \" + ev.getNode().getId()); \n            e.setNodeid(ev.getNode().getId());\n        } else {\n            log.info(\"No Event node found.\"); \n        }\n\n\n        // timestamp\n        if (ev.getEventTime() != null) {\n            log.debug(\"Setting event date timestamp to GMT\");\n            DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL);\n            dateFormat.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n            log.debug(\"Setting Event Time: \" + ev.getEventTime()); \n            e.setTime(dateFormat.format(ev.getEventTime()));\n        } else {\n            log.info(\"No Event time found.\"); \n        }\n        \n        // host\n        if (ev.getEventHost() != null) {\n            log.debug(\"Setting Event Host: \" + ev.getEventHost());\n            e.setHost(ev.getEventHost());\n        } else {\n            log.info(\"No Event host found.\");\n        }\n        \n        // interface\n        if (ev.getIpAddr() != null) {\n            log.debug(\"Setting Event Interface/ipaddress: \" + ev.getIpAddr());\n            e.setInterface(ev\n                           .getIpAddr());\n        } else {\n            log.info(\"No Event ip address found.\");\n        }\n        \n        // Service Name\n        if (ev.getServiceType() != null) {\n            log.debug(\"Setting Event Service Name: \" + ev.getServiceType().getName());\n            e.setService(ev.getServiceType().getName());\n        } else {\n            log.info(\"No Event service name found.\");\n        }\n\n        // Description\n        if (ev.getEventDescr() != null ) {\n            log.debug(\"Setting Event Description\");\n            e.setDescr(ev.getEventDescr());\n        } else {\n            log.info(\"No Event ip address found.\");\n        }\n        \n        // Log message\n        if (ev.getEventLogMsg() != null) {\n            Logmsg msg = new Logmsg();\n            log.debug(\"Setting Event Log Message\");\n            msg.setContent(ev.getEventLogMsg());\n            e.setLogmsg(msg);\n        } else {\n            log.info(\"No Event log Message found.\");\n        }\n\n        // severity\n        if (ev.getEventSeverity() != null) {\n            log.debug(\"Setting Event Severity\");\n            e.setSeverity(Constants.getSeverityString(ev.getEventSeverity()));\n        } else {\n            log.info(\"No Event severity found.\");\n        }\n\n        //TODO FIXME SEND IFINDEX and IFALIAS To INS                                                        \n//          if (ev.getIfIndex() != null) \n//              e.setIfIndex(ev.getIfIndex().toString());\n        e.setIfIndex(-1);\n//          if (ev.getIfAlias() != null)\n//              e.setIfAlias(ev.getIfAlias());\n        e.setIfAlias(\"ifalias\");\n        \n        // operator Instruction\n        if (ev.getEventOperInstruct() != null) {\n            log.debug(\"Setting Event Operator Instruction\");\n            e.setOperinstruct(ev.getEventOperInstruct());\n        } else {\n            log.info(\"No Event operator Instruction found.\");\n        }\n\n        // parms\n        if (ev.getEventParms() != null ) {\n            Parms parms = Parameter.decode(ev.getEventParms());\n        \n            if (parms != null ) e.setParms(parms);\n        }\n\n        AlarmData ad = new AlarmData();\n        OnmsAlarm onmsAlarm = ev\n                .getAlarm();\n        try {\n            if (onmsAlarm != null) {\n                ad\n                        .setReductionKey(onmsAlarm\n                                .getReductionKey());\n                ad\n                        .setAlarmType(onmsAlarm\n                                .getAlarmType());\n                ad\n                        .setClearKey(onmsAlarm\n                                .getClearKey());\n                e\n                        .setAlarmData(ad);\n            }\n        } catch (ObjectNotFoundException e1) {\n            log\n                    .warn(\"correlated alarm data not found \"\n                            + e1);\n        }\n        log\n        .info(\"return Event with id: \" + ev.getId()); \n        return e;\n    }","id":49375,"modified_method":"private Event getXMLEvent(OnmsEvent ev) {\n        Category log = getLog();\n        log.info(\"Working on XML Event for id: \" + ev.getId()); \n        log.debug(\"Setting Event id: \" + ev.getId()); \n        Event e = new Event();\n        e.setDbid(ev.getId());\n\n        //UEI\n        if (ev.getEventUei() != null ) {\n            log.debug(\"Setting Event uei: \" + ev.getEventUei()); \n            e.setUei(ev.getEventUei());\n        } else {\n            log.warn(\"No Event uei found: skipping event....\");\n            return null;\n        }\n\n        // Source\n        if (ev.getEventSource() != null ) {\n            log.debug(\"Setting Event source: \" + ev.getEventSource()); \n            e.setSource(ev.getEventSource());\n        } else {\n            log.info(\"No Event source found.\"); \n        }\n\n        //nodeid\n        if (ev.getNode() != null) {\n            log.debug(\"Setting Event nodeid: \" + ev.getNode().getId()); \n            e.setNodeid(ev.getNode().getId());\n        } else {\n            log.info(\"No Event node found.\"); \n        }\n\n\n        // timestamp\n        if (ev.getEventTime() != null) {\n            log.debug(\"Setting event date timestamp to GMT\");\n            DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL);\n            dateFormat.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n            log.debug(\"Setting Event Time: \" + ev.getEventTime()); \n            e.setTime(dateFormat.format(ev.getEventTime()));\n        } else {\n            log.info(\"No Event time found.\"); \n        }\n        \n        // host\n        if (ev.getEventHost() != null) {\n            log.debug(\"Setting Event Host: \" + ev.getEventHost());\n            e.setHost(ev.getEventHost());\n        } else {\n            log.info(\"No Event host found.\");\n        }\n        \n        // interface\n        if (ev.getIpAddr() != null) {\n            log.debug(\"Setting Event Interface/ipaddress: \" + ev.getIpAddr());\n            e.setInterface(ev\n                           .getIpAddr());\n        } else {\n            log.info(\"No Event ip address found.\");\n        }\n        \n        // Service Name\n        if (ev.getServiceType() != null) {\n            log.debug(\"Setting Event Service Name: \" + ev.getServiceType().getName());\n            e.setService(ev.getServiceType().getName());\n        } else {\n            log.info(\"No Event service name found.\");\n        }\n\n        // Description\n        if (ev.getEventDescr() != null ) {\n            log.debug(\"Setting Event Description\");\n            e.setDescr(ev.getEventDescr());\n        } else {\n            log.info(\"No Event ip address found.\");\n        }\n        \n        // Log message\n        if (ev.getEventLogMsg() != null) {\n            Logmsg msg = new Logmsg();\n            log.debug(\"Setting Event Log Message\");\n            msg.setContent(ev.getEventLogMsg());\n            e.setLogmsg(msg);\n        } else {\n            log.info(\"No Event log Message found.\");\n        }\n\n        // severity\n        if (ev.getEventSeverity() != null) {\n            log.debug(\"Setting Event Severity\");\n            e.setSeverity(Constants.getSeverityString(ev.getEventSeverity()));\n        } else {\n            log.info(\"No Event severity found.\");\n        }\n\n          if (ev.getIfIndex() != null) {\n              e.setIfIndex(ev.getIfIndex());\n              e.setIfAlias(getIfAlias(ev.getNode().getId(),ev.getIfIndex()));\n          } else if (!ev.getIpAddr().equals(\"0.0.0.0\")) {\n              OnmsSnmpInterface iface = getIfAlias(ev.getNode().getId(), ev.getIpAddr());\n              if (iface != null) {\n                  e.setIfIndex(iface.getIfIndex());\n                  e.setIfAlias(iface.getIfAlias());\n              } else {\n                  e.setIfIndex(-1);\n                  e.setIfAlias(\"-1\");\n              }\n          } else {\n              e.setIfIndex(-1);\n              e.setIfAlias(\"-1\");\n          }\n\n        \n        // operator Instruction\n        if (ev.getEventOperInstruct() != null) {\n            log.debug(\"Setting Event Operator Instruction\");\n            e.setOperinstruct(ev.getEventOperInstruct());\n        } else {\n            log.info(\"No Event operator Instruction found.\");\n        }\n\n        // parms\n        if (ev.getEventParms() != null ) {\n            log.debug(\"Setting Event Parms: \" + ev.getEventParms());\n            Parms parms = Parameter.decode(ev.getEventParms());\n            if (parms != null ) e.setParms(parms);\n        } else {\n            log.info(\"No Event parms found.\");\n        }\n\n        AlarmData ad = new AlarmData();\n        OnmsAlarm onmsAlarm = ev\n                .getAlarm();\n        try {\n            if (onmsAlarm != null) {\n                ad\n                        .setReductionKey(onmsAlarm\n                                .getReductionKey());\n                ad\n                        .setAlarmType(onmsAlarm\n                                .getAlarmType());\n                ad\n                        .setClearKey(onmsAlarm\n                                .getClearKey());\n                e\n                        .setAlarmData(ad);\n            }\n        } catch (ObjectNotFoundException e1) {\n            log\n                    .warn(\"correlated alarm data not found \"\n                            + e1);\n        }\n        log\n        .info(\"return Event with id: \" + ev.getId()); \n        return e;\n    }","commit_id":"9aa9ffa35b5557363f0948ffffd9b8b2058ea537","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void run() {\n\t\tinput = \"\";\n\n\t\ttry {\n\t\t\t// Get input from the client\n\t\t\tBufferedReader in = new BufferedReader(new InputStreamReader(server\n\t\t\t\t\t.getInputStream()));\n\n\t\t\treadingFromClient: while ((line = in.readLine()) != null) {\n\t\t\t\tinput = input + \"\\n\" + line;\n\t\t\t\tlog.debug(\"Client wrote: \" + line + \" from \"\n\t\t\t\t\t\t+ server.getInetAddress());\n\n\t\t\t\tif (status == STARTING_SESSION_STATUS) {\n\t\t\t\t\tif (line.equalsIgnoreCase(START_AUTHENTICATION_REQUEST)) {\n\t\t\t\t\t\tif (sharedAuthAsciiString != null) {\n\t\t\t\t\t\t\t// authorization required\n\t\t\t\t\t\t\tstreamToClient.println(AUTH_REQUIRED_ACK);\n\t\t\t\t\t\t\tlog.debug(\"Starting authentication, sending \"\n\t\t\t\t\t\t\t\t\t+ AUTH_REQUIRED_ACK + \" to the client\");\n\t\t\t\t\t\t\tstatus = AUTHENTICATING_STATUS;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// authorization not required\n\t\t\t\t\t\t\tstreamToClient.println(AUTH_NOT_REQUIRED_ACK);\n\t\t\t\t\t\t\tlog.debug(\"Starting authentication, sending \"\n\t\t\t\t\t\t\t\t\t+ AUTH_NOT_REQUIRED_ACK + \" to the client\");\n\t\t\t\t\t\t\tstatus = AUTHENTICATED_STATUS;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// security reset (a malicious user may use DOS attack\n\t\t\t\t\t\t// before authentication)\n\t\t\t\t\t\tlog.warn(\"Wrong client request\");\n\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (status == AUTHENTICATING_STATUS) {\n\t\t\t\t\tif (sharedAuthAsciiString != null) {\n\t\t\t\t\t\t// authentication required (security check)\n\t\t\t\t\t\tif (line.equals(sharedAuthAsciiString)) {\n\t\t\t\t\t\t\tstatus = AUTHENTICATED_STATUS;\n\t\t\t\t\t\t\tlog.debug(\"Authentication success!\");\n\t\t\t\t\t\t\tstreamToClient.println(AUTHENTICATION_SUCCESS);\n\t\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstreamToClient.println(RESET_SIGNAL);\n\t\t\t\t\t\t\tlog\n\t\t\t\t\t\t\t\t\t.warn(\"Authentication failure! Resetting session.\");\n\t\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (status == AUTHENTICATED_STATUS || status == DATAFLOW_STATUS) {\n\t\t\t\t\tif (line.equalsIgnoreCase(LIST_CURRENT_ALARM_REQUEST)) {\n\t\t\t\t\t\tlog.debug(\"Sending alarms to the client\");\n\t\t\t\t\t\trefreshAlarms();\n\t\t\t\t\t\tstatus = DATAFLOW_STATUS;\n\t\t\t\t\t\tsynchronized (streamToClient) {\n\t\t\t\t\t\t\tstreamToClient.println(ACTIVE_ALARM_BEGIN);\n\t\t\t\t\t\t\tList<Event> events = getEvents();\n\t\t\t\t\t\t\tif (events != null && events.size() > 0) {\n                                Iterator<Event> ite = events.iterator();\n                                while (ite.hasNext()) {\n                                    StringWriter sw = new StringWriter();\n                                    Event xmlEvent = ite.next();\n                                    try {\n                                        log.info(\"Marshal Event with id: \" + xmlEvent.getDbid()); \n                                        xmlEvent.marshal(sw);\n                                        log.info(\"Flushing Event with id: \" + xmlEvent.getDbid()); \n                                        sw.flush();\n                                        log.info(\"String Writer:\" + sw.getBuffer().toString()); \n                                        if (sw != null) {\n                                            streamToClient.print(sw.toString());\n                                        } else {\n                                            log.warn(\"String Writer is null\");\n//                                          break readingFromClient;\n                                        }\n                                    } catch (MarshalException e) {\n                                        log.error(\"Marshall Exception: \" + e);\n                                    } catch (ValidationException e) {\n                                        log.error(\"Validation Exception: \" + e);\n                                    }\n                                }\n\t\t\t\t\t\t\t}\n                            streamToClient.println(ACTIVE_ALARM_END);\n                            continue readingFromClient;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (line.equalsIgnoreCase(STOP_ALARM_REQUEST)) {\n\t\t\t\t\t\t\tlog.debug(\"Closing session due client request.\");\n\t\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlog.warn(\"Wrong client request\");\n\t\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlog.debug(\"Overall message from \" + server.getInetAddress()\n\t\t\t\t\t+ \" is:\" + input);\n\t\t\tlog.debug(\"\\nClosing session with \" + server.getInetAddress()\n\t\t\t\t\t+ \"...\\n\\n\");\n\t\t\tserver.close();\n\t\t} catch (IOException ioe) {\n\t\t\tlog.warn(\"IOException on socket listen: \" + ioe, ioe);\n\t\t}\n\t}","id":49376,"modified_method":"public void run() {\n        Category log = getLog();\n\t\tinput = \"\";\n\n\t\ttry {\n\t\t\t// Get input from the client\n\t\t\tBufferedReader in = new BufferedReader(new InputStreamReader(server\n\t\t\t\t\t.getInputStream()));\n\n\t\t\treadingFromClient: while ((line = in.readLine()) != null) {\n\t\t\t\tinput = input + \"\\n\" + line;\n\t\t\t\tlog.debug(\"Client wrote: \" + line + \" from \"\n\t\t\t\t\t\t+ server.getInetAddress());\n\n\t\t\t\tif (status == STARTING_SESSION_STATUS) {\n\t\t\t\t\tif (line.equalsIgnoreCase(START_AUTHENTICATION_REQUEST)) {\n\t\t\t\t\t\tif (sharedAuthAsciiString != null) {\n\t\t\t\t\t\t\t// authorization required\n\t\t\t\t\t\t\tstreamToClient.println(AUTH_REQUIRED_ACK);\n\t\t\t\t\t\t\tlog.debug(\"Starting authentication, sending \"\n\t\t\t\t\t\t\t\t\t+ AUTH_REQUIRED_ACK + \" to the client\");\n\t\t\t\t\t\t\tstatus = AUTHENTICATING_STATUS;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// authorization not required\n\t\t\t\t\t\t\tstreamToClient.println(AUTH_NOT_REQUIRED_ACK);\n\t\t\t\t\t\t\tlog.debug(\"Starting authentication, sending \"\n\t\t\t\t\t\t\t\t\t+ AUTH_NOT_REQUIRED_ACK + \" to the client\");\n\t\t\t\t\t\t\tstatus = AUTHENTICATED_STATUS;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// security reset (a malicious user may use DOS attack\n\t\t\t\t\t\t// before authentication)\n\t\t\t\t\t\tlog.warn(\"Wrong client request\");\n\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (status == AUTHENTICATING_STATUS) {\n\t\t\t\t\tif (sharedAuthAsciiString != null) {\n\t\t\t\t\t\t// authentication required (security check)\n\t\t\t\t\t\tif (line.equals(sharedAuthAsciiString)) {\n\t\t\t\t\t\t\tstatus = AUTHENTICATED_STATUS;\n\t\t\t\t\t\t\tlog.debug(\"Authentication success!\");\n\t\t\t\t\t\t\tstreamToClient.println(AUTHENTICATION_SUCCESS);\n\t\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstreamToClient.println(RESET_SIGNAL);\n\t\t\t\t\t\t\tlog\n\t\t\t\t\t\t\t\t\t.warn(\"Authentication failure! Resetting session.\");\n\t\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (status == AUTHENTICATED_STATUS || status == DATAFLOW_STATUS) {\n\t\t\t\t\tif (line.equalsIgnoreCase(LIST_CURRENT_ALARM_REQUEST)) {\n\t\t\t\t        log.debug(\"Fetching Events from Database\");\n\t\t\t\t\t    getEventsByCriteria();\n\t\t\t\t\t\tstatus = DATAFLOW_STATUS;\n\t\t\t\t\t\tsynchronized (streamToClient) {\n\t\t\t\t\t\t\t streamToClient.println(ACTIVE_ALARM_BEGIN);\n\t                         StringWriter sw = getOutput();\n  \t\t                     if (sw != null) {\n   \t\t                        log.info(\"String Writer:\" + sw.getBuffer().toString()); \n\t\t                        streamToClient.print(sw.toString());\n\t\t                     } else {\n\t\t                        log.error(\"String Writer is null\");\n//\t\t\t                      break readingFromClient;\n\t\t                     }\n                             streamToClient.println(ACTIVE_ALARM_END);\n                             continue readingFromClient;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (line.equalsIgnoreCase(STOP_ALARM_REQUEST)) {\n\t\t\t\t\t\t\tlog.debug(\"Closing session due client request.\");\n\t\t\t\t\t\t\tbreak readingFromClient;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlog.warn(\"Wrong client request\");\n\t\t\t\t\t\t\tcontinue readingFromClient;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlog.debug(\"Overall message from \" + server.getInetAddress()\n\t\t\t\t\t+ \" is:\" + input);\n\t\t\tlog.debug(\"\\nClosing session with \" + server.getInetAddress()\n\t\t\t\t\t+ \"...\\n\\n\");\n\t\t\tserver.close();\n\t\t} catch (IOException ioe) {\n\t\t\tlog.warn(\"IOException on socket listen: \" + ioe, ioe);\n\t\t}\n\t}","commit_id":"9aa9ffa35b5557363f0948ffffd9b8b2058ea537","url":"https://github.com/OpenNMS/opennms"},{"original_method":"Query query( String keyOrNull, Object value, QueryContext contextOrNull )\n    {\n        if ( value instanceof Query )\n        {\n            return (Query) value;\n        }\n        \n        QueryParser parser = new QueryParser( Version.LUCENE_30, keyOrNull, analyzer );\n        parser.setAllowLeadingWildcard( true );\n        parser.setLowercaseExpandedTerms( false );\n        if ( contextOrNull != null && contextOrNull.defaultOperator != null )\n        {\n            parser.setDefaultOperator( contextOrNull.defaultOperator );\n        }\n        try\n        {\n            return parser.parse( value.toString() );\n        }\n        catch ( ParseException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":49377,"modified_method":"Query query( String keyOrNull, Object value, QueryContext contextOrNull )\n    {\n        if ( value instanceof Query )\n        {\n            return (Query) value;\n        }\n        \n        QueryParser parser = new QueryParser( Version.LUCENE_30, keyOrNull, analyzer );\n        parser.setAllowLeadingWildcard( true );\n        parser.setLowercaseExpandedTerms( toLowerCase );\n        if ( contextOrNull != null && contextOrNull.defaultOperator != null )\n        {\n            parser.setDefaultOperator( contextOrNull.defaultOperator );\n        }\n        try\n        {\n            return parser.parse( value.toString() );\n        }\n        catch ( ParseException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"69bf216105e449c25a1845abd2094bba88a4951a","url":"https://github.com/neo4j/neo4j"},{"original_method":"static IndexType getIndexType( IndexIdentifier identifier )\n    {\n        Map<String, String> config = identifier.config;\n        String type = config.get( configKey( identifier.indexName, \"type\" ) );\n        IndexType result = null;\n        if ( type.equals( \"exact\" ) )\n        {\n            result = EXACT;\n        }\n        else if ( type.equals( \"fulltext\" ) )\n        {\n            result = new FulltextType( getAnalyzer( config, identifier.indexName ) );\n        }\n        else\n        {\n            throw new RuntimeException( \"Unknown type '\" + type + \"' for index '\" +\n                    identifier.indexName + \"'\" );\n        }\n        return result;\n    }","id":49378,"modified_method":"static IndexType getIndexType( IndexIdentifier identifier )\n    {\n        Map<String, String> config = identifier.config;\n        String type = config.get( configKey( identifier.indexName, \"type\" ) );\n        IndexType result = null;\n        boolean toLowerCase = parseBoolean( config.get( configKey( identifier.indexName, \"to_lower_case\" ) ), true );\n        Analyzer customAnalyzer = getCustomAnalyzer( config, identifier.indexName );\n        if ( type != null )\n        {\n            // Use the built in alternatives... \"exact\" or \"fulltext\"\n            if ( type.equals( \"exact\" ) )\n            {\n                result = EXACT;\n            }\n            else if ( type.equals( \"fulltext\" ) )\n            {\n                Analyzer analyzer = customAnalyzer;\n                if ( analyzer == null )\n                {\n                    analyzer = toLowerCase ? LuceneDataSource.LOWER_CASE_WHITESPACE_ANALYZER :\n                            LuceneDataSource.WHITESPACE_ANALYZER;\n                }\n                result = new CustomType( analyzer, toLowerCase );\n            }\n        }\n        else\n        {\n            // Use custom analyzer\n            if ( customAnalyzer == null )\n            {\n                throw new IllegalArgumentException( \"No 'type' was given (which can point out \" +\n                \t\t\"built-in analyzers, such as 'exact' and 'fulltext')\" +\n                \t\t\" and no 'analyzer' was given either (which can point out a custom \" +\n                \t\tAnalyzer.class.getName() + \" to use)\" );\n            }\n            result = new CustomType( customAnalyzer, toLowerCase );\n        }\n        return result;\n    }","commit_id":"69bf216105e449c25a1845abd2094bba88a4951a","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static Analyzer getAnalyzer( Map<String, String> config, String indexName )\n    {\n        String analyzerClass = config.get( configKey( indexName, \"analyzer\" ) );\n        if ( analyzerClass != null )\n        {\n            try\n            {\n                return Class.forName( analyzerClass ).asSubclass( Analyzer.class ).newInstance();\n            }\n            catch ( Exception e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        \n        String lowerCase = config.get( configKey( indexName, \"to_lower_case\" ) );\n        if ( lowerCase == null || Boolean.parseBoolean( lowerCase ) )\n        {\n            return LuceneDataSource.LOWER_CASE_WHITESPACE_ANALYZER;\n        }\n        else\n        {\n            return LuceneDataSource.WHITESPACE_ANALYZER;\n        }\n    }","id":49379,"modified_method":"private static Analyzer getCustomAnalyzer( Map<String, String> config, String indexName )\n    {\n        String analyzerClass = config.get( configKey( indexName, \"analyzer\" ) );\n        if ( analyzerClass != null )\n        {\n            try\n            {\n                return Class.forName( analyzerClass ).asSubclass( Analyzer.class ).newInstance();\n            }\n            catch ( Exception e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return null;\n    }","commit_id":"69bf216105e449c25a1845abd2094bba88a4951a","url":"https://github.com/neo4j/neo4j"},{"original_method":"private IndexType( Analyzer analyzer )\n    {\n        this.analyzer = analyzer;\n    }","id":49380,"modified_method":"private IndexType( Analyzer analyzer, boolean toLowerCase )\n    {\n        this.analyzer = analyzer;\n        this.toLowerCase = toLowerCase;\n    }","commit_id":"69bf216105e449c25a1845abd2094bba88a4951a","url":"https://github.com/neo4j/neo4j"},{"original_method":"static IndexType getIndexType( IndexIdentifier identifier )\n    {\n        Map<String, String> config = identifier.config;\n        String type = config.get( configKey( identifier.indexName, \"type\" ) );\n        IndexType result = null;\n        if ( type.equals( \"exact\" ) )\n        {\n            result = EXACT;\n        }\n        else if ( type.equals( \"fulltext\" ) )\n        {\n            result = new FulltextType( getAnalyzer( config, identifier.indexName ) );\n        }\n        else\n        {\n            throw new RuntimeException( \"Unknown type '\" + type + \"' for index '\" +\n                    identifier.indexName + \"'\" );\n        }\n        return result;\n    }","id":49381,"modified_method":"static IndexType getIndexType( IndexIdentifier identifier )\n    {\n        Map<String, String> config = identifier.config;\n        String type = config.get( configKey( identifier.indexName, \"type\" ) );\n        IndexType result = null;\n        boolean toLowerCase = parseBoolean( config.get( configKey( identifier.indexName, \"to_lower_case\" ) ), true );\n        Analyzer customAnalyzer = getCustomAnalyzer( config, identifier.indexName );\n        if ( type != null )\n        {\n            // Use the built in alternatives... \"exact\" or \"fulltext\"\n            if ( type.equals( \"exact\" ) )\n            {\n                result = EXACT;\n            }\n            else if ( type.equals( \"fulltext\" ) )\n            {\n                Analyzer analyzer = customAnalyzer;\n                if ( analyzer == null )\n                {\n                    analyzer = toLowerCase ? LuceneDataSource.LOWER_CASE_WHITESPACE_ANALYZER :\n                            LuceneDataSource.WHITESPACE_ANALYZER;\n                }\n                result = new CustomType( analyzer, toLowerCase );\n            }\n        }\n        else\n        {\n            // Use custom analyzer\n            if ( customAnalyzer == null )\n            {\n                throw new IllegalArgumentException( \"No 'type' was given (which can point out \" +\n                \t\t\"built-in analyzers, such as 'exact' and 'fulltext')\" +\n                \t\t\" and no 'analyzer' was given either (which can point out a custom \" +\n                \t\tAnalyzer.class.getName() + \" to use)\" );\n            }\n            result = new CustomType( customAnalyzer, toLowerCase );\n        }\n        return result;\n    }","commit_id":"ded8922360fe4258455907d2d283826a48654eb6","url":"https://github.com/neo4j/neo4j"},{"original_method":"private IndexType( Analyzer analyzer )\n    {\n        this.analyzer = analyzer;\n    }","id":49382,"modified_method":"private IndexType( Analyzer analyzer, boolean toLowerCase )\n    {\n        this.analyzer = analyzer;\n        this.toLowerCase = toLowerCase;\n    }","commit_id":"ded8922360fe4258455907d2d283826a48654eb6","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static Analyzer getAnalyzer( Map<String, String> config, String indexName )\n    {\n        String analyzerClass = config.get( configKey( indexName, \"analyzer\" ) );\n        if ( analyzerClass != null )\n        {\n            try\n            {\n                return Class.forName( analyzerClass ).asSubclass( Analyzer.class ).newInstance();\n            }\n            catch ( Exception e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        \n        String lowerCase = config.get( configKey( indexName, \"to_lower_case\" ) );\n        if ( lowerCase == null || Boolean.parseBoolean( lowerCase ) )\n        {\n            return LuceneDataSource.LOWER_CASE_WHITESPACE_ANALYZER;\n        }\n        else\n        {\n            return LuceneDataSource.WHITESPACE_ANALYZER;\n        }\n    }","id":49383,"modified_method":"private static Analyzer getCustomAnalyzer( Map<String, String> config, String indexName )\n    {\n        String analyzerClass = config.get( configKey( indexName, \"analyzer\" ) );\n        if ( analyzerClass != null )\n        {\n            try\n            {\n                return Class.forName( analyzerClass ).asSubclass( Analyzer.class ).newInstance();\n            }\n            catch ( Exception e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return null;\n    }","commit_id":"ded8922360fe4258455907d2d283826a48654eb6","url":"https://github.com/neo4j/neo4j"},{"original_method":"Query query( String keyOrNull, Object value, QueryContext contextOrNull )\n    {\n        if ( value instanceof Query )\n        {\n            return (Query) value;\n        }\n        \n        QueryParser parser = new QueryParser( Version.LUCENE_30, keyOrNull, analyzer );\n        parser.setAllowLeadingWildcard( true );\n        parser.setLowercaseExpandedTerms( false );\n        if ( contextOrNull != null && contextOrNull.defaultOperator != null )\n        {\n            parser.setDefaultOperator( contextOrNull.defaultOperator );\n        }\n        try\n        {\n            return parser.parse( value.toString() );\n        }\n        catch ( ParseException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":49384,"modified_method":"Query query( String keyOrNull, Object value, QueryContext contextOrNull )\n    {\n        if ( value instanceof Query )\n        {\n            return (Query) value;\n        }\n        \n        QueryParser parser = new QueryParser( Version.LUCENE_30, keyOrNull, analyzer );\n        parser.setAllowLeadingWildcard( true );\n        parser.setLowercaseExpandedTerms( toLowerCase );\n        if ( contextOrNull != null && contextOrNull.defaultOperator != null )\n        {\n            parser.setDefaultOperator( contextOrNull.defaultOperator );\n        }\n        try\n        {\n            return parser.parse( value.toString() );\n        }\n        catch ( ParseException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"ded8922360fe4258455907d2d283826a48654eb6","url":"https://github.com/neo4j/neo4j"},{"original_method":"Query query( String keyOrNull, Object value, QueryContext contextOrNull )\n    {\n        if ( value instanceof Query )\n        {\n            return (Query) value;\n        }\n        \n        QueryParser parser = new QueryParser( Version.LUCENE_30, keyOrNull, analyzer );\n        parser.setAllowLeadingWildcard( true );\n        parser.setLowercaseExpandedTerms( false );\n        if ( contextOrNull != null && contextOrNull.defaultOperator != null )\n        {\n            parser.setDefaultOperator( contextOrNull.defaultOperator );\n        }\n        try\n        {\n            return parser.parse( value.toString() );\n        }\n        catch ( ParseException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":49385,"modified_method":"Query query( String keyOrNull, Object value, QueryContext contextOrNull )\n    {\n        if ( value instanceof Query )\n        {\n            return (Query) value;\n        }\n        \n        QueryParser parser = new QueryParser( Version.LUCENE_30, keyOrNull, analyzer );\n        parser.setAllowLeadingWildcard( true );\n        parser.setLowercaseExpandedTerms( toLowerCase );\n        if ( contextOrNull != null && contextOrNull.defaultOperator != null )\n        {\n            parser.setDefaultOperator( contextOrNull.defaultOperator );\n        }\n        try\n        {\n            return parser.parse( value.toString() );\n        }\n        catch ( ParseException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"f27d8f47c948c06b6bcb8c8e9e9ba1fcb017f142","url":"https://github.com/neo4j/neo4j"},{"original_method":"static IndexType getIndexType( IndexIdentifier identifier )\n    {\n        Map<String, String> config = identifier.config;\n        String type = config.get( configKey( identifier.indexName, \"type\" ) );\n        IndexType result = null;\n        if ( type.equals( \"exact\" ) )\n        {\n            result = EXACT;\n        }\n        else if ( type.equals( \"fulltext\" ) )\n        {\n            result = new FulltextType( getAnalyzer( config, identifier.indexName ) );\n        }\n        else\n        {\n            throw new RuntimeException( \"Unknown type '\" + type + \"' for index '\" +\n                    identifier.indexName + \"'\" );\n        }\n        return result;\n    }","id":49386,"modified_method":"static IndexType getIndexType( IndexIdentifier identifier )\n    {\n        Map<String, String> config = identifier.config;\n        String type = config.get( configKey( identifier.indexName, \"type\" ) );\n        IndexType result = null;\n        boolean toLowerCase = parseBoolean( config.get( configKey( identifier.indexName, \"to_lower_case\" ) ), true );\n        Analyzer customAnalyzer = getCustomAnalyzer( config, identifier.indexName );\n        if ( type != null )\n        {\n            // Use the built in alternatives... \"exact\" or \"fulltext\"\n            if ( type.equals( \"exact\" ) )\n            {\n                result = EXACT;\n            }\n            else if ( type.equals( \"fulltext\" ) )\n            {\n                Analyzer analyzer = customAnalyzer;\n                if ( analyzer == null )\n                {\n                    analyzer = toLowerCase ? LuceneDataSource.LOWER_CASE_WHITESPACE_ANALYZER :\n                            LuceneDataSource.WHITESPACE_ANALYZER;\n                }\n                result = new CustomType( analyzer, toLowerCase );\n            }\n        }\n        else\n        {\n            // Use custom analyzer\n            if ( customAnalyzer == null )\n            {\n                throw new IllegalArgumentException( \"No 'type' was given (which can point out \" +\n                \t\t\"built-in analyzers, such as 'exact' and 'fulltext')\" +\n                \t\t\" and no 'analyzer' was given either (which can point out a custom \" +\n                \t\tAnalyzer.class.getName() + \" to use)\" );\n            }\n            result = new CustomType( customAnalyzer, toLowerCase );\n        }\n        return result;\n    }","commit_id":"f27d8f47c948c06b6bcb8c8e9e9ba1fcb017f142","url":"https://github.com/neo4j/neo4j"},{"original_method":"private IndexType( Analyzer analyzer )\n    {\n        this.analyzer = analyzer;\n    }","id":49387,"modified_method":"private IndexType( Analyzer analyzer, boolean toLowerCase )\n    {\n        this.analyzer = analyzer;\n        this.toLowerCase = toLowerCase;\n    }","commit_id":"f27d8f47c948c06b6bcb8c8e9e9ba1fcb017f142","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static Analyzer getAnalyzer( Map<String, String> config, String indexName )\n    {\n        String analyzerClass = config.get( configKey( indexName, \"analyzer\" ) );\n        if ( analyzerClass != null )\n        {\n            try\n            {\n                return Class.forName( analyzerClass ).asSubclass( Analyzer.class ).newInstance();\n            }\n            catch ( Exception e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        \n        String lowerCase = config.get( configKey( indexName, \"to_lower_case\" ) );\n        if ( lowerCase == null || Boolean.parseBoolean( lowerCase ) )\n        {\n            return LuceneDataSource.LOWER_CASE_WHITESPACE_ANALYZER;\n        }\n        else\n        {\n            return LuceneDataSource.WHITESPACE_ANALYZER;\n        }\n    }","id":49388,"modified_method":"private static Analyzer getCustomAnalyzer( Map<String, String> config, String indexName )\n    {\n        String analyzerClass = config.get( configKey( indexName, \"analyzer\" ) );\n        if ( analyzerClass != null )\n        {\n            try\n            {\n                return Class.forName( analyzerClass ).asSubclass( Analyzer.class ).newInstance();\n            }\n            catch ( Exception e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n        return null;\n    }","commit_id":"f27d8f47c948c06b6bcb8c8e9e9ba1fcb017f142","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Overwrites the setVisible method in order to set the size and the\n     * position of this window before showing it.\n     */\n    public void setVisible(boolean isVisible)\n    {   \n        if(isVisible)\n        {\n            this.pack();\n\n            if(isSaveSizeAndLocation)\n                this.setSizeAndLocation();\n            else\n            {\n                this.pack();\n                this.setCenterLocation();\n            }\n\n            ensureOnScreenLocationAndSize();\n            \n            JButton button = this.getRootPane().getDefaultButton();\n\n            if(button != null)\n                button.requestFocus();\n        }\n        \n        super.setVisible(isVisible);\n    }","id":49389,"modified_method":"/**\n     * Overwrites the setVisible method in order to set the size and the\n     * position of this window before showing it.\n     * @param isVisible indicates if the dialog should be visible\n     */\n    public void setVisible(boolean isVisible)\n    {\n        if(isVisible)\n        {\n            this.pack();\n\n            if(isSaveSizeAndLocation)\n                this.setSizeAndLocation();\n            else\n            {\n                this.pack();\n                this.setCenterLocation();\n            }\n\n            ensureOnScreenLocationAndSize();\n            \n            JButton button = this.getRootPane().getDefaultButton();\n\n            if(button != null)\n                button.requestFocus();\n        }\n        super.setVisible(isVisible);\n    }","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"public SIPCommDialog(Dialog owner)\n    {\n        super(owner);\n\n        this.init();\n    }","id":49390,"modified_method":"/**\n     * Creates an instance of <tt>SIPCommDialog<\/tt> by specifying the\n     * <tt>Dialog<\/tt>owner of this dialog.\n     * @param owner the owner of this dialog\n     */\n    public SIPCommDialog(Dialog owner)\n    {\n        super(owner);\n\n        this.init();\n    }","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"public SIPCommDialog(Frame owner)\n    {\n        super(owner);\n\n        this.init();\n    }","id":49391,"modified_method":"/**\n     * Creates an instance of <tt>SIPCommDialog<\/tt> by specifying the\n     * <tt>Frame<\/tt> owner.\n     * @param owner the owner of this dialog\n     */\n    public SIPCommDialog(Frame owner)\n    {\n        super(owner);\n\n        this.init();\n    }","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"public SIPCommDialog(Frame owner, boolean isSaveSizeAndLocation)\n    {\n        this(owner);\n\n        this.isSaveSizeAndLocation = isSaveSizeAndLocation;\n    }","id":49392,"modified_method":"/**\n     * Creates an instance of <tt>SIPCommDialog<\/tt> by specifying the owner\n     * of this dialog and indicating whether to save the size and location\n     * properties.\n     * @param owner the owner of this dialog\n     * @param isSaveSizeAndLocation indicates whether to save the size and\n     * location of this dialog\n     */\n    public SIPCommDialog(Frame owner, boolean isSaveSizeAndLocation)\n    {\n        this(owner);\n\n        this.isSaveSizeAndLocation = isSaveSizeAndLocation;\n    }","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"public SIPCommDialog(boolean isSaveSizeAndLocation)\n    {\n        this();\n\n        this.isSaveSizeAndLocation = isSaveSizeAndLocation;\n    }","id":49393,"modified_method":"/**\n     * Creates an instance of <tt>SIPCommDialog<\/tt> by specifying explicitly\n     * if the size and location properties are saved. By default size and\n     * location are stored.\n     * @param isSaveSizeAndLocation indicates whether to save the size and\n     * location of this dialog\n     */\n    public SIPCommDialog(boolean isSaveSizeAndLocation)\n    {\n        this();\n\n        this.isSaveSizeAndLocation = isSaveSizeAndLocation;\n    }","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void windowClosing(WindowEvent e)\n        {\n            if(isSaveSizeAndLocation)\n                saveSizeAndLocation();\n\n            close(false);\n        }","id":49394,"modified_method":"/**\n         * Invoked when this window is in the process of being closed.\n         * @param e the <tt>WindowEvent<\/tt> that notified us\n         */\n        public void windowClosing(WindowEvent e)\n        {\n            if(isSaveSizeAndLocation)\n                saveSizeAndLocation();\n\n            close(false);\n        }","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * All functions implemented in this method will be invoked when user\n     * presses the Escape key. \n     */\n    protected abstract void close(boolean isEscaped);","id":49395,"modified_method":"/**\n     * All functions implemented in this method will be invoked when user\n     * presses the Escape key.\n     * @param isEscaped indicates if this dialog has been closed by pressing\n     * the Esc key\n     */\n    protected abstract void close(boolean isEscaped);","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"public SIPCommDialog(Dialog owner, boolean isSaveSizeAndLocation)\n    {\n        this(owner);\n\n        this.isSaveSizeAndLocation = isSaveSizeAndLocation;\n    }","id":49396,"modified_method":"/**\n     * Creates an instance of <tt>SIPCommDialog<\/tt> by specifying the owner\n     * of this dialog and indicating whether to save the size and location\n     * properties.\n     * @param owner the owner of this dialog\n     * @param isSaveSizeAndLocation indicates whether to save the size and\n     * location of this dialog\n     */\n    public SIPCommDialog(Dialog owner, boolean isSaveSizeAndLocation)\n    {\n        this(owner);\n\n        this.isSaveSizeAndLocation = isSaveSizeAndLocation;\n    }","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"public SIPCommDialog()\n    {\n        super();\n\n        this.init();\n    }","id":49397,"modified_method":"/**\n     * Creates an instance of <tt>SIPCommDialog<\/tt>.\n     */\n    public SIPCommDialog()\n    {\n        super();\n\n        this.init();\n    }","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"public MainContentPane()\n        {\n            super(new BorderLayout());\n\n            ResourceManagementService resources =\n                UtilActivator.getResources();\n\n            int borderSize =\n                resources\n                    .getSettingsInt(\"impl.gui.MAIN_WINDOW_BORDER_SIZE\");\n            this.setBorder(BorderFactory.createEmptyBorder(borderSize,\n                borderSize, borderSize, borderSize));\n\n            isColorBgEnabled =\n                new Boolean(resources.getSettingsString(\n                    \"impl.gui.IS_WINDOW_COLOR_BACKGROUND_ENABLED\"))\n                    .booleanValue();\n\n            if (isColorBgEnabled)\n            {\n                bgStartColor =\n                    new Color(resources.getColor(\"service.gui.MAIN_BACKGROUND\"));\n                bgEndColor =\n                    new Color(resources\n                        .getColor(\"service.gui.MAIN_BACKGROUND_GRADIENT\"));\n            }\n            else\n            {\n                bgStartColor = null;\n                bgEndColor = null;\n            }\n\n            isImageBgEnabled =\n                new Boolean(resources.getSettingsString(\n                    \"impl.gui.IS_WINDOW_IMAGE_BACKGROUND_ENABLED\"))\n                    .booleanValue();\n\n            if (isImageBgEnabled)\n            {\n                final URL bgImagePath\n                    = resources.getImageURL(\"service.gui.WINDOW_TITLE_BAR_BG\");\n\n                bgImage = ImageUtils.getBufferedImage(bgImagePath);\n\n                final Rectangle rect =\n                    new Rectangle(0, 0, bgImage.getWidth(),\n                                    bgImage.getHeight());\n\n                texture = new TexturePaint(bgImage, rect);\n            }\n        }","id":49398,"modified_method":"/**\n         * Creates an instance of <tt>MainContentPane<\/tt>.\n         */\n        public MainContentPane()\n        {\n            super(new BorderLayout());\n\n            ResourceManagementService resources =\n                UtilActivator.getResources();\n\n            int borderSize =\n                resources\n                    .getSettingsInt(\"impl.gui.MAIN_WINDOW_BORDER_SIZE\");\n            this.setBorder(BorderFactory.createEmptyBorder(borderSize,\n                borderSize, borderSize, borderSize));\n\n            isColorBgEnabled =\n                new Boolean(resources.getSettingsString(\n                    \"impl.gui.IS_WINDOW_COLOR_BACKGROUND_ENABLED\"))\n                    .booleanValue();\n\n            if (isColorBgEnabled)\n            {\n                bgStartColor =\n                    new Color(resources.getColor(\"service.gui.MAIN_BACKGROUND\"));\n                bgEndColor =\n                    new Color(resources\n                        .getColor(\"service.gui.MAIN_BACKGROUND_GRADIENT\"));\n            }\n            else\n            {\n                bgStartColor = null;\n                bgEndColor = null;\n            }\n\n            isImageBgEnabled =\n                new Boolean(resources.getSettingsString(\n                    \"impl.gui.IS_WINDOW_IMAGE_BACKGROUND_ENABLED\"))\n                    .booleanValue();\n\n            if (isImageBgEnabled)\n            {\n                final URL bgImagePath\n                    = resources.getImageURL(\"service.gui.WINDOW_TITLE_BAR_BG\");\n\n                bgImage = ImageUtils.getBufferedImage(bgImagePath);\n\n                final Rectangle rect =\n                    new Rectangle(0, 0, bgImage.getWidth(),\n                                    bgImage.getHeight());\n\n                texture = new TexturePaint(bgImage, rect);\n            }\n        }","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Overwrites the dispose method in order to save the size and the position\n     * of this window before closing it.\n     */\n    public void dispose()\n    {\n        this.saveSizeAndLocation();\n\n        /*\n         * The keybinding service will outlive us so don't let us retain our\n         * memory.\n         */\n        if (bindings != null)\n            bindings.deleteObserver(this);\n\n        super.dispose();\n    }","id":49399,"modified_method":"/**\n     * Overwrites the dispose method in order to save the size and the position\n     * of this window before closing it.\n     */\n    public void dispose()\n    {\n        if (isSaveSizeAndLocation)\n            this.saveSizeAndLocation();\n\n        /*\n         * The keybinding service will outlive us so don't let us retain our\n         * memory.\n         */\n        if (bindings != null)\n            bindings.deleteObserver(this);\n\n        super.dispose();\n    }","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void paintComponent(Graphics g)\n        {\n            super.paintComponent(g);\n\n            // If the custom color or image window background is not enabled we\n            // have nothing to do here.\n            if (isColorBgEnabled || isImageBgEnabled)\n            {\n                g = g.create();\n                try\n                {\n                    internalPaintComponent(g);\n                }\n                finally\n                {\n                    g.dispose();\n                }\n            }\n        }","id":49400,"modified_method":"/**\n         * Paints this content pane.\n         * @param g the <tt>Graphics<\/tt> object used for painting\n         */\n        public void paintComponent(Graphics g)\n        {\n            super.paintComponent(g);\n\n            // If the custom color or image window background is not enabled we\n            // have nothing to do here.\n            if (isColorBgEnabled || isImageBgEnabled)\n            {\n                g = g.create();\n                try\n                {\n                    internalPaintComponent(g);\n                }\n                finally\n                {\n                    g.dispose();\n                }\n            }\n        }","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * All functions implemented in this method will be invoked when user\n     * presses the Escape key.\n     */\n    protected abstract void close(boolean isEscaped);","id":49401,"modified_method":"/**\n     * All functions implemented in this method will be invoked when user\n     * presses the Escape key.\n     * @param isEscaped indicates if this frame has been closed by pressing the\n     * Esc key\n     */\n    protected abstract void close(boolean isEscaped);","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void actionPerformed(ActionEvent e)\n        {\n            saveSizeAndLocation();\n            close(true);\n        }","id":49402,"modified_method":"public void actionPerformed(ActionEvent e)\n        {\n            if (isSaveSizeAndLocation)\n                saveSizeAndLocation();\n            close(true);\n        }","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Listens for changes in binding sets so they can be reflected in the input\n     * map\n     */\n    public void update(Observable obs, Object arg)\n    {\n        if (obs instanceof KeybindingSet)\n        {\n            KeybindingSet changedBindings = (KeybindingSet) obs;\n\n            resetInputMap();\n            for (Map.Entry<KeyStroke, String> key2action : changedBindings\n                .getBindings().entrySet())\n            {\n                imap.put(key2action.getKey(), key2action.getValue());\n            }\n        }\n    }","id":49403,"modified_method":"/**\n     * Listens for changes in binding sets so they can be reflected in the input\n     * map.\n     * @param obs the <tt>KeybindingSet<\/tt> from which to update\n     */\n    public void update(Observable obs, Object arg)\n    {\n        if (obs instanceof KeybindingSet)\n        {\n            KeybindingSet changedBindings = (KeybindingSet) obs;\n\n            resetInputMap();\n            for (Map.Entry<KeyStroke, String> key2action : changedBindings\n                .getBindings().entrySet())\n            {\n                imap.put(key2action.getKey(), key2action.getValue());\n            }\n        }\n    }","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Overwrites the setVisible method in order to set the size and the\n     * position of this window before showing it.\n     */\n    public void setVisible(boolean isVisible)\n    {\n        if (isVisible)\n        {\n            this.setSizeAndLocation();\n\n            this.ensureOnScreenLocationAndSize();\n        }\n\n        super.setVisible(isVisible);\n    }","id":49404,"modified_method":"/**\n     * Overwrites the setVisible method in order to set the size and the\n     * position of this window before showing it.\n     * @param isVisible indicates if this frame should be visible\n     */\n    public void setVisible(boolean isVisible)\n    {\n        if (isVisible)\n        {\n            this.setSizeAndLocation();\n\n            this.ensureOnScreenLocationAndSize();\n        }\n\n        super.setVisible(isVisible);\n    }","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Invoked when this window is in the process of being closed. The close\n     * operation can be overridden at this point.\n     * \n     * @param e\n     */\n    protected void windowClosing(WindowEvent e)\n    {\n        /*\n         * Before closing the application window save the current size and\n         * position through the ConfigurationService.\n         */\n        saveSizeAndLocation();\n\n        close(false);\n    }","id":49405,"modified_method":"/**\n     * Invoked when this window is in the process of being closed. The close\n     * operation can be overridden at this point.\n     * @param e the <tt>WindowEvent<\/tt> that notified us\n     */\n    protected void windowClosing(WindowEvent e)\n    {\n        /*\n         * Before closing the application window save the current size and\n         * position through the ConfigurationService.\n         */\n        if(isSaveSizeAndLocation)\n            saveSizeAndLocation();\n\n        close(false);\n    }","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"private void internalPaintComponent(Graphics g)\n        {\n            AntialiasingManager.activateAntialiasing(g);\n\n            Graphics2D g2 = (Graphics2D) g;\n            int width = getWidth();\n            int height = getHeight();\n\n            if (isColorBgEnabled)\n            {\n                GradientPaint bgGradientColor =\n                    new GradientPaint(width / 2, 0, bgStartColor, width / 2, 80,\n                        bgEndColor);\n\n                g2.setPaint(bgGradientColor);\n                g2.fillRect(0, 0, width, 80);\n\n                g2.setColor(bgEndColor);\n                g2.fillRect(0, 78, width, height);\n            }\n\n            if (isImageBgEnabled)\n            {\n                if (bgImage != null && texture != null)\n                {\n                    g2.setPaint(texture);\n\n                    g2.fillRect(0, 0, this.getWidth(), bgImage.getHeight());\n                }\n            }\n        }","id":49406,"modified_method":"/**\n         * Provides a custom paint if the color or image background properties\n         * are enabled.\n         * @param g the <tt>Graphics<\/tt> object used for painting\n         */\n        private void internalPaintComponent(Graphics g)\n        {\n            AntialiasingManager.activateAntialiasing(g);\n\n            Graphics2D g2 = (Graphics2D) g;\n            int width = getWidth();\n            int height = getHeight();\n\n            if (isColorBgEnabled)\n            {\n                GradientPaint bgGradientColor =\n                    new GradientPaint(width / 2, 0, bgStartColor, width / 2, 80,\n                        bgEndColor);\n\n                g2.setPaint(bgGradientColor);\n                g2.fillRect(0, 0, width, 80);\n\n                g2.setColor(bgEndColor);\n                g2.fillRect(0, 78, width, height);\n            }\n\n            if (isImageBgEnabled)\n            {\n                if (bgImage != null && texture != null)\n                {\n                    g2.setPaint(texture);\n\n                    g2.fillRect(0, 0, this.getWidth(), bgImage.getHeight());\n                }\n            }\n        }","commit_id":"dd91828b7d7b6ff46089a6d98c0ee687e2f31ebd","url":"https://github.com/jitsi/jitsi"},{"original_method":"public AnnotationColumn(LeftEditorHighlighter leftEditorHighlighter, SNode root, FileAnnotation fileAnnotation, AbstractVcs vcs, VirtualFile modelVirtualFile) {\n    super(leftEditorHighlighter);\n    Set<SNodeId> descendantIds = SetSequence.fromSetWithValues(new HashSet<SNodeId>(), ListSequence.fromList(SNodeOperations.getDescendants(root, null, true, new String[]{})).<SNodeId>select(new ISelector<SNode, SNodeId>() {\n      public SNodeId select(SNode n) {\n        return n.getSNodeId();\n      }\n    }));\n    final SModel model = SNodeOperations.getModel(root);\n    myFileAnnotation = fileAnnotation;\n    for (VcsFileRevision rev : ListSequence.fromList(fileAnnotation.getRevisions())) {\n      MapSequence.fromMap(myRevisionNumberToRevision).put(rev.getRevisionNumber(), rev);\n    }\n    myFileLineToContent = ModelPersistence.getLineToContentMap(myFileAnnotation.getAnnotatedContent());\n    if (myFileLineToContent == null) {\n      return;\n    }\n    myFileAnnotation.addListener(myAnnotationListener);\n    myAuthorAnnotationAspect = Sequence.fromIterable(Sequence.fromArray(myFileAnnotation.getAspects())).findFirst(new IWhereFilter<LineAnnotationAspect>() {\n      public boolean accept(LineAnnotationAspect a) {\n        return LineAnnotationAspect.AUTHOR.equals(a.getId());\n      }\n    });\n    Map<SNodeId, Integer> nodeIdToFileLine = MapSequence.fromMap(new HashMap<SNodeId, Integer>());\n    for (int line = 0; line < ListSequence.fromList(myFileLineToContent).count(); line++) {\n      SNode node = null;\n      SNodeId id = check_5mnya_a0b0k0a(ListSequence.fromList(myFileLineToContent).getElement(line));\n      if (id != null && SetSequence.fromSet(descendantIds).contains(id)) {\n        node = model.getNodeById(id);\n      }\n      if (node == null) {\n        continue;\n      }\n      if (MapSequence.fromMap(nodeIdToFileLine).containsKey(id)) {\n        MapSequence.fromMap(nodeIdToFileLine).put(id, getFileLineWithMaxRevision(MapSequence.fromMap(nodeIdToFileLine).get(id), line));\n      } else {\n        MapSequence.fromMap(nodeIdToFileLine).put(id, line);\n      }\n    }\n    for (LineAnnotationAspect aspect : Sequence.fromIterable(Sequence.fromArray(fileAnnotation.getAspects()))) {\n      ListSequence.fromList(myAspectSubcolumns).addElement(new AnnotationAspectSubcolumn(this, aspect));\n    }\n    ListSequence.fromList(myAspectSubcolumns).addElement(new CommitNumberSubcolumn(this, myFileAnnotation));\n    for (VcsFileRevision revision : ListSequence.fromList(myFileAnnotation.getRevisions())) {\n      String author = revision.getAuthor();\n      if (!(MapSequence.fromMap(myAuthorsToColors).containsKey(author))) {\n        MapSequence.fromMap(myAuthorsToColors).put(author, AnnotationColors.BG_COLORS[MapSequence.fromMap(myAuthorsToColors).count() % AnnotationColors.BG_COLORS.length]);\n      }\n    }\n    myViewActionGroup = new ViewActionGroup(this, myAspectSubcolumns);\n    myRevisionRange = new VcsRevisionRange(this, myFileAnnotation);\n    ListSequence.fromList(myAspectSubcolumns).addElement(new HighlightRevisionSubcolumn(this, myRevisionRange));\n    myLeftEditorHighlighter = leftEditorHighlighter;\n    myModelVirtualFile = modelVirtualFile;\n    myModelDescriptor = model.getModelDescriptor();\n    myVcs = vcs;\n    final ChangesManager changesManager = ChangesManager.getInstance(getProject());\n    changesManager.getCommandQueue().runTask(new Runnable() {\n      public void run() {\n        ModelChangesManager modelChangesManager = changesManager.getModelChangesManager(model);\n        ListSequence.fromList(modelChangesManager.getChangeList()).visitAll(new IVisitor<Change>() {\n          public void visit(Change ch) {\n            saveChange(ch);\n          }\n        });\n        modelChangesManager.addChangeListener(myChangeListener);\n      }\n    });\n  }","id":49407,"modified_method":"public AnnotationColumn(LeftEditorHighlighter leftEditorHighlighter, SNode root, FileAnnotation fileAnnotation, AbstractVcs vcs, VirtualFile modelVirtualFile) {\n    super(leftEditorHighlighter);\n    Set<SNodeId> descendantIds = SetSequence.fromSetWithValues(new HashSet<SNodeId>(), ListSequence.fromList(SNodeOperations.getDescendants(root, null, true, new String[]{})).<SNodeId>select(new ISelector<SNode, SNodeId>() {\n      public SNodeId select(SNode n) {\n        return n.getSNodeId();\n      }\n    }));\n    final SModel model = SNodeOperations.getModel(root);\n    myFileAnnotation = fileAnnotation;\n    for (VcsFileRevision rev : ListSequence.fromList(fileAnnotation.getRevisions())) {\n      MapSequence.fromMap(myRevisionNumberToRevision).put(rev.getRevisionNumber(), rev);\n    }\n    myFileLineToContent = ModelPersistence.getLineToContentMap(myFileAnnotation.getAnnotatedContent());\n    if (myFileLineToContent == null) {\n      return;\n    }\n    myFileAnnotation.addListener(myAnnotationListener);\n    myAuthorAnnotationAspect = Sequence.fromIterable(Sequence.fromArray(myFileAnnotation.getAspects())).findFirst(new IWhereFilter<LineAnnotationAspect>() {\n      public boolean accept(LineAnnotationAspect a) {\n        return LineAnnotationAspect.AUTHOR.equals(a.getId());\n      }\n    });\n    Map<SNodeId, Integer> nodeIdToFileLine = MapSequence.fromMap(new HashMap<SNodeId, Integer>());\n    for (int line = 0; line < ListSequence.fromList(myFileLineToContent).count(); line++) {\n      SNode node = null;\n      SNodeId id = check_5mnya_a0b0k0a(ListSequence.fromList(myFileLineToContent).getElement(line));\n      if (id != null && SetSequence.fromSet(descendantIds).contains(id)) {\n        node = model.getNodeById(id);\n      }\n      if (node == null) {\n        continue;\n      }\n      if (MapSequence.fromMap(nodeIdToFileLine).containsKey(id)) {\n        MapSequence.fromMap(nodeIdToFileLine).put(id, getFileLineWithMaxRevision(MapSequence.fromMap(nodeIdToFileLine).get(id), line));\n      } else {\n        MapSequence.fromMap(nodeIdToFileLine).put(id, line);\n      }\n    }\n    ListSequence.fromList(myAspectSubcolumns).addSequence(Sequence.fromIterable(Sequence.fromArray(fileAnnotation.getAspects())).<AnnotationAspectSubcolumn>select(new ISelector<LineAnnotationAspect, AnnotationAspectSubcolumn>() {\n      public AnnotationAspectSubcolumn select(LineAnnotationAspect a) {\n        return new AnnotationAspectSubcolumn(AnnotationColumn.this, a);\n      }\n    }));\n    ListSequence.fromList(myAspectSubcolumns).addElement(new CommitNumberSubcolumn(this, myFileAnnotation));\n    for (VcsFileRevision revision : ListSequence.fromList(myFileAnnotation.getRevisions())) {\n      String author = revision.getAuthor();\n      if (!(MapSequence.fromMap(myAuthorsToColors).containsKey(author))) {\n        MapSequence.fromMap(myAuthorsToColors).put(author, AnnotationColors.BG_COLORS[MapSequence.fromMap(myAuthorsToColors).count() % AnnotationColors.BG_COLORS.length]);\n      }\n    }\n    myViewActionGroup = new ViewActionGroup(this, myAspectSubcolumns);\n    myRevisionRange = new VcsRevisionRange(this, myFileAnnotation);\n    ListSequence.fromList(myAspectSubcolumns).addElement(new HighlightRevisionSubcolumn(this, myRevisionRange));\n    myLeftEditorHighlighter = leftEditorHighlighter;\n    myModelVirtualFile = modelVirtualFile;\n    myModelDescriptor = model.getModelDescriptor();\n    myVcs = vcs;\n    final ChangesManager changesManager = ChangesManager.getInstance(getProject());\n    changesManager.getCommandQueue().runTask(new Runnable() {\n      public void run() {\n        ModelChangesManager modelChangesManager = changesManager.getModelChangesManager(model);\n        ListSequence.fromList(modelChangesManager.getChangeList()).visitAll(new IVisitor<Change>() {\n          public void visit(Change ch) {\n            saveChange(ch);\n          }\n        });\n        modelChangesManager.addChangeListener(myChangeListener);\n      }\n    });\n  }","commit_id":"c7accdd36cb1fa0107d6b975d0f9d2c7b5b779f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Set<String> getClasspath(boolean withSvnkit) {\n    Set<String> classpathItems = SetSequence.fromSet(new LinkedHashSet<String>());\n    SetSequence.fromSet(classpathItems).addElement(PathUtil.getJarPathForClass(MergeDriverMain.class));\n    SetSequence.fromSet(classpathItems).addElement(PathUtil.getJarPathForClass(ListSequence.class));\n    SetSequence.fromSet(classpathItems).addElement(PathUtil.getJarPathForClass(_FunctionTypes.class));\n    SetSequence.fromSet(classpathItems).addElement(PathUtil.getJarPathForClass(StringUtils.class));\n    SetSequence.fromSet(classpathItems).addElement(PathUtil.getJarPathForClass(FileUtil.class));\n    if (withSvnkit) {\n      SetSequence.fromSet(classpathItems).addElement(getSvnkitJar());\n    }\n    return classpathItems;\n  }","id":49408,"modified_method":"public static Set<String> getClasspath(boolean withSvnkit) {\n    Set<String> classpathItems = SetSequence.fromSet(new LinkedHashSet<String>());\n    final Iterable<String> OTHER_CLASSES = Arrays.asList(\"com.intellij.ide.projectView.impl.ProjectViewImpl\", \"jetbrains.mps.internal.collections.runtime.ListSequence\", \"jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes\", \"org.apache.commons.logging.Log\", \"org.apache.log4j.Logger\", \"com.intellij.util.containers.ConcurrentHashSet\", \"gnu.trove.THash\", \"org.jdom.JDOMException\", \"com.intellij.openapi.components.ApplicationComponent\", \"com.intellij.idea.IdeaTestApplication\", \"org.picocontainer.Disposable\", \"com.intellij.openapi.extensions.Extensions\", \"com.intellij.ide.ClassloaderUtil\", \"jetbrains.mps.generator.TransientModelsComponent\", \"org.apache.xmlrpc.XmlRpcServer\", \"jetbrains.mps.typesystem.inference.TypeChecker\", \"jetbrains.mps.debug.customViewers.CustomViewersManager\", \"jetbrains.mps.debug.api.breakpoints.BreakpointProvidersManager\", \"jetbrains.mps.editor.runtime.impl.LanguagesKeymapManager\", \"jetbrains.mps.intentions.IntentionsManager\", \"jetbrains.mps.ide.findusages.FindersManager\", \"jetbrains.mps.baseLanguage.index.ClassifierSuccessorsIndexer\", \"jetbrains.mps.execution.impl.configurations.runners.MPSProgramRunner\", \"com.google.common.collect.ImmutableList\", \"jetbrains.mps.analyzers.runtime.framework.CustomAnalyzerRunner\", \"jetbrains.mps.plugins.applicationplugins.BaseApplicationPlugin\", \"jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple\");\n    Iterable<Class> classes = Arrays.<Class>asList(MergeDriverMain.class, FileUtil.class, MergeContext.class, SModel.class, StringUtils.class, IdeMain.class);\n    classes = Sequence.fromIterable(OTHER_CLASSES).<Class>select(new ISelector<String, Class>() {\n      public Class select(String cn) {\n        try {\n          return (Class) Class.forName(cn);\n        } catch (ClassNotFoundException e) {\n          if (log.isErrorEnabled()) {\n            log.error(\"\", e);\n          }\n          return null;\n        }\n      }\n    }).concat(Sequence.fromIterable(classes));\n    SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(classes).<String>select(new ISelector<Class, String>() {\n      public String select(Class c) {\n        return PathUtil.getJarPathForClass(c);\n      }\n    }));\n    SetSequence.fromSet(classpathItems).addElement(PathManager.getHomePath() + File.separator + \"lib\" + File.separator + \"resources.jar\");\n    SetSequence.fromSet(classpathItems).addElement(PathManager.getHomePath() + File.separator + \"lib\" + File.separator + \"resources_en.jar\");\n    SetSequence.fromSet(classpathItems).addElement(PathManager.getHomePath() + File.separator + \"lib\" + File.separator + \"icons.jar\");\n    if (withSvnkit) {\n      SetSequence.fromSet(classpathItems).addElement(getSvnkitJar());\n    }\n    return classpathItems;\n  }","commit_id":"ec7e676ae69a9233c16ecb7a308dbd6377688f9b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static FileMerger selectMerger(File file) {\n    FileType fileType = FileType.get(file);\n    if (FileType.MODEL == fileType) {\n      return new SimpleMerger();\n    } else if (FileType.TRACE_CACHE == fileType || FileType.GENERATOR_DEPENDENCIES == fileType) {\n      return new EmptyMerger();\n    } else {\n      return new TextMerger();\n    }\n  }","id":49409,"modified_method":"private static FileMerger selectMerger(File file) {\n    FileType fileType = FileType.get(file);\n    if (FileType.MODEL == fileType) {\n      return new ModelMerger();\n    } else if (FileType.TRACE_CACHE == fileType || FileType.GENERATOR_DEPENDENCIES == fileType) {\n      return new EmptyMerger();\n    } else {\n      return new TextMerger();\n    }\n  }","commit_id":"ec7e676ae69a9233c16ecb7a308dbd6377688f9b","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SimpleMerger() {\n  }","id":49410,"modified_method":"SimpleMerger() {\n  }","commit_id":"ec7e676ae69a9233c16ecb7a308dbd6377688f9b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_k2wvr2_a0a0a51a0(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","id":49411,"modified_method":"private static boolean eq_k2wvr2_a0a0a71a0(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","commit_id":"ec7e676ae69a9233c16ecb7a308dbd6377688f9b","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  protected AbstractInstaller.State install(boolean dryRun) {\n    if (CommandLineGenerator.getSvnkitJar() == null) {\n      return AbstractInstaller.State.INSTALLED;\n    }\n    if (!(myConfigFile.exists())) {\n      if (!(dryRun)) {\n        Messages.showErrorDialog(myProject, \"Could not find Subversion configuration file (~/.subversion/config).\", \"Subversion Config Not Found\");\n      }\n      return AbstractInstaller.State.NOT_INSTALLED;\n    }\n    if (!(myConfigFile.canWrite()) && myConfigDir.canWrite()) {\n      if (!(dryRun)) {\n        Messages.showErrorDialog(myProject, \"Can't write to Subversion config (~/.subversion).\", \"Can't Write\");\n      }\n      return AbstractInstaller.State.NOT_INSTALLED;\n    }\n\n    String configLine = String.format(\"diff3-cmd = %s\", getScriptFile());\n\n    List<String> lines = StringsIO.readLines(myConfigFile);\n    int lineToReplace = -1;\n    for (int i = 0; i < ListSequence.fromList(lines).count(); i++) {\n      String line = ListSequence.fromList(lines).getElement(i);\n      if (line.trim().startsWith(\"diff3-cmd\")) {\n        // Some diff3 is already present \n\n        Matcher matcher = Pattern.compile(\"^\\\\s*diff3-cmd\\\\s*=\\\\s*(.+)$\").matcher(line);\n        if (matcher.matches()) {\n          String cmd = matcher.group(1);\n\n          if (cmd.contains(\"mps-merger.\")) {\n            // already installed \n\n            if (dryRun && neq_k2wvr2_a0a2a2a3a1a8a0(line, configLine)) {\n              return AbstractInstaller.State.OUTDATED;\n            }\n            lineToReplace = i;\n            break;\n          } else {\n            // another is installed \n\n            if (!(dryRun)) {\n              if (Messages.showYesNoDialog(myProject, String.format(\"You already have custom diff3-cmd in your Subversion config (%s).\\nIt will be overriden by MPS custom diff3. Continue?\", cmd), \"diff3-cmd is already present\", Messages.getQuestionIcon()) != 0) {\n                return AbstractInstaller.State.NOT_INSTALLED;\n              }\n            }\n            lineToReplace = i;\n            break;\n          }\n        }\n      }\n    }\n\n    if (lineToReplace == -1) {\n      String commented = ListSequence.fromList(lines).findFirst(new IWhereFilter<String>() {\n        public boolean accept(String line) {\n          return line.trim().startsWith(\"# diff3-cmd\");\n        }\n      });\n      if (commented != null) {\n        lineToReplace = ListSequence.fromList(lines).indexOf(commented);\n      } else {\n        int helpersStart = ListSequence.fromList(lines).indexOf(ListSequence.fromList(lines).findFirst(new IWhereFilter<String>() {\n          public boolean accept(String line) {\n            return line.trim().equals(\"[helpers]\");\n          }\n        }));\n        if (helpersStart != -1) {\n          // [helpers] section is present, finding next section start \n          int nextStart = ListSequence.fromList(lines).indexOf(ListSequence.fromList(lines).skip(helpersStart + 1).findFirst(new IWhereFilter<String>() {\n            public boolean accept(String line) {\n              return line.trim().startsWith(\"[\");\n            }\n          }));\n          if (nextStart == -1) {\n            // [helpers] is the last section \n            ListSequence.fromList(lines).addElement(\"\");\n            lineToReplace = ListSequence.fromList(lines).count() - 1;\n          } else {\n            Iterable<String> section = ListSequence.fromList(lines).page(helpersStart + 1, nextStart);\n            // Finding last non-comment line \n            int nonComment = Sequence.fromIterable(section).indexOf(Sequence.fromIterable(section).findLast(new IWhereFilter<String>() {\n              public boolean accept(String line) {\n                return !(line.trim().startsWith(\"#\")) && !(line.trim().isEmpty());\n              }\n            }));\n            if (nonComment == -1) {\n              lineToReplace = helpersStart + 1;\n            } else {\n              lineToReplace = nonComment + helpersStart + 1;\n            }\n            ListSequence.fromList(lines).insertElement(lineToReplace, \"\");\n          }\n        }\n      }\n    }\n\n    AbstractInstaller.State createScriptResult = createScript(dryRun);\n    if (createScriptResult != AbstractInstaller.State.INSTALLED) {\n      return createScriptResult;\n    }\n\n    if (dryRun) {\n      if (lineToReplace != -1 && eq_k2wvr2_a0a0a51a0(ListSequence.fromList(lines).getElement(lineToReplace), configLine)) {\n        return AbstractInstaller.State.INSTALLED;\n      } else {\n        return AbstractInstaller.State.NOT_INSTALLED;\n      }\n    }\n\n    if (lineToReplace == -1) {\n      ListSequence.fromList(lines).addElement(\"[helpers]\");\n      ListSequence.fromList(lines).addElement(configLine);\n    } else {\n      ListSequence.fromList(lines).setElement(lineToReplace, configLine);\n    }\n\n    try {\n      StringsIO.writeLines(myConfigFile, lines);\n      Messages.showInfoMessage(myProject, \"Successfully installed MPS merger for Subversion\", \"Subversion Merger Installed\");\n      return AbstractInstaller.State.INSTALLED;\n    } catch (IOException e) {\n      Messages.showErrorDialog(myProject, \"Could not update Subversion configuration file (~/.subversion/config).\" + e.getMessage(), \"Could Not Save Config\");\n      return AbstractInstaller.State.NOT_INSTALLED;\n    }\n  }","id":49412,"modified_method":"@NotNull\n  protected AbstractInstaller.State install(boolean dryRun) {\n    if (CommandLineGenerator.getSvnkitJar() == null) {\n      return AbstractInstaller.State.INSTALLED;\n    }\n    if (InternalFlag.isInternalMode()) {\n      if (dryRun) {\n        if (InternalRuntimePacker.getFile().exists()) {\n          return AbstractInstaller.State.OUTDATED;\n        } else {\n          return AbstractInstaller.State.NOT_INSTALLED;\n        }\n      } else {\n        InternalRuntimePacker.pack();\n      }\n    }\n\n    if (!(myConfigFile.exists())) {\n      if (!(dryRun)) {\n        Messages.showErrorDialog(myProject, \"Could not find Subversion configuration file (~/.subversion/config).\", \"Subversion Config Not Found\");\n      }\n      return AbstractInstaller.State.NOT_INSTALLED;\n    }\n    if (!(myConfigFile.canWrite()) && myConfigDir.canWrite()) {\n      if (!(dryRun)) {\n        Messages.showErrorDialog(myProject, \"Can't write to Subversion config (~/.subversion).\", \"Can't Write\");\n      }\n      return AbstractInstaller.State.NOT_INSTALLED;\n    }\n\n    String configLine = String.format(\"diff3-cmd = %s\", getScriptFile());\n\n    List<String> lines = StringsIO.readLines(myConfigFile);\n    int lineToReplace = -1;\n    for (int i = 0; i < ListSequence.fromList(lines).count(); i++) {\n      String line = ListSequence.fromList(lines).getElement(i);\n      if (line.trim().startsWith(\"diff3-cmd\")) {\n        // Some diff3 is already present \n\n        Matcher matcher = Pattern.compile(\"^\\\\s*diff3-cmd\\\\s*=\\\\s*(.+)$\").matcher(line);\n        if (matcher.matches()) {\n          String cmd = matcher.group(1);\n\n          if (cmd.contains(\"mps-merger.\")) {\n            // already installed \n\n            if (dryRun && neq_k2wvr2_a0a2a2a3a1a01a0(line, configLine)) {\n              return AbstractInstaller.State.OUTDATED;\n            }\n            lineToReplace = i;\n            break;\n          } else {\n            // another is installed \n\n            if (!(dryRun)) {\n              if (Messages.showYesNoDialog(myProject, String.format(\"You already have custom diff3-cmd in your Subversion config (%s).\\nIt will be overriden by MPS custom diff3. Continue?\", cmd), \"diff3-cmd is already present\", Messages.getQuestionIcon()) != 0) {\n                return AbstractInstaller.State.NOT_INSTALLED;\n              }\n            }\n            lineToReplace = i;\n            break;\n          }\n        }\n      }\n    }\n\n    if (lineToReplace == -1) {\n      String commented = ListSequence.fromList(lines).findFirst(new IWhereFilter<String>() {\n        public boolean accept(String line) {\n          return line.trim().startsWith(\"# diff3-cmd\");\n        }\n      });\n      if (commented != null) {\n        lineToReplace = ListSequence.fromList(lines).indexOf(commented);\n      } else {\n        int helpersStart = ListSequence.fromList(lines).indexOf(ListSequence.fromList(lines).findFirst(new IWhereFilter<String>() {\n          public boolean accept(String line) {\n            return line.trim().equals(\"[helpers]\");\n          }\n        }));\n        if (helpersStart != -1) {\n          // [helpers] section is present, finding next section start \n          int nextStart = ListSequence.fromList(lines).indexOf(ListSequence.fromList(lines).skip(helpersStart + 1).findFirst(new IWhereFilter<String>() {\n            public boolean accept(String line) {\n              return line.trim().startsWith(\"[\");\n            }\n          }));\n          if (nextStart == -1) {\n            // [helpers] is the last section \n            ListSequence.fromList(lines).addElement(\"\");\n            lineToReplace = ListSequence.fromList(lines).count() - 1;\n          } else {\n            Iterable<String> section = ListSequence.fromList(lines).page(helpersStart + 1, nextStart);\n            // Finding last non-comment line \n            int nonComment = Sequence.fromIterable(section).indexOf(Sequence.fromIterable(section).findLast(new IWhereFilter<String>() {\n              public boolean accept(String line) {\n                return !(line.trim().startsWith(\"#\")) && !(line.trim().isEmpty());\n              }\n            }));\n            if (nonComment == -1) {\n              lineToReplace = helpersStart + 1;\n            } else {\n              lineToReplace = nonComment + helpersStart + 1;\n            }\n            ListSequence.fromList(lines).insertElement(lineToReplace, \"\");\n          }\n        }\n      }\n    }\n\n    AbstractInstaller.State createScriptResult = createScript(dryRun);\n    if (createScriptResult != AbstractInstaller.State.INSTALLED) {\n      return createScriptResult;\n    }\n\n    if (dryRun) {\n      if (lineToReplace != -1 && eq_k2wvr2_a0a0a71a0(ListSequence.fromList(lines).getElement(lineToReplace), configLine)) {\n        return AbstractInstaller.State.INSTALLED;\n      } else {\n        return AbstractInstaller.State.NOT_INSTALLED;\n      }\n    }\n\n    if (lineToReplace == -1) {\n      ListSequence.fromList(lines).addElement(\"[helpers]\");\n      ListSequence.fromList(lines).addElement(configLine);\n    } else {\n      ListSequence.fromList(lines).setElement(lineToReplace, configLine);\n    }\n\n    try {\n      StringsIO.writeLines(myConfigFile, lines);\n      Messages.showInfoMessage(myProject, \"Successfully installed MPS merger for Subversion\", \"Subversion Merger Installed\");\n      return AbstractInstaller.State.INSTALLED;\n    } catch (IOException e) {\n      Messages.showErrorDialog(myProject, \"Could not update Subversion configuration file (~/.subversion/config).\" + e.getMessage(), \"Could Not Save Config\");\n      return AbstractInstaller.State.NOT_INSTALLED;\n    }\n  }","commit_id":"ec7e676ae69a9233c16ecb7a308dbd6377688f9b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean neq_k2wvr2_a0a2a2a3a1a8a0(Object a, Object b) {\n    return !((a != null ?\n      a.equals(b) :\n      a == b\n    ));\n  }","id":49413,"modified_method":"private static boolean neq_k2wvr2_a0a2a2a3a1a01a0(Object a, Object b) {\n    return !((a != null ?\n      a.equals(b) :\n      a == b\n    ));\n  }","commit_id":"ec7e676ae69a9233c16ecb7a308dbd6377688f9b","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static List<File> getAntClassPath(String antHome) throws ExecutionException {\n    String antlib = antHome + File.separator + \"lib\";\n    File antLibFile = new File(antlib);\n    if (!(antLibFile.exists())) {\n      throw new ExecutionException(\"Ant directory \" + antlib + \" does not exist.\");\n    }\n    List<File> classPath = ListSequence.fromList(new ArrayList<File>());\n    for (File jarFile : antLibFile.listFiles()) {\n      String jarFilePath = jarFile.getAbsolutePath();\n      if (jarFilePath.endsWith(\".jar\") && !(jarFilePath.endsWith(\"mps.jar\"))) {\n        ListSequence.fromList(classPath).addElement(jarFile);\n      }\n    }\n\n    ListSequence.fromList(classPath).addElement(new File(CommonPaths.getToolsJar()));\n\n    return classPath;\n  }","id":49414,"modified_method":"private static List<File> getAntClassPath(String antHome) throws ExecutionException {\n    String antlib = antHome + File.separator + \"lib\";\n    File antLibFile = new File(antlib);\n    if (!(antLibFile.exists())) {\n      throw new ExecutionException(\"Ant directory \" + antlib + \" does not exist.\");\n    }\n    List<File> classPath = ListSequence.fromList(new ArrayList<File>());\n    for (File jarFile : antLibFile.listFiles()) {\n      String jarFilePath = jarFile.getAbsolutePath();\n      if (jarFilePath.endsWith(\".jar\") && !(jarFilePath.endsWith(\"mps.jar\"))) {\n        ListSequence.fromList(classPath).addElement(jarFile);\n      }\n    }\n\n    List<String> mpsPaths = CommonPaths.getMPSPaths(ClassType.JDK_TOOLS);\n    ListSequence.fromList(classPath).addSequence(ListSequence.fromList(mpsPaths).select(new ISelector<String, File>() {\n      public File select(String it) {\n        return new File(it);\n      }\n    }));\n\n    return classPath;\n  }","commit_id":"19f11413318351bb3f12a9e092770a9a26d1613d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Set<String> getClasspath(boolean withSvnkit) {\n    Set<String> classpathItems = SetSequence.fromSet(new LinkedHashSet<String>());\n    final Iterable<String> OTHER_CLASSES = Arrays.asList(\"com.intellij.ide.projectView.impl.ProjectViewImpl\", \"jetbrains.mps.internal.collections.runtime.ListSequence\", \"jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes\", \"org.apache.commons.logging.Log\", \"org.apache.log4j.Logger\", \"com.intellij.util.containers.ConcurrentHashSet\", \"gnu.trove.THash\", \"org.jdom.JDOMException\", \"com.intellij.openapi.components.ApplicationComponent\", \"com.intellij.idea.IdeaTestApplication\", \"org.picocontainer.Disposable\", \"com.intellij.openapi.extensions.Extensions\", \"com.intellij.ide.ClassloaderUtil\", \"org.apache.xmlrpc.XmlRpcServer\", \"jetbrains.mps.typesystem.inference.TypeChecker\", \"jetbrains.mps.editor.runtime.impl.LanguagesKeymapManager\", \"jetbrains.mps.intentions.IntentionsManager\", \"jetbrains.mps.ide.findusages.FindersManager\", \"com.google.common.collect.ImmutableList\", \"jetbrains.mps.analyzers.runtime.framework.CustomAnalyzerRunner\", \"jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple\");\n    Iterable<Class> classes = Arrays.<Class>asList(MergeDriverMain.class, FileUtil.class, MergeSession.class, SModel.class, StringUtils.class, IdeMain.class);\n    classes = Sequence.fromIterable(OTHER_CLASSES).select(new ISelector<String, Class>() {\n      public Class select(String cn) {\n        try {\n          return (Class) Class.forName(cn);\n        } catch (ClassNotFoundException e) {\n          if (log.isErrorEnabled()) {\n            log.error(\"\", e);\n          }\n          return null;\n        }\n      }\n    }).concat(Sequence.fromIterable(classes));\n    SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(classes).select(new ISelector<Class, String>() {\n      public String select(Class c) {\n        return PathUtil.getJarPathForClass(c);\n      }\n    }));\n    SetSequence.fromSet(classpathItems).addElement(jetbrains.mps.util.PathManager.getHomePath() + File.separator + \"lib\" + File.separator + \"resources.jar\");\n    SetSequence.fromSet(classpathItems).addElement(jetbrains.mps.util.PathManager.getHomePath() + File.separator + \"lib\" + File.separator + \"resources_en.jar\");\n    SetSequence.fromSet(classpathItems).addElement(jetbrains.mps.util.PathManager.getHomePath() + File.separator + \"lib\" + File.separator + \"icons.jar\");\n    if (withSvnkit) {\n      SetSequence.fromSet(classpathItems).addElement(getSvnkitJar());\n    }\n    SetSequence.fromSet(classpathItems).addElement(getTextMergerJar());\n    return classpathItems;\n  }","id":49415,"modified_method":"public static Set<String> getClasspath(boolean withSvnkit) {\n    Set<String> classpathItems = SetSequence.fromSet(new LinkedHashSet<String>());\n    final Wrappers._T<String> mpsCorePath = new Wrappers._T<String>(PathManager.getLibPath());\n    File mpsCore = new File(mpsCorePath.value + File.separator + \"mps-core.jar\");\n    if (mpsCore.exists()) {\n      SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(libJars).select(new ISelector<String, String>() {\n        public String select(String it) {\n          return mpsCorePath.value + File.separator + it;\n        }\n      }));\n      SetSequence.fromSet(classpathItems).addElement(PathManager.getHomePath() + File.separator + \"plugins\" + File.separator + \"vcs\" + File.separator + \"lib\" + File.separator + \"mps-vcs-core.jar\");\n    } else {\n      mpsCorePath.value = PathManager.getPluginsPath() + File.separator + \"mps-core\" + File.separator + \"lib\";\n      mpsCore = new File(mpsCorePath.value + File.separator + \"mps-core.jar\");\n      if (mpsCore.exists()) {\n        SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(libJars).select(new ISelector<String, String>() {\n          public String select(String it) {\n            return mpsCorePath.value + File.separator + it;\n          }\n        }));\n        SetSequence.fromSet(classpathItems).addElement(PathManager.getPluginsPath() + File.separator + \"mps-vcs\" + File.separator + \"lib\" + File.separator + \"mps-vcs-core.jar\");\n      } else {\n        SetSequence.fromSet(classpathItems).addSequence(SetSequence.fromSet(getClasspathInternal()));\n      }\n    }\n    SetSequence.fromSet(classpathItems).addSequence(Sequence.fromIterable(ideaLibJars).select(new ISelector<String, String>() {\n      public String select(String it) {\n        return PathManager.getLibPath() + File.separator + it;\n      }\n    }));\n\n\n    if (withSvnkit) {\n      SetSequence.fromSet(classpathItems).addElement(getSvnkitJar());\n    }\n    SetSequence.fromSet(classpathItems).addElement(getTextMergerJar());\n    return classpathItems;\n  }","commit_id":"2337b79e457a0922d5527b0be8c66bc2e9aa1eeb","url":"https://github.com/JetBrains/MPS"},{"original_method":"/** {@inheritDoc} */\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Asset[] assets = null;\n\n        try {\n            assets = this.model.getAllAssets();\n        } catch (SQLException e) {\n            throw new ServletException(\"Database exception\", e);\n        }\n\n        response.setContentType(\"text/plain\");\n\n        CSVWriter out = new CSVWriter(response.getWriter());\n\n        String[] header = {\n                \"Node Label\",\n                \"Node ID\",\n                \"Category\",\n                \"Manufacturer\",\n                \"Vendor\",\n                \"Model Number\",\n                \"Serial Number\",\n                \"Description\",\n                \"Circuit ID\",\n                \"Asset Number\",\n                \"Operating System\",\n                \"Rack\",\n                \"Slot\",\n                \"Port\",\n                \"Region\",\n                \"Division\",\n                \"Department\",\n                \"Address 1\",\n                \"Address 2\",\n                \"City\",\n                \"State\",\n                \"Zip\",\n                \"Building\",\n                \"Floor\",\n                \"Room\",\n                \"Vendor Phone\",\n                \"Vendor Fax\",\n                \"Date Installed\",\n                \"Lease\",\n                \"Lease Expires\",\n                \"Support Phone\",\n                \"Maint Contract\",\n                \"Vendor Asset Number\",\n                \"Maint Contract Expires\",\n                \"Display Category\",\n                \"Notification Category\",\n                \"Poller Category\",\n                \"Threshold Category\",\n                \"Username\",\n                \"Password\",\n                \"Enable\",\n                \"Connection\",\n                \"Auto Enable\",\n                \"Comments\",\n\t\t\"Cpu\",\n\t\t\"Ram\",\n\t\t\"Storage Controller\",\n\t\t\"HDD 1\",\n\t\t\"HDD 2\",\n\t\t\"HDD 3\",\n\t\t\"HDD 4\",\n\t\t\"HDD 5\",\n\t\t\"HDD 6\",\n\t\t\"Number of power supplies\",\n\t\t\"Inputpower\",\n\t\t\"Additional hardware\",\n\t\t\"Admin\",\n\t\t\"SNMP Community\",\n\t\t\"Rack unit height\",\n                \"Country\",\n                \"Longitude\",\n                \"Latitude\"\n        };\n        \n        out.writeNext(header);\n\n        // print a single line for each asset\n        for (int i = 0; i < assets.length; i++) {\n            Asset asset = assets[i];\n            ArrayList<String> entries = new ArrayList<String>();\n\n            entries.add(NetworkElementFactory.getInstance(getServletContext()).getNodeLabel(asset.getNodeId()));\n            entries.add(Integer.toString(asset.getNodeId()));\n            entries.add(asset.getCategory());\n            entries.add(asset.getManufacturer());\n            entries.add(asset.getVendor());\n            entries.add(asset.getModelNumber());\n            entries.add(asset.getSerialNumber());\n            entries.add(asset.getDescription());\n            entries.add(asset.getCircuitId());\n            entries.add(asset.getAssetNumber());\n            entries.add(asset.getOperatingSystem());\n            entries.add(asset.getRack());\n            entries.add(asset.getSlot());\n            entries.add(asset.getPort());\n            entries.add(asset.getRegion());\n            entries.add(asset.getDivision());\n            entries.add(asset.getDepartment());\n            entries.add(asset.getAddress1());\n            entries.add(asset.getAddress2());\n            entries.add(asset.getCity());\n            entries.add(asset.getState());\n            entries.add(asset.getZip());\n            entries.add(asset.getBuilding());\n            entries.add(asset.getFloor());\n            entries.add(asset.getRoom());\n            entries.add(asset.getVendorPhone());\n            entries.add(asset.getVendorFax());\n            entries.add(asset.getDateInstalled());\n            entries.add(asset.getLease());\n            entries.add(asset.getLeaseExpires());\n            entries.add(asset.getSupportPhone());\n            entries.add(asset.getMaintContract());\n            entries.add(asset.getVendorAssetNumber());\n            entries.add(asset.getMaintContractExpires());\n            entries.add(asset.getDisplayCategory());\n            entries.add(asset.getNotifyCategory());\n            entries.add(asset.getPollerCategory());\n            entries.add(asset.getThresholdCategory());\n            entries.add(asset.getUsername());\n            entries.add(asset.getPassword());\n            entries.add(asset.getEnable());\n            entries.add(asset.getConnection());\n            entries.add(asset.getAutoenable());\n            entries.add(asset.getComments());\n            entries.add(asset.getCpu());\n            entries.add(asset.getRam());\n            entries.add(asset.getStoragectrl());\n            entries.add(asset.getHdd1());\n            entries.add(asset.getHdd2());\n            entries.add(asset.getHdd3());\n            entries.add(asset.getHdd4());\n            entries.add(asset.getHdd5());\n            entries.add(asset.getHdd6());\n            entries.add(asset.getNumpowersupplies());\n            entries.add(asset.getInputpower());\n            entries.add(asset.getAdditionalhardware());\n            entries.add(asset.getAdmin());\n            entries.add(asset.getSnmpcommunity());\n            entries.add(asset.getRackunitheight());\n            entries.add(asset.getLongitude());\n            entries.add(asset.getLatitude());\n            entries.add(asset.getCountry());\n            \n            out.writeNext(entries.toArray(new String[0]));\n        }\n\n        out.close();\n    }","id":49416,"modified_method":"/** {@inheritDoc} */\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Asset[] assets = null;\n\n        try {\n            assets = this.model.getAllAssets();\n        } catch (SQLException e) {\n            throw new ServletException(\"Database exception\", e);\n        }\n\n        response.setContentType(\"text/plain\");\n\n        CSVWriter out = new CSVWriter(response.getWriter());\n\n        String[] header = {\n                \"Node Label\",\n                \"Node ID\",\n                \"Category\",\n                \"Manufacturer\",\n                \"Vendor\",\n                \"Model Number\",\n                \"Serial Number\",\n                \"Description\",\n                \"Circuit ID\",\n                \"Asset Number\",\n                \"Operating System\",\n                \"Rack\",\n                \"Slot\",\n                \"Port\",\n                \"Region\",\n                \"Division\",\n                \"Department\",\n                \"Address 1\",\n                \"Address 2\",\n                \"City\",\n                \"State\",\n                \"Zip\",\n                \"Building\",\n                \"Floor\",\n                \"Room\",\n                \"Vendor Phone\",\n                \"Vendor Fax\",\n                \"Date Installed\",\n                \"Lease\",\n                \"Lease Expires\",\n                \"Support Phone\",\n                \"Maint Contract\",\n                \"Vendor Asset Number\",\n                \"Maint Contract Expires\",\n                \"Display Category\",\n                \"Notification Category\",\n                \"Poller Category\",\n                \"Threshold Category\",\n                \"Username\",\n                \"Password\",\n                \"Enable\",\n                \"Connection\",\n                \"Auto Enable\",\n                \"Comments\",\n\t\t\"Cpu\",\n\t\t\"Ram\",\n\t\t\"Storage Controller\",\n\t\t\"HDD 1\",\n\t\t\"HDD 2\",\n\t\t\"HDD 3\",\n\t\t\"HDD 4\",\n\t\t\"HDD 5\",\n\t\t\"HDD 6\",\n\t\t\"Number of power supplies\",\n\t\t\"Inputpower\",\n\t\t\"Additional hardware\",\n\t\t\"Admin\",\n\t\t\"SNMP Community\",\n\t\t\"Rack unit height\",\n                \"Country\",\n                \"Longitude\",\n                \"Latitude\"\n        };\n        \n        out.writeNext(header);\n\n        // print a single line for each asset\n        for (int i = 0; i < assets.length; i++) {\n            Asset asset = assets[i];\n            ArrayList<String> entries = new ArrayList<String>();\n\n            entries.add(NetworkElementFactory.getInstance(getServletContext()).getNodeLabel(asset.getNodeId()));\n            entries.add(Integer.toString(asset.getNodeId()));\n            entries.add(asset.getCategory());\n            entries.add(asset.getManufacturer());\n            entries.add(asset.getVendor());\n            entries.add(asset.getModelNumber());\n            entries.add(asset.getSerialNumber());\n            entries.add(asset.getDescription());\n            entries.add(asset.getCircuitId());\n            entries.add(asset.getAssetNumber());\n            entries.add(asset.getOperatingSystem());\n            entries.add(asset.getRack());\n            entries.add(asset.getSlot());\n            entries.add(asset.getPort());\n            entries.add(asset.getRegion());\n            entries.add(asset.getDivision());\n            entries.add(asset.getDepartment());\n            entries.add(asset.getAddress1());\n            entries.add(asset.getAddress2());\n            entries.add(asset.getCity());\n            entries.add(asset.getState());\n            entries.add(asset.getZip());\n            entries.add(asset.getBuilding());\n            entries.add(asset.getFloor());\n            entries.add(asset.getRoom());\n            entries.add(asset.getVendorPhone());\n            entries.add(asset.getVendorFax());\n            entries.add(asset.getDateInstalled());\n            entries.add(asset.getLease());\n            entries.add(asset.getLeaseExpires());\n            entries.add(asset.getSupportPhone());\n            entries.add(asset.getMaintContract());\n            entries.add(asset.getVendorAssetNumber());\n            entries.add(asset.getMaintContractExpires());\n            entries.add(asset.getDisplayCategory());\n            entries.add(asset.getNotifyCategory());\n            entries.add(asset.getPollerCategory());\n            entries.add(asset.getThresholdCategory());\n            entries.add(asset.getUsername());\n            entries.add(asset.getPassword());\n            entries.add(asset.getEnable());\n            entries.add(asset.getConnection());\n            entries.add(asset.getAutoenable());\n            entries.add(asset.getComments());\n            entries.add(asset.getCpu());\n            entries.add(asset.getRam());\n            entries.add(asset.getStoragectrl());\n            entries.add(asset.getHdd1());\n            entries.add(asset.getHdd2());\n            entries.add(asset.getHdd3());\n            entries.add(asset.getHdd4());\n            entries.add(asset.getHdd5());\n            entries.add(asset.getHdd6());\n            entries.add(asset.getNumpowersupplies());\n            entries.add(asset.getInputpower());\n            entries.add(asset.getAdditionalhardware());\n            entries.add(asset.getAdmin());\n            entries.add(asset.getSnmpcommunity());\n            entries.add(asset.getRackunitheight());\n            entries.add(asset.getCountry());\n            entries.add(asset.getLongitude());\n            entries.add(asset.getLatitude());\n            \n            out.writeNext(entries.toArray(new String[0]));\n        }\n\n        out.close();\n    }","commit_id":"538ca1e70edc6188caf765379229e92e7e747729","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>decodeAssetsText<\/p>\n     *\n     * @param text a {@link java.lang.String} object.\n     * @return a {@link java.util.List} object.\n     * @throws org.opennms.web.asset.ImportAssetsServlet$AssetException if any.\n     */\n    public List<Asset> decodeAssetsText(String text) throws AssetException {\n        CSVReader reader = new CSVReader(new StringReader(text));\n        String[] line;\n        List<Asset> list = new ArrayList<Asset>();\n        text = text.trim();\n        \n        int count = 0;\n\n        try {\n            while ((line = reader.readNext()) != null) {\n                count++;\n                try {\n                    logger.debug(\"asset line is:'{}'\", line);\n                    if (line.length != 62) {\n                        logger.error(\"csv test row length was not 58 line length: '{}' line was:'{}', line length\", line.length, line);\n                        throw new NoSuchElementException();\n                    }\n\n                    // skip the first line if it's the headers\n                    if (line[0].equals(\"Node Label\")) {\n                        logger.debug(\"line was header. line:'{}'\", line);\n                        continue;\n                    }\n                    \n                    Asset asset = new Asset();\n\n                    asset.setNodeId(WebSecurityUtils.safeParseInt(line[1]));\n                    asset.setCategory(Util.decode(line[2]));\n                    asset.setManufacturer(Util.decode(line[3]));\n                    asset.setVendor(Util.decode(line[4]));\n                    asset.setModelNumber(Util.decode(line[5]));\n                    asset.setSerialNumber(Util.decode(line[6]));\n                    asset.setDescription(Util.decode(line[7]));\n                    asset.setCircuitId(Util.decode(line[8]));\n                    asset.setAssetNumber(Util.decode(line[9]));\n                    asset.setOperatingSystem(Util.decode(line[10]));\n                    asset.setRack(Util.decode(line[11]));\n                    asset.setSlot(Util.decode(line[12]));\n                    asset.setPort(Util.decode(line[13]));\n                    asset.setRegion(Util.decode(line[14]));\n                    asset.setDivision(Util.decode(line[15]));\n                    asset.setDepartment(Util.decode(line[16]));\n                    asset.setAddress1(Util.decode(line[17]));\n                    asset.setAddress2(Util.decode(line[18]));\n                    asset.setCity(Util.decode(line[19]));\n                    asset.setState(Util.decode(line[20]));\n                    asset.setZip(Util.decode(line[21]));\n                    asset.setBuilding(Util.decode(line[22]));\n                    asset.setFloor(Util.decode(line[23]));\n                    asset.setRoom(Util.decode(line[24]));\n                    asset.setVendorPhone(Util.decode(line[25]));\n                    asset.setVendorFax(Util.decode(line[26]));\n                    asset.setDateInstalled(Util.decode(line[27]));\n                    asset.setLease(Util.decode(line[28]));\n                    asset.setLeaseExpires(Util.decode(line[29]));\n                    asset.setSupportPhone(Util.decode(line[30]));\n                    asset.setMaintContract(Util.decode(line[31]));\n                    asset.setVendorAssetNumber(Util.decode(line[32]));\n                    asset.setMaintContractExpires(Util.decode(line[33]));\n                    asset.setDisplayCategory(Util.decode(line[34]));\n                    asset.setNotifyCategory(Util.decode(line[35]));\n                    asset.setPollerCategory(Util.decode(line[36]));\n                    asset.setThresholdCategory(Util.decode(line[37]));\n                    asset.setUsername(Util.decode(line[38]));\n                    asset.setPassword(Util.decode(line[39]));\n                    asset.setEnable(Util.decode(line[40]));\n                    asset.setConnection(Util.decode(line[41]));\n                    asset.setAutoenable(Util.decode(line[42]));\n                    asset.setComments(Util.decode(line[43]));\n                    \n                    asset.setCpu(Util.decode(line[44]));\n                    asset.setRam(Util.decode(line[45]));                   \n                    asset.setStoragectrl(Util.decode(line[46]));\n                    \n                    asset.setHdd1(Util.decode(line[47]));\n                    asset.setHdd2(Util.decode(line[48]));\n                    asset.setHdd3(Util.decode(line[49]));\n                    asset.setHdd4(Util.decode(line[50]));\n                    asset.setHdd5(Util.decode(line[51]));\n                    asset.setHdd6(Util.decode(line[52]));\n\n                    asset.setNumpowersupplies(Util.decode(line[53]));\n                    asset.setInputpower(Util.decode(line[54]));\n\n                    asset.setAdditionalhardware(Util.decode(line[55]));\n                    asset.setAdmin(Util.decode(line[56]));\n                    asset.setSnmpcommunity(Util.decode(line[57]));\n                    asset.setRackunitheight(Util.decode(line[58]));\n                    asset.setLongitude(Util.decode(line[59]));\n                    asset.setLatitude(Util.decode(line[60]));\n                    asset.setCountry(Util.decode(line[61]));\n            \n                    list.add(asset);\n                    logger.debug(\"decoded asset:'{}'\", asset);\n\n                } catch (NoSuchElementException e) {\n                    errors.add(\"Ignoring malformed import for entry \" + count + \", not enough values.\");\n                } catch (NumberFormatException e) {\n                    logger.error(\"NodeId parsing to int faild, ignoreing malformed import for entry number '{}' exception message:'{}'\", count, e.getMessage());\n                    errors.add(\"Ignoring malformed import for entry \" + count + \", node id not a number.\");\n                }\n            }\n        } catch (IOException e) {\n            logger.error(\"An error occurred reading the CSV input. Message:'{}'\", e.getMessage());\n            throw new AssetException(\"An error occurred reading the CSV input.\", e);\n        }\n\n        if (list.size() == 0) {\n            logger.error(\"No asset information was found, list size was 0\");\n        \tthrow new AssetException(\"No asset information was found.\");\n        }\n\n        return list;\n    }","id":49417,"modified_method":"/**\n     * <p>decodeAssetsText<\/p>\n     *\n     * @param text a {@link java.lang.String} object.\n     * @return a {@link java.util.List} object.\n     * @throws org.opennms.web.asset.ImportAssetsServlet$AssetException if any.\n     */\n    public List<Asset> decodeAssetsText(String text) throws AssetException {\n        CSVReader csvReader = null;\n        StringReader stringReader = null;\n        String[] line;\n        List<Asset> list = new ArrayList<Asset>();\n        text = text.trim();\n        \n        int count = 0;\n\n        try {\n            stringReader = new StringReader(text);\n            csvReader = new CSVReader(stringReader);\n\n            while ((line = csvReader.readNext()) != null) {\n                count++;\n                try {\n                    logger.debug(\"asset line is:'{}'\", (Object)line);\n                    if (line.length <= 37) {\n                        logger.error(\"csv test row length was not at least 37 line length: '{}' line was:'{}', line length\", line.length, line);\n                        throw new NoSuchElementException();\n                    }\n\n                    // skip the first line if it's the headers\n                    if (line[0].equals(\"Node Label\")) {\n                        logger.debug(\"line was header. line:'{}'\", (Object)line);\n                        continue;\n                    }\n                    \n                    final Asset asset = new Asset();\n\n                    asset.setNodeId(WebSecurityUtils.safeParseInt(line[1]));\n                    asset.setCategory(Util.decode(line[2]));\n                    asset.setManufacturer(Util.decode(line[3]));\n                    asset.setVendor(Util.decode(line[4]));\n                    asset.setModelNumber(Util.decode(line[5]));\n                    asset.setSerialNumber(Util.decode(line[6]));\n                    asset.setDescription(Util.decode(line[7]));\n                    asset.setCircuitId(Util.decode(line[8]));\n                    asset.setAssetNumber(Util.decode(line[9]));\n                    asset.setOperatingSystem(Util.decode(line[10]));\n                    asset.setRack(Util.decode(line[11]));\n                    asset.setSlot(Util.decode(line[12]));\n                    asset.setPort(Util.decode(line[13]));\n                    asset.setRegion(Util.decode(line[14]));\n                    asset.setDivision(Util.decode(line[15]));\n                    asset.setDepartment(Util.decode(line[16]));\n                    asset.setAddress1(Util.decode(line[17]));\n                    asset.setAddress2(Util.decode(line[18]));\n                    asset.setCity(Util.decode(line[19]));\n                    asset.setState(Util.decode(line[20]));\n                    asset.setZip(Util.decode(line[21]));\n                    asset.setBuilding(Util.decode(line[22]));\n                    asset.setFloor(Util.decode(line[23]));\n                    asset.setRoom(Util.decode(line[24]));\n                    asset.setVendorPhone(Util.decode(line[25]));\n                    asset.setVendorFax(Util.decode(line[26]));\n                    asset.setDateInstalled(Util.decode(line[27]));\n                    asset.setLease(Util.decode(line[28]));\n                    asset.setLeaseExpires(Util.decode(line[29]));\n                    asset.setSupportPhone(Util.decode(line[30]));\n                    asset.setMaintContract(Util.decode(line[31]));\n                    asset.setVendorAssetNumber(Util.decode(line[32]));\n                    asset.setMaintContractExpires(Util.decode(line[33]));\n                    asset.setDisplayCategory(Util.decode(line[34]));\n                    asset.setNotifyCategory(Util.decode(line[35]));\n                    asset.setPollerCategory(Util.decode(line[36]));\n                    \n                    if (line.length > 37) {\n                        asset.setThresholdCategory(Util.decode(line[37]));\n                        asset.setUsername(Util.decode(line[38]));\n                        asset.setPassword(Util.decode(line[39]));\n                        asset.setEnable(Util.decode(line[40]));\n                        asset.setConnection(Util.decode(line[41]));\n                        asset.setAutoenable(Util.decode(line[42]));\n                        asset.setComments(Util.decode(line[43]));\n                    }\n\n                    if (line.length > 44) {\n                        asset.setCpu(Util.decode(line[44]));\n                        asset.setRam(Util.decode(line[45]));\n                        asset.setStoragectrl(Util.decode(line[46]));\n                        asset.setHdd1(Util.decode(line[47]));\n                        asset.setHdd2(Util.decode(line[48]));\n                        asset.setHdd3(Util.decode(line[49]));\n                        asset.setHdd4(Util.decode(line[50]));\n                        asset.setHdd5(Util.decode(line[51]));\n                        asset.setHdd6(Util.decode(line[52]));\n    \n                        asset.setNumpowersupplies(Util.decode(line[53]));\n                        asset.setInputpower(Util.decode(line[54]));\n    \n                        asset.setAdditionalhardware(Util.decode(line[55]));\n                        asset.setAdmin(Util.decode(line[56]));\n                        asset.setSnmpcommunity(Util.decode(line[57]));\n                        asset.setRackunitheight(Util.decode(line[58]));\n                    }\n\n                    if (line.length > 59) {\n                        asset.setCountry(Util.decode(line[59]));\n                        asset.setLongitude(Util.decode(line[60]));\n                        asset.setLatitude(Util.decode(line[61]));\n                    }\n\n                    list.add(asset);\n                    logger.debug(\"decoded asset:'{}'\", (Object)asset);\n\n                } catch (NoSuchElementException e) {\n                    errors.add(\"Ignoring malformed import for entry \" + count + \", not enough values.\");\n                } catch (NumberFormatException e) {\n                    logger.error(\"NodeId parsing to int faild, ignoreing malformed import for entry number '{}' exception message:'{}'\", count, e.getMessage());\n                    errors.add(\"Ignoring malformed import for entry \" + count + \", node id not a number.\");\n                }\n            }\n        } catch (IOException e) {\n            logger.error(\"An error occurred reading the CSV input. Message:'{}'\", e.getMessage());\n            throw new AssetException(\"An error occurred reading the CSV input.\", e);\n        } finally {\n            IOUtils.closeQuietly(stringReader);\n            IOUtils.closeQuietly(csvReader);\n        }\n\n        if (list.size() == 0) {\n            logger.error(\"No asset information was found, list size was 0\");\n        \tthrow new AssetException(\"No asset information was found.\");\n        }\n\n        return list;\n    }","commit_id":"538ca1e70edc6188caf765379229e92e7e747729","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@POST\n   @Path(\"/tokens\")\n   @Consumes(MediaType.APPLICATION_XML)\n   @Produces(MediaType.APPLICATION_XML)\n   public Response getToken(AuthenticationRequest authRequest, @Context UriInfo context) throws DatatypeConfigurationException {\n      KeystoneProvider p = getProvider();\n      ResponseWrapper wrapper = new JaxbElementWrapper();\n\n      Token token;\n      PasswordCredentialsRequiredUsername credentials;\n      if (authRequest.getCredential() != null) {\n         CredentialType credentialType = authRequest.getCredential().getValue();\n         credentials = (PasswordCredentialsRequiredUsername) credentialType;\n\n      } else {\n         credentials = new PasswordCredentialsRequiredUsername();\n         credentials.setUsername(authRequest.getTenantId());\n         credentials.setPassword(authRequest.getToken().getId());\n\n         if (!p.isValidToken(credentials.getPassword())) {\n\n            return Response.status(Response.Status.NOT_FOUND).entity(wrapper.wrapElement(p.createItemNotFound())).build();\n         }\n\n         String userName = p.getUsernameFromToken(credentials.getPassword());\n\n         if (!StringUtilities.nullSafeEqualsIgnoreCase(userName, credentials.getUsername())) {\n            return Response.status(Response.Status.NOT_FOUND).entity(wrapper.wrapElement(p.createItemNotFound())).build();\n         }\n\n\n      }\n      if (!validateCredentials(credentials)) {\n         return Response.status(Response.Status.UNAUTHORIZED).entity(wrapper.wrapElement(p.createUnauthorized(\"SecurityServiceFault: Unable to get customer auth by username\"))).build();\n      }\n      token = p.createToken(credentials);\n\n      AuthenticateResponse response = p.newAuthenticateResponse();\n      response.setToken(token);\n      response.setServiceCatalog(p.getServiceCatalog(credentials.getUsername()));\n      response.setUser(p.getUser(credentials.getUsername()));\n\n      return Response.ok(wrapper.wrapElement(response)).build();\n   }","id":49418,"modified_method":"@POST\n   @Path(\"/tokens\")\n   @Consumes(MediaType.APPLICATION_XML)\n   @Produces(MediaType.APPLICATION_XML)\n   public Response getToken(AuthenticationRequest authRequest, @Context UriInfo context) throws DatatypeConfigurationException {\n      KeystoneProvider p = getProvider();\n      ResponseWrapper wrapper = new JaxbElementWrapper();\n      Token token;\n      PasswordCredentialsRequiredUsername credentials;\n      if (authRequest.getCredential() != null) {\n\n         CredentialType credentialType = authRequest.getCredential().getValue();\n         credentials = (PasswordCredentialsRequiredUsername) credentialType;\n\n      } else {\n         credentials = new PasswordCredentialsRequiredUsername();\n         credentials.setUsername(authRequest.getTenantId());\n         credentials.setPassword(\"someKey\");\n\n      }\n      if (!validateCredentials(credentials)) {\n         return Response.status(Response.Status.UNAUTHORIZED).entity(wrapper.wrapElement(p.createUnauthorized(\"SecurityServiceFault: Unable to get customer auth by username\"))).build();\n      }\n      token = p.createToken(credentials);\n\n      AuthenticateResponse response = p.newAuthenticateResponse();\n      response.setToken(token);\n      response.setServiceCatalog(p.getServiceCatalog(credentials.getUsername()));\n      response.setUser(p.getUser(credentials.getUsername()));\n\n      return Response.ok(wrapper.wrapElement(response)).build();\n   }","commit_id":"ae4634629ea22a8f1f29133c18f907316b7573a9","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n   public FullAuthInfo validateToken(ExtractorResult<String> account, String token) {\n\n      FullAuthInfo accountInfo;\n\n      if (account != null) {\n         accountInfo = authenticationService.validateToken(account.getResult(), token);\n      } else {\n         accountInfo = authenticationService.validateToken(null, token);\n      }\n      if (accountInfo != null && accountInfo.getEndpoints() != null) {\n         try {\n            endpointListCache.cacheEndpointsForToken(token, accountInfo.getEndpoints());\n         } catch (IOException io) {\n            LOG.error(\"Caching Failure: \" + io.getMessage(), io);\n         }\n      }\n\n      return accountInfo;\n   }","id":49419,"modified_method":"@Override\n   public FullAuthInfo validateToken(ExtractorResult<String> account, String token) {\n\n      FullAuthInfo accountInfo;\n\n      if (account != null) {\n         accountInfo = authenticationService.validateToken(account.getResult(), token);\n      } else {\n         accountInfo = authenticationService.validateToken(null, token);\n      }\n      if (accountInfo.getEndpoints() != null) {\n         try {\n            endpointListCache.cacheEndpointsForToken(token, accountInfo.getEndpoints());\n         } catch (IOException io) {\n            LOG.error(\"Caching Failure: \" + io.getMessage(), io);\n         }\n      }\n\n      return accountInfo;\n   }","commit_id":"ae4634629ea22a8f1f29133c18f907316b7573a9","url":"https://github.com/rackerlabs/repose"},{"original_method":"/**\n     * Creates an account for the given user and password.\n     *\n     * @param providerFactory the ProtocolProviderFactory which will create\n     * the account\n     * @param userName the user identifier\n     * @param passwd the password\n     * @return the <tt>ProtocolProviderService<\/tt> for the new account.\n     * @throws OperationFailedException if the operation didn't succeed\n     */\n    protected ProtocolProviderService installAccount(\n        ProtocolProviderFactory providerFactory,\n        String userName,\n        String passwd)\n        throws OperationFailedException\n    {\n        if(logger.isTraceEnabled())\n        {\n            logger.trace(\"Preparing to install account for user \" + userName);\n        }\n        Hashtable<String, String> accountProperties\n            = new Hashtable<String, String>();\n\n        accountProperties.put(ProtocolProviderFactory.IS_PREFERRED_PROTOCOL,\n            Boolean.toString(isPreferredProtocol()));\n        accountProperties.put(ProtocolProviderFactory.PROTOCOL, getProtocol());\n\n        String protocolIconPath = getProtocolIconPath();\n\n        String accountIconPath = getAccountIconPath();\n\n        registration.storeProperties(\n                userName, passwd,\n                protocolIconPath, accountIconPath,\n                accountProperties);\n\n        if (isModification())\n        {\n            providerFactory.modifyAccount(  protocolProvider,\n                accountProperties);\n\n            setModification(false);\n\n            return protocolProvider;\n        }\n\n        try\n        {\n            if(logger.isTraceEnabled())\n            {\n                logger.trace(\"Will install account for user \" + userName\n                             + \" with the following properties.\"\n                             + accountProperties);\n            }\n\n            AccountID accountID = providerFactory.installAccount(\n                userName,\n                accountProperties);\n\n            ServiceReference serRef = providerFactory\n                .getProviderForAccount(accountID);\n\n            protocolProvider = (ProtocolProviderService)\n                JabberAccRegWizzActivator.bundleContext\n                .getService(serRef);\n        }\n        catch (IllegalArgumentException exc)\n        {\n            logger.warn(exc.getMessage());\n\n            throw new OperationFailedException(\n                \"Username, password or server is null.\",\n                OperationFailedException.ILLEGAL_ARGUMENT);\n        }\n        catch (IllegalStateException exc)\n        {\n            logger.warn(exc.getMessage());\n\n            throw new OperationFailedException(\n                \"Account already exists.\",\n                OperationFailedException.IDENTIFICATION_CONFLICT);\n        }\n        catch (Throwable exc)\n        {\n            logger.warn(exc.getMessage());\n\n            throw new OperationFailedException(\n                \"Failed to add account.\",\n                OperationFailedException.GENERAL_ERROR);\n        }\n\n        return protocolProvider;\n    }","id":49420,"modified_method":"/**\n     * Creates an account for the given user and password.\n     *\n     * @param providerFactory the ProtocolProviderFactory which will create\n     * the account\n     * @param userName the user identifier\n     * @param passwd the password\n     * @return the <tt>ProtocolProviderService<\/tt> for the new account.\n     * @throws OperationFailedException if the operation didn't succeed\n     */\n    protected ProtocolProviderService installAccount(\n        ProtocolProviderFactory providerFactory,\n        String userName,\n        String passwd)\n        throws OperationFailedException\n    {\n        if(logger.isTraceEnabled())\n        {\n            logger.trace(\"Preparing to install account for user \" + userName);\n        }\n        Hashtable<String, String> accountProperties\n            = new Hashtable<String, String>();\n\n        String protocolIconPath = getProtocolIconPath();\n\n        String accountIconPath = getAccountIconPath();\n\n        registration.storeProperties(\n                userName, passwd,\n                protocolIconPath, accountIconPath,\n                accountProperties);\n\n        accountProperties.put(ProtocolProviderFactory.IS_PREFERRED_PROTOCOL,\n                              Boolean.toString(isPreferredProtocol()));\n        accountProperties.put(ProtocolProviderFactory.PROTOCOL, getProtocol());\n\n        if (isModification())\n        {\n            providerFactory.modifyAccount(  protocolProvider,\n                accountProperties);\n\n            setModification(false);\n\n            return protocolProvider;\n        }\n\n        try\n        {\n            if(logger.isTraceEnabled())\n            {\n                logger.trace(\"Will install account for user \" + userName\n                             + \" with the following properties.\"\n                             + accountProperties);\n            }\n\n            AccountID accountID = providerFactory.installAccount(\n                userName,\n                accountProperties);\n\n            ServiceReference serRef = providerFactory\n                .getProviderForAccount(accountID);\n\n            protocolProvider = (ProtocolProviderService)\n                JabberAccRegWizzActivator.bundleContext\n                .getService(serRef);\n        }\n        catch (IllegalArgumentException exc)\n        {\n            logger.warn(exc.getMessage());\n\n            throw new OperationFailedException(\n                \"Username, password or server is null.\",\n                OperationFailedException.ILLEGAL_ARGUMENT);\n        }\n        catch (IllegalStateException exc)\n        {\n            logger.warn(exc.getMessage());\n\n            throw new OperationFailedException(\n                \"Account already exists.\",\n                OperationFailedException.IDENTIFICATION_CONFLICT);\n        }\n        catch (Throwable exc)\n        {\n            logger.warn(exc.getMessage());\n\n            throw new OperationFailedException(\n                \"Failed to add account.\",\n                OperationFailedException.GENERAL_ERROR);\n        }\n\n        return protocolProvider;\n    }","commit_id":"2271a34d1604880bfa4389e209a1464a92636854","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Installs the account defined in this wizard.\n     *\n     * @param userName the user name to sign in with\n     * @param password the password to sign in with\n     * @return the created <tt>ProtocolProviderService<\/tt> corresponding to the\n     * new account\n     * @throws OperationFailedException if the operation didn't succeed\n     */\n    @Override\n    public ProtocolProviderService signin(String userName, String password)\n        throws OperationFailedException\n    {\n        // if firstWizardPage is null we are requested sign-in from\n        // initial account registration form we must init\n        // firstWizardPage in order to init default values\n        if(firstWizardPage == null)\n        {\n            firstWizardPage = new FirstWizardPage(this);\n            AccountPanel accPanel =\n                    (AccountPanel)firstWizardPage.getSimpleForm();\n            accPanel.setUsername(userName);\n            accPanel.setPassword(password);\n            accPanel.setRememberPassword(true);\n        }\n\n        if(!firstWizardPage.isCommitted())\n            firstWizardPage.commitPage();\n\n        if(!firstWizardPage.isCommitted())\n            throw new OperationFailedException(\"Could not confirm data.\",\n                OperationFailedException.GENERAL_ERROR);\n\n        ProtocolProviderFactory factory\n            = JabberAccRegWizzActivator.getJabberProtocolProviderFactory();\n\n        return this.installAccount(\n            factory,\n            registration.getUserID(),  // The user id may get changed.Server\n                                       // part can be added in the data\n                                       // commit.\n            password);\n    }","id":49421,"modified_method":"/**\n     * Installs the account defined in this wizard.\n     *\n     * @param userName the user name to sign in with\n     * @param password the password to sign in with\n     * @return the created <tt>ProtocolProviderService<\/tt> corresponding to the\n     * new account\n     * @throws OperationFailedException if the operation didn't succeed\n     */\n    @Override\n    public ProtocolProviderService signin(String userName, String password)\n        throws OperationFailedException\n    {\n        // if firstWizardPage is null we are requested sign-in from\n        // initial account registration form we must init\n        // firstWizardPage in order to init default values\n        // Pawel: firstWizardPage is never null, and commitPage fails\n        // with no user ID provided for simple account wizard.\n        // Now userName and password are reentered here\n        AccountPanel accPanel =\n                    (AccountPanel)firstWizardPage.getSimpleForm();\n        accPanel.setUsername(userName);\n        accPanel.setPassword(password);\n        accPanel.setRememberPassword(password != null);\n\n        if(!firstWizardPage.isCommitted())\n            firstWizardPage.commitPage();\n\n        if(!firstWizardPage.isCommitted())\n            throw new OperationFailedException(\"Could not confirm data.\",\n                OperationFailedException.GENERAL_ERROR);\n\n        ProtocolProviderFactory factory\n            = JabberAccRegWizzActivator.getJabberProtocolProviderFactory();\n\n        return this.installAccount(\n            factory,\n            registration.getUserID(),  // The user id may get changed.Server\n                                       // part can be added in the data\n                                       // commit.\n            password);\n    }","commit_id":"2271a34d1604880bfa4389e209a1464a92636854","url":"https://github.com/jitsi/jitsi"},{"original_method":"@POST\n   @Path(\"/tokens\")\n   @Consumes(MediaType.APPLICATION_XML)\n   @Produces(MediaType.APPLICATION_XML)\n   public Response getToken(AuthenticationRequest authRequest, @Context UriInfo context) throws DatatypeConfigurationException {\n      KeystoneProvider p = getProvider();\n      ResponseWrapper wrapper = new JaxbElementWrapper();\n      Token token;\n      PasswordCredentialsRequiredUsername credentials;\n      if (authRequest.getCredential() != null) {\n\n         CredentialType credentialType = authRequest.getCredential().getValue();\n         credentials = (PasswordCredentialsRequiredUsername) credentialType;\n\n      } else {\n         credentials = new PasswordCredentialsRequiredUsername();\n         credentials.setUsername(authRequest.getTenantId());\n         credentials.setPassword(\"someKey\");\n\n      }\n      if (!validateCredentials(credentials)) {\n         return Response.status(Response.Status.UNAUTHORIZED).entity(wrapper.wrapElement(p.createUnauthorized(\"SecurityServiceFault: Unable to get customer auth by username\"))).build();\n      }\n      token = p.createToken(credentials);\n\n      AuthenticateResponse response = p.newAuthenticateResponse();\n      response.setToken(token);\n      response.setServiceCatalog(p.getServiceCatalog(credentials.getUsername()));\n      response.setUser(p.getUser(credentials.getUsername()));\n\n      return Response.ok(wrapper.wrapElement(response)).build();\n   }","id":49422,"modified_method":"@POST\n   @Path(\"/tokens\")\n   @Consumes(MediaType.APPLICATION_XML)\n   @Produces(MediaType.APPLICATION_XML)\n   public Response getToken(AuthenticationRequest authRequest, @Context UriInfo context) throws DatatypeConfigurationException {\n      KeystoneProvider p = getProvider();\n      ResponseWrapper wrapper = new JaxbElementWrapper();\n\n      Token token;\n      PasswordCredentialsRequiredUsername credentials;\n      if (authRequest.getCredential() != null) {\n         CredentialType credentialType = authRequest.getCredential().getValue();\n         credentials = (PasswordCredentialsRequiredUsername) credentialType;\n\n      } else {\n         credentials = new PasswordCredentialsRequiredUsername();\n         credentials.setUsername(authRequest.getTenantId());\n         credentials.setPassword(authRequest.getToken().getId());\n\n         if (!p.isValidToken(credentials.getPassword())) {\n\n            return Response.status(Response.Status.NOT_FOUND).entity(wrapper.wrapElement(p.createItemNotFound())).build();\n         }\n\n         String userName = p.getUsernameFromToken(credentials.getPassword());\n\n         if (!StringUtilities.nullSafeEqualsIgnoreCase(userName, credentials.getUsername())) {\n            return Response.status(Response.Status.NOT_FOUND).entity(wrapper.wrapElement(p.createItemNotFound())).build();\n         }\n\n\n      }\n      if (!validateCredentials(credentials)) {\n         return Response.status(Response.Status.UNAUTHORIZED).entity(wrapper.wrapElement(p.createUnauthorized(\"SecurityServiceFault: Unable to get customer auth by username\"))).build();\n      }\n      token = p.createToken(credentials);\n\n      AuthenticateResponse response = p.newAuthenticateResponse();\n      response.setToken(token);\n      response.setServiceCatalog(p.getServiceCatalog(credentials.getUsername()));\n      response.setUser(p.getUser(credentials.getUsername()));\n\n      return Response.ok(wrapper.wrapElement(response)).build();\n   }","commit_id":"56a3b6ca0b4c2bbb1712c83ee1ae211ddba33a4a","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n   public FullAuthInfo validateToken(ExtractorResult<String> account, String token) {\n\n      FullAuthInfo accountInfo;\n\n      if (account != null) {\n         accountInfo = authenticationService.validateToken(account.getResult(), token);\n      } else {\n         accountInfo = authenticationService.validateToken(null, token);\n      }\n      if (accountInfo.getEndpoints() != null) {\n         try {\n            endpointListCache.cacheEndpointsForToken(token, accountInfo.getEndpoints());\n         } catch (IOException io) {\n            LOG.error(\"Caching Failure: \" + io.getMessage(), io);\n         }\n      }\n\n      return accountInfo;\n   }","id":49423,"modified_method":"@Override\n   public FullAuthInfo validateToken(ExtractorResult<String> account, String token) {\n\n      FullAuthInfo accountInfo;\n\n      if (account != null) {\n         accountInfo = authenticationService.validateToken(account.getResult(), token);\n      } else {\n         accountInfo = authenticationService.validateToken(null, token);\n      }\n      if (accountInfo != null && accountInfo.getEndpoints() != null) {\n         try {\n            endpointListCache.cacheEndpointsForToken(token, accountInfo.getEndpoints());\n         } catch (IOException io) {\n            LOG.error(\"Caching Failure: \" + io.getMessage(), io);\n         }\n      }\n\n      return accountInfo;\n   }","commit_id":"56a3b6ca0b4c2bbb1712c83ee1ae211ddba33a4a","url":"https://github.com/rackerlabs/repose"},{"original_method":"private Component createEventsAndInvetoryPanel() {\n        JSplitPane leftSplitPanel = new JSplitPane();\n        leftSplitPanel.setOrientation( JSplitPane.VERTICAL_SPLIT );\n        leftSplitPanel.setDividerLocation( 500 );\n\n        Component eventsPanel = createEventsPanel();\n        leftSplitPanel.setLeftComponent( eventsPanel );\n\n        Component inventoryPanel = createInventoryPanel();\n        leftSplitPanel.setRightComponent( inventoryPanel );\n\n        return leftSplitPanel;\n    }","id":49424,"modified_method":"private Component createEventsAndInvetoryPanel() {\n        JSplitPane leftSplitPanel = new JSplitPane();\n        leftSplitPanel.setOrientation( JSplitPane.VERTICAL_SPLIT );\n        leftSplitPanel.setDividerLocation( 400 );\n\n        //Component eventsPanel = createEventsPanel();\n        Component eventsPanel = createLocalEventsPanel();\n        leftSplitPanel.setLeftComponent( eventsPanel );\n\n        Component inventoryPanel = createInventoryPanel();\n        leftSplitPanel.setRightComponent( inventoryPanel );\n\n        return leftSplitPanel;\n    }","commit_id":"c9a7f81c16e8c8bd535bddec9675a62e6640a340","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private Component createLocalEventsPanel() {\n        JPanel localEventsPanel = new JPanel();\n\n        localEventsPanel.setLayout( new BoxLayout( localEventsPanel,\n                                                   BoxLayout.Y_AXIS ) );\n\n        JLabel localEventsLabel = new JLabel( \"Local Events\" );\n        localEventsPanel.add( localEventsLabel );\n\n        //        JScrollPane pane2 = createTextAreaScroll( \"\",\n        //                                                  20,\n        //                                                  50,\n        //                                                  true,\n        //                                                  true );\n        JTextArea ta = new JTextArea( \"\",\n                                      20,\n                                      50 );\n        ta.setFont( UIManager.getFont( \"TextField.font\" ) );\n        ta.setWrapStyleWord( true );\n        ta.setLineWrap( true );\n\n        JScrollPane scroll = new JScrollPane( ta,\n                                              ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED,\n                                              ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED );\n\n        localEventsTextArea = (JTextArea) ((JViewport) scroll.getComponents()[0]).getComponents()[0];\n        localEventsPanel.add( scroll );\n\n        return localEventsPanel;\n    }","id":49425,"modified_method":"private Component createLocalEventsPanel() {\n        JPanel localEventsPanel = new JPanel();\n\n        localEventsPanel.setLayout( new BoxLayout( localEventsPanel,\n                                                   BoxLayout.Y_AXIS ) );\n\n        JLabel localEventsLabel = new JLabel( \"Events\" );\n        localEventsPanel.add( localEventsLabel );\n\n        //        JScrollPane pane2 = createTextAreaScroll( \"\",\n        //                                                  20,\n        //                                                  50,\n        //                                                  true,\n        //                                                  true );\n        JTextArea ta = new JTextArea( \"\",\n                                      20,\n                                      50 );\n        ta.setFont( UIManager.getFont( \"TextField.font\" ) );\n        ta.setWrapStyleWord( true );\n        ta.setLineWrap( true );\n\n        JScrollPane scroll = new JScrollPane( ta,\n                                              ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED,\n                                              ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED );\n\n        localEventsTextArea = (JTextArea) ((JViewport) scroll.getComponents()[0]).getComponents()[0];\n        localEventsPanel.add( scroll );\n\n        return localEventsPanel;\n    }","commit_id":"c9a7f81c16e8c8bd535bddec9675a62e6640a340","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private Component createInventoryPanel() {\n        inventoryTable = new JTable();\n        inventoryTable.setBorder( null );\n        inventoryTable.setModel( new DefaultTableModel(\n                                                        new Object[][]{\n                                                        },\n                                                        new String[]{\n                                                                \"Inventory\"\n                                                        }\n                ) );\n        inventoryTable.addMouseListener( new MouseListener() {\n\n            public void mouseReleased(MouseEvent e) {\n            }\n\n            public void mousePressed(MouseEvent e) {\n            }\n\n            public void mouseExited(MouseEvent e) {\n            }\n\n            public void mouseEntered(MouseEvent e) {\n            }\n\n            public void mouseClicked(MouseEvent e) {\n                if ( cmd == null ) {\n                    return;\n                }\n                int row = inventoryTable.rowAtPoint( e.getPoint() );\n                int col = inventoryTable.columnAtPoint( e.getPoint() );\n                Object o = inventoryTable.getModel().getValueAt( row,\n                                                                 col );\n                cmdTextField.setText( cmdTextField.getText() + o.toString() + \" \" );\n                cmd.add( o );\n            }\n        } );\n\n        JScrollPane inventoryPanel = new JScrollPane( inventoryTable );\n        return inventoryPanel;\n    }","id":49426,"modified_method":"private Component createInventoryPanel() {\n        inventoryTable = new JTable();\n        inventoryTable.setBorder( null );\n        inventoryTable.setModel( new DefaultTableModel(\n                                                        new Object[][]{\n                                                        },\n                                                        new String[]{\n                                                                \"Inventory\"\n                                                        }\n                ) );\n        inventoryTable.addMouseListener( new MouseListener() {\n\n            public void mouseReleased(MouseEvent e) {\n            }\n\n            public void mousePressed(MouseEvent e) {\n            }\n\n            public void mouseExited(MouseEvent e) {\n            }\n\n            public void mouseEntered(MouseEvent e) {\n            }\n\n            public void mouseClicked(MouseEvent e) {\n                if ( cmd == null ) {\n                    return;\n                }\n                int row = inventoryTable.rowAtPoint( e.getPoint() );\n                int col = inventoryTable.columnAtPoint( e.getPoint() );\n                Thing t = (Thing) inventoryTable.getModel().getValueAt( row,\n                                                                 col );\n                cmdTextField.setText( cmdTextField.getText() + t.getName() + \" \" );\n                cmd.add( t );\n            }\n        } );\n\n        JScrollPane inventoryPanel = new JScrollPane( inventoryTable );\n        return inventoryPanel;\n    }","commit_id":"c9a7f81c16e8c8bd535bddec9675a62e6640a340","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private Component createGlobalEventsPanel() {\n        JPanel globalEventsPanel = new JPanel();\n\n        globalEventsPanel.setLayout( new BoxLayout( globalEventsPanel,\n                                                    BoxLayout.Y_AXIS ) );\n\n        JLabel globalEventsLabel = new JLabel( \"Global Events\" );\n        globalEventsPanel.add( globalEventsLabel );\n\n        JScrollPane pane1 = createTextAreaScroll( \"\",\n                                                  20,\n                                                  50,\n                                                  true,\n                                                  true );\n        globalEventsTextArea = (JTextArea) ((JViewport) pane1.getComponents()[0]).getComponents()[0];\n        globalEventsPanel.add( pane1 );\n        return globalEventsPanel;\n    }","id":49427,"modified_method":"private Component createGlobalEventsPanel() {\n        JPanel globalEventsPanel = new JPanel();\n\n        globalEventsPanel.setLayout( new BoxLayout( globalEventsPanel,\n                                                    BoxLayout.Y_AXIS ) );\n\n        JLabel globalEventsLabel = new JLabel( \"Global Events\" );\n        globalEventsPanel.add( globalEventsLabel );\n\n        JScrollPane pane1 = createTextAreaScroll( \"\",\n                                                  20,\n                                                  50,\n                                                  true,\n                                                  true );\n        //globalEventsTextArea = (JTextArea) ((JViewport) pane1.getComponents()[0]).getComponents()[0];\n        globalEventsPanel.add( pane1 );\n        return globalEventsPanel;\n    }","commit_id":"c9a7f81c16e8c8bd535bddec9675a62e6640a340","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Create the frame.\n     */\n    public AdventureFrame(UserSession session,\n                          int onClose) {\n        setDefaultCloseOperation( onClose );\n        setBounds( 100,\n                   100,\n                   1100,\n                   787 );\n        contentPane = new JPanel();\n        contentPane.setBorder( new EmptyBorder( 5,\n                                                5,\n                                                5,\n                                                5 ) );\n        setContentPane( contentPane );\n        contentPane.setLayout( new BoxLayout( contentPane,\n                                              BoxLayout.Y_AXIS ) );\n\n        JToolBar toolBar_1 = new JToolBar();\n        toolBar_1.setAlignmentX( Component.LEFT_ALIGNMENT );\n        contentPane.add( toolBar_1 );\n\n        JToggleButton newFrame = new JToggleButton( \"New Window\" );\n        toolBar_1.add( newFrame );\n        newFrame.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                TextAdventure.createFrame( gameEngine,\n                                           JFrame.DISPOSE_ON_CLOSE );\n            }\n        } );\n\n        JSplitPane splitPane = new JSplitPane();\n        splitPane.setResizeWeight( 0.4 );\n        contentPane.add( splitPane );\n\n        Component leftPanel = createEventsAndInvetoryPanel();\n        splitPane.setLeftComponent( leftPanel );\n\n        JPanel test = new JPanel();\n        splitPane.setRightComponent( test );\n        test.setLayout( new MigLayout( \"\",\n                                       \"[][][]\",\n                                       \"[][grow, fill][][][][][fill][]\" ) );\n\n        createpOutputPanel( test );\n        createCharacterPanel( test );\n        createBuildActionsPanel( test );\n        createSendCommandPanel( test );\n\n        this.session = session;\n\n    }","id":49428,"modified_method":"/**\n     * Create the frame.\n     */\n    public AdventureFrame(UserSession session,\n                          final GameEngine gameEngine,\n                          int onClose) {\n\n        this.session = session;\n        this.gameEngine = gameEngine;\n        setDefaultCloseOperation( onClose );\n        setBounds( 100,\n                   100,\n                   1100,\n                   787 );\n        contentPane = new JPanel();\n        contentPane.setBorder( new EmptyBorder( 5,\n                                                5,\n                                                5,\n                                                5 ) );\n        setContentPane( contentPane );\n        contentPane.setLayout( new BoxLayout( contentPane,\n                                              BoxLayout.Y_AXIS ) );\n\n        JToolBar toolBar_1 = new JToolBar();\n        toolBar_1.setAlignmentX( Component.LEFT_ALIGNMENT );\n        contentPane.add( toolBar_1 );\n\n        JToggleButton newFrame = new JToggleButton( \"New Window\" );\n        toolBar_1.add( newFrame );\n        newFrame.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                TextAdventure.createFrame( gameEngine,\n                                           JFrame.DISPOSE_ON_CLOSE );\n            }\n        } );\n\n        JSplitPane splitPane = new JSplitPane();\n        splitPane.setResizeWeight( 0.4 );\n        contentPane.add( splitPane );\n\n        Component leftPanel = createEventsAndInvetoryPanel();\n        splitPane.setLeftComponent( leftPanel );\n\n        JPanel test = new JPanel();\n        splitPane.setRightComponent( test );\n        test.setLayout( new MigLayout( \"\",\n                                       \"[][][]\",\n                                       \"[][grow, fill][][][][][fill][]\" ) );\n\n        createpOutputPanel( test );\n        createCharacterPanel( test );\n        createBuildActionsPanel( test );\n        createSendCommandPanel( test );\n    }","commit_id":"c9a7f81c16e8c8bd535bddec9675a62e6640a340","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public JTableChannel(JTable exitsTable) {\n            this.jTable = exitsTable;\n        }","id":49429,"modified_method":"public JTableChannel(JTable jTable) {\n            this.jTable = jTable;\n            String name = jTable.getColumnName(0);\n            jTable.getColumn( name ).setCellRenderer(new DefaultTableCellRenderer() {\n                public void setValue(Object value) {\n                    setText(((Thing) value).getName());\n                }\n            });\n\n        }","commit_id":"c9a7f81c16e8c8bd535bddec9675a62e6640a340","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void send(Object object) {\n            DefaultTableModel model = (DefaultTableModel) jTable.getModel();\n\n            List list = (List) object;\n\n            if ( model.getRowCount() < list.size() ) {\n                Object[][] exits = new Object[list.size()][];\n                for ( int i = 0, length = model.getRowCount(); i < length; i++ ) {\n                    model.setValueAt( list.get( i ),\n                                      i,\n                                      0 );\n                }\n                for ( int i = model.getRowCount(), length = exits.length; i < length; i++ ) {\n                    model.addRow( new Object[]{list.get( i )} );\n                }\n            } else {\n                Object[][] exits = new Object[list.size()][];\n                for ( int i = 0; i < exits.length; i++ ) {\n                    model.setValueAt( list.get( i ),\n                                      i,\n                                      0 );\n                }\n                int i = exits.length;\n                while ( model.getRowCount() > exits.length ) {\n                    model.removeRow( i );\n                }\n            }\n        }","id":49430,"modified_method":"public void send(Object object) {\n            List<Thing> things = (List<Thing>) object;\n            addRows( things );\n        }","commit_id":"c9a7f81c16e8c8bd535bddec9675a62e6640a340","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void createBuildActionsPanel(JPanel parent) {\n        parent.add( createLabel( \"Actions\" ),\n                    \"wrap, spanx 3\" );\n\n        JPanel actionsPanel = new JPanel();\n        actionsPanel.setBorder( null );\n        actionsPanel.setLayout( new BoxLayout( actionsPanel,\n                                               BoxLayout.Y_AXIS ) );\n\n        JButton moveBtn = new JButton( \"Move\" );\n        actionsPanel.add( moveBtn );\n//        msg = new ACLMessage();\n//        msg.setPerformative( Performative.REQUEST );\n        \n        moveBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Move \" );\n                cmd = new ArrayList();\n                cmd.add( Action.MOVE );\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton pickupBtn = new JButton( \"Pick Up\" );\n        actionsPanel.add( pickupBtn );\n        pickupBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Pickup \" );\n                cmd = new ArrayList();\n                cmd.add( Action.PICKUP );\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton dropBtn = new JButton( \"Drop\" );\n        actionsPanel.add( dropBtn );\n        dropBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Drop \" );\n                cmd = new ArrayList();\n                cmd.add( Action.DROP );\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton giveBtn = new JButton( \"Give\" );\n        actionsPanel.add( giveBtn );\n        giveBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {                \n                cmdTextField.setText( \"Request Give \" );\n                cmd = new ArrayList();\n                cmd.add( Action.GIVE );\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton lookBtn = new JButton( \"Look\" );\n        actionsPanel.add( lookBtn );\n        lookBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Look \" );\n                cmd = new ArrayList();\n                cmd.add( Action.LOOK );\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        parent.add( actionsPanel,\n                    \"top, left\" );\n\n        thingsTable = new JTable();\n        thingsTable.setPreferredScrollableViewportSize( new Dimension( 245,\n                                                                       250 ) );\n        thingsTable.setBorder( null );\n        thingsTable.setModel( new DefaultTableModel(\n                                                     new Object[][]{\n                                                     },\n                                                     new String[]{\n                                                             \"Items\"\n                                                     }\n                ) );\n        thingsTable.addMouseListener( new MouseListener() {\n\n            public void mouseReleased(MouseEvent e) {\n            }\n\n            public void mousePressed(MouseEvent e) {\n            }\n\n            public void mouseExited(MouseEvent e) {\n            }\n\n            public void mouseEntered(MouseEvent e) {\n            }\n\n            public void mouseClicked(MouseEvent e) {\n                if ( cmd == null ) {\n                    return;\n                }\n                int row = thingsTable.rowAtPoint( e.getPoint() );\n                int col = thingsTable.columnAtPoint( e.getPoint() );\n                Object o = thingsTable.getModel().getValueAt( row,\n                                                              col );\n                cmdTextField.setText( cmdTextField.getText() + o.toString() + \" \" );\n                cmd.add( o );\n            }\n        } );\n\n        JScrollPane itemsPanel = new JScrollPane( thingsTable );\n        parent.add( itemsPanel,\n                    \"top, left\" );\n\n        exitsTable = new JTable();\n        exitsTable.setPreferredScrollableViewportSize( new Dimension( 245,\n                                                                      250 ) );\n        exitsTable.setBorder( null );\n        exitsTable.setModel( new DefaultTableModel(\n                                                    new Object[][]{\n                                                    },\n                                                    new String[]{\n                                                            \"Exits\"\n                                                    }\n                ) );\n\n        exitsTable.addMouseListener( new MouseListener() {\n\n            public void mouseReleased(MouseEvent e) {\n            }\n\n            public void mousePressed(MouseEvent e) {\n            }\n\n            public void mouseExited(MouseEvent e) {\n            }\n\n            public void mouseEntered(MouseEvent e) {\n            }\n\n            public void mouseClicked(MouseEvent e) {\n                if ( cmd == null ) {\n                    return;\n                }\n                int row = exitsTable.rowAtPoint( e.getPoint() );\n                int col = exitsTable.columnAtPoint( e.getPoint() );\n                Object o = exitsTable.getModel().getValueAt( row,\n                                                             col );\n                cmdTextField.setText( cmdTextField.getText() + o.toString() + \" \" );\n                cmd.add( o );\n            }\n        } );\n\n        JScrollPane exitsPanel = new JScrollPane( exitsTable );\n        parent.add( exitsPanel,\n                    \"top, left, wrap\" );\n\n    }","id":49431,"modified_method":"private void createBuildActionsPanel(JPanel parent) {\n        parent.add( createLabel( \"Actions\" ),\n                    \"wrap, spanx 3\" );\n\n        JPanel actionsPanel = new JPanel();\n        actionsPanel.setBorder( null );\n        actionsPanel.setLayout( new BoxLayout( actionsPanel,\n                                               BoxLayout.Y_AXIS ) );\n\n        JButton moveBtn = new JButton( \"Move\" );\n        moveBtn.setToolTipText(\"Select one Room from the Exits, then press Send\");\n        actionsPanel.add( moveBtn );\n//        msg = new ACLMessage();\n//        msg.setPerformative( Performative.REQUEST );\n        \n        moveBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Move \" );\n                cmd = new ArrayList();\n                cmd.add(MoveCommand.class );\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton pickupBtn = new JButton( \"Pick Up\" );\n        pickupBtn.setToolTipText(\"Select one from the Items list, then press Send\");\n        actionsPanel.add( pickupBtn );\n        pickupBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Pickup \" );\n                cmd = new ArrayList();\n                cmd.add(PickupCommand.class);\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton dropBtn = new JButton( \"Drop\" );\n        dropBtn.setToolTipText(\"Select one from the Inventory, then press Send\");\n        actionsPanel.add( dropBtn );\n        dropBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Drop \" );\n                cmd = new ArrayList();\n                cmd.add(DropCommand.class);\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton giveBtn = new JButton( \"Give\" );\n        giveBtn.setToolTipText(\"Select one from the Inventory, then Select the target Character, then press Send\");\n        actionsPanel.add( giveBtn );\n        giveBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {                \n                cmdTextField.setText( \"Request Give \" );\n                cmd = new ArrayList();\n                cmd.add(GiveCommand.class);\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        JButton lookBtn = new JButton( \"Look\" );\n        giveBtn.setToolTipText(\"Just press Send\");\n        actionsPanel.add( lookBtn );\n        lookBtn.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmdTextField.setText( \"Look \" );\n                cmd = new ArrayList();\n                cmd.add( LookCommand.class );\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n            }\n        } );\n\n        parent.add( actionsPanel,\n                    \"top, left\" );\n\n        thingsTable = new JTable();\n        thingsTable.setPreferredScrollableViewportSize( new Dimension( 245,\n                                                                       250 ) );\n        thingsTable.setBorder( null );\n        thingsTable.setModel( new DefaultTableModel(\n                                                     new Object[][]{\n                                                     },\n                                                     new String[]{\n                                                             \"Items\"\n                                                     }\n                ) );\n        thingsTable.addMouseListener( new MouseListener() {\n\n            public void mouseReleased(MouseEvent e) {\n            }\n\n            public void mousePressed(MouseEvent e) {\n            }\n\n            public void mouseExited(MouseEvent e) {\n            }\n\n            public void mouseEntered(MouseEvent e) {\n            }\n\n            public void mouseClicked(MouseEvent e) {\n                if ( cmd == null ) {\n                    return;\n                }\n                int row = thingsTable.rowAtPoint( e.getPoint() );\n                int col = thingsTable.columnAtPoint( e.getPoint() );\n                Thing t = (Thing) thingsTable.getModel().getValueAt( row,\n                                                              col );\n                cmdTextField.setText( cmdTextField.getText() + t.getName() + \" \" );\n                cmd.add( t );\n            }\n        } );\n\n        JScrollPane itemsPanel = new JScrollPane( thingsTable );\n        parent.add( itemsPanel,\n                    \"top, left\" );\n\n        exitsTable = new JTable();\n        exitsTable.setPreferredScrollableViewportSize( new Dimension( 245,\n                                                                      250 ) );\n        exitsTable.setBorder( null );\n        exitsTable.setModel( new DefaultTableModel(\n                                                    new Object[][]{\n                                                    },\n                                                    new String[]{\n                                                            \"Exits\"\n                                                    }\n                ) );\n\n        exitsTable.addMouseListener( new MouseListener() {\n\n            public void mouseReleased(MouseEvent e) {\n            }\n\n            public void mousePressed(MouseEvent e) {\n            }\n\n            public void mouseExited(MouseEvent e) {\n            }\n\n            public void mouseEntered(MouseEvent e) {\n            }\n\n            public void mouseClicked(MouseEvent e) {\n                if ( cmd == null ) {\n                    return;\n                }\n                int row = exitsTable.rowAtPoint( e.getPoint() );\n                int col = exitsTable.columnAtPoint( e.getPoint() );\n                Room r = (Room) exitsTable.getModel().getValueAt( row,\n                                                             col );\n                cmdTextField.setText( cmdTextField.getText() + r.getName() + \" \" );\n                cmd.add( r );\n            }\n        } );\n\n        JScrollPane exitsPanel = new JScrollPane( exitsTable );\n        parent.add( exitsPanel,\n                    \"top, left, wrap\" );\n\n    }","commit_id":"c9a7f81c16e8c8bd535bddec9675a62e6640a340","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private Component createEventsPanel() {\n        JSplitPane splitPanel = new JSplitPane();\n        splitPanel.setResizeWeight( 0.4 );\n        splitPanel.setOrientation( JSplitPane.VERTICAL_SPLIT );\n\n        splitPanel.setRightComponent( createGlobalEventsPanel() );\n\n        splitPanel.setLeftComponent( createLocalEventsPanel() );\n\n        return splitPanel;\n    }","id":49432,"modified_method":"private Component createEventsPanel() {\n        JSplitPane splitPanel = new JSplitPane();\n        splitPanel.setResizeWeight( 0.4 );\n        splitPanel.setOrientation( JSplitPane.VERTICAL_SPLIT );\n\n        //splitPanel.setRightComponent( createGlobalEventsPanel() );\n\n        splitPanel.setLeftComponent( createLocalEventsPanel() );\n\n        return splitPanel;\n    }","commit_id":"c9a7f81c16e8c8bd535bddec9675a62e6640a340","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void createCharacterPanel(JPanel parent) {\n        parent.add( createLabel( \"Character\" ),\n                    \"wrap, spanx 3\" );\n        characterSelectCombo = new JComboBox();\n        characterSelectCombo.setModel( new DefaultComboBoxModel( new Object[]{null, null} ) );\n        parent.add( characterSelectCombo,\n                    \"top, left\" );\n        characterSelectCombo.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                cmd = new ArrayList();\n                cmd.add( Action.SELECT_CHARACTER );\n                cmd.add( session );\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n                gameEngine.receiveMessage( session,\n                                           cmd );\n                cmd = null;\n            }\n        } );\n\n        JTable characterPropertiesTable = new JTable();\n        characterPropertiesTable.setPreferredScrollableViewportSize( new Dimension( 240,\n                                                                                    200 ) );\n        characterPropertiesTable.setBorder( null );\n        characterPropertiesTable.setModel( new DefaultTableModel(\n                                                                  new Object[][]{\n                                                                          {\"strength\", \"100\"},\n                                                                          {\"health\", \"100\"},\n                                                                          {\"coiins\", \"100\"},\n                                                                          {\"speed\", \"100\"},\n                                                                          {\"mana\", \"100\"},\n                                                                  },\n                                                                  new String[]{\n                                                                          \"property\", \"value\"\n                                                                  }\n                ) );\n        JScrollPane characterPropertiesPanel = new JScrollPane( characterPropertiesTable );\n        parent.add( characterPropertiesPanel,\n                    \"top, left, wrap, spanx 2\" );\n    }","id":49433,"modified_method":"private void createCharacterPanel(JPanel parent) {\n        parent.add( createLabel( \"Character\" ),\n                    \"wrap, spanx 3\" );\n        characterSelectCombo = new JComboBox();\n        characterSelectCombo.setModel( new DefaultComboBoxModel( new Object[]{null, null} ) );\n        parent.add( characterSelectCombo,\n                    \"top, left\" );\n\n        Map<String, Character> characterMap = ( Map<String, Character> ) gameEngine.getData().get(\"characters\");\n        Character[] characters = characterMap.values().toArray( new Character[characterMap.size()] );\n\n        characterSelectCombo.setModel( new DefaultComboBoxModel( characters ) );\n        characterSelectCombo.setSelectedItem( characterMap.get(\"hero\"));\n\n        characterSelectCombo.addActionListener( new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n\n                Character c = (Character) characterSelectCombo.getSelectedObjects()[0];\n                org.kie.api.runtime.rule.FactHandle fh = gameEngine.getKieSession().getFactHandle(session);\n                session.setCharacter(c);\n                gameEngine.getKieSession().update(fh, session);\n\n                cmd = new ArrayList();\n                cmd.add( LookCommand.class );\n                cmd.add( characterSelectCombo.getSelectedObjects()[0] );\n                gameEngine.receiveMessage( session,\n                                           cmd );\n                cmd = null;\n            }\n        } );\n\n        JTable characterPropertiesTable = new JTable();\n        characterPropertiesTable.setPreferredScrollableViewportSize( new Dimension( 240,\n                                                                                    200 ) );\n        characterPropertiesTable.setBorder( null );\n        characterPropertiesTable.setModel( new DefaultTableModel(\n                                                                  new Object[][]{\n                                                                          {\"strength\", \"100\"},\n                                                                          {\"health\", \"100\"},\n                                                                          {\"coiins\", \"100\"},\n                                                                          {\"speed\", \"100\"},\n                                                                          {\"mana\", \"100\"},\n                                                                  },\n                                                                  new String[]{\n                                                                          \"property\", \"value\"\n                                                                  }\n                ) );\n        JScrollPane characterPropertiesPanel = new JScrollPane( characterPropertiesTable );\n        parent.add( characterPropertiesPanel,\n                    \"top, left, wrap, spanx 2\" );\n    }","commit_id":"c9a7f81c16e8c8bd535bddec9675a62e6640a340","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void createGame() {\n\n        KieContainer kc = KieServices.Factory.get().getKieClasspathContainer();\n        System.out.println(kc.verify().getMessages().toString());\n        ksession = kc.newKieSession( \"TextAdventureKS\");\n\n        KieBase kbase = ksession.getKieBase();\n\n        Counter c = new Counter();\n        ksession.setGlobal( \"counter\",\n                            c );\n\n        classLoader = ((KnowledgeBaseImpl) kbase).getRootClassLoader();\n        ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n        try {\n            Thread.currentThread().setContextClassLoader( classLoader );\n            Map vars = new HashMap();\n            vars.put( \"c\",\n                      c );\n            Map<String, Map> map;\n            try {\n                String mvelContent = new String(IOUtils.toByteArray(getClass().getResource(\"data.mvel\").openStream()), IoUtils.UTF8_CHARSET);\n                map = (Map<String, Map>) MVEL.executeExpression(MVEL.compileExpression(mvelContent), vars );\n            } catch ( IOException e ) {\n                throw new RuntimeException( e );\n            }\n\n            for ( Object o : map.get( \"rooms\" ).values() ) {\n                ksession.insert( o );\n            }\n\n            for ( Object o : map.get( \"doors\" ).values() ) {\n                ksession.insert( o );\n            }\n\n            for ( Object o : map.get( \"characters\" ).values() ) {\n                ksession.insert( o );\n            }\n\n            for ( Object o : map.get( \"items\" ).values() ) {\n                ksession.insert( o );\n            }\n\n            for ( Object o : map.get( \"locations\" ).values() ) {\n                ksession.insert( o );\n            }\n\n            MapVariableResolverFactory f = new MapVariableResolverFactory( map );\n\n            String baseStr = \"import  org.drools.games.adventures.*;  import org.drools.games.adventures.commands.*;\\n\";\n            FactHandle fh = ksession.insert( MVEL.eval( baseStr + \"new EnterEvent( characters['hero'], rooms['first floor hallway'] )\",\n                                                        f ) );\n            ksession.fireAllRules();\n        } finally {\n            Thread.currentThread().setContextClassLoader( currentClassLoader );\n        }\n    }","id":49434,"modified_method":"public void createGame() {\n\n        KieContainer kc = KieServices.Factory.get().getKieClasspathContainer();\n        System.out.println(kc.verify().getMessages().toString());\n        ksession = kc.newKieSession(\"TextAdventureKS\");\n\n        Counter c = new Counter();\n        ksession.setGlobal(\"counter\",\n                           c);\n        Map vars = new HashMap();\n        vars.put(\"c\",\n                 c);\n        try {\n            String mvelContent = new String(IOUtils.toByteArray(getClass().getResource(\"data.mvel\").openStream()), IoUtils.UTF8_CHARSET);\n            data = (Map<String, Map>) MVEL.executeExpression(MVEL.compileExpression(mvelContent), vars);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        for (Object o : data.get(\"rooms\").values()) {\n            ksession.insert( o );\n        }\n\n        for ( Object o : data.get( \"doors\" ).values() ) {\n            ksession.insert( o );\n        }\n\n        for ( Object o : data.get( \"characters\" ).values() ) {\n            ksession.insert( o );\n        }\n\n        for ( Object o : data.get( \"items\" ).values() ) {\n            ksession.insert( o );\n        }\n\n        for ( Object o : data.get( \"keys\" ).values() ) {\n            ksession.insert( o );\n        }\n//\n//        for ( Object o : data.get( \"locks\" ).values() ) {\n//            ksession.insert( o );\n//        }\n\n        for ( Object o : data.get( \"locations\" ).values() ) {\n            ksession.insert( o );\n        }\n    }","commit_id":"c9a7f81c16e8c8bd535bddec9675a62e6640a340","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void receiveMessage(UserSession session,\n                               List cmd) {\n        ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n        String baseStr = \"import  org.drools.games.adventures.*;  import org.drools.games.adventures.commands.*;\\n\";\n        try {\n            Thread.currentThread().setContextClassLoader( classLoader );\n            Map vars = new HashMap();\n            vars.put( \"args\",\n                      cmd );\n            MapVariableResolverFactory f = new MapVariableResolverFactory( vars );\n            Action c = (Action) cmd.get( 0 );\n            switch ( c ) {\n                case MOVE : {\n                    ksession.insert( new Request( session,\n                                                  MVEL.eval( baseStr + \"new MoveCommand(args[1], args[2])\",\n                                                             f ) ) );\n                    ksession.fireAllRules();\n                    break;\n                }\n                case PICKUP : {\n                    ksession.insert( new Request( session,\n                                                  MVEL.eval( baseStr + \"new PickupCommand(args[1], args[2])\",\n                                                             f ) ) );\n                    ksession.fireAllRules();\n                    break;\n                }\n                case DROP : {\n                    ksession.insert( new Request( session,\n                                                  MVEL.eval( baseStr + \"new DropCommand(args[1], args[2])\",\n                                                             f ) ) );\n                    ksession.fireAllRules();\n                    break;\n                }\n                case GIVE : {\n                    ksession.insert( new Request( session,\n                                                  MVEL.eval( baseStr + \"new GiveCommand(args[1], args[2], args[3])\",\n                                                             f ) ) );\n                    ksession.fireAllRules();\n                    break;\n                }\n                case LOOK : {\n                    ksession.insert( new Request( session,\n                                                  MVEL.eval( baseStr + \"new LookCommand(args[1])\",\n                                                             f ) ) );\n                    ksession.fireAllRules();\n                    break;\n                }\n                case SELECT_CHARACTER : {\n                    ksession.insert( new Request( session,\n                                                  MVEL.eval( baseStr + \"new SetSessionCharacterCommand(args[1], args[2])\",\n                                                             f ) ) );\n                    ksession.fireAllRules();\n                    break;\n                }\n            }\n        } catch ( Exception e ) {\n            session.getChannels().get( \"output\" ).send( \"Unable to Execute Command: \" + cmd );\n        } finally {\n            Thread.currentThread().setContextClassLoader( currentClassLoader );\n        }\n\n    }","id":49435,"modified_method":"public void receiveMessage(UserSession session,\n                               List cmdList) {\n        try {\n            Class<Command> cls = (Class<Command>) cmdList.get(0);\n            Class[] constructorParamTypes = new Class[cmdList.size()-1];\n            for ( int i = 1; i < cmdList.size(); i++) {\n                constructorParamTypes[i-1] = cmdList.get(i).getClass();\n            }\n\n            Object[] args = cmdList.subList(1, cmdList.size() ).toArray();\n\n            Command cmd = (Command) cls.getDeclaredConstructors()[0].newInstance(args);\n            cmd.setSession( session );\n            ksession.insert( cmd );\n            ksession.fireAllRules();\n        } catch ( Exception e ) {\n            e.printStackTrace();\n            session.getChannels().get( \"output\" ).send( \"Unable to Execute Command: \" + cmdList );\n        }\n\n    }","commit_id":"c9a7f81c16e8c8bd535bddec9675a62e6640a340","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public static void createFrame(GameEngine engine, int onClose) {\n        UserSession session = new UserSession();\n        \n        AdventureFrame frame = new AdventureFrame(session, onClose);\n        frame.setVisible( true );\n                                                \n        session.getChannels().put( \"output\", new JTextAreaChannel( frame.getOutputTextArea() ) );\n        session.getChannels().put( \"events\",  new JTextAreaChannel( frame.getLocalEventsTextArea() ) );\n        session.getChannels().put( \"exits\", new JTableChannel( frame.getExitsTable() ) );\n        session.getChannels().put( \"things\", new JTableChannel( frame.getThingsTable()) );\n        session.getChannels().put( \"inventory\", new JTableChannel( frame.getInventoryTable()) );\n        session.getChannels().put( \"characters\", new JComboBoxChannel( frame.getCharacterSelectCombo() ) );\n        \n        frame.setGameEngine( engine );\n        \n        engine.ksession.insert( session );\n        engine.ksession.fireAllRules();\n    }","id":49436,"modified_method":"public static void createFrame(GameEngine engine, int onClose) {\n        UserSession session = new UserSession();\n\n        Map<String, Character> characterMap = ( Map<String, Character> ) engine.getData().get(\"characters\");\n        session.setCharacter(characterMap.get(\"hero\"));\n\n        AdventureFrame frame = new AdventureFrame(session, engine, onClose);\n        frame.setVisible( true );\n\n        session.getChannels().put( \"output\", new JTextAreaChannel( frame.getOutputTextArea() ) );\n        session.getChannels().put( \"events\",  new JTextAreaChannel( frame.getLocalEventsTextArea() ) );\n        session.getChannels().put( \"exits\", new JTableChannel( frame.getExitsTable() ) );\n        session.getChannels().put( \"things\", new JTableChannel( frame.getThingsTable()) );\n        session.getChannels().put( \"inventory\", new JTableChannel( frame.getInventoryTable()) );\n\n\n        engine.ksession.insert( session );\n        LookCommand lc = new LookCommand(characterMap.get(\"hero\"));\n        lc.setSession(session);\n        engine.getKieSession().insert(lc);\n        engine.ksession.fireAllRules();\n    }","commit_id":"c9a7f81c16e8c8bd535bddec9675a62e6640a340","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public static void configureFindModel(boolean replace, Editor editor, FindModel model) {\n    String selectedText = editor.getSelectionModel().getSelectedText();\n    model.setReplaceState(replace);\n    if (selectedText != null) {\n      if (replace) {\n        if (!StringUtil.isEmpty(selectedText)) {\n          if (selectedText.indexOf('\\n') >= 0) {\n            model.setGlobal(false);\n          }\n          else {\n            model.setStringToFind(selectedText);\n            model.setGlobal(true);\n          }\n        } else {\n          model.setGlobal(true);\n        }\n      } else {\n        model.setStringToFind(selectedText);\n        model.setGlobal(true);\n      }\n\n      if (model.isGlobal()) {\n        model.setStringToFind(selectedText);\n      }\n    }\n    model.setPromptOnReplace(false);\n  }","id":49437,"modified_method":"public static void configureFindModel(boolean replace, Editor editor, FindModel model) {\n    final String selectedText = editor.getSelectionModel().getSelectedText();\n\n    boolean isGlobal = true;\n    String stringToFind = null;\n    if (!StringUtil.isEmpty(selectedText)) {\n      if (selectedText.indexOf('\\n') >= 0) {\n        if (replace){\n          isGlobal = false;\n          stringToFind = model.getStringToFind();\n        }\n      }\n      if (stringToFind == null) {\n        stringToFind = selectedText;\n      }\n    } else {\n      stringToFind = model.getStringToFind();\n    }\n\n    model.setReplaceState(replace);\n    model.setStringToFind(stringToFind);\n    model.setGlobal(isGlobal);\n    model.setPromptOnReplace(false);\n  }","commit_id":"94aa1230cdc128ae6c54b27f46912d5849d3811e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void performReplaceAll(Editor e) {\n    if (!Utils.ensureOkToWrite(e)) return;\n    if (mySearchResults.getFindModel() != null) {\n      FindUtil.replace(e.getProject(), e,\n                       mySearchResults.getFindModel().isGlobal() ? 0 : mySearchResults.getEditor().getSelectionModel().getSelectionStart(),\n                       mySearchResults.getFindModel(), this);\n      if (myReplaceListener != null) {\n        myReplaceListener.replaceAllPerformed(e);\n      }\n    }\n  }","id":49438,"modified_method":"@Override\n  public void performReplaceAll(Editor e) {\n    if (!Utils.ensureOkToWrite(e)) return;\n    if (mySearchResults.getFindModel() != null) {\n      final FindModel copy = new FindModel();\n      copy.copyFrom(mySearchResults.getFindModel());\n\n      final SelectionModel selectionModel = mySearchResults.getEditor().getSelectionModel();\n\n      int offset;\n      if (selectionModel.getSelectedText() != null) {\n        offset = selectionModel.getSelectionStart();\n      } else {\n        offset = 0;\n        copy.setGlobal(true);\n      }\n\n      FindUtil.replace(e.getProject(), e, offset, copy, this);\n\n      if (myReplaceListener != null) {\n        myReplaceListener.replaceAllPerformed(e);\n      }\n    }\n  }","commit_id":"94aa1230cdc128ae6c54b27f46912d5849d3811e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateInBackground(FindModel findModel, final boolean allowedToChangedEditorSelection) {\n    myLivePreviewAlarm.cancelAllRequests();\n    if (findModel == null) return;\n    final boolean unitTestMode = ApplicationManager.getApplication().isUnitTestMode();\n    final FindModel copy = (FindModel)findModel.clone();\n    final ModalityState modalityState = ModalityState.current();\n    Runnable request = new Runnable() {\n      @Override\n      public void run() {\n        Runnable denyReplace = new Runnable() {\n          @Override\n          public void run() {\n            setReplaceDenied(true);\n          }\n        };\n        if (unitTestMode) {\n          denyReplace.run();\n        } else {\n          ApplicationManager.getApplication().invokeAndWait(denyReplace, modalityState);\n        }\n        mySearchResults.updateThreadSafe(copy, allowedToChangedEditorSelection, null);\n      }\n    };\n    if (unitTestMode) {\n      request.run();\n    } else {\n      myLivePreviewAlarm.addRequest(request, myUserActivityDelay);\n    }\n  }","id":49439,"modified_method":"public void updateInBackground(FindModel findModel, final boolean allowedToChangedEditorSelection) {\n    myLivePreviewAlarm.cancelAllRequests();\n    if (findModel == null) return;\n    final boolean unitTestMode = ApplicationManager.getApplication().isUnitTestMode();\n    final FindModel copy = new FindModel();\n    copy.copyFrom(findModel);\n    \n    final ModalityState modalityState = ModalityState.current();\n    Runnable request = new Runnable() {\n      @Override\n      public void run() {\n        Runnable denyReplace = new Runnable() {\n          @Override\n          public void run() {\n            setReplaceDenied(true);\n          }\n        };\n        if (unitTestMode) {\n          denyReplace.run();\n        } else {\n          ApplicationManager.getApplication().invokeAndWait(denyReplace, modalityState);\n        }\n        mySearchResults.updateThreadSafe(copy, allowedToChangedEditorSelection, null);\n      }\n    };\n    if (unitTestMode) {\n      request.run();\n    } else {\n      myLivePreviewAlarm.addRequest(request, myUserActivityDelay);\n    }\n  }","commit_id":"94aa1230cdc128ae6c54b27f46912d5849d3811e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void runConverters(Message msg) {\n        Timer cTimer = metricRegistry.timer(getConverterTimerName());\n        final Timer.Context cTimerContext = cTimer.time();\n\n        for (Converter converter : converters) {\n            try {\n                if (!(msg.getFields().get(targetField) instanceof String)) {\n                    continue;\n                }\n\n                if (!converter.buildsMultipleFields()) {\n                    Object converted = converter.convert((String) msg.getFields().get(targetField));\n\n                    // We have arrived here if no exception was thrown and can safely replace the original field.\n                    msg.removeField(targetField);\n                    msg.addField(targetField, converted);\n                } else {\n                    @SuppressWarnings(\"unchecked\")\n                    final Map<String, Object> convert = (Map<String, Object>) converter.convert((String) msg.getFields().get(\n                            targetField));\n                    for (String reservedField : Message.RESERVED_FIELDS) {\n                        if (convert.containsKey(reservedField)) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\n                                        \"Not setting reserved field {} from converter {} on message {}, rest of the message is being processed\",\n                                        new Object[]{reservedField, converter.getType(), msg.getId()});\n                            }\n                            converterExceptions.incrementAndGet();\n                            convert.remove(reservedField);\n                        }\n                    }\n\n                    msg.addFields(convert);\n                }\n            } catch (Exception e) {\n                this.converterExceptions.incrementAndGet();\n                LOG.error(\"Could not apply converter [\" + converter.getType() + \"] of extractor [\" + getId() + \"].\", e);\n            }\n        }\n\n        cTimerContext.stop();\n    }","id":49440,"modified_method":"public void runConverters(Message msg) {\n        final Timer.Context timerContext = metricRegistry.timer(getConverterTimerName()).time();\n\n        for (Converter converter : converters) {\n            try {\n                if (!(msg.getFields().get(targetField) instanceof String)) {\n                    continue;\n                }\n\n                if (!converter.buildsMultipleFields()) {\n                    final Object converted = converter.convert((String) msg.getFields().get(targetField));\n\n                    // We have arrived here if no exception was thrown and can safely replace the original field.\n                    msg.removeField(targetField);\n                    msg.addField(targetField, converted);\n                } else {\n                    @SuppressWarnings(\"unchecked\")\n                    final Map<String, Object> convert = (Map<String, Object>) converter.convert((String) msg.getFields().get(\n                            targetField));\n                    for (String reservedField : Message.RESERVED_FIELDS) {\n                        if (convert.containsKey(reservedField)) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\n                                        \"Not setting reserved field {} from converter {} on message {}, rest of the message is being processed\",\n                                        reservedField, converter.getType(), msg.getId());\n                            }\n                            converterExceptions.incrementAndGet();\n                            convert.remove(reservedField);\n                        }\n                    }\n\n                    msg.addFields(convert);\n                }\n            } catch (Exception e) {\n                this.converterExceptions.incrementAndGet();\n                LOG.error(\"Could not apply converter [\" + converter.getType() + \"] of extractor [\" + getId() + \"].\", e);\n            }\n        }\n\n        timerContext.stop();\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public List<Map<String, Object>> converterConfigMap() {\n        List<Map<String, Object>> converterConfig = Lists.newArrayList();\n\n        for (Converter converter : converters) {\n            Map<String, Object> config = Maps.newHashMap();\n\n            config.put(\"type\", converter.getType().toLowerCase());\n            config.put(\"config\", converter.getConfig());\n\n            converterConfig.add(config);\n        }\n\n        return converterConfig;\n    }","id":49441,"modified_method":"public List<Map<String, Object>> converterConfigMap() {\n        final ImmutableList.Builder<Map<String, Object>> listBuilder = ImmutableList.builder();\n\n        for (Converter converter : converters) {\n            final Map<String, Object> config = ImmutableMap.of(\n                    FIELD_CONVERTER_TYPE, converter.getType().toLowerCase(),\n                    FIELD_CONVERTER_CONFIG, converter.getConfig()\n            );\n            listBuilder.add(config);\n        }\n\n        return listBuilder.build();\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public void runExtractor(Message msg) {\n        // We can only work on Strings.\n        if (!(msg.getField(sourceField) instanceof String)) {\n            return;\n        }\n\n        String field = (String) msg.getField(sourceField);\n\n        // Decide if to extract at all.\n        if (conditionType.equals(ConditionType.STRING)) {\n            if (!field.contains(conditionValue)) {\n                return;\n            }\n        } else if (conditionType.equals(ConditionType.REGEX)) {\n            if (!regexConditionPattern.matcher(field).find()) {\n                return;\n            }\n        }\n\n        Timer timer = metricRegistry.timer(getTotalTimerName());\n        final Timer.Context timerContext = timer.time();\n\n        Result result = run(field);\n\n        if (result == null || result.getValue() == null) {\n            timerContext.close();\n            return;\n        } else {\n            msg.addField(targetField, result.getValue());\n        }\n\n        // Remove original from message?\n        if (cursorStrategy.equals(CursorStrategy.CUT) && !targetField.equals(sourceField) && !Message.RESERVED_FIELDS.contains(sourceField)) {\n            StringBuilder sb = new StringBuilder(field);\n\n            sb.delete(result.getBeginIndex(), result.getEndIndex());\n\n            String finalResult = sb.toString();\n\n            if(finalResult.isEmpty()) {\n                finalResult = \"fullyCutByExtractor\";\n            }\n\n            msg.removeField(sourceField);\n            msg.addField(sourceField, finalResult);\n        }\n\n        runConverters(msg);\n\n        timerContext.stop();\n    }","id":49442,"modified_method":"public void runExtractor(Message msg) {\n        // We can only work on Strings.\n        if (!(msg.getField(sourceField) instanceof String)) {\n            return;\n        }\n\n        String field = (String) msg.getField(sourceField);\n\n        // Decide if to extract at all.\n        if (conditionType.equals(ConditionType.STRING)) {\n            if (!field.contains(conditionValue)) {\n                return;\n            }\n        } else if (conditionType.equals(ConditionType.REGEX)) {\n            if (!regexConditionPattern.matcher(field).find()) {\n                return;\n            }\n        }\n\n        final Timer.Context timerContext = metricRegistry.timer(getTotalTimerName()).time();\n\n        Result result = run(field);\n\n        if (result == null || result.getValue() == null) {\n            timerContext.close();\n            return;\n        } else {\n            msg.addField(targetField, result.getValue());\n        }\n\n        // Remove original from message?\n        if (cursorStrategy.equals(CursorStrategy.CUT) && !targetField.equals(sourceField) && !Message.RESERVED_FIELDS.contains(sourceField)) {\n            StringBuilder sb = new StringBuilder(field);\n\n            sb.delete(result.getBeginIndex(), result.getEndIndex());\n\n            String finalResult = sb.toString();\n\n            if (finalResult.isEmpty()) {\n                finalResult = \"fullyCutByExtractor\";\n            }\n\n            msg.removeField(sourceField);\n            msg.addField(sourceField, finalResult);\n        }\n\n        runConverters(msg);\n\n        timerContext.stop();\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public Map<String, Object> getPersistedFields() {\n        return new HashMap<String, Object>() {{\n            put(\"id\", id);\n            put(\"title\", title);\n            put(\"order\", order);\n            put(\"type\", superType.toString().toLowerCase());\n            put(\"cursor_strategy\", cursorStrategy.toString().toLowerCase());\n            put(\"target_field\", targetField);\n            put(\"source_field\", sourceField);\n            put(\"creator_user_id\", creatorUserId);\n            put(\"extractor_config\", extractorConfig);\n            put(\"condition_type\", conditionType.toString().toLowerCase());\n            put(\"condition_value\", conditionValue);\n            put(\"converters\", converterConfigMap());\n        }};\n    }","id":49443,"modified_method":"public Map<String, Object> getPersistedFields() {\n        return new HashMap<String, Object>() {{\n            put(FIELD_ID, id);\n            put(FIELD_TITLE, title);\n            put(FIELD_ORDER, order);\n            put(FIELD_TYPE, superType.toString().toLowerCase());\n            put(FIELD_CURSOR_STRATEGY, cursorStrategy.toString().toLowerCase());\n            put(FIELD_TARGET_FIELD, targetField);\n            put(FIELD_SOURCE_FIELD, sourceField);\n            put(FIELD_CREATOR_USER_ID, creatorUserId);\n            put(FIELD_EXTRACTOR_CONFIG, extractorConfig);\n            put(FIELD_CONDITION_TYPE, conditionType.toString().toLowerCase());\n            put(FIELD_CONDITION_VALUE, conditionValue);\n            put(FIELD_CONVERTERS, converterConfigMap());\n        }};\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private Map<String, Object> toMap(Extractor extractor) {\n        Map<String, Object> map = Maps.newHashMap();\n\n        map.put(\"id\", extractor.getId());\n        map.put(\"title\", extractor.getTitle());\n        map.put(\"type\", extractor.getType().toString().toLowerCase());\n        map.put(\"cursor_strategy\", extractor.getCursorStrategy().toString().toLowerCase());\n        map.put(\"source_field\", extractor.getSourceField());\n        map.put(\"target_field\", extractor.getTargetField());\n        map.put(\"extractor_config\", extractor.getExtractorConfig());\n        map.put(\"creator_user_id\", extractor.getCreatorUserId());\n        map.put(\"converters\", extractor.converterConfigMap());\n        map.put(\"condition_type\", extractor.getConditionType().toString().toLowerCase());\n        map.put(\"condition_value\", extractor.getConditionValue());\n        map.put(\"order\", extractor.getOrder());\n\n        map.put(\"exceptions\", extractor.getExceptionCount());\n        map.put(\"converter_exceptions\", extractor.getConverterExceptionCount());\n\n        Map<String, Object> metrics = Maps.newHashMap();\n        metrics.put(\"total\",  buildTimerMap(metricRegistry.getTimers().get(extractor.getTotalTimerName())));\n        metrics.put(\"converters\", buildTimerMap(metricRegistry.getTimers().get(extractor.getConverterTimerName())));\n        map.put(\"metrics\", metrics);\n\n        return map;\n    }","id":49444,"modified_method":"private Map<String, Object> toMap(Extractor extractor) {\n        Map<String, Object> map = Maps.newHashMap();\n\n        map.put(Extractor.FIELD_ID, extractor.getId());\n        map.put(Extractor.FIELD_TITLE, extractor.getTitle());\n        map.put(Extractor.FIELD_TYPE, extractor.getType().toString().toLowerCase());\n        map.put(Extractor.FIELD_CURSOR_STRATEGY, extractor.getCursorStrategy().toString().toLowerCase());\n        map.put(Extractor.FIELD_SOURCE_FIELD, extractor.getSourceField());\n        map.put(Extractor.FIELD_TARGET_FIELD, extractor.getTargetField());\n        map.put(Extractor.FIELD_EXTRACTOR_CONFIG, extractor.getExtractorConfig());\n        map.put(Extractor.FIELD_CREATOR_USER_ID, extractor.getCreatorUserId());\n        map.put(Extractor.FIELD_CONVERTERS, extractor.converterConfigMap());\n        map.put(Extractor.FIELD_CONDITION_TYPE, extractor.getConditionType().toString().toLowerCase());\n        map.put(Extractor.FIELD_CONDITION_VALUE, extractor.getConditionValue());\n        map.put(Extractor.FIELD_ORDER, extractor.getOrder());\n\n        map.put(\"exceptions\", extractor.getExceptionCount());\n        map.put(\"converter_exceptions\", extractor.getConverterExceptionCount());\n\n        Map<String, Object> metrics = Maps.newHashMap();\n        metrics.put(\"total\", buildTimerMap(metricRegistry.getTimers().get(extractor.getTotalTimerName())));\n        metrics.put(\"converters\", buildTimerMap(metricRegistry.getTimers().get(extractor.getConverterTimerName())));\n        map.put(\"metrics\", metrics);\n\n        return map;\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public Map<String, Object> getConfiguration() {\n        return (Map<String, Object>) fields.get(\"configuration\");\n    }","id":49445,"modified_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<String, Object> getConfiguration() {\n        return (Map<String, Object>) fields.get(MessageInput.FIELD_CONFIGURATION);\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public Map<String, Validator> getValidations() {\n        return new HashMap<String, Validator>() {{\n            put(\"input_id\", new FilledStringValidator());\n            put(\"title\", new FilledStringValidator());\n            put(\"type\", new FilledStringValidator());\n            put(\"configuration\", new MapValidator());\n            put(\"creator_user_id\", new FilledStringValidator());\n            put(\"created_at\", new DateValidator());\n        }};\n    }","id":49446,"modified_method":"@Override\n    public Map<String, Validator> getValidations() {\n        return new HashMap<String, Validator>() {{\n            put(MessageInput.FIELD_INPUT_ID, new FilledStringValidator());\n            put(MessageInput.FIELD_TITLE, new FilledStringValidator());\n            put(MessageInput.FIELD_TYPE, new FilledStringValidator());\n            put(MessageInput.FIELD_CONFIGURATION, new MapValidator());\n            put(MessageInput.FIELD_CREATOR_USER_ID, new FilledStringValidator());\n            put(MessageInput.FIELD_CREATED_AT, new DateValidator());\n        }};\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public String getCreatorUserId() {\n        return (String) fields.get(\"creator_user_id\");\n    }","id":49447,"modified_method":"@Override\n    public String getCreatorUserId() {\n        return (String) fields.get(MessageInput.FIELD_CREATOR_USER_ID);\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public Map<String, String> getStaticFields() {\n        Map<String, String> staticFields = Maps.newHashMap();\n\n        if (fields.get(EMBEDDED_STATIC_FIELDS) == null) {\n            return staticFields;\n        }\n\n        BasicDBList list = (BasicDBList) fields.get(EMBEDDED_STATIC_FIELDS);\n        Iterator<Object> iterator = list.iterator();\n        while (iterator.hasNext()) {\n            try {\n                DBObject field = (BasicDBObject) iterator.next();\n                staticFields.put((String) field.get(\"key\"), (String) field.get(\"value\"));\n            } catch (Exception e) {\n                LOG.error(\"Cannot build static field from persisted data. Skipping.\", e);\n                continue;\n            }\n        }\n\n        return staticFields;\n    }","id":49448,"modified_method":"@Override\n    public Map<String, String> getStaticFields() {\n        if (fields.get(EMBEDDED_STATIC_FIELDS) == null) {\n            return Collections.emptyMap();\n        }\n\n        final BasicDBList list = (BasicDBList) fields.get(EMBEDDED_STATIC_FIELDS);\n        final Map<String, String> staticFields = Maps.newHashMapWithExpectedSize(list.size());\n        for (final Object element : list) {\n            try {\n                final DBObject field = (DBObject) element;\n                staticFields.put((String) field.get(FIELD_STATIC_FIELD_KEY), (String) field.get(FIELD_STATIC_FIELD_VALUE));\n            } catch (Exception e) {\n                LOG.error(\"Cannot build static field from persisted data. Skipping.\", e);\n            }\n        }\n\n        return staticFields;\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public String getInputId() {\n        return (String) fields.get(\"input_id\");\n    }","id":49449,"modified_method":"@Override\n    public String getInputId() {\n        return (String) fields.get(MessageInput.FIELD_INPUT_ID);\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public Map<String, Validator> getEmbeddedValidations(String key) {\n        if (key.equals(EMBEDDED_EXTRACTORS)) {\n            return new HashMap<String, Validator>() {{\n                put(\"id\", new FilledStringValidator());\n                put(\"title\", new FilledStringValidator());\n                put(\"type\", new FilledStringValidator());\n                put(\"cursor_strategy\", new FilledStringValidator());\n                put(\"target_field\", new FilledStringValidator());\n                put(\"source_field\", new FilledStringValidator());\n                put(\"creator_user_id\", new FilledStringValidator());\n                put(\"extractor_config\", new MapValidator());\n            }};\n        }\n\n        if (key.equals(EMBEDDED_STATIC_FIELDS)) {\n            return new HashMap<String, Validator>() {{\n                put(\"key\", new FilledStringValidator());\n                put(\"value\", new FilledStringValidator());\n            }};\n        }\n\n        return Maps.newHashMap();\n    }","id":49450,"modified_method":"@Override\n    public Map<String, Validator> getEmbeddedValidations(String key) {\n        if (key.equals(EMBEDDED_EXTRACTORS)) {\n            return new HashMap<String, Validator>() {{\n                put(Extractor.FIELD_ID, new FilledStringValidator());\n                put(Extractor.FIELD_TITLE, new FilledStringValidator());\n                put(Extractor.FIELD_TYPE, new FilledStringValidator());\n                put(Extractor.FIELD_CURSOR_STRATEGY, new FilledStringValidator());\n                put(Extractor.FIELD_TARGET_FIELD, new FilledStringValidator());\n                put(Extractor.FIELD_SOURCE_FIELD, new FilledStringValidator());\n                put(Extractor.FIELD_CREATOR_USER_ID, new FilledStringValidator());\n                put(Extractor.FIELD_EXTRACTOR_CONFIG, new MapValidator());\n            }};\n        }\n\n        if (key.equals(EMBEDDED_STATIC_FIELDS)) {\n            return new HashMap<String, Validator>() {{\n                put(FIELD_STATIC_FIELD_KEY, new FilledStringValidator());\n                put(FIELD_STATIC_FIELD_VALUE, new FilledStringValidator());\n            }};\n        }\n\n        return Collections.emptyMap();\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public String getTitle() {\n        return (String) fields.get(\"title\");\n    }","id":49451,"modified_method":"@Override\n    public String getTitle() {\n        return (String) fields.get(MessageInput.FIELD_TITLE);\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public Boolean isGlobal() {\n        Object global = fields.get(\"global\");\n        if (global != null && global instanceof Boolean)\n            return (Boolean) global;\n        else\n            return false;\n    }","id":49452,"modified_method":"@Override\n    public Boolean isGlobal() {\n        final Object global = fields.get(MessageInput.FIELD_GLOBAL);\n        if (global instanceof Boolean) {\n            return (Boolean) global;\n        } else {\n            return false;\n        }\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public String getType() {\n        return (String) fields.get(\"type\");\n    }","id":49453,"modified_method":"@Override\n    public String getType() {\n        return (String) fields.get(MessageInput.FIELD_TYPE);\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public DateTime getCreatedAt() {\n        return new DateTime(fields.get(\"created_at\"));\n    }","id":49454,"modified_method":"@Override\n    public DateTime getCreatedAt() {\n        return new DateTime(fields.get(MessageInput.FIELD_CREATED_AT));\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public Input find(String id) throws NotFoundException {\n        DBObject o = get(org.graylog2.inputs.InputImpl.class, id);\n        if (o == null)\n            throw new NotFoundException(\"Input <\" + id + \"> not found!\");\n        return new org.graylog2.inputs.InputImpl((ObjectId) o.get(\"_id\"), o.toMap());\n    }","id":49455,"modified_method":"@Override\n    public Input find(String id) throws NotFoundException {\n        final DBObject o = get(org.graylog2.inputs.InputImpl.class, id);\n        if (o == null) {\n            throw new NotFoundException(\"Input <\" + id + \"> not found!\");\n        }\n        return new org.graylog2.inputs.InputImpl((ObjectId) o.get(\"_id\"), o.toMap());\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public Input findForThisRadioOrGlobal(final String radioId, String id) throws NotFoundException {\n        List<DBObject> query = new ArrayList<>();\n        query.add(new BasicDBObject(\"_id\", new ObjectId(id)));\n        List<DBObject> radioIdOrGlobal = new ArrayList<DBObject>() {{\n            add(new BasicDBObject(\"radio_id\", radioId));\n            add(new BasicDBObject(\"global\", true));\n        }};\n\n        query.add(new BasicDBObject(\"$or\", radioIdOrGlobal));\n\n        DBObject o = findOne(InputImpl.class, new BasicDBObject(\"$and\", query));\n\n        if (o == null)\n            throw new NotFoundException();\n        else\n            return new InputImpl((ObjectId) o.get(\"_id\"), o.toMap());\n    }","id":49456,"modified_method":"@Override\n    public Input findForThisRadioOrGlobal(final String radioId, String id) throws NotFoundException {\n        final List<DBObject> radioIdOrGlobal = ImmutableList.<DBObject>of(\n                new BasicDBObject(MessageInput.FIELD_RADIO_ID, radioId),\n                new BasicDBObject(MessageInput.FIELD_GLOBAL, true));\n\n        final List<DBObject> query = ImmutableList.<DBObject>of(\n                new BasicDBObject(\"_id\", new ObjectId(id)),\n                new BasicDBObject(\"$or\", radioIdOrGlobal));\n\n        final DBObject o = findOne(InputImpl.class, new BasicDBObject(\"$and\", query));\n        if (o == null) {\n            throw new NotFoundException();\n        } else {\n            return new InputImpl((ObjectId) o.get(\"_id\"), o.toMap());\n        }\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public List<Extractor> getExtractors(Input input) {\n        List<Extractor> extractors = Lists.newArrayList();\n\n        if (input.getFields().get(InputImpl.EMBEDDED_EXTRACTORS) == null) {\n            return extractors;\n        }\n\n        BasicDBList mEx = (BasicDBList) input.getFields().get(InputImpl.EMBEDDED_EXTRACTORS);\n        Iterator<Object> iterator = mEx.iterator();\n        while (iterator.hasNext()) {\n            DBObject ex = (BasicDBObject) iterator.next();\n\n            // SOFT MIGRATION: does this extractor have an order set? Implemented for issue: #726\n            Long order = new Long(0);\n            if (ex.containsField(\"order\")) {\n                order = (Long) ex.get(\"order\"); // mongodb driver gives us a java.lang.Long\n            }\n\n            try {\n                Extractor extractor = extractorFactory.factory(\n                        (String) ex.get(\"id\"),\n                        (String) ex.get(\"title\"),\n                        order.intValue(),\n                        Extractor.CursorStrategy.valueOf(((String) ex.get(\"cursor_strategy\")).toUpperCase()),\n                        Extractor.Type.valueOf(((String) ex.get(\"type\")).toUpperCase()),\n                        (String) ex.get(\"source_field\"),\n                        (String) ex.get(\"target_field\"),\n                        (Map<String, Object>) ex.get(\"extractor_config\"),\n                        (String) ex.get(\"creator_user_id\"),\n                        getConvertersOfExtractor(ex),\n                        Extractor.ConditionType.valueOf(((String) ex.get(\"condition_type\")).toUpperCase()),\n                        (String) ex.get(\"condition_value\")\n                );\n\n                extractors.add(extractor);\n            } catch (Exception e) {\n                LOG.error(\"Cannot build extractor from persisted data. Skipping.\", e);\n                continue;\n            }\n        }\n\n        return extractors;\n    }","id":49457,"modified_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    public List<Extractor> getExtractors(Input input) {\n        if (input.getFields().get(InputImpl.EMBEDDED_EXTRACTORS) == null) {\n            return Collections.emptyList();\n        }\n\n        final ImmutableList.Builder<Extractor> listBuilder = ImmutableList.builder();\n        final BasicDBList mEx = (BasicDBList) input.getFields().get(InputImpl.EMBEDDED_EXTRACTORS);\n        for (final Object element : mEx) {\n            final DBObject ex = (BasicDBObject) element;\n\n            // SOFT MIGRATION: does this extractor have an order set? Implemented for issue: #726\n            Long order = 0l;\n            if (ex.containsField(Extractor.FIELD_ORDER)) {\n                order = (Long) ex.get(Extractor.FIELD_ORDER); // mongodb driver gives us a java.lang.Long\n            }\n\n            try {\n                final Extractor extractor = extractorFactory.factory(\n                        (String) ex.get(Extractor.FIELD_ID),\n                        (String) ex.get(Extractor.FIELD_TITLE),\n                        order.intValue(),\n                        Extractor.CursorStrategy.valueOf(((String) ex.get(Extractor.FIELD_CURSOR_STRATEGY)).toUpperCase()),\n                        Extractor.Type.valueOf(((String) ex.get(Extractor.FIELD_TYPE)).toUpperCase()),\n                        (String) ex.get(Extractor.FIELD_SOURCE_FIELD),\n                        (String) ex.get(Extractor.FIELD_TARGET_FIELD),\n                        (Map<String, Object>) ex.get(Extractor.FIELD_EXTRACTOR_CONFIG),\n                        (String) ex.get(Extractor.FIELD_CREATOR_USER_ID),\n                        getConvertersOfExtractor(ex),\n                        Extractor.ConditionType.valueOf(((String) ex.get(Extractor.FIELD_CONDITION_TYPE)).toUpperCase()),\n                        (String) ex.get(Extractor.FIELD_CONDITION_VALUE)\n                );\n\n                listBuilder.add(extractor);\n            } catch (Exception e) {\n                LOG.error(\"Cannot build extractor from persisted data. Skipping.\", e);\n            }\n        }\n\n        return listBuilder.build();\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void addStaticField(Input input, final String key, final String value) throws ValidationException {\n        EmbeddedPersistable obj = new EmbeddedPersistable() {\n            @Override\n            public Map<String, Object> getPersistedFields() {\n                return new HashMap<String, Object>() {{\n                    put(\"key\", key);\n                    put(\"value\", value);\n                }};\n            }\n        };\n\n        embed(input, InputImpl.EMBEDDED_STATIC_FIELDS, obj);\n    }","id":49458,"modified_method":"@Override\n    public void addStaticField(Input input, final String key, final String value) throws ValidationException {\n        final EmbeddedPersistable obj = new EmbeddedPersistable() {\n            @Override\n            public Map<String, Object> getPersistedFields() {\n                return ImmutableMap.<String, Object>of(\n                        InputImpl.FIELD_STATIC_FIELD_KEY, key,\n                        InputImpl.FIELD_STATIC_FIELD_VALUE, value);\n            }\n        };\n\n        embed(input, InputImpl.EMBEDDED_STATIC_FIELDS, obj);\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public MessageInput buildMessageInput(Input io) throws NoSuchInputTypeException {\n        MessageInput input = messageInputFactory.create(io.getType());\n\n        // Add all standard fields.\n        input.setTitle(io.getTitle());\n        input.setCreatorUserId(io.getCreatorUserId());\n        input.setPersistId(io.getId());\n        input.setCreatedAt(io.getCreatedAt());\n        if (io.isGlobal())\n            input.setGlobal(true);\n\n        // Add extractors.\n        for (Extractor extractor : this.getExtractors(io)) {\n            input.addExtractor(extractor.getId(), extractor);\n        }\n\n        // Add static fields.\n        for (Map.Entry<String, String> field : io.getStaticFields().entrySet()) {\n            input.addStaticField(field.getKey(), field.getValue());\n        }\n\n        return input;\n    }","id":49459,"modified_method":"@Override\n    public MessageInput buildMessageInput(Input io) throws NoSuchInputTypeException {\n        final MessageInput input = messageInputFactory.create(io.getType());\n\n        // Add all standard fields.\n        input.setTitle(io.getTitle());\n        input.setCreatorUserId(io.getCreatorUserId());\n        input.setPersistId(io.getId());\n        input.setCreatedAt(io.getCreatedAt());\n        if (io.isGlobal()) {\n            input.setGlobal(true);\n        }\n\n        // Add extractors.\n        for (Extractor extractor : this.getExtractors(io)) {\n            input.addExtractor(extractor.getId(), extractor);\n        }\n\n        // Add static fields.\n        input.addStaticFields(io.getStaticFields());\n\n        return input;\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public List<Input> allOfThisNode(String nodeId) {\n        List<Input> inputs = Lists.newArrayList();\n        List<BasicDBObject> query = new ArrayList<BasicDBObject>();\n        query.add(new BasicDBObject(\"node_id\", nodeId));\n        query.add(new BasicDBObject(\"global\", true));\n        List<DBObject> ownInputs = query(org.graylog2.inputs.InputImpl.class, new BasicDBObject(\"$or\", query));\n        for (DBObject o : ownInputs) {\n            inputs.add(new org.graylog2.inputs.InputImpl((ObjectId) o.get(\"_id\"), o.toMap()));\n        }\n\n        return inputs;\n    }","id":49460,"modified_method":"@Override\n    public List<Input> allOfThisNode(final String nodeId) {\n        final List<BasicDBObject> query = ImmutableList.of(\n                new BasicDBObject(MessageInput.FIELD_NODE_ID, nodeId),\n                new BasicDBObject(MessageInput.FIELD_GLOBAL, true));\n        final List<DBObject> ownInputs = query(InputImpl.class, new BasicDBObject(\"$or\", query));\n\n        final ImmutableList.Builder<Input> inputs = ImmutableList.builder();\n        for (final DBObject o : ownInputs) {\n            inputs.add(new InputImpl((ObjectId) o.get(\"_id\"), o.toMap()));\n        }\n\n        return inputs.build();\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public MessageInput getMessageInput(Input io) throws NoSuchInputTypeException {\n        MessageInput input = buildMessageInput(io);\n        input.initialize(new Configuration(io.getConfiguration()));\n\n        return input;\n    }","id":49461,"modified_method":"@Override\n    public MessageInput getMessageInput(Input io) throws NoSuchInputTypeException {\n        final MessageInput input = buildMessageInput(io);\n        input.initialize(new Configuration(io.getConfiguration()));\n\n        return input;\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public Input findForThisNode(String nodeId, String id) throws NotFoundException, IllegalArgumentException {\n        List<BasicDBObject> query = new ArrayList<BasicDBObject>();\n        query.add(new BasicDBObject(\"_id\", new ObjectId(id)));\n\n        List<BasicDBObject> forThisNode = new ArrayList<BasicDBObject>();\n        forThisNode.add(new BasicDBObject(\"node_id\", nodeId));\n        forThisNode.add(new BasicDBObject(\"global\", false));\n\n        query.add(new BasicDBObject(\"$and\", forThisNode));\n\n        DBObject o = findOne(InputImpl.class, new BasicDBObject(\"$and\", query));\n\n        if (o == null)\n            throw new NotFoundException();\n        else\n            return new InputImpl((ObjectId) o.get(\"_id\"), o.toMap());\n    }","id":49462,"modified_method":"@Override\n    public Input findForThisNode(String nodeId, String id) throws NotFoundException, IllegalArgumentException {\n        final List<BasicDBObject> forThisNode = ImmutableList.of(\n                new BasicDBObject(MessageInput.FIELD_NODE_ID, nodeId),\n                new BasicDBObject(MessageInput.FIELD_GLOBAL, false));\n\n        final List<BasicDBObject> query = ImmutableList.of(\n                new BasicDBObject(\"_id\", new ObjectId(id)),\n                new BasicDBObject(\"$and\", forThisNode));\n\n        final DBObject o = findOne(InputImpl.class, new BasicDBObject(\"$and\", query));\n        if (o == null) {\n            throw new NotFoundException();\n        } else {\n            return new InputImpl((ObjectId) o.get(\"_id\"), o.toMap());\n        }\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public Input findForThisNodeOrGlobal(String nodeId, String id) throws NotFoundException {\n        List<BasicDBObject> query = new ArrayList<BasicDBObject>();\n        query.add(new BasicDBObject(\"_id\", new ObjectId(id)));\n\n        List<BasicDBObject> forThisNodeOrGlobal = new ArrayList<BasicDBObject>();\n        forThisNodeOrGlobal.add(new BasicDBObject(\"node_id\", nodeId));\n        forThisNodeOrGlobal.add(new BasicDBObject(\"global\", true));\n\n        query.add(new BasicDBObject(\"$or\", forThisNodeOrGlobal));\n\n        DBObject o = findOne(InputImpl.class, new BasicDBObject(\"$and\", query));\n\n        return new InputImpl((ObjectId) o.get(\"_id\"), o.toMap());\n    }","id":49463,"modified_method":"@Override\n    public Input findForThisNodeOrGlobal(String nodeId, String id) throws NotFoundException {\n        final List<BasicDBObject> forThisNodeOrGlobal = ImmutableList.of(\n                new BasicDBObject(MessageInput.FIELD_NODE_ID, nodeId),\n                new BasicDBObject(MessageInput.FIELD_GLOBAL, true));\n\n        final List<BasicDBObject> query = ImmutableList.of(\n                new BasicDBObject(\"_id\", new ObjectId(id)),\n                new BasicDBObject(\"$or\", forThisNodeOrGlobal));\n\n        final DBObject o = findOne(InputImpl.class, new BasicDBObject(\"$and\", query));\n        return new InputImpl((ObjectId) o.get(\"_id\"), o.toMap());\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public Input findForThisRadio(String radioId, String id) throws NotFoundException {\n        List<DBObject> query = new ArrayList<>();\n        query.add(new BasicDBObject(\"_id\", new ObjectId(id)));\n        query.add(new BasicDBObject(\"radio_id\", radioId));\n        List<Object> list = new ArrayList<Object>()\n        {{\n            add(false);\n            add(null);\n        }};\n        query.add(QueryBuilder.start(\"global\").in(list).get());\n\n        DBObject o = findOne(InputImpl.class, new BasicDBObject(\"$and\", query));\n\n        if (o == null)\n            throw new NotFoundException();\n        else\n            return new InputImpl((ObjectId) o.get(\"_id\"), o.toMap());\n    }","id":49464,"modified_method":"@Override\n    public Input findForThisRadio(String radioId, String id) throws NotFoundException {\n        final List<Object> list = new ArrayList<Object>() {{\n            add(false);\n            add(null);\n        }};\n\n        final List<DBObject> query = ImmutableList.of(\n                new BasicDBObject(\"_id\", new ObjectId(id)),\n                new BasicDBObject(MessageInput.FIELD_RADIO_ID, radioId),\n                QueryBuilder.start(MessageInput.FIELD_GLOBAL).in(list).get());\n\n        final DBObject o = findOne(InputImpl.class, new BasicDBObject(\"$and\", query));\n        if (o == null) {\n            throw new NotFoundException();\n        } else {\n            return new InputImpl((ObjectId) o.get(\"_id\"), o.toMap());\n        }\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public List<Input> allOfRadio(Node radio) {\n        List<Input> inputs = Lists.newArrayList();\n        List<BasicDBObject> query = Lists.newArrayList();\n        query.add(new BasicDBObject(\"radio_id\", radio.getNodeId()));\n        query.add(new BasicDBObject(\"global\", true));\n\n        for (DBObject o : query(InputImpl.class, new BasicDBObject(\"$or\", query))) {\n            inputs.add(new org.graylog2.inputs.InputImpl((ObjectId) o.get(\"_id\"), o.toMap()));\n        }\n\n        return inputs;\n    }","id":49465,"modified_method":"@Override\n    public List<Input> allOfRadio(Node radio) {\n        final List<BasicDBObject> query = ImmutableList.of(\n                new BasicDBObject(MessageInput.FIELD_RADIO_ID, radio.getNodeId()),\n                new BasicDBObject(MessageInput.FIELD_GLOBAL, true));\n\n        final ImmutableList.Builder<Input> inputs = ImmutableList.builder();\n        for (DBObject o : query(InputImpl.class, new BasicDBObject(\"$or\", query))) {\n            inputs.add(new InputImpl((ObjectId) o.get(\"_id\"), o.toMap()));\n        }\n\n        return inputs.build();\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private List<Converter> getConvertersOfExtractor(DBObject extractor) {\n        List<Converter> cl = Lists.newArrayList();\n\n        BasicDBList m = (BasicDBList) extractor.get(\"converters\");\n        Iterator<Object> iterator = m.iterator();\n        while (iterator.hasNext()) {\n            DBObject c = (BasicDBObject) iterator.next();\n\n            try {\n                cl.add(ConverterFactory.factory(\n                        Converter.Type.valueOf(((String) c.get(\"type\")).toUpperCase()),\n                        (Map<String, Object>) c.get(\"config\")\n                ));\n            } catch (ConverterFactory.NoSuchConverterException e1) {\n                LOG.error(\"Cannot build converter from persisted data. No such converter.\", e1);\n                continue;\n            } catch (Exception e) {\n                LOG.error(\"Cannot build converter from persisted data.\", e);\n                continue;\n            }\n        }\n\n        return cl;\n    }","id":49466,"modified_method":"@SuppressWarnings(\"unchecked\")\n    private List<Converter> getConvertersOfExtractor(DBObject extractor) {\n        final ImmutableList.Builder<Converter> listBuilder = ImmutableList.builder();\n\n        final BasicDBList converters = (BasicDBList) extractor.get(Extractor.FIELD_CONVERTERS);\n        for (final Object element : converters) {\n            final DBObject c = (BasicDBObject) element;\n\n            try {\n                listBuilder.add(ConverterFactory.factory(\n                        Converter.Type.valueOf(((String) c.get(Extractor.FIELD_CONVERTER_TYPE)).toUpperCase()),\n                        (Map<String, Object>) c.get(Extractor.FIELD_CONVERTER_CONFIG)\n                ));\n            } catch (ConverterFactory.NoSuchConverterException e1) {\n                LOG.error(\"Cannot build converter from persisted data. No such converter.\", e1);\n            } catch (Exception e) {\n                LOG.error(\"Cannot build converter from persisted data.\", e);\n            }\n        }\n\n        return listBuilder.build();\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void removeStaticField(Input input, String key) {\n        removeEmbedded(input, InputImpl.EMBEDDED_STATIC_FIELDS_KEY, InputImpl.EMBEDDED_STATIC_FIELDS, key);\n    }","id":49467,"modified_method":"@Override\n    public void removeStaticField(Input input, String key) {\n        removeEmbedded(input, InputImpl.FIELD_STATIC_FIELD_KEY, InputImpl.EMBEDDED_STATIC_FIELDS, key);\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public String getUniqueReadableId() {\n        String readableId = getClass().getName() + \".\" + getId();\n        return readableId;\n    }","id":49468,"modified_method":"public String getUniqueReadableId() {\n        return getClass().getName() + \".\" + getId();\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public long getRecvBufferSize() {\n        if (configuration.intIsSet(CK_RECV_BUFFER_SIZE)) {\n            return configuration.getInt(CK_RECV_BUFFER_SIZE);\n        }\n        return defaultRecvBufferSize;\n    }","id":49469,"modified_method":"public long getRecvBufferSize() {\n        return firstNonNull(configuration.getInt(CK_RECV_BUFFER_SIZE), defaultRecvBufferSize);\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public boolean equals(Object obj) {\n        if (obj instanceof MessageInput) {\n            MessageInput input = (MessageInput) obj;\n            return this.getPersistId().equals(input.getPersistId());\n        } else {\n            return false;\n        }\n    }","id":49470,"modified_method":"@Override\n    public boolean equals(final Object obj) {\n        if (obj instanceof MessageInput) {\n            final MessageInput input = (MessageInput) obj;\n            return this.getPersistId().equals(input.getPersistId());\n        } else {\n            return false;\n        }\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public Map<String, Object> asMap() {\n        Map<String, Object> inputMap = Maps.newHashMap();\n\n        inputMap.put(\"type\", this.getClass().getCanonicalName());\n        inputMap.put(\"input_id\", this.getId());\n        inputMap.put(\"persist_id\", this.getPersistId());\n        inputMap.put(\"name\", this.getName());\n        inputMap.put(\"title\", this.getTitle());\n        inputMap.put(\"creator_user_id\", this.getCreatorUserId());\n        inputMap.put(\"started_at\", Tools.getISO8601String(this.getCreatedAt()));\n        inputMap.put(\"attributes\", this.getAttributesWithMaskedPasswords());\n        inputMap.put(\"static_fields\", this.getStaticFields());\n        inputMap.put(\"global\", this.getGlobal());\n\n        return inputMap;\n    }","id":49471,"modified_method":"public Map<String, Object> asMap() {\n        final Map<String, Object> inputMap = Maps.newHashMap();\n\n        inputMap.put(FIELD_TYPE, this.getClass().getCanonicalName());\n        inputMap.put(FIELD_INPUT_ID, this.getId());\n        inputMap.put(FIELD_PERSIST_ID, this.getPersistId());\n        inputMap.put(FIELD_NAME, this.getName());\n        inputMap.put(FIELD_TITLE, this.getTitle());\n        inputMap.put(FIELD_CREATOR_USER_ID, this.getCreatorUserId());\n        inputMap.put(FIELD_STARTED_AT, Tools.getISO8601String(this.getCreatedAt()));\n        inputMap.put(FIELD_ATTRIBUTES, this.getAttributesWithMaskedPasswords());\n        inputMap.put(FIELD_STATIC_FIELDS, this.getStaticFields());\n        inputMap.put(FIELD_GLOBAL, this.getGlobal());\n\n        return inputMap;\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public Object getAttributesWithMaskedPasswords() {\n        Map<String, Object> result = Maps.newHashMap();\n\n        final ConfigurationRequest config = getRequestedConfiguration();\n        if (config == null) {\n            return result;\n        }\n\n        for(Map.Entry<String, Object> attribute : getAttributes().entrySet()) {\n            Object value = attribute.getValue();\n\n            final Map<String, Map<String, Object>> configAsList = config.asList();\n            final String attributeKey = attribute.getKey();\n            final Map<String, Object> attributesForConfigSetting = configAsList.get(attributeKey);\n            if (attributesForConfigSetting != null) {\n                // we know the config setting, check its attributes\n                final List<String> attributes = (List<String>) attributesForConfigSetting.get(\"attributes\");\n                if (attributes.contains(TextField.Attribute.IS_PASSWORD.toString().toLowerCase())) {\n                    value = \"********\";\n                }\n            } else {\n                // safety measure, although this is bad.\n                LOG.warn(\"Unknown input configuration setting {}={} found. Not trying to mask its value,\" +\n                                 \" though this is likely a bug.\", attribute, value);\n            }\n\n            result.put(attributeKey, value);\n        }\n\n        return result;\n    }","id":49472,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public Object getAttributesWithMaskedPasswords() {\n        final ConfigurationRequest config = getRequestedConfiguration();\n        if (config == null) {\n            return Collections.emptyMap();\n        }\n\n        final Map<String, Object> result = Maps.newHashMapWithExpectedSize(getAttributes().size());\n        for (Map.Entry<String, Object> attribute : getAttributes().entrySet()) {\n            Object value = attribute.getValue();\n\n            final Map<String, Map<String, Object>> configAsList = config.asList();\n            final Map<String, Object> attributesForConfigSetting = configAsList.get(attribute.getKey());\n\n            if (attributesForConfigSetting != null) {\n                // we know the config setting, check its attributes\n                final List<String> attributes = (List<String>) attributesForConfigSetting.get(\"attributes\");\n                if (attributes.contains(TextField.Attribute.IS_PASSWORD.toString().toLowerCase())) {\n                    value = \"********\";\n                }\n            } else {\n                // safety measure, although this is bad.\n                LOG.warn(\"Unknown input configuration setting {}={} found. Not trying to mask its value,\" +\n                        \" though this is likely a bug.\", attribute, value);\n            }\n\n            result.put(attribute.getKey(), value);\n        }\n\n        return result;\n    }","commit_id":"03927cbd2e58f2126539fd886be32b4658ab0c56","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n\t * Execute the given SQL script.\n\t * <p>Use with caution outside of a transaction!\n\t * <p>The script will normally be loaded by classpath. There should be one\n\t * statement per line. Any semicolons will be removed. <b>Do not use this\n\t * method to execute DDL if you expect rollback.<\/b>\n\t * @param sqlResourcePath the Spring resource path for the SQL script\n\t * @param continueOnError whether or not to continue without throwing an\n\t * exception in the event of an error\n\t * @throws DataAccessException if there is an error executing a statement\n\t * and continueOnError was {@code false}\n\t * @see JdbcTestUtils#executeSqlScript(JdbcTemplate, EncodedResource, boolean)\n\t * @see #setSqlScriptEncoding\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tprotected void executeSqlScript(String sqlResourcePath, boolean continueOnError) throws DataAccessException {\n\t\tResource resource = this.applicationContext.getResource(sqlResourcePath);\n\t\tJdbcTestUtils.executeSqlScript(this.jdbcTemplate, new EncodedResource(resource, this.sqlScriptEncoding),\n\t\t\tcontinueOnError);\n\t}","id":49473,"modified_method":"/**\n\t * Execute the given SQL script.\n\t * <p>Use with caution outside of a transaction!\n\t * <p>The script will normally be loaded by classpath.\n\t * <p><b>Do not use this method to execute DDL if you expect rollback.<\/b>\n\t * @param sqlResourcePath the Spring resource path for the SQL script\n\t * @param continueOnError whether or not to continue without throwing an\n\t * exception in the event of an error\n\t * @throws DataAccessException if there is an error executing a statement\n\t * @see ResourceDatabasePopulator\n\t * @see DatabasePopulatorUtils\n\t * @see #setSqlScriptEncoding\n\t */\n\tprotected void executeSqlScript(String sqlResourcePath, boolean continueOnError) throws DataAccessException {\n\t\tResource resource = this.applicationContext.getResource(sqlResourcePath);\n\t\tResourceDatabasePopulator databasePopulator = new ResourceDatabasePopulator();\n\t\tdatabasePopulator.setContinueOnError(continueOnError);\n\t\tdatabasePopulator.addScript(resource);\n\t\tdatabasePopulator.setSqlScriptEncoding(this.sqlScriptEncoding);\n\n\t\tDatabasePopulatorUtils.execute(databasePopulator, jdbcTemplate.getDataSource());\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Execute the given SQL script.\n\t * <p>Use with caution outside of a transaction!\n\t * <p>The script will normally be loaded by classpath. There should be one\n\t * statement per line. Any semicolons will be removed. <b>Do not use this\n\t * method to execute DDL if you expect rollback.<\/b>\n\t * @param sqlResourcePath the Spring resource path for the SQL script\n\t * @param continueOnError whether or not to continue without throwing an\n\t * exception in the event of an error\n\t * @throws DataAccessException if there is an error executing a statement\n\t * and continueOnError was {@code false}\n\t * @see JdbcTestUtils#executeSqlScript(JdbcTemplate, EncodedResource, boolean)\n\t * @see #setSqlScriptEncoding\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tprotected void executeSqlScript(String sqlResourcePath, boolean continueOnError) throws DataAccessException {\n\t\tResource resource = this.applicationContext.getResource(sqlResourcePath);\n\t\tJdbcTestUtils.executeSqlScript(this.jdbcTemplate, new EncodedResource(resource, this.sqlScriptEncoding),\n\t\t\tcontinueOnError);\n\t}","id":49474,"modified_method":"/**\n\t * Execute the given SQL script.\n\t * <p>Use with caution outside of a transaction!\n\t * <p>The script will normally be loaded by classpath.\n\t * <p><b>Do not use this method to execute DDL if you expect rollback.<\/b>\n\t * @param sqlResourcePath the Spring resource path for the SQL script\n\t * @param continueOnError whether or not to continue without throwing an\n\t * exception in the event of an error\n\t * @throws DataAccessException if there is an error executing a statement\n\t * @see ResourceDatabasePopulator\n\t * @see DatabasePopulatorUtils\n\t * @see #setSqlScriptEncoding\n\t */\n\tprotected void executeSqlScript(String sqlResourcePath, boolean continueOnError) throws DataAccessException {\n\t\tResource resource = this.applicationContext.getResource(sqlResourcePath);\n\t\tResourceDatabasePopulator databasePopulator = new ResourceDatabasePopulator();\n\t\tdatabasePopulator.setContinueOnError(continueOnError);\n\t\tdatabasePopulator.addScript(resource);\n\t\tdatabasePopulator.setSqlScriptEncoding(this.sqlScriptEncoding);\n\n\t\tDatabasePopulatorUtils.execute(databasePopulator, jdbcTemplate.getDataSource());\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Execute the given DatabasePopulator against the given DataSource.\n\t * @param populator the DatabasePopulator to execute\n\t * @param dataSource the DataSource to execute against\n\t */\n\tpublic static void execute(DatabasePopulator populator, DataSource dataSource) {\n\t\tAssert.notNull(populator, \"DatabasePopulator must be provided\");\n\t\tAssert.notNull(dataSource, \"DataSource must be provided\");\n\t\ttry {\n\t\t\tConnection connection = DataSourceUtils.getConnection(dataSource);\n\t\t\ttry {\n\t\t\t\tpopulator.populate(connection);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (connection != null) {\n\t\t\t\t\tDataSourceUtils.releaseConnection(connection, dataSource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new DataAccessResourceFailureException(\"Failed to execute database script\", ex);\n\t\t}\n\t}","id":49475,"modified_method":"/**\n\t * Execute the given {@link DatabasePopulator} against the given {@link DataSource}.\n\t * @param populator the {@code DatabasePopulator} to execute\n\t * @param dataSource the {@code DataSource} to execute against\n\t * @throws DataAccessException if an error occurs\n\t */\n\tpublic static void execute(DatabasePopulator populator, DataSource dataSource) throws DataAccessException {\n\t\tAssert.notNull(populator, \"DatabasePopulator must be provided\");\n\t\tAssert.notNull(dataSource, \"DataSource must be provided\");\n\t\ttry {\n\t\t\tConnection connection = DataSourceUtils.getConnection(dataSource);\n\t\t\ttry {\n\t\t\t\tpopulator.populate(connection);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (connection != null) {\n\t\t\t\t\tDataSourceUtils.releaseConnection(connection, dataSource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new DataAccessResourceFailureException(\"Failed to execute database script\", ex);\n\t\t}\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Execute the given SQL script.\n\t * <p>The script will typically be loaded from the classpath. There should\n\t * be one statement per line. Any semicolons and line comments will be removed.\n\t * <p><b>Do not use this method to execute DDL if you expect rollback.<\/b>\n\t * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @param continueOnError whether or not to continue without throwing an\n\t * exception in the event of an error\n\t * @throws DataAccessException if there is an error executing a statement\n\t * and {@code continueOnError} is {@code false}\n\t * @see ResourceDatabasePopulator\n\t * @deprecated as of Spring 4.0.3, in favor of using \n\t * {@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript(ScriptStatementExecutor, EncodedResource, boolean, boolean, String, String, String, String)}  \n\t */\n\t@Deprecated\n\tpublic static void executeSqlScript(JdbcTemplate jdbcTemplate, EncodedResource resource, boolean continueOnError)\n\t\t\tthrows DataAccessException {\n\t\tScriptUtils.executeSqlScript(new JdbcTemplateScriptStatementExecutor(jdbcTemplate), resource, \n\t\t\t\tcontinueOnError, continueOnError, ScriptUtils.DEFAULT_COMMENT_PREFIX,\n\t\t\t\tScriptUtils.DEFAULT_STATEMENT_SEPARATOR, ScriptUtils.DEFAULT_BLOCK_COMMENT_START_DELIMITER,\n\t\t\t\tScriptUtils.DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t}","id":49476,"modified_method":"/**\n\t * Execute the given SQL script.\n\t * <p>The script will typically be loaded from the classpath. There should\n\t * be one statement per line. Any semicolons and line comments will be removed.\n\t * <p><b>Do not use this method to execute DDL if you expect rollback.<\/b>\n\t * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @param continueOnError whether or not to continue without throwing an\n\t * exception in the event of an error\n\t * @throws DataAccessException if there is an error executing a statement\n\t * and {@code continueOnError} is {@code false}\n\t * @see ResourceDatabasePopulator\n\t * @see DatabasePopulatorUtils\n\t * @deprecated as of Spring 4.0.3, in favor of using\n\t * {@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}\n\t * or {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.\n\t */\n\t@Deprecated\n\tpublic static void executeSqlScript(JdbcTemplate jdbcTemplate, EncodedResource resource, boolean continueOnError)\n\t\t\tthrows DataAccessException {\n\t\tResourceDatabasePopulator databasePopulator = new ResourceDatabasePopulator();\n\t\tdatabasePopulator.setContinueOnError(continueOnError);\n\t\tdatabasePopulator.addScript(resource.getResource());\n\t\tdatabasePopulator.setSqlScriptEncoding(resource.getEncoding());\n\n\t\tDatabasePopulatorUtils.execute(databasePopulator, jdbcTemplate.getDataSource());\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Execute the given SQL script.\n\t * <p>The script will typically be loaded from the classpath. Statements\n\t * should be delimited with a semicolon. If statements are not delimited with\n\t * a semicolon then there should be one statement per line. Statements are\n\t * allowed to span lines only if they are delimited with a semicolon. Any\n\t * line comments will be removed.\n\t * <p><b>Do not use this method to execute DDL if you expect rollback.<\/b>\n\t * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations\n\t * @param resource the resource to load the SQL script from\n\t * @param continueOnError whether or not to continue without throwing an\n\t * exception in the event of an error\n\t * @throws DataAccessException if there is an error executing a statement\n\t * and {@code continueOnError} is {@code false}\n\t * @see ResourceDatabasePopulator\n\t * @see #executeSqlScript(JdbcTemplate, EncodedResource, boolean)\n\t * @deprecated as of Spring 4.0.3, in favor of using \n\t * {@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript(ScriptStatementExecutor, EncodedResource, boolean, boolean, String, String, String, String)}  \n\t */\n\t@Deprecated\n\tpublic static void executeSqlScript(JdbcTemplate jdbcTemplate, Resource resource, boolean continueOnError)\n\t\t\tthrows DataAccessException {\n\t\texecuteSqlScript(jdbcTemplate, new EncodedResource(resource), continueOnError);\n\t}","id":49477,"modified_method":"/**\n\t * Execute the given SQL script.\n\t * <p>The script will typically be loaded from the classpath. Statements\n\t * should be delimited with a semicolon. If statements are not delimited with\n\t * a semicolon then there should be one statement per line. Statements are\n\t * allowed to span lines only if they are delimited with a semicolon. Any\n\t * line comments will be removed.\n\t * <p><b>Do not use this method to execute DDL if you expect rollback.<\/b>\n\t * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations\n\t * @param resource the resource to load the SQL script from\n\t * @param continueOnError whether or not to continue without throwing an\n\t * exception in the event of an error\n\t * @throws DataAccessException if there is an error executing a statement\n\t * and {@code continueOnError} is {@code false}\n\t * @see ResourceDatabasePopulator\n\t * @see DatabasePopulatorUtils\n\t * @see #executeSqlScript(JdbcTemplate, EncodedResource, boolean)\n\t * @deprecated as of Spring 4.0.3, in favor of using\n\t * {@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}\n\t * or {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.\n\t */\n\t@Deprecated\n\tpublic static void executeSqlScript(JdbcTemplate jdbcTemplate, Resource resource, boolean continueOnError)\n\t\t\tthrows DataAccessException {\n\t\texecuteSqlScript(jdbcTemplate, new EncodedResource(resource), continueOnError);\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Determine if the provided SQL script contains the specified delimiter.\n\t * @param script the SQL script\n\t * @param delim character delimiting each statement &mdash; typically a ';' character\n\t * @return {@code true} if the script contains the delimiter; {@code false} otherwise\n\t * @deprecated as of Spring 4.0.3, in favor of using \n\t * {@link org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters(String, char)}  \n\t */\n\t@Deprecated\n\tpublic static boolean containsSqlScriptDelimiters(String script, char delim) {\n\t\treturn ScriptUtils.containsSqlScriptDelimiters(script, delim);\n\t}","id":49478,"modified_method":"/**\n\t * Determine if the provided SQL script contains the specified delimiter.\n\t * @param script the SQL script\n\t * @param delim character delimiting each statement &mdash; typically a ';' character\n\t * @return {@code true} if the script contains the delimiter; {@code false} otherwise\n\t * @deprecated as of Spring 4.0.3, in favor of using\n\t * {@link org.springframework.jdbc.datasource.init.ScriptUtils#containsSqlScriptDelimiters}\n\t */\n\t@Deprecated\n\tpublic static boolean containsSqlScriptDelimiters(String script, char delim) {\n\t\treturn ScriptUtils.containsSqlScriptDelimiters(script, String.valueOf(delim));\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Read a script from the provided {@code LineNumberReader}, using\n\t * \"{@code --}\" as the comment prefix, and build a {@code String} containing\n\t * the lines.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @return a {@code String} containing the script lines\n\t * @see #readScript(LineNumberReader, String)\n\t * @deprecated as of Spring 4.0.3, in favor of using \n\t * {@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader)}  \n\t */\n\t@Deprecated\n\tpublic static String readScript(LineNumberReader lineNumberReader) throws IOException {\n\t\treturn ScriptUtils.readScript(lineNumberReader);\n\t}","id":49479,"modified_method":"/**\n\t * Read a script from the provided {@code LineNumberReader}, using\n\t * \"{@code --}\" as the comment prefix, and build a {@code String} containing\n\t * the lines.\n\t * @param lineNumberReader the {@code LineNumberReader} containing the script\n\t * to be processed\n\t * @return a {@code String} containing the script lines\n\t * @see #readScript(LineNumberReader, String)\n\t * @deprecated as of Spring 4.0.3, in favor of using\n\t * {@link org.springframework.jdbc.datasource.init.ScriptUtils#readScript(LineNumberReader, String, String)}\n\t */\n\t@Deprecated\n\tpublic static String readScript(LineNumberReader lineNumberReader) throws IOException {\n\t\treturn readScript(lineNumberReader, ScriptUtils.DEFAULT_COMMENT_PREFIX);\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Execute the given SQL script.\n\t * <p>The script will typically be loaded from the classpath. There should\n\t * be one statement per line. Any semicolons and line comments will be removed.\n\t * <p><b>Do not use this method to execute DDL if you expect rollback.<\/b>\n\t * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations\n\t * @param resourceLoader the resource loader with which to load the SQL script\n\t * @param sqlResourcePath the Spring resource path for the SQL script\n\t * @param continueOnError whether or not to continue without throwing an\n\t * exception in the event of an error\n\t * @throws DataAccessException if there is an error executing a statement\n\t * and {@code continueOnError} is {@code false}\n\t * @see ResourceDatabasePopulator\n\t * @see #executeSqlScript(JdbcTemplate, Resource, boolean)\n\t * @deprecated as of Spring 4.0.3, in favor of using \n\t * {@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript(ScriptStatementExecutor, EncodedResource, boolean, boolean, String, String, String, String)}  \n\t */\n\t@Deprecated\n\tpublic static void executeSqlScript(JdbcTemplate jdbcTemplate, ResourceLoader resourceLoader,\n\t\t\tString sqlResourcePath, boolean continueOnError) throws DataAccessException {\n\t\tResource resource = resourceLoader.getResource(sqlResourcePath);\n\t\texecuteSqlScript(jdbcTemplate, resource, continueOnError);\n\t}","id":49480,"modified_method":"/**\n\t * Execute the given SQL script.\n\t * <p>The script will typically be loaded from the classpath. There should\n\t * be one statement per line. Any semicolons and line comments will be removed.\n\t * <p><b>Do not use this method to execute DDL if you expect rollback.<\/b>\n\t * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations\n\t * @param resourceLoader the resource loader with which to load the SQL script\n\t * @param sqlResourcePath the Spring resource path for the SQL script\n\t * @param continueOnError whether or not to continue without throwing an\n\t * exception in the event of an error\n\t * @throws DataAccessException if there is an error executing a statement\n\t * and {@code continueOnError} is {@code false}\n\t * @see ResourceDatabasePopulator\n\t * @see DatabasePopulatorUtils\n\t * @see #executeSqlScript(JdbcTemplate, Resource, boolean)\n\t * @deprecated as of Spring 4.0.3, in favor of using\n\t * {@link org.springframework.jdbc.datasource.init.ScriptUtils#executeSqlScript}\n\t * or {@link org.springframework.jdbc.datasource.init.ResourceDatabasePopulator}.\n\t */\n\t@Deprecated\n\tpublic static void executeSqlScript(JdbcTemplate jdbcTemplate, ResourceLoader resourceLoader,\n\t\t\tString sqlResourcePath, boolean continueOnError) throws DataAccessException {\n\t\tResource resource = resourceLoader.getResource(sqlResourcePath);\n\t\texecuteSqlScript(jdbcTemplate, resource, continueOnError);\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void populate(Connection connection) throws SQLException {\n\t\tStatement statement = null;\n\t\ttry {\n\t\t\tstatement = connection.createStatement();\n\t\t\tfinal Statement stmt = statement; \n\t\t\tfor (Resource script : this.scripts) {\n\t\t\t\tScriptUtils.executeSqlScript(\n\t\t\t\t\t\tnew ScriptStatementExecutor() {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic int executeScriptStatement(String statement) throws DataAccessException {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tstmt.execute(statement);\n\t\t\t\t\t\t\t\t\treturn stmt.getUpdateCount();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\t\t\t\tthrow new UncategorizedSQLException(getClass().getName(), statement, e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, \n\t\t\t\t\t\tapplyEncodingIfNecessary(script), this.continueOnError, this.ignoreFailedDrops, \n\t\t\t\t\t\tthis.commentPrefix, this.separator,\tthis.blockCommentStartDelimiter, \n\t\t\t\t\t\tthis.blockCommentEndDelimiter);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (statement != null) {\n\t\t\t\tstatement.close();\n\t\t\t}\n\t\t}\n\t}","id":49481,"modified_method":"@Override\n\tpublic void populate(Connection connection) throws SQLException {\n\t\tfor (Resource script : this.scripts) {\n\t\t\tScriptUtils.executeSqlScript(connection, applyEncodingIfNecessary(script), this.continueOnError,\n\t\t\t\tthis.ignoreFailedDrops, this.commentPrefix, this.separator, this.blockCommentStartDelimiter,\n\t\t\t\tthis.blockCommentEndDelimiter);\n\t\t}\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Set the block comment start delimiter in the SQL script.\n\t * Default is \"/*\"\n\t * @since 4.0.3\n\t */\n\tpublic void setBlockCommentStartDelimiter(String blockCommentStartDelimiter) {\n\t\tthis.blockCommentStartDelimiter = blockCommentStartDelimiter;\t\t\n\t}","id":49482,"modified_method":"/**\n\t * Set the start delimiter that identifies block comments within the SQL\n\t * scripts.\n\t * <p>Default is \"/*\".\n\t * @since 4.0.3\n\t * @see #setBlockCommentEndDelimiter\n\t */\n\tpublic void setBlockCommentStartDelimiter(String blockCommentStartDelimiter) {\n\t\tthis.blockCommentStartDelimiter = blockCommentStartDelimiter;\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Set the block comment end delimiter in the SQL script.\n\t * Default is \"*\\/\"\n\t * @since 4.0.3\n\t */\n\tpublic void setBlockCommentEndDelimiter(String blockCommentEndDelimiter) {\n\t\tthis.blockCommentEndDelimiter = blockCommentEndDelimiter;\n\t}","id":49483,"modified_method":"/**\n\t * Set the end delimiter that identifies block comments within the SQL\n\t * scripts.\n\t * <p>Default is \"*&#47;\".\n\t * @since 4.0.3\n\t * @see #setBlockCommentStartDelimiter\n\t */\n\tpublic void setBlockCommentEndDelimiter(String blockCommentEndDelimiter) {\n\t\tthis.blockCommentEndDelimiter = blockCommentEndDelimiter;\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Read a script from the provided resource, using the supplied\n\t * comment prefix and statement separator, and build a {@code String} containing the lines.\n\t * <p>Lines <em>beginning<\/em> with the comment prefix are excluded from the\n\t * results; however, line comments anywhere else &mdash; for example, within\n\t * a statement &mdash; will be included in the results.\n\t * @param resource the {@code EncodedResource} containing the script\n\t * to be processed\n\t * @param commentPrefix the prefix that identifies comments in the SQL script &mdash; typically \"--\"\n\t * @param separator the statement separator in the SQL script &mdash; typically \";\"\n\t * @return a {@code String} containing the script lines\n\t * @since 4.0.3\n\t */\n\tpublic static String readScript(EncodedResource resource, String commentPrefix, \n\t\t\tString separator) throws IOException {\n\t\tLineNumberReader lnr = new LineNumberReader(resource.getReader());\n\t\ttry {\n\t\t\treturn readScript(lnr, commentPrefix, separator);\n\t\t}\n\t\tfinally {\n\t\t\tlnr.close();\n\t\t}\n\t}","id":49484,"modified_method":"/**\n\t * Read a script from the provided resource, using the supplied\n\t * comment prefix and statement separator, and build a {@code String} containing\n\t * the lines.\n\t * <p>Lines <em>beginning<\/em> with the comment prefix are excluded from the\n\t * results; however, line comments anywhere else &mdash; for example, within\n\t * a statement &mdash; will be included in the results.\n\t * @param resource the {@code EncodedResource} containing the script\n\t * to be processed\n\t * @param commentPrefix the prefix that identifies comments in the SQL script &mdash;\n\t * typically \"--\"\n\t * @param separator the statement separator in the SQL script &mdash; typically \";\"\n\t * @return a {@code String} containing the script lines\n\t */\n\tprivate static String readScript(EncodedResource resource, String commentPrefix, String separator)\n\t\t\tthrows IOException {\n\t\tLineNumberReader lnr = new LineNumberReader(resource.getReader());\n\t\ttry {\n\t\t\treturn readScript(lnr, commentPrefix, separator);\n\t\t}\n\t\tfinally {\n\t\t\tlnr.close();\n\t\t}\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * delimiter string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within a statement, the provided {@code commentPrefix} will be honored;\n\t * any text beginning with the comment prefix and extending to the end of the\n\t * line will be omitted from the statement. In addition, multiple adjacent\n\t * whitespace characters will be collapsed into a single space.\n\t * @param script the SQL script\n\t * @param delim character delimiting each statement &mdash; typically a ';' character\n\t * @param commentPrefix the prefix that identifies line comments in the SQL script &mdash; typically \"--\"\n\t * @param statements the List that will contain the individual statements\n\t * @since 4.0.3\n\t */\n\tpublic static void splitSqlScript(String script, String delim, String commentPrefix, String blockCommentOpen,\n\t\t\tString blockCommentClose, List<String> statements) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean inLiteral = false;\n\t\tboolean inEscape = false;\n\t\tchar[] content = script.toCharArray();\n\t\tfor (int i = 0; i < script.length(); i++) {\n\t\t\tchar c = content[i];\n\t\t\tif (inEscape) {\n\t\t\t\tinEscape = false;\n\t\t\t\tsb.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// MySQL style escapes\n\t\t\tif (c == '\\\\') {\n\t\t\t\tinEscape = true;\n\t\t\t\tsb.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c == '\\'') {\n\t\t\t\tinLiteral = !inLiteral;\n\t\t\t}\n\t\t\tif (!inLiteral) {\n\t\t\t\tif (script.startsWith(delim, i)) {\n\t\t\t\t\t// we've reached the end of the current statement\n\t\t\t\t\tif (sb.length() > 0) {\n\t\t\t\t\t\tstatements.add(sb.toString());\n\t\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t\t}\n\t\t\t\t\ti += delim.length() - 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (script.startsWith(commentPrefix, i)) {\n\t\t\t\t\t// skip over any content from the start of the comment to the EOL\n\t\t\t\t\tint indexOfNextNewline = script.indexOf(\"\\n\", i);\n\t\t\t\t\tif (indexOfNextNewline > i) {\n\t\t\t\t\t\ti = indexOfNextNewline;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if there's no EOL, we must be at the end\n\t\t\t\t\t\t// of the script, so stop here.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (script.startsWith(blockCommentOpen, i)) {\n\t\t\t\t\t// skip over any block comments\n\t\t\t\t\tint indexOfCommentClose = script.indexOf(blockCommentClose, i);\n\t\t\t\t\tif (indexOfCommentClose > i) {\n\t\t\t\t\t\ti = indexOfCommentClose + blockCommentClose.length() - 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new BadSqlGrammarException(\"\", script.substring(i), \n\t\t\t\t\t\t\t\tnew SQLException(\"Missing block comment end delimiter\")); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (c == ' ' || c == '\\n' || c == '\\t') {\n\t\t\t\t\t// avoid multiple adjacent whitespace characters\n\t\t\t\t\tif (sb.length() > 0 && sb.charAt(sb.length() - 1) != ' ') {\n\t\t\t\t\t\tc = ' ';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(c);\n\t\t}\n\t\tif (StringUtils.hasText(sb)) {\n\t\t\tstatements.add(sb.toString());\n\t\t}\n\t}","id":49485,"modified_method":"/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * delimiter string. Each individual statement will be added to the provided\n\t * {@code List}.\n\t * <p>Within the script, the provided {@code commentPrefix} will be honored:\n\t * any text beginning with the comment prefix and extending to the end of the\n\t * line will be omitted from the output. Similarly, the provided\n\t * {@code blockCommentStartDelimiter} and {@code blockCommentEndDelimiter}\n\t * delimiters will be honored: any text enclosed in a block comment will be\n\t * omitted from the output. In addition, multiple adjacent whitespace characters\n\t * will be collapsed into a single space.\n\t * @param resource the resource from which the script was read\n\t * @param script the SQL script; never {@code null} or empty\n\t * @param delimiter text delimiting each statement &mdash; typically a ';'\n\t * character; never {@code null}\n\t * @param commentPrefix the prefix that identifies SQL line comments &mdash;\n\t * typically \"--\"; never {@code null} or empty\n\t * @param blockCommentStartDelimiter the <em>start<\/em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end<\/em> block comment delimiter;\n\t * never {@code null} or empty\n\t * @param statements the list that will contain the individual statements\n\t */\n\tpublic static void splitSqlScript(EncodedResource resource, String script, String delimiter, String commentPrefix,\n\t\t\tString blockCommentStartDelimiter, String blockCommentEndDelimiter, List<String> statements)\n\t\t\tthrows ScriptException {\n\n\t\tAssert.hasText(script, \"script must not be null or empty\");\n\t\tAssert.notNull(delimiter, \"delimiter must not be null\");\n\t\tAssert.hasText(commentPrefix, \"commentPrefix must not be null or empty\");\n\t\tAssert.hasText(blockCommentStartDelimiter, \"blockCommentStartDelimiter must not be null or empty\");\n\t\tAssert.hasText(blockCommentEndDelimiter, \"blockCommentEndDelimiter must not be null or empty\");\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean inLiteral = false;\n\t\tboolean inEscape = false;\n\t\tchar[] content = script.toCharArray();\n\t\tfor (int i = 0; i < script.length(); i++) {\n\t\t\tchar c = content[i];\n\t\t\tif (inEscape) {\n\t\t\t\tinEscape = false;\n\t\t\t\tsb.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// MySQL style escapes\n\t\t\tif (c == '\\\\') {\n\t\t\t\tinEscape = true;\n\t\t\t\tsb.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c == '\\'') {\n\t\t\t\tinLiteral = !inLiteral;\n\t\t\t}\n\t\t\tif (!inLiteral) {\n\t\t\t\tif (script.startsWith(delimiter, i)) {\n\t\t\t\t\t// we've reached the end of the current statement\n\t\t\t\t\tif (sb.length() > 0) {\n\t\t\t\t\t\tstatements.add(sb.toString());\n\t\t\t\t\t\tsb = new StringBuilder();\n\t\t\t\t\t}\n\t\t\t\t\ti += delimiter.length() - 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (script.startsWith(commentPrefix, i)) {\n\t\t\t\t\t// skip over any content from the start of the comment to the EOL\n\t\t\t\t\tint indexOfNextNewline = script.indexOf(\"\\n\", i);\n\t\t\t\t\tif (indexOfNextNewline > i) {\n\t\t\t\t\t\ti = indexOfNextNewline;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if there's no EOL, we must be at the end\n\t\t\t\t\t\t// of the script, so stop here.\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (script.startsWith(blockCommentStartDelimiter, i)) {\n\t\t\t\t\t// skip over any block comments\n\t\t\t\t\tint indexOfCommentEnd = script.indexOf(blockCommentEndDelimiter, i);\n\t\t\t\t\tif (indexOfCommentEnd > i) {\n\t\t\t\t\t\ti = indexOfCommentEnd + blockCommentEndDelimiter.length() - 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new ScriptParseException(String.format(\"Missing block comment end delimiter [%s].\",\n\t\t\t\t\t\t\tblockCommentEndDelimiter), resource);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (c == ' ' || c == '\\n' || c == '\\t') {\n\t\t\t\t\t// avoid multiple adjacent whitespace characters\n\t\t\t\t\tif (sb.length() > 0 && sb.charAt(sb.length() - 1) != ' ') {\n\t\t\t\t\t\tc = ' ';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(c);\n\t\t}\n\t\tif (StringUtils.hasText(sb)) {\n\t\t\tstatements.add(sb.toString());\n\t\t}\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Read a script from the given resource, using \"{@code --}\" as the comment prefix \n\t * and \"{@code ;} as the statement separator, and build a String containing the lines.\n\t * @param resource the {@code EncodedResource} to be read\n\t * @return {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t * @since 4.0.3\n\t */\n\tpublic static String readScript(EncodedResource resource) throws IOException {\n\t\tLineNumberReader lnr = new LineNumberReader(resource.getReader());\n\t\ttry {\n\t\t\treturn readScript(lnr, DEFAULT_COMMENT_PREFIX, DEFAULT_STATEMENT_SEPARATOR);\n\t\t}\n\t\tfinally {\n\t\t\tlnr.close();\n\t\t}\n\t}","id":49486,"modified_method":"/**\n\t * Read a script from the given resource, using \"{@code --}\" as the comment prefix\n\t * and \"{@code ;}\" as the statement separator, and build a String containing the lines.\n\t * @param resource the {@code EncodedResource} to be read\n\t * @return {@code String} containing the script lines\n\t * @throws IOException in case of I/O errors\n\t */\n\tstatic String readScript(EncodedResource resource) throws IOException {\n\t\treturn readScript(resource, DEFAULT_COMMENT_PREFIX, DEFAULT_STATEMENT_SEPARATOR);\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Execute the given SQL script.\n\t * <p>The script will normally be loaded by classpath. There should be one statement\n\t * per line. Any statement separators will be removed.\n\t * <p><b>Do not use this method to execute DDL if you expect rollback.<\/b>\n\t * @param executor the {@code ScriptStatementExecutor} with which to perform JDBC operations\n\t * @param resource the resource (potentially associated with a specific encoding) to load the SQL script from\n\t * @param continueOnError whether or not to continue without throwing an exception in the event of an error\n\t * @param ignoreFailedDrops whether of not to continue in the event of specifically an error on a {@code DROP}\n\t * @param commentPrefix the script line comment prefix\n\t * if not specified \n\t * @param separator the script statement separator, defaults to {@code DEFAUT_STATEMENT_SEPARATOR}\n\t * if not specified \n\t * @param blockCommentStartDelim the script block comment starting delimiter\n\t * @param blockCommentEndDelim the script block comment ending delimiter\n\t * @since 4.0.3\n\t */\n\tpublic static void executeSqlScript(ScriptStatementExecutor executor, EncodedResource resource, \n\t\t\tboolean continueOnError, boolean ignoreFailedDrops, String commentPrefix, String separator,\n\t\t\tString blockCommentStartDelim, String blockCommentEndDelim) throws DataAccessException {\n\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Executing SQL script from \" + resource);\n\t\t}\n\t\tlong startTime = System.currentTimeMillis();\n\t\tList<String> statements = new LinkedList<String>();\n\t\tString script;\n\t\ttry {\n\t\t\tscript = readScript(resource, commentPrefix, separator);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new CannotReadScriptException(resource, ex);\n\t\t}\n\t\tif (separator == null) {\n\t\t\tseparator = DEFAULT_STATEMENT_SEPARATOR;\n\t\t\tif (!containsSqlScriptDelimiters(script, separator)) {\n\t\t\t\tseparator = \"\\n\";\n\t\t\t}\n\t\t}\n\t\tsplitSqlScript(script, separator, commentPrefix, blockCommentStartDelim, blockCommentEndDelim, statements);\n\t\tint lineNumber = 0;\n\t\tfor (String statement : statements) {\n\t\t\tlineNumber++;\n\t\t\ttry {\n\t\t\t\tint rowsAffected = executor.executeScriptStatement(statement);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(rowsAffected + \" returned as updateCount for SQL: \" + statement);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (DataAccessException ex) {\n\t\t\t\tboolean dropStatement = StringUtils.startsWithIgnoreCase(statement.trim(), \"drop\");\n\t\t\t\tif (continueOnError || (dropStatement && ignoreFailedDrops)) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Failed to execute SQL script statement at line \" + lineNumber +\n\t\t\t\t\t\t\t\t\" of resource \" + resource + \": \" + statement, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new ScriptStatementFailedException(statement, lineNumber, resource, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong elapsedTime = System.currentTimeMillis() - startTime;\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Done executing SQL script from \" + resource + \" in \" + elapsedTime + \" ms.\");\n\t\t}\n\t}","id":49487,"modified_method":"/**\n\t * Execute the given SQL script.\n\t * <p>Statement separators and comments will be removed before executing\n\t * individual statements within the supplied script.\n\t * <p><b>Do not use this method to execute DDL if you expect rollback.<\/b>\n\t * @param connection the JDBC connection to use to execute the script; already\n\t * configured and ready to use\n\t * @param resource the resource (potentially associated with a specific encoding)\n\t * to load the SQL script from\n\t * @param continueOnError whether or not to continue without throwing an exception\n\t * in the event of an error\n\t * @param ignoreFailedDrops whether or not to continue in the event of specifically\n\t * an error on a {@code DROP} statement\n\t * @param commentPrefix the prefix that identifies comments in the SQL script &mdash;\n\t * typically \"--\"\n\t * @param separator the script statement separator; defaults to\n\t * {@value #DEFAULT_STATEMENT_SEPARATOR} if not specified\n\t * @param blockCommentStartDelimiter the <em>start<\/em> block comment delimiter; never\n\t * {@code null} or empty\n\t * @param blockCommentEndDelimiter the <em>end<\/em> block comment delimiter; never\n\t * {@code null} or empty\n\t */\n\tpublic static void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError,\n\t\t\tboolean ignoreFailedDrops, String commentPrefix, String separator, String blockCommentStartDelimiter,\n\t\t\tString blockCommentEndDelimiter) throws SQLException, ScriptException {\n\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Executing SQL script from \" + resource);\n\t\t}\n\t\tlong startTime = System.currentTimeMillis();\n\t\tList<String> statements = new LinkedList<String>();\n\t\tString script;\n\t\ttry {\n\t\t\tscript = readScript(resource, commentPrefix, separator);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new CannotReadScriptException(resource, ex);\n\t\t}\n\n\t\tif (separator == null) {\n\t\t\tseparator = DEFAULT_STATEMENT_SEPARATOR;\n\t\t\tif (!containsSqlScriptDelimiters(script, separator)) {\n\t\t\t\tseparator = \"\\n\";\n\t\t\t}\n\t\t}\n\n\t\tsplitSqlScript(resource, script, separator, commentPrefix, blockCommentStartDelimiter,\n\t\t\tblockCommentEndDelimiter, statements);\n\t\tint lineNumber = 0;\n\t\tStatement stmt = connection.createStatement();\n\t\ttry {\n\t\t\tfor (String statement : statements) {\n\t\t\t\tlineNumber++;\n\t\t\t\ttry {\n\t\t\t\t\tstmt.execute(statement);\n\t\t\t\t\tint rowsAffected = stmt.getUpdateCount();\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(rowsAffected + \" returned as updateCount for SQL: \" + statement);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (SQLException ex) {\n\t\t\t\t\tboolean dropStatement = StringUtils.startsWithIgnoreCase(statement.trim(), \"drop\");\n\t\t\t\t\tif (continueOnError || (dropStatement && ignoreFailedDrops)) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Failed to execute SQL script statement at line \" + lineNumber\n\t\t\t\t\t\t\t\t\t+ \" of resource \" + resource + \": \" + statement, ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new ScriptStatementFailedException(statement, lineNumber, resource, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tstmt.close();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.debug(\"Could not close JDBC Statement\", ex);\n\t\t\t}\n\t\t}\n\n\t\tlong elapsedTime = System.currentTimeMillis() - startTime;\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Executed SQL script from \" + resource + \" in \" + elapsedTime + \" ms.\");\n\t\t}\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * delimiter character. Each individual statement will be added to the\n\t * provided {@code List}.\n\t * <p>Within a statement, \"{@code --}\" will be used as the comment prefix;\n\t * any text beginning with the comment prefix and extending to the end of\n\t * the line will be omitted from the statement. In addition, multiple adjacent\n\t * whitespace characters will be collapsed into a single space.\n\t * @param script the SQL script\n\t * @param delim character delimiting each statement &mdash; typically a ';' character\n\t * @param statements the list that will contain the individual statements\n\t * @since 4.0.3\n\t */\n\tpublic static void splitSqlScript(String script, char delim, List<String> statements) {\n\t\tsplitSqlScript(script, String.valueOf(delim), DEFAULT_COMMENT_PREFIX, DEFAULT_BLOCK_COMMENT_START_DELIMITER,\n\t\t\t\tDEFAULT_BLOCK_COMMENT_END_DELIMITER, statements);\n\t}","id":49488,"modified_method":"/**\n\t * Split an SQL script into separate statements delimited by the provided\n\t * delimiter character. Each individual statement will be added to the\n\t * provided {@code List}.\n\t * <p>Within the script, {@value #DEFAULT_COMMENT_PREFIX} will be used as the\n\t * comment prefix; any text beginning with the comment prefix and extending to\n\t * the end of the line will be omitted from the output. Similarly,\n\t * {@value #DEFAULT_BLOCK_COMMENT_START_DELIMITER} and\n\t * {@value #DEFAULT_BLOCK_COMMENT_END_DELIMITER} will be used as the\n\t * <em>start<\/em> and <em>end<\/em> block comment delimiters: any text enclosed\n\t * in a block comment will be omitted from the output. In addition, multiple\n\t * adjacent whitespace characters will be collapsed into a single space.\n\t * @param script the SQL script\n\t * @param delimiter character delimiting each statement &mdash; typically a ';' character\n\t * @param statements the list that will contain the individual statements\n\t * @see #splitSqlScript(EncodedResource, String, String, String, String, String, List)\n\t */\n\tpublic static void splitSqlScript(String script, char delimiter, List<String> statements) throws ScriptException {\n\t\tsplitSqlScript(null, script, String.valueOf(delimiter), DEFAULT_COMMENT_PREFIX,\n\t\t\tDEFAULT_BLOCK_COMMENT_START_DELIMITER, DEFAULT_BLOCK_COMMENT_END_DELIMITER, statements);\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * See <a href=\"https://jira.springsource.org/browse/SPR-10330\">SPR-10330<\/a>\n\t */\n\t@Test\n\tpublic void readAndSplitScriptContainingCommentsWithLeadingTabs() throws Exception {\n\n\t\tEncodedResource resource = new EncodedResource(new ClassPathResource(\n\t\t\t\"test-data-with-comments-and-leading-tabs.sql\", getClass()));\n\t\tLineNumberReader lineNumberReader = new LineNumberReader(resource.getReader());\n\n\t\tString script = ScriptUtils.readScript(lineNumberReader);\n\n\t\tchar delim = ';';\n\t\tList<String> statements = new ArrayList<String>();\n\t\tScriptUtils.splitSqlScript(script, delim, statements);\n\n\t\tString statement1 = \"insert into customer (id, name) values (1, 'Sam Brannen')\";\n\t\tString statement2 = \"insert into orders(id, order_date, customer_id) values (1, '2013-06-08', 1)\";\n\t\tString statement3 = \"insert into orders(id, order_date, customer_id) values (2, '2013-06-08', 1)\";\n\n\t\tassertEquals(\"wrong number of statements\", 3, statements.size());\n\t\tassertEquals(\"statement 1 not split correctly\", statement1, statements.get(0));\n\t\tassertEquals(\"statement 2 not split correctly\", statement2, statements.get(1));\n\t\tassertEquals(\"statement 3 not split correctly\", statement3, statements.get(2));\n\t}","id":49489,"modified_method":"/**\n\t * See <a href=\"https://jira.springsource.org/browse/SPR-10330\">SPR-10330<\/a>\n\t */\n\t@Test\n\tpublic void readAndSplitScriptContainingCommentsWithLeadingTabs() throws Exception {\n\t\tEncodedResource resource = new EncodedResource(new ClassPathResource(\n\t\t\t\"test-data-with-comments-and-leading-tabs.sql\", getClass()));\n\n\t\tString script = ScriptUtils.readScript(resource);\n\n\t\tchar delim = ';';\n\t\tList<String> statements = new ArrayList<String>();\n\t\tScriptUtils.splitSqlScript(script, delim, statements);\n\n\t\tString statement1 = \"insert into customer (id, name) values (1, 'Sam Brannen')\";\n\t\tString statement2 = \"insert into orders(id, order_date, customer_id) values (1, '2013-06-08', 1)\";\n\t\tString statement3 = \"insert into orders(id, order_date, customer_id) values (2, '2013-06-08', 1)\";\n\n\t\tassertEquals(\"wrong number of statements\", 3, statements.size());\n\t\tassertEquals(\"statement 1 not split correctly\", statement1, statements.get(0));\n\t\tassertEquals(\"statement 2 not split correctly\", statement2, statements.get(1));\n\t\tassertEquals(\"statement 3 not split correctly\", statement3, statements.get(2));\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void assertUsersDatabaseCreated(String... lastNames) {\n\t\tfor (String lastName : lastNames) {\n\t\t\tassertThat(\"Did not find user with last name [\" + lastName + \"].\",\n\t\t\t\tjdbcTemplate.queryForObject(\"select count(0) from users where last_name = ?\", Integer.class, lastName),\n\t\t\t\tequalTo(1));\n\t\t}\n\t}","id":49490,"modified_method":"private void assertUsersDatabaseCreated(String... lastNames) {\n\t\tfinal JdbcTemplate jdbcTemplate = new JdbcTemplate(db);\n\t\tfor (String lastName : lastNames) {\n\t\t\tassertThat(\"Did not find user with last name [\" + lastName + \"].\",\n\t\t\t\tjdbcTemplate.queryForObject(\"select count(0) from users where last_name = ?\", Integer.class, lastName),\n\t\t\t\tequalTo(1));\n\t\t}\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void readAndSplitScriptContainingComments() throws Exception {\n\n\t\tEncodedResource resource = new EncodedResource(new ClassPathResource(\"test-data-with-comments.sql\", getClass()));\n\t\tLineNumberReader lineNumberReader = new LineNumberReader(resource.getReader());\n\n\t\tString script = ScriptUtils.readScript(lineNumberReader);\n\n\t\tchar delim = ';';\n\t\tList<String> statements = new ArrayList<String>();\n\t\tScriptUtils.splitSqlScript(script, delim, statements);\n\n\t\tString statement1 = \"insert into customer (id, name) values (1, 'Rod; Johnson'), (2, 'Adrian Collier')\";\n\t\tString statement2 = \"insert into orders(id, order_date, customer_id) values (1, '2008-01-02', 2)\";\n\t\tString statement3 = \"insert into orders(id, order_date, customer_id) values (1, '2008-01-02', 2)\";\n\t\t// Statement 4 addresses the error described in SPR-9982.\n\t\tString statement4 = \"INSERT INTO persons( person_id , name) VALUES( 1 , 'Name' )\";\n\n\t\tassertEquals(\"wrong number of statements\", 4, statements.size());\n\t\tassertEquals(\"statement 1 not split correctly\", statement1, statements.get(0));\n\t\tassertEquals(\"statement 2 not split correctly\", statement2, statements.get(1));\n\t\tassertEquals(\"statement 3 not split correctly\", statement3, statements.get(2));\n\t\tassertEquals(\"statement 4 not split correctly\", statement4, statements.get(3));\n\t}","id":49491,"modified_method":"@Test\n\tpublic void readAndSplitScriptContainingComments() throws Exception {\n\t\tEncodedResource resource = new EncodedResource(new ClassPathResource(\"test-data-with-comments.sql\", getClass()));\n\n\t\tString script = ScriptUtils.readScript(resource);\n\n\t\tchar delim = ';';\n\t\tList<String> statements = new ArrayList<String>();\n\t\tScriptUtils.splitSqlScript(script, delim, statements);\n\n\t\tString statement1 = \"insert into customer (id, name) values (1, 'Rod; Johnson'), (2, 'Adrian Collier')\";\n\t\tString statement2 = \"insert into orders(id, order_date, customer_id) values (1, '2008-01-02', 2)\";\n\t\tString statement3 = \"insert into orders(id, order_date, customer_id) values (1, '2008-01-02', 2)\";\n\t\t// Statement 4 addresses the error described in SPR-9982.\n\t\tString statement4 = \"INSERT INTO persons( person_id , name) VALUES( 1 , 'Name' )\";\n\n\t\tassertEquals(\"wrong number of statements\", 4, statements.size());\n\t\tassertEquals(\"statement 1 not split correctly\", statement1, statements.get(0));\n\t\tassertEquals(\"statement 2 not split correctly\", statement2, statements.get(1));\n\t\tassertEquals(\"statement 3 not split correctly\", statement3, statements.get(2));\n\t\tassertEquals(\"statement 4 not split correctly\", statement4, statements.get(3));\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void containsDelimiters() {\n\t\tassertTrue(\"test with ';' is wrong\", !ScriptUtils.containsSqlScriptDelimiters(\"select 1\\n select ';'\", ';'));\n\t\tassertTrue(\"test with delimiter ; is wrong\",\n\t\t\tScriptUtils.containsSqlScriptDelimiters(\"select 1; select 2\", ';'));\n\t\tassertTrue(\"test with '\\\\n' is wrong\",\n\t\t\t!ScriptUtils.containsSqlScriptDelimiters(\"select 1; select '\\\\n\\n';\", '\\n'));\n\t\tassertTrue(\"test with delimiter \\\\n is wrong\",\n\t\t\tScriptUtils.containsSqlScriptDelimiters(\"select 1\\n select 2\", '\\n'));\n\t}","id":49492,"modified_method":"@Test\n\tpublic void containsDelimiters() {\n\t\tassertTrue(\"test with ';' is wrong\", !ScriptUtils.containsSqlScriptDelimiters(\"select 1\\n select ';'\", \";\"));\n\t\tassertTrue(\"test with delimiter ; is wrong\", ScriptUtils.containsSqlScriptDelimiters(\"select 1; select 2\", \";\"));\n\t\tassertTrue(\"test with '\\\\n' is wrong\",\n\t\t\t!ScriptUtils.containsSqlScriptDelimiters(\"select 1; select '\\\\n\\n';\", \"\\n\"));\n\t\tassertTrue(\"test with delimiter \\\\n is wrong\",\n\t\t\tScriptUtils.containsSqlScriptDelimiters(\"select 1\\n select 2\", \"\\n\"));\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void executeSqlScript() throws SQLException {\n\t\tEncodedResource schemaResource = new EncodedResource(new ClassPathResource(\n\t\t\t\t\"users-schema.sql\", getClass()));\n\t\tEncodedResource commentResource = new EncodedResource(new ClassPathResource(\n\t\t\t\t\"test-data-with-multi-line-comments.sql\", getClass()));\n\t\tConnection connection = db.getConnection();\n\t\tStatement stmt = connection.createStatement();\n\t\tTestScriptStatementExecutor executor = new TestScriptStatementExecutor(stmt);\n\t\t\n\t\ttry {\n\t\t\tScriptUtils.executeSqlScript(executor, schemaResource, false, false, ScriptUtils.DEFAULT_COMMENT_PREFIX, \n\t\t\t\t\tScriptUtils.DEFAULT_STATEMENT_SEPARATOR, ScriptUtils.DEFAULT_BLOCK_COMMENT_START_DELIMITER,\n\t\t\t\t\tScriptUtils.DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t\t\tScriptUtils.executeSqlScript(executor, commentResource, false, false, ScriptUtils.DEFAULT_COMMENT_PREFIX, \n\t\t\t\t\tScriptUtils.DEFAULT_STATEMENT_SEPARATOR, ScriptUtils.DEFAULT_BLOCK_COMMENT_START_DELIMITER,\n\t\t\t\t\tScriptUtils.DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t\t}\n\t\tfinally {\n\t\t\tstmt.close();\n\t\t\tconnection.close();\n\t\t}\n\t\t\n\t\tassertUsersDatabaseCreated(\"Hoeller\", \"Brannen\");\n\t}","id":49493,"modified_method":"@Test\n\tpublic void executeSqlScript() throws SQLException {\n\t\tEncodedResource schemaResource = new EncodedResource(new ClassPathResource(\"users-schema.sql\", getClass()));\n\t\tEncodedResource commentResource = new EncodedResource(new ClassPathResource(\n\t\t\t\"test-data-with-multi-line-comments.sql\", getClass()));\n\t\tConnection connection = db.getConnection();\n\n\t\tScriptUtils.executeSqlScript(connection, schemaResource, false, false, ScriptUtils.DEFAULT_COMMENT_PREFIX,\n\t\t\tScriptUtils.DEFAULT_STATEMENT_SEPARATOR, ScriptUtils.DEFAULT_BLOCK_COMMENT_START_DELIMITER,\n\t\t\tScriptUtils.DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\t\tScriptUtils.executeSqlScript(connection, commentResource, false, false, ScriptUtils.DEFAULT_COMMENT_PREFIX,\n\t\t\tScriptUtils.DEFAULT_STATEMENT_SEPARATOR, ScriptUtils.DEFAULT_BLOCK_COMMENT_START_DELIMITER,\n\t\t\tScriptUtils.DEFAULT_BLOCK_COMMENT_END_DELIMITER);\n\n\t\tassertUsersDatabaseCreated(\"Hoeller\", \"Brannen\");\n\t}","commit_id":"2bfd6ddcf4de600942a7564a43a338febd4267f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void updateOSMFile(String pathToOsmFile, String pathToModifiedFile, boolean show) throws IOException, SAXException, XMLStreamException, JSONException{\n\t\tOsmBaseStorage storage = new OsmBaseStorage();\n\t\tfinal Map<String, EntityId> winkelNumbers = new LinkedHashMap<String, EntityId>();\n\t\t\n\t\tstorage.getFilters().add(new IOsmStorageFilter(){\n\n\t\t\t@Override\n\t\t\tpublic boolean acceptEntityToLoad(OsmBaseStorage storage, EntityId entityId, Entity entity) {\n\t\t\t\tif(entity.getTag(\"winkelnummer\") !=null && entity.getTag(\"name\").contains(\"eijn\")){\n\t\t\t\t\twinkelNumbers.put(entity.getTag(\"winkelnummer\"), entityId);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// register all nodes in order to operate with ways\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t});\n\t\tstorage.parseOSM(new FileInputStream(pathToOsmFile), new ConsoleProgressImplementation(2), null, true);\n\t\tMap<String, Map<String, Object>> supermarkets = getSupermarkets();\n\t\t\n\t\tDataTileManager<Entity> deleted = new DataTileManager<Entity>();\n\t\t\n\t\tfor(String s : winkelNumbers.keySet()){\n\t\t\tif(!supermarkets.containsKey(s)){\n\t\t\t\tSystem.err.println(\"Shop \" + s + \" id=\" +winkelNumbers.get(s) + \" doesn't present on the site.\");\n\t\t\t\tEntityId e = winkelNumbers.get(s);\n\t\t\t\tEntity en = storage.getRegisteredEntities().get(e);\n\t\t\t\tdeleted.registerObject(en.getLatLon().getLatitude(), en.getLatLon().getLongitude(), \n\t\t\t\t\t\ten);\n\t\t\t}\n\t\t}\n\t\t\n\t\tDataTileManager<Entity> notCorrelated = new DataTileManager<Entity>();\n\t\tDataTileManager<Entity> notShown = new DataTileManager<Entity>();\n\t\t\n\t\tfor(String s : supermarkets.keySet()){\n\t\t\tMap<String, Object> props = supermarkets.get(s);\n\t\t\tif(winkelNumbers.get(s) != null){\n\t\t\t\tEntityId id = winkelNumbers.get(s);\n\t\t\t\tEntity e = storage.getRegisteredEntities().get(id);\n\t\t\t\tEntityInfo info = storage.getRegisteredEntityInfo().get(id);\n\t\t\t\tMap<String, String> newTags = new LinkedHashMap<String, String>();\n\t\t\t\tString p = props.get(\"format\")+\"\";\n\t\t\t\t//IMPORTANT : comment what information should be updated or check\n\t\t\t\tString name = \"Albert Heijn\";\n\t\t\t\tif(!p.equals(\"AH\")){\n\t\t\t\t\tname += \" \" + p;\n\t\t\t\t}\n\t\t\t\tnewTags.put(\"name\", name);\n\t\t\t\tnewTags.put(\"phone\", props.get(\"phone\")+\"\");\n\t\t\t\tnewTags.put(\"addr:city\", props.get(\"city\")+\"\");\n\t\t\t\tnewTags.put(\"addr:street\", props.get(\"street\")+\"\");\n\t\t\t\tnewTags.put(\"addr:housenumber\", props.get(\"housenr\")+\"\");\n\t\t\t\tnewTags.put(\"addr:postcode\", props.get(\"zip\")+\"\");\n\t\t\t\t\n\t\t\t\tJSONArray o = (JSONArray) props.get(\"hours\");\n\t\t\t\tList<OpeningHoursParser.OpeningHoursRule> rules = new ArrayList<OpeningHoursRule>();\n\t\t\t\tBasicDayOpeningHourRule prev = null;\n\t\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t\tJSONObject obj = o.getJSONObject(i);\n\t\t\t\t\t\n\t\t\t\t\tif(!obj.isNull(\"C\") && obj.getBoolean(\"C\")){\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString opened  = obj.get(\"F\")+\"\";\n\t\t\t\t\t\tString closed = obj.get(\"U\")+\"\";\n\t\t\t\t\t\tint start = Integer.parseInt(opened.substring(0, 2)) * 60 + Integer.parseInt(opened.substring(2));\n\t\t\t\t\t\tint end = Integer.parseInt(closed.substring(0, 2)) * 60 + Integer.parseInt(closed.substring(2));\n\t\t\t\t\t\tif(prev != null && prev.getStartTime() == start && prev.getEndTime() == end){\n\t\t\t\t\t\t\tprev.getDays()[i] = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tBasicDayOpeningHourRule rule = new OpeningHoursParser.BasicDayOpeningHourRule();\n\t\t\t\t\t\t\trule.getDays()[i] = true;\n\t\t\t\t\t\t\trule.setStartTime(start);\n\t\t\t\t\t\t\trule.setEndTime(end);\n\t\t\t\t\t\t\tprev = rule;\n\t\t\t\t\t\t\trules.add(rule);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tnewTags.put(\"opening_hours\", OpeningHoursParser.toStringOpenedHours(rules));\n\t\t\t\t\n\t\t\t\t// Check distance to info\n\t\t\t\tLatLon real = new LatLon((Double)props.get(\"lat\"), (Double) props.get(\"lng\"));\n\t\t\t\tdouble dist = MapUtils.getDistance(e.getLatLon(), real);\n\t\t\t\tif(dist > 150){\n\t\t\t\t\t// TODO move shop ?\n\t\t\t\t\tSystem.err.println(\"Winkel number = \" + s + \" is too far from site info - \" + dist + \" m !!! \" + real);\n\t\t\t\t\tif(dist > 300){\n\t\t\t\t\t\tnotCorrelated.registerObject(real.getLatitude(), real.getLongitude(), e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean changed = false;\n\t\t\t\tfor(String k : newTags.keySet()){\n\t\t\t\t\tString val = newTags.get(k);\n\t\t\t\t\tif(!Algoritms.objectEquals(val, e.getTag(k))){\n\t\t\t\t\t\te.putTag(k, val);\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(changed){\n\t\t\t\t\tinfo.setAction(\"modify\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// TODO?\n\t\t\t\tLatLon real = new LatLon((Double)props.get(\"lat\"), (Double) props.get(\"lng\"));\n\t\t\t\tSystem.err.println(\"Winkel number = \" + s + \" is not found in database !!! \" + real);\n\t\t\t\tNode n = new Node(real.getLatitude(), real.getLongitude(), -1);\n\t\t\t\tn.putTag(\"winkelnummer\", \"REG : \" + s);\n\t\t\t\tnotShown.registerObject(real.getLatitude(), real.getLongitude(), n);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tOsmStorageWriter writer = new OsmStorageWriter();\n\t\twriter.saveStorage(new FileOutputStream(pathToModifiedFile), storage, null, true);\n\t\tif(show){\n\t\t\ttry {\n\t\t\t\tUIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\tfinal MapPanel panel = new MapPanel(DataExtractionSettings.getSettings().getTilesDirectory());\n\t\t\tpanel.setFocusable(true);\n\t\t\tMapPointsLayer toAdd = panel.getLayer(MapPointsLayer.class);\n\t\t\ttoAdd.setPoints(notShown);\n\t\t\ttoAdd.setPointSize(5);\n\t\t\ttoAdd.setTagToShow(\"winkelnummer\");\n\t\t\t\n\t\t\t\n\t\t\tMapPointsLayer red = new MapPointsLayer();\n\t\t\tred.setPoints(deleted);\n\t\t\tred.setColor(Color.red);\n\t\t\tred.setPointSize(5);\n\t\t\tpanel.addLayer(red);\n\t\t\t\n\t\t\tMapPointsLayer blue = new MapPointsLayer();\n\t\t\tblue.setPoints(notCorrelated);\n\t\t\tblue.setColor(Color.blue);\n\t\t\tblue.setPointSize(4);\n\t\t\tpanel.addLayer(blue);\n\t\t\t\n\t\t\t\n\t\t\tJFrame frame = new JFrame(\"Map view\");\n\t\t    \n\t\t\t\n\t\t    frame.addWindowListener(new WindowAdapter(){\n\t\t    \t@Override\n\t\t    \tpublic void windowClosing(WindowEvent e) {\n\t\t    \t\tDataExtractionSettings settings = DataExtractionSettings.getSettings();\n\t\t\t\t\tsettings.saveDefaultLocation(panel.getLatitude(), panel.getLongitude());\n\t\t\t\t\tsettings.saveDefaultZoom(panel.getZoom());\n\t\t    \t\tSystem.exit(0);\n\t\t    \t}\n\t\t    });\n\t\t    Container content = frame.getContentPane();\n\t\t    content.add(panel, BorderLayout.CENTER);\n\n\t\t    JMenuBar bar = new JMenuBar();\n\t\t    bar.add(MapPanel.getMenuToChooseSource(panel));\n\t\t    frame.setJMenuBar(bar);\n\t\t    frame.setSize(512, 512);\n\t\t    frame.setVisible(true);\n\t\t\t\n\t\t}\n\t}","id":49494,"modified_method":"public void updateOSMFile(String pathToOsmFile, String pathToModifiedFile, boolean show) throws IOException, SAXException, XMLStreamException, JSONException{\n\t\tOsmBaseStorage storage = new OsmBaseStorage();\n\t\tfinal Map<String, EntityId> winkelNumbers = new LinkedHashMap<String, EntityId>();\n\t\t\n\t\tstorage.getFilters().add(new IOsmStorageFilter(){\n\n\t\t\t@Override\n\t\t\tpublic boolean acceptEntityToLoad(OsmBaseStorage storage, EntityId entityId, Entity entity) {\n\t\t\t\tif(entity.getTag(\"winkelnummer\") !=null && entity.getTag(\"name\").contains(\"eijn\")){\n\t\t\t\t\twinkelNumbers.put(entity.getTag(\"winkelnummer\"), entityId);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// register all nodes in order to operate with ways\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t});\n\t\tstorage.parseOSM(new FileInputStream(pathToOsmFile), new ConsoleProgressImplementation(2), null, true);\n\t\tMap<String, Map<String, Object>> supermarkets = getSupermarkets();\n\t\t\n\t\tDataTileManager<Entity> deleted = new DataTileManager<Entity>();\n\t\t\n\t\tfor(String s : winkelNumbers.keySet()){\n\t\t\tif(!supermarkets.containsKey(s)){\n\t\t\t\tSystem.err.println(\"Shop \" + s + \" id=\" +winkelNumbers.get(s) + \" doesn't present on the site.\");\n\t\t\t\tEntityId e = winkelNumbers.get(s);\n\t\t\t\tEntity en = storage.getRegisteredEntities().get(e);\n\t\t\t\tdeleted.registerObject(en.getLatLon().getLatitude(), en.getLatLon().getLongitude(), \n\t\t\t\t\t\ten);\n\t\t\t}\n\t\t}\n\t\t\n\t\tDataTileManager<Entity> notCorrelated = new DataTileManager<Entity>();\n\t\tDataTileManager<Entity> notShown = new DataTileManager<Entity>();\n\t\t\n\t\tfor(String s : supermarkets.keySet()){\n\t\t\tMap<String, Object> props = supermarkets.get(s);\n\t\t\tif(winkelNumbers.get(s) != null){\n\t\t\t\tEntityId id = winkelNumbers.get(s);\n\t\t\t\tEntity e = storage.getRegisteredEntities().get(id);\n\t\t\t\tEntityInfo info = storage.getRegisteredEntityInfo().get(id);\n\t\t\t\tMap<String, String> newTags = new LinkedHashMap<String, String>();\n\t\t\t\tString p = props.get(\"format\")+\"\";\n\t\t\t\t//IMPORTANT : comment what information should be updated or check\n\t\t\t\tString name = \"Albert Heijn\";\n\t\t\t\tif(!p.equals(\"AH\")){\n\t\t\t\t\tname += \" \" + p;\n\t\t\t\t}\n\t\t\t\tnewTags.put(\"name\", name);\n\t\t\t\tnewTags.put(\"phone\", props.get(\"phone\")+\"\");\n\t\t\t\tnewTags.put(\"addr:city\", props.get(\"city\")+\"\");\n\t\t\t\tnewTags.put(\"addr:street\", props.get(\"street\")+\"\");\n\t\t\t\tnewTags.put(\"addr:housenumber\", props.get(\"housenr\")+\"\");\n\t\t\t\tnewTags.put(\"addr:postcode\", props.get(\"zip\")+\"\");\n\t\t\t\t\n\t\t\t\tJSONArray o = (JSONArray) props.get(\"hours\");\n\t\t\t\tList<OpeningHoursParser.OpeningHoursRule> rules = new ArrayList<OpeningHoursRule>();\n\t\t\t\tBasicDayOpeningHourRule prev = null;\n\t\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t\tJSONObject obj = o.getJSONObject(i);\n\t\t\t\t\t\n\t\t\t\t\tif(!obj.isNull(\"C\") && obj.getBoolean(\"C\")){\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString opened  = obj.get(\"F\")+\"\";\n\t\t\t\t\t\tString closed = obj.get(\"U\")+\"\";\n\t\t\t\t\t\tint start = Integer.parseInt(opened.substring(0, 2)) * 60 + Integer.parseInt(opened.substring(2));\n\t\t\t\t\t\tint end = Integer.parseInt(closed.substring(0, 2)) * 60 + Integer.parseInt(closed.substring(2));\n\t\t\t\t\t\tif(prev != null && prev.getStartTime(0) == start && prev.getEndTime(0) == end){\n\t\t\t\t\t\t\tprev.getDays()[i] = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tBasicDayOpeningHourRule rule = new OpeningHoursParser.BasicDayOpeningHourRule();\n\t\t\t\t\t\t\trule.getDays()[i] = true;\n\t\t\t\t\t\t\trule.setStartEndTime(start, end);\n\t\t\t\t\t\t\tprev = rule;\n\t\t\t\t\t\t\trules.add(rule);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tnewTags.put(\"opening_hours\", OpeningHoursParser.toStringOpenedHours(rules));\n\t\t\t\t\n\t\t\t\t// Check distance to info\n\t\t\t\tLatLon real = new LatLon((Double)props.get(\"lat\"), (Double) props.get(\"lng\"));\n\t\t\t\tdouble dist = MapUtils.getDistance(e.getLatLon(), real);\n\t\t\t\tif(dist > 150){\n\t\t\t\t\t// TODO move shop ?\n\t\t\t\t\tSystem.err.println(\"Winkel number = \" + s + \" is too far from site info - \" + dist + \" m !!! \" + real);\n\t\t\t\t\tif(dist > 300){\n\t\t\t\t\t\tnotCorrelated.registerObject(real.getLatitude(), real.getLongitude(), e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean changed = false;\n\t\t\t\tfor(String k : newTags.keySet()){\n\t\t\t\t\tString val = newTags.get(k);\n\t\t\t\t\tif(!Algoritms.objectEquals(val, e.getTag(k))){\n\t\t\t\t\t\te.putTag(k, val);\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(changed){\n\t\t\t\t\tinfo.setAction(\"modify\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// TODO?\n\t\t\t\tLatLon real = new LatLon((Double)props.get(\"lat\"), (Double) props.get(\"lng\"));\n\t\t\t\tSystem.err.println(\"Winkel number = \" + s + \" is not found in database !!! \" + real);\n\t\t\t\tNode n = new Node(real.getLatitude(), real.getLongitude(), -1);\n\t\t\t\tn.putTag(\"winkelnummer\", \"REG : \" + s);\n\t\t\t\tnotShown.registerObject(real.getLatitude(), real.getLongitude(), n);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tOsmStorageWriter writer = new OsmStorageWriter();\n\t\twriter.saveStorage(new FileOutputStream(pathToModifiedFile), storage, null, true);\n\t\tif(show){\n\t\t\ttry {\n\t\t\t\tUIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\tfinal MapPanel panel = new MapPanel(DataExtractionSettings.getSettings().getTilesDirectory());\n\t\t\tpanel.setFocusable(true);\n\t\t\tMapPointsLayer toAdd = panel.getLayer(MapPointsLayer.class);\n\t\t\ttoAdd.setPoints(notShown);\n\t\t\ttoAdd.setPointSize(5);\n\t\t\ttoAdd.setTagToShow(\"winkelnummer\");\n\t\t\t\n\t\t\t\n\t\t\tMapPointsLayer red = new MapPointsLayer();\n\t\t\tred.setPoints(deleted);\n\t\t\tred.setColor(Color.red);\n\t\t\tred.setPointSize(5);\n\t\t\tpanel.addLayer(red);\n\t\t\t\n\t\t\tMapPointsLayer blue = new MapPointsLayer();\n\t\t\tblue.setPoints(notCorrelated);\n\t\t\tblue.setColor(Color.blue);\n\t\t\tblue.setPointSize(4);\n\t\t\tpanel.addLayer(blue);\n\t\t\t\n\t\t\t\n\t\t\tJFrame frame = new JFrame(\"Map view\");\n\t\t    \n\t\t\t\n\t\t    frame.addWindowListener(new WindowAdapter(){\n\t\t    \t@Override\n\t\t    \tpublic void windowClosing(WindowEvent e) {\n\t\t    \t\tDataExtractionSettings settings = DataExtractionSettings.getSettings();\n\t\t\t\t\tsettings.saveDefaultLocation(panel.getLatitude(), panel.getLongitude());\n\t\t\t\t\tsettings.saveDefaultZoom(panel.getZoom());\n\t\t    \t\tSystem.exit(0);\n\t\t    \t}\n\t\t    });\n\t\t    Container content = frame.getContentPane();\n\t\t    content.add(panel, BorderLayout.CENTER);\n\n\t\t    JMenuBar bar = new JMenuBar();\n\t\t    bar.add(MapPanel.getMenuToChooseSource(panel));\n\t\t    frame.setJMenuBar(bar);\n\t\t    frame.setSize(512, 512);\n\t\t    frame.setVisible(true);\n\t\t\t\n\t\t}\n\t}","commit_id":"1d4319f9aa52f8e8d25d8445c377eeabffa609b6","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void setStartTime(int startTime) {\n\t\t\tthis.startTime = startTime;\n\t\t}","id":49495,"modified_method":"public int getStartTime(int idx) {\n\t\t\treturn startTime.get(idx);\n\t\t}","commit_id":"1d4319f9aa52f8e8d25d8445c377eeabffa609b6","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static void main(String[] args) {\n\t\tList<OpeningHoursRule> hours = parseOpenedHours(\"Mo-Fr 08:30-14:40; Sa 08:00 - 14:00\"); //$NON-NLS-1$\n\t\tSystem.out.println(hours);\n\t\tSystem.out.println(toStringOpenedHours(hours));\n\t\thours = parseOpenedHours(\"Mo, We-Fr, Th, Sa 08:30-14:40; Sa 08:00 - 14:00\"); //$NON-NLS-1$\n\t\tSystem.out.println(hours);\n\t\tSystem.out.println(toStringOpenedHours(hours));\n\t\thours = parseOpenedHours(\"Mo-Su 00:00-24:00\"); //$NON-NLS-1$\n\t\tSystem.out.println(hours);\n\t\tSystem.out.println(toStringOpenedHours(hours));\n\t\thours = parseOpenedHours(\"24/7\"); //$NON-NLS-1$\n\t\tSystem.out.println(hours);\n\t\tSystem.out.println(toStringOpenedHours(hours));\n\t}","id":49496,"modified_method":"public static void main(String[] args) throws ParseException {\n\t\t\n\t\tList<OpeningHoursRule> hours = parseOpenedHours(\"Mo-Fr 08:30-14:40; Sa 08:00 - 14:00\"); //$NON-NLS-1$\n\t\tSystem.out.println(hours);\n\t\tSystem.out.println(toStringOpenedHours(hours));\n\t\thours = parseOpenedHours(\"Mo-Fr 08:30-14:40,15:00-19:00\"); //$NON-NLS-1$\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.setTime(new SimpleDateFormat(\"dd.MM.yyyy hh:mm\").parse(\"20.04.2012 14:00\"));\n\t\tSystem.out.println(\"true=\"+hours.get(0).isOpenedForTime(cal));\n\t\tcal.setTime(new SimpleDateFormat(\"dd.MM.yyyy hh:mm\").parse(\"20.04.2012 15:50\"));\n\t\tSystem.out.println(\"true=\"+hours.get(0).isOpenedForTime(cal));\n\t\tcal.setTime(new SimpleDateFormat(\"dd.MM.yyyy hh:mm\").parse(\"20.04.2012 14:50\"));\n\t\tSystem.out.println(\"false=\"+hours.get(0).isOpenedForTime(cal));\n\t\tSystem.out.println(hours);\n\t\tSystem.out.println(toStringOpenedHours(hours));\n\t\thours = parseOpenedHours(\"Mo, We-Fr, Th, Sa 08:30-14:40; Sa 08:00 - 14:00\"); //$NON-NLS-1$\n\t\tSystem.out.println(hours);\n\t\tSystem.out.println(toStringOpenedHours(hours));\n\t\thours = parseOpenedHours(\"Mo-Su 00:00-24:00\"); //$NON-NLS-1$\n\t\tSystem.out.println(hours);\n\t\tSystem.out.println(toStringOpenedHours(hours));\n\t\thours = parseOpenedHours(\"24/7\"); //$NON-NLS-1$\n\t\tSystem.out.println(hours);\n\t\tSystem.out.println(toStringOpenedHours(hours));\n\t}","commit_id":"1d4319f9aa52f8e8d25d8445c377eeabffa609b6","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\t\tpublic String toRuleString() {\n\t\t\tStringBuilder b = new StringBuilder(25);\n\t\t\tboolean dash = false;\n\t\t\tboolean first = true;\n\t\t\tboolean open24_7 = true;\n\t\t\tfor(int i=0; i< 7; i++){\n\t\t\t\tif (days[i]) {\n\t\t\t\t\tif (i > 0 && days[i - 1] && i < 6 && days[i + 1]) {\n\t\t\t\t\t\tif (!dash) {\n\t\t\t\t\t\t\tdash = true;\n\t\t\t\t\t\t\tb.append(\"-\"); //$NON-NLS-1$\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (first) {\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t} else if (!dash) {\n\t\t\t\t\t\tb.append(\", \"); //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t\tb.append(daysStr[i]);\n\t\t\t\t\tdash = false;\n\t\t\t\t} else {\n\t\t\t\t\topen24_7 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(open24_7 && startTime == 0 && endTime / 60 == 24){\n\t\t\t\treturn \"24/7\";\n\t\t\t}\n\t\t\tint stHour = startTime / 60;\n\t\t\tint stTime = startTime - stHour * 60;\n\t\t\tint enHour = endTime / 60;\n\t\t\tint enTime = endTime - enHour * 60;\n\t\t\tb.append(\" \"); //$NON-NLS-1$\n\t\t\tformatTime(stHour, stTime, b);\n\t\t\tb.append(\"-\"); //$NON-NLS-1$\n\t\t\tformatTime(enHour, enTime, b);\n\t\t\treturn b.toString();\n\t\t}","id":49497,"modified_method":"@Override\n\t\tpublic String toRuleString() {\n\t\t\tStringBuilder b = new StringBuilder(25);\n\t\t\tboolean dash = false;\n\t\t\tboolean first = true;\n\t\t\tboolean open24_7 = true;\n\t\t\tfor(int i=0; i< 7; i++){\n\t\t\t\tif (days[i]) {\n\t\t\t\t\tif (i > 0 && days[i - 1] && i < 6 && days[i + 1]) {\n\t\t\t\t\t\tif (!dash) {\n\t\t\t\t\t\t\tdash = true;\n\t\t\t\t\t\t\tb.append(\"-\"); //$NON-NLS-1$\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (first) {\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t} else if (!dash) {\n\t\t\t\t\t\tb.append(\", \"); //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t\tb.append(daysStr[i]);\n\t\t\t\t\tdash = false;\n\t\t\t\t} else {\n\t\t\t\t\topen24_7 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(open24_7 && startTime.get(0) == 0 && endTime.get(0) / 60 == 24){\n\t\t\t\treturn \"24/7\";\n\t\t\t}\n\t\t\tb.append(\" \"); //$NON-NLS-1$\n\t\t\tfor (int i = 0; i < startTime.size(); i++) {\n\t\t\t\tif(i > 0) {\n\t\t\t\t\tb.append(\", \");\n\t\t\t\t}\n\t\t\t\tint stHour = startTime.get(i) / 60;\n\t\t\t\tint stTime = startTime.get(i) - stHour * 60;\n\t\t\t\tint enHour = endTime.get(i) / 60;\n\t\t\t\tint enTime = endTime.get(i) - enHour * 60;\n\t\t\t\tformatTime(stHour, stTime, b);\n\t\t\t\tb.append(\"-\"); //$NON-NLS-1$\n\t\t\t\tformatTime(enHour, enTime, b);\n\t\t\t}\n\t\t\treturn b.toString();\n\t\t}","commit_id":"1d4319f9aa52f8e8d25d8445c377eeabffa609b6","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void setEndTime(int endTime) {\n\t\t\tthis.endTime = endTime;\n\t\t}","id":49498,"modified_method":"public int getEndTime(int idx) {\n\t\t\treturn endTime.get(idx);\n\t\t}","commit_id":"1d4319f9aa52f8e8d25d8445c377eeabffa609b6","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\t\tpublic boolean isOpenedForTime(Calendar cal) {\n\t\t\tif(startTime == -1){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tint i = cal.get(Calendar.DAY_OF_WEEK);\n\t\t\tint d = (i + 5) % 7;\n\t\t\tint p = d - 1;\n\t\t\tif(p < 0){\n\t\t\t\tp+=7;\n\t\t\t}\n\t\t\tint time = cal.get(Calendar.HOUR_OF_DAY) * 60 + cal.get(Calendar.MINUTE);\n\t\t\t// one day working 10 - 20 (not 20 - 04)\n\t\t\tif(startTime < endTime || endTime == -1){\n\t\t\t\tif(days[d]){\n\t\t\t\t\tif(time >= startTime && (endTime == -1 || time <= endTime)){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tif (time >= startTime && days[p]) {\n\t\t\t\t\t// check in previous day\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (time <= endTime && days[d]) {\n\t\t\t\t\t// check in previous day\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}","id":49499,"modified_method":"@Override\n\t\tpublic boolean isOpenedForTime(Calendar cal) {\n\t\t\tfor (int ij = 0; ij < startTime.size(); ij++) {\n\t\t\t\tint i = cal.get(Calendar.DAY_OF_WEEK);\n\t\t\t\tint d = (i + 5) % 7;\n\t\t\t\tint p = d - 1;\n\t\t\t\tif(p < 0){\n\t\t\t\t\tp+=7;\n\t\t\t\t}\n\t\t\t\tint time = cal.get(Calendar.HOUR_OF_DAY) * 60 + cal.get(Calendar.MINUTE);\n\t\t\t\tint startTime = this.startTime.get(ij);\n\t\t\t\tint endTime = this.endTime.get(ij);\n\t\t\t\t// one day working 10 - 20 (not 20 - 04)\n\t\t\t\tif (startTime < endTime || endTime == -1) {\n\t\t\t\t\tif (days[d]) {\n\t\t\t\t\t\tif (time >= startTime && (endTime == -1 || time <= endTime)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (time >= startTime && days[p]) {\n\t\t\t\t\t\t// check in previous day\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (time <= endTime && days[d]) {\n\t\t\t\t\t\t// check in previous day\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}","commit_id":"1d4319f9aa52f8e8d25d8445c377eeabffa609b6","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public static OpeningHoursRule parseRule(String r){\n\t\tint startDay = -1;\n\t\tint previousDay = -1;\n\t\tint k = 0;\n\t\t// check 24/7\n\t\tBasicDayOpeningHourRule basic = new BasicDayOpeningHourRule();\n\t\tboolean[] days = basic.getDays();\n\t\tif(\"24/7\".equals(r)){\n\t\t\tArrays.fill(days, true);\n\t\t\tbasic.setStartTime(0);\n\t\t\tbasic.setEndTime(24*60);\n\t\t\treturn basic;\n\t\t}\n\t\t\n\t\tfor (; k < r.length(); k++) {\n\t\t\tchar ch = r.charAt(k);\n\t\t\tif (Character.isDigit(ch)) {\n\t\t\t\t// time starts\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(Character.isWhitespace(ch) || ch == ','){\n\t\t\t\tcontinue;\n\t\t\t} else if(ch == '-'){\n\t\t\t\tif(previousDay != -1){\n\t\t\t\t\tstartDay = previousDay; \n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else if(k < r.length() - 1){\n\t\t\t\tint i = 0;\n\t\t\t\tfor(String s : daysStr){\n\t\t\t\t\tif(s.charAt(0) == ch && s.charAt(1) == r.charAt(k+1)){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tif(i < daysStr.length){\n\t\t\t\t\tif(startDay != -1){\n\t\t\t\t\t\tfor (int j = startDay; j <= i; j++) {\n\t\t\t\t\t\t\tdays[j] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstartDay = -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdays[i] = true;\n\t\t\t\t\t}\n\t\t\t\t\tpreviousDay = i;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif(previousDay == -1){\n\t\t\treturn null;\n\t\t}\n\t\tString time = r.substring(k);\n\t\tString[] stEnd = time.split(\"-\"); //$NON-NLS-1$\n\t\tif(stEnd.length != 2){\n\t\t\treturn null;\n\t\t}\n\t\tint st;\n\t\tint end;\n\t\ttry {\n\t\t\tint i1 = stEnd[0].indexOf(':');\n\t\t\tint i2 = stEnd[1].indexOf(':');\n\t\t\tif(i1 == -1 || i2 == -1){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tst = Integer.parseInt(stEnd[0].substring(0, i1).trim())* 60 + Integer.parseInt(stEnd[0].substring(i1 + 1).trim());\n\t\t\tend = Integer.parseInt(stEnd[1].substring(0, i2).trim())* 60 + Integer.parseInt(stEnd[1].substring(i2 + 1).trim());\n\t\t} catch (NumberFormatException e) {\n\t\t\treturn null;\n\t\t}\n\t\tbasic.setStartTime(st);\n\t\tbasic.setEndTime(end);\n\t\treturn basic;\n\t}","id":49500,"modified_method":"public static OpeningHoursRule parseRule(String r){\n\t\tint startDay = -1;\n\t\tint previousDay = -1;\n\t\tint k = 0;\n\t\t// check 24/7\n\t\tBasicDayOpeningHourRule basic = new BasicDayOpeningHourRule();\n\t\tboolean[] days = basic.getDays();\n\t\tif(\"24/7\".equals(r)){\n\t\t\tArrays.fill(days, true);\n\t\t\tbasic.setStartEndTime(0, 24*60);\n\t\t\treturn basic;\n\t\t}\n\t\t\n\t\tfor (; k < r.length(); k++) {\n\t\t\tchar ch = r.charAt(k);\n\t\t\tif (Character.isDigit(ch)) {\n\t\t\t\t// time starts\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(Character.isWhitespace(ch) || ch == ','){\n\t\t\t\tcontinue;\n\t\t\t} else if(ch == '-'){\n\t\t\t\tif(previousDay != -1){\n\t\t\t\t\tstartDay = previousDay; \n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else if(k < r.length() - 1){\n\t\t\t\tint i = 0;\n\t\t\t\tfor(String s : daysStr){\n\t\t\t\t\tif(s.charAt(0) == ch && s.charAt(1) == r.charAt(k+1)){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tif(i < daysStr.length){\n\t\t\t\t\tif(startDay != -1){\n\t\t\t\t\t\tfor (int j = startDay; j <= i; j++) {\n\t\t\t\t\t\t\tdays[j] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstartDay = -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdays[i] = true;\n\t\t\t\t\t}\n\t\t\t\t\tpreviousDay = i;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif(previousDay == -1){\n\t\t\treturn null;\n\t\t}\n\t\tString timeSubstr = r.substring(k);\n\t\tString[] times = timeSubstr.split(\",\");\n\t\tboolean timesExist = true;\n\t\tfor (String time : times) {\n\t\t\ttime = time.trim();\n\t\t\tif(time.length() == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString[] stEnd = time.split(\"-\"); //$NON-NLS-1$\n\t\t\tif (stEnd.length != 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttimesExist = true;\n\t\t\tint st;\n\t\t\tint end;\n\t\t\ttry {\n\t\t\t\tint i1 = stEnd[0].indexOf(':');\n\t\t\t\tint i2 = stEnd[1].indexOf(':');\n\t\t\t\tif (i1 == -1 || i2 == -1) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tst = Integer.parseInt(stEnd[0].substring(0, i1).trim()) * 60 + Integer.parseInt(stEnd[0].substring(i1 + 1).trim());\n\t\t\t\tend = Integer.parseInt(stEnd[1].substring(0, i2).trim()) * 60 + Integer.parseInt(stEnd[1].substring(i2 + 1).trim());\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbasic.setStartEndTime(st, end);\n\t\t}\n\t\tif(!timesExist){\n\t\t\treturn null;\n\t\t}\n\t\treturn basic;\n\t}","commit_id":"1d4319f9aa52f8e8d25d8445c377eeabffa609b6","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n     * Formats the time for the given date. The result format is the following:\n     * [Hour]:[Minute]:[Second]. For example: 12:25:30. \n     * @param time the date to format\n     * @return the formatted hour string\n     */\n    public static String formatTime(long time)\n    {\n        c1.setTimeInMillis(time);\n\n        return\n            GuiUtils.formatTime(c1.get(Calendar.HOUR_OF_DAY)) + \":\"\n                + GuiUtils.formatTime(c1.get(Calendar.MINUTE)) + \":\"\n                + GuiUtils.formatTime(c1.get(Calendar.SECOND)) ;\n    }","id":49501,"modified_method":"/**\n     * Formats the time for the given date. The result format is the following:\n     * [Hour]:[Minute]:[Second]. For example: 12:25:30. \n     * @param time the date to format\n     * @return the formatted hour string\n     */\n    public static String formatTime(long time)\n    {\n        c1.setTimeInMillis(time);\n\n        StringBuffer timeStrBuf = new StringBuffer();\n\n        GuiUtils.formatTime(c1.get(Calendar.HOUR_OF_DAY), timeStrBuf);\n        timeStrBuf.append(':');\n        GuiUtils.formatTime(c1.get(Calendar.MINUTE), timeStrBuf);\n        timeStrBuf.append(':');\n        GuiUtils.formatTime(c1.get(Calendar.SECOND), timeStrBuf);\n        return timeStrBuf.toString();\n    }","commit_id":"b96866bc71c8ecc1d6b32837cc50d269dd719dd8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Formats the given date. The result format is the following:\n     * [Month] [Day], [Year]. For example: Dec 24, 2000.\n     * @param date the date to format\n     * @return the formatted date string\n     */\n    public static String formatDate(final long date)\n    {\n        c1.setTimeInMillis(date);\n\n        return\n            GuiUtils.processMonth(c1.get(Calendar.MONTH) + 1) + \" \" \n                + GuiUtils.formatTime(c1.get(Calendar.DAY_OF_MONTH)) + \", \"\n                + GuiUtils.formatTime(c1.get(Calendar.YEAR));\n    }","id":49502,"modified_method":"/**\n     * Formats the given date. The result format is the following:\n     * [Month] [Day], [Year]. For example: Dec 24, 2000.\n     * @param date the date to format\n     * @return the formatted date string\n     */\n    public static String formatDate(final long date)\n    {\n        StringBuffer strBuf = new StringBuffer();\n\n        formatDate(date, strBuf);\n        return strBuf.toString();\n    }","commit_id":"b96866bc71c8ecc1d6b32837cc50d269dd719dd8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds a 0 in the beginning of one digit numbers.\n     *\n     * @param time The time parameter could be hours, minutes or seconds.\n     * @return The formatted minutes string.\n     */\n    private static String formatTime(int time)\n    {\n        String timeString = Integer.toString(time);\n\n        return (timeString.length() < 2) ? \"0\".concat(timeString) : timeString;\n    }","id":49503,"modified_method":"/**\n     * Adds a 0 in the beginning of one digit numbers.\n     *\n     * @param time The time parameter could be hours, minutes or seconds.\n     * @param timeStrBuf the <tt>StringBuffer<\/tt> to which the formatted\n     * minutes string is to be appended\n     */\n    private static void formatTime(int time, StringBuffer timeStrBuf)\n    {\n        String timeString = Integer.toString(time);\n\n        if (timeString.length() < 2)\n            timeStrBuf.append('0');\n        timeStrBuf.append(timeString);\n    }","commit_id":"b96866bc71c8ecc1d6b32837cc50d269dd719dd8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Formats the given long to X hour, Y min, Z sec.\n     */\n    public static String formatSeconds(long millis)\n    {\n        long[] values = new long[4];\n        values[0] = millis / MILLIS_PER_DAY;\n        values[1] = (millis / MILLIS_PER_HOUR) % 24;\n        values[2] = (millis / MILLIS_PER_MINUTE) % 60;\n        values[3] = (millis / MILLIS_PER_SECOND) % 60;\n\n        String[] fields = { \" d \", \" h \", \" min \", \" sec\" };\n\n        StringBuffer buf = new StringBuffer(64);\n        boolean valueOutput = false;\n\n        for (int i = 0; i < 4; i++)\n        {\n            long value = values[i];\n            if (value == 0)\n            {\n                // handle zero\n                if (valueOutput)\n                {\n                    buf.append('0').append(fields[i]);\n                }\n            }\n            else if (value == 1)\n            {\n                // one\n                valueOutput = true;\n                buf.append('1').append(fields[i]);\n            }\n            else\n            {\n                // other\n                valueOutput = true;\n                buf.append(value).append(fields[i]);\n            }\n        }\n\n        return buf.toString().trim();\n    }","id":49504,"modified_method":"/**\n     * Formats the given long to X hour, Y min, Z sec.\n     */\n    public static String formatSeconds(long millis)\n    {\n        long[] values = new long[4];\n        values[0] = millis / MILLIS_PER_DAY;\n        values[1] = (millis / MILLIS_PER_HOUR) % 24;\n        values[2] = (millis / MILLIS_PER_MINUTE) % 60;\n        values[3] = (millis / MILLIS_PER_SECOND) % 60;\n\n        String[] fields = { \" d \", \" h \", \" min \", \" sec\" };\n\n        StringBuffer buf = new StringBuffer(64);\n        boolean valueOutput = false;\n\n        for (int i = 0; i < 4; i++)\n        {\n            long value = values[i];\n\n            if (value == 0)\n            {\n                if (valueOutput)\n                    buf.append('0').append(fields[i]);\n            }\n            else\n            {\n                valueOutput = true;\n                buf.append(value).append(fields[i]);\n            }\n        }\n\n        return buf.toString().trim();\n    }","commit_id":"b96866bc71c8ecc1d6b32837cc50d269dd719dd8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Replaces the month with its abbreviation.\n     * @param month Value from 1 to 12, which indicates the month.\n     * @return the corresponding month abbreviation\n     */\n    private static String processMonth(int month)\n    {\n        String monthString = \"\";\n        if(month == 1)\n            monthString = UtilActivator.getResources()\n                            .getI18NString(\"service.gui.JANUARY\");\n        else if(month == 2)\n            monthString = UtilActivator.getResources()\n                            .getI18NString(\"service.gui.FEBRUARY\");\n        else if(month == 3)\n            monthString = UtilActivator.getResources()\n                            .getI18NString(\"service.gui.MARCH\");\n        else if(month == 4)\n            monthString = UtilActivator.getResources()\n                            .getI18NString(\"service.gui.APRIL\");\n        else if(month == 5)\n            monthString = UtilActivator.getResources()\n                            .getI18NString(\"service.gui.MAY\");\n        else if(month == 6)\n            monthString = UtilActivator.getResources()\n                            .getI18NString(\"service.gui.JUNE\");\n        else if(month == 7)\n            monthString = UtilActivator.getResources()\n                            .getI18NString(\"service.gui.JULY\");\n        else if(month == 8)\n            monthString = UtilActivator.getResources()\n                            .getI18NString(\"service.gui.AUGUST\");\n        else if(month == 9)\n            monthString = UtilActivator.getResources()\n                            .getI18NString(\"service.gui.SEPTEMBER\");\n        else if(month == 10)\n            monthString = UtilActivator.getResources()\n                            .getI18NString(\"service.gui.OCTOBER\");\n        else if(month == 11)\n            monthString = UtilActivator.getResources()\n                            .getI18NString(\"service.gui.NOVEMBER\");\n        else if(month == 12)\n            monthString = UtilActivator.getResources()\n                            .getI18NString(\"service.gui.DECEMBER\");\n\n        return monthString;\n    }","id":49505,"modified_method":"/**\n     * Gets the display/human-readable string representation of the month with\n     * the specified zero-based month number.\n     *\n     * @param month the zero-based month number\n     * @return the corresponding month abbreviation\n     */\n    private static String processMonth(int month)\n    {\n        String monthStringKey;\n\n        switch (month)\n        {\n        case 0: monthStringKey = \"service.gui.JANUARY\"; break;\n        case 1: monthStringKey = \"service.gui.FEBRUARY\"; break;\n        case 2: monthStringKey = \"service.gui.MARCH\"; break;\n        case 3: monthStringKey = \"service.gui.APRIL\"; break;\n        case 4: monthStringKey = \"service.gui.MAY\"; break;\n        case 5: monthStringKey = \"service.gui.JUNE\"; break;\n        case 6: monthStringKey = \"service.gui.JULY\"; break;\n        case 7: monthStringKey = \"service.gui.AUGUST\"; break;\n        case 8: monthStringKey = \"service.gui.SEPTEMBER\"; break;\n        case 9: monthStringKey = \"service.gui.OCTOBER\"; break;\n        case 10: monthStringKey = \"service.gui.NOVEMBER\"; break;\n        case 11: monthStringKey = \"service.gui.DECEMBER\"; break;\n        default: return \"\";\n        }\n\n        return UtilActivator.getResources().getI18NString(monthStringKey);\n    }","commit_id":"b96866bc71c8ecc1d6b32837cc50d269dd719dd8","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Updates the RSS feed associated with rssContact. If the update has been\n     * requested by the user the method would fire a message received event\n     * even if there are no new items.\n     *\n     * @param rssContact the <tt>contact<\/tt> to send query to.\n     * @param userRequestedUpdate indicates whether the query is triggered by\n     * the user or by a scheduled timer task.\n     */\n    private void submitRssQuery(ContactRssImpl rssContact,\n                                boolean userRequestedUpdate)\n    {\n        Message msg;\n        boolean newName = false;\n        boolean newItem = false;\n        boolean update = false;\n        String newDisplayName = new String();\n        String oldDisplayName = new String();\n\n        RssFeedReader rssFeed = rssContact.getRssFeedReader();\n        try\n        {\n            rssFeed.retrieveFlow();\n        }\n        catch (OperationFailedException ex)\n        {\n            logger.error(\"Failed to retrieve RSS flow. Error was: \"\n                         + ex.getMessage()\n                         , ex);\n            return;\n        }\n\n\n        //we recover the feed's old name\n        oldDisplayName = rssContact.getDisplayName();\n\n        //we change the contact's displayName according to the feed's title\n        newDisplayName = rssFeed.getTitle();\n        if (! (newDisplayName.equals(oldDisplayName)))\n        {\n            newName = true;\n        }\n        rssContact.setDisplayName(newDisplayName);\n\n        //we create the message containing the new items retrieved\n        msg = createMessage(rssFeed.feedToString(rssContact.getLastItemKey()));\n\n        //if a newer date is available for the current feed/contact looking\n        //the date of each item of the feed retrieved, we update this date\n        if (rssFeed.getLastItemKey().usesDate())\n        {\n            if(rssFeed.getLastItemKey().getItemDate()\n                .compareTo(rssContact.getLastItemKey().getItemDate()) > 0)\n            {\n                rssContact.setLastItemKey(\n                    new RssItemKey(rssFeed.getLastItemKey().getItemDate()));\n                newItem = true;\n                update = true;\n            }\n        }\n        else\n        {\n            if (!rssFeed.getLastItemKey().getItemUri().equalsIgnoreCase(\n                rssContact.getLastItemKey().getItemUri()))\n            {\n                rssContact.setLastItemKey(\n                    new RssItemKey(rssFeed.getLastItemKey().getItemUri()));\n                \n                newItem = true;\n                update = true;\n            }\n        }\n\n        //if we have a new date or a new name on this feed/contact, we fire\n        //that the contact has his properties modified in order to save it\n        if (newName || newItem)\n            this.opSetPersPresence.fireContactPropertyChangeEvent(\n                ContactPropertyChangeEvent.\n                PROPERTY_DISPLAY_NAME, rssContact,\n                oldDisplayName, newDisplayName);\n\n        //if the feed has been updated or if the user made a request on a\n        //specific feed/contact, we fire a new message containing the new items\n        //to the user\n        if(update || userRequestedUpdate)\n            fireMessageReceived(msg, rssContact);\n    }","id":49506,"modified_method":"/**\n     * Updates the RSS feed associated with rssContact. If the update has been\n     * requested by the user the method would fire a message received event\n     * even if there are no new items.\n     *\n     * @param rssContact the <tt>contact<\/tt> to send query to.\n     * @param userRequestedUpdate indicates whether the query is triggered by\n     * the user or by a scheduled timer task.\n     */\n    private void submitRssQuery(ContactRssImpl rssContact,\n                                boolean userRequestedUpdate)\n    {\n        Message msg;\n        boolean newName = false;\n        boolean newItem = false;\n        boolean update = false;\n        String newDisplayName = new String();\n        String oldDisplayName = new String();\n\n        RssFeedReader rssFeed = rssContact.getRssFeedReader();\n        try\n        {\n            rssFeed.retrieveFlow();\n        }\n        catch (OperationFailedException ex)\n        {\n            logger.error(\"Failed to retrieve RSS flow. Error was: \"\n                         + ex.getMessage()\n                         , ex);\n            return;\n        }\n\n\n        //we recover the feed's old name\n        oldDisplayName = rssContact.getDisplayName();\n\n        //we change the contact's displayName according to the feed's title\n        newDisplayName = rssFeed.getTitle();\n        if (! (newDisplayName.equals(oldDisplayName)))\n        {\n            newName = true;\n        }\n        rssContact.setDisplayName(newDisplayName);\n\n        //we create the message containing the new items retrieved\n        msg = createMessage(rssFeed.feedToString(rssContact.getLastItemKey()));\n\n        //if a newer date is available for the current feed/contact looking\n        //the date of each item of the feed retrieved, we update this date\n        if (rssFeed.getLastItemKey().usesDate())\n        {\n            if(rssFeed.getLastItemKey().getItemDate()\n                .compareTo(rssContact.getLastItemKey().getItemDate()) > 0)\n            {\n                rssContact.setLastItemKey(\n                    new RssItemKey(rssFeed.getLastItemKey().getItemDate()));\n                newItem = true;\n                update = true;\n            }\n        }\n        else\n        {\n            if (!rssFeed.getLastItemKey().getItemUri().equalsIgnoreCase(\n                rssContact.getLastItemKey().getItemUri()))\n            {\n                rssContact.setLastItemKey(\n                    new RssItemKey(rssFeed.getLastItemKey().getItemUri()));\n                \n                newItem = true;\n                update = true;\n            }\n        }\n\n        //if we have a new date or a new name on this feed/contact, we fire\n        //that the contact has his properties modified in order to save it\n        if (newName || newItem)\n            this.opSetPersPresence.fireContactPropertyChangeEvent(\n                ContactPropertyChangeEvent.\n                PROPERTY_DISPLAY_NAME, rssContact,\n                oldDisplayName, newDisplayName);\n\n        //if the feed has been updated or if the user made a request on a\n        //specific feed/contact, we fire a new message containing the new items\n        //to the user\n        if(update || userRequestedUpdate)\n        {\n            fireMessageEvent(new MessageReceivedEvent(msg, rssContact, new Date()));\n        }\n    }","commit_id":"ce4173caddf54c1711131976568b2b8f93d0c15b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sends the <tt>message<\/tt> to the destination indicated by the\n     * <tt>to<\/tt> contact.\n     *\n     * @param to the <tt>Contact<\/tt> to send <tt>message<\/tt> to\n     * @param message the <tt>Message<\/tt> to send.\n     * @throws IllegalStateException if the underlying ICQ stack is not\n     *   registered and initialized.\n     * @throws IllegalArgumentException if <tt>to<\/tt> is not an instance\n     *   belonging to the underlying implementation.\n     */\n    public void sendInstantMessage(Contact to, Message message)\n        throws  IllegalStateException,\n                IllegalArgumentException\n    {\n        if( !(to instanceof ContactRssImpl) )\n           throw new IllegalArgumentException(\n               \"The specified contact is not a Rss contact.\"\n               + to);\n\n        //refresh the present rssFeed \"to\"\n        Message msg = new MessageRssImpl(\"Refreshing feed...\",\n            DEFAULT_MIME_TYPE, DEFAULT_MIME_ENCODING, null);\n        \n        fireMessageDelivered(msg,to);\n            \n        threadedContactFeedUpdate((ContactRssImpl)to);\n    }","id":49507,"modified_method":"/**\n     * Sends the <tt>message<\/tt> to the destination indicated by the\n     * <tt>to<\/tt> contact.\n     *\n     * @param to the <tt>Contact<\/tt> to send <tt>message<\/tt> to\n     * @param message the <tt>Message<\/tt> to send.\n     * @throws IllegalStateException if the underlying ICQ stack is not\n     *   registered and initialized.\n     * @throws IllegalArgumentException if <tt>to<\/tt> is not an instance\n     *   belonging to the underlying implementation.\n     */\n    public void sendInstantMessage(Contact to, Message message)\n        throws  IllegalStateException,\n                IllegalArgumentException\n    {\n        if( !(to instanceof ContactRssImpl) )\n           throw new IllegalArgumentException(\n               \"The specified contact is not a Rss contact.\"\n               + to);\n\n        if( to.isPersistent() &&\n            to.getPresenceStatus().equals(RssStatusEnum.OFFLINE))\n        {\n            MessageDeliveryFailedEvent evt =\n                new MessageDeliveryFailedEvent(\n                    message,\n                    to,\n                    MessageDeliveryFailedEvent.OFFLINE_MESSAGES_NOT_SUPPORTED,\n                    new Date());\n            fireMessageEvent(evt);\n            return;\n        }\n\n        //refresh the present rssFeed \"to\"\n        Message msg = new MessageRssImpl(\"Refreshing feed...\",\n            DEFAULT_MIME_TYPE, DEFAULT_MIME_ENCODING, null);\n        \n        fireMessageEvent(new MessageDeliveredEvent(msg, to, new Date()));\n            \n        threadedContactFeedUpdate((ContactRssImpl)to);\n    }","commit_id":"ce4173caddf54c1711131976568b2b8f93d0c15b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * The method is called by a ProtocolProvider implementation whenever\n         * a change in the registration state of the corresponding provider had\n         * occurred. The method is particularly interested in events stating\n         * that the RSS provider has unregistered so that it would fire\n         * status change events for all contacts in our buddy list.\n         *\n         * @param evt ProviderStatusChangeEvent the event describing the status\n         * change.\n         */\n        public void registrationStateChanged(RegistrationStateChangeEvent evt)\n        {\n            if (! evt.getNewState().equals(RegistrationState.UNREGISTERED)\n                && !evt.getNewState().equals(RegistrationState.AUTHENTICATION_FAILED)\n                && !evt.getNewState().equals(RegistrationState.CONNECTION_FAILED))\n            {\n                return;\n            }\n\n            //send event notifications saying that all our buddies are offline.\n            //The icq (?) protocol does not implement top level buddies\n            //nor subgroups for top level groups so a simple nested loop\n            //would be enough.\n            Iterator groupsIter = getServerStoredContactListRoot()\n                .subgroups();\n            while (groupsIter.hasNext())\n            {\n                ContactGroupRssImpl group\n                    = (ContactGroupRssImpl) groupsIter.next();\n\n                Iterator contactsIter = group.contacts();\n\n                while (contactsIter.hasNext())\n                {\n                    ContactRssImpl contact\n                        = (ContactRssImpl) contactsIter.next();\n\n                    PresenceStatus oldContactStatus\n                        = contact.getPresenceStatus();\n\n                    if (!oldContactStatus.isOnline())\n                        continue;\n\n                    contact.setPresenceStatus(RssStatusEnum.ONLINE);\n\n                    fireContactPresenceStatusChangeEvent(\n                        contact\n                        , contact.getParentContactGroup()\n                        , oldContactStatus);\n                }\n            }\n        }","id":49508,"modified_method":"/**\n         * The method is called by a ProtocolProvider implementation whenever\n         * a change in the registration state of the corresponding provider had\n         * occurred. The method is particularly interested in events stating\n         * that the RSS provider has unregistered so that it would fire\n         * status change events for all contacts in our buddy list.\n         *\n         * @param evt ProviderStatusChangeEvent the event describing the status\n         * change.\n         */\n        public void registrationStateChanged(RegistrationStateChangeEvent evt)\n        {\n            if(evt.getNewState() == RegistrationState.REGISTERED)\n            {\n                if(presenceStatus != RssStatusEnum.ONLINE)\n                {\n                    presenceStatus = RssStatusEnum.ONLINE;\n                    changePresenceStatusForAllContacts(contactListRoot, presenceStatus);\n                }\n            }\n            else if(evt.getNewState() == RegistrationState.UNREGISTERED\n                 || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED\n                 || evt.getNewState() == RegistrationState.CONNECTION_FAILED)\n            {\n                if(presenceStatus != RssStatusEnum.OFFLINE)\n                {\n                    presenceStatus = RssStatusEnum.OFFLINE;\n                    changePresenceStatusForAllContacts(contactListRoot, presenceStatus);\n                }\n            }\n\n        }","commit_id":"ce4173caddf54c1711131976568b2b8f93d0c15b","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n         * The method is called by a ProtocolProvider implementation whenver a\r\n         * change in the registration state of the corresponding provider had\r\n         * occurred. The method is particularly interested in events stating\r\n         * that the facebook provider has unregistered so that it would fire\r\n         * status change events for all contacts in our buddy list.\r\n         *\r\n         * @param evt ProviderStatusChangeEvent the event describing the status\r\n         *            change.\r\n         */\r\n        public void registrationStateChanged(RegistrationStateChangeEvent evt)\r\n        {\r\n            if (!evt.getNewState().equals(RegistrationState.UNREGISTERED)\r\n                && !evt.getNewState().equals(\r\n                    RegistrationState.AUTHENTICATION_FAILED)\r\n                && !evt.getNewState().equals(\r\n                    RegistrationState.CONNECTION_FAILED))\r\n            {\r\n                return;\r\n            }\r\n\r\n            // send event notifications saying that all our buddies are\r\n            // offline. The icq protocol does not implement top level buddies\r\n            // nor subgroups for top level groups so a simple nested loop\r\n            // would be enough.\r\n            Iterator<ContactGroup> groupsIter\r\n                = getServerStoredContactListRoot().subgroups();\r\n            while (groupsIter.hasNext())\r\n            {\r\n                ContactGroupFacebookImpl group =\r\n                    (ContactGroupFacebookImpl) groupsIter.next();\r\n\r\n                Iterator<Contact> contactsIter = group.contacts();\r\n\r\n                while (contactsIter.hasNext())\r\n                {\r\n                    ContactFacebookImpl contact =\r\n                        (ContactFacebookImpl) contactsIter.next();\r\n\r\n                    PresenceStatus oldContactStatus =\r\n                        contact.getPresenceStatus();\r\n\r\n                    if (!oldContactStatus.isOnline())\r\n                        continue;\r\n\r\n                    contact.setPresenceStatus(FacebookStatusEnum.OFFLINE);\r\n\r\n                    fireContactPresenceStatusChangeEvent(contact, contact\r\n                        .getParentContactGroup(), oldContactStatus);\r\n                }\r\n            }\r\n        }","id":49509,"modified_method":"/**\r\n         * The method is called by a ProtocolProvider implementation whenver a\r\n         * change in the registration state of the corresponding provider had\r\n         * occurred. The method is particularly interested in events stating\r\n         * that the facebook provider has unregistered so that it would fire\r\n         * status change events for all contacts in our buddy list.\r\n         *\r\n         * @param evt ProviderStatusChangeEvent the event describing the status\r\n         *            change.\r\n         */\r\n        public void registrationStateChanged(RegistrationStateChangeEvent evt)\r\n        {\r\n            RegistrationState newState = evt.getNewState();\r\n\r\n            if (RegistrationState.UNREGISTERED.equals(newState))\r\n            {\r\n\r\n                /*\r\n                 * Reflect the RegistrationState of the ProtocolProviderService\r\n                 * onto the presenceStatus of this instance.\r\n                 */\r\n                if (!FacebookStatusEnum.OFFLINE.equals(presenceStatus))\r\n                {\r\n                    PresenceStatus oldValue = presenceStatus;\r\n\r\n                    presenceStatus = FacebookStatusEnum.OFFLINE;\r\n                    fireProviderStatusChangeEvent(oldValue, presenceStatus);\r\n                }\r\n            }\r\n            else if (!newState.equals(RegistrationState.AUTHENTICATION_FAILED)\r\n                    && !newState.equals(RegistrationState.CONNECTION_FAILED))\r\n                return;\r\n\r\n            // send event notifications saying that all our buddies are\r\n            // offline. The icq protocol does not implement top level buddies\r\n            // nor subgroups for top level groups so a simple nested loop\r\n            // would be enough.\r\n            Iterator<ContactGroup> groupsIter\r\n                = getServerStoredContactListRoot().subgroups();\r\n            while (groupsIter.hasNext())\r\n            {\r\n                ContactGroup group = groupsIter.next();\r\n                Iterator<Contact> contactsIter = group.contacts();\r\n\r\n                while (contactsIter.hasNext())\r\n                {\r\n                    ContactFacebookImpl contact\r\n                        = (ContactFacebookImpl) contactsIter.next();\r\n                    PresenceStatus oldContactStatus\r\n                        = contact.getPresenceStatus();\r\n\r\n                    if (!oldContactStatus.isOnline())\r\n                        continue;\r\n\r\n                    contact.setPresenceStatus(FacebookStatusEnum.OFFLINE);\r\n\r\n                    fireContactPresenceStatusChangeEvent(contact, contact\r\n                        .getParentContactGroup(), oldContactStatus);\r\n                }\r\n            }\r\n        }","commit_id":"84d904ff667a20a5a3a5043b0aca12033bf59c4d","url":"https://github.com/jitsi/jitsi"},{"original_method":"protected static String appendClsName(String pack, String fqName, final SNodeTextGen textGen) {\n    if (fqName == null) {\n      textGen.foundError(\"class name is NULL\");\n      return \"???\";\n    }\n\n    ImportsContext context = ImportsContext.getInstance(textGen.getBuffer());\n    String simpleName = JavaNameUtil.shortName(fqName);\n    if (context.containsBinding(simpleName)) {\n      if (fqName.equals(context.getBinding(simpleName))) {\n        return simpleName;\n      } else {\n        return fqName;\n      }\n    } else {\n      if (context.addBinding(pack, fqName)) {\n        int currPartId = textGen.getBuffer().selectPart(TextGenBuffer.TOP);\n        textGen.appendNewLine();\n        textGen.append(\"import \" + fqName + \";\");\n        textGen.getBuffer().selectPart(currPartId);\n      }\n\n      // todo: ? \n      BaseLanguageTextGen.addDependency(InternUtil.intern(fqName), textGen);\n\n      return simpleName;\n    }\n  }","id":49510,"modified_method":"protected static void appendClassName(String packageName, String fqName, final SNodeTextGen textGen) {\n    textGen.append(BaseLanguageTextGen.getClassName(packageName, fqName, textGen));\n  }","commit_id":"9a94b3480cdb724cd98f5ec40f1cca2c747b2212","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void blClassifierRef(SReference classifierRef, final SNodeTextGen textGen) {\n    if (classifierRef == null) {\n      textGen.foundError(\"null classifier ref\");\n      return;\n    }\n    _2<String, String> packageAndShortName = BaseLanguageTextGen.getPackageAndShortName(classifierRef, textGen);\n    if (packageAndShortName == null) {\n      LOG.warning(\"null package and short name\");\n      return;\n    }\n    String packageName = packageAndShortName._0();\n    String shortName = packageAndShortName._1();\n    String longName = NameUtil.longNameFromNamespaceAndShortName(packageAndShortName._0(), packageAndShortName._1());\n    textGen.append(BaseLanguageTextGen.appendClsName(packageAndShortName._0(), longName, textGen));\n  }","id":49511,"modified_method":"public static void blClassifierRef(SReference classifierRef, final SNodeTextGen textGen) {\n    if (classifierRef == null) {\n      textGen.foundError(\"null classifier ref\");\n      return;\n    }\n    _2<String, String> packageAndShortName = BaseLanguageTextGen.getPackageAndShortName(classifierRef, textGen);\n    if (packageAndShortName == null) {\n      LOG.warning(\"null package and short name\");\n      return;\n    }\n    String longName = NameUtil.longNameFromNamespaceAndShortName(packageAndShortName._0(), packageAndShortName._1());\n    BaseLanguageTextGen.appendClassName(packageAndShortName._0(), longName, textGen);\n  }","commit_id":"9a94b3480cdb724cd98f5ec40f1cca2c747b2212","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected static boolean isNeedLongName(String fqName, final SNodeTextGen textGen) {\n    assert fqName != null && !((fqName == null || fqName.length() == 0));\n    Set<String> importedNames = BaseLanguageTextGen.getUserObjects(TextGenManager.IMPORT, textGen);\n    for (String importedName : importedNames) {\n      boolean shortEquals = JavaNameUtil.shortName(importedName).equals(JavaNameUtil.shortName(fqName));\n      boolean longEquals = importedName.equals(fqName);\n      if (shortEquals && !(longEquals)) {\n        return true;\n      }\n    }\n    return false;\n  }","id":49512,"modified_method":"protected static String getClassName(String packageName, String fqName, final SNodeTextGen textGen) {\n    if (fqName == null) {\n      textGen.foundError(\"class name is NULL\");\n      return \"???\";\n    }\n\n    ImportsContext context = ImportsContext.getInstance(textGen.getBuffer());\n    String simpleName = JavaNameUtil.shortName(fqName);\n    if (context.containsBinding(simpleName)) {\n      if (fqName.equals(context.getBinding(simpleName))) {\n        return simpleName;\n      } else {\n        return fqName;\n      }\n    } else {\n      if (context.addBinding(packageName, fqName)) {\n        int currPartId = textGen.getBuffer().selectPart(TextGenBuffer.TOP);\n        textGen.appendNewLine();\n        textGen.append(\"import \" + fqName + \";\");\n        textGen.getBuffer().selectPart(currPartId);\n      }\n\n      // todo: ? \n      BaseLanguageTextGen.addDependency(InternUtil.intern(fqName), textGen);\n\n      return simpleName;\n    }\n  }","commit_id":"9a94b3480cdb724cd98f5ec40f1cca2c747b2212","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void internalClassName(String pack, String className, final SNodeTextGen textGen) {\n    String toAppend = BaseLanguageTextGen.appendClsName(pack, NameUtil.longNameFromNamespaceAndShortName(pack, className), textGen);\n    textGen.append(toAppend);\n  }","id":49513,"modified_method":"public static void internalClassName(String packageName, String className, final SNodeTextGen textGen) {\n    BaseLanguageTextGen.appendClassName(packageName, NameUtil.longNameFromNamespaceAndShortName(packageName, className), textGen);\n  }","commit_id":"9a94b3480cdb724cd98f5ec40f1cca2c747b2212","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void internalClassifierName(SNode node, final SNodeTextGen textGen) {\n    if ((node == null)) {\n      textGen.append(\"???\");\n      textGen.foundError(\"classifier is null\");\n      return;\n    }\n    String toAppend = BaseLanguageTextGen.appendClsName(BaseLanguageTextGen.getPackageName(node, textGen), NameUtil.longNameFromNamespaceAndShortName(BaseLanguageTextGen.getPackageName(node, textGen), SPropertyOperations.getString(node, \"nestedName\")), textGen);\n    textGen.append(toAppend);\n  }","id":49514,"modified_method":"public static void internalClassifierName(SNode node, final SNodeTextGen textGen) {\n    if ((node == null)) {\n      textGen.append(\"???\");\n      textGen.foundError(\"classifier is null\");\n      return;\n    }\n    BaseLanguageTextGen.appendClassName(BaseLanguageTextGen.getPackageName(node, textGen), NameUtil.longNameFromNamespaceAndShortName(BaseLanguageTextGen.getPackageName(node, textGen), SPropertyOperations.getString(node, \"nestedName\")), textGen);\n  }","commit_id":"9a94b3480cdb724cd98f5ec40f1cca2c747b2212","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.importRefPart(SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.ClassCreator\", \"constructorDeclaration\")), this);\n    BaseLanguageTextGen.methodTypeArguments(node, this);\n    BaseLanguageTextGen.blClassifierRef(SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.ClassCreator\", \"constructorDeclaration\")), this);\n    BaseLanguageTextGen.typeParameters(SLinkOperations.getTargets(node, \"typeParameter\", true), this);\n    BaseLanguageTextGen.arguments(node, this);\n  }","id":49515,"modified_method":"public void doGenerateText(SNode node) {\n    BaseLanguageTextGen.methodTypeArguments(node, this);\n    BaseLanguageTextGen.blClassifierRef(SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.ClassCreator\", \"constructorDeclaration\")), this);\n    BaseLanguageTextGen.typeParameters(SLinkOperations.getTargets(node, \"typeParameter\", true), this);\n    BaseLanguageTextGen.arguments(node, this);\n  }","commit_id":"9a94b3480cdb724cd98f5ec40f1cca2c747b2212","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void testWithExpanderDSL() throws Exception {\r\n        //final PackageBuilder builder = new PackageBuilder();\r\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        \r\n        final Reader source = new InputStreamReader( getClass().getResourceAsStream( \"rule_with_expander_dsl.dslr\" ) );\r\n        final Reader dsl = new InputStreamReader( getClass().getResourceAsStream( \"test_expander.dsl\" ) );\r\n        kbuilder.addResource( dsl,\r\n                              KnowledgeType.DSL );        \r\n        kbuilder.addResource( source,\r\n                              KnowledgeType.DSLR );\r\n\r\n        // the compiled package\r\n        final Collection<KnowledgePackage> pkgs = kbuilder.getKnowledgePackages();\r\n        assertFalse( kbuilder.hasErrors() );\r\n        //assertTrue( pkg.isValid() );\r\n//        assertEquals( null,\r\n//                      pkg.getErrorSummary() );\r\n        // Check errors\r\n//        final String err = builder.getErrors().toString();\r\n//        assertEquals( \"\",\r\n//                      err );\r\n//\r\n//        assertEquals( 0,\r\n//                      builder.getErrors().getErrors().length );\r\n\r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        kbase.addKnowledgePackages( pkgs );\r\n        kbase    = SerializationHelper.serializeObject( kbase );\r\n\r\n        StatefulKnowledgeSession session = kbase.newStatefulKnowledgeSession();\r\n        session.insert( new Person( \"Bob\",\r\n                               \"http://foo.bar\" ) );\r\n        session.insert( new Cheese( \"stilton\",\r\n                               42 ) );\r\n\r\n        final List messages = new ArrayList();\r\n        session.setGlobal( \"messages\",\r\n                      messages );\r\n//        wm  = SerializationHelper.serializeObject(wm);\r\n        session.fireAllRules();\r\n\r\n        // should have fired\r\n        assertEquals( 1,\r\n                      messages.size() );\r\n\r\n    }","id":49516,"modified_method":"public void testWithExpanderDSL() throws Exception {\r\n        //final PackageBuilder builder = new PackageBuilder();\r\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        \r\n        final Reader source = new InputStreamReader( getClass().getResourceAsStream( \"rule_with_expander_dsl.dslr\" ) );\r\n        final Reader dsl = new InputStreamReader( getClass().getResourceAsStream( \"test_expander.dsl\" ) );\r\n        kbuilder.addResource( dsl,\r\n                              KnowledgeType.DSL );        \r\n        kbuilder.addResource( source,\r\n                              KnowledgeType.DSLR );\r\n\r\n        assertFalse( kbuilder.hasErrors() );\r\n\r\n        // Check errors\r\n        final String err = kbuilder.getErrors().toString();\r\n        assertEquals( \"\",\r\n                      err );\r\n        assertEquals( 0,\r\n                      kbuilder.getErrors().size() );\r\n        \r\n        // the compiled package\r\n        final Collection<KnowledgePackage> pkgs = kbuilder.getKnowledgePackages();\r\n        assertEquals( 1, pkgs.size() );        \r\n\r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        kbase.addKnowledgePackages( pkgs );\r\n        kbase    = SerializationHelper.serializeObject( kbase );\r\n\r\n        StatefulKnowledgeSession session = kbase.newStatefulKnowledgeSession();\r\n        session.insert( new Person( \"Bob\",\r\n                               \"http://foo.bar\" ) );\r\n        session.insert( new Cheese( \"stilton\",\r\n                               42 ) );\r\n\r\n        final List messages = new ArrayList();\r\n        session.setGlobal( \"messages\",\r\n                      messages );\r\n//        wm  = SerializationHelper.serializeObject(wm);\r\n        session.fireAllRules();\r\n\r\n        // should have fired\r\n        assertEquals( 1,\r\n                      messages.size() );\r\n\r\n    }","commit_id":"7a838fc7570ba67b3b9899a9ed984ec4f5895638","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testEmptyDSL() throws Exception {\r\n        final String DSL = \"# This is an empty dsl file.\";\r\n        final PackageBuilder builder = new PackageBuilder();\r\n        final Reader drlReader = new InputStreamReader( getClass().getResourceAsStream( \"literal_rule.drl\" ) );\r\n        final Reader dslReader = new StringReader( DSL );\r\n\r\n        builder.addPackageFromDrl( drlReader,\r\n                                   dslReader );\r\n        Package pkg = builder.getPackage();\r\n\r\n        pkg = SerializationHelper.serializeObject(pkg);\r\n        assertNull( pkg );\r\n    }","id":49517,"modified_method":"public void FIXME_estEmptyDSL() throws Exception {\r\n        // FIXME eterelli / mic_hat not sure what to do with this?\r\n        final String DSL = \"# This is an empty dsl file.\\n\";\r\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        final Reader drlReader = new InputStreamReader( getClass().getResourceAsStream( \"literal_rule.drl\" ) );\r\n        final Reader dslReader = new StringReader( DSL );\r\n\r\n        kbuilder.addResource( dslReader,\r\n                              KnowledgeType.DSL );        \r\n        kbuilder.addResource( drlReader,\r\n                              KnowledgeType.DSLR );\r\n\r\n        assertFalse( kbuilder.hasErrors() );\r\n\r\n        // Check errors\r\n        final String err = kbuilder.getErrors().toString();\r\n        assertEquals( \"\",\r\n                      err );\r\n        assertEquals( 0,\r\n                      kbuilder.getErrors().size() );\r\n        \r\n        // the compiled package\r\n        Collection<KnowledgePackage> pkgs = kbuilder.getKnowledgePackages();\r\n        assertEquals( 0, pkgs.size() );     \r\n        \r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        kbase.addKnowledgePackages( pkgs );\r\n        kbase    = SerializationHelper.serializeObject( kbase );\r\n\r\n        StatefulKnowledgeSession session = kbase.newStatefulKnowledgeSession();\r\n\r\n        pkgs = SerializationHelper.serializeObject( pkgs );\r\n        assertNull( pkgs );\r\n    }","commit_id":"7a838fc7570ba67b3b9899a9ed984ec4f5895638","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testWithExpanderMore() throws Exception {\r\n        final PackageBuilder builder = new PackageBuilder();\r\n        final Reader source = new InputStreamReader( getClass().getResourceAsStream( \"rule_with_expander_dsl_more.dslr\" ) );\r\n        final Reader dsl = new InputStreamReader( getClass().getResourceAsStream( \"test_expander.dsl\" ) );\r\n        builder.addPackageFromDrl( source,\r\n                                   dsl );\r\n\r\n        // the compiled package\r\n        final Package pkg = builder.getPackage();\r\n        assertTrue( pkg.isValid() );\r\n        assertEquals( null,\r\n                      pkg.getErrorSummary() );\r\n        // Check errors\r\n        final String err = builder.getErrors().toString();\r\n        assertEquals( \"\",\r\n                      err );\r\n        assertEquals( 0,\r\n                      builder.getErrors().getErrors().length );\r\n\r\n        RuleBase ruleBase = getRuleBase();\r\n        ruleBase.addPackage( pkg );\r\n        ruleBase    = SerializationHelper.serializeObject(ruleBase);\r\n\r\n        WorkingMemory wm = ruleBase.newStatefulSession();\r\n        wm.insert( new Person( \"rage\" ) );\r\n        wm.insert( new Cheese( \"cheddar\",\r\n                               15 ) );\r\n\r\n        final List messages = new ArrayList();\r\n        wm.setGlobal( \"messages\",\r\n                      messages );\r\n//        wm  = SerializationHelper.serializeObject(wm);\r\n        wm.fireAllRules();\r\n\r\n        // should have NONE, as both conditions should be false.\r\n        assertEquals( 0,\r\n                      messages.size() );\r\n\r\n        wm.insert( new Person( \"fire\" ) );\r\n        wm.fireAllRules();\r\n\r\n        // still no firings\r\n        assertEquals( 0,\r\n                      messages.size() );\r\n\r\n        wm.insert( new Cheese( \"brie\",\r\n                               15 ) );\r\n\r\n        wm.fireAllRules();\r\n\r\n        // YOUR FIRED\r\n        assertEquals( 1,\r\n                      messages.size() );\r\n    }","id":49518,"modified_method":"public void testWithExpanderMore() throws Exception {\r\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        \r\n        final Reader source = new InputStreamReader( getClass().getResourceAsStream( \"rule_with_expander_dsl_more.dslr\" ) );\r\n        final Reader dsl = new InputStreamReader( getClass().getResourceAsStream( \"test_expander.dsl\" ) );\r\n        kbuilder.addResource( dsl,\r\n                              KnowledgeType.DSL );        \r\n        kbuilder.addResource( source,\r\n                              KnowledgeType.DSLR );\r\n\r\n        assertFalse( kbuilder.hasErrors() );\r\n\r\n        // Check errors\r\n        final String err = kbuilder.getErrors().toString();\r\n        assertEquals( \"\",\r\n                      err );\r\n        assertEquals( 0,\r\n                      kbuilder.getErrors().size() );\r\n        \r\n        // the compiled package\r\n        final Collection<KnowledgePackage> pkgs = kbuilder.getKnowledgePackages();\r\n        assertEquals( 1, pkgs.size() );     \r\n        \r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        kbase.addKnowledgePackages( pkgs );\r\n        kbase    = SerializationHelper.serializeObject( kbase );\r\n\r\n        StatefulKnowledgeSession session = kbase.newStatefulKnowledgeSession();\r\n        session.insert( new Person( \"rage\" ) );\r\n        session.insert( new Cheese( \"cheddar\",\r\n                               15 ) );\r\n\r\n        final List messages = new ArrayList();\r\n        session.setGlobal( \"messages\",\r\n                      messages );\r\n//        wm  = SerializationHelper.serializeObject(wm);\r\n        session.fireAllRules();\r\n\r\n        // should have NONE, as both conditions should be false.\r\n        assertEquals( 0,\r\n                      messages.size() );\r\n\r\n        session.insert( new Person( \"fire\" ) );\r\n        session.fireAllRules();\r\n\r\n        // still no firings\r\n        assertEquals( 0,\r\n                      messages.size() );\r\n\r\n        session.insert( new Cheese( \"brie\",\r\n                               15 ) );\r\n\r\n        session.fireAllRules();\r\n\r\n        // YOUR FIRED\r\n        assertEquals( 1,\r\n                      messages.size() );\r\n    }","commit_id":"7a838fc7570ba67b3b9899a9ed984ec4f5895638","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testDSLWithIndividualConstraintMappings() throws Exception {\r\n        final PackageBuilder builder = new PackageBuilder();\r\n        final Reader source = new InputStreamReader( getClass().getResourceAsStream( \"test_dslWithIndividualConstraints.dslr\" ) );\r\n        final Reader dsl = new InputStreamReader( getClass().getResourceAsStream( \"test_dslWithIndividualConstraints.dsl\" ) );\r\n        builder.addPackageFromDrl( source,\r\n                                   dsl );\r\n\r\n        // the compiled package\r\n        final Package pkg = builder.getPackage();\r\n        assertTrue( pkg.getErrorSummary(),\r\n                    pkg.isValid() );\r\n        assertEquals( pkg.getErrorSummary(),\r\n                      null,\r\n                      pkg.getErrorSummary() );\r\n        // Check errors\r\n        assertEquals( 0,\r\n                      builder.getErrors().getErrors().length );\r\n\r\n        RuleBase ruleBase = getRuleBase();\r\n        ruleBase.addPackage( pkg );\r\n        ruleBase    = SerializationHelper.serializeObject(ruleBase);\r\n\r\n        WorkingMemory wm = ruleBase.newStatefulSession();\r\n        List results = new ArrayList();\r\n        wm.setGlobal( \"results\",\r\n                      results );\r\n        Cheese cheese = new Cheese( \"stilton\",\r\n                                    42 );\r\n        wm.insert( cheese );\r\n\r\n//        wm  = SerializationHelper.serializeObject(wm);\r\n        wm.fireAllRules();\r\n\r\n        // should have fired\r\n        assertEquals( 1,\r\n                      results.size() );\r\n        assertEquals( cheese,\r\n                      results.get( 0 ) );\r\n\r\n    }","id":49519,"modified_method":"public void testDSLWithIndividualConstraintMappings() throws Exception {\r\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        final Reader source = new InputStreamReader( getClass().getResourceAsStream( \"test_dslWithIndividualConstraints.dslr\" ) );\r\n        final Reader dsl = new InputStreamReader( getClass().getResourceAsStream( \"test_dslWithIndividualConstraints.dsl\" ) );\r\n        kbuilder.addResource( dsl,\r\n                              KnowledgeType.DSL );        \r\n        kbuilder.addResource( source,\r\n                              KnowledgeType.DSLR );\r\n\r\n        assertFalse( kbuilder.hasErrors() );\r\n\r\n        // Check errors\r\n        final String err = kbuilder.getErrors().toString();\r\n        assertEquals( \"\",\r\n                      err );\r\n        assertEquals( 0,\r\n                      kbuilder.getErrors().size() );\r\n        \r\n        // the compiled package\r\n        final Collection<KnowledgePackage> pkgs = kbuilder.getKnowledgePackages();\r\n        assertEquals( 1, pkgs.size() );     \r\n        \r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        kbase.addKnowledgePackages( pkgs );\r\n        kbase    = SerializationHelper.serializeObject( kbase );\r\n\r\n        StatefulKnowledgeSession session = kbase.newStatefulKnowledgeSession();\r\n        List results = new ArrayList();\r\n        session.setGlobal( \"results\",\r\n                      results );\r\n        Cheese cheese = new Cheese( \"stilton\",\r\n                                    42 );\r\n        session.insert( cheese );\r\n\r\n//        wm  = SerializationHelper.serializeObject(wm);\r\n        session.fireAllRules();\r\n\r\n        // should have fired\r\n        assertEquals( 1,\r\n                      results.size() );\r\n        assertEquals( cheese,\r\n                      results.get( 0 ) );\r\n\r\n    }","commit_id":"7a838fc7570ba67b3b9899a9ed984ec4f5895638","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public PackageBuilderErrors(DroolsError[] errors) {\r\n        this.errors = errors;\r\n    }","id":49520,"modified_method":"public PackageBuilderErrors(DroolsError[] errors) {\r\n        super( errors.length );\r\n        this.errors = errors;\r\n        for ( DroolsError error : errors ) {\r\n            add( error );\r\n        }\r\n    }","commit_id":"7a838fc7570ba67b3b9899a9ed984ec4f5895638","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void addSaveMapping(Mapping mapping) {\n\t\tsaveMappings.put(URI.createURI(mapping.getFrom()), URI.createURI(mapping.getTo()));\n\t}","id":49521,"modified_method":"/**\n\t * @deprecated Save mappings are no longer supported. The EcoreGeneratorFragment will use the \n\t * uri that is given in the referenced genmodel or create a platform resource uri for new files. \n\t */\n\t@Deprecated\n\tpublic void addSaveMapping(Mapping mapping) {\n\t\tlog.warn(\"Save mappings are no longer supported. The EcoreGeneratorFragment will use the \" +\n\t\t\t\t\"uri that is given in the referenced genmodel or create a platform resource uri for new files.\");\n\t}","commit_id":"4e5bb894a6a5e064d0b02fa40002a0762718629a","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @since 2.0\n\t */\n\tprotected GenModel getSaveAndReconcileGenModel(ResourceSet rs, Grammar grammar, XpandExecutionContext ctx,\n\t\t\tList<EPackage> packs) throws ConfigurationException {\n\t\tGenModel genModel = getGenModel(rs, grammar, ctx, packs);\n\t\tgenModel.initialize(packs);\n\t\tfor (GenPackage genPackage : genModel.getGenPackages()) {\n\t\t\tgenPackage.setBasePackage(getBasePackage(grammar));\n\t\t\tif (getFileExtensions() != null && packs.contains(genPackage.getEcorePackage())) {\n\t\t\t\tgenPackage.setFileExtensions(getFileExtensions());\n\t\t\t}\n\t\t}\n\t\tList<GenPackage> usedGenPackages = getGenPackagesForPackages(genModel, getReferencedEPackages(packs));\n\t\tgenModel.getUsedGenPackages().addAll(usedGenPackages);\n\t\tresolveAll(rs);\n\t\ttry {\n\t\t\tgenModel.eResource().save(\n\t\t\t\t\tsingletonMap(XMLResource.OPTION_URI_HANDLER, new ToPlatformResourceDeresolvingURIHandler()));\n\t\t} catch (IOException e) {\n\t\t\tthrow new WrappedException(e);\n\t\t}\n\t\tnew GenModelHelper().registerGenModel(genModel);\n\t\treturn genModel;\n\t}","id":49522,"modified_method":"/**\n\t * @since 2.0\n\t */\n\tprotected GenModel getSaveAndReconcileGenModel(ResourceSet rs, Grammar grammar, XpandExecutionContext ctx,\n\t\t\tList<EPackage> packs) throws ConfigurationException {\n\t\tGenModel genModel = getGenModel(rs, grammar, ctx, packs);\n\t\tgenModel.initialize(packs);\n\t\tfor (GenPackage genPackage : genModel.getGenPackages()) {\n\t\t\tgenPackage.setBasePackage(getBasePackage(grammar));\n\t\t\tif (getFileExtensions() != null && packs.contains(genPackage.getEcorePackage())) {\n\t\t\t\tgenPackage.setFileExtensions(getFileExtensions());\n\t\t\t}\n\t\t}\n\t\tSet<EPackage> referencedEPackages = getReferencedEPackages(packs);\n\t\tList<GenPackage> usedGenPackages = getGenPackagesForPackages(genModel, referencedEPackages);\n\t\treconcileMissingGenPackagesInUsedModels(usedGenPackages);\n\t\tgenModel.getUsedGenPackages().addAll(usedGenPackages);\n\t\ttry {\n\t\t\tsaveResource(genModel.eResource());\n\t\t} catch (IOException e) {\n\t\t\tthrow new WrappedException(e);\n\t\t}\n\t\tnew GenModelHelper().registerGenModel(genModel);\n\t\treturn genModel;\n\t}","commit_id":"4e5bb894a6a5e064d0b02fa40002a0762718629a","url":"https://github.com/eclipse/xtext"},{"original_method":"protected GenModel getGenModel(ResourceSet rs, Grammar grammar, XpandExecutionContext ctx, List<EPackage> packs) {\n\t\tURI genModelUri = getGenModelUri(grammar, ctx);\n\t\tResource genModelFile = rs.createResource(genModelUri, ContentHandler.UNSPECIFIED_CONTENT_TYPE);\n\t\tGenModel genModel;\n\t\tif (rs.getURIConverter().exists(genModelUri, null)) {\n\t\t\ttry {\n\t\t\t\tgenModelFile.load(null);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new WrappedException(e);\n\t\t\t}\n\t\t\tif (genModelUri.hasFragment()) {\n\t\t\t\tgenModel = (GenModel) genModelFile.getEObject(genModelUri.fragment());\n\t\t\t} else {\n\t\t\t\tgenModel = (GenModel) genModelFile.getContents().get(0);\n\t\t\t}\n\t\t} else {\n\t\t\tgenModel = GenModelPackage.eINSTANCE.getGenModelFactory().createGenModel();\n\t\t\tgenModel.setModelDirectory(toGenModelProjectPath(getJavaModelDirectory(ctx)));\n\t\t\tgenModel.setModelName(getModelName(grammar));\n\t\t\tgenModel.setModelPluginID(getModelPluginID(ctx));\n\t\t\tgenModel.setEditDirectory(toGenModelProjectPath(getEditDirectory(ctx)));\n\t\t\tgenModel.setEditorDirectory(toGenModelProjectPath(getEditorDirectory(ctx)));\n\t\t\tgenModel.setEditPluginID(getEditPluginID(ctx));\n\t\t\tgenModel.setEditorPluginID(getEditorPluginID(ctx));\n\t\t\tgenModel.setValidateModel(false);\n\t\t\tgenModel.setForceOverwrite(true);\n\t\t\tgenModel.setCanGenerate(true);\n\t\t\tgenModel.setFacadeHelperClass(null);\n\t\t\tgenModel.setBundleManifest(true);\n\t\t\tgenModel.setUpdateClasspath(false);\n\t\t\tgenModel.setComplianceLevel(GenJDKLevel.JDK50_LITERAL);\n\t\t\tgenModel.setRootExtendsClass(\"org.eclipse.emf.ecore.impl.MinimalEObjectImpl$Container\");\n\t\t}\n\t\tgenModelFile.getContents().add(genModel);\n\t\treturn genModel;\n\t}","id":49523,"modified_method":"protected GenModel getGenModel(ResourceSet rs, Grammar grammar, XpandExecutionContext ctx, List<EPackage> packs) {\n\t\tURI genModelUri = getGenModelUri(grammar, ctx);\n\t\tgenModelUri = toPlatformResourceURI(genModelUri);\n\t\tResource genModelFile = rs.createResource(genModelUri, ContentHandler.UNSPECIFIED_CONTENT_TYPE);\n\t\tGenModel genModel;\n\t\tif (rs.getURIConverter().exists(genModelUri, null)) {\n\t\t\ttry {\n\t\t\t\tgenModelFile.load(null);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new WrappedException(e);\n\t\t\t}\n\t\t\tif (genModelUri.hasFragment()) {\n\t\t\t\tgenModel = (GenModel) genModelFile.getEObject(genModelUri.fragment());\n\t\t\t} else {\n\t\t\t\tgenModel = (GenModel) genModelFile.getContents().get(0);\n\t\t\t}\n\t\t} else {\n\t\t\tgenModel = GenModelPackage.eINSTANCE.getGenModelFactory().createGenModel();\n\t\t\tgenModel.setModelDirectory(toGenModelProjectPath(getJavaModelDirectory(ctx)));\n\t\t\tgenModel.setModelName(getModelName(grammar));\n\t\t\tgenModel.setModelPluginID(getModelPluginID(ctx));\n\t\t\tgenModel.setEditDirectory(toGenModelProjectPath(getEditDirectory(ctx)));\n\t\t\tgenModel.setEditorDirectory(toGenModelProjectPath(getEditorDirectory(ctx)));\n\t\t\tgenModel.setEditPluginID(getEditPluginID(ctx));\n\t\t\tgenModel.setEditorPluginID(getEditorPluginID(ctx));\n\t\t\tgenModel.setValidateModel(false);\n\t\t\tgenModel.setForceOverwrite(true);\n\t\t\tgenModel.setCanGenerate(true);\n\t\t\tgenModel.setFacadeHelperClass(null);\n\t\t\tgenModel.setBundleManifest(true);\n\t\t\tgenModel.setUpdateClasspath(false);\n\t\t\tgenModel.setComplianceLevel(GenJDKLevel.JDK50_LITERAL);\n\t\t\tgenModel.setRootExtendsClass(\"org.eclipse.emf.ecore.impl.MinimalEObjectImpl$Container\");\n\t\t}\n\t\tgenModelFile.getContents().add(genModel);\n\t\treturn genModel;\n\t}","commit_id":"4e5bb894a6a5e064d0b02fa40002a0762718629a","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Resource createResourceForEPackages(Grammar grammar, XpandExecutionContext ctx, List<EPackage> packs,\n\t\t\tResourceSet rs) {\n\t\tURI ecoreFileUri = getEcoreFileUri(grammar, ctx);\n\t\tResource ecoreFile = rs.createResource(ecoreFileUri, ContentHandler.UNSPECIFIED_CONTENT_TYPE);\n\t\tecoreFile.getContents().addAll(packs);\n\t\treturn ecoreFile;\n\t}","id":49524,"modified_method":"protected Resource createResourceForEPackages(Grammar grammar, XpandExecutionContext ctx, List<EPackage> packs,\n\t\t\tResourceSet rs) {\n\t\tURI ecoreFileUri = getEcoreFileUri(grammar, ctx);\n\t\tecoreFileUri = toPlatformResourceURI(ecoreFileUri);\n\t\tResource ecoreFile = rs.createResource(ecoreFileUri, ContentHandler.UNSPECIFIED_CONTENT_TYPE);\n\t\tecoreFile.getContents().addAll(packs);\n\t\treturn ecoreFile;\n\t}","commit_id":"4e5bb894a6a5e064d0b02fa40002a0762718629a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void generate(Grammar grammar, XpandExecutionContext ctx) {\n\t\ttry {\n\t\t\tregisterReferencedGenModels();\n\n\t\t\t// create a defensive clone\n\t\t\tResourceSet copiedResourceSet = EcoreUtil2.clone(new XtextResourceSet(), grammar.eResource()\n\t\t\t\t\t.getResourceSet());\n\t\t\tGrammar copiedGrammar = (Grammar) copiedResourceSet.getResource(grammar.eResource().getURI(), true)\n\t\t\t\t\t.getContents().get(0);\n\n\t\t\tList<EPackage> packs = getGeneratedEPackages(copiedGrammar);\n\t\t\tif (!packs.isEmpty()) {\n\t\t\t\tremoveFromResource(packs);\n\t\t\t\tproxifyExternalReferences(packs);\n\t\t\t\tXtextResourceSet resourceSet = getNsUriMappingResourceSet();\n\n\t\t\t\tResource ePackages = createResourceForEPackages(copiedGrammar, ctx, packs, resourceSet);\n\t\t\t\tif (!skipGenerate) {\n\t\t\t\t\tGenModel genModel = getSaveAndReconcileGenModel(resourceSet, copiedGrammar, ctx, packs);\n\t\t\t\t\tgenModel.reconcile();\n\t\t\t\t\tdoGenerate(genModel);\n\t\t\t\t\tif (basePackage == null)\n\t\t\t\t\t\tbasePackage = genModel.getGenPackages().get(0).getBasePackage();\n\t\t\t\t\tsuper.generate(copiedGrammar, ctx);\n\t\t\t\t}\n\t\t\t\tresolveAll(resourceSet);\n\t\t\t\tePackages.save(singletonMap(XMLResource.OPTION_URI_HANDLER,\n\t\t\t\t\t\tnew ToPlatformResourceDeresolvingURIHandler()));\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","id":49525,"modified_method":"@Override\n\tpublic void generate(Grammar grammar, XpandExecutionContext ctx) {\n\t\ttry {\n\t\t\t// register all explicitly referenced genmodels\n\t\t\t// since this may cause side effects on global singeltons, we don't guard it\n\t\t\tregisterReferencedGenModels();\n\t\t\t\n\t\t\t// early exit\n\t\t\tif (!hasGeneratedMetamodel(grammar))\n\t\t\t\treturn;\n\n\t\t\t// Create a clone of the grammar that can be safely modified\n\t\t\tGrammar clonedGrammar = cloneGrammarIntoNewResourceSet(grammar);\n\t\t\tResourceSet workingResourceSet = clonedGrammar.eResource().getResourceSet();\n\t\t\t\n\t\t\t// Let's collect all the copies of the generated EPackages of this grammar\n\t\t\tList<EPackage> generatedPackages = getGeneratedEPackages(clonedGrammar);\n\n\t\t\t// now we register the to-be-used genmodel\n\t\t\t// if it was explicitly set\n\t\t\tregisterUsedGenModel(workingResourceSet.getURIConverter());\n\t\t\t\t\t\t\n\t\t\t// just to make sure that we really have a generated package and not only a \n\t\t\t// meta model declaration\n\t\t\tif (!generatedPackages.isEmpty()) {\n\t\t\t\t// create an index for all EPackages that are used by the generated packages\n\t\t\t\tMap<String, EPackage> usedEPackages = findAllUsedEPackages(generatedPackages);\n\t\t\t\t\n\t\t\t\t// try to find the *.ecore files for the potentially installed packages \n\t\t\t\tMap<String, EPackage> loadedEPackages = findEPackagesInGenPackages(usedEPackages.keySet(), workingResourceSet);\n\t\t\t\t\n\t\t\t\t// map the elements from the installed version to the file-version\n\t\t\t\tMap<EObject, EObject> eNamedElementMapping = createENamedElementMapping(usedEPackages, loadedEPackages);\n\t\t\t\t\n\t\t\t\t// and finally replace all the references to installed elements with their \n\t\t\t\t// loaded equivalent\n\t\t\t\treplaceReferencesInGeneratedPackages(generatedPackages, eNamedElementMapping);\n\t\t\t\t\n\t\t\t\t// put all the generated packages into a single resource\n\t\t\t\tResource ePackageResource = createResourceForEPackages(clonedGrammar, ctx, generatedPackages, workingResourceSet);\n\t\t\t\tif (!skipGenerate) {\n\t\t\t\t\t// obtain the genmodel - either load the given resource (this.genModel) or create a new one\n\t\t\t\t\tGenModel genModel = getSaveAndReconcileGenModel(workingResourceSet, clonedGrammar, ctx, generatedPackages);\n\t\t\t\t\t// make sure everything is set\n\t\t\t\t\tgenModel.reconcile();\n\t\t\t\t\t// execute the emf generator\n\t\t\t\t\tdoGenerate(genModel);\n\t\t\t\t\tif (basePackage == null)\n\t\t\t\t\t\tbasePackage = genModel.getGenPackages().get(0).getBasePackage();\n\t\t\t\t\tsuper.generate(clonedGrammar, ctx);\n\t\t\t\t}\n\t\t\t\t// finally save the ecore packages to the file system\n\t\t\t\tsaveResource(ePackageResource);\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","commit_id":"4e5bb894a6a5e064d0b02fa40002a0762718629a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\t\tpublic URI deresolve(URI uri) {\n\t\t\tif (uri.isPlatform())\n\t\t\t\treturn uri;\n\t\t\tMap<String, URI> map = EcorePlugin.getPlatformResourceMap();\n\t\t\tfor (Entry<String, URI> entries : map.entrySet()) {\n\t\t\t\tfinal URI newPrefix = URI.createURI(\"platform:/resource/\" + entries.getKey() + \"/\");\n\t\t\t\tURI uri2 = uri.replacePrefix(entries.getValue(), newPrefix);\n\t\t\t\tif (uri2 != null)\n\t\t\t\t\treturn uri2;\n\t\t\t}\n\t\t\treturn super.deresolve(uri);\n\t\t}","id":49526,"modified_method":"@Override\n\t\tpublic URI deresolve(URI uri) {\n\t\t\treturn super.deresolve(toPlatformResourceURI(uri));\n\t\t}","commit_id":"4e5bb894a6a5e064d0b02fa40002a0762718629a","url":"https://github.com/eclipse/xtext"},{"original_method":"public static GenPackage getGenPackage(EPackage pkg, ResourceSet resourceSet) {\n\t\tURI genModelURI = EcorePlugin.getEPackageNsURIToGenModelLocationMap().get(pkg.getNsURI());\n\t\tif (genModelURI == null) {\n\t\t\tString from = pkg.eResource() != null ? \" from \" + pkg.eResource().getURI() : \"\";\n\t\t\tStringBuilder buf = new StringBuilder();\n\t\t\tbuf.append(\"Could not find a GenModel for EPackage '\" + pkg.getNsURI() + \"'\" + from + \"\\n\");\n\t\t\tbuf.append(\"If the missing GenModel has been generated via \" + EcoreGeneratorFragment.class.getSimpleName());\n\t\t\tbuf.append(\" make sure to run it first in the workflow.\\n\");\n\t\t\tbuf.append(\"If you have a *.genmodel-file, make sure to register it via StandaloneSetup.registerGenModelFile(String)\");\n\t\t\tthrow new RuntimeException(buf.toString());\n\t\t}\n\t\tif (resourceSet == null)\n\t\t\tthrow new RuntimeException(\"There is no ResourceSet for EPackage '\" + pkg.getNsURI() + \"'. \"\n\t\t\t\t\t+ \"Please make sure the EPackage has been loaded from a .ecore file \"\n\t\t\t\t\t+ \"and not from the generated Java file.\");\n\t\tResource genModelResource = resourceSet.getResource(genModelURI, true);\n\t\tif (genModelResource == null)\n\t\t\tthrow new RuntimeException(\"Error loading GenModel \" + genModelURI);\n\t\tfor (EObject model : genModelResource.getContents())\n\t\t\tif (model instanceof GenModel) {\n\t\t\t\tGenPackage genPkg = ((GenModel) model).findGenPackage(pkg);\n\t\t\t\tif (genPkg != null) {\n\t\t\t\t\tgenPkg.getEcorePackage().getEClassifiers();\n\t\t\t\t\treturn genPkg;\n\t\t\t\t}\n\t\t\t}\n\t\tthrow new RuntimeException(\"No GenPackage for NsURI \" + pkg.getNsURI() + \" found in \" + genModelURI);\n\t}","id":49527,"modified_method":"public static GenPackage getGenPackage(EPackage pkg, ResourceSet resourceSet) {\n\t\tString nsURI = pkg.getNsURI();\n\t\tString location = null;\n\t\tif (pkg.eResource() != null && pkg.eResource().getURI() != null)\n\t\t\tlocation = pkg.eResource().getURI().toString();\n\t\tResource genModelResource = getGenModelResource(location, nsURI, resourceSet);\n\t\tfor (EObject model : genModelResource.getContents())\n\t\t\tif (model instanceof GenModel) {\n\t\t\t\tGenPackage genPkg = ((GenModel) model).findGenPackage(pkg);\n\t\t\t\tif (genPkg != null) {\n\t\t\t\t\tgenPkg.getEcorePackage().getEClassifiers();\n\t\t\t\t\treturn genPkg;\n\t\t\t\t}\n\t\t\t}\n\t\tthrow new RuntimeException(\"No GenPackage for NsURI \" + nsURI + \" found in \" + genModelResource.getURI());\n\t}","commit_id":"4e5bb894a6a5e064d0b02fa40002a0762718629a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void generate(Grammar grammar, XpandExecutionContext ctx) {\n\t\tsuper.generate(grammar, ctx);\n\t\t// create a defensive clone\n\t\tResourceSet copiedResourceSet = EcoreUtil2.clone(new ResourceSetImpl(),grammar.eResource().getResourceSet());\n\t\tGrammar copiedGrammar = (Grammar) copiedResourceSet.getResource(grammar.eResource().getURI(), true).getContents().get(0);\n\t\t\n\t\t// save grammar model\n\t\tString xmiPath = GrammarUtil.getClasspathRelativePathToXmi(copiedGrammar);\n\t\tResource resource = copiedResourceSet.createResource(URI.createURI(ctx.getOutput().getOutlet(Generator.SRC_GEN).getPath()\n\t\t\t\t+ \"/\" + xmiPath), ContentHandler.UNSPECIFIED_CONTENT_TYPE);\n\t\taddAllGrammarsToResource(resource, copiedGrammar, new HashSet<Grammar>());\n\t\tif(resource instanceof XMLResource) {\n\t\t\t((XMLResource) resource).setXMLVersion(getXmlVersion());\n\t\t}\n\t\ttry {\n\t\t\tresource.save(null);\n\t\t} catch (IOException e) {\n\t\t\tlog.error(e.getMessage(), e);\n\t\t}\n\t}","id":49528,"modified_method":"@Override\n\tpublic void generate(Grammar grammar, XpandExecutionContext ctx) {\n\t\tsuper.generate(grammar, ctx);\n\n\t\tfinal ResourceSaveIndicator isSaving = new ResourceSaveIndicator();\n\t\t// create a defensive clone\n\t\tGrammar copy = deepCopy(grammar, isSaving);\n\t\tResourceSet set = copy.eResource().getResourceSet();\n\n\t\t// save grammar model\n\t\tString xmiPath = GrammarUtil.getClasspathRelativePathToXmi(copy);\n\t\tResource resource = set.createResource(\n\t\t\t\tURI.createURI(ctx.getOutput().getOutlet(Generator.SRC_GEN).getPath() + \"/\" + xmiPath),\n\t\t\t\tContentHandler.UNSPECIFIED_CONTENT_TYPE);\n\t\taddAllGrammarsToResource(resource, copy, new HashSet<Grammar>());\n\t\tisSaving.set(Boolean.TRUE);\n\t\tif (resource instanceof XMLResource) {\n\t\t\t((XMLResource) resource).setXMLVersion(getXmlVersion());\n\t\t}\n\t\ttry {\n\t\t\tresource.save(null);\n\t\t} catch (IOException e) {\n\t\t\tlog.error(e.getMessage(), e);\n\t\t} finally {\n\t\t\tisSaving.set(Boolean.FALSE);\n\t\t}\n\t}","commit_id":"88d7f5808cedf141ef1feed1c3c4756d8d32d6df","url":"https://github.com/eclipse/xtext"},{"original_method":"private void replaceResourceURIsWithNsURIs(Grammar grammar) {\n\t\tfor (AbstractMetamodelDeclaration metamodelDecl : grammar.getMetamodelDeclarations()) {\n\t\t\tEPackage generatedPackage = metamodelDecl.getEPackage();\n\t\t\tResource packResource = generatedPackage.eResource();\n\t\t\tpackResource.setURI(URI.createURI(generatedPackage.getNsURI()));\n\t\t}\n\t}","id":49529,"modified_method":"public void replaceResourceURIsWithNsURIs(Grammar grammar, ResourceSet set) {\n\t\tfor (AbstractMetamodelDeclaration metamodelDecl : grammar.getMetamodelDeclarations()) {\n\t\t\tEPackage pack = metamodelDecl.getEPackage();\n\t\t\tResource packResource = pack.eResource();\n\t\t\tif (!packResource.getURI().equals(pack.getNsURI())) {\n\t\t\t\tResourceSet packResourceSet = packResource.getResourceSet();\n\t\t\t\tif (packResourceSet != null && packResourceSet.equals(set)) {\n\t\t\t\t\tEPackage topMost = pack;\n\t\t\t\t\t// we need to be aware of empty subpackages\n\t\t\t\t\twhile (topMost.getESuperPackage() != null\n\t\t\t\t\t\t\t&& topMost.getESuperPackage().eResource() == topMost.eResource())\n\t\t\t\t\t\ttopMost = topMost.getESuperPackage();\n\t\t\t\t\tif (packResource.getContents().contains(topMost) && packResource.getContents().size() == 1) {\n\t\t\t\t\t\tif (!topMost.getEClassifiers().isEmpty())\n\t\t\t\t\t\t\tpackResource.setURI(URI.createURI(topMost.getNsURI()));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmoveSubpackagesToNewResource(topMost, set);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"88d7f5808cedf141ef1feed1c3c4756d8d32d6df","url":"https://github.com/eclipse/xtext"},{"original_method":"private void addAllGrammarsToResource(Resource resource, Grammar grammar, Set<Grammar> visitedGrammars) {\n\t\tif (!visitedGrammars.add(grammar))\n\t\t\treturn;\n\t\tresource.getContents().add(grammar);\n\t\treplaceResourceURIsWithNsURIs(grammar);\n\t\tfor (Grammar usedGrammar : grammar.getUsedGrammars()) {\n\t\t\taddAllGrammarsToResource(resource, usedGrammar, visitedGrammars);\n\t\t}\n\t}","id":49530,"modified_method":"public void addAllGrammarsToResource(Resource resource, Grammar grammar, Set<Grammar> visitedGrammars) {\n\t\tif (!visitedGrammars.add(grammar))\n\t\t\treturn;\n\t\tresource.getContents().add(grammar);\n\t\treplaceResourceURIsWithNsURIs(grammar, resource.getResourceSet());\n\t\tfor (Grammar usedGrammar : grammar.getUsedGrammars()) {\n\t\t\taddAllGrammarsToResource(resource, usedGrammar, visitedGrammars);\n\t\t}\n\t}","commit_id":"88d7f5808cedf141ef1feed1c3c4756d8d32d6df","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tXtextResourceSet set = new XtextResourceSet();\n\t\tset.setClasspathURIContext(getClass());\n\t\tResource resource = set.getResource(URI.createURI(\"classpath:/org/eclipse/xtext/generator/grammarAccess/ametamodel.ecore\"), true);\n\t\tmetamodel = (EPackage) resource.getContents().get(0);\n\t\tfragment = new SubPackageAwareGrammarAccessFragment();\n\t}","id":49531,"modified_method":"@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tXtextResourceSet set = new XtextResourceSet();\n\t\tset.setClasspathURIContext(getClass());\n\t\tResource resource = set.getResource(URI.createURI(\"classpath:/org/eclipse/xtext/generator/grammarAccess/ametamodel.ecore\"), true);\n\t\tmetamodel = (EPackage) resource.getContents().get(0);\n\t\tfragment = new GrammarAccessFragment();\n\t}","commit_id":"88d7f5808cedf141ef1feed1c3c4756d8d32d6df","url":"https://github.com/eclipse/xtext"},{"original_method":"public static GenPackage getGenPackage(EPackage pkg) {\n\t\tURI genModelURI = EcorePlugin.getEPackageNsURIToGenModelLocationMap().get(pkg.getNsURI());\n\t\tif (genModelURI == null)\n\t\t\tthrow new RuntimeException(\"No GenModel for EPackage '\" + pkg.getNsURI() + \"' is registered.\");\n\t\tResource genModelResource = pkg.eResource().getResourceSet().getResource(genModelURI, true);\n\t\tif (genModelResource == null)\n\t\t\tthrow new RuntimeException(\"Error loading GenModel \" + genModelURI);\n\t\tfor (EObject model : genModelResource.getContents())\n\t\t\tif (model instanceof GenModel)\n\t\t\t\tfor (GenPackage genPkg : ((GenModel) model).getGenPackages())\n\t\t\t\t\tif (pkg.getNsURI().equals(genPkg.getEcorePackage().getNsURI())) {\n\t\t\t\t\t\treturn genPkg;\n\t\t\t\t\t}\n\t\tthrow new RuntimeException(\"No GenPackage for NsURI \" + pkg.getNsURI() + \" found in \" + genModelURI);\n\t}","id":49532,"modified_method":"public static GenPackage getGenPackage(EPackage pkg) {\n\t\tURI genModelURI = EcorePlugin.getEPackageNsURIToGenModelLocationMap().get(pkg.getNsURI());\n\t\tif (genModelURI == null)\n\t\t\tthrow new RuntimeException(\"No GenModel for EPackage '\" + pkg.getNsURI() + \"' is registered.\");\n\t\tResourceSet resourceSet = pkg.eResource().getResourceSet();\n\t\tif (resourceSet == null)\n\t\t\tthrow new RuntimeException(\"There is no ResourceSet for EPackage '\" + pkg.getNsURI() + \"'. \"\n\t\t\t\t\t+ \"Please make sure the EPackage has been loaded from a .ecore file \"\n\t\t\t\t\t+ \"and not from the generated Java file.\");\n\t\tResource genModelResource = resourceSet.getResource(genModelURI, true);\n\t\tif (genModelResource == null)\n\t\t\tthrow new RuntimeException(\"Error loading GenModel \" + genModelURI);\n\t\tfor (EObject model : genModelResource.getContents())\n\t\t\tif (model instanceof GenModel)\n\t\t\t\tfor (GenPackage genPkg : ((GenModel) model).getGenPackages())\n\t\t\t\t\tif (pkg.getNsURI().equals(genPkg.getEcorePackage().getNsURI())) {\n\t\t\t\t\t\treturn genPkg;\n\t\t\t\t\t}\n\t\tthrow new RuntimeException(\"No GenPackage for NsURI \" + pkg.getNsURI() + \" found in \" + genModelURI);\n\t}","commit_id":"f5be3ceea96d049cb8f841a479f609c0f54553c9","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testCallable() throws Exception {\n\t\tthis.mockMvc.perform(get(\"/1\").param(\"callable\", \"true\"))\n\t\t\t.andExpect(status().isOk())\n\t\t\t.andExpect(request().asyncStarted())\n\t\t\t.andExpect(request().asyncResult(new Person(\"Joe\")));\n\t}","id":49533,"modified_method":"@Test\n\tpublic void testCallable() throws Exception {\n\t\tMvcResult mvcResult = this.mockMvc.perform(get(\"/1\").param(\"callable\", \"true\"))\n\t\t\t.andExpect(request().asyncStarted())\n\t\t\t.andExpect(request().asyncResult(new Person(\"Joe\")))\n\t\t\t.andReturn();\n\n\t\tthis.mockMvc.perform(asyncDispatch(mvcResult))\n\t\t\t.andExpect(status().isOk())\n\t\t\t.andExpect(content().contentType(MediaType.APPLICATION_JSON))\n\t\t\t.andExpect(content().string(\"{\\\"name\\\":\\\"Joe\\\",\\\"someDouble\\\":0.0,\\\"someBoolean\\\":false}\"));\n\t}","commit_id":"c348be25116dfdf560763f4efbf3b07077e9de4f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void testDeferredResult() throws Exception {\n\t\tthis.mockMvc.perform(get(\"/1\").param(\"deferredResult\", \"true\"))\n\t\t\t.andExpect(status().isOk())\n\t\t\t.andExpect(request().asyncStarted());\n\t}","id":49534,"modified_method":"@Test\n\tpublic void testDeferredResult() throws Exception {\n\t\tMvcResult mvcResult = this.mockMvc.perform(get(\"/1\").param(\"deferredResult\", \"true\"))\n\t\t\t.andExpect(request().asyncStarted())\n\t\t\t.andReturn();\n\n\t\tthis.asyncController.onMessage(\"Joe\");\n\n\t\tthis.mockMvc.perform(asyncDispatch(mvcResult))\n\t\t.andExpect(status().isOk())\n\t\t.andExpect(content().contentType(MediaType.APPLICATION_JSON))\n\t\t.andExpect(content().string(\"{\\\"name\\\":\\\"Joe\\\",\\\"someDouble\\\":0.0,\\\"someBoolean\\\":false}\"));\n\t}","commit_id":"c348be25116dfdf560763f4efbf3b07077e9de4f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@RequestMapping(value=\"/{id}\", params=\"deferredResult\", produces=\"application/json\")\n\t\tpublic DeferredResult<Person> getDeferredResult() {\n\t\t\treturn new DeferredResult<Person>();\n\t\t}","id":49535,"modified_method":"@RequestMapping(value=\"/{id}\", params=\"deferredResult\", produces=\"application/json\")\n\t\t@ResponseBody\n\t\tpublic DeferredResult<Person> getDeferredResult() {\n\t\t\tDeferredResult<Person> deferredResult = new DeferredResult<Person>();\n\t\t\tthis.deferredResults.add(deferredResult);\n\t\t\treturn deferredResult;\n\t\t}","commit_id":"c348be25116dfdf560763f4efbf3b07077e9de4f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\tpublic void setup() {\n\t\tthis.mockMvc = standaloneSetup(new AsyncController()).build();\n\t}","id":49536,"modified_method":"@Before\n\tpublic void setup() {\n\t\tthis.asyncController = new AsyncController();\n\t\tthis.mockMvc = standaloneSetup(this.asyncController).build();\n\t}","commit_id":"c348be25116dfdf560763f4efbf3b07077e9de4f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public static GenericRecord encode(Schema schema, LoggerContextVO context) {\n    if (context != null) {\n      GenericRecord datum = new GenericData.Record(schema.getTypes().get(1));\n      datum.put(\"birthTime\", context.getBirthTime());\n      datum.put(\"name\", context.getName());\n      datum.put(\"propertyMap\", context.getPropertyMap());\n      return datum;\n    }\n    return null;\n  }","id":49537,"modified_method":"public static GenericRecord encode(Schema schema, LoggerContextVO context) {\n    if (context != null) {\n      GenericRecord datum = new GenericData.Record(schema.getTypes().get(1));\n      datum.put(\"birthTime\", context.getBirthTime());\n      datum.put(\"name\", context.getName());\n      datum.put(\"propertyMap\", LoggingEvent.encodeMdcMap(context.getPropertyMap()));\n      return datum;\n    }\n    return null;\n  }","commit_id":"1ccc4a5a58af4f1240f8ca2b5f01397cba6073e3","url":"https://github.com/caskdata/cdap"},{"original_method":"public static LoggerContextVO decode(GenericRecord datum) {\n    if (datum != null) {\n      long birthTime = (Long) datum.get(\"birthTime\");\n      String name = stringOrNull(datum.get(\"name\"));\n      //noinspection unchecked\n      Map<String, String> propertyMap = (Map<String, String>) datum.get(\"propertyMap\");\n      return new LoggerContextVO(name, propertyMap, birthTime);\n    }\n    return null;\n  }","id":49538,"modified_method":"public static LoggerContextVO decode(GenericRecord datum) {\n    if (datum != null) {\n      long birthTime = (Long) datum.get(\"birthTime\");\n      String name = stringOrNull(datum.get(\"name\"));\n      //noinspection unchecked\n      Map<String, String> propertyMap = LoggingEvent.decodeMdcMap((Map<?, ?>) datum.get(\"propertyMap\"));\n      return new LoggerContextVO(name, propertyMap, birthTime);\n    }\n    return null;\n  }","commit_id":"1ccc4a5a58af4f1240f8ca2b5f01397cba6073e3","url":"https://github.com/caskdata/cdap"},{"original_method":"public LoggingEvent(ILoggingEvent loggingEvent) {\n    this.threadName = loggingEvent.getThreadName();\n    this.level = loggingEvent.getLevel().toInt();\n    this.message = loggingEvent.getMessage();\n\n    if (loggingEvent.getArgumentArray() != null) {\n      this.argumentArray = new String[loggingEvent.getArgumentArray().length];\n      int i = 0;\n      for (Object obj : loggingEvent.getArgumentArray()) {\n        this.argumentArray[i++] = obj == null ? null : obj.toString();\n      }\n    }\n\n    this.formattedMessage = loggingEvent.getFormattedMessage();\n    this.loggerName = loggingEvent.getLoggerName();\n    this.loggerContextVO = loggingEvent.getLoggerContextVO();\n    this.throwableProxy = ThrowableProxyVO.build(loggingEvent.getThrowableProxy());\n\n    if (loggingEvent.hasCallerData()) {\n      this.callerData = loggingEvent.getCallerData();\n    }\n    this.hasCallerData = loggingEvent.hasCallerData();\n\n    this.marker = loggingEvent.getMarker();\n    this.mdc = loggingEvent.getMDCPropertyMap();\n    this.timestamp = loggingEvent.getTimeStamp();\n  }","id":49539,"modified_method":"public LoggingEvent(ILoggingEvent loggingEvent) {\n    this.threadName = loggingEvent.getThreadName();\n    this.level = loggingEvent.getLevel() == null ? Level.ERROR_INT : loggingEvent.getLevel().toInt();\n    this.message = loggingEvent.getMessage();\n\n    if (loggingEvent.getArgumentArray() != null) {\n      this.argumentArray = new String[loggingEvent.getArgumentArray().length];\n      int i = 0;\n      for (Object obj : loggingEvent.getArgumentArray()) {\n        this.argumentArray[i++] = obj == null ? null : obj.toString();\n      }\n    }\n\n    this.formattedMessage = loggingEvent.getFormattedMessage();\n    this.loggerName = loggingEvent.getLoggerName();\n    this.loggerContextVO = loggingEvent.getLoggerContextVO();\n    this.throwableProxy = ThrowableProxyVO.build(loggingEvent.getThrowableProxy());\n\n    if (loggingEvent.hasCallerData()) {\n      this.callerData = loggingEvent.getCallerData();\n    }\n    this.hasCallerData = loggingEvent.hasCallerData();\n\n    this.marker = loggingEvent.getMarker();\n    this.mdc = loggingEvent.getMDCPropertyMap();\n    this.timestamp = loggingEvent.getTimeStamp();\n  }","commit_id":"1ccc4a5a58af4f1240f8ca2b5f01397cba6073e3","url":"https://github.com/caskdata/cdap"},{"original_method":"public static ILoggingEvent decode(GenericRecord datum) {\n    LoggingEvent loggingEvent = new LoggingEvent();\n    loggingEvent.threadName = stringOrNull(datum.get(\"threadName\"));\n    loggingEvent.level = (Integer) datum.get(\"level\");\n    loggingEvent.message = stringOrNull(datum.get(\"message\"));\n\n    GenericArray<?> argArray = (GenericArray<?>) datum.get(\"argumentArray\");\n    if (argArray != null) {\n      loggingEvent.argumentArray = new String[argArray.size()];\n      for (int i = 0; i < argArray.size(); ++i) {\n        loggingEvent.argumentArray[i] = argArray.get(i) == null ? null : argArray.get(i).toString();\n      }\n    }\n    loggingEvent.formattedMessage = stringOrNull(datum.get(\"formattedMessage\"));\n    loggingEvent.loggerName = stringOrNull(datum.get(\"loggerName\"));\n    loggingEvent.loggerContextVO = LoggerContextSerializer.decode((GenericRecord) datum.get(\"loggerContextVO\"));\n    loggingEvent.throwableProxy = ThrowableProxySerializer.decode((GenericRecord) datum.get(\"throwableProxy\"));\n    //noinspection unchecked\n    loggingEvent.callerData = CallerDataSerializer.decode((GenericArray<GenericRecord>) datum.get(\"callerData\"));\n    loggingEvent.hasCallerData = (Boolean) datum.get(\"hasCallerData\");\n    //loggingEvent.marker =\n    loggingEvent.mdc = convertToStringMap((Map<?, ?>) datum.get(\"mdc\"));\n    loggingEvent.timestamp = (Long) datum.get(\"timestamp\");\n    return loggingEvent;\n  }","id":49540,"modified_method":"public static ILoggingEvent decode(GenericRecord datum) {\n    LoggingEvent loggingEvent = new LoggingEvent();\n    loggingEvent.threadName = stringOrNull(datum.get(\"threadName\"));\n    loggingEvent.level = (Integer) datum.get(\"level\");\n    loggingEvent.message = stringOrNull(datum.get(\"message\"));\n\n    GenericArray<?> argArray = (GenericArray<?>) datum.get(\"argumentArray\");\n    if (argArray != null) {\n      loggingEvent.argumentArray = new String[argArray.size()];\n      for (int i = 0; i < argArray.size(); ++i) {\n        loggingEvent.argumentArray[i] = argArray.get(i) == null ? null : argArray.get(i).toString();\n      }\n    }\n    loggingEvent.formattedMessage = stringOrNull(datum.get(\"formattedMessage\"));\n    loggingEvent.loggerName = stringOrNull(datum.get(\"loggerName\"));\n    loggingEvent.loggerContextVO = LoggerContextSerializer.decode((GenericRecord) datum.get(\"loggerContextVO\"));\n    loggingEvent.throwableProxy = ThrowableProxySerializer.decode((GenericRecord) datum.get(\"throwableProxy\"));\n    //noinspection unchecked\n    loggingEvent.callerData = CallerDataSerializer.decode((GenericArray<GenericRecord>) datum.get(\"callerData\"));\n    loggingEvent.hasCallerData = (Boolean) datum.get(\"hasCallerData\");\n    //loggingEvent.marker =\n    loggingEvent.mdc = decodeMdcMap((Map<?, ?>) datum.get(\"mdc\"));\n    loggingEvent.timestamp = (Long) datum.get(\"timestamp\");\n    return loggingEvent;\n  }","commit_id":"1ccc4a5a58af4f1240f8ca2b5f01397cba6073e3","url":"https://github.com/caskdata/cdap"},{"original_method":"private static Map<String, String> generateContextMdc(Map<String, String> mdc) {\n    LoggingContext loggingContext = LoggingContextAccessor.getLoggingContext();\n    if (loggingContext == null) {\n      throw new IllegalStateException(String.format(\"Logging context not setup correctly for MDC %s\", mdc));\n    }\n\n    Map<String, SystemTag> systemTagMap = LoggingContextAccessor.getLoggingContext().getSystemTagsMap();\n    Map<String, String> contextMdcMap = Maps.newHashMapWithExpectedSize(systemTagMap.size() + MAX_MDC_TAGS);\n    // First add MAX_MDC_TAGS MDC tags\n    int i = 0;\n    for (Map.Entry<String, String> entry : mdc.entrySet()) {\n      if (i++ > MAX_MDC_TAGS) {\n        break;\n      }\n      // Any tag beginning with . is reserved\n      if (entry.getKey() == null || !entry.getKey().startsWith(\".\")) {\n        // AVRO does not allow null map keys.\n        contextMdcMap.put(entry.getKey() == null ? MDC_NULL_KEY : entry.getKey(), entry.getValue());\n      }\n    }\n\n    for (Map.Entry<String, SystemTag> entry : systemTagMap.entrySet()) {\n      contextMdcMap.put(entry.getKey(), entry.getValue().getValue());\n    }\n    return contextMdcMap;\n  }","id":49541,"modified_method":"static Map<String, String> generateContextMdc(Map<String, String> mdc) {\n    LoggingContext loggingContext = LoggingContextAccessor.getLoggingContext();\n    if (loggingContext == null) {\n      throw new IllegalStateException(String.format(\"Logging context not setup correctly for MDC %s\", mdc));\n    }\n\n    Map<String, String> contextMdcMap = encodeMdcMap(mdc);\n\n    Map<String, SystemTag> systemTagMap = LoggingContextAccessor.getLoggingContext().getSystemTagsMap();\n    for (Map.Entry<String, SystemTag> entry : systemTagMap.entrySet()) {\n      contextMdcMap.put(entry.getKey(), entry.getValue().getValue());\n    }\n    return contextMdcMap;\n  }","commit_id":"1ccc4a5a58af4f1240f8ca2b5f01397cba6073e3","url":"https://github.com/caskdata/cdap"},{"original_method":"public static boolean assertLoggingEventEquals(ILoggingEvent expected, ILoggingEvent actual) {\n    if (!expected.getLevel().equals(actual.getLevel())) {\n      return false;\n    }\n    if (notBothNull(expected.getLoggerName(), actual.getLoggerName()) &&\n      !expected.getLoggerName().equals(actual.getLoggerName())) {\n      return false;\n    }\n    if (notBothNull(expected.getMessage(), actual.getMessage()) &&\n      !expected.getMessage().equals(actual.getMessage())) {\n      return false;\n    }\n    Assert.assertArrayEquals(expected.getArgumentArray(), actual.getArgumentArray());\n    if (!expected.getThreadName().equals(actual.getThreadName())) {\n      return false;\n    }\n    if (expected.getTimeStamp() != actual.getTimeStamp()) {\n      return false;\n    }\n    if (expected.hasCallerData() != actual.hasCallerData()) {\n      return false;\n    }\n    if (expected.hasCallerData()) {\n      Assert.assertArrayEquals(expected.getCallerData(), actual.getCallerData());\n    }\n    return !(expected.getThrowableProxy() != actual.getThrowableProxy() &&\n      !expected.getThrowableProxy().equals(actual.getThrowableProxy()));\n  }","id":49542,"modified_method":"public static void assertLoggingEventEquals(ILoggingEvent expected, ILoggingEvent actual) {\n    expected.getMDCPropertyMap().putAll(\n      ImmutableMap.of(\".accountId\", \"TEST_ACCT_ID1\", \".applicationId\", \"TEST_APP_ID1\"));\n\n    Assert.assertEquals(expected.getThreadName(), actual.getThreadName());\n    Assert.assertEquals(expected.getLevel(), actual.getLevel());\n    Assert.assertEquals(expected.getMessage(), actual.getMessage());\n    Assert.assertArrayEquals(expected.getArgumentArray(), actual.getArgumentArray());\n    Assert.assertEquals(expected.getFormattedMessage(), actual.getFormattedMessage());\n\n    Assert.assertEquals(expected.getLoggerName(), actual.getLoggerName());\n    Assert.assertEquals(expected.getLoggerContextVO(), actual.getLoggerContextVO());\n\n    Assert.assertEquals(expected.hasCallerData(), actual.hasCallerData());\n    if (expected.hasCallerData()) {\n      Assert.assertArrayEquals(expected.getCallerData(), actual.getCallerData());\n    }\n\n    Assert.assertEquals(expected.getMarker(), actual.getMarker());\n    Assert.assertEquals(expected.getTimeStamp(), actual.getTimeStamp());\n    Assert.assertEquals(expected.getMDCPropertyMap(), actual.getMDCPropertyMap());\n\n    assertThrowableProxyEquals(expected.getThrowableProxy(), actual.getThrowableProxy());\n  }","commit_id":"1ccc4a5a58af4f1240f8ca2b5f01397cba6073e3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSerialization() throws Exception {\n    Map<String, String> mdcMap = Maps.newHashMap();\n    mdcMap.put(\"mdc1\", \"mdc-val1\");\n    mdcMap.put(\"mdc2\", null);\n    mdcMap.put(null, null);\n\n    LoggingEventSerializer serializer = new LoggingEventSerializer(new VerifiableProperties());\n    ch.qos.logback.classic.spi.LoggingEvent iLoggingEvent = new ch.qos.logback.classic.spi.LoggingEvent();\n    iLoggingEvent.setLevel(Level.INFO);\n    iLoggingEvent.setLoggerName(\"loggerName1\");\n    iLoggingEvent.setMessage(\"Log message1\");\n    iLoggingEvent.setArgumentArray(new Object[]{null, \"arg2\", \"100\"});\n    iLoggingEvent.setThreadName(\"threadName1\");\n    iLoggingEvent.setTimeStamp(1234567890L);\n    iLoggingEvent.setMDCPropertyMap(mdcMap);\n    iLoggingEvent.setCallerData(new StackTraceElement[]{\n      new StackTraceElement(\"com.Class1\", \"methodName1\", \"fileName1\", 10),\n      null,\n      new StackTraceElement(\"com.Class2\", \"methodName2\", \"fileName2\", 20),\n      new StackTraceElement(\"com.Class3\",  \"methodName3\", null, 30),\n    });\n    Exception e1 = new Exception(null, null);\n    Exception e2 = new Exception(\"Test Exception2\", e1);\n    iLoggingEvent.setThrowableProxy(new ThrowableProxy(e2));\n    iLoggingEvent.prepareForDeferredProcessing();\n    ((ThrowableProxy) iLoggingEvent.getThrowableProxy()).calculatePackagingData();\n\n    // Serialize\n    LoggingEvent event = new LoggingEvent(iLoggingEvent);\n    byte [] serializedBytes = serializer.toBytes(event);\n\n    // De-serialize\n    ILoggingEvent actualEvent = serializer.fromBytes(ByteBuffer.wrap(serializedBytes));\n    System.out.println(actualEvent);\n    assertLoggingEventEquals(iLoggingEvent, actualEvent);\n  }","id":49543,"modified_method":"@Test\n  public void testSerialization() throws Exception {\n    Map<String, String> mdcMap = Maps.newHashMap();\n    mdcMap.put(\"mdc1\", \"mdc-val1\");\n    mdcMap.put(\"mdc2\", null);\n    mdcMap.put(null, null);\n\n    Map<String, String> contextMap = Maps.newHashMap();\n    contextMap.put(\"p1\", \"ctx-val1\");\n    contextMap.put(\"p2\", null);\n    contextMap.put(null, null);\n\n    LoggingEventSerializer serializer = new LoggingEventSerializer(new VerifiableProperties());\n    ch.qos.logback.classic.spi.LoggingEvent iLoggingEvent = new ch.qos.logback.classic.spi.LoggingEvent();\n    iLoggingEvent.setThreadName(\"threadName1\");\n    iLoggingEvent.setLevel(Level.INFO);\n    iLoggingEvent.setMessage(\"Log message1\");\n    iLoggingEvent.setArgumentArray(new Object[]{null, \"arg2\", \"100\", null});\n    iLoggingEvent.setLoggerName(\"loggerName1\");\n\n    iLoggingEvent.setLoggerContextRemoteView(new LoggerContextVO(\"logger_context1\", contextMap, 12345634234L));\n\n    Exception e1 = new Exception(null, null);\n    Exception e2 = new Exception(\"Test Exception2\", e1);\n    iLoggingEvent.setThrowableProxy(new ThrowableProxy(e2));\n    iLoggingEvent.prepareForDeferredProcessing();\n    ((ThrowableProxy) iLoggingEvent.getThrowableProxy()).calculatePackagingData();\n\n    iLoggingEvent.setCallerData(new StackTraceElement[]{\n      new StackTraceElement(\"com.Class1\", \"methodName1\", \"fileName1\", 10),\n      null,\n      new StackTraceElement(\"com.Class2\", \"methodName2\", \"fileName2\", 20),\n      new StackTraceElement(\"com.Class3\",  \"methodName3\", null, 30),\n      null\n    });\n\n    iLoggingEvent.setMarker(null);\n    iLoggingEvent.getMDCPropertyMap().putAll(mdcMap);\n    iLoggingEvent.setTimeStamp(1234567890L);\n\n    // Serialize\n    LoggingEvent event = new LoggingEvent(iLoggingEvent);\n    byte [] serializedBytes = serializer.toBytes(event);\n\n    // De-serialize\n    ILoggingEvent actualEvent = serializer.fromBytes(ByteBuffer.wrap(serializedBytes));\n    System.out.println(actualEvent);\n    assertLoggingEventEquals(iLoggingEvent, actualEvent);\n  }","commit_id":"1ccc4a5a58af4f1240f8ca2b5f01397cba6073e3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSerialize() throws Exception {\n    ch.qos.logback.classic.spi.LoggingEvent iLoggingEvent = new ch.qos.logback.classic.spi.LoggingEvent();\n    iLoggingEvent.setLevel(Level.ERROR);\n    iLoggingEvent.setLoggerName(\"loggerName1\");\n    iLoggingEvent.setMessage(\"Log message1\");\n    iLoggingEvent.setArgumentArray(new Object[] {\"arg1\", \"arg2\", \"100\"});\n    iLoggingEvent.setThreadName(\"threadName1\");\n    iLoggingEvent.setTimeStamp(1234567890L);\n    iLoggingEvent.setLoggerContextRemoteView(new LoggerContextVO(\"loggerContextRemoteView\",\n                                                                 ImmutableMap.of(\"key1\", \"value1\", \"key2\", \"value2\"),\n                                                                 100000L));\n    iLoggingEvent.setMDCPropertyMap(ImmutableMap.of(\"mdck1\", \"mdcv1\", \"mdck2\", \"mdck2\"));\n\n    Schema schema = new Schema.Parser().parse(getClass().getResourceAsStream(\"/logging/schema/LoggingEvent.avsc\"));\n    GenericRecord datum = LoggingEvent.encode(schema, iLoggingEvent);\n\n    LoggingEvent actualEvent = new LoggingEvent(LoggingEvent.decode(datum));\n    LoggingEventSerializerTest.assertLoggingEventEquals(iLoggingEvent, actualEvent);\n  }","id":49544,"modified_method":"@Test\n  public void testSerialize() throws Exception {\n    ch.qos.logback.classic.spi.LoggingEvent iLoggingEvent = new ch.qos.logback.classic.spi.LoggingEvent();\n    iLoggingEvent.setLevel(Level.ERROR);\n    iLoggingEvent.setLoggerName(\"loggerName1\");\n    iLoggingEvent.setMessage(\"Log message1\");\n    iLoggingEvent.setArgumentArray(new Object[] {\"arg1\", \"arg2\", \"100\"});\n    iLoggingEvent.setThreadName(\"threadName1\");\n    iLoggingEvent.setTimeStamp(1234567890L);\n    iLoggingEvent.setLoggerContextRemoteView(new LoggerContextVO(\"loggerContextRemoteView\",\n                                                                 ImmutableMap.of(\"key1\", \"value1\", \"key2\", \"value2\"),\n                                                                 100000L));\n    Map<String, String> mdcMap = Maps.newHashMap(ImmutableMap.of(\"mdck1\", \"mdcv1\", \"mdck2\", \"mdck2\"));\n    iLoggingEvent.setMDCPropertyMap(mdcMap);\n\n    Schema schema = new Schema.Parser().parse(getClass().getResourceAsStream(\"/logging/schema/LoggingEvent.avsc\"));\n    GenericRecord datum = LoggingEvent.encode(schema, iLoggingEvent);\n\n    LoggingEvent actualEvent = new LoggingEvent(LoggingEvent.decode(datum));\n    LoggingEventSerializerTest.assertLoggingEventEquals(iLoggingEvent, actualEvent);\n  }","commit_id":"1ccc4a5a58af4f1240f8ca2b5f01397cba6073e3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Get the JMF streams.\n     *\n     * @return streams (one element in image streaming case)\n     */\n    public PushBufferStream[] getStreams()\n    {\n        if(stream == null)\n        {\n            stream = new ImageStream(getLocator());\n            /* XXX allow to select other format */\n            stream.setFormat(getFormats()[4]);\n        }\n\n        return (stream == null) ? EMPTY_STREAMS : \n            new PushBufferStream[] {stream};\n    }","id":49545,"modified_method":"/**\n     * Get the JMF streams.\n     *\n     * @return streams (one element in image streaming case)\n     */\n    public PushBufferStream[] getStreams()\n    {\n        if(stream == null)\n        {\n            stream = new ImageStream(getLocator());\n            /* XXX allow to select other format */\n            stream.setFormat(getFormats()[5]);\n        }\n\n        return (stream == null) ? EMPTY_STREAMS : \n            new PushBufferStream[] {stream};\n    }","commit_id":"67e5dc87ca982422d7a2f4d2e2f918fab493f884","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Thread entry point.\n     */\n    public void run()\n    {\n        screen = null;\n\n        synchronized(this)\n        {\n            while(transferHandler == null && started) \n            {\n                try \n                {\n                    wait(1000);\n                } \n                catch (InterruptedException e)\n                {\n                }\n            }\n        }\n    \n        while(started)\n        {\n            if(started && transferHandler != null) \n            {\n                try \n                {\n                    screen = RobotDesktopInteractImpl.getInstance().captureScreen();\n                    transferHandler.transferData(this);\n\n                    /* 200 ms */\n                    Thread.sleep(200);\n                } \n                catch(AWTException ae)\n                {\n                    logger.warn(\"Desktop capture failed!\");\n                }\n                catch (InterruptedException e) \n                {\n                }\n            }\n        }\n    }","id":49546,"modified_method":"/**\n     * Thread entry point.\n     */\n    public void run()\n    {\n        final Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();\n        final RGBFormat format = (RGBFormat)currentFormat;\n        final int width = (int)format.getSize().getWidth();\n        final int height = (int)format.getSize().getHeight();\n        BufferedImage scaledScreen = null;\n        BufferedImage screen = null;\n        Buffer buffer = new Buffer();\n        byte data[] = null;\n\n        /* capture first full desktop screen \n        try\n        {\n            screen = RobotDesktopInteractImpl.getInstance().captureScreen();\n            scaledScreen = ImageStreamingUtils.getScaledImage(screen, \n                width, height, BufferedImage.TYPE_INT_ARGB);\n        }\n        catch(Exception e)\n        {\n        }\n\n        screen = null;\n        */\n/*\n        synchronized(this)\n        {\n            while(transferHandler == null && started) \n            {\n                try \n                {\n                    wait(1000);\n                } \n                catch (InterruptedException e)\n                {\n                }\n            }\n        }\n*/\n        while(started)\n        {\n            try \n            {\n                long t = System.nanoTime();\n\n                /* get desktop screen and resize it */\n                screen = RobotDesktopInteractImpl.getInstance().captureScreen();\n                scaledScreen = ImageStreamingUtils.getScaledImage(screen, \n                    width, height, BufferedImage.TYPE_INT_ARGB);\n\n                /* get raw bytes */\n                data = ImageStreamingUtils.getImageByte(scaledScreen);\n        \n                /* add it to a RingBuffer and notify JMF that new data\n                 * is available\n                 */\n                buffer.setData(data);\n                buffer.setOffset(0);\n                buffer.setLength(data.length);\n                buffer.setFormat(currentFormat);\n                buffer.setHeader(null);\n                buffer.setTimeStamp(System.nanoTime());\n                buffer.setSequenceNumber(seqNo);\n                buffer.setFlags(Buffer.FLAG_LIVE_DATA | Buffer.FLAG_SYSTEM_TIME);\n                seqNo++;\n\n                ringBuffer.put(buffer);\n\n                /* pass to JMF handler */\n                if(transferHandler != null)\n                {\n                    transferHandler.transferData(this);\n                }\n                \n                t = System.nanoTime() - t;\n                logger.info(\"Desktop capture processing time: \" + t);\n                \n                /* cleanup */\n                screen = null;\n                scaledScreen = null;\n                data = null;\n\n                /* 500 ms */\n                Thread.sleep(500);\n            } \n            catch(AWTException ae)\n            {\n                logger.warn(\"Desktop capture failed!\");\n            }\n            catch (InterruptedException e) \n            {\n            }\n        }\n\n        buffer = null;\n    }","commit_id":"67e5dc87ca982422d7a2f4d2e2f918fab493f884","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Stop desktop capture stream.\n     */\n    public void stop()\n    {\n        System.out.println(\"Stop stream!\");\n        started = false;\n        captureThread = null;\n    }","id":49547,"modified_method":"/**\n     * Stop desktop capture stream.\n     */\n    public void stop()\n    {\n        logger.info(\"Stop stream\");\n        started = false;\n        captureThread = null;\n    }","commit_id":"67e5dc87ca982422d7a2f4d2e2f918fab493f884","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Block and read a buffer from the stream.\n     *\n     * @param buffer the <tt>Buffer<\/tt> to read captured media into\n     * @throws IOException if an error occurs while reading.\n     */\n    public void read(Buffer buffer) throws IOException\n    {\n        /* TODO get last screen capture of the desktop,\n         * convert and put the result in buffer\n         */\n        RGBFormat format = (RGBFormat)currentFormat;\n        int intData[] = null;\n        byte data[] = null;\n        /* BufferedImage screen = null; */\n        BufferedImage scaledScreen = null;\n        int width = (int)format.getSize().getWidth();\n        int height = (int)format.getSize().getHeight();\n\n        /* get last screencapture and resize it */\n        try\n        {\n            scaledScreen = ImageStreamingUtils.getScaledImage(\n                    screen, width, height, BufferedImage.TYPE_INT_ARGB);\n        }\n        catch(Exception e)\n        {\n            logger.warn(\"Cannot capture screen.\");\n            return;\n        }\n        \n        long t = System.nanoTime();\n\n        data = ImageStreamingUtils.getImageByte(scaledScreen);\n\n        t = System.nanoTime() - t;\n        /* System.out.println(\"Time: \" + t); */\n\n        buffer.setData(data);\n        buffer.setOffset(0);\n        buffer.setLength(data.length * 4);\n        buffer.setFormat(currentFormat);\n        buffer.setHeader(null);\n        buffer.setTimeStamp(System.nanoTime());\n        buffer.setSequenceNumber(seqNo);\n        seqNo++;\n\n        buffer.setFlags(Buffer.FLAG_LIVE_DATA | Buffer.FLAG_SYSTEM_TIME);\n    }","id":49548,"modified_method":"/**\n     * Block and read a buffer from the stream.\n     *\n     * @param buffer the <tt>Buffer<\/tt> to read captured media into\n     * @throws IOException if an error occurs while reading.\n     */\n    public void read(Buffer buffer) throws IOException\n    {\n        try\n        {\n            /* get the next data */\n            Buffer buf = (Buffer)ringBuffer.get();\n\n            buffer.setData(buf.getData());\n            buffer.setOffset(0);\n            buffer.setLength(buf.getLength());\n            buffer.setFormat(buf.getFormat());\n            buffer.setHeader(null);\n            buffer.setTimeStamp(buf.getTimeStamp());\n            buffer.setSequenceNumber(buf.getSequenceNumber());\n            buffer.setFlags(buf.getFlags());\n        }\n        catch(Exception e)\n        {\n        }\n    }","commit_id":"67e5dc87ca982422d7a2f4d2e2f918fab493f884","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Start desktop capture stream.\n     */\n    public void start()\n    {\n        if(captureThread == null || !captureThread.isAlive())\n        {\n            System.out.println(\"Start stream!\");\n            captureThread = new Thread(this);\n            captureThread.start();\n            started = true;\n        }\n    }","id":49549,"modified_method":"/**\n     * Start desktop capture stream.\n     */\n    public void start()\n    {\n        if(captureThread == null || !captureThread.isAlive())\n        {\n            logger.info(\"Start stream\");\n            captureThread = new Thread(this);\n            captureThread.start();\n            ringBuffer = new RingBuffer(5);\n            started = true;\n        }\n    }","commit_id":"67e5dc87ca982422d7a2f4d2e2f918fab493f884","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Get raw bytes from ARGB <tt>BufferedImage<\/tt>.\n     *\n     * @param src ARGB <BufferImage<\/tt>\n     * @return raw bytes or null if src is not an ARGB\n     * <tt>BufferedImage<\/tt>\n     */\n    public static byte[] getImageByte(BufferedImage src)\n    {\n        if(src.getType() != BufferedImage.TYPE_INT_ARGB)\n        {\n            return null;\n        }\n\nif(false)\n{\n        /* get raw bytes */\n        int intData[] = ((DataBufferInt)src.getData().getDataBuffer()).getData();\n        byte data[] = new byte[intData.length * 4];\n\n        /* convert to byte (Java is always big endian) */\n        for(int i = 0 ; i < intData.length ; i++)\n        {\n            data[(i * 4) + 3] = (byte)(intData[i] >>> 24);\n            data[(i * 4) + 2] = (byte)(intData[i] >>> 16);\n            data[(i * 4) + 1] = (byte)(intData[i] >>> 8);\n            data[(i * 4)] = (byte)(intData[i]);\n        }\n        return data;\n}\n\n        WritableRaster raster = src.getRaster();\n        byte data[] = null;\n        int width = src.getWidth();\n        int height = src.getHeight();\n        int pixel[] = new int[4];\n        int off = 0;\n\n        /* allocate our bytes array */\n        data = new byte[width * height * 4];\n        \n        for(int y = 0 ; y < height ; y++)\n        {\n            for(int x = 0 ; x < width ; x++)\n            {\n                raster.getPixel(x, y, pixel);\n                data[off++] = (byte)pixel[0];\n                data[off++] = (byte)pixel[1];\n                data[off++] = (byte)pixel[2];\n                data[off++] = (byte)pixel[3];\n            }\n        }\n\n        raster = null;\n        pixel = null;\n        return data;\n    }","id":49550,"modified_method":"/**\n     * Get raw bytes from ARGB <tt>BufferedImage<\/tt>.\n     *\n     * @param src ARGB <BufferImage<\/tt>\n     * @return raw bytes or null if src is not an ARGB\n     * <tt>BufferedImage<\/tt>\n     */\n    public static byte[] getImageByte(BufferedImage src)\n    {\n        if(src.getType() != BufferedImage.TYPE_INT_ARGB)\n        {\n            return null;\n        }\n\n        WritableRaster raster = src.getRaster();\n        byte data[] = null;\n        int pixel[] = new int[4];\n        int width = src.getWidth();\n        int height = src.getHeight();\n        int off = 0;\n\n        /* allocate our bytes array */\n        data = new byte[width * height * 4];\n        \n        for(int y = 0 ; y < height ; y++)\n        {\n            for(int x = 0 ; x < width ; x++)\n            {\n                raster.getPixel(x, y, pixel);\n                data[off++] = (byte)pixel[0];\n                data[off++] = (byte)pixel[1];\n                data[off++] = (byte)pixel[2];\n                data[off++] = (byte)pixel[3];\n            }\n        }\n\n        raster = null;\n        pixel = null;\n        return data;\n    }","commit_id":"67e5dc87ca982422d7a2f4d2e2f918fab493f884","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Get the unique instance of <tt>RobotDesktopInteractImpl<\/tt>.\n     *\n     * @return instance\n     * @throws AWTException if platform configuration does not allow low-level input control\n     * @throws SecurityException if Robot creation is not permitted\n     */\n    public static RobotDesktopInteractImpl getInstance() throws AWTException, SecurityException\n    {\n        if(instance == null)\n        {\n            instance = new RobotDesktopInteractImpl();\n        }\n        return instance;\n    }","id":49551,"modified_method":"/**\n     * Get the unique instance of <tt>RobotDesktopInteractImpl<\/tt>.\n     *\n     * @return instance\n     * @throws AWTException if platform configuration does not allow low-level input control\n     * @throws SecurityException if Robot creation is not permitted\n     */\n    public static RobotDesktopInteractImpl getInstance() throws AWTException, SecurityException\n    {\n        if(instance == null)\n        {\n            instance = new RobotDesktopInteractImpl();\n            instance.robot = new Robot();\n        }\n\n        return instance;\n    }","commit_id":"67e5dc87ca982422d7a2f4d2e2f918fab493f884","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Capture a part of the desktop screen.\n     *\n     * @return <tt>BufferedImage<\/tt> of a part of the desktop screen\n     * or null if Robot problem\n     */\n    public BufferedImage captureScreen(int x, int y, int width, int height)\n    {\n        BufferedImage img = null;\n        Rectangle rect = null;\n      \n        /* Robot has not been created so abort */\n        if(robot == null)\n        {\n            return null;\n        }\n\n        logger.info(\"Begin \" + System.nanoTime());\n        rect = new Rectangle(x, y, width, height);\n        img = robot.createScreenCapture(rect);\n        logger.info(\"End \" + System.nanoTime());\n        return img;\n    }","id":49552,"modified_method":"/**\n     * Capture a part of the desktop screen.\n     *\n     * @return <tt>BufferedImage<\/tt> of a part of the desktop screen\n     * or null if Robot problem\n     */\n    public BufferedImage captureScreen(int x, int y, int width, int height)\n    {\n        BufferedImage img = null;\n        Rectangle rect = null;\n      \n        /* Robot has not been created so abort */\n        if(robot == null)\n        {\n            return null;\n        }\n\n        logger.info(\"Begin capture: \" + System.nanoTime());\n        rect = new Rectangle(x, y, width, height);\n        img = robot.createScreenCapture(rect);\n        logger.info(\"End capture: \" + System.nanoTime());\n        return img;\n    }","commit_id":"67e5dc87ca982422d7a2f4d2e2f918fab493f884","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Constructor.\n     *\n     * @throws AWTException if platform configuration does not allow low-level input control\n     * @throws SecurityException if Robot creation is not permitted\n     */\n    private RobotDesktopInteractImpl() throws AWTException, SecurityException\n    {\n    }","id":49553,"modified_method":"/**\n     * Constructor.\n     */\n    private RobotDesktopInteractImpl() \n    {\n    }","commit_id":"67e5dc87ca982422d7a2f4d2e2f918fab493f884","url":"https://github.com/jitsi/jitsi"},{"original_method":"private void makeSearch(Module module) throws IOException {\n        FileWriter writer = new FileWriter(new File(destDir, \"search.html\"));\n        try {\n            new Search(module, this, writer).generate();\n        } finally {\n            writer.close();\n        }\n    }","id":49554,"modified_method":"private void makeSearch(Module module) throws IOException {\n        Writer writer = openWriter(new File(destDir, \"search.html\"));\n        try {\n            new Search(module, this, writer).generate();\n        } finally {\n            writer.close();\n        }\n    }","commit_id":"8f4d5a743f94870292017a667e811069ac09974f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void doc(Declaration decl) throws IOException {\n        if (decl instanceof ClassOrInterface) {\n            if (shouldInclude(decl)) {\n                FileWriter writer = new FileWriter(getObjectFile(decl));\n                try {\n                    new ClassDoc(this, writer,\n                            (ClassOrInterface) decl,\n                            subclasses.get(decl),\n                            satisfyingClassesOrInterfaces.get(decl)).generate();\n                } finally {\n                    writer.close();\n                }\n            }\n        }\n    }","id":49555,"modified_method":"private void doc(Declaration decl) throws IOException {\n        if (decl instanceof ClassOrInterface) {\n            if (shouldInclude(decl)) {\n                Writer writer = openWriter(getObjectFile(decl));\n                try {\n                    new ClassDoc(this, writer,\n                            (ClassOrInterface) decl,\n                            subclasses.get(decl),\n                            satisfyingClassesOrInterfaces.get(decl)).generate();\n                } finally {\n                    writer.close();\n                }\n            }\n        }\n    }","commit_id":"8f4d5a743f94870292017a667e811069ac09974f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void makeIndex(Module module) throws IOException {\n        File dir = getResourcesDir();\n        FileWriter writer = new FileWriter(new File(dir, \"index.js\"));\n        try {\n            new IndexDoc(this, writer, module).generate();\n        } finally {\n            writer.close();\n        }\n    }","id":49556,"modified_method":"private void makeIndex(Module module) throws IOException {\n        File dir = getResourcesDir();\n        Writer writer = openWriter(new File(dir, \"index.js\"));\n        try {\n            new IndexDoc(this, writer, module).generate();\n        } finally {\n            writer.close();\n        }\n    }","commit_id":"8f4d5a743f94870292017a667e811069ac09974f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void copySourceFiles() throws FileNotFoundException, IOException {\n        for (PhasedUnit pu : phasedUnits) {\n            File file = new File(getFolder(pu.getPackage()), pu.getUnitFile().getName()+\".html\");\n            File dir = file.getParentFile();\n            if (!dir.exists() && !dir.mkdirs()) {\n                throw new IOException(\"Couldn't create directory for file: \" + file);\n            }\n            FileWriter writer = new FileWriter(file);\n            try {\n            Markup markup = new Markup(writer);\n                markup.write(\"<?xml charset='UTF-8'?>\");\n                markup.write(\"<!DOCTYPE html>\");\n                markup.open(\"html\", \"head\");\n                markup.around(\"title\", pu.getUnit().getFilename());\n                Package decl = pu.getUnit().getPackage();\n                markup.tag(\"link href='\" + getResourceUrl(decl, \"shCore.css\") + \"' rel='stylesheet' type='text/css'\");\n                markup.tag(\"link href='\" + getResourceUrl(decl, \"shThemeDefault.css\") + \"' rel='stylesheet' type='text/css'\");\n                markup.around(\"script type='text/javascript' src='\"+getResourceUrl(decl, \"jquery-1.7.min.js\")+\"'\");\n                markup.around(\"script type='text/javascript' src='\"+getResourceUrl(decl, \"ceylond.js\")+\"'\");\n                markup.around(\"script src='\" + getResourceUrl(decl, \"shCore.js\") + \"' type='text/javascript'\");\n                markup.around(\"script src='\" + getResourceUrl(decl, \"shBrushCeylon.js\") + \"' type='text/javascript'\");\n                markup.close(\"head\");\n                markup.open(\"body\", \"pre class='brush: ceylon'\");\n                // XXX source char encoding\n                BufferedReader input = new BufferedReader(new InputStreamReader(pu.getUnitFile().getInputStream()));\n                try{\n                    String line = input.readLine();\n                    while (line != null) {\n                        markup.text(line, \"\\n\");\n                        line = input.readLine();\n                    }\n                } finally {\n                    input.close();\n                }\n                markup.close(\"pre\", \"body\", \"html\");\n            } finally {\n                writer.close();\n            }\n        }\n    }","id":49557,"modified_method":"private void copySourceFiles() throws FileNotFoundException, IOException {\n        for (PhasedUnit pu : phasedUnits) {\n            File file = new File(getFolder(pu.getPackage()), pu.getUnitFile().getName()+\".html\");\n            File dir = file.getParentFile();\n            if (!dir.exists() && !dir.mkdirs()) {\n                throw new IOException(\"Couldn't create directory for file: \" + file);\n            }\n            Writer writer = openWriter(file);\n            try {\n            Markup markup = new Markup(writer);\n                markup.write(\"<?xml charset='UTF-8'?>\");\n                markup.write(\"<!DOCTYPE html>\");\n                markup.open(\"html\", \"head\");\n                markup.around(\"title\", pu.getUnit().getFilename());\n                Package decl = pu.getUnit().getPackage();\n                markup.tag(\"link href='\" + getResourceUrl(decl, \"shCore.css\") + \"' rel='stylesheet' type='text/css'\");\n                markup.tag(\"link href='\" + getResourceUrl(decl, \"shThemeDefault.css\") + \"' rel='stylesheet' type='text/css'\");\n                markup.around(\"script type='text/javascript' src='\"+getResourceUrl(decl, \"jquery-1.7.min.js\")+\"'\");\n                markup.around(\"script type='text/javascript' src='\"+getResourceUrl(decl, \"ceylond.js\")+\"'\");\n                markup.around(\"script src='\" + getResourceUrl(decl, \"shCore.js\") + \"' type='text/javascript'\");\n                markup.around(\"script src='\" + getResourceUrl(decl, \"shBrushCeylon.js\") + \"' type='text/javascript'\");\n                markup.close(\"head\");\n                markup.open(\"body\", \"pre class='brush: ceylon'\");\n                // XXX source char encoding\n                BufferedReader input = new BufferedReader(new InputStreamReader(pu.getUnitFile().getInputStream()));\n                try{\n                    String line = input.readLine();\n                    while (line != null) {\n                        markup.text(line, \"\\n\");\n                        line = input.readLine();\n                    }\n                } finally {\n                    input.close();\n                }\n                markup.close(\"pre\", \"body\", \"html\");\n            } finally {\n                writer.close();\n            }\n        }\n    }","commit_id":"8f4d5a743f94870292017a667e811069ac09974f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void doc(Module module) throws IOException {\n        FileWriter rootWriter = new FileWriter(getObjectFile(module));\n        try {\n            ModuleDoc moduleDoc = new ModuleDoc(this, rootWriter, module);\n            moduleDoc.generate();\n            for (Package pkg : module.getPackages()) {\n                if (isRootPackage(module, pkg)) {\n                    new PackageDoc(this, rootWriter, pkg).generate();\n                } else {\n                    FileWriter packageWriter = new FileWriter(getObjectFile(pkg));\n                    try {\n                        new PackageDoc(this, packageWriter, pkg).generate();\n                    } finally {\n                        packageWriter.close();\n                    }\n                }\n            }\n            moduleDoc.complete();\n        } finally {\n            rootWriter.close();\n        }\n        \n    }","id":49558,"modified_method":"private void doc(Module module) throws IOException {\n        Writer rootWriter = openWriter(getObjectFile(module));\n        try {\n            ModuleDoc moduleDoc = new ModuleDoc(this, rootWriter, module);\n            moduleDoc.generate();\n            for (Package pkg : module.getPackages()) {\n                if (isRootPackage(module, pkg)) {\n                    new PackageDoc(this, rootWriter, pkg).generate();\n                } else {\n                    Writer packageWriter = openWriter(getObjectFile(pkg));\n                    try {\n                        new PackageDoc(this, packageWriter, pkg).generate();\n                    } finally {\n                        packageWriter.close();\n                    }\n                }\n            }\n            moduleDoc.complete();\n        } finally {\n            rootWriter.close();\n        }\n        \n    }","commit_id":"8f4d5a743f94870292017a667e811069ac09974f","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Feature(summary = \"The administrator can set a read-only project \" +\n            \"to writable\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void setAProjectToWritable() throws Exception {\n        assertThat(new ProjectWorkFlow()\n                .goToProjectByName(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .lockProject()\n                .goToProjects()\n                .setActiveFilterEnabled(false)\n                .setReadOnlyFilterEnabled(true)\n                .expectProjectVisible(\"about fedora\")\n                .setArchivedFilterEnabled(false)\n                .getProjectNamesOnCurrentPage())\n                .contains(\"about fedora\")\n                .as(\"The project is locked\");\n\n        ProjectsPage projectsPage = new BasicWorkFlow()\n                .goToHome()\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .unlockProject()\n                .goToProjects()\n                .setActiveFilterEnabled(true)\n                .setReadOnlyFilterEnabled(false)\n                .setArchivedFilterEnabled(false)\n                .expectProjectVisible(\"about fedora\");\n\n        assertThat(projectsPage.getProjectNamesOnCurrentPage())\n                .contains(\"about fedora\")\n                .as(\"The project is now displayed\");\n    }","id":49559,"modified_method":"@Feature(summary = \"The administrator can set a read-only project \" +\n            \"to writable\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 0)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void setAProjectToWritable() throws Exception {\n        assertThat(new ProjectWorkFlow()\n                .goToProjectByName(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .lockProject()\n                .goToProjects()\n                .setActiveFilterEnabled(false)\n                .setReadOnlyFilterEnabled(true)\n                .expectProjectVisible(\"about fedora\")\n                .getProjectNamesOnCurrentPage())\n                .contains(\"about fedora\")\n                .as(\"The project is locked\");\n\n        ProjectsPage projectsPage = new BasicWorkFlow()\n                .goToHome()\n                .goToProjects()\n                .goToProject(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .unlockProject()\n                .goToProjects()\n                .setActiveFilterEnabled(true)\n                .setReadOnlyFilterEnabled(false)\n                .expectProjectVisible(\"about fedora\");\n\n        assertThat(projectsPage.getProjectNamesOnCurrentPage())\n                .contains(\"about fedora\")\n                .as(\"The project is now displayed\");\n    }","commit_id":"df6ce292c7bb59f7cc6c661092f8d4324359110b","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Feature(summary = \"The administrator can set a project to read-only\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 135848)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void setAProjectToReadOnly() throws Exception {\n        ProjectsPage projectsPage = new ProjectWorkFlow()\n                .goToProjectByName(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .lockProject()\n                .goToProjects()\n                .setActiveFilterEnabled(true)\n                .setReadOnlyFilterEnabled(false)\n                .setArchivedFilterEnabled(false)\n                .expectProjectNotVisible(\"about fedora\");\n\n        assertThat(projectsPage.getProjectNamesOnCurrentPage())\n                .doesNotContain(\"about fedora\")\n                .as(\"The project is not displayed\");\n\n        projectsPage = projectsPage.setActiveFilterEnabled(false)\n                .setReadOnlyFilterEnabled(true)\n                .setArchivedFilterEnabled(false)\n                .expectProjectVisible(\"about fedora\");\n\n        assertThat(projectsPage.getProjectNamesOnCurrentPage())\n                .contains(\"about fedora\")\n                .as(\"The project is now displayed\");\n    }","id":49560,"modified_method":"@Feature(summary = \"The administrator can set a project to read-only\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 135848)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void setAProjectToReadOnly() throws Exception {\n        ProjectsPage projectsPage = new ProjectWorkFlow()\n                .goToProjectByName(\"about fedora\")\n                .gotoSettingsTab()\n                .gotoSettingsGeneral()\n                .lockProject()\n                .goToProjects()\n                .setActiveFilterEnabled(true)\n                .setReadOnlyFilterEnabled(false)\n                .expectProjectNotVisible(\"about fedora\");\n\n        assertThat(projectsPage.getProjectNamesOnCurrentPage())\n                .doesNotContain(\"about fedora\")\n                .as(\"The project is not displayed\");\n\n        projectsPage = projectsPage.setActiveFilterEnabled(false)\n                .setReadOnlyFilterEnabled(true)\n                .expectProjectVisible(\"about fedora\");\n\n        assertThat(projectsPage.getProjectNamesOnCurrentPage())\n                .contains(\"about fedora\")\n                .as(\"The project is now displayed\");\n    }","commit_id":"df6ce292c7bb59f7cc6c661092f8d4324359110b","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Press the \"Archive this project\" button\n     * @return new Project General Settings page\n     */\n    public ProjectGeneralTab archiveProject() {\n        log.info(\"Click Archive this project\");\n        clickElement(archiveButton);\n        return new ProjectGeneralTab(getDriver());\n    }","id":49561,"modified_method":"/**\n     * Press the \"Delete this project\" button\n     * @return new Dashboard page\n     */\n    public ProjectGeneralTab deleteProject() {\n        log.info(\"Click Delete this project\");\n        clickElement(deleteButton);\n        return new ProjectGeneralTab(getDriver());\n    }","commit_id":"df6ce292c7bb59f7cc6c661092f8d4324359110b","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Query for availability of the Archive This Project button.\n     * Only Administrators can use this feature.\n     * @return button available true/false\n     */\n    public boolean isArchiveButtonAvailable() {\n        log.info(\"Query is Archive button displayed\");\n        return getDriver().findElements(archiveButton).size() > 0;\n    }","id":49562,"modified_method":"/**\n     * Query for availability of the Archive This Project button.\n     * Only Administrators can use this feature.\n     * @return button available true/false\n     */\n    public boolean isDeleteButtonAvailable() {\n        log.info(\"Query is Archive button displayed\");\n        return getDriver().findElements(deleteButton).size() > 0;\n    }","commit_id":"df6ce292c7bb59f7cc6c661092f8d4324359110b","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n     * Validates the links for the specified resource.<p>\n     * \n     * @param dbc the database context\n     * @param resource the resource that will be validated\n     * @param fileLookup a map for faster lookup with all resources keyed by their rootpath\n     * @param project the project to validate\n     * @param report the report to write to\n     * \n     * @return a list with the broken links as {@link CmsRelation} objects for the specified resource, \n     *          or an empty list if no broken links were found\n     */\n    protected List<CmsRelation> validateLinks(\n        CmsDbContext dbc,\n        CmsResource resource,\n        Map<String, CmsResource> fileLookup,\n        CmsProject project,\n        I_CmsReport report) {\n\n        List<CmsRelation> brokenRelations = new ArrayList<CmsRelation>();\n        Map<String, Boolean> validatedLinks = new HashMap<String, Boolean>();\n\n        // get the relations\n        List<CmsRelation> relations = null;\n        try {\n            if (!resource.getState().isDeleted()) {\n                // search the target of links in the current (offline) project\n                relations = m_driverManager.getRelationsForResource(dbc, resource, CmsRelationFilter.TARGETS);\n            } else {\n                // search the source of links in the online project\n                CmsProject currentProject = dbc.currentProject();\n                dbc.getRequestContext().setCurrentProject(project);\n                try {\n                    relations = m_driverManager.getRelationsForResource(dbc, resource, CmsRelationFilter.SOURCES);\n                } finally {\n                    dbc.getRequestContext().setCurrentProject(currentProject);\n                }\n            }\n        } catch (CmsException e) {\n            LOG.error(Messages.get().getBundle().key(Messages.LOG_LINK_SEARCH_1, resource), e);\n            if (report != null) {\n                report.println(Messages.get().container(\n                    Messages.LOG_LINK_SEARCH_1,\n                    dbc.removeSiteRoot(resource.getRootPath())), I_CmsReport.FORMAT_ERROR);\n            }\n            return brokenRelations;\n        }\n\n        // check the relations\n        boolean first = true;\n        Iterator<CmsRelation> itRelations = relations.iterator();\n        while (itRelations.hasNext()) {\n            CmsRelation relation = itRelations.next();\n            String link;\n            if (!resource.getState().isDeleted()) {\n                link = relation.getTargetPath();\n            } else {\n                link = relation.getSourcePath();\n            }\n            boolean isValidLink = true;\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(link)) {\n                // skip empty links\n                continue;\n            }\n            if (validatedLinks.keySet().contains(link)) {\n                // skip already validated links\n                if (validatedLinks.get(link).booleanValue()) {\n                    // add broken relation of different type\n                    brokenRelations.add(relation);\n                }\n                continue;\n            }\n            // the link is valid...\n            try {\n                // ... if the linked resource exists in the online project\n                if (!resource.getState().isDeleted()) {\n                    // search the target of link in the online project\n                    try {\n                        CmsDbContext newDbc = new CmsDbContext();\n                        link = m_driverManager.getVfsDriver(newDbc).readResource(\n                            newDbc,\n                            project.getUuid(),\n                            relation.getTargetId(),\n                            true).getRootPath();\n                    } catch (CmsVfsResourceNotFoundException e) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(Messages.get().getBundle().key(\n                                Messages.LOG_LINK_VALIDATION_READBYID_FAILED_2,\n                                relation.getTargetId().toString(),\n                                project.getName()), e);\n                        }\n                        CmsDbContext newDbc = new CmsDbContext();\n                        m_driverManager.getVfsDriver(newDbc).readResource(\n                            newDbc,\n                            project.getUuid(),\n                            relation.getTargetPath(),\n                            true);\n                    }\n                } else {\n                    // since we are going to delete the resource\n                    // check if the linked resource is also to be deleted\n                    isValidLink = false;\n                    if (fileLookup.containsKey(link)) {\n                        CmsResource offlineResource = fileLookup.get(link);\n                        if (offlineResource.getState().isDeleted()) {\n                            isValidLink = true;\n                        }\n                    }\n                }\n            } catch (CmsException e) {\n                // ... or if the linked resource is a resource that gets actually published\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(Messages.get().getBundle().key(\n                        Messages.LOG_LINK_VALIDATION_READBYPATH_FAILED_2,\n                        relation.getTargetPath(),\n                        project.getName()), e);\n                }\n                if (!fileLookup.containsKey(link)) {\n                    isValidLink = false;\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(Messages.get().getBundle().key(\n                            Messages.LOG_LINK_VALIDATION_RESOURCENOTINLOOKUP_1,\n                            link));\n                    }\n                }\n            } finally {\n                // ... and if the linked resource to be published get deleted\n                if (!resource.getState().isDeleted() && fileLookup.containsKey(link)) {\n                    CmsResource offlineResource = fileLookup.get(link);\n                    if (offlineResource.getState().isDeleted()) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(Messages.get().getBundle().key(\n                                Messages.LOG_LINK_VALIDATION_RESOURCEDELETED_1,\n                                link));\n                        }\n                        isValidLink = false;\n                    }\n                }\n            }\n            if (!isValidLink) {\n                if (first) {\n                    if (report != null) {\n                        report.println(\n                            Messages.get().container(Messages.RPT_HTMLLINK_FOUND_BROKEN_LINKS_0),\n                            I_CmsReport.FORMAT_WARNING);\n                    }\n                    first = false;\n                }\n                brokenRelations.add(relation);\n                if (report != null) {\n                    if (!resource.getState().isDeleted()) {\n                        report.println(Messages.get().container(\n                            Messages.RPT_HTMLLINK_BROKEN_TARGET_2,\n                            relation.getSourcePath(),\n                            dbc.removeSiteRoot(link)), I_CmsReport.FORMAT_WARNING);\n                    } else {\n                        report.println(Messages.get().container(\n                            Messages.RPT_HTMLLINK_BROKEN_SOURCE_2,\n                            dbc.removeSiteRoot(link),\n                            relation.getTargetPath()), I_CmsReport.FORMAT_WARNING);\n                    }\n                }\n            }\n            validatedLinks.put(link, Boolean.valueOf(!isValidLink));\n        }\n        return brokenRelations;\n    }","id":49563,"modified_method":"/**\n     * Validates the links for the specified resource.<p>\n     * \n     * @param dbc the database context\n     * @param resource the resource that will be validated\n     * @param fileLookup a map for faster lookup with all resources keyed by their rootpath\n     * @param sitemapCache the sitemap cache for checking sitemap links \n     * @param project the project to validate\n     * @param report the report to write to\n     * \n     * @return a list with the broken links as {@link CmsRelation} objects for the specified resource, \n     *          or an empty list if no broken links were found\n     */\n    protected List<CmsRelation> validateLinks(\n        CmsDbContext dbc,\n        CmsResource resource,\n        Map<String, CmsResource> fileLookup,\n        CmsPublishSitemapCache sitemapCache,\n        CmsProject project,\n        I_CmsReport report) {\n\n        List<CmsRelation> brokenRelations = new ArrayList<CmsRelation>();\n        Map<String, Boolean> validatedLinks = new HashMap<String, Boolean>();\n\n        // get the relations\n        List<CmsRelation> relations = null;\n        try {\n            relations = getLinkRelations(dbc, project, resource);\n        } catch (CmsException e) {\n            LOG.error(Messages.get().getBundle().key(Messages.LOG_LINK_SEARCH_1, resource), e);\n            if (report != null) {\n                report.println(Messages.get().container(\n                    Messages.LOG_LINK_SEARCH_1,\n                    dbc.removeSiteRoot(resource.getRootPath())), I_CmsReport.FORMAT_ERROR);\n            }\n            return brokenRelations;\n        }\n\n        // check the relations\n        boolean first = true;\n        Iterator<CmsRelation> itRelations = relations.iterator();\n        while (itRelations.hasNext()) {\n            CmsRelation relation = itRelations.next();\n            String link;\n            if (!resource.getState().isDeleted()) {\n                link = relation.getTargetPath();\n            } else {\n                link = relation.getSourcePath();\n            }\n            if (CmsStringUtil.isEmptyOrWhitespaceOnly(link)) {\n                // skip empty links\n                continue;\n            }\n            if (validatedLinks.keySet().contains(link)) {\n                // skip already validated links\n                if (validatedLinks.get(link).booleanValue()) {\n                    // add broken relation of different type\n                    brokenRelations.add(relation);\n                }\n                continue;\n            }\n            boolean isValidLink = checkLinkValid(resource, relation, link, project, fileLookup, sitemapCache);\n            if (!isValidLink) {\n                if (first) {\n                    if (report != null) {\n                        report.println(\n                            Messages.get().container(Messages.RPT_HTMLLINK_FOUND_BROKEN_LINKS_0),\n                            I_CmsReport.FORMAT_WARNING);\n                    }\n                    first = false;\n                }\n                brokenRelations.add(relation);\n                if (report != null) {\n                    if (!resource.getState().isDeleted()) {\n                        report.println(Messages.get().container(\n                            Messages.RPT_HTMLLINK_BROKEN_TARGET_2,\n                            relation.getSourcePath(),\n                            dbc.removeSiteRoot(link)), I_CmsReport.FORMAT_WARNING);\n                    } else {\n                        report.println(Messages.get().container(\n                            Messages.RPT_HTMLLINK_BROKEN_SOURCE_2,\n                            dbc.removeSiteRoot(link),\n                            relation.getTargetPath()), I_CmsReport.FORMAT_WARNING);\n                    }\n                }\n            }\n            validatedLinks.put(link, Boolean.valueOf(!isValidLink));\n        }\n        return brokenRelations;\n    }","commit_id":"a71015203b611719e4b512ab261ac3ba26eecc23","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Validates the relations against the online project.<p>\n     * \n     * The result is printed to the given report.<p>\n     * \n     * Validating references means to answer the question, whether \n     * we would have broken links in the online project if the given \n     * publish list would get published.<p>\n     * \n     * @param dbc the database context\n     * @param publishList the publish list to validate\n     * @param report a report to print messages\n     * \n     * @return a map with lists of invalid links \n     *          (<code>{@link org.opencms.relations.CmsRelation}}<\/code> objects) \n     *          keyed by root paths\n     */\n    public Map<String, List<CmsRelation>> validateResources(\n        CmsDbContext dbc,\n        CmsPublishList publishList,\n        I_CmsReport report) {\n\n        // check if progress should be set in the thread\n        CmsProgressThread thread = null;\n        if (Thread.currentThread() instanceof CmsProgressThread) {\n            thread = (CmsProgressThread)Thread.currentThread();\n        }\n\n        Map<String, List<CmsRelation>> invalidResources = new HashMap<String, List<CmsRelation>>();\n        boolean interProject = (publishList != null);\n        if (report != null) {\n            report.println(\n                Messages.get().container(Messages.RPT_HTMLLINK_VALIDATOR_BEGIN_0),\n                I_CmsReport.FORMAT_HEADLINE);\n        }\n        List<CmsResource> resources = new ArrayList<CmsResource>();\n        if (publishList == null) {\n            CmsResourceFilter filter = CmsResourceFilter.IGNORE_EXPIRATION;\n            List<I_CmsResourceType> resTypes = OpenCms.getResourceManager().getResourceTypes();\n            Iterator<I_CmsResourceType> itTypes = resTypes.iterator();\n            int count = 0;\n            while (itTypes.hasNext()) {\n\n                // set progress in thread (first 10 percent)\n                count++;\n                if (thread != null) {\n\n                    if (thread.isInterrupted()) {\n                        throw new CmsIllegalStateException(org.opencms.workplace.commons.Messages.get().container(\n                            org.opencms.workplace.commons.Messages.ERR_PROGRESS_INTERRUPTED_0));\n                    }\n                    thread.setProgress(count * 10 / resTypes.size());\n                }\n\n                I_CmsResourceType type = itTypes.next();\n                if (type instanceof I_CmsLinkParseable) {\n                    filter = filter.addRequireType(type.getTypeId());\n                    try {\n                        resources.addAll(m_driverManager.readResources(dbc, m_driverManager.readResource(\n                            dbc,\n                            \"/\",\n                            filter), filter, true));\n                    } catch (CmsException e) {\n                        LOG.error(\n                            Messages.get().getBundle().key(Messages.LOG_RETRIEVAL_RESOURCES_1, type.getTypeName()),\n                            e);\n                    }\n                }\n            }\n        } else {\n            resources.addAll(publishList.getAllResources());\n        }\n\n        // populate a lookup map with the project resources that \n        // actually get published keyed by their resource names.\n        // second, resources that don't get validated are ignored.\n        Map<String, CmsResource> offlineFilesLookup = new HashMap<String, CmsResource>();\n        Iterator<CmsResource> itResources = resources.iterator();\n        int count = 0;\n        while (itResources.hasNext()) {\n\n            // set progress in thread (next 10 percent)\n            count++;\n            if (thread != null) {\n\n                if (thread.isInterrupted()) {\n                    throw new CmsIllegalStateException(org.opencms.workplace.commons.Messages.get().container(\n                        org.opencms.workplace.commons.Messages.ERR_PROGRESS_INTERRUPTED_0));\n                }\n                thread.setProgress((count * 10 / resources.size()) + 10);\n            }\n\n            CmsResource resource = itResources.next();\n            offlineFilesLookup.put(resource.getRootPath(), resource);\n        }\n        CmsProject project = dbc.currentProject();\n        if (interProject) {\n            try {\n                project = m_driverManager.readProject(dbc, CmsProject.ONLINE_PROJECT_ID);\n            } catch (CmsException e) {\n                // should never happen\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n        }\n\n        boolean foundBrokenLinks = false;\n        for (int index = 0, size = resources.size(); index < size; index++) {\n\n            // set progress in thread (next 20 percent; leave rest for creating the list and the html)\n            if (thread != null) {\n\n                if (thread.isInterrupted()) {\n                    throw new CmsIllegalStateException(org.opencms.workplace.commons.Messages.get().container(\n                        org.opencms.workplace.commons.Messages.ERR_PROGRESS_INTERRUPTED_0));\n                }\n                thread.setProgress((index * 20 / resources.size()) + 20);\n            }\n\n            CmsResource resource = resources.get(index);\n            String resourceName = resource.getRootPath();\n\n            if (report != null) {\n                report.print(org.opencms.report.Messages.get().container(\n                    org.opencms.report.Messages.RPT_SUCCESSION_2,\n                    new Integer(index + 1),\n                    new Integer(size)), I_CmsReport.FORMAT_NOTE);\n                report.print(Messages.get().container(Messages.RPT_HTMLLINK_VALIDATING_0), I_CmsReport.FORMAT_NOTE);\n                report.print(org.opencms.report.Messages.get().container(\n                    org.opencms.report.Messages.RPT_ARGUMENT_1,\n                    dbc.removeSiteRoot(resourceName)));\n                report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_DOTS_0));\n            }\n            List<CmsRelation> brokenLinks = validateLinks(dbc, resource, offlineFilesLookup, project, report);\n            if (brokenLinks.size() > 0) {\n                // the resource contains broken links\n                invalidResources.put(resourceName, brokenLinks);\n                foundBrokenLinks = true;\n            } else {\n                // the resource contains *NO* broken links\n                if (report != null) {\n                    report.println(\n                        org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_OK_0),\n                        I_CmsReport.FORMAT_OK);\n                }\n            }\n        }\n\n        if (foundBrokenLinks) {\n            // print a summary if we found broken links in the validated resources\n            if (report != null) {\n                report.println(\n                    Messages.get().container(Messages.RPT_HTMLLINK_VALIDATOR_ERROR_0),\n                    I_CmsReport.FORMAT_ERROR);\n            }\n        }\n        if (report != null) {\n            report.println(Messages.get().container(Messages.RPT_HTMLLINK_VALIDATOR_END_0), I_CmsReport.FORMAT_HEADLINE);\n        }\n        return invalidResources;\n    }","id":49564,"modified_method":"/**\n     * Validates the relations against the online project.<p>\n     * \n     * The result is printed to the given report.<p>\n     * \n     * Validating references means to answer the question, whether \n     * we would have broken links in the online project if the given \n     * publish list would get published.<p>\n     * \n     * @param dbc the database context\n     * @param publishList the publish list to validate\n     * @param report a report to print messages\n     * \n     * @return a map with lists of invalid links \n     *          (<code>{@link org.opencms.relations.CmsRelation}}<\/code> objects) \n     *          keyed by root paths\n     *          \n     * @throws Exception if something goes wrong          \n     */\n    public Map<String, List<CmsRelation>> validateResources(\n        CmsDbContext dbc,\n        CmsPublishList publishList,\n        I_CmsReport report) throws Exception {\n\n        // check if progress should be set in the thread\n        CmsProgressThread thread = null;\n        if (Thread.currentThread() instanceof CmsProgressThread) {\n            thread = (CmsProgressThread)Thread.currentThread();\n        }\n\n        Map<String, List<CmsRelation>> invalidResources = new HashMap<String, List<CmsRelation>>();\n        boolean interProject = (publishList != null);\n        if (report != null) {\n            report.println(\n                Messages.get().container(Messages.RPT_HTMLLINK_VALIDATOR_BEGIN_0),\n                I_CmsReport.FORMAT_HEADLINE);\n        }\n        List<CmsResource> resources = new ArrayList<CmsResource>();\n        if (publishList == null) {\n            CmsResourceFilter filter = CmsResourceFilter.IGNORE_EXPIRATION;\n            List<I_CmsResourceType> resTypes = OpenCms.getResourceManager().getResourceTypes();\n            Iterator<I_CmsResourceType> itTypes = resTypes.iterator();\n            int count = 0;\n            while (itTypes.hasNext()) {\n\n                // set progress in thread (first 10 percent)\n                count++;\n                if (thread != null) {\n\n                    if (thread.isInterrupted()) {\n                        throw new CmsIllegalStateException(org.opencms.workplace.commons.Messages.get().container(\n                            org.opencms.workplace.commons.Messages.ERR_PROGRESS_INTERRUPTED_0));\n                    }\n                    thread.setProgress(count * 10 / resTypes.size());\n                }\n\n                I_CmsResourceType type = itTypes.next();\n                if (type instanceof I_CmsLinkParseable) {\n                    filter = filter.addRequireType(type.getTypeId());\n                    try {\n                        resources.addAll(m_driverManager.readResources(dbc, m_driverManager.readResource(\n                            dbc,\n                            \"/\",\n                            filter), filter, true));\n                    } catch (CmsException e) {\n                        LOG.error(\n                            Messages.get().getBundle().key(Messages.LOG_RETRIEVAL_RESOURCES_1, type.getTypeName()),\n                            e);\n                    }\n                }\n            }\n        } else {\n            resources.addAll(publishList.getAllResources());\n        }\n\n        // populate a lookup map with the project resources that \n        // actually get published keyed by their resource names.\n        // second, resources that don't get validated are ignored.\n        Map<String, CmsResource> offlineFilesLookup = new HashMap<String, CmsResource>();\n        Iterator<CmsResource> itResources = resources.iterator();\n        int count = 0;\n        while (itResources.hasNext()) {\n\n            // set progress in thread (next 10 percent)\n            count++;\n            if (thread != null) {\n\n                if (thread.isInterrupted()) {\n                    throw new CmsIllegalStateException(org.opencms.workplace.commons.Messages.get().container(\n                        org.opencms.workplace.commons.Messages.ERR_PROGRESS_INTERRUPTED_0));\n                }\n                thread.setProgress((count * 10 / resources.size()) + 10);\n            }\n\n            CmsResource resource = itResources.next();\n            offlineFilesLookup.put(resource.getRootPath(), resource);\n        }\n        CmsProject project = dbc.currentProject();\n        if (interProject) {\n            try {\n                project = m_driverManager.readProject(dbc, CmsProject.ONLINE_PROJECT_ID);\n            } catch (CmsException e) {\n                // should never happen\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n        }\n        String name = publishList == null ? \"CmsPublishSitemapCache(null)\" : \"CmsPublishSitemapCache(pubHistId=\"\n            + publishList.getPublishHistoryId().toString()\n            + \")\";\n        CmsPublishSitemapCache sitemapCache = OpenCms.getSitemapManager().createPublishSitemapCache(name);\n        sitemapCache.init(dbc.currentProject(), project, offlineFilesLookup);\n\n        boolean foundBrokenLinks = false;\n        for (int index = 0, size = resources.size(); index < size; index++) {\n\n            // set progress in thread (next 20 percent; leave rest for creating the list and the html)\n            if (thread != null) {\n\n                if (thread.isInterrupted()) {\n                    throw new CmsIllegalStateException(org.opencms.workplace.commons.Messages.get().container(\n                        org.opencms.workplace.commons.Messages.ERR_PROGRESS_INTERRUPTED_0));\n                }\n                thread.setProgress((index * 20 / resources.size()) + 20);\n            }\n\n            CmsResource resource = resources.get(index);\n            String resourceName = resource.getRootPath();\n\n            if (report != null) {\n                report.print(org.opencms.report.Messages.get().container(\n                    org.opencms.report.Messages.RPT_SUCCESSION_2,\n                    new Integer(index + 1),\n                    new Integer(size)), I_CmsReport.FORMAT_NOTE);\n                report.print(Messages.get().container(Messages.RPT_HTMLLINK_VALIDATING_0), I_CmsReport.FORMAT_NOTE);\n                report.print(org.opencms.report.Messages.get().container(\n                    org.opencms.report.Messages.RPT_ARGUMENT_1,\n                    dbc.removeSiteRoot(resourceName)));\n                report.print(org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_DOTS_0));\n            }\n            List<CmsRelation> brokenLinks = validateLinks(\n                dbc,\n                resource,\n                offlineFilesLookup,\n                sitemapCache,\n                project,\n                report);\n            if (brokenLinks.size() > 0) {\n                // the resource contains broken links\n                invalidResources.put(resourceName, brokenLinks);\n                foundBrokenLinks = true;\n            } else {\n                // the resource contains *NO* broken links\n                if (report != null) {\n                    report.println(\n                        org.opencms.report.Messages.get().container(org.opencms.report.Messages.RPT_OK_0),\n                        I_CmsReport.FORMAT_OK);\n                }\n            }\n        }\n\n        if (foundBrokenLinks) {\n            // print a summary if we found broken links in the validated resources\n            if (report != null) {\n                report.println(\n                    Messages.get().container(Messages.RPT_HTMLLINK_VALIDATOR_ERROR_0),\n                    I_CmsReport.FORMAT_ERROR);\n            }\n        }\n        if (report != null) {\n            report.println(Messages.get().container(Messages.RPT_HTMLLINK_VALIDATOR_END_0), I_CmsReport.FORMAT_HEADLINE);\n        }\n        return invalidResources;\n    }","commit_id":"a71015203b611719e4b512ab261ac3ba26eecc23","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a new sitemap manager.<p>\n     * \n     * @param adminCms The admin context\n     * @param memoryMonitor the memory monitor instance\n     * @param systemConfiguration the system configuration\n     */\n    public CmsSitemapManager(\n        CmsObject adminCms,\n        CmsMemoryMonitor memoryMonitor,\n        CmsSystemConfiguration systemConfiguration) {\n\n        // initialize the sitemap cache\n        CmsSitemapCacheSettings cacheSettings = systemConfiguration.getSitemapCacheSettings();\n        if (cacheSettings == null) {\n            cacheSettings = new CmsSitemapCacheSettings();\n        }\n        m_cache = new CmsSitemapCache(adminCms, memoryMonitor, cacheSettings);\n\n        if (!isSitemapResourceInitConfigured(systemConfiguration)) {\n            LOG.warn(Messages.get().getBundle().key(\n                Messages.LOG_WARN_SITEMAP_HANDLER_NOT_CONFIGURED_1,\n                CmsSitemapResourceHandler.class.getName()));\n        }\n    }","id":49565,"modified_method":"/**\n     * Creates a new sitemap manager.<p>\n     * \n     * @param adminCms The admin context\n     * @param memoryMonitor the memory monitor instance\n     * @param systemConfiguration the system configuration\n     */\n    public CmsSitemapManager(\n        CmsObject adminCms,\n        CmsMemoryMonitor memoryMonitor,\n        CmsSystemConfiguration systemConfiguration) {\n\n        m_adminCms = adminCms;\n        // initialize the sitemap cache\n        CmsSitemapCacheSettings cacheSettings = systemConfiguration.getSitemapCacheSettings();\n        if (cacheSettings == null) {\n            cacheSettings = new CmsSitemapCacheSettings();\n        }\n        //m_cache = new CmsSitemapCache(adminCms, memoryMonitor, cacheSettings);\n        m_cache = new CmsOnlineAndOfflineSitemapCache(adminCms, memoryMonitor);\n\n        m_sitemapXmlCaches = new HashMap<Boolean, CmsSitemapXmlCache>();\n        CmsSitemapXmlCache onlineXmlCache = new CmsSitemapXmlCache(\n            \"Online\",\n            true,\n            cacheSettings.getDocumentOnlineSize());\n        CmsSitemapXmlCache offlineXmlCache = new CmsSitemapXmlCache(\n            \"Offline\",\n            false,\n            cacheSettings.getDocumentOfflineSize());\n        m_sitemapXmlCaches.put(Boolean.TRUE, onlineXmlCache);\n        m_sitemapXmlCaches.put(Boolean.FALSE, offlineXmlCache);\n\n        if (!isSitemapResourceInitConfigured(systemConfiguration)) {\n            LOG.warn(Messages.get().getBundle().key(\n                Messages.LOG_WARN_SITEMAP_HANDLER_NOT_CONFIGURED_1,\n                CmsSitemapResourceHandler.class.getName()));\n        }\n    }","commit_id":"a71015203b611719e4b512ab261ac3ba26eecc23","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the cache.<p>\n     *\n     * @return the cache\n     */\n    protected CmsSitemapCache getCache() {\n\n        return m_cache;\n    }","id":49566,"modified_method":"/**\n     * Returns the cache.<p>\n     *\n     * @return the cache\n     */\n    protected I_CmsSitemapCache getCache() {\n\n        return m_cache;\n    }","commit_id":"a71015203b611719e4b512ab261ac3ba26eecc23","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Clean up at shutdown time. Only intended to be called at system shutdown.<p>\n     * \n     * @see org.opencms.main.OpenCmsCore#shutDown\n     */\n    public void shutdown() {\n\n        m_cache.shutdown();\n    }","id":49567,"modified_method":"/**\n     * Clean up at shutdown time. Only intended to be called at system shutdown.<p>\n     * \n     * @see org.opencms.main.OpenCmsCore#shutDown\n     */\n    public void shutdown() {\n\n        m_cache.shutdown();\n        getSitemapXmlCache(true).shutdown();\n        getSitemapXmlCache(false).shutdown();\n    }","commit_id":"a71015203b611719e4b512ab261ac3ba26eecc23","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the sitemap entry for the given URI, or <code>null<\/code> if not found.<p>\n     * \n     * If the URI passed as an argument is a VFS URI instead of a sitemap URI, a dummy sitemap\n     * entry for the VFS location will be returned.<p>\n     * \n     * @param cms the current CMS context\n     * @param entryUri the sitemap entry URI to look for\n     * \n     * @return the sitemap entry for the given URI, or <code>null<\/code> if not found\n     * \n     * @throws CmsException if something goes wrong\n     */\n    public CmsSitemapEntry getEntryForUri(CmsObject cms, String entryUri) throws CmsException {\n\n        // get the entry for the given path\n        CmsInternalSitemapEntry entry = m_cache.getEntryByUri(cms, entryUri);\n        if (entry != null) {\n            // check permissions\n            cms.readResource(entry.getStructureId());\n            return entry;\n        }\n\n        // if not found try as detail page\n        String path = entryUri;\n        if (path.endsWith(\"/\")) {\n            path = path.substring(0, path.length() - 1);\n        }\n        String detailId = CmsResource.getName(path);\n        if (!CmsUUID.isValidUUID(detailId)) {\n            // not a detail page URI\n            return new CmsInternalSitemapEntry(cms, entryUri);\n        }\n        entry = m_cache.getEntryByUri(cms, CmsResource.getParentFolder(entryUri));\n        if (entry == null) {\n            // not a detail page URI\n            return new CmsInternalSitemapEntry(cms, entryUri);\n        }\n\n        // detail page\n        CmsUUID id = new CmsUUID(detailId);\n        // check existence / permissions\n        CmsResource contentRes = cms.readResource(id);\n        // get the title\n        String title = cms.readPropertyObject(contentRes, CmsPropertyDefinition.PROPERTY_TITLE, false).getValue(\n            id.toString());\n        // clone & extend the properties\n        HashMap<String, String> entryProps = new HashMap<String, String>(entry.getProperties());\n        // detail pages are NEVER shown in the navigation\n        entryProps.put(Property.navigation.getName(), Boolean.FALSE.toString());\n        // create entry\n        CmsInternalSitemapEntry contentEntry = new CmsInternalSitemapEntry(\n            entry.getId(),\n            entry.getOriginalUri(),\n            entry.getStructureId(),\n            id.toString(),\n            title,\n            entry.isRootEntry(),\n            entryProps,\n            null,\n            id);\n        contentEntry.setRuntimeInfo(entry.getEntryPoint(), 0, entry.getInheritedProperties());\n        return contentEntry;\n    }","id":49568,"modified_method":"/**\n     * Returns the sitemap entry for the given URI, or <code>null<\/code> if not found.<p>\n     * \n     * If the URI passed as an argument is a VFS URI instead of a sitemap URI, a dummy sitemap\n     * entry for the VFS location will be returned.<p>\n     * \n     * @param cms the current CMS context\n     * @param entryUri the sitemap entry URI to look for\n     * \n     * @return the sitemap entry for the given URI, or <code>null<\/code> if not found\n     * \n     * @throws CmsException if something goes wrong\n     */\n    public CmsSitemapEntry getEntryForUri(CmsObject cms, String entryUri) throws CmsException {\n\n        return getEntryForUri(cms, entryUri, m_cache);\n    }","commit_id":"a71015203b611719e4b512ab261ac3ba26eecc23","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the cached sitemap.<p>\n     * \n     * @param cms the cms context\n     * @param resource the sitemap resource\n     * @param keepEncoding if to keep the encoding while unmarshalling\n     * \n     * @return the cached sitemap, or <code>null<\/code> if not found\n     */\n    private static CmsXmlSitemap getCache(CmsObject cms, CmsResource resource, boolean keepEncoding) {\n\n        if (resource instanceof I_CmsHistoryResource) {\n            return null;\n        }\n        return m_cache.getDocument(\n            m_cache.getCacheKey(resource.getStructureId(), keepEncoding),\n            cms.getRequestContext().currentProject().isOnlineProject());\n    }","id":49569,"modified_method":"/**\n     * Returns the cached sitemap.<p>\n     * \n     * @param cms the cms context\n     * @param resource the sitemap resource\n     * @param keepEncoding if to keep the encoding while unmarshalling\n     * \n     * @return the cached sitemap, or <code>null<\/code> if not found\n     */\n    private static CmsXmlSitemap getCache(CmsObject cms, CmsResource resource, boolean keepEncoding) {\n\n        if (resource instanceof I_CmsHistoryResource) {\n            return null;\n        }\n        boolean online = cms.getRequestContext().currentProject().isOnlineProject();\n        CmsSitemapXmlCache cache = OpenCms.getSitemapManager().getSitemapXmlCache(online);\n        String key = cache.getCacheKey(resource.getStructureId(), keepEncoding);\n        return cache.getDocument(key);\n    }","commit_id":"a71015203b611719e4b512ab261ac3ba26eecc23","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Stores the given sitemap in the cache.<p>\n     * \n     * @param cms the cms context\n     * @param xmlSitemap the sitemap to cache\n     * @param keepEncoding if the encoding was kept while unmarshalling\n     */\n    private static void setCache(CmsObject cms, CmsXmlSitemap xmlSitemap, boolean keepEncoding) {\n\n        if (xmlSitemap.getFile() instanceof I_CmsHistoryResource) {\n            return;\n        }\n        boolean online = cms.getRequestContext().currentProject().isOnlineProject();\n        m_cache.setDocument(\n            m_cache.getCacheKey(xmlSitemap.getFile().getStructureId(), keepEncoding),\n            xmlSitemap,\n            online);\n    }","id":49570,"modified_method":"/**\n     * Stores the given sitemap in the cache.<p>\n     * \n     * @param cms the cms context\n     * @param xmlSitemap the sitemap to cache\n     * @param keepEncoding if the encoding was kept while unmarshalling\n     */\n    private static void setCache(CmsObject cms, CmsXmlSitemap xmlSitemap, boolean keepEncoding) {\n\n        if (xmlSitemap.getFile() instanceof I_CmsHistoryResource) {\n            return;\n        }\n        boolean online = cms.getRequestContext().currentProject().isOnlineProject();\n        CmsSitemapXmlCache cache = OpenCms.getSitemapManager().getSitemapXmlCache(online);\n        String key = cache.getCacheKey(xmlSitemap.getFile().getStructureId(), keepEncoding);\n        cache.setDocument(key, xmlSitemap);\n    }","commit_id":"a71015203b611719e4b512ab261ac3ba26eecc23","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the resource root path in the OpenCms VFS for the given link, or <code>null<\/code> in\n     * case the link points to an external site.<p>\n     * \n     * If the target URI contains no site information, but starts with the opencms context, the context is removed:<pre>\n     * /opencms/opencms/system/further_path -> /system/further_path<\/pre>\n     * \n     * If the target URI contains no site information, the path will be prefixed with the current site\n     * from the provided OpenCms user context:<pre>\n     * /folder/page.html -> /sites/mysite/folder/page.html<\/pre>\n     *  \n     * If the path of the target URI is relative, i.e. does not start with \"/\", \n     * the path will be prefixed with the current site and the given relative path,\n     * then normalized.\n     * If no relative path is given, <code>null<\/code> is returned.\n     * If the normalized path is outsite a site, null is returned.<pre>\n     * page.html -> /sites/mysite/page.html\n     * ../page.html -> /sites/mysite/page.html\n     * ../../page.html -> null<\/pre>\n     * \n     * If the target URI contains a scheme/server name that denotes an opencms site, \n     * it is replaced by the appropriate site path:<pre>\n     * http://www.mysite.de/folder/page.html -> /sites/mysite/folder/page.html<\/pre><p>\n     * \n     * If the target URI contains a scheme/server name that does not match with any site, \n     * or if the URI is opaque or invalid,\n     * <code>null<\/code> is returned:<pre>\n     * http://www.elsewhere.com/page.html -> null\n     * mailto:someone@elsewhere.com -> null<\/pre>\n     * \n     * @see org.opencms.staticexport.I_CmsLinkSubstitutionHandler#getLink(org.opencms.file.CmsObject, java.lang.String, java.lang.String, boolean)\n     */\n    public String getLink(CmsObject cms, String link, String siteRoot, boolean forceSecure) {\n\n        if (CmsStringUtil.isEmpty(link)) {\n            // not a valid link parameter, return an empty String\n            return \"\";\n        }\n        // make sure we have an absolute link        \n        String absoluteLink = CmsLinkManager.getAbsoluteUri(link, cms.getRequestContext().getUri());\n\n        String vfsName;\n        String parameters;\n        int pos = absoluteLink.indexOf('?');\n        // check if the link has parameters, if so cut them\n        if (pos >= 0) {\n            vfsName = absoluteLink.substring(0, pos);\n            parameters = absoluteLink.substring(pos);\n        } else {\n            vfsName = absoluteLink;\n            parameters = null;\n        }\n\n        String anchor = null;\n        pos = vfsName.indexOf('#');\n        if (pos >= 0) {\n            anchor = vfsName.substring(pos);\n            vfsName = vfsName.substring(0, pos);\n        }\n\n        String resultLink = null;\n        String uriBaseName = null;\n        boolean useRelativeLinks = false;\n\n        // determine the target site of the link        \n        CmsSite currentSite = OpenCms.getSiteManager().getCurrentSite(cms);\n        CmsSite targetSite = null;\n        if (CmsStringUtil.isNotEmpty(siteRoot)) {\n            targetSite = OpenCms.getSiteManager().getSiteForSiteRoot(siteRoot);\n        }\n        if (targetSite == null) {\n            targetSite = currentSite;\n        }\n        String serverPrefix;\n        // if the link points to another site, there needs to be a server prefix\n        if (targetSite != currentSite) {\n            serverPrefix = targetSite.getUrl();\n        } else {\n            serverPrefix = \"\";\n        }\n\n        // in the online project, check static export and secure settings\n\n        if (cms.getRequestContext().currentProject().isOnlineProject()) {\n\n            // first check if this link needs static export\n\n            CmsStaticExportManager exportManager = OpenCms.getStaticExportManager();\n            // check if we need relative links in the exported pages\n            if (exportManager.relativeLinksInExport(cms.getRequestContext().getSiteRoot()\n                + cms.getRequestContext().getUri())) {\n                // try to get base URI from cache  \n                uriBaseName = exportManager.getCachedOnlineLink(exportManager.getCacheKey(\n                    cms.getRequestContext().getSiteRoot(),\n                    cms.getRequestContext().getUri()));\n                if (uriBaseName == null) {\n                    // base not cached, check if we must export it\n                    if (exportManager.isExportLink(cms, cms.getRequestContext().getUri())) {\n                        // base URI must also be exported\n                        uriBaseName = exportManager.getRfsName(cms, cms.getRequestContext().getUri());\n                    } else {\n                        // base URI dosn't need to be exported\n                        uriBaseName = exportManager.getVfsPrefix() + cms.getRequestContext().getUri();\n                    }\n                    // cache export base URI\n                    exportManager.cacheOnlineLink(exportManager.getCacheKey(\n                        cms.getRequestContext().getSiteRoot(),\n                        cms.getRequestContext().getUri()), uriBaseName);\n                }\n                // use relative links only on pages that get exported\n                useRelativeLinks = uriBaseName.startsWith(OpenCms.getStaticExportManager().getRfsPrefix(\n                    cms.getRequestContext().getSiteRoot() + cms.getRequestContext().getUri()));\n            }\n\n            // check if we have the absolute VFS name for the link target cached\n            resultLink = exportManager.getCachedOnlineLink(cms.getRequestContext().getSiteRoot() + \":\" + absoluteLink);\n            if (resultLink == null) {\n                String storedSiteRoot = cms.getRequestContext().getSiteRoot();\n                try {\n                    cms.getRequestContext().setSiteRoot(targetSite.getSiteRoot());\n                    // didn't find the link in the cache\n                    if (exportManager.isExportLink(cms, vfsName)) {\n                        // export required, get export name for target link\n                        resultLink = exportManager.getRfsName(cms, vfsName, parameters);\n                        // now set the parameters to null, we do not need them anymore\n                        parameters = null;\n                    } else {\n                        // no export required for the target link\n                        resultLink = exportManager.getVfsPrefix().concat(vfsName);\n                        // add cut off parameters if required\n                        if (parameters != null) {\n                            resultLink = resultLink.concat(parameters);\n                        }\n                    }\n                } finally {\n                    cms.getRequestContext().setSiteRoot(storedSiteRoot);\n                }\n                // cache the result\n                exportManager.cacheOnlineLink(cms.getRequestContext().getSiteRoot() + \":\" + absoluteLink, resultLink);\n            }\n\n            // now check for the secure settings \n\n            // check if either the current site or the target site does have a secure server configured\n            if (targetSite.hasSecureServer() || currentSite.hasSecureServer()) {\n\n                if (!vfsName.startsWith(CmsWorkplace.VFS_PATH_SYSTEM)) {\n                    // don't make a secure connection to the \"/system\" folder (why ?)\n                    int linkType = -1;\n                    try {\n                        // read the linked resource \n                        linkType = cms.readResource(vfsName).getTypeId();\n                    } catch (CmsException e) {\n                        // the resource could not be read\n                        if (LOG.isInfoEnabled()) {\n                            String message = Messages.get().getBundle().key(\n                                Messages.LOG_RESOURCE_ACESS_ERROR_3,\n                                vfsName,\n                                cms.getRequestContext().currentUser().getName(),\n                                cms.getRequestContext().getSiteRoot());\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(message, e);\n                            } else {\n                                LOG.info(message);\n                            }\n                        }\n                    }\n\n                    // images are always referenced without a server prefix\n                    if (linkType != CmsResourceTypeImage.getStaticTypeId()) {\n                        // check the secure property of the link\n                        boolean secureLink = exportManager.isSecureLink(cms, vfsName, targetSite.getSiteRoot());\n                        boolean secureRequest = exportManager.isSecureLink(cms, cms.getRequestContext().getUri());\n                        // if we are on a normal server, and the requested resource is secure, \n                        // the server name has to be prepended                        \n                        if (secureLink && (forceSecure || !secureRequest)) {\n                            serverPrefix = targetSite.getSecureUrl();\n                        } else if (!secureLink && secureRequest) {\n                            serverPrefix = targetSite.getUrl();\n                        }\n                    }\n                }\n            }\n            // make absolute link relative, if relative links in export are required\n            // and if the link does not point to another server\n            if (useRelativeLinks && CmsStringUtil.isEmpty(serverPrefix)) {\n                resultLink = CmsLinkManager.getRelativeUri(uriBaseName, resultLink);\n            }\n\n        } else {\n            // offline project, no export or secure handling required\n            if (OpenCms.getRunLevel() >= OpenCms.RUNLEVEL_3_SHELL_ACCESS) {\n                // in unit test this code would fail otherwise\n                resultLink = OpenCms.getStaticExportManager().getVfsPrefix().concat(vfsName);\n            }\n\n            // add cut off parameters and return the result\n            if ((parameters != null) && (resultLink != null)) {\n                resultLink = resultLink.concat(parameters);\n            }\n\n        }\n\n        if ((anchor != null) && (resultLink != null)) {\n            resultLink = resultLink.concat(anchor);\n        }\n\n        return serverPrefix.concat(resultLink);\n    }","id":49571,"modified_method":"/**\n     * Returns the resource root path in the OpenCms VFS for the given link, or <code>null<\/code> in\n     * case the link points to an external site.<p>\n     * \n     * If the target URI contains no site information, but starts with the opencms context, the context is removed:<pre>\n     * /opencms/opencms/system/further_path -> /system/further_path<\/pre>\n     * \n     * If the target URI contains no site information, the path will be prefixed with the current site\n     * from the provided OpenCms user context:<pre>\n     * /folder/page.html -> /sites/mysite/folder/page.html<\/pre>\n     *  \n     * If the path of the target URI is relative, i.e. does not start with \"/\", \n     * the path will be prefixed with the current site and the given relative path,\n     * then normalized.\n     * If no relative path is given, <code>null<\/code> is returned.\n     * If the normalized path is outsite a site, null is returned.<pre>\n     * page.html -> /sites/mysite/page.html\n     * ../page.html -> /sites/mysite/page.html\n     * ../../page.html -> null<\/pre>\n     * \n     * If the target URI contains a scheme/server name that denotes an opencms site, \n     * it is replaced by the appropriate site path:<pre>\n     * http://www.mysite.de/folder/page.html -> /sites/mysite/folder/page.html<\/pre><p>\n     * \n     * If the target URI contains a scheme/server name that does not match with any site, \n     * or if the URI is opaque or invalid,\n     * <code>null<\/code> is returned:<pre>\n     * http://www.elsewhere.com/page.html -> null\n     * mailto:someone@elsewhere.com -> null<\/pre>\n     * \n     * @see org.opencms.staticexport.I_CmsLinkSubstitutionHandler#getLink(org.opencms.file.CmsObject, java.lang.String, java.lang.String, boolean)\n     */\n    public String getLink(CmsObject cms, String link, String siteRoot, boolean forceSecure) {\n\n        if (CmsStringUtil.isEmpty(link)) {\n            // not a valid link parameter, return an empty String\n            return \"\";\n        }\n        // make sure we have an absolute link        \n        String absoluteLink = CmsLinkManager.getAbsoluteUri(link, cms.getRequestContext().getUri());\n\n        String vfsName;\n        String parameters;\n        int pos = absoluteLink.indexOf('?');\n        // check if the link has parameters, if so cut them\n        if (pos >= 0) {\n            vfsName = absoluteLink.substring(0, pos);\n            parameters = absoluteLink.substring(pos);\n        } else {\n            vfsName = absoluteLink;\n            parameters = null;\n        }\n\n        String anchor = null;\n        pos = vfsName.indexOf('#');\n        if (pos >= 0) {\n            anchor = vfsName.substring(pos);\n            vfsName = vfsName.substring(0, pos);\n        }\n\n        String resultLink = null;\n        String uriBaseName = null;\n        boolean useRelativeLinks = false;\n\n        // determine the target site of the link        \n        CmsSite currentSite = OpenCms.getSiteManager().getCurrentSite(cms);\n        CmsSite targetSite = null;\n        if (CmsStringUtil.isNotEmpty(siteRoot)) {\n            targetSite = OpenCms.getSiteManager().getSiteForSiteRoot(siteRoot);\n        }\n        if (targetSite == null) {\n            targetSite = currentSite;\n        }\n        String serverPrefix;\n        // if the link points to another site, there needs to be a server prefix\n        if (targetSite != currentSite) {\n            serverPrefix = targetSite.getUrl();\n        } else {\n            serverPrefix = \"\";\n        }\n\n        // in the online project, check static export and secure settings\n\n        if (cms.getRequestContext().currentProject().isOnlineProject()) {\n\n            // first check if this link needs static export\n\n            CmsStaticExportManager exportManager = OpenCms.getStaticExportManager();\n            // check if we need relative links in the exported pages\n            if (exportManager.relativeLinksInExport(cms.getRequestContext().getSiteRoot()\n                + cms.getRequestContext().getUri())) {\n                // try to get base URI from cache  \n                String cacheKey = exportManager.getCacheKey(\n                    cms.getRequestContext().getSiteRoot(),\n                    cms.getRequestContext().getUri());\n                uriBaseName = exportManager.getCachedOnlineLink(cacheKey);\n                if (uriBaseName == null) {\n                    // base not cached, check if we must export it\n                    CmsResource resource = null;\n                    try {\n                        resource = cms.readResource(cms.getRequestContext().getUri());\n                    } catch (CmsException e) {\n                        // should never happen\n                        LOG.error(e.getLocalizedMessage(), e);\n                    }\n                    if ((resource != null) && exportManager.isExportLink(cms, resource)) {\n                        // base URI must also be exported\n                        uriBaseName = exportManager.getRfsName(cms, cms.getRequestContext().getUri());\n                    } else {\n                        // base URI dosn't need to be exported\n                        uriBaseName = exportManager.getVfsPrefix() + cms.getRequestContext().getUri();\n                    }\n                    // cache export base URI\n                    exportManager.cacheOnlineLink(cacheKey, uriBaseName);\n                }\n                // use relative links only on pages that get exported\n                useRelativeLinks = uriBaseName.startsWith(OpenCms.getStaticExportManager().getRfsPrefix(\n                    cms.getRequestContext().getSiteRoot() + cms.getRequestContext().getUri()));\n            }\n\n            // check if we have the absolute VFS name for the link target cached\n            String cacheKey = cms.getRequestContext().getSiteRoot() + \":\" + absoluteLink;\n            resultLink = exportManager.getCachedOnlineLink(cacheKey);\n            if (resultLink == null) {\n                String storedSiteRoot = cms.getRequestContext().getSiteRoot();\n                try {\n                    cms.getRequestContext().setSiteRoot(targetSite.getSiteRoot());\n                    // didn't find the link in the cache\n                    CmsResource resource = null;\n                    try {\n                        resource = cms.readResource(vfsName);\n                    } catch (CmsException e) {\n                        // sitemap case\n                        try {\n                            CmsSiteEntryBean entry = OpenCms.getSitemapManager().getEntryForUri(cms, vfsName);\n                            if (entry != null) {\n                                resource = cms.readResource(entry.getResourceId());\n                            }\n                        } catch (CmsException e1) {\n                            // should never happen\n                            LOG.error(e.getLocalizedMessage(), e);\n                        }\n                    }\n                    if ((resource != null) && exportManager.isExportLink(cms, resource)) {\n                        // export required, get export name for target link\n                        resultLink = exportManager.getRfsName(cms, vfsName, parameters);\n                        // now set the parameters to null, we do not need them anymore\n                        parameters = null;\n                    } else {\n                        // no export required for the target link\n                        resultLink = exportManager.getVfsPrefix().concat(vfsName);\n                        // add cut off parameters if required\n                        if (parameters != null) {\n                            resultLink = resultLink.concat(parameters);\n                        }\n                    }\n                } finally {\n                    cms.getRequestContext().setSiteRoot(storedSiteRoot);\n                }\n                // cache the result\n                exportManager.cacheOnlineLink(cacheKey, resultLink);\n            }\n\n            // now check for the secure settings \n\n            // check if either the current site or the target site does have a secure server configured\n            if (targetSite.hasSecureServer() || currentSite.hasSecureServer()) {\n\n                if (!vfsName.startsWith(CmsWorkplace.VFS_PATH_SYSTEM)) {\n                    // don't make a secure connection to the \"/system\" folder (why ?)\n                    int linkType = -1;\n                    try {\n                        // read the linked resource \n                        linkType = cms.readResource(vfsName).getTypeId();\n                    } catch (CmsException e) {\n                        // the resource could not be read\n                        if (LOG.isInfoEnabled()) {\n                            String message = Messages.get().getBundle().key(\n                                Messages.LOG_RESOURCE_ACESS_ERROR_3,\n                                vfsName,\n                                cms.getRequestContext().currentUser().getName(),\n                                cms.getRequestContext().getSiteRoot());\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(message, e);\n                            } else {\n                                LOG.info(message);\n                            }\n                        }\n                    }\n\n                    // images are always referenced without a server prefix\n                    if (linkType != CmsResourceTypeImage.getStaticTypeId()) {\n                        // check the secure property of the link\n                        boolean secureLink = exportManager.isSecureLink(cms, vfsName, targetSite.getSiteRoot());\n                        boolean secureRequest = exportManager.isSecureLink(cms, cms.getRequestContext().getUri());\n                        // if we are on a normal server, and the requested resource is secure, \n                        // the server name has to be prepended                        \n                        if (secureLink && (forceSecure || !secureRequest)) {\n                            serverPrefix = targetSite.getSecureUrl();\n                        } else if (!secureLink && secureRequest) {\n                            serverPrefix = targetSite.getUrl();\n                        }\n                    }\n                }\n            }\n            // make absolute link relative, if relative links in export are required\n            // and if the link does not point to another server\n            if (useRelativeLinks && CmsStringUtil.isEmpty(serverPrefix)) {\n                resultLink = CmsLinkManager.getRelativeUri(uriBaseName, resultLink);\n            }\n\n        } else {\n            // offline project, no export or secure handling required\n            if (OpenCms.getRunLevel() >= OpenCms.RUNLEVEL_3_SHELL_ACCESS) {\n                // in unit test this code would fail otherwise\n                resultLink = OpenCms.getStaticExportManager().getVfsPrefix().concat(vfsName);\n            }\n\n            // add cut off parameters and return the result\n            if ((parameters != null) && (resultLink != null)) {\n                resultLink = resultLink.concat(parameters);\n            }\n\n        }\n\n        if ((anchor != null) && (resultLink != null)) {\n            resultLink = resultLink.concat(anchor);\n        }\n\n        return serverPrefix.concat(resultLink);\n    }","commit_id":"b7124475003cf7e28a6e474f17d8f81bbc893e77","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public GlobalSearchScope getResolveScope(PsiElement element) {\n    VirtualFile vFile;\n    if (element instanceof PsiDirectory) {\n      vFile = ((PsiDirectory)element).getVirtualFile();\n    }\n    else {\n      final PsiFile contextFile = ResolveUtil.getContextFile(element);\n      if (contextFile == null || contextFile instanceof XmlFile) {\n        return GlobalSearchScope.allScope(myManager.getProject());\n      }\n      vFile = contextFile.getVirtualFile();\n      if (vFile == null) {\n        PsiFile originalFile = contextFile.getOriginalFile();\n        if (originalFile != null) {\n          vFile = originalFile.getVirtualFile();\n        }\n      }\n    }\n    if (vFile == null) {\n      return GlobalSearchScope.allScope(myManager.getProject());\n    }\n\n    ProjectFileIndex projectFileIndex = myProjectRootManager.getFileIndex();\n    Module module = projectFileIndex.getModuleForFile(vFile);\n    if (module != null) {\n      boolean includeTests = projectFileIndex.isInTestSourceContent(vFile) ||\n                             !projectFileIndex.isContentJavaSourceFile(vFile);\n      return GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module, includeTests);\n    }\n    else {\n      // resolve references in libraries in any module which contain it\n      //TODO: exclude project content\n      OrderEntry[] orderEntries = projectFileIndex.getOrderEntriesForFile(vFile);\n      if (orderEntries.length == 0) return GlobalSearchScope.allScope(myManager.getProject());\n      for (OrderEntry entry : orderEntries) {\n        if (entry instanceof LibraryOrderEntry) {\n          Module ownerModule = entry.getOwnerModule();\n          return GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(ownerModule);\n        }\n      }\n      return GlobalSearchScope.allScope(myManager.getProject());\n    }\n  }","id":49572,"modified_method":"public GlobalSearchScope getResolveScope(PsiElement element) {\n    VirtualFile vFile;\n    if (element instanceof PsiDirectory) {\n      vFile = ((PsiDirectory)element).getVirtualFile();\n    }\n    else {\n      final PsiFile contextFile = ResolveUtil.getContextFile(element);\n      if (contextFile == null || contextFile instanceof XmlFile) {\n        return GlobalSearchScope.allScope(myManager.getProject());\n      }\n      vFile = contextFile.getVirtualFile();\n      if (vFile == null) {\n        PsiFile originalFile = contextFile.getOriginalFile();\n        if (originalFile != null) {\n          vFile = originalFile.getVirtualFile();\n        }\n      }\n    }\n    if (vFile == null) {\n      return GlobalSearchScope.allScope(myManager.getProject());\n    }\n\n    ProjectFileIndex projectFileIndex = myProjectRootManager.getFileIndex();\n    Module module = projectFileIndex.getModuleForFile(vFile);\n    if (module != null) {\n      boolean includeTests = projectFileIndex.isInTestSourceContent(vFile) ||\n                             !projectFileIndex.isContentJavaSourceFile(vFile);\n      return GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module, includeTests);\n    }\n    else {\n      // resolve references in libraries in context of all modules which contain it\n      GlobalSearchScope allInclusiveModuleScope = null;\n\n      OrderEntry[] orderEntries = projectFileIndex.getOrderEntriesForFile(vFile);\n      if (orderEntries.length > 0) {\n        for (OrderEntry entry : orderEntries) {\n          if (entry instanceof LibraryOrderEntry) {\n            Module ownerModule = entry.getOwnerModule();\n            final GlobalSearchScope moduleScope = GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(ownerModule);\n            if (allInclusiveModuleScope == null) {\n              allInclusiveModuleScope = moduleScope;\n            }\n            else {\n              allInclusiveModuleScope = allInclusiveModuleScope.uniteWith(moduleScope);\n            }\n          }\n        }\n      }\n\n      if (allInclusiveModuleScope == null) {\n        allInclusiveModuleScope = GlobalSearchScope.allScope(myManager.getProject());\n      }\n\n      return new LibrariesOnlyScope(allInclusiveModuleScope);\n    }\n  }","commit_id":"3811453c228f8b31ab254b44faa99bd9a1d874b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public GlobalSearchScope getResolveScope(@NotNull VirtualFile file, Project project) {\n    final GroovyConsoleStateService projectConsole = GroovyConsoleStateService.getInstance(project);\n    final Module module = projectConsole.getSelectedModule(file);\n    if (module == null || module.isDisposed()) return null;\n\n    final GlobalSearchScope moduleScope = GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module);\n    if (!GroovyConsoleUtil.hasGroovyAll(module)) {\n      final List<VirtualFile> bundledGroovyJarRoots = GroovyBundledClassFinder.getBundledGroovyJarRoots();\n      if (!bundledGroovyJarRoots.isEmpty()) {\n        return new NonClasspathDirectoriesScope(bundledGroovyJarRoots).uniteWith(moduleScope);\n      }\n    }\n    return moduleScope;\n  }","id":49573,"modified_method":"@Nullable\n  @Override\n  public GlobalSearchScope getResolveScope(@NotNull VirtualFile file, Project project) {\n    final GroovyConsoleStateService projectConsole = GroovyConsoleStateService.getInstance(project);\n    final Module module = projectConsole.getSelectedModule(file);\n    return module == null || module.isDisposed() ? null : GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module);\n  }","commit_id":"4fcdbd552dd4975b228e682b4e982e576f2998c9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public GlobalSearchScope getResolveScope(@NotNull VirtualFile file, Project project) {\n    final GroovyConsoleStateService projectConsole = GroovyConsoleStateService.getInstance(project);\n    final Module module = projectConsole.getSelectedModule(file);\n    return module == null || module.isDisposed() ? null : GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module);\n  }","id":49574,"modified_method":"@Nullable\n  @Override\n  public GlobalSearchScope getResolveScope(@NotNull VirtualFile file, Project project) {\n    final GroovyConsoleStateService projectConsole = GroovyConsoleStateService.getInstance(project);\n    final Module module = projectConsole.getSelectedModule(file);\n    if (module == null || module.isDisposed()) return null;\n\n    final GlobalSearchScope moduleScope = GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module);\n    if (!GroovyConsoleUtil.hasGroovyAll(module)) {\n      final List<VirtualFile> bundledGroovyJarRoots = GroovyBundledClassFinder.getBundledGroovyJarRoots();\n      if (!bundledGroovyJarRoots.isEmpty()) {\n        return new NonClasspathDirectoriesScope(bundledGroovyJarRoots).uniteWith(moduleScope);\n      }\n    }\n    return moduleScope;\n  }","commit_id":"6cb72ff3013b1dc69e401cd679e1aff17ff12a70","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n\tpublic void testDLFileEntryAttachment() throws Exception {\n\t\tfinal Indexer indexer = Mockito.mock(Indexer.class);\n\n\t\tclass IndexerRegistryGetIndexer implements InvocationHandler {\n\n\t\t\t@Override\n\t\t\tpublic Indexer invoke(Object proxy, Method method, Object[] args)\n\t\t\t\tthrows Throwable {\n\n\t\t\t\tString className = (String)args[0];\n\n\t\t\t\tif (DLFILEENTRY_CLASS_NAME.equals(className)) {\n\t\t\t\t\treturn indexer;\n\t\t\t\t}\n\n\t\t\t\tif (SearchTestUtil.ATTACHMENT_OWNER_CLASS_NAME.equals(\n\t\t\t\t\t\tclassName)) {\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\treplace(\n\t\t\tmethod(IndexerRegistryUtil.class, \"getIndexer\", String.class)\n\t\t).with(\n\t\t\tnew IndexerRegistryGetIndexer()\n\t\t);\n\n\t\tString title = RandomTestUtil.randomString();\n\t\tString content = RandomTestUtil.randomString();\n\n\t\tSummary summary = new Summary(null, title, content, null);\n\n\t\tdoReturn(\n\t\t\tsummary\n\t\t).when(\n\t\t\tindexer\n\t\t).getSummary(\n\t\t\t(Document)Matchers.any(), Matchers.anyString(),\n\t\t\t(PortletURL)Matchers.any(), (PortletRequest)Matchers.isNull(),\n\t\t\t(PortletResponse)Matchers.isNull());\n\n\t\tclass AssetRendererFactoryRegistryGetAssetRendererFactoryByClassName\n\t\t\timplements InvocationHandler {\n\n\t\t\t@Override\n\t\t\tpublic AssetRendererFactory invoke(\n\t\t\t\t\tObject proxy, Method method, Object[] args)\n\t\t\t\tthrows Throwable {\n\n\t\t\t\tString className = (String)args[0];\n\n\t\t\t\tif (DLFILEENTRY_CLASS_NAME.equals(className)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (SearchTestUtil.ATTACHMENT_OWNER_CLASS_NAME.equals(\n\t\t\t\t\t\tclassName)) {\n\n\t\t\t\t\treturn assetRendererFactory;\n\t\t\t\t}\n\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t}\n\n\t\treplace(\n\t\t\tmethod(\n\t\t\t\tAssetRendererFactoryRegistryUtil.class,\n\t\t\t\t\"getAssetRendererFactoryByClassName\", String.class)\n\t\t).with(\n\t\t\tnew AssetRendererFactoryRegistryGetAssetRendererFactoryByClassName()\n\t\t);\n\n\t\twhen(\n\t\t\tassetRendererFactory.getAssetRenderer(\n\t\t\t\tSearchTestUtil.ATTACHMENT_OWNER_CLASS_PK)\n\t\t).thenReturn(\n\t\t\tassetRenderer\n\t\t);\n\n\t\twhen(\n\t\t\tassetRenderer.getSearchSummary((Locale)Matchers.any())\n\t\t).thenReturn(\n\t\t\tSearchTestUtil.SUMMARY_CONTENT\n\t\t);\n\n\t\twhen(\n\t\t\tassetRenderer.getTitle((Locale)Matchers.any())\n\t\t).thenReturn(\n\t\t\tSearchTestUtil.SUMMARY_TITLE\n\t\t);\n\n\t\twhen(\n\t\t\tdlAppLocalService.getFileEntry(SearchTestUtil.ENTRY_CLASS_PK)\n\t\t).thenReturn(\n\t\t\tfileEntry\n\t\t);\n\n\t\tSearchResult searchResult =\n\t\t\tassertThatSearchSingleDocumentReturnsOneSearchResult(\n\t\t\t\tcreateDLFileEntryAttachmentDocument());\n\n\t\tAssert.assertEquals(\n\t\t\tSearchTestUtil.ATTACHMENT_OWNER_CLASS_NAME,\n\t\t\tsearchResult.getClassName());\n\t\tAssert.assertEquals(\n\t\t\tSearchTestUtil.ATTACHMENT_OWNER_CLASS_PK,\n\t\t\tsearchResult.getClassPK());\n\n\t\tSummary searchResultSummary = searchResult.getSummary();\n\n\t\tAssert.assertNotSame(\n\t\t\t\"Summary in searchResult is not the same one returned by Indexer\",\n\t\t\tsummary, searchResultSummary);\n\n\t\tAssert.assertEquals(\n\t\t\tSearchTestUtil.SUMMARY_CONTENT, searchResultSummary.getContent());\n\t\tAssert.assertEquals(\n\t\t\tSearchTestUtil.SUMMARY_TITLE, searchResultSummary.getTitle());\n\n\t\tList<Tuple> fileEntryTuples = searchResult.getFileEntryTuples();\n\n\t\tAssert.assertEquals(1, fileEntryTuples.size());\n\n\t\tTuple tuple = fileEntryTuples.get(0);\n\n\t\tFileEntry tupleFileEntry = (FileEntry)tuple.getObject(0);\n\n\t\tSummary tupleSummary = (Summary)tuple.getObject(1);\n\n\t\tAssert.assertSame(fileEntry, tupleFileEntry);\n\n\t\tAssert.assertSame(\n\t\t\t\"Summary in tuple must be the same one returned by Indexer\",\n\t\t\tsummary, tupleSummary);\n\n\t\tAssert.assertEquals(content, tupleSummary.getContent());\n\t\tAssert.assertEquals(title, tupleSummary.getTitle());\n\n\t\tassertThatMBMessagesAndVersionsAreEmpty(searchResult);\n\t}","id":49575,"modified_method":"@Test\n\tpublic void testDLFileEntryAttachment() throws Exception {\n\t\tfinal Indexer indexer = Mockito.mock(Indexer.class);\n\n\t\treplace(\n\t\t\tmethod(IndexerRegistryUtil.class, \"getIndexer\", String.class)\n\t\t).with(\n\t\t\tnew InvocationHandler() {\n\t\n\t\t\t\t@Override\n\t\t\t\tpublic Indexer invoke(\n\t\t\t\t\t\tObject proxy, Method method, Object[] args)\n\t\t\t\t\tthrows Throwable {\n\t\n\t\t\t\t\tString className = (String)args[0];\n\t\n\t\t\t\t\tif (DLFILEENTRY_CLASS_NAME.equals(className)) {\n\t\t\t\t\t\treturn indexer;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (SearchTestUtil.ATTACHMENT_OWNER_CLASS_NAME.equals(\n\t\t\t\t\t\t\tclassName)) {\n\t\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t\t}\n\n\t\t\t}\n\t\t);\n\n\t\tString title = RandomTestUtil.randomString();\n\t\tString content = RandomTestUtil.randomString();\n\n\t\tSummary summary = new Summary(null, title, content, null);\n\n\t\tdoReturn(\n\t\t\tsummary\n\t\t).when(\n\t\t\tindexer\n\t\t).getSummary(\n\t\t\t(Document)Matchers.any(), Matchers.anyString(),\n\t\t\t(PortletURL)Matchers.any(), (PortletRequest)Matchers.isNull(),\n\t\t\t(PortletResponse)Matchers.isNull());\n\n\t\treplace(\n\t\t\tmethod(\n\t\t\t\tAssetRendererFactoryRegistryUtil.class,\n\t\t\t\t\"getAssetRendererFactoryByClassName\", String.class)\n\t\t).with(\n\t\t\tnew InvocationHandler() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic AssetRendererFactory invoke(\n\t\t\t\t\t\tObject proxy, Method method, Object[] args)\n\t\t\t\t\tthrows Throwable {\n\t\n\t\t\t\t\tString className = (String)args[0];\n\t\n\t\t\t\t\tif (DLFILEENTRY_CLASS_NAME.equals(className)) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (SearchTestUtil.ATTACHMENT_OWNER_CLASS_NAME.equals(\n\t\t\t\t\t\t\tclassName)) {\n\t\n\t\t\t\t\t\treturn assetRendererFactory;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t\t}\n\n\t\t\t}\n\t\t);\n\n\t\twhen(\n\t\t\tassetRendererFactory.getAssetRenderer(\n\t\t\t\tSearchTestUtil.ATTACHMENT_OWNER_CLASS_PK)\n\t\t).thenReturn(\n\t\t\tassetRenderer\n\t\t);\n\n\t\twhen(\n\t\t\tassetRenderer.getSearchSummary((Locale)Matchers.any())\n\t\t).thenReturn(\n\t\t\tSearchTestUtil.SUMMARY_CONTENT\n\t\t);\n\n\t\twhen(\n\t\t\tassetRenderer.getTitle((Locale)Matchers.any())\n\t\t).thenReturn(\n\t\t\tSearchTestUtil.SUMMARY_TITLE\n\t\t);\n\n\t\twhen(\n\t\t\tdlAppLocalService.getFileEntry(SearchTestUtil.ENTRY_CLASS_PK)\n\t\t).thenReturn(\n\t\t\tfileEntry\n\t\t);\n\n\t\tSearchResult searchResult =\n\t\t\tassertThatSearchSingleDocumentReturnsOneSearchResult(\n\t\t\t\tcreateDLFileEntryAttachmentDocument());\n\n\t\tAssert.assertEquals(\n\t\t\tSearchTestUtil.ATTACHMENT_OWNER_CLASS_NAME,\n\t\t\tsearchResult.getClassName());\n\t\tAssert.assertEquals(\n\t\t\tSearchTestUtil.ATTACHMENT_OWNER_CLASS_PK,\n\t\t\tsearchResult.getClassPK());\n\n\t\tSummary searchResultSummary = searchResult.getSummary();\n\n\t\tAssert.assertNotSame(\n\t\t\t\"Summary in searchResult is not the same one returned by Indexer\",\n\t\t\tsummary, searchResultSummary);\n\n\t\tAssert.assertEquals(\n\t\t\tSearchTestUtil.SUMMARY_CONTENT, searchResultSummary.getContent());\n\t\tAssert.assertEquals(\n\t\t\tSearchTestUtil.SUMMARY_TITLE, searchResultSummary.getTitle());\n\n\t\tList<Tuple> fileEntryTuples = searchResult.getFileEntryTuples();\n\n\t\tAssert.assertEquals(1, fileEntryTuples.size());\n\n\t\tTuple tuple = fileEntryTuples.get(0);\n\n\t\tFileEntry tupleFileEntry = (FileEntry)tuple.getObject(0);\n\n\t\tSummary tupleSummary = (Summary)tuple.getObject(1);\n\n\t\tAssert.assertSame(fileEntry, tupleFileEntry);\n\n\t\tAssert.assertSame(\n\t\t\t\"Summary in tuple must be the same one returned by Indexer\",\n\t\t\tsummary, tupleSummary);\n\n\t\tAssert.assertEquals(content, tupleSummary.getContent());\n\t\tAssert.assertEquals(title, tupleSummary.getTitle());\n\n\t\tassertThatMBMessagesAndVersionsAreEmpty(searchResult);\n\t}","commit_id":"8baf55e6df26fd29e17d8a8bc26af3a754174ef1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static Tree createTestIndexNode(Tree index, String type)\n            throws Exception {\n        Tree indexDef = index;\n        for (String p : PathUtils.elements(TEST_INDEX_HOME)) {\n            if (indexDef.hasChild(p)) {\n                indexDef = indexDef.getChild(p);\n            } else {\n                indexDef = indexDef.addChild(p);\n            }\n        }\n        indexDef = indexDef.addChild(INDEX_DEFINITIONS_NAME).addChild(\n                TEST_INDEX_NAME);\n        indexDef.setProperty(JcrConstants.JCR_PRIMARYTYPE,\n                INDEX_DEFINITIONS_NODE_TYPE, Type.NAME);\n        indexDef.setProperty(TYPE_PROPERTY_NAME, type);\n        indexDef.setProperty(REINDEX_PROPERTY_NAME, true);\n        return indexDef;\n    }","id":49576,"modified_method":"protected static Tree createTestIndexNode(Tree index, String type)\n            throws Exception {\n        Tree indexDef = index.addChild(INDEX_DEFINITIONS_NAME).addChild(\n                TEST_INDEX_NAME);\n        indexDef.setProperty(JcrConstants.JCR_PRIMARYTYPE,\n                INDEX_DEFINITIONS_NODE_TYPE, Type.NAME);\n        indexDef.setProperty(TYPE_PROPERTY_NAME, type);\n        indexDef.setProperty(REINDEX_PROPERTY_NAME, true);\n        return indexDef;\n    }","commit_id":"620d646b1d80e3b27605cafe7a9548b0fdda72aa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void initialize(NodeStore store) {\n        NodeStoreBranch branch = store.branch();\n\n        NodeBuilder root = branch.getRoot().builder();\n        root.setProperty(\"jcr:primaryType\", \"rep:root\", Type.NAME);\n\n        if (!root.hasChildNode(\"jcr:system\")) {\n            NodeBuilder system = root.child(\"jcr:system\");\n            system.setProperty(\"jcr:primaryType\", \"rep:system\", Type.NAME);\n\n            system.child(\"jcr:versionStorage\")\n                .setProperty(\"jcr:primaryType\", \"rep:versionStorage\", Type.NAME);\n            system.child(\"jcr:nodeTypes\")\n                .setProperty(\"jcr:primaryType\", \"rep:nodeTypes\", Type.NAME);\n            system.child(\"jcr:activities\")\n                .setProperty(\"jcr:primaryType\", \"rep:Activities\", Type.NAME);\n            system.child(\"rep:privileges\")\n                .setProperty(\"jcr:primaryType\", \"rep:Privileges\", Type.NAME);\n\n            NodeBuilder security = root.child(\"rep:security\");\n            security.setProperty(\n                    \"jcr:primaryType\", \"rep:AuthorizableFolder\", Type.NAME);\n\n            NodeBuilder authorizables = security.child(\"rep:authorizables\");\n            authorizables.setProperty(\n                    \"jcr:primaryType\", \"rep:AuthorizableFolder\", Type.NAME);\n\n            NodeBuilder users = authorizables.child(\"rep:users\");\n            users.setProperty(\n                    \"jcr:primaryType\", \"rep:AuthorizableFolder\", Type.NAME);\n\n            NodeBuilder a = users.child(\"a\");\n            a.setProperty(\"jcr:primaryType\", \"rep:AuthorizableFolder\", Type.NAME);\n\n            a.child(\"ad\")\n                .setProperty(\"jcr:primaryType\", \"rep:AuthorizableFolder\", Type.NAME)\n                .child(\"admin\")\n                .setProperty(\"jcr:primaryType\", \"rep:User\", Type.NAME)\n                .setProperty(\"jcr:uuid\", \"21232f29-7a57-35a7-8389-4a0e4a801fc3\")\n                .setProperty(\"rep:principalName\", \"admin\")\n                .setProperty(\"rep:authorizableId\", \"admin\")\n                .setProperty(\"rep:password\", \"{SHA-256}9e515755e95513ce-1000-0696716f8baf8890a35eda1b9f2d5a4e727d1c7e1c062f03180dcc2a20f61f3b\");\n\n            a.child(\"an\")\n                .setProperty(\"jcr:primaryType\", \"rep:AuthorizableFolder\", Type.NAME)\n                .child(\"anonymous\")\n                .setProperty(\"jcr:primaryType\", \"rep:User\", Type.NAME)\n                .setProperty(\"jcr:uuid\", \"294de355-7d9d-30b3-92d8-a1e6aab028cf\")\n                .setProperty(\"rep:principalName\", \"anonymous\")\n                .setProperty(\"rep:authorizableId\", \"anonymous\");\n        }\n\n        if (!root.hasChildNode(\"oak:index\")) {\n            NodeBuilder index = root.child(\"oak:index\");\n            index.child(\"uuid\")\n                .setProperty(\"jcr:primaryType\", \"oak:queryIndexDefinition\", Type.NAME)\n                .setProperty(\"propertyNames\", \"jcr:uuid\")\n                .setProperty(\"unique\", true);\n            index.child(\"primaryType\")\n                .setProperty(\"jcr:primaryType\", \"oak:queryIndexDefinition\", Type.NAME)\n                .setProperty(\"propertyNames\", \"jcr:primaryType\");\n            // FIXME: user-mgt related unique properties (rep:authorizableId, rep:principalName) are implementation detail and not generic for repo\n            // FIXME: rep:principalName only needs to be unique if defined with user/group nodes -> add defining nt-info to uniqueness constraint otherwise ac-editing will fail.\n            index.child(\"authorizableId\")\n                .setProperty(\"jcr:primaryType\", \"oak:queryIndexDefinition\", Type.NAME)\n                .setProperty(\"propertyNames\", \"rep:authorizableId\")\n                .setProperty(\"unique\", true);\n            index.child(\"principalName\")\n                .setProperty(\"jcr:primaryType\", \"oak:queryIndexDefinition\", Type.NAME)\n                .setProperty(\"propertyNames\", \"rep:principalName\")\n                .setProperty(\"unique\", true);\n        }\n        try {\n            branch.setRoot(root.getNodeState());\n            branch.merge();\n        } catch (CommitFailedException e) {\n            throw new RuntimeException(e); // TODO: shouldn't need the wrapper\n        }\n\n        BuiltInNodeTypes.register(new RootImpl(store));\n    }","id":49577,"modified_method":"@Override\n    public void initialize(NodeStore store) {\n        NodeStoreBranch branch = store.branch();\n\n        NodeBuilder root = branch.getRoot().builder();\n        root.setProperty(\"jcr:primaryType\", \"rep:root\", Type.NAME);\n\n        if (!root.hasChildNode(\"jcr:system\")) {\n            NodeBuilder system = root.child(\"jcr:system\");\n            system.setProperty(\"jcr:primaryType\", \"rep:system\", Type.NAME);\n\n            system.child(\"jcr:versionStorage\")\n                .setProperty(\"jcr:primaryType\", \"rep:versionStorage\", Type.NAME);\n            system.child(\"jcr:nodeTypes\")\n                .setProperty(\"jcr:primaryType\", \"rep:nodeTypes\", Type.NAME);\n            system.child(\"jcr:activities\")\n                .setProperty(\"jcr:primaryType\", \"rep:Activities\", Type.NAME);\n            system.child(\"rep:privileges\")\n                .setProperty(\"jcr:primaryType\", \"rep:Privileges\", Type.NAME);\n\n            NodeBuilder security = root.child(\"rep:security\");\n            security.setProperty(\n                    \"jcr:primaryType\", \"rep:AuthorizableFolder\", Type.NAME);\n\n            NodeBuilder authorizables = security.child(\"rep:authorizables\");\n            authorizables.setProperty(\n                    \"jcr:primaryType\", \"rep:AuthorizableFolder\", Type.NAME);\n\n            NodeBuilder users = authorizables.child(\"rep:users\");\n            users.setProperty(\n                    \"jcr:primaryType\", \"rep:AuthorizableFolder\", Type.NAME);\n\n            NodeBuilder a = users.child(\"a\");\n            a.setProperty(\"jcr:primaryType\", \"rep:AuthorizableFolder\", Type.NAME);\n\n            a.child(\"ad\")\n                .setProperty(\"jcr:primaryType\", \"rep:AuthorizableFolder\", Type.NAME)\n                .child(\"admin\")\n                .setProperty(\"jcr:primaryType\", \"rep:User\", Type.NAME)\n                .setProperty(\"jcr:uuid\", \"21232f29-7a57-35a7-8389-4a0e4a801fc3\")\n                .setProperty(\"rep:principalName\", \"admin\")\n                .setProperty(\"rep:authorizableId\", \"admin\")\n                .setProperty(\"rep:password\", \"{SHA-256}9e515755e95513ce-1000-0696716f8baf8890a35eda1b9f2d5a4e727d1c7e1c062f03180dcc2a20f61f3b\");\n\n            a.child(\"an\")\n                .setProperty(\"jcr:primaryType\", \"rep:AuthorizableFolder\", Type.NAME)\n                .child(\"anonymous\")\n                .setProperty(\"jcr:primaryType\", \"rep:User\", Type.NAME)\n                .setProperty(\"jcr:uuid\", \"294de355-7d9d-30b3-92d8-a1e6aab028cf\")\n                .setProperty(\"rep:principalName\", \"anonymous\")\n                .setProperty(\"rep:authorizableId\", \"anonymous\");\n        }\n\n        if (!root.hasChildNode(\"oak:index\")) {\n            NodeBuilder index = root.child(\"oak:index\");\n            index.child(\"uuid\")\n                .setProperty(\"jcr:primaryType\", \"oak:queryIndexDefinition\", Type.NAME)\n                .setProperty(\"type\", \"property\")\n                .setProperty(\"propertyNames\", \"jcr:uuid\")\n                .setProperty(\"unique\", true);\n            index.child(\"primaryType\")\n                .setProperty(\"jcr:primaryType\", \"oak:queryIndexDefinition\", Type.NAME)\n                .setProperty(\"propertyNames\", \"jcr:primaryType\");\n            // FIXME: user-mgt related unique properties (rep:authorizableId, rep:principalName) are implementation detail and not generic for repo\n            // FIXME: rep:principalName only needs to be unique if defined with user/group nodes -> add defining nt-info to uniqueness constraint otherwise ac-editing will fail.\n            index.child(\"authorizableId\")\n                .setProperty(\"jcr:primaryType\", \"oak:queryIndexDefinition\", Type.NAME)\n                .setProperty(\"type\", \"property\")\n                .setProperty(\"propertyNames\", \"rep:authorizableId\")\n                .setProperty(\"unique\", true);\n            index.child(\"principalName\")\n                .setProperty(\"jcr:primaryType\", \"oak:queryIndexDefinition\", Type.NAME)\n                .setProperty(\"type\", \"property\")\n                .setProperty(\"propertyNames\", \"rep:principalName\")\n                .setProperty(\"unique\", true);\n        }\n        try {\n            branch.setRoot(root.getNodeState());\n            branch.merge();\n        } catch (CommitFailedException e) {\n            throw new RuntimeException(e); // TODO: shouldn't need the wrapper\n        }\n\n        BuiltInNodeTypes.register(new RootImpl(store));\n    }","commit_id":"620d646b1d80e3b27605cafe7a9548b0fdda72aa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private Jcr(Oak oak) {\n        this.oak = oak;\n\n        with(new InitialContent());\n\n        with(new DefaultTypeEditor());\n\n        with(new SecurityProviderImpl());\n\n        with(new NameValidatorProvider());\n        with(new NamespaceValidatorProvider());\n        with(new TypeValidatorProvider());\n        with(new ConflictValidatorProvider());\n\n        with(new PropertyIndexHook());\n        with(new LuceneReindexHook(DEFAULT_INDEX_HOME));\n        with(new LuceneHook(DEFAULT_INDEX_HOME));\n        with(new AnnotatingConflictHandler());\n\n        with(new PropertyIndexProvider());\n        with(new LuceneIndexProvider(DEFAULT_INDEX_HOME));\n    }","id":49578,"modified_method":"private Jcr(Oak oak) {\n        this.oak = oak;\n\n        with(new InitialContent());\n\n        with(new DefaultTypeEditor());\n\n        with(new SecurityProviderImpl());\n\n        with(new NameValidatorProvider());\n        with(new NamespaceValidatorProvider());\n        with(new TypeValidatorProvider());\n        with(new ConflictValidatorProvider());\n\n        with(new IndexHookManager(\n                new CompositeIndexHookProvider(\n                new PropertyIndexHookProvider(), \n                new LuceneIndexHookProvider())));\n        with(new AnnotatingConflictHandler());\n\n        with(new PropertyIndexProvider());\n        with(new LuceneIndexProvider());\n    }","commit_id":"620d646b1d80e3b27605cafe7a9548b0fdda72aa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeState processCommit(NodeState before, NodeState after)\n            throws CommitFailedException {\n        NodeBuilder rootBuilder = after.builder();\n        NodeBuilder builder = rootBuilder;\n        for (String name : elements(path)) {\n            builder = builder.child(name);\n        }\n        builder = builder.child(INDEX_DATA_CHILD_NAME);\n        Directory directory = new ReadWriteOakDirectory(builder);\n\n        try {\n            IndexWriter writer = new IndexWriter(directory, config);\n            try {\n                LuceneDiff diff = new LuceneDiff(writer, \"/\");\n                after.compareAgainstBaseState(before, diff);\n                diff.postProcess(after);\n            } finally {\n                writer.close();\n                builder.setProperty(REINDEX_PROPERTY_NAME, false);\n            }\n            return rootBuilder.getNodeState();\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new CommitFailedException(\n                    \"Failed to update the full text search index\", e);\n        }\n    }","id":49579,"modified_method":"@Override\n    public NodeState processCommit(NodeState before, NodeState after)\n            throws CommitFailedException {\n        Directory directory = new ReadWriteOakDirectory(\n                root.child(INDEX_DATA_CHILD_NAME));\n        try {\n            IndexWriter writer = new IndexWriter(directory, config);\n            try {\n                LuceneDiff diff = new LuceneDiff(writer, \"/\");\n                after.compareAgainstBaseState(before, diff);\n                diff.postProcess(after);\n            } finally {\n                writer.close();\n            }\n            return after;\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new CommitFailedException(\n                    \"Failed to update the full text search index\", e);\n        }\n    }","commit_id":"620d646b1d80e3b27605cafe7a9548b0fdda72aa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeState processCommit(NodeState before, NodeState after)\n            throws CommitFailedException {\n        List<CommitHook> hooks = new ArrayList<CommitHook>();\n        List<IndexDefinition> indexDefinitions = buildIndexDefinitions(after,\n                indexConfigPath, TYPE_LUCENE);\n        for (IndexDefinition def : indexDefinitions) {\n            hooks.add(new LuceneEditor(def.getPath()));\n        }\n        return CompositeHook.compose(hooks).processCommit(before, after);\n    }","id":49580,"modified_method":"@Override\n    public NodeState processCommit(NodeState before, NodeState after)\n            throws CommitFailedException {\n        new LuceneEditor(builder).processCommit(before, after);\n        return after;\n    }","commit_id":"620d646b1d80e3b27605cafe7a9548b0fdda72aa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override @Nonnull\n    public List<QueryIndex> getQueryIndexes(NodeState nodeState) {\n        if (!PathUtils.isValid(indexPath)) {\n            LOG.warn(\"index path is not valid {}\", indexPath);\n            return Collections.<QueryIndex> emptyList();\n        }\n        List<QueryIndex> tempIndexes = new ArrayList<QueryIndex>();\n        for (IndexDefinition child : buildIndexDefinitions(nodeState,\n                indexPath, TYPE_LUCENE)) {\n            LOG.debug(\"found a lucene index definition {}\", child);\n            tempIndexes.add(new LuceneIndex(child));\n        }\n        return tempIndexes;\n    }","id":49581,"modified_method":"@Override @Nonnull\n    public List<QueryIndex> getQueryIndexes(NodeState nodeState) {\n        List<QueryIndex> tempIndexes = new ArrayList<QueryIndex>();\n        for (IndexDefinition child : buildIndexDefinitions(nodeState, \"/\",\n                TYPE_LUCENE)) {\n            LOG.debug(\"found a lucene index definition {}\", child);\n            tempIndexes.add(new LuceneIndex(child));\n        }\n        return tempIndexes;\n    }","commit_id":"620d646b1d80e3b27605cafe7a9548b0fdda72aa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected ContentRepository createRepository() {\n        return new Oak()\n            .with(new InitialContent())\n            .with(new LuceneIndexProvider(TEST_INDEX_HOME))\n            .with(new LuceneReindexHook(TEST_INDEX_HOME))\n            .with(new LuceneHook(TEST_INDEX_HOME))\n            .createContentRepository();\n    }","id":49582,"modified_method":"@Override\n    protected ContentRepository createRepository() {\n        return new Oak()\n            .with(new InitialContent())\n            .with(new LuceneIndexProvider())\n            .with(new IndexHookManager(new LuceneIndexHookProvider()))\n            .createContentRepository();\n    }","commit_id":"620d646b1d80e3b27605cafe7a9548b0fdda72aa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testLucene() throws Exception {\n        KernelNodeStore store = new KernelNodeStore(new MicroKernelImpl());\n\n        IndexDefinition testID = new IndexDefinitionImpl(DEFAULT_INDEX_NAME,\n                TYPE_LUCENE, \"/\" + INDEX_DEFINITIONS_NAME + \"/\"\n                        + DEFAULT_INDEX_NAME);\n\n        store.setHook(new LuceneEditor(testID.getPath()));\n        Root root = new RootImpl(store, null, new Subject(),\n                new AccessControlProviderImpl(),\n                new CompositeQueryIndexProvider());\n\n        Tree tree = root.getTree(\"/\");\n        tree.setProperty(\"foo\", \"bar\");\n        root.commit();\n\n        QueryIndex index = new LuceneIndex(testID);\n        FilterImpl filter = new FilterImpl(null);\n        filter.restrictPath(\"/\", Filter.PathRestriction.EXACT);\n        filter.restrictProperty(\"foo\", Operator.EQUAL,\n                PropertyValues.newString(\"bar\"));\n        Cursor cursor = index.query(filter, store.getRoot());\n        assertTrue(cursor.next());\n        assertEquals(\"/\", cursor.currentRow().getPath());\n        assertFalse(cursor.next());\n    }","id":49583,"modified_method":"@Test\n    public void testLucene() throws Exception {\n        NodeState root = MemoryNodeState.EMPTY_NODE;\n\n        NodeBuilder builder = root.builder();\n        NodeBuilder index = builder.child(\"oak:index\").child(\"lucene\");\n        IndexDefinition testDef = new IndexDefinitionImpl(\"lucene\",\n                TYPE_LUCENE, \"/oak:index/lucene\");\n\n        NodeState before = builder.getNodeState();\n        builder.setProperty(\"foo\", \"bar\");\n        NodeState after = builder.getNodeState();\n\n        new LuceneEditor(index).processCommit(before, after);\n\n        QueryIndex queryIndex = new LuceneIndex(testDef);\n        FilterImpl filter = new FilterImpl(null);\n        filter.restrictPath(\"/\", Filter.PathRestriction.EXACT);\n        filter.restrictProperty(\"foo\", Operator.EQUAL,\n                PropertyValues.newString(\"bar\"));\n        Cursor cursor = queryIndex.query(filter, builder.getNodeState());\n        assertTrue(cursor.next());\n        assertEquals(\"/\", cursor.currentRow().getPath());\n        assertFalse(cursor.next());\n    }","commit_id":"620d646b1d80e3b27605cafe7a9548b0fdda72aa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static CommitHook buildDefaultCommitHook() {\n            return new CompositeHook(\n                    new DefaultTypeEditor(),\n                    new ValidatingHook(createDefaultValidatorProvider()),\n                    new PropertyIndexHook(),\n                    new LuceneReindexHook(DEFAULT_INDEX_HOME),\n                    new LuceneHook(DEFAULT_INDEX_HOME));\n        }","id":49584,"modified_method":"private static CommitHook buildDefaultCommitHook() {\n            return new CompositeHook(\n                    new DefaultTypeEditor(),\n                    new ValidatingHook(createDefaultValidatorProvider()),\n                    new IndexHookManager(\n                            new CompositeIndexHookProvider(\n                            new PropertyIndexHookProvider(), \n                            new LuceneIndexHookProvider())));\n        }","commit_id":"620d646b1d80e3b27605cafe7a9548b0fdda72aa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private PropertyIndexDiff(\n            PropertyIndexDiff parent,\n            NodeBuilder node, String name, String path,\n            Map<String, List<PropertyIndexUpdate>> updates) {\n        this.parent = parent;\n        this.node = node;\n        this.name = name;\n        this.path = path;\n        this.updates = updates;\n\n        if (node != null && node.hasChildNode(INDEX_DEFINITIONS_NAME)) {\n            NodeBuilder index = node.child(INDEX_DEFINITIONS_NAME);\n            for (String indexName : index.getChildNodeNames()) {\n                NodeBuilder indexChild = index.child(indexName);\n                PropertyState ps = indexChild.getProperty(\"propertyNames\");\n                Iterable<String> propertyNames = ps != null ? ps\n                        .getValue(Type.STRINGS) : ImmutableList.of(indexName);\n                for (String pname : propertyNames) {\n                    List<PropertyIndexUpdate> list = this.updates.get(pname);\n                    if (list == null) {\n                        list = Lists.newArrayList();\n                        this.updates.put(pname, list);\n                    }\n                    list.add(new PropertyIndexUpdate(getPath(), indexChild));\n                }\n            }\n        }\n    }","id":49585,"modified_method":"private PropertyIndexDiff(\n            PropertyIndexDiff parent,\n            NodeBuilder node, String name, String path,\n            Map<String, List<PropertyIndexUpdate>> updates) {\n        this.parent = parent;\n        this.node = node;\n        this.name = name;\n        this.path = path;\n        this.updates = updates;\n\n        if (node != null && isIndexNodeType(node.getProperty(JCR_PRIMARYTYPE))) {\n            update(node, name);\n        }\n        if (node != null && node.hasChildNode(INDEX_DEFINITIONS_NAME)) {\n            NodeBuilder index = node.child(INDEX_DEFINITIONS_NAME);\n            for (String indexName : index.getChildNodeNames()) {\n                update(index.child(indexName), indexName);\n            }\n        }\n    }","commit_id":"620d646b1d80e3b27605cafe7a9548b0fdda72aa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override @Nonnull\n    public NodeState processCommit(NodeState before, NodeState after)\n            throws CommitFailedException {\n        NodeBuilder builder = after.builder();\n\n        Map<String, List<PropertyIndexUpdate>> indexes = Maps.newHashMap();\n        PropertyIndexDiff diff = new PropertyIndexDiff(builder, indexes);\n        after.compareAgainstBaseState(before, diff);\n\n        for (List<PropertyIndexUpdate> updates : indexes.values()) {\n            for (PropertyIndexUpdate update : updates) {\n                update.apply();\n            }\n        }\n\n        return builder.getNodeState();\n    }","id":49586,"modified_method":"@Override @Nonnull\n    public NodeState processCommit(NodeState before, NodeState after)\n            throws CommitFailedException {\n        Map<String, List<PropertyIndexUpdate>> indexes = Maps.newHashMap();\n        PropertyIndexDiff diff = new PropertyIndexDiff(builder, indexes);\n        after.compareAgainstBaseState(before, diff);\n\n        for (List<PropertyIndexUpdate> updates : indexes.values()) {\n            for (PropertyIndexUpdate update : updates) {\n                update.apply();\n            }\n        }\n\n        return after;\n    }","commit_id":"620d646b1d80e3b27605cafe7a9548b0fdda72aa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected ContentRepository createRepository() {\n        return new Oak()\n            .with(new InitialContent())\n            .with(new PropertyIndexProvider())\n            .with(new PropertyIndexHook())\n            .createContentRepository();\n    }","id":49587,"modified_method":"@Override\n    protected ContentRepository createRepository() {\n        return new Oak()\n            .with(new InitialContent())\n            .with(new PropertyIndexProvider())\n            .with(new IndexHookManager(new PropertyIndexHookProvider()))\n            .createContentRepository();\n    }","commit_id":"620d646b1d80e3b27605cafe7a9548b0fdda72aa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testPropertyLookup() throws Exception {\n        NodeState root = MemoryNodeState.EMPTY_NODE;\n\n        // Add index definition\n        NodeBuilder builder = root.builder();\n        builder.child(\"oak:index\").child(\"foo\");\n        NodeState before = builder.getNodeState();\n\n        // Add some content and process it through the property index hook\n        builder = before.builder();\n        builder.child(\"a\").setProperty(\"foo\", \"abc\");\n        builder.child(\"b\").setProperty(\"foo\", Arrays.asList(\"abc\", \"def\"), Type.STRINGS);\n        // plus lots of dummy content to highlight the benefit of indexing\n        for (int i = 0; i < MANY; i++) {\n            builder.child(\"n\" + i).setProperty(\"foo\", \"xyz\");\n        }\n        NodeState after = builder.getNodeState();\n\n        // First check lookups without an index\n        PropertyIndexLookup lookup = new PropertyIndexLookup(after);\n        long withoutIndex = System.nanoTime();\n        assertEquals(ImmutableSet.of(\"a\", \"b\"), lookup.find(\"foo\", \"abc\"));\n        assertEquals(ImmutableSet.of(\"b\"), lookup.find(\"foo\", \"def\"));\n        assertEquals(ImmutableSet.of(), lookup.find(\"foo\", \"ghi\"));\n        assertEquals(MANY, lookup.find(\"foo\", \"xyz\").size());\n        withoutIndex = System.nanoTime() - withoutIndex;\n\n        // ... then see how adding an index affects the code\n        lookup = new PropertyIndexLookup(\n                new PropertyIndexHook().processCommit(before, after));\n        long withIndex = System.nanoTime();\n        assertEquals(ImmutableSet.of(\"a\", \"b\"), lookup.find(\"foo\", \"abc\"));\n        assertEquals(ImmutableSet.of(\"b\"), lookup.find(\"foo\", \"def\"));\n        assertEquals(ImmutableSet.of(), lookup.find(\"foo\", \"ghi\"));\n        assertEquals(MANY, lookup.find(\"foo\", \"xyz\").size());\n        withIndex = System.nanoTime() - withIndex;\n\n        // System.out.println(\"Index performance ratio: \" + withoutIndex/withIndex);\n        // assertTrue(withoutIndex > withIndex);\n    }","id":49588,"modified_method":"@Test\n    public void testPropertyLookup() throws Exception {\n        NodeState root = MemoryNodeState.EMPTY_NODE;\n\n        // Add index definition\n        NodeBuilder builder = root.builder();\n        builder.child(\"oak:index\").child(\"foo\");\n        NodeState before = builder.getNodeState();\n\n        // Add some content and process it through the property index hook\n        builder = before.builder();\n        builder.child(\"a\").setProperty(\"foo\", \"abc\");\n        builder.child(\"b\").setProperty(\"foo\", Arrays.asList(\"abc\", \"def\"), Type.STRINGS);\n        // plus lots of dummy content to highlight the benefit of indexing\n        for (int i = 0; i < MANY; i++) {\n            builder.child(\"n\" + i).setProperty(\"foo\", \"xyz\");\n        }\n        NodeState after = builder.getNodeState();\n\n        // First check lookups without an index\n        PropertyIndexLookup lookup = new PropertyIndexLookup(after);\n        long withoutIndex = System.nanoTime();\n        assertEquals(ImmutableSet.of(\"a\", \"b\"), lookup.find(\"foo\", \"abc\"));\n        assertEquals(ImmutableSet.of(\"b\"), lookup.find(\"foo\", \"def\"));\n        assertEquals(ImmutableSet.of(), lookup.find(\"foo\", \"ghi\"));\n        assertEquals(MANY, lookup.find(\"foo\", \"xyz\").size());\n        withoutIndex = System.nanoTime() - withoutIndex;\n\n        // ... then see how adding an index affects the code\n        lookup = new PropertyIndexLookup(\n                new PropertyIndexHook(builder).processCommit(before, after));\n        long withIndex = System.nanoTime();\n        assertEquals(ImmutableSet.of(\"a\", \"b\"), lookup.find(\"foo\", \"abc\"));\n        assertEquals(ImmutableSet.of(\"b\"), lookup.find(\"foo\", \"def\"));\n        assertEquals(ImmutableSet.of(), lookup.find(\"foo\", \"ghi\"));\n        assertEquals(MANY, lookup.find(\"foo\", \"xyz\").size());\n        withIndex = System.nanoTime() - withIndex;\n\n        // System.out.println(\"Index performance ratio: \" + withoutIndex/withIndex);\n        // assertTrue(withoutIndex > withIndex);\n    }","commit_id":"620d646b1d80e3b27605cafe7a9548b0fdda72aa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testCustomConfigPropertyLookup() throws Exception {\n        NodeState root = MemoryNodeState.EMPTY_NODE;\n\n        // Add index definition\n        NodeBuilder builder = root.builder();\n        builder.child(\"oak:index\").child(\"fooIndex\").setProperty(\"propertyNames\", Arrays.asList(\"foo\", \"extrafoo\"), Type.STRINGS);\n        NodeState before = builder.getNodeState();\n\n        // Add some content and process it through the property index hook\n        builder = before.builder();\n        builder.child(\"a\").setProperty(\"foo\", \"abc\").setProperty(\"extrafoo\", \"pqr\");\n        builder.child(\"b\").setProperty(\"foo\", Arrays.asList(\"abc\", \"def\"), Type.STRINGS);\n        // plus lots of dummy content to highlight the benefit of indexing\n        for (int i = 0; i < MANY; i++) {\n            builder.child(\"n\" + i).setProperty(\"foo\", \"xyz\");\n        }\n        NodeState after = builder.getNodeState();\n\n        // First check lookups without an index\n        PropertyIndexLookup lookup = new PropertyIndexLookup(after);\n        long withoutIndex = System.nanoTime();\n        assertEquals(ImmutableSet.of(\"a\", \"b\"), lookup.find(\"foo\", \"abc\"));\n        assertEquals(ImmutableSet.of(\"b\"), lookup.find(\"foo\", \"def\"));\n        assertEquals(ImmutableSet.of(), lookup.find(\"foo\", \"ghi\"));\n        assertEquals(MANY, lookup.find(\"foo\", \"xyz\").size());\n        assertEquals(ImmutableSet.of(\"a\"), lookup.find(\"extrafoo\", \"pqr\"));\n        assertEquals(ImmutableSet.of(), lookup.find(\"pqr\", \"foo\"));\n        withoutIndex = System.nanoTime() - withoutIndex;\n\n        // ... then see how adding an index affects the code\n        lookup = new PropertyIndexLookup(\n                new PropertyIndexHook().processCommit(before, after));\n        long withIndex = System.nanoTime();\n        assertEquals(ImmutableSet.of(\"a\", \"b\"), lookup.find(\"foo\", \"abc\"));\n        assertEquals(ImmutableSet.of(\"b\"), lookup.find(\"foo\", \"def\"));\n        assertEquals(ImmutableSet.of(), lookup.find(\"foo\", \"ghi\"));\n        assertEquals(MANY, lookup.find(\"foo\", \"xyz\").size());\n        assertEquals(ImmutableSet.of(\"a\"), lookup.find(\"extrafoo\", \"pqr\"));\n        assertEquals(ImmutableSet.of(), lookup.find(\"pqr\", \"foo\"));\n        withIndex = System.nanoTime() - withIndex;\n\n        // System.out.println(\"Index performance ratio: \" + withoutIndex/withIndex);\n        // assertTrue(withoutIndex > withIndex);\n    }","id":49589,"modified_method":"@Test\n    public void testCustomConfigPropertyLookup() throws Exception {\n        NodeState root = MemoryNodeState.EMPTY_NODE;\n\n        // Add index definition\n        NodeBuilder builder = root.builder();\n        builder.child(\"oak:index\").child(\"fooIndex\").setProperty(\"propertyNames\", Arrays.asList(\"foo\", \"extrafoo\"), Type.STRINGS);\n        NodeState before = builder.getNodeState();\n\n        // Add some content and process it through the property index hook\n        builder = before.builder();\n        builder.child(\"a\").setProperty(\"foo\", \"abc\").setProperty(\"extrafoo\", \"pqr\");\n        builder.child(\"b\").setProperty(\"foo\", Arrays.asList(\"abc\", \"def\"), Type.STRINGS);\n        // plus lots of dummy content to highlight the benefit of indexing\n        for (int i = 0; i < MANY; i++) {\n            builder.child(\"n\" + i).setProperty(\"foo\", \"xyz\");\n        }\n        NodeState after = builder.getNodeState();\n\n        // First check lookups without an index\n        PropertyIndexLookup lookup = new PropertyIndexLookup(after);\n        long withoutIndex = System.nanoTime();\n        assertEquals(ImmutableSet.of(\"a\", \"b\"), lookup.find(\"foo\", \"abc\"));\n        assertEquals(ImmutableSet.of(\"b\"), lookup.find(\"foo\", \"def\"));\n        assertEquals(ImmutableSet.of(), lookup.find(\"foo\", \"ghi\"));\n        assertEquals(MANY, lookup.find(\"foo\", \"xyz\").size());\n        assertEquals(ImmutableSet.of(\"a\"), lookup.find(\"extrafoo\", \"pqr\"));\n        assertEquals(ImmutableSet.of(), lookup.find(\"pqr\", \"foo\"));\n        withoutIndex = System.nanoTime() - withoutIndex;\n\n        // ... then see how adding an index affects the code\n        lookup = new PropertyIndexLookup(\n                new PropertyIndexHook(builder).processCommit(before, after));\n        long withIndex = System.nanoTime();\n        assertEquals(ImmutableSet.of(\"a\", \"b\"), lookup.find(\"foo\", \"abc\"));\n        assertEquals(ImmutableSet.of(\"b\"), lookup.find(\"foo\", \"def\"));\n        assertEquals(ImmutableSet.of(), lookup.find(\"foo\", \"ghi\"));\n        assertEquals(MANY, lookup.find(\"foo\", \"xyz\").size());\n        assertEquals(ImmutableSet.of(\"a\"), lookup.find(\"extrafoo\", \"pqr\"));\n        assertEquals(ImmutableSet.of(), lookup.find(\"pqr\", \"foo\"));\n        withIndex = System.nanoTime() - withIndex;\n\n        // System.out.println(\"Index performance ratio: \" + withoutIndex/withIndex);\n        // assertTrue(withoutIndex > withIndex);\n    }","commit_id":"620d646b1d80e3b27605cafe7a9548b0fdda72aa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected ContentRepository createRepository() {\n        // the property and prefix index currently require the index wrapper\n        IndexWrapper mk = new IndexWrapper(new MicroKernelImpl(),\n                TEST_INDEX_HOME + INDEX_DEFINITIONS_NAME + \"/indexes\");\n\n        PropertyIndexer indexer = new PropertyIndexer(mk.getIndexer());\n\n        return new Oak(mk)\n            .with(new InitialContent())\n            .with((QueryIndexProvider) indexer)\n            .with((CommitHook) indexer)\n            .with(new LuceneReindexHook(TEST_INDEX_HOME))\n            .with(new LuceneHook(TEST_INDEX_HOME))\n            .createContentRepository();\n    }","id":49590,"modified_method":"@Override\n    protected ContentRepository createRepository() {\n        // the property and prefix index currently require the index wrapper\n        IndexWrapper mk = new IndexWrapper(new MicroKernelImpl(),\n                \"/\" + INDEX_DEFINITIONS_NAME + \"/indexes\");\n\n        PropertyIndexer indexer = new PropertyIndexer(mk.getIndexer());\n\n        return new Oak(mk)\n            .with(new InitialContent())\n            .with((QueryIndexProvider) indexer)\n            .with((CommitHook) indexer)\n            .createContentRepository();\n    }","commit_id":"620d646b1d80e3b27605cafe7a9548b0fdda72aa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        root = new Oak()\n                .with(new InitialContent())\n                .with(new PropertyIndexHook())\n                .createRoot();\n\n        defaultConfig = new ConfigurationParameters();\n        defaultUserPath = defaultConfig.getConfigValue(UserConstants.PARAM_USER_PATH, UserConstants.DEFAULT_USER_PATH);\n        defaultGroupPath = defaultConfig.getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\n\n        customOptions = new HashMap<String, Object>();\n        customOptions.put(UserConstants.PARAM_GROUP_PATH, customGroupPath);\n        customOptions.put(UserConstants.PARAM_USER_PATH, customUserPath);\n    }","id":49591,"modified_method":"@Before\n    public void setUp() throws Exception {\n        root = new Oak()\n                .with(new InitialContent())\n                .with(new IndexHookManager(new PropertyIndexHookProvider()))\n                .createRoot();\n\n        defaultConfig = new ConfigurationParameters();\n        defaultUserPath = defaultConfig.getConfigValue(UserConstants.PARAM_USER_PATH, UserConstants.DEFAULT_USER_PATH);\n        defaultGroupPath = defaultConfig.getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\n\n        customOptions = new HashMap<String, Object>();\n        customOptions.put(UserConstants.PARAM_GROUP_PATH, customGroupPath);\n        customOptions.put(UserConstants.PARAM_USER_PATH, customUserPath);\n    }","commit_id":"620d646b1d80e3b27605cafe7a9548b0fdda72aa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private int estimateFrameHeight(){\n    // Assuming each tree node height to be 25 pixels\n    return Math.min(20 * (editor.getSketch().getCodeCount() + 1),\n                    frmOutlineView.getHeight());\n//    return Math.min(editor.ta.getHeight(),\n//                    frmOutlineView.getHeight());\n  }","id":49592,"modified_method":"private int estimateFrameHeight(){\n    // Assuming each tree node height to be 20 pixels\n    int t = Math.max(4, editor.getSketch().getCodeCount() + 1);\n    return Math.min(20 * t, frmOutlineView.getHeight());\n  }","commit_id":"1c8c4b37be8356e1959590775ca55ab47955248a","url":"https://github.com/processing/processing"},{"original_method":"@Nullable\n  private Point createToolTipImage(@NotNull KeyType key) {\n    Pair<Component, Rectangle> rendererAndBounds = getCellRendererAndBounds(key);\n    if (rendererAndBounds == null) return null;\n\n    Component renderer = rendererAndBounds.first;\n    if (!(renderer instanceof JComponent)) return null;\n\n    myKeyItemBounds = rendererAndBounds.second;\n    myKeyItemBounds.width = Math.min(myKeyItemBounds.width, myComponent.getToolkit().getScreenSize().width);\n\n    Rectangle cellBounds = myKeyItemBounds;\n    Rectangle visibleRect = getVisibleRect(key);\n\n    int width = cellBounds.x + cellBounds.width - (visibleRect.x + visibleRect.width);\n    int height = cellBounds.height;\n\n    if (width <= 0 || height <= 0) return null;\n    if (cellBounds.y < visibleRect.y) return null;\n    if (cellBounds.y + cellBounds.height > visibleRect.y + visibleRect.height) return null;\n\n    Dimension size = getImageSize(width, height);\n    myImage = UIUtil.createImage(size.width, size.height, BufferedImage.TYPE_INT_RGB);\n\n    Graphics2D g = myImage.createGraphics();\n    g.setClip(null);\n    doFillBackground(height, width, g);\n    g.translate(-(visibleRect.x + visibleRect.width - cellBounds.x), 0);\n    doPaintTooltipImage(renderer, cellBounds, g, key);\n\n    Point location = new Point(visibleRect.x + visibleRect.width, cellBounds.y);\n    CustomLineBorder border = null;\n    if (isPaintBorder()) {\n      border = new CustomLineBorder(getBorderColor(), 1, 0, 1, 1);\n      location.y -= 1;\n      size.width += 1;\n      size.height += 2;\n    }\n\n    g.dispose();\n    myRendererPane.remove(renderer);\n\n    myTipComponent.setBorder(border);\n    myTipComponent.setPreferredSize(size);\n    return location;\n  }","id":49593,"modified_method":"@Nullable\n  private Point createToolTipImage(@NotNull KeyType key) {\n    Pair<Component, Rectangle> rendererAndBounds = getCellRendererAndBounds(key);\n    if (rendererAndBounds == null) return null;\n\n    Component renderer = rendererAndBounds.first;\n    if (!(renderer instanceof JComponent)) return null;\n\n    myKeyItemBounds = rendererAndBounds.second;\n\n    Point toolTipLocationOnScreen = myKeyItemBounds.getLocation();\n    SwingUtilities.convertPointToScreen(toolTipLocationOnScreen, myComponent);\n    int maximumWidth = Math.max(0, myComponent.getToolkit().getScreenSize().width - toolTipLocationOnScreen.x);\n    myKeyItemBounds.width = Math.min(myKeyItemBounds.width, maximumWidth);\n\n    Rectangle cellBounds = myKeyItemBounds;\n    Rectangle visibleRect = getVisibleRect(key);\n\n    int width = cellBounds.x + cellBounds.width - (visibleRect.x + visibleRect.width);\n    int height = cellBounds.height;\n\n    if (width <= 0 || height <= 0) return null;\n    if (cellBounds.y < visibleRect.y) return null;\n    if (cellBounds.y + cellBounds.height > visibleRect.y + visibleRect.height) return null;\n\n    Dimension size = getImageSize(width, height);\n    myImage = UIUtil.createImage(size.width, size.height, BufferedImage.TYPE_INT_RGB);\n\n    Graphics2D g = myImage.createGraphics();\n    g.setClip(null);\n    doFillBackground(height, width, g);\n    g.translate(-(visibleRect.x + visibleRect.width - cellBounds.x), 0);\n    doPaintTooltipImage(renderer, cellBounds, g, key);\n\n    Point location = new Point(visibleRect.x + visibleRect.width, cellBounds.y);\n    CustomLineBorder border = null;\n    if (isPaintBorder()) {\n      border = new CustomLineBorder(getBorderColor(), 1, 0, 1, 1);\n      location.y -= 1;\n      size.width += 1;\n      size.height += 2;\n    }\n\n    g.dispose();\n    myRendererPane.remove(renderer);\n\n    myTipComponent.setBorder(border);\n    myTipComponent.setPreferredSize(size);\n    return location;\n  }","commit_id":"7b46e0b3e37f3167911f8a170929f625e2440e55","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Size getPreferredWindowSize()\n   {\n      Size windowBounds = new Size(Window.getClientWidth(),\n                                   Window.getClientHeight());\n\n      return new Size(Math.min(windowBounds.width - 100, 1200),\n                      windowBounds.height - 25);\n   }","id":49594,"modified_method":"private Size getPreferredWindowSize()\n   {\n      Size windowBounds = new Size(Window.getClientWidth(),\n                                   Window.getClientHeight());\n\n      int availWidth = Math.max(NativeScreen.get().getAvailWidth() - 135,\n                                windowBounds.width - 25); \n      int maxWidth = 1100;\n      int width = Math.min(availWidth, maxWidth);\n      \n      int availHeight = Math.max(NativeScreen.get().getAvailHeight() - 135,\n                                 windowBounds.height - 25);\n      int maxHeight = 1200;\n      int height = Math.min(availHeight, maxHeight);\n      \n      return new Size(width, height);\n   }","commit_id":"ccf1429c2a14193f24da9304698a383108739f3c","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void testAbs() throws Exception\n    {\n        System.out.println(\"STARTING testAbs\");\n        Client client = getClient();\n        initialLoad(client, \"P1\");\n\n        ClientResponse cr = null;\n        VoltTable r = null;\n\n        // The next two queries used to fail due to ENG-3913,\n        // abuse of compound indexes for partial GT filters.\n        // An old issue only brought to light by the addition of a compound index to this suite.\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ABS(ID) > 9\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        assertEquals(5, r.asScalarLong()); // used to get 6, matching like >=\n\n        initialLoad(client, \"R1\");\n\n        cr = client.callProcedure(\"WHERE_ABS\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        assertEquals(5, r.asScalarLong()); // used to get 6, matching like >=\n\n        try {\n            // test decimal support and non-column expressions\n            cr = client.callProcedure(\"WHERE_ABSFF\");\n            assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n            r = cr.getResults()[0];\n            assertEquals(5, r.asScalarLong());\n        } catch (ProcCallException hsqlFailed) {\n            // Give HSQLDB a pass on this query.\n            String msg = hsqlFailed.getMessage();\n            assertTrue(msg.matches(\".*ExpectedProcedureException.*HSQLDB.*\"));\n        }\n\n        // Test type promotions\n        cr = client.callProcedure(\"WHERE_ABSIF\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        assertEquals(5, r.asScalarLong());\n\n        try {\n            cr = client.callProcedure(\"WHERE_ABSFI\");\n            assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n            r = cr.getResults()[0];\n        assertEquals(5, r.asScalarLong());\n        } catch (ProcCallException hsqlFailed) {\n            // Give HSQLDB a pass on this query.\n            String msg = hsqlFailed.getMessage();\n            assertTrue(msg.matches(\".*ExpectedProcedureException.*HSQLDB.*\"));\n        }\n\n\n        // Test application to weakly typed NUMERIC constants\n        try {\n            cr = client.callProcedure(\"WHERE_ABSWEAK\");\n            assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n            r = cr.getResults()[0];\n            assertEquals(5, r.asScalarLong());\n        } catch (ProcCallException hsqlFailed) {\n            // Give HSQLDB a pass on this query.\n            String msg = hsqlFailed.getMessage();\n            assertTrue(msg.matches(\".*ExpectedProcedureException.*HSQLDB.*\"));\n        }\n\n        cr = client.callProcedure(\"DISPLAY_ABS\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        assertEquals(5, r.asScalarLong());\n\n        cr = client.callProcedure(\"ORDER_ABS\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        r.advanceRow();\n        long value = r.getLong(0);\n        assertEquals(5, value);\n/*\n        cr = client.callProcedure(\"GROUP_ABS\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        assertEquals(5, r.asScalarLong());\n*/\n        cr = client.callProcedure(\"AGG_OF_ABS\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        assertEquals(5, r.asScalarLong());\n/*\n        cr = client.callProcedure(\"ABS_OF_AGG\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        assertEquals(5, r.asScalarLong());\n*/\n\n        initialLoad(client, \"R1\");\n\n        initialLoad(client, \"R2\");\n\n        // The next 2 queries failed in 3.4 with a runtime type exception about casting from VARCHAR reported in ENG-5004\n        cr = client.callProcedure(\"@AdHoc\", \"select * from P1, R2 where P1.ID = R2.ID AND ABS(P1.NUM) > 0\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        System.out.println(r);\n        assertEquals(8, r.getRowCount());\n\n        cr = client.callProcedure(\"@AdHoc\", \"select * from P1, R2 where P1.ID = R2.ID AND ABS(P1.NUM+0) > 0\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        System.out.println(r);\n        assertEquals(8, r.getRowCount());\n\n        // These next queries fail in 3.5 with a runtime type exception about unrecognized type related?/similar? to ENG-5004?\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1, R2 where P1.ID = R2.ID AND ABS(R2.NUM+0) > 0\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        System.out.println(r);\n        assertEquals(8, r.asScalarLong());\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1, R2 where P1.ID = R2.ID AND ABS(R2.NUM) > 0\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        System.out.println(r);\n        assertEquals(8, r.asScalarLong());\n        // */\n\n\n        // Test null propagation\n        cr = client.callProcedure(\"INSERT_NULL\", 99);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        cr = client.callProcedure(\"INSERT_NULL\", 98);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        cr = client.callProcedure(\"INSERT_NULL\", 97);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        cr = client.callProcedure(\"INSERT_NULL\", 96);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        cr = client.callProcedure(\"INSERT_NULL\", 95);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n\n        long resultA;\n        long resultB;\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where NUM > 9\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultA = r.asScalarLong();\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ABS(NUM) > 9\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultB = r.asScalarLong();\n        assertEquals(resultA, resultB);\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ABS(0-NUM) > 9\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultB = r.asScalarLong();\n        assertEquals(resultA, resultB);\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where not NUM > 9\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultA = r.asScalarLong();\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where not ABS(0-NUM) > 9\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultB = r.asScalarLong();\n        assertEquals(resultA, resultB);\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where not ABS(NUM) > 9\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultB = r.asScalarLong();\n        assertEquals(resultA, resultB);\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ID = -2 - NUM\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultA = r.asScalarLong();\n\n        // These cases were originally failed attempts to trigger ENG-3191, but they still seem worth trying.\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ABS(ID) = 2 + NUM\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultB = r.asScalarLong();\n        assertEquals(resultA, resultB);\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ABS(NUM) = (2 - ID)\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultB = r.asScalarLong();\n        assertEquals(resultA, resultB);\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ID < 0\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultA = r.asScalarLong();\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ABS(ID) = (0 - ID)\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultB = r.asScalarLong();\n        assertEquals(resultA, resultB);\n\n        // Here's the ENG-3191 case, all better now.\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ID = (0 - ABS(ID))\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultB = r.asScalarLong();\n        assertEquals(resultA, resultB);\n\n        boolean caught = false;\n\n        caught = false;\n        try {\n            cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where not ABS(DESC) > 9\");\n            assertTrue(cr.getStatus() != ClientResponse.SUCCESS);\n        } catch (ProcCallException e) {\n            String msg = e.getMessage();\n            assertTrue(msg.indexOf(\"incompatible data type\") != -1);\n            caught = true;\n        }\n        assertTrue(caught);\n\n        caught = false;\n        try {\n            cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where not ABS(DESC) > 'ABC'\");\n            assertTrue(cr.getStatus() != ClientResponse.SUCCESS);\n        } catch (ProcCallException e) {\n            String msg = e.getMessage();\n            assertTrue(msg.indexOf(\"incompatible data type\") != -1);\n            caught = true;\n        }\n        assertTrue(caught);\n\n        cr = client.callProcedure(\"@AdHoc\", \"insert into R1 values (1, null, null, null, null)\");\n\n        caught = false;\n        try {\n            // This should violate the UNIQUE ABS constraint without violating the primary key constraint.\n            cr = client.callProcedure(\"@AdHoc\", \"insert into R1 values (-1, null, null, null, null)\");\n        } catch (ProcCallException e) {\n            String msg = e.getMessage();\n            assertTrue(msg.indexOf(\"violation of constraint\") != -1);\n            caught = true;\n        }\n        // If the insert succeeds on VoltDB, the constraint failed to trigger.\n        // If the insert fails on HSQL, the test is invalid -- HSQL should not detect the subtle constraint violation we are trying to trigger.\n        assertEquals( ! isHSQL(), caught);\n    }","id":49595,"modified_method":"public void testAbs() throws Exception\n    {\n        System.out.println(\"STARTING testAbs\");\n        Client client = getClient();\n        initialLoad(client, \"P1\");\n\n        ClientResponse cr = null;\n        VoltTable r = null;\n\n        // The next two queries used to fail due to ENG-3913,\n        // abuse of compound indexes for partial GT filters.\n        // An old issue only brought to light by the addition of a compound index to this suite.\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ABS(ID) > 9\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        assertEquals(5, r.asScalarLong()); // used to get 6, matching like >=\n\n        initialLoad(client, \"R1\");\n\n        cr = client.callProcedure(\"WHERE_ABS\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        assertEquals(5, r.asScalarLong()); // used to get 6, matching like >=\n\n        try {\n            // test decimal support and non-column expressions\n            cr = client.callProcedure(\"WHERE_ABSFF\");\n            assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n            r = cr.getResults()[0];\n            assertEquals(5, r.asScalarLong());\n        } catch (ProcCallException hsqlFailed) {\n            // Give HSQLDB a pass on this query.\n            String msg = hsqlFailed.getMessage();\n            assertTrue(msg.matches(\".*ExpectedProcedureException.*HSQLDB.*\"));\n        }\n\n        // Test type promotions\n        cr = client.callProcedure(\"WHERE_ABSIF\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        assertEquals(5, r.asScalarLong());\n\n        try {\n            cr = client.callProcedure(\"WHERE_ABSFI\");\n            assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n            r = cr.getResults()[0];\n        assertEquals(5, r.asScalarLong());\n        } catch (ProcCallException hsqlFailed) {\n            // Give HSQLDB a pass on this query.\n            String msg = hsqlFailed.getMessage();\n            assertTrue(msg.matches(\".*ExpectedProcedureException.*HSQLDB.*\"));\n        }\n\n\n        // Test application to weakly typed NUMERIC constants\n        try {\n            cr = client.callProcedure(\"WHERE_ABSWEAK\");\n            assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n            r = cr.getResults()[0];\n            assertEquals(5, r.asScalarLong());\n        } catch (ProcCallException hsqlFailed) {\n            // Give HSQLDB a pass on this query.\n            String msg = hsqlFailed.getMessage();\n            assertTrue(msg.matches(\".*ExpectedProcedureException.*HSQLDB.*\"));\n        }\n\n        cr = client.callProcedure(\"DISPLAY_ABS\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        assertEquals(5, r.asScalarLong());\n\n        cr = client.callProcedure(\"ORDER_ABS\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        r.advanceRow();\n        long value = r.getLong(0);\n        assertEquals(5, value);\n/*\n        cr = client.callProcedure(\"GROUP_ABS\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        assertEquals(5, r.asScalarLong());\n*/\n        cr = client.callProcedure(\"AGG_OF_ABS\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        assertEquals(5, r.asScalarLong());\n/*\n        cr = client.callProcedure(\"ABS_OF_AGG\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        assertEquals(5, r.asScalarLong());\n*/\n\n        initialLoad(client, \"R1\");\n\n        initialLoad(client, \"R2\");\n\n        // The next 2 queries failed in 3.4 with a runtime type exception about casting from VARCHAR reported in ENG-5004\n        cr = client.callProcedure(\"@AdHoc\", \"select * from P1, R2 where P1.ID = R2.ID AND ABS(P1.NUM) > 0\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        System.out.println(r);\n        assertEquals(8, r.getRowCount());\n\n        cr = client.callProcedure(\"@AdHoc\", \"select * from P1, R2 where P1.ID = R2.ID AND ABS(P1.NUM+0) > 0\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        System.out.println(r);\n        assertEquals(8, r.getRowCount());\n\n        // These next queries fail in 3.5 with a runtime type exception about unrecognized type related?/similar? to ENG-5004?\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1, R2 where P1.ID = R2.ID AND ABS(R2.NUM+0) > 0\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        System.out.println(r);\n        assertEquals(8, r.asScalarLong());\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1, R2 where P1.ID = R2.ID AND ABS(R2.NUM) > 0\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        System.out.println(r);\n        assertEquals(8, r.asScalarLong());\n        // */\n\n\n        // Test null propagation\n        cr = client.callProcedure(\"INSERT_NULL\", 99);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        cr = client.callProcedure(\"INSERT_NULL\", 98);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        cr = client.callProcedure(\"INSERT_NULL\", 97);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        cr = client.callProcedure(\"INSERT_NULL\", 96);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        cr = client.callProcedure(\"INSERT_NULL\", 95);\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n\n        long resultA;\n        long resultB;\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where NUM > 9\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultA = r.asScalarLong();\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ABS(NUM) > 9\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultB = r.asScalarLong();\n        assertEquals(resultA, resultB);\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ABS(0-NUM) > 9\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultB = r.asScalarLong();\n        assertEquals(resultA, resultB);\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where not NUM > 9\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultA = r.asScalarLong();\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where not ABS(0-NUM) > 9\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultB = r.asScalarLong();\n        assertEquals(resultA, resultB);\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where not ABS(NUM) > 9\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultB = r.asScalarLong();\n        assertEquals(resultA, resultB);\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ID = -2 - NUM\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultA = r.asScalarLong();\n\n        // These cases were originally failed attempts to trigger ENG-3191, but they still seem worth trying.\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ABS(ID) = 2 + NUM\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultB = r.asScalarLong();\n        assertEquals(resultA, resultB);\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ABS(NUM) = (2 - ID)\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultB = r.asScalarLong();\n        assertEquals(resultA, resultB);\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ID < 0\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultA = r.asScalarLong();\n\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ABS(ID) = (0 - ID)\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultB = r.asScalarLong();\n        assertEquals(resultA, resultB);\n\n        // Here's the ENG-3191 case, all better now.\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where ID = (0 - ABS(ID))\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        resultB = r.asScalarLong();\n        assertEquals(resultA, resultB);\n\n        // Here's the ENG-3196 case, all better now\n        cr = client.callProcedure(\"@AdHoc\", \"SELECT ABS(ID) AS ENG3196 FROM R1 ORDER BY (ID) LIMIT 5;\");\n        assertEquals(ClientResponse.SUCCESS, cr.getStatus());\n        r = cr.getResults()[0];\n        System.out.println(\"DEBUG ENG-3196: \" + r);\n        long resultCount = r.getRowCount();\n        assertEquals(5, resultCount);\n        r.advanceRow();\n        resultB = r.getLong(0);\n        assertEquals(14, resultB);\n        r.advanceToRow(4);\n        resultB = r.getLong(0);\n        assertEquals(10, resultB);\n\n        boolean caught = false;\n\n        caught = false;\n        try {\n            cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where not ABS(DESC) > 9\");\n            assertTrue(cr.getStatus() != ClientResponse.SUCCESS);\n        } catch (ProcCallException e) {\n            String msg = e.getMessage();\n            assertTrue(msg.indexOf(\"incompatible data type\") != -1);\n            caught = true;\n        }\n        assertTrue(caught);\n\n        caught = false;\n        try {\n            cr = client.callProcedure(\"@AdHoc\", \"select count(*) from P1 where not ABS(DESC) > 'ABC'\");\n            assertTrue(cr.getStatus() != ClientResponse.SUCCESS);\n        } catch (ProcCallException e) {\n            String msg = e.getMessage();\n            assertTrue(msg.indexOf(\"incompatible data type\") != -1);\n            caught = true;\n        }\n        assertTrue(caught);\n\n        cr = client.callProcedure(\"@AdHoc\", \"insert into R1 values (1, null, null, null, null)\");\n\n        caught = false;\n        try {\n            // This should violate the UNIQUE ABS constraint without violating the primary key constraint.\n            cr = client.callProcedure(\"@AdHoc\", \"insert into R1 values (-1, null, null, null, null)\");\n        } catch (ProcCallException e) {\n            String msg = e.getMessage();\n            assertTrue(msg.indexOf(\"violation of constraint\") != -1);\n            caught = true;\n        }\n        // If the insert succeeds on VoltDB, the constraint failed to trigger.\n        // If the insert fails on HSQL, the test is invalid -- HSQL should not detect the subtle constraint violation we are trying to trigger.\n        assertEquals( ! isHSQL(), caught);\n    }","commit_id":"3a877bb58e835c0491a70cd534309d0c57e7747e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testOrderBySingleColumnDescending() throws NoConnectionsException, ProcCallException, IOException, InterruptedException {\n        VoltTable vt;\n        Client client = this.getClient();\n        load(client);\n\n        // sort column of ints descending\n        vt = client.callProcedure(\"@AdHoc\", \"select * from O1 order by A_INT DESC\").getResults()[0];\n        assertTrue(vt.getRowCount() == 20);\n        int it = 19;\n        while (vt.advanceRow()) {\n            Integer key = (Integer) vt.get(0, VoltType.INTEGER);\n            Integer a = (Integer) vt.get(1, VoltType.INTEGER);\n            String b = (String) vt.get(2, VoltType.STRING);\n            String c = (String) vt.get(3, VoltType.STRING);\n\n            int pos = a_int.indexOf(a);   // offset of this value in unsorted data\n\n            assertEquals(it, a.intValue());     // a should be order 1, 2, 3..\n            assertEquals(pos, key.intValue());  // side-effect of insertion method\n            assertEquals(b, a_inline_str.get(pos));\n            assertEquals(c, a_pool_str.get(pos));\n\n            it--;\n        }\n\n        // sort column of inlined strings descending\n        vt = client.callProcedure(\"@AdHoc\", \"select * from O1 order by A_INLINE_STR DESC\").getResults()[0];\n        assertTrue(vt.getRowCount() == 20);\n        String lastString = \"z\";\n        while (vt.advanceRow()) {\n            Integer key = (Integer) vt.get(0, VoltType.INTEGER);\n            Integer a = (Integer) vt.get(1, VoltType.INTEGER);\n            String b = (String) vt.get(2, VoltType.STRING);\n            String c = (String) vt.get(3, VoltType.STRING);\n\n            assertTrue(lastString.compareTo(b) > 0);  // always descending\n            lastString = b;\n\n            int pos = a_inline_str.indexOf(b);   // offset of this value in unsorted data\n            assertEquals(pos, key.intValue());   // side-effect of insertion method\n            assertEquals(a, a_int.get(pos));     // retrieved value matches at index in unsorted data\n            assertEquals(c, a_pool_str.get(pos));\n        }\n\n\n        // sort column of non-inlined strings descending\n        vt = client.callProcedure(\"@AdHoc\", \"select * from O1 order by A_POOL_STR DESC\").getResults()[0];\n        assertTrue(vt.getRowCount() == 20);\n        lastString = bigString + \"99\";\n        while (vt.advanceRow()) {\n            Integer key = (Integer) vt.get(0, VoltType.INTEGER);\n            Integer a = (Integer) vt.get(1, VoltType.INTEGER);\n            String b = (String) vt.get(2, VoltType.STRING);\n            String c = (String) vt.get(3, VoltType.STRING);\n\n            assertTrue(lastString.compareTo(c) > 0);  // always descending\n            lastString = c;\n\n            int pos = a_pool_str.indexOf(c);     // offset of this value in unsorted data\n            assertEquals(pos, key.intValue());   // side-effect of insertion method\n            assertEquals(a, a_int.get(pos));     // retrieved value matches at index in unsorted data\n            assertEquals(b, a_inline_str.get(pos));\n        }\n\n        loadO3(client);\n        Integer lastPk2 = 20;\n        // sort indexed column descending with equality filter on prefix indexed key\n        vt = client.callProcedure(\"@AdHoc\", \"SELECT * FROM O3 WHERE PK1 = 0 ORDER BY PK2 DESC\").getResults()[0];\n        assertTrue(vt.getRowCount() == 20);\n        System.out.println(vt.toString());\n        while(vt.advanceRow()) {\n            assertEquals(0, vt.getLong(0));\n            Integer pk2 = (Integer) vt.get(1, VoltType.INTEGER);\n            assertTrue(lastPk2.compareTo(pk2) > 0);\n            lastPk2 = pk2;\n        }\n        lastPk2 = 20;\n        // desc sort indexed column descending with upper bound filter on prefix indexed key\n        vt = client.callProcedure(\"@AdHoc\", \"SELECT * FROM O3 WHERE PK1 < 1 ORDER BY PK2 DESC\").getResults()[0];\n        assertTrue(vt.getRowCount() == 20);\n        System.out.println(vt.toString());\n        while(vt.advanceRow()) {\n            assertEquals(0, vt.getLong(0));\n            Integer pk2 = (Integer) vt.get(1, VoltType.INTEGER);\n            assertTrue(lastPk2.compareTo(pk2) > 0);\n            lastPk2 = pk2;\n        }\n    }","id":49596,"modified_method":"public void testOrderBySingleColumnDescending() throws NoConnectionsException, ProcCallException, IOException, InterruptedException {\n        VoltTable vt;\n        int it;\n        Client client = this.getClient();\n        load(client);\n\n        // sort column of ints descending\n        vt = client.callProcedure(\"@AdHoc\", \"select * from O1 order by A_INT DESC\").getResults()[0];\n        assertTrue(vt.getRowCount() == 20);\n        it = 19;\n        while (vt.advanceRow()) {\n            Integer key = (Integer) vt.get(0, VoltType.INTEGER);\n            Integer a = (Integer) vt.get(1, VoltType.INTEGER);\n            String b = (String) vt.get(2, VoltType.STRING);\n            String c = (String) vt.get(3, VoltType.STRING);\n\n            int pos = a_int.indexOf(a);   // offset of this value in unsorted data\n\n            assertEquals(it, a.intValue());     // a should be order 1, 2, 3..\n            assertEquals(pos, key.intValue());  // side-effect of insertion method\n            assertEquals(b, a_inline_str.get(pos));\n            assertEquals(c, a_pool_str.get(pos));\n\n            it--;\n        }\n\n        // try that again unperturbed by a silly extra duplicate order by column\n        // -- something very similar used to fail as ENG-631\n        vt = client.callProcedure(\"@AdHoc\",      // order by A_INT DESC, A_INT is just silly\n                                  \"select * from O1 order by A_INT DESC, A_INT\").getResults()[0];\n        assertTrue(vt.getRowCount() == 20);\n        it = 19;\n        while (vt.advanceRow()) {\n            Integer key = (Integer) vt.get(0, VoltType.INTEGER);\n            Integer a = (Integer) vt.get(1, VoltType.INTEGER);\n            String b = (String) vt.get(2, VoltType.STRING);\n            String c = (String) vt.get(3, VoltType.STRING);\n\n            int pos = a_int.indexOf(a);   // offset of this value in unsorted data\n\n            assertEquals(it, a.intValue());     // a should be order 1, 2, 3..\n            assertEquals(pos, key.intValue());  // side-effect of insertion method\n            assertEquals(b, a_inline_str.get(pos));\n            assertEquals(c, a_pool_str.get(pos));\n\n            it--;\n        }\n\n        // sort column of inlined strings descending\n        vt = client.callProcedure(\"@AdHoc\", \"select * from O1 order by A_INLINE_STR DESC\").getResults()[0];\n        assertTrue(vt.getRowCount() == 20);\n        String lastString = \"z\";\n        while (vt.advanceRow()) {\n            Integer key = (Integer) vt.get(0, VoltType.INTEGER);\n            Integer a = (Integer) vt.get(1, VoltType.INTEGER);\n            String b = (String) vt.get(2, VoltType.STRING);\n            String c = (String) vt.get(3, VoltType.STRING);\n\n            assertTrue(lastString.compareTo(b) > 0);  // always descending\n            lastString = b;\n\n            int pos = a_inline_str.indexOf(b);   // offset of this value in unsorted data\n            assertEquals(pos, key.intValue());   // side-effect of insertion method\n            assertEquals(a, a_int.get(pos));     // retrieved value matches at index in unsorted data\n            assertEquals(c, a_pool_str.get(pos));\n        }\n\n        // sort column of non-inlined strings descending\n        vt = client.callProcedure(\"@AdHoc\", \"select * from O1 order by A_POOL_STR DESC\").getResults()[0];\n        assertTrue(vt.getRowCount() == 20);\n        lastString = bigString + \"99\";\n        while (vt.advanceRow()) {\n            Integer key = (Integer) vt.get(0, VoltType.INTEGER);\n            Integer a = (Integer) vt.get(1, VoltType.INTEGER);\n            String b = (String) vt.get(2, VoltType.STRING);\n            String c = (String) vt.get(3, VoltType.STRING);\n\n            assertTrue(lastString.compareTo(c) > 0);  // always descending\n            lastString = c;\n\n            int pos = a_pool_str.indexOf(c);     // offset of this value in unsorted data\n            assertEquals(pos, key.intValue());   // side-effect of insertion method\n            assertEquals(a, a_int.get(pos));     // retrieved value matches at index in unsorted data\n            assertEquals(b, a_inline_str.get(pos));\n        }\n\n        loadO3(client);\n        Integer lastPk2 = 20;\n        // sort indexed column descending with equality filter on prefix indexed key\n        vt = client.callProcedure(\"@AdHoc\", \"SELECT * FROM O3 WHERE PK1 = 0 ORDER BY PK2 DESC\").getResults()[0];\n        assertTrue(vt.getRowCount() == 20);\n        System.out.println(vt.toString());\n        while(vt.advanceRow()) {\n            assertEquals(0, vt.getLong(0));\n            Integer pk2 = (Integer) vt.get(1, VoltType.INTEGER);\n            assertTrue(lastPk2.compareTo(pk2) > 0);\n            lastPk2 = pk2;\n        }\n        lastPk2 = 20;\n        // desc sort indexed column descending with upper bound filter on prefix indexed key\n        vt = client.callProcedure(\"@AdHoc\", \"SELECT * FROM O3 WHERE PK1 < 1 ORDER BY PK2 DESC\").getResults()[0];\n        assertTrue(vt.getRowCount() == 20);\n        System.out.println(vt.toString());\n        while(vt.advanceRow()) {\n            assertEquals(0, vt.getLong(0));\n            Integer pk2 = (Integer) vt.get(1, VoltType.INTEGER);\n            assertTrue(lastPk2.compareTo(pk2) > 0);\n            lastPk2 = pk2;\n        }\n    }","commit_id":"3a877bb58e835c0491a70cd534309d0c57e7747e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testOrderByUseIndex() throws NoConnectionsException,\n                                     ProcCallException,\n                                     IOException, InterruptedException {\n        @SuppressWarnings(\"unused\")\n        long start, elapsed;\n        //long base;\n        VoltTable vt;\n        Client client = this.getClient();\n        if (this.isHSQL())\n            return;\n\n        loadInOrder(client);\n\n        // the duration of doing sequential scan followed by a quicksort\n        // start = System.currentTimeMillis();\n        // vt = client.callProcedure(\"OrderByNonIndex\")[0];\n        // base = System.currentTimeMillis() - start;\n\n        // sort one index column of ints ascending\n        start = System.currentTimeMillis();\n        vt = client.callProcedure(\"OrderByOneIndex\").getResults()[0];\n        elapsed = System.currentTimeMillis() - start;\n        // at least 3 times faster\n        // TODO (nshi): This should really belong to performance tests.\n        // assertTrue(elapsed <= base / 3);\n        assertTrue(vt.getRowCount() == 3);\n        long it = Integer.MAX_VALUE;\n        while (vt.advanceRow()) {\n            int b = (Integer) vt.get(1, VoltType.INTEGER);\n            int c = (Integer) vt.get(2, VoltType.INTEGER);\n            int d = (Integer) vt.get(3, VoltType.INTEGER);\n\n            assertTrue(b == c && c == d && b <= it);\n            it = b;\n        }\n    }","id":49597,"modified_method":"public void testOrderByUseIndex() throws NoConnectionsException,\n                                     ProcCallException,\n                                     IOException, InterruptedException {\n        @SuppressWarnings(\"unused\")\n        long start, elapsed;\n        //long base;\n        VoltTable vt;\n        Client client = this.getClient();\n        if (this.isHSQL())\n            return;\n\n        loadInOrder(client);\n\n        // the duration of doing sequential scan followed by a quicksort\n        // start = System.currentTimeMillis();\n        // vt = client.callProcedure(\"OrderByNonIndex\")[0];\n        // base = System.currentTimeMillis() - start;\n\n        // sort one index column of ints descending.\n        // When testSillyCase goes non-zero, test for non-effect of ENG-631\n        // -- possible confusion caused by \"order by I3 desc, I3\".\n        for (int testSillyCase = 0; testSillyCase < 2; ++testSillyCase) {\n            start = System.currentTimeMillis();\n            vt = client.callProcedure(\"OrderByOneIndex\", testSillyCase).getResults()[0];\n            elapsed = System.currentTimeMillis() - start;\n            // at least 3 times faster\n            // TODO (nshi): This should really belong to performance tests.\n            // assertTrue(elapsed <= base / 3);\n            assertTrue(vt.getRowCount() == 3);\n            long it = Integer.MAX_VALUE;\n            while (vt.advanceRow()) {\n                int b = (Integer) vt.get(1, VoltType.INTEGER);\n                int c = (Integer) vt.get(2, VoltType.INTEGER);\n                int d = (Integer) vt.get(3, VoltType.INTEGER);\n\n                assertTrue(b == c && c == d && b <= it);\n                it = b;\n            }\n        }\n    }","commit_id":"3a877bb58e835c0491a70cd534309d0c57e7747e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * distributed sums of a partitioned table\n     * select sum(F_VAL1), sum(F_VAL2), sum(F_VAL3) from F\n     * @throws InterruptedException\n     */\n    public void testDistributedSum() throws IOException, ProcCallException, InterruptedException {\n        VoltTable vt;\n        Client client = getClient();\n        loadF(client, 0);\n\n        String qs = \"select sum(F_VAL1), sum(F_VAL2), sum(F_VAL3) from F\";\n\n        vt = client.callProcedure(\"@AdHoc\", qs).getResults()[0];\n        System.out.println(\"testDistributedSum result: \" + vt);\n        assertTrue(vt.getRowCount() == 1);\n        while (vt.advanceRow()) {\n            Integer sum1 = (Integer) vt.get(0, VoltType.INTEGER);\n            assertEquals(2000, sum1.intValue());\n            Integer sum2 = (Integer) vt.get(1, VoltType.INTEGER);\n            assertEquals(4995000, sum2.intValue());\n            Integer sum3 = (Integer) vt.get(2, VoltType.INTEGER);\n            assertEquals(500, sum3.intValue());\n        }\n    }","id":49598,"modified_method":"/**\n     * distributed sums of a partitioned table\n     * select sum(F_VAL1), sum(F_VAL2), sum(F_VAL3) from F\n     * @throws InterruptedException\n     */\n    public void testDistributedSum() throws IOException, ProcCallException, InterruptedException {\n        VoltTable vt;\n        Client client = getClient();\n        loadF(client, 0);\n\n        String qs = \"select sum(F_VAL1), sum(F_VAL2), sum(F_VAL3) from F\";\n\n        vt = client.callProcedure(\"@AdHoc\", qs).getResults()[0];\n        System.out.println(\"testDistributedSum result: \" + vt);\n        assertTrue(vt.getRowCount() == 1);\n        vt.advanceRow();\n        Integer sum1 = (Integer) vt.get(0, VoltType.INTEGER);\n        assertEquals(2000, sum1.intValue());\n        Integer sum2 = (Integer) vt.get(1, VoltType.INTEGER);\n        assertEquals(4995000, sum2.intValue());\n        Integer sum3 = (Integer) vt.get(2, VoltType.INTEGER);\n        assertEquals(500, sum3.intValue());\n\n        // Also, regression test ENG-199 -- duplicate aggregation column.\n        vt = client.callProcedure(\"@AdHoc\", \"select sum(F_VAL1), sum(F_VAL1) from F\").getResults()[0];\n        System.out.println(\"testDistributedSum result: \" + vt);\n        assertTrue(vt.getRowCount() == 1);\n        vt.advanceRow();\n        sum1 = (Integer) vt.get(0, VoltType.INTEGER);\n        assertEquals(2000, sum1.intValue());\n        try {\n            sum2 = (Integer) vt.get(1, VoltType.INTEGER);\n            assertEquals(2000, sum2.intValue());\n        } catch ( Exception exc ) {\n            fail(\"Apparently failing like ENG-199 with: \" + exc);\n        }\n    }","commit_id":"3a877bb58e835c0491a70cd534309d0c57e7747e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/** select A1 from T1 group by A1 */\n    public void testSelectAGroubyA() throws IOException, ProcCallException {\n        Client client = this.getClient();\n        VoltTable vt;\n\n        loaderNxN(client, 0);\n\n        vt = client.callProcedure(\"@AdHoc\", \"Select * from T1\").getResults()[0];\n        System.out.println(\"T1-*:\" + vt);\n\n        // execute the query\n        vt = client.callProcedure(\"@AdHoc\", \"SELECT A1 from T1 group by A1\").getResults()[0];\n\n        // one row per unique value of A1\n        System.out.println(\"testSelectAGroubyA: \" + vt);\n        assertTrue(vt.getRowCount() == 11);\n\n        // Selecting A1 - should get values 1 through 11\n        // once each. These results aren't necessarily ordered.\n        int found[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        while (vt.advanceRow()) {\n            Integer A1 = (Integer) vt.get(0, VoltType.INTEGER);\n            assertTrue(A1 <= 11);\n            assertTrue(A1 > 0);\n            found[A1.intValue()] += 1;\n        }\n        assertEquals(0, found[0]);\n        for (int i = 1; i < 12; i++) {\n            assertEquals(1, found[i]);\n        }\n    }","id":49599,"modified_method":"/** select A1 from T1 group by A1 */\n    public void testSelectAGroupbyA() throws IOException, ProcCallException {\n        Client client = this.getClient();\n        VoltTable vt;\n\n        loaderNxN(client, 0);\n\n        vt = client.callProcedure(\"@AdHoc\", \"Select * from T1\").getResults()[0];\n        System.out.println(\"T1-*:\" + vt);\n\n        // execute the query\n        vt = client.callProcedure(\"@AdHoc\", \"SELECT A1 from T1 group by A1\").getResults()[0];\n\n        // one row per unique value of A1\n        System.out.println(\"testSelectAGroubyA: \" + vt);\n        assertTrue(vt.getRowCount() == 11);\n\n        // Selecting A1 - should get values 1 through 11\n        // once each. These results aren't necessarily ordered.\n        int found[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        while (vt.advanceRow()) {\n            Integer A1 = (Integer) vt.get(0, VoltType.INTEGER);\n            assertTrue(A1 <= 11);\n            assertTrue(A1 > 0);\n            found[A1.intValue()] += 1;\n        }\n        assertEquals(0, found[0]);\n        for (int i = 1; i < 12; i++) {\n            assertEquals(1, found[i]);\n        }\n    }","commit_id":"3a877bb58e835c0491a70cd534309d0c57e7747e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/** select B_VAL1 from B group by B_VAL1 */\n    public void testSelectGroubyVarbinary() throws IOException, ProcCallException {\n        Client client = this.getClient();\n        VoltTable vt;\n\n        loaderNxNb(client, 0);\n\n        vt = client.callProcedure(\"@AdHoc\", \"Select * from B\").getResults()[0];\n        System.out.println(\"B-*:\" + vt);\n\n        // execute the query\n        vt = client.callProcedure(\"@AdHoc\", \"SELECT B_VAL1 from B group by B_VAL1\").getResults()[0];\n\n        // one row per unique value of A1\n        System.out.println(\"testSelectGroubyVarbinary: \" + vt);\n        assertTrue(vt.getRowCount() == 11);\n\n        // Selecting B_VAL1 - should get byte values \"1,1,1,1,1,1\" through \"11,11,11,11,11,11\"\n        // once each. These results aren't necessarily ordered.\n        byte found[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        while (vt.advanceRow()) {\n            byte[] b_val1 = vt.getVarbinary(0);\n            assertTrue(b_val1.length == 6);\n            assertTrue(b_val1[0] <= 11);\n            assertTrue(b_val1[5] <= 11);\n            assertTrue(b_val1[0] > 0);\n            assertTrue(b_val1[5] > 0);\n            found[b_val1[0]] += 1;\n        }\n        assertEquals(0, found[0]);\n        for (int i = 1; i < 12; i++) {\n            assertEquals(1, found[i]);\n        }\n    }","id":49600,"modified_method":"/** select B_VAL1 from B group by B_VAL1 */\n    public void testSelectGroupbyVarbinary() throws IOException, ProcCallException {\n        Client client = this.getClient();\n        VoltTable vt;\n\n        loaderNxNb(client, 0);\n\n        vt = client.callProcedure(\"@AdHoc\", \"Select * from B\").getResults()[0];\n        System.out.println(\"B-*:\" + vt);\n\n        // execute the query\n        vt = client.callProcedure(\"@AdHoc\", \"SELECT B_VAL1 from B group by B_VAL1\").getResults()[0];\n\n        // one row per unique value of A1\n        System.out.println(\"testSelectGroubyVarbinary: \" + vt);\n        assertTrue(vt.getRowCount() == 11);\n\n        // Selecting B_VAL1 - should get byte values \"1,1,1,1,1,1\" through \"11,11,11,11,11,11\"\n        // once each. These results aren't necessarily ordered.\n        byte found[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        while (vt.advanceRow()) {\n            byte[] b_val1 = vt.getVarbinary(0);\n            assertTrue(b_val1.length == 6);\n            assertTrue(b_val1[0] <= 11);\n            assertTrue(b_val1[5] <= 11);\n            assertTrue(b_val1[0] > 0);\n            assertTrue(b_val1[5] > 0);\n            found[b_val1[0]] += 1;\n        }\n        assertEquals(0, found[0]);\n        for (int i = 1; i < 12; i++) {\n            assertEquals(1, found[i]);\n        }\n    }","commit_id":"3a877bb58e835c0491a70cd534309d0c57e7747e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"SnapshotDaemon(final SnapshotSchedule schedule) {\n        if (schedule == null) {\n            m_frequencyUnit = null;\n            m_retain = 0;\n            m_frequency = 0;\n            m_frequencyInMillis = 0;\n            m_prefix = null;\n            m_path = null;\n            m_prefixAndSeparator = null;\n        } else {\n            m_frequency = schedule.getFrequencyvalue();\n            m_retain = schedule.getRetain();\n            m_path = schedule.getPath();\n            m_prefix = schedule.getPrefix();\n            m_prefixAndSeparator = m_prefix + \"_\";\n            final String frequencyUnitString = schedule.getFrequencyunit().toLowerCase();\n            assert(frequencyUnitString.length() == 1);\n            final char frequencyUnit = frequencyUnitString.charAt(0);\n\n            switch (frequencyUnit) {\n            case 's':\n                m_frequencyUnit = TimeUnit.SECONDS;\n                break;\n            case 'm':\n                m_frequencyUnit = TimeUnit.MINUTES;\n                break;\n            case 'h':\n                m_frequencyUnit = TimeUnit.HOURS;\n                break;\n                default:\n                    throw new RuntimeException(\"Frequency unit \" + frequencyUnitString + \"\" +\n                            \" in snapshot schedule is not one of d,m,h\");\n            }\n            m_frequencyInMillis = TimeUnit.MILLISECONDS.convert( m_frequency, m_frequencyUnit);\n            m_nextSnapshotTime += m_frequencyInMillis;\n        }\n    }","id":49601,"modified_method":"SnapshotDaemon(final SnapshotSchedule schedule) {\n        if (schedule == null) {\n            m_frequencyUnit = null;\n            m_retain = 0;\n            m_frequency = 0;\n            m_frequencyInMillis = 0;\n            m_prefix = null;\n            m_path = null;\n            m_prefixAndSeparator = null;\n        } else {\n            m_frequency = schedule.getFrequencyvalue();\n            m_retain = schedule.getRetain();\n            m_path = schedule.getPath();\n            m_prefix = schedule.getPrefix();\n            m_prefixAndSeparator = m_prefix + \"_\";\n            final String frequencyUnitString = schedule.getFrequencyunit().toLowerCase();\n            assert(frequencyUnitString.length() == 1);\n            final char frequencyUnit = frequencyUnitString.charAt(0);\n\n            switch (frequencyUnit) {\n            case 's':\n                m_frequencyUnit = TimeUnit.SECONDS;\n                break;\n            case 'm':\n                m_frequencyUnit = TimeUnit.MINUTES;\n                break;\n            case 'h':\n                m_frequencyUnit = TimeUnit.HOURS;\n                break;\n                default:\n                    throw new RuntimeException(\"Frequency unit \" + frequencyUnitString + \"\" +\n                            \" in snapshot schedule is not one of d,m,h\");\n            }\n            m_frequencyInMillis = TimeUnit.MILLISECONDS.convert( m_frequency, m_frequencyUnit);\n            m_nextSnapshotTime += m_frequencyInMillis;\n        }\n\n        // Register the snapshot status to the StatsAgent\n        SnapshotStatus snapshotStatus = new SnapshotStatus(\"Snapshot Status\");\n        VoltDB.instance().getStatsAgent().registerStatsSource(SysProcSelector.SNAPSHOTSTATUS,\n                                                              0,\n                                                              snapshotStatus);\n    }","commit_id":"92555f7fe4d38992d60c5d5cae73cb5b369ec08c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private final List<File> retrieveRelevantFiles(File f, final String nonce) {\n        assert(f.isDirectory());\n        assert(f.canRead());\n        assert(f.canWrite());\n        final String digestName = nonce.substring(0, nonce.lastIndexOf('-')) + \".digest\";\n        return java.util.Arrays.asList(f.listFiles(new FileFilter() {\n\n            @Override\n            public boolean accept(File pathname) {\n                if (pathname.isDirectory()) {\n                    return false;\n                }\n\n                if (!pathname.getName().endsWith(\".vpt\") && !pathname.getName().endsWith(\".digest\")) {\n                    return false;\n                }\n\n                if (pathname.getName().startsWith(nonce) || pathname.getName().equals(digestName)) {\n                    return true;\n                }\n                return false;\n            }\n        }));\n    }","id":49602,"modified_method":"private final List<File> retrieveRelevantFiles(File f, final String nonce) {\n        assert(f.isDirectory());\n        assert(f.canRead());\n        assert(f.canWrite());\n        final String digestName =\n            SnapshotUtil.constructDigestFilenameForNonce(nonce.substring(0, nonce.lastIndexOf('-')));\n        return java.util.Arrays.asList(f.listFiles(new FileFilter() {\n\n            @Override\n            public boolean accept(File pathname) {\n                if (pathname.isDirectory()) {\n                    return false;\n                }\n\n                if (!pathname.getName().endsWith(\".vpt\") && !pathname.getName().endsWith(\".digest\")) {\n                    return false;\n                }\n\n                if (pathname.getName().startsWith(nonce) || pathname.getName().equals(digestName)) {\n                    return true;\n                }\n                return false;\n            }\n        }));\n    }","commit_id":"92555f7fe4d38992d60c5d5cae73cb5b369ec08c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private Table(String name, long timeCreated) {\n                this.name = name;\n                this.timeCreated = timeCreated;\n                size = 0;\n                timeClosed = 0;\n                error = null;\n            }","id":49603,"modified_method":"private Table(String name, String filename, long timeCreated) {\n                this.name = name;\n                this.filename = filename;\n                this.timeCreated = timeCreated;\n                size = 0;\n                timeClosed = 0;\n                error = null;\n            }","commit_id":"92555f7fe4d38992d60c5d5cae73cb5b369ec08c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public Table(Table t, long size, long timeClosed, Exception error) {\n                this.name = t.name;\n                this.size = size;\n                this.timeClosed = timeClosed;\n                this.timeCreated = t.timeCreated;\n                this.error = error;\n            }","id":49604,"modified_method":"public Table(Table t, long size, long timeClosed, Exception error) {\n                this.name = t.name;\n                this.filename = t.filename;\n                this.size = size;\n                this.timeClosed = timeClosed;\n                this.timeCreated = t.timeCreated;\n                this.error = error;\n            }","commit_id":"92555f7fe4d38992d60c5d5cae73cb5b369ec08c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static synchronized Snapshot startSnapshot(long startTime, String path, String nonce, String tables[]) {\n        final Snapshot s = new Snapshot(startTime, path, nonce, tables);\n\n        m_snapshots.add(s);\n        if (m_snapshots.size() > m_maxStatusHistory) {\n            Iterator<Snapshot> iter = m_snapshots.iterator();\n            iter.next();\n            iter.remove();\n        }\n\n        return s;\n    }","id":49605,"modified_method":"public static synchronized Snapshot startSnapshot(long startTime, int hostId, String path, String nonce, org.voltdb.catalog.Table tables[]) {\n        final Snapshot s = new Snapshot(startTime, hostId, path, nonce, tables);\n\n        m_snapshots.add(s);\n        if (m_snapshots.size() > m_maxStatusHistory) {\n            Iterator<Snapshot> iter = m_snapshots.iterator();\n            iter.next();\n            iter.remove();\n        }\n\n        return s;\n    }","commit_id":"92555f7fe4d38992d60c5d5cae73cb5b369ec08c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private final File constructFileForTable(Table table,\n                                             String filePath,\n                                             String fileNonce,\n                                             String hostId)\n    {\n        StringBuilder filename_builder = new StringBuilder(fileNonce);\n        filename_builder.append(\"-\");\n        filename_builder.append(table.getTypeName());\n        if (!table.getIsreplicated())\n        {\n            filename_builder.append(\"-host_\");\n            filename_builder.append(hostId);\n        }\n        filename_builder.append(\".vpt\");//Volt partitioned table\n        return new File(filePath, new String(filename_builder));\n    }","id":49606,"modified_method":"private final File constructFileForTable(Table table,\n                                             String filePath,\n                                             String fileNonce,\n                                             String hostId)\n    {\n        return new File(filePath, SnapshotUtil.constructFilenameForTable(table, fileNonce, hostId));\n    }","commit_id":"92555f7fe4d38992d60c5d5cae73cb5b369ec08c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public DependencyPair\n    executePlanFragment(HashMap<Integer, List<VoltTable>> dependencies, long fragmentId, ParameterSet params,\n                        SystemProcedureExecutionContext context)\n    {\n        String hostname = ConnectionUtil.getHostnameOrAddress();\n        if (fragmentId == SysProcFragmentId.PF_saveTest)\n        {\n            assert(params.toArray()[0] != null);\n            assert(params.toArray()[1] != null);\n            String file_path = (String) params.toArray()[0];\n            String file_nonce = (String) params.toArray()[1];\n            VoltTable result = constructNodeResultsTable();\n            // Choose the lowest site ID on this host to do the file scan\n            // All other sites should just return empty results tables.\n            int host_id = context.getExecutionSite().getCorrespondingHostId();\n            Integer lowest_site_id =\n                VoltDB.instance().getCatalogContext().siteTracker.\n                getLowestLiveExecSiteIdForHost(host_id);\n            if (context.getExecutionSite().getSiteId() == lowest_site_id)\n            {\n                TRACE_LOG.trace(\"Checking feasibility of save with path and nonce: \"\n                                + file_path + \", \" + file_nonce);\n\n                if (SnapshotSiteProcessor.ExecutionSitesCurrentlySnapshotting.get() != -1) {\n                    result.addRow(\n                                  Integer.parseInt(context.getSite().getHost().getTypeName()),\n                                  hostname,\n                                  \"\",\n                                  \"FAILURE\",\n                    \"SNAPSHOT IN PROGRESS\");\n                    return new DependencyPair( DEP_saveTest, result);\n                }\n\n                for (Table table : getTablesToSave(context))\n                {\n                    File saveFilePath =\n                        constructFileForTable(table, file_path, file_nonce,\n                                              context.getSite().getHost().getTypeName());\n                    TRACE_LOG.trace(\"Host ID \" + context.getSite().getHost().getTypeName() +\n                                    \" table: \" + table.getTypeName() +\n                                    \" to path: \" + saveFilePath);\n                    String file_valid = \"SUCCESS\";\n                    String err_msg = \"\";\n                    if (saveFilePath.exists())\n                    {\n                        file_valid = \"FAILURE\";\n                        err_msg = \"SAVE FILE ALREADY EXISTS: \" + saveFilePath;\n                    }\n                    else if (!saveFilePath.getParentFile().canWrite())\n                    {\n                        file_valid = \"FAILURE\";\n                        err_msg = \"FILE LOCATION UNWRITABLE: \" + saveFilePath;\n                    }\n                    else\n                    {\n                        try\n                        {\n                            saveFilePath.createNewFile();\n                        }\n                        catch (IOException ex)\n                        {\n                            file_valid = \"FAILURE\";\n                            err_msg = \"FILE CREATION OF \" + saveFilePath +\n                            \"RESULTED IN IOException: \" + ex.getMessage();\n                        }\n                    }\n                    result.addRow(Integer.parseInt(context.getSite().getHost().getTypeName()),\n                                  hostname,\n                                  table.getTypeName(),\n                                  file_valid,\n                                  err_msg);\n                }\n            }\n            return new DependencyPair(DEP_saveTest, result);\n        }\n        else if (fragmentId == SysProcFragmentId.PF_saveTestResults)\n        {\n            TRACE_LOG.trace(\"Aggregating save feasiblity results\");\n            assert (dependencies.size() > 0);\n            List<VoltTable> dep = dependencies.get(DEP_saveTest);\n            VoltTable result = constructNodeResultsTable();\n            for (VoltTable table : dep)\n            {\n                while (table.advanceRow())\n                {\n                    // this will add the active row of table\n                    result.add(table);\n                }\n            }\n            return new\n                DependencyPair( DEP_saveTestResults, result);\n        } else if (fragmentId == SysProcFragmentId.PF_createSnapshotTargets) {\n            TRACE_LOG.trace(\"Creating snapshot target and handing to EEs\");\n            assert(params.toArray()[0] != null);\n            assert(params.toArray()[1] != null);\n            assert(params.toArray()[2] != null);\n            assert(params.toArray()[3] != null);\n            final String file_path = (String) params.toArray()[0];\n            final String file_nonce = (String) params.toArray()[1];\n            byte block = (Byte)params.toArray()[3];\n            final VoltTable result = constructNodeResultsTable();\n            boolean willDoSetup = m_snapshotCreateSetupPermit.tryAcquire();\n            final int numLocalSites = VoltDB.instance().getLocalSites().values().size();\n            if (willDoSetup) {\n                try {\n                    assert(SnapshotSiteProcessor.ExecutionSitesCurrentlySnapshotting.get() == -1);\n                    final long startTime = (Long)params.toArray()[2];\n                    final ArrayDeque<SnapshotTableTask> partitionedSnapshotTasks =\n                        new ArrayDeque<SnapshotTableTask>();\n                    final ArrayList<SnapshotTableTask> replicatedSnapshotTasks =\n                        new ArrayList<SnapshotTableTask>();\n\n                    final ArrayList<String> tableNames = new ArrayList<String>();\n                    for (final Table table : getTablesToSave(context))\n                    {\n                        tableNames.add(table.getTypeName());\n                    }\n                    SnapshotUtil.recordSnapshotTableList(\n                            startTime,\n                            file_path,\n                            file_nonce,\n                            tableNames);\n                    final AtomicInteger numTables = new AtomicInteger(tableNames.size());\n                    final SnapshotRegistry.Snapshot snapshotRecord =\n                        SnapshotRegistry.startSnapshot(\n                                startTime,\n                                file_path,\n                                file_nonce,\n                                tableNames.toArray(new String[0]));\n                    for (final Table table : getTablesToSave(context))\n                    {\n                        String canSnapshot = \"SUCCESS\";\n                        String err_msg = \"\";\n                        final File saveFilePath =\n                            constructFileForTable(table, file_path, file_nonce,\n                                                  context.getSite().getHost().getTypeName());\n                        try {\n                            final SnapshotDataTarget sdt =\n                                constructSnapshotDataTargetForTable(\n                                        context,\n                                        saveFilePath,\n                                        table,\n                                        context.getSite().getHost(),\n                                        context.getCluster().getPartitions().size(),\n                                        startTime);\n\n                            final Runnable onClose = new Runnable() {\n                                @Override\n                                public void run() {\n                                    final long now = System.currentTimeMillis();\n                                    snapshotRecord.updateTable(table.getTypeName(),\n                                            new SnapshotRegistry.Snapshot.TableUpdater() {\n                                        @Override\n                                        public SnapshotRegistry.Snapshot.Table update(\n                                                SnapshotRegistry.Snapshot.Table registryTable) {\n                                            return snapshotRecord.new Table(\n                                                    registryTable,\n                                                    sdt.getBytesWritten(),\n                                                    now,\n                                                    sdt.getLastWriteException());\n                                        }\n                                    });\n                                    int tablesLeft = numTables.decrementAndGet();\n                                    if (tablesLeft == 0) {\n                                        final SnapshotRegistry.Snapshot completed =\n                                            SnapshotRegistry.finishSnapshot(snapshotRecord);\n                                        final double duration =\n                                            (completed.timeFinished - completed.timeStarted) / 1000.0;\n                                        HOST_LOG.info(\n                                                \"Snapshot \" + snapshotRecord.nonce + \" finished at \" +\n                                                 completed.timeFinished + \" and took \" + duration\n                                                 + \" seconds \");\n                                    }\n                                }\n                            };\n\n                            sdt.setOnCloseHandler(onClose);\n\n                            final SnapshotTableTask task =\n                                new SnapshotTableTask(\n                                        table.getRelativeIndex(),\n                                        sdt,\n                                        table.getIsreplicated(),\n                                        table.getTypeName());\n\n                            if (table.getIsreplicated()) {\n                                replicatedSnapshotTasks.add(task);\n                            } else {\n                                partitionedSnapshotTasks.offer(task);\n                            }\n                        } catch (IOException ex) {\n                            canSnapshot = \"FAILURE\";\n                            err_msg = \"SNAPSHOT INITIATION OF \" + saveFilePath +\n                            \"RESULTED IN IOException: \" + ex.getMessage();\n                        }\n\n                        result.addRow(Integer.parseInt(context.getSite().getHost().getTypeName()),\n                                hostname,\n                                table.getTypeName(),\n                                canSnapshot,\n                                err_msg);\n                    }\n\n                    synchronized (m_taskListsForSites) {\n                        if (!partitionedSnapshotTasks.isEmpty() || !replicatedSnapshotTasks.isEmpty()) {\n                            SnapshotSiteProcessor.ExecutionSitesCurrentlySnapshotting.set(\n                                    VoltDB.instance().getLocalSites().values().size());\n                        } else {\n                            SnapshotRegistry.discardSnapshot(snapshotRecord);\n                        }\n\n                        /**\n                         * Distribute the writing of replicated tables to exactly one partition.\n                         */\n                        for (int ii = 0; ii < numLocalSites && !partitionedSnapshotTasks.isEmpty(); ii++) {\n                            m_taskListsForSites.add(new ArrayDeque<SnapshotTableTask>(partitionedSnapshotTasks));\n                        }\n\n                        int siteIndex = 0;\n                        for (SnapshotTableTask t : replicatedSnapshotTasks) {\n                            m_taskListsForSites.get(siteIndex++ % numLocalSites).offer(t);\n                        }\n                    }\n                } catch (Exception ex) {\n                    result.addRow(\n                            Integer.parseInt(context.getSite().getHost().getTypeName()),\n                            hostname,\n                            \"\",\n                            \"FAILURE\",\n                            \"SNAPSHOT INITIATION OF \" + file_path + file_nonce +\n                            \"RESULTED IN Exception: \" + ex.getMessage());\n                    HOST_LOG.error(ex);\n                } finally {\n                    m_snapshotPermits.release(numLocalSites);\n                }\n            }\n\n            try {\n                m_snapshotPermits.acquire();\n            } catch (Exception e) {\n                result.addRow(Integer.parseInt(context.getSite().getHost().getTypeName()),\n                        hostname,\n                        \"\",\n                        \"FAILURE\",\n                        e.toString());\n                return new DependencyPair( DEP_createSnapshotTargets, result);\n            } finally {\n                /*\n                 * The last thead to acquire a snapshot permit has to be the one\n                 * to release the setup permit to ensure that a thread\n                 * doesn't come late and think it is supposed to do the setup work\n                 */\n                synchronized (m_snapshotPermits) {\n                    if (m_snapshotPermits.availablePermits() == 0 &&\n                            m_snapshotCreateSetupPermit.availablePermits() == 0) {\n                        m_snapshotCreateSetupPermit.release();\n                    }\n                }\n            }\n\n            synchronized (m_taskListsForSites) {\n                final Deque<SnapshotTableTask> m_taskList = m_taskListsForSites.poll();\n                if (m_taskList == null) {\n                    return new DependencyPair( DEP_createSnapshotTargets, result);\n                } else {\n                    if (m_taskListsForSites.isEmpty()) {\n                        assert(m_snapshotCreateSetupPermit.availablePermits() == 1);\n                        assert(m_snapshotPermits.availablePermits() == 0);\n                    }\n                    assert(SnapshotSiteProcessor.ExecutionSitesCurrentlySnapshotting.get() > 0);\n                    context.getExecutionSite().initiateSnapshots(m_taskList);\n                }\n            }\n\n            if (block != 0) {\n                HashSet<Exception> failures = null;\n                String status = \"SUCCESS\";\n                String err = \"\";\n                try {\n                    failures = context.getExecutionSite().completeSnapshotWork();\n                } catch (InterruptedException e) {\n                    status = \"FAILURE\";\n                    err = e.toString();\n                }\n                final VoltTable blockingResult = constructPartitionResultsTable();\n\n                if (failures.isEmpty()) {\n                    blockingResult.addRow(\n                            Integer.parseInt(context.getSite().getHost().getTypeName()),\n                            hostname,\n                            Integer.parseInt(context.getSite().getTypeName()),\n                            status,\n                            err);\n                } else {\n                    status = \"FAILURE\";\n                    for (Exception e : failures) {\n                        err = e.toString();\n                    }\n                    blockingResult.addRow(\n                            Integer.parseInt(context.getSite().getHost().getTypeName()),\n                            hostname,\n                            Integer.parseInt(context.getSite().getTypeName()),\n                            status,\n                            err);\n                }\n                return new DependencyPair( DEP_createSnapshotTargets, blockingResult);\n            }\n\n            return new DependencyPair( DEP_createSnapshotTargets, result);\n        } else if (fragmentId == SysProcFragmentId.PF_createSnapshotTargetsResults)\n        {\n            TRACE_LOG.trace(\"Aggregating create snapshot target results\");\n            assert (dependencies.size() > 0);\n            List<VoltTable> dep = dependencies.get(DEP_createSnapshotTargets);\n            VoltTable result = null;\n            for (VoltTable table : dep)\n            {\n                /**\n                 * XXX Ning: There are two different tables here. We have to\n                 * detect which table we are looking at in order to create the\n                 * result table with the proper schema. Maybe we should make the\n                 * result table consistent?\n                 */\n                if (result == null) {\n                    if (table.getColumnType(2).equals(VoltType.INTEGER))\n                        result = constructPartitionResultsTable();\n                    else\n                        result = constructNodeResultsTable();\n                }\n\n                while (table.advanceRow())\n                {\n                    // this will add the active row of table\n                    result.add(table);\n                }\n            }\n            return new\n                DependencyPair( DEP_createSnapshotTargetsResults, result);\n        }\n        assert (false);\n        return null;\n    }","id":49607,"modified_method":"@Override\n    public DependencyPair\n    executePlanFragment(HashMap<Integer, List<VoltTable>> dependencies, long fragmentId, ParameterSet params,\n                        SystemProcedureExecutionContext context)\n    {\n        String hostname = ConnectionUtil.getHostnameOrAddress();\n        if (fragmentId == SysProcFragmentId.PF_saveTest)\n        {\n            assert(params.toArray()[0] != null);\n            assert(params.toArray()[1] != null);\n            String file_path = (String) params.toArray()[0];\n            String file_nonce = (String) params.toArray()[1];\n            VoltTable result = constructNodeResultsTable();\n            // Choose the lowest site ID on this host to do the file scan\n            // All other sites should just return empty results tables.\n            int host_id = context.getExecutionSite().getCorrespondingHostId();\n            Integer lowest_site_id =\n                VoltDB.instance().getCatalogContext().siteTracker.\n                getLowestLiveExecSiteIdForHost(host_id);\n            if (context.getExecutionSite().getSiteId() == lowest_site_id)\n            {\n                TRACE_LOG.trace(\"Checking feasibility of save with path and nonce: \"\n                                + file_path + \", \" + file_nonce);\n\n                if (SnapshotSiteProcessor.ExecutionSitesCurrentlySnapshotting.get() != -1) {\n                    result.addRow(\n                                  Integer.parseInt(context.getSite().getHost().getTypeName()),\n                                  hostname,\n                                  \"\",\n                                  \"FAILURE\",\n                    \"SNAPSHOT IN PROGRESS\");\n                    return new DependencyPair( DEP_saveTest, result);\n                }\n\n                for (Table table : getTablesToSave(context))\n                {\n                    File saveFilePath =\n                        constructFileForTable(table, file_path, file_nonce,\n                                              context.getSite().getHost().getTypeName());\n                    TRACE_LOG.trace(\"Host ID \" + context.getSite().getHost().getTypeName() +\n                                    \" table: \" + table.getTypeName() +\n                                    \" to path: \" + saveFilePath);\n                    String file_valid = \"SUCCESS\";\n                    String err_msg = \"\";\n                    if (saveFilePath.exists())\n                    {\n                        file_valid = \"FAILURE\";\n                        err_msg = \"SAVE FILE ALREADY EXISTS: \" + saveFilePath;\n                    }\n                    else if (!saveFilePath.getParentFile().canWrite())\n                    {\n                        file_valid = \"FAILURE\";\n                        err_msg = \"FILE LOCATION UNWRITABLE: \" + saveFilePath;\n                    }\n                    else\n                    {\n                        try\n                        {\n                            saveFilePath.createNewFile();\n                        }\n                        catch (IOException ex)\n                        {\n                            file_valid = \"FAILURE\";\n                            err_msg = \"FILE CREATION OF \" + saveFilePath +\n                            \"RESULTED IN IOException: \" + ex.getMessage();\n                        }\n                    }\n                    result.addRow(Integer.parseInt(context.getSite().getHost().getTypeName()),\n                                  hostname,\n                                  table.getTypeName(),\n                                  file_valid,\n                                  err_msg);\n                }\n            }\n            return new DependencyPair(DEP_saveTest, result);\n        }\n        else if (fragmentId == SysProcFragmentId.PF_saveTestResults)\n        {\n            TRACE_LOG.trace(\"Aggregating save feasiblity results\");\n            assert (dependencies.size() > 0);\n            List<VoltTable> dep = dependencies.get(DEP_saveTest);\n            VoltTable result = constructNodeResultsTable();\n            for (VoltTable table : dep)\n            {\n                while (table.advanceRow())\n                {\n                    // this will add the active row of table\n                    result.add(table);\n                }\n            }\n            return new\n                DependencyPair( DEP_saveTestResults, result);\n        } else if (fragmentId == SysProcFragmentId.PF_createSnapshotTargets) {\n            TRACE_LOG.trace(\"Creating snapshot target and handing to EEs\");\n            assert(params.toArray()[0] != null);\n            assert(params.toArray()[1] != null);\n            assert(params.toArray()[2] != null);\n            assert(params.toArray()[3] != null);\n            final String file_path = (String) params.toArray()[0];\n            final String file_nonce = (String) params.toArray()[1];\n            byte block = (Byte)params.toArray()[3];\n            final VoltTable result = constructNodeResultsTable();\n            boolean willDoSetup = m_snapshotCreateSetupPermit.tryAcquire();\n            final int numLocalSites = VoltDB.instance().getLocalSites().values().size();\n            if (willDoSetup) {\n                try {\n                    assert(SnapshotSiteProcessor.ExecutionSitesCurrentlySnapshotting.get() == -1);\n                    final long startTime = (Long)params.toArray()[2];\n                    final ArrayDeque<SnapshotTableTask> partitionedSnapshotTasks =\n                        new ArrayDeque<SnapshotTableTask>();\n                    final ArrayList<SnapshotTableTask> replicatedSnapshotTasks =\n                        new ArrayList<SnapshotTableTask>();\n\n                    final List<Table> tables = getTablesToSave(context);\n                    SnapshotUtil.recordSnapshotTableList(\n                            startTime,\n                            file_path,\n                            file_nonce,\n                            tables);\n                    final AtomicInteger numTables = new AtomicInteger(tables.size());\n                    final SnapshotRegistry.Snapshot snapshotRecord =\n                        SnapshotRegistry.startSnapshot(\n                                startTime,\n                                context.getExecutionSite().getCorrespondingHostId(),\n                                file_path,\n                                file_nonce,\n                                tables.toArray(new Table[0]));\n                    for (final Table table : getTablesToSave(context))\n                    {\n                        String canSnapshot = \"SUCCESS\";\n                        String err_msg = \"\";\n                        final File saveFilePath =\n                            constructFileForTable(table, file_path, file_nonce,\n                                                  context.getSite().getHost().getTypeName());\n                        try {\n                            final SnapshotDataTarget sdt =\n                                constructSnapshotDataTargetForTable(\n                                        context,\n                                        saveFilePath,\n                                        table,\n                                        context.getSite().getHost(),\n                                        context.getCluster().getPartitions().size(),\n                                        startTime);\n\n                            final Runnable onClose = new Runnable() {\n                                @Override\n                                public void run() {\n                                    final long now = System.currentTimeMillis();\n                                    snapshotRecord.updateTable(table.getTypeName(),\n                                            new SnapshotRegistry.Snapshot.TableUpdater() {\n                                        @Override\n                                        public SnapshotRegistry.Snapshot.Table update(\n                                                SnapshotRegistry.Snapshot.Table registryTable) {\n                                            return snapshotRecord.new Table(\n                                                    registryTable,\n                                                    sdt.getBytesWritten(),\n                                                    now,\n                                                    sdt.getLastWriteException());\n                                        }\n                                    });\n                                    int tablesLeft = numTables.decrementAndGet();\n                                    if (tablesLeft == 0) {\n                                        final SnapshotRegistry.Snapshot completed =\n                                            SnapshotRegistry.finishSnapshot(snapshotRecord);\n                                        final double duration =\n                                            (completed.timeFinished - completed.timeStarted) / 1000.0;\n                                        HOST_LOG.info(\n                                                \"Snapshot \" + snapshotRecord.nonce + \" finished at \" +\n                                                 completed.timeFinished + \" and took \" + duration\n                                                 + \" seconds \");\n                                    }\n                                }\n                            };\n\n                            sdt.setOnCloseHandler(onClose);\n\n                            final SnapshotTableTask task =\n                                new SnapshotTableTask(\n                                        table.getRelativeIndex(),\n                                        sdt,\n                                        table.getIsreplicated(),\n                                        table.getTypeName());\n\n                            if (table.getIsreplicated()) {\n                                replicatedSnapshotTasks.add(task);\n                            } else {\n                                partitionedSnapshotTasks.offer(task);\n                            }\n                        } catch (IOException ex) {\n                            canSnapshot = \"FAILURE\";\n                            err_msg = \"SNAPSHOT INITIATION OF \" + saveFilePath +\n                            \"RESULTED IN IOException: \" + ex.getMessage();\n                        }\n\n                        result.addRow(Integer.parseInt(context.getSite().getHost().getTypeName()),\n                                hostname,\n                                table.getTypeName(),\n                                canSnapshot,\n                                err_msg);\n                    }\n\n                    synchronized (m_taskListsForSites) {\n                        if (!partitionedSnapshotTasks.isEmpty() || !replicatedSnapshotTasks.isEmpty()) {\n                            SnapshotSiteProcessor.ExecutionSitesCurrentlySnapshotting.set(\n                                    VoltDB.instance().getLocalSites().values().size());\n                        } else {\n                            SnapshotRegistry.discardSnapshot(snapshotRecord);\n                        }\n\n                        /**\n                         * Distribute the writing of replicated tables to exactly one partition.\n                         */\n                        for (int ii = 0; ii < numLocalSites && !partitionedSnapshotTasks.isEmpty(); ii++) {\n                            m_taskListsForSites.add(new ArrayDeque<SnapshotTableTask>(partitionedSnapshotTasks));\n                        }\n\n                        int siteIndex = 0;\n                        for (SnapshotTableTask t : replicatedSnapshotTasks) {\n                            m_taskListsForSites.get(siteIndex++ % numLocalSites).offer(t);\n                        }\n                    }\n                } catch (Exception ex) {\n                    result.addRow(\n                            Integer.parseInt(context.getSite().getHost().getTypeName()),\n                            hostname,\n                            \"\",\n                            \"FAILURE\",\n                            \"SNAPSHOT INITIATION OF \" + file_path + file_nonce +\n                            \"RESULTED IN Exception: \" + ex.getMessage());\n                    HOST_LOG.error(ex);\n                } finally {\n                    m_snapshotPermits.release(numLocalSites);\n                }\n            }\n\n            try {\n                m_snapshotPermits.acquire();\n            } catch (Exception e) {\n                result.addRow(Integer.parseInt(context.getSite().getHost().getTypeName()),\n                        hostname,\n                        \"\",\n                        \"FAILURE\",\n                        e.toString());\n                return new DependencyPair( DEP_createSnapshotTargets, result);\n            } finally {\n                /*\n                 * The last thead to acquire a snapshot permit has to be the one\n                 * to release the setup permit to ensure that a thread\n                 * doesn't come late and think it is supposed to do the setup work\n                 */\n                synchronized (m_snapshotPermits) {\n                    if (m_snapshotPermits.availablePermits() == 0 &&\n                            m_snapshotCreateSetupPermit.availablePermits() == 0) {\n                        m_snapshotCreateSetupPermit.release();\n                    }\n                }\n            }\n\n            synchronized (m_taskListsForSites) {\n                final Deque<SnapshotTableTask> m_taskList = m_taskListsForSites.poll();\n                if (m_taskList == null) {\n                    return new DependencyPair( DEP_createSnapshotTargets, result);\n                } else {\n                    if (m_taskListsForSites.isEmpty()) {\n                        assert(m_snapshotCreateSetupPermit.availablePermits() == 1);\n                        assert(m_snapshotPermits.availablePermits() == 0);\n                    }\n                    assert(SnapshotSiteProcessor.ExecutionSitesCurrentlySnapshotting.get() > 0);\n                    context.getExecutionSite().initiateSnapshots(m_taskList);\n                }\n            }\n\n            if (block != 0) {\n                HashSet<Exception> failures = null;\n                String status = \"SUCCESS\";\n                String err = \"\";\n                try {\n                    failures = context.getExecutionSite().completeSnapshotWork();\n                } catch (InterruptedException e) {\n                    status = \"FAILURE\";\n                    err = e.toString();\n                }\n                final VoltTable blockingResult = constructPartitionResultsTable();\n\n                if (failures.isEmpty()) {\n                    blockingResult.addRow(\n                            Integer.parseInt(context.getSite().getHost().getTypeName()),\n                            hostname,\n                            Integer.parseInt(context.getSite().getTypeName()),\n                            status,\n                            err);\n                } else {\n                    status = \"FAILURE\";\n                    for (Exception e : failures) {\n                        err = e.toString();\n                    }\n                    blockingResult.addRow(\n                            Integer.parseInt(context.getSite().getHost().getTypeName()),\n                            hostname,\n                            Integer.parseInt(context.getSite().getTypeName()),\n                            status,\n                            err);\n                }\n                return new DependencyPair( DEP_createSnapshotTargets, blockingResult);\n            }\n\n            return new DependencyPair( DEP_createSnapshotTargets, result);\n        } else if (fragmentId == SysProcFragmentId.PF_createSnapshotTargetsResults)\n        {\n            TRACE_LOG.trace(\"Aggregating create snapshot target results\");\n            assert (dependencies.size() > 0);\n            List<VoltTable> dep = dependencies.get(DEP_createSnapshotTargets);\n            VoltTable result = null;\n            for (VoltTable table : dep)\n            {\n                /**\n                 * XXX Ning: There are two different tables here. We have to\n                 * detect which table we are looking at in order to create the\n                 * result table with the proper schema. Maybe we should make the\n                 * result table consistent?\n                 */\n                if (result == null) {\n                    if (table.getColumnType(2).equals(VoltType.INTEGER))\n                        result = constructPartitionResultsTable();\n                    else\n                        result = constructNodeResultsTable();\n                }\n\n                while (table.advanceRow())\n                {\n                    // this will add the active row of table\n                    result.add(table);\n                }\n            }\n            return new\n                DependencyPair( DEP_createSnapshotTargetsResults, result);\n        }\n        assert (false);\n        return null;\n    }","commit_id":"92555f7fe4d38992d60c5d5cae73cb5b369ec08c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public VoltTable[] run(SystemProcedureExecutionContext ctx) throws VoltAbortException\n    {\n        VoltTable scanResults = performScanWork()[0];\n        VoltTable clientResults = constructClientResultsTable();\n        HashMap<Long, SnapshotResult> aggregate = new HashMap<Long, SnapshotResult>();\n        while (scanResults.advanceRow())\n        {\n            SnapshotResult snapshotResult = aggregate.get(scanResults.getLong(\"START_TIME\"));\n            if (snapshotResult == null) {\n                aggregate.put(scanResults.getLong(\"START_TIME\"), new SnapshotResult(scanResults));\n            } else {\n                snapshotResult.processRow(scanResults);\n            }\n        }\n        for (SnapshotResult s : aggregate.values()) {\n            final double duration = (s.endTime - s.startTime) / 1000.0;\n            final double throughput =  (s.size / (1024.0 * 1024.0)) / duration;\n            StringWriter sw = new StringWriter();\n            PrintWriter pw = new PrintWriter(sw);\n            pw.printf(\"%.2f mb/sec\", throughput);\n            pw.flush();\n            clientResults.addRow(\n                    s.path,\n                    s.nonce,\n                    s.startTime,\n                    s.endTime,\n                    s.size,\n                    s.endTime - s.startTime,\n                    sw.toString(),\n                    s.result ? \"SUCCESS\" : \"FAILURE\");\n        }\n        return new VoltTable[] { clientResults, scanResults };\n    }","id":49608,"modified_method":"public VoltTable[] run(SystemProcedureExecutionContext ctx) throws VoltAbortException\n    {\n        ArrayList<Integer> catalogIds = new ArrayList<Integer>();\n        catalogIds.add(0);\n        return new VoltTable[] {\n            VoltDB.instance().getStatsAgent().getStats(SysProcSelector.SNAPSHOTSTATUS,\n                                                       catalogIds,\n                                                       false,\n                                                       System.currentTimeMillis())\n        };\n    }","commit_id":"92555f7fe4d38992d60c5d5cae73cb5b369ec08c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public DependencyPair\n    executePlanFragment(HashMap<Integer, List<VoltTable>> dependencies, long fragmentId, ParameterSet params,\n                        final SystemProcedureExecutionContext context)\n    {\n        String hn = ConnectionUtil.getHostnameOrAddress();\n        final String hostname = hn;\n        final VoltTable results = constructFragmentResultsTable();\n        if (fragmentId == SysProcFragmentId.PF_scanSnapshotRegistries)\n        {\n            // Choose the lowest site ID on this host to do the file scan\n            // All other sites should just return empty results tables.\n            int host_id = context.getExecutionSite().getCorrespondingHostId();\n            Integer lowest_site_id =\n                VoltDB.instance().getCatalogContext().siteTracker.\n                getLowestLiveExecSiteIdForHost(host_id);\n            if (context.getExecutionSite().getSiteId() == lowest_site_id)\n            {\n                TreeSet<Snapshot> snapshots = SnapshotRegistry.getSnapshotHistory();\n                for (final Snapshot s : snapshots) {\n                    s.iterateTables(new TableIterator() {\n                        @Override\n                        public void next(Table t) {\n                            results.addRow(\n                                           Integer.parseInt(context.getSite().getHost().getTypeName()),\n                                           hostname,\n                                           t.name,\n                                           s.path,\n                                           s.nonce,\n                                           t.timeCreated,\n                                           t.timeClosed,\n                                           t.size,\n                                           t.error == null ? \"SUCCESS\" : \"FAILURE\",\n                                                           t.error != null ? t.error.toString() : \"\");\n                        }\n                    });\n                }\n            }\n            return new DependencyPair( DEP_scanSnapshotRegistries, results);\n        } else if (fragmentId == SysProcFragmentId.PF_scanSnapshotRegistriesResults) {\n            TRACE_LOG.trace(\"Aggregating Snapshot Status Scan  results\");\n            assert (dependencies.size() > 0);\n            List<VoltTable> dep = dependencies.get(DEP_scanSnapshotRegistries);\n            for (VoltTable table : dep)\n            {\n                while (table.advanceRow())\n                {\n                    // this will add the active row of table\n                    results.add(table);\n                }\n            }\n            return new\n                DependencyPair( DEP_scanSnapshotRegistriesResults, results);\n        }\n        assert (false);\n        return null;\n    }","id":49609,"modified_method":"@Override\n    public DependencyPair\n    executePlanFragment(HashMap<Integer, List<VoltTable>> dependencies, long fragmentId, ParameterSet params,\n                        final SystemProcedureExecutionContext context)\n    {\n        return null;\n    }","commit_id":"92555f7fe4d38992d60c5d5cae73cb5b369ec08c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public boolean accept(File pathname) {\n            if (!super.accept(pathname)) {\n                return false;\n            }\n\n            if (pathname.isDirectory()) {\n                return true;\n            }\n\n            for (String snapshotName : snapshotNames) {\n                if (pathname.getName().startsWith(snapshotName + \"-\") ||\n                        pathname.getName().equals(snapshotName + \".digest\")) {\n                    return true;\n                }\n            }\n\n            return false;\n        }","id":49610,"modified_method":"@Override\n        public boolean accept(File pathname) {\n            if (!super.accept(pathname)) {\n                return false;\n            }\n\n            if (pathname.isDirectory()) {\n                return true;\n            }\n\n            for (String snapshotName : snapshotNames) {\n                if (pathname.getName().startsWith(snapshotName + \"-\") ||\n                        pathname.getName().equals(constructDigestFilenameForNonce(snapshotName))) {\n                    return true;\n                }\n            }\n\n            return false;\n        }","commit_id":"92555f7fe4d38992d60c5d5cae73cb5b369ec08c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Retrieve a list of tables from a digest. Doesn't return the snapshot time\n     * value that is stashed in the digest file.\n     * @param f\n     * @return\n     * @throws Exception\n     */\n    public static Pair<Long, List<String>> retrieveRelevantTableNamesAndTime(File f) throws Exception {\n        final FileInputStream fis = new FileInputStream(f);\n        try {\n            final BufferedInputStream bis = new BufferedInputStream(fis);\n            ByteBuffer crcBuffer = ByteBuffer.allocate(4);\n            if (4 != bis.read(crcBuffer.array())) {\n                throw new EOFException(\"EOF while attempting to read CRC from snapshot digest\");\n            }\n            final int crc = crcBuffer.getInt();\n            final InputStreamReader isr = new InputStreamReader(bis, \"UTF-8\");\n            CharArrayWriter caw = new CharArrayWriter();\n            while (true) {\n                int nextChar = isr.read();\n                if (nextChar == -1) {\n                    throw new EOFException(\"EOF while reading snapshot digest\");\n                }\n                if (nextChar == '\\n') {\n                    break;\n                }\n                caw.write(nextChar);\n            }\n            String tableList = caw.toString();\n            byte tableListBytes[] = tableList.getBytes(\"UTF-8\");\n            CRC32 tableListCRC = new CRC32();\n            tableListCRC.update(tableListBytes);\n            tableListCRC.update(\"\\n\".getBytes(\"UTF-8\"));\n            final int calculatedValue = (int)tableListCRC.getValue();\n            if (crc != calculatedValue) {\n                throw new IOException(\"CRC of snapshot digest did not match digest contents\");\n            }\n            String tableNames[] = tableList.split(\",\");\n            String actualTableNames[] = new String[tableNames.length - 1];\n            System.arraycopy( tableNames, 1, actualTableNames, 0, tableNames.length - 1);\n            return Pair.of(\n                    Long.valueOf(tableNames[0]),\n                    java.util.Arrays.asList(actualTableNames));\n        } finally {\n            try {\n                if (fis != null) {\n                    fis.close();\n                }\n            } catch (IOException e) {\n            }\n        }\n    }","id":49611,"modified_method":"/**\n     * Retrieve a list of tables from a digest. Doesn't return the snapshot time\n     * value that is stashed in the digest file.\n     * @param f\n     * @return\n     * @throws Exception\n     */\n    public static Pair<Long, List<String>> retrieveRelevantTableNamesAndTime(File f) throws Exception {\n        String tableList = CRCCheck(f);\n        String tableNames[] = tableList.split(\",\");\n        String actualTableNames[] = new String[tableNames.length - 1];\n        System.arraycopy( tableNames, 1, actualTableNames, 0, tableNames.length - 1);\n        return Pair.of(Long.valueOf(tableNames[0]),\n                       java.util.Arrays.asList(actualTableNames));\n    }","commit_id":"92555f7fe4d38992d60c5d5cae73cb5b369ec08c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static List<String> retrieveRelevantTableNames(String path,\n            String nonce) throws Exception {\n        return retrieveRelevantTableNamesAndTime(new File(path, nonce + \".digest\")).getSecond();\n    }","id":49612,"modified_method":"public static List<String> retrieveRelevantTableNames(String path,\n            String nonce) throws Exception {\n        return retrieveRelevantTableNamesAndTime(new File(path, constructDigestFilenameForNonce(nonce))).getSecond();\n    }","commit_id":"92555f7fe4d38992d60c5d5cae73cb5b369ec08c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Create a digest for a snapshot containing the time of the snapshot and the list of tables included.\n     * The first item in the comma separated list is the time in milliseconds as a string.\n     * @param snapshotTime\n     * @param path\n     * @param nonce\n     * @param tables\n     * @throws IOException\n     */\n    public static void\n        recordSnapshotTableList(\n            long snapshotTime,\n            String path,\n            String nonce,\n            List<String> tables) throws IOException {\n        final File f = new File(path, nonce + \".digest\");\n        if (f.exists()) {\n            if (!f.delete()) {\n                throw new IOException(\"Unable to write table list file \" + f);\n            }\n        }\n        FileOutputStream fos = new FileOutputStream(f);\n        StringWriter sw = new StringWriter();\n        sw.append(Long.toString(snapshotTime));\n        if (!tables.isEmpty()) {\n            sw.append(',');\n        }\n        for (int ii = 0; ii < tables.size(); ii++) {\n            sw.append(tables.get(ii));\n            if (!(ii == (tables.size() - 1))) {\n                sw.append(',');\n            } else {\n                sw.append('\\n');\n            }\n        }\n\n        final byte tableListBytes[] = sw.getBuffer().toString().getBytes(\"UTF-8\");\n        final CRC32 crc = new CRC32();\n        crc.update(tableListBytes);\n        ByteBuffer fileBuffer = ByteBuffer.allocate(tableListBytes.length + 4);\n        fileBuffer.putInt((int)crc.getValue());\n        fileBuffer.put(tableListBytes);\n        fileBuffer.flip();\n        fos.getChannel().write(fileBuffer);\n        fos.getFD().sync();\n    }","id":49613,"modified_method":"/**\n     * Create a digest for a snapshot containing the time of the snapshot and the list of tables included.\n     * The first item in the comma separated list is the time in milliseconds as a string.\n     * @param snapshotTime\n     * @param path\n     * @param nonce\n     * @param tables\n     * @throws IOException\n     */\n    public static void\n        recordSnapshotTableList(\n            long snapshotTime,\n            String path,\n            String nonce,\n            List<Table> tables) throws IOException {\n        final File f = new File(path, constructDigestFilenameForNonce(nonce));\n        if (f.exists()) {\n            if (!f.delete()) {\n                throw new IOException(\"Unable to write table list file \" + f);\n            }\n        }\n        FileOutputStream fos = new FileOutputStream(f);\n        StringWriter sw = new StringWriter();\n        sw.append(Long.toString(snapshotTime));\n        if (!tables.isEmpty()) {\n            sw.append(',');\n        }\n        for (int ii = 0; ii < tables.size(); ii++) {\n            sw.append(tables.get(ii).getTypeName());\n            if (!(ii == (tables.size() - 1))) {\n                sw.append(',');\n            } else {\n                sw.append('\\n');\n            }\n        }\n\n        final byte tableListBytes[] = sw.getBuffer().toString().getBytes(\"UTF-8\");\n        final CRC32 crc = new CRC32();\n        crc.update(tableListBytes);\n        ByteBuffer fileBuffer = ByteBuffer.allocate(tableListBytes.length + 4);\n        fileBuffer.putInt((int)crc.getValue());\n        fileBuffer.put(tableListBytes);\n        fileBuffer.flip();\n        fos.getChannel().write(fileBuffer);\n        fos.getFD().sync();\n    }","commit_id":"92555f7fe4d38992d60c5d5cae73cb5b369ec08c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testSnapshotSave() throws Exception\n    {\n        System.out.println(\"Starting testSnapshotSave\");\n        Client client = getClient();\n\n        int num_replicated_items_per_chunk = 100;\n        int num_replicated_chunks = 10;\n        int num_partitioned_items_per_chunk = 120;\n        int num_partitioned_chunks = 10;\n\n        loadLargeReplicatedTable(client, \"REPLICATED_TESTER\",\n                                 num_replicated_items_per_chunk,\n                                 num_replicated_chunks);\n        loadLargePartitionedTable(client, \"PARTITION_TESTER\",\n                                  num_partitioned_items_per_chunk,\n                                  num_partitioned_chunks);\n\n        VoltTable[] results = null;\n\n        results = client.callProcedure(\"@SnapshotSave\", TMPDIR,\n                                       TESTNONCE, (byte)1).getResults();\n\n        validateSnapshot(true);\n\n        /*\n         * Check that snapshot status returns a reasonable result\n         */\n        VoltTable statusResults[] = client.callProcedure(\"@SnapshotStatus\").getResults();\n        assertNotNull(statusResults);\n        assertEquals( 2, statusResults.length);\n        assertEquals( 8, statusResults[0].getColumnCount());\n        assertEquals( 1, statusResults[0].getRowCount());\n        assertTrue(statusResults[0].advanceRow());\n        assertTrue(TMPDIR.equals(statusResults[0].getString(\"PATH\")));\n        assertTrue(TESTNONCE.equals(statusResults[0].getString(\"NONCE\")));\n        assertFalse( 0 == statusResults[0].getLong(\"END_TIME\"));\n        assertTrue(\"SUCCESS\".equals(statusResults[0].getString(\"RESULT\")));\n\n        VoltTable scanResults[] = client.callProcedure(\"@SnapshotScan\", new Object[] { null }).getResults();\n        assertNotNull(scanResults);\n        assertEquals( 1, scanResults.length);\n        assertEquals( 1, scanResults[0].getColumnCount());\n        assertEquals( 1, scanResults[0].getRowCount());\n        assertTrue( scanResults[0].advanceRow());\n        assertTrue( \"ERR_MSG\".equals(scanResults[0].getColumnName(0)));\n\n        scanResults = client.callProcedure(\"@SnapshotScan\", \"/doesntexist\").getResults();\n        assertNotNull(scanResults);\n        assertEquals( 1, scanResults[1].getRowCount());\n        assertTrue( scanResults[1].advanceRow());\n        assertTrue( \"FAILURE\".equals(scanResults[1].getString(\"RESULT\")));\n\n        scanResults = client.callProcedure(\"@SnapshotScan\", TMPDIR).getResults();\n        assertNotNull(scanResults);\n        assertEquals( 3, scanResults.length);\n        assertEquals( 8, scanResults[0].getColumnCount());\n        assertTrue(scanResults[0].getRowCount() >= 1);\n        assertTrue(scanResults[0].advanceRow());\n        /*\n         * We can't assert that all snapshot files are generated by this test.\n         * There might be leftover snapshot files from other runs.\n         */\n        int count = 0;\n        String completeStatus = null;\n        do {\n            assertTrue(TMPDIR.equals(scanResults[0].getString(\"PATH\")));\n            if (TESTNONCE.equals(scanResults[0].getString(\"NONCE\"))) {\n                count++;\n                completeStatus = scanResults[0].getString(\"COMPLETE\");\n            }\n        } while (scanResults[0].advanceRow());\n        assertEquals(1, count);\n        assertNotNull(completeStatus);\n        assertTrue(\"TRUE\".equals(completeStatus));\n\n        FilenameFilter cleaner = new FilenameFilter()\n        {\n            public boolean accept(File dir, String file)\n            {\n                return file.startsWith(TESTNONCE) && file.endsWith(\"vpt\");\n            }\n        };\n\n        File tmp_dir = new File(TMPDIR);\n        File[] tmp_files = tmp_dir.listFiles(cleaner);\n        tmp_files[0].delete();\n\n        scanResults = client.callProcedure(\"@SnapshotScan\", TMPDIR).getResults();\n        assertNotNull(scanResults);\n        assertEquals( 3, scanResults.length);\n        assertEquals( 8, scanResults[0].getColumnCount());\n        assertTrue(scanResults[0].getRowCount() >= 1);\n        assertTrue(scanResults[0].advanceRow());\n        count = 0;\n        String missingTableName = null;\n        do {\n            assertTrue(TMPDIR.equals(scanResults[0].getString(\"PATH\")));\n            if (TESTNONCE.equals(scanResults[0].getString(\"NONCE\"))\n                && \"FALSE\".equals(scanResults[0].getString(\"COMPLETE\"))) {\n                count++;\n                missingTableName = scanResults[0].getString(\"TABLES_MISSING\");\n            }\n        } while (scanResults[0].advanceRow());\n        assertEquals(1, count);\n        assertNotNull(missingTableName);\n        assertTrue(tmp_files[0].getName().contains(missingTableName));\n\n        // Instead of something exhaustive, let's just make sure that we get\n        // the number of result rows corresponding to the number of ExecutionSites\n        // that did save work\n        Cluster cluster = VoltDB.instance().getCatalogContext().cluster;\n        Database database = cluster.getDatabases().get(\"database\");\n        CatalogMap<Table> tables = database.getTables();\n        CatalogMap<Site> sites = cluster.getSites();\n        int num_hosts = cluster.getHosts().size();\n        int replicated = 0;\n        int total_tables = 0;\n        int expected_entries = 0;\n\n        for (Table table : tables)\n        {\n            // Ignore materialized tables\n            if (table.getMaterializer() == null)\n            {\n                total_tables++;\n                if (table.getIsreplicated())\n                {\n                    replicated++;\n                }\n            }\n        }\n\n        for (Site s : sites) {\n            if (s.getIsexec()) {\n                expected_entries++;\n            }\n        }\n        assertEquals(expected_entries, results[0].getRowCount());\n\n        while (results[0].advanceRow())\n        {\n            assertEquals(results[0].getString(\"RESULT\"), \"SUCCESS\");\n        }\n\n        // Now, try the save again and verify that we fail (since all the save\n        // files will still exist. This will return one entry per table\n        // per host\n        expected_entries =\n            ((total_tables - replicated) * num_hosts) + replicated;\n        try\n        {\n            results = client.callProcedure(\"@SnapshotSave\", TMPDIR,\n                                           TESTNONCE, (byte)1).getResults();\n        }\n        catch (Exception ex)\n        {\n            ex.printStackTrace();\n            fail(\"SnapshotSave exception: \" + ex.getMessage());\n        }\n        assertEquals(expected_entries, results[0].getRowCount());\n        while (results[0].advanceRow())\n        {\n            if (!tmp_files[0].getName().contains(results[0].getString(\"TABLE\"))) {\n                assertEquals(results[0].getString(\"RESULT\"), \"FAILURE\");\n                assertTrue(results[0].getString(\"ERR_MSG\").contains(\"SAVE FILE ALREADY EXISTS\"));\n            }\n        }\n\n        VoltTable deleteResults[] =\n            client.callProcedure(\n                \"@SnapshotDelete\",\n                new String[] {TMPDIR},\n                new String[]{TESTNONCE}).getResults();\n        assertNotNull(deleteResults);\n        assertEquals( 1, deleteResults.length);\n        assertEquals( 9, deleteResults[0].getColumnCount());\n        assertEquals( 8, deleteResults[0].getRowCount());\n        tmp_files = tmp_dir.listFiles(cleaner);\n        assertEquals( 0, tmp_files.length);\n\n        validateSnapshot(false);\n    }","id":49614,"modified_method":"public void testSnapshotSave() throws Exception\n    {\n        System.out.println(\"Starting testSnapshotSave\");\n        Client client = getClient();\n\n        int num_replicated_items_per_chunk = 100;\n        int num_replicated_chunks = 10;\n        int num_partitioned_items_per_chunk = 120;\n        int num_partitioned_chunks = 10;\n\n        loadLargeReplicatedTable(client, \"REPLICATED_TESTER\",\n                                 num_replicated_items_per_chunk,\n                                 num_replicated_chunks);\n        loadLargePartitionedTable(client, \"PARTITION_TESTER\",\n                                  num_partitioned_items_per_chunk,\n                                  num_partitioned_chunks);\n\n        VoltTable[] results = null;\n\n        results = client.callProcedure(\"@SnapshotSave\", TMPDIR,\n                                       TESTNONCE, (byte)1).getResults();\n\n        validateSnapshot(true);\n\n        /*\n         * Check that snapshot status returns a reasonable result\n         */\n        VoltTable statusResults[] = client.callProcedure(\"@SnapshotStatus\").getResults();\n        assertNotNull(statusResults);\n        assertEquals( 1, statusResults.length);\n        assertEquals( 13, statusResults[0].getColumnCount());\n        assertTrue(statusResults[0].advanceRow());\n        assertTrue(TMPDIR.equals(statusResults[0].getString(\"PATH\")));\n        assertTrue(TESTNONCE.equals(statusResults[0].getString(\"NONCE\")));\n        assertFalse( 0 == statusResults[0].getLong(\"END_TIME\"));\n        assertTrue(\"SUCCESS\".equals(statusResults[0].getString(\"RESULT\")));\n\n        VoltTable scanResults[] = client.callProcedure(\"@SnapshotScan\", new Object[] { null }).getResults();\n        assertNotNull(scanResults);\n        assertEquals( 1, scanResults.length);\n        assertEquals( 1, scanResults[0].getColumnCount());\n        assertEquals( 1, scanResults[0].getRowCount());\n        assertTrue( scanResults[0].advanceRow());\n        assertTrue( \"ERR_MSG\".equals(scanResults[0].getColumnName(0)));\n\n        scanResults = client.callProcedure(\"@SnapshotScan\", \"/doesntexist\").getResults();\n        assertNotNull(scanResults);\n        assertEquals( 1, scanResults[1].getRowCount());\n        assertTrue( scanResults[1].advanceRow());\n        assertTrue( \"FAILURE\".equals(scanResults[1].getString(\"RESULT\")));\n\n        scanResults = client.callProcedure(\"@SnapshotScan\", TMPDIR).getResults();\n        assertNotNull(scanResults);\n        assertEquals( 3, scanResults.length);\n        assertEquals( 8, scanResults[0].getColumnCount());\n        assertTrue(scanResults[0].getRowCount() >= 1);\n        assertTrue(scanResults[0].advanceRow());\n        /*\n         * We can't assert that all snapshot files are generated by this test.\n         * There might be leftover snapshot files from other runs.\n         */\n        int count = 0;\n        String completeStatus = null;\n        do {\n            if (TESTNONCE.equals(scanResults[0].getString(\"NONCE\"))) {\n                assertTrue(TMPDIR.equals(scanResults[0].getString(\"PATH\")));\n                count++;\n                completeStatus = scanResults[0].getString(\"COMPLETE\");\n            }\n        } while (scanResults[0].advanceRow());\n        assertEquals(1, count);\n        assertNotNull(completeStatus);\n        assertTrue(\"TRUE\".equals(completeStatus));\n\n        FilenameFilter cleaner = new FilenameFilter()\n        {\n            public boolean accept(File dir, String file)\n            {\n                return file.startsWith(TESTNONCE) && file.endsWith(\"vpt\");\n            }\n        };\n\n        File tmp_dir = new File(TMPDIR);\n        File[] tmp_files = tmp_dir.listFiles(cleaner);\n        tmp_files[0].delete();\n\n        scanResults = client.callProcedure(\"@SnapshotScan\", TMPDIR).getResults();\n        assertNotNull(scanResults);\n        assertEquals( 3, scanResults.length);\n        assertEquals( 8, scanResults[0].getColumnCount());\n        assertTrue(scanResults[0].getRowCount() >= 1);\n        assertTrue(scanResults[0].advanceRow());\n        count = 0;\n        String missingTableName = null;\n        do {\n            if (TESTNONCE.equals(scanResults[0].getString(\"NONCE\"))\n                && \"FALSE\".equals(scanResults[0].getString(\"COMPLETE\"))) {\n                assertTrue(TMPDIR.equals(scanResults[0].getString(\"PATH\")));\n                count++;\n                missingTableName = scanResults[0].getString(\"TABLES_MISSING\");\n            }\n        } while (scanResults[0].advanceRow());\n        assertEquals(1, count);\n        assertNotNull(missingTableName);\n        assertTrue(tmp_files[0].getName().contains(missingTableName));\n\n        // Instead of something exhaustive, let's just make sure that we get\n        // the number of result rows corresponding to the number of ExecutionSites\n        // that did save work\n        Cluster cluster = VoltDB.instance().getCatalogContext().cluster;\n        Database database = cluster.getDatabases().get(\"database\");\n        CatalogMap<Table> tables = database.getTables();\n        CatalogMap<Site> sites = cluster.getSites();\n        int num_hosts = cluster.getHosts().size();\n        int replicated = 0;\n        int total_tables = 0;\n        int expected_entries = 0;\n\n        for (Table table : tables)\n        {\n            // Ignore materialized tables\n            if (table.getMaterializer() == null)\n            {\n                total_tables++;\n                if (table.getIsreplicated())\n                {\n                    replicated++;\n                }\n            }\n        }\n\n        for (Site s : sites) {\n            if (s.getIsexec()) {\n                expected_entries++;\n            }\n        }\n        assertEquals(expected_entries, results[0].getRowCount());\n\n        while (results[0].advanceRow())\n        {\n            assertEquals(results[0].getString(\"RESULT\"), \"SUCCESS\");\n        }\n\n        // Now, try the save again and verify that we fail (since all the save\n        // files will still exist. This will return one entry per table\n        // per host\n        expected_entries =\n            ((total_tables - replicated) * num_hosts) + replicated;\n        try\n        {\n            results = client.callProcedure(\"@SnapshotSave\", TMPDIR,\n                                           TESTNONCE, (byte)1).getResults();\n        }\n        catch (Exception ex)\n        {\n            ex.printStackTrace();\n            fail(\"SnapshotSave exception: \" + ex.getMessage());\n        }\n        assertEquals(expected_entries, results[0].getRowCount());\n        while (results[0].advanceRow())\n        {\n            if (!tmp_files[0].getName().contains(results[0].getString(\"TABLE\"))) {\n                assertEquals(results[0].getString(\"RESULT\"), \"FAILURE\");\n                assertTrue(results[0].getString(\"ERR_MSG\").contains(\"SAVE FILE ALREADY EXISTS\"));\n            }\n        }\n\n        VoltTable deleteResults[] =\n            client.callProcedure(\n                \"@SnapshotDelete\",\n                new String[] {TMPDIR},\n                new String[]{TESTNONCE}).getResults();\n        assertNotNull(deleteResults);\n        assertEquals( 1, deleteResults.length);\n        assertEquals( 9, deleteResults[0].getColumnCount());\n        assertEquals( 8, deleteResults[0].getRowCount());\n        tmp_files = tmp_dir.listFiles(cleaner);\n        assertEquals( 0, tmp_files.length);\n\n        validateSnapshot(false);\n    }","commit_id":"92555f7fe4d38992d60c5d5cae73cb5b369ec08c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testIdleOnlineSnapshot() throws Exception\n    {\n        System.out.println(\"Starting testIdleOnlineSnapshot\");\n        Client client = getClient();\n\n        int num_replicated_items_per_chunk = 100;\n        int num_replicated_chunks = 10;\n        int num_partitioned_items_per_chunk = 120;\n        int num_partitioned_chunks = 10;\n\n        loadLargeReplicatedTable(client, \"REPLICATED_TESTER\",\n                                 num_replicated_items_per_chunk,\n                                 num_replicated_chunks);\n        loadLargePartitionedTable(client, \"PARTITION_TESTER\",\n                                  num_partitioned_items_per_chunk,\n                                  num_partitioned_chunks);\n\n        client.callProcedure(\"@SnapshotSave\", TMPDIR,\n                                       TESTNONCE, (byte)0);\n\n        Thread.sleep(700);\n\n        /*\n         * Check that snapshot status returns a reasonable result\n         */\n        VoltTable statusResults[] = client.callProcedure(\"@SnapshotStatus\").getResults();\n        assertNotNull(statusResults);\n        assertEquals( 2, statusResults.length);\n        assertEquals( 8, statusResults[0].getColumnCount());\n        assertEquals( 1, statusResults[0].getRowCount());\n        assertTrue(statusResults[0].advanceRow());\n        assertTrue(TMPDIR.equals(statusResults[0].getString(\"PATH\")));\n        assertTrue(TESTNONCE.equals(statusResults[0].getString(\"NONCE\")));\n        assertFalse( 0 == statusResults[0].getLong(\"END_TIME\"));\n        assertTrue(\"SUCCESS\".equals(statusResults[0].getString(\"RESULT\")));\n\n        validateSnapshot(true);\n    }","id":49615,"modified_method":"public void testIdleOnlineSnapshot() throws Exception\n    {\n        System.out.println(\"Starting testIdleOnlineSnapshot\");\n        Client client = getClient();\n\n        int num_replicated_items_per_chunk = 100;\n        int num_replicated_chunks = 10;\n        int num_partitioned_items_per_chunk = 120;\n        int num_partitioned_chunks = 10;\n\n        loadLargeReplicatedTable(client, \"REPLICATED_TESTER\",\n                                 num_replicated_items_per_chunk,\n                                 num_replicated_chunks);\n        loadLargePartitionedTable(client, \"PARTITION_TESTER\",\n                                  num_partitioned_items_per_chunk,\n                                  num_partitioned_chunks);\n\n        client.callProcedure(\"@SnapshotSave\", TMPDIR,\n                                       TESTNONCE, (byte)0);\n\n        Thread.sleep(700);\n\n        /*\n         * Check that snapshot status returns a reasonable result\n         */\n        VoltTable statusResults[] = client.callProcedure(\"@SnapshotStatus\").getResults();\n        assertNotNull(statusResults);\n        assertEquals( 1, statusResults.length);\n        assertEquals( 13, statusResults[0].getColumnCount());\n        assertEquals( 7, statusResults[0].getRowCount());\n        assertTrue(statusResults[0].advanceRow());\n        assertTrue(TMPDIR.equals(statusResults[0].getString(\"PATH\")));\n        assertTrue(TESTNONCE.equals(statusResults[0].getString(\"NONCE\")));\n        assertFalse( 0 == statusResults[0].getLong(\"END_TIME\"));\n        assertTrue(\"SUCCESS\".equals(statusResults[0].getString(\"RESULT\")));\n\n        validateSnapshot(true);\n    }","commit_id":"92555f7fe4d38992d60c5d5cae73cb5b369ec08c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testSaveAndRestorePartitionedTable()\n    throws IOException, InterruptedException, ProcCallException\n    {\n        System.out.println(\"Starting testSaveAndRestorePartitionedTable\");\n        int num_partitioned_items_per_chunk = 120; // divisible by 3\n        int num_partitioned_chunks = 10;\n        Client client = getClient();\n\n        loadLargePartitionedTable(client, \"PARTITION_TESTER\",\n                                  num_partitioned_items_per_chunk,\n                                  num_partitioned_chunks);\n        VoltTable[] results = null;\n\n        DefaultSnapshotDataTarget.m_simulateFullDiskWritingHeader = true;\n        results = saveTables(client);\n        deleteTestFiles();\n\n        while (results[0].advanceRow()) {\n            assertTrue(results[0].getString(\"RESULT\").equals(\"FAILURE\"));\n        }\n\n        DefaultSnapshotDataTarget.m_simulateFullDiskWritingHeader = false;\n\n        validateSnapshot(false);\n\n        results = saveTables(client);\n\n        validateSnapshot(true);\n\n        while (results[0].advanceRow()) {\n            if (!results[0].getString(\"RESULT\").equals(\"SUCCESS\")) {\n                System.out.println(results[0].getString(\"ERR_MSG\"));\n            }\n            assertTrue(results[0].getString(\"RESULT\").equals(\"SUCCESS\"));\n        }\n\n        try\n        {\n            results = client.callProcedure(\"@SnapshotStatus\").getResults();\n            assertTrue(results[0].advanceRow());\n            assertTrue(results[0].getString(\"RESULT\").equals(\"SUCCESS\"));\n            assertEquals( 1, results[0].getRowCount());\n        }\n        catch (Exception ex)\n        {\n            ex.printStackTrace();\n            fail(\"SnapshotRestore exception: \" + ex.getMessage());\n        }\n\n        // Kill and restart all the execution sites.\n        m_config.shutDown();\n        m_config.startUp();\n\n        client = getClient();\n\n        try\n        {\n            results = client.callProcedure(\"@SnapshotRestore\", TMPDIR,\n                                           TESTNONCE, ALLOWELT).getResults();\n\n            while (results[0].advanceRow()) {\n                if (results[0].getString(\"RESULT\").equals(\"FAILURE\")) {\n                    fail(results[0].getString(\"ERR_MSG\"));\n                }\n            }\n        }\n        catch (Exception ex)\n        {\n            ex.printStackTrace();\n            fail(\"SnapshotRestore exception: \" + ex.getMessage());\n        }\n\n        checkTable(client, \"PARTITION_TESTER\", \"PT_ID\",\n                   num_partitioned_items_per_chunk * num_partitioned_chunks);\n\n        results = client.callProcedure(\"@Statistics\", \"table\", 0).getResults();\n\n        int foundItem = 0;\n        while (results[0].advanceRow())\n        {\n            if (results[0].getString(\"TABLE_NAME\").equals(\"PARTITION_TESTER\"))\n            {\n                ++foundItem;\n                assertEquals((num_partitioned_items_per_chunk * num_partitioned_chunks) / 3,\n                        results[0].getLong(\"TABLE_ACTIVE_TUPLE_COUNT\"));\n            }\n        }\n        // make sure all sites were loaded\n        assertEquals(3, foundItem);\n\n        // Kill and restart all the execution sites.\n        m_config.shutDown();\n        m_config.startUp();\n        deleteTestFiles();\n\n        DefaultSnapshotDataTarget.m_simulateFullDiskWritingChunk = true;\n\n        org.voltdb.sysprocs.SnapshotRegistry.clear();\n        client = getClient();\n\n        loadLargePartitionedTable(client, \"PARTITION_TESTER\",\n                                  num_partitioned_items_per_chunk,\n                                  num_partitioned_chunks);\n\n        results = saveTables(client);\n\n        validateSnapshot(false);\n\n        try\n        {\n            results = client.callProcedure(\"@SnapshotStatus\").getResults();\n            assertTrue(results[0].advanceRow());\n            assertTrue(results[0].getString(\"RESULT\").equals(\"FAILURE\"));\n        }\n        catch (Exception ex)\n        {\n            ex.printStackTrace();\n            fail(\"SnapshotRestore exception: \" + ex.getMessage());\n        }\n\n        DefaultSnapshotDataTarget.m_simulateFullDiskWritingChunk = false;\n        deleteTestFiles();\n        results = saveTables(client);\n\n        validateSnapshot(true);\n\n        // Kill and restart all the execution sites.\n        m_config.shutDown();\n        m_config.startUp();\n\n        client = getClient();\n\n        try\n        {\n            results = client.callProcedure(\"@SnapshotRestore\", TMPDIR,\n                                           TESTNONCE, ALLOWELT).getResults();\n        }\n        catch (Exception ex)\n        {\n            ex.printStackTrace();\n            fail(\"SnapshotRestore exception: \" + ex.getMessage());\n        }\n\n        checkTable(client, \"PARTITION_TESTER\", \"PT_ID\",\n                   num_partitioned_items_per_chunk * num_partitioned_chunks);\n\n        results = client.callProcedure(\"@Statistics\", \"table\", 0).getResults();\n\n        foundItem = 0;\n        while (results[0].advanceRow())\n        {\n            if (results[0].getString(\"TABLE_NAME\").equals(\"PARTITION_TESTER\"))\n            {\n                ++foundItem;\n                assertEquals((num_partitioned_items_per_chunk * num_partitioned_chunks) / 3,\n                        results[0].getLong(\"TABLE_ACTIVE_TUPLE_COUNT\"));\n            }\n        }\n        // make sure all sites were loaded\n        assertEquals(3, foundItem);\n    }","id":49616,"modified_method":"public void testSaveAndRestorePartitionedTable()\n    throws IOException, InterruptedException, ProcCallException\n    {\n        System.out.println(\"Starting testSaveAndRestorePartitionedTable\");\n        int num_partitioned_items_per_chunk = 120; // divisible by 3\n        int num_partitioned_chunks = 10;\n        Client client = getClient();\n\n        loadLargePartitionedTable(client, \"PARTITION_TESTER\",\n                                  num_partitioned_items_per_chunk,\n                                  num_partitioned_chunks);\n        VoltTable[] results = null;\n\n        DefaultSnapshotDataTarget.m_simulateFullDiskWritingHeader = true;\n        results = saveTables(client);\n        deleteTestFiles();\n\n        while (results[0].advanceRow()) {\n            assertTrue(results[0].getString(\"RESULT\").equals(\"FAILURE\"));\n        }\n\n        DefaultSnapshotDataTarget.m_simulateFullDiskWritingHeader = false;\n\n        validateSnapshot(false);\n\n        results = saveTables(client);\n\n        validateSnapshot(true);\n\n        while (results[0].advanceRow()) {\n            if (!results[0].getString(\"RESULT\").equals(\"SUCCESS\")) {\n                System.out.println(results[0].getString(\"ERR_MSG\"));\n            }\n            assertTrue(results[0].getString(\"RESULT\").equals(\"SUCCESS\"));\n        }\n\n        try\n        {\n            results = client.callProcedure(\"@SnapshotStatus\").getResults();\n            assertTrue(results[0].advanceRow());\n            assertTrue(results[0].getString(\"RESULT\").equals(\"SUCCESS\"));\n            assertEquals( 7, results[0].getRowCount());\n        }\n        catch (Exception ex)\n        {\n            ex.printStackTrace();\n            fail(\"SnapshotRestore exception: \" + ex.getMessage());\n        }\n\n        // Kill and restart all the execution sites.\n        m_config.shutDown();\n        m_config.startUp();\n\n        client = getClient();\n\n        try\n        {\n            results = client.callProcedure(\"@SnapshotRestore\", TMPDIR,\n                                           TESTNONCE, ALLOWELT).getResults();\n\n            while (results[0].advanceRow()) {\n                if (results[0].getString(\"RESULT\").equals(\"FAILURE\")) {\n                    fail(results[0].getString(\"ERR_MSG\"));\n                }\n            }\n        }\n        catch (Exception ex)\n        {\n            ex.printStackTrace();\n            fail(\"SnapshotRestore exception: \" + ex.getMessage());\n        }\n\n        checkTable(client, \"PARTITION_TESTER\", \"PT_ID\",\n                   num_partitioned_items_per_chunk * num_partitioned_chunks);\n\n        results = client.callProcedure(\"@Statistics\", \"table\", 0).getResults();\n\n        int foundItem = 0;\n        while (results[0].advanceRow())\n        {\n            if (results[0].getString(\"TABLE_NAME\").equals(\"PARTITION_TESTER\"))\n            {\n                ++foundItem;\n                assertEquals((num_partitioned_items_per_chunk * num_partitioned_chunks) / 3,\n                        results[0].getLong(\"TABLE_ACTIVE_TUPLE_COUNT\"));\n            }\n        }\n        // make sure all sites were loaded\n        assertEquals(3, foundItem);\n\n        // Kill and restart all the execution sites.\n        m_config.shutDown();\n        m_config.startUp();\n        deleteTestFiles();\n\n        DefaultSnapshotDataTarget.m_simulateFullDiskWritingChunk = true;\n\n        org.voltdb.sysprocs.SnapshotRegistry.clear();\n        client = getClient();\n\n        loadLargePartitionedTable(client, \"PARTITION_TESTER\",\n                                  num_partitioned_items_per_chunk,\n                                  num_partitioned_chunks);\n\n        results = saveTables(client);\n\n        validateSnapshot(false);\n\n        try\n        {\n            results = client.callProcedure(\"@SnapshotStatus\").getResults();\n            boolean hasFailure = false;\n            while (results[0].advanceRow())\n                hasFailure |= results[0].getString(\"RESULT\").equals(\"FAILURE\");\n            assertTrue(hasFailure);\n        }\n        catch (Exception ex)\n        {\n            ex.printStackTrace();\n            fail(\"SnapshotRestore exception: \" + ex.getMessage());\n        }\n\n        DefaultSnapshotDataTarget.m_simulateFullDiskWritingChunk = false;\n        deleteTestFiles();\n        results = saveTables(client);\n\n        validateSnapshot(true);\n\n        // Kill and restart all the execution sites.\n        m_config.shutDown();\n        m_config.startUp();\n\n        client = getClient();\n\n        try\n        {\n            results = client.callProcedure(\"@SnapshotRestore\", TMPDIR,\n                                           TESTNONCE, ALLOWELT).getResults();\n        }\n        catch (Exception ex)\n        {\n            ex.printStackTrace();\n            fail(\"SnapshotRestore exception: \" + ex.getMessage());\n        }\n\n        checkTable(client, \"PARTITION_TESTER\", \"PT_ID\",\n                   num_partitioned_items_per_chunk * num_partitioned_chunks);\n\n        results = client.callProcedure(\"@Statistics\", \"table\", 0).getResults();\n\n        foundItem = 0;\n        while (results[0].advanceRow())\n        {\n            if (results[0].getString(\"TABLE_NAME\").equals(\"PARTITION_TESTER\"))\n            {\n                ++foundItem;\n                assertEquals((num_partitioned_items_per_chunk * num_partitioned_chunks) / 3,\n                        results[0].getLong(\"TABLE_ACTIVE_TUPLE_COUNT\"));\n            }\n        }\n        // make sure all sites were loaded\n        assertEquals(3, foundItem);\n    }","commit_id":"92555f7fe4d38992d60c5d5cae73cb5b369ec08c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void deleteEvent(CalEvent event)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Pool\n\n\t\tCalEventLocalUtil.clearEventsPool(event.getGroupId());\n\n\t\t// Resources\n\n\t\tResourceLocalServiceUtil.deleteResource(\n\t\t\tevent.getCompanyId(), CalEvent.class.getName(),\n\t\t\tResourceImpl.TYPE_CLASS, ResourceImpl.SCOPE_INDIVIDUAL,\n\t\t\tString.valueOf(event.getPrimaryKey()));\n\n\t\t// Event\n\n\t\tCalEventUtil.remove(event.getEventId());\n\t}","id":49617,"modified_method":"public void deleteEvent(CalEvent event)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Pool\n\n\t\tCalEventLocalUtil.clearEventsPool(event.getGroupId());\n\n\t\t// Resources\n\n\t\tResourceLocalServiceUtil.deleteResource(\n\t\t\tevent.getCompanyId(), CalEvent.class.getName(),\n\t\t\tResourceImpl.TYPE_CLASS, ResourceImpl.SCOPE_INDIVIDUAL,\n\t\t\tevent.getPrimaryKey());\n\n\t\t// Event\n\n\t\tCalEventUtil.remove(event.getEventId());\n\t}","commit_id":"c50f14a6a37ca975497160fbdd2b748f18fbf443","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addEventResources(\n\t\t\tCalEvent event, String[] communityPermissions,\n\t\t\tString[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addModelResources(\n\t\t\tevent.getCompanyId(), event.getGroupId(), event.getUserId(),\n\t\t\tCalEvent.class.getName(), String.valueOf(event.getPrimaryKey()),\n\t\t\tcommunityPermissions, guestPermissions);\n\t}","id":49618,"modified_method":"public void addEventResources(\n\t\t\tCalEvent event, String[] communityPermissions,\n\t\t\tString[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addModelResources(\n\t\t\tevent.getCompanyId(), event.getGroupId(), event.getUserId(),\n\t\t\tCalEvent.class.getName(), event.getPrimaryKey(),\n\t\t\tcommunityPermissions, guestPermissions);\n\t}","commit_id":"c50f14a6a37ca975497160fbdd2b748f18fbf443","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addEventResources(\n\t\t\tCalEvent event, boolean addCommunityPermissions,\n\t\t\tboolean addGuestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addResources(\n\t\t\tevent.getCompanyId(), event.getGroupId(), event.getUserId(),\n\t\t\tCalEvent.class.getName(), String.valueOf(event.getPrimaryKey()),\n\t\t\tfalse, addCommunityPermissions, addGuestPermissions);\n\t}","id":49619,"modified_method":"public void addEventResources(\n\t\t\tCalEvent event, boolean addCommunityPermissions,\n\t\t\tboolean addGuestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addResources(\n\t\t\tevent.getCompanyId(), event.getGroupId(), event.getUserId(),\n\t\t\tCalEvent.class.getName(), event.getPrimaryKey(), false,\n\t\t\taddCommunityPermissions, addGuestPermissions);\n\t}","commit_id":"c50f14a6a37ca975497160fbdd2b748f18fbf443","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, CalEvent event,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tevent.getGroupId(), CalEvent.class.getName(),\n\t\t\tString.valueOf(event.getPrimaryKey()), actionId);\n\t}","id":49620,"modified_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, CalEvent event,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tevent.getGroupId(), CalEvent.class.getName(), event.getPrimaryKey(),\n\t\t\tactionId);\n\t}","commit_id":"c50f14a6a37ca975497160fbdd2b748f18fbf443","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setColumn(\n\t\t\tPreparedStatement ps, int index, Integer type, String value)\n\t\tthrows Exception {\n\n\t\tint t = type.intValue();\n\n\t\tint parameterIndex = index + 1;\n\n\t\tif (t == Types.BIGINT) {\n\t\t\tps.setLong(parameterIndex, GetterUtil.getLong(value));\n\t\t}\n\t\telse if (t == Types.BOOLEAN) {\n\t\t\tps.setBoolean(parameterIndex, GetterUtil.getBoolean(value));\n\t\t}\n\t\telse if ((t == Types.CLOB) || (t == Types.VARCHAR)) {\n\t\t\tvalue = StringUtil.replace(value, _SAFE_CHARS[1], _SAFE_CHARS[0]);\n\n\t\t\tps.setString(parameterIndex, value);\n\t\t}\n\t\telse if (t == Types.DOUBLE) {\n\t\t\tps.setDouble(parameterIndex, GetterUtil.getDouble(value));\n\t\t}\n\t\telse if (t == Types.FLOAT) {\n\t\t\tps.setFloat(parameterIndex, GetterUtil.getFloat(value));\n\t\t}\n\t\telse if (t == Types.INTEGER) {\n\t\t\tps.setInt(parameterIndex, GetterUtil.getInteger(value));\n\t\t}\n\t\telse if (t == Types.SMALLINT) {\n\t\t\tps.setShort(parameterIndex, GetterUtil.getShort(value));\n\t\t}\n\t\telse if (t == Types.TIMESTAMP) {\n\t\t\tif (StringPool.NULL.equals(value)) {\n\t\t\t\tps.setTimestamp(parameterIndex, null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDateFormat df = DateUtil.getISOFormat();\n\n\t\t\t\tps.setTimestamp(\n\t\t\t\t\tparameterIndex, new Timestamp(df.parse(value).getTime()));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new UpgradeException(\n\t\t\t\t\"Upgrade code using unsupported class type \" + type);\n\t\t}\n\t}","id":49621,"modified_method":"public void setColumn(\n\t\t\tPreparedStatement ps, int index, Integer type, String value)\n\t\tthrows Exception {\n\n\t\tint t = type.intValue();\n\n\t\tint paramIndex = index + 1;\n\n\t\tif (t == Types.BIGINT) {\n\t\t\tps.setLong(paramIndex, GetterUtil.getLong(value));\n\t\t}\n\t\telse if (t == Types.BOOLEAN) {\n\t\t\tps.setBoolean(paramIndex, GetterUtil.getBoolean(value));\n\t\t}\n\t\telse if ((t == Types.CLOB) || (t == Types.VARCHAR)) {\n\t\t\tvalue = StringUtil.replace(value, _SAFE_CHARS[1], _SAFE_CHARS[0]);\n\n\t\t\tps.setString(paramIndex, value);\n\t\t}\n\t\telse if (t == Types.DOUBLE) {\n\t\t\tps.setDouble(paramIndex, GetterUtil.getDouble(value));\n\t\t}\n\t\telse if (t == Types.FLOAT) {\n\t\t\tps.setFloat(paramIndex, GetterUtil.getFloat(value));\n\t\t}\n\t\telse if (t == Types.INTEGER) {\n\t\t\tps.setInt(paramIndex, GetterUtil.getInteger(value));\n\t\t}\n\t\telse if (t == Types.SMALLINT) {\n\t\t\tps.setShort(paramIndex, GetterUtil.getShort(value));\n\t\t}\n\t\telse if (t == Types.TIMESTAMP) {\n\t\t\tif (StringPool.NULL.equals(value)) {\n\t\t\t\tps.setTimestamp(paramIndex, null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDateFormat df = DateUtil.getISOFormat();\n\n\t\t\t\tps.setTimestamp(\n\t\t\t\t\tparamIndex, new Timestamp(df.parse(value).getTime()));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new UpgradeException(\n\t\t\t\t\"Upgrade code using unsupported class type \" + type);\n\t\t}\n\t}","commit_id":"fbd190c57605618173e0dee3dd74044d0bb49850","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteCategory(BlogsCategory category)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Categories\n\n\t\tIterator itr = BlogsCategoryUtil.findByParentCategoryId(\n\t\t\tcategory.getCategoryId()).iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tBlogsCategory curCategory = (BlogsCategory)itr.next();\n\n\t\t\tdeleteCategory(curCategory);\n\t\t}\n\n\t\t// Entries\n\n\t\titr = BlogsEntryUtil.findByCategoryId(\n\t\t\tcategory.getCategoryId()).iterator();\n\n\t\twhile (itr.hasNext()) {\n\n\t\t\t// Entry\n\n\t\t\tBlogsEntry entry = (BlogsEntry)itr.next();\n\n\t\t\tentry.setCategoryId(BlogsCategoryImpl.DEFAULT_PARENT_CATEGORY_ID);\n\n\t\t\tBlogsEntryUtil.update(entry);\n\n\t\t\t// Lucene\n\n\t\t\ttry {\n\t\t\t\tIndexer.updateEntry(\n\t\t\t\t\tentry.getCompanyId(), entry.getGroupId(), entry.getUserId(),\n\t\t\t\t\tcategory.getCategoryId(), entry.getEntryId(),\n\t\t\t\t\tentry.getTitle(), entry.getContent());\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\t_log.error(\"Indexing \" + entry.getEntryId(), ioe);\n\t\t\t}\n\t\t}\n\n\t\t// Resources\n\n\t\tResourceLocalServiceUtil.deleteResource(\n\t\t\tcategory.getCompanyId(), BlogsCategory.class.getName(),\n\t\t\tResourceImpl.TYPE_CLASS, ResourceImpl.SCOPE_INDIVIDUAL,\n\t\t\tString.valueOf(category.getPrimaryKey()));\n\n\t\t// Category\n\n\t\tBlogsCategoryUtil.remove(category.getCategoryId());\n\t}","id":49622,"modified_method":"public void deleteCategory(BlogsCategory category)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Categories\n\n\t\tIterator itr = BlogsCategoryUtil.findByParentCategoryId(\n\t\t\tcategory.getCategoryId()).iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tBlogsCategory curCategory = (BlogsCategory)itr.next();\n\n\t\t\tdeleteCategory(curCategory);\n\t\t}\n\n\t\t// Entries\n\n\t\titr = BlogsEntryUtil.findByCategoryId(\n\t\t\tcategory.getCategoryId()).iterator();\n\n\t\twhile (itr.hasNext()) {\n\n\t\t\t// Entry\n\n\t\t\tBlogsEntry entry = (BlogsEntry)itr.next();\n\n\t\t\tentry.setCategoryId(BlogsCategoryImpl.DEFAULT_PARENT_CATEGORY_ID);\n\n\t\t\tBlogsEntryUtil.update(entry);\n\n\t\t\t// Lucene\n\n\t\t\ttry {\n\t\t\t\tIndexer.updateEntry(\n\t\t\t\t\tentry.getCompanyId(), entry.getGroupId(), entry.getUserId(),\n\t\t\t\t\tcategory.getCategoryId(), entry.getEntryId(),\n\t\t\t\t\tentry.getTitle(), entry.getContent());\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\t_log.error(\"Indexing \" + entry.getEntryId(), ioe);\n\t\t\t}\n\t\t}\n\n\t\t// Resources\n\n\t\tResourceLocalServiceUtil.deleteResource(\n\t\t\tcategory.getCompanyId(), BlogsCategory.class.getName(),\n\t\t\tResourceImpl.TYPE_CLASS, ResourceImpl.SCOPE_INDIVIDUAL,\n\t\t\tcategory.getPrimaryKey());\n\n\t\t// Category\n\n\t\tBlogsCategoryUtil.remove(category.getCategoryId());\n\t}","commit_id":"fbd190c57605618173e0dee3dd74044d0bb49850","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addCategoryResources(\n\t\t\tBlogsCategory category, boolean addCommunityPermissions,\n\t\t\tboolean addGuestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addResources(\n\t\t\tcategory.getCompanyId(), 0, category.getUserId(),\n\t\t\tBlogsCategory.class.getName(),\n\t\t\tString.valueOf(category.getPrimaryKey()), false,\n\t\t\taddCommunityPermissions, addGuestPermissions);\n\t}","id":49623,"modified_method":"public void addCategoryResources(\n\t\t\tBlogsCategory category, boolean addCommunityPermissions,\n\t\t\tboolean addGuestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addResources(\n\t\t\tcategory.getCompanyId(), 0, category.getUserId(),\n\t\t\tBlogsCategory.class.getName(), category.getPrimaryKey(), false,\n\t\t\taddCommunityPermissions, addGuestPermissions);\n\t}","commit_id":"fbd190c57605618173e0dee3dd74044d0bb49850","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addCategoryResources(\n\t\t\tBlogsCategory category, String[] communityPermissions,\n\t\t\tString[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addModelResources(\n\t\t\tcategory.getCompanyId(), 0, category.getUserId(),\n\t\t\tBlogsCategory.class.getName(),\n\t\t\tString.valueOf(category.getPrimaryKey()), communityPermissions,\n\t\t\tguestPermissions);\n\t}","id":49624,"modified_method":"public void addCategoryResources(\n\t\t\tBlogsCategory category, String[] communityPermissions,\n\t\t\tString[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addModelResources(\n\t\t\tcategory.getCompanyId(), 0, category.getUserId(),\n\t\t\tBlogsCategory.class.getName(), category.getPrimaryKey(),\n\t\t\tcommunityPermissions, guestPermissions);\n\t}","commit_id":"fbd190c57605618173e0dee3dd74044d0bb49850","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, BlogsCategory category,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\t0, BlogsCategory.class.getName(),\n\t\t\tString.valueOf(category.getPrimaryKey()), actionId);\n\t}","id":49625,"modified_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, BlogsCategory category,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\t0, BlogsCategory.class.getName(), category.getPrimaryKey(),\n\t\t\tactionId);\n\t}","commit_id":"fbd190c57605618173e0dee3dd74044d0bb49850","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addEntryResources(\n\t\t\tBlogsEntry entry, boolean addCommunityPermissions,\n\t\t\tboolean addGuestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addResources(\n\t\t\tentry.getCompanyId(), entry.getGroupId(), entry.getUserId(),\n\t\t\tBlogsEntry.class.getName(), String.valueOf(entry.getPrimaryKey()),\n\t\t\tfalse, addCommunityPermissions, addGuestPermissions);\n\t}","id":49626,"modified_method":"public void addEntryResources(\n\t\t\tBlogsEntry entry, boolean addCommunityPermissions,\n\t\t\tboolean addGuestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addResources(\n\t\t\tentry.getCompanyId(), entry.getGroupId(), entry.getUserId(),\n\t\t\tBlogsEntry.class.getName(), entry.getPrimaryKey(), false,\n\t\t\taddCommunityPermissions, addGuestPermissions);\n\t}","commit_id":"fbd190c57605618173e0dee3dd74044d0bb49850","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addEntryResources(\n\t\t\tBlogsEntry entry, String[] communityPermissions,\n\t\t\tString[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addModelResources(\n\t\t\tentry.getCompanyId(), entry.getGroupId(), entry.getUserId(),\n\t\t\tBlogsEntry.class.getName(), String.valueOf(entry.getPrimaryKey()),\n\t\t\tcommunityPermissions, guestPermissions);\n\t}","id":49627,"modified_method":"public void addEntryResources(\n\t\t\tBlogsEntry entry, String[] communityPermissions,\n\t\t\tString[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addModelResources(\n\t\t\tentry.getCompanyId(), entry.getGroupId(), entry.getUserId(),\n\t\t\tBlogsEntry.class.getName(), entry.getPrimaryKey(),\n\t\t\tcommunityPermissions, guestPermissions);\n\t}","commit_id":"fbd190c57605618173e0dee3dd74044d0bb49850","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteEntry(BlogsEntry entry)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tIndexer.deleteEntry(entry.getCompanyId(), entry.getEntryId());\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(\"Deleting index \" + entry.getEntryId(), ioe);\n\t\t}\n\n\t\t// Message boards\n\n\t\tMBMessageLocalServiceUtil.deleteDiscussionMessages(\n\t\t\tBlogsEntry.class.getName(), String.valueOf(entry.getEntryId()));\n\n\t\t// Resources\n\n\t\tResourceLocalServiceUtil.deleteResource(\n\t\t\tentry.getCompanyId(), BlogsEntry.class.getName(),\n\t\t\tResourceImpl.TYPE_CLASS, ResourceImpl.SCOPE_INDIVIDUAL,\n\t\t\tString.valueOf(entry.getPrimaryKey()));\n\n\t\t// Entry\n\n\t\tBlogsEntryUtil.remove(entry.getEntryId());\n\t}","id":49628,"modified_method":"public void deleteEntry(BlogsEntry entry)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Lucene\n\n\t\ttry {\n\t\t\tIndexer.deleteEntry(entry.getCompanyId(), entry.getEntryId());\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(\"Deleting index \" + entry.getEntryId(), ioe);\n\t\t}\n\n\t\t// Message boards\n\n\t\tMBMessageLocalServiceUtil.deleteDiscussionMessages(\n\t\t\tBlogsEntry.class.getName(), String.valueOf(entry.getEntryId()));\n\n\t\t// Resources\n\n\t\tResourceLocalServiceUtil.deleteResource(\n\t\t\tentry.getCompanyId(), BlogsEntry.class.getName(),\n\t\t\tResourceImpl.TYPE_CLASS, ResourceImpl.SCOPE_INDIVIDUAL,\n\t\t\tentry.getPrimaryKey());\n\n\t\t// Entry\n\n\t\tBlogsEntryUtil.remove(entry.getEntryId());\n\t}","commit_id":"fbd190c57605618173e0dee3dd74044d0bb49850","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, BlogsEntry entry,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tentry.getGroupId(), BlogsEntry.class.getName(),\n\t\t\tString.valueOf(entry.getPrimaryKey()), actionId);\n\t}","id":49629,"modified_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, BlogsEntry entry,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tentry.getGroupId(), BlogsEntry.class.getName(),\n\t\t\tentry.getPrimaryKey(), actionId);\n\t}","commit_id":"fbd190c57605618173e0dee3dd74044d0bb49850","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateCategory(ActionRequest req) throws Exception {\n\t\tlong categoryId = ParamUtil.getLong(req, \"categoryId\");\n\n\t\tlong parentCategoryId = ParamUtil.getLong(\n\t\t\treq, \"parentCategoryId\",\n\t\t\tBlogsCategoryImpl.DEFAULT_PARENT_CATEGORY_ID);\n\t\tString name = ParamUtil.getString(req, \"name\");\n\t\tString description = ParamUtil.getString(req, \"description\");\n\n\t\tString[] communityPermissions = req.getParameterValues(\n\t\t\t\"communityPermissions\");\n\t\tString[] guestPermissions = req.getParameterValues(\n\t\t\t\"guestPermissions\");\n\n\t\tif (categoryId <= 0) {\n\n\t\t\t// Add category\n\n\t\t\tBlogsCategoryServiceUtil.addCategory(\n\t\t\t\tparentCategoryId, name, description, communityPermissions,\n\t\t\t\tguestPermissions);\n\t\t}\n\t\telse {\n\n\t\t\t// Update category\n\n\t\t\tBlogsCategoryServiceUtil.updateCategory(\n\t\t\t\tcategoryId, parentCategoryId, name, description);\n\t\t}\n\t}","id":49630,"modified_method":"protected void updateCategory(ActionRequest req) throws Exception {\n\t\tlong categoryId = ParamUtil.getLong(req, \"categoryId\");\n\n\t\tlong parentCategoryId = ParamUtil.getLong(req, \"parentCategoryId\");\n\t\tString name = ParamUtil.getString(req, \"name\");\n\t\tString description = ParamUtil.getString(req, \"description\");\n\n\t\tString[] communityPermissions = req.getParameterValues(\n\t\t\t\"communityPermissions\");\n\t\tString[] guestPermissions = req.getParameterValues(\n\t\t\t\"guestPermissions\");\n\n\t\tif (categoryId <= 0) {\n\n\t\t\t// Add category\n\n\t\t\tBlogsCategoryServiceUtil.addCategory(\n\t\t\t\tparentCategoryId, name, description, communityPermissions,\n\t\t\t\tguestPermissions);\n\t\t}\n\t\telse {\n\n\t\t\t// Update category\n\n\t\t\tBlogsCategoryServiceUtil.updateCategory(\n\t\t\t\tcategoryId, parentCategoryId, name, description);\n\t\t}\n\t}","commit_id":"fbd190c57605618173e0dee3dd74044d0bb49850","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void _upgradeResources() throws Exception {\n\t\tTempScopeUpgradeColumnImpl upgradeScopeColumn =\n\t\t\tnew TempScopeUpgradeColumnImpl();\n\n\t\tUpgradeColumn upgradePrimKeyColumn =\n\t\t\tnew PrimKeyUpgradeColumnImpl(\n\t\t\t\tupgradeScopeColumn, _groupIdMapper, _ownerIdMapper);\n\n\t\tUpgradeTable upgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tResourceImpl.TABLE_NAME, ResourceImpl.TABLE_COLUMNS,\n\t\t\tupgradeScopeColumn, upgradePrimKeyColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t/*\n\t\tResourceUtil.upgradePrimKey(\n\t\t\t_groupIdMapper, StringPool.BLANK, ResourceImpl.SCOPE_GROUP,\n\t\t\tStringPool.BLANK, true);\n\n\t\tResourceUtil.upgradePrimKey(new PrimKeyLayoutIdMapper(_groupIdMapper),\n\t\t\tStringPool.BLANK, ResourceImpl.SCOPE_INDIVIDUAL,\n\t\t\tLayoutImpl.PUBLIC + StringPool.PERCENT, false);\n\n\t\tResourceUtil.upgradePrimKey(new PrimKeyLayoutIdMapper(_groupIdMapper),\n\t\t\tStringPool.BLANK, ResourceImpl.SCOPE_INDIVIDUAL,\n\t\t\tLayoutImpl.PRIVATE + StringPool.PERCENT, false);\n\n\t\tResourceUtil.upgradePrimKey(\n\t\t\tnew PrimKeyGroupOrOwnerIdMapper(_groupIdMapper, true),\n\t\t\tStringPool.BLANK, ResourceImpl.SCOPE_INDIVIDUAL, \"%groupId=%\",\n\t\t\tfalse);\n\n\t\tResourceUtil.upgradePrimKey(\n\t\t\tnew PrimKeyGroupOrOwnerIdMapper(_ownerIdMapper, false),\n\t\t\tStringPool.BLANK, ResourceImpl.SCOPE_INDIVIDUAL, \"%ownerId=%\",\n\t\t\tfalse);\n\t\t */\n\t}","id":49631,"modified_method":"private void _upgradeResources() throws Exception {\n\t\tTempScopeUpgradeColumnImpl upgradeScopeColumn =\n\t\t\tnew TempScopeUpgradeColumnImpl();\n\n\t\tUpgradeColumn upgradePrimKeyColumn =\n\t\t\tnew PrimKeyUpgradeColumnImpl(\n\t\t\t\tupgradeScopeColumn, _groupIdMapper, _ownerIdMapper);\n\n\t\tUpgradeTable upgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tResourceImpl.TABLE_NAME, ResourceImpl.TABLE_COLUMNS,\n\t\t\tupgradeScopeColumn, upgradePrimKeyColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t/*\n\t\tResourceUtil.upgradePrimKey(\n\t\t\t_groupIdMapper, StringPool.BLANK, ResourceImpl.SCOPE_GROUP,\n\t\t\tStringPool.BLANK, true);\n\n\t\tResourceUtil.upgradePrimKey(new PrimKeyLayoutIdMapper(_groupIdMapper),\n\t\t\tStringPool.BLANK, ResourceImpl.SCOPE_INDIVIDUAL,\n\t\t\tLayoutImpl.PUBLIC + StringPool.PERCENT, false);\n\n\t\tResourceUtil.upgradePrimKey(new PrimKeyLayoutIdMapper(_groupIdMapper),\n\t\t\tStringPool.BLANK, ResourceImpl.SCOPE_INDIVIDUAL,\n\t\t\tLayoutImpl.PRIVATE + StringPool.PERCENT, false);\n\n\t\tResourceUtil.upgradePrimKey(\n\t\t\tnew PrimKeyGroupOrOwnerIdMapper(_groupIdMapper, true),\n\t\t\tStringPool.BLANK, ResourceImpl.SCOPE_INDIVIDUAL, \"%groupId=%\",\n\t\t\tfalse);\n\n\t\tResourceUtil.upgradePrimKey(\n\t\t\tnew PrimKeyGroupOrOwnerIdMapper(_ownerIdMapper, false),\n\t\t\tStringPool.BLANK, ResourceImpl.SCOPE_INDIVIDUAL, \"%ownerId=%\",\n\t\t\tfalse);\n\t\t */\n\t}","commit_id":"fbd190c57605618173e0dee3dd74044d0bb49850","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void _upgradeGroupIds() throws Exception {\n\n\t\t// Group_\n\n\t\tPKUpgradeColumnImpl pkUpgradeColumn = new PKUpgradeColumnImpl(0, true);\n\n\t\tUpgradeTable upgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tGroupImpl.TABLE_NAME, GroupImpl.TABLE_COLUMNS, pkUpgradeColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// Groups_Orgs\n\n\t\t_groupIdMapper = pkUpgradeColumn.getValueMapper();\n\n\t\t_groupIdMapper.appendException(\n\t\t\tnew Long(GroupImpl.DEFAULT_PARENT_GROUP_ID));\n\t\t_groupIdMapper.appendException(new Long(0));\n\t\t_groupIdMapper.appendException(StringPool.NULL);\n\n\t\t_ownerIdMapper = new OwnerIdMapper(_groupIdMapper);\n\n\t\tUpgradeColumn upgradeGroupIdColumn =\n\t\t\tnew SwapUpgradeColumnImpl(\"groupId\", _groupIdMapper);\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\t_TABLE_GROUPS_ORGS, _COLUMNS_GROUPS_ORGS, upgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// Groups_Permissions\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\t_TABLE_GROUPS_PERMISSIONS, _COLUMNS_GROUPS_PERMISSIONS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// Groups_Roles\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\t_TABLE_GROUPS_ROLES, _COLUMNS_GROUPS_ROLES,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// Groups_UserGroups\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\t_TABLE_GROUPS_USERGROUPS, _COLUMNS_GROUPS_USERGROUPS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// OrgGroupPermission\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tOrgGroupPermissionImpl.TABLE_NAME,\n\t\t\tOrgGroupPermissionImpl.TABLE_COLUMNS, upgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// OrgGroupRole\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tOrgGroupRoleImpl.TABLE_NAME, OrgGroupRoleImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// Users_Groups\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\t_TABLE_USERS_GROUPS, _COLUMNS_USERS_GROUPS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// BlogsEntry\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tBlogsEntryImpl.TABLE_NAME, BlogsEntryImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// BookmarksFolder\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tBookmarksFolderImpl.TABLE_NAME, BookmarksFolderImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// CalEvent\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tCalEventImpl.TABLE_NAME, CalEventImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// DLFolder\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tDLFolderImpl.TABLE_NAME, DLFolderImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// IGFolder\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tIGFolderImpl.TABLE_NAME, IGFolderImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// JournalArticle\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tJournalArticleImpl.TABLE_NAME, JournalArticleImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// JournalStructure\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tJournalStructureImpl.TABLE_NAME, JournalStructureImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// JournalTemplate\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tJournalTemplateImpl.TABLE_NAME, JournalTemplateImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// MBCategory\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tMBCategoryImpl.TABLE_NAME, MBCategoryImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// MBStatsUser\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tMBStatsUserImpl.TABLE_NAME, MBStatsUserImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// PollsQuestion\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tPollsQuestionImpl.TABLE_NAME, PollsQuestionImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// ShoppingCart\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tShoppingCartImpl.TABLE_NAME, ShoppingCartImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// ShoppingCategory\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tShoppingCategoryImpl.TABLE_NAME, ShoppingCategoryImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// ShoppingCoupon\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tShoppingCouponImpl.TABLE_NAME, ShoppingCouponImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// ShoppingOrder\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tShoppingOrderImpl.TABLE_NAME, ShoppingOrderImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// WikiNode\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tWikiNodeImpl.TABLE_NAME, WikiNodeImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\t}","id":49632,"modified_method":"private void _upgradeGroupIds() throws Exception {\n\n\t\t// Group_\n\n\t\tPKUpgradeColumnImpl pkUpgradeColumn = new PKUpgradeColumnImpl(0, true);\n\n\t\tUpgradeTable upgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tGroupImpl.TABLE_NAME, GroupImpl.TABLE_COLUMNS, pkUpgradeColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// Groups_Orgs\n\n\t\t_groupIdMapper = pkUpgradeColumn.getValueMapper();\n\n\t\t_groupIdMapper.appendException(\n\t\t\tnew Long(GroupImpl.DEFAULT_PARENT_GROUP_ID));\n\t\t_groupIdMapper.appendException(new Long(0));\n\t\t_groupIdMapper.appendException(StringPool.NULL);\n\n\t\t_ownerIdMapper = new OwnerIdMapper(_groupIdMapper);\n\n\t\tUpgradeColumn upgradeGroupIdColumn =\n\t\t\tnew SwapUpgradeColumnImpl(\"groupId\", _groupIdMapper);\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\t_TABLE_GROUPS_ORGS, _COLUMNS_GROUPS_ORGS, upgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// Groups_Permissions\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\t_TABLE_GROUPS_PERMISSIONS, _COLUMNS_GROUPS_PERMISSIONS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// Groups_Roles\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\t_TABLE_GROUPS_ROLES, _COLUMNS_GROUPS_ROLES,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// Groups_UserGroups\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\t_TABLE_GROUPS_USERGROUPS, _COLUMNS_GROUPS_USERGROUPS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// OrgGroupPermission\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tOrgGroupPermissionImpl.TABLE_NAME,\n\t\t\tOrgGroupPermissionImpl.TABLE_COLUMNS, upgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// OrgGroupRole\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tOrgGroupRoleImpl.TABLE_NAME, OrgGroupRoleImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// Users_Groups\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\t_TABLE_USERS_GROUPS, _COLUMNS_USERS_GROUPS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// BlogsEntry\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tBlogsEntryImpl.TABLE_NAME, BlogsEntryImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// BookmarksFolder\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tBookmarksFolderImpl.TABLE_NAME, BookmarksFolderImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// CalEvent\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tCalEventImpl.TABLE_NAME, CalEventImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// DLFolder\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tDLFolderImpl.TABLE_NAME, DLFolderImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// IGFolder\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tIGFolderImpl.TABLE_NAME, IGFolderImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// JournalArticle\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tJournalArticleImpl.TABLE_NAME, JournalArticleImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// JournalStructure\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tJournalStructureImpl.TABLE_NAME, JournalStructureImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// JournalTemplate\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tJournalTemplateImpl.TABLE_NAME, JournalTemplateImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// MBCategory\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tMBCategoryImpl.TABLE_NAME, MBCategoryImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// MBStatsUser\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tMBStatsUserImpl.TABLE_NAME, MBStatsUserImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// PollsQuestion\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tPollsQuestionImpl.TABLE_NAME, PollsQuestionImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// ShoppingCart\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tShoppingCartImpl.TABLE_NAME, ShoppingCartImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// ShoppingCategory\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tShoppingCategoryImpl.TABLE_NAME, ShoppingCategoryImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// ShoppingCoupon\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tShoppingCouponImpl.TABLE_NAME, ShoppingCouponImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// ShoppingOrder\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tShoppingOrderImpl.TABLE_NAME, ShoppingOrderImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// WikiNode\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tWikiNodeImpl.TABLE_NAME, WikiNodeImpl.TABLE_COLUMNS,\n\t\t\tupgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\t}","commit_id":"fbd190c57605618173e0dee3dd74044d0bb49850","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void _upgradeOwnerIds() throws Exception {\n\t\tUpgradeColumn upgradeOwnerIdColumn =\n\t\t\tnew SwapUpgradeColumnImpl(\"ownerId\", _ownerIdMapper);\n\n\t\tUpgradeColumn upgradeGroupIdColumn =\n\t\t\tnew SwapUpgradeColumnImpl(\"groupId\", _groupIdMapper);\n\n\t\t// Layout\n\n\t\tUpgradeTable upgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tLayoutImpl.TABLE_NAME, LayoutImpl.TABLE_COLUMNS,\n\t\t\tupgradeOwnerIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// LayoutSet\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tLayoutSetImpl.TABLE_NAME, LayoutSetImpl.TABLE_COLUMNS,\n\t\t\tupgradeOwnerIdColumn, upgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// PortletPreferences\n\n\t\tUpgradeColumn upgradePreferencesColumn =\n\t\t\tnew PreferencesUpgradeColumnImpl(_groupIdMapper);\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tPortletPreferencesImpl.TABLE_NAME,\n\t\t\tPortletPreferencesImpl.TABLE_COLUMNS,\n\t\t\tupgradeOwnerIdColumn, upgradePreferencesColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// JournalContentSearch\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tJournalContentSearchImpl.TABLE_NAME,\n\t\t\tJournalContentSearchImpl.TABLE_COLUMNS, upgradeGroupIdColumn,\n\t\t\tupgradeOwnerIdColumn);\n\n\t\tupgradeTable.updateTable();\n\t}","id":49633,"modified_method":"private void _upgradeOwnerIds() throws Exception {\n\t\tUpgradeColumn upgradeOwnerIdColumn =\n\t\t\tnew SwapUpgradeColumnImpl(\"ownerId\", _ownerIdMapper);\n\n\t\tUpgradeColumn upgradeGroupIdColumn =\n\t\t\tnew SwapUpgradeColumnImpl(\"groupId\", _groupIdMapper);\n\n\t\t// Layout\n\n\t\tUpgradeTable upgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tLayoutImpl.TABLE_NAME, LayoutImpl.TABLE_COLUMNS,\n\t\t\tupgradeOwnerIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// LayoutSet\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tLayoutSetImpl.TABLE_NAME, LayoutSetImpl.TABLE_COLUMNS,\n\t\t\tupgradeOwnerIdColumn, upgradeGroupIdColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// PortletPreferences\n\n\t\tUpgradeColumn upgradePreferencesColumn =\n\t\t\tnew PreferencesUpgradeColumnImpl(_groupIdMapper);\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tPortletPreferencesImpl.TABLE_NAME,\n\t\t\tPortletPreferencesImpl.TABLE_COLUMNS,\n\t\t\tupgradeOwnerIdColumn, upgradePreferencesColumn);\n\n\t\tupgradeTable.updateTable();\n\n\t\t// JournalContentSearch\n\n\t\tupgradeTable = new DefaultUpgradeTableImpl(\n\t\t\tJournalContentSearchImpl.TABLE_NAME,\n\t\t\tJournalContentSearchImpl.TABLE_COLUMNS, upgradeGroupIdColumn,\n\t\t\tupgradeOwnerIdColumn);\n\n\t\tupgradeTable.updateTable();\n\t}","commit_id":"fbd190c57605618173e0dee3dd74044d0bb49850","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addEntryResources(\n\t\t\tBookmarksFolder folder, BookmarksEntry entry,\n\t\t\tString[] communityPermissions, String[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addModelResources(\n\t\t\tentry.getCompanyId(), folder.getGroupId(), entry.getUserId(),\n\t\t\tBookmarksEntry.class.getName(),\n\t\t\tString.valueOf(entry.getPrimaryKey()), communityPermissions,\n\t\t\tguestPermissions);\n\t}","id":49634,"modified_method":"public void addEntryResources(\n\t\t\tBookmarksFolder folder, BookmarksEntry entry,\n\t\t\tString[] communityPermissions, String[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addModelResources(\n\t\t\tentry.getCompanyId(), folder.getGroupId(), entry.getUserId(),\n\t\t\tBookmarksEntry.class.getName(), entry.getPrimaryKey(),\n\t\t\tcommunityPermissions, guestPermissions);\n\t}","commit_id":"79694a599b7ccbaafaf1980920a68b5b53850775","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addEntryResources(\n\t\t\tBookmarksFolder folder, BookmarksEntry entry,\n\t\t\tboolean addCommunityPermissions, boolean addGuestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addResources(\n\t\t\tentry.getCompanyId(), folder.getGroupId(), entry.getUserId(),\n\t\t\tBookmarksEntry.class.getName(),\n\t\t\tString.valueOf(entry.getPrimaryKey()), false,\n\t\t\taddCommunityPermissions, addGuestPermissions);\n\t}","id":49635,"modified_method":"public void addEntryResources(\n\t\t\tBookmarksFolder folder, BookmarksEntry entry,\n\t\t\tboolean addCommunityPermissions, boolean addGuestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addResources(\n\t\t\tentry.getCompanyId(), folder.getGroupId(), entry.getUserId(),\n\t\t\tBookmarksEntry.class.getName(), entry.getPrimaryKey(), false,\n\t\t\taddCommunityPermissions, addGuestPermissions);\n\t}","commit_id":"79694a599b7ccbaafaf1980920a68b5b53850775","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteEntry(BookmarksEntry entry)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Tags\n\n\t\tTagsAssetLocalServiceUtil.deleteAsset(\n\t\t\tBookmarksEntry.class.getName(),\n\t\t\tString.valueOf(entry.getPrimaryKey()));\n\n\t\t// Resources\n\n\t\tResourceLocalServiceUtil.deleteResource(\n\t\t\tentry.getCompanyId(), BookmarksEntry.class.getName(),\n\t\t\tResourceImpl.TYPE_CLASS, ResourceImpl.SCOPE_INDIVIDUAL,\n\t\t\tString.valueOf(entry.getPrimaryKey()));\n\n\t\t// Entry\n\n\t\tBookmarksEntryUtil.remove(entry.getEntryId());\n\t}","id":49636,"modified_method":"public void deleteEntry(BookmarksEntry entry)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Tags\n\n\t\tTagsAssetLocalServiceUtil.deleteAsset(\n\t\t\tBookmarksEntry.class.getName(),\n\t\t\tString.valueOf(entry.getPrimaryKey()));\n\n\t\t// Resources\n\n\t\tResourceLocalServiceUtil.deleteResource(\n\t\t\tentry.getCompanyId(), BookmarksEntry.class.getName(),\n\t\t\tResourceImpl.TYPE_CLASS, ResourceImpl.SCOPE_INDIVIDUAL,\n\t\t\tentry.getPrimaryKey());\n\n\t\t// Entry\n\n\t\tBookmarksEntryUtil.remove(entry.getEntryId());\n\t}","commit_id":"79694a599b7ccbaafaf1980920a68b5b53850775","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, BookmarksEntry entry,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tBookmarksFolder folder = entry.getFolder();\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tfolder.getGroupId(), BookmarksEntry.class.getName(),\n\t\t\tString.valueOf(entry.getPrimaryKey()), actionId);\n\t}","id":49637,"modified_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, BookmarksEntry entry,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\tBookmarksFolder folder = entry.getFolder();\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tfolder.getGroupId(), BookmarksEntry.class.getName(),\n\t\t\tentry.getPrimaryKey(), actionId);\n\t}","commit_id":"79694a599b7ccbaafaf1980920a68b5b53850775","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addFolderResources(\n\t\t\tBookmarksFolder folder, String[] communityPermissions,\n\t\t\tString[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addModelResources(\n\t\t\tfolder.getCompanyId(), folder.getGroupId(), folder.getUserId(),\n\t\t\tBookmarksFolder.class.getName(),\n\t\t\tString.valueOf(folder.getPrimaryKey()), communityPermissions,\n\t\t\tguestPermissions);\n\t}","id":49638,"modified_method":"public void addFolderResources(\n\t\t\tBookmarksFolder folder, String[] communityPermissions,\n\t\t\tString[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addModelResources(\n\t\t\tfolder.getCompanyId(), folder.getGroupId(), folder.getUserId(),\n\t\t\tBookmarksFolder.class.getName(), folder.getPrimaryKey(),\n\t\t\tcommunityPermissions, guestPermissions);\n\t}","commit_id":"79694a599b7ccbaafaf1980920a68b5b53850775","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addFolderResources(\n\t\t\tBookmarksFolder folder, boolean addCommunityPermissions,\n\t\t\tboolean addGuestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addResources(\n\t\t\tfolder.getCompanyId(), folder.getGroupId(), folder.getUserId(),\n\t\t\tBookmarksFolder.class.getName(),\n\t\t\tString.valueOf(folder.getPrimaryKey()), false,\n\t\t\taddCommunityPermissions, addGuestPermissions);\n\t}","id":49639,"modified_method":"public void addFolderResources(\n\t\t\tBookmarksFolder folder, boolean addCommunityPermissions,\n\t\t\tboolean addGuestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tResourceLocalServiceUtil.addResources(\n\t\t\tfolder.getCompanyId(), folder.getGroupId(), folder.getUserId(),\n\t\t\tBookmarksFolder.class.getName(), folder.getPrimaryKey(), false,\n\t\t\taddCommunityPermissions, addGuestPermissions);\n\t}","commit_id":"79694a599b7ccbaafaf1980920a68b5b53850775","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFolder(BookmarksFolder folder)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Folders\n\n\t\tIterator itr = BookmarksFolderUtil.findByG_P(\n\t\t\tfolder.getGroupId(), folder.getFolderId()).iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tBookmarksFolder curFolder = (BookmarksFolder)itr.next();\n\n\t\t\tdeleteFolder(curFolder);\n\t\t}\n\n\t\t// Entries\n\n\t\tBookmarksEntryLocalServiceUtil.deleteEntries(folder.getFolderId());\n\n\t\t// Resources\n\n\t\tResourceLocalServiceUtil.deleteResource(\n\t\t\tfolder.getCompanyId(), BookmarksFolder.class.getName(),\n\t\t\tResourceImpl.TYPE_CLASS, ResourceImpl.SCOPE_INDIVIDUAL,\n\t\t\tString.valueOf(folder.getPrimaryKey()));\n\n\t\t// Folder\n\n\t\tBookmarksFolderUtil.remove(folder.getFolderId());\n\t}","id":49640,"modified_method":"public void deleteFolder(BookmarksFolder folder)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Folders\n\n\t\tIterator itr = BookmarksFolderUtil.findByG_P(\n\t\t\tfolder.getGroupId(), folder.getFolderId()).iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tBookmarksFolder curFolder = (BookmarksFolder)itr.next();\n\n\t\t\tdeleteFolder(curFolder);\n\t\t}\n\n\t\t// Entries\n\n\t\tBookmarksEntryLocalServiceUtil.deleteEntries(folder.getFolderId());\n\n\t\t// Resources\n\n\t\tResourceLocalServiceUtil.deleteResource(\n\t\t\tfolder.getCompanyId(), BookmarksFolder.class.getName(),\n\t\t\tResourceImpl.TYPE_CLASS, ResourceImpl.SCOPE_INDIVIDUAL,\n\t\t\tfolder.getPrimaryKey());\n\n\t\t// Folder\n\n\t\tBookmarksFolderUtil.remove(folder.getFolderId());\n\t}","commit_id":"79694a599b7ccbaafaf1980920a68b5b53850775","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, BookmarksFolder folder,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tfolder.getGroupId(), BookmarksFolder.class.getName(),\n\t\t\tString.valueOf(folder.getPrimaryKey()), actionId);\n\t}","id":49641,"modified_method":"public static boolean contains(\n\t\t\tPermissionChecker permissionChecker, BookmarksFolder folder,\n\t\t\tString actionId)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tfolder.getGroupId(), BookmarksFolder.class.getName(),\n\t\t\tfolder.getPrimaryKey(), actionId);\n\t}","commit_id":"79694a599b7ccbaafaf1980920a68b5b53850775","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void upgrade() throws UpgradeException {\n\t\t_log.info(\"Upgrading\");\n\n\t\tupgrade(new UpgradeAddress());\n\t\tupgrade(new UpgradeBookmarks());\n\t\tupgrade(new UpgradeBlogs());\n\t\tupgrade(new UpgradeCalendar());\n\t\tupgrade(new UpgradeEmailAddress());\n\t\tupgrade(new UpgradeGroup());\n\t\tupgrade(new UpgradePermission());\n\t\tupgrade(new UpgradePhone());\n\t\tupgrade(new UpgradeWebsite());\n\t}","id":49642,"modified_method":"public void upgrade() throws UpgradeException {\n\t\t_log.info(\"Upgrading\");\n\n\t\tupgrade(new UpgradeAddress());\n\t\tupgrade(new UpgradeBlogs());\n\t\tupgrade(new UpgradeBookmarks());\n\t\tupgrade(new UpgradeCalendar());\n\t\tupgrade(new UpgradeEmailAddress());\n\t\tupgrade(new UpgradeGroup());\n\t\tupgrade(new UpgradePermission());\n\t\tupgrade(new UpgradePhone());\n\t\tupgrade(new UpgradeWebsite());\n\t}","commit_id":"79694a599b7ccbaafaf1980920a68b5b53850775","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n    public void testGetSlingIdFromTooShortData()\n            throws IOException {\n        String data = RandomStringUtils.randomAscii(8); // 8 byte long string\n        writeSlingId(slingIdFile, optionsFile, data);\n        String slingId =  readSlingId(slingIdFile, optionsFile);\n        Assert.assertNotNull(slingId);\n        Assert.assertNotEquals(SLING_ID, slingId);\n    }","id":49643,"modified_method":"@Test\n    public void testGetSlingIdFromTooShortData()\n            throws IOException {\n        final String data = RandomStringUtils.randomAscii(8); // 8 byte long string\n        SlingIdUtil.writeSlingId(slingIdFile, data);\n        final SlingSettingsService slingSettingsService = getSlingSettings(slingIdFile, optionsFile);\n\n        final String slingId = slingSettingsService.getSlingId();\n        Assert.assertNotNull(slingId);\n        Assert.assertNotEquals(SLING_ID, slingId);\n    }","commit_id":"9ea79b4f518ef9a94f8ad0eeccee56905cebd7ca","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testGenerateSlingId()\n            throws IOException {\n        String slingId =  readSlingId(slingIdFile, optionsFile);\n        Assert.assertNotNull(slingId);\n    }","id":49644,"modified_method":"@Test\n    public void testGetSlingIdCreating()\n            throws IOException {\n        final SlingSettingsService slingSettingsService = getSlingSettings(slingIdFile, optionsFile);\n\n        final String slingId = slingSettingsService.getSlingId();\n        Assert.assertNotNull(slingId);\n    }","commit_id":"9ea79b4f518ef9a94f8ad0eeccee56905cebd7ca","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testGetLongSlingIdFromTooLargeData()\n            throws IOException {\n        String data = SLING_ID + RandomStringUtils.randomAscii(1024 * 1024); // 1MB long random String\n        writeSlingId(slingIdFile, optionsFile, data);\n        String slingId =  readSlingId(slingIdFile, optionsFile);\n        Assert.assertNotNull(slingId);\n        Assert.assertEquals(SLING_ID, slingId);\n    }","id":49645,"modified_method":"@Test\n    public void testGetSlingIdFromTooLargeData()\n            throws IOException {\n        final String data = SLING_ID + RandomStringUtils.randomAscii(1024 * 1024); // 1MB long random String\n        SlingIdUtil.writeSlingId(slingIdFile, data);\n        final SlingSettingsService slingSettingsService = getSlingSettings(slingIdFile, optionsFile);\n\n        final String slingId = slingSettingsService.getSlingId();\n        Assert.assertNotNull(slingId);\n        Assert.assertEquals(SLING_ID, slingId);\n    }","commit_id":"9ea79b4f518ef9a94f8ad0eeccee56905cebd7ca","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testGetSlingId()\n            throws IOException {\n        writeSlingId(slingIdFile, optionsFile, SLING_ID);\n        String generated =  readSlingId(slingIdFile, optionsFile);\n        Assert.assertNotNull(generated);\n        Assert.assertEquals(SLING_ID, generated);\n        String slingId = readSlingId(slingIdFile, optionsFile);\n        Assert.assertNotNull(slingId);\n        Assert.assertEquals(generated, slingId);\n    }","id":49646,"modified_method":"@Test\n    public void testGetSlingIdExisting()\n            throws IOException {\n        SlingIdUtil.writeSlingId(slingIdFile, SLING_ID);\n        final SlingSettingsService slingSettingsService = getSlingSettings(slingIdFile, optionsFile);\n\n        final String slingId = slingSettingsService.getSlingId();\n        Assert.assertNotNull(slingId);\n        Assert.assertEquals(SLING_ID, slingId);\n    }","commit_id":"9ea79b4f518ef9a94f8ad0eeccee56905cebd7ca","url":"https://github.com/apache/sling"},{"original_method":"/**\n\t * Specify the type that the located JNDI object is supposed\n\t * to be assignable to, if any.\n\t */\n\tpublic void setExpectedType(Class expectedType) {\n\t\tthis.expectedType = expectedType;\n\t}","id":49647,"modified_method":"/**\n\t * Specify the type that the located JNDI object is supposed\n\t * to be assignable to, if any.\n\t */\n\tpublic void setExpectedType(Class<?> expectedType) {\n\t\tthis.expectedType = expectedType;\n\t}","commit_id":"59d2d35f4a567d0ef56809e9505aeaa334c2013a","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Gets the Formatter with the user-specific settings applied to thefrom the base <code>formatter<\/code>.\n\t * @param formatter the base formatter that establishes default formatting rules, generally user independent\n\t * @param locale the current user locale (may be null if not known)\n\t * @return the user's DateTimeFormatter\n\t */\n\tpublic static DateTimeFormatter getFormatter(DateTimeFormatter formatter, Locale locale) {\n\t\tif (locale != null) {\n\t\t\tformatter = formatter.withLocale(locale);\n\t\t}\n\t\tJodaTimeContext context = getJodaTimeContext();\n\t\treturn (context != null ? context.getFormatter(formatter) : formatter);\n\t}","id":49648,"modified_method":"/**\n\t * Obtain a DateTimeFormatter with user-specific settings applied to the given base Formatter.\n\t * @param formatter the base formatter that establishes default formatting rules\n\t * (generally user independent)\n\t * @param locale the current user locale (may be <code>null<\/code> if not known)\n\t * @return the user-specific DateTimeFormatter\n\t */\n\tpublic static DateTimeFormatter getFormatter(DateTimeFormatter formatter, Locale locale) {\n\t\tDateTimeFormatter formatterToUse = (locale != null ? formatter.withLocale(locale) : formatter);\n\t\tJodaTimeContext context = getJodaTimeContext();\n\t\treturn (context != null ? context.getFormatter(formatterToUse) : formatterToUse);\n\t}","commit_id":"59d2d35f4a567d0ef56809e9505aeaa334c2013a","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public FormatDateTimeFormatter(String format, DateTimeFormatter parser, DateTimeFormatter printer, Locale locale) {\n        this.format = format;\n        this.locale = locale;\n        this.printer = locale == null ? printer : printer.withLocale(locale);\n        this.parser = locale == null ? parser : parser.withLocale(locale);\n    }","id":49649,"modified_method":"public FormatDateTimeFormatter(String format, DateTimeFormatter parser, DateTimeFormatter printer, Locale locale) {\n        this.format = format;\n        this.locale = locale;\n        this.printer = locale == null ? printer.withDefaultYear(1970) : printer.withLocale(locale).withDefaultYear(1970);\n        this.parser = locale == null ? parser.withDefaultYear(1970) : parser.withLocale(locale).withDefaultYear(1970);\n    }","commit_id":"56b394170653ee590cf9908509be00fab690d918","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            int eventIdentifier, String resource, TransactionStream transactionStream )\n    {\n        throw new UnsupportedOperationException();\n    }","id":49650,"modified_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            int eventIdentifier, String resource, TransactionStream transactionStream )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            XaDataSource dataSource = getConfig().getTxModule().getXaDataSourceManager()\n                    .getXaDataSource( resource );\n            // Always exactly one transaction (ReadableByteChannel)\n            final long txId = dataSource.applyPreparedTransaction(\n                    transactionStream.getChannels().iterator().next() );\n            Predicate<Long> notThisTx = new Predicate<Long>()\n            {\n                public boolean accept( Long item )\n                {\n                    return item != txId;\n                }\n            };\n            return packResponse( context, txId, notThisTx );\n        }\n        catch ( IOException e )\n        {\n            return new FailedResponse<Long>();\n        }\n        finally\n        {\n            // Since the master-transaction carries no actual state, just locks\n            // we would like to release the locks... and it's best done by just\n            // rolling back the tx\n            rollbackThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"f6611e9b57f484d8a0272c2c9801bbbbe134a034","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<LockResult> acquireWriteLock( SlaveContext context, int eventIdentifier,\n            Node... nodes )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Node node : nodes )\n            {\n                lockManager.getWriteLock( node );\n                lockReleaser.addLockToTransaction( node, LockType.WRITE );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStream() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStream() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStream() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","id":49651,"modified_method":"public Response<LockResult> acquireWriteLock( SlaveContext context, int eventIdentifier,\n            Node... nodes )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Node node : nodes )\n            {\n                lockManager.getWriteLock( node );\n                lockReleaser.addLockToTransaction( node, LockType.WRITE );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStreams() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStreams() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStreams() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"f6611e9b57f484d8a0272c2c9801bbbbe134a034","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Integer> createRelationshipType( SlaveContext context, String name )\n    {\n        // Does this type exist locally?\n        Integer id = getConfig().getRelationshipTypeHolder().getIdFor( name );\n        if ( id != null )\n        {\n            // OK, return\n            return new Response<Integer>( id, new TransactionStream() );\n        }\n        \n        // No? Create it then\n        Config config = getConfig();\n        id = config.getRelationshipTypeCreator().getOrCreate( txManager,\n                config.getIdGeneratorModule().getIdGenerator(),\n                config.getPersistenceModule().getPersistenceManager(), name );\n        // TODO Include the transaction which created it in the tx stream\n        return new Response<Integer>( id, new TransactionStream() );\n    }","id":49652,"modified_method":"public Response<Integer> createRelationshipType( SlaveContext context, String name )\n    {\n        // Does this type exist locally?\n        Integer id = getConfig().getRelationshipTypeHolder().getIdFor( name );\n        if ( id != null )\n        {\n            // OK, return\n            return new Response<Integer>( id, new TransactionStreams() );\n        }\n        \n        // No? Create it then\n        Config config = getConfig();\n        id = config.getRelationshipTypeCreator().getOrCreate( txManager,\n                config.getIdGeneratorModule().getIdGenerator(),\n                config.getPersistenceModule().getPersistenceManager(), name );\n        return packResponse( context, id, ALL );\n    }","commit_id":"f6611e9b57f484d8a0272c2c9801bbbbe134a034","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Void> rollbackTransaction( SlaveContext context, int eventIdentifier )\n    {\n        TxIdElement txId = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( txId );\n        try\n        {\n            Transaction tx = transactions.get( txId );\n            if ( tx == null )\n            {\n                throw new RuntimeException( \"Shouldn't happen\" );\n            }\n            txManager.rollback();\n            return new Response<Void>( null, new TransactionStream() );\n        }\n        catch ( IllegalStateException e )\n        {\n            throw new RuntimeException( e );\n        }\n        catch ( SecurityException e )\n        {\n            throw new RuntimeException( e );\n        }\n        catch ( SystemException e )\n        {\n            throw new RuntimeException( e );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","id":49653,"modified_method":"public Response<Void> rollbackTransaction( SlaveContext context, int eventIdentifier )\n    {\n        TxIdElement txId = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( txId );\n        try\n        {\n            Transaction tx = transactions.get( txId );\n            if ( tx == null )\n            {\n                throw new RuntimeException( \"Shouldn't happen\" );\n            }\n            txManager.rollback();\n            return new Response<Void>( null, new TransactionStreams() );\n        }\n        catch ( IllegalStateException e )\n        {\n            throw new RuntimeException( e );\n        }\n        catch ( SecurityException e )\n        {\n            throw new RuntimeException( e );\n        }\n        catch ( SystemException e )\n        {\n            throw new RuntimeException( e );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"f6611e9b57f484d8a0272c2c9801bbbbe134a034","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<LockResult> acquireReadLock( SlaveContext context, int eventIdentifier,\n            Node... nodes )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Node node : nodes )\n            {\n                lockManager.getReadLock( node );\n                lockReleaser.addLockToTransaction( node, LockType.READ );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStream() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStream() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStream() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","id":49654,"modified_method":"public Response<LockResult> acquireReadLock( SlaveContext context, int eventIdentifier,\n            Node... nodes )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Node node : nodes )\n            {\n                lockManager.getReadLock( node );\n                lockReleaser.addLockToTransaction( node, LockType.READ );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStreams() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStreams() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStreams() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"f6611e9b57f484d8a0272c2c9801bbbbe134a034","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<IdAllocation> allocateIds( SlaveContext context, IdType idType )\n    {\n        IdGeneratorFactory factory = getConfig().getIdGeneratorFactory();\n        IdGenerator generator = factory.get( idType );\n        int size = 10;\n        long[] ids = new long[size];\n        for ( int i = 0; i < size; i++ )\n        {\n            ids[i] = generator.nextId();\n        }\n        return new Response<IdAllocation>( new IdAllocation( ids, generator.getHighId(),\n                generator.getDefragCount() ), new TransactionStream() );\n    }","id":49655,"modified_method":"public Response<IdAllocation> allocateIds( SlaveContext context, IdType idType )\n    {\n        IdGeneratorFactory factory = getConfig().getIdGeneratorFactory();\n        IdGenerator generator = factory.get( idType );\n        int size = 10;\n        long[] ids = new long[size];\n        for ( int i = 0; i < size; i++ )\n        {\n            ids[i] = generator.nextId();\n        }\n        return new Response<IdAllocation>( new IdAllocation( ids, generator.getHighId(),\n                generator.getDefragCount() ), new TransactionStreams() );\n    }","commit_id":"f6611e9b57f484d8a0272c2c9801bbbbe134a034","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<LockResult> acquireWriteLock( SlaveContext context, int eventIdentifier,\n            Relationship... relationships )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Relationship relationship : relationships )\n            {\n                lockManager.getWriteLock( relationship );\n                lockReleaser.addLockToTransaction( relationship, LockType.WRITE );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStream() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStream() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStream() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","id":49656,"modified_method":"public Response<LockResult> acquireWriteLock( SlaveContext context, int eventIdentifier,\n            Relationship... relationships )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Relationship relationship : relationships )\n            {\n                lockManager.getWriteLock( relationship );\n                lockReleaser.addLockToTransaction( relationship, LockType.WRITE );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStreams() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStreams() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStreams() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"f6611e9b57f484d8a0272c2c9801bbbbe134a034","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<LockResult> acquireReadLock( SlaveContext context, int eventIdentifier,\n            Relationship... relationships )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Relationship relationship : relationships )\n            {\n                lockManager.getReadLock( relationship );\n                lockReleaser.addLockToTransaction( relationship, LockType.READ );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStream() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStream() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStream() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","id":49657,"modified_method":"public Response<LockResult> acquireReadLock( SlaveContext context, int eventIdentifier,\n            Relationship... relationships )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Relationship relationship : relationships )\n            {\n                lockManager.getReadLock( relationship );\n                lockReleaser.addLockToTransaction( relationship, LockType.READ );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStreams() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStreams() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStreams() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"f6611e9b57f484d8a0272c2c9801bbbbe134a034","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void reevaluateMyself()\n    {\n        shutdownIfNecessary();\n        if ( brokerSaysIAmMaster() )\n        {\n            this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                    LockManagerFactory.DEFAULT, IdGeneratorFactory.DEFAULT,\n                    DefaultRelationshipTypeCreator.INSTANCE, TopLevelTransactionFactory.DEFAULT,\n                    TxIdGeneratorFactory.DEFAULT );\n        }\n        else\n        {\n            ResponseReceiver receiver = new ResponseReceiver();\n            this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                    new SlaveLockManagerFactory( broker, receiver ),\n                    new SlaveIdGeneratorFactory( broker, receiver ),\n                    new SlaveRelationshipTypeCreator( broker, receiver ),\n                    new SlaveTopLevelTransactionFactory( broker, receiver ),\n                    new SlaveTxIdGeneratorFactory( broker, receiver ) );\n        }\n    }","id":49658,"modified_method":"protected void reevaluateMyself()\n    {\n        shutdownIfNecessary();\n        if ( brokerSaysIAmMaster() )\n        {\n            this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                    LockManagerFactory.DEFAULT, IdGeneratorFactory.DEFAULT,\n                    DefaultRelationshipTypeCreator.INSTANCE, TopLevelTransactionFactory.DEFAULT,\n                    TxIdGeneratorFactory.DEFAULT );\n        }\n        else\n        {\n            this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                    new SlaveLockManagerFactory( broker, this ),\n                    new SlaveIdGeneratorFactory( broker, this ),\n                    new SlaveRelationshipTypeCreator( broker, this ),\n                    new SlaveTopLevelTransactionFactory( broker, this ),\n                    new SlaveTxIdGeneratorFactory( broker, this ) );\n        }\n    }","commit_id":"f6611e9b57f484d8a0272c2c9801bbbbe134a034","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long generate( XaDataSource dataSource, int identifier )\n    {\n        try\n        {\n            Response<Long> response = broker.getMaster().commitSingleResourceTransaction(\n                    broker.getSlaveContext(), ((TxManager) txManager).getEventIdentifier(),\n                    dataSource.getName(), new TransactionStream(\n                            dataSource.getCommittedTransaction( identifier ) ) );\n            return receiver.receive( response );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":49659,"modified_method":"public long generate( XaDataSource dataSource, int identifier )\n    {\n        try\n        {\n            Response<Long> response = broker.getMaster().commitSingleResourceTransaction(\n                    broker.getSlaveContext(), ((TxManager) txManager).getEventIdentifier(),\n                    dataSource.getName(), new TransactionStream( Arrays.asList(\n                            dataSource.getPreparedTransaction( identifier ) ) ) );\n            return receiver.receive( response );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"f6611e9b57f484d8a0272c2c9801bbbbe134a034","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            int eventIdentifier, String resource, TransactionStream transactionStream )\n    {\n        throw new UnsupportedOperationException();\n    }","id":49660,"modified_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            int eventIdentifier, String resource, TransactionStream transactionStream )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            XaDataSource dataSource = getConfig().getTxModule().getXaDataSourceManager()\n                    .getXaDataSource( resource );\n            // Always exactly one transaction (ReadableByteChannel)\n            final long txId = dataSource.applyPreparedTransaction(\n                    transactionStream.getChannels().iterator().next() );\n            Predicate<Long> notThisTx = new Predicate<Long>()\n            {\n                public boolean accept( Long item )\n                {\n                    return item != txId;\n                }\n            };\n            return packResponse( context, txId, notThisTx );\n        }\n        catch ( IOException e )\n        {\n            return new FailedResponse<Long>();\n        }\n        finally\n        {\n            // Since the master-transaction carries no actual state, just locks\n            // we would like to release the locks... and it's best done by just\n            // rolling back the tx\n            rollbackThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"9f53b16155acb38db3ed67e3695115a4256a45ef","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<IdAllocation> allocateIds( SlaveContext context, IdType idType )\n    {\n        IdGeneratorFactory factory = getConfig().getIdGeneratorFactory();\n        IdGenerator generator = factory.get( idType );\n        int size = 10;\n        long[] ids = new long[size];\n        for ( int i = 0; i < size; i++ )\n        {\n            ids[i] = generator.nextId();\n        }\n        return new Response<IdAllocation>( new IdAllocation( ids, generator.getHighId(),\n                generator.getDefragCount() ), new TransactionStream() );\n    }","id":49661,"modified_method":"public Response<IdAllocation> allocateIds( SlaveContext context, IdType idType )\n    {\n        IdGeneratorFactory factory = getConfig().getIdGeneratorFactory();\n        IdGenerator generator = factory.get( idType );\n        int size = 10;\n        long[] ids = new long[size];\n        for ( int i = 0; i < size; i++ )\n        {\n            ids[i] = generator.nextId();\n        }\n        return new Response<IdAllocation>( new IdAllocation( ids, generator.getHighId(),\n                generator.getDefragCount() ), new TransactionStreams() );\n    }","commit_id":"9f53b16155acb38db3ed67e3695115a4256a45ef","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Void> rollbackTransaction( SlaveContext context, int eventIdentifier )\n    {\n        TxIdElement txId = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( txId );\n        try\n        {\n            Transaction tx = transactions.get( txId );\n            if ( tx == null )\n            {\n                throw new RuntimeException( \"Shouldn't happen\" );\n            }\n            txManager.rollback();\n            return new Response<Void>( null, new TransactionStream() );\n        }\n        catch ( IllegalStateException e )\n        {\n            throw new RuntimeException( e );\n        }\n        catch ( SecurityException e )\n        {\n            throw new RuntimeException( e );\n        }\n        catch ( SystemException e )\n        {\n            throw new RuntimeException( e );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","id":49662,"modified_method":"public Response<Void> rollbackTransaction( SlaveContext context, int eventIdentifier )\n    {\n        TxIdElement txId = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( txId );\n        try\n        {\n            Transaction tx = transactions.get( txId );\n            if ( tx == null )\n            {\n                throw new RuntimeException( \"Shouldn't happen\" );\n            }\n            txManager.rollback();\n            return new Response<Void>( null, new TransactionStreams() );\n        }\n        catch ( IllegalStateException e )\n        {\n            throw new RuntimeException( e );\n        }\n        catch ( SecurityException e )\n        {\n            throw new RuntimeException( e );\n        }\n        catch ( SystemException e )\n        {\n            throw new RuntimeException( e );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"9f53b16155acb38db3ed67e3695115a4256a45ef","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<LockResult> acquireReadLock( SlaveContext context, int eventIdentifier,\n            Node... nodes )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Node node : nodes )\n            {\n                lockManager.getReadLock( node );\n                lockReleaser.addLockToTransaction( node, LockType.READ );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStream() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStream() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStream() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","id":49663,"modified_method":"public Response<LockResult> acquireReadLock( SlaveContext context, int eventIdentifier,\n            Node... nodes )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Node node : nodes )\n            {\n                lockManager.getReadLock( node );\n                lockReleaser.addLockToTransaction( node, LockType.READ );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStreams() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStreams() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStreams() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"9f53b16155acb38db3ed67e3695115a4256a45ef","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<LockResult> acquireReadLock( SlaveContext context, int eventIdentifier,\n            Relationship... relationships )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Relationship relationship : relationships )\n            {\n                lockManager.getReadLock( relationship );\n                lockReleaser.addLockToTransaction( relationship, LockType.READ );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStream() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStream() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStream() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","id":49664,"modified_method":"public Response<LockResult> acquireReadLock( SlaveContext context, int eventIdentifier,\n            Relationship... relationships )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Relationship relationship : relationships )\n            {\n                lockManager.getReadLock( relationship );\n                lockReleaser.addLockToTransaction( relationship, LockType.READ );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStreams() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStreams() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStreams() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"9f53b16155acb38db3ed67e3695115a4256a45ef","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Integer> createRelationshipType( SlaveContext context, String name )\n    {\n        // Does this type exist locally?\n        Integer id = getConfig().getRelationshipTypeHolder().getIdFor( name );\n        if ( id != null )\n        {\n            // OK, return\n            return new Response<Integer>( id, new TransactionStream() );\n        }\n        \n        // No? Create it then\n        Config config = getConfig();\n        id = config.getRelationshipTypeCreator().getOrCreate( txManager,\n                config.getIdGeneratorModule().getIdGenerator(),\n                config.getPersistenceModule().getPersistenceManager(), name );\n        // TODO Include the transaction which created it in the tx stream\n        return new Response<Integer>( id, new TransactionStream() );\n    }","id":49665,"modified_method":"public Response<Integer> createRelationshipType( SlaveContext context, String name )\n    {\n        // Does this type exist locally?\n        Integer id = getConfig().getRelationshipTypeHolder().getIdFor( name );\n        if ( id != null )\n        {\n            // OK, return\n            return new Response<Integer>( id, new TransactionStreams() );\n        }\n        \n        // No? Create it then\n        Config config = getConfig();\n        id = config.getRelationshipTypeCreator().getOrCreate( txManager,\n                config.getIdGeneratorModule().getIdGenerator(),\n                config.getPersistenceModule().getPersistenceManager(), name );\n        return packResponse( context, id, ALL );\n    }","commit_id":"9f53b16155acb38db3ed67e3695115a4256a45ef","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<LockResult> acquireWriteLock( SlaveContext context, int eventIdentifier,\n            Relationship... relationships )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Relationship relationship : relationships )\n            {\n                lockManager.getWriteLock( relationship );\n                lockReleaser.addLockToTransaction( relationship, LockType.WRITE );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStream() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStream() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStream() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","id":49666,"modified_method":"public Response<LockResult> acquireWriteLock( SlaveContext context, int eventIdentifier,\n            Relationship... relationships )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Relationship relationship : relationships )\n            {\n                lockManager.getWriteLock( relationship );\n                lockReleaser.addLockToTransaction( relationship, LockType.WRITE );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStreams() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStreams() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStreams() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"9f53b16155acb38db3ed67e3695115a4256a45ef","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<LockResult> acquireWriteLock( SlaveContext context, int eventIdentifier,\n            Node... nodes )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Node node : nodes )\n            {\n                lockManager.getWriteLock( node );\n                lockReleaser.addLockToTransaction( node, LockType.WRITE );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStream() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStream() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStream() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","id":49667,"modified_method":"public Response<LockResult> acquireWriteLock( SlaveContext context, int eventIdentifier,\n            Node... nodes )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Node node : nodes )\n            {\n                lockManager.getWriteLock( node );\n                lockReleaser.addLockToTransaction( node, LockType.WRITE );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStreams() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStreams() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStreams() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"9f53b16155acb38db3ed67e3695115a4256a45ef","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void reevaluateMyself()\n    {\n        shutdownIfNecessary();\n        if ( brokerSaysIAmMaster() )\n        {\n            this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                    LockManagerFactory.DEFAULT, IdGeneratorFactory.DEFAULT,\n                    DefaultRelationshipTypeCreator.INSTANCE, TopLevelTransactionFactory.DEFAULT,\n                    TxIdGeneratorFactory.DEFAULT );\n        }\n        else\n        {\n            ResponseReceiver receiver = new ResponseReceiver();\n            this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                    new SlaveLockManagerFactory( broker, receiver ),\n                    new SlaveIdGeneratorFactory( broker, receiver ),\n                    new SlaveRelationshipTypeCreator( broker, receiver ),\n                    new SlaveTopLevelTransactionFactory( broker, receiver ),\n                    new SlaveTxIdGeneratorFactory( broker, receiver ) );\n        }\n    }","id":49668,"modified_method":"protected void reevaluateMyself()\n    {\n        shutdownIfNecessary();\n        if ( brokerSaysIAmMaster() )\n        {\n            this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                    LockManagerFactory.DEFAULT, IdGeneratorFactory.DEFAULT,\n                    DefaultRelationshipTypeCreator.INSTANCE, TopLevelTransactionFactory.DEFAULT,\n                    TxIdGeneratorFactory.DEFAULT );\n        }\n        else\n        {\n            this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                    new SlaveLockManagerFactory( broker, this ),\n                    new SlaveIdGeneratorFactory( broker, this ),\n                    new SlaveRelationshipTypeCreator( broker, this ),\n                    new SlaveTopLevelTransactionFactory( broker, this ),\n                    new SlaveTxIdGeneratorFactory( broker, this ) );\n        }\n    }","commit_id":"9f53b16155acb38db3ed67e3695115a4256a45ef","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long generate( XaDataSource dataSource, int identifier )\n    {\n        try\n        {\n            Response<Long> response = broker.getMaster().commitSingleResourceTransaction(\n                    broker.getSlaveContext(), ((TxManager) txManager).getEventIdentifier(),\n                    dataSource.getName(), new TransactionStream(\n                            dataSource.getCommittedTransaction( identifier ) ) );\n            return receiver.receive( response );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":49669,"modified_method":"public long generate( XaDataSource dataSource, int identifier )\n    {\n        try\n        {\n            Response<Long> response = broker.getMaster().commitSingleResourceTransaction(\n                    broker.getSlaveContext(), ((TxManager) txManager).getEventIdentifier(),\n                    dataSource.getName(), new TransactionStream( Arrays.asList(\n                            dataSource.getPreparedTransaction( identifier ) ) ) );\n            return receiver.receive( response );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"9f53b16155acb38db3ed67e3695115a4256a45ef","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<IdAllocation> allocateIds( SlaveContext context, IdType idType )\n    {\n        IdGeneratorFactory factory = getConfig().getIdGeneratorFactory();\n        IdGenerator generator = factory.get( idType );\n        int size = 10;\n        long[] ids = new long[size];\n        for ( int i = 0; i < size; i++ )\n        {\n            ids[i] = generator.nextId();\n        }\n        return new Response<IdAllocation>( new IdAllocation( ids, generator.getHighId(),\n                generator.getDefragCount() ), new TransactionStream() );\n    }","id":49670,"modified_method":"public Response<IdAllocation> allocateIds( SlaveContext context, IdType idType )\n    {\n        IdGeneratorFactory factory = getConfig().getIdGeneratorFactory();\n        IdGenerator generator = factory.get( idType );\n        int size = 10;\n        long[] ids = new long[size];\n        for ( int i = 0; i < size; i++ )\n        {\n            ids[i] = generator.nextId();\n        }\n        return new Response<IdAllocation>( new IdAllocation( ids, generator.getHighId(),\n                generator.getDefragCount() ), new TransactionStreams() );\n    }","commit_id":"941d0a86afe650c04938e0409895c6fae791ccc7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<LockResult> acquireReadLock( SlaveContext context, int eventIdentifier,\n            Node... nodes )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Node node : nodes )\n            {\n                lockManager.getReadLock( node );\n                lockReleaser.addLockToTransaction( node, LockType.READ );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStream() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStream() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStream() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","id":49671,"modified_method":"public Response<LockResult> acquireReadLock( SlaveContext context, int eventIdentifier,\n            Node... nodes )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Node node : nodes )\n            {\n                lockManager.getReadLock( node );\n                lockReleaser.addLockToTransaction( node, LockType.READ );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStreams() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStreams() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStreams() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"941d0a86afe650c04938e0409895c6fae791ccc7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Void> rollbackTransaction( SlaveContext context, int eventIdentifier )\n    {\n        TxIdElement txId = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( txId );\n        try\n        {\n            Transaction tx = transactions.get( txId );\n            if ( tx == null )\n            {\n                throw new RuntimeException( \"Shouldn't happen\" );\n            }\n            txManager.rollback();\n            return new Response<Void>( null, new TransactionStream() );\n        }\n        catch ( IllegalStateException e )\n        {\n            throw new RuntimeException( e );\n        }\n        catch ( SecurityException e )\n        {\n            throw new RuntimeException( e );\n        }\n        catch ( SystemException e )\n        {\n            throw new RuntimeException( e );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","id":49672,"modified_method":"public Response<Void> rollbackTransaction( SlaveContext context, int eventIdentifier )\n    {\n        TxIdElement txId = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( txId );\n        try\n        {\n            Transaction tx = transactions.get( txId );\n            if ( tx == null )\n            {\n                throw new RuntimeException( \"Shouldn't happen\" );\n            }\n            txManager.rollback();\n            return new Response<Void>( null, new TransactionStreams() );\n        }\n        catch ( IllegalStateException e )\n        {\n            throw new RuntimeException( e );\n        }\n        catch ( SecurityException e )\n        {\n            throw new RuntimeException( e );\n        }\n        catch ( SystemException e )\n        {\n            throw new RuntimeException( e );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"941d0a86afe650c04938e0409895c6fae791ccc7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<LockResult> acquireWriteLock( SlaveContext context, int eventIdentifier,\n            Relationship... relationships )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Relationship relationship : relationships )\n            {\n                lockManager.getWriteLock( relationship );\n                lockReleaser.addLockToTransaction( relationship, LockType.WRITE );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStream() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStream() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStream() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","id":49673,"modified_method":"public Response<LockResult> acquireWriteLock( SlaveContext context, int eventIdentifier,\n            Relationship... relationships )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Relationship relationship : relationships )\n            {\n                lockManager.getWriteLock( relationship );\n                lockReleaser.addLockToTransaction( relationship, LockType.WRITE );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStreams() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStreams() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStreams() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"941d0a86afe650c04938e0409895c6fae791ccc7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            int eventIdentifier, String resource, TransactionStream transactionStream )\n    {\n        throw new UnsupportedOperationException();\n    }","id":49674,"modified_method":"public Response<Long> commitSingleResourceTransaction( SlaveContext context,\n            int eventIdentifier, String resource, TransactionStream transactionStream )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            XaDataSource dataSource = getConfig().getTxModule().getXaDataSourceManager()\n                    .getXaDataSource( resource );\n            // Always exactly one transaction (ReadableByteChannel)\n            final long txId = dataSource.applyPreparedTransaction(\n                    transactionStream.getChannels().iterator().next() );\n            Predicate<Long> notThisTx = new Predicate<Long>()\n            {\n                public boolean accept( Long item )\n                {\n                    return item != txId;\n                }\n            };\n            return packResponse( context, txId, notThisTx );\n        }\n        catch ( IOException e )\n        {\n            return new FailedResponse<Long>();\n        }\n        finally\n        {\n            // Since the master-transaction carries no actual state, just locks\n            // we would like to release the locks... and it's best done by just\n            // rolling back the tx\n            rollbackThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"941d0a86afe650c04938e0409895c6fae791ccc7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<LockResult> acquireWriteLock( SlaveContext context, int eventIdentifier,\n            Node... nodes )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Node node : nodes )\n            {\n                lockManager.getWriteLock( node );\n                lockReleaser.addLockToTransaction( node, LockType.WRITE );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStream() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStream() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStream() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","id":49675,"modified_method":"public Response<LockResult> acquireWriteLock( SlaveContext context, int eventIdentifier,\n            Node... nodes )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Node node : nodes )\n            {\n                lockManager.getWriteLock( node );\n                lockReleaser.addLockToTransaction( node, LockType.WRITE );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStreams() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStreams() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStreams() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"941d0a86afe650c04938e0409895c6fae791ccc7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<LockResult> acquireReadLock( SlaveContext context, int eventIdentifier,\n            Relationship... relationships )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Relationship relationship : relationships )\n            {\n                lockManager.getReadLock( relationship );\n                lockReleaser.addLockToTransaction( relationship, LockType.READ );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStream() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStream() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStream() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","id":49676,"modified_method":"public Response<LockResult> acquireReadLock( SlaveContext context, int eventIdentifier,\n            Relationship... relationships )\n    {\n        TxIdElement tx = new TxIdElement( context.slaveId(), eventIdentifier );\n        Transaction otherTx = suspendOtherAndResumeThis( tx );\n        try\n        {\n            LockManager lockManager = getConfig().getLockManager();\n            LockReleaser lockReleaser = getConfig().getLockReleaser();\n            for ( Relationship relationship : relationships )\n            {\n                lockManager.getReadLock( relationship );\n                lockReleaser.addLockToTransaction( relationship, LockType.READ );\n            }\n            return new Response<LockResult>( new LockResult( LockStatus.OK_LOCKED ),\n                    new TransactionStreams() );\n        }\n        catch ( DeadlockDetectedException e )\n        {\n            return new Response<LockResult>( new LockResult( e.getMessage() ),\n                    new TransactionStreams() );\n        }\n        catch ( IllegalResourceException e )\n        {\n            return new Response<LockResult>( new LockResult( LockStatus.NOT_LOCKED ),\n                    new TransactionStreams() );\n        }\n        finally\n        {\n            suspendThisAndResumeOther( otherTx );\n        }\n    }","commit_id":"941d0a86afe650c04938e0409895c6fae791ccc7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Response<Integer> createRelationshipType( SlaveContext context, String name )\n    {\n        // Does this type exist locally?\n        Integer id = getConfig().getRelationshipTypeHolder().getIdFor( name );\n        if ( id != null )\n        {\n            // OK, return\n            return new Response<Integer>( id, new TransactionStream() );\n        }\n        \n        // No? Create it then\n        Config config = getConfig();\n        id = config.getRelationshipTypeCreator().getOrCreate( txManager,\n                config.getIdGeneratorModule().getIdGenerator(),\n                config.getPersistenceModule().getPersistenceManager(), name );\n        // TODO Include the transaction which created it in the tx stream\n        return new Response<Integer>( id, new TransactionStream() );\n    }","id":49677,"modified_method":"public Response<Integer> createRelationshipType( SlaveContext context, String name )\n    {\n        // Does this type exist locally?\n        Integer id = getConfig().getRelationshipTypeHolder().getIdFor( name );\n        if ( id != null )\n        {\n            // OK, return\n            return new Response<Integer>( id, new TransactionStreams() );\n        }\n        \n        // No? Create it then\n        Config config = getConfig();\n        id = config.getRelationshipTypeCreator().getOrCreate( txManager,\n                config.getIdGeneratorModule().getIdGenerator(),\n                config.getPersistenceModule().getPersistenceManager(), name );\n        return packResponse( context, id, ALL );\n    }","commit_id":"941d0a86afe650c04938e0409895c6fae791ccc7","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void reevaluateMyself()\n    {\n        shutdownIfNecessary();\n        if ( brokerSaysIAmMaster() )\n        {\n            this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                    LockManagerFactory.DEFAULT, IdGeneratorFactory.DEFAULT,\n                    DefaultRelationshipTypeCreator.INSTANCE, TopLevelTransactionFactory.DEFAULT,\n                    TxIdGeneratorFactory.DEFAULT );\n        }\n        else\n        {\n            ResponseReceiver receiver = new ResponseReceiver();\n            this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                    new SlaveLockManagerFactory( broker, receiver ),\n                    new SlaveIdGeneratorFactory( broker, receiver ),\n                    new SlaveRelationshipTypeCreator( broker, receiver ),\n                    new SlaveTopLevelTransactionFactory( broker, receiver ),\n                    new SlaveTxIdGeneratorFactory( broker, receiver ) );\n        }\n    }","id":49678,"modified_method":"protected void reevaluateMyself()\n    {\n        shutdownIfNecessary();\n        if ( brokerSaysIAmMaster() )\n        {\n            this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                    LockManagerFactory.DEFAULT, IdGeneratorFactory.DEFAULT,\n                    DefaultRelationshipTypeCreator.INSTANCE, TopLevelTransactionFactory.DEFAULT,\n                    TxIdGeneratorFactory.DEFAULT );\n        }\n        else\n        {\n            this.localGraph = new EmbeddedGraphDbImpl( storeDir, config, this,\n                    new SlaveLockManagerFactory( broker, this ),\n                    new SlaveIdGeneratorFactory( broker, this ),\n                    new SlaveRelationshipTypeCreator( broker, this ),\n                    new SlaveTopLevelTransactionFactory( broker, this ),\n                    new SlaveTxIdGeneratorFactory( broker, this ) );\n        }\n    }","commit_id":"941d0a86afe650c04938e0409895c6fae791ccc7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long generate( XaDataSource dataSource, int identifier )\n    {\n        try\n        {\n            Response<Long> response = broker.getMaster().commitSingleResourceTransaction(\n                    broker.getSlaveContext(), ((TxManager) txManager).getEventIdentifier(),\n                    dataSource.getName(), new TransactionStream(\n                            dataSource.getCommittedTransaction( identifier ) ) );\n            return receiver.receive( response );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":49679,"modified_method":"public long generate( XaDataSource dataSource, int identifier )\n    {\n        try\n        {\n            Response<Long> response = broker.getMaster().commitSingleResourceTransaction(\n                    broker.getSlaveContext(), ((TxManager) txManager).getEventIdentifier(),\n                    dataSource.getName(), new TransactionStream( Arrays.asList(\n                            dataSource.getPreparedTransaction( identifier ) ) ) );\n            return receiver.receive( response );\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"941d0a86afe650c04938e0409895c6fae791ccc7","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected final void deleteTag(final XmlTag tag) {\n    try {\n      tag.delete();\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    myXmlTag = null;\n  }","id":49680,"modified_method":"protected final void deleteTag(final XmlTag tag) {\n    final boolean changing = myManager.setChanging(true);\n    try {\n      tag.delete();\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    } finally {\n      myManager.setChanging(changing);\n    }\n    myXmlTag = null;\n  }","commit_id":"1f6335f90ed7210decb3ae33ff31c1e5c9469aa8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected final void cacheDomElement(final XmlTag tag) {\n    synchronized (PsiLock.LOCK) {\n      DomManagerImpl.setCachedElement(myXmlTag, null);\n      myXmlTag = tag;\n      DomManagerImpl.setCachedElement(tag, this);\n    }\n  }","id":49681,"modified_method":"protected final void cacheDomElement(final XmlTag tag) {\n    synchronized (PsiLock.LOCK) {\n      myXmlTag = tag;\n      DomManagerImpl.setCachedElement(tag, this);\n    }\n  }","commit_id":"1f6335f90ed7210decb3ae33ff31c1e5c9469aa8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void visitXmlTagChildRemoved(final XmlTagChildRemoved change) {\n    final XmlTag tag = change.getTag();\n    if (isTagValueChange(change.getChild(), tag)) {\n      fireTagValueChanged(tag);\n    }\n  }","id":49682,"modified_method":"public final void visitXmlTagChildRemoved(final XmlTagChildRemoved change) {\n    final XmlTag tag = change.getTag();\n    final XmlTagChild child = change.getChild();\n    if (isTagValueChange(child, tag)) {\n      fireTagValueChanged(tag);\n    } else if (child instanceof XmlTag) {\n      XmlTag childTag = (XmlTag)child;\n      final DomInvocationHandler element = getCachedElement(tag);\n      if (element != null) {\n        //element.processChildTagRemoved(childTag);\n      }\n    }\n  }","commit_id":"1f6335f90ed7210decb3ae33ff31c1e5c9469aa8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void visitXmlTagChildAdd(final XmlTagChildAdd change) {\n    final XmlTagChild child = change.getChild();\n    final XmlTag tag = change.getTag();\n    if (isTagValueChange(child)) {\n      fireTagValueChanged(tag);\n    }\n    if (child instanceof XmlTag) {\n      XmlTag childTag = (XmlTag)child;\n      final DomInvocationHandler element = getCachedElement(tag);\n      if (element != null) {\n        element.processChildTagAdded(childTag);\n      }\n    }\n  }","id":49683,"modified_method":"public final void visitXmlTagChildAdd(final XmlTagChildAdd change) {\n    final XmlTagChild child = change.getChild();\n    final XmlTag tag = change.getTag();\n    if (isTagValueChange(child)) {\n      fireTagValueChanged(tag);\n    } else if (child instanceof XmlTag) {\n      XmlTag childTag = (XmlTag)child;\n      final DomInvocationHandler element = getCachedElement(tag);\n      if (element != null) {\n        //element.processChildTagAdded(childTag);\n      }\n    }\n  }","commit_id":"1f6335f90ed7210decb3ae33ff31c1e5c9469aa8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void projectOpened() {\n    final XmlAspect xmlAspect = myPomModel.getModelAspect(XmlAspect.class);\n    assert xmlAspect != null;\n    myXmlListener = new PomModelListener() {\n      public void modelChanged(PomModelEvent event) {\n        if (myChanging) return;\n        final XmlChangeSet changeSet = (XmlChangeSet) event.getChangeSet(xmlAspect);\n        if (changeSet != null) {\n          for (XmlChange change : changeSet.getChanges()) {\n            change.accept(DomManagerImpl.this);\n          }\n        }\n      }\n\n      public boolean isAspectChangeInteresting(PomModelAspect aspect) {\n        return xmlAspect.equals(aspect);\n      }\n    };\n    myPomModel.addModelListener(myXmlListener);\n  }","id":49684,"modified_method":"public final void projectOpened() {\n    final XmlAspect xmlAspect = myPomModel.getModelAspect(XmlAspect.class);\n    assert xmlAspect != null;\n    myXmlListener = new PomModelListener() {\n      public void modelChanged(PomModelEvent event) {\n        if (myChanging) return;\n        final XmlChangeSet changeSet = (XmlChangeSet) event.getChangeSet(xmlAspect);\n        if (changeSet != null) {\n          boolean flag = false;\n          for (XmlChange change : changeSet.getChanges()) {\n            change.accept(DomManagerImpl.this);\n            if (!flag) {\n              flag = true;\n              change.accept(new XmlChangeVisitorBase(){\n              public void visitXmlTagChildAdd(final XmlTagChildAdd xmlTagChildAdd) {\n                final DomInvocationHandler element = getCachedElement(xmlTagChildAdd.getTag());\n                if (element != null) {\n                  element.processChildrenChange(changeSet);\n                }\n              }\n\n              public void visitXmlTagChildRemoved(final XmlTagChildRemoved xmlTagChildRemoved) {\n                final DomInvocationHandler element = getCachedElement(xmlTagChildRemoved.getTag());\n                if (element != null) {\n                  element.processChildrenChange(changeSet);\n                }\n              }\n\n              public void visitXmlTagChildChanged(final XmlTagChildChanged xmlTagChildChanged) {\n                final DomInvocationHandler element = getCachedElement(xmlTagChildChanged.getTag());\n                if (element != null) {\n                  element.processChildrenChange(changeSet);\n                }\n              }\n              });\n            }\n          }\n        }\n      }\n\n      public boolean isAspectChangeInteresting(PomModelAspect aspect) {\n        return xmlAspect.equals(aspect);\n      }\n    };\n    myPomModel.addModelListener(myXmlListener);\n  }","commit_id":"1f6335f90ed7210decb3ae33ff31c1e5c9469aa8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected ElementChangedEvent(final DomElement element) {\n    assert element != null;\n    myElement = element;\n  }","id":49685,"modified_method":"public ElementChangedEvent(final DomElement element) {\n    assert element != null;\n    myElement = element;\n  }","commit_id":"1f6335f90ed7210decb3ae33ff31c1e5c9469aa8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object invoke(final DomInvocationHandler handler, final Object[] args) throws Throwable {\n    XmlTag tag = handler.getXmlTag();\n    if (tag == null) return Collections.emptyList();\n\n    handler.checkInitialized();\n    final XmlTag[] subTags = tag.findSubTags(myQname);\n    DomElement[] elements = new DomElement[subTags.length - myStartIndex];\n    for (int i = myStartIndex; i < subTags.length; i++) {\n      final DomElement element = DomManagerImpl.getCachedElement(subTags[i]).getProxy();\n      assert element != null : \"Null annotated element for \" + tag.getText() + \"; \" + myQname + \"; \" + i;\n      elements[i - myStartIndex] = element;\n    }\n    return Arrays.asList(elements);\n  }","id":49686,"modified_method":"public Object invoke(final DomInvocationHandler handler, final Object[] args) throws Throwable {\n    XmlTag tag = handler.getXmlTag();\n    if (tag == null) return Collections.emptyList();\n\n    handler.checkInitialized();\n    final XmlTag[] subTags = tag.findSubTags(myQname);\n    if (subTags.length <= myStartIndex) return Collections.emptyList();\n\n    List<DomElement> elements = new ArrayList<DomElement>(subTags.length - myStartIndex);\n    for (int i = myStartIndex; i < subTags.length; i++) {\n      final DomInvocationHandler element = DomManagerImpl.getCachedElement(subTags[i]);\n      if (element != null) {\n        elements.add(element.getProxy());\n      }\n    }\n    return Collections.unmodifiableList(elements);\n  }","commit_id":"1f6335f90ed7210decb3ae33ff31c1e5c9469aa8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      final AttributeValue attributeValue = method.getAnnotation(AttributeValue.class);\n      if (attributeValue != null) {\n        return myTag.getAttributeValue(guessName(attributeValue.value(), method));\n      }\n      final TagValue tagValue = method.getAnnotation(TagValue.class);\n      if (tagValue != null || isGetValueMethod(method)) {\n        return myTag.getValue().getText();\n      }\n      final SubTagValue subTagValue = method.getAnnotation(SubTagValue.class);\n      if (subTagValue != null) {\n        final String qname = guessName(subTagValue.value(), method);\n        if (qname != null) {\n          final XmlTag subTag = myTag.findFirstSubTag(qname);\n          if (subTag != null) {\n            return subTag.getValue().getText();\n          }\n        }\n        return null;\n      }\n\n      checkInitialized();\n\n      if (XmlAnnotatedElement.class.isAssignableFrom(method.getReturnType())) {\n        final String qname = getSubTagName(method);\n        final XmlTag subTag = myTag.findFirstSubTag(qname);\n        if (subTag != null) {\n          return getCachedElement(subTag);\n        }\n      }\n\n      if (extractElementType(method.getGenericReturnType()) != null) {\n        final XmlTag[] subTags = myTag.findSubTags(getSubTagNameForCollection(method));\n        final ArrayList<XmlAnnotatedElement> list = new ArrayList<XmlAnnotatedElement>(subTags.length);\n        for (XmlTag xmlTag : subTags) {\n          list.add(getCachedElement(xmlTag));\n        }\n        return Collections.unmodifiableList(list);\n      }\n\n      if (Object.class.equals(method.getDeclaringClass())) {\n        final String name = method.getName();\n        if (\"toString\".equals(name)) {\n          return StringUtil.getShortName(myClass) + \" on tag \" + myTag.getText() + \" @\" + System.identityHashCode(proxy);\n        }\n        if (\"equals\".equals(name)) {\n          return proxy == args[0];\n        }\n        if (\"hashCode\".equals(name)) {\n          return System.identityHashCode(proxy);\n        }\n      }\n\n      throw new UnsupportedOperationException(\"Cannot call \" + method.toString());\n    }","id":49687,"modified_method":"public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      final AttributeValue attributeValue = method.getAnnotation(AttributeValue.class);\n      if (attributeValue != null) {\n        return myTag.getAttributeValue(guessName(attributeValue.value(), method));\n      }\n      final TagValue tagValue = method.getAnnotation(TagValue.class);\n      if (tagValue != null || isGetValueMethod(method)) {\n        return myTag.getValue().getText();\n      }\n      final SubTagValue subTagValue = method.getAnnotation(SubTagValue.class);\n      if (subTagValue != null) {\n        final String qname = guessName(subTagValue.value(), method);\n        if (qname != null) {\n          final XmlTag subTag = myTag.findFirstSubTag(qname);\n          if (subTag != null) {\n            return subTag.getValue().getText();\n          }\n        }\n        return null;\n      }\n\n      if (Object.class.equals(method.getDeclaringClass())) {\n        final String name = method.getName();\n        if (\"toString\".equals(name)) {\n          return StringUtil.getShortName(myClass) + \" on tag \" + myTag.getText() + \" @\" + System.identityHashCode(proxy);\n        }\n        if (\"equals\".equals(name)) {\n          return proxy == args[0];\n        }\n        if (\"hashCode\".equals(name)) {\n          return System.identityHashCode(proxy);\n        }\n      }\n\n      checkInitialized();\n\n      if (XmlAnnotatedElement.class.isAssignableFrom(method.getReturnType())) {\n        final String qname = getSubTagName(method);\n        if (qname != null) {\n          final XmlTag subTag = myTag.findFirstSubTag(qname);\n          if (subTag != null) {\n            final XmlAnnotatedElement element = getCachedElement(subTag);\n            assert element != null : \"Null annotated element for \" + myTag.getText() + \"; \" + qname;\n            return element;\n          }\n        }\n      }\n\n      if (extractElementType(method.getGenericReturnType()) != null) {\n        final String qname = getSubTagNameForCollection(method);\n        if (qname != null) {\n          final XmlTag[] subTags = myTag.findSubTags(qname);\n          XmlAnnotatedElement[] elements = new XmlAnnotatedElement[subTags.length];\n          for (int i = 0; i < subTags.length; i++) {\n            final XmlAnnotatedElement element = getCachedElement(subTags[i]);\n            assert element != null : \"Null annotated element for \" + myTag.getText() + \"; \" + qname + \"; \" + i;\n            elements[i] = element;\n          }\n          return Arrays.asList(elements);\n        }\n      }\n\n      throw new UnsupportedOperationException(\"Cannot call \" + method.toString());\n    }","commit_id":"507d287944e33fc82776c65455d90678ecb2f371","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private DomInvocationHandler _getDomElement(final XmlTag tag) {\n    if (tag == null) return null;\n\n    DomInvocationHandler invocationHandler = getCachedElement(tag);\n    if (invocationHandler != null && invocationHandler.isValid()) {\n      return invocationHandler;\n    }\n\n    final XmlTag parentTag = tag.getParentTag();\n    if (parentTag == null) {\n      final PsiFile psiFile = tag.getContainingFile();\n      return psiFile instanceof XmlFile ? getRootInvocationHandler((XmlFile)psiFile) : null;\n    }\n\n    DomInvocationHandler parent = _getDomElement(parentTag);\n    if (parent == null) return null;\n\n    final DynamicGenericInfo info = parent.getGenericInfo();\n    final AbstractDomChildrenDescription childDescription = info.findChildrenDescription(parent, tag.getLocalName(), tag.getNamespace(), false, tag.getName());\n    if (childDescription == null) return null;\n\n    childDescription.getValues(parent.getProxy());\n    return getCachedElement(tag);\n  }","id":49688,"modified_method":"@Nullable\n  private DomInvocationHandler _getDomElement(final XmlTag tag) {\n    if (tag == null) return null;\n\n    DomInvocationHandler invocationHandler = getCachedElement(tag);\n    if (invocationHandler != null && invocationHandler.isValid() && invocationHandler.getXmlTag() == tag) {\n      return invocationHandler;\n    }\n\n    final XmlTag parentTag = tag.getParentTag();\n    if (parentTag == null) {\n      final PsiFile psiFile = tag.getContainingFile();\n      if (psiFile instanceof XmlFile) {\n        final DomRootInvocationHandler handler = getRootInvocationHandler((XmlFile)psiFile);\n        return handler != null && handler.getXmlTag() == tag ? handler : null;\n      }\n      return null;\n    }\n\n    DomInvocationHandler parent = _getDomElement(parentTag);\n    if (parent == null) return null;\n\n    final DynamicGenericInfo info = parent.getGenericInfo();\n    final AbstractDomChildrenDescription childDescription = info.findChildrenDescription(parent, tag.getLocalName(), tag.getNamespace(), false, tag.getName());\n    if (childDescription == null) return null;\n\n    childDescription.getValues(parent.getProxy());\n    final DomInvocationHandler handler = getCachedElement(tag);\n    return handler != null && handler.getXmlTag() == tag ? handler : null;\n  }","commit_id":"b51cf819643a060c75d73618583df549bfa81b2c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void processValues(VirtualFile virtualFile, FileBasedIndex.ValueProcessor<ImageInfo> processor) {\n    FileBasedIndex.getInstance().processValues(INDEX_ID, FileBasedIndex.getFileId(virtualFile), virtualFile, processor, VirtualFileFilter.ALL);\n  }","id":49689,"modified_method":"public static void processValues(VirtualFile virtualFile, FileBasedIndex.ValueProcessor<ImageInfo> processor) {\n    FileBasedIndex.getInstance().processValues(INDEX_ID, Math.abs(FileBasedIndex.getFileId(virtualFile)), virtualFile, processor, VirtualFileFilter.ALL);\n  }","commit_id":"fdedb7fd6ee8d9b10ea53e366fadf19e032a1a02","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addSourceForRecompilation(final int projectId, final VirtualFile srcFile, @Nullable final SourceFileInfo preloadedInfo) {\n    final SourceFileInfo srcInfo = preloadedInfo != null? preloadedInfo : loadSourceInfo(srcFile);\n\n    final boolean alreadyMarked;\n    synchronized (mySourcesToRecompile) {\n      TIntHashSet set = mySourcesToRecompile.get(projectId);\n      if (set == null) {\n        set = new TIntHashSet();\n        mySourcesToRecompile.put(projectId, set);\n      }\n      alreadyMarked = !set.add(getFileId(srcFile));\n      if (!alreadyMarked && LOG.isDebugEnabled()) {\n        LOG.debug(\"Scheduled recompilation \" + srcFile.getPresentableUrl());\n      }\n    }\n\n    if (!alreadyMarked && srcInfo != null) {\n      srcInfo.updateTimestamp(projectId, -1L);\n      srcInfo.processOutputPaths(projectId, new ScheduleOutputsForDeletionProc(srcFile.getUrl()));\n      saveSourceInfo(srcFile, srcInfo);\n    }\n  }","id":49690,"modified_method":"private void addSourceForRecompilation(final int projectId, final VirtualFile srcFile, @Nullable final SourceFileInfo preloadedInfo) {\n    final SourceFileInfo srcInfo = preloadedInfo != null? preloadedInfo : loadSourceInfo(srcFile);\n\n    final boolean alreadyMarked;\n    synchronized (mySourcesToRecompile) {\n      TIntHashSet set = mySourcesToRecompile.get(projectId);\n      if (set == null) {\n        set = new TIntHashSet();\n        mySourcesToRecompile.put(projectId, set);\n      }\n      alreadyMarked = !set.add(Math.abs(getFileId(srcFile)));\n      if (!alreadyMarked && LOG.isDebugEnabled()) {\n        LOG.debug(\"Scheduled recompilation \" + srcFile.getPresentableUrl());\n      }\n    }\n\n    if (!alreadyMarked && srcInfo != null) {\n      srcInfo.updateTimestamp(projectId, -1L);\n      srcInfo.processOutputPaths(projectId, new ScheduleOutputsForDeletionProc(srcFile.getUrl()));\n      saveSourceInfo(srcFile, srcInfo);\n    }\n  }","commit_id":"90d82e461eab0cc3126d82c397232581a20bb8f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(final CompileContext context, final TranslatingCompiler.OutputItem[] successfullyCompiled, final VirtualFile[] filesToRecompile)\n      throws IOException {\n    final Project project = context.getProject();\n    final int projectId = getProjectId(project);\n    final LocalFileSystem lfs = LocalFileSystem.getInstance();\n    final IOException[] _ex = {null};\n\n    // need read action here to ensure that no modifications were made to VFS while updating file attributes\n    ApplicationManager.getApplication().runReadAction(new Runnable() {\n      public void run() {\n        try {\n          final Map<VirtualFile, SourceFileInfo> compiledSources = new HashMap<VirtualFile, SourceFileInfo>();\n          final Set<VirtualFile> forceRecompile = new HashSet<VirtualFile>();\n\n          for (TranslatingCompiler.OutputItem item : successfullyCompiled) {\n            final VirtualFile sourceFile = item.getSourceFile();\n            final boolean isSourceValid = sourceFile.isValid();\n            SourceFileInfo srcInfo = compiledSources.get(sourceFile);\n            if (isSourceValid && srcInfo == null) {\n              srcInfo = loadSourceInfo(sourceFile);\n              if (srcInfo != null) {\n                srcInfo.clearPaths(projectId);\n              }\n              else {\n                srcInfo = new SourceFileInfo();\n              }\n              compiledSources.put(sourceFile, srcInfo);\n            }\n\n            final String outputPath = item.getOutputPath();\n            if (outputPath != null) { // can be null for packageinfo\n              final VirtualFile outputFile = lfs.findFileByPath(outputPath);\n\n              //assert outputFile != null : \"Virtual file was not found for \\\"\" + outputPath + \"\\\"\";\n\n              if (outputFile != null) {\n                if (!sourceFile.equals(outputFile)) {\n                  final String outputRoot = item.getOutputRootDirectory();\n                  final String className = MakeUtil.relativeClassPathToQName(outputPath.substring(outputRoot.length()), '/');\n                  if (isSourceValid) {\n                    srcInfo.addOutputPath(projectId, outputPath);\n                    saveOutputInfo(outputFile, new OutputFileInfo(sourceFile.getPath(), className));\n                  }\n                  else {\n                    markOutputPathForDeletion(projectId, outputPath, className, sourceFile.getUrl());\n                  }\n                }\n              }\n              else {  // output file was not found\n                LOG.warn(\"TranslatingCompilerFilesMonitor.update():  Virtual file was not found for \\\"\" + outputPath + \"\\\"\");\n                if (isSourceValid) {\n                  forceRecompile.add(sourceFile);\n                }\n              }\n            }\n          }\n\n          final long compilationStartStamp = ((CompileContextEx)context).getStartCompilationStamp();\n\n          for (Map.Entry<VirtualFile, SourceFileInfo> entry : compiledSources.entrySet()) {\n            final SourceFileInfo info = entry.getValue();\n            final VirtualFile file = entry.getKey();\n            final long fileStamp = file.getTimeStamp();\n            info.updateTimestamp(projectId, fileStamp);\n            saveSourceInfo(file, info);\n            removeSourceForRecompilation(projectId, getFileId(file));\n            if ((fileStamp > compilationStartStamp && !((CompileContextEx) context).isGenerated(file)) || forceRecompile.contains(file)) {\n              // changes were made during compilation, need to re-schedule compilation\n              // it is important to invoke removeSourceForRecompilation() before to make sure\n              // the corresponding output paths will be scheduled for deletion\n              addSourceForRecompilation(projectId, file, info);\n            }\n          }\n        }\n        catch (IOException e) {\n          _ex[0] = e;\n        }\n      }\n    });\n    if (_ex[0] != null) {\n      throw _ex[0];\n    }\n\n    if (filesToRecompile.length > 0) {\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        public void run() {\n          for (VirtualFile file : filesToRecompile) {\n            if (file.isValid()) {\n              addSourceForRecompilation(projectId, file, null);\n            }\n          }\n        }\n      });\n    }\n  }","id":49691,"modified_method":"public void update(final CompileContext context, final TranslatingCompiler.OutputItem[] successfullyCompiled, final VirtualFile[] filesToRecompile)\n      throws IOException {\n    final Project project = context.getProject();\n    final int projectId = getProjectId(project);\n    final LocalFileSystem lfs = LocalFileSystem.getInstance();\n    final IOException[] _ex = {null};\n\n    // need read action here to ensure that no modifications were made to VFS while updating file attributes\n    ApplicationManager.getApplication().runReadAction(new Runnable() {\n      public void run() {\n        try {\n          final Map<VirtualFile, SourceFileInfo> compiledSources = new HashMap<VirtualFile, SourceFileInfo>();\n          final Set<VirtualFile> forceRecompile = new HashSet<VirtualFile>();\n\n          for (TranslatingCompiler.OutputItem item : successfullyCompiled) {\n            final VirtualFile sourceFile = item.getSourceFile();\n            final boolean isSourceValid = sourceFile.isValid();\n            SourceFileInfo srcInfo = compiledSources.get(sourceFile);\n            if (isSourceValid && srcInfo == null) {\n              srcInfo = loadSourceInfo(sourceFile);\n              if (srcInfo != null) {\n                srcInfo.clearPaths(projectId);\n              }\n              else {\n                srcInfo = new SourceFileInfo();\n              }\n              compiledSources.put(sourceFile, srcInfo);\n            }\n\n            final String outputPath = item.getOutputPath();\n            if (outputPath != null) { // can be null for packageinfo\n              final VirtualFile outputFile = lfs.findFileByPath(outputPath);\n\n              //assert outputFile != null : \"Virtual file was not found for \\\"\" + outputPath + \"\\\"\";\n\n              if (outputFile != null) {\n                if (!sourceFile.equals(outputFile)) {\n                  final String outputRoot = item.getOutputRootDirectory();\n                  final String className = MakeUtil.relativeClassPathToQName(outputPath.substring(outputRoot.length()), '/');\n                  if (isSourceValid) {\n                    srcInfo.addOutputPath(projectId, outputPath);\n                    saveOutputInfo(outputFile, new OutputFileInfo(sourceFile.getPath(), className));\n                  }\n                  else {\n                    markOutputPathForDeletion(projectId, outputPath, className, sourceFile.getUrl());\n                  }\n                }\n              }\n              else {  // output file was not found\n                LOG.warn(\"TranslatingCompilerFilesMonitor.update():  Virtual file was not found for \\\"\" + outputPath + \"\\\"\");\n                if (isSourceValid) {\n                  forceRecompile.add(sourceFile);\n                }\n              }\n            }\n          }\n\n          final long compilationStartStamp = ((CompileContextEx)context).getStartCompilationStamp();\n\n          for (Map.Entry<VirtualFile, SourceFileInfo> entry : compiledSources.entrySet()) {\n            final SourceFileInfo info = entry.getValue();\n            final VirtualFile file = entry.getKey();\n            final long fileStamp = file.getTimeStamp();\n            info.updateTimestamp(projectId, fileStamp);\n            saveSourceInfo(file, info);\n            removeSourceForRecompilation(projectId, Math.abs(getFileId(file)));\n            if ((fileStamp > compilationStartStamp && !((CompileContextEx) context).isGenerated(file)) || forceRecompile.contains(file)) {\n              // changes were made during compilation, need to re-schedule compilation\n              // it is important to invoke removeSourceForRecompilation() before to make sure\n              // the corresponding output paths will be scheduled for deletion\n              addSourceForRecompilation(projectId, file, info);\n            }\n          }\n        }\n        catch (IOException e) {\n          _ex[0] = e;\n        }\n      }\n    });\n    if (_ex[0] != null) {\n      throw _ex[0];\n    }\n\n    if (filesToRecompile.length > 0) {\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        public void run() {\n          for (VirtualFile file : filesToRecompile) {\n            if (file.isValid()) {\n              addSourceForRecompilation(projectId, file, null);\n            }\n          }\n        }\n      });\n    }\n  }","commit_id":"90d82e461eab0cc3126d82c397232581a20bb8f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void beforeFileDeletion(final VirtualFileEvent event) {\n      final VirtualFile eventFile = event.getFile();\n      if (LOG.isDebugEnabled() && eventFile.isDirectory()) {\n        LOG.debug(\"Processing file deletion: \" + eventFile.getPresentableUrl());\n      }\n      processRecursively(eventFile, true, new FileProcessor() {\n        public void execute(final VirtualFile file) {\n          final String filePath = file.getPath();\n          try {\n            final OutputFileInfo outputInfo = loadOutputInfo(file);\n            if (outputInfo != null) {\n              final String srcPath = outputInfo.getSourceFilePath();\n              final VirtualFile srcFile = srcPath != null? LocalFileSystem.getInstance().findFileByPath(srcPath) : null;\n              if (srcFile != null) {\n                final SourceFileInfo srcInfo = loadSourceInfo(srcFile);\n                if (srcInfo != null) {\n                  for (int projectId : srcInfo.getProjectIds().toArray()) {\n                    if (srcInfo.isAssociated(projectId, filePath)) {\n                      addSourceForRecompilation(projectId, srcFile, srcInfo);\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n  \n            final SourceFileInfo srcInfo = loadSourceInfo(file);\n            if (srcInfo != null) {\n              final TIntHashSet projects = srcInfo.getProjectIds();\n              if (!projects.isEmpty()) {\n                final ScheduleOutputsForDeletionProc deletionProc = new ScheduleOutputsForDeletionProc(file.getUrl());\n                for (int projectId : projects.toArray()) {\n                  // mark associated outputs for deletion\n                  srcInfo.processOutputPaths(projectId, deletionProc);\n                  removeSourceForRecompilation(projectId, getFileId(file));\n                }\n              }\n            }\n          }\n          finally {\n            // it is important that update of myOutputsToDelete is done at the end\n            // otherwise the filePath of the file that is about to be deleted may be re-scheduled for deletion in addSourceForRecompilation()\n            unmarkOutputPathForDeletion(filePath);\n          }\n        }\n      });\n    }","id":49692,"modified_method":"public void beforeFileDeletion(final VirtualFileEvent event) {\n      final VirtualFile eventFile = event.getFile();\n      if (LOG.isDebugEnabled() && eventFile.isDirectory()) {\n        LOG.debug(\"Processing file deletion: \" + eventFile.getPresentableUrl());\n      }\n      processRecursively(eventFile, true, new FileProcessor() {\n        public void execute(final VirtualFile file) {\n          final String filePath = file.getPath();\n          try {\n            final OutputFileInfo outputInfo = loadOutputInfo(file);\n            if (outputInfo != null) {\n              final String srcPath = outputInfo.getSourceFilePath();\n              final VirtualFile srcFile = srcPath != null? LocalFileSystem.getInstance().findFileByPath(srcPath) : null;\n              if (srcFile != null) {\n                final SourceFileInfo srcInfo = loadSourceInfo(srcFile);\n                if (srcInfo != null) {\n                  for (int projectId : srcInfo.getProjectIds().toArray()) {\n                    if (srcInfo.isAssociated(projectId, filePath)) {\n                      addSourceForRecompilation(projectId, srcFile, srcInfo);\n                    }\n                  }\n                }\n              }\n            }\n\n            final SourceFileInfo srcInfo = loadSourceInfo(file);\n            if (srcInfo != null) {\n              final TIntHashSet projects = srcInfo.getProjectIds();\n              if (!projects.isEmpty()) {\n                final ScheduleOutputsForDeletionProc deletionProc = new ScheduleOutputsForDeletionProc(file.getUrl());\n                for (int projectId : projects.toArray()) {\n                  // mark associated outputs for deletion\n                  srcInfo.processOutputPaths(projectId, deletionProc);\n                  removeSourceForRecompilation(projectId, getFileId(file));\n                }\n              }\n            }\n          }\n          finally {\n            // it is important that update of myOutputsToDelete is done at the end\n            // otherwise the filePath of the file that is about to be deleted may be re-scheduled for deletion in addSourceForRecompilation()\n            unmarkOutputPathForDeletion(filePath);\n          }\n        }\n      });\n    }","commit_id":"90d82e461eab0cc3126d82c397232581a20bb8f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void scheduleInvalidation(final VirtualFile file, final boolean saveContent) {\n      if (file.isDirectory()) {\n        if (areChildrenLoaded(file)) {\n          for (VirtualFile child : file.getChildren()) {\n            scheduleInvalidation(child, saveContent); \n          }\n        }\n      }\n      else {\n        final List<ID<?, ?>> affectedIndices = new ArrayList<ID<?, ?>>(myIndices.size());\n        for (ID<?, ?> indexId : myIndices.keySet()) {\n          if (shouldUpdateIndex(file, indexId)) {\n            if (myNeedContentLoading.contains(indexId)) {\n              affectedIndices.add(indexId);\n            }\n            else {\n              // invalidate it synchronously\n              try {\n                updateSingleIndex(indexId, file, null, new FileContent(file, (byte[])null));\n              }\n              catch (StorageException e) {\n                LOG.info(e);\n                requestRebuild(indexId);\n              }\n            }\n          }\n        }\n        \n        if (affectedIndices.size() > 0) {\n          if (saveContent) {\n            myFileContentAttic.offer(file);\n          }\n          else {\n            byte[] content;\n            try {\n              content = file.contentsToByteArray();\n            }\n            catch (IOException e) {\n              content = ArrayUtil.EMPTY_BYTE_ARRAY;\n            }\n            final FileContent fc = new FileContent(file, content);\n            final FutureTask<?> future = (FutureTask<?>)myInvalidationService.submit(new Runnable() {\n              public void run() {\n                for (ID<?, ?> indexId : affectedIndices) {\n                  try {\n                    updateSingleIndex(indexId, file, null, fc);\n                  }\n                  catch (StorageException e) {\n                    LOG.info(e);\n                    requestRebuild(indexId);\n                  }\n                }\n              }\n            });\n            myFutureInvalidations.offer(future);\n          }\n          iterateIndexableFiles(file, new Processor<VirtualFile>() {\n            public boolean process(final VirtualFile file) {\n              myFilesToUpdate.add(file);\n              return true;\n            }\n          });\n        }\n      }\n    }","id":49693,"modified_method":"private void scheduleInvalidation(final VirtualFile file, final boolean saveContent) {\n      if (file.isDirectory()) {\n        if (areChildrenLoaded(file)) {\n          for (VirtualFile child : file.getChildren()) {\n            scheduleInvalidation(child, saveContent); \n          }\n        }\n      }\n      else {\n        final List<ID<?, ?>> affectedIndices = new ArrayList<ID<?, ?>>(myIndices.size());\n        for (ID<?, ?> indexId : myIndices.keySet()) {\n          if (shouldUpdateIndex(file, indexId)) {\n            if (myNeedContentLoading.contains(indexId)) {\n              affectedIndices.add(indexId);\n            }\n            else {\n              // invalidate it synchronously\n              try {\n                updateSingleIndex(indexId, file, null, new FileContent(file, (byte[])null));\n              }\n              catch (StorageException e) {\n                LOG.info(e);\n                requestRebuild(indexId);\n              }\n            }\n          }\n        }\n        \n        if (affectedIndices.size() > 0) {\n          if (saveContent) {\n            myFileContentAttic.offer(file);\n          }\n          else {\n            // first check if there is an unprocessed content from previous events\n            byte[] content = myFileContentAttic.remove(file);\n            try {\n              if (content == null) {\n                content = file.contentsToByteArray();\n              }\n            }\n            catch (IOException e) {\n              content = ArrayUtil.EMPTY_BYTE_ARRAY;\n            }\n            final FileContent fc = new FileContent(file, content);\n            final FutureTask<?> future = (FutureTask<?>)myInvalidationService.submit(new Runnable() {\n              public void run() {\n                for (ID<?, ?> indexId : affectedIndices) {\n                  try {\n                    updateSingleIndex(indexId, file, null, fc);\n                  }\n                  catch (StorageException e) {\n                    LOG.info(e);\n                    requestRebuild(indexId);\n                  }\n                }\n              }\n            });\n            myFutureInvalidations.offer(future);\n          }\n          iterateIndexableFiles(file, new Processor<VirtualFile>() {\n            public boolean process(final VirtualFile file) {\n              myFilesToUpdate.add(file);\n              return true;\n            }\n          });\n        }\n      }\n    }","commit_id":"0f7f8ef0fc160ee0546f66101c9039fa9c90143c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void offer(VirtualFile file) {\n    try {\n      final byte[] bytes = file.contentsToByteArray();\n      if (bytes != null) {\n        synchronized (myLock) {\n          final int fileId = FileBasedIndex.getFileId(file);\n          myFileIds.add(fileId);\n          myCache.put(fileId, bytes);\n        }\n      }\n    }\n    catch (FileNotFoundException ignored) {\n      // may happen, if content was never queried before\n      // In this case the index for this file must not have been built and it is ok to ignore the file\n    }\n    catch (IOException e) {\n      LOG.error(e);\n    }\n  }","id":49694,"modified_method":"public void offer(VirtualFile file) {\n    try {\n      final byte[] bytes = file.contentsToByteArray();\n      if (bytes != null) {\n        synchronized (myLock) {\n          final int fileId = Math.abs(FileBasedIndex.getFileId(file));\n          final boolean added = myFileIds.add(fileId);\n          if (added) {\n            myCache.put(fileId, bytes);\n          }\n        }\n      }\n    }\n    catch (FileNotFoundException ignored) {\n      // may happen, if content was never queried before\n      // In this case the index for this file must not have been built and it is ok to ignore the file\n    }\n    catch (IOException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"0f7f8ef0fc160ee0546f66101c9039fa9c90143c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public synchronized byte[] remove(VirtualFile file) {\n    final int fileId = FileBasedIndex.getFileId(file);\n    synchronized (myLock) {\n      try {\n        return myCache.get(fileId);\n      }\n      finally {\n        myKeyBeingRemoved = fileId;\n        myCache.remove(fileId);\n        myFileIds.remove(fileId);\n        myKeyBeingRemoved = -1;\n      }\n    }\n  }","id":49695,"modified_method":"@Nullable\n  public synchronized byte[] remove(VirtualFile file) {\n    final int fileId = Math.abs(FileBasedIndex.getFileId(file));\n    synchronized (myLock) {\n      try {\n        final byte[] bytes = myCache.get(fileId);\n        myKeyBeingRemoved = fileId;\n        final boolean wasStoredInCache = myCache.remove(fileId);\n        return wasStoredInCache? bytes : null;\n      }\n      finally {\n        myFileIds.remove(fileId);\n        myKeyBeingRemoved = -1;\n      }\n    }\n  }","commit_id":"0f7f8ef0fc160ee0546f66101c9039fa9c90143c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public synchronized byte[] remove(VirtualFile file) {\n    final int fileId = FileBasedIndex.getFileId(file);\n    synchronized (myLock) {\n      try {\n        return myFileIds.contains(fileId)? myCache.get(fileId) : null;\n      }\n      finally {\n        if (myFileIds.remove(fileId)) {\n          myKeyBeingRemoved = fileId;\n          if (!myCache.remove(fileId)) {\n            FileUtil.delete(getDataFile(fileId));\n          }\n          myKeyBeingRemoved = -1;\n        }\n      }\n    }\n  }","id":49696,"modified_method":"@Nullable\n  public synchronized byte[] remove(VirtualFile file) {\n    final int fileId = Math.abs(FileBasedIndex.getFileId(file));\n    synchronized (myLock) {\n      try {\n        return myFileIds.contains(fileId)? myCache.get(fileId) : null;\n      }\n      finally {\n        if (myFileIds.remove(fileId)) {\n          myKeyBeingRemoved = fileId;\n          if (!myCache.remove(fileId)) {\n            FileUtil.delete(getDataFile(fileId));\n          }\n          myKeyBeingRemoved = -1;\n        }\n      }\n    }\n  }","commit_id":"083a74d9f935fb2bfe058f4d55e1be03662731d5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Gets a stream to read the data of a block. The stream is backed by Tachyon storage.\n   *\n   * @param blockId the block to read from\n   * @return a BlockInStream which can be used to read the data in a streaming fashion\n   * @throws IOException if the block does not exist\n   */\n  public BufferedBlockInStream getInStream(long blockId) throws IOException {\n    BlockMasterClient masterClient = mContext.acquireMasterClient();\n    try {\n      // TODO(calvin): Fix this RPC.\n      BlockInfo blockInfo = masterClient.getBlockInfo(blockId);\n      // TODO(calvin): Get location via a policy.\n      if (blockInfo.locations.isEmpty()) {\n        // TODO(calvin): Maybe this shouldn't be an exception.\n        throw new IOException(\"No block \" + blockId + \" is not available in Tachyon\");\n      }\n      // TODO(calvin): Investigate making this a Factory method\n      NetAddress workerNetAddress = blockInfo.locations.get(0).getWorkerAddress();\n      InetSocketAddress workerAddr =\n          new InetSocketAddress(workerNetAddress.getHost(), workerNetAddress.getDataPort());\n      if (NetworkAddressUtils.getLocalHostName(ClientContext.getConf()).equals(\n          workerAddr.getHostName())) {\n        if (mContext.hasLocalWorker()) {\n          return new LocalBlockInStream(blockId, blockInfo.getLength(), workerAddr);\n        } else {\n          throw new IOException(\"Local read requested but there is no local worker.\");\n        }\n      } else {\n        return new RemoteBlockInStream(blockId, blockInfo.getLength(), workerAddr);\n      }\n    } finally {\n      mContext.releaseMasterClient(masterClient);\n    }\n  }","id":49697,"modified_method":"/**\n   * Gets a stream to read the data of a block. The stream is backed by Tachyon storage.\n   *\n   * @param blockId the block to read from\n   * @return a BlockInStream which can be used to read the data in a streaming fashion\n   * @throws IOException if the block does not exist\n   */\n  public BufferedBlockInStream getInStream(long blockId) throws IOException {\n    BlockMasterClient masterClient = mContext.acquireMasterClient();\n    try {\n      // TODO(calvin): Fix this RPC.\n      BlockInfo blockInfo = masterClient.getBlockInfo(blockId);\n      if (blockInfo.locations.isEmpty()) {\n        throw new IOException(\"Block \" + blockId + \" is not available in Tachyon\");\n      }\n      // TODO(calvin): Get location via a policy.\n      // Although blockInfo.locations are sorted by tier, we prefer reading from the local worker.\n      // But when there is no local worker or there are no local blocks, we prefer the first\n      // location in blockInfo.locations that is nearest to memory tier.\n      String localHostName = NetworkAddressUtils.getLocalHostName(ClientContext.getConf());\n      for (BlockLocation location : blockInfo.locations) {\n        NetAddress workerNetAddress = location.getWorkerAddress();\n        if (workerNetAddress.getHost().equals(localHostName)) {\n          if (mContext.hasLocalWorker()) {\n            // There is a local worker and the block is local.\n            return new LocalBlockInStream(blockId, blockInfo.getLength(),\n                new InetSocketAddress(workerNetAddress.getHost(), workerNetAddress.getDataPort()));\n          } else {\n            throw new IOException(\"Attempts to read a local block but there is no local worker.\");\n          }\n        }\n      }\n      // No local block, get the first location since it's nearest to memory tier.\n      NetAddress workerNetAddress = blockInfo.locations.get(0).getWorkerAddress();\n      return new RemoteBlockInStream(blockId, blockInfo.getLength(),\n          new InetSocketAddress(workerNetAddress.getHost(), workerNetAddress.getDataPort()));\n    } finally {\n      mContext.releaseMasterClient(masterClient);\n    }\n  }","commit_id":"9783c1c66fd547470ebbd75a956fab4b0a31135a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Gets a stream to write data to a block. The stream can only be backed by Alluxio storage.\n   *\n   * @param blockId the block to write\n   * @param blockSize the standard block size to write, or -1 if the block already exists (and this\n   *        stream is just storing the block in Alluxio again)\n   * @param address the address of the worker to write the block to, fails if the worker cannot\n   *        serve the request\n   * @return a {@link BufferedBlockOutStream} which can be used to write data to the block in a\n   *         streaming fashion\n   * @throws IOException if the block cannot be written\n   */\n  public BufferedBlockOutStream getOutStream(long blockId, long blockSize, WorkerNetAddress address)\n      throws IOException {\n    if (blockSize == -1) {\n      try (CloseableResource<BlockMasterClient> blockMasterClientResource =\n          mContext.acquireMasterClientResource()) {\n        blockSize = blockMasterClientResource.get().getBlockInfo(blockId).getLength();\n      } catch (AlluxioException e) {\n        throw new IOException(e);\n      }\n    }\n    // No specified location to write to.\n    if (address == null) {\n      throw new RuntimeException(ExceptionMessage.NO_WORKER_AVAILABLE.getMessage());\n    }\n    // Location is local.\n    if (NetworkAddressUtils.getLocalHostName(ClientContext.getConf()).equals(address.getHost())) {\n      if (mContext.hasLocalWorker()) {\n        return new LocalBlockOutStream(blockId, blockSize);\n      } else {\n        throw new IOException(ExceptionMessage.NO_LOCAL_WORKER.getMessage(\"write\"));\n      }\n    }\n    // Location is specified and it is remote.\n    return new RemoteBlockOutStream(blockId, blockSize, address);\n  }","id":49698,"modified_method":"/**\n   * Gets a stream to write data to a block. The stream can only be backed by Alluxio storage.\n   *\n   * @param blockId the block to write\n   * @param blockSize the standard block size to write, or -1 if the block already exists (and this\n   *        stream is just storing the block in Alluxio again)\n   * @param address the address of the worker to write the block to, fails if the worker cannot\n   *        serve the request\n   * @return a {@link BufferedBlockOutStream} which can be used to write data to the block in a\n   *         streaming fashion\n   * @throws IOException if the block cannot be written\n   */\n  public BufferedBlockOutStream getOutStream(long blockId, long blockSize, WorkerNetAddress address)\n      throws IOException {\n    if (blockSize == -1) {\n      try (CloseableResource<BlockMasterClient> blockMasterClientResource =\n          mContext.acquireMasterClientResource()) {\n        blockSize = blockMasterClientResource.get().getBlockInfo(blockId).getLength();\n      } catch (AlluxioException e) {\n        throw new IOException(e);\n      }\n    }\n    // No specified location to write to.\n    if (address == null) {\n      throw new RuntimeException(ExceptionMessage.NO_WORKER_AVAILABLE.getMessage());\n    }\n    // Location is local.\n    if (NetworkAddressUtils.getLocalHostName(ClientContext.getConf()).equals(address.getHost())) {\n      return new LocalBlockOutStream(blockId, blockSize, address);\n    }\n    // Location is specified and it is remote.\n    return new RemoteBlockOutStream(blockId, blockSize, address);\n  }","commit_id":"3bb2d6971c1209f961bf7a5a0ceecac5f45ca644","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new local block output stream.\n   *\n   * @param blockId the block id\n   * @param blockSize the block size\n   * @throws IOException if an I/O error occurs\n   */\n  public LocalBlockOutStream(long blockId, long blockSize) throws IOException {\n    super(blockId, blockSize);\n    mCloser = Closer.create();\n    mBlockWorkerClient =\n        mContext.acquireWorkerClient(NetworkAddressUtils.getLocalHostName(ClientContext.getConf()));\n\n    try {\n      long initialSize = ClientContext.getConf().getBytes(Constants.USER_FILE_BUFFER_BYTES);\n      String blockPath = mBlockWorkerClient.requestBlockLocation(mBlockId, initialSize);\n      mReservedBytes += initialSize;\n      FileUtils.createBlockPath(blockPath);\n      mWriter = new LocalFileBlockWriter(blockPath);\n      mCloser.register(mWriter);\n      // Change the permission of the temporary file in order that the worker can move it.\n      FileUtils.changeLocalFileToFullPermission(blockPath);\n      LOG.info(\"LocalBlockOutStream created new file block, block path: {}\", blockPath);\n    } catch (IOException e) {\n      mContext.releaseWorkerClient(mBlockWorkerClient);\n      throw e;\n    }\n  }","id":49699,"modified_method":"/**\n   * Creates a new local block output stream.\n   *\n   * @param blockId the block id\n   * @param blockSize the block size\n   * @param workerAddress the address of the local worker\n   * @throws IOException if an I/O error occurs\n   */\n  public LocalBlockOutStream(long blockId, long blockSize, WorkerNetAddress workerAddress)\n      throws IOException {\n    super(blockId, blockSize);\n    if (!NetworkAddressUtils.getLocalHostName(ClientContext.getConf())\n        .equals(workerAddress.getHost())) {\n      throw new IOException(\"The worker address \" + workerAddress + \" is not local\");\n    }\n\n    mCloser = Closer.create();\n    mBlockWorkerClient = mContext.acquireWorkerClient(workerAddress);\n\n    try {\n      long initialSize = ClientContext.getConf().getBytes(Constants.USER_FILE_BUFFER_BYTES);\n      String blockPath = mBlockWorkerClient.requestBlockLocation(mBlockId, initialSize);\n      mReservedBytes += initialSize;\n      FileUtils.createBlockPath(blockPath);\n      mWriter = new LocalFileBlockWriter(blockPath);\n      mCloser.register(mWriter);\n      // Change the permission of the temporary file in order that the worker can move it.\n      FileUtils.changeLocalFileToFullPermission(blockPath);\n      LOG.info(\"LocalBlockOutStream created new file block, block path: {}\", blockPath);\n    } catch (IOException e) {\n      mContext.releaseWorkerClient(mBlockWorkerClient);\n      throw e;\n    }\n  }","commit_id":"3bb2d6971c1209f961bf7a5a0ceecac5f45ca644","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new remote block input stream.\n   *\n   * @param blockId the block id\n   * @param blockSize the block size\n   * @param workerNetAddress the address of the worker to read from\n   * @throws IOException if the block is not available on the remote worker\n   */\n  public RemoteBlockInStream(long blockId, long blockSize, WorkerNetAddress workerNetAddress)\n      throws IOException {\n    super(blockId, blockSize);\n    mWorkerNetAddress = workerNetAddress;\n    mWorkerInetSocketAddress =\n        new InetSocketAddress(workerNetAddress.getHost(), workerNetAddress.getDataPort());\n\n    mContext = BlockStoreContext.INSTANCE;\n    mBlockWorkerClient = mContext.acquireWorkerClient(mWorkerInetSocketAddress.getHostName());\n\n    try {\n      mLockId = mBlockWorkerClient.lockBlock(blockId).getLockId();\n      if (mLockId == null) {\n        throw new IOException(ExceptionMessage.BLOCK_UNAVAILABLE.getMessage(blockId));\n      }\n      mMetrics = mBlockWorkerClient.getClientMetrics();\n    } catch (IOException e) {\n      mContext.releaseWorkerClient(mBlockWorkerClient);\n      throw e;\n    }\n  }","id":49700,"modified_method":"/**\n   * Creates a new remote block input stream.\n   *\n   * @param blockId the block id\n   * @param blockSize the block size\n   * @param address the worker address\n   * @throws IOException if the block is not available on the remote worker\n   */\n  public RemoteBlockInStream(long blockId, long blockSize, WorkerNetAddress address)\n      throws IOException {\n    super(blockId, blockSize);\n    mWorkerNetAddress = address;\n    mWorkerInetSocketAddress = new InetSocketAddress(address.getHost(), address.getDataPort());\n\n    mContext = BlockStoreContext.INSTANCE;\n    mBlockWorkerClient = mContext.acquireWorkerClient(address);\n\n    try {\n      mLockId = mBlockWorkerClient.lockBlock(blockId).getLockId();\n      if (mLockId == null) {\n        throw new IOException(ExceptionMessage.BLOCK_UNAVAILABLE.getMessage(blockId));\n      }\n      mMetrics = mBlockWorkerClient.getClientMetrics();\n    } catch (IOException e) {\n      mContext.releaseWorkerClient(mBlockWorkerClient);\n      throw e;\n    }\n  }","commit_id":"3bb2d6971c1209f961bf7a5a0ceecac5f45ca644","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a {@link BlockWorkerClient}.\n   *\n   * @param workerNetAddress to worker's location\n   * @param executorService the executor service\n   * @param conf Alluxio configuration\n   * @param sessionId the id of the session\n   * @param isLocal true if it is a local client, false otherwise\n   * @param clientMetrics metrics of the client\n   */\n  public BlockWorkerClient(WorkerNetAddress workerNetAddress, ExecutorService executorService,\n      Configuration conf, long sessionId, boolean isLocal, ClientMetrics clientMetrics) {\n    super(NetworkAddressUtils.getRpcPortSocketAddress(workerNetAddress), conf, \"blockWorker\");\n    mWorkerDataServerAddress = NetworkAddressUtils.getDataPortSocketAddress(workerNetAddress);\n    mExecutorService = Preconditions.checkNotNull(executorService);\n    mSessionId = sessionId;\n    mIsLocal = isLocal;\n    mClientMetrics = Preconditions.checkNotNull(clientMetrics);\n    mHeartbeatExecutor = new BlockWorkerClientHeartbeatExecutor(this);\n  }","id":49701,"modified_method":"/**\n   * Creates a {@link BlockWorkerClient}.\n   *\n   * @param workerNetAddress to worker's location\n   * @param executorService the executor service\n   * @param conf Alluxio configuration\n   * @param sessionId the id of the session\n   * @param isLocal true if it is a local client, false otherwise\n   * @param clientMetrics metrics of the client\n   */\n  public BlockWorkerClient(WorkerNetAddress workerNetAddress, ExecutorService executorService,\n      Configuration conf, long sessionId, boolean isLocal, ClientMetrics clientMetrics) {\n    super(NetworkAddressUtils.getRpcPortSocketAddress(workerNetAddress), conf, \"blockWorker\");\n    mWorkerNetAddress = workerNetAddress;\n    mWorkerDataServerAddress = NetworkAddressUtils.getDataPortSocketAddress(workerNetAddress);\n    mExecutorService = Preconditions.checkNotNull(executorService);\n    mSessionId = sessionId;\n    mIsLocal = isLocal;\n    mClientMetrics = Preconditions.checkNotNull(clientMetrics);\n    mHeartbeatExecutor = new BlockWorkerClientHeartbeatExecutor(this);\n  }","commit_id":"d9d600facf1d962c06a4107b759fbea877382e73","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new local block input stream.\n   *\n   * @param blockId the block id\n   * @param blockSize the size of the block\n   * @throws IOException if I/O error occurs\n   */\n  public LocalBlockInStream(long blockId, long blockSize) throws IOException {\n    super(blockId, blockSize);\n    mContext = BlockStoreContext.INSTANCE;\n\n    mCloser = Closer.create();\n    mBlockWorkerClient =\n        mContext.acquireWorkerClient(NetworkAddressUtils.getLocalHostName(ClientContext.getConf()));\n    try {\n      LockBlockResult result = mBlockWorkerClient.lockBlock(blockId);\n      if (result == null) {\n        throw new IOException(ExceptionMessage.BLOCK_NOT_LOCALLY_AVAILABLE.getMessage(mBlockId));\n      }\n      mReader = new LocalFileBlockReader(result.getBlockPath());\n      mCloser.register(mReader);\n    } catch (IOException e) {\n      mContext.releaseWorkerClient(mBlockWorkerClient);\n      throw e;\n    }\n  }","id":49702,"modified_method":"/**\n   * Creates a new local block input stream.\n   *\n   * @param blockId the block id\n   * @param blockSize the size of the block\n   * @param workerAddress the address of the local worker\n   * @throws IOException if I/O error occurs\n   */\n  public LocalBlockInStream(long blockId, long blockSize, WorkerNetAddress workerAddress)\n      throws IOException {\n    super(blockId, blockSize);\n    if (!NetworkAddressUtils.getLocalHostName(ClientContext.getConf())\n        .equals(workerAddress.getHost())) {\n      throw new IOException(\"The worker address \" + workerAddress + \" is not local\");\n    }\n    mContext = BlockStoreContext.INSTANCE;\n\n    mCloser = Closer.create();\n    mBlockWorkerClient = mContext.acquireWorkerClient(workerAddress);\n    try {\n      LockBlockResult result = mBlockWorkerClient.lockBlock(blockId);\n      if (result == null) {\n        throw new IOException(ExceptionMessage.BLOCK_NOT_LOCALLY_AVAILABLE.getMessage(mBlockId));\n      }\n      mReader = new LocalFileBlockReader(result.getBlockPath());\n      mCloser.register(mReader);\n    } catch (IOException e) {\n      mContext.releaseWorkerClient(mBlockWorkerClient);\n      throw e;\n    }\n  }","commit_id":"d9d600facf1d962c06a4107b759fbea877382e73","url":"https://github.com/amplab/tachyon"},{"original_method":"@NotNull\n  final IndexedElementInvocationHandler getFixedChild(final Pair<FixedChildDescriptionImpl, Integer> info) {\n    final FixedChildDescriptionImpl description = info.first;\n    final EvaluatedXmlName evaluatedXmlName = createEvaluatedXmlName(description.getXmlName());\n    final XmlTag tag = getXmlTag();\n    final int index = info.second;\n    if (tag != null) {\n      if (!LOG.assertTrue(tag.isValid())) {\n        throw new PsiInvalidElementAccessException(tag);\n      }\n      final List<XmlTag> tags = DomImplUtil.findSubTags(tag.getSubTags(), evaluatedXmlName, getFile());\n      if (tags.size() > index) {\n        return myManager.getSemService().getSemElement(DomManagerImpl.DOM_INDEXED_HANDLER_KEY, tags.get(index));\n      }\n    }\n    return new IndexedElementInvocationHandler(evaluatedXmlName, description, index, new VirtualDomParentStrategy(this), myManager, \"\");\n  }","id":49703,"modified_method":"@NotNull\n  final IndexedElementInvocationHandler getFixedChild(final Pair<FixedChildDescriptionImpl, Integer> info) {\n    final FixedChildDescriptionImpl description = info.first;\n    final EvaluatedXmlName evaluatedXmlName = createEvaluatedXmlName(description.getXmlName());\n    final XmlTag tag = getXmlTag();\n    final int index = info.second;\n    if (tag != null) {\n      if (!tag.isValid()) {\n        throw new PsiInvalidElementAccessException(tag);\n      }\n      final XmlTag[] subTags = tag.getSubTags();\n      for (XmlTag xmlTag : subTags) {\n        if (!xmlTag.isValid()) {\n          throw new PsiInvalidElementAccessException(xmlTag, \"invalid children of valid tag: \" + tag.getText());\n        }\n      }\n      final List<XmlTag> tags = DomImplUtil.findSubTags(subTags, evaluatedXmlName, getFile());\n      if (tags.size() > index) {\n        return myManager.getSemService().getSemElement(DomManagerImpl.DOM_INDEXED_HANDLER_KEY, tags.get(index));\n      }\n    }\n    return new IndexedElementInvocationHandler(evaluatedXmlName, description, index, new VirtualDomParentStrategy(this), myManager, \"\");\n  }","commit_id":"2933f52ce117423bfaa202231158f018c94921bc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void invoke(@NotNull Project project, Editor editor, @NotNull PsiElement element) throws IncorrectOperationException {\n    if (!CodeInsightUtilBase.preparePsiElementsForWrite(element)) return;\n    final XmlTag tag = (XmlTag)element.getParent();\n    final XmlAttribute attribute = XmlElementFactory.getInstance(project).createXmlAttribute(tag.getName(), tag.getValue().getText().trim());\n    final XmlTag parentTag = tag.getParentTag();\n    parentTag.add(attribute);\n    tag.delete();\n  }","id":49704,"modified_method":"@Override\n  public void invoke(@NotNull Project project, Editor editor, @NotNull PsiElement element) throws IncorrectOperationException {\n    if (!CodeInsightUtilBase.preparePsiElementsForWrite(element)) return;\n    final XmlTag tag = (XmlTag)element.getParent();\n    final String value;\n    if (tag.getSubTags().length == 0) {\n      value = tag.getValue().getText().trim();\n    }\n    else {\n      value = StringUtil.join(tag.getSubTags(), new Function<XmlTag, String>() {\n        @Override\n        public String fun(XmlTag childTag) {\n          final XmlAttribute valueAttr = childTag.getAttribute(FxmlConstants.FX_VALUE);\n          if (valueAttr != null) {\n            return valueAttr.getValue();\n          }\n          return \"\";\n        }\n      }, \", \");\n    }\n    final XmlAttribute attribute = XmlElementFactory.getInstance(project).createXmlAttribute(tag.getName(), value);\n    final XmlTag parentTag = tag.getParentTag();\n    parentTag.add(attribute);\n    tag.delete();\n  }","commit_id":"124689fa7b12aee1899897e33fc0dc5f07c1a4a2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isAvailable(@NotNull Project project, Editor editor, @NotNull PsiElement element) {\n    if (element instanceof XmlToken && ((XmlToken)element).getTokenType() == XmlTokenType.XML_NAME && element.getParent() instanceof XmlTag) {\n      final XmlTag tag = (XmlTag)element.getParent();\n      if (tag.getSubTags().length == 0) {\n        final XmlTag parentTag = tag.getParentTag();\n        if (parentTag != null &&\n            tag.getDescriptor() instanceof JavaFxPropertyElementDescriptor &&\n            parentTag.getDescriptor() instanceof JavaFxClassBackedElementDescriptor) {\n  \n          setText(\"Collapse tag '\" + tag.getName() + \"' to attribute\");\n          return true;\n        }\n      }\n    }\n    return false;\n  }","id":49705,"modified_method":"@Override\n  public boolean isAvailable(@NotNull Project project, Editor editor, @NotNull PsiElement element) {\n    if (element instanceof XmlToken && ((XmlToken)element).getTokenType() == XmlTokenType.XML_NAME && element.getParent() instanceof XmlTag) {\n      final XmlTag tag = (XmlTag)element.getParent();\n      for (XmlTag xmlTag : tag.getSubTags()) {\n        if (xmlTag.getAttribute(FxmlConstants.FX_VALUE) == null) return false;\n      }\n      final XmlTag parentTag = tag.getParentTag();\n      if (parentTag != null &&\n          tag.getDescriptor() instanceof JavaFxPropertyElementDescriptor &&\n          parentTag.getDescriptor() instanceof JavaFxClassBackedElementDescriptor) {\n\n        setText(\"Collapse tag '\" + tag.getName() + \"' to attribute\");\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"124689fa7b12aee1899897e33fc0dc5f07c1a4a2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<XmlTag> findSubTags(@NotNull XmlTag tag, final EvaluatedXmlName name, final XmlFile file) {\n    return findSubTags(tag.getSubTags(), name, file);\n  }","id":49706,"modified_method":"public static List<XmlTag> findSubTags(@NotNull XmlTag tag, final EvaluatedXmlName name, final XmlFile file) {\n    assert tag.isValid();\n    XmlTag[] subTags = tag.getSubTags();\n    for (XmlTag subTag : subTags) {\n      assert subTag.isValid() : \"tag.getSubTags() returned invalid, tag=\" + tag + \", subTag.parent=\" + subTag.getNode().getTreeParent();\n    }\n    return findSubTags(subTags, name, file);\n  }","commit_id":"1dfc6709a7dcc6d9fa7f071a6d5aa32cdcbadc84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean _canContainTag(String localName, String namespace, XmlTag tag,Set<XmlTag> visited) {\n    if (visited.contains(tag)) return false;\n    visited.add(tag);\n\n    if (XmlNSDescriptorImpl.equalsToSchemaName(tag, \"any\")) {\n      if (OTHER_NAMESPACE_ATTR_VALUE.equals(tag.getAttributeValue(\"namespace\"))) {\n        return namespace == null || !namespace.equals(myDocumentDescriptor.getDefaultNamespace());\n      }\n      return true;\n    }\n    else if (XmlNSDescriptorImpl.equalsToSchemaName(tag, \"group\")) {\n      String ref = tag.getAttributeValue(\"ref\");\n\n      if (ref != null) {\n        XmlTag groupTag = myDocumentDescriptor.findGroup(ref);\n        if (groupTag != null && _canContainTag(localName, namespace, groupTag,visited)) return true;\n      }\n    }\n    else if (XmlNSDescriptorImpl.equalsToSchemaName(tag, \"restriction\") ||\n             XmlNSDescriptorImpl.equalsToSchemaName(tag, \"extension\")) {\n      String base = tag.getAttributeValue(\"base\");\n\n      if (base != null) {\n        TypeDescriptor descriptor = myDocumentDescriptor.findTypeDescriptor(\n          myDocumentDescriptor.getTag(),\n          base);\n\n        if (descriptor instanceof ComplexTypeDescriptor) {\n          ComplexTypeDescriptor complexTypeDescriptor = (ComplexTypeDescriptor)descriptor;\n          if (complexTypeDescriptor.canContainTag(localName, namespace)) return true;\n        }\n      }\n    }\n\n    XmlTag[] subTags = tag.getSubTags();\n    for (int i = 0; i < subTags.length; i++) {\n      XmlTag subTag = subTags[i];\n      if (_canContainTag(localName, namespace, subTag, visited)) return true;\n    }\n\n    return false;\n  }","id":49707,"modified_method":"private boolean _canContainTag(String localName, String namespace, XmlTag tag,Set<XmlTag> visited) {\n    if (visited.contains(tag)) return false;\n    visited.add(tag);\n\n    if (XmlNSDescriptorImpl.equalsToSchemaName(tag, \"any\")) {\n      if (OTHER_NAMESPACE_ATTR_VALUE.equals(tag.getAttributeValue(\"namespace\"))) {\n        return namespace == null || !namespace.equals(myDocumentDescriptor.getDefaultNamespace());\n      }\n      return true;\n    }\n    else if (XmlNSDescriptorImpl.equalsToSchemaName(tag, \"group\")) {\n      String ref = tag.getAttributeValue(\"ref\");\n\n      if (ref != null) {\n        XmlTag groupTag = myDocumentDescriptor.findGroup(ref);\n        if (groupTag != null && _canContainTag(localName, namespace, groupTag,visited)) return true;\n      }\n    }\n    else if (XmlNSDescriptorImpl.equalsToSchemaName(tag, \"restriction\") ||\n             XmlNSDescriptorImpl.equalsToSchemaName(tag, \"extension\")) {\n      String base = tag.getAttributeValue(\"base\");\n\n      if (base != null) {\n        TypeDescriptor descriptor = myDocumentDescriptor.findTypeDescriptor(\n          myDocumentDescriptor.getTag(),\n          base);\n\n        if (descriptor instanceof ComplexTypeDescriptor) {\n          ComplexTypeDescriptor complexTypeDescriptor = (ComplexTypeDescriptor)descriptor;\n          if (complexTypeDescriptor.canContainTag(localName, namespace)) return true;\n        }\n      }\n    } else if (XmlNSDescriptorImpl.equalsToSchemaName(tag, \"element\")) {\n      final String ref = tag.getAttributeValue(\"ref\");\n      XmlTag descriptorTag = tag;\n\n      if (ref != null) {\n        final PsiElement psiElement = tag.getAttribute(\"ref\", null).getValueElement().getReferences()[0].resolve();\n        if (psiElement instanceof XmlTag) descriptorTag = (XmlTag)psiElement;\n      }\n\n      if (\"true\".equals(descriptorTag.getAttributeValue(\"abstract\"))) {\n\n        final XmlNSDescriptorImpl nsDescriptor = (XmlNSDescriptorImpl)tag.getNSDescriptor(namespace, true);\n        final XmlElementDescriptor descriptor = nsDescriptor != null ? nsDescriptor.getElementDescriptor(localName, namespace):null;\n        final String name = descriptorTag.getAttributeValue(\"name\");\n\n        if (descriptor != null &&\n            name != null) {\n          final String substitutionValue = ((XmlTag)descriptor.getDeclaration()).getAttributeValue(\"substitutionGroup\");\n\n          if (substitutionValue != null && name.equals(XmlUtil.findLocalNameByQualifiedName(substitutionValue))) {\n            return true; // could be more parent-child relation complex!!!\n          }\n        }\n    }\n    }\n\n    for (XmlTag subTag : tag.getSubTags()) {\n      if (_canContainTag(localName, namespace, subTag, visited)) return true;\n    }\n\n    return false;\n  }","commit_id":"61f51fb3aa73bfa4ecce9fdb2ace9f004e1848c6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setContext(EvaluationContextImpl context) {\n    ThreadReferenceProxyImpl thread = getThreadReference();\n\n    SuspendManager suspendManager = context.getDebugProcess().getSuspendManager();\n    myIsSuspended    = suspendManager.isSuspended(thread);\n    myIsExpandable   = calcExpandable(suspendManager);\n    mySuspendContext = SuspendManagerUtil.getSuspendContextForThread(context.getSuspendContext(), thread);\n    myIsAtBreakpoint = SuspendManagerUtil.findContextByThread(suspendManager, thread) != null;\n    myIsCurrent      = calcIsCurrent(context);\n    myIsFrozen       = suspendManager.isFrozen(getThreadReference());\n  }","id":49708,"modified_method":"public void setContext(EvaluationContextImpl context) {\n    final ThreadReferenceProxyImpl thread = getThreadReference();\n    final SuspendManager suspendManager = context.getDebugProcess().getSuspendManager();\n    final SuspendContextImpl suspendContext = context.getSuspendContext();\n\n    myIsSuspended    = suspendManager.isSuspended(thread);\n    myIsExpandable   = calcExpandable(myIsSuspended);\n    mySuspendContext = SuspendManagerUtil.getSuspendContextForThread(suspendContext, thread);\n    myIsAtBreakpoint = SuspendManagerUtil.findContextByThread(suspendManager, thread) != null;\n    myIsCurrent      = suspendContext.getThread() == thread;\n    myIsFrozen       = suspendManager.isFrozen(thread);\n  }","commit_id":"bf45a4d3b7474d749a5c8c22591afcfecb5bbef2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Icon getIcon() {\n    Icon nodeIcon;\n    if(isCurrent()) {\n      nodeIcon = myCurrentThreadIcon;\n    }\n    else if(isFrozen()) {\n      nodeIcon = myFrozenThreadIcon;\n    }\n    else if(isAtBreakpoint()) {\n      nodeIcon = myThreadAtBreakpointIcon;\n    }\n    else if(isSuspended()) {\n      nodeIcon = mySuspendedThreadIcon;\n    } else {\n      nodeIcon = myRunningThreadIcon;\n    }\n    return nodeIcon;\n  }","id":49709,"modified_method":"public Icon getIcon() {\n    if(isCurrent()) {\n      return myCurrentThreadIcon;\n    }\n    if(isFrozen()) {\n      return myFrozenThreadIcon;\n    }\n    if(isAtBreakpoint()) {\n      return myThreadAtBreakpointIcon;\n    }\n    if(isSuspended()) {\n      return mySuspendedThreadIcon;\n    }\n    return myRunningThreadIcon;\n  }","commit_id":"bf45a4d3b7474d749a5c8c22591afcfecb5bbef2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ButtonEditorTab(ButtonTabsComponent tabComponent, NodeChangeCallback callback, int index, RelationDescriptor descriptor, SNodeReference baseNode, TabColorProvider tabColorProvider, JComponent editor) {\n        myTabComponent = tabComponent;\n        myCallback = callback;\n        myIndex = index;\n        myDescriptor = descriptor;\n        myBaseNode = baseNode;\n        myTabColorProvider = tabColorProvider;\n        mySelectTabAction = createAction(editor);\n    }","id":49710,"modified_method":"public ButtonEditorTab(ButtonTabsComponent tabComponent, int index, RelationDescriptor descriptor, SNodeReference baseNode, TabColorProvider tabColorProvider) {\n    myTabComponent = tabComponent;\n    myIndex = index;\n    myDescriptor = descriptor;\n    myBaseNode = baseNode;\n    myTabColorProvider = tabColorProvider;\n  }","commit_id":"122409dff7b519b390a2ecefbbb247d81243eca9","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Icon createCompositeTabIcon() {\n        Font font = UIUtil.getLabelFont();\n        FontMetrics fontMetrics = myTabComponent.getComponent().getFontMetrics(font);\n        Icon icon = myDescriptor.getIcon();\n\n        Dimension size = new Dimension(ActionToolbar.DEFAULT_MINIMUM_BUTTON_SIZE);\n        size.width -= 4;\n        size.height -= 4;\n        if (icon != null && (icon.getIconWidth() > size.width && icon.getIconHeight() > size.height)) {\n            size.width = icon.getIconWidth();\n            size.height = icon.getIconHeight();\n        }\n\n        String text = myDescriptor.getTitle();\n        int textWidth = fontMetrics.stringWidth(text);\n        int textHeight = fontMetrics.getMaxAscent() + fontMetrics.getMaxDescent();\n\n        size.width += 2 + textWidth;\n        BufferedImage image = new BufferedImage(size.width, size.height, BufferedImage.TYPE_INT_ARGB);\n        Graphics g = image.getGraphics();\n\n        int textX = 0;\n        int textY = (size.height - textHeight) / 2 + fontMetrics.getMaxAscent();\n\n        if (icon != null) {\n            int x = (size.width - icon.getIconWidth() - textWidth) / 2;\n            int y = (size.height - icon.getIconHeight()) / 2;\n            icon.paintIcon(null, g, x, y);\n            textX = x + icon.getIconWidth() + 2;\n        }\n\n        UIUtil.applyRenderingHints(g);\n        Color color = getButtonForegroundColor();\n        if (color != null) {\n            g.setColor(color);\n        }\n        g.setFont(font);\n        g.drawString(text, textX, textY);\n\n        Character shortcutChar = myDescriptor.getShortcutChar();\n        if (shortcutChar != null) {\n            final int mnemonicIndex = text.indexOf(shortcutChar);\n            if (mnemonicIndex >= 0) {\n                final char[] chars = text.toCharArray();\n                final int startX = textX + fontMetrics.charsWidth(chars, 0, mnemonicIndex);\n                final int startY = textY + fontMetrics.getMaxDescent();\n                final int endX = startX + fontMetrics.charWidth(text.charAt(mnemonicIndex));\n                UIUtil.drawLine(g, startX, startY, endX, startY);\n            }\n        }\n\n        return new ImageIcon(image);\n    }","id":49711,"modified_method":"private Icon createCompositeTabIcon() {\n    Font font = UIUtil.getLabelFont();\n    FontMetrics fontMetrics = myTabComponent.getComponent().getFontMetrics(font);\n    Icon icon = myDescriptor.getIcon();\n\n    Dimension size = new Dimension(ActionToolbar.DEFAULT_MINIMUM_BUTTON_SIZE);\n    size.width -= 4;\n    size.height -= 4;\n    if (icon != null && (icon.getIconWidth() > size.width && icon.getIconHeight() > size.height)) {\n      size.width = icon.getIconWidth();\n      size.height = icon.getIconHeight();\n    }\n\n    String text = myDescriptor.getTitle();\n    int textWidth = fontMetrics.stringWidth(text);\n    int textHeight = fontMetrics.getMaxAscent() + fontMetrics.getMaxDescent();\n\n    size.width += 2 + textWidth;\n    BufferedImage image = UIUtil.createImage(size.width, size.height, BufferedImage.TYPE_INT_ARGB);\n    Graphics g = image.getGraphics();\n\n    int textX = 0;\n    int textY = (size.height - textHeight) / 2 + fontMetrics.getMaxAscent();\n\n    if (icon != null) {\n      int x = (size.width - icon.getIconWidth() - textWidth) / 2;\n      int y = (size.height - icon.getIconHeight()) / 2;\n      icon.paintIcon(null, g, x, y);\n      textX = x + icon.getIconWidth() + 2;\n    }\n\n    UIUtil.applyRenderingHints(g);\n    Color color = getButtonForegroundColor();\n    if (color != null) {\n      g.setColor(color);\n    }\n    g.setFont(font);\n    g.drawString(text, textX, textY);\n\n    Character shortcutChar = myDescriptor.getShortcutChar();\n    if (shortcutChar != null) {\n      final int mnemonicIndex = text.indexOf(shortcutChar);\n      if (mnemonicIndex >= 0) {\n        final char[] chars = text.toCharArray();\n        final int startX = textX + fontMetrics.charsWidth(chars, 0, mnemonicIndex);\n        final int startY = textY + fontMetrics.getMaxDescent();\n        final int endX = startX + fontMetrics.charWidth(text.charAt(mnemonicIndex));\n        UIUtil.drawLine(g, startX, startY, endX, startY);\n      }\n    }\n\n    return new ImageIcon(image);\n  }","commit_id":"122409dff7b519b390a2ecefbbb247d81243eca9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void updateIcon() {\n        mySelectTabAction.myIcon = createCompositeTabIcon();\n    }","id":49712,"modified_method":"public void updateIcon() {\n    mySelectTabAction.updateIcon(createCompositeTabIcon());\n  }","commit_id":"122409dff7b519b390a2ecefbbb247d81243eca9","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public RelationDescriptor getCurrentTabAspect() {\n    SNode currentAspect = getLastNode().resolve(MPSModuleRepository.getInstance());\n    assert currentAspect != null;\n\n    for (final ButtonEditorTab bet : myRealTabs) {\n      RelationDescriptor d = bet.getDescriptor();\n      List<SNode> nodes = d.getNodes(myBaseNode.resolve(MPSModuleRepository.getInstance()));\n      if (nodes.contains(currentAspect)) return d;\n    }\n\n    return null;\n  }","id":49713,"modified_method":"@Override\n  public RelationDescriptor getCurrentTabAspect() {\n    SNode currentAspect = getLastNode().resolve(MPSModuleRepository.getInstance());\n    assert currentAspect != null;\n\n    for (final ButtonEditorTab bet : myRealTabs) {\n      if (bet.getNodes().contains(currentAspect)) {\n        return bet.getDescriptor();\n      }\n    }\n\n    return null;\n  }","commit_id":"122409dff7b519b390a2ecefbbb247d81243eca9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isCurrent(ButtonEditorTab tab) {\n    boolean current = false;\n    for (SNode aspect : tab.getDescriptor().getNodes(myBaseNode.resolve(MPSModuleRepository.getInstance()))) {\n      if (getLastNode() == null) continue;\n      if (aspect.getContainingRoot().equals(getLastNode().resolve(MPSModuleRepository.getInstance()))) {\n        current = true;\n        break;\n      }\n    }\n    return current;\n  }","id":49714,"modified_method":"public boolean isCurrent(ButtonEditorTab tab) {\n    if (getLastNode() == null) {\n      return false;\n    }\n    boolean current = false;\n    final SNode lastNode = getLastNode().resolve(MPSModuleRepository.getInstance());\n    for (SNode aspect : tab.getNodes()) {\n      if (aspect.getContainingRoot().equals(lastNode)) {\n        current = true;\n        break;\n      }\n    }\n    return current;\n  }","commit_id":"122409dff7b519b390a2ecefbbb247d81243eca9","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected void updateTabs() {\n    if (isDisposedNode()) return;\n\n    if (getLastNode()!=null && getLastNode().resolve(MPSModuleRepository.getInstance()) == null) {\n      onNodeChange(myBaseNode.resolve(MPSModuleRepository.getInstance()));\n    }\n\n    myRealTabs.clear();\n\n    ArrayList<RelationDescriptor> tabs = new ArrayList<RelationDescriptor>(myPossibleTabs);\n    Collections.sort(tabs, new RelationComparator());\n\n    Map<RelationDescriptor, List<SNode>> newContent = updateDocumentsAndNodes();\n    for (RelationDescriptor tab : tabs) {\n      List<SNode> nodes = newContent.get(tab);\n      if (nodes != null) {\n        myRealTabs.add(new ButtonEditorTab(this, new NodeChangeCallback() {\n          @Override\n          public void changeNode(SNode newNode) {\n            onNodeChange(newNode);\n          }\n        }, myRealTabs.size(), tab, myBaseNode, getColorProvider(), myEditor));\n      }\n    }\n\n    DefaultActionGroup group = new DefaultActionGroup();\n    for (ButtonEditorTab tab : myRealTabs) {\n      group.add(tab.getSelectTabAction());\n    }\n    if (myToolbar != null) {\n      getComponent().remove(myToolbar.getComponent());\n    }\n    ActionToolbar actionToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, true);\n    actionToolbar.setLayoutPolicy(ActionToolbar.WRAP_LAYOUT_POLICY);\n    myToolbar = actionToolbar;\n    getComponent().add(myToolbar.getComponent(), BorderLayout.CENTER);\n  }","id":49715,"modified_method":"@Override\n  protected void updateTabs() {\n    if (isDisposedNode()) return;\n\n    if (getLastNode()!=null && getLastNode().resolve(MPSModuleRepository.getInstance()) == null) {\n      onNodeChange(myBaseNode.resolve(MPSModuleRepository.getInstance()));\n    }\n\n    myRealTabs.clear();\n\n    ArrayList<RelationDescriptor> tabs = new ArrayList<RelationDescriptor>(myPossibleTabs);\n    Collections.sort(tabs, new RelationComparator());\n\n    Map<RelationDescriptor, List<SNode>> newContent = updateDocumentsAndNodes();\n    final NodeChangeCallback callback = new NodeChangeCallback() {\n      @Override\n      public void changeNode(SNode newNode) {\n        onNodeChange(newNode);\n      }\n    };\n    for (RelationDescriptor tabDescriptor : tabs) {\n      List<SNode> nodes = newContent.get(tabDescriptor);\n      if (nodes != null) {\n        final ButtonEditorTab tab = new ButtonEditorTab(this, myRealTabs.size(), tabDescriptor, myBaseNode, getColorProvider());\n        final SelectTabAction action = new SelectTabAction(tab, callback);\n        tab.setSelectTabAction(action);\n        action.registerShortcut(myEditor);\n        myRealTabs.add(tab);\n      }\n    }\n    updateTabColors();\n\n    DefaultActionGroup group = new DefaultActionGroup();\n    for (ButtonEditorTab tab : myRealTabs) {\n      group.add(tab.getSelectTabAction());\n    }\n    if (myToolbar != null) {\n      getComponent().remove(myToolbar.getComponent());\n    }\n    ActionToolbar actionToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, true);\n    actionToolbar.setLayoutPolicy(ActionToolbar.WRAP_LAYOUT_POLICY);\n    myToolbar = actionToolbar;\n    getComponent().add(myToolbar.getComponent(), BorderLayout.CENTER);\n  }","commit_id":"122409dff7b519b390a2ecefbbb247d81243eca9","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void nextTab() {\n    for (ButtonEditorTab tab : myRealTabs) {\n      if (!isCurrent(tab)) continue;\n      int index = myRealTabs.indexOf(tab);\n      if (index == myRealTabs.size() - 1) {\n        performTabAction(0);\n        return;\n      }\n\n      performTabAction(index + 1);\n      return;\n    }\n  }","id":49716,"modified_method":"@Override\n  public void nextTab() {\n    for (ButtonEditorTab tab : myRealTabs) {\n      if (!isCurrent(tab)) continue;\n      int index = myRealTabs.indexOf(tab);\n      if (index == myRealTabs.size() - 1) {\n        performTabAction(myRealTabs.get(0));\n        return;\n      }\n\n      performTabAction(myRealTabs.get(index + 1));\n      return;\n    }\n  }","commit_id":"122409dff7b519b390a2ecefbbb247d81243eca9","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected void updateTabColors() {\n    for (ButtonEditorTab realTab : myRealTabs) {\n      realTab.updateIcon();\n    }\n  }","id":49717,"modified_method":"private void performTabAction(ButtonEditorTab tab) {\n    final DataContext context = DataManager.getInstance().getDataContext(getComponent());\n    AnActionEvent event = ActionUtils.createEvent(ActionPlaces.UNKNOWN, context);\n\n    tab.getSelectTabAction().actionPerformed(event);\n  }","commit_id":"122409dff7b519b390a2ecefbbb247d81243eca9","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void prevTab() {\n    for (ButtonEditorTab tab : myRealTabs) {\n      if (!isCurrent(tab)) continue;\n\n      int index = myRealTabs.indexOf(tab);\n      if (index == 0) {\n        performTabAction(myRealTabs.size() - 1);\n        return;\n      }\n\n      performTabAction(index - 1);\n      return;\n    }\n  }","id":49718,"modified_method":"@Override\n  public void prevTab() {\n    for (ButtonEditorTab tab : myRealTabs) {\n      if (isCurrent(tab)) {\n        performTabAction(tab);\n        return;\n      }\n    }\n  }","commit_id":"122409dff7b519b390a2ecefbbb247d81243eca9","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Invokes {@link com.intellij.openapi.diff.DiffManager#getDiffTool()} to show difference between the given revisions of the given file.\n   * @param project   project under vcs control.\n   * @param filePath  file which revisions are compared.\n   * @param revision1 first revision - 'before', to the left.\n   * @param revision2 second revision - 'after', to the right.\n   * @throws com.intellij.openapi.vcs.VcsException\n   * @throws java.io.IOException\n   */\n  public static void showDiff(@NotNull final Project project, @NotNull final FilePath filePath,\n                              @NotNull VcsFileRevision revision1, @NotNull VcsFileRevision revision2,\n                              @NotNull String title1, @NotNull String title2) throws VcsException, IOException {\n    final byte[] content1 = loadRevisionContent(revision1);\n    final byte[] content2 = loadRevisionContent(revision2);\n\n    final SimpleDiffRequest diffData = new SimpleDiffRequest(project, filePath.getPresentableUrl());\n    diffData.addHint(DiffTool.HINT_SHOW_FRAME);\n    final Document doc = ApplicationManager.getApplication().runReadAction(new Computable<Document>() {\n      @Override\n      public Document compute() {\n        return filePath.getDocument();\n      }\n    });\n    final Charset charset = filePath.getCharset();\n    final FileType fileType = filePath.getFileType();\n    diffData.setContentTitles(title1, title2);\n    final Ref<VirtualFile> f1 = new Ref<VirtualFile>(null);\n    final Ref<VirtualFile> f2 = new Ref<VirtualFile>(null);\n\n    if (fileType.isBinary()) {\n      final File file1 = FileUtil.createTempFile(revision1.getRevisionNumber().asString(), filePath.getName());\n      final File file2 = FileUtil.createTempFile(revision2.getRevisionNumber().asString(), filePath.getName());\n      try {\n        final FileOutputStream fos1 = new FileOutputStream(file1);\n        fos1.write(content1);\n        final FileOutputStream fos2 = new FileOutputStream(file2);\n        fos2.write(content2);\n        fos1.close();\n        fos2.close();\n        f1.set(LocalFileSystem.getInstance().findFileByIoFile(file1));\n        f2.set(LocalFileSystem.getInstance().findFileByIoFile(file2));\n      } catch(Exception e) {//\n      }\n    }\n    if (f1.isNull() || f2.isNull()) {\n      diffData.setContents(createContent(project, content1, revision1, doc, charset, fileType, filePath.getPath()),\n                           createContent(project, content2, revision2, doc, charset, fileType, filePath.getPath()));\n    } else {\n      diffData.setContents(createFileContent(project, f1.get(), revision1), createFileContent(project, f2.get(), revision2));\n    }\n    WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n      public void run() {\n        DiffManager.getInstance().getDiffTool().show(diffData);\n        if (!f1.isNull() || !f2.isNull()) {\n          Disposer.register(project, new Disposable() {\n            @Override\n            public void dispose() {\n              ApplicationManager.getApplication().runWriteAction(new Runnable() {\n                public void run() {\n                  try {\n                    if (!f1.isNull()) {\n                      f1.get().delete(this);\n                    }\n                    if (!f2.isNull()) {\n                      f2.get().delete(this);\n                    }\n                  }\n                  catch (IOException e) {//\n                  }\n                }\n              });\n            }\n          });\n        }\n      }\n    }, null, project);\n  }","id":49719,"modified_method":"/**\n   * Invokes {@link com.intellij.openapi.diff.DiffManager#getDiffTool()} to show difference between the given revisions of the given file.\n   * @param project   project under vcs control.\n   * @param filePath  file which revisions are compared.\n   * @param revision1 first revision - 'before', to the left.\n   * @param revision2 second revision - 'after', to the right.\n   * @throws com.intellij.openapi.vcs.VcsException\n   * @throws java.io.IOException\n   */\n  public static void showDiff(@NotNull final Project project, @NotNull FilePath filePath,\n                              @NotNull VcsFileRevision revision1, @NotNull VcsFileRevision revision2,\n                              @NotNull String title1, @NotNull String title2) throws VcsException, IOException {\n    final byte[] content1 = loadRevisionContent(revision1);\n    final byte[] content2 = loadRevisionContent(revision2);\n\n    String title = filePath.getPresentableUrl();\n\n    DiffContent diffContent1 = createContent(project, content1, revision1, filePath);\n    DiffContent diffContent2 = createContent(project, content2, revision2, filePath);\n\n    final DiffRequest request = new SimpleDiffRequest(title, diffContent1, diffContent2, title1, title2);\n\n    WaitForProgressToShow.runOrInvokeLaterAboveProgress(new Runnable() {\n      public void run() {\n        DiffManager.getInstance().showDiff(project, request, DiffDialogHints.FRAME);\n      }\n    }, null, project);\n  }","commit_id":"d08837170ac2b212fc6c1d0b519933d6a5d9bbe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static DiffContent createFileContent(@NotNull Project project, VirtualFile file, VcsFileRevision revision) {\n    if (isEmpty(revision)) { return SimpleContent.createEmpty(); }\n    return new FileContent(project, file);\n  }","id":49720,"modified_method":"@NotNull\n  private static DiffContent createContent(@NotNull Project project, @NotNull byte[] content, @NotNull VcsFileRevision revision,\n                                           @NotNull FilePath filePath) throws IOException {\n    if (isCurrent(revision)) {\n      VirtualFile file = filePath.getVirtualFile();\n      if (file != null) return DiffContentFactory.create(project, file);\n    }\n    if (isEmpty(revision)) {\n      return DiffContentFactory.createEmpty();\n    }\n    if (filePath.getFileType().isBinary()) {\n      return DiffContentFactory.createBinary(project, filePath.getName(), filePath.getFileType(), content);\n    }\n    String text = CharsetToolkit.bytesToString(content, filePath.getCharset());\n    return FileAwareDocumentContent.create(project, text, filePath);\n  }","commit_id":"d08837170ac2b212fc6c1d0b519933d6a5d9bbe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processDeployment(DeploymentUnitContext context) throws DeploymentUnitProcessingException {\n        final VirtualFile deploymentRoot = VirtualFileAttachment.getVirtualFileAttachment(context);\n        TldsMetaData tldsMetaData = context.getAttachment(TldsMetaData.ATTACHMENT_KEY);\n        if (tldsMetaData == null) {\n            tldsMetaData = new TldsMetaData();\n            context.putAttachment(TldsMetaData.ATTACHMENT_KEY, tldsMetaData);\n        }\n        Map<String, TldMetaData> tlds = new HashMap<String, TldMetaData>();\n        tldsMetaData.setTlds(tlds);\n        // TLDs are located in WEB-INF or any subdir (except the top level \"classes\" and \"lib\")\n        // and in JARs from WEB-INF/lib, in META-INF or any subdir\n        DeploymentStructure structure = context.getAttachment(DeploymentStructure.ATTACHMENT_KEY);\n        assert structure != null;\n        assert structure.getEntries() != null;\n        for (DeploymentStructure.ClassPathEntry resourceRoot : structure.getEntries()) {\n            if (resourceRoot.getRoot().isFile()) {\n                VirtualFile webFragment = resourceRoot.getRoot().getChild(META_INF);\n                if (webFragment.exists() && webFragment.isDirectory()) {\n                    processTlds(deploymentRoot, webFragment.getChildren(), tlds);\n                }\n            }\n        }\n        VirtualFile webInf = deploymentRoot.getChild(WEB_INF);\n        if (webInf.exists() && webInf.isDirectory()) {\n            for (VirtualFile file : webInf.getChildren()) {\n                if (file.isFile() && file.getName().endsWith(TLD)) {\n                    tlds.put(file.getPathNameRelativeTo(deploymentRoot), parseTLD(file));\n                } else if (file.isDirectory() && !CLASSES.equals(file.getName()) && !LIB.equals(file.getName())) {\n                    processTlds(deploymentRoot, file.getChildren(), tlds);\n                }\n            }\n        }\n    }","id":49721,"modified_method":"public void processDeployment(DeploymentUnitContext context) throws DeploymentUnitProcessingException {\n        final VirtualFile deploymentRoot = VirtualFileAttachment.getVirtualFileAttachment(context);\n        TldsMetaData tldsMetaData = context.getAttachment(TldsMetaData.ATTACHMENT_KEY);\n        if (tldsMetaData == null) {\n            tldsMetaData = new TldsMetaData();\n            context.putAttachment(TldsMetaData.ATTACHMENT_KEY, tldsMetaData);\n        }\n        Map<String, TldMetaData> tlds = new HashMap<String, TldMetaData>();\n        tldsMetaData.setTlds(tlds);\n        // TLDs are located in WEB-INF or any subdir (except the top level \"classes\" and \"lib\")\n        // and in JARs from WEB-INF/lib, in META-INF or any subdir\n        DeploymentStructure structure = context.getAttachment(DeploymentStructure.ATTACHMENT_KEY);\n        assert structure != null;\n        assert structure.getEntries() != null;\n        for (DeploymentStructure.ClassPathEntry resourceRoot : structure.getEntries()) {\n            if (resourceRoot.getRoot().getLowerCaseName().endsWith(\".jar\")) {\n                VirtualFile webFragment = resourceRoot.getRoot().getChild(META_INF);\n                if (webFragment.exists() && webFragment.isDirectory()) {\n                    processTlds(deploymentRoot, webFragment.getChildren(), tlds);\n                }\n            }\n        }\n        VirtualFile webInf = deploymentRoot.getChild(WEB_INF);\n        if (webInf.exists() && webInf.isDirectory()) {\n            for (VirtualFile file : webInf.getChildren()) {\n                if (file.isFile() && file.getName().endsWith(TLD)) {\n                    tlds.put(file.getPathNameRelativeTo(deploymentRoot), parseTLD(file));\n                } else if (file.isDirectory() && !CLASSES.equals(file.getName()) && !LIB.equals(file.getName())) {\n                    processTlds(deploymentRoot, file.getChildren(), tlds);\n                }\n            }\n        }\n    }","commit_id":"c9c7a8edf6e75b4a8cee0ec673ae30b6e6a32ecd","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Merge everything into WarMetaData.\n     */\n    public void processDeployment(DeploymentUnitContext context) throws DeploymentUnitProcessingException {\n        WarMetaData warMetaData = context.getAttachment(WarMetaData.ATTACHMENT_KEY);\n        assert warMetaData != null;\n        DeploymentStructure structure = context.getAttachment(DeploymentStructure.ATTACHMENT_KEY);\n        assert structure != null;\n        assert structure.getEntries() != null;\n\n        WebMetaData specMetaData = warMetaData.getWebMetaData();\n        boolean isComplete = false;\n        if (specMetaData != null) {\n            if (specMetaData instanceof Web25MetaData) {\n                isComplete |= ((Web25MetaData) specMetaData).isMetadataComplete();\n            } else if (specMetaData instanceof Web30MetaData) {\n                isComplete |= ((Web30MetaData) specMetaData).isMetadataComplete();\n            } else {\n                // Any web.xml 2.4 or earlier deployment is metadata complete\n                isComplete = true;\n            }\n        }\n\n        // Find all fragments that have been processed by deployers, and place\n        // them in a map keyed by location\n        LinkedList<String> order = new LinkedList<String>();\n        List<WebOrdering> orderings = new ArrayList<WebOrdering>();\n        HashSet<String> jarsSet = new HashSet<String>();\n        Set<VirtualFile> overlays = new HashSet<VirtualFile>();\n        Map<String, VirtualFile> scis = new HashMap<String, VirtualFile>();\n        boolean fragmentFound = false;\n        Map<String, WebFragmentMetaData> webFragments = warMetaData.getWebFragmentsMetaData();\n        for (DeploymentStructure.ClassPathEntry resourceRoot : structure.getEntries()) {\n            if (resourceRoot.getRoot().isFile()) {\n                jarsSet.add(resourceRoot.getName());\n                // Find overlays\n                VirtualFile overlay = resourceRoot.getRoot().getChild(\"META-INF/resources\");\n                if (overlay.exists()) {\n                    overlays.add(overlay);\n                }\n                // Find ServletContainerInitializer services\n                VirtualFile sci = resourceRoot.getRoot()\n                        .getChild(\"META-INF/services/javax.servlet.ServletContainerInitializer\");\n                if (sci.exists()) {\n                    scis.put(resourceRoot.getName(), sci);\n                }\n            }\n        }\n\n        if (!isComplete) {\n            HashSet<String> jarsWithoutFragmentsSet = new HashSet<String>();\n            jarsWithoutFragmentsSet.addAll(jarsSet);\n            for (String jarName : webFragments.keySet()) {\n                fragmentFound = true;\n                WebFragmentMetaData fragmentMetaData = webFragments.get(jarName);\n                webFragments.put(jarName, fragmentMetaData);\n                WebOrdering webOrdering = new WebOrdering();\n                webOrdering.setName(fragmentMetaData.getName());\n                webOrdering.setJar(jarName);\n                jarsWithoutFragmentsSet.remove(jarName);\n                if (fragmentMetaData.getOrdering() != null) {\n                    if (fragmentMetaData.getOrdering().getAfter() != null) {\n                        for (OrderingElementMetaData orderingElementMetaData : fragmentMetaData.getOrdering().getAfter()\n                                .getOrdering()) {\n                            if (orderingElementMetaData.isOthers()) {\n                                webOrdering.setAfterOthers(true);\n                            } else {\n                                webOrdering.addAfter(orderingElementMetaData.getName());\n                            }\n                        }\n                    }\n                    if (fragmentMetaData.getOrdering().getBefore() != null) {\n                        for (OrderingElementMetaData orderingElementMetaData : fragmentMetaData.getOrdering().getBefore()\n                                .getOrdering()) {\n                            if (orderingElementMetaData.isOthers()) {\n                                webOrdering.setBeforeOthers(true);\n                            } else {\n                                webOrdering.addBefore(orderingElementMetaData.getName());\n                            }\n                        }\n                    }\n                }\n                orderings.add(webOrdering);\n            }\n            // If there is no fragment, still consider it for ordering as a\n            // fragment specifying no name and no order\n            for (String jarName : jarsWithoutFragmentsSet) {\n                WebOrdering ordering = new WebOrdering();\n                ordering.setJar(jarName);\n                orderings.add(ordering);\n            }\n\n        }\n\n        if (!fragmentFound) {\n            // Drop the order as there is no fragment in the webapp\n            orderings.clear();\n        }\n\n        // Generate web fragments parsing order\n        AbsoluteOrderingMetaData absoluteOrderingMetaData = null;\n        if (!isComplete && specMetaData instanceof Web30MetaData) {\n            absoluteOrderingMetaData = ((Web30MetaData) specMetaData).getAbsoluteOrdering();\n        }\n        if (absoluteOrderingMetaData != null) {\n            // Absolute ordering from web.xml, any relative fragment ordering is\n            // ignored\n            int otherPos = -1;\n            int i = 0;\n            for (OrderingElementMetaData orderingElementMetaData : absoluteOrderingMetaData.getOrdering()) {\n                if (orderingElementMetaData.isOthers()) {\n                    if (otherPos >= 0) {\n                        throw new DeploymentUnitProcessingException(\"Duplicate others in absolute ordering\");\n                    }\n                    otherPos = i;\n                } else {\n                    boolean found = false;\n                    for (WebOrdering ordering : orderings) {\n                        if (orderingElementMetaData.getName().equals(ordering.getName())) {\n                            order.add(ordering.getJar());\n                            jarsSet.remove(ordering.getJar());\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found)\n                        throw new DeploymentUnitProcessingException(\"Could not resolve name in absolute ordering: \"\n                                + orderingElementMetaData.getName());\n                }\n                i++;\n            }\n            if (otherPos >= 0) {\n                order.addAll(otherPos, jarsSet);\n                jarsSet.clear();\n            }\n        } else if (orderings.size() > 0) {\n            // Resolve relative ordering\n            try {\n                resolveOrder(orderings, order);\n            } catch (IllegalStateException e) {\n                throw new DeploymentUnitProcessingException(\"Invalid ordering\", e);\n            }\n            jarsSet.clear();\n        } else {\n            // No order specified\n            order.addAll(jarsSet);\n            jarsSet.clear();\n            warMetaData.setNoOrder(true);\n        }\n\n        Logger log = Logger.getLogger(\"org.jboss.web\");\n        if (log.isDebugEnabled()) {\n            StringBuilder builder = new StringBuilder();\n            builder.append(\"Resolved order: [ \");\n            for (String jar : order) {\n                builder.append(jar).append(' ');\n            }\n            builder.append(']');\n            log.debug(builder.toString());\n        }\n\n        warMetaData.setOrder(order);\n        warMetaData.setOverlays(overlays);\n        warMetaData.setScis(scis);\n\n        Map<String, WebMetaData> annotationsMetaData = warMetaData.getAnnotationsMetaData();\n\n        // The fragments and corresponding annotations will need to be merged in\n        // order\n        // For each JAR in the order:\n        // - Merge the annotation metadata into the fragment meta data\n        // (unless the fragment exists and is meta data complete)\n        // - Merge the fragment metadata into merged fragment meta data\n        WebCommonMetaData mergedFragmentMetaData = new WebCommonMetaData();\n        if (specMetaData == null) {\n            // If there is no web.xml, it has to be considered to be the latest version\n            specMetaData = new Web30MetaData();\n            specMetaData.setVersion(\"3.0\");\n        }\n        // Augment with meta data from annotations in /WEB-INF/classes\n        WebMetaData classesAnnotatedMetaData = annotationsMetaData.get(\"\");\n        if (classesAnnotatedMetaData != null) {\n            if (isComplete) {\n                // Discard @WebFilter, @WebListener and @WebServlet\n                classesAnnotatedMetaData.setFilters(null);\n                classesAnnotatedMetaData.setFilterMappings(null);\n                classesAnnotatedMetaData.setListeners(null);\n                classesAnnotatedMetaData.setServlets(null);\n                classesAnnotatedMetaData.setServletMappings(null);\n            }\n            specMetaData.augment(classesAnnotatedMetaData, null, true);\n        }\n        // Augment with meta data from fragments and annotations from the\n        // corresponding JAR\n        for (String jar : order) {\n            WebFragmentMetaData webFragmentMetaData = webFragments.get(jar);\n            if (webFragmentMetaData == null) {\n                webFragmentMetaData = new WebFragmentMetaData();\n                // Add non overriding default distributable flag\n                webFragmentMetaData.setDistributable(new EmptyMetaData());\n            }\n            WebMetaData jarAnnotatedMetaData = annotationsMetaData.get(jar);\n            if ((isComplete || webFragmentMetaData.isMetadataComplete()) && jarAnnotatedMetaData != null) {\n                // Discard @WebFilter, @WebListener and @WebServlet\n                jarAnnotatedMetaData.setFilters(null);\n                jarAnnotatedMetaData.setFilterMappings(null);\n                jarAnnotatedMetaData.setListeners(null);\n                jarAnnotatedMetaData.setServlets(null);\n                jarAnnotatedMetaData.setServletMappings(null);\n            }\n            if (jarAnnotatedMetaData != null) {\n                // Merge annotations corresponding to the JAR\n                webFragmentMetaData.augment(jarAnnotatedMetaData, null, true);\n            }\n            // Merge fragment meta data according to the conflict rules\n            try {\n                mergedFragmentMetaData.augment(webFragmentMetaData, specMetaData, false);\n            } catch (Exception e) {\n                throw new DeploymentUnitProcessingException(\"Deployment error processing fragment for JAR: \" + jar, e);\n            }\n        }\n        // Augment with meta data from annotations from JARs excluded from the\n        // order\n        for (String jar : jarsSet) {\n            WebFragmentMetaData webFragmentMetaData = new WebFragmentMetaData();\n            // Add non overriding default distributable flag\n            webFragmentMetaData.setDistributable(new EmptyMetaData());\n            WebMetaData jarAnnotatedMetaData = annotationsMetaData.get(jar);\n            if (jarAnnotatedMetaData != null) {\n                // Discard @WebFilter, @WebListener and @WebServlet\n                jarAnnotatedMetaData.setFilters(null);\n                jarAnnotatedMetaData.setFilterMappings(null);\n                jarAnnotatedMetaData.setListeners(null);\n                jarAnnotatedMetaData.setServlets(null);\n                jarAnnotatedMetaData.setServletMappings(null);\n            }\n            if (jarAnnotatedMetaData != null) {\n                // Merge annotations corresponding to the JAR\n                webFragmentMetaData.augment(jarAnnotatedMetaData, null, true);\n            }\n            // Merge fragment meta data according to the conflict rules\n            try {\n                mergedFragmentMetaData.augment(webFragmentMetaData, specMetaData, false);\n            } catch (Exception e) {\n                throw new DeploymentUnitProcessingException(\"Deployment error processing fragment for JAR: \" + jar, e);\n            }\n        }\n        specMetaData.augment(mergedFragmentMetaData, null, true);\n\n        // Override with meta data (JBossWebMetaData)\n        // Create a merged view\n        JBossWebMetaData mergedMetaData = new JBossWebMetaData();\n        JBossWebMetaData metaData = warMetaData.getJbossWebMetaData();\n        mergedMetaData.merge(metaData, specMetaData);\n        // FIXME: Incorporate any ear level overrides\n\n        warMetaData.setMergedJBossWebMetaData(mergedMetaData);\n\n    }","id":49722,"modified_method":"/**\n     * Merge everything into WarMetaData.\n     */\n    public void processDeployment(DeploymentUnitContext context) throws DeploymentUnitProcessingException {\n        WarMetaData warMetaData = context.getAttachment(WarMetaData.ATTACHMENT_KEY);\n        assert warMetaData != null;\n        DeploymentStructure structure = context.getAttachment(DeploymentStructure.ATTACHMENT_KEY);\n        assert structure != null;\n        assert structure.getEntries() != null;\n\n        WebMetaData specMetaData = warMetaData.getWebMetaData();\n        boolean isComplete = false;\n        if (specMetaData != null) {\n            if (specMetaData instanceof Web25MetaData) {\n                isComplete |= ((Web25MetaData) specMetaData).isMetadataComplete();\n            } else if (specMetaData instanceof Web30MetaData) {\n                isComplete |= ((Web30MetaData) specMetaData).isMetadataComplete();\n            } else {\n                // Any web.xml 2.4 or earlier deployment is metadata complete\n                isComplete = true;\n            }\n        }\n\n        // Find all fragments that have been processed by deployers, and place\n        // them in a map keyed by location\n        LinkedList<String> order = new LinkedList<String>();\n        List<WebOrdering> orderings = new ArrayList<WebOrdering>();\n        HashSet<String> jarsSet = new HashSet<String>();\n        Set<VirtualFile> overlays = new HashSet<VirtualFile>();\n        Map<String, VirtualFile> scis = new HashMap<String, VirtualFile>();\n        boolean fragmentFound = false;\n        Map<String, WebFragmentMetaData> webFragments = warMetaData.getWebFragmentsMetaData();\n        for (DeploymentStructure.ClassPathEntry resourceRoot : structure.getEntries()) {\n            if (resourceRoot.getRoot().getLowerCaseName().endsWith(\".jar\")) {\n                jarsSet.add(resourceRoot.getName());\n                // Find overlays\n                VirtualFile overlay = resourceRoot.getRoot().getChild(\"META-INF/resources\");\n                if (overlay.exists()) {\n                    overlays.add(overlay);\n                }\n                // Find ServletContainerInitializer services\n                VirtualFile sci = resourceRoot.getRoot()\n                        .getChild(\"META-INF/services/javax.servlet.ServletContainerInitializer\");\n                if (sci.exists()) {\n                    scis.put(resourceRoot.getName(), sci);\n                }\n            }\n        }\n\n        if (!isComplete) {\n            HashSet<String> jarsWithoutFragmentsSet = new HashSet<String>();\n            jarsWithoutFragmentsSet.addAll(jarsSet);\n            for (String jarName : webFragments.keySet()) {\n                fragmentFound = true;\n                WebFragmentMetaData fragmentMetaData = webFragments.get(jarName);\n                webFragments.put(jarName, fragmentMetaData);\n                WebOrdering webOrdering = new WebOrdering();\n                webOrdering.setName(fragmentMetaData.getName());\n                webOrdering.setJar(jarName);\n                jarsWithoutFragmentsSet.remove(jarName);\n                if (fragmentMetaData.getOrdering() != null) {\n                    if (fragmentMetaData.getOrdering().getAfter() != null) {\n                        for (OrderingElementMetaData orderingElementMetaData : fragmentMetaData.getOrdering().getAfter()\n                                .getOrdering()) {\n                            if (orderingElementMetaData.isOthers()) {\n                                webOrdering.setAfterOthers(true);\n                            } else {\n                                webOrdering.addAfter(orderingElementMetaData.getName());\n                            }\n                        }\n                    }\n                    if (fragmentMetaData.getOrdering().getBefore() != null) {\n                        for (OrderingElementMetaData orderingElementMetaData : fragmentMetaData.getOrdering().getBefore()\n                                .getOrdering()) {\n                            if (orderingElementMetaData.isOthers()) {\n                                webOrdering.setBeforeOthers(true);\n                            } else {\n                                webOrdering.addBefore(orderingElementMetaData.getName());\n                            }\n                        }\n                    }\n                }\n                orderings.add(webOrdering);\n            }\n            // If there is no fragment, still consider it for ordering as a\n            // fragment specifying no name and no order\n            for (String jarName : jarsWithoutFragmentsSet) {\n                WebOrdering ordering = new WebOrdering();\n                ordering.setJar(jarName);\n                orderings.add(ordering);\n            }\n\n        }\n\n        if (!fragmentFound) {\n            // Drop the order as there is no fragment in the webapp\n            orderings.clear();\n        }\n\n        // Generate web fragments parsing order\n        AbsoluteOrderingMetaData absoluteOrderingMetaData = null;\n        if (!isComplete && specMetaData instanceof Web30MetaData) {\n            absoluteOrderingMetaData = ((Web30MetaData) specMetaData).getAbsoluteOrdering();\n        }\n        if (absoluteOrderingMetaData != null) {\n            // Absolute ordering from web.xml, any relative fragment ordering is\n            // ignored\n            int otherPos = -1;\n            int i = 0;\n            for (OrderingElementMetaData orderingElementMetaData : absoluteOrderingMetaData.getOrdering()) {\n                if (orderingElementMetaData.isOthers()) {\n                    if (otherPos >= 0) {\n                        throw new DeploymentUnitProcessingException(\"Duplicate others in absolute ordering\");\n                    }\n                    otherPos = i;\n                } else {\n                    boolean found = false;\n                    for (WebOrdering ordering : orderings) {\n                        if (orderingElementMetaData.getName().equals(ordering.getName())) {\n                            order.add(ordering.getJar());\n                            jarsSet.remove(ordering.getJar());\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found)\n                        throw new DeploymentUnitProcessingException(\"Could not resolve name in absolute ordering: \"\n                                + orderingElementMetaData.getName());\n                }\n                i++;\n            }\n            if (otherPos >= 0) {\n                order.addAll(otherPos, jarsSet);\n                jarsSet.clear();\n            }\n        } else if (orderings.size() > 0) {\n            // Resolve relative ordering\n            try {\n                resolveOrder(orderings, order);\n            } catch (IllegalStateException e) {\n                throw new DeploymentUnitProcessingException(\"Invalid ordering\", e);\n            }\n            jarsSet.clear();\n        } else {\n            // No order specified\n            order.addAll(jarsSet);\n            jarsSet.clear();\n            warMetaData.setNoOrder(true);\n        }\n\n        Logger log = Logger.getLogger(\"org.jboss.web\");\n        if (log.isDebugEnabled()) {\n            StringBuilder builder = new StringBuilder();\n            builder.append(\"Resolved order: [ \");\n            for (String jar : order) {\n                builder.append(jar).append(' ');\n            }\n            builder.append(']');\n            log.debug(builder.toString());\n        }\n\n        warMetaData.setOrder(order);\n        warMetaData.setOverlays(overlays);\n        warMetaData.setScis(scis);\n\n        Map<String, WebMetaData> annotationsMetaData = warMetaData.getAnnotationsMetaData();\n\n        // The fragments and corresponding annotations will need to be merged in\n        // order\n        // For each JAR in the order:\n        // - Merge the annotation metadata into the fragment meta data\n        // (unless the fragment exists and is meta data complete)\n        // - Merge the fragment metadata into merged fragment meta data\n        WebCommonMetaData mergedFragmentMetaData = new WebCommonMetaData();\n        if (specMetaData == null) {\n            // If there is no web.xml, it has to be considered to be the latest version\n            specMetaData = new Web30MetaData();\n            specMetaData.setVersion(\"3.0\");\n        }\n        // Augment with meta data from annotations in /WEB-INF/classes\n        WebMetaData classesAnnotatedMetaData = annotationsMetaData.get(\"\");\n        if (classesAnnotatedMetaData != null) {\n            if (isComplete) {\n                // Discard @WebFilter, @WebListener and @WebServlet\n                classesAnnotatedMetaData.setFilters(null);\n                classesAnnotatedMetaData.setFilterMappings(null);\n                classesAnnotatedMetaData.setListeners(null);\n                classesAnnotatedMetaData.setServlets(null);\n                classesAnnotatedMetaData.setServletMappings(null);\n            }\n            specMetaData.augment(classesAnnotatedMetaData, null, true);\n        }\n        // Augment with meta data from fragments and annotations from the\n        // corresponding JAR\n        for (String jar : order) {\n            WebFragmentMetaData webFragmentMetaData = webFragments.get(jar);\n            if (webFragmentMetaData == null) {\n                webFragmentMetaData = new WebFragmentMetaData();\n                // Add non overriding default distributable flag\n                webFragmentMetaData.setDistributable(new EmptyMetaData());\n            }\n            WebMetaData jarAnnotatedMetaData = annotationsMetaData.get(jar);\n            if ((isComplete || webFragmentMetaData.isMetadataComplete()) && jarAnnotatedMetaData != null) {\n                // Discard @WebFilter, @WebListener and @WebServlet\n                jarAnnotatedMetaData.setFilters(null);\n                jarAnnotatedMetaData.setFilterMappings(null);\n                jarAnnotatedMetaData.setListeners(null);\n                jarAnnotatedMetaData.setServlets(null);\n                jarAnnotatedMetaData.setServletMappings(null);\n            }\n            if (jarAnnotatedMetaData != null) {\n                // Merge annotations corresponding to the JAR\n                webFragmentMetaData.augment(jarAnnotatedMetaData, null, true);\n            }\n            // Merge fragment meta data according to the conflict rules\n            try {\n                mergedFragmentMetaData.augment(webFragmentMetaData, specMetaData, false);\n            } catch (Exception e) {\n                throw new DeploymentUnitProcessingException(\"Deployment error processing fragment for JAR: \" + jar, e);\n            }\n        }\n        // Augment with meta data from annotations from JARs excluded from the\n        // order\n        for (String jar : jarsSet) {\n            WebFragmentMetaData webFragmentMetaData = new WebFragmentMetaData();\n            // Add non overriding default distributable flag\n            webFragmentMetaData.setDistributable(new EmptyMetaData());\n            WebMetaData jarAnnotatedMetaData = annotationsMetaData.get(jar);\n            if (jarAnnotatedMetaData != null) {\n                // Discard @WebFilter, @WebListener and @WebServlet\n                jarAnnotatedMetaData.setFilters(null);\n                jarAnnotatedMetaData.setFilterMappings(null);\n                jarAnnotatedMetaData.setListeners(null);\n                jarAnnotatedMetaData.setServlets(null);\n                jarAnnotatedMetaData.setServletMappings(null);\n            }\n            if (jarAnnotatedMetaData != null) {\n                // Merge annotations corresponding to the JAR\n                webFragmentMetaData.augment(jarAnnotatedMetaData, null, true);\n            }\n            // Merge fragment meta data according to the conflict rules\n            try {\n                mergedFragmentMetaData.augment(webFragmentMetaData, specMetaData, false);\n            } catch (Exception e) {\n                throw new DeploymentUnitProcessingException(\"Deployment error processing fragment for JAR: \" + jar, e);\n            }\n        }\n        specMetaData.augment(mergedFragmentMetaData, null, true);\n\n        // Override with meta data (JBossWebMetaData)\n        // Create a merged view\n        JBossWebMetaData mergedMetaData = new JBossWebMetaData();\n        JBossWebMetaData metaData = warMetaData.getJbossWebMetaData();\n        mergedMetaData.merge(metaData, specMetaData);\n        // FIXME: Incorporate any ear level overrides\n\n        warMetaData.setMergedJBossWebMetaData(mergedMetaData);\n\n    }","commit_id":"c9c7a8edf6e75b4a8cee0ec673ae30b6e6a32ecd","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Process web annotations.\n     *\n     * TODO this should be based on the xml metadata\n     *\n     * {@inheritDoc}\n     */\n    public void processDeployment(final DeploymentUnitContext context) throws DeploymentUnitProcessingException {\n        final WarAnnotationIndex index = context.getAttachment(WarAnnotationIndexProcessor.ATTACHMENT_KEY);\n        if (index == null) {\n            return; // Skip if there is no annotation index\n        }\n        // process web-inf/classes\n        processAnnotations(index.getRootIndex());\n\n        // Process lib/*.jar\n        for(final String pathName : index.getPathNames()) {\n            final Index jarIndex = index.getIndex(pathName);\n            processAnnotations(jarIndex);\n        }\n        // TODO process annotations on both - the resources found here, plus the\n        // ones from the parsed metadata\n    }","id":49723,"modified_method":"/**\n     * Process web annotations.\n     *\n     * TODO this should be based on the xml metadata\n     *\n     * {@inheritDoc}\n     */\n    public void processDeployment(final DeploymentUnitContext context) throws DeploymentUnitProcessingException {\n        WarMetaData warMetaData = context.getAttachment(WarMetaData.ATTACHMENT_KEY);\n        assert warMetaData != null;\n        Map<String, WebMetaData> annotationsMetaData = warMetaData.getAnnotationsMetaData();\n        if (annotationsMetaData == null) {\n            annotationsMetaData = new HashMap<String, WebMetaData>();\n            warMetaData.setAnnotationsMetaData(annotationsMetaData);\n        }\n        final WarAnnotationIndex index = context.getAttachment(WarAnnotationIndexProcessor.ATTACHMENT_KEY);\n        if (index == null) {\n            return; // Skip if there is no annotation index\n        }\n        // process web-inf/classes\n        processAnnotations(index.getRootIndex());\n\n        // Process lib/*.jar\n        for(final String pathName : index.getPathNames()) {\n            final Index jarIndex = index.getIndex(pathName);\n            processAnnotations(jarIndex);\n        }\n        // TODO process annotations on both - the resources found here, plus the\n        // ones from the parsed metadata\n    }","commit_id":"c9c7a8edf6e75b4a8cee0ec673ae30b6e6a32ecd","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void processDeployment(DeploymentUnitContext context) throws DeploymentUnitProcessingException {\n        WarMetaData warMetaData = context.getAttachment(WarMetaData.ATTACHMENT_KEY);\n        assert warMetaData != null;\n        Map<String, WebFragmentMetaData> webFragments = warMetaData.getWebFragmentsMetaData();\n        if (webFragments == null) {\n            webFragments = new HashMap<String, WebFragmentMetaData>();\n            warMetaData.setWebFragmentsMetaData(webFragments);\n        }\n        DeploymentStructure structure = context.getAttachment(DeploymentStructure.ATTACHMENT_KEY);\n        assert structure != null;\n        assert structure.getEntries() != null;\n        for (DeploymentStructure.ClassPathEntry resourceRoot : structure.getEntries()) {\n            if (resourceRoot.getRoot().isFile()) {\n                VirtualFile webFragment = resourceRoot.getRoot().getChild(WEB_FRAGMENT_XML);\n                if (webFragment.exists() && webFragment.isFile()) {\n                    InputStream is = null;\n                    long time = System.currentTimeMillis();\n                    try {\n                        is = webFragment.openStream();\n                        final XMLInputFactory inputFactory = XMLInputFactory.newInstance();\n                        XMLStreamReader xmlReader = inputFactory.createXMLStreamReader(is);\n                        webFragments.put(resourceRoot.getName(), WebFragmentMetaDataParser.parse(xmlReader));\n                    } catch (Exception e) {\n                        throw new DeploymentUnitProcessingException(\"Failed to parse \" + webFragment, e);\n                    } finally {\n                        Logger.getLogger(\"org.jboss.web\").info(\"parse \" + (System.currentTimeMillis() - time));\n                        try {\n                            if (is != null) {\n                                is.close();\n                            }\n                        } catch (IOException e) {\n                            // Ignore\n                        }\n                    }\n                }\n            }\n        }\n    }","id":49724,"modified_method":"public void processDeployment(DeploymentUnitContext context) throws DeploymentUnitProcessingException {\n        WarMetaData warMetaData = context.getAttachment(WarMetaData.ATTACHMENT_KEY);\n        assert warMetaData != null;\n        Map<String, WebFragmentMetaData> webFragments = warMetaData.getWebFragmentsMetaData();\n        if (webFragments == null) {\n            webFragments = new HashMap<String, WebFragmentMetaData>();\n            warMetaData.setWebFragmentsMetaData(webFragments);\n        }\n        DeploymentStructure structure = context.getAttachment(DeploymentStructure.ATTACHMENT_KEY);\n        assert structure != null;\n        assert structure.getEntries() != null;\n        for (DeploymentStructure.ClassPathEntry resourceRoot : structure.getEntries()) {\n            if (resourceRoot.getRoot().getLowerCaseName().endsWith(\".jar\")) {\n                VirtualFile webFragment = resourceRoot.getRoot().getChild(WEB_FRAGMENT_XML);\n                if (webFragment.exists() && webFragment.isFile()) {\n                    InputStream is = null;\n                    long time = System.currentTimeMillis();\n                    try {\n                        is = webFragment.openStream();\n                        final XMLInputFactory inputFactory = XMLInputFactory.newInstance();\n                        XMLStreamReader xmlReader = inputFactory.createXMLStreamReader(is);\n                        webFragments.put(resourceRoot.getName(), WebFragmentMetaDataParser.parse(xmlReader));\n                    } catch (Exception e) {\n                        throw new DeploymentUnitProcessingException(\"Failed to parse \" + webFragment, e);\n                    } finally {\n                        Logger.getLogger(\"org.jboss.web\").info(\"parse \" + (System.currentTimeMillis() - time));\n                        try {\n                            if (is != null) {\n                                is.close();\n                            }\n                        } catch (IOException e) {\n                            // Ignore\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"c9c7a8edf6e75b4a8cee0ec673ae30b6e6a32ecd","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public synchronized void removeHost(Host host) {\n        final Engine engine = this.engine;\n        engine.removeChild(host);\n    }","id":49725,"modified_method":"/** {@inheritDoc} */\n    public synchronized void removeHost(Host host) {\n        final Engine engine = this.engine;\n        engine.removeChild(host);\n        // FIXME: Hack, remove with next JBW build\n        for (LifecycleListener listener : service.findLifecycleListeners()) {\n            if (listener instanceof ServiceMapperListener) {\n                host.removeContainerListener((ServiceMapperListener) listener);\n            }\n        }\n    }","commit_id":"c9c7a8edf6e75b4a8cee0ec673ae30b6e6a32ecd","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public synchronized void addHost(Host host) {\n        final Engine engine = this.engine;\n        engine.addChild(host);\n    }","id":49726,"modified_method":"/** {@inheritDoc} */\n    public synchronized void addHost(Host host) {\n        final Engine engine = this.engine;\n        engine.addChild(host);\n        // FIXME: Hack, remove with next JBW build\n        for (LifecycleListener listener : service.findLifecycleListeners()) {\n            if (listener instanceof ServiceMapperListener) {\n                host.addContainerListener((ServiceMapperListener) listener);\n            }\n        }\n    }","commit_id":"c9c7a8edf6e75b4a8cee0ec673ae30b6e6a32ecd","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n\t * Helper function to decode and unpack a public key from DER encoding to a Java PublicKey\n\t * @param derEncodedPublicKey DER encoding of public key in standard format (SubjectPublicKeyInfo)\n\t * @return the decoded PublicKey\n\t * @throws CertificateEncodingException if there is a problem decoding the content\n\t * @throws NoSuchAlgorithmException if the key algorithm is unknown\n\t * @throws InvalidKeySpecException if the data in the SubjectPublicKeyInfo doesn't correctly represent a key\n\t */\n\tpublic static PublicKey getPublicKey(byte [] derEncodedPublicKey) throws CertificateEncodingException, NoSuchAlgorithmException, \n\t\t\t\t\t\t\t\t\t\tInvalidKeySpecException {\n\n\t\t// Problem is, we need the algorithm identifier inside\n\t\t// the key to decode it. So in essence we need to\n\t\t// decode it twice.\n\t\tDERObject genericObject = decode(derEncodedPublicKey);\n\t\tif (!(genericObject instanceof ASN1Sequence)) {\n\t\t\tthrow new InvalidKeySpecException(\"This object is not a public key!\");\n\t\t}\n\t\t\n\t\t// At this point it might also be a certificate, or\n\t\t// any number of things. \n\t\tSubjectPublicKeyInfo spki = \n\t\t\tnew SubjectPublicKeyInfo((ASN1Sequence)genericObject);\n\t\t\n\t\tX509EncodedKeySpec keySpec = new X509EncodedKeySpec(derEncodedPublicKey);\n\t\tString algorithmOID= \n\t\t\tspki.getAlgorithmId().getObjectId().getId();\n\t\tString algorithm = OIDLookup.getCipherName(algorithmOID);\n\t\tif (algorithm == null) {\n\t\t\tthrow new NoSuchAlgorithmException(\"Unknown key algorithm: \" + algorithmOID);\n\t\t}\n\t\tKeyFactory fact = KeyFactory.getInstance(algorithm);\n\t\treturn fact.generatePublic(keySpec);\n\t}","id":49727,"modified_method":"/**\n\t * Helper function to decode and unpack a public key from DER encoding to a Java PublicKey\n\t * @param derEncodedPublicKey DER encoding of public key in standard format (SubjectPublicKeyInfo)\n\t * @return the decoded PublicKey\n\t * @throws CertificateEncodingException if there is a problem decoding the content\n\t * @throws NoSuchAlgorithmException if the key algorithm is unknown\n\t * @throws InvalidKeySpecException if the data in the SubjectPublicKeyInfo doesn't correctly represent a key\n\t */\n\tpublic static PublicKey getPublicKey(byte [] derEncodedPublicKey) throws CertificateEncodingException, \n\t\t\t\t\t\t\t\t\t\tInvalidKeySpecException {\n\n\t\tX509EncodedKeySpec keySpec = new X509EncodedKeySpec(derEncodedPublicKey);\n\t\t// Problem is, we need the algorithm identifier inside\n\t\t// the key to decode it. So in essence we need to\n\t\t// decode it twice.\n\t\tDERObject genericObject = decode(derEncodedPublicKey);\n\t\tif (!(genericObject instanceof ASN1Sequence)) {\n\t\t\tthrow new InvalidKeySpecException(\"This object is not a public key!\");\n\t\t}\n\t\t\n\t\t// At this point it might also be a certificate, or\n\t\t// any number of things. \n\t\tSubjectPublicKeyInfo keyInfo = \n\t\t\tnew SubjectPublicKeyInfo((ASN1Sequence)genericObject);\n\t\t\n\t\tString keyType = OIDLookup.getCipherName(keyInfo.getAlgorithmId().getObjectId().toString());\n\t\tif (keyType == null) {\n\t\t\tLog.info(\"Cannot find key type corresponding to OID: \" + keyInfo.getAlgorithmId().getObjectId().toString());\n\t\t\tLog.warning(\"Unknown key type \" + keyType + \" in stored key.\");\n\t\t\tthrow new InvalidKeySpecException(\"Unknown key type \" + keyType + \" in stored key.\");\n\t\t}\n\t\t\n\t\tKeyFactory keyFactory = null;\n\t\tPublicKey key = null;\n\t\ttry {\n\t\t\tkeyFactory = KeyFactory.getInstance(keyType);\n\t\t\tkey = keyFactory.generatePublic(keySpec);\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tLog.warning(\"Unknown key type \" + keyType + \" in stored key.\");\n\t\t\tthrow new InvalidKeySpecException(\"Unknown key type \" + keyType + \" in stored key.\");\n\t\t}\n\t\treturn key;\n\t}","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public KeyName name() { return _keyName; }","id":49728,"modified_method":"/**\n\t * Get the KeyName if present\n\t * @return the KeyName or null\n\t */\r\n    public KeyName name() { return _keyName; }","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public static KeyLocatorType nameToType(String name) {\r\n\t\treturn NameTypes.get(name);\r\n\t}","id":49729,"modified_method":"/**\n\t * Conversion methods for dealing with enums. Not necessary, and will\n\t * be removed.\n\t * @param name\n\t * @return\n\t */\r\n\tpublic static KeyLocatorType nameToType(String name) {\r\n\t\treturn NameTypes.get(name);\r\n\t}","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public KeyLocator(KeyName keyName) {\r\n    \t_keyName = keyName;\r\n    }","id":49730,"modified_method":"/**\n     * Make a KeyLocator specifying a KeyName -- a structure combining the name\n     * at which to find the key and authentication information by which to verify it\n     * @param keyName the KeyName to use to retrieve and authenticate the key\n     */\n   public KeyLocator(KeyName keyName) {\r\n    \t_keyName = keyName;\r\n    }","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public KeyLocatorType type() { \r\n    \tif (null != certificate())\r\n    \t\treturn KeyLocatorType.CERTIFICATE;\r\n    \tif (null != key())\r\n    \t\treturn KeyLocatorType.KEY;\r\n    \treturn KeyLocatorType.NAME; \r\n    }","id":49731,"modified_method":"/**\n     * Return the type of data stored in this KeyLocator - KEY, CERTIFICATE, or NAME.\n     * @return the type\n     */\r\n    public KeyLocatorType type() { \r\n    \tif (null != certificate())\r\n    \t\treturn KeyLocatorType.CERTIFICATE;\r\n    \tif (null != key())\r\n    \t\treturn KeyLocatorType.KEY;\r\n    \treturn KeyLocatorType.NAME; \r\n    }","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public KeyLocator(PublicKey key) {\r\n    \t_key = key;\r\n    }","id":49732,"modified_method":"/**\n    * Make a KeyLocator containing an explicit public key\n    * @param key the key\n    */\r\n    public KeyLocator(PublicKey key) {\r\n    \t_key = key;\r\n    }","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public KeyLocator(ContentName name, PublisherID publisher) {\r\n    \tthis(new KeyName(name, publisher));\r\n    }","id":49733,"modified_method":"/**\n     * Make a KeyLocator containing a key name and the desired publisher\n     * @param name the key name\n     * @param publisher the desired publisher\n     */\r\n    public KeyLocator(ContentName name, PublisherID publisher) {\r\n    \tthis(new KeyName(name, publisher));\r\n    }","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public static String typeToName(KeyLocatorType type) {\r\n\t\treturn TypeNames.get(type);\r\n\t}","id":49734,"modified_method":"/**\n\t * Conversion methods for dealing with enums. Not necessary, and will\n\t * be removed.\n\t * @param type\n\t * @return\n\t */\r\n\tpublic static String typeToName(KeyLocatorType type) {\r\n\t\treturn TypeNames.get(type);\r\n\t}","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public KeyLocator() {}","id":49735,"modified_method":"/**\n     * For use by decoders.\n     */\r\n    public KeyLocator() {}","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected KeyLocator(KeyName name, PublicKey key, X509Certificate certificate) {\r\n    \t_keyName = name;\r\n    \t_key = key;\r\n    \t_certificate = certificate;\r\n    }","id":49736,"modified_method":"/**\n     * Internal constructor.\n     * @param name\n     * @param key\n     * @param certificate\n     */\r\n    protected KeyLocator(KeyName name, PublicKey key, X509Certificate certificate) {\r\n    \t_keyName = name;\r\n    \t_key = key;\r\n    \t_certificate = certificate;\r\n    }","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Override\r\n\tpublic void decode(XMLDecoder decoder) throws XMLStreamException {\r\n\t\tdecoder.readStartElement(getElementLabel());\r\n\r\n\t\tif (decoder.peekStartElement(PUBLISHER_KEY_ELEMENT)) {\r\n\t\t\ttry {\r\n\t\t\t\tbyte [] encodedKey = decoder.readBinaryElement(PUBLISHER_KEY_ELEMENT);\r\n\t\t\t\t// This is a DER-encoded SubjectPublicKeyInfo.\r\n\t\t\t\t_key = decodeKey(encodedKey);\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\tLog.warning(\"Cannot parse stored key: error: \" + e.getMessage());\r\n\t\t\t\tthrow new XMLStreamException(\"Cannot parse key: \", e);\r\n\t\t\t} catch (InvalidKeySpecException e) {\r\n\t\t\t\tLog.warning(\"Cannot turn stored key \" + \" into key of appropriate type.\");\r\n\t\t\t\tthrow new XMLStreamException(\"Cannot turn stored key \" + \" into key of appropriate type.\");\r\n\t\t\t}\r\n\t\t\tif (null == _key) {\r\n\t\t\t\tthrow new XMLStreamException(\"Cannot parse key: \");\r\n\t\t\t}\r\n\t\t} else if (decoder.peekStartElement(PUBLISHER_CERTIFICATE_ELEMENT)) {\r\n\t\t\ttry {\r\n\t\t\t\tbyte [] encodedCert = decoder.readBinaryElement(PUBLISHER_CERTIFICATE_ELEMENT);\r\n\t\t\t\tCertificateFactory factory = CertificateFactory.getInstance(\"X.509\");\r\n\t\t\t\t_certificate = (X509Certificate) factory.generateCertificate(new ByteArrayInputStream(encodedCert));\r\n\t\t\t} catch (CertificateException e) {\r\n\t\t\t\tthrow new XMLStreamException(\"Cannot decode certificate: \" + e.getMessage(), e);\r\n\t\t\t}\r\n\t\t\tif (null == _certificate) {\r\n\t\t\t\tthrow new XMLStreamException(\"Cannot parse certificate! \");\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t_keyName = new KeyName();\r\n\t\t\t_keyName.decode(decoder);\r\n\t\t}\r\n\t\tdecoder.readEndElement();\r\n\t}","id":49737,"modified_method":"@Override\r\n\tpublic void decode(XMLDecoder decoder) throws XMLStreamException {\r\n\t\tdecoder.readStartElement(getElementLabel());\r\n\r\n\t\tif (decoder.peekStartElement(PUBLISHER_KEY_ELEMENT)) {\r\n\t\t\ttry {\r\n\t\t\t\tbyte [] encodedKey = decoder.readBinaryElement(PUBLISHER_KEY_ELEMENT);\r\n\t\t\t\t// This is a DER-encoded SubjectPublicKeyInfo.\r\n\t\t\t\t_key = CryptoUtil.getPublicKey(encodedKey);\r\n\t\t\t} catch (CertificateEncodingException e) {\r\n\t\t\t\tLog.warning(\"Cannot parse stored key: error: \" + e.getMessage());\r\n\t\t\t\tthrow new XMLStreamException(\"Cannot parse key: \", e);\r\n\t\t\t} catch (InvalidKeySpecException e) {\r\n\t\t\t\tLog.warning(\"Cannot turn stored key \" + \" into key of appropriate type.\");\r\n\t\t\t\tthrow new XMLStreamException(\"Cannot turn stored key \" + \" into key of appropriate type.\");\r\n\t\t\t}\r\n\t\t\tif (null == _key) {\r\n\t\t\t\tthrow new XMLStreamException(\"Cannot parse key: \");\r\n\t\t\t}\r\n\t\t} else if (decoder.peekStartElement(PUBLISHER_CERTIFICATE_ELEMENT)) {\r\n\t\t\ttry {\r\n\t\t\t\tbyte [] encodedCert = decoder.readBinaryElement(PUBLISHER_CERTIFICATE_ELEMENT);\r\n\t\t\t\tCertificateFactory factory = CertificateFactory.getInstance(\"X.509\");\r\n\t\t\t\t_certificate = (X509Certificate) factory.generateCertificate(new ByteArrayInputStream(encodedCert));\r\n\t\t\t} catch (CertificateException e) {\r\n\t\t\t\tthrow new XMLStreamException(\"Cannot decode certificate: \" + e.getMessage(), e);\r\n\t\t\t}\r\n\t\t\tif (null == _certificate) {\r\n\t\t\t\tthrow new XMLStreamException(\"Cannot parse certificate! \");\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t_keyName = new KeyName();\r\n\t\t\t_keyName.decode(decoder);\r\n\t\t}\r\n\t\tdecoder.readEndElement();\r\n\t}","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public KeyLocator(X509Certificate certificate) {\r\n    \t_certificate = certificate;\r\n    }","id":49738,"modified_method":"/**\n     * Make a KeyLocator containing an explicit X509Certificate. \n     * @param certificate the certificate\n     */\r\n    public KeyLocator(X509Certificate certificate) {\r\n    \t_certificate = certificate;\r\n    }","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public KeyLocator(ContentName name) {\r\n    \tthis (name, null);\r\n    }","id":49739,"modified_method":"/**\n     * Make a KeyLocator containing only a name\n     * @param name the name\n     */\r\n    public KeyLocator(ContentName name) {\r\n    \tthis (name, null);\r\n    }","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public KeyLocator clone() {\r\n    \treturn new KeyLocator(name(),\r\n    \t\t\t\t\t\t  key(),\r\n    \t\t\t\t\t\t  certificate());\r\n    }","id":49740,"modified_method":"/**\n     * Implement Cloneable\n     */\r\n    public KeyLocator clone() {\r\n    \treturn new KeyLocator(name(),\r\n    \t\t\t\t\t\t  key(),\r\n    \t\t\t\t\t\t  certificate());\r\n    }","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public X509Certificate certificate() { return _certificate; }","id":49741,"modified_method":"/**\n     * Get the certificate if present\n     * @return the certificate or null\n     */\r\n    public X509Certificate certificate() { return _certificate; }","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public PublicKey key() { return _key; }","id":49742,"modified_method":"/**\n \t * Get the key if present\n     * @return the key or null\n     */\r\n\tpublic PublicKey key() { return _key; }","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Retrieve the public key from cache given a key digest \n\t * @param desiredKeyID the digest of the desired public key.\n\t */\n\tpublic PublicKey getPublicKey(PublisherPublicKeyDigest desiredKeyID) throws IOException {\n\t\tContentObject keyObject = null;\n\t\tPublicKey theKey = _rawKeyMap.get(desiredKeyID);\n\t\tif (null == theKey) {\n\t\t\tCertificate theCertificate = _rawCertificateMap.get(desiredKeyID);\n\t\t\tif (null != theCertificate) {\n\t\t\t\ttheKey = theCertificate.getPublicKey();\n\t\t\t}\n\t\t}\n\t\tContentName name = _idMap.get(desiredKeyID);\n\t\tif (null != name) {\n\t\t\tkeyObject = _keyMap.get(name);\n\t\t\tif (null != keyObject) {\n\t\t\t\ttry {\n\t\t\t\t\ttheKey = CryptoUtil.getPublicKey(keyObject.content());\n\t\t\t\t} catch (CertificateEncodingException e) {\n\t\t\t\t\tLog.warning(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\tthrow new IOException(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t} catch (InvalidKeySpecException e) {\n\t\t\t\t\tLog.warning(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\tthrow new IOException(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\t\tLog.warning(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\tthrow new IOException(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\treturn theKey;\n\t}","id":49743,"modified_method":"/**\n\t * Retrieve the public key from cache given a key digest \n\t * @param desiredKeyID the digest of the desired public key.\n\t */\n\tpublic PublicKey getPublicKey(PublisherPublicKeyDigest desiredKeyID) throws IOException {\n\t\tContentObject keyObject = null;\n\t\tPublicKey theKey = _rawKeyMap.get(desiredKeyID);\n\t\tif (null == theKey) {\n\t\t\tCertificate theCertificate = _rawCertificateMap.get(desiredKeyID);\n\t\t\tif (null != theCertificate) {\n\t\t\t\ttheKey = theCertificate.getPublicKey();\n\t\t\t}\n\t\t}\n\t\tContentName name = _idMap.get(desiredKeyID);\n\t\tif (null != name) {\n\t\t\tkeyObject = _keyMap.get(name);\n\t\t\tif (null != keyObject) {\n\t\t\t\ttry {\n\t\t\t\t\ttheKey = CryptoUtil.getPublicKey(keyObject.content());\n\t\t\t\t} catch (CertificateEncodingException e) {\n\t\t\t\t\tLog.warning(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\tthrow new IOException(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t} catch (InvalidKeySpecException e) {\n\t\t\t\t\tLog.warning(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\tthrow new IOException(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\treturn theKey;\n\t}","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Retrieve the public key from CCN given a key digest and a key locator\n\t * the function blocks and waits for the public key until a certain timeout\n\t * @param desiredKeyID the digest of the desired public key.\n\t * @param locator locator for the key\n\t * @param timeout timeout value\n\t * @throws IOException \n\t */\n\tpublic PublicKey getPublicKey(PublisherPublicKeyDigest desiredKeyID, KeyLocator locator, long timeout) throws IOException {\n\t\n\t\t// Look for it in our cache first.\n\t\tPublicKey publicKey = getPublicKey(desiredKeyID);\n\t\tif (null != publicKey) {\n\t\t\treturn publicKey;\n\t\t}\n\t\t\n\t\tContentObject keyObject = null;\n\t\tif (locator.type() != KeyLocator.KeyLocatorType.NAME) {\n\t\t\tLog.info(\"This is silly: asking the repository to retrieve for me a key I already have...\");\n\t\t\tif (locator.type() == KeyLocator.KeyLocatorType.KEY) {\n\t\t\t\tPublicKey key = locator.key();\n\t\t\t\tremember(key);\n\t\t\t\treturn key;\n\t\t\t} else if (locator.type() == KeyLocator.KeyLocatorType.CERTIFICATE) {\n\t\t\t\tCertificate certificate = locator.certificate();\n\t\t\t\tPublicKey key = certificate.getPublicKey();\n\t\t\t\tremember(certificate);\n\t\t\t\treturn key;\n\t\t\t}\n\t\t} else {\n\t\t\t// DKS TODO -- better key retrieval\n\t\t\t// take code from #BasicKeyManager.getKey, to validate more complex publisher constraints\n\t\t\tInterest keyInterest = new Interest(locator.name().name());\n\t\t\tif (null != locator.name().publisher()) {\n\t\t\t\tkeyInterest.publisherID(locator.name().publisher());\n\t\t\t}\t\t\t\n\t\t\t//  it would be really good to know how many additional name components to expect...\n\t\t\ttry {\n\t\t\t\tLog.info(\"Trying network retrieval of key: \" + keyInterest.name());\n\t\t\t\tkeyObject = _networkManager.get(keyInterest, timeout);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.warning(\"IOException attempting to retrieve key: \" + keyInterest.name() + \": \" + e.getMessage());\n\t\t\t\tLog.warningStackTrace(e);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLog.warning(\"Interrupted attempting to retrieve key: \" + keyInterest.name() + \": \" + e.getMessage());\n\t\t\t}\n\t\t\tif (null != keyObject) {\n\t\t\t\tif (keyObject.signedInfo().getType().equals(ContentType.KEY)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tLog.info(\"Retrieved public key using name: \" + locator.name().name());\n\t\t\t\t\t\tPublicKey theKey = CryptoUtil.getPublicKey(keyObject.content());\n\t\t\t\t\t\tremember(theKey, keyObject);\n\t\t\t\t\t\treturn theKey;\n\t\t\t\t\t} catch (CertificateEncodingException e) {\n\t\t\t\t\t\tLog.warning(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t\tthrow new IOException(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t} catch (InvalidKeySpecException e) {\n\t\t\t\t\t\tLog.warning(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t\tthrow new IOException(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\t\t\tLog.warning(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t\tthrow new IOException(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLog.warning(\"Retrieved an object when looking for key \" + locator.name().name() + \" at \" + keyObject.name() + \", but type is \" + keyObject.signedInfo().getTypeName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":49744,"modified_method":"/**\n\t * Retrieve the public key from CCN given a key digest and a key locator\n\t * the function blocks and waits for the public key until a certain timeout\n\t * @param desiredKeyID the digest of the desired public key.\n\t * @param locator locator for the key\n\t * @param timeout timeout value\n\t * @throws IOException \n\t */\n\tpublic PublicKey getPublicKey(PublisherPublicKeyDigest desiredKeyID, KeyLocator locator, long timeout) throws IOException {\n\t\n\t\t// Look for it in our cache first.\n\t\tPublicKey publicKey = getPublicKey(desiredKeyID);\n\t\tif (null != publicKey) {\n\t\t\treturn publicKey;\n\t\t}\n\t\t\n\t\tContentObject keyObject = null;\n\t\tif (locator.type() != KeyLocator.KeyLocatorType.NAME) {\n\t\t\tLog.info(\"This is silly: asking the repository to retrieve for me a key I already have...\");\n\t\t\tif (locator.type() == KeyLocator.KeyLocatorType.KEY) {\n\t\t\t\tPublicKey key = locator.key();\n\t\t\t\tremember(key);\n\t\t\t\treturn key;\n\t\t\t} else if (locator.type() == KeyLocator.KeyLocatorType.CERTIFICATE) {\n\t\t\t\tCertificate certificate = locator.certificate();\n\t\t\t\tPublicKey key = certificate.getPublicKey();\n\t\t\t\tremember(certificate);\n\t\t\t\treturn key;\n\t\t\t}\n\t\t} else {\n\t\t\t// DKS TODO -- better key retrieval\n\t\t\t// take code from #BasicKeyManager.getKey, to validate more complex publisher constraints\n\t\t\tInterest keyInterest = new Interest(locator.name().name());\n\t\t\tif (null != locator.name().publisher()) {\n\t\t\t\tkeyInterest.publisherID(locator.name().publisher());\n\t\t\t}\t\t\t\n\t\t\t//  it would be really good to know how many additional name components to expect...\n\t\t\ttry {\n\t\t\t\tLog.info(\"Trying network retrieval of key: \" + keyInterest.name());\n\t\t\t\tkeyObject = _networkManager.get(keyInterest, timeout);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.warning(\"IOException attempting to retrieve key: \" + keyInterest.name() + \": \" + e.getMessage());\n\t\t\t\tLog.warningStackTrace(e);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLog.warning(\"Interrupted attempting to retrieve key: \" + keyInterest.name() + \": \" + e.getMessage());\n\t\t\t}\n\t\t\tif (null != keyObject) {\n\t\t\t\tif (keyObject.signedInfo().getType().equals(ContentType.KEY)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tLog.info(\"Retrieved public key using name: \" + locator.name().name());\n\t\t\t\t\t\tPublicKey theKey = CryptoUtil.getPublicKey(keyObject.content());\n\t\t\t\t\t\tremember(theKey, keyObject);\n\t\t\t\t\t\treturn theKey;\n\t\t\t\t\t} catch (CertificateEncodingException e) {\n\t\t\t\t\t\tLog.warning(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t\tthrow new IOException(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t} catch (InvalidKeySpecException e) {\n\t\t\t\t\t\tLog.warning(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t\tthrow new IOException(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLog.warning(\"Retrieved an object when looking for key \" + locator.name().name() + \" at \" + keyObject.name() + \", but type is \" + keyObject.signedInfo().getTypeName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Override\n\tprotected PublicKey readObjectImpl(InputStream input) throws IOException, XMLStreamException {\n\t\t// assume we read until we have all the bytes, then decode.\n\t\t// Doesn't give us a good opportunity to check whether it's of type KEY. TODO\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tbyte [] buf = new byte[1024];\n\t\tint byteCount = 0;\n\t\tbyteCount = input.read(buf);\n\t\twhile (byteCount > 0) {\n\t\t\tbaos.write(buf, 0, byteCount);\n\t\t\tbyteCount = input.read(buf);\n\t\t}\n\t\ttry {\n\t\t\treturn CryptoUtil.getPublicKey(baos.toByteArray());\n\t\t} catch (CertificateEncodingException e) {\n\t\t\tLog.warning(\"Cannot decode public key \" + e.getClass().getName() + \": \" + e.getMessage());\n\t\t\tthrow new IOException(\"Cannot decode public key \" + e.getClass().getName() + \": \" + e.getMessage());\n\t\t} catch (InvalidKeySpecException e) {\n\t\t\tLog.warning(\"Cannot decode public key from block: \" + ((CCNInputStream)input).currentSegmentName() + \"  \" + e.getClass().getName() + \": \" + e.getMessage());\n\t\t\tthrow new IOException(\"Cannot decode public key \" + e.getClass().getName() + \": \" + e.getMessage());\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tLog.warning(\"Cannot decode public key \" + e.getClass().getName() + \": \" + e.getMessage());\n\t\t\tthrow new IOException(\"Cannot decode public key \" + e.getClass().getName() + \": \" + e.getMessage());\n\t\t}\n\t}","id":49745,"modified_method":"@Override\n\tprotected PublicKey readObjectImpl(InputStream input) throws IOException, XMLStreamException {\n\t\t// assume we read until we have all the bytes, then decode.\n\t\t// Doesn't give us a good opportunity to check whether it's of type KEY. TODO\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tbyte [] buf = new byte[1024];\n\t\tint byteCount = 0;\n\t\tbyteCount = input.read(buf);\n\t\twhile (byteCount > 0) {\n\t\t\tbaos.write(buf, 0, byteCount);\n\t\t\tbyteCount = input.read(buf);\n\t\t}\n\t\ttry {\n\t\t\treturn CryptoUtil.getPublicKey(baos.toByteArray());\n\t\t} catch (CertificateEncodingException e) {\n\t\t\tLog.warning(\"Cannot decode public key \" + e.getClass().getName() + \": \" + e.getMessage());\n\t\t\tthrow new IOException(\"Cannot decode public key \" + e.getClass().getName() + \": \" + e.getMessage());\n\t\t} catch (InvalidKeySpecException e) {\n\t\t\tLog.warning(\"Cannot decode public key from block: \" + ((CCNInputStream)input).currentSegmentName() + \"  \" + e.getClass().getName() + \": \" + e.getMessage());\n\t\t\tthrow new IOException(\"Cannot decode public key \" + e.getClass().getName() + \": \" + e.getMessage());\n\t\t}\n\t}","commit_id":"55c2a1e01c8111ea285150685b4f1b143dbf9336","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public ObjectId renameRepositoryDirectory(ObjectId id, RepositoryDirectory newParentDir, String newName) throws KettleException\n  {\n    try\n    {\n      renameDirectory(id, newParentDir.getObjectId(), newName);\n      return id; // doesn't change in this specific case.\n    }\n    catch(Exception e)\n    {\n      throw new KettleException(\"Unable to rename the specified repository directory [\"+id+\"]\", e);\n    }\n  }","id":49746,"modified_method":"public ObjectId renameRepositoryDirectory(ObjectId id, RepositoryDirectory newParentDir, String newName) throws KettleException\n  {\n\t  ObjectId parentId = null;\n\t  if (newParentDir != null)\n\t  {\n\t    parentId = newParentDir.getObjectId();\n\t  }\n\t  \n\t  try\n    {\n      renameDirectory(id, parentId, newName);\n      return id; // doesn't change in this specific case.\n    }\n    catch(Exception e)\n    {\n      throw new KettleException(\"Unable to rename the specified repository directory [\"+id+\"]\", e);\n    }\n  }","commit_id":"cfdfcccb660dedae183d3204fd424e4e3bef600b","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n  public void beforeApplicationLoaded(Application application) {\n    if (application.isUnitTestMode()) {\n      return;\n    }\n\n    IdeaConfigurationServerManager.getInstance().registerApplicationLevelProviders(application);\n\n    ApplicationManager.getApplication().getMessageBus().connect().subscribe(ProjectLifecycleListener.TOPIC, new ProjectLifecycleListener.Adapter() {\n      @Override\n      public void beforeProjectLoaded(@NotNull Project project) {\n        if (!project.isDefault()) {\n          IdeaConfigurationServerManager.getInstance().registerProjectLevelProviders(project);\n        }\n      }\n    });\n  }","id":49747,"modified_method":"@Override\n  public void beforeApplicationLoaded(Application application) {\n    if (application.isUnitTestMode()) {\n      return;\n    }\n\n    IcsManager.getInstance().registerApplicationLevelProviders(application);\n\n    ApplicationManager.getApplication().getMessageBus().connect().subscribe(ProjectLifecycleListener.TOPIC, new ProjectLifecycleListener.Adapter() {\n      @Override\n      public void beforeProjectLoaded(@NotNull Project project) {\n        if (!project.isDefault()) {\n          IcsManager.getInstance().registerProjectLevelProviders(project);\n        }\n      }\n    });\n  }","commit_id":"b9fb58935401c457deeb710b7f6b7d83f2346e65","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public InputStream loadUserPreferences(@NotNull String path) throws IOException {\n    TreeWalk treeWalk = new TreeWalk(repository);\n    treeWalk.addTree(new RevWalk(repository).parseCommit(repository.resolve(Constants.HEAD)).getTree());\n    treeWalk.setRecursive(true);\n    treeWalk.setFilter(PathFilter.create(path));\n    if (!treeWalk.next()) {\n      return null;\n    }\n\n    ObjectId objectId = treeWalk.getObjectId(0);\n    ObjectLoader loader = repository.open(objectId);\n    return loader.openStream();\n  }","id":49748,"modified_method":"@Nullable\n  public InputStream loadUserPreferences(@NotNull String path) throws IOException {\n    TreeWalk treeWalk = TreeWalk.forPath(repository, path, new RevWalk(repository).parseCommit(repository.resolve(Constants.HEAD)).getTree());\n    if (treeWalk == null) {\n      return null;\n    }\n    return repository.open(treeWalk.getObjectId(0)).openStream();\n  }","commit_id":"b9fb58935401c457deeb710b7f6b7d83f2346e65","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void saveContent(String fileSpec, @NotNull InputStream content, long size, RoamingType roamingType, boolean async) throws IOException {\n      saveFileContent(content, size, createBuilder(fileSpec, this.roamingType, projectId), async);\n    }","id":49749,"modified_method":"@Override\n    public void saveContent(String fileSpec, @NotNull final InputStream content, long size, RoamingType roamingType, boolean async) throws IOException {\n      final String path = createBuilder(fileSpec, this.roamingType, projectId).buildPath();\n      if (async) {\n        ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n          @Override\n          public void run() {\n            try {\n              serverConnector.save(content, path);\n            }\n            catch (IOException e) {\n              LOG.error(e);\n            }\n          }\n        });\n      }\n      else {\n        serverConnector.save(content, path);\n      }\n    }","commit_id":"b9fb58935401c457deeb710b7f6b7d83f2346e65","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean saveHashToKeyMap() throws IOException {\n    File mappingsFile = getMappingsFile();\n\n    saveNewMappings(mappingsFile);\n\n    FileInputStream input = new FileInputStream(mappingsFile);\n    try {\n      saveUserPreferences(mappingsFile, createBuilder(\"projects/mapping.txt\",\n                                                      RoamingType.PER_USER,\n                                                      null));\n      return true;\n    }\n    catch (Throwable t) {\n      return false;\n    }\n    finally {\n      input.close();\n    }\n  }","id":49750,"modified_method":"private boolean saveHashToKeyMap() throws IOException {\n    File mappingsFile = getMappingsFile();\n\n    saveNewMappings(mappingsFile);\n\n    FileInputStream input = new FileInputStream(mappingsFile);\n    try {\n      IcsGitConnector.send(mappingsFile, createBuilder(\"projects/mapping.txt\",\n                                                        RoamingType.PER_USER,\n                                                        null));\n      return true;\n    }\n    catch (Throwable t) {\n      return false;\n    }\n    finally {\n      input.close();\n    }\n  }","commit_id":"b9fb58935401c457deeb710b7f6b7d83f2346e65","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Icon getIcon() {\n    return getStatusIcon(IdeaConfigurationServerManager.getInstance().getIdeaServerSettings().getStatus());\n  }","id":49751,"modified_method":"@NotNull\n  @Override\n  public Icon getIcon() {\n    return getStatusIcon(IcsManager.getInstance().getIdeaServerSettings().getStatus());\n  }","commit_id":"b9fb58935401c457deeb710b7f6b7d83f2346e65","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String getTooltipText() {\n    return \"IntelliJ Configuration Server status: \" + IdeaConfigurationServerManager.getStatusText();\n  }","id":49752,"modified_method":"@Override\n  public String getTooltipText() {\n    return \"IntelliJ Configuration Server status: \" + IcsManager.getStatusText();\n  }","commit_id":"b9fb58935401c457deeb710b7f6b7d83f2346e65","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Establishes a connection to a relational database.\n   * @param ctx query context\n   * @return connection id\n   * @throws QueryException query exception\n   */\n  private Itr connect(final QueryContext ctx) throws QueryException {\n    // URL to relational database\n    final String url = string(checkStr(expr[0], ctx));\n    // Auto-commit mode\n    final boolean autoComm = expr.length < 2 || checkBln(expr[1], ctx);\n    try {\n      final Connection conn = expr.length == 4 ? DriverManager.getConnection(\n          url, string(checkStr(expr[2], ctx)), string(checkStr(expr[3], ctx)))\n          : DriverManager.getConnection(url);\n      conn.setAutoCommit(autoComm);\n      return Itr.get(ctx.jdbc.add(conn));\n    } catch(final SQLException ex) {\n      throw SQLEXC.thrw(input, ex.getMessage());\n    }\n  }","id":49753,"modified_method":"/**\n   * Establishes a connection to a relational database.\n   * @param ctx query context\n   * @return connection id\n   * @throws QueryException query exception\n   */\n  private Itr connect(final QueryContext ctx) throws QueryException {\n    // URL to relational database\n    final String url = string(checkStr(expr[0], ctx));\n    try {\n      if(expr.length > 2) {\n        // Credentials\n        final String user = string(checkStr(expr[1], ctx));\n        final String pass = string(checkStr(expr[2], ctx));\n        if(expr.length == 4) {\n          // Connection options\n          final TokenObjMap<Object> options = options(3, E_OPS, ctx);\n          boolean autoCommit = true;\n          final Object commit = options.get(AUTO_COMM);\n          if(commit != null) {\n            // Extract auto-commit mode from options\n            autoCommit = Boolean.parseBoolean(commit.toString());\n            options.delete(AUTO_COMM);\n          }\n          // Connection properties\n          final Properties props = connProps(options(3, E_OPS, ctx));\n          props.setProperty(USER, user);\n          props.setProperty(PASS, pass);\n          // Open connection\n          final Connection conn = getConnection(url, props);\n          // Set auto/commit mode\n          conn.setAutoCommit(autoCommit);\n          return Itr.get(ctx.jdbc.add(conn));\n        }\n        return Itr.get(ctx.jdbc.add(getConnection(url, user, pass)));\n      }\n      return Itr.get(ctx.jdbc.add(getConnection(url)));\n    } catch(final SQLException ex) {\n      throw SQLEXC.thrw(input, ex.getMessage());\n    }\n  }","commit_id":"83f99e2f96317fccb4c4e4901a19ca192556d242","url":"https://github.com/BaseXdb/basex"},{"original_method":"protected synchronized CounterRegister getCounterRegister(String name)\n\t\tthrows SystemException {\n\n\t\tCounterRegister register = _registerLookup.get(name);\n\n\t\tif (register == null) {\n\t\t\tregister = createCounterRegister(name);\n\n\t\t\t_registerLookup.put(name, register);\n\t\t}\n\n\t\treturn register;\n\t}","id":49754,"modified_method":"protected CounterRegister getCounterRegister(String name)\n\t\tthrows SystemException {\n\n\t\tCounterRegister register = _registerLookup.get(name);\n\n\t\tif (register != null) {\n\t\t\treturn register;\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tsynchronized (_registerLookup) {\n\n\t\t\t\t//Double check\n\n\t\t\t\tregister = _registerLookup.get(name);\n\n\t\t\t\tif (register == null) {\n\t\t\t\t\tregister = createCounterRegister(name);\n\n\t\t\t\t\t_registerLookup.put(name, register);\n\t\t\t\t}\n\n\t\t\t\treturn register;\n\t\t\t}\n\t\t}\n\t}","commit_id":"f041d5de485b36fc940905abb34fb8f0b9b4a095","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected synchronized CounterRegister createCounterRegister(\n\t\t\tString name, long size)\n\t\tthrows SystemException {\n\n\t\tlong rangeMin = 0;\n\t\tlong rangeMax = 0;\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tConnection connection = getConnection();\n\n\t\t\tsession = _sessionFactory.openNewSession(connection);\n\n\t\t\tCounter counter = (Counter)session.get(\n\t\t\t\tCounter.class, name, LockMode.UPGRADE);\n\n\t\t\tif (counter == null) {\n\t\t\t\trangeMin = _DEFAULT_CURRENT_ID;\n\n\t\t\t\tcounter = new Counter();\n\n\t\t\t\tcounter.setName(name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trangeMin = counter.getCurrentId();\n\t\t\t}\n\n\t\t\tif (size >= _DEFAULT_CURRENT_ID) {\n\t\t\t\trangeMin = size;\n\t\t\t}\n\n\t\t\trangeMax = rangeMin + _COUNTER_INCREMENT;\n\n\t\t\tcounter.setCurrentId(rangeMax);\n\n\t\t\tsession.save(counter);\n\t\t\tsession.flush();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow processException(e);\n\t\t}\n\t\tfinally {\n\t\t\tsession.close();\n\t\t}\n\n\t\tCounterRegister register = new CounterRegister(\n\t\t\tname, rangeMin, rangeMax, _COUNTER_INCREMENT);\n\n\t\treturn register;\n\t}","id":49755,"modified_method":"protected CounterRegister createCounterRegister(\n\t\tString name, long size) throws SystemException {\n\n\t\tlong rangeMin = -1;\n\t\tlong rangeMax = -1;\n\n\t\tConnection con = null;\n\t\tPreparedStatement psQuery = null;\n\t\tPreparedStatement psUpdate = null;\n\t\tResultSet rs = null;\n\t\ttry {\n\t\t\tcon = getConnection();\n\t\t\tpsQuery = con.prepareStatement(_SQL_SELECT_ID_BY_NAME);\n\n\t\t\tpsQuery.setString(1, name);\n\n\t\t\trs = psQuery.executeQuery();\n\n\t\t\tif (rs.next()) {\n\n\t\t\t\t//do update\n\n\t\t\t\trangeMin = rs.getLong(1);\n\t\t\t\trangeMax = rangeMin + _COUNTER_INCREMENT;\n\n\t\t\t\tpsUpdate = con.prepareStatement(_SQL_UPDATE_ID_BY_NAME);\n\t\t\t\tpsUpdate.setLong(1, rangeMax);\n\t\t\t\tpsUpdate.setString(2, name);\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t//do insert\n\n\t\t\t\trangeMin = _DEFAULT_CURRENT_ID;\n\t\t\t\trangeMax = rangeMin + _COUNTER_INCREMENT;\n\n\t\t\t\tpsUpdate = con.prepareStatement(_SQL_INSERT);\n\t\t\t\tpsUpdate.setString(1, name);\n\t\t\t\tpsUpdate.setLong(2, rangeMax);\n\t\t\t}\n\n\t\t\tpsUpdate.executeUpdate();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow processException(e);\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(psUpdate);\n\t\t\tDataAccess.cleanUp(con, psQuery, rs);\n\t\t}\n\n\t\tif (size > rangeMin) {\n\t\t\trangeMin = size;\n\t\t}\n\n\t\tCounterRegister register = new CounterRegister(\n\t\t\tname, rangeMin, rangeMax, _COUNTER_INCREMENT);\n\n\t\treturn register;\n\t}","commit_id":"f041d5de485b36fc940905abb34fb8f0b9b4a095","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<String> getNames() throws SystemException {\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tConnection connection = getConnection();\n\n\t\t\tsession = _sessionFactory.openNewSession(connection);\n\n\t\t\tList<String> list = new ArrayList<String>();\n\n\t\t\tQuery q = session.createQuery(\n\t\t\t\t\"SELECT counter FROM Counter counter\");\n\n\t\t\tIterator<Counter> itr = q.iterate();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tCounter counter = itr.next();\n\n\t\t\t\tlist.add(counter.getName());\n\t\t\t}\n\n\t\t\treturn ListUtil.sort(list);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow processException(e);\n\t\t}\n\t\tfinally {\n\t\t\tsession.close();\n\t\t}\n\t}","id":49756,"modified_method":"public List<String> getNames() throws SystemException {\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = getConnection();\n\t\t\tps = con.prepareStatement(_SQL_SELECT_NAMES);\n\t\t\trs = ps.executeQuery();\n\n\t\t\tList<String> list = new ArrayList<String>();\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tlist.add(rs.getString(1));\n\t\t\t}\n\n\t\t\treturn list;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow processException(e);\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\t}","commit_id":"f041d5de485b36fc940905abb34fb8f0b9b4a095","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void reset(String name, long size) throws SystemException {\n\t\tCounterRegister register = createCounterRegister(name, size);\n\n\t\tsynchronized (register) {\n\t\t\t_registerLookup.put(name, register);\n\t\t}\n\t}","id":49757,"modified_method":"public void reset(String name, long size) throws SystemException {\n\t\tCounterRegister register = createCounterRegister(name, size);\n\n\t\t_registerLookup.put(name, register);\n\t}","commit_id":"f041d5de485b36fc940905abb34fb8f0b9b4a095","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected synchronized CounterRegister createCounterRegister(String name)\n\t\tthrows SystemException {\n\n\t\treturn createCounterRegister(name, -1);\n\t}","id":49758,"modified_method":"protected CounterRegister createCounterRegister(String name)\n\t\tthrows SystemException {\n\n\t\treturn createCounterRegister(name, -1);\n\t}","commit_id":"f041d5de485b36fc940905abb34fb8f0b9b4a095","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public synchronized Connection getConnection() throws Exception {\n\t\tif ((_connection == null) || _connection.isClosed()) {\n\t\t\t_connection = getDataSource().getConnection();\n\n\t\t\t_connection.setAutoCommit(true);\n\t\t}\n\n\t\treturn _connection;\n\t}","id":49759,"modified_method":"public Connection getConnection() throws SQLException {\n\t\tConnection con = getDataSource().getConnection();\n\n\t\tcon.setAutoCommit(true);\n\n\t\treturn con;\n\t}","commit_id":"f041d5de485b36fc940905abb34fb8f0b9b4a095","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public long increment(String name, int size)\n\t\tthrows SystemException {\n\n\t\tif (size < _MINIMUM_INCREMENT_SIZE) {\n\t\t\tsize = _MINIMUM_INCREMENT_SIZE;\n\t\t}\n\n\t\tCounterRegister register = getCounterRegister(name);\n\n\t\tsynchronized (register) {\n\t\t\tlong newValue = register.getCurrentValue() + size;\n\n\t\t\tif (newValue > register.getRangeMax()) {\n\t\t\t\tSession session = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tConnection connection = getConnection();\n\n\t\t\t\t\tsession = _sessionFactory.openNewSession(connection);\n\n\t\t\t\t\tCounter counter = (Counter)session.get(\n\t\t\t\t\t\tCounter.class, register.getName());\n\n\t\t\t\t\tnewValue = counter.getCurrentId() + 1;\n\n\t\t\t\t\tlong rangeMax =\n\t\t\t\t\t\tcounter.getCurrentId() + register.getRangeSize();\n\n\t\t\t\t\tcounter.setCurrentId(rangeMax);\n\n\t\t\t\t\tsession.save(counter);\n\t\t\t\t\tsession.flush();\n\n\t\t\t\t\tregister.setCurrentValue(newValue);\n\t\t\t\t\tregister.setRangeMax(rangeMax);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow processException(e);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tregister.setCurrentValue(newValue);\n\t\t\t}\n\n\t\t\treturn newValue;\n\t\t}\n\t}","id":49760,"modified_method":"public long increment(String name, int size) throws SystemException {\n\n\t\tif (size < _MINIMUM_INCREMENT_SIZE) {\n\t\t\tsize = _MINIMUM_INCREMENT_SIZE;\n\t\t}\n\n\t\tCounterRegister register = getCounterRegister(name);\n\n\t\treturn competeIncrement(register, size);\n\t}","commit_id":"f041d5de485b36fc940905abb34fb8f0b9b4a095","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void reset(String name) throws SystemException {\n\t\tCounterRegister register = getCounterRegister(name);\n\n\t\tsynchronized (register) {\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tConnection connection = getConnection();\n\n\t\t\t\tsession = _sessionFactory.openNewSession(connection);\n\n\t\t\t\tCounter counter = (Counter)session.load(Counter.class, name);\n\n\t\t\t\tsession.delete(counter);\n\n\t\t\t\tsession.flush();\n\t\t\t}\n\t\t\tcatch (ObjectNotFoundException onfe) {\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow processException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tsession.close();\n\t\t\t}\n\n\t\t\t_registerLookup.remove(name);\n\t\t}\n\t}","id":49761,"modified_method":"public void reset(String name) throws SystemException {\n\t\tCounterRegister register = getCounterRegister(name);\n\n\t\tsynchronized (register) {\n\t\t\tConnection con = null;\n\t\t\tPreparedStatement ps = null;\n\t\t\ttry {\n\t\t\t\tcon = getConnection();\n\t\t\t\tps = con.prepareStatement(_SQL_DELETE_BY_NAME);\n\t\t\t\tps.setString(1, name);\n\t\t\t\tps.executeUpdate();\n\t\t\t}\n\t\t\tcatch (ObjectNotFoundException onfe) {\n\t\t\t\t// No such counter item, no need to process\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow processException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tDataAccess.cleanUp(con, ps);\n\t\t\t}\n\n\t\t\t_registerLookup.remove(name);\n\t\t}\n\t}","commit_id":"f041d5de485b36fc940905abb34fb8f0b9b4a095","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void rename(String oldName, String newName)\n\t\tthrows SystemException {\n\n\t\tCounterRegister register = getCounterRegister(oldName);\n\n\t\tsynchronized (register) {\n\t\t\tif (_registerLookup.containsKey(newName)) {\n\t\t\t\tthrow new SystemException(\n\t\t\t\t\t\"Cannot rename \" + oldName + \" to \" + newName);\n\t\t\t}\n\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tConnection connection = getConnection();\n\n\t\t\t\tsession = _sessionFactory.openNewSession(connection);\n\n\t\t\t\tCounter counter = (Counter)session.load(Counter.class, oldName);\n\n\t\t\t\tlong currentId = counter.getCurrentId();\n\n\t\t\t\tsession.delete(counter);\n\n\t\t\t\tcounter = new Counter();\n\n\t\t\t\tcounter.setName(newName);\n\t\t\t\tcounter.setCurrentId(currentId);\n\n\t\t\t\tsession.save(counter);\n\n\t\t\t\tsession.flush();\n\t\t\t}\n\t\t\tcatch (ObjectNotFoundException onfe) {\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow processException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tsession.close();\n\t\t\t}\n\n\t\t\tregister.setName(newName);\n\n\t\t\t_registerLookup.put(newName, register);\n\t\t\t_registerLookup.remove(oldName);\n\t\t}\n\t}","id":49762,"modified_method":"public void rename(String oldName, String newName) throws SystemException {\n\t\tCounterRegister register = getCounterRegister(oldName);\n\n\t\tsynchronized (register) {\n\t\t\tif (_registerLookup.containsKey(newName)) {\n\t\t\t\tthrow new SystemException(\n\t\t\t\t\t\"Cannot rename \" + oldName + \" to \" + newName);\n\t\t\t}\n\n\t\t\tConnection con = null;\n\t\t\tPreparedStatement ps = null;\n\t\t\ttry {\n\t\t\t\tcon = getConnection();\n\t\t\t\tps = con.prepareStatement(_SQL_UPDATE_NAME_BY_NAME);\n\n\t\t\t\tps.setString(1, newName);\n\t\t\t\tps.setString(2, oldName);\n\n\t\t\t\tps.executeUpdate();\n\t\t\t}\n\t\t\tcatch (ObjectNotFoundException onfe) {\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow processException(e);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tDataAccess.cleanUp(con, ps);\n\t\t\t}\n\n\t\t\tregister.setName(newName);\n\n\t\t\t_registerLookup.put(newName, register);\n\t\t\t_registerLookup.remove(oldName);\n\t\t}\n\t}","commit_id":"f041d5de485b36fc940905abb34fb8f0b9b4a095","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public CounterRegister(String name, long rangeMin, long rangeMax,\n\t\t\t\t\t\t   int rangeSize) {\n\n\t\t_name = name;\n\t\t_currentValue = rangeMin;\n\t\t_rangeMax = rangeMax;\n\t\t_rangeSize = rangeSize;\n\t}","id":49763,"modified_method":"public CounterRegister(\n\t\tString name, long rangeMin, long rangeMax, int rangeSize) {\n\n\t\t_name = name;\n\t\t_holder = new CounterHolder(rangeMin, rangeMax);\n\t\t_rangeSize = rangeSize;\n\t\t_latch = new CompeteLatch();\n\t}","commit_id":"f041d5de485b36fc940905abb34fb8f0b9b4a095","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    protected byte[] readBlockFromBackend(BlockId blockId) throws Exception {\n        String id = StringUtils.convertBytesToHex(blockId.getDigest());\n        byte[] data = cache.get(id);\n        try {\n            PreparedStatement prep = connection.prepareStatement(\"select data from datastore_data where id = ?\");\n            try {\n                prep.setString(1, id);\n                ResultSet rs = prep.executeQuery();\n                if (!rs.next()) {\n                    throw new IOException(\"Datastore block \" + id + \" not found\");\n                }\n                data = rs.getBytes(1);\n            } finally {\n                prep.close();\n            }\n            cache.put(id, data);\n        } finally {\n            connection.commit();\n        }\n        // System.out.println(\"    read block \" + id + \" blockLen: \" +\n        // data.length + \" [0]: \" + data[0]);\n        if (blockId.getPos() == 0) {\n            return data;\n        }\n        int len = (int) (data.length - blockId.getPos());\n        if (len < 0) {\n            return new byte[0];\n        }\n        byte[] d2 = new byte[len];\n        System.arraycopy(data, (int) blockId.getPos(), d2, 0, len);\n        return d2;\n    }","id":49764,"modified_method":"@Override\n    protected byte[] readBlockFromBackend(BlockId blockId) throws Exception {\n\n        String id = StringUtils.convertBytesToHex(blockId.getDigest());\n        byte[] data = cache.get(id);\n        Connection con = ds.getConnection();\n\n        try {\n            PreparedStatement prep = con.prepareStatement(\"select data from datastore_data where id = ?\");\n            try {\n                prep.setString(1, id);\n                ResultSet rs = prep.executeQuery();\n                if (!rs.next()) {\n                    throw new IOException(\"Datastore block \" + id + \" not found\");\n                }\n                data = rs.getBytes(1);\n            } finally {\n                prep.close();\n            }\n            cache.put(id, data);\n        } finally {\n            con.commit();\n            con.close();\n        }\n        // System.out.println(\"    read block \" + id + \" blockLen: \" +\n        // data.length + \" [0]: \" + data[0]);\n        if (blockId.getPos() == 0) {\n            return data;\n        }\n        int len = (int) (data.length - blockId.getPos());\n        if (len < 0) {\n            return new byte[0];\n        }\n        byte[] d2 = new byte[len];\n        System.arraycopy(data, (int) blockId.getPos(), d2, 0, len);\n        return d2;\n    }","commit_id":"9b027c5467d6edadf9b752237963f7745d8801dd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Iterator<String> getAllChunkIds(long maxLastModifiedTime) throws Exception {\n        return new ChunkIdIterator(this.connection, maxLastModifiedTime);\n    }","id":49765,"modified_method":"@Override\n    public Iterator<String> getAllChunkIds(long maxLastModifiedTime) throws Exception {\n        return new ChunkIdIterator(this.ds, maxLastModifiedTime);\n    }","commit_id":"9b027c5467d6edadf9b752237963f7745d8801dd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void finalize() {\n        if (this.connection != null && this.callStack != null) {\n            LOG.debug(\"finalizing RDBDocumentStore that was not disposed\", this.callStack);\n        }\n    }","id":49766,"modified_method":"@Override\n    public void finalize() {\n        if (this.ds != null && this.callStack != null) {\n            LOG.debug(\"finalizing RDBDocumentStore that was not disposed\", this.callStack);\n        }\n    }","commit_id":"9b027c5467d6edadf9b752237963f7745d8801dd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected void mark(BlockId blockId) throws Exception {\n        try {\n            if (minLastModified == 0) {\n                return;\n            }\n            String id = StringUtils.convertBytesToHex(blockId.getDigest());\n            PreparedStatement prep = connection\n                    .prepareStatement(\"update datastore_meta set lastMod = ? where id = ? and lastMod < ?\");\n            prep.setLong(1, System.currentTimeMillis());\n            prep.setString(2, id);\n            prep.setLong(3, minLastModified);\n            prep.executeUpdate();\n            prep.close();\n        } finally {\n            connection.commit();\n        }\n    }","id":49767,"modified_method":"@Override\n    protected void mark(BlockId blockId) throws Exception {\n        Connection con = ds.getConnection();\n        try {\n            if (minLastModified == 0) {\n                return;\n            }\n            String id = StringUtils.convertBytesToHex(blockId.getDigest());\n            PreparedStatement prep = con.prepareStatement(\"update datastore_meta set lastMod = ? where id = ? and lastMod < ?\");\n            prep.setLong(1, System.currentTimeMillis());\n            prep.setString(2, id);\n            prep.setLong(3, minLastModified);\n            prep.executeUpdate();\n            prep.close();\n        } finally {\n            con.commit();\n            con.close();\n        }\n    }","commit_id":"9b027c5467d6edadf9b752237963f7745d8801dd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public ChunkIdIterator(Connection connection, long maxLastModifiedTime) {\n            this.maxLastModifiedTime = maxLastModifiedTime;\n            this.connection = connection;\n        }","id":49768,"modified_method":"public ChunkIdIterator(DataSource ds, long maxLastModifiedTime) {\n            this.maxLastModifiedTime = maxLastModifiedTime;\n            this.ds = ds;\n        }","commit_id":"9b027c5467d6edadf9b752237963f7745d8801dd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean deleteChunks(List<String> chunkIds, long maxLastModifiedTime) throws Exception {\n        try {\n            PreparedStatement prep = null;\n            PreparedStatement prepData = null;\n\n            StringBuilder inClause = new StringBuilder();\n            int batch = chunkIds.size();\n            for (int i = 0; i < batch; i++) {\n                inClause.append('?');\n                if (i != batch - 1) {\n                    inClause.append(',');\n                }\n            }\n\n            if (maxLastModifiedTime > 0) {\n                prep = connection.prepareStatement(\n                        \"delete from datastore_meta where id in (\" \n                                + inClause.toString() + \") and lastMod <= ?\");\n                prep.setLong(batch + 1, maxLastModifiedTime);\n\n                prepData = connection.prepareStatement(\n                        \"delete from datastore_data where id in (\" \n                                + inClause.toString() + \") and lastMod <= ?\");\n                prepData.setLong(batch + 1, maxLastModifiedTime);\n            } else {\n                prep = connection.prepareStatement(\n                        \"delete from datastore_meta where id in (\" \n                                + inClause.toString() + \")\");\n\n                prepData = connection.prepareStatement(\n                        \"delete from datastore_data where id in (\" \n                                + inClause.toString() + \")\");\n            }\n            \n            for (int idx = 0; idx < batch; idx++) {\n                prep.setString(idx + 1, chunkIds.get(idx));\n                prepData.setString(idx + 1, chunkIds.get(idx));\n            }\n\n            prep.execute();\n            prepData.execute();\n            prep.close();\n            prepData.close();\n        } finally {\n            connection.commit();\n        }\n\n        return true;\n    }","id":49769,"modified_method":"@Override\n    public boolean deleteChunks(List<String> chunkIds, long maxLastModifiedTime) throws Exception {\n        Connection con = ds.getConnection();\n        try {\n            PreparedStatement prep = null;\n            PreparedStatement prepData = null;\n\n            StringBuilder inClause = new StringBuilder();\n            int batch = chunkIds.size();\n            for (int i = 0; i < batch; i++) {\n                inClause.append('?');\n                if (i != batch - 1) {\n                    inClause.append(',');\n                }\n            }\n\n            if (maxLastModifiedTime > 0) {\n                prep = con.prepareStatement(\n                        \"delete from datastore_meta where id in (\" \n                                + inClause.toString() + \") and lastMod <= ?\");\n                prep.setLong(batch + 1, maxLastModifiedTime);\n\n                prepData = con.prepareStatement(\n                        \"delete from datastore_data where id in (\" \n                                + inClause.toString() + \") and lastMod <= ?\");\n                prepData.setLong(batch + 1, maxLastModifiedTime);\n            } else {\n                prep = con.prepareStatement(\n                        \"delete from datastore_meta where id in (\" \n                                + inClause.toString() + \")\");\n\n                prepData = con.prepareStatement(\n                        \"delete from datastore_data where id in (\" \n                                + inClause.toString() + \")\");\n            }\n\n            for (int idx = 0; idx < batch; idx++) {\n                prep.setString(idx + 1, chunkIds.get(idx));\n                prepData.setString(idx + 1, chunkIds.get(idx));\n            }\n\n            prep.execute();\n            prepData.execute();\n            prep.close();\n            prepData.close();\n        } finally {\n            con.commit();\n            con.close();\n        }\n\n        return true;\n    }","commit_id":"9b027c5467d6edadf9b752237963f7745d8801dd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private boolean refill() {\n            StringBuffer query = new StringBuffer();\n            query.append(\"select id from datastore_meta\");\n            if (maxLastModifiedTime > 0) {\n                query.append(\" where lastMod <= ?\");\n                if (lastId != null) {\n                    query.append(\" and id > ?\");\n                }\n            } else {\n                if (lastId != null) {\n                    query.append(\" where id > ?\");\n                }\n            }\n            query.append(\" order by id limit \" + BATCHSIZE);\n\n            try {\n                try {\n                    PreparedStatement prep = connection.prepareStatement(query.toString());\n                    int idx = 1;\n                    if (maxLastModifiedTime > 0) {\n                        prep.setLong(idx++, maxLastModifiedTime);\n                    }\n                    if (lastId != null) {\n                        prep.setString(idx++, lastId);\n                    }\n\n                    ResultSet rs = prep.executeQuery();\n                    while (rs.next()) {\n                        lastId = rs.getString(1);\n                        results.add(lastId);\n                    }\n                    return !results.isEmpty();\n                } finally {\n                    connection.commit();\n                }\n            } catch (SQLException ex) {\n                try {\n                    connection.rollback();\n                } catch (SQLException e) {\n                }\n                return false;\n            }\n        }","id":49770,"modified_method":"private boolean refill() {\n            StringBuffer query = new StringBuffer();\n            query.append(\"select id from datastore_meta\");\n            if (maxLastModifiedTime > 0) {\n                query.append(\" where lastMod <= ?\");\n                if (lastId != null) {\n                    query.append(\" and id > ?\");\n                }\n            } else {\n                if (lastId != null) {\n                    query.append(\" where id > ?\");\n                }\n            }\n            query.append(\" order by id limit \" + BATCHSIZE);\n\n            Connection connection = null;\n            try {\n                connection = ds.getConnection();\n                try {\n                    PreparedStatement prep = connection.prepareStatement(query.toString());\n                    int idx = 1;\n                    if (maxLastModifiedTime > 0) {\n                        prep.setLong(idx++, maxLastModifiedTime);\n                    }\n                    if (lastId != null) {\n                        prep.setString(idx++, lastId);\n                    }\n\n                    ResultSet rs = prep.executeQuery();\n                    while (rs.next()) {\n                        lastId = rs.getString(1);\n                        results.add(lastId);\n                    }\n                    return !results.isEmpty();\n                } finally {\n                    connection.commit();\n                    connection.close();\n                }\n            } catch (SQLException ex) {\n                try {\n                    if (connection != null) {\n                        connection.rollback();\n                        connection.close();\n                    }\n                } catch (SQLException e) {\n                }\n                return false;\n            }\n        }","commit_id":"9b027c5467d6edadf9b752237963f7745d8801dd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void close() {\n        try {\n            this.connection.close();\n            this.connection = null;\n        } catch (SQLException ex) {\n            throw new MicroKernelException(ex);\n        }\n    }","id":49771,"modified_method":"@Override\n    public void close() {\n        this.ds = null;\n    }","commit_id":"9b027c5467d6edadf9b752237963f7745d8801dd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private int sweepFromDatabase() throws SQLException {\n        try {\n            int count = 0;\n            PreparedStatement prep = connection.prepareStatement(\"select id from datastore_meta where lastMod < ?\");\n            prep.setLong(1, minLastModified);\n            ResultSet rs = prep.executeQuery();\n            ArrayList<String> ids = new ArrayList<String>();\n            while (rs.next()) {\n                ids.add(rs.getString(1));\n            }\n            prep = connection.prepareStatement(\"delete from datastore_meta where id = ?\");\n            PreparedStatement prepData = connection.prepareStatement(\"delete from datastore_data where id = ?\");\n            for (String id : ids) {\n                prep.setString(1, id);\n                prep.execute();\n                prepData.setString(1, id);\n                prepData.execute();\n                count++;\n            }\n            prepData.close();\n            prep.close();\n            minLastModified = 0;\n            return count;\n        } finally {\n            connection.commit();\n        }\n    }","id":49772,"modified_method":"private int sweepFromDatabase() throws SQLException {\n        Connection con = ds.getConnection();\n        try {\n            int count = 0;\n            PreparedStatement prep = con.prepareStatement(\"select id from datastore_meta where lastMod < ?\");\n            prep.setLong(1, minLastModified);\n            ResultSet rs = prep.executeQuery();\n            ArrayList<String> ids = new ArrayList<String>();\n            while (rs.next()) {\n                ids.add(rs.getString(1));\n            }\n            prep = con.prepareStatement(\"delete from datastore_meta where id = ?\");\n            PreparedStatement prepData = con.prepareStatement(\"delete from datastore_data where id = ?\");\n            for (String id : ids) {\n                prep.setString(1, id);\n                prep.execute();\n                prepData.setString(1, id);\n                prepData.execute();\n                count++;\n            }\n            prepData.close();\n            prep.close();\n            minLastModified = 0;\n            return count;\n        } finally {\n            con.commit();\n            con.close();\n        }\n    }","commit_id":"9b027c5467d6edadf9b752237963f7745d8801dd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates a {@linkplain RDBBlobStore} instance using an embedded H2\n     * database in in-memory mode.\n     */\n    public RDBBlobStore() {\n        try {\n            String jdbcurl = \"jdbc:h2:mem:oaknodes\";\n            DataSource ds = RDBDataSourceFactory.forJdbcUrl(jdbcurl, \"sa\", \"\");\n            initialize(ds.getConnection());\n        } catch (Exception ex) {\n            throw new MicroKernelException(\"initializing RDB blob store\", ex);\n        }\n    }","id":49773,"modified_method":"/**\n     * Creates a {@linkplain RDBBlobStore} instance using an embedded H2\n     * database in in-memory mode.\n     */\n    public RDBBlobStore() {\n        try {\n            String jdbcurl = \"jdbc:h2:mem:oaknodes\";\n            DataSource ds = RDBDataSourceFactory.forJdbcUrl(jdbcurl, \"sa\", \"\");\n            initialize(ds);\n        } catch (Exception ex) {\n            throw new MicroKernelException(\"initializing RDB blob store\", ex);\n        }\n    }","commit_id":"9b027c5467d6edadf9b752237963f7745d8801dd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void storeBlockInDatabase(byte[] digest, int level, byte[] data) throws SQLException {\n        String id = StringUtils.convertBytesToHex(digest);\n        cache.put(id, data);\n        try {\n            long now = System.currentTimeMillis();\n            PreparedStatement prep = connection.prepareStatement(\"update datastore_meta set lastMod = ? where id = ?\");\n            int count;\n            try {\n                prep.setLong(1, now);\n                prep.setString(2, id);\n                count = prep.executeUpdate();\n            } finally {\n                prep.close();\n            }\n            if (count == 0) {\n                try {\n                    prep = connection.prepareStatement(\"insert into datastore_data(id, data) values(?, ?)\");\n                    try {\n                        prep.setString(1, id);\n                        prep.setBytes(2, data);\n                        prep.execute();\n                    } finally {\n                        prep.close();\n                    }\n                } catch (SQLException e) {\n                    // already exists - ok\n                }\n                try {\n                    prep = connection.prepareStatement(\"insert into datastore_meta(id, level, lastMod) values(?, ?, ?)\");\n                    try {\n                        prep.setString(1, id);\n                        prep.setInt(2, level);\n                        prep.setLong(3, now);\n                        prep.execute();\n                    } finally {\n                        prep.close();\n                    }\n                } catch (SQLException e) {\n                    // already exists - ok\n                }\n            }\n        } finally {\n            connection.commit();\n        }\n    }","id":49774,"modified_method":"private void storeBlockInDatabase(byte[] digest, int level, byte[] data) throws SQLException {\n\n        String id = StringUtils.convertBytesToHex(digest);\n        cache.put(id, data);\n        Connection con = ds.getConnection();\n\n        try {\n            long now = System.currentTimeMillis();\n            PreparedStatement prep = con.prepareStatement(\"update datastore_meta set lastMod = ? where id = ?\");\n            int count;\n            try {\n                prep.setLong(1, now);\n                prep.setString(2, id);\n                count = prep.executeUpdate();\n            } finally {\n                prep.close();\n            }\n            if (count == 0) {\n                try {\n                    prep = con.prepareStatement(\"insert into datastore_data(id, data) values(?, ?)\");\n                    try {\n                        prep.setString(1, id);\n                        prep.setBytes(2, data);\n                        prep.execute();\n                    } finally {\n                        prep.close();\n                    }\n                } catch (SQLException e) {\n                    // already exists - ok\n                }\n                try {\n                    prep = con.prepareStatement(\"insert into datastore_meta(id, level, lastMod) values(?, ?, ?)\");\n                    try {\n                        prep.setString(1, id);\n                        prep.setInt(2, level);\n                        prep.setLong(3, now);\n                        prep.execute();\n                    } finally {\n                        prep.close();\n                    }\n                } catch (SQLException e) {\n                    // already exists - ok\n                }\n            }\n        } finally {\n            con.commit();\n            con.close();\n        }\n    }","commit_id":"9b027c5467d6edadf9b752237963f7745d8801dd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates a {@linkplain RDBBlobStore} instance using the provided JDBC\n     * connection information.\n     */\n    public RDBBlobStore(String jdbcurl, String username, String password) {\n        try {\n            DataSource ds = RDBDataSourceFactory.forJdbcUrl(jdbcurl, username, password);\n            initialize(ds.getConnection());\n        } catch (Exception ex) {\n            throw new MicroKernelException(\"initializing RDB blob store\", ex);\n        }\n    }","id":49775,"modified_method":"/**\n     * Creates a {@linkplain RDBBlobStore} instance using the provided JDBC\n     * connection information.\n     */\n    public RDBBlobStore(String jdbcurl, String username, String password) {\n        try {\n            DataSource ds = RDBDataSourceFactory.forJdbcUrl(jdbcurl, username, password);\n            initialize(ds);\n        } catch (Exception ex) {\n            throw new MicroKernelException(\"initializing RDB blob store\", ex);\n        }\n    }","commit_id":"9b027c5467d6edadf9b752237963f7745d8801dd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates a {@linkplain RDBBlobStore} instance using the provided\n     * {@link DataSource}.\n     */\n    public RDBBlobStore(DataSource ds) {\n        try {\n            initialize(ds.getConnection());\n        } catch (Exception ex) {\n            throw new MicroKernelException(\"initializing RDB blob store\", ex);\n        }\n    }","id":49776,"modified_method":"/**\n     * Creates a {@linkplain RDBBlobStore} instance using the provided\n     * {@link DataSource}.\n     */\n    public RDBBlobStore(DataSource ds) {\n        try {\n            initialize(ds);\n        } catch (Exception ex) {\n            throw new MicroKernelException(\"initializing RDB blob store\", ex);\n        }\n    }","commit_id":"9b027c5467d6edadf9b752237963f7745d8801dd","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Config(String name, Map<String, String> properties) {\n    Preconditions.checkNotNull(name);\n    Preconditions.checkNotNull(properties);\n    this.id = name;\n    this.properties = ImmutableMap.copyOf(properties);\n  }","id":49777,"modified_method":"/**\n   * Constructor for Config Class.\n   * @param name name of the configuration\n   * @param properties map of properties\n   */\n  public Config(String name, Map<String, String> properties) {\n    Preconditions.checkNotNull(name);\n    Preconditions.checkNotNull(properties);\n    this.id = name;\n    this.properties = ImmutableMap.copyOf(properties);\n  }","commit_id":"d0f1e4a783b7f30cc9c23692b44c9afcbb9518cc","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void create(final String namespace, final String type, final Config config) throws Exception {\n    txnl.executeUnchecked(new TransactionExecutor.Function<ConfigTable, Void>() {\n      @Override\n      public Void apply(ConfigTable configTable) throws Exception {\n        if (configTable.table.get(rowKey(namespace, type), Bytes.toBytes(config.getId())) != null) {\n          throw new ConfigExistsException(namespace, type, config.getId());\n        }\n        configTable.table.put(rowKey(namespace, type), Bytes.toBytes(config.getId()),\n                              Bytes.toBytes(GSON.toJson(config.getProperties())));\n        return null;\n      }\n    });\n  }","id":49778,"modified_method":"@Override\n  public void create(final String namespace, final String type, final Config config) throws ConfigExistsException {\n    Boolean success = txnl.executeUnchecked(new TransactionExecutor.Function<ConfigTable, Boolean>() {\n      @Override\n      public Boolean apply(ConfigTable configTable) throws Exception {\n        if (configTable.table.get(rowKey(namespace, type), Bytes.toBytes(config.getId())) != null) {\n          return false;\n        }\n        configTable.table.put(rowKey(namespace, type), Bytes.toBytes(config.getId()),\n                              Bytes.toBytes(GSON.toJson(config.getProperties())));\n        return true;\n      }\n    });\n\n    if (!success) {\n      throw new ConfigExistsException(namespace, type, config.getId());\n    }\n  }","commit_id":"d0f1e4a783b7f30cc9c23692b44c9afcbb9518cc","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Config get(final String namespace, final String type, final String id) throws Exception {\n    return txnl.executeUnchecked(new TransactionExecutor.Function<ConfigTable, Config>() {\n      @Override\n      public Config apply(ConfigTable configTable) throws Exception {\n        if (configTable.table.get(rowKey(namespace, type), Bytes.toBytes(id)) == null) {\n          throw new ConfigNotFoundException(namespace, type, id);\n        }\n        byte[] prop = configTable.table.get(rowKey(namespace, type), Bytes.toBytes(id));\n        Map<String, String> propertyMap = GSON.fromJson(Bytes.toString(prop), MAP_STRING_STRING_TYPE);\n        return new Config(id, propertyMap);\n      }\n    });\n  }","id":49779,"modified_method":"@Override\n  public Config get(final String namespace, final String type, final String id) throws ConfigNotFoundException {\n    Config config = txnl.executeUnchecked(new TransactionExecutor.Function<ConfigTable, Config>() {\n      @Override\n      public Config apply(ConfigTable configTable) throws Exception {\n        if (configTable.table.get(rowKey(namespace, type), Bytes.toBytes(id)) == null) {\n          return null;\n        }\n        byte[] prop = configTable.table.get(rowKey(namespace, type), Bytes.toBytes(id));\n        Map<String, String> propertyMap = GSON.fromJson(Bytes.toString(prop), MAP_STRING_STRING_TYPE);\n        return new Config(id, propertyMap);\n      }\n    });\n\n    if (config == null) {\n      throw new ConfigNotFoundException(namespace, type, id);\n    } else {\n      return config;\n    }\n  }","commit_id":"d0f1e4a783b7f30cc9c23692b44c9afcbb9518cc","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void update(final String namespace, final String type, final Config config) throws Exception {\n    txnl.executeUnchecked(new TransactionExecutor.Function<ConfigTable, Void>() {\n      @Override\n      public Void apply(ConfigTable configTable) throws Exception {\n        if (configTable.table.get(rowKey(namespace, type), Bytes.toBytes(config.getId())) == null) {\n          throw new ConfigNotFoundException(namespace, type, config.getId());\n        }\n        configTable.table.put(rowKey(namespace, type), Bytes.toBytes(config.getId()),\n                              Bytes.toBytes(GSON.toJson(config.getProperties())));\n        return null;\n      }\n    });\n  }","id":49780,"modified_method":"@Override\n  public void update(final String namespace, final String type, final Config config) throws ConfigNotFoundException {\n    Boolean success = txnl.executeUnchecked(new TransactionExecutor.Function<ConfigTable, Boolean>() {\n      @Override\n      public Boolean apply(ConfigTable configTable) throws Exception {\n        if (configTable.table.get(rowKey(namespace, type), Bytes.toBytes(config.getId())) == null) {\n          return false;\n        }\n        configTable.table.put(rowKey(namespace, type), Bytes.toBytes(config.getId()),\n                              Bytes.toBytes(GSON.toJson(config.getProperties())));\n        return true;\n      }\n    });\n\n    if (!success) {\n      throw new ConfigNotFoundException(namespace, type, config.getId());\n    }\n  }","commit_id":"d0f1e4a783b7f30cc9c23692b44c9afcbb9518cc","url":"https://github.com/caskdata/cdap"},{"original_method":"private String rowKeyString(String namespace, String type) {\n    return String.format(\"%s.%s\", namespace, type);\n  }","id":49781,"modified_method":"private String rowKeyString(String namespace, String type) {\n    int nsSize = namespace.length();\n    int typeSize = type.length();\n    return String.format(\"%b%d%s%d%s\", Constants.ConfigStore.VERSION, nsSize, namespace, typeSize, type);\n  }","commit_id":"d0f1e4a783b7f30cc9c23692b44c9afcbb9518cc","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void delete(final String namespace, final String type, final String id) throws Exception {\n    txnl.executeUnchecked(new TransactionExecutor.Function<ConfigTable, Void>() {\n      @Override\n      public Void apply(ConfigTable configTable) throws Exception {\n        if (configTable.table.get(rowKey(namespace, type), Bytes.toBytes(id)) == null) {\n          throw new ConfigNotFoundException(namespace, type, id);\n        }\n        configTable.table.delete(rowKey(namespace, type), Bytes.toBytes(id));\n        return null;\n      }\n    });\n  }","id":49782,"modified_method":"@Override\n  public void delete(final String namespace, final String type, final String id) throws ConfigNotFoundException {\n    Boolean success = txnl.executeUnchecked(new TransactionExecutor.Function<ConfigTable, Boolean>() {\n      @Override\n      public Boolean apply(ConfigTable configTable) throws Exception {\n        if (configTable.table.get(rowKey(namespace, type), Bytes.toBytes(id)) == null) {\n          return false;\n        }\n        configTable.table.delete(rowKey(namespace, type), Bytes.toBytes(id));\n        return true;\n      }\n    });\n\n    if (!success) {\n      throw new ConfigNotFoundException(namespace, type, id);\n    }\n  }","commit_id":"d0f1e4a783b7f30cc9c23692b44c9afcbb9518cc","url":"https://github.com/caskdata/cdap"},{"original_method":"private void upgradeSystemDatasets(Injector injector) throws Exception {\n    // Setting up all system datasets to be upgraded, collecting them from respective components\n    DatasetFramework framework = createRegisteredDatasetFramework(injector);\n    // dataset service\n    DatasetMetaTableUtil.setupDatasets(framework);\n    // app metadata\n    DefaultStore.setupDatasets(framework);\n    // logs metadata\n    LogSaverTableUtil.setupDatasets(framework);\n    // scheduler metadata\n    ScheduleStoreTableUtil.setupDatasets(framework);\n\n    // Upgrade all datasets\n    for (DatasetSpecification spec : framework.getInstances()) {\n      System.out.println(String.format(\"Upgrading dataset: %s, spec: %s\", spec.getName(), spec.toString()));\n      DatasetAdmin admin = framework.getAdmin(spec.getName(), null);\n      // we know admin is not null, since we are looping over existing datasets\n      admin.upgrade();\n      System.out.println(String.format(\"Upgraded dataset: %s\", spec.getName()));\n    }\n  }","id":49783,"modified_method":"private void upgradeSystemDatasets(Injector injector) throws Exception {\n    // Setting up all system datasets to be upgraded, collecting them from respective components\n    DatasetFramework framework = createRegisteredDatasetFramework(injector);\n    // dataset service\n    DatasetMetaTableUtil.setupDatasets(framework);\n    // app metadata\n    DefaultStore.setupDatasets(framework);\n    // config store\n    DefaultConfigStore.setupDatasets(framework);\n    // logs metadata\n    LogSaverTableUtil.setupDatasets(framework);\n    // scheduler metadata\n    ScheduleStoreTableUtil.setupDatasets(framework);\n\n    // Upgrade all datasets\n    for (DatasetSpecification spec : framework.getInstances()) {\n      System.out.println(String.format(\"Upgrading dataset: %s, spec: %s\", spec.getName(), spec.toString()));\n      DatasetAdmin admin = framework.getAdmin(spec.getName(), null);\n      // we know admin is not null, since we are looping over existing datasets\n      admin.upgrade();\n      System.out.println(String.format(\"Upgraded dataset: %s\", spec.getName()));\n    }\n  }","commit_id":"d0f1e4a783b7f30cc9c23692b44c9afcbb9518cc","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\r\n   * Adjusts the Time to the time zone.\r\n   * @param it item to be checked\r\n   * @param zon timezone\r\n   * @param d zone was defined\r\n   * @return duration\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item timzon(final Item it, final Item zon, final boolean d)\r\n      throws QueryException {\r\n\r\n    final Item i = it.type.isUntyped() ? new Tim(it.string(info), info) :\r\n      checkType(it, AtomType.TIM);\r\n    return adjust((Date) i, zon, d);\r\n  }","id":49784,"modified_method":"/**\r\n   * Adjusts the Time to the time zone.\r\n   * @param it item to be checked\r\n   * @param zon timezone\r\n   * @param d zone was defined\r\n   * @return duration\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item timzon(final Item it, final Item zon, final boolean d)\r\n      throws QueryException {\r\n\r\n    final Item i = it.type.isUntyped() ? new Tim(it.string(info), info) :\r\n      new Tim((Date) checkType(it, AtomType.TIM));\r\n    return adjust((Date) i, zon, d);\r\n  }","commit_id":"6a19bbf2a772a8905eb282423d295707bad4e81a","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Adjusts the Date to the time zone.\r\n   * @param it item to be checked\r\n   * @param zon timezone\r\n   * @param d zone was defined\r\n   * @return duration\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item datzon(final Item it, final Item zon, final boolean d)\r\n      throws QueryException {\r\n\r\n    final Item i = it.type.isUntyped() ? new Dat(it.string(info), info) :\r\n      checkType(it, AtomType.DAT);\r\n    return adjust((Date) i, zon, d);\r\n  }","id":49785,"modified_method":"/**\r\n   * Adjusts the Date to the time zone.\r\n   * @param it item to be checked\r\n   * @param zon timezone\r\n   * @param d zone was defined\r\n   * @return duration\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item datzon(final Item it, final Item zon, final boolean d)\r\n      throws QueryException {\r\n\r\n    final Item i = it.type.isUntyped() ? new Dat(it.string(info), info) :\r\n      new Dat((Date) checkType(it, AtomType.DAT));\r\n    return adjust((Date) i, zon, d);\r\n  }","commit_id":"6a19bbf2a772a8905eb282423d295707bad4e81a","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Adjusts the DateTime to the time zone.\r\n   * @param it item to be checked\r\n   * @param zon timezone\r\n   * @param d zone was defined\r\n   * @return duration\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item dtmzon(final Item it, final Item zon, final boolean d)\r\n      throws QueryException {\r\n\r\n    final Item i = it.type.isUntyped() ? new Dtm(it.string(info), info) :\r\n      checkType(it, AtomType.DTM);\r\n    return adjust((Date) i, zon, d);\r\n  }","id":49786,"modified_method":"/**\r\n   * Adjusts the DateTime to the time zone.\r\n   * @param it item to be checked\r\n   * @param zon timezone\r\n   * @param d zone was defined\r\n   * @return duration\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item dtmzon(final Item it, final Item zon, final boolean d)\r\n      throws QueryException {\r\n\r\n    final Item i = it.type.isUntyped() ? new Dtm(it.string(info), info) :\r\n      new Dtm((Date) checkType(it, AtomType.DTM));\r\n    return adjust((Date) i, zon, d);\r\n  }","commit_id":"6a19bbf2a772a8905eb282423d295707bad4e81a","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Constructor.\r\n   * @param d date\r\n   */\r\n  Tim(final Date d) {\r\n    super(AtomType.TIM, d);\r\n    xc.setYear(UNDEF);\r\n    xc.setMonth(UNDEF);\r\n    xc.setDay(UNDEF);\r\n  }","id":49787,"modified_method":"/**\r\n   * Constructor.\r\n   * @param d date\r\n   */\r\n  public Tim(final Date d) {\r\n    super(AtomType.TIM, d);\r\n    xc.setYear(UNDEF);\r\n    xc.setMonth(UNDEF);\r\n    xc.setDay(UNDEF);\r\n  }","commit_id":"6a19bbf2a772a8905eb282423d295707bad4e81a","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n     * Authorize credit card payment service. Service wrapper around PayFlow Pro API.\n     * @param dctx Service Engine DispatchContext.\n     * @param context Map context of parameters.\n     * @return Response map, including RESPMSG, and RESULT keys.\n     */\n    public static Map ccProcessor(DispatchContext dctx, Map context) {\n        GenericValue paymentPref = (GenericValue) context.get(\"orderPaymentPreference\");\n        GenericValue authTrans = (GenericValue) context.get(\"authTrans\");\n        String orderId = (String) context.get(\"orderId\");\n        String cvv2 = (String) context.get(\"cardSecurityCode\");\n        Double processAmount = (Double) context.get(\"processAmount\");\n        GenericValue party = (GenericValue) context.get(\"billToParty\");\n        GenericValue cc = (GenericValue) context.get(\"creditCard\");\n        GenericValue ps = (GenericValue) context.get(\"billingAddress\");\n        String configString = (String) context.get(\"paymentConfig\");\n        if (configString == null) {\n            configString = \"payment.properties\";\n        }\n\n        if (authTrans == null){\n            authTrans = PaymentGatewayServices.getAuthTransaction(paymentPref);\n        }\n\n        // set the orderId as comment1 so we can query in PF Manager\n        boolean isReAuth = false;\n        Map data = UtilMisc.toMap(\"COMMENT1\", orderId);\n        data.put(\"PONUM\", orderId);\n        data.put(\"CUSTCODE\", party.getString(\"partyId\"));\n\n        // transaction type\n        if (UtilProperties.propertyValueEqualsIgnoreCase(configString, \"payment.verisign.preAuth\", \"Y\")) {\n            data.put(\"TRXTYPE\", \"A\");\n            // only support re-auth for auth types; sale types don't do it\n            if (authTrans != null) {\n                String refNum = authTrans.getString(\"referenceNum\");\n                data.put(\"ORIGID\", refNum);\n                isReAuth = true;\n            }\n        } else {\n            data.put(\"TRXTYPE\", \"S\");\n        }\n\n        // credit card tender\n        data.put(\"TENDER\", \"C\");\n\n        // card security code\n        if (UtilValidate.isNotEmpty(cvv2)) {\n            data.put(\"CVV2\", cvv2);\n        }\n\n        // set the amount\n        data.put(\"AMT\", processAmount.toString());\n\n        // get the payment information\n        data.put(\"ACCT\", cc.getString(\"cardNumber\"));\n\n        // name on card\n        String name = cc.getString(\"firstNameOnCard\") + \" \" + cc.getString(\"lastNameOnCard\");\n        data.put(\"FIRSTNAME\", cc.getString(\"firstNameOnCard\"));\n        data.put(\"LASTNAME\", cc.getString(\"lastNameOnCard\"));\n        data.put(\"COMMENT2\", name);\n        if (cc.get(\"expireDate\") != null) {\n            String exp = cc.getString(\"expireDate\");\n            String expDate = exp.substring(0, 2);\n\n            expDate = expDate + exp.substring(exp.length() - 2);\n            data.put(\"EXPDATE\", expDate);\n        }\n\n        // gather the address info\n        if (ps != null) {\n            String street = ps.getString(\"address1\") +\n                (ps.get(\"address2\") != null && ps.getString(\"address2\").length() > 0 ? \" \" +\n                    ps.getString(\"address2\") : \"\");\n\n            data.put(\"STREET\", street);\n            data.put(\"ZIP\", ps.getString(\"postalCode\"));\n        }\n\n        PFProAPI pn = init(configString);\n\n        // get the base params\n        StringBuffer params = makeBaseParams(configString);\n\n        // parse the context parameters\n        params.append(\"&\").append(parseContext(data));\n\n        // transmit the request\n        if (Debug.verboseOn()) Debug.logVerbose(\"Sending to Verisign: \" + params.toString(), module);\n        String resp;\n        if (UtilProperties.propertyValueEqualsIgnoreCase(configString, \"payment.verisign.enable_transmit\", \"true\")) {\n            resp = pn.SubmitTransaction(params.toString());\n        } else {\n            resp = \"RESULT=0&AUTHCODE=T&PNREF=\" + (new Date()).getTime() + \"&RESPMSG=Testing\";\n        } \n\n        if (Debug.verboseOn()) Debug.logVerbose(\"Response from Verisign: \" + resp, module);\n\n        // reset for next use\n        pn.DestroyContext();\n\n        // check the response\n        Map result = ServiceUtil.returnSuccess();\n        parseAuthResponse(resp, result, configString, isReAuth);\n        result.put(\"processAmount\", processAmount);\n        return result;\n    }","id":49788,"modified_method":"/**\n     * Authorize credit card payment service. Service wrapper around PayFlow Pro API.\n     * @param dctx Service Engine DispatchContext.\n     * @param context Map context of parameters.\n     * @return Response map, including RESPMSG, and RESULT keys.\n     */\n    public static Map ccProcessor(DispatchContext dctx, Map context) {\n        GenericValue paymentPref = (GenericValue) context.get(\"orderPaymentPreference\");\n        GenericValue authTrans = (GenericValue) context.get(\"authTrans\");\n        String orderId = (String) context.get(\"orderId\");\n        String cvv2 = (String) context.get(\"cardSecurityCode\");\n        Double processAmount = (Double) context.get(\"processAmount\");\n        GenericValue party = (GenericValue) context.get(\"billToParty\");\n        GenericValue cc = (GenericValue) context.get(\"creditCard\");\n        GenericValue ps = (GenericValue) context.get(\"billingAddress\");\n        String configString = (String) context.get(\"paymentConfig\");\n        if (configString == null) {\n            configString = \"payment.properties\";\n        }\n\n        if (authTrans == null){\n            authTrans = PaymentGatewayServices.getAuthTransaction(paymentPref);\n        }\n\n        // set the orderId as comment1 so we can query in PF Manager\n        boolean isReAuth = false;\n        Map data = UtilMisc.toMap(\"COMMENT1\", orderId);\n        data.put(\"PONUM\", orderId);\n        data.put(\"CUSTCODE\", party.getString(\"partyId\"));\n\n        // transaction type\n        if (UtilProperties.propertyValueEqualsIgnoreCase(configString, \"payment.verisign.preAuth\", \"Y\")) {\n            data.put(\"TRXTYPE\", \"A\");\n            // only support re-auth for auth types; sale types don't do it\n            if (authTrans != null) {\n                String refNum = authTrans.getString(\"referenceNum\");\n                data.put(\"ORIGID\", refNum);\n                isReAuth = true;\n            }\n        } else {\n            data.put(\"TRXTYPE\", \"S\");\n        }\n\n        // credit card tender\n        data.put(\"TENDER\", \"C\");\n\n        // card security code\n        if (UtilValidate.isNotEmpty(cvv2)) {\n            data.put(\"CVV2\", cvv2);\n        }\n\n        // set the amount\n        data.put(\"AMT\", processAmount.toString());\n\n        // get the payment information\n        data.put(\"ACCT\", cc.getString(\"cardNumber\"));\n\n        // name on card\n        String name = cc.getString(\"firstNameOnCard\") + \" \" + cc.getString(\"lastNameOnCard\");\n        data.put(\"FIRSTNAME\", cc.getString(\"firstNameOnCard\"));\n        data.put(\"LASTNAME\", cc.getString(\"lastNameOnCard\"));\n        data.put(\"COMMENT2\", name);\n        if (cc.get(\"expireDate\") != null) {\n            String exp = cc.getString(\"expireDate\");\n            String expDate = exp.substring(0, 2);\n\n            expDate = expDate + exp.substring(exp.length() - 2);\n            data.put(\"EXPDATE\", expDate);\n        }\n\n        // gather the address info\n        if (ps != null) {\n            String street = ps.getString(\"address1\") +\n                (ps.get(\"address2\") != null && ps.getString(\"address2\").length() > 0 ? \" \" +\n                    ps.getString(\"address2\") : \"\");\n\n            data.put(\"STREET\", street);\n            data.put(\"ZIP\", ps.getString(\"postalCode\"));\n        }\n\n        PFProAPI pn = init(configString);\n\n        // get the base params\n        StringBuffer params = makeBaseParams(configString);\n\n        // parse the context parameters\n        params.append(\"&\").append(parseContext(data));\n\n        // transmit the request\n        if (Debug.verboseOn()) Debug.logVerbose(\"Sending to Verisign: \" + params.toString(), module);\n        String resp;\n        if (!UtilProperties.propertyValueEqualsIgnoreCase(configString, \"payment.verisign.enable_transmit\", \"false\")) {\n            resp = pn.SubmitTransaction(params.toString());\n        } else {\n            resp = \"RESULT=0&AUTHCODE=T&PNREF=\" + (new Date()).getTime() + \"&RESPMSG=Testing\";\n        } \n\n        if (Debug.verboseOn()) Debug.logVerbose(\"Response from Verisign: \" + resp, module);\n\n        // reset for next use\n        pn.DestroyContext();\n\n        // check the response\n        Map result = ServiceUtil.returnSuccess();\n        parseAuthResponse(resp, result, configString, isReAuth);\n        result.put(\"processAmount\", processAmount);\n        return result;\n    }","commit_id":"0ebc65febce139454f55e34f52b69906263ee127","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map ccVoid(DispatchContext dctx, Map context) {\n        GenericValue paymentPref = (GenericValue) context.get(\"orderPaymentPreference\");\n        GenericValue authTrans = (GenericValue) context.get(\"authTrans\");\n        Double amount = (Double) context.get(\"releaseAmount\");\n        String configString = (String) context.get(\"paymentConfig\");\n        if (configString == null) {\n            configString = \"payment.properties\";\n        }\n\n        if (authTrans == null){\n            authTrans = PaymentGatewayServices.getAuthTransaction(paymentPref);\n        }\n\n        if (authTrans == null) {\n            return ServiceUtil.returnError(\"No authorization transaction found for the OrderPaymentPreference; cannot capture\");\n        }\n\n        // auth ref number\n        String refNum = authTrans.getString(\"referenceNum\");\n        Map data = UtilMisc.toMap(\"ORIGID\", refNum);\n\n        // tx type (Void)\n        data.put(\"TRXTYPE\", \"V\");\n\n        // credit card tender\n        data.put(\"TENDER\", \"C\");\n\n        // get the orderID\n        String orderId = paymentPref.getString(\"orderId\");\n        data.put(\"COMMENT1\", orderId);\n\n        // amount to capture\n        data.put(\"AMT\", amount.toString());\n\n        PFProAPI pn = init(configString);\n\n        // get the base params\n        StringBuffer params = makeBaseParams(configString);\n\n        // parse the context parameters\n        params.append(\"&\").append(parseContext(data));\n\n        // transmit the request\n        if (Debug.verboseOn()) Debug.logVerbose(\"Sending to Verisign: \" + params.toString(), module);\n        String resp;\n        if (UtilProperties.propertyValueEqualsIgnoreCase(configString, \"payment.verisign.enable_transmit\", \"true\")) {\n            resp = pn.SubmitTransaction(params.toString());\n        } else {\n            resp = \"RESULT=0&AUTHCODE=T&PNREF=\" + (new Date()).getTime() + \"&RESPMSG=Testing\";\n        }\n\n        if (Debug.verboseOn()) Debug.logVerbose(\"Response from Verisign: \" + resp, module);\n\n        // reset for next use\n        pn.DestroyContext();\n\n        // check the response\n        Map result = ServiceUtil.returnSuccess();\n        parseVoidResponse(resp, result);\n        result.put(\"releaseAmount\", amount);\n        return result;\n    }","id":49789,"modified_method":"public static Map ccVoid(DispatchContext dctx, Map context) {\n        GenericValue paymentPref = (GenericValue) context.get(\"orderPaymentPreference\");\n        GenericValue authTrans = (GenericValue) context.get(\"authTrans\");\n        Double amount = (Double) context.get(\"releaseAmount\");\n        String configString = (String) context.get(\"paymentConfig\");\n        if (configString == null) {\n            configString = \"payment.properties\";\n        }\n\n        if (authTrans == null){\n            authTrans = PaymentGatewayServices.getAuthTransaction(paymentPref);\n        }\n\n        if (authTrans == null) {\n            return ServiceUtil.returnError(\"No authorization transaction found for the OrderPaymentPreference; cannot capture\");\n        }\n\n        // auth ref number\n        String refNum = authTrans.getString(\"referenceNum\");\n        Map data = UtilMisc.toMap(\"ORIGID\", refNum);\n\n        // tx type (Void)\n        data.put(\"TRXTYPE\", \"V\");\n\n        // credit card tender\n        data.put(\"TENDER\", \"C\");\n\n        // get the orderID\n        String orderId = paymentPref.getString(\"orderId\");\n        data.put(\"COMMENT1\", orderId);\n\n        // amount to capture\n        data.put(\"AMT\", amount.toString());\n\n        PFProAPI pn = init(configString);\n\n        // get the base params\n        StringBuffer params = makeBaseParams(configString);\n\n        // parse the context parameters\n        params.append(\"&\").append(parseContext(data));\n\n        // transmit the request\n        if (Debug.verboseOn()) Debug.logVerbose(\"Sending to Verisign: \" + params.toString(), module);\n        String resp;\n        if (!UtilProperties.propertyValueEqualsIgnoreCase(configString, \"payment.verisign.enable_transmit\", \"false\")) {\n            resp = pn.SubmitTransaction(params.toString());\n        } else {\n            resp = \"RESULT=0&AUTHCODE=T&PNREF=\" + (new Date()).getTime() + \"&RESPMSG=Testing\";\n        }\n\n        if (Debug.verboseOn()) Debug.logVerbose(\"Response from Verisign: \" + resp, module);\n\n        // reset for next use\n        pn.DestroyContext();\n\n        // check the response\n        Map result = ServiceUtil.returnSuccess();\n        parseVoidResponse(resp, result);\n        result.put(\"releaseAmount\", amount);\n        return result;\n    }","commit_id":"0ebc65febce139454f55e34f52b69906263ee127","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map ccCapture(DispatchContext dctx, Map context) {\n        GenericValue paymentPref = (GenericValue) context.get(\"orderPaymentPreference\");\n        GenericValue authTrans = (GenericValue) context.get(\"authTrans\");\n        Double amount = (Double) context.get(\"captureAmount\");\n        String configString = (String) context.get(\"paymentConfig\");\n        if (configString == null) {\n            configString = \"payment.properties\";\n        }\n\n        if (authTrans == null){\n            authTrans = PaymentGatewayServices.getAuthTransaction(paymentPref);\n        }\n\n        if (authTrans == null) {\n            return ServiceUtil.returnError(\"No authorization transaction found for the OrderPaymentPreference; cannot capture\");\n        }\n\n        // auth ref number\n        String refNum = authTrans.getString(\"referenceNum\");\n        Map data = UtilMisc.toMap(\"ORIGID\", refNum);\n\n        // tx type (Delayed Capture)\n        data.put(\"TRXTYPE\", \"D\");\n\n        // credit card tender\n        data.put(\"TENDER\", \"C\");\n\n        // get the orderID\n        String orderId = paymentPref.getString(\"orderId\");\n        data.put(\"COMMENT1\", orderId);\n\n        // amount to capture\n        data.put(\"AMT\", amount.toString());\n\n        PFProAPI pn = init(configString);\n\n        // get the base params\n        StringBuffer params = makeBaseParams(configString);\n\n        // parse the context parameters\n        params.append(\"&\").append(parseContext(data));\n\n        // transmit the request\n        if (Debug.verboseOn()) Debug.logVerbose(\"Sending to Verisign: \" + params.toString(), module);\n        String resp;\n        if (UtilProperties.propertyValueEqualsIgnoreCase(configString, \"payment.verisign.enable_transmit\", \"true\")) {\n            resp = pn.SubmitTransaction(params.toString());\n        } else {\n            resp = \"RESULT=0&AUTHCODE=T&PNREF=\" + (new Date()).getTime() + \"&RESPMSG=Testing\";\n        }\n\n        if (Debug.verboseOn()) Debug.logVerbose(\"Response from Verisign: \" + resp, module);\n\n        // reset for next use\n        pn.DestroyContext();\n\n        // check the response\n        Map result = ServiceUtil.returnSuccess();\n        parseCaptureResponse(resp, result);\n        result.put(\"captureAmount\", amount);\n        return result;\n    }","id":49790,"modified_method":"public static Map ccCapture(DispatchContext dctx, Map context) {\n        GenericValue paymentPref = (GenericValue) context.get(\"orderPaymentPreference\");\n        GenericValue authTrans = (GenericValue) context.get(\"authTrans\");\n        Double amount = (Double) context.get(\"captureAmount\");\n        String configString = (String) context.get(\"paymentConfig\");\n        if (configString == null) {\n            configString = \"payment.properties\";\n        }\n\n        if (authTrans == null){\n            authTrans = PaymentGatewayServices.getAuthTransaction(paymentPref);\n        }\n\n        if (authTrans == null) {\n            return ServiceUtil.returnError(\"No authorization transaction found for the OrderPaymentPreference; cannot capture\");\n        }\n\n        // auth ref number\n        String refNum = authTrans.getString(\"referenceNum\");\n        Map data = UtilMisc.toMap(\"ORIGID\", refNum);\n\n        // tx type (Delayed Capture)\n        data.put(\"TRXTYPE\", \"D\");\n\n        // credit card tender\n        data.put(\"TENDER\", \"C\");\n\n        // get the orderID\n        String orderId = paymentPref.getString(\"orderId\");\n        data.put(\"COMMENT1\", orderId);\n\n        // amount to capture\n        data.put(\"AMT\", amount.toString());\n\n        PFProAPI pn = init(configString);\n\n        // get the base params\n        StringBuffer params = makeBaseParams(configString);\n\n        // parse the context parameters\n        params.append(\"&\").append(parseContext(data));\n\n        // transmit the request\n        if (Debug.verboseOn()) Debug.logVerbose(\"Sending to Verisign: \" + params.toString(), module);\n        String resp;\n        if (!UtilProperties.propertyValueEqualsIgnoreCase(configString, \"payment.verisign.enable_transmit\", \"false\")) {\n            resp = pn.SubmitTransaction(params.toString());\n        } else {\n            resp = \"RESULT=0&AUTHCODE=T&PNREF=\" + (new Date()).getTime() + \"&RESPMSG=Testing\";\n        }\n\n        if (Debug.verboseOn()) Debug.logVerbose(\"Response from Verisign: \" + resp, module);\n\n        // reset for next use\n        pn.DestroyContext();\n\n        // check the response\n        Map result = ServiceUtil.returnSuccess();\n        parseCaptureResponse(resp, result);\n        result.put(\"captureAmount\", amount);\n        return result;\n    }","commit_id":"0ebc65febce139454f55e34f52b69906263ee127","url":"https://github.com/apache/ofbiz"},{"original_method":"public static Map ccRefund(DispatchContext dctx, Map context) {\n        GenericValue paymentPref = (GenericValue) context.get(\"orderPaymentPreference\");\n        Double amount = (Double) context.get(\"refundAmount\");\n        String configString = (String) context.get(\"paymentConfig\");\n        if (configString == null) {\n            configString = \"payment.properties\";\n        }\n\n        GenericValue captureTrans = PaymentGatewayServices.getCaptureTransaction(paymentPref);\n\n\n        if (captureTrans == null) {\n            return ServiceUtil.returnError(\"No capture transaction found for the OrderPaymentPreference; cannot refund\");\n        }\n\n        // auth ref number\n        String refNum = captureTrans.getString(\"referenceNum\");\n        Map data = UtilMisc.toMap(\"ORIGID\", refNum);\n\n        // tx type (Credit)\n        data.put(\"TRXTYPE\", \"C\");\n\n        // credit card tender\n        data.put(\"TENDER\", \"C\");\n\n        // get the orderID\n        String orderId = paymentPref.getString(\"orderId\");\n        data.put(\"COMMENT1\", orderId);\n\n        // amount to capture\n        data.put(\"AMT\", amount.toString());\n\n        PFProAPI pn = init(configString);\n\n        // get the base params\n        StringBuffer params = makeBaseParams(configString);\n\n        // parse the context parameters\n        params.append(\"&\").append(parseContext(data));\n\n        // transmit the request\n        if (Debug.verboseOn()) Debug.logVerbose(\"Sending to Verisign: \" + params.toString(), module);\n        String resp;\n        if (UtilProperties.propertyValueEqualsIgnoreCase(configString, \"payment.verisign.enable_transmit\", \"true\")) {\n            resp = pn.SubmitTransaction(params.toString());\n        } else {\n            resp = \"RESULT=0&AUTHCODE=T&PNREF=\" + (new Date()).getTime() + \"&RESPMSG=Testing\";\n        } \n\n        if (Debug.verboseOn()) Debug.logVerbose(\"Response from Verisign: \" + resp, module);\n\n        // reset for next use\n        pn.DestroyContext();\n\n        // check the response\n        Map result = ServiceUtil.returnSuccess();\n        parseRefundResponse(resp, result);\n        result.put(\"refundAmount\", amount);\n        return result;\n    }","id":49791,"modified_method":"public static Map ccRefund(DispatchContext dctx, Map context) {\n        GenericValue paymentPref = (GenericValue) context.get(\"orderPaymentPreference\");\n        Double amount = (Double) context.get(\"refundAmount\");\n        String configString = (String) context.get(\"paymentConfig\");\n        if (configString == null) {\n            configString = \"payment.properties\";\n        }\n\n        GenericValue captureTrans = PaymentGatewayServices.getCaptureTransaction(paymentPref);\n\n\n        if (captureTrans == null) {\n            return ServiceUtil.returnError(\"No capture transaction found for the OrderPaymentPreference; cannot refund\");\n        }\n\n        // auth ref number\n        String refNum = captureTrans.getString(\"referenceNum\");\n        Map data = UtilMisc.toMap(\"ORIGID\", refNum);\n\n        // tx type (Credit)\n        data.put(\"TRXTYPE\", \"C\");\n\n        // credit card tender\n        data.put(\"TENDER\", \"C\");\n\n        // get the orderID\n        String orderId = paymentPref.getString(\"orderId\");\n        data.put(\"COMMENT1\", orderId);\n\n        // amount to capture\n        data.put(\"AMT\", amount.toString());\n\n        PFProAPI pn = init(configString);\n\n        // get the base params\n        StringBuffer params = makeBaseParams(configString);\n\n        // parse the context parameters\n        params.append(\"&\").append(parseContext(data));\n\n        // transmit the request\n        if (Debug.verboseOn()) Debug.logVerbose(\"Sending to Verisign: \" + params.toString(), module);\n        String resp;\n        if (!UtilProperties.propertyValueEqualsIgnoreCase(configString, \"payment.verisign.enable_transmit\", \"false\")) {\n            resp = pn.SubmitTransaction(params.toString());\n        } else {\n            resp = \"RESULT=0&AUTHCODE=T&PNREF=\" + (new Date()).getTime() + \"&RESPMSG=Testing\";\n        } \n\n        if (Debug.verboseOn()) Debug.logVerbose(\"Response from Verisign: \" + resp, module);\n\n        // reset for next use\n        pn.DestroyContext();\n\n        // check the response\n        Map result = ServiceUtil.returnSuccess();\n        parseRefundResponse(resp, result);\n        result.put(\"refundAmount\", amount);\n        return result;\n    }","commit_id":"0ebc65febce139454f55e34f52b69906263ee127","url":"https://github.com/apache/ofbiz"},{"original_method":"@Override\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        validator.validate(operation);\n        String jndiName = operation.require(CommonAttributes.JNDI_BINDING).asString();\n        final ModelNode entries = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS).getModel().get(CommonAttributes.ENTRIES.getName());\n        for (ModelNode entry : entries.asList()) {\n            if (jndiName.equals(entry.asString())) {\n                throw new OperationFailedException(new ModelNode().set(String.format(\"JNDI name %s is already registered\", jndiName)));\n            }\n        }\n        entries.add(jndiName);\n\n\n        if (context.getType() == OperationContext.Type.SERVER) {\n            context.addStep(new OperationStepHandler() {\n                @Override\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n                    ServiceController<?> hqService = context.getServiceRegistry(false).getService(MessagingServices.JBOSS_MESSAGING);\n                    if (hqService != null) {\n                        HornetQServer hqServer = HornetQServer.class.cast(hqService.getValue());\n                        String resourceName = PathAddress.pathAddress(operation.require(ModelDescriptionConstants.OP_ADDR)).getLastElement().getValue();\n                        String jndiName = operation.require(CommonAttributes.JNDI_BINDING).asString();\n                        addJndiNameToControl(jndiName, resourceName, hqServer, context);\n                    } // else the subsystem isn't started yet\n\n                    if (!context.hasFailureDescription()) {\n                        context.getResult();\n                    }\n                    context.completeStep();\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        context.completeStep();\n    }","id":49792,"modified_method":"@Override\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        validator.validate(operation);\n        String jndiName = operation.require(CommonAttributes.JNDI_BINDING).asString();\n        final ModelNode entries = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS).getModel().get(CommonAttributes.ENTRIES.getName());\n        for (ModelNode entry : entries.asList()) {\n            if (jndiName.equals(entry.asString())) {\n                throw new OperationFailedException(new ModelNode().set(String.format(\"JNDI name %s is already registered\", jndiName)));\n            }\n        }\n        entries.add(jndiName);\n\n\n        if (context.getType() == OperationContext.Type.SERVER) {\n            context.addStep(new OperationStepHandler() {\n                @Override\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n                    ServiceController<?> hqService = context.getServiceRegistry(false).getService(MessagingServices.JBOSS_MESSAGING);\n                    if (hqService != null) {\n                        HornetQServer hqServer = HornetQServer.class.cast(hqService.getValue());\n                        String resourceName = PathAddress.pathAddress(operation.require(ModelDescriptionConstants.OP_ADDR)).getLastElement().getValue();\n                        String jndiName = operation.require(CommonAttributes.JNDI_BINDING).asString();\n                        addJndiNameToControl(jndiName, resourceName, hqServer, context);\n                    } // else the subsystem isn't started yet\n\n                    if (!context.hasFailureDescription()) {\n                        context.getResult();\n                    }\n\n                    if (context.completeStep() != OperationContext.ResultAction.KEEP) {\n                        // TODO is it possible to revert?\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        context.completeStep();\n    }","commit_id":"4ebe5babbb9fc06070a040cad2ae96dde3a5500c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void executeRuntimeStep(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        final String operationName = operation.require(OP).asString();\n\n        if (READ_ATTRIBUTE_OPERATION.equals(operationName)) {\n            readAttributeValidator.validate(operation);\n            final String name = operation.require(NAME).asString();\n            if (STARTED.equals(name)) {\n                HornetQComponentControl control = getHornetQComponentControl(context, operation, false);\n                context.getResult().set(control.isStarted());\n            } else {\n                handleReadAttribute(name, context, operation);\n            }\n        } else if (START.equals(operationName)) {\n            HornetQComponentControl control = getHornetQComponentControl(context, operation, true);\n            try {\n                control.start();\n                context.getResult();\n            } catch (Exception e) {\n                context.getFailureDescription().set(e.toString());\n            }\n\n        } else if (STOP.equals(operationName)) {\n            HornetQComponentControl control = getHornetQComponentControl(context, operation, true);\n            try {\n                control.stop();\n                context.getResult();\n            } catch (Exception e) {\n                context.getFailureDescription().set(e.toString());\n            }\n        } else {\n            throw new IllegalStateException(String.format(\"Unknown operation %s\", operationName));\n        }\n\n        context.completeStep();\n    }","id":49793,"modified_method":"@Override\n    protected void executeRuntimeStep(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        final String operationName = operation.require(OP).asString();\n\n        HornetQComponentControl control = null;\n        boolean appliedToRuntime = false;\n        Object handback = null;\n        if (READ_ATTRIBUTE_OPERATION.equals(operationName)) {\n            readAttributeValidator.validate(operation);\n            final String name = operation.require(NAME).asString();\n            if (STARTED.equals(name)) {\n                control = getHornetQComponentControl(context, operation, false);\n                context.getResult().set(control.isStarted());\n            } else {\n                handleReadAttribute(name, context, operation);\n            }\n        } else if (START.equals(operationName)) {\n            control = getHornetQComponentControl(context, operation, true);\n            try {\n                control.start();\n                appliedToRuntime = true;\n                context.getResult();\n            } catch (Exception e) {\n                context.getFailureDescription().set(e.toString());\n            }\n\n        } else if (STOP.equals(operationName)) {\n            control = getHornetQComponentControl(context, operation, true);\n            try {\n                control.stop();\n                appliedToRuntime = true;\n                context.getResult();\n            } catch (Exception e) {\n                context.getFailureDescription().set(e.toString());\n            }\n        } else {\n            handback = handleOperation(operationName, context, operation);\n            appliedToRuntime = handback != null;\n        }\n\n        if (context.completeStep() != OperationContext.ResultAction.KEEP && appliedToRuntime) {\n            try {\n                if (START.equals(operationName)) {\n                    control.stop();\n                } else if (STOP.equals(operationName)) {\n                    control.start();\n                } else {\n                    handleRevertOperation(operationName, context, operation, handback);\n                }\n            } catch (Exception e) {\n                log.errorf(e, String.format(\"%s caught exception attempting to revert operation %s at address %s\",\n                        getClass().getSimpleName(),\n                        operation.require(ModelDescriptionConstants.OP).asString(),\n                        PathAddress.pathAddress(operation.require(ModelDescriptionConstants.OP_ADDR))));\n            }\n        }\n    }","commit_id":"4ebe5babbb9fc06070a040cad2ae96dde3a5500c","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Hook to allow subclasses to handle operations other than {@code read-attribute}, {@code start} and\n     * {@code stop}. Implementations must not call {@link org.jboss.as.controller.OperationContext#completeStep()}.\n     * <p>\n     * This default implementation just throws the exception returned by {@link #unsupportedOperation(String)}.\n     * <\/p>\n     *\n     *\n     * @param operationName the name of the operation\n     * @param context the operation context\n     * @param operation the operation\n     * @throws OperationFailedException\n     */\n    protected void handleOperation(String operationName, OperationContext context, ModelNode operation) throws OperationFailedException {\n        unsupportedOperation(operationName);\n    }","id":49794,"modified_method":"/**\n     * Hook to allow subclasses to handle operations other than {@code read-attribute}, {@code start} and\n     * {@code stop}. Implementations must not call {@link org.jboss.as.controller.OperationContext#completeStep()}.\n     * <p>\n     * This default implementation just throws the exception returned by {@link #unsupportedOperation(String)}.\n     * <\/p>\n     *\n     *\n     * @param operationName the name of the operation\n     * @param context the operation context\n     * @param operation the operation\n     *\n     * @return an object that can be passed back in {@link #handleRevertOperation(String, org.jboss.as.controller.OperationContext, org.jboss.dmr.ModelNode, Object)}\n     *         if the operation should be reverted. A value of {@code null} is an indication that no reversible\n     *         modification was made\n     * @throws OperationFailedException\n     */\n    protected Object handleOperation(String operationName, OperationContext context, ModelNode operation) throws OperationFailedException {\n        unsupportedOperation(operationName);\n        throw new IllegalStateException(\"unreachable statement\");\n    }","commit_id":"4ebe5babbb9fc06070a040cad2ae96dde3a5500c","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Return an ISE with a message saying support for the attribute was not properly implemented. This handler should\n     * only be called if for a \"read-attribute\" operation if {@link #register(org.jboss.as.controller.registry.ManagementResourceRegistration)}\n     * registers the attribute, so a handler then not recognizing the attribute name would be a bug and this method\n     * returns an exception highlighting that bug.\n     *\n     * @param attributeName the name of the attribute\n     * @throws IllegalStateException an exception with a message indicating a bug in this handler\n     */\n    protected void unsupportedAttribute(final String attributeName) {\n        // Bug\n        throw new IllegalStateException(String.format(\"Read support for attribute %s was not properly implemented\", attributeName));\n    }","id":49795,"modified_method":"/**\n     * Return an ISE with a message saying support for the attribute was not properly implemented. This handler should\n     * only be called if for a \"read-attribute\" operation if {@link #register(org.jboss.as.controller.registry.ManagementResourceRegistration)}\n     * registers the attribute, so a handler then not recognizing the attribute name would be a bug and this method\n     * returns an exception highlighting that bug.\n     *\n     * @param attributeName the name of the attribute\n     * @throws IllegalStateException an exception with a message indicating a bug in this handler\n     */\n    protected final void unsupportedAttribute(final String attributeName) {\n        // Bug\n        throw new IllegalStateException(String.format(\"Read support for attribute %s was not properly implemented\", attributeName));\n    }","commit_id":"4ebe5babbb9fc06070a040cad2ae96dde3a5500c","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected abstract void handleAdditonalOperation(final String operationName, final ModelNode operation,\n                                                     final OperationContext context, T queueControl) throws OperationFailedException;","id":49796,"modified_method":"protected abstract Object handleAdditonalOperation(final String operationName, final ModelNode operation,\n                                                     final OperationContext context, T queueControl) throws OperationFailedException;","commit_id":"4ebe5babbb9fc06070a040cad2ae96dde3a5500c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void executeRuntimeStep(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        final String operationName = operation.require(ModelDescriptionConstants.OP).asString();\n        final String queueName = PathAddress.pathAddress(operation.require(ModelDescriptionConstants.OP_ADDR)).getLastElement().getValue();\n        ServiceController<?> hqService = context.getServiceRegistry(false).getService(MessagingServices.JBOSS_MESSAGING);\n        HornetQServer hqServer = HornetQServer.class.cast(hqService.getValue());\n        DelegatingQueueControl<T> control = getQueueControl(hqServer, queueName);\n\n        try {\n            if (LIST_MESSAGES.equals(operationName)) {\n                singleOptionalFilterValidator.validate(operation);\n                String filter = operation.hasDefined(FILTER.getName()) ? operation.get(FILTER.getName()).asString() : null;\n                String json = control.listMessagesAsJSON(filter);\n                context.getResult().set(ModelNode.fromJSONString(json));\n            } else if (LIST_MESSAGES_AS_JSON.equals(operationName)) {\n                singleOptionalFilterValidator.validate(operation);\n                String filter = operation.hasDefined(FILTER.getName()) ? operation.get(FILTER.getName()).asString() : null;\n                context.getResult().set(control.listMessagesAsJSON(filter));\n            } else if (COUNT_MESSAGES.equals(operationName)) {\n                singleOptionalFilterValidator.validate(operation);\n                String filter = operation.hasDefined(FILTER.getName()) ? operation.get(FILTER.getName()).asString() : null;\n                context.getResult().set(control.countMessages(filter));\n            } else if (REMOVE_MESSAGE.equals(operationName)) {\n                singleMessageIdValidator.validate(operation);\n                ModelNode id = operation.require(MESSAGE_ID);\n                context.getResult().set(control.removeMessage(id));\n            } else if (REMOVE_MESSAGES.equals(operationName)) {\n                singleOptionalFilterValidator.validate(operation);\n                String filter = operation.hasDefined(FILTER.getName()) ? operation.get(FILTER.getName()).asString() : null;\n                context.getResult().set(control.removeMessages(filter));\n            } else if (EXPIRE_MESSAGES.equals(operationName)) {\n                singleOptionalFilterValidator.validate(operation);\n                String filter = operation.hasDefined(FILTER.getName()) ? operation.get(FILTER.getName()).asString() : null;\n                context.getResult().set(control.expireMessages(filter));\n            } else if (EXPIRE_MESSAGE.equals(operationName)) {\n                singleMessageIdValidator.validate(operation);\n                ModelNode id = operation.require(MESSAGE_ID);\n                context.getResult().set(control.expireMessage(id));\n            } else if (SEND_MESSAGE_TO_DEAD_LETTER_ADDRESS.equals(operationName)) {\n                singleMessageIdValidator.validate(operation);\n                ModelNode id = operation.require(MESSAGE_ID);\n                context.getResult().set(control.sendMessageToDeadLetterAddress(id));\n            } else if (SEND_MESSAGES_TO_DEAD_LETTER_ADDRESS.equals(operationName)) {\n                singleOptionalFilterValidator.validate(operation);\n                String filter = operation.hasDefined(FILTER.getName()) ? operation.get(FILTER.getName()).asString() : null;\n                context.getResult().set(control.sendMessagesToDeadLetterAddress(filter));\n            } else if (CHANGE_MESSAGE_PRIORITY.equals(operationName)) {\n                changeMessagePriorityValidator.validate(operation);\n                ModelNode id = operation.require(MESSAGE_ID);\n                int priority = operation.require(NEW_PRIORITY).asInt();\n                context.getResult().set(control.changeMessagePriority(id, priority));\n            } else if (CHANGE_MESSAGES_PRIORITY.equals(operationName)) {\n                changeMessagesPriorityValidator.validate(operation);\n                String filter = operation.hasDefined(FILTER.getName()) ? operation.get(FILTER.getName()).asString() : null;\n                int priority = operation.require(NEW_PRIORITY).asInt();\n                context.getResult().set(control.changeMessagesPriority(filter, priority));\n            } else if (MOVE_MESSAGE.equals(operationName)) {\n                moveMessageValidator.validate(operation);\n                ModelNode id = operation.require(MESSAGE_ID);\n                String otherQueue = operation.require(OTHER_QUEUE_NAME).asString();\n                if (operation.hasDefined(REJECT_DUPLICATES)) {\n                    boolean reject = operation.get(REJECT_DUPLICATES).asBoolean();\n                    context.getResult().set(control.moveMessage(id, otherQueue, reject));\n                } else {\n                    context.getResult().set(control.moveMessage(id, otherQueue));\n                }\n            } else if (MOVE_MESSAGES.equals(operationName)) {\n                moveMessagesValidator.validate(operation);\n                String filter = operation.hasDefined(FILTER.getName()) ? operation.get(FILTER.getName()).asString() : null;\n                String otherQueue = operation.require(OTHER_QUEUE_NAME).asString();\n                if (operation.hasDefined(REJECT_DUPLICATES)) {\n                    boolean reject = operation.get(REJECT_DUPLICATES).asBoolean();\n                    context.getResult().set(control.moveMessages(filter, otherQueue, reject));\n                } else {\n                    context.getResult().set(control.moveMessages(filter, otherQueue));\n                }\n            } else if (LIST_MESSAGE_COUNTER_AS_JSON.equals(operationName)) {\n                context.getResult().set(control.listMessageCounter());\n            } else if (LIST_MESSAGE_COUNTER_AS_HTML.equals(operationName)) {\n                context.getResult().set(control.listMessageCounterAsHTML());\n            } else if (LIST_MESSAGE_COUNTER_HISTORY_AS_JSON.equals(operationName)) {\n                context.getResult().set(control.listMessageCounterHistory());\n            } else if (LIST_MESSAGE_COUNTER_HISTORY_AS_HTML.equals(operationName)) {\n                context.getResult().set(control.listMessageCounterHistoryAsHTML());\n            } else if (RESET_MESSAGE_COUNTER.equals(operationName)) {\n                control.resetMessageCounter();\n                context.getResult(); // undefined\n            } else if (PAUSE.equals(operationName)) {\n                control.pause();\n                context.getResult(); // undefined\n            } else if (RESUME.equals(operationName)) {\n                control.resume();\n                context.getResult(); // undefined\n            } else if (LIST_CONSUMERS_AS_JSON.equals(operationName)) {\n                context.getResult().set(control.listConsumersAsJSON());\n            } else {\n                // TODO LIST_MESSAGE_COUNTER, LIST_MESSAGE_COUNTER_HISTORY, LIST_CONSUMERS\n                handleAdditonalOperation(operationName, operation, context, control.getDelegate());\n            }\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            context.getFailureDescription().set(e.toString());\n        }\n\n        context.completeStep();\n    }","id":49797,"modified_method":"@Override\n    protected void executeRuntimeStep(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        final String operationName = operation.require(ModelDescriptionConstants.OP).asString();\n        final String queueName = PathAddress.pathAddress(operation.require(ModelDescriptionConstants.OP_ADDR)).getLastElement().getValue();\n        ServiceController<?> hqService = context.getServiceRegistry(false).getService(MessagingServices.JBOSS_MESSAGING);\n        HornetQServer hqServer = HornetQServer.class.cast(hqService.getValue());\n        DelegatingQueueControl<T> control = getQueueControl(hqServer, queueName);\n\n        boolean reversible = false;\n        Object handback = null;\n        try {\n            if (LIST_MESSAGES.equals(operationName)) {\n                singleOptionalFilterValidator.validate(operation);\n                String filter = operation.hasDefined(FILTER.getName()) ? operation.get(FILTER.getName()).asString() : null;\n                String json = control.listMessagesAsJSON(filter);\n                context.getResult().set(ModelNode.fromJSONString(json));\n            } else if (LIST_MESSAGES_AS_JSON.equals(operationName)) {\n                singleOptionalFilterValidator.validate(operation);\n                String filter = operation.hasDefined(FILTER.getName()) ? operation.get(FILTER.getName()).asString() : null;\n                context.getResult().set(control.listMessagesAsJSON(filter));\n            } else if (COUNT_MESSAGES.equals(operationName)) {\n                singleOptionalFilterValidator.validate(operation);\n                String filter = operation.hasDefined(FILTER.getName()) ? operation.get(FILTER.getName()).asString() : null;\n                context.getResult().set(control.countMessages(filter));\n            } else if (REMOVE_MESSAGE.equals(operationName)) {\n                singleMessageIdValidator.validate(operation);\n                ModelNode id = operation.require(MESSAGE_ID);\n                context.getResult().set(control.removeMessage(id));\n            } else if (REMOVE_MESSAGES.equals(operationName)) {\n                singleOptionalFilterValidator.validate(operation);\n                String filter = operation.hasDefined(FILTER.getName()) ? operation.get(FILTER.getName()).asString() : null;\n                context.getResult().set(control.removeMessages(filter));\n            } else if (EXPIRE_MESSAGES.equals(operationName)) {\n                singleOptionalFilterValidator.validate(operation);\n                String filter = operation.hasDefined(FILTER.getName()) ? operation.get(FILTER.getName()).asString() : null;\n                context.getResult().set(control.expireMessages(filter));\n            } else if (EXPIRE_MESSAGE.equals(operationName)) {\n                singleMessageIdValidator.validate(operation);\n                ModelNode id = operation.require(MESSAGE_ID);\n                context.getResult().set(control.expireMessage(id));\n            } else if (SEND_MESSAGE_TO_DEAD_LETTER_ADDRESS.equals(operationName)) {\n                singleMessageIdValidator.validate(operation);\n                ModelNode id = operation.require(MESSAGE_ID);\n                context.getResult().set(control.sendMessageToDeadLetterAddress(id));\n            } else if (SEND_MESSAGES_TO_DEAD_LETTER_ADDRESS.equals(operationName)) {\n                singleOptionalFilterValidator.validate(operation);\n                String filter = operation.hasDefined(FILTER.getName()) ? operation.get(FILTER.getName()).asString() : null;\n                context.getResult().set(control.sendMessagesToDeadLetterAddress(filter));\n            } else if (CHANGE_MESSAGE_PRIORITY.equals(operationName)) {\n                changeMessagePriorityValidator.validate(operation);\n                ModelNode id = operation.require(MESSAGE_ID);\n                int priority = operation.require(NEW_PRIORITY).asInt();\n                context.getResult().set(control.changeMessagePriority(id, priority));\n            } else if (CHANGE_MESSAGES_PRIORITY.equals(operationName)) {\n                changeMessagesPriorityValidator.validate(operation);\n                String filter = operation.hasDefined(FILTER.getName()) ? operation.get(FILTER.getName()).asString() : null;\n                int priority = operation.require(NEW_PRIORITY).asInt();\n                context.getResult().set(control.changeMessagesPriority(filter, priority));\n            } else if (MOVE_MESSAGE.equals(operationName)) {\n                moveMessageValidator.validate(operation);\n                ModelNode id = operation.require(MESSAGE_ID);\n                String otherQueue = operation.require(OTHER_QUEUE_NAME).asString();\n                if (operation.hasDefined(REJECT_DUPLICATES)) {\n                    boolean reject = operation.get(REJECT_DUPLICATES).asBoolean();\n                    context.getResult().set(control.moveMessage(id, otherQueue, reject));\n                } else {\n                    context.getResult().set(control.moveMessage(id, otherQueue));\n                }\n            } else if (MOVE_MESSAGES.equals(operationName)) {\n                moveMessagesValidator.validate(operation);\n                String filter = operation.hasDefined(FILTER.getName()) ? operation.get(FILTER.getName()).asString() : null;\n                String otherQueue = operation.require(OTHER_QUEUE_NAME).asString();\n                if (operation.hasDefined(REJECT_DUPLICATES)) {\n                    boolean reject = operation.get(REJECT_DUPLICATES).asBoolean();\n                    context.getResult().set(control.moveMessages(filter, otherQueue, reject));\n                } else {\n                    context.getResult().set(control.moveMessages(filter, otherQueue));\n                }\n            } else if (LIST_MESSAGE_COUNTER_AS_JSON.equals(operationName)) {\n                context.getResult().set(control.listMessageCounter());\n            } else if (LIST_MESSAGE_COUNTER_AS_HTML.equals(operationName)) {\n                context.getResult().set(control.listMessageCounterAsHTML());\n            } else if (LIST_MESSAGE_COUNTER_HISTORY_AS_JSON.equals(operationName)) {\n                context.getResult().set(control.listMessageCounterHistory());\n            } else if (LIST_MESSAGE_COUNTER_HISTORY_AS_HTML.equals(operationName)) {\n                context.getResult().set(control.listMessageCounterHistoryAsHTML());\n            } else if (RESET_MESSAGE_COUNTER.equals(operationName)) {\n                control.resetMessageCounter();\n                context.getResult(); // undefined\n            } else if (PAUSE.equals(operationName)) {\n                control.pause();\n                reversible = true;\n                context.getResult(); // undefined\n            } else if (RESUME.equals(operationName)) {\n                control.resume();\n                reversible = true;\n                context.getResult(); // undefined\n            } else if (LIST_CONSUMERS_AS_JSON.equals(operationName)) {\n                context.getResult().set(control.listConsumersAsJSON());\n            } else {\n                // TODO LIST_MESSAGE_COUNTER, LIST_MESSAGE_COUNTER_HISTORY, LIST_CONSUMERS\n                handback = handleAdditonalOperation(operationName, operation, context, control.getDelegate());\n                reversible = handback == null;\n            }\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            context.getFailureDescription().set(e.toString());\n        }\n\n        if (context.completeStep() != OperationContext.ResultAction.KEEP && reversible) {\n            try {\n                if (PAUSE.equals(operationName)) {\n                    control.resume();\n                } else if (RESUME.equals(operationName)) {\n                    control.pause();\n                } else {\n                    revertAdditonalOperation(operationName, operation, context, control.getDelegate(), handback);\n                }\n            } catch (Exception e) {\n                log.errorf(e, String.format(\"%s caught exception attempting to revert operation %s at address %s\",\n                        getClass().getSimpleName(),\n                        operation.require(ModelDescriptionConstants.OP).asString(),\n                        PathAddress.pathAddress(operation.require(ModelDescriptionConstants.OP_ADDR))));\n            }\n        }\n    }","commit_id":"4ebe5babbb9fc06070a040cad2ae96dde3a5500c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        final Resource resource = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);\n        final String attribute = operation.require(ModelDescriptionConstants.NAME).asString();\n        final AttributeDefinition def = getAttributeDefinition(attribute);\n        if(def == null) {\n            context.getFailureDescription().set(new ModelNode().set(String.format(\"no such attribute (%s) \", attribute)));\n        }\n        def.getValidator().validateParameter(ModelDescriptionConstants.VALUE, operation);\n        resource.getModel().get(attribute).set(operation.get(ModelDescriptionConstants.VALUE));\n        if(context.getType() == OperationContext.Type.SERVER) {\n            context.addStep(new OperationStepHandler() {\n                @Override\n                public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n                    final HornetQServer server = AddressSettingAdd.getServer(context);\n                    if(server != null) {\n                        final ModelNode model = resource.getModel();\n                        final PathAddress address = PathAddress.pathAddress(operation.require(ModelDescriptionConstants.OP_ADDR));\n                        final AddressSettings settings = AddressSettingAdd.createSettings(model);\n                        server.getAddressSettingsRepository().addMatch(address.getLastElement().getValue(), settings);\n                    }\n                    context.completeStep();\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        context.completeStep();\n    }","id":49798,"modified_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        final Resource resource = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);\n        final String attribute = operation.require(ModelDescriptionConstants.NAME).asString();\n        final AttributeDefinition def = getAttributeDefinition(attribute);\n        if(def == null) {\n            context.getFailureDescription().set(new ModelNode().set(String.format(\"no such attribute (%s) \", attribute)));\n        }\n        def.getValidator().validateParameter(ModelDescriptionConstants.VALUE, operation);\n        resource.getModel().get(attribute).set(operation.get(ModelDescriptionConstants.VALUE));\n\n        if(context.getType() == OperationContext.Type.SERVER) {\n            context.addStep(new OperationStepHandler() {\n                @Override\n                public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n                    final HornetQServer server = AddressSettingAdd.getServer(context);\n                    PathAddress address = null;\n                    HierarchicalRepository<AddressSettings> repository = null;\n                    AddressSettings existingSettings = null;\n                    if(server != null) {\n                        final ModelNode model = resource.getModel();\n                        address = PathAddress.pathAddress(operation.require(ModelDescriptionConstants.OP_ADDR));\n                        final AddressSettings settings = AddressSettingAdd.createSettings(model);\n                        repository = server.getAddressSettingsRepository();\n                        String match = address.getLastElement().getValue();\n                        existingSettings = repository.getMatch(match);\n                        repository.addMatch(match, settings);\n                    }\n\n                    if (context.completeStep() != OperationContext.ResultAction.KEEP && existingSettings != null) {\n                        // Restore the old settings\n                        repository.addMatch(address.getLastElement().getValue(), existingSettings);\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        context.completeStep();\n    }","commit_id":"4ebe5babbb9fc06070a040cad2ae96dde3a5500c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void handleOperation(String operationName, OperationContext context, ModelNode operation) throws OperationFailedException {\n        if (GET_CONNECTOR_PAIRS_AS_JSON.equals(operationName)) {\n            BroadcastGroupControl control = getHornetQComponentControl(context, operation, false);\n            try {\n                context.getResult().set(control.getConnectorPairsAsJSON());\n            } catch (Exception e) {\n                context.getFailureDescription().set(e.toString());\n            }\n        } else {\n            unsupportedOperation(operationName);\n        }\n    }","id":49799,"modified_method":"@Override\n    protected Object handleOperation(String operationName, OperationContext context, ModelNode operation) throws OperationFailedException {\n        if (GET_CONNECTOR_PAIRS_AS_JSON.equals(operationName)) {\n            BroadcastGroupControl control = getHornetQComponentControl(context, operation, false);\n            try {\n                context.getResult().set(control.getConnectorPairsAsJSON());\n            } catch (Exception e) {\n                context.getFailureDescription().set(e.toString());\n            }\n        } else {\n            unsupportedOperation(operationName);\n        }\n\n        return null;\n    }","commit_id":"4ebe5babbb9fc06070a040cad2ae96dde3a5500c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void handleOperation(String operationName, OperationContext context, ModelNode operation) throws OperationFailedException {\n        if (GET_STATIC_CONNECTORS_AS_JSON.equals(operationName)) {\n            ClusterConnectionControl control = getHornetQComponentControl(context, operation, false);\n            try {\n                context.getResult().set(control.getStaticConnectorsAsJSON());\n            } catch (Exception e) {\n                context.getFailureDescription().set(e.toString());\n            }\n        } else if (GET_NODES.equals(operationName)) {\n            ClusterConnectionControl control = getHornetQComponentControl(context, operation, false);\n            try {\n                Map<String, String> nodes = control.getNodes();\n                final ModelNode result = context.getResult();\n                result.setEmptyObject();\n                for (Map.Entry<String, String> entry : nodes.entrySet()) {\n                    result.get(entry.getKey()).set(entry.getValue());\n                }\n            } catch (Exception e) {\n                context.getFailureDescription().set(e.toString());\n            }\n        } else {\n            unsupportedOperation(operationName);\n        }\n    }","id":49800,"modified_method":"@Override\n    protected Object handleOperation(String operationName, OperationContext context, ModelNode operation) throws OperationFailedException {\n        if (GET_STATIC_CONNECTORS_AS_JSON.equals(operationName)) {\n            ClusterConnectionControl control = getHornetQComponentControl(context, operation, false);\n            try {\n                context.getResult().set(control.getStaticConnectorsAsJSON());\n            } catch (Exception e) {\n                context.getFailureDescription().set(e.toString());\n            }\n        } else if (GET_NODES.equals(operationName)) {\n            ClusterConnectionControl control = getHornetQComponentControl(context, operation, false);\n            try {\n                Map<String, String> nodes = control.getNodes();\n                final ModelNode result = context.getResult();\n                result.setEmptyObject();\n                for (Map.Entry<String, String> entry : nodes.entrySet()) {\n                    result.get(entry.getKey()).set(entry.getValue());\n                }\n            } catch (Exception e) {\n                context.getFailureDescription().set(e.toString());\n            }\n        } else {\n            unsupportedOperation(operationName);\n        }\n\n        return null;\n    }","commit_id":"4ebe5babbb9fc06070a040cad2ae96dde3a5500c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode newValue, ModelNode currentValue) throws OperationFailedException {\n        AttributeDefinition attr = runtimeAttributes.get(attributeName);\n        if (attr != null) {\n            ServiceRegistry registry = context.getServiceRegistry(true);\n            ServiceController<?> hqService = registry.getService(MessagingServices.JBOSS_MESSAGING);\n            if (hqService != null && hqService.getState() == ServiceController.State.UP) {\n                final String name = PathAddress.pathAddress(operation.require(ModelDescriptionConstants.OP_ADDR)).getLastElement().getValue();\n                HornetQServer server =  HornetQServer.class.cast(hqService.getValue());\n                ConnectionFactoryControl control = ConnectionFactoryControl.class.cast(server.getManagementService().getResource(ResourceNames.JMS_CONNECTION_FACTORY + name));\n                try {\n                    if (attributeName.equals(CommonAttributes.CLIENT_ID.getName()))  {\n                        final ModelNode node = CommonAttributes.CLIENT_ID.validateResolvedOperation(operation);\n                        control.setClientID(node.isDefined() ? node.asString() : null);\n                    } else if (attributeName.equals(CommonAttributes.COMPRESS_LARGE_MESSAGES.getName())) {\n                        control.setCompressLargeMessages(CommonAttributes.COMPRESS_LARGE_MESSAGES.validateResolvedOperation(operation).asBoolean());\n                    } else if (attributeName.equals(CommonAttributes.CLIENT_FAILURE_CHECK_PERIOD.getName())) {\n                        control.setClientFailureCheckPeriod(CommonAttributes.CLIENT_FAILURE_CHECK_PERIOD.validateResolvedOperation(operation).asLong());\n                    } else if (attributeName.equals(CommonAttributes.CALL_TIMEOUT.getName())) {\n                        control.setCallTimeout(CommonAttributes.CALL_TIMEOUT.validateResolvedOperation(operation).asLong());\n                    } else if (attributeName.equals(CommonAttributes.DUPS_OK_BATCH_SIZE.getName())) {\n                        control.setDupsOKBatchSize(CommonAttributes.DUPS_OK_BATCH_SIZE.validateResolvedOperation(operation).asInt());\n                    } else if (attributeName.equals(CommonAttributes.CONSUMER_MAX_RATE.getName())) {\n                        control.setConsumerMaxRate(CommonAttributes.CONSUMER_MAX_RATE.validateResolvedOperation(operation).asInt());\n                    } else if (attributeName.equals(CommonAttributes.CONSUMER_WINDOW_SIZE.getName())) {\n                        control.setConsumerWindowSize(CommonAttributes.CONSUMER_WINDOW_SIZE.validateResolvedOperation(operation).asInt());\n                    } else if (attributeName.equals(CommonAttributes.PRODUCER_MAX_RATE.getName())) {\n                        control.setProducerMaxRate(CommonAttributes.PRODUCER_MAX_RATE.validateResolvedOperation(operation).asInt());\n                    } else if (attributeName.equals(CommonAttributes.CONFIRMATION_WINDOW_SIZE.getName())) {\n                        control.setConfirmationWindowSize(CommonAttributes.CONFIRMATION_WINDOW_SIZE.validateResolvedOperation(operation).asInt());\n                    } else if (attributeName.equals(CommonAttributes.BLOCK_ON_ACK.getName())) {\n                        control.setBlockOnAcknowledge(CommonAttributes.BLOCK_ON_ACK.validateResolvedOperation(operation).asBoolean());\n                    } else if (attributeName.equals(CommonAttributes.BLOCK_ON_DURABLE_SEND.getName())) {\n                        control.setBlockOnDurableSend(CommonAttributes.BLOCK_ON_DURABLE_SEND.validateResolvedOperation(operation).asBoolean());\n                    } else if (attributeName.equals(CommonAttributes.BLOCK_ON_NON_DURABLE_SEND.getName())) {\n                        control.setBlockOnNonDurableSend(CommonAttributes.BLOCK_ON_NON_DURABLE_SEND.validateResolvedOperation(operation).asBoolean());\n                    } else if (attributeName.equals(CommonAttributes.PRE_ACK.getName())) {\n                        control.setPreAcknowledge(CommonAttributes.PRE_ACK.validateResolvedOperation(operation).asBoolean());\n                    } else if (attributeName.equals(CommonAttributes.CONNECTION_TTL.getName())) {\n                        control.setConnectionTTL(CommonAttributes.CONNECTION_TTL.validateResolvedOperation(operation).asLong());\n                    } else if (attributeName.equals(CommonAttributes.TRANSACTION_BATCH_SIZE.getName())) {\n                        control.setTransactionBatchSize(CommonAttributes.TRANSACTION_BATCH_SIZE.validateResolvedOperation(operation).asInt());\n                    } else if (attributeName.equals(CommonAttributes.MIN_LARGE_MESSAGE_SIZE.getName())) {\n                        control.setMinLargeMessageSize(CommonAttributes.MIN_LARGE_MESSAGE_SIZE.validateResolvedOperation(operation).asInt());\n                    } else if (attributeName.equals(CommonAttributes.AUTO_GROUP.getName())) {\n                        control.setAutoGroup(CommonAttributes.AUTO_GROUP.validateResolvedOperation(operation).asBoolean());\n                    } else if (attributeName.equals(CommonAttributes.RETRY_INTERVAL.getName())) {\n                        control.setRetryInterval(CommonAttributes.RETRY_INTERVAL.validateResolvedOperation(operation).asLong());\n                    } else if (attributeName.equals(CommonAttributes.RETRY_INTERVAL_MULTIPLIER.getName())) {\n                        control.setRetryIntervalMultiplier(CommonAttributes.RETRY_INTERVAL_MULTIPLIER.validateResolvedOperation(operation).asDouble());\n                    } else if (attributeName.equals(CommonAttributes.CONNECTION_FACTORY_RECONNECT_ATTEMPTS.getName())) {\n                        control.setReconnectAttempts(CommonAttributes.CONNECTION_FACTORY_RECONNECT_ATTEMPTS.validateResolvedOperation(operation).asInt());\n                    } else if (attributeName.equals(CommonAttributes.FAILOVER_ON_INITIAL_CONNECTION.getName())) {\n                        control.setFailoverOnInitialConnection(CommonAttributes.FAILOVER_ON_INITIAL_CONNECTION.validateResolvedOperation(operation).asBoolean());\n                    } else if (attributeName.equals(CommonAttributes.PRODUCER_WINDOW_SIZE.getName())) {\n                        control.setProducerWindowSize(CommonAttributes.PRODUCER_WINDOW_SIZE.validateResolvedOperation(operation).asInt());\n                    } else if (attributeName.equals(CommonAttributes.CACHE_LARGE_MESSAGE_CLIENT.getName())) {\n                        control.setCacheLargeMessagesClient(CommonAttributes.CACHE_LARGE_MESSAGE_CLIENT.validateResolvedOperation(operation).asBoolean());\n                    } else if (attributeName.equals(CommonAttributes.MAX_RETRY_INTERVAL.getName())) {\n                        control.setMaxRetryInterval(CommonAttributes.MAX_RETRY_INTERVAL.validateResolvedOperation(operation).asLong());\n                    } else if (attributeName.equals(CommonAttributes.CONNECTION_SCHEDULED_THREAD_POOL_MAX_SIZE.getName())) {\n                        control.setScheduledThreadPoolMaxSize(CommonAttributes.CONNECTION_SCHEDULED_THREAD_POOL_MAX_SIZE.validateResolvedOperation(operation).asInt());\n                    } else if (attributeName.equals(CommonAttributes.CONNECTION_THREAD_POOL_MAX_SIZE.getName())) {\n                        control.setThreadPoolMaxSize(CommonAttributes.CONNECTION_THREAD_POOL_MAX_SIZE.validateResolvedOperation(operation).asInt());\n                    } else if (attributeName.equals(CommonAttributes.GROUP_ID.getName())) {\n                        final ModelNode node = CommonAttributes.GROUP_ID.validateResolvedOperation(operation);\n                        control.setGroupID(node.isDefined() ? node.asString() : null);\n                    } else if (attributeName.equals(CommonAttributes.USE_GLOBAL_POOLS.getName())) {\n                        control.setUseGlobalPools(CommonAttributes.USE_GLOBAL_POOLS.validateResolvedOperation(operation).asBoolean());\n                    } else if (attributeName.equals(CommonAttributes.LOAD_BALANCING_CLASS_NAME.getName())) {\n                        control.setConnectionLoadBalancingPolicyClassName(CommonAttributes.LOAD_BALANCING_CLASS_NAME.validateResolvedOperation(operation).asString());\n                    } else {\n                        // Bug! Someone added the attribute to the set but did not implement\n                        throw new UnsupportedOperationException(String.format(\"Runtime handling for %s is not implemented\", attributeName));\n                    }\n\n                } catch (RuntimeException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n\n                return false;\n\n            } else {\n                throw new IllegalStateException(String.format(\"Cannot apply attribue %s ti runtime; service %s is not in state %s, it is in state %s\",\n                            attributeName, MessagingServices.JBOSS_MESSAGING, ServiceController.State.UP, hqService.getState()));\n            }\n\n        } else {\n            // Not a runtime attribute; restart required\n            return true;\n        }\n    }","id":49801,"modified_method":"@Override\n    protected boolean applyUpdateToRuntime(final OperationContext context, final ModelNode operation,\n                                           final String attributeName, final ModelNode newValue,\n                                           final ModelNode currentValue) throws OperationFailedException {\n\n        AttributeDefinition attr = runtimeAttributes.get(attributeName);\n        if (attr == null) {\n            // Not a runtime attribute; restart required\n            return true;\n        }\n        else {\n            ServiceRegistry registry = context.getServiceRegistry(true);\n            ServiceController<?> hqService = registry.getService(MessagingServices.JBOSS_MESSAGING);\n            if (hqService == null) {\n                // The service isn't installed, so the work done in the Stage.MODEL part is all there is to it\n                return false;\n            } else if (hqService.getState() != ServiceController.State.UP) {\n                // Service is installed but not up?\n                //throw new IllegalStateException(String.format(\"Cannot apply attribue %s to runtime; service %s is not in state %s, it is in state %s\",\n                //            attributeName, MessagingServices.JBOSS_MESSAGING, ServiceController.State.UP, hqService.getState()));\n                // No, don't barf; just let the update apply to the model and put the server in a reload-required state\n                return true;\n            } else {\n                // Actually apply the update\n                applyOperationToHornetQService(operation, attributeName, hqService);\n\n                return false;\n            }\n\n        }\n    }","commit_id":"4ebe5babbb9fc06070a040cad2ae96dde3a5500c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode newValue, ModelNode currentValue) throws OperationFailedException {\n        AttributeDefinition attr = runtimeAttributes.get(attributeName);\n        if (attr != null) {\n            ServiceRegistry registry = context.getServiceRegistry(true);\n            ServiceController<?> hqService = registry.getService(MessagingServices.JBOSS_MESSAGING);\n            if (hqService != null && hqService.getState() == ServiceController.State.UP) {\n\n                HornetQServerControl serverControl = HornetQServer.class.cast(hqService.getValue()).getHornetQServerControl();\n                try {\n                    if (attributeName.equals(CommonAttributes.FAILOVER_ON_SHUTDOWN.getName()))  {\n                        serverControl.setFailoverOnServerShutdown(newValue.resolve().asBoolean());\n                    } else if (attributeName.equals(CommonAttributes.MESSAGE_COUNTER_SAMPLE_PERIOD.getName())) {\n                        serverControl.setMessageCounterSamplePeriod(newValue.resolve().asLong());\n                    } else if (attributeName.equals(CommonAttributes.MESSAGE_COUNTER_MAX_DAY_HISTORY.getName())) {\n                        serverControl.setMessageCounterMaxDayCount(newValue.resolve().asInt());\n                    } else if (attributeName.equals(CommonAttributes.MESSAGE_COUNTER_ENABLED.getName())) {\n                        boolean enabled = newValue.resolve().asBoolean();\n                        if (enabled) {\n                            serverControl.enableMessageCounters();\n                        } else {\n                            serverControl.disableMessageCounters();\n                        }\n                    } else {\n                        // Bug! Someone added the attribute to the set but did not implement\n                        throw new UnsupportedOperationException(String.format(\"Runtime handling for %s is not implemented\", attributeName));\n                    }\n\n                } catch (RuntimeException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n\n                return false;\n\n            } else {\n                throw new IllegalStateException(String.format(\"Cannot apply attribute %s to runtime; service %s is not in state %s, it is in state %s\",\n                            attributeName, MessagingServices.JBOSS_MESSAGING, ServiceController.State.UP, hqService.getState()));\n            }\n\n        } else {\n            // Not a runtime attribute; restart required\n            return true;\n        }\n    }","id":49802,"modified_method":"@Override\n    protected boolean applyUpdateToRuntime(OperationContext context, ModelNode operation, String attributeName, ModelNode newValue, ModelNode currentValue) throws OperationFailedException {\n        AttributeDefinition attr = runtimeAttributes.get(attributeName);\n        if (attr == null) {\n            // Not a runtime attribute; restart required\n            return true;\n        } else {\n            ServiceRegistry registry = context.getServiceRegistry(true);\n            ServiceController<?> hqService = registry.getService(MessagingServices.JBOSS_MESSAGING);\n            if (hqService == null) {\n                // The service isn't installed, so the work done in the Stage.MODEL part is all there is to it\n                return false;\n            } else if (hqService.getState() != ServiceController.State.UP) {\n                // Service is installed but not up?\n                //throw new IllegalStateException(String.format(\"Cannot apply attribue %s to runtime; service %s is not in state %s, it is in state %s\",\n                //            attributeName, MessagingServices.JBOSS_MESSAGING, ServiceController.State.UP, hqService.getState()));\n                // No, don't barf; just let the update apply to the model and put the server in a reload-required state\n                return true;\n            } else {\n                applyOperationToHornetQService(operation, attributeName, hqService);\n                return false;\n\n            }\n\n        }\n    }","commit_id":"4ebe5babbb9fc06070a040cad2ae96dde3a5500c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void handleAdditonalOperation(String operationName, ModelNode operation, OperationContext context,\n                                            JMSQueueControl queueControl) throws OperationFailedException {\n        throwUnimplementedOperationException(operationName);\n    }","id":49803,"modified_method":"@Override\n    protected Object handleAdditonalOperation(String operationName, ModelNode operation, OperationContext context,\n                                            JMSQueueControl queueControl) throws OperationFailedException {\n        throwUnimplementedOperationException(operationName);\n        return null;\n    }","commit_id":"4ebe5babbb9fc06070a040cad2ae96dde3a5500c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void handleAdditonalOperation(String operationName, ModelNode operation, OperationContext context,\n                                            QueueControl queueControl) throws OperationFailedException {\n        try {\n        if (LIST_SCHEDULED_MESSAGES.equals(operationName)) {\n            String json = queueControl.listScheduledMessagesAsJSON();\n            context.getResult().set(ModelNode.fromJSONString(json));\n        } else if (LIST_SCHEDULED_MESSAGES_AS_JSON.equals(operationName)) {\n            context.getResult().set(queueControl.listScheduledMessagesAsJSON());\n        } else {\n            // Bug\n            throwUnimplementedOperationException(operationName);\n        }\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            context.getFailureDescription().set(e.toString());\n        }\n    }","id":49804,"modified_method":"@Override\n    protected Object handleAdditonalOperation(String operationName, ModelNode operation, OperationContext context,\n                                            QueueControl queueControl) throws OperationFailedException {\n        try {\n            if (LIST_SCHEDULED_MESSAGES.equals(operationName)) {\n                String json = queueControl.listScheduledMessagesAsJSON();\n                context.getResult().set(ModelNode.fromJSONString(json));\n            } else if (LIST_SCHEDULED_MESSAGES_AS_JSON.equals(operationName)) {\n                context.getResult().set(queueControl.listScheduledMessagesAsJSON());\n            } else {\n                // Bug\n                throwUnimplementedOperationException(operationName);\n            }\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            context.getFailureDescription().set(e.toString());\n        }\n\n        return null;\n    }","commit_id":"4ebe5babbb9fc06070a040cad2ae96dde3a5500c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void modelChanged(final OperationContext context, final ModelNode operation,\n                                final String attributeName, final ModelNode newValue, final ModelNode currentValue) throws OperationFailedException {\n\n        boolean restartRequired = false;\n        boolean applyToRuntime = context.getType() == OperationContext.Type.SERVER;\n        ModelNode resolvedValue = null;\n        if (applyToRuntime) {\n            validateResolvedValue(attributeName, newValue);\n            resolvedValue = newValue.isDefined() ? newValue.resolve() : newValue;\n            restartRequired = applyUpdateToRuntime(context, operation, attributeName, resolvedValue, currentValue);\n            if (restartRequired) {\n                context.reloadRequired();\n            }\n        }\n\n        if (context.completeStep() != OperationContext.ResultAction.KEEP && applyToRuntime) {\n            ModelNode valueToRestore = currentValue.isDefined() ? currentValue.resolve() : currentValue;\n            revertUpdateToRuntime(context, operation, attributeName, valueToRestore, resolvedValue);\n            if (restartRequired) {\n                context.revertReloadRequired();\n            }\n        }\n    }","id":49805,"modified_method":"@Override\n    protected void modelChanged(final OperationContext context, final ModelNode operation,\n                                final String attributeName, final ModelNode newValue, final ModelNode currentValue) throws OperationFailedException {\n\n        boolean restartRequired = false;\n        boolean applyToRuntime = context.getType() == OperationContext.Type.SERVER;\n        ModelNode resolvedValue = null;\n        if (applyToRuntime) {\n            validateResolvedValue(attributeName, newValue);\n            resolvedValue = newValue.resolve();\n            restartRequired = applyUpdateToRuntime(context, operation, attributeName, resolvedValue, currentValue);\n            if (restartRequired) {\n                context.reloadRequired();\n            }\n        }\n\n        if (context.completeStep() != OperationContext.ResultAction.KEEP && applyToRuntime) {\n            ModelNode valueToRestore = currentValue.resolve();\n            try {\n                revertUpdateToRuntime(context, operation, attributeName, valueToRestore, resolvedValue);\n            } catch (Exception e) {\n                log.errorf(e, String.format(\"%s caught exception attempting to revert operation %s at address %s\",\n                        getClass().getSimpleName(),\n                        operation.require(ModelDescriptionConstants.OP).asString(),\n                        PathAddress.pathAddress(operation.require(ModelDescriptionConstants.OP_ADDR))));\n            }\n            if (restartRequired) {\n                context.revertReloadRequired();\n            }\n        }\n    }","commit_id":"4ebe5babbb9fc06070a040cad2ae96dde3a5500c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void shouldFailAuthenticationIfUserIsNotFound() throws Throwable\n    {\n        // Given\n        final InMemoryUserRepository users = new InMemoryUserRepository();\n        final User user = new User( \"jake\", \"admin\", Credential.forPassword( \"abc123\" ), true );\n        users.create( user );\n        final AuthenticationStrategy authStrategy = mock( AuthenticationStrategy.class );\n        final BasicAuthManager manager = new BasicAuthManager( users, mock( PasswordPolicy.class ), authStrategy );\n        manager.start();\n\n        // When\n        AuthenticationResult result = manager.authenticate( \"unknown\", \"abc123\" );\n\n        // Then\n        assertThat( result, equalTo( AuthenticationResult.FAILURE ) );\n    }","id":49806,"modified_method":"@Test\n    public void shouldFailAuthenticationIfUserIsNotFound() throws Throwable\n    {\n        // Given\n        final InMemoryUserRepository users = new InMemoryUserRepository();\n        final User user = new User( \"jake\", \"admin\", Credential.forPassword( \"abc123\" ), true );\n        users.create( user );\n        final AuthenticationStrategy authStrategy = mock( AuthenticationStrategy.class );\n        final BasicAuthManager manager = new BasicAuthManager( users, mock( PasswordPolicy.class ), authStrategy );\n        manager.start();\n\n        // When\n        AuthSubject authSubject = manager.login( \"unknown\", \"abc123\" );\n        AuthenticationResult result = authSubject.getAuthenticationResult();\n\n        // Then\n        assertThat( result, equalTo( AuthenticationResult.FAILURE ) );\n    }","commit_id":"298752a8225cba70b54a50909328cdadd9a16b33","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldFindAndAuthenticateUserAndReturnPasswordChangeIfRequired() throws Throwable\n    {\n        // Given\n        final InMemoryUserRepository users = new InMemoryUserRepository();\n        final User user = new User( \"jake\", \"admin\", Credential.forPassword( \"abc123\" ), true );\n        users.create( user );\n        final AuthenticationStrategy authStrategy = mock( AuthenticationStrategy.class );\n        final BasicAuthManager manager = new BasicAuthManager( users, mock( PasswordPolicy.class ), authStrategy );\n        manager.start();\n        when( authStrategy.authenticate( user, \"abc123\" )).thenReturn( AuthenticationResult.SUCCESS );\n\n        // When\n        AuthenticationResult result = manager.authenticate( \"jake\", \"abc123\" );\n\n        // Then\n        assertThat( result, equalTo( AuthenticationResult.PASSWORD_CHANGE_REQUIRED ) );\n    }","id":49807,"modified_method":"@Test\n    public void shouldFindAndAuthenticateUserAndReturnPasswordChangeIfRequired() throws Throwable\n    {\n        // Given\n        final InMemoryUserRepository users = new InMemoryUserRepository();\n        final User user = new User( \"jake\", \"admin\", Credential.forPassword( \"abc123\" ), true );\n        users.create( user );\n        final AuthenticationStrategy authStrategy = mock( AuthenticationStrategy.class );\n        final BasicAuthManager manager = new BasicAuthManager( users, mock( PasswordPolicy.class ), authStrategy );\n        manager.start();\n        when( authStrategy.authenticate( user, \"abc123\" )).thenReturn( AuthenticationResult.SUCCESS );\n\n        // When\n        AuthSubject authSubject = manager.login( \"jake\", \"abc123\" );\n        AuthenticationResult result = authSubject.getAuthenticationResult();\n\n        // Then\n        assertThat( result, equalTo( AuthenticationResult.PASSWORD_CHANGE_REQUIRED ) );\n    }","commit_id":"298752a8225cba70b54a50909328cdadd9a16b33","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldFindAndAuthenticateUserAndReturnAuthStrategyResult() throws Throwable\n    {\n        // Given\n        final InMemoryUserRepository users = new InMemoryUserRepository();\n        final User user = new User( \"jake\", \"admin\", Credential.forPassword( \"abc123\" ), true );\n        users.create( user );\n        final AuthenticationStrategy authStrategy = mock( AuthenticationStrategy.class );\n        final BasicAuthManager manager = new BasicAuthManager( users, mock( PasswordPolicy.class ), authStrategy );\n        manager.start();\n        when( authStrategy.authenticate( user, \"abc123\" )).thenReturn( AuthenticationResult.TOO_MANY_ATTEMPTS );\n\n        // When\n        AuthenticationResult result = manager.authenticate( \"jake\", \"abc123\" );\n\n        // Then\n        assertThat( result, equalTo( AuthenticationResult.TOO_MANY_ATTEMPTS ) );\n    }","id":49808,"modified_method":"@Test\n    public void shouldFindAndAuthenticateUserAndReturnAuthStrategyResult() throws Throwable\n    {\n        // Given\n        final InMemoryUserRepository users = new InMemoryUserRepository();\n        final User user = new User( \"jake\", \"admin\", Credential.forPassword( \"abc123\" ), true );\n        users.create( user );\n        final AuthenticationStrategy authStrategy = mock( AuthenticationStrategy.class );\n        final BasicAuthManager manager = new BasicAuthManager( users, mock( PasswordPolicy.class ), authStrategy );\n        manager.start();\n        when( authStrategy.authenticate( user, \"abc123\" )).thenReturn( AuthenticationResult.TOO_MANY_ATTEMPTS );\n\n        // When\n        AuthSubject authSubject = manager.login( \"jake\", \"abc123\" );\n        AuthenticationResult result = authSubject.getAuthenticationResult();\n\n        // Then\n        assertThat( result, equalTo( AuthenticationResult.TOO_MANY_ATTEMPTS ) );\n    }","commit_id":"298752a8225cba70b54a50909328cdadd9a16b33","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldFindAndAuthenticateUserSuccessfully() throws Throwable\n    {\n        // Given\n        final InMemoryUserRepository users = new InMemoryUserRepository();\n            final User user = new User( \"jake\", \"admin\", Credential.forPassword( \"abc123\" ), false );\n        users.create( user );\n        final AuthenticationStrategy authStrategy = mock( AuthenticationStrategy.class );\n        final BasicAuthManager manager = new BasicAuthManager( users, mock( PasswordPolicy.class ), authStrategy );\n        manager.start();\n        when( authStrategy.authenticate( user, \"abc123\" )).thenReturn( AuthenticationResult.SUCCESS );\n\n        // When\n        AuthenticationResult result = manager.authenticate( \"jake\", \"abc123\" );\n\n        // Then\n        assertThat( result, equalTo( AuthenticationResult.SUCCESS ) );\n    }","id":49809,"modified_method":"@Test\n    public void shouldFindAndAuthenticateUserSuccessfully() throws Throwable\n    {\n        // Given\n        final InMemoryUserRepository users = new InMemoryUserRepository();\n            final User user = new User( \"jake\", \"admin\", Credential.forPassword( \"abc123\" ), false );\n        users.create( user );\n        final AuthenticationStrategy authStrategy = mock( AuthenticationStrategy.class );\n        final BasicAuthManager manager = new BasicAuthManager( users, mock( PasswordPolicy.class ), authStrategy );\n        manager.start();\n        when( authStrategy.authenticate( user, \"abc123\" )).thenReturn( AuthenticationResult.SUCCESS );\n\n        // When\n        AuthSubject authSubject = manager.login( \"jake\", \"abc123\" );\n        AuthenticationResult result = authSubject.getAuthenticationResult();\n\n        // Then\n        assertThat( result, equalTo( AuthenticationResult.SUCCESS ) );\n    }","commit_id":"298752a8225cba70b54a50909328cdadd9a16b33","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldThrowWhenAuthIsDisabled() throws Throwable\n    {\n        final InMemoryUserRepository users = new InMemoryUserRepository();\n        final BasicAuthManager manager =\n                new BasicAuthManager( users, mock( PasswordPolicy.class ), mock( AuthenticationStrategy.class ), false );\n        manager.start();\n\n        try\n        {\n            manager.authenticate( \"foo\", \"bar\" );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        try\n        {\n            manager.newUser( \"foo\", \"bar\", true );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        try\n        {\n            manager.deleteUser( \"foo\" );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        try\n        {\n            manager.getUser( \"foo\" );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        try\n        {\n            manager.setUserPassword( \"foo\", \"bar\" );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        assertTrue( users.numberOfUsers() == 0 );\n    }","id":49810,"modified_method":"@Test\n    public void shouldThrowWhenAuthIsDisabled() throws Throwable\n    {\n        final InMemoryUserRepository users = new InMemoryUserRepository();\n        final BasicAuthManager manager =\n                new BasicAuthManager( users, mock( PasswordPolicy.class ), mock( AuthenticationStrategy.class ), false );\n        manager.start();\n\n        try\n        {\n            manager.login( \"foo\", \"bar\" );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        try\n        {\n            manager.newUser( \"foo\", \"bar\", true );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        try\n        {\n            manager.deleteUser( \"foo\" );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        try\n        {\n            manager.getUser( \"foo\" );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        try\n        {\n            manager.setUserPassword( \"foo\", \"bar\" );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        assertTrue( users.numberOfUsers() == 0 );\n    }","commit_id":"298752a8225cba70b54a50909328cdadd9a16b33","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldFindAndAuthenticateUserAndReturnPasswordChangeIfRequired() throws Throwable\n    {\n        // Given\n        final User user = new User( \"jake\", \"admin\", Credential.forPassword( \"abc123\" ), true );\n        users.create( user );\n        manager.start();\n        when( authStrategy.isAuthenticationPermitted( user.name() )).thenReturn( true );\n\n        // When\n        AuthenticationResult result = manager.authenticate( \"jake\", \"abc123\" );\n\n        // Then\n        assertThat( result, equalTo( AuthenticationResult.PASSWORD_CHANGE_REQUIRED ) );\n    }","id":49811,"modified_method":"@Test\n    public void shouldFindAndAuthenticateUserAndReturnPasswordChangeIfRequired() throws Throwable\n    {\n        // Given\n        final User user = new User( \"jake\", \"admin\", Credential.forPassword( \"abc123\" ), true );\n        users.create( user );\n        manager.start();\n        when( authStrategy.isAuthenticationPermitted( user.name() )).thenReturn( true );\n\n        // When\n        AuthenticationResult result = manager.login( \"jake\", \"abc123\" ).getAuthenticationResult();\n\n        // Then\n        assertThat( result, equalTo( AuthenticationResult.PASSWORD_CHANGE_REQUIRED ) );\n    }","commit_id":"298752a8225cba70b54a50909328cdadd9a16b33","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldFindAndAuthenticateUserAndReturnAuthStrategyResult() throws Throwable\n    {\n        // Given\n        final User user = new User( \"jake\", \"admin\", Credential.forPassword( \"abc123\" ), true );\n        users.create( user );\n        manager.start();\n\n        // When\n        AuthenticationResult result = manager.authenticate( \"jake\", \"abc123\" );\n\n        // Then\n        assertThat( result, equalTo( AuthenticationResult.TOO_MANY_ATTEMPTS ) );\n    }","id":49812,"modified_method":"@Test\n    public void shouldFindAndAuthenticateUserAndReturnAuthStrategyResult() throws Throwable\n    {\n        // Given\n        final User user = new User( \"jake\", \"admin\", Credential.forPassword( \"abc123\" ), true );\n        users.create( user );\n        manager.start();\n\n        // When\n        AuthSubject authSubject = manager.login( \"jake\", \"abc123\" );\n        AuthenticationResult result = authSubject.getAuthenticationResult();\n\n        // Then\n        assertThat( result, equalTo( AuthenticationResult.TOO_MANY_ATTEMPTS ) );\n    }","commit_id":"298752a8225cba70b54a50909328cdadd9a16b33","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldFindAndAuthenticateUserSuccessfully() throws Throwable\n    {\n        // Given\n        final User user = new User( \"jake\", \"admin\", Credential.forPassword( \"abc123\" ), false );\n        users.create( user );\n        manager.start();\n        when( authStrategy.isAuthenticationPermitted( user.name() )).thenReturn( true );\n\n        // When\n        AuthenticationResult result = manager.authenticate( \"jake\", \"abc123\" );\n\n        // Then\n        assertThat( result, equalTo( AuthenticationResult.SUCCESS ) );\n    }","id":49813,"modified_method":"@Test\n    public void shouldFindAndAuthenticateUserSuccessfully() throws Throwable\n    {\n        // Given\n        final User user = new User( \"jake\", \"admin\", Credential.forPassword( \"abc123\" ), false );\n        users.create( user );\n        manager.start();\n        when( authStrategy.isAuthenticationPermitted( user.name() )).thenReturn( true );\n\n        // When\n        AuthenticationResult result = manager.login( \"jake\", \"abc123\" ).getAuthenticationResult();\n\n        // Then\n        assertThat( result, equalTo( AuthenticationResult.SUCCESS ) );\n    }","commit_id":"298752a8225cba70b54a50909328cdadd9a16b33","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldFailAuthenticationIfUserIsNotFound() throws Throwable\n    {\n        // Given\n        final User user = new User( \"jake\", \"admin\", Credential.forPassword( \"abc123\" ), true );\n        users.create( user );\n        manager.start();\n        when( authStrategy.isAuthenticationPermitted( \"unknown\" )).thenReturn( true );\n\n        // When\n        AuthenticationResult result = manager.authenticate( \"unknown\", \"abc123\" );\n\n        // Then\n        assertThat( result, equalTo( AuthenticationResult.FAILURE ) );\n    }","id":49814,"modified_method":"@Test\n    public void shouldFailAuthenticationIfUserIsNotFound() throws Throwable\n    {\n        // Given\n        final User user = new User( \"jake\", \"admin\", Credential.forPassword( \"abc123\" ), true );\n        users.create( user );\n        manager.start();\n        when( authStrategy.isAuthenticationPermitted( \"unknown\" )).thenReturn( true );\n\n        // When\n        AuthSubject authSubject = manager.login( \"unknown\", \"abc123\" );\n        AuthenticationResult result = authSubject.getAuthenticationResult();\n\n        // Then\n        assertThat( result, equalTo( AuthenticationResult.FAILURE ) );\n    }","commit_id":"298752a8225cba70b54a50909328cdadd9a16b33","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldThrowWhenAuthIsDisabled() throws Throwable\n    {\n        manager = new ShiroAuthManager( users, passwordPolicy, authStrategy, false );\n        manager.start();\n\n        try\n        {\n            manager.authenticate( \"foo\", \"bar\" );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        try\n        {\n            manager.newUser( \"foo\", \"bar\", true );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        try\n        {\n            manager.deleteUser( \"foo\" );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        try\n        {\n            manager.getUser( \"foo\" );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        try\n        {\n            manager.setUserPassword( \"foo\", \"bar\" );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        assertTrue( users.numberOfUsers() == 0 );\n    }","id":49815,"modified_method":"@Test\n    public void shouldThrowWhenAuthIsDisabled() throws Throwable\n    {\n        manager = new ShiroAuthManager( users, passwordPolicy, authStrategy, false );\n        manager.start();\n\n        try\n        {\n            manager.login( \"foo\", \"bar\" );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        try\n        {\n            manager.newUser( \"foo\", \"bar\", true );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        try\n        {\n            manager.deleteUser( \"foo\" );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        try\n        {\n            manager.getUser( \"foo\" );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        try\n        {\n            manager.setUserPassword( \"foo\", \"bar\" );\n            fail( \"exception expected\" );\n        } catch ( IllegalStateException e )\n        {\n            // expected\n        }\n\n        assertTrue( users.numberOfUsers() == 0 );\n    }","commit_id":"298752a8225cba70b54a50909328cdadd9a16b33","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void printException(Throwable ex, FileWriter out) throws IOException {\n        if(ex == null)\n            return;\n        StackTraceElement[] stack_trace=ex.getStackTrace();\n        out.write(\"\\n<\" + CDATA + \"\\n\");\n        out.write(ex.getClass().getName() + \" \\n\");\n        for(int i=0;i < stack_trace.length;i++) {\n            StackTraceElement frame=stack_trace[i];\n            try {\n                out.write(\"at \" + frame.toString() + \" \\n\");\n            }\n            catch(IOException e) {\n            }\n        }\n        out.write(\"\\n]]>\");\n    }","id":49816,"modified_method":"private static String printException(Throwable ex) throws IOException {\n        if(ex == null)\n            return null;\n        StackTraceElement[] stack_trace=ex.getStackTrace();\n        StringBuilder sb=new StringBuilder();\n        sb.append(\"\\n<\" + CDATA + \"\\n\");\n        sb.append(ex.getClass().getName() + \" \\n\");\n        for(int i=0;i < stack_trace.length;i++) {\n            StackTraceElement frame=stack_trace[i];\n            sb.append(\"at \" + frame.toString() + \" \\n\");\n        }\n        sb.append(\"\\n]]>\");\n        return sb.toString();\n    }","commit_id":"030244e4ea97f68740992ae22b0929f8c7a48e72","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * generate the XML report given what we know from all the test results\n     */\n    protected void generateReport(Class<?> clazz, Collection<ITestResult> results) throws IOException {\n\n        int num_failures=getFailures(results);\n        int num_skips=getSkips(results);\n        int num_errors=getErrors(results);\n        long total_time=getTotalTime(results);\n\n        String file_name=output_dir + File.separator + \"TEST-\" + clazz.getName();\n        if(suffix != null)\n            file_name=file_name + \"-\" + suffix;\n        file_name=file_name + \".xml\";\n        FileWriter out=new FileWriter(file_name, false); // don't append, overwrite\n        try {\n            out.write(XML_DEF + \"\\n\");\n\n            out.write(\"\\n<testsuite \" + \" failures=\\\"\"\n                      + num_failures\n                      + \"\\\" errors=\\\"\"\n                      + num_errors\n                      + \"\\\" skips=\\\"\"\n                      + num_skips\n                      + \"\\\" name=\\\"\"\n                      + clazz.getName());\n            if(suffix != null)\n                out.write(\" (\" + suffix + \")\");\n            out.write(\"\\\" tests=\\\"\" + results.size() + \"\\\" time=\\\"\" + (total_time / 1000.0) + \"\\\">\");\n\n            out.write(\"\\n<properties>\");\n            Properties props=System.getProperties();\n\n            for(Map.Entry<Object,Object> tmp:props.entrySet()) {\n                out.write(\"\\n    <property name=\\\"\" + tmp.getKey()\n                          + \"\\\"\"\n                          + \" value=\\\"\"\n                          + tmp.getValue()\n                          + \"\\\"/>\");\n            }\n            out.write(\"\\n<\/properties>\\n\");\n\n            for(ITestResult result: results) {\n                if(result == null)\n                    continue;\n                long time=result.getEndMillis() - result.getStartMillis();\n                out.write(\"\\n    <testcase classname=\\\"\" + clazz.getName());\n                if(suffix != null)\n                    out.write(\" (\" + suffix + \")\");\n                out.write(\"\\\" name=\\\"\" + result.getMethod().getMethodName()\n                          + \"\\\" time=\\\"\"\n                          + (time / 1000.0)\n                          + \"\\\">\");\n\n                Throwable ex=result.getThrowable();\n\n                switch(result.getStatus()) {\n                    case ITestResult.SUCCESS:\n                    case ITestResult.SUCCESS_PERCENTAGE_FAILURE:\n                        break;\n                    case ITestResult.FAILURE:\n                        writeFailure(\"failure\",\n                                     result.getMethod().getMethod(),\n                                     ex,\n                                     \"exception\",\n                                     out);\n                        break;\n                    case ITestResult.SKIP:\n                        writeFailure(\"error\", result.getMethod().getMethod(), ex, \"SKIPPED\", out);\n                        break;\n                    default:\n                        writeFailure(\"error\", result.getMethod().getMethod(), ex, \"exception\", out);\n                }\n\n                out.write(\"\\n<\/testcase>\");\n            }\n\n            Tuple<StringBuffer,StringBuffer> stdout=outputs.get(clazz);\n            if(stdout != null) {\n                StringBuffer system_out=stdout.getVal1();\n                StringBuffer system_err=stdout.getVal2();\n                writeOutput(out, system_out.toString(), 1);\n                out.write(\"\\n\");\n                writeOutput(out, system_err.toString(), 2);\n            }\n\n            out.write(\"\\n<\/testsuite>\\n\");\n        }\n        finally {\n            out.close();\n        }\n    }","id":49817,"modified_method":"/**\n     * generate the XML report given what we know from all the test results\n     */\n    protected void generateReport(Class<?> clazz, Collection<ITestResult> results) throws IOException {\n\n        int num_failures=getFailures(results);\n        int num_skips=getSkips(results);\n        int num_errors=getErrors(results);\n        long total_time=getTotalTime(results);\n\n        String file_name=output_dir + File.separator + \"TEST-\" + clazz.getName();\n        if(suffix != null)\n            file_name=file_name + \"-\" + suffix;\n        file_name=file_name + \".xml\";\n        Writer out=new FileWriter(file_name, false); // don't append, overwrite\n        try {\n            out.write(XML_DEF + \"\\n\");\n\n            out.write(\"\\n<testsuite \" + \" failures=\\\"\"\n                      + num_failures\n                      + \"\\\" errors=\\\"\"\n                      + num_errors\n                      + \"\\\" skips=\\\"\"\n                      + num_skips\n                      + \"\\\" name=\\\"\"\n                      + clazz.getName());\n            if(suffix != null)\n                out.write(\" (\" + suffix + \")\");\n            out.write(\"\\\" tests=\\\"\" + results.size() + \"\\\" time=\\\"\" + (total_time / 1000.0) + \"\\\">\");\n\n            out.write(\"\\n<properties>\");\n            Properties props=System.getProperties();\n\n            for(Map.Entry<Object,Object> tmp: props.entrySet()) {\n                out.write(\"\\n    <property name=\\\"\" + tmp.getKey()\n                          + \"\\\"\"\n                          + \" value=\\\"\"\n                          + tmp.getValue()\n                          + \"\\\"/>\");\n            }\n            out.write(\"\\n<\/properties>\\n\");\n\n            for(ITestResult result: results) {\n                if(result == null)\n                    continue;\n\n                try {\n                    String testcase=writeTestCase(result,clazz,suffix);\n                    out.write(testcase);\n                }\n                catch(Throwable t) {\n                    t.printStackTrace();\n                }\n            }\n\n            Tuple<StringBuffer,StringBuffer> stdout=outputs.get(clazz);\n            if(stdout != null) {\n                StringBuffer system_out=stdout.getVal1();\n                StringBuffer system_err=stdout.getVal2();\n                writeOutput(out, system_out.toString(), 1);\n                out.write(\"\\n\");\n                writeOutput(out, system_err.toString(), 2);\n            }\n        }\n        finally {\n            out.write(\"\\n<\/testsuite>\\n\");\n            out.close();\n        }\n    }","commit_id":"030244e4ea97f68740992ae22b0929f8c7a48e72","url":"https://github.com/belaban/JGroups"},{"original_method":"private static int enabledMethods(ITestNGMethod[] testMethods) {\n        int count = testMethods.length;\n        for(ITestNGMethod testNGMethod:testMethods) {\n            Method m = testNGMethod.getMethod();\n            if(m.isAnnotationPresent(Test.class)){\n              Test annotation=m.getAnnotation(Test.class);  \n              if(!annotation.enabled()){\n                  count --;\n              }\n            }\n        }\n        return count;\n    }","id":49818,"modified_method":"private static int enabledMethods(ITestNGMethod[] testMethods) {\n        int count = testMethods.length;\n        for(ITestNGMethod testNGMethod:testMethods) {\n            Method m = testNGMethod.getConstructorOrMethod().getMethod();\n            if(m != null && m.isAnnotationPresent(Test.class)){\n              Test annotation=m.getAnnotation(Test.class);  \n              if(!annotation.enabled()){\n                  count --;\n              }\n            }\n        }\n        return count;\n    }","commit_id":"030244e4ea97f68740992ae22b0929f8c7a48e72","url":"https://github.com/belaban/JGroups"},{"original_method":"private static void writeOutput(FileWriter out, String s, int type) throws IOException {\n        if(s != null && s.length() > 0) {\n            out.write(\"\\n<\" + (type == 2? SYSTEM_ERR : SYSTEM_OUT) + \"><\" + CDATA + \"\\n\");\n            out.write(s);\n            out.write(\"\\n]]>\");\n            out.write(\"\\n<\/\" + (type == 2? SYSTEM_ERR : SYSTEM_OUT) + \">\");\n        }\n    }","id":49819,"modified_method":"private static void writeOutput(Writer out, String s, int type) throws IOException {\n        if(s != null && s.length() > 0) {\n            out.write(\"\\n<\" + (type == 2? SYSTEM_ERR : SYSTEM_OUT) + \"><\" + CDATA + \"\\n\");\n            out.write(s);\n            out.write(\"\\n]]>\");\n            out.write(\"\\n<\/\" + (type == 2? SYSTEM_ERR : SYSTEM_OUT) + \">\");\n        }\n    }","commit_id":"030244e4ea97f68740992ae22b0929f8c7a48e72","url":"https://github.com/belaban/JGroups"},{"original_method":"private static void writeFailure(String type,\n                                     Method method,\n                                     Throwable ex,\n                                     String msg,\n                                     FileWriter out) throws IOException {\n        Test annotation=method.getAnnotation(Test.class);\n        if(annotation != null && ex != null) {\n            Class<?>[] expected_exceptions=annotation.expectedExceptions();\n            for(int i=0;i < expected_exceptions.length;i++) {\n                Class<?> expected_exception=expected_exceptions[i];\n                if(expected_exception.equals(ex.getClass())) {\n                    return;\n                }\n            }\n        }\n\n        out.write(\"\\n<\" + type + \" type=\\\"\");\n        if(ex != null) {\n            out.write(ex.getClass().getName() + \"\\\" message=\\\"\" + escape(ex.getMessage()) + \"\\\">\");\n            printException(ex, out);\n        }\n        else\n            out.write(\"exception\\\" message=\\\"\" + msg + \"\\\">\");\n        out.write(\"\\n<\/\" + type + \">\");\n    }","id":49820,"modified_method":"private static String writeFailure(String type, Method method, Throwable ex, String msg) throws IOException {\n        Test annotation=method != null? method.getAnnotation(Test.class) : null;\n        if(annotation != null && ex != null) {\n            Class<?>[] expected_exceptions=annotation.expectedExceptions();\n            for(int i=0;i < expected_exceptions.length;i++) {\n                Class<?> expected_exception=expected_exceptions[i];\n                if(expected_exception.equals(ex.getClass())) {\n                    return null;\n                }\n            }\n        }\n\n        StringBuilder sb=new StringBuilder();\n        sb.append(\"\\n        <\" + type + \" type=\\\"\");\n        if(ex != null) {\n            sb.append(ex.getClass().getName() + \"\\\" message=\\\"\" + escape(ex.getMessage()) + \"\\\">\");\n            String ex_str=printException(ex);\n            if(ex_str != null)\n                sb.append(ex_str);\n        }\n        else\n            sb.append(\"exception\\\" message=\\\"\" + msg + \"\\\">\");\n        sb.append(\"\\n        <\/\" + type + \">\");\n        return sb.toString();\n    }","commit_id":"030244e4ea97f68740992ae22b0929f8c7a48e72","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\n\tprotected PortletPreferences doDeleteData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tif (!portletDataContext.addPrimaryKey(\n\t\t\t\tDDLPortletDataHandler.class, \"deleteData\")) {\n\n\t\t\tDDLRecordSetLocalServiceUtil.deleteRecordSets(\n\t\t\t\tportletDataContext.getScopeGroupId());\n\t\t}\n\n\t\treturn portletPreferences;\n\t}","id":49821,"modified_method":"@Override\n\tprotected PortletPreferences doDeleteData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tif (portletDataContext.addPrimaryKey(\n\t\t\t\tDDLPortletDataHandler.class, \"deleteData\")) {\n\n\t\t\treturn portletPreferences;\n\t\t}\n\n\t\tDDLRecordSetLocalServiceUtil.deleteRecordSets(\n\t\t\tportletDataContext.getScopeGroupId());\n\n\t\treturn portletPreferences;\n\t}","commit_id":"0a4e8430d1bf04f6cb8d04665fc9414c993af2aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected String doExportData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tportletDataContext.addPermissions(\n\t\t\t\"com.liferay.portlet.dynamicdatalist\",\n\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tDocument document = SAXReaderUtil.createDocument();\n\n\t\tElement rootElement = document.addElement(\"ddl-data\");\n\n\t\tElement recordSetsElement = rootElement.addElement(\"record-sets\");\n\n\t\tList<DDLRecordSet> recordSets =\n\t\t\tDDLRecordSetLocalServiceUtil.getRecordSets(\n\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tfor (DDLRecordSet recordSet : recordSets) {\n\t\t\tif (portletDataContext.isWithinDateRange(\n\t\t\t\t\trecordSet.getModifiedDate())) {\n\n\t\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\t\tportletDataContext, recordSetsElement, recordSet);\n\t\t\t}\n\t\t}\n\n\t\treturn document.formattedString();\n\t}","id":49822,"modified_method":"@Override\n\tprotected String doExportData(\n\t\t\tfinal PortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tportletDataContext.addPermissions(\n\t\t\t\"com.liferay.portlet.dynamicdatalist\",\n\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tDocument document = SAXReaderUtil.createDocument();\n\n\t\tElement rootElement = document.addElement(\"ddl-data\");\n\n\t\tfinal Element recordSetsElement = rootElement.addElement(\"record-sets\");\n\n\t\tActionableDynamicQuery actionableDynamicQuery =\n\t\t\tnew DDLRecordSetActionableDynamicQuery() {\n\n\t\t\t\t@Override\n\t\t\t\tprotected void addCriteria(DynamicQuery dynamicQuery) {\n\t\t\t\t\tportletDataContext.addDateRangeCriteria(\n\t\t\t\t\t\tdynamicQuery, \"modifiedDate\");\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void performAction(Object object)\n\t\t\t\t\tthrows PortalException {\n\n\t\t\t\t\tDDLRecordSet recordSet = (DDLRecordSet)object;\n\n\t\t\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\t\t\tportletDataContext, recordSetsElement, recordSet);\n\t\t\t\t}\n\n\t\t};\n\n\t\tactionableDynamicQuery.setGroupId(portletDataContext.getScopeGroupId());\n\n\t\tactionableDynamicQuery.performActions();\n\n\t\treturn document.formattedString();\n\t}","commit_id":"0a4e8430d1bf04f6cb8d04665fc9414c993af2aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected PortletPreferences doDeleteData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tif (!portletDataContext.addPrimaryKey(\n\t\t\t\tAdminPortletDataHandler.class, \"deleteData\")) {\n\n\t\t\tKBArticleLocalServiceUtil.deleteGroupKBArticles(\n\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\t\tKBTemplateLocalServiceUtil.deleteGroupKBTemplates(\n\t\t\t\tportletDataContext.getScopeGroupId());\n\t\t}\n\n\t\treturn null;\n\t}","id":49823,"modified_method":"@Override\n\tprotected PortletPreferences doDeleteData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tif (portletDataContext.addPrimaryKey(\n\t\t\t\tAdminPortletDataHandler.class, \"deleteData\")) {\n\n\t\t\treturn portletPreferences;\n\t\t}\n\n\t\tKBArticleLocalServiceUtil.deleteGroupKBArticles(\n\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tKBTemplateLocalServiceUtil.deleteGroupKBTemplates(\n\t\t\tportletDataContext.getScopeGroupId());\n\n\t\treturn portletPreferences;\n\t}","commit_id":"527536766106ce4b107d73f6e108dedf8363864f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected PortletPreferences doDeleteData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tlong companyId = portletDataContext.getCompanyId();\n\n\t\tList<WSRPProducer> wsrpProducers =\n\t\t\tWSRPProducerLocalServiceUtil.getWSRPProducers(\n\t\t\t\tcompanyId, QueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (WSRPProducer wsrpProducer : wsrpProducers) {\n\t\t\tWSRPProducerLocalServiceUtil.deleteWSRPProducer(wsrpProducer);\n\t\t}\n\n\t\tList<WSRPConsumer> wsrpConsumers =\n\t\t\tWSRPConsumerLocalServiceUtil.getWSRPConsumers(\n\t\t\t\tcompanyId, QueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (WSRPConsumer wsrpConsumer : wsrpConsumers) {\n\t\t\tWSRPConsumerLocalServiceUtil.deleteWSRPConsumer(wsrpConsumer);\n\t\t}\n\n\t\treturn null;\n\t}","id":49824,"modified_method":"@Override\n\tprotected PortletPreferences doDeleteData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tlong companyId = portletDataContext.getCompanyId();\n\n\t\tList<WSRPProducer> wsrpProducers =\n\t\t\tWSRPProducerLocalServiceUtil.getWSRPProducers(\n\t\t\t\tcompanyId, QueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (WSRPProducer wsrpProducer : wsrpProducers) {\n\t\t\tWSRPProducerLocalServiceUtil.deleteWSRPProducer(wsrpProducer);\n\t\t}\n\n\t\tList<WSRPConsumer> wsrpConsumers =\n\t\t\tWSRPConsumerLocalServiceUtil.getWSRPConsumers(\n\t\t\t\tcompanyId, QueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (WSRPConsumer wsrpConsumer : wsrpConsumers) {\n\t\t\tWSRPConsumerLocalServiceUtil.deleteWSRPConsumer(wsrpConsumer);\n\t\t}\n\n\t\treturn portletPreferences;\n\t}","commit_id":"527536766106ce4b107d73f6e108dedf8363864f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected PortletPreferences doDeleteData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tList<Gadget> gadgets = GadgetLocalServiceUtil.getGadgets(\n\t\t\tportletDataContext.getCompanyId(), QueryUtil.ALL_POS,\n\t\t\tQueryUtil.ALL_POS);\n\n\t\tfor (Gadget gadget : gadgets) {\n\t\t\tGadgetLocalServiceUtil.deleteGadget(gadget);\n\t\t}\n\n\t\treturn null;\n\t}","id":49825,"modified_method":"@Override\n\tprotected PortletPreferences doDeleteData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tList<Gadget> gadgets = GadgetLocalServiceUtil.getGadgets(\n\t\t\tportletDataContext.getCompanyId(), QueryUtil.ALL_POS,\n\t\t\tQueryUtil.ALL_POS);\n\n\t\tfor (Gadget gadget : gadgets) {\n\t\t\tGadgetLocalServiceUtil.deleteGadget(gadget);\n\t\t}\n\n\t\treturn portletPreferences;\n\t}","commit_id":"527536766106ce4b107d73f6e108dedf8363864f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected PortletPreferences doDeleteData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tif (!portletDataContext.addPrimaryKey(\n\t\t\t\tCalendarPortletDataHandler.class, \"deleteData\")) {\n\n\t\t\tCalendarResourceLocalServiceUtil.deleteCalendarResources(\n\t\t\t\tportletDataContext.getScopeGroupId());\n\t\t}\n\n\t\treturn portletPreferences;\n\t}","id":49826,"modified_method":"@Override\n\tprotected PortletPreferences doDeleteData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tif (portletDataContext.addPrimaryKey(\n\t\t\t\tCalendarPortletDataHandler.class, \"deleteData\")) {\n\n\t\t\treturn portletPreferences;\n\t\t}\n\n\t\tCalendarResourceLocalServiceUtil.deleteCalendarResources(\n\t\t\tportletDataContext.getScopeGroupId());\n\n\t\treturn portletPreferences;\n\t}","commit_id":"527536766106ce4b107d73f6e108dedf8363864f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tprotected PortletPreferences doDeleteData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tif (portletPreferences == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tportletPreferences.setValue(\"formDDMTemplateId\", StringPool.BLANK);\n\t\tportletPreferences.setValue(\n\t\t\t\"multipleSubmissions\", Boolean.FALSE.toString());\n\t\tportletPreferences.setValue(\"recordSetId\", StringPool.BLANK);\n\n\t\treturn portletPreferences;\n\t}","id":49827,"modified_method":"@Override\n\tprotected PortletPreferences doDeleteData(\n\t\t\tPortletDataContext portletDataContext, String portletId,\n\t\t\tPortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tif (portletPreferences == null) {\n\t\t\treturn portletPreferences;\n\t\t}\n\n\t\tportletPreferences.setValue(\"formDDMTemplateId\", StringPool.BLANK);\n\t\tportletPreferences.setValue(\n\t\t\t\"multipleSubmissions\", Boolean.FALSE.toString());\n\t\tportletPreferences.setValue(\"recordSetId\", StringPool.BLANK);\n\n\t\treturn portletPreferences;\n\t}","commit_id":"527536766106ce4b107d73f6e108dedf8363864f","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"private static void _addGroupsBreadcrumbEntries(\n\t\t\tList<BreadcrumbEntry> breadcrumbEntries, ThemeDisplay themeDisplay,\n\t\t\tLayoutSet layoutSet, boolean includeParentGroups)\n\t\tthrows Exception {\n\n\t\tGroup group = layoutSet.getGroup();\n\n\t\tif (group.isControlPanel()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (includeParentGroups) {\n\t\t\tLayoutSet parentLayoutSet = _getParentLayoutSet(layoutSet);\n\n\t\t\tif (parentLayoutSet != null) {\n\t\t\t\t_addGroupsBreadcrumbEntries(\n\t\t\t\t\tbreadcrumbEntries, themeDisplay, parentLayoutSet, true);\n\t\t\t}\n\t\t}\n\n\t\tint layoutsPageCount = 0;\n\n\t\tif (layoutSet.isPrivateLayout()) {\n\t\t\tlayoutsPageCount = group.getPrivateLayoutsPageCount();\n\t\t}\n\t\telse {\n\t\t\tlayoutsPageCount = group.getPublicLayoutsPageCount();\n\t\t}\n\n\t\tif ((layoutsPageCount > 0) && !group.isGuest()) {\n\t\t\tString layoutSetFriendlyURL = PortalUtil.getLayoutSetFriendlyURL(\n\t\t\t\tlayoutSet, themeDisplay);\n\n\t\t\tif (themeDisplay.isAddSessionIdToURL()) {\n\t\t\t\tlayoutSetFriendlyURL = PortalUtil.getURLWithSessionId(\n\t\t\t\t\tlayoutSetFriendlyURL, themeDisplay.getSessionId());\n\t\t\t}\n\n\t\t\tBreadcrumbEntry breadcrumbEntry = new BreadcrumbEntry();\n\n\t\t\tbreadcrumbEntry.setTitle(\n\t\t\t\tgroup.getDescriptiveName(themeDisplay.getLocale()));\n\t\t\tbreadcrumbEntry.setURL(layoutSetFriendlyURL);\n\n\t\t\tbreadcrumbEntries.add(breadcrumbEntry);\n\t\t}\n\t}","id":49828,"modified_method":"private static void _addGroupsBreadcrumbEntries(\n\t\t\tList<BreadcrumbEntry> breadcrumbEntries, ThemeDisplay themeDisplay,\n\t\t\tLayoutSet layoutSet, boolean includeParentGroups)\n\t\tthrows Exception {\n\n\t\tGroup group = layoutSet.getGroup();\n\n\t\tif (group.isControlPanel() || group.isUserPersonalPanel()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (includeParentGroups) {\n\t\t\tLayoutSet parentLayoutSet = _getParentLayoutSet(layoutSet);\n\n\t\t\tif (parentLayoutSet != null) {\n\t\t\t\t_addGroupsBreadcrumbEntries(\n\t\t\t\t\tbreadcrumbEntries, themeDisplay, parentLayoutSet, true);\n\t\t\t}\n\t\t}\n\n\t\tint layoutsPageCount = 0;\n\n\t\tif (layoutSet.isPrivateLayout()) {\n\t\t\tlayoutsPageCount = group.getPrivateLayoutsPageCount();\n\t\t}\n\t\telse {\n\t\t\tlayoutsPageCount = group.getPublicLayoutsPageCount();\n\t\t}\n\n\t\tif ((layoutsPageCount > 0) && !group.isGuest()) {\n\t\t\tString layoutSetFriendlyURL = PortalUtil.getLayoutSetFriendlyURL(\n\t\t\t\tlayoutSet, themeDisplay);\n\n\t\t\tif (themeDisplay.isAddSessionIdToURL()) {\n\t\t\t\tlayoutSetFriendlyURL = PortalUtil.getURLWithSessionId(\n\t\t\t\t\tlayoutSetFriendlyURL, themeDisplay.getSessionId());\n\t\t\t}\n\n\t\t\tBreadcrumbEntry breadcrumbEntry = new BreadcrumbEntry();\n\n\t\t\tbreadcrumbEntry.setTitle(\n\t\t\t\tgroup.getDescriptiveName(themeDisplay.getLocale()));\n\t\t\tbreadcrumbEntry.setURL(layoutSetFriendlyURL);\n\n\t\t\tbreadcrumbEntries.add(breadcrumbEntry);\n\t\t}\n\t}","commit_id":"4f107775e4a65dabfd2ca3dc21a3eff43dc52275","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ThemeDisplay initThemeDisplay(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tHttpSession session = request.getSession();\n\n\t\t// Company\n\n\t\tCompany company = PortalUtil.getCompany(request);\n\n\t\tlong companyId = company.getCompanyId();\n\n\t\t// CDN host\n\n\t\tString cdnHost = PortalUtil.getCDNHost(request);\n\n\t\tString dynamicResourcesCDNHost = StringPool.BLANK;\n\n\t\tboolean cdnDynamicResourceEnabled =\n\t\t\tPortalUtil.isCDNDynamicResourcesEnabled(request);\n\n\t\tif (cdnDynamicResourceEnabled) {\n\t\t\tdynamicResourcesCDNHost = cdnHost;\n\t\t}\n\n\t\t// Portal URL\n\n\t\tString portalURL = PortalUtil.getPortalURL(request);\n\n\t\t// Paths\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\t\tString friendlyURLPrivateGroupPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateGroup();\n\t\tString friendlyURLPrivateUserPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateUser();\n\t\tString friendlyURLPublicPath = PortalUtil.getPathFriendlyURLPublic();\n\t\tString imagePath = dynamicResourcesCDNHost.concat(\n\t\t\tPortalUtil.getPathImage());\n\t\tString mainPath = PortalUtil.getPathMain();\n\n\t\tString i18nPath = (String)request.getAttribute(WebKeys.I18N_PATH);\n\n\t\tif (Validator.isNotNull(i18nPath)) {\n\t\t\tif (Validator.isNotNull(contextPath)) {\n\t\t\t\tString i18nContextPath = contextPath.concat(i18nPath);\n\n\t\t\t\tfriendlyURLPrivateGroupPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateGroupPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPrivateUserPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateUserPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPublicPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPublicPath, contextPath, i18nContextPath);\n\t\t\t\tmainPath = StringUtil.replaceFirst(\n\t\t\t\t\tmainPath, contextPath, i18nContextPath);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfriendlyURLPrivateGroupPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateGroupPath);\n\t\t\t\tfriendlyURLPrivateUserPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateUserPath);\n\t\t\t\tfriendlyURLPublicPath = i18nPath.concat(friendlyURLPublicPath);\n\t\t\t\tmainPath = i18nPath.concat(mainPath);\n\t\t\t}\n\t\t}\n\n\t\t// Company logo\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(imagePath);\n\t\tsb.append(\"/company_logo?img_id=\");\n\t\tsb.append(company.getLogoId());\n\t\tsb.append(\"&t=\");\n\t\tsb.append(WebServerServletTokenUtil.getToken(company.getLogoId()));\n\n\t\tString companyLogo = sb.toString();\n\n\t\tint companyLogoHeight = 0;\n\t\tint companyLogoWidth = 0;\n\n\t\tImage companyLogoImage = null;\n\n\t\tif (company.getLogoId() > 0) {\n\t\t\tcompanyLogoImage = ImageLocalServiceUtil.getCompanyLogo(\n\t\t\t\tcompany.getLogoId());\n\t\t}\n\t\telse {\n\t\t\tcompanyLogoImage = ImageToolUtil.getDefaultCompanyLogo();\n\t\t}\n\n\t\tif (companyLogoImage != null) {\n\t\t\tcompanyLogoHeight = companyLogoImage.getHeight();\n\t\t\tcompanyLogoWidth = companyLogoImage.getWidth();\n\t\t}\n\n\t\tString realCompanyLogo = companyLogo;\n\t\tint realCompanyLogoHeight = companyLogoHeight;\n\t\tint realCompanyLogoWidth = companyLogoWidth;\n\n\t\t// User\n\n\t\tUser user = null;\n\n\t\ttry {\n\t\t\tuser = PortalUtil.initUser(request);\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t\treturn null;\n\t\t}\n\n\t\tboolean signedIn = !user.isDefaultUser();\n\n\t\tif (PropsValues.BROWSER_CACHE_DISABLED ||\n\t\t\t(PropsValues.BROWSER_CACHE_SIGNED_IN_DISABLED && signedIn)) {\n\n\t\t\tresponse.setDateHeader(HttpHeaders.EXPIRES, 0);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.CACHE_CONTROL,\n\t\t\t\tHttpHeaders.CACHE_CONTROL_NO_CACHE_VALUE);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.PRAGMA, HttpHeaders.PRAGMA_NO_CACHE_VALUE);\n\t\t}\n\n\t\tUser realUser = user;\n\n\t\tLong realUserId = (Long)session.getAttribute(WebKeys.USER_ID);\n\n\t\tif (realUserId != null) {\n\t\t\tif (user.getUserId() != realUserId.longValue()) {\n\t\t\t\trealUser = UserLocalServiceUtil.getUserById(\n\t\t\t\t\trealUserId.longValue());\n\t\t\t}\n\t\t}\n\n\t\tString doAsUserId = ParamUtil.getString(request, \"doAsUserId\");\n\t\tString doAsUserLanguageId = ParamUtil.getString(\n\t\t\trequest, \"doAsUserLanguageId\");\n\t\tlong doAsGroupId = ParamUtil.getLong(request, \"doAsGroupId\");\n\n\t\tlong refererGroupId = ParamUtil.getLong(request, \"refererGroupId\");\n\n\t\tlong refererPlid = ParamUtil.getLong(request, \"refererPlid\");\n\n\t\tif (LayoutLocalServiceUtil.fetchLayout(refererPlid) == null) {\n\t\t\trefererPlid = 0;\n\t\t}\n\n\t\tString controlPanelCategory = ParamUtil.getString(\n\t\t\trequest, \"controlPanelCategory\");\n\n\t\t// Permission checker\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tPermissionCheckerFactoryUtil.create(user);\n\n\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t// Cookie support\n\n\t\ttry {\n\n\t\t\t// LEP-4069\n\n\t\t\tCookieKeys.validateSupportCookie(request);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tCookieKeys.addSupportCookie(request, response);\n\t\t}\n\n\t\t// Time zone\n\n\t\tTimeZone timeZone = user.getTimeZone();\n\n\t\tif (timeZone == null) {\n\t\t\ttimeZone = company.getTimeZone();\n\t\t}\n\n\t\t// Layouts\n\n\t\tif (signedIn) {\n\t\t\tupdateUserLayouts(user);\n\t\t}\n\n\t\tLayout layout = null;\n\t\tList<Layout> layouts = null;\n\n\t\tlong plid = ParamUtil.getLong(request, \"p_l_id\");\n\n\t\tboolean viewableSourceGroup = true;\n\n\t\tif (plid > 0) {\n\t\t\tlayout = LayoutLocalServiceUtil.getLayout(plid);\n\t\t}\n\t\telse {\n\t\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\t\t\tboolean privateLayout = ParamUtil.getBoolean(\n\t\t\t\trequest, \"privateLayout\");\n\t\t\tlong layoutId = ParamUtil.getLong(request, \"layoutId\");\n\n\t\t\tif ((groupId > 0) && (layoutId > 0)) {\n\t\t\t\tlayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tgroupId, privateLayout, layoutId);\n\t\t\t}\n\t\t}\n\n\t\tif (layout != null) {\n\t\t\tlong sourceGroupId = ParamUtil.getLong(request, \"p_v_l_s_g_id\");\n\n\t\t\tif ((sourceGroupId > 0) && (sourceGroupId != layout.getGroupId())) {\n\t\t\t\tGroup sourceGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\t\tsourceGroupId);\n\n\t\t\t\tif (layout.isPublicLayout() ||\n\t\t\t\t\tSitesUtil.isUserGroupLayoutSetViewable(\n\t\t\t\t\t\tpermissionChecker, layout.getGroup())) {\n\n\t\t\t\t\tlayout = new VirtualLayout(layout, sourceGroup);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tviewableSourceGroup = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString ppid = ParamUtil.getString(request, \"p_p_id\");\n\n\t\tBoolean redirectToDefaultLayout = (Boolean)request.getAttribute(\n\t\t\tWebKeys.REDIRECT_TO_DEFAULT_LAYOUT);\n\n\t\tif (redirectToDefaultLayout == null) {\n\t\t\tredirectToDefaultLayout = Boolean.FALSE;\n\t\t}\n\n\t\tif (layout != null) {\n\t\t\tGroup group = layout.getGroup();\n\n\t\t\tif (!signedIn && PropsValues.AUTH_FORWARD_BY_REDIRECT) {\n\t\t\t\trequest.setAttribute(WebKeys.REQUESTED_LAYOUT, layout);\n\t\t\t}\n\n\t\t\tif ((Validator.isNull(controlPanelCategory) ||\n\t\t\t\t controlPanelCategory.equals(PortletCategoryKeys.MY) ||\n\t\t\t\t controlPanelCategory.equals(PortletCategoryKeys.PORTLET)) &&\n\t\t\t\tValidator.isNotNull(ppid) &&\n\t\t\t\t(LiferayWindowState.isPopUp(request) ||\n\t\t\t\t LiferayWindowState.isExclusive(request))) {\n\n\t\t\t\tcontrolPanelCategory = PortletCategoryKeys.PORTLET;\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(ppid)) {\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tcompanyId, ppid);\n\n\t\t\t\tString portletControlPanelEntryCategory =\n\t\t\t\t\tportlet.getControlPanelEntryCategory();\n\n\t\t\t\tif (!controlPanelCategory.startsWith(\n\t\t\t\t\t\tPortletCategoryKeys.CURRENT_SITE) &&\n\t\t\t\t\tportletControlPanelEntryCategory.startsWith(\n\t\t\t\t\t\tPortletCategoryKeys.SITE_ADMINISTRATION)) {\n\n\t\t\t\t\tportletControlPanelEntryCategory =\n\t\t\t\t\t\tPortletCategoryKeys.SITES;\n\t\t\t\t}\n\n\t\t\t\tif (!controlPanelCategory.startsWith(\n\t\t\t\t\t\tPortletCategoryKeys.CURRENT_SITE) &&\n\t\t\t\t\tValidator.isNotNull(portletControlPanelEntryCategory)) {\n\n\t\t\t\t\tcontrolPanelCategory = portletControlPanelEntryCategory;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean viewableGroup = hasAccessPermission(\n\t\t\t\tpermissionChecker, layout, doAsGroupId, controlPanelCategory,\n\t\t\t\ttrue);\n\t\t\tboolean viewableStaging =\n\t\t\t\t!group.isControlPanel() &&\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, group, ActionKeys.VIEW_STAGING);\n\n\t\t\tif (viewableStaging) {\n\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\t\t\t}\n\t\t\telse if ((!viewableGroup || !viewableSourceGroup) &&\n\t\t\t\t\t group.isStagingGroup()) {\n\n\t\t\t\tlayout = null;\n\t\t\t}\n\t\t\telse if (!isLoginRequest(request) &&\n\t\t\t\t\t (!viewableGroup || !viewableSourceGroup ||\n\t\t\t\t\t  (!redirectToDefaultLayout &&\n\t\t\t\t\t   !hasAccessPermission(\n\t\t\t\t\t\t   permissionChecker, layout, doAsGroupId,\n\t\t\t\t\t\t   controlPanelCategory, false)))) {\n\n\t\t\t\tif (user.isDefaultUser() &&\n\t\t\t\t\tPropsValues.AUTH_LOGIN_PROMPT_ENABLED) {\n\n\t\t\t\t\tthrow new PrincipalException(\"User is not authenticated\");\n\t\t\t\t}\n\n\t\t\t\tsb = new StringBundler(6);\n\n\t\t\t\tsb.append(\"User \");\n\t\t\t\tsb.append(user.getUserId());\n\t\t\t\tsb.append(\" is not allowed to access the \");\n\t\t\t\tsb.append(layout.isPrivateLayout() ? \"private\": \"public\");\n\t\t\t\tsb.append(\" pages of group \");\n\t\t\t\tsb.append(layout.getGroupId());\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(sb.toString());\n\t\t\t\t}\n\n\t\t\t\tthrow new NoSuchLayoutException(sb.toString());\n\t\t\t}\n\t\t\telse if (isLoginRequest(request) && !viewableGroup) {\n\t\t\t\tlayout = null;\n\t\t\t}\n\t\t\telse if (group.isLayoutPrototype()) {\n\t\t\t\tlayouts = new ArrayList<>();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\t\t\tif (!group.isControlPanel()) {\n\t\t\t\t\tdoAsGroupId = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tList<Layout> unfilteredLayouts = layouts;\n\n\t\tif (layout == null) {\n\t\t\tObject[] defaultLayout = getDefaultLayout(request, user, signedIn);\n\n\t\t\tlayout = (Layout)defaultLayout[0];\n\t\t\tlayouts = (List<Layout>)defaultLayout[1];\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT_DEFAULT, Boolean.TRUE);\n\t\t}\n\n\t\tObject[] viewableLayouts = getViewableLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts, doAsGroupId,\n\t\t\tcontrolPanelCategory);\n\n\t\tString layoutSetLogo = null;\n\n\t\tlayout = (Layout)viewableLayouts[0];\n\t\tlayouts = (List<Layout>)viewableLayouts[1];\n\n\t\tGroup group = null;\n\n\t\tif (layout != null) {\n\t\t\tgroup = layout.getGroup();\n\n\t\t\tif (!group.isControlPanel()) {\n\t\t\t\trememberVisitedGroupIds(request, group.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\tLayoutTypePortlet layoutTypePortlet = null;\n\n\t\tlayouts = mergeAdditionalLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts, doAsGroupId,\n\t\t\tcontrolPanelCategory);\n\n\t\tLayoutSet layoutSet = null;\n\n\t\tboolean hasAddLayoutLayoutPermission = false;\n\t\tboolean hasCustomizeLayoutPermission = false;\n\t\tboolean hasDeleteLayoutPermission = false;\n\t\tboolean hasUpdateLayoutPermission = false;\n\n\t\tboolean customizedView = SessionParamUtil.getBoolean(\n\t\t\trequest, \"customized_view\", true);\n\n\t\tif (layout != null) {\n\t\t\tLayoutType layoutType = layout.getLayoutType();\n\n\t\t\tLayoutTypeAccessPolicy layoutTypeAccessPolicy =\n\t\t\t\tlayoutType.getLayoutTypeAccessPolicy();\n\n\t\t\thasAddLayoutLayoutPermission =\n\t\t\t\tlayoutTypeAccessPolicy.isAddLayoutAllowed(\n\t\t\t\t\tpermissionChecker, layout);\n\t\t\thasCustomizeLayoutPermission =\n\t\t\t\tlayoutTypeAccessPolicy.isCustomizeLayoutAllowed(\n\t\t\t\t\tpermissionChecker, layout);\n\t\t\thasDeleteLayoutPermission =\n\t\t\t\tlayoutTypeAccessPolicy.isDeleteLayoutAllowed(\n\t\t\t\t\tpermissionChecker, layout);\n\t\t\thasUpdateLayoutPermission =\n\t\t\t\tlayoutTypeAccessPolicy.isUpdateLayoutAllowed(\n\t\t\t\t\tpermissionChecker, layout);\n\n\t\t\tlayoutSet = layout.getLayoutSet();\n\n\t\t\tif (company.isSiteLogo()) {\n\t\t\t\tlong logoId = 0;\n\n\t\t\t\tif (layoutSet.isLogo()) {\n\t\t\t\t\tlogoId = layoutSet.getLogoId();\n\n\t\t\t\t\tif (logoId == 0) {\n\t\t\t\t\t\tlogoId = layoutSet.getLiveLogoId();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLayoutSet siblingLayoutSet =\n\t\t\t\t\t\tLayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\t\t\tlayout.getGroupId(), !layout.isPrivateLayout());\n\n\t\t\t\t\tif (siblingLayoutSet.isLogo()) {\n\t\t\t\t\t\tlogoId = siblingLayoutSet.getLogoId();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (logoId > 0) {\n\t\t\t\t\tsb = new StringBundler(5);\n\n\t\t\t\t\tsb.append(imagePath);\n\t\t\t\t\tsb.append(\"/layout_set_logo?img_id=\");\n\t\t\t\t\tsb.append(logoId);\n\t\t\t\t\tsb.append(\"&t=\");\n\t\t\t\t\tsb.append(WebServerServletTokenUtil.getToken(logoId));\n\n\t\t\t\t\tlayoutSetLogo = sb.toString();\n\n\t\t\t\t\tImage layoutSetLogoImage =\n\t\t\t\t\t\tImageLocalServiceUtil.getCompanyLogo(logoId);\n\n\t\t\t\t\tcompanyLogo = layoutSetLogo;\n\t\t\t\t\tcompanyLogoHeight = layoutSetLogoImage.getHeight();\n\t\t\t\t\tcompanyLogoWidth = layoutSetLogoImage.getWidth();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplid = layout.getPlid();\n\n\t\t\t// Updates to shared layouts are not reflected until the next time\n\t\t\t// the user logs in because group layouts are cached in the session\n\n\t\t\tlayout = (Layout)layout.clone();\n\n\t\t\tlayoutTypePortlet = (LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\tboolean customizable = layoutTypePortlet.isCustomizable();\n\n\t\t\tif (!customizable ||\n\t\t\t\tgroup.isLayoutPrototype() || group.isLayoutSetPrototype() ||\n\t\t\t\tgroup.isStagingGroup()) {\n\n\t\t\t\tcustomizedView = false;\n\t\t\t}\n\n\t\t\tlayoutTypePortlet.setCustomizedView(customizedView);\n\t\t\tlayoutTypePortlet.setUpdatePermission(hasUpdateLayoutPermission);\n\n\t\t\tif (signedIn && customizable && customizedView &&\n\t\t\t\thasCustomizeLayoutPermission) {\n\n\t\t\t\tPortalPreferences portalPreferences =\n\t\t\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(\n\t\t\t\t\t\tuser.getUserId(), true);\n\n\t\t\t\tlayoutTypePortlet.setPortalPreferences(portalPreferences);\n\t\t\t}\n\n\t\t\tLayoutClone layoutClone = LayoutCloneFactory.getInstance();\n\n\t\t\tif (layoutClone != null) {\n\t\t\t\tString typeSettings = layoutClone.get(request, plid);\n\n\t\t\t\tif (typeSettings != null) {\n\t\t\t\t\tUnicodeProperties typeSettingsProperties =\n\t\t\t\t\t\tnew UnicodeProperties(true);\n\n\t\t\t\t\ttypeSettingsProperties.load(typeSettings);\n\n\t\t\t\t\tString stateMax = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MAX);\n\t\t\t\t\tString stateMin = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MIN);\n\t\t\t\t\tString modeAbout = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_ABOUT);\n\t\t\t\t\tString modeConfig = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_CONFIG);\n\t\t\t\t\tString modeEdit = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT);\n\t\t\t\t\tString modeEditDefaults =\n\t\t\t\t\t\ttypeSettingsProperties.getProperty(\n\t\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_DEFAULTS);\n\t\t\t\t\tString modeEditGuest = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_GUEST);\n\t\t\t\t\tString modeHelp = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_HELP);\n\t\t\t\t\tString modePreview = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PREVIEW);\n\t\t\t\t\tString modePrint = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PRINT);\n\n\t\t\t\t\tlayoutTypePortlet.setStateMax(stateMax);\n\t\t\t\t\tlayoutTypePortlet.setStateMin(stateMin);\n\t\t\t\t\tlayoutTypePortlet.setModeAbout(modeAbout);\n\t\t\t\t\tlayoutTypePortlet.setModeConfig(modeConfig);\n\t\t\t\t\tlayoutTypePortlet.setModeEdit(modeEdit);\n\t\t\t\t\tlayoutTypePortlet.setModeEditDefaults(modeEditDefaults);\n\t\t\t\t\tlayoutTypePortlet.setModeEditGuest(modeEditGuest);\n\t\t\t\t\tlayoutTypePortlet.setModeHelp(modeHelp);\n\t\t\t\t\tlayoutTypePortlet.setModePreview(modePreview);\n\t\t\t\t\tlayoutTypePortlet.setModePrint(modePrint);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT, layout);\n\t\t\trequest.setAttribute(WebKeys.LAYOUTS, layouts);\n\t\t}\n\n\t\t// Locale\n\n\t\tString i18nLanguageId = (String)request.getAttribute(\n\t\t\tWebKeys.I18N_LANGUAGE_ID);\n\n\t\tLocale locale = PortalUtil.getLocale(request, response, true);\n\n\t\t// Scope\n\n\t\tlong scopeGroupId = PortalUtil.getScopeGroupId(request);\n\n\t\tif (group.isInheritContent()) {\n\t\t\tscopeGroupId = group.getParentGroupId();\n\t\t}\n\n\t\tif ((scopeGroupId <= 0) && (doAsGroupId > 0)) {\n\t\t\tscopeGroupId = doAsGroupId;\n\t\t}\n\n\t\tlong siteGroupId = 0;\n\n\t\tif (layout != null) {\n\t\t\tif (layout.isTypeControlPanel()) {\n\t\t\t\tsiteGroupId = PortalUtil.getSiteGroupId(scopeGroupId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsiteGroupId = PortalUtil.getSiteGroupId(layout.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\t// Theme and color scheme\n\n\t\tTheme theme = null;\n\t\tColorScheme colorScheme = null;\n\n\t\tboolean wapTheme = BrowserSnifferUtil.isWap(request);\n\n\t\tif ((layout != null) &&\n\t\t\t(group.isControlPanel() || group.isUserPersonalPanel())) {\n\n\t\t\tString themeId = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsKeys.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID);\n\t\t\tString colorSchemeId =\n\t\t\t\tColorSchemeFactoryUtil.getDefaultRegularColorSchemeId();\n\n\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\tcompanyId, themeId, wapTheme);\n\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, wapTheme);\n\n\t\t\tif (!wapTheme && theme.isWapTheme()) {\n\t\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tPropsValues.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID, false);\n\t\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, false);\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.THEME, theme);\n\t\t\trequest.setAttribute(WebKeys.COLOR_SCHEME, colorScheme);\n\t\t}\n\n\t\tboolean themeCssFastLoad = PropsValues.THEME_CSS_FAST_LOAD;\n\n\t\tif (PropsValues.THEME_CSS_FAST_LOAD_CHECK_REQUEST_PARAMETER) {\n\t\t\tthemeCssFastLoad = SessionParamUtil.getBoolean(\n\t\t\t\trequest, \"css_fast_load\", PropsValues.THEME_CSS_FAST_LOAD);\n\t\t}\n\n\t\tboolean themeImagesFastLoad = PropsValues.THEME_IMAGES_FAST_LOAD;\n\n\t\tif (PropsValues.THEME_IMAGES_FAST_LOAD_CHECK_REQUEST_PARAMETER) {\n\t\t\tSessionParamUtil.getBoolean(\n\t\t\t\trequest, \"images_fast_load\",\n\t\t\t\tPropsValues.THEME_IMAGES_FAST_LOAD);\n\t\t}\n\n\t\tboolean themeJsBarebone = PropsValues.JAVASCRIPT_BAREBONE_ENABLED;\n\n\t\tif (themeJsBarebone) {\n\t\t\tif (signedIn) {\n\t\t\t\tthemeJsBarebone = false;\n\t\t\t}\n\t\t}\n\n\t\tboolean themeJsFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"js_fast_load\", PropsValues.JAVASCRIPT_FAST_LOAD);\n\n\t\tString lifecycle = ParamUtil.getString(request, \"p_p_lifecycle\", \"0\");\n\n\t\tlifecycle = ParamUtil.getString(request, \"p_t_lifecycle\", lifecycle);\n\n\t\tboolean isolated = ParamUtil.getBoolean(request, \"p_p_isolated\");\n\n\t\tString facebookCanvasPageURL = (String)request.getAttribute(\n\t\t\tWebKeys.FACEBOOK_CANVAS_PAGE_URL);\n\n\t\tboolean widget = false;\n\n\t\tBoolean widgetObj = (Boolean)request.getAttribute(WebKeys.WIDGET);\n\n\t\tif (widgetObj != null) {\n\t\t\twidget = widgetObj.booleanValue();\n\t\t}\n\n\t\t// Theme display\n\n\t\tThemeDisplay themeDisplay = ThemeDisplayFactory.create();\n\n\t\tthemeDisplay.setRequest(request);\n\n\t\t// Set attributes first that other methods (getCDNBaseURL and\n\t\t// setLookAndFeel) depend on\n\n\t\tthemeDisplay.setCDNHost(cdnHost);\n\t\tthemeDisplay.setCDNDynamicResourcesHost(dynamicResourcesCDNHost);\n\t\tthemeDisplay.setFacebookCanvasPageURL(facebookCanvasPageURL);\n\t\tthemeDisplay.setPortalURL(portalURL);\n\t\tthemeDisplay.setRefererPlid(refererPlid);\n\t\tthemeDisplay.setSecure(request.isSecure());\n\t\tthemeDisplay.setServerName(request.getServerName());\n\t\tthemeDisplay.setServerPort(request.getServerPort());\n\t\tthemeDisplay.setWidget(widget);\n\n\t\tthemeDisplay.setCompany(company);\n\t\tthemeDisplay.setCompanyLogo(companyLogo);\n\t\tthemeDisplay.setCompanyLogoHeight(companyLogoHeight);\n\t\tthemeDisplay.setCompanyLogoWidth(companyLogoWidth);\n\t\tthemeDisplay.setControlPanelCategory(controlPanelCategory);\n\t\tthemeDisplay.setDoAsGroupId(doAsGroupId);\n\t\tthemeDisplay.setDoAsUserId(doAsUserId);\n\t\tthemeDisplay.setDoAsUserLanguageId(doAsUserLanguageId);\n\t\tthemeDisplay.setI18nLanguageId(i18nLanguageId);\n\t\tthemeDisplay.setI18nPath(i18nPath);\n\t\tthemeDisplay.setIsolated(isolated);\n\t\tthemeDisplay.setLanguageId(LocaleUtil.toLanguageId(locale));\n\t\tthemeDisplay.setLayout(layout);\n\t\tthemeDisplay.setLayouts(layouts);\n\t\tthemeDisplay.setLayoutSet(layoutSet);\n\t\tthemeDisplay.setLayoutSetLogo(layoutSetLogo);\n\t\tthemeDisplay.setLayoutTypePortlet(layoutTypePortlet);\n\t\tthemeDisplay.setLifecycle(lifecycle);\n\t\tthemeDisplay.setLifecycleAction(lifecycle.equals(\"1\"));\n\t\tthemeDisplay.setLifecycleEvent(lifecycle.equals(\"3\"));\n\t\tthemeDisplay.setLifecycleRender(lifecycle.equals(\"0\"));\n\t\tthemeDisplay.setLifecycleResource(lifecycle.equals(\"2\"));\n\t\tthemeDisplay.setLocale(locale);\n\t\tthemeDisplay.setLookAndFeel(theme, colorScheme);\n\t\tthemeDisplay.setPathApplet(contextPath.concat(\"/applets\"));\n\t\tthemeDisplay.setPathCms(contextPath.concat(\"/cms\"));\n\t\tthemeDisplay.setPathContext(contextPath);\n\t\tthemeDisplay.setPathFlash(contextPath.concat(\"/flash\"));\n\t\tthemeDisplay.setPathFriendlyURLPrivateGroup(\n\t\t\tfriendlyURLPrivateGroupPath);\n\t\tthemeDisplay.setPathFriendlyURLPrivateUser(friendlyURLPrivateUserPath);\n\t\tthemeDisplay.setPathFriendlyURLPublic(friendlyURLPublicPath);\n\t\tthemeDisplay.setPathImage(imagePath);\n\t\tthemeDisplay.setPathJavaScript(\n\t\t\tPortalWebResourcesUtil.getContextPath().concat(\"/html/js\"));\n\t\tthemeDisplay.setPathMain(mainPath);\n\t\tthemeDisplay.setPathSound(contextPath.concat(\"/html/sound\"));\n\t\tthemeDisplay.setPermissionChecker(permissionChecker);\n\t\tthemeDisplay.setPlid(plid);\n\t\tthemeDisplay.setPpid(ppid);\n\t\tthemeDisplay.setRealCompanyLogo(realCompanyLogo);\n\t\tthemeDisplay.setRealCompanyLogoHeight(realCompanyLogoHeight);\n\t\tthemeDisplay.setRealCompanyLogoWidth(realCompanyLogoWidth);\n\t\tthemeDisplay.setRealUser(realUser);\n\t\tthemeDisplay.setRefererGroupId(refererGroupId);\n\t\tthemeDisplay.setScopeGroupId(scopeGroupId);\n\t\tthemeDisplay.setSignedIn(signedIn);\n\t\tthemeDisplay.setSiteDefaultLocale(\n\t\t\tPortalUtil.getSiteDefaultLocale(siteGroupId));\n\t\tthemeDisplay.setSiteGroupId(siteGroupId);\n\t\tthemeDisplay.setStateExclusive(LiferayWindowState.isExclusive(request));\n\t\tthemeDisplay.setStateMaximized(LiferayWindowState.isMaximized(request));\n\t\tthemeDisplay.setStatePopUp(LiferayWindowState.isPopUp(request));\n\t\tthemeDisplay.setThemeCssFastLoad(themeCssFastLoad);\n\t\tthemeDisplay.setThemeImagesFastLoad(themeImagesFastLoad);\n\t\tthemeDisplay.setThemeJsBarebone(themeJsBarebone);\n\t\tthemeDisplay.setThemeJsFastLoad(themeJsFastLoad);\n\t\tthemeDisplay.setTimeZone(timeZone);\n\t\tthemeDisplay.setUnfilteredLayouts(unfilteredLayouts);\n\t\tthemeDisplay.setUser(user);\n\n\t\t// Icons\n\n\t\tthemeDisplay.setShowAddContentIcon(false);\n\n\t\tboolean showControlPanelIcon = false;\n\n\t\tif (signedIn &&\n\t\t\tPortalPermissionUtil.contains(\n\t\t\t\tpermissionChecker, ActionKeys.VIEW_CONTROL_PANEL)) {\n\n\t\t\tshowControlPanelIcon = true;\n\t\t}\n\n\t\tthemeDisplay.setShowControlPanelIcon(showControlPanelIcon);\n\n\t\tthemeDisplay.setShowHomeIcon(true);\n\t\tthemeDisplay.setShowMyAccountIcon(signedIn);\n\t\tthemeDisplay.setShowPageSettingsIcon(hasDeleteLayoutPermission);\n\t\tthemeDisplay.setShowPortalIcon(true);\n\t\tthemeDisplay.setShowSignInIcon(!signedIn);\n\n\t\tboolean showSignOutIcon = signedIn;\n\n\t\tif (themeDisplay.isImpersonated()) {\n\t\t\tshowSignOutIcon = false;\n\t\t}\n\n\t\tthemeDisplay.setShowSignOutIcon(showSignOutIcon);\n\n\t\tthemeDisplay.setShowStagingIcon(false);\n\n\t\tboolean showSiteAdministrationIcon = false;\n\n\t\tif (signedIn &&\n\t\t\tGroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, group,\n\t\t\t\tActionKeys.VIEW_SITE_ADMINISTRATION)) {\n\n\t\t\tshowSiteAdministrationIcon = true;\n\t\t}\n\n\t\tthemeDisplay.setShowSiteAdministrationIcon(showSiteAdministrationIcon);\n\n\t\t// Session\n\n\t\tif (PropsValues.SESSION_ENABLE_URL_WITH_SESSION_ID &&\n\t\t\t!CookieKeys.hasSessionId(request)) {\n\n\t\t\tthemeDisplay.setAddSessionIdToURL(true);\n\t\t\tthemeDisplay.setSessionId(session.getId());\n\t\t}\n\n\t\t// URLs\n\n\t\tString urlControlPanel = friendlyURLPrivateGroupPath.concat(\n\t\t\tGroupConstants.CONTROL_PANEL_FRIENDLY_URL);\n\n\t\tif (Validator.isNotNull(doAsUserId)) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"doAsUserId\", doAsUserId);\n\t\t}\n\n\t\tif (refererGroupId > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererGroupId\", refererGroupId);\n\t\t}\n\t\telse if (scopeGroupId > 0) {\n\t\t\tLayout refererLayout = LayoutLocalServiceUtil.fetchLayout(plid);\n\n\t\t\tif (refererLayout != null) {\n\t\t\t\tGroup refererLayoutGroup = refererLayout.getGroup();\n\n\t\t\t\tif (refererLayoutGroup.isUserGroup()) {\n\t\t\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\t\t\turlControlPanel, \"refererGroupId\", scopeGroupId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (refererPlid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", refererPlid);\n\t\t}\n\t\telse if (plid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", plid);\n\t\t}\n\n\t\tif (themeDisplay.isAddSessionIdToURL()) {\n\t\t\turlControlPanel = PortalUtil.getURLWithSessionId(\n\t\t\t\turlControlPanel, session.getId());\n\t\t}\n\n\t\tthemeDisplay.setURLControlPanel(urlControlPanel);\n\n\t\tString currentURL = PortalUtil.getCurrentURL(request);\n\n\t\tthemeDisplay.setURLCurrent(currentURL);\n\n\t\tString urlHome = PortalUtil.getHomeURL(request);\n\n\t\tthemeDisplay.setURLHome(urlHome);\n\n\t\tString siteAdministrationURL = urlControlPanel;\n\n\t\tsiteAdministrationURL = HttpUtil.addParameter(\n\t\t\tsiteAdministrationURL, \"controlPanelCategory\",\n\t\t\tPortletCategoryKeys.CURRENT_SITE);\n\t\tsiteAdministrationURL = HttpUtil.addParameter(\n\t\t\tsiteAdministrationURL, \"doAsGroupId\", siteGroupId);\n\n\t\tthemeDisplay.setURLSiteAdministration(siteAdministrationURL);\n\n\t\tlong controlPanelPlid = PortalUtil.getControlPanelPlid(companyId);\n\n\t\tif (layout != null) {\n\t\t\tif (layout.isTypePortlet()) {\n\t\t\t\tboolean freeformLayout =\n\t\t\t\t\tlayoutTypePortlet.getLayoutTemplateId().equals(\"freeform\");\n\n\t\t\t\tthemeDisplay.setFreeformLayout(freeformLayout);\n\n\t\t\t\tif (hasUpdateLayoutPermission) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(true);\n\n\t\t\t\t\tif (!group.isUser()) {\n\t\t\t\t\t\tthemeDisplay.setShowPageCustomizationIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.Dockbar.loadAddPanel();\");\n\t\t\t\t}\n\n\t\t\t\tif (hasCustomizeLayoutPermission && customizedView) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.Dockbar.loadAddPanel();\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasUpdateLayoutPermission) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\n\t\t\t\tLiferayPortletURL pageSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.GROUP_PAGES, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tpageSettingsURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/group_pages/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tpageSettingsURL.setParameter(\"selPlid\", String.valueOf(plid));\n\t\t\t\tpageSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tif (PropsValues.DOCKBAR_ADMINISTRATIVE_LINKS_SHOW_IN_POP_UP) {\n\t\t\t\t\tpageSettingsURL.setControlPanelCategory(\n\t\t\t\t\t\tPortletCategoryKeys.PORTLET);\n\t\t\t\t\tpageSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\t\"redirect\", themeDisplay.getURLHome());\n\t\t\t\t\tpageSettingsURL.setPlid(plid);\n\t\t\t\t\tpageSettingsURL.setWindowState(WindowState.MAXIMIZED);\n\t\t\t\t}\n\n\t\t\t\tthemeDisplay.setURLPageSettings(pageSettingsURL);\n\n\t\t\t\tboolean site = group.isSite();\n\n\t\t\t\tif (!site && group.isStagingGroup()) {\n\t\t\t\t\tGroup liveGroup = group.getLiveGroup();\n\n\t\t\t\t\tsite = liveGroup.isSite();\n\t\t\t\t}\n\n\t\t\t\tif (site &&\n\t\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, scopeGroupId,\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS)) {\n\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(true);\n\n\t\t\t\t\tLiferayPortletURL manageSiteMembershipsURL =\n\t\t\t\t\t\tnew PortletURLImpl(\n\t\t\t\t\t\t\trequest, PortletKeys.SITE_MEMBERSHIPS_ADMIN,\n\t\t\t\t\t\t\tcontrolPanelPlid, PortletRequest.RENDER_PHASE);\n\n\t\t\t\t\tmanageSiteMembershipsURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site_assignments\");\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\t\t\t\t\tmanageSiteMembershipsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\t\tif (PropsValues.\n\t\t\t\t\t\t\tDOCKBAR_ADMINISTRATIVE_LINKS_SHOW_IN_POP_UP) {\n\n\t\t\t\t\t\tmanageSiteMembershipsURL.setControlPanelCategory(\n\t\t\t\t\t\t\tPortletCategoryKeys.PORTLET);\n\t\t\t\t\t\tmanageSiteMembershipsURL.setWindowState(\n\t\t\t\t\t\t\tLiferayWindowState.POP_UP);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\t\"redirect\", themeDisplay.getURLHome());\n\t\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\t\"showBackURL\", Boolean.FALSE.toString());\n\t\t\t\t\t\tmanageSiteMembershipsURL.setPlid(plid);\n\t\t\t\t\t\tmanageSiteMembershipsURL.setWindowState(\n\t\t\t\t\t\t\tWindowState.MAXIMIZED);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLManageSiteMemberships(\n\t\t\t\t\t\tmanageSiteMembershipsURL);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tGroup scopeGroup = GroupLocalServiceUtil.getGroup(scopeGroupId);\n\n\t\t\tboolean hasAddLayoutGroupPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.ADD_LAYOUT);\n\t\t\tboolean hasManageLayoutsGroupPermission =\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.MANAGE_LAYOUTS);\n\t\t\tboolean hasManageStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.MANAGE_STAGING);\n\t\t\tboolean hasPublishStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.PUBLISH_STAGING);\n\t\t\tboolean hasUpdateGroupPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.UPDATE);\n\t\t\tboolean hasViewStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.VIEW_STAGING);\n\n\t\t\tif (!group.isControlPanel() && !group.isUser() &&\n\t\t\t\t!group.isUserGroup() && hasUpdateGroupPermission) {\n\n\t\t\t\tthemeDisplay.setShowSiteSettingsIcon(true);\n\n\t\t\t\tLiferayPortletURL siteSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.SITE_SETTINGS, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteSettingsURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site\");\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"showBackURL\", Boolean.FALSE.toString());\n\t\t\t\tsiteSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tif (PropsValues.DOCKBAR_ADMINISTRATIVE_LINKS_SHOW_IN_POP_UP) {\n\t\t\t\t\tsiteSettingsURL.setControlPanelCategory(\n\t\t\t\t\t\tPortletCategoryKeys.PORTLET);\n\t\t\t\t\tsiteSettingsURL.setParameter(\"closeRedirect\", currentURL);\n\t\t\t\t\tsiteSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\t\"redirect\", themeDisplay.getURLHome());\n\t\t\t\t\tsiteSettingsURL.setPlid(plid);\n\t\t\t\t\tsiteSettingsURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.MAXIMIZED);\n\t\t\t\t}\n\n\t\t\t\tthemeDisplay.setURLSiteSettings(siteSettingsURL);\n\t\t\t}\n\n\t\t\tif (!group.isLayoutPrototype() &&\n\t\t\t\t(hasAddLayoutGroupPermission || hasAddLayoutLayoutPermission ||\n\t\t\t\t hasManageLayoutsGroupPermission || hasUpdateGroupPermission)) {\n\n\t\t\t\tthemeDisplay.setShowSiteMapSettingsIcon(true);\n\n\t\t\t\tLiferayPortletURL siteMapSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.GROUP_PAGES, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteMapSettingsURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/group_pages/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tsiteMapSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tif (PropsValues.DOCKBAR_ADMINISTRATIVE_LINKS_SHOW_IN_POP_UP) {\n\t\t\t\t\tsiteMapSettingsURL.setControlPanelCategory(\n\t\t\t\t\t\tPortletCategoryKeys.PORTLET);\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\t\"closeRedirect\", currentURL);\n\t\t\t\t\tsiteMapSettingsURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.POP_UP);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\t\"redirect\", themeDisplay.getURLHome());\n\t\t\t\t\tsiteMapSettingsURL.setPlid(plid);\n\t\t\t\t\tsiteMapSettingsURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.MAXIMIZED);\n\t\t\t\t}\n\n\t\t\t\tthemeDisplay.setURLSiteMapSettings(siteMapSettingsURL);\n\t\t\t}\n\n\t\t\tif (group.hasStagingGroup() && !group.isStagingGroup()) {\n\t\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\tif (group.isControlPanel()) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\t// LEP-4987\n\n\t\t\tif (group.isStaged() || group.isStagingGroup()) {\n\t\t\t\tif (hasManageStagingPermission || hasPublishStagingPermission ||\n\t\t\t\t\thasUpdateLayoutPermission || hasViewStagingPermission) {\n\n\t\t\t\t\tthemeDisplay.setShowStagingIcon(true);\n\t\t\t\t}\n\n\t\t\t\tif (hasPublishStagingPermission) {\n\t\t\t\t\tPortletURL publishToLiveURL = new PortletURLImpl(\n\t\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, plid,\n\t\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/layouts_admin/publish_layouts\");\n\n\t\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t\t}\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\t\t\t\t\tpublishToLiveURL.setPortletMode(PortletMode.VIEW);\n\t\t\t\t\tpublishToLiveURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.EXCLUSIVE);\n\n\t\t\t\t\tthemeDisplay.setURLPublishToLive(publishToLiveURL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPortlet myAccountPortlet = PortalUtil.getFirstMyAccountPortlet(\n\t\t\t\tthemeDisplay);\n\n\t\t\tif (myAccountPortlet != null) {\n\t\t\t\tPortletURLImpl myAccountURL = new PortletURLImpl(\n\t\t\t\t\trequest, myAccountPortlet.getPortletId(), controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tif (signedIn) {\n\t\t\t\t\tmyAccountURL.setDoAsGroupId(user.getGroupId());\n\t\t\t\t}\n\t\t\t\telse if (scopeGroupId > 0) {\n\t\t\t\t\tmyAccountURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\t}\n\n\t\t\t\tif (refererPlid > 0) {\n\t\t\t\t\tmyAccountURL.setRefererPlid(refererPlid);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmyAccountURL.setRefererPlid(plid);\n\t\t\t\t}\n\n\t\t\t\tmyAccountURL.setWindowState(WindowState.MAXIMIZED);\n\n\t\t\t\tthemeDisplay.setURLMyAccount(myAccountURL);\n\t\t\t}\n\t\t}\n\n\t\tif (!user.isActive() ||\n\t\t\t(PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.TERMS_OF_USE_REQUIRED) &&\n\t\t\t !user.isAgreedToTermsOfUse())) {\n\n\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t}\n\n\t\tif ((layout != null) && layout.isLayoutPrototypeLinkActive()) {\n\t\t\tthemeDisplay.setShowPageCustomizationIcon(false);\n\t\t}\n\n\t\tif (group.isLayoutPrototype()) {\n\t\t\tthemeDisplay.setShowHomeIcon(false);\n\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageCustomizationIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\t\t\tthemeDisplay.setShowPortalIcon(false);\n\t\t\tthemeDisplay.setShowSignInIcon(false);\n\t\t\tthemeDisplay.setShowSignOutIcon(false);\n\t\t\tthemeDisplay.setShowSiteAdministrationIcon(false);\n\t\t\tthemeDisplay.setShowSiteSettingsIcon(false);\n\t\t\tthemeDisplay.setShowStagingIcon(false);\n\t\t}\n\n\t\tif (group.isLayoutSetPrototype()) {\n\t\t\tthemeDisplay.setShowPageCustomizationIcon(false);\n\t\t\tthemeDisplay.setShowSiteSettingsIcon(false);\n\t\t}\n\n\t\tif (group.hasStagingGroup() && !group.isStagingGroup()) {\n\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(false);\n\t\t\tthemeDisplay.setShowPageCustomizationIcon(false);\n\t\t\tthemeDisplay.setShowSiteMapSettingsIcon(false);\n\t\t\tthemeDisplay.setShowSiteSettingsIcon(false);\n\t\t}\n\n\t\tthemeDisplay.setURLPortal(portalURL.concat(contextPath));\n\n\t\tboolean secure = false;\n\n\t\tif (PropsValues.COMPANY_SECURITY_AUTH_REQUIRES_HTTPS ||\n\t\t\trequest.isSecure()) {\n\n\t\t\tsecure = true;\n\t\t}\n\n\t\tString securePortalURL = PortalUtil.getPortalURL(request, secure);\n\n\t\tString urlSignIn = securePortalURL.concat(mainPath).concat(\n\t\t\t_PATH_PORTAL_LOGIN);\n\n\t\tif (layout != null) {\n\t\t\turlSignIn = HttpUtil.addParameter(\n\t\t\t\turlSignIn, \"p_l_id\", layout.getPlid());\n\t\t}\n\n\t\tthemeDisplay.setURLSignIn(urlSignIn);\n\n\t\tthemeDisplay.setURLSignOut(mainPath.concat(_PATH_PORTAL_LOGOUT));\n\n\t\tPortletURL updateManagerURL = new PortletURLImpl(\n\t\t\trequest, PortletKeys.MARKETPLACE_STORE, controlPanelPlid,\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tthemeDisplay.setURLUpdateManager(updateManagerURL);\n\n\t\treturn themeDisplay;\n\t}","id":49829,"modified_method":"public ThemeDisplay initThemeDisplay(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tHttpSession session = request.getSession();\n\n\t\t// Company\n\n\t\tCompany company = PortalUtil.getCompany(request);\n\n\t\tlong companyId = company.getCompanyId();\n\n\t\t// CDN host\n\n\t\tString cdnHost = PortalUtil.getCDNHost(request);\n\n\t\tString dynamicResourcesCDNHost = StringPool.BLANK;\n\n\t\tboolean cdnDynamicResourceEnabled =\n\t\t\tPortalUtil.isCDNDynamicResourcesEnabled(request);\n\n\t\tif (cdnDynamicResourceEnabled) {\n\t\t\tdynamicResourcesCDNHost = cdnHost;\n\t\t}\n\n\t\t// Portal URL\n\n\t\tString portalURL = PortalUtil.getPortalURL(request);\n\n\t\t// Paths\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\t\tString friendlyURLPrivateGroupPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateGroup();\n\t\tString friendlyURLPrivateUserPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateUser();\n\t\tString friendlyURLPublicPath = PortalUtil.getPathFriendlyURLPublic();\n\t\tString imagePath = dynamicResourcesCDNHost.concat(\n\t\t\tPortalUtil.getPathImage());\n\t\tString mainPath = PortalUtil.getPathMain();\n\n\t\tString i18nPath = (String)request.getAttribute(WebKeys.I18N_PATH);\n\n\t\tif (Validator.isNotNull(i18nPath)) {\n\t\t\tif (Validator.isNotNull(contextPath)) {\n\t\t\t\tString i18nContextPath = contextPath.concat(i18nPath);\n\n\t\t\t\tfriendlyURLPrivateGroupPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateGroupPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPrivateUserPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateUserPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPublicPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPublicPath, contextPath, i18nContextPath);\n\t\t\t\tmainPath = StringUtil.replaceFirst(\n\t\t\t\t\tmainPath, contextPath, i18nContextPath);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfriendlyURLPrivateGroupPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateGroupPath);\n\t\t\t\tfriendlyURLPrivateUserPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateUserPath);\n\t\t\t\tfriendlyURLPublicPath = i18nPath.concat(friendlyURLPublicPath);\n\t\t\t\tmainPath = i18nPath.concat(mainPath);\n\t\t\t}\n\t\t}\n\n\t\t// Company logo\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(imagePath);\n\t\tsb.append(\"/company_logo?img_id=\");\n\t\tsb.append(company.getLogoId());\n\t\tsb.append(\"&t=\");\n\t\tsb.append(WebServerServletTokenUtil.getToken(company.getLogoId()));\n\n\t\tString companyLogo = sb.toString();\n\n\t\tint companyLogoHeight = 0;\n\t\tint companyLogoWidth = 0;\n\n\t\tImage companyLogoImage = null;\n\n\t\tif (company.getLogoId() > 0) {\n\t\t\tcompanyLogoImage = ImageLocalServiceUtil.getCompanyLogo(\n\t\t\t\tcompany.getLogoId());\n\t\t}\n\t\telse {\n\t\t\tcompanyLogoImage = ImageToolUtil.getDefaultCompanyLogo();\n\t\t}\n\n\t\tif (companyLogoImage != null) {\n\t\t\tcompanyLogoHeight = companyLogoImage.getHeight();\n\t\t\tcompanyLogoWidth = companyLogoImage.getWidth();\n\t\t}\n\n\t\tString realCompanyLogo = companyLogo;\n\t\tint realCompanyLogoHeight = companyLogoHeight;\n\t\tint realCompanyLogoWidth = companyLogoWidth;\n\n\t\t// User\n\n\t\tUser user = null;\n\n\t\ttry {\n\t\t\tuser = PortalUtil.initUser(request);\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t\treturn null;\n\t\t}\n\n\t\tboolean signedIn = !user.isDefaultUser();\n\n\t\tif (PropsValues.BROWSER_CACHE_DISABLED ||\n\t\t\t(PropsValues.BROWSER_CACHE_SIGNED_IN_DISABLED && signedIn)) {\n\n\t\t\tresponse.setDateHeader(HttpHeaders.EXPIRES, 0);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.CACHE_CONTROL,\n\t\t\t\tHttpHeaders.CACHE_CONTROL_NO_CACHE_VALUE);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.PRAGMA, HttpHeaders.PRAGMA_NO_CACHE_VALUE);\n\t\t}\n\n\t\tUser realUser = user;\n\n\t\tLong realUserId = (Long)session.getAttribute(WebKeys.USER_ID);\n\n\t\tif (realUserId != null) {\n\t\t\tif (user.getUserId() != realUserId.longValue()) {\n\t\t\t\trealUser = UserLocalServiceUtil.getUserById(\n\t\t\t\t\trealUserId.longValue());\n\t\t\t}\n\t\t}\n\n\t\tString doAsUserId = ParamUtil.getString(request, \"doAsUserId\");\n\t\tString doAsUserLanguageId = ParamUtil.getString(\n\t\t\trequest, \"doAsUserLanguageId\");\n\t\tlong doAsGroupId = ParamUtil.getLong(request, \"doAsGroupId\");\n\n\t\tlong refererGroupId = ParamUtil.getLong(request, \"refererGroupId\");\n\n\t\tlong refererPlid = ParamUtil.getLong(request, \"refererPlid\");\n\n\t\tif (LayoutLocalServiceUtil.fetchLayout(refererPlid) == null) {\n\t\t\trefererPlid = 0;\n\t\t}\n\n\t\tString controlPanelCategory = ParamUtil.getString(\n\t\t\trequest, \"controlPanelCategory\");\n\n\t\t// Permission checker\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tPermissionCheckerFactoryUtil.create(user);\n\n\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t// Cookie support\n\n\t\ttry {\n\n\t\t\t// LEP-4069\n\n\t\t\tCookieKeys.validateSupportCookie(request);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tCookieKeys.addSupportCookie(request, response);\n\t\t}\n\n\t\t// Time zone\n\n\t\tTimeZone timeZone = user.getTimeZone();\n\n\t\tif (timeZone == null) {\n\t\t\ttimeZone = company.getTimeZone();\n\t\t}\n\n\t\t// Layouts\n\n\t\tif (signedIn) {\n\t\t\tupdateUserLayouts(user);\n\t\t}\n\n\t\tLayout layout = null;\n\t\tList<Layout> layouts = null;\n\n\t\tlong plid = ParamUtil.getLong(request, \"p_l_id\");\n\n\t\tboolean viewableSourceGroup = true;\n\n\t\tif (plid > 0) {\n\t\t\tlayout = LayoutLocalServiceUtil.getLayout(plid);\n\t\t}\n\t\telse {\n\t\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\t\t\tboolean privateLayout = ParamUtil.getBoolean(\n\t\t\t\trequest, \"privateLayout\");\n\t\t\tlong layoutId = ParamUtil.getLong(request, \"layoutId\");\n\n\t\t\tif ((groupId > 0) && (layoutId > 0)) {\n\t\t\t\tlayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tgroupId, privateLayout, layoutId);\n\t\t\t}\n\t\t}\n\n\t\tif (layout != null) {\n\t\t\tlong sourceGroupId = ParamUtil.getLong(request, \"p_v_l_s_g_id\");\n\n\t\t\tif ((sourceGroupId > 0) && (sourceGroupId != layout.getGroupId())) {\n\t\t\t\tGroup sourceGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\t\tsourceGroupId);\n\n\t\t\t\tif (layout.isPublicLayout() ||\n\t\t\t\t\tSitesUtil.isUserGroupLayoutSetViewable(\n\t\t\t\t\t\tpermissionChecker, layout.getGroup())) {\n\n\t\t\t\t\tlayout = new VirtualLayout(layout, sourceGroup);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tviewableSourceGroup = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString ppid = ParamUtil.getString(request, \"p_p_id\");\n\n\t\tBoolean redirectToDefaultLayout = (Boolean)request.getAttribute(\n\t\t\tWebKeys.REDIRECT_TO_DEFAULT_LAYOUT);\n\n\t\tif (redirectToDefaultLayout == null) {\n\t\t\tredirectToDefaultLayout = Boolean.FALSE;\n\t\t}\n\n\t\tif (layout != null) {\n\t\t\tGroup group = layout.getGroup();\n\n\t\t\tif (!signedIn && PropsValues.AUTH_FORWARD_BY_REDIRECT) {\n\t\t\t\trequest.setAttribute(WebKeys.REQUESTED_LAYOUT, layout);\n\t\t\t}\n\n\t\t\tif ((Validator.isNull(controlPanelCategory) ||\n\t\t\t\t controlPanelCategory.equals(PortletCategoryKeys.MY) ||\n\t\t\t\t controlPanelCategory.equals(PortletCategoryKeys.PORTLET)) &&\n\t\t\t\tValidator.isNotNull(ppid) &&\n\t\t\t\t(LiferayWindowState.isPopUp(request) ||\n\t\t\t\t LiferayWindowState.isExclusive(request))) {\n\n\t\t\t\tcontrolPanelCategory = PortletCategoryKeys.PORTLET;\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(ppid)) {\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tcompanyId, ppid);\n\n\t\t\t\tString portletControlPanelEntryCategory =\n\t\t\t\t\tportlet.getControlPanelEntryCategory();\n\n\t\t\t\tif (!controlPanelCategory.startsWith(\n\t\t\t\t\t\tPortletCategoryKeys.CURRENT_SITE) &&\n\t\t\t\t\tportletControlPanelEntryCategory.startsWith(\n\t\t\t\t\t\tPortletCategoryKeys.SITE_ADMINISTRATION)) {\n\n\t\t\t\t\tportletControlPanelEntryCategory =\n\t\t\t\t\t\tPortletCategoryKeys.SITES;\n\t\t\t\t}\n\n\t\t\t\tif (!controlPanelCategory.startsWith(\n\t\t\t\t\t\tPortletCategoryKeys.CURRENT_SITE) &&\n\t\t\t\t\tValidator.isNotNull(portletControlPanelEntryCategory)) {\n\n\t\t\t\t\tcontrolPanelCategory = portletControlPanelEntryCategory;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean viewableGroup = hasAccessPermission(\n\t\t\t\tpermissionChecker, layout, doAsGroupId, controlPanelCategory,\n\t\t\t\ttrue);\n\t\t\tboolean viewableStaging =\n\t\t\t\t!group.isControlPanel() &&\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, group, ActionKeys.VIEW_STAGING);\n\n\t\t\tif (viewableStaging) {\n\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\t\t\t}\n\t\t\telse if ((!viewableGroup || !viewableSourceGroup) &&\n\t\t\t\t\t group.isStagingGroup()) {\n\n\t\t\t\tlayout = null;\n\t\t\t}\n\t\t\telse if (!isLoginRequest(request) &&\n\t\t\t\t\t (!viewableGroup || !viewableSourceGroup ||\n\t\t\t\t\t  (!redirectToDefaultLayout &&\n\t\t\t\t\t   !hasAccessPermission(\n\t\t\t\t\t\t   permissionChecker, layout, doAsGroupId,\n\t\t\t\t\t\t   controlPanelCategory, false)))) {\n\n\t\t\t\tif (user.isDefaultUser() &&\n\t\t\t\t\tPropsValues.AUTH_LOGIN_PROMPT_ENABLED) {\n\n\t\t\t\t\tthrow new PrincipalException(\"User is not authenticated\");\n\t\t\t\t}\n\n\t\t\t\tsb = new StringBundler(6);\n\n\t\t\t\tsb.append(\"User \");\n\t\t\t\tsb.append(user.getUserId());\n\t\t\t\tsb.append(\" is not allowed to access the \");\n\t\t\t\tsb.append(layout.isPrivateLayout() ? \"private\": \"public\");\n\t\t\t\tsb.append(\" pages of group \");\n\t\t\t\tsb.append(layout.getGroupId());\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(sb.toString());\n\t\t\t\t}\n\n\t\t\t\tthrow new NoSuchLayoutException(sb.toString());\n\t\t\t}\n\t\t\telse if (isLoginRequest(request) && !viewableGroup) {\n\t\t\t\tlayout = null;\n\t\t\t}\n\t\t\telse if (group.isLayoutPrototype()) {\n\t\t\t\tlayouts = new ArrayList<>();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\t\t\tif (!group.isControlPanel()) {\n\t\t\t\t\tdoAsGroupId = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tList<Layout> unfilteredLayouts = layouts;\n\n\t\tif (layout == null) {\n\t\t\tObject[] defaultLayout = getDefaultLayout(request, user, signedIn);\n\n\t\t\tlayout = (Layout)defaultLayout[0];\n\t\t\tlayouts = (List<Layout>)defaultLayout[1];\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT_DEFAULT, Boolean.TRUE);\n\t\t}\n\n\t\tObject[] viewableLayouts = getViewableLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts, doAsGroupId,\n\t\t\tcontrolPanelCategory);\n\n\t\tString layoutSetLogo = null;\n\n\t\tlayout = (Layout)viewableLayouts[0];\n\t\tlayouts = (List<Layout>)viewableLayouts[1];\n\n\t\tGroup group = null;\n\n\t\tif (layout != null) {\n\t\t\tgroup = layout.getGroup();\n\n\t\t\tif (!group.isControlPanel()) {\n\t\t\t\trememberVisitedGroupIds(request, group.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\tLayoutTypePortlet layoutTypePortlet = null;\n\n\t\tlayouts = mergeAdditionalLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts, doAsGroupId,\n\t\t\tcontrolPanelCategory);\n\n\t\tLayoutSet layoutSet = null;\n\n\t\tboolean hasAddLayoutLayoutPermission = false;\n\t\tboolean hasCustomizeLayoutPermission = false;\n\t\tboolean hasDeleteLayoutPermission = false;\n\t\tboolean hasUpdateLayoutPermission = false;\n\n\t\tboolean customizedView = SessionParamUtil.getBoolean(\n\t\t\trequest, \"customized_view\", true);\n\n\t\tif (layout != null) {\n\t\t\tLayoutType layoutType = layout.getLayoutType();\n\n\t\t\tLayoutTypeAccessPolicy layoutTypeAccessPolicy =\n\t\t\t\tlayoutType.getLayoutTypeAccessPolicy();\n\n\t\t\thasAddLayoutLayoutPermission =\n\t\t\t\tlayoutTypeAccessPolicy.isAddLayoutAllowed(\n\t\t\t\t\tpermissionChecker, layout);\n\t\t\thasCustomizeLayoutPermission =\n\t\t\t\tlayoutTypeAccessPolicy.isCustomizeLayoutAllowed(\n\t\t\t\t\tpermissionChecker, layout);\n\t\t\thasDeleteLayoutPermission =\n\t\t\t\tlayoutTypeAccessPolicy.isDeleteLayoutAllowed(\n\t\t\t\t\tpermissionChecker, layout);\n\t\t\thasUpdateLayoutPermission =\n\t\t\t\tlayoutTypeAccessPolicy.isUpdateLayoutAllowed(\n\t\t\t\t\tpermissionChecker, layout);\n\n\t\t\tlayoutSet = layout.getLayoutSet();\n\n\t\t\tif (company.isSiteLogo()) {\n\t\t\t\tlong logoId = 0;\n\n\t\t\t\tif (layoutSet.isLogo()) {\n\t\t\t\t\tlogoId = layoutSet.getLogoId();\n\n\t\t\t\t\tif (logoId == 0) {\n\t\t\t\t\t\tlogoId = layoutSet.getLiveLogoId();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLayoutSet siblingLayoutSet =\n\t\t\t\t\t\tLayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\t\t\tlayout.getGroupId(), !layout.isPrivateLayout());\n\n\t\t\t\t\tif (siblingLayoutSet.isLogo()) {\n\t\t\t\t\t\tlogoId = siblingLayoutSet.getLogoId();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (logoId > 0) {\n\t\t\t\t\tsb = new StringBundler(5);\n\n\t\t\t\t\tsb.append(imagePath);\n\t\t\t\t\tsb.append(\"/layout_set_logo?img_id=\");\n\t\t\t\t\tsb.append(logoId);\n\t\t\t\t\tsb.append(\"&t=\");\n\t\t\t\t\tsb.append(WebServerServletTokenUtil.getToken(logoId));\n\n\t\t\t\t\tlayoutSetLogo = sb.toString();\n\n\t\t\t\t\tImage layoutSetLogoImage =\n\t\t\t\t\t\tImageLocalServiceUtil.getCompanyLogo(logoId);\n\n\t\t\t\t\tcompanyLogo = layoutSetLogo;\n\t\t\t\t\tcompanyLogoHeight = layoutSetLogoImage.getHeight();\n\t\t\t\t\tcompanyLogoWidth = layoutSetLogoImage.getWidth();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplid = layout.getPlid();\n\n\t\t\t// Updates to shared layouts are not reflected until the next time\n\t\t\t// the user logs in because group layouts are cached in the session\n\n\t\t\tlayout = (Layout)layout.clone();\n\n\t\t\tlayoutTypePortlet = (LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\tboolean customizable = layoutTypePortlet.isCustomizable();\n\n\t\t\tif (!customizable ||\n\t\t\t\tgroup.isLayoutPrototype() || group.isLayoutSetPrototype() ||\n\t\t\t\tgroup.isStagingGroup()) {\n\n\t\t\t\tcustomizedView = false;\n\t\t\t}\n\n\t\t\tlayoutTypePortlet.setCustomizedView(customizedView);\n\t\t\tlayoutTypePortlet.setUpdatePermission(hasUpdateLayoutPermission);\n\n\t\t\tif (signedIn && customizable && customizedView &&\n\t\t\t\thasCustomizeLayoutPermission) {\n\n\t\t\t\tPortalPreferences portalPreferences =\n\t\t\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(\n\t\t\t\t\t\tuser.getUserId(), true);\n\n\t\t\t\tlayoutTypePortlet.setPortalPreferences(portalPreferences);\n\t\t\t}\n\n\t\t\tLayoutClone layoutClone = LayoutCloneFactory.getInstance();\n\n\t\t\tif (layoutClone != null) {\n\t\t\t\tString typeSettings = layoutClone.get(request, plid);\n\n\t\t\t\tif (typeSettings != null) {\n\t\t\t\t\tUnicodeProperties typeSettingsProperties =\n\t\t\t\t\t\tnew UnicodeProperties(true);\n\n\t\t\t\t\ttypeSettingsProperties.load(typeSettings);\n\n\t\t\t\t\tString stateMax = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MAX);\n\t\t\t\t\tString stateMin = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MIN);\n\t\t\t\t\tString modeAbout = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_ABOUT);\n\t\t\t\t\tString modeConfig = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_CONFIG);\n\t\t\t\t\tString modeEdit = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT);\n\t\t\t\t\tString modeEditDefaults =\n\t\t\t\t\t\ttypeSettingsProperties.getProperty(\n\t\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_DEFAULTS);\n\t\t\t\t\tString modeEditGuest = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_GUEST);\n\t\t\t\t\tString modeHelp = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_HELP);\n\t\t\t\t\tString modePreview = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PREVIEW);\n\t\t\t\t\tString modePrint = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PRINT);\n\n\t\t\t\t\tlayoutTypePortlet.setStateMax(stateMax);\n\t\t\t\t\tlayoutTypePortlet.setStateMin(stateMin);\n\t\t\t\t\tlayoutTypePortlet.setModeAbout(modeAbout);\n\t\t\t\t\tlayoutTypePortlet.setModeConfig(modeConfig);\n\t\t\t\t\tlayoutTypePortlet.setModeEdit(modeEdit);\n\t\t\t\t\tlayoutTypePortlet.setModeEditDefaults(modeEditDefaults);\n\t\t\t\t\tlayoutTypePortlet.setModeEditGuest(modeEditGuest);\n\t\t\t\t\tlayoutTypePortlet.setModeHelp(modeHelp);\n\t\t\t\t\tlayoutTypePortlet.setModePreview(modePreview);\n\t\t\t\t\tlayoutTypePortlet.setModePrint(modePrint);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT, layout);\n\t\t\trequest.setAttribute(WebKeys.LAYOUTS, layouts);\n\t\t}\n\n\t\t// Locale\n\n\t\tString i18nLanguageId = (String)request.getAttribute(\n\t\t\tWebKeys.I18N_LANGUAGE_ID);\n\n\t\tLocale locale = PortalUtil.getLocale(request, response, true);\n\n\t\t// Scope\n\n\t\tlong scopeGroupId = PortalUtil.getScopeGroupId(request);\n\n\t\tif (group.isInheritContent()) {\n\t\t\tscopeGroupId = group.getParentGroupId();\n\t\t}\n\n\t\tif ((scopeGroupId <= 0) && (doAsGroupId > 0)) {\n\t\t\tscopeGroupId = doAsGroupId;\n\t\t}\n\n\t\tlong siteGroupId = 0;\n\n\t\tif (layout != null) {\n\t\t\tif (layout.isTypeControlPanel()) {\n\t\t\t\tsiteGroupId = PortalUtil.getSiteGroupId(scopeGroupId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsiteGroupId = PortalUtil.getSiteGroupId(layout.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\t// Theme and color scheme\n\n\t\tTheme theme = null;\n\t\tColorScheme colorScheme = null;\n\n\t\tboolean wapTheme = BrowserSnifferUtil.isWap(request);\n\n\t\tif ((layout != null) &&\n\t\t\t(group.isControlPanel() || group.isUserPersonalPanel())) {\n\n\t\t\tString themeId = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsKeys.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID);\n\t\t\tString colorSchemeId =\n\t\t\t\tColorSchemeFactoryUtil.getDefaultRegularColorSchemeId();\n\n\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\tcompanyId, themeId, wapTheme);\n\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, wapTheme);\n\n\t\t\tif (!wapTheme && theme.isWapTheme()) {\n\t\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tPropsValues.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID, false);\n\t\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, false);\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.THEME, theme);\n\t\t\trequest.setAttribute(WebKeys.COLOR_SCHEME, colorScheme);\n\t\t}\n\n\t\tboolean themeCssFastLoad = PropsValues.THEME_CSS_FAST_LOAD;\n\n\t\tif (PropsValues.THEME_CSS_FAST_LOAD_CHECK_REQUEST_PARAMETER) {\n\t\t\tthemeCssFastLoad = SessionParamUtil.getBoolean(\n\t\t\t\trequest, \"css_fast_load\", PropsValues.THEME_CSS_FAST_LOAD);\n\t\t}\n\n\t\tboolean themeImagesFastLoad = PropsValues.THEME_IMAGES_FAST_LOAD;\n\n\t\tif (PropsValues.THEME_IMAGES_FAST_LOAD_CHECK_REQUEST_PARAMETER) {\n\t\t\tSessionParamUtil.getBoolean(\n\t\t\t\trequest, \"images_fast_load\",\n\t\t\t\tPropsValues.THEME_IMAGES_FAST_LOAD);\n\t\t}\n\n\t\tboolean themeJsBarebone = PropsValues.JAVASCRIPT_BAREBONE_ENABLED;\n\n\t\tif (themeJsBarebone) {\n\t\t\tif (signedIn) {\n\t\t\t\tthemeJsBarebone = false;\n\t\t\t}\n\t\t}\n\n\t\tboolean themeJsFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"js_fast_load\", PropsValues.JAVASCRIPT_FAST_LOAD);\n\n\t\tString lifecycle = ParamUtil.getString(request, \"p_p_lifecycle\", \"0\");\n\n\t\tlifecycle = ParamUtil.getString(request, \"p_t_lifecycle\", lifecycle);\n\n\t\tboolean isolated = ParamUtil.getBoolean(request, \"p_p_isolated\");\n\n\t\tString facebookCanvasPageURL = (String)request.getAttribute(\n\t\t\tWebKeys.FACEBOOK_CANVAS_PAGE_URL);\n\n\t\tboolean widget = false;\n\n\t\tBoolean widgetObj = (Boolean)request.getAttribute(WebKeys.WIDGET);\n\n\t\tif (widgetObj != null) {\n\t\t\twidget = widgetObj.booleanValue();\n\t\t}\n\n\t\t// Theme display\n\n\t\tThemeDisplay themeDisplay = ThemeDisplayFactory.create();\n\n\t\tthemeDisplay.setRequest(request);\n\n\t\t// Set attributes first that other methods (getCDNBaseURL and\n\t\t// setLookAndFeel) depend on\n\n\t\tthemeDisplay.setCDNHost(cdnHost);\n\t\tthemeDisplay.setCDNDynamicResourcesHost(dynamicResourcesCDNHost);\n\t\tthemeDisplay.setFacebookCanvasPageURL(facebookCanvasPageURL);\n\t\tthemeDisplay.setPortalURL(portalURL);\n\t\tthemeDisplay.setRefererPlid(refererPlid);\n\t\tthemeDisplay.setSecure(request.isSecure());\n\t\tthemeDisplay.setServerName(request.getServerName());\n\t\tthemeDisplay.setServerPort(request.getServerPort());\n\t\tthemeDisplay.setWidget(widget);\n\n\t\tthemeDisplay.setCompany(company);\n\t\tthemeDisplay.setCompanyLogo(companyLogo);\n\t\tthemeDisplay.setCompanyLogoHeight(companyLogoHeight);\n\t\tthemeDisplay.setCompanyLogoWidth(companyLogoWidth);\n\t\tthemeDisplay.setControlPanelCategory(controlPanelCategory);\n\t\tthemeDisplay.setDoAsGroupId(doAsGroupId);\n\t\tthemeDisplay.setDoAsUserId(doAsUserId);\n\t\tthemeDisplay.setDoAsUserLanguageId(doAsUserLanguageId);\n\t\tthemeDisplay.setI18nLanguageId(i18nLanguageId);\n\t\tthemeDisplay.setI18nPath(i18nPath);\n\t\tthemeDisplay.setIsolated(isolated);\n\t\tthemeDisplay.setLanguageId(LocaleUtil.toLanguageId(locale));\n\t\tthemeDisplay.setLayout(layout);\n\t\tthemeDisplay.setLayouts(layouts);\n\t\tthemeDisplay.setLayoutSet(layoutSet);\n\t\tthemeDisplay.setLayoutSetLogo(layoutSetLogo);\n\t\tthemeDisplay.setLayoutTypePortlet(layoutTypePortlet);\n\t\tthemeDisplay.setLifecycle(lifecycle);\n\t\tthemeDisplay.setLifecycleAction(lifecycle.equals(\"1\"));\n\t\tthemeDisplay.setLifecycleEvent(lifecycle.equals(\"3\"));\n\t\tthemeDisplay.setLifecycleRender(lifecycle.equals(\"0\"));\n\t\tthemeDisplay.setLifecycleResource(lifecycle.equals(\"2\"));\n\t\tthemeDisplay.setLocale(locale);\n\t\tthemeDisplay.setLookAndFeel(theme, colorScheme);\n\t\tthemeDisplay.setPathApplet(contextPath.concat(\"/applets\"));\n\t\tthemeDisplay.setPathCms(contextPath.concat(\"/cms\"));\n\t\tthemeDisplay.setPathContext(contextPath);\n\t\tthemeDisplay.setPathFlash(contextPath.concat(\"/flash\"));\n\t\tthemeDisplay.setPathFriendlyURLPrivateGroup(\n\t\t\tfriendlyURLPrivateGroupPath);\n\t\tthemeDisplay.setPathFriendlyURLPrivateUser(friendlyURLPrivateUserPath);\n\t\tthemeDisplay.setPathFriendlyURLPublic(friendlyURLPublicPath);\n\t\tthemeDisplay.setPathImage(imagePath);\n\t\tthemeDisplay.setPathJavaScript(\n\t\t\tPortalWebResourcesUtil.getContextPath().concat(\"/html/js\"));\n\t\tthemeDisplay.setPathMain(mainPath);\n\t\tthemeDisplay.setPathSound(contextPath.concat(\"/html/sound\"));\n\t\tthemeDisplay.setPermissionChecker(permissionChecker);\n\t\tthemeDisplay.setPlid(plid);\n\t\tthemeDisplay.setPpid(ppid);\n\t\tthemeDisplay.setRealCompanyLogo(realCompanyLogo);\n\t\tthemeDisplay.setRealCompanyLogoHeight(realCompanyLogoHeight);\n\t\tthemeDisplay.setRealCompanyLogoWidth(realCompanyLogoWidth);\n\t\tthemeDisplay.setRealUser(realUser);\n\t\tthemeDisplay.setRefererGroupId(refererGroupId);\n\t\tthemeDisplay.setScopeGroupId(scopeGroupId);\n\t\tthemeDisplay.setSignedIn(signedIn);\n\t\tthemeDisplay.setSiteDefaultLocale(\n\t\t\tPortalUtil.getSiteDefaultLocale(siteGroupId));\n\t\tthemeDisplay.setSiteGroupId(siteGroupId);\n\t\tthemeDisplay.setStateExclusive(LiferayWindowState.isExclusive(request));\n\t\tthemeDisplay.setStateMaximized(LiferayWindowState.isMaximized(request));\n\t\tthemeDisplay.setStatePopUp(LiferayWindowState.isPopUp(request));\n\t\tthemeDisplay.setThemeCssFastLoad(themeCssFastLoad);\n\t\tthemeDisplay.setThemeImagesFastLoad(themeImagesFastLoad);\n\t\tthemeDisplay.setThemeJsBarebone(themeJsBarebone);\n\t\tthemeDisplay.setThemeJsFastLoad(themeJsFastLoad);\n\t\tthemeDisplay.setTimeZone(timeZone);\n\t\tthemeDisplay.setUnfilteredLayouts(unfilteredLayouts);\n\t\tthemeDisplay.setUser(user);\n\n\t\t// Icons\n\n\t\tthemeDisplay.setShowAddContentIcon(false);\n\n\t\tboolean showControlPanelIcon = false;\n\n\t\tif (signedIn &&\n\t\t\tPortalPermissionUtil.contains(\n\t\t\t\tpermissionChecker, ActionKeys.VIEW_CONTROL_PANEL)) {\n\n\t\t\tshowControlPanelIcon = true;\n\t\t}\n\n\t\tthemeDisplay.setShowControlPanelIcon(showControlPanelIcon);\n\n\t\tthemeDisplay.setShowHomeIcon(true);\n\t\tthemeDisplay.setShowMyAccountIcon(signedIn);\n\t\tthemeDisplay.setShowPageSettingsIcon(hasDeleteLayoutPermission);\n\t\tthemeDisplay.setShowPortalIcon(true);\n\t\tthemeDisplay.setShowSignInIcon(!signedIn);\n\n\t\tboolean showSignOutIcon = signedIn;\n\n\t\tif (themeDisplay.isImpersonated()) {\n\t\t\tshowSignOutIcon = false;\n\t\t}\n\n\t\tthemeDisplay.setShowSignOutIcon(showSignOutIcon);\n\n\t\tthemeDisplay.setShowStagingIcon(false);\n\n\t\tboolean showSiteAdministrationIcon = false;\n\n\t\tif (signedIn &&\n\t\t\tGroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, group,\n\t\t\t\tActionKeys.VIEW_SITE_ADMINISTRATION)) {\n\n\t\t\tshowSiteAdministrationIcon = true;\n\t\t}\n\n\t\tthemeDisplay.setShowSiteAdministrationIcon(showSiteAdministrationIcon);\n\n\t\t// Session\n\n\t\tif (PropsValues.SESSION_ENABLE_URL_WITH_SESSION_ID &&\n\t\t\t!CookieKeys.hasSessionId(request)) {\n\n\t\t\tthemeDisplay.setAddSessionIdToURL(true);\n\t\t\tthemeDisplay.setSessionId(session.getId());\n\t\t}\n\n\t\t// URLs\n\n\t\tString urlControlPanel = friendlyURLPrivateGroupPath.concat(\n\t\t\tGroupConstants.CONTROL_PANEL_FRIENDLY_URL);\n\n\t\tif (Validator.isNotNull(doAsUserId)) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"doAsUserId\", doAsUserId);\n\t\t}\n\n\t\tif (refererGroupId > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererGroupId\", refererGroupId);\n\t\t}\n\t\telse if (scopeGroupId > 0) {\n\t\t\tLayout refererLayout = LayoutLocalServiceUtil.fetchLayout(plid);\n\n\t\t\tif (refererLayout != null) {\n\t\t\t\tGroup refererLayoutGroup = refererLayout.getGroup();\n\n\t\t\t\tif (refererLayoutGroup.isUserGroup()) {\n\t\t\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\t\t\turlControlPanel, \"refererGroupId\", scopeGroupId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (refererPlid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", refererPlid);\n\t\t}\n\t\telse if (plid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", plid);\n\t\t}\n\n\t\tif (themeDisplay.isAddSessionIdToURL()) {\n\t\t\turlControlPanel = PortalUtil.getURLWithSessionId(\n\t\t\t\turlControlPanel, session.getId());\n\t\t}\n\n\t\tthemeDisplay.setURLControlPanel(urlControlPanel);\n\n\t\tString currentURL = PortalUtil.getCurrentURL(request);\n\n\t\tthemeDisplay.setURLCurrent(currentURL);\n\n\t\tString urlHome = PortalUtil.getHomeURL(request);\n\n\t\tthemeDisplay.setURLHome(urlHome);\n\n\t\tString siteAdministrationURL = urlControlPanel;\n\n\t\tsiteAdministrationURL = HttpUtil.addParameter(\n\t\t\tsiteAdministrationURL, \"controlPanelCategory\",\n\t\t\tPortletCategoryKeys.CURRENT_SITE);\n\t\tsiteAdministrationURL = HttpUtil.addParameter(\n\t\t\tsiteAdministrationURL, \"doAsGroupId\", siteGroupId);\n\n\t\tthemeDisplay.setURLSiteAdministration(siteAdministrationURL);\n\n\t\tlong controlPanelPlid = PortalUtil.getControlPanelPlid(companyId);\n\n\t\tif (layout != null) {\n\t\t\tif (layout.isTypePortlet()) {\n\t\t\t\tboolean freeformLayout =\n\t\t\t\t\tlayoutTypePortlet.getLayoutTemplateId().equals(\"freeform\");\n\n\t\t\t\tthemeDisplay.setFreeformLayout(freeformLayout);\n\n\t\t\t\tif (hasUpdateLayoutPermission) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(true);\n\n\t\t\t\t\tif (!group.isUser()) {\n\t\t\t\t\t\tthemeDisplay.setShowPageCustomizationIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.Dockbar.loadAddPanel();\");\n\t\t\t\t}\n\n\t\t\t\tif (hasCustomizeLayoutPermission && customizedView) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.Dockbar.loadAddPanel();\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasUpdateLayoutPermission) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\n\t\t\t\tLiferayPortletURL pageSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.GROUP_PAGES, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tpageSettingsURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/group_pages/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tpageSettingsURL.setParameter(\"selPlid\", String.valueOf(plid));\n\t\t\t\tpageSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tif (PropsValues.DOCKBAR_ADMINISTRATIVE_LINKS_SHOW_IN_POP_UP) {\n\t\t\t\t\tpageSettingsURL.setControlPanelCategory(\n\t\t\t\t\t\tPortletCategoryKeys.PORTLET);\n\t\t\t\t\tpageSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\t\"redirect\", themeDisplay.getURLHome());\n\t\t\t\t\tpageSettingsURL.setPlid(plid);\n\t\t\t\t\tpageSettingsURL.setWindowState(WindowState.MAXIMIZED);\n\t\t\t\t}\n\n\t\t\t\tthemeDisplay.setURLPageSettings(pageSettingsURL);\n\n\t\t\t\tboolean site = group.isSite();\n\n\t\t\t\tif (!site && group.isStagingGroup()) {\n\t\t\t\t\tGroup liveGroup = group.getLiveGroup();\n\n\t\t\t\t\tsite = liveGroup.isSite();\n\t\t\t\t}\n\n\t\t\t\tif (site &&\n\t\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, scopeGroupId,\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS)) {\n\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(true);\n\n\t\t\t\t\tLiferayPortletURL manageSiteMembershipsURL =\n\t\t\t\t\t\tnew PortletURLImpl(\n\t\t\t\t\t\t\trequest, PortletKeys.SITE_MEMBERSHIPS_ADMIN,\n\t\t\t\t\t\t\tcontrolPanelPlid, PortletRequest.RENDER_PHASE);\n\n\t\t\t\t\tmanageSiteMembershipsURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site_assignments\");\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\t\t\t\t\tmanageSiteMembershipsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\t\tif (PropsValues.\n\t\t\t\t\t\t\tDOCKBAR_ADMINISTRATIVE_LINKS_SHOW_IN_POP_UP) {\n\n\t\t\t\t\t\tmanageSiteMembershipsURL.setControlPanelCategory(\n\t\t\t\t\t\t\tPortletCategoryKeys.PORTLET);\n\t\t\t\t\t\tmanageSiteMembershipsURL.setWindowState(\n\t\t\t\t\t\t\tLiferayWindowState.POP_UP);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\t\"redirect\", themeDisplay.getURLHome());\n\t\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\t\"showBackURL\", Boolean.FALSE.toString());\n\t\t\t\t\t\tmanageSiteMembershipsURL.setPlid(plid);\n\t\t\t\t\t\tmanageSiteMembershipsURL.setWindowState(\n\t\t\t\t\t\t\tWindowState.MAXIMIZED);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLManageSiteMemberships(\n\t\t\t\t\t\tmanageSiteMembershipsURL);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tGroup scopeGroup = GroupLocalServiceUtil.getGroup(scopeGroupId);\n\n\t\t\tboolean hasAddLayoutGroupPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.ADD_LAYOUT);\n\t\t\tboolean hasManageLayoutsGroupPermission =\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.MANAGE_LAYOUTS);\n\t\t\tboolean hasManageStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.MANAGE_STAGING);\n\t\t\tboolean hasPublishStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.PUBLISH_STAGING);\n\t\t\tboolean hasUpdateGroupPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.UPDATE);\n\t\t\tboolean hasViewStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.VIEW_STAGING);\n\n\t\t\tif (!group.isControlPanel() && !group.isUserPersonalPanel() &&\n\t\t\t\t!group.isUser() &&\n\t\t\t\t!group.isUserGroup() && hasUpdateGroupPermission) {\n\n\t\t\t\tthemeDisplay.setShowSiteSettingsIcon(true);\n\n\t\t\t\tLiferayPortletURL siteSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.SITE_SETTINGS, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteSettingsURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site\");\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"showBackURL\", Boolean.FALSE.toString());\n\t\t\t\tsiteSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tif (PropsValues.DOCKBAR_ADMINISTRATIVE_LINKS_SHOW_IN_POP_UP) {\n\t\t\t\t\tsiteSettingsURL.setControlPanelCategory(\n\t\t\t\t\t\tPortletCategoryKeys.PORTLET);\n\t\t\t\t\tsiteSettingsURL.setParameter(\"closeRedirect\", currentURL);\n\t\t\t\t\tsiteSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\t\"redirect\", themeDisplay.getURLHome());\n\t\t\t\t\tsiteSettingsURL.setPlid(plid);\n\t\t\t\t\tsiteSettingsURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.MAXIMIZED);\n\t\t\t\t}\n\n\t\t\t\tthemeDisplay.setURLSiteSettings(siteSettingsURL);\n\t\t\t}\n\n\t\t\tif (!group.isLayoutPrototype() &&\n\t\t\t\t(hasAddLayoutGroupPermission || hasAddLayoutLayoutPermission ||\n\t\t\t\t hasManageLayoutsGroupPermission || hasUpdateGroupPermission)) {\n\n\t\t\t\tthemeDisplay.setShowSiteMapSettingsIcon(true);\n\n\t\t\t\tLiferayPortletURL siteMapSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.GROUP_PAGES, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteMapSettingsURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/group_pages/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tsiteMapSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tif (PropsValues.DOCKBAR_ADMINISTRATIVE_LINKS_SHOW_IN_POP_UP) {\n\t\t\t\t\tsiteMapSettingsURL.setControlPanelCategory(\n\t\t\t\t\t\tPortletCategoryKeys.PORTLET);\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\t\"closeRedirect\", currentURL);\n\t\t\t\t\tsiteMapSettingsURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.POP_UP);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\t\"redirect\", themeDisplay.getURLHome());\n\t\t\t\t\tsiteMapSettingsURL.setPlid(plid);\n\t\t\t\t\tsiteMapSettingsURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.MAXIMIZED);\n\t\t\t\t}\n\n\t\t\t\tthemeDisplay.setURLSiteMapSettings(siteMapSettingsURL);\n\t\t\t}\n\n\t\t\tif (group.hasStagingGroup() && !group.isStagingGroup()) {\n\t\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\tif (group.isControlPanel() || group.isUserPersonalPanel()) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\t// LEP-4987\n\n\t\t\tif (group.isStaged() || group.isStagingGroup()) {\n\t\t\t\tif (hasManageStagingPermission || hasPublishStagingPermission ||\n\t\t\t\t\thasUpdateLayoutPermission || hasViewStagingPermission) {\n\n\t\t\t\t\tthemeDisplay.setShowStagingIcon(true);\n\t\t\t\t}\n\n\t\t\t\tif (hasPublishStagingPermission) {\n\t\t\t\t\tPortletURL publishToLiveURL = new PortletURLImpl(\n\t\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, plid,\n\t\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/layouts_admin/publish_layouts\");\n\n\t\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t\t}\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\t\t\t\t\tpublishToLiveURL.setPortletMode(PortletMode.VIEW);\n\t\t\t\t\tpublishToLiveURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.EXCLUSIVE);\n\n\t\t\t\t\tthemeDisplay.setURLPublishToLive(publishToLiveURL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPortlet myAccountPortlet = PortalUtil.getFirstMyAccountPortlet(\n\t\t\t\tthemeDisplay);\n\n\t\t\tif (myAccountPortlet != null) {\n\t\t\t\tPortletURLImpl myAccountURL = new PortletURLImpl(\n\t\t\t\t\trequest, myAccountPortlet.getPortletId(), controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tif (signedIn) {\n\t\t\t\t\tmyAccountURL.setDoAsGroupId(user.getGroupId());\n\t\t\t\t}\n\t\t\t\telse if (scopeGroupId > 0) {\n\t\t\t\t\tmyAccountURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\t}\n\n\t\t\t\tif (refererPlid > 0) {\n\t\t\t\t\tmyAccountURL.setRefererPlid(refererPlid);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmyAccountURL.setRefererPlid(plid);\n\t\t\t\t}\n\n\t\t\t\tmyAccountURL.setWindowState(WindowState.MAXIMIZED);\n\n\t\t\t\tthemeDisplay.setURLMyAccount(myAccountURL);\n\t\t\t}\n\t\t}\n\n\t\tif (!user.isActive() ||\n\t\t\t(PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.TERMS_OF_USE_REQUIRED) &&\n\t\t\t !user.isAgreedToTermsOfUse())) {\n\n\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t}\n\n\t\tif ((layout != null) && layout.isLayoutPrototypeLinkActive()) {\n\t\t\tthemeDisplay.setShowPageCustomizationIcon(false);\n\t\t}\n\n\t\tif (group.isLayoutPrototype()) {\n\t\t\tthemeDisplay.setShowHomeIcon(false);\n\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageCustomizationIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\t\t\tthemeDisplay.setShowPortalIcon(false);\n\t\t\tthemeDisplay.setShowSignInIcon(false);\n\t\t\tthemeDisplay.setShowSignOutIcon(false);\n\t\t\tthemeDisplay.setShowSiteAdministrationIcon(false);\n\t\t\tthemeDisplay.setShowSiteSettingsIcon(false);\n\t\t\tthemeDisplay.setShowStagingIcon(false);\n\t\t}\n\n\t\tif (group.isLayoutSetPrototype()) {\n\t\t\tthemeDisplay.setShowPageCustomizationIcon(false);\n\t\t\tthemeDisplay.setShowSiteSettingsIcon(false);\n\t\t}\n\n\t\tif (group.hasStagingGroup() && !group.isStagingGroup()) {\n\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(false);\n\t\t\tthemeDisplay.setShowPageCustomizationIcon(false);\n\t\t\tthemeDisplay.setShowSiteMapSettingsIcon(false);\n\t\t\tthemeDisplay.setShowSiteSettingsIcon(false);\n\t\t}\n\n\t\tthemeDisplay.setURLPortal(portalURL.concat(contextPath));\n\n\t\tboolean secure = false;\n\n\t\tif (PropsValues.COMPANY_SECURITY_AUTH_REQUIRES_HTTPS ||\n\t\t\trequest.isSecure()) {\n\n\t\t\tsecure = true;\n\t\t}\n\n\t\tString securePortalURL = PortalUtil.getPortalURL(request, secure);\n\n\t\tString urlSignIn = securePortalURL.concat(mainPath).concat(\n\t\t\t_PATH_PORTAL_LOGIN);\n\n\t\tif (layout != null) {\n\t\t\turlSignIn = HttpUtil.addParameter(\n\t\t\t\turlSignIn, \"p_l_id\", layout.getPlid());\n\t\t}\n\n\t\tthemeDisplay.setURLSignIn(urlSignIn);\n\n\t\tthemeDisplay.setURLSignOut(mainPath.concat(_PATH_PORTAL_LOGOUT));\n\n\t\tPortletURL updateManagerURL = new PortletURLImpl(\n\t\t\trequest, PortletKeys.MARKETPLACE_STORE, controlPanelPlid,\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tthemeDisplay.setURLUpdateManager(updateManagerURL);\n\n\t\treturn themeDisplay;\n\t}","commit_id":"4f107775e4a65dabfd2ca3dc21a3eff43dc52275","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getThemeSetting(String key, String device) {\n\t\tUnicodeProperties settingsProperties = getSettingsProperties();\n\n\t\tString value = settingsProperties.getProperty(\n\t\t\tThemeSettingImpl.namespaceProperty(device, key));\n\n\t\tif (value != null) {\n\t\t\treturn value;\n\t\t}\n\n\t\tTheme theme = null;\n\n\t\tboolean controlPanel = false;\n\n\t\ttry {\n\t\t\tGroup group = getGroup();\n\n\t\t\tcontrolPanel = group.isControlPanel();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tif (controlPanel) {\n\t\t\tString themeId = PrefsPropsUtil.getString(\n\t\t\t\tgetCompanyId(),\n\t\t\t\tPropsKeys.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID);\n\n\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\tgetCompanyId(), themeId, !device.equals(\"regular\"));\n\t\t}\n\t\telse if (device.equals(\"regular\")) {\n\t\t\ttheme = getTheme();\n\t\t}\n\t\telse {\n\t\t\ttheme = getWapTheme();\n\t\t}\n\n\t\tvalue = theme.getSetting(key);\n\n\t\treturn value;\n\t}","id":49830,"modified_method":"@Override\n\tpublic String getThemeSetting(String key, String device) {\n\t\tUnicodeProperties settingsProperties = getSettingsProperties();\n\n\t\tString value = settingsProperties.getProperty(\n\t\t\tThemeSettingImpl.namespaceProperty(device, key));\n\n\t\tif (value != null) {\n\t\t\treturn value;\n\t\t}\n\n\t\tTheme theme = null;\n\n\t\tboolean controlPanel = false;\n\t\tboolean userPersonalPanel = false;\n\n\t\ttry {\n\t\t\tGroup group = getGroup();\n\n\t\t\tcontrolPanel = group.isControlPanel();\n\t\t\tuserPersonalPanel = group.isUserPersonalPanel();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tif (controlPanel || userPersonalPanel) {\n\t\t\tString themeId = PrefsPropsUtil.getString(\n\t\t\t\tgetCompanyId(),\n\t\t\t\tPropsKeys.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID);\n\n\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\tgetCompanyId(), themeId, !device.equals(\"regular\"));\n\t\t}\n\t\telse if (device.equals(\"regular\")) {\n\t\t\ttheme = getTheme();\n\t\t}\n\t\telse {\n\t\t\ttheme = getWapTheme();\n\t\t}\n\n\t\tvalue = theme.getSetting(key);\n\n\t\treturn value;\n\t}","commit_id":"9040e07cdf4e0fea17d1a991a3a82d5bc3b8a705","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Theme getTheme(String device) {\n\t\tboolean controlPanel = false;\n\n\t\ttry {\n\t\t\tGroup group = getGroup();\n\n\t\t\tcontrolPanel = group.isControlPanel();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tif (controlPanel) {\n\t\t\tString themeId = PrefsPropsUtil.getString(\n\t\t\t\tgetCompanyId(),\n\t\t\t\tPropsKeys.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID);\n\n\t\t\treturn ThemeLocalServiceUtil.getTheme(\n\t\t\t\tgetCompanyId(), themeId, !device.equals(\"regular\"));\n\t\t}\n\t\telse if (device.equals(\"regular\")) {\n\t\t\treturn getTheme();\n\t\t}\n\t\telse {\n\t\t\treturn getWapTheme();\n\t\t}\n\t}","id":49831,"modified_method":"protected Theme getTheme(String device) {\n\t\tboolean controlPanel = false;\n\t\tboolean userPersonalPanel = false;\n\n\t\ttry {\n\t\t\tGroup group = getGroup();\n\n\t\t\tcontrolPanel = group.isControlPanel();\n\t\t\tuserPersonalPanel = group.isUserPersonalPanel();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t}\n\n\t\tif (controlPanel || userPersonalPanel) {\n\t\t\tString themeId = PrefsPropsUtil.getString(\n\t\t\t\tgetCompanyId(),\n\t\t\t\tPropsKeys.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID);\n\n\t\t\treturn ThemeLocalServiceUtil.getTheme(\n\t\t\t\tgetCompanyId(), themeId, !device.equals(\"regular\"));\n\t\t}\n\t\telse if (device.equals(\"regular\")) {\n\t\t\treturn getTheme();\n\t\t}\n\t\telse {\n\t\t\treturn getWapTheme();\n\t\t}\n\t}","commit_id":"9040e07cdf4e0fea17d1a991a3a82d5bc3b8a705","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ThemeDisplay initThemeDisplay(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tHttpSession session = request.getSession();\n\n\t\t// Company\n\n\t\tCompany company = PortalUtil.getCompany(request);\n\n\t\tlong companyId = company.getCompanyId();\n\n\t\t// CDN host\n\n\t\tString cdnHost = PortalUtil.getCDNHost(request);\n\n\t\tString dynamicResourcesCDNHost = StringPool.BLANK;\n\n\t\tboolean cdnDynamicResourceEnabled =\n\t\t\tPortalUtil.isCDNDynamicResourcesEnabled(request);\n\n\t\tif (cdnDynamicResourceEnabled) {\n\t\t\tdynamicResourcesCDNHost = cdnHost;\n\t\t}\n\n\t\t// Portal URL\n\n\t\tString portalURL = PortalUtil.getPortalURL(request);\n\n\t\t// Paths\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\t\tString friendlyURLPrivateGroupPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateGroup();\n\t\tString friendlyURLPrivateUserPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateUser();\n\t\tString friendlyURLPublicPath = PortalUtil.getPathFriendlyURLPublic();\n\t\tString imagePath = dynamicResourcesCDNHost.concat(\n\t\t\tPortalUtil.getPathImage());\n\t\tString mainPath = PortalUtil.getPathMain();\n\n\t\tString i18nPath = (String)request.getAttribute(WebKeys.I18N_PATH);\n\n\t\tif (Validator.isNotNull(i18nPath)) {\n\t\t\tif (Validator.isNotNull(contextPath)) {\n\t\t\t\tString i18nContextPath = contextPath.concat(i18nPath);\n\n\t\t\t\tfriendlyURLPrivateGroupPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateGroupPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPrivateUserPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateUserPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPublicPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPublicPath, contextPath, i18nContextPath);\n\t\t\t\tmainPath = StringUtil.replaceFirst(\n\t\t\t\t\tmainPath, contextPath, i18nContextPath);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfriendlyURLPrivateGroupPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateGroupPath);\n\t\t\t\tfriendlyURLPrivateUserPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateUserPath);\n\t\t\t\tfriendlyURLPublicPath = i18nPath.concat(friendlyURLPublicPath);\n\t\t\t\tmainPath = i18nPath.concat(mainPath);\n\t\t\t}\n\t\t}\n\n\t\t// Company logo\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(imagePath);\n\t\tsb.append(\"/company_logo?img_id=\");\n\t\tsb.append(company.getLogoId());\n\t\tsb.append(\"&t=\");\n\t\tsb.append(WebServerServletTokenUtil.getToken(company.getLogoId()));\n\n\t\tString companyLogo = sb.toString();\n\n\t\tint companyLogoHeight = 0;\n\t\tint companyLogoWidth = 0;\n\n\t\tImage companyLogoImage = null;\n\n\t\tif (company.getLogoId() > 0) {\n\t\t\tcompanyLogoImage = ImageLocalServiceUtil.getCompanyLogo(\n\t\t\t\tcompany.getLogoId());\n\t\t}\n\t\telse {\n\t\t\tcompanyLogoImage = ImageToolUtil.getDefaultCompanyLogo();\n\t\t}\n\n\t\tif (companyLogoImage != null) {\n\t\t\tcompanyLogoHeight = companyLogoImage.getHeight();\n\t\t\tcompanyLogoWidth = companyLogoImage.getWidth();\n\t\t}\n\n\t\tString realCompanyLogo = companyLogo;\n\t\tint realCompanyLogoHeight = companyLogoHeight;\n\t\tint realCompanyLogoWidth = companyLogoWidth;\n\n\t\t// User\n\n\t\tUser user = null;\n\n\t\ttry {\n\t\t\tuser = PortalUtil.initUser(request);\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t\treturn null;\n\t\t}\n\n\t\tboolean signedIn = !user.isDefaultUser();\n\n\t\tif (PropsValues.BROWSER_CACHE_DISABLED ||\n\t\t\t(PropsValues.BROWSER_CACHE_SIGNED_IN_DISABLED && signedIn)) {\n\n\t\t\tresponse.setDateHeader(HttpHeaders.EXPIRES, 0);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.CACHE_CONTROL,\n\t\t\t\tHttpHeaders.CACHE_CONTROL_NO_CACHE_VALUE);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.PRAGMA, HttpHeaders.PRAGMA_NO_CACHE_VALUE);\n\t\t}\n\n\t\tUser realUser = user;\n\n\t\tLong realUserId = (Long)session.getAttribute(WebKeys.USER_ID);\n\n\t\tif (realUserId != null) {\n\t\t\tif (user.getUserId() != realUserId.longValue()) {\n\t\t\t\trealUser = UserLocalServiceUtil.getUserById(\n\t\t\t\t\trealUserId.longValue());\n\t\t\t}\n\t\t}\n\n\t\tString doAsUserId = ParamUtil.getString(request, \"doAsUserId\");\n\t\tString doAsUserLanguageId = ParamUtil.getString(\n\t\t\trequest, \"doAsUserLanguageId\");\n\t\tlong doAsGroupId = ParamUtil.getLong(request, \"doAsGroupId\");\n\n\t\tlong refererGroupId = ParamUtil.getLong(request, \"refererGroupId\");\n\n\t\tlong refererPlid = ParamUtil.getLong(request, \"refererPlid\");\n\n\t\tif (LayoutLocalServiceUtil.fetchLayout(refererPlid) == null) {\n\t\t\trefererPlid = 0;\n\t\t}\n\n\t\tString controlPanelCategory = ParamUtil.getString(\n\t\t\trequest, \"controlPanelCategory\");\n\n\t\t// Permission checker\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tPermissionCheckerFactoryUtil.create(user);\n\n\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t// Cookie support\n\n\t\ttry {\n\n\t\t\t// LEP-4069\n\n\t\t\tCookieKeys.validateSupportCookie(request);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tCookieKeys.addSupportCookie(request, response);\n\t\t}\n\n\t\t// Time zone\n\n\t\tTimeZone timeZone = user.getTimeZone();\n\n\t\tif (timeZone == null) {\n\t\t\ttimeZone = company.getTimeZone();\n\t\t}\n\n\t\t// Layouts\n\n\t\tif (signedIn) {\n\t\t\tupdateUserLayouts(user);\n\t\t}\n\n\t\tLayout layout = null;\n\t\tList<Layout> layouts = null;\n\n\t\tlong plid = ParamUtil.getLong(request, \"p_l_id\");\n\n\t\tboolean viewableSourceGroup = true;\n\n\t\tif (plid > 0) {\n\t\t\tlayout = LayoutLocalServiceUtil.getLayout(plid);\n\t\t}\n\t\telse {\n\t\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\t\t\tboolean privateLayout = ParamUtil.getBoolean(\n\t\t\t\trequest, \"privateLayout\");\n\t\t\tlong layoutId = ParamUtil.getLong(request, \"layoutId\");\n\n\t\t\tif ((groupId > 0) && (layoutId > 0)) {\n\t\t\t\tlayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tgroupId, privateLayout, layoutId);\n\t\t\t}\n\t\t}\n\n\t\tif (layout != null) {\n\t\t\tlong sourceGroupId = ParamUtil.getLong(request, \"p_v_l_s_g_id\");\n\n\t\t\tif ((sourceGroupId > 0) && (sourceGroupId != layout.getGroupId())) {\n\t\t\t\tGroup sourceGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\t\tsourceGroupId);\n\n\t\t\t\tif (layout.isPublicLayout() ||\n\t\t\t\t\tSitesUtil.isUserGroupLayoutSetViewable(\n\t\t\t\t\t\tpermissionChecker, layout.getGroup())) {\n\n\t\t\t\t\tlayout = new VirtualLayout(layout, sourceGroup);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tviewableSourceGroup = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString ppid = ParamUtil.getString(request, \"p_p_id\");\n\n\t\tBoolean redirectToDefaultLayout = (Boolean)request.getAttribute(\n\t\t\tWebKeys.REDIRECT_TO_DEFAULT_LAYOUT);\n\n\t\tif (redirectToDefaultLayout == null) {\n\t\t\tredirectToDefaultLayout = Boolean.FALSE;\n\t\t}\n\n\t\tif (layout != null) {\n\t\t\tGroup group = layout.getGroup();\n\n\t\t\tif (!signedIn && PropsValues.AUTH_FORWARD_BY_REDIRECT) {\n\t\t\t\trequest.setAttribute(WebKeys.REQUESTED_LAYOUT, layout);\n\t\t\t}\n\n\t\t\tif ((Validator.isNull(controlPanelCategory) ||\n\t\t\t\t controlPanelCategory.equals(PortletCategoryKeys.MY) ||\n\t\t\t\t controlPanelCategory.equals(PortletCategoryKeys.PORTLET)) &&\n\t\t\t\tValidator.isNotNull(ppid) &&\n\t\t\t\t(LiferayWindowState.isPopUp(request) ||\n\t\t\t\t LiferayWindowState.isExclusive(request))) {\n\n\t\t\t\tcontrolPanelCategory = PortletCategoryKeys.PORTLET;\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(ppid)) {\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tcompanyId, ppid);\n\n\t\t\t\tString portletControlPanelEntryCategory =\n\t\t\t\t\tportlet.getControlPanelEntryCategory();\n\n\t\t\t\tif (!controlPanelCategory.startsWith(\n\t\t\t\t\t\tPortletCategoryKeys.CURRENT_SITE) &&\n\t\t\t\t\tportletControlPanelEntryCategory.startsWith(\n\t\t\t\t\t\tPortletCategoryKeys.SITE_ADMINISTRATION)) {\n\n\t\t\t\t\tportletControlPanelEntryCategory =\n\t\t\t\t\t\tPortletCategoryKeys.SITES;\n\t\t\t\t}\n\n\t\t\t\tif (!controlPanelCategory.startsWith(\n\t\t\t\t\t\tPortletCategoryKeys.CURRENT_SITE) &&\n\t\t\t\t\tValidator.isNotNull(portletControlPanelEntryCategory)) {\n\n\t\t\t\t\tcontrolPanelCategory = portletControlPanelEntryCategory;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean viewableGroup = hasAccessPermission(\n\t\t\t\tpermissionChecker, layout, doAsGroupId, controlPanelCategory,\n\t\t\t\ttrue);\n\t\t\tboolean viewableStaging =\n\t\t\t\t!group.isControlPanel() &&\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, group, ActionKeys.VIEW_STAGING);\n\n\t\t\tif (viewableStaging) {\n\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\t\t\t}\n\t\t\telse if ((!viewableGroup || !viewableSourceGroup) &&\n\t\t\t\t\t group.isStagingGroup()) {\n\n\t\t\t\tlayout = null;\n\t\t\t}\n\t\t\telse if (!isLoginRequest(request) &&\n\t\t\t\t\t (!viewableGroup || !viewableSourceGroup ||\n\t\t\t\t\t  (!redirectToDefaultLayout &&\n\t\t\t\t\t   !hasAccessPermission(\n\t\t\t\t\t\t   permissionChecker, layout, doAsGroupId,\n\t\t\t\t\t\t   controlPanelCategory, false)))) {\n\n\t\t\t\tif (user.isDefaultUser() &&\n\t\t\t\t\tPropsValues.AUTH_LOGIN_PROMPT_ENABLED) {\n\n\t\t\t\t\tthrow new PrincipalException(\"User is not authenticated\");\n\t\t\t\t}\n\n\t\t\t\tsb = new StringBundler(6);\n\n\t\t\t\tsb.append(\"User \");\n\t\t\t\tsb.append(user.getUserId());\n\t\t\t\tsb.append(\" is not allowed to access the \");\n\t\t\t\tsb.append(layout.isPrivateLayout() ? \"private\": \"public\");\n\t\t\t\tsb.append(\" pages of group \");\n\t\t\t\tsb.append(layout.getGroupId());\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(sb.toString());\n\t\t\t\t}\n\n\t\t\t\tthrow new NoSuchLayoutException(sb.toString());\n\t\t\t}\n\t\t\telse if (isLoginRequest(request) && !viewableGroup) {\n\t\t\t\tlayout = null;\n\t\t\t}\n\t\t\telse if (group.isLayoutPrototype()) {\n\t\t\t\tlayouts = new ArrayList<>();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\t\t\tif (!group.isControlPanel()) {\n\t\t\t\t\tdoAsGroupId = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tList<Layout> unfilteredLayouts = layouts;\n\n\t\tif (layout == null) {\n\t\t\tObject[] defaultLayout = getDefaultLayout(request, user, signedIn);\n\n\t\t\tlayout = (Layout)defaultLayout[0];\n\t\t\tlayouts = (List<Layout>)defaultLayout[1];\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT_DEFAULT, Boolean.TRUE);\n\t\t}\n\n\t\tObject[] viewableLayouts = getViewableLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts, doAsGroupId,\n\t\t\tcontrolPanelCategory);\n\n\t\tString layoutSetLogo = null;\n\n\t\tlayout = (Layout)viewableLayouts[0];\n\t\tlayouts = (List<Layout>)viewableLayouts[1];\n\n\t\tGroup group = null;\n\n\t\tif (layout != null) {\n\t\t\tgroup = layout.getGroup();\n\n\t\t\tif (!group.isControlPanel()) {\n\t\t\t\trememberVisitedGroupIds(request, group.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\tLayoutTypePortlet layoutTypePortlet = null;\n\n\t\tlayouts = mergeAdditionalLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts, doAsGroupId,\n\t\t\tcontrolPanelCategory);\n\n\t\tLayoutSet layoutSet = null;\n\n\t\tboolean hasAddLayoutLayoutPermission = false;\n\t\tboolean hasCustomizeLayoutPermission = false;\n\t\tboolean hasDeleteLayoutPermission = false;\n\t\tboolean hasUpdateLayoutPermission = false;\n\n\t\tboolean customizedView = SessionParamUtil.getBoolean(\n\t\t\trequest, \"customized_view\", true);\n\n\t\tif (layout != null) {\n\t\t\tLayoutType layoutType = layout.getLayoutType();\n\n\t\t\tLayoutTypeAccessPolicy layoutTypeAccessPolicy =\n\t\t\t\tlayoutType.getLayoutTypeAccessPolicy();\n\n\t\t\thasAddLayoutLayoutPermission =\n\t\t\t\tlayoutTypeAccessPolicy.isAddLayoutAllowed(\n\t\t\t\t\tpermissionChecker, layout);\n\t\t\thasCustomizeLayoutPermission =\n\t\t\t\tlayoutTypeAccessPolicy.isCustomizeLayoutAllowed(\n\t\t\t\t\tpermissionChecker, layout);\n\t\t\thasDeleteLayoutPermission =\n\t\t\t\tlayoutTypeAccessPolicy.isDeleteLayoutAllowed(\n\t\t\t\t\tpermissionChecker, layout);\n\t\t\thasUpdateLayoutPermission =\n\t\t\t\tlayoutTypeAccessPolicy.isUpdateLayoutAllowed(\n\t\t\t\t\tpermissionChecker, layout);\n\n\t\t\tlayoutSet = layout.getLayoutSet();\n\n\t\t\tif (company.isSiteLogo()) {\n\t\t\t\tlong logoId = 0;\n\n\t\t\t\tif (layoutSet.isLogo()) {\n\t\t\t\t\tlogoId = layoutSet.getLogoId();\n\n\t\t\t\t\tif (logoId == 0) {\n\t\t\t\t\t\tlogoId = layoutSet.getLiveLogoId();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLayoutSet siblingLayoutSet =\n\t\t\t\t\t\tLayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\t\t\tlayout.getGroupId(), !layout.isPrivateLayout());\n\n\t\t\t\t\tif (siblingLayoutSet.isLogo()) {\n\t\t\t\t\t\tlogoId = siblingLayoutSet.getLogoId();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (logoId > 0) {\n\t\t\t\t\tsb = new StringBundler(5);\n\n\t\t\t\t\tsb.append(imagePath);\n\t\t\t\t\tsb.append(\"/layout_set_logo?img_id=\");\n\t\t\t\t\tsb.append(logoId);\n\t\t\t\t\tsb.append(\"&t=\");\n\t\t\t\t\tsb.append(WebServerServletTokenUtil.getToken(logoId));\n\n\t\t\t\t\tlayoutSetLogo = sb.toString();\n\n\t\t\t\t\tImage layoutSetLogoImage =\n\t\t\t\t\t\tImageLocalServiceUtil.getCompanyLogo(logoId);\n\n\t\t\t\t\tcompanyLogo = layoutSetLogo;\n\t\t\t\t\tcompanyLogoHeight = layoutSetLogoImage.getHeight();\n\t\t\t\t\tcompanyLogoWidth = layoutSetLogoImage.getWidth();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplid = layout.getPlid();\n\n\t\t\t// Updates to shared layouts are not reflected until the next time\n\t\t\t// the user logs in because group layouts are cached in the session\n\n\t\t\tlayout = (Layout)layout.clone();\n\n\t\t\tlayoutTypePortlet = (LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\tboolean customizable = layoutTypePortlet.isCustomizable();\n\n\t\t\tif (!customizable ||\n\t\t\t\tgroup.isLayoutPrototype() || group.isLayoutSetPrototype() ||\n\t\t\t\tgroup.isStagingGroup()) {\n\n\t\t\t\tcustomizedView = false;\n\t\t\t}\n\n\t\t\tlayoutTypePortlet.setCustomizedView(customizedView);\n\t\t\tlayoutTypePortlet.setUpdatePermission(hasUpdateLayoutPermission);\n\n\t\t\tif (signedIn && customizable && customizedView &&\n\t\t\t\thasCustomizeLayoutPermission) {\n\n\t\t\t\tPortalPreferences portalPreferences =\n\t\t\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(\n\t\t\t\t\t\tuser.getUserId(), true);\n\n\t\t\t\tlayoutTypePortlet.setPortalPreferences(portalPreferences);\n\t\t\t}\n\n\t\t\tLayoutClone layoutClone = LayoutCloneFactory.getInstance();\n\n\t\t\tif (layoutClone != null) {\n\t\t\t\tString typeSettings = layoutClone.get(request, plid);\n\n\t\t\t\tif (typeSettings != null) {\n\t\t\t\t\tUnicodeProperties typeSettingsProperties =\n\t\t\t\t\t\tnew UnicodeProperties(true);\n\n\t\t\t\t\ttypeSettingsProperties.load(typeSettings);\n\n\t\t\t\t\tString stateMax = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MAX);\n\t\t\t\t\tString stateMin = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MIN);\n\t\t\t\t\tString modeAbout = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_ABOUT);\n\t\t\t\t\tString modeConfig = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_CONFIG);\n\t\t\t\t\tString modeEdit = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT);\n\t\t\t\t\tString modeEditDefaults =\n\t\t\t\t\t\ttypeSettingsProperties.getProperty(\n\t\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_DEFAULTS);\n\t\t\t\t\tString modeEditGuest = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_GUEST);\n\t\t\t\t\tString modeHelp = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_HELP);\n\t\t\t\t\tString modePreview = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PREVIEW);\n\t\t\t\t\tString modePrint = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PRINT);\n\n\t\t\t\t\tlayoutTypePortlet.setStateMax(stateMax);\n\t\t\t\t\tlayoutTypePortlet.setStateMin(stateMin);\n\t\t\t\t\tlayoutTypePortlet.setModeAbout(modeAbout);\n\t\t\t\t\tlayoutTypePortlet.setModeConfig(modeConfig);\n\t\t\t\t\tlayoutTypePortlet.setModeEdit(modeEdit);\n\t\t\t\t\tlayoutTypePortlet.setModeEditDefaults(modeEditDefaults);\n\t\t\t\t\tlayoutTypePortlet.setModeEditGuest(modeEditGuest);\n\t\t\t\t\tlayoutTypePortlet.setModeHelp(modeHelp);\n\t\t\t\t\tlayoutTypePortlet.setModePreview(modePreview);\n\t\t\t\t\tlayoutTypePortlet.setModePrint(modePrint);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT, layout);\n\t\t\trequest.setAttribute(WebKeys.LAYOUTS, layouts);\n\t\t}\n\n\t\t// Locale\n\n\t\tString i18nLanguageId = (String)request.getAttribute(\n\t\t\tWebKeys.I18N_LANGUAGE_ID);\n\n\t\tLocale locale = PortalUtil.getLocale(request, response, true);\n\n\t\t// Scope\n\n\t\tlong scopeGroupId = PortalUtil.getScopeGroupId(request);\n\n\t\tif (group.isInheritContent()) {\n\t\t\tscopeGroupId = group.getParentGroupId();\n\t\t}\n\n\t\tif ((scopeGroupId <= 0) && (doAsGroupId > 0)) {\n\t\t\tscopeGroupId = doAsGroupId;\n\t\t}\n\n\t\tlong siteGroupId = 0;\n\n\t\tif (layout != null) {\n\t\t\tif (layout.isTypeControlPanel()) {\n\t\t\t\tsiteGroupId = PortalUtil.getSiteGroupId(scopeGroupId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsiteGroupId = PortalUtil.getSiteGroupId(layout.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\t// Theme and color scheme\n\n\t\tTheme theme = null;\n\t\tColorScheme colorScheme = null;\n\n\t\tboolean wapTheme = BrowserSnifferUtil.isWap(request);\n\n\t\tif ((layout != null) && group.isControlPanel()) {\n\t\t\tString themeId = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsKeys.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID);\n\t\t\tString colorSchemeId =\n\t\t\t\tColorSchemeFactoryUtil.getDefaultRegularColorSchemeId();\n\n\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\tcompanyId, themeId, wapTheme);\n\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, wapTheme);\n\n\t\t\tif (!wapTheme && theme.isWapTheme()) {\n\t\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tPropsValues.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID, false);\n\t\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, false);\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.THEME, theme);\n\t\t\trequest.setAttribute(WebKeys.COLOR_SCHEME, colorScheme);\n\t\t}\n\n\t\tboolean themeCssFastLoad = PropsValues.THEME_CSS_FAST_LOAD;\n\n\t\tif (PropsValues.THEME_CSS_FAST_LOAD_CHECK_REQUEST_PARAMETER) {\n\t\t\tthemeCssFastLoad = SessionParamUtil.getBoolean(\n\t\t\t\trequest, \"css_fast_load\", PropsValues.THEME_CSS_FAST_LOAD);\n\t\t}\n\n\t\tboolean themeImagesFastLoad = PropsValues.THEME_IMAGES_FAST_LOAD;\n\n\t\tif (PropsValues.THEME_IMAGES_FAST_LOAD_CHECK_REQUEST_PARAMETER) {\n\t\t\tSessionParamUtil.getBoolean(\n\t\t\t\trequest, \"images_fast_load\",\n\t\t\t\tPropsValues.THEME_IMAGES_FAST_LOAD);\n\t\t}\n\n\t\tboolean themeJsBarebone = PropsValues.JAVASCRIPT_BAREBONE_ENABLED;\n\n\t\tif (themeJsBarebone) {\n\t\t\tif (signedIn) {\n\t\t\t\tthemeJsBarebone = false;\n\t\t\t}\n\t\t}\n\n\t\tboolean themeJsFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"js_fast_load\", PropsValues.JAVASCRIPT_FAST_LOAD);\n\n\t\tString lifecycle = ParamUtil.getString(request, \"p_p_lifecycle\", \"0\");\n\n\t\tlifecycle = ParamUtil.getString(request, \"p_t_lifecycle\", lifecycle);\n\n\t\tboolean isolated = ParamUtil.getBoolean(request, \"p_p_isolated\");\n\n\t\tString facebookCanvasPageURL = (String)request.getAttribute(\n\t\t\tWebKeys.FACEBOOK_CANVAS_PAGE_URL);\n\n\t\tboolean widget = false;\n\n\t\tBoolean widgetObj = (Boolean)request.getAttribute(WebKeys.WIDGET);\n\n\t\tif (widgetObj != null) {\n\t\t\twidget = widgetObj.booleanValue();\n\t\t}\n\n\t\t// Theme display\n\n\t\tThemeDisplay themeDisplay = ThemeDisplayFactory.create();\n\n\t\tthemeDisplay.setRequest(request);\n\n\t\t// Set attributes first that other methods (getCDNBaseURL and\n\t\t// setLookAndFeel) depend on\n\n\t\tthemeDisplay.setCDNHost(cdnHost);\n\t\tthemeDisplay.setCDNDynamicResourcesHost(dynamicResourcesCDNHost);\n\t\tthemeDisplay.setFacebookCanvasPageURL(facebookCanvasPageURL);\n\t\tthemeDisplay.setPortalURL(portalURL);\n\t\tthemeDisplay.setRefererPlid(refererPlid);\n\t\tthemeDisplay.setSecure(request.isSecure());\n\t\tthemeDisplay.setServerName(request.getServerName());\n\t\tthemeDisplay.setServerPort(request.getServerPort());\n\t\tthemeDisplay.setWidget(widget);\n\n\t\tthemeDisplay.setCompany(company);\n\t\tthemeDisplay.setCompanyLogo(companyLogo);\n\t\tthemeDisplay.setCompanyLogoHeight(companyLogoHeight);\n\t\tthemeDisplay.setCompanyLogoWidth(companyLogoWidth);\n\t\tthemeDisplay.setControlPanelCategory(controlPanelCategory);\n\t\tthemeDisplay.setDoAsGroupId(doAsGroupId);\n\t\tthemeDisplay.setDoAsUserId(doAsUserId);\n\t\tthemeDisplay.setDoAsUserLanguageId(doAsUserLanguageId);\n\t\tthemeDisplay.setI18nLanguageId(i18nLanguageId);\n\t\tthemeDisplay.setI18nPath(i18nPath);\n\t\tthemeDisplay.setIsolated(isolated);\n\t\tthemeDisplay.setLanguageId(LocaleUtil.toLanguageId(locale));\n\t\tthemeDisplay.setLayout(layout);\n\t\tthemeDisplay.setLayouts(layouts);\n\t\tthemeDisplay.setLayoutSet(layoutSet);\n\t\tthemeDisplay.setLayoutSetLogo(layoutSetLogo);\n\t\tthemeDisplay.setLayoutTypePortlet(layoutTypePortlet);\n\t\tthemeDisplay.setLifecycle(lifecycle);\n\t\tthemeDisplay.setLifecycleAction(lifecycle.equals(\"1\"));\n\t\tthemeDisplay.setLifecycleEvent(lifecycle.equals(\"3\"));\n\t\tthemeDisplay.setLifecycleRender(lifecycle.equals(\"0\"));\n\t\tthemeDisplay.setLifecycleResource(lifecycle.equals(\"2\"));\n\t\tthemeDisplay.setLocale(locale);\n\t\tthemeDisplay.setLookAndFeel(theme, colorScheme);\n\t\tthemeDisplay.setPathApplet(contextPath.concat(\"/applets\"));\n\t\tthemeDisplay.setPathCms(contextPath.concat(\"/cms\"));\n\t\tthemeDisplay.setPathContext(contextPath);\n\t\tthemeDisplay.setPathFlash(contextPath.concat(\"/flash\"));\n\t\tthemeDisplay.setPathFriendlyURLPrivateGroup(\n\t\t\tfriendlyURLPrivateGroupPath);\n\t\tthemeDisplay.setPathFriendlyURLPrivateUser(friendlyURLPrivateUserPath);\n\t\tthemeDisplay.setPathFriendlyURLPublic(friendlyURLPublicPath);\n\t\tthemeDisplay.setPathImage(imagePath);\n\t\tthemeDisplay.setPathJavaScript(\n\t\t\tPortalWebResourcesUtil.getContextPath().concat(\"/html/js\"));\n\t\tthemeDisplay.setPathMain(mainPath);\n\t\tthemeDisplay.setPathSound(contextPath.concat(\"/html/sound\"));\n\t\tthemeDisplay.setPermissionChecker(permissionChecker);\n\t\tthemeDisplay.setPlid(plid);\n\t\tthemeDisplay.setPpid(ppid);\n\t\tthemeDisplay.setRealCompanyLogo(realCompanyLogo);\n\t\tthemeDisplay.setRealCompanyLogoHeight(realCompanyLogoHeight);\n\t\tthemeDisplay.setRealCompanyLogoWidth(realCompanyLogoWidth);\n\t\tthemeDisplay.setRealUser(realUser);\n\t\tthemeDisplay.setRefererGroupId(refererGroupId);\n\t\tthemeDisplay.setScopeGroupId(scopeGroupId);\n\t\tthemeDisplay.setSignedIn(signedIn);\n\t\tthemeDisplay.setSiteDefaultLocale(\n\t\t\tPortalUtil.getSiteDefaultLocale(siteGroupId));\n\t\tthemeDisplay.setSiteGroupId(siteGroupId);\n\t\tthemeDisplay.setStateExclusive(LiferayWindowState.isExclusive(request));\n\t\tthemeDisplay.setStateMaximized(LiferayWindowState.isMaximized(request));\n\t\tthemeDisplay.setStatePopUp(LiferayWindowState.isPopUp(request));\n\t\tthemeDisplay.setThemeCssFastLoad(themeCssFastLoad);\n\t\tthemeDisplay.setThemeImagesFastLoad(themeImagesFastLoad);\n\t\tthemeDisplay.setThemeJsBarebone(themeJsBarebone);\n\t\tthemeDisplay.setThemeJsFastLoad(themeJsFastLoad);\n\t\tthemeDisplay.setTimeZone(timeZone);\n\t\tthemeDisplay.setUnfilteredLayouts(unfilteredLayouts);\n\t\tthemeDisplay.setUser(user);\n\n\t\t// Icons\n\n\t\tthemeDisplay.setShowAddContentIcon(false);\n\n\t\tboolean showControlPanelIcon = false;\n\n\t\tif (signedIn &&\n\t\t\tPortalPermissionUtil.contains(\n\t\t\t\tpermissionChecker, ActionKeys.VIEW_CONTROL_PANEL)) {\n\n\t\t\tshowControlPanelIcon = true;\n\t\t}\n\n\t\tthemeDisplay.setShowControlPanelIcon(showControlPanelIcon);\n\n\t\tthemeDisplay.setShowHomeIcon(true);\n\t\tthemeDisplay.setShowMyAccountIcon(signedIn);\n\t\tthemeDisplay.setShowPageSettingsIcon(hasDeleteLayoutPermission);\n\t\tthemeDisplay.setShowPortalIcon(true);\n\t\tthemeDisplay.setShowSignInIcon(!signedIn);\n\n\t\tboolean showSignOutIcon = signedIn;\n\n\t\tif (themeDisplay.isImpersonated()) {\n\t\t\tshowSignOutIcon = false;\n\t\t}\n\n\t\tthemeDisplay.setShowSignOutIcon(showSignOutIcon);\n\n\t\tthemeDisplay.setShowStagingIcon(false);\n\n\t\tboolean showSiteAdministrationIcon = false;\n\n\t\tif (signedIn &&\n\t\t\tGroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, group,\n\t\t\t\tActionKeys.VIEW_SITE_ADMINISTRATION)) {\n\n\t\t\tshowSiteAdministrationIcon = true;\n\t\t}\n\n\t\tthemeDisplay.setShowSiteAdministrationIcon(showSiteAdministrationIcon);\n\n\t\t// Session\n\n\t\tif (PropsValues.SESSION_ENABLE_URL_WITH_SESSION_ID &&\n\t\t\t!CookieKeys.hasSessionId(request)) {\n\n\t\t\tthemeDisplay.setAddSessionIdToURL(true);\n\t\t\tthemeDisplay.setSessionId(session.getId());\n\t\t}\n\n\t\t// URLs\n\n\t\tString urlControlPanel = friendlyURLPrivateGroupPath.concat(\n\t\t\tGroupConstants.CONTROL_PANEL_FRIENDLY_URL);\n\n\t\tif (Validator.isNotNull(doAsUserId)) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"doAsUserId\", doAsUserId);\n\t\t}\n\n\t\tif (refererGroupId > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererGroupId\", refererGroupId);\n\t\t}\n\t\telse if (scopeGroupId > 0) {\n\t\t\tLayout refererLayout = LayoutLocalServiceUtil.fetchLayout(plid);\n\n\t\t\tif (refererLayout != null) {\n\t\t\t\tGroup refererLayoutGroup = refererLayout.getGroup();\n\n\t\t\t\tif (refererLayoutGroup.isUserGroup()) {\n\t\t\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\t\t\turlControlPanel, \"refererGroupId\", scopeGroupId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (refererPlid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", refererPlid);\n\t\t}\n\t\telse if (plid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", plid);\n\t\t}\n\n\t\tif (themeDisplay.isAddSessionIdToURL()) {\n\t\t\turlControlPanel = PortalUtil.getURLWithSessionId(\n\t\t\t\turlControlPanel, session.getId());\n\t\t}\n\n\t\tthemeDisplay.setURLControlPanel(urlControlPanel);\n\n\t\tString currentURL = PortalUtil.getCurrentURL(request);\n\n\t\tthemeDisplay.setURLCurrent(currentURL);\n\n\t\tString urlHome = PortalUtil.getHomeURL(request);\n\n\t\tthemeDisplay.setURLHome(urlHome);\n\n\t\tString siteAdministrationURL = urlControlPanel;\n\n\t\tsiteAdministrationURL = HttpUtil.addParameter(\n\t\t\tsiteAdministrationURL, \"controlPanelCategory\",\n\t\t\tPortletCategoryKeys.CURRENT_SITE);\n\t\tsiteAdministrationURL = HttpUtil.addParameter(\n\t\t\tsiteAdministrationURL, \"doAsGroupId\", siteGroupId);\n\n\t\tthemeDisplay.setURLSiteAdministration(siteAdministrationURL);\n\n\t\tlong controlPanelPlid = PortalUtil.getControlPanelPlid(companyId);\n\n\t\tif (layout != null) {\n\t\t\tif (layout.isTypePortlet()) {\n\t\t\t\tboolean freeformLayout =\n\t\t\t\t\tlayoutTypePortlet.getLayoutTemplateId().equals(\"freeform\");\n\n\t\t\t\tthemeDisplay.setFreeformLayout(freeformLayout);\n\n\t\t\t\tif (hasUpdateLayoutPermission) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(true);\n\n\t\t\t\t\tif (!group.isUser()) {\n\t\t\t\t\t\tthemeDisplay.setShowPageCustomizationIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.Dockbar.loadAddPanel();\");\n\t\t\t\t}\n\n\t\t\t\tif (hasCustomizeLayoutPermission && customizedView) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.Dockbar.loadAddPanel();\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasUpdateLayoutPermission) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\n\t\t\t\tLiferayPortletURL pageSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.GROUP_PAGES, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tpageSettingsURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/group_pages/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tpageSettingsURL.setParameter(\"selPlid\", String.valueOf(plid));\n\t\t\t\tpageSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tif (PropsValues.DOCKBAR_ADMINISTRATIVE_LINKS_SHOW_IN_POP_UP) {\n\t\t\t\t\tpageSettingsURL.setControlPanelCategory(\n\t\t\t\t\t\tPortletCategoryKeys.PORTLET);\n\t\t\t\t\tpageSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\t\"redirect\", themeDisplay.getURLHome());\n\t\t\t\t\tpageSettingsURL.setPlid(plid);\n\t\t\t\t\tpageSettingsURL.setWindowState(WindowState.MAXIMIZED);\n\t\t\t\t}\n\n\t\t\t\tthemeDisplay.setURLPageSettings(pageSettingsURL);\n\n\t\t\t\tboolean site = group.isSite();\n\n\t\t\t\tif (!site && group.isStagingGroup()) {\n\t\t\t\t\tGroup liveGroup = group.getLiveGroup();\n\n\t\t\t\t\tsite = liveGroup.isSite();\n\t\t\t\t}\n\n\t\t\t\tif (site &&\n\t\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, scopeGroupId,\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS)) {\n\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(true);\n\n\t\t\t\t\tLiferayPortletURL manageSiteMembershipsURL =\n\t\t\t\t\t\tnew PortletURLImpl(\n\t\t\t\t\t\t\trequest, PortletKeys.SITE_MEMBERSHIPS_ADMIN,\n\t\t\t\t\t\t\tcontrolPanelPlid, PortletRequest.RENDER_PHASE);\n\n\t\t\t\t\tmanageSiteMembershipsURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site_assignments\");\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\t\t\t\t\tmanageSiteMembershipsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\t\tif (PropsValues.\n\t\t\t\t\t\t\tDOCKBAR_ADMINISTRATIVE_LINKS_SHOW_IN_POP_UP) {\n\n\t\t\t\t\t\tmanageSiteMembershipsURL.setControlPanelCategory(\n\t\t\t\t\t\t\tPortletCategoryKeys.PORTLET);\n\t\t\t\t\t\tmanageSiteMembershipsURL.setWindowState(\n\t\t\t\t\t\t\tLiferayWindowState.POP_UP);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\t\"redirect\", themeDisplay.getURLHome());\n\t\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\t\"showBackURL\", Boolean.FALSE.toString());\n\t\t\t\t\t\tmanageSiteMembershipsURL.setPlid(plid);\n\t\t\t\t\t\tmanageSiteMembershipsURL.setWindowState(\n\t\t\t\t\t\t\tWindowState.MAXIMIZED);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLManageSiteMemberships(\n\t\t\t\t\t\tmanageSiteMembershipsURL);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tGroup scopeGroup = GroupLocalServiceUtil.getGroup(scopeGroupId);\n\n\t\t\tboolean hasAddLayoutGroupPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.ADD_LAYOUT);\n\t\t\tboolean hasManageLayoutsGroupPermission =\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.MANAGE_LAYOUTS);\n\t\t\tboolean hasManageStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.MANAGE_STAGING);\n\t\t\tboolean hasPublishStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.PUBLISH_STAGING);\n\t\t\tboolean hasUpdateGroupPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.UPDATE);\n\t\t\tboolean hasViewStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.VIEW_STAGING);\n\n\t\t\tif (!group.isControlPanel() && !group.isUser() &&\n\t\t\t\t!group.isUserGroup() && hasUpdateGroupPermission) {\n\n\t\t\t\tthemeDisplay.setShowSiteSettingsIcon(true);\n\n\t\t\t\tLiferayPortletURL siteSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.SITE_SETTINGS, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteSettingsURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site\");\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"showBackURL\", Boolean.FALSE.toString());\n\t\t\t\tsiteSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tif (PropsValues.DOCKBAR_ADMINISTRATIVE_LINKS_SHOW_IN_POP_UP) {\n\t\t\t\t\tsiteSettingsURL.setControlPanelCategory(\n\t\t\t\t\t\tPortletCategoryKeys.PORTLET);\n\t\t\t\t\tsiteSettingsURL.setParameter(\"closeRedirect\", currentURL);\n\t\t\t\t\tsiteSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\t\"redirect\", themeDisplay.getURLHome());\n\t\t\t\t\tsiteSettingsURL.setPlid(plid);\n\t\t\t\t\tsiteSettingsURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.MAXIMIZED);\n\t\t\t\t}\n\n\t\t\t\tthemeDisplay.setURLSiteSettings(siteSettingsURL);\n\t\t\t}\n\n\t\t\tif (!group.isLayoutPrototype() &&\n\t\t\t\t(hasAddLayoutGroupPermission || hasAddLayoutLayoutPermission ||\n\t\t\t\t hasManageLayoutsGroupPermission || hasUpdateGroupPermission)) {\n\n\t\t\t\tthemeDisplay.setShowSiteMapSettingsIcon(true);\n\n\t\t\t\tLiferayPortletURL siteMapSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.GROUP_PAGES, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteMapSettingsURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/group_pages/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tsiteMapSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tif (PropsValues.DOCKBAR_ADMINISTRATIVE_LINKS_SHOW_IN_POP_UP) {\n\t\t\t\t\tsiteMapSettingsURL.setControlPanelCategory(\n\t\t\t\t\t\tPortletCategoryKeys.PORTLET);\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\t\"closeRedirect\", currentURL);\n\t\t\t\t\tsiteMapSettingsURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.POP_UP);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\t\"redirect\", themeDisplay.getURLHome());\n\t\t\t\t\tsiteMapSettingsURL.setPlid(plid);\n\t\t\t\t\tsiteMapSettingsURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.MAXIMIZED);\n\t\t\t\t}\n\n\t\t\t\tthemeDisplay.setURLSiteMapSettings(siteMapSettingsURL);\n\t\t\t}\n\n\t\t\tif (group.hasStagingGroup() && !group.isStagingGroup()) {\n\t\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\tif (group.isControlPanel()) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\t// LEP-4987\n\n\t\t\tif (group.isStaged() || group.isStagingGroup()) {\n\t\t\t\tif (hasManageStagingPermission || hasPublishStagingPermission ||\n\t\t\t\t\thasUpdateLayoutPermission || hasViewStagingPermission) {\n\n\t\t\t\t\tthemeDisplay.setShowStagingIcon(true);\n\t\t\t\t}\n\n\t\t\t\tif (hasPublishStagingPermission) {\n\t\t\t\t\tPortletURL publishToLiveURL = new PortletURLImpl(\n\t\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, plid,\n\t\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/layouts_admin/publish_layouts\");\n\n\t\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t\t}\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\t\t\t\t\tpublishToLiveURL.setPortletMode(PortletMode.VIEW);\n\t\t\t\t\tpublishToLiveURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.EXCLUSIVE);\n\n\t\t\t\t\tthemeDisplay.setURLPublishToLive(publishToLiveURL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPortlet myAccountPortlet = PortalUtil.getFirstMyAccountPortlet(\n\t\t\t\tthemeDisplay);\n\n\t\t\tif (myAccountPortlet != null) {\n\t\t\t\tPortletURLImpl myAccountURL = new PortletURLImpl(\n\t\t\t\t\trequest, myAccountPortlet.getPortletId(), controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tif (signedIn) {\n\t\t\t\t\tmyAccountURL.setDoAsGroupId(user.getGroupId());\n\t\t\t\t}\n\t\t\t\telse if (scopeGroupId > 0) {\n\t\t\t\t\tmyAccountURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\t}\n\n\t\t\t\tif (refererPlid > 0) {\n\t\t\t\t\tmyAccountURL.setRefererPlid(refererPlid);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmyAccountURL.setRefererPlid(plid);\n\t\t\t\t}\n\n\t\t\t\tmyAccountURL.setWindowState(WindowState.MAXIMIZED);\n\n\t\t\t\tthemeDisplay.setURLMyAccount(myAccountURL);\n\t\t\t}\n\t\t}\n\n\t\tif (!user.isActive() ||\n\t\t\t(PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.TERMS_OF_USE_REQUIRED) &&\n\t\t\t !user.isAgreedToTermsOfUse())) {\n\n\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t}\n\n\t\tif ((layout != null) && layout.isLayoutPrototypeLinkActive()) {\n\t\t\tthemeDisplay.setShowPageCustomizationIcon(false);\n\t\t}\n\n\t\tif (group.isLayoutPrototype()) {\n\t\t\tthemeDisplay.setShowHomeIcon(false);\n\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageCustomizationIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\t\t\tthemeDisplay.setShowPortalIcon(false);\n\t\t\tthemeDisplay.setShowSignInIcon(false);\n\t\t\tthemeDisplay.setShowSignOutIcon(false);\n\t\t\tthemeDisplay.setShowSiteAdministrationIcon(false);\n\t\t\tthemeDisplay.setShowSiteSettingsIcon(false);\n\t\t\tthemeDisplay.setShowStagingIcon(false);\n\t\t}\n\n\t\tif (group.isLayoutSetPrototype()) {\n\t\t\tthemeDisplay.setShowPageCustomizationIcon(false);\n\t\t\tthemeDisplay.setShowSiteSettingsIcon(false);\n\t\t}\n\n\t\tif (group.hasStagingGroup() && !group.isStagingGroup()) {\n\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(false);\n\t\t\tthemeDisplay.setShowPageCustomizationIcon(false);\n\t\t\tthemeDisplay.setShowSiteMapSettingsIcon(false);\n\t\t\tthemeDisplay.setShowSiteSettingsIcon(false);\n\t\t}\n\n\t\tthemeDisplay.setURLPortal(portalURL.concat(contextPath));\n\n\t\tboolean secure = false;\n\n\t\tif (PropsValues.COMPANY_SECURITY_AUTH_REQUIRES_HTTPS ||\n\t\t\trequest.isSecure()) {\n\n\t\t\tsecure = true;\n\t\t}\n\n\t\tString securePortalURL = PortalUtil.getPortalURL(request, secure);\n\n\t\tString urlSignIn = securePortalURL.concat(mainPath).concat(\n\t\t\t_PATH_PORTAL_LOGIN);\n\n\t\tif (layout != null) {\n\t\t\turlSignIn = HttpUtil.addParameter(\n\t\t\t\turlSignIn, \"p_l_id\", layout.getPlid());\n\t\t}\n\n\t\tthemeDisplay.setURLSignIn(urlSignIn);\n\n\t\tthemeDisplay.setURLSignOut(mainPath.concat(_PATH_PORTAL_LOGOUT));\n\n\t\tPortletURL updateManagerURL = new PortletURLImpl(\n\t\t\trequest, PortletKeys.MARKETPLACE_STORE, controlPanelPlid,\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tthemeDisplay.setURLUpdateManager(updateManagerURL);\n\n\t\treturn themeDisplay;\n\t}","id":49832,"modified_method":"public ThemeDisplay initThemeDisplay(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tHttpSession session = request.getSession();\n\n\t\t// Company\n\n\t\tCompany company = PortalUtil.getCompany(request);\n\n\t\tlong companyId = company.getCompanyId();\n\n\t\t// CDN host\n\n\t\tString cdnHost = PortalUtil.getCDNHost(request);\n\n\t\tString dynamicResourcesCDNHost = StringPool.BLANK;\n\n\t\tboolean cdnDynamicResourceEnabled =\n\t\t\tPortalUtil.isCDNDynamicResourcesEnabled(request);\n\n\t\tif (cdnDynamicResourceEnabled) {\n\t\t\tdynamicResourcesCDNHost = cdnHost;\n\t\t}\n\n\t\t// Portal URL\n\n\t\tString portalURL = PortalUtil.getPortalURL(request);\n\n\t\t// Paths\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\t\tString friendlyURLPrivateGroupPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateGroup();\n\t\tString friendlyURLPrivateUserPath =\n\t\t\tPortalUtil.getPathFriendlyURLPrivateUser();\n\t\tString friendlyURLPublicPath = PortalUtil.getPathFriendlyURLPublic();\n\t\tString imagePath = dynamicResourcesCDNHost.concat(\n\t\t\tPortalUtil.getPathImage());\n\t\tString mainPath = PortalUtil.getPathMain();\n\n\t\tString i18nPath = (String)request.getAttribute(WebKeys.I18N_PATH);\n\n\t\tif (Validator.isNotNull(i18nPath)) {\n\t\t\tif (Validator.isNotNull(contextPath)) {\n\t\t\t\tString i18nContextPath = contextPath.concat(i18nPath);\n\n\t\t\t\tfriendlyURLPrivateGroupPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateGroupPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPrivateUserPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPrivateUserPath, contextPath, i18nContextPath);\n\t\t\t\tfriendlyURLPublicPath = StringUtil.replaceFirst(\n\t\t\t\t\tfriendlyURLPublicPath, contextPath, i18nContextPath);\n\t\t\t\tmainPath = StringUtil.replaceFirst(\n\t\t\t\t\tmainPath, contextPath, i18nContextPath);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfriendlyURLPrivateGroupPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateGroupPath);\n\t\t\t\tfriendlyURLPrivateUserPath = i18nPath.concat(\n\t\t\t\t\tfriendlyURLPrivateUserPath);\n\t\t\t\tfriendlyURLPublicPath = i18nPath.concat(friendlyURLPublicPath);\n\t\t\t\tmainPath = i18nPath.concat(mainPath);\n\t\t\t}\n\t\t}\n\n\t\t// Company logo\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(imagePath);\n\t\tsb.append(\"/company_logo?img_id=\");\n\t\tsb.append(company.getLogoId());\n\t\tsb.append(\"&t=\");\n\t\tsb.append(WebServerServletTokenUtil.getToken(company.getLogoId()));\n\n\t\tString companyLogo = sb.toString();\n\n\t\tint companyLogoHeight = 0;\n\t\tint companyLogoWidth = 0;\n\n\t\tImage companyLogoImage = null;\n\n\t\tif (company.getLogoId() > 0) {\n\t\t\tcompanyLogoImage = ImageLocalServiceUtil.getCompanyLogo(\n\t\t\t\tcompany.getLogoId());\n\t\t}\n\t\telse {\n\t\t\tcompanyLogoImage = ImageToolUtil.getDefaultCompanyLogo();\n\t\t}\n\n\t\tif (companyLogoImage != null) {\n\t\t\tcompanyLogoHeight = companyLogoImage.getHeight();\n\t\t\tcompanyLogoWidth = companyLogoImage.getWidth();\n\t\t}\n\n\t\tString realCompanyLogo = companyLogo;\n\t\tint realCompanyLogoHeight = companyLogoHeight;\n\t\tint realCompanyLogoWidth = companyLogoWidth;\n\n\t\t// User\n\n\t\tUser user = null;\n\n\t\ttry {\n\t\t\tuser = PortalUtil.initUser(request);\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t\treturn null;\n\t\t}\n\n\t\tboolean signedIn = !user.isDefaultUser();\n\n\t\tif (PropsValues.BROWSER_CACHE_DISABLED ||\n\t\t\t(PropsValues.BROWSER_CACHE_SIGNED_IN_DISABLED && signedIn)) {\n\n\t\t\tresponse.setDateHeader(HttpHeaders.EXPIRES, 0);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.CACHE_CONTROL,\n\t\t\t\tHttpHeaders.CACHE_CONTROL_NO_CACHE_VALUE);\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.PRAGMA, HttpHeaders.PRAGMA_NO_CACHE_VALUE);\n\t\t}\n\n\t\tUser realUser = user;\n\n\t\tLong realUserId = (Long)session.getAttribute(WebKeys.USER_ID);\n\n\t\tif (realUserId != null) {\n\t\t\tif (user.getUserId() != realUserId.longValue()) {\n\t\t\t\trealUser = UserLocalServiceUtil.getUserById(\n\t\t\t\t\trealUserId.longValue());\n\t\t\t}\n\t\t}\n\n\t\tString doAsUserId = ParamUtil.getString(request, \"doAsUserId\");\n\t\tString doAsUserLanguageId = ParamUtil.getString(\n\t\t\trequest, \"doAsUserLanguageId\");\n\t\tlong doAsGroupId = ParamUtil.getLong(request, \"doAsGroupId\");\n\n\t\tlong refererGroupId = ParamUtil.getLong(request, \"refererGroupId\");\n\n\t\tlong refererPlid = ParamUtil.getLong(request, \"refererPlid\");\n\n\t\tif (LayoutLocalServiceUtil.fetchLayout(refererPlid) == null) {\n\t\t\trefererPlid = 0;\n\t\t}\n\n\t\tString controlPanelCategory = ParamUtil.getString(\n\t\t\trequest, \"controlPanelCategory\");\n\n\t\t// Permission checker\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tPermissionCheckerFactoryUtil.create(user);\n\n\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t// Cookie support\n\n\t\ttry {\n\n\t\t\t// LEP-4069\n\n\t\t\tCookieKeys.validateSupportCookie(request);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tCookieKeys.addSupportCookie(request, response);\n\t\t}\n\n\t\t// Time zone\n\n\t\tTimeZone timeZone = user.getTimeZone();\n\n\t\tif (timeZone == null) {\n\t\t\ttimeZone = company.getTimeZone();\n\t\t}\n\n\t\t// Layouts\n\n\t\tif (signedIn) {\n\t\t\tupdateUserLayouts(user);\n\t\t}\n\n\t\tLayout layout = null;\n\t\tList<Layout> layouts = null;\n\n\t\tlong plid = ParamUtil.getLong(request, \"p_l_id\");\n\n\t\tboolean viewableSourceGroup = true;\n\n\t\tif (plid > 0) {\n\t\t\tlayout = LayoutLocalServiceUtil.getLayout(plid);\n\t\t}\n\t\telse {\n\t\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\t\t\tboolean privateLayout = ParamUtil.getBoolean(\n\t\t\t\trequest, \"privateLayout\");\n\t\t\tlong layoutId = ParamUtil.getLong(request, \"layoutId\");\n\n\t\t\tif ((groupId > 0) && (layoutId > 0)) {\n\t\t\t\tlayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tgroupId, privateLayout, layoutId);\n\t\t\t}\n\t\t}\n\n\t\tif (layout != null) {\n\t\t\tlong sourceGroupId = ParamUtil.getLong(request, \"p_v_l_s_g_id\");\n\n\t\t\tif ((sourceGroupId > 0) && (sourceGroupId != layout.getGroupId())) {\n\t\t\t\tGroup sourceGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\t\tsourceGroupId);\n\n\t\t\t\tif (layout.isPublicLayout() ||\n\t\t\t\t\tSitesUtil.isUserGroupLayoutSetViewable(\n\t\t\t\t\t\tpermissionChecker, layout.getGroup())) {\n\n\t\t\t\t\tlayout = new VirtualLayout(layout, sourceGroup);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tviewableSourceGroup = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString ppid = ParamUtil.getString(request, \"p_p_id\");\n\n\t\tBoolean redirectToDefaultLayout = (Boolean)request.getAttribute(\n\t\t\tWebKeys.REDIRECT_TO_DEFAULT_LAYOUT);\n\n\t\tif (redirectToDefaultLayout == null) {\n\t\t\tredirectToDefaultLayout = Boolean.FALSE;\n\t\t}\n\n\t\tif (layout != null) {\n\t\t\tGroup group = layout.getGroup();\n\n\t\t\tif (!signedIn && PropsValues.AUTH_FORWARD_BY_REDIRECT) {\n\t\t\t\trequest.setAttribute(WebKeys.REQUESTED_LAYOUT, layout);\n\t\t\t}\n\n\t\t\tif ((Validator.isNull(controlPanelCategory) ||\n\t\t\t\t controlPanelCategory.equals(PortletCategoryKeys.MY) ||\n\t\t\t\t controlPanelCategory.equals(PortletCategoryKeys.PORTLET)) &&\n\t\t\t\tValidator.isNotNull(ppid) &&\n\t\t\t\t(LiferayWindowState.isPopUp(request) ||\n\t\t\t\t LiferayWindowState.isExclusive(request))) {\n\n\t\t\t\tcontrolPanelCategory = PortletCategoryKeys.PORTLET;\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(ppid)) {\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tcompanyId, ppid);\n\n\t\t\t\tString portletControlPanelEntryCategory =\n\t\t\t\t\tportlet.getControlPanelEntryCategory();\n\n\t\t\t\tif (!controlPanelCategory.startsWith(\n\t\t\t\t\t\tPortletCategoryKeys.CURRENT_SITE) &&\n\t\t\t\t\tportletControlPanelEntryCategory.startsWith(\n\t\t\t\t\t\tPortletCategoryKeys.SITE_ADMINISTRATION)) {\n\n\t\t\t\t\tportletControlPanelEntryCategory =\n\t\t\t\t\t\tPortletCategoryKeys.SITES;\n\t\t\t\t}\n\n\t\t\t\tif (!controlPanelCategory.startsWith(\n\t\t\t\t\t\tPortletCategoryKeys.CURRENT_SITE) &&\n\t\t\t\t\tValidator.isNotNull(portletControlPanelEntryCategory)) {\n\n\t\t\t\t\tcontrolPanelCategory = portletControlPanelEntryCategory;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean viewableGroup = hasAccessPermission(\n\t\t\t\tpermissionChecker, layout, doAsGroupId, controlPanelCategory,\n\t\t\t\ttrue);\n\t\t\tboolean viewableStaging =\n\t\t\t\t!group.isControlPanel() &&\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, group, ActionKeys.VIEW_STAGING);\n\n\t\t\tif (viewableStaging) {\n\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\t\t\t}\n\t\t\telse if ((!viewableGroup || !viewableSourceGroup) &&\n\t\t\t\t\t group.isStagingGroup()) {\n\n\t\t\t\tlayout = null;\n\t\t\t}\n\t\t\telse if (!isLoginRequest(request) &&\n\t\t\t\t\t (!viewableGroup || !viewableSourceGroup ||\n\t\t\t\t\t  (!redirectToDefaultLayout &&\n\t\t\t\t\t   !hasAccessPermission(\n\t\t\t\t\t\t   permissionChecker, layout, doAsGroupId,\n\t\t\t\t\t\t   controlPanelCategory, false)))) {\n\n\t\t\t\tif (user.isDefaultUser() &&\n\t\t\t\t\tPropsValues.AUTH_LOGIN_PROMPT_ENABLED) {\n\n\t\t\t\t\tthrow new PrincipalException(\"User is not authenticated\");\n\t\t\t\t}\n\n\t\t\t\tsb = new StringBundler(6);\n\n\t\t\t\tsb.append(\"User \");\n\t\t\t\tsb.append(user.getUserId());\n\t\t\t\tsb.append(\" is not allowed to access the \");\n\t\t\t\tsb.append(layout.isPrivateLayout() ? \"private\": \"public\");\n\t\t\t\tsb.append(\" pages of group \");\n\t\t\t\tsb.append(layout.getGroupId());\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(sb.toString());\n\t\t\t\t}\n\n\t\t\t\tthrow new NoSuchLayoutException(sb.toString());\n\t\t\t}\n\t\t\telse if (isLoginRequest(request) && !viewableGroup) {\n\t\t\t\tlayout = null;\n\t\t\t}\n\t\t\telse if (group.isLayoutPrototype()) {\n\t\t\t\tlayouts = new ArrayList<>();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\t\t\tif (!group.isControlPanel()) {\n\t\t\t\t\tdoAsGroupId = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tList<Layout> unfilteredLayouts = layouts;\n\n\t\tif (layout == null) {\n\t\t\tObject[] defaultLayout = getDefaultLayout(request, user, signedIn);\n\n\t\t\tlayout = (Layout)defaultLayout[0];\n\t\t\tlayouts = (List<Layout>)defaultLayout[1];\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT_DEFAULT, Boolean.TRUE);\n\t\t}\n\n\t\tObject[] viewableLayouts = getViewableLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts, doAsGroupId,\n\t\t\tcontrolPanelCategory);\n\n\t\tString layoutSetLogo = null;\n\n\t\tlayout = (Layout)viewableLayouts[0];\n\t\tlayouts = (List<Layout>)viewableLayouts[1];\n\n\t\tGroup group = null;\n\n\t\tif (layout != null) {\n\t\t\tgroup = layout.getGroup();\n\n\t\t\tif (!group.isControlPanel()) {\n\t\t\t\trememberVisitedGroupIds(request, group.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\tLayoutTypePortlet layoutTypePortlet = null;\n\n\t\tlayouts = mergeAdditionalLayouts(\n\t\t\trequest, user, permissionChecker, layout, layouts, doAsGroupId,\n\t\t\tcontrolPanelCategory);\n\n\t\tLayoutSet layoutSet = null;\n\n\t\tboolean hasAddLayoutLayoutPermission = false;\n\t\tboolean hasCustomizeLayoutPermission = false;\n\t\tboolean hasDeleteLayoutPermission = false;\n\t\tboolean hasUpdateLayoutPermission = false;\n\n\t\tboolean customizedView = SessionParamUtil.getBoolean(\n\t\t\trequest, \"customized_view\", true);\n\n\t\tif (layout != null) {\n\t\t\tLayoutType layoutType = layout.getLayoutType();\n\n\t\t\tLayoutTypeAccessPolicy layoutTypeAccessPolicy =\n\t\t\t\tlayoutType.getLayoutTypeAccessPolicy();\n\n\t\t\thasAddLayoutLayoutPermission =\n\t\t\t\tlayoutTypeAccessPolicy.isAddLayoutAllowed(\n\t\t\t\t\tpermissionChecker, layout);\n\t\t\thasCustomizeLayoutPermission =\n\t\t\t\tlayoutTypeAccessPolicy.isCustomizeLayoutAllowed(\n\t\t\t\t\tpermissionChecker, layout);\n\t\t\thasDeleteLayoutPermission =\n\t\t\t\tlayoutTypeAccessPolicy.isDeleteLayoutAllowed(\n\t\t\t\t\tpermissionChecker, layout);\n\t\t\thasUpdateLayoutPermission =\n\t\t\t\tlayoutTypeAccessPolicy.isUpdateLayoutAllowed(\n\t\t\t\t\tpermissionChecker, layout);\n\n\t\t\tlayoutSet = layout.getLayoutSet();\n\n\t\t\tif (company.isSiteLogo()) {\n\t\t\t\tlong logoId = 0;\n\n\t\t\t\tif (layoutSet.isLogo()) {\n\t\t\t\t\tlogoId = layoutSet.getLogoId();\n\n\t\t\t\t\tif (logoId == 0) {\n\t\t\t\t\t\tlogoId = layoutSet.getLiveLogoId();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLayoutSet siblingLayoutSet =\n\t\t\t\t\t\tLayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\t\t\t\t\tlayout.getGroupId(), !layout.isPrivateLayout());\n\n\t\t\t\t\tif (siblingLayoutSet.isLogo()) {\n\t\t\t\t\t\tlogoId = siblingLayoutSet.getLogoId();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (logoId > 0) {\n\t\t\t\t\tsb = new StringBundler(5);\n\n\t\t\t\t\tsb.append(imagePath);\n\t\t\t\t\tsb.append(\"/layout_set_logo?img_id=\");\n\t\t\t\t\tsb.append(logoId);\n\t\t\t\t\tsb.append(\"&t=\");\n\t\t\t\t\tsb.append(WebServerServletTokenUtil.getToken(logoId));\n\n\t\t\t\t\tlayoutSetLogo = sb.toString();\n\n\t\t\t\t\tImage layoutSetLogoImage =\n\t\t\t\t\t\tImageLocalServiceUtil.getCompanyLogo(logoId);\n\n\t\t\t\t\tcompanyLogo = layoutSetLogo;\n\t\t\t\t\tcompanyLogoHeight = layoutSetLogoImage.getHeight();\n\t\t\t\t\tcompanyLogoWidth = layoutSetLogoImage.getWidth();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplid = layout.getPlid();\n\n\t\t\t// Updates to shared layouts are not reflected until the next time\n\t\t\t// the user logs in because group layouts are cached in the session\n\n\t\t\tlayout = (Layout)layout.clone();\n\n\t\t\tlayoutTypePortlet = (LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\tboolean customizable = layoutTypePortlet.isCustomizable();\n\n\t\t\tif (!customizable ||\n\t\t\t\tgroup.isLayoutPrototype() || group.isLayoutSetPrototype() ||\n\t\t\t\tgroup.isStagingGroup()) {\n\n\t\t\t\tcustomizedView = false;\n\t\t\t}\n\n\t\t\tlayoutTypePortlet.setCustomizedView(customizedView);\n\t\t\tlayoutTypePortlet.setUpdatePermission(hasUpdateLayoutPermission);\n\n\t\t\tif (signedIn && customizable && customizedView &&\n\t\t\t\thasCustomizeLayoutPermission) {\n\n\t\t\t\tPortalPreferences portalPreferences =\n\t\t\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(\n\t\t\t\t\t\tuser.getUserId(), true);\n\n\t\t\t\tlayoutTypePortlet.setPortalPreferences(portalPreferences);\n\t\t\t}\n\n\t\t\tLayoutClone layoutClone = LayoutCloneFactory.getInstance();\n\n\t\t\tif (layoutClone != null) {\n\t\t\t\tString typeSettings = layoutClone.get(request, plid);\n\n\t\t\t\tif (typeSettings != null) {\n\t\t\t\t\tUnicodeProperties typeSettingsProperties =\n\t\t\t\t\t\tnew UnicodeProperties(true);\n\n\t\t\t\t\ttypeSettingsProperties.load(typeSettings);\n\n\t\t\t\t\tString stateMax = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MAX);\n\t\t\t\t\tString stateMin = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.STATE_MIN);\n\t\t\t\t\tString modeAbout = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_ABOUT);\n\t\t\t\t\tString modeConfig = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_CONFIG);\n\t\t\t\t\tString modeEdit = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT);\n\t\t\t\t\tString modeEditDefaults =\n\t\t\t\t\t\ttypeSettingsProperties.getProperty(\n\t\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_DEFAULTS);\n\t\t\t\t\tString modeEditGuest = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_EDIT_GUEST);\n\t\t\t\t\tString modeHelp = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_HELP);\n\t\t\t\t\tString modePreview = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PREVIEW);\n\t\t\t\t\tString modePrint = typeSettingsProperties.getProperty(\n\t\t\t\t\t\tLayoutTypePortletConstants.MODE_PRINT);\n\n\t\t\t\t\tlayoutTypePortlet.setStateMax(stateMax);\n\t\t\t\t\tlayoutTypePortlet.setStateMin(stateMin);\n\t\t\t\t\tlayoutTypePortlet.setModeAbout(modeAbout);\n\t\t\t\t\tlayoutTypePortlet.setModeConfig(modeConfig);\n\t\t\t\t\tlayoutTypePortlet.setModeEdit(modeEdit);\n\t\t\t\t\tlayoutTypePortlet.setModeEditDefaults(modeEditDefaults);\n\t\t\t\t\tlayoutTypePortlet.setModeEditGuest(modeEditGuest);\n\t\t\t\t\tlayoutTypePortlet.setModeHelp(modeHelp);\n\t\t\t\t\tlayoutTypePortlet.setModePreview(modePreview);\n\t\t\t\t\tlayoutTypePortlet.setModePrint(modePrint);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.LAYOUT, layout);\n\t\t\trequest.setAttribute(WebKeys.LAYOUTS, layouts);\n\t\t}\n\n\t\t// Locale\n\n\t\tString i18nLanguageId = (String)request.getAttribute(\n\t\t\tWebKeys.I18N_LANGUAGE_ID);\n\n\t\tLocale locale = PortalUtil.getLocale(request, response, true);\n\n\t\t// Scope\n\n\t\tlong scopeGroupId = PortalUtil.getScopeGroupId(request);\n\n\t\tif (group.isInheritContent()) {\n\t\t\tscopeGroupId = group.getParentGroupId();\n\t\t}\n\n\t\tif ((scopeGroupId <= 0) && (doAsGroupId > 0)) {\n\t\t\tscopeGroupId = doAsGroupId;\n\t\t}\n\n\t\tlong siteGroupId = 0;\n\n\t\tif (layout != null) {\n\t\t\tif (layout.isTypeControlPanel()) {\n\t\t\t\tsiteGroupId = PortalUtil.getSiteGroupId(scopeGroupId);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsiteGroupId = PortalUtil.getSiteGroupId(layout.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\t// Theme and color scheme\n\n\t\tTheme theme = null;\n\t\tColorScheme colorScheme = null;\n\n\t\tboolean wapTheme = BrowserSnifferUtil.isWap(request);\n\n\t\tif ((layout != null) &&\n\t\t\t(group.isControlPanel() || group.isUserPersonalPanel())) {\n\n\t\t\tString themeId = PrefsPropsUtil.getString(\n\t\t\t\tcompanyId, PropsKeys.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID);\n\t\t\tString colorSchemeId =\n\t\t\t\tColorSchemeFactoryUtil.getDefaultRegularColorSchemeId();\n\n\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\tcompanyId, themeId, wapTheme);\n\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, wapTheme);\n\n\t\t\tif (!wapTheme && theme.isWapTheme()) {\n\t\t\t\ttheme = ThemeLocalServiceUtil.getTheme(\n\t\t\t\t\tcompanyId,\n\t\t\t\t\tPropsValues.CONTROL_PANEL_LAYOUT_REGULAR_THEME_ID, false);\n\t\t\t\tcolorScheme = ThemeLocalServiceUtil.getColorScheme(\n\t\t\t\t\tcompanyId, theme.getThemeId(), colorSchemeId, false);\n\t\t\t}\n\n\t\t\trequest.setAttribute(WebKeys.THEME, theme);\n\t\t\trequest.setAttribute(WebKeys.COLOR_SCHEME, colorScheme);\n\t\t}\n\n\t\tboolean themeCssFastLoad = PropsValues.THEME_CSS_FAST_LOAD;\n\n\t\tif (PropsValues.THEME_CSS_FAST_LOAD_CHECK_REQUEST_PARAMETER) {\n\t\t\tthemeCssFastLoad = SessionParamUtil.getBoolean(\n\t\t\t\trequest, \"css_fast_load\", PropsValues.THEME_CSS_FAST_LOAD);\n\t\t}\n\n\t\tboolean themeImagesFastLoad = PropsValues.THEME_IMAGES_FAST_LOAD;\n\n\t\tif (PropsValues.THEME_IMAGES_FAST_LOAD_CHECK_REQUEST_PARAMETER) {\n\t\t\tSessionParamUtil.getBoolean(\n\t\t\t\trequest, \"images_fast_load\",\n\t\t\t\tPropsValues.THEME_IMAGES_FAST_LOAD);\n\t\t}\n\n\t\tboolean themeJsBarebone = PropsValues.JAVASCRIPT_BAREBONE_ENABLED;\n\n\t\tif (themeJsBarebone) {\n\t\t\tif (signedIn) {\n\t\t\t\tthemeJsBarebone = false;\n\t\t\t}\n\t\t}\n\n\t\tboolean themeJsFastLoad = SessionParamUtil.getBoolean(\n\t\t\trequest, \"js_fast_load\", PropsValues.JAVASCRIPT_FAST_LOAD);\n\n\t\tString lifecycle = ParamUtil.getString(request, \"p_p_lifecycle\", \"0\");\n\n\t\tlifecycle = ParamUtil.getString(request, \"p_t_lifecycle\", lifecycle);\n\n\t\tboolean isolated = ParamUtil.getBoolean(request, \"p_p_isolated\");\n\n\t\tString facebookCanvasPageURL = (String)request.getAttribute(\n\t\t\tWebKeys.FACEBOOK_CANVAS_PAGE_URL);\n\n\t\tboolean widget = false;\n\n\t\tBoolean widgetObj = (Boolean)request.getAttribute(WebKeys.WIDGET);\n\n\t\tif (widgetObj != null) {\n\t\t\twidget = widgetObj.booleanValue();\n\t\t}\n\n\t\t// Theme display\n\n\t\tThemeDisplay themeDisplay = ThemeDisplayFactory.create();\n\n\t\tthemeDisplay.setRequest(request);\n\n\t\t// Set attributes first that other methods (getCDNBaseURL and\n\t\t// setLookAndFeel) depend on\n\n\t\tthemeDisplay.setCDNHost(cdnHost);\n\t\tthemeDisplay.setCDNDynamicResourcesHost(dynamicResourcesCDNHost);\n\t\tthemeDisplay.setFacebookCanvasPageURL(facebookCanvasPageURL);\n\t\tthemeDisplay.setPortalURL(portalURL);\n\t\tthemeDisplay.setRefererPlid(refererPlid);\n\t\tthemeDisplay.setSecure(request.isSecure());\n\t\tthemeDisplay.setServerName(request.getServerName());\n\t\tthemeDisplay.setServerPort(request.getServerPort());\n\t\tthemeDisplay.setWidget(widget);\n\n\t\tthemeDisplay.setCompany(company);\n\t\tthemeDisplay.setCompanyLogo(companyLogo);\n\t\tthemeDisplay.setCompanyLogoHeight(companyLogoHeight);\n\t\tthemeDisplay.setCompanyLogoWidth(companyLogoWidth);\n\t\tthemeDisplay.setControlPanelCategory(controlPanelCategory);\n\t\tthemeDisplay.setDoAsGroupId(doAsGroupId);\n\t\tthemeDisplay.setDoAsUserId(doAsUserId);\n\t\tthemeDisplay.setDoAsUserLanguageId(doAsUserLanguageId);\n\t\tthemeDisplay.setI18nLanguageId(i18nLanguageId);\n\t\tthemeDisplay.setI18nPath(i18nPath);\n\t\tthemeDisplay.setIsolated(isolated);\n\t\tthemeDisplay.setLanguageId(LocaleUtil.toLanguageId(locale));\n\t\tthemeDisplay.setLayout(layout);\n\t\tthemeDisplay.setLayouts(layouts);\n\t\tthemeDisplay.setLayoutSet(layoutSet);\n\t\tthemeDisplay.setLayoutSetLogo(layoutSetLogo);\n\t\tthemeDisplay.setLayoutTypePortlet(layoutTypePortlet);\n\t\tthemeDisplay.setLifecycle(lifecycle);\n\t\tthemeDisplay.setLifecycleAction(lifecycle.equals(\"1\"));\n\t\tthemeDisplay.setLifecycleEvent(lifecycle.equals(\"3\"));\n\t\tthemeDisplay.setLifecycleRender(lifecycle.equals(\"0\"));\n\t\tthemeDisplay.setLifecycleResource(lifecycle.equals(\"2\"));\n\t\tthemeDisplay.setLocale(locale);\n\t\tthemeDisplay.setLookAndFeel(theme, colorScheme);\n\t\tthemeDisplay.setPathApplet(contextPath.concat(\"/applets\"));\n\t\tthemeDisplay.setPathCms(contextPath.concat(\"/cms\"));\n\t\tthemeDisplay.setPathContext(contextPath);\n\t\tthemeDisplay.setPathFlash(contextPath.concat(\"/flash\"));\n\t\tthemeDisplay.setPathFriendlyURLPrivateGroup(\n\t\t\tfriendlyURLPrivateGroupPath);\n\t\tthemeDisplay.setPathFriendlyURLPrivateUser(friendlyURLPrivateUserPath);\n\t\tthemeDisplay.setPathFriendlyURLPublic(friendlyURLPublicPath);\n\t\tthemeDisplay.setPathImage(imagePath);\n\t\tthemeDisplay.setPathJavaScript(\n\t\t\tPortalWebResourcesUtil.getContextPath().concat(\"/html/js\"));\n\t\tthemeDisplay.setPathMain(mainPath);\n\t\tthemeDisplay.setPathSound(contextPath.concat(\"/html/sound\"));\n\t\tthemeDisplay.setPermissionChecker(permissionChecker);\n\t\tthemeDisplay.setPlid(plid);\n\t\tthemeDisplay.setPpid(ppid);\n\t\tthemeDisplay.setRealCompanyLogo(realCompanyLogo);\n\t\tthemeDisplay.setRealCompanyLogoHeight(realCompanyLogoHeight);\n\t\tthemeDisplay.setRealCompanyLogoWidth(realCompanyLogoWidth);\n\t\tthemeDisplay.setRealUser(realUser);\n\t\tthemeDisplay.setRefererGroupId(refererGroupId);\n\t\tthemeDisplay.setScopeGroupId(scopeGroupId);\n\t\tthemeDisplay.setSignedIn(signedIn);\n\t\tthemeDisplay.setSiteDefaultLocale(\n\t\t\tPortalUtil.getSiteDefaultLocale(siteGroupId));\n\t\tthemeDisplay.setSiteGroupId(siteGroupId);\n\t\tthemeDisplay.setStateExclusive(LiferayWindowState.isExclusive(request));\n\t\tthemeDisplay.setStateMaximized(LiferayWindowState.isMaximized(request));\n\t\tthemeDisplay.setStatePopUp(LiferayWindowState.isPopUp(request));\n\t\tthemeDisplay.setThemeCssFastLoad(themeCssFastLoad);\n\t\tthemeDisplay.setThemeImagesFastLoad(themeImagesFastLoad);\n\t\tthemeDisplay.setThemeJsBarebone(themeJsBarebone);\n\t\tthemeDisplay.setThemeJsFastLoad(themeJsFastLoad);\n\t\tthemeDisplay.setTimeZone(timeZone);\n\t\tthemeDisplay.setUnfilteredLayouts(unfilteredLayouts);\n\t\tthemeDisplay.setUser(user);\n\n\t\t// Icons\n\n\t\tthemeDisplay.setShowAddContentIcon(false);\n\n\t\tboolean showControlPanelIcon = false;\n\n\t\tif (signedIn &&\n\t\t\tPortalPermissionUtil.contains(\n\t\t\t\tpermissionChecker, ActionKeys.VIEW_CONTROL_PANEL)) {\n\n\t\t\tshowControlPanelIcon = true;\n\t\t}\n\n\t\tthemeDisplay.setShowControlPanelIcon(showControlPanelIcon);\n\n\t\tthemeDisplay.setShowHomeIcon(true);\n\t\tthemeDisplay.setShowMyAccountIcon(signedIn);\n\t\tthemeDisplay.setShowPageSettingsIcon(hasDeleteLayoutPermission);\n\t\tthemeDisplay.setShowPortalIcon(true);\n\t\tthemeDisplay.setShowSignInIcon(!signedIn);\n\n\t\tboolean showSignOutIcon = signedIn;\n\n\t\tif (themeDisplay.isImpersonated()) {\n\t\t\tshowSignOutIcon = false;\n\t\t}\n\n\t\tthemeDisplay.setShowSignOutIcon(showSignOutIcon);\n\n\t\tthemeDisplay.setShowStagingIcon(false);\n\n\t\tboolean showSiteAdministrationIcon = false;\n\n\t\tif (signedIn &&\n\t\t\tGroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, group,\n\t\t\t\tActionKeys.VIEW_SITE_ADMINISTRATION)) {\n\n\t\t\tshowSiteAdministrationIcon = true;\n\t\t}\n\n\t\tthemeDisplay.setShowSiteAdministrationIcon(showSiteAdministrationIcon);\n\n\t\t// Session\n\n\t\tif (PropsValues.SESSION_ENABLE_URL_WITH_SESSION_ID &&\n\t\t\t!CookieKeys.hasSessionId(request)) {\n\n\t\t\tthemeDisplay.setAddSessionIdToURL(true);\n\t\t\tthemeDisplay.setSessionId(session.getId());\n\t\t}\n\n\t\t// URLs\n\n\t\tString urlControlPanel = friendlyURLPrivateGroupPath.concat(\n\t\t\tGroupConstants.CONTROL_PANEL_FRIENDLY_URL);\n\n\t\tif (Validator.isNotNull(doAsUserId)) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"doAsUserId\", doAsUserId);\n\t\t}\n\n\t\tif (refererGroupId > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererGroupId\", refererGroupId);\n\t\t}\n\t\telse if (scopeGroupId > 0) {\n\t\t\tLayout refererLayout = LayoutLocalServiceUtil.fetchLayout(plid);\n\n\t\t\tif (refererLayout != null) {\n\t\t\t\tGroup refererLayoutGroup = refererLayout.getGroup();\n\n\t\t\t\tif (refererLayoutGroup.isUserGroup()) {\n\t\t\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\t\t\turlControlPanel, \"refererGroupId\", scopeGroupId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (refererPlid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", refererPlid);\n\t\t}\n\t\telse if (plid > 0) {\n\t\t\turlControlPanel = HttpUtil.addParameter(\n\t\t\t\turlControlPanel, \"refererPlid\", plid);\n\t\t}\n\n\t\tif (themeDisplay.isAddSessionIdToURL()) {\n\t\t\turlControlPanel = PortalUtil.getURLWithSessionId(\n\t\t\t\turlControlPanel, session.getId());\n\t\t}\n\n\t\tthemeDisplay.setURLControlPanel(urlControlPanel);\n\n\t\tString currentURL = PortalUtil.getCurrentURL(request);\n\n\t\tthemeDisplay.setURLCurrent(currentURL);\n\n\t\tString urlHome = PortalUtil.getHomeURL(request);\n\n\t\tthemeDisplay.setURLHome(urlHome);\n\n\t\tString siteAdministrationURL = urlControlPanel;\n\n\t\tsiteAdministrationURL = HttpUtil.addParameter(\n\t\t\tsiteAdministrationURL, \"controlPanelCategory\",\n\t\t\tPortletCategoryKeys.CURRENT_SITE);\n\t\tsiteAdministrationURL = HttpUtil.addParameter(\n\t\t\tsiteAdministrationURL, \"doAsGroupId\", siteGroupId);\n\n\t\tthemeDisplay.setURLSiteAdministration(siteAdministrationURL);\n\n\t\tlong controlPanelPlid = PortalUtil.getControlPanelPlid(companyId);\n\n\t\tif (layout != null) {\n\t\t\tif (layout.isTypePortlet()) {\n\t\t\t\tboolean freeformLayout =\n\t\t\t\t\tlayoutTypePortlet.getLayoutTemplateId().equals(\"freeform\");\n\n\t\t\t\tthemeDisplay.setFreeformLayout(freeformLayout);\n\n\t\t\t\tif (hasUpdateLayoutPermission) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(true);\n\n\t\t\t\t\tif (!group.isUser()) {\n\t\t\t\t\t\tthemeDisplay.setShowPageCustomizationIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.Dockbar.loadAddPanel();\");\n\t\t\t\t}\n\n\t\t\t\tif (hasCustomizeLayoutPermission && customizedView) {\n\t\t\t\t\tthemeDisplay.setShowAddContentIconPermission(true);\n\n\t\t\t\t\tif (!LiferayWindowState.isMaximized(request)) {\n\t\t\t\t\t\tthemeDisplay.setShowAddContentIcon(true);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLAddContent(\n\t\t\t\t\t\t\"Liferay.Dockbar.loadAddPanel();\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasUpdateLayoutPermission) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\n\t\t\t\tLiferayPortletURL pageSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.GROUP_PAGES, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tpageSettingsURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/group_pages/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpageSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tpageSettingsURL.setParameter(\"selPlid\", String.valueOf(plid));\n\t\t\t\tpageSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tif (PropsValues.DOCKBAR_ADMINISTRATIVE_LINKS_SHOW_IN_POP_UP) {\n\t\t\t\t\tpageSettingsURL.setControlPanelCategory(\n\t\t\t\t\t\tPortletCategoryKeys.PORTLET);\n\t\t\t\t\tpageSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpageSettingsURL.setParameter(\n\t\t\t\t\t\t\"redirect\", themeDisplay.getURLHome());\n\t\t\t\t\tpageSettingsURL.setPlid(plid);\n\t\t\t\t\tpageSettingsURL.setWindowState(WindowState.MAXIMIZED);\n\t\t\t\t}\n\n\t\t\t\tthemeDisplay.setURLPageSettings(pageSettingsURL);\n\n\t\t\t\tboolean site = group.isSite();\n\n\t\t\t\tif (!site && group.isStagingGroup()) {\n\t\t\t\t\tGroup liveGroup = group.getLiveGroup();\n\n\t\t\t\t\tsite = liveGroup.isSite();\n\t\t\t\t}\n\n\t\t\t\tif (site &&\n\t\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, scopeGroupId,\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS)) {\n\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(true);\n\n\t\t\t\t\tLiferayPortletURL manageSiteMembershipsURL =\n\t\t\t\t\t\tnew PortletURLImpl(\n\t\t\t\t\t\t\trequest, PortletKeys.SITE_MEMBERSHIPS_ADMIN,\n\t\t\t\t\t\t\tcontrolPanelPlid, PortletRequest.RENDER_PHASE);\n\n\t\t\t\t\tmanageSiteMembershipsURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site_assignments\");\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\t\t\t\t\tmanageSiteMembershipsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\t\tif (PropsValues.\n\t\t\t\t\t\t\tDOCKBAR_ADMINISTRATIVE_LINKS_SHOW_IN_POP_UP) {\n\n\t\t\t\t\t\tmanageSiteMembershipsURL.setControlPanelCategory(\n\t\t\t\t\t\t\tPortletCategoryKeys.PORTLET);\n\t\t\t\t\t\tmanageSiteMembershipsURL.setWindowState(\n\t\t\t\t\t\t\tLiferayWindowState.POP_UP);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\t\"redirect\", themeDisplay.getURLHome());\n\t\t\t\t\t\tmanageSiteMembershipsURL.setParameter(\n\t\t\t\t\t\t\t\"showBackURL\", Boolean.FALSE.toString());\n\t\t\t\t\t\tmanageSiteMembershipsURL.setPlid(plid);\n\t\t\t\t\t\tmanageSiteMembershipsURL.setWindowState(\n\t\t\t\t\t\t\tWindowState.MAXIMIZED);\n\t\t\t\t\t}\n\n\t\t\t\t\tthemeDisplay.setURLManageSiteMemberships(\n\t\t\t\t\t\tmanageSiteMembershipsURL);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tGroup scopeGroup = GroupLocalServiceUtil.getGroup(scopeGroupId);\n\n\t\t\tboolean hasAddLayoutGroupPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.ADD_LAYOUT);\n\t\t\tboolean hasManageLayoutsGroupPermission =\n\t\t\t\tGroupPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.MANAGE_LAYOUTS);\n\t\t\tboolean hasManageStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.MANAGE_STAGING);\n\t\t\tboolean hasPublishStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.PUBLISH_STAGING);\n\t\t\tboolean hasUpdateGroupPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.UPDATE);\n\t\t\tboolean hasViewStagingPermission = GroupPermissionUtil.contains(\n\t\t\t\tpermissionChecker, scopeGroup, ActionKeys.VIEW_STAGING);\n\n\t\t\tif (!group.isControlPanel() && !group.isUser() &&\n\t\t\t\t!group.isUserGroup() && hasUpdateGroupPermission) {\n\n\t\t\t\tthemeDisplay.setShowSiteSettingsIcon(true);\n\n\t\t\t\tLiferayPortletURL siteSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.SITE_SETTINGS, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteSettingsURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/sites_admin/edit_site\");\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\"showBackURL\", Boolean.FALSE.toString());\n\t\t\t\tsiteSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tif (PropsValues.DOCKBAR_ADMINISTRATIVE_LINKS_SHOW_IN_POP_UP) {\n\t\t\t\t\tsiteSettingsURL.setControlPanelCategory(\n\t\t\t\t\t\tPortletCategoryKeys.PORTLET);\n\t\t\t\t\tsiteSettingsURL.setParameter(\"closeRedirect\", currentURL);\n\t\t\t\t\tsiteSettingsURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteSettingsURL.setParameter(\n\t\t\t\t\t\t\"redirect\", themeDisplay.getURLHome());\n\t\t\t\t\tsiteSettingsURL.setPlid(plid);\n\t\t\t\t\tsiteSettingsURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.MAXIMIZED);\n\t\t\t\t}\n\n\t\t\t\tthemeDisplay.setURLSiteSettings(siteSettingsURL);\n\t\t\t}\n\n\t\t\tif (!group.isLayoutPrototype() &&\n\t\t\t\t(hasAddLayoutGroupPermission || hasAddLayoutLayoutPermission ||\n\t\t\t\t hasManageLayoutsGroupPermission || hasUpdateGroupPermission)) {\n\n\t\t\t\tthemeDisplay.setShowSiteMapSettingsIcon(true);\n\n\t\t\t\tLiferayPortletURL siteMapSettingsURL = new PortletURLImpl(\n\t\t\t\t\trequest, PortletKeys.GROUP_PAGES, controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tsiteMapSettingsURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"struts_action\", \"/group_pages/edit_layouts\");\n\n\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t}\n\n\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\tsiteMapSettingsURL.setPortletMode(PortletMode.VIEW);\n\n\t\t\t\tif (PropsValues.DOCKBAR_ADMINISTRATIVE_LINKS_SHOW_IN_POP_UP) {\n\t\t\t\t\tsiteMapSettingsURL.setControlPanelCategory(\n\t\t\t\t\t\tPortletCategoryKeys.PORTLET);\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\t\"closeRedirect\", currentURL);\n\t\t\t\t\tsiteMapSettingsURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.POP_UP);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsiteMapSettingsURL.setParameter(\n\t\t\t\t\t\t\"redirect\", themeDisplay.getURLHome());\n\t\t\t\t\tsiteMapSettingsURL.setPlid(plid);\n\t\t\t\t\tsiteMapSettingsURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.MAXIMIZED);\n\t\t\t\t}\n\n\t\t\t\tthemeDisplay.setURLSiteMapSettings(siteMapSettingsURL);\n\t\t\t}\n\n\t\t\tif (group.hasStagingGroup() && !group.isStagingGroup()) {\n\t\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\tif (group.isControlPanel()) {\n\t\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t\t\tthemeDisplay.setURLPublishToLive(null);\n\t\t\t}\n\n\t\t\t// LEP-4987\n\n\t\t\tif (group.isStaged() || group.isStagingGroup()) {\n\t\t\t\tif (hasManageStagingPermission || hasPublishStagingPermission ||\n\t\t\t\t\thasUpdateLayoutPermission || hasViewStagingPermission) {\n\n\t\t\t\t\tthemeDisplay.setShowStagingIcon(true);\n\t\t\t\t}\n\n\t\t\t\tif (hasPublishStagingPermission) {\n\t\t\t\t\tPortletURL publishToLiveURL = new PortletURLImpl(\n\t\t\t\t\t\trequest, PortletKeys.LAYOUTS_ADMIN, plid,\n\t\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"struts_action\", \"/layouts_admin/publish_layouts\");\n\n\t\t\t\t\tif (layout.isPrivateLayout()) {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"private-pages\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpublishToLiveURL.setParameter(\"tabs1\", \"public-pages\");\n\t\t\t\t\t}\n\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"groupId\", String.valueOf(scopeGroupId));\n\t\t\t\t\tpublishToLiveURL.setParameter(\n\t\t\t\t\t\t\"selPlid\", String.valueOf(plid));\n\t\t\t\t\tpublishToLiveURL.setPortletMode(PortletMode.VIEW);\n\t\t\t\t\tpublishToLiveURL.setWindowState(\n\t\t\t\t\t\tLiferayWindowState.EXCLUSIVE);\n\n\t\t\t\t\tthemeDisplay.setURLPublishToLive(publishToLiveURL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPortlet myAccountPortlet = PortalUtil.getFirstMyAccountPortlet(\n\t\t\t\tthemeDisplay);\n\n\t\t\tif (myAccountPortlet != null) {\n\t\t\t\tPortletURLImpl myAccountURL = new PortletURLImpl(\n\t\t\t\t\trequest, myAccountPortlet.getPortletId(), controlPanelPlid,\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tif (signedIn) {\n\t\t\t\t\tmyAccountURL.setDoAsGroupId(user.getGroupId());\n\t\t\t\t}\n\t\t\t\telse if (scopeGroupId > 0) {\n\t\t\t\t\tmyAccountURL.setDoAsGroupId(scopeGroupId);\n\t\t\t\t}\n\n\t\t\t\tif (refererPlid > 0) {\n\t\t\t\t\tmyAccountURL.setRefererPlid(refererPlid);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmyAccountURL.setRefererPlid(plid);\n\t\t\t\t}\n\n\t\t\t\tmyAccountURL.setWindowState(WindowState.MAXIMIZED);\n\n\t\t\t\tthemeDisplay.setURLMyAccount(myAccountURL);\n\t\t\t}\n\t\t}\n\n\t\tif (!user.isActive() ||\n\t\t\t(PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.TERMS_OF_USE_REQUIRED) &&\n\t\t\t !user.isAgreedToTermsOfUse())) {\n\n\t\t\tthemeDisplay.setShowAddContentIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(false);\n\t\t}\n\n\t\tif ((layout != null) && layout.isLayoutPrototypeLinkActive()) {\n\t\t\tthemeDisplay.setShowPageCustomizationIcon(false);\n\t\t}\n\n\t\tif (group.isLayoutPrototype()) {\n\t\t\tthemeDisplay.setShowHomeIcon(false);\n\t\t\tthemeDisplay.setShowManageSiteMembershipsIcon(false);\n\t\t\tthemeDisplay.setShowMyAccountIcon(false);\n\t\t\tthemeDisplay.setShowPageCustomizationIcon(false);\n\t\t\tthemeDisplay.setShowPageSettingsIcon(true);\n\t\t\tthemeDisplay.setShowPortalIcon(false);\n\t\t\tthemeDisplay.setShowSignInIcon(false);\n\t\t\tthemeDisplay.setShowSignOutIcon(false);\n\t\t\tthemeDisplay.setShowSiteAdministrationIcon(false);\n\t\t\tthemeDisplay.setShowSiteSettingsIcon(false);\n\t\t\tthemeDisplay.setShowStagingIcon(false);\n\t\t}\n\n\t\tif (group.isLayoutSetPrototype()) {\n\t\t\tthemeDisplay.setShowPageCustomizationIcon(false);\n\t\t\tthemeDisplay.setShowSiteSettingsIcon(false);\n\t\t}\n\n\t\tif (group.hasStagingGroup() && !group.isStagingGroup()) {\n\t\t\tthemeDisplay.setShowLayoutTemplatesIcon(false);\n\t\t\tthemeDisplay.setShowPageCustomizationIcon(false);\n\t\t\tthemeDisplay.setShowSiteMapSettingsIcon(false);\n\t\t\tthemeDisplay.setShowSiteSettingsIcon(false);\n\t\t}\n\n\t\tthemeDisplay.setURLPortal(portalURL.concat(contextPath));\n\n\t\tboolean secure = false;\n\n\t\tif (PropsValues.COMPANY_SECURITY_AUTH_REQUIRES_HTTPS ||\n\t\t\trequest.isSecure()) {\n\n\t\t\tsecure = true;\n\t\t}\n\n\t\tString securePortalURL = PortalUtil.getPortalURL(request, secure);\n\n\t\tString urlSignIn = securePortalURL.concat(mainPath).concat(\n\t\t\t_PATH_PORTAL_LOGIN);\n\n\t\tif (layout != null) {\n\t\t\turlSignIn = HttpUtil.addParameter(\n\t\t\t\turlSignIn, \"p_l_id\", layout.getPlid());\n\t\t}\n\n\t\tthemeDisplay.setURLSignIn(urlSignIn);\n\n\t\tthemeDisplay.setURLSignOut(mainPath.concat(_PATH_PORTAL_LOGOUT));\n\n\t\tPortletURL updateManagerURL = new PortletURLImpl(\n\t\t\trequest, PortletKeys.MARKETPLACE_STORE, controlPanelPlid,\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tthemeDisplay.setURLUpdateManager(updateManagerURL);\n\n\t\treturn themeDisplay;\n\t}","commit_id":"9040e07cdf4e0fea17d1a991a3a82d5bc3b8a705","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected List getRemoteAttachments(ActionRequest req)\n\t\tthrows Exception {\n\n\t\tList list = new ArrayList();\n\n\t\tString prefix = \"remoteAttachment\";\n\n\t\tEnumeration enu = req.getParameterNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString name = (String)enu.nextElement();\n\n\t\t\tif (name.startsWith(prefix)) {\n\t\t\t\tString fileName = name.substring(prefix.length());\n\t\t\t\tString contentPath = ParamUtil.getString(req, name);\n\n\t\t\t\tRemoteMailAttachment remoteMailAttachment =\n\t\t\t\t\tnew RemoteMailAttachment();\n\n\t\t\t\tremoteMailAttachment.setFilename(fileName);\n\t\t\t\tremoteMailAttachment.setContentPath(contentPath);\n\n\t\t\t\tlist.add(remoteMailAttachment);\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}","id":49833,"modified_method":"protected List getRemoteAttachments(PortletRequest req)\n\t\tthrows Exception {\n\n\t\tList list = new ArrayList();\n\n\t\tString prefix = \"remoteAttachment\";\n\n\t\tEnumeration enu = req.getParameterNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString name = (String)enu.nextElement();\n\n\t\t\tif (name.startsWith(prefix)) {\n\t\t\t\tString fileName = name.substring(prefix.length());\n\t\t\t\tString contentPath = ParamUtil.getString(req, name);\n\n\t\t\t\tRemoteMailAttachment remoteMailAttachment =\n\t\t\t\t\tnew RemoteMailAttachment();\n\n\t\t\t\tremoteMailAttachment.setFilename(fileName);\n\t\t\t\tremoteMailAttachment.setContentPath(contentPath);\n\n\t\t\t\tlist.add(remoteMailAttachment);\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}","commit_id":"320d4f9bfd2e2f2a2b60721cb0fe7710b6edfc62","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void completeMessage(ActionRequest req)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tUser user = PortalUtil.getUser(req);\n\n\t\tAddress from = new InternetAddress(\n\t\t\tuser.getEmailAddress(), user.getFullName());\n\n\t\tString to = ParamUtil.getString(req, \"to\");\n\t\tString cc = ParamUtil.getString(req, \"cc\");\n\t\tString bcc = ParamUtil.getString(req, \"bcc\");\n\t\tString subject = ParamUtil.getString(req, \"subject\");\n\t\tString body = ParamUtil.getString(req, \"body\");\n\n\t\tMailMessage mailMessage = new MailMessage();\n\n\t\tmailMessage.setFrom(from);\n\t\tmailMessage.setTo(to);\n\t\tmailMessage.setCc(cc);\n\t\tmailMessage.setBcc(bcc);\n\t\tmailMessage.setSubject(subject);\n\t\tmailMessage.setHtmlBody(body);\n\n\t\tIterator itr = getAttachments(req).entrySet().iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tMap.Entry entry = (Map.Entry)itr.next();\n\n\t\t\tString fileName = (String)entry.getKey();\n\t\t\tbyte[] attachment = (byte[])entry.getValue();\n\n\t\t\tMailAttachment mailAttachment = new MailAttachment();\n\n\t\t\tmailAttachment.setFilename(fileName);\n\t\t\tmailAttachment.setContent(attachment);\n\t\t\tmailAttachment.setContentType(\n\t\t\t\tContentTypeUtil.getContentType(fileName));\n\n\t\t\tmailMessage.appendAttachment(mailAttachment);\n\t\t}\n\n\t\tmailMessage.setRemoteAttachments(getRemoteAttachments(req));\n\n\t\tboolean send = cmd.equals(Constants.SEND);\n\n\t\tlong draftId = ParamUtil.getLong(req, \"draftId\");\n\n\t\tActionRequestImpl actionReqImpl = (ActionRequestImpl)req;\n\n\t\tMailUtil.completeMessage(\n\t\t\tactionReqImpl.getHttpServletRequest(), mailMessage, send, draftId);\n\t}","id":49834,"modified_method":"protected void completeMessage(ActionRequest req)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tUser user = PortalUtil.getUser(req);\n\n\t\tlong draftId = ParamUtil.getLong(req, \"draftId\");\n\n\t\tString to = ParamUtil.getString(req, \"to\");\n\t\tString cc = ParamUtil.getString(req, \"cc\");\n\t\tString bcc = ParamUtil.getString(req, \"bcc\");\n\t\tString subject = ParamUtil.getString(req, \"subject\");\n\t\tString body = ParamUtil.getString(req, \"body\");\n\n\t\tMailMessage mailMessage = new MailMessage();\n\n\t\ttry {\n\t\t\tmailMessage.setFrom(new InternetAddress(\n\t\t\t\tuser.getEmailAddress(), user.getFullName()));\n\t\t\tmailMessage.setTo(to);\n\t\t\tmailMessage.setCc(cc);\n\t\t\tmailMessage.setBcc(bcc);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new RecipientException(ex);\n\t\t}\n\t\t\n\t\tmailMessage.setSubject(subject);\n\t\tmailMessage.setHtmlBody(body);\n\n\t\tIterator itr = getAttachments(req).entrySet().iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tMap.Entry entry = (Map.Entry)itr.next();\n\n\t\t\tString fileName = (String)entry.getKey();\n\t\t\tbyte[] attachment = (byte[])entry.getValue();\n\n\t\t\tMailAttachment mailAttachment = new MailAttachment();\n\n\t\t\tmailAttachment.setFilename(fileName);\n\t\t\tmailAttachment.setContent(attachment);\n\t\t\tmailAttachment.setContentType(\n\t\t\t\tContentTypeUtil.getContentType(fileName));\n\n\t\t\tmailMessage.appendAttachment(mailAttachment);\n\t\t}\n\n\t\tmailMessage.setRemoteAttachments(getRemoteAttachments(req));\n\n\t\tboolean send = cmd.equals(Constants.SEND);\n\n\t\tActionRequestImpl actionReqImpl = (ActionRequestImpl)req;\n\n\t\tMailUtil.completeMessage(\n\t\t\tactionReqImpl.getHttpServletRequest(), mailMessage, send, draftId);\n\t}","commit_id":"320d4f9bfd2e2f2a2b60721cb0fe7710b6edfc62","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tcompleteMessage(req);\n\n\t\t\tsendRedirect(req, res);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof RecipientException) {\n\t\t\t\tSessionErrors.add(req, e.getClass().getName());\n\n\t\t\t\treq.setAttribute(\n\t\t\t\t\tWebKeys.MAIL_MESSAGE_ATTACHMENTS, \n\t\t\t\t\tgetRemoteAttachments(req));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":49835,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tcompleteMessage(req);\n\n\t\t\tsendRedirect(req, res);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof RecipientException) {\n\t\t\t\tSessionErrors.add(req, e.getClass().getName());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"320d4f9bfd2e2f2a2b60721cb0fe7710b6edfc62","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ActionForward render(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tRenderRequest req, RenderResponse res)\n\t\tthrows Exception {\n\n\t\tRenderRequestImpl reqImpl = (RenderRequestImpl)req;\n\n\t\tHttpServletRequest httpReq = reqImpl.getHttpServletRequest();\n\t\tHttpSession httpSes = httpReq.getSession();\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tString folderId = ParamUtil.getString(req, \"folderId\");\n\t\tlong messageId = ParamUtil.getLong(req, \"messageId\");\n\n\t\tif (cmd.equals(\"forward\") || cmd.startsWith(\"reply\")) {\n\t\t\tMailUtil.setFolder(httpSes, folderId);\n\n\t\t\tMailMessage mailMessage = MailUtil.getMessage(httpReq, messageId);\n\n\t\t\tif (cmd.equals(\"forward\")) {\n\t\t\t\treq.setAttribute(\n\t\t\t\t\tWebKeys.MAIL_MESSAGE_SUBJECT,\n\t\t\t\t\t\"Fw: \" + getSubject(mailMessage.getSubject(), \"fw\"));\n\t\t\t\treq.setAttribute(\n\t\t\t\t\tWebKeys.MAIL_MESSAGE_ATTACHMENTS,\n\t\t\t\t\tmailMessage.getRemoteAttachments());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString to = StringPool.BLANK;\n\t\t\t\tString cc = StringPool.BLANK;\n\n\t\t\t\tif (cmd.equals(\"replyAll\")) {\n\t\t\t\t\tUser user = PortalUtil.getUser(req);\n\n\t\t\t\t\tString emailAddress = user.getEmailAddress();\n\n\t\t\t\t\tto = InternetAddressUtil.toString(\n\t\t\t\t\t\tInternetAddressUtil.removeEntry(\n\t\t\t\t\t\t\tmailMessage.getTo(), emailAddress));\n\n\t\t\t\t\tcc = InternetAddressUtil.toString(\n\t\t\t\t\t\tInternetAddressUtil.removeEntry(\n\t\t\t\t\t\t\tmailMessage.getCc(), emailAddress));\n\n\t\t\t\t\tString replyTo = InternetAddressUtil.toString(\n\t\t\t\t\t\tmailMessage.getReplyTo());\n\n\t\t\t\t\tif (Validator.isNull(replyTo)) {\n\t\t\t\t\t\tInternetAddress from =\n\t\t\t\t\t\t\t(InternetAddress)mailMessage.getFrom();\n\n\t\t\t\t\t\treplyTo = from.toUnicodeString();\n\t\t\t\t\t}\n\n\t\t\t\t\tto = replyTo + StringPool.COMMA + StringPool.SPACE + to;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tto = InternetAddressUtil.toString(\n\t\t\t\t\t\tmailMessage.getReplyTo());\n\n\t\t\t\t\tif (Validator.isNull(to)) {\n\t\t\t\t\t\tInternetAddress from =\n\t\t\t\t\t\t\t(InternetAddress)mailMessage.getFrom();\n\n\t\t\t\t\t\tto = from.toUnicodeString();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tString[] recipients = new String[] {\n\t\t\t\t\tHtml.escape(to, true),\n\t\t\t\t\tHtml.escape(cc, true),\n\t\t\t\t\tStringPool.BLANK\n\t\t\t\t};\n\n\t\t\t\treq.setAttribute(WebKeys.MAIL_MESSAGE_RECIPIENTS, recipients);\n\t\t\t\treq.setAttribute(\n\t\t\t\t\tWebKeys.MAIL_MESSAGE_SUBJECT,\n\t\t\t\t\t\"Re: \" + getSubject(mailMessage.getSubject(), \"re\"));\n\t\t\t}\n\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.MAIL_MESSAGE_BODY, getBody(req, mailMessage));\n\t\t}\n\t\telse if (cmd.equals(Constants.EDIT)) {\n\t\t\tMailUtil.setFolder(httpSes, folderId);\n\n\t\t\tMailMessage mailMessage = MailUtil.getMessage(httpReq, messageId);\n\n\t\t\tString to = Html.escape(\n\t\t\t\tInternetAddressUtil.toString(mailMessage.getTo()));\n\t\t\tString cc = Html.escape(\n\t\t\t\tInternetAddressUtil.toString(mailMessage.getCc()));\n\t\t\tString bcc = Html.escape(\n\t\t\t\tInternetAddressUtil.toString(mailMessage.getBcc()));\n\n\t\t\tString[] recipients = new String[] {to, cc, bcc};\n\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.MAIL_MESSAGE_DRAFT_ID, new Long(messageId));\n\t\t\treq.setAttribute(WebKeys.MAIL_MESSAGE_RECIPIENTS, recipients);\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.MAIL_MESSAGE_SUBJECT, mailMessage.getSubject());\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.MAIL_MESSAGE_BODY, mailMessage.getHtmlBody());\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.MAIL_MESSAGE_ATTACHMENTS,\n\t\t\t\tmailMessage.getRemoteAttachments());\n\t\t}\n\t\telse if (cmd.equals(Constants.SEND)) {\n\t\t\tString to = ParamUtil.getString(req, \"to\");\n\t\t\tString cc = ParamUtil.getString(req, \"cc\");\n\t\t\tString bcc = ParamUtil.getString(req, \"bcc\");\n\t\t\tString subject = ParamUtil.getString(req, \"subject\");\n\t\t\tString body = ParamUtil.getString(req, \"body\");\n\t\t\tlong draftId = ParamUtil.getLong(req, \"draftId\");\n\t\t\tString[] recipients = new String[] {to, cc, bcc};\n\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.MAIL_MESSAGE_DRAFT_ID, new Long(draftId));\n\t\t\treq.setAttribute(WebKeys.MAIL_MESSAGE_RECIPIENTS, recipients);\n\t\t\treq.setAttribute(WebKeys.MAIL_MESSAGE_SUBJECT, subject);\n\t\t\treq.setAttribute(WebKeys.MAIL_MESSAGE_BODY, body);\n\t\t}\n\n\t\treturn mapping.findForward(\"portlet.mail.edit_message\");\n\t}","id":49836,"modified_method":"public ActionForward render(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tRenderRequest req, RenderResponse res)\n\t\tthrows Exception {\n\n\t\tRenderRequestImpl reqImpl = (RenderRequestImpl)req;\n\n\t\tHttpServletRequest httpReq = reqImpl.getHttpServletRequest();\n\t\tHttpSession httpSes = httpReq.getSession();\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tString folderId = ParamUtil.getString(req, \"folderId\");\n\t\tlong messageId = ParamUtil.getLong(req, \"messageId\");\n\n\t\tif (cmd.equals(\"forward\") || cmd.startsWith(\"reply\")) {\n\t\t\tMailUtil.setFolder(httpSes, folderId);\n\n\t\t\tMailMessage mailMessage = MailUtil.getMessage(httpReq, messageId);\n\n\t\t\tif (cmd.equals(\"forward\")) {\n\t\t\t\treq.setAttribute(\n\t\t\t\t\tWebKeys.MAIL_MESSAGE_SUBJECT,\n\t\t\t\t\t\"Fw: \" + getSubject(mailMessage.getSubject(), \"fw\"));\n\t\t\t\treq.setAttribute(\n\t\t\t\t\tWebKeys.MAIL_MESSAGE_ATTACHMENTS,\n\t\t\t\t\tmailMessage.getRemoteAttachments());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString to = StringPool.BLANK;\n\t\t\t\tString cc = StringPool.BLANK;\n\n\t\t\t\tif (cmd.equals(\"replyAll\")) {\n\t\t\t\t\tUser user = PortalUtil.getUser(req);\n\n\t\t\t\t\tString emailAddress = user.getEmailAddress();\n\n\t\t\t\t\tto = InternetAddressUtil.toString(\n\t\t\t\t\t\tInternetAddressUtil.removeEntry(\n\t\t\t\t\t\t\tmailMessage.getTo(), emailAddress));\n\n\t\t\t\t\tcc = InternetAddressUtil.toString(\n\t\t\t\t\t\tInternetAddressUtil.removeEntry(\n\t\t\t\t\t\t\tmailMessage.getCc(), emailAddress));\n\n\t\t\t\t\tString replyTo = InternetAddressUtil.toString(\n\t\t\t\t\t\tmailMessage.getReplyTo());\n\n\t\t\t\t\tif (Validator.isNull(replyTo)) {\n\t\t\t\t\t\tInternetAddress from =\n\t\t\t\t\t\t\t(InternetAddress)mailMessage.getFrom();\n\n\t\t\t\t\t\treplyTo = from.toUnicodeString();\n\t\t\t\t\t}\n\n\t\t\t\t\tto = replyTo + StringPool.COMMA + StringPool.SPACE + to;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tto = InternetAddressUtil.toString(\n\t\t\t\t\t\tmailMessage.getReplyTo());\n\n\t\t\t\t\tif (Validator.isNull(to)) {\n\t\t\t\t\t\tInternetAddress from =\n\t\t\t\t\t\t\t(InternetAddress)mailMessage.getFrom();\n\n\t\t\t\t\t\tto = from.toUnicodeString();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tString[] recipients = new String[] {\n\t\t\t\t\tHtml.escape(to, true),\n\t\t\t\t\tHtml.escape(cc, true),\n\t\t\t\t\tStringPool.BLANK\n\t\t\t\t};\n\n\t\t\t\treq.setAttribute(WebKeys.MAIL_MESSAGE_RECIPIENTS, recipients);\n\t\t\t\treq.setAttribute(\n\t\t\t\t\tWebKeys.MAIL_MESSAGE_SUBJECT,\n\t\t\t\t\t\"Re: \" + getSubject(mailMessage.getSubject(), \"re\"));\n\t\t\t}\n\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.MAIL_MESSAGE_BODY, getBody(req, mailMessage));\n\t\t}\n\t\telse if (cmd.equals(Constants.EDIT)) {\n\t\t\tMailUtil.setFolder(httpSes, folderId);\n\n\t\t\tMailMessage mailMessage = MailUtil.getMessage(httpReq, messageId);\n\n\t\t\tString to = Html.escape(\n\t\t\t\tInternetAddressUtil.toString(mailMessage.getTo()));\n\t\t\tString cc = Html.escape(\n\t\t\t\tInternetAddressUtil.toString(mailMessage.getCc()));\n\t\t\tString bcc = Html.escape(\n\t\t\t\tInternetAddressUtil.toString(mailMessage.getBcc()));\n\n\t\t\tString[] recipients = new String[] {to, cc, bcc};\n\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.MAIL_MESSAGE_DRAFT_ID, new Long(messageId));\n\t\t\treq.setAttribute(WebKeys.MAIL_MESSAGE_RECIPIENTS, recipients);\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.MAIL_MESSAGE_SUBJECT, mailMessage.getSubject());\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.MAIL_MESSAGE_BODY, mailMessage.getHtmlBody());\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.MAIL_MESSAGE_ATTACHMENTS,\n\t\t\t\tmailMessage.getRemoteAttachments());\n\t\t}\n\t\telse if (cmd.equals(Constants.SEND)) {\n\t\t\tlong draftId = ParamUtil.getLong(req, \"draftId\");\n\n\t\t\tString to = ParamUtil.getString(req, \"to\");\n\t\t\tString cc = ParamUtil.getString(req, \"cc\");\n\t\t\tString bcc = ParamUtil.getString(req, \"bcc\");\n\n\t\t\tString[] recipients = new String[] {to, cc, bcc};\n\n\t\t\tString subject = ParamUtil.getString(req, \"subject\");\n\t\t\tString body = ParamUtil.getString(req, \"body\");\n\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.MAIL_MESSAGE_DRAFT_ID, new Long(draftId));\n\t\t\treq.setAttribute(WebKeys.MAIL_MESSAGE_RECIPIENTS, recipients);\n\t\t\treq.setAttribute(WebKeys.MAIL_MESSAGE_SUBJECT, subject);\n\t\t\treq.setAttribute(WebKeys.MAIL_MESSAGE_BODY, body);\n\t\t\treq.setAttribute(\n\t\t\t\tWebKeys.MAIL_MESSAGE_ATTACHMENTS, getRemoteAttachments(req));\n\t\t}\n\n\t\treturn mapping.findForward(\"portlet.mail.edit_message\");\n\t}","commit_id":"320d4f9bfd2e2f2a2b60721cb0fe7710b6edfc62","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setBcc(String bccs) throws Exception {\n\t\t_bcc = InternetAddressUtil.getAddresses(bccs);\n\t}","id":49837,"modified_method":"public void setBcc(String bccs)\n\t\tthrows AddressException, UnsupportedEncodingException {\n\n\t\t_bcc = InternetAddressUtil.getAddresses(bccs);\n\t}","commit_id":"320d4f9bfd2e2f2a2b60721cb0fe7710b6edfc62","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setTo(String to) throws Exception {\n\t\t_to = InternetAddressUtil.getAddresses(to);\n\t}","id":49838,"modified_method":"public void setTo(String to) \n\t\tthrows AddressException, UnsupportedEncodingException {\n\n\t\t_to = InternetAddressUtil.getAddresses(to);\n\t}","commit_id":"320d4f9bfd2e2f2a2b60721cb0fe7710b6edfc62","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setCc(String ccs) throws Exception {\n\t\t_cc = InternetAddressUtil.getAddresses(ccs);\n\t}","id":49839,"modified_method":"public void setCc(String ccs)\n\t\tthrows AddressException, UnsupportedEncodingException {\n\n\t\t_cc = InternetAddressUtil.getAddresses(ccs);\n\t}","commit_id":"320d4f9bfd2e2f2a2b60721cb0fe7710b6edfc62","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setReplyTo(String replyTos) throws Exception {\n\t\t_replyTo = InternetAddressUtil.getAddresses(replyTos);\n\t}","id":49840,"modified_method":"public void setReplyTo(String replyTos)\n\t\tthrows AddressException, UnsupportedEncodingException {\n\n\t\t_replyTo = InternetAddressUtil.getAddresses(replyTos);\n\t}","commit_id":"320d4f9bfd2e2f2a2b60721cb0fe7710b6edfc62","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Mail()\r\n    {\r\n        super();\r\n    }","id":49841,"modified_method":"public Mail()\r\n    {\r\n        headers = new HashMap<String, String>();\r\n    }","commit_id":"c2515b11c85796ccec9056cf29f3ef256c0183fe","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Mail(String from, String to, String cc, String bcc, String subject, String message, String htmlPart)\r\n    {\r\n        super();\r\n        this.from = from;\r\n        this.to = to;\r\n        this.cc = cc;\r\n        this.bcc = bcc;\r\n        this.subject = subject;\r\n        this.textPart = message;\r\n        this.htmlPart = htmlPart;\r\n    }","id":49842,"modified_method":"public Mail(String from, String to, String cc, String bcc, String subject, String textPart, String htmlPart)\r\n    {\r\n        this();\r\n        \r\n        this.from = from;\r\n        this.to = to;\r\n        this.cc = cc;\r\n        this.bcc = bcc;\r\n        this.subject = subject;\r\n        this.textPart = textPart;\r\n        this.htmlPart = htmlPart;\r\n    }","commit_id":"c2515b11c85796ccec9056cf29f3ef256c0183fe","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String toFullString()\r\n    {\r\n        return \"From: \" + from + \"\\nTo: \" + to + \"\\nCc: \" + cc + \"\\nBcc: \" + bcc + \"\\nSubject:\"\r\n            + subject + \"\\nText: \" + textPart+\" \\nHTML:\"+htmlPart;\r\n    }","id":49843,"modified_method":"public String toString()\r\n    {\r\n        StringBuffer buffer = new StringBuffer();\r\n\r\n        if (getFrom() != null) {\r\n            buffer.append(\"From [\" + getFrom() + \"]\");\r\n        }\r\n\r\n        if (getTo() != null) {\r\n            buffer.append(\", To [\" + getTo() + \"]\");\r\n        }\r\n\r\n        if (getCc() != null) {\r\n            buffer.append(\", Cc [\" + getCc() + \"]\");\r\n        }\r\n\r\n        if (getBcc() != null) {\r\n            buffer.append(\", Bcc [\" + getBcc() + \"]\");\r\n        }\r\n\r\n        if (getSubject() != null) {\r\n            buffer.append(\", Subject [\" + getSubject() + \"]\");\r\n        }\r\n\r\n        if (getTextPart() != null) {\r\n            buffer.append(\", Text [\" + getTextPart() + \"]\");\r\n        }\r\n\r\n        if (getHtmlPart() != null) {\r\n            buffer.append(\", HTML [\" + getHtmlPart() + \"]\");\r\n        }\r\n\r\n        if (!getHeaders().isEmpty()) {\r\n            buffer.append(\", Headers [\" + toStringHeaders() + \"]\");\r\n        }\r\n\r\n        return buffer.toString();\r\n    }","commit_id":"c2515b11c85796ccec9056cf29f3ef256c0183fe","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Creates a MIME message (message with binary content carrying capabilities) from an existing\r\n     * Mail\r\n     *\r\n     * @param mail The original Mail object\r\n     * @param session Mail session\r\n     * @return The MIME message\r\n     */\r\n    private MimeMessage createMimeMessage(Mail mail, Session session, XWikiContext context)\r\n        throws MessagingException,\r\n        XWikiException, IOException\r\n    {\r\n        // this will also check for email error\r\n        InternetAddress from = new InternetAddress(mail.getFrom());\r\n        InternetAddress[] to = toInternetAddresses(mail.getTo());\r\n        InternetAddress[] cc = toInternetAddresses(mail.getCc());\r\n        InternetAddress[] bcc = toInternetAddresses(mail.getBcc());\r\n\r\n        if ((to == null) && (cc == null) && (bcc == null)) {\r\n            LOG.info(\"No recipient -> skipping this email\");\r\n            return null;\r\n        }\r\n\r\n        MimeMessage message = new MimeMessage(session);\r\n        message.setSentDate(new Date());\r\n        message.setFrom(from);\r\n\r\n        if (to != null) {\r\n            message.setRecipients(javax.mail.Message.RecipientType.TO, to);\r\n        }\r\n\r\n        if (cc != null) {\r\n            message.setRecipients(javax.mail.Message.RecipientType.CC, cc);\r\n        }\r\n\r\n        if (bcc != null) {\r\n            message.setRecipients(javax.mail.Message.RecipientType.BCC, bcc);\r\n        }\r\n\r\n        message.setSubject(mail.getSubject(), \"UTF-8\");\r\n\r\n        if (mail.getHtmlPart() != null || mail.getAttachments() != null) {\r\n            Multipart multipart = createMimeMultipart(mail, context);\r\n            message.setContent(multipart);\r\n        } else {\r\n            message.setText(mail.getTextPart());\r\n        }\r\n\r\n        message.setSentDate(new Date());\r\n        message.saveChanges();\r\n        return message;\r\n    }","id":49844,"modified_method":"/**\r\n     * Creates a MIME message (message with binary content carrying capabilities) from an existing\r\n     * Mail\r\n     *\r\n     * @param mail The original Mail object\r\n     * @param session Mail session\r\n     * @return The MIME message\r\n     */\r\n    private MimeMessage createMimeMessage(Mail mail, Session session, XWikiContext context)\r\n        throws MessagingException,\r\n        XWikiException, IOException\r\n    {\r\n        // this will also check for email error\r\n        InternetAddress from = new InternetAddress(mail.getFrom());\r\n        InternetAddress[] to = toInternetAddresses(mail.getTo());\r\n        InternetAddress[] cc = toInternetAddresses(mail.getCc());\r\n        InternetAddress[] bcc = toInternetAddresses(mail.getBcc());\r\n\r\n        if ((to == null) && (cc == null) && (bcc == null)) {\r\n            LOG.info(\"No recipient -> skipping this email\");\r\n            return null;\r\n        }\r\n\r\n        MimeMessage message = new MimeMessage(session);\r\n        message.setSentDate(new Date());\r\n        message.setFrom(from);\r\n\r\n        if (to != null) {\r\n            message.setRecipients(javax.mail.Message.RecipientType.TO, to);\r\n        }\r\n\r\n        if (cc != null) {\r\n            message.setRecipients(javax.mail.Message.RecipientType.CC, cc);\r\n        }\r\n\r\n        if (bcc != null) {\r\n            message.setRecipients(javax.mail.Message.RecipientType.BCC, bcc);\r\n        }\r\n\r\n        message.setSubject(mail.getSubject(), \"UTF-8\");\r\n\r\n        for(Map.Entry<String,String> header : mail.getHeaders().entrySet()) {\r\n            message.setHeader(header.getKey(), header.getValue());\r\n        }\r\n\r\n        if (mail.getHtmlPart() != null || mail.getAttachments() != null) {\r\n            Multipart multipart = createMimeMultipart(mail, context);\r\n            message.setContent(multipart);\r\n        } else {\r\n            message.setText(mail.getTextPart());\r\n        }\r\n\r\n        message.setSentDate(new Date());\r\n        message.saveChanges();\r\n        return message;\r\n    }","commit_id":"c2515b11c85796ccec9056cf29f3ef256c0183fe","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Send a Collection of Mails (multiple emails)\r\n     *\r\n     * @param emails Mail Collection\r\n     * @return True in any case (TODO ?)\r\n     */\r\n    public boolean sendMails(Collection emails, XWikiContext context) throws MessagingException,\r\n        UnsupportedEncodingException\r\n    {\r\n        Session session = null;\r\n        Transport transport = null;\r\n        int emailCount = emails.size();\r\n        int count = 0;\r\n        int sendFailedCount = 0;\r\n        try {\r\n            for (Iterator emailIt = emails.iterator(); emailIt.hasNext();) {\r\n                count++;\r\n                if ((transport == null) || (session == null)) {\r\n                    Properties props = initProperties(context);\r\n                    session = Session.getDefaultInstance(props, null);\r\n                    transport = session.getTransport(\"smtp\");\r\n                    transport.connect();\r\n                }\r\n\r\n                Mail mail = (Mail) emailIt.next();\r\n                LOG.info(\"Sending email: \" + mail.toFullString());\r\n\r\n                try {\r\n\r\n                    MimeMessage message = createMimeMessage(mail, session, context);\r\n                    if (message == null) {\r\n                        continue;\r\n                    }\r\n\r\n                    transport.sendMessage(message, message.getAllRecipients());\r\n\r\n                    // close the connection every other 100 emails\r\n                    if ((count % 100) == 0) {\r\n                        try {\r\n                            if (transport != null) {\r\n                                transport.close();\r\n                            }\r\n                        } catch (MessagingException ex) {\r\n                            LOG.error(\"MessagingException has occured.\", ex);\r\n                        }\r\n                        transport = null;\r\n                        session = null;\r\n                    }\r\n                } catch (SendFailedException ex) {\r\n                    sendFailedCount++;\r\n                    LOG.error(\"SendFailedException has occured.\", ex);\r\n                    LOG.error(\"Detailed email information\" + mail.toFullString());\r\n                    if (emailCount == 1) {\r\n                        throw ex;\r\n                    }\r\n                    if ((emailCount != 1) && (sendFailedCount > 10)) {\r\n                        throw ex;\r\n                    }\r\n                } catch (MessagingException mex) {\r\n                    LOG.error(\"MessagingException has occured.\", mex);\r\n                    LOG.error(\"Detailed email information\" + mail.toFullString());\r\n                    if (emailCount == 1) {\r\n                        throw mex;\r\n                    }\r\n                } catch (XWikiException e) {\r\n                    LOG.error(\"XWikiException has occured.\", e);\r\n                } catch (IOException e) {\r\n                    LOG.error(\"IOException has occured.\", e);\r\n                }\r\n            }\r\n        } finally {\r\n            try {\r\n                if (transport != null) {\r\n                    transport.close();\r\n                }\r\n            } catch (MessagingException ex) {\r\n                LOG.error(\"MessagingException has occured.\", ex);\r\n            }\r\n\r\n            LOG.info(\"sendEmails: Email count = \" + emailCount + \" sent count = \" + count);\r\n        }\r\n        return true;\r\n    }","id":49845,"modified_method":"/**\r\n     * Send a Collection of Mails (multiple emails)\r\n     *\r\n     * @param emails Mail Collection\r\n     * @return True in any case (TODO ?)\r\n     */\r\n    public boolean sendMails(Collection emails, XWikiContext context)\r\n        throws MessagingException, UnsupportedEncodingException\r\n    {\r\n        // TODO: Fix the need to instantiate a new XWiki API object\r\n        com.xpn.xwiki.api.XWiki xwikiApi = new com.xpn.xwiki.api.XWiki(context.getWiki(), context);\r\n        return sendMails(emails, new MailConfiguration(xwikiApi), context);\r\n    }","commit_id":"c2515b11c85796ccec9056cf29f3ef256c0183fe","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Send a single Mail\r\n     *\r\n     * @param mailItem The Mail to send\r\n     * @return True if the the email has been sent\r\n     */\r\n    public boolean sendMail(Mail mailItem, XWikiContext context) throws MessagingException,\r\n        UnsupportedEncodingException\r\n    {\r\n        ArrayList mailList = new ArrayList();\r\n        mailList.add(mailItem);\r\n        return sendMails(mailList, context);\r\n    }","id":49846,"modified_method":"/**\r\n     * Send a single Mail\r\n     *\r\n     * @param mailItem The Mail to send\r\n     * @return True if the the email has been sent\r\n     */\r\n    public boolean sendMail(Mail mailItem, XWikiContext context)\r\n        throws MessagingException, UnsupportedEncodingException\r\n    {\r\n        // TODO: Fix the need to instantiate a new XWiki API object\r\n        com.xpn.xwiki.api.XWiki xwikiApi = new com.xpn.xwiki.api.XWiki(context.getWiki(), context);\r\n        return sendMail(mailItem, new MailConfiguration(xwikiApi), context);\r\n    }","commit_id":"c2515b11c85796ccec9056cf29f3ef256c0183fe","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Uses an XWiki document to build the message subject and context, based on variables stored in\r\n     * the VelocityContext. Sends the email.\r\n     *\r\n     * @param templateDocFullName Full name of the template to be used (example:\r\n     * XWiki.MyEmailTemplate). The template needs to have an XWiki.Email object attached\r\n     * @param from Email sender\r\n     * @param to Email recipient\r\n     * @param cc Email Carbon Copy\r\n     * @param bcc Email Hidden Carbon Copy\r\n     * @param language Language of the email\r\n     * @param vcontext Velocity context passed to the velocity renderer\r\n     * @return True if the email has been sent\r\n     */\r\n    public int sendMailFromTemplate(String templateDocFullName, String from, String to,\r\n        String cc, String bcc, String language, VelocityContext vcontext, XWikiContext context)\r\n        throws XWikiException\r\n    {\r\n\r\n        VelocityContext updatedVelocityContext =\r\n            prepareVelocityContext(from, to, bcc, vcontext, context);\r\n        XWiki xwiki = context.getWiki();\r\n        XWikiDocument doc = xwiki.getDocument(templateDocFullName, context);\r\n        BaseObject obj = doc.getObject(EMAIL_XWIKI_CLASS_NAME, \"language\", language);\r\n        if (obj == null) {\r\n            obj = doc.getObject(EMAIL_XWIKI_CLASS_NAME, \"language\", \"en\");\r\n        }\r\n        if (obj == null) {\r\n            LOG.error(\"No mail object found in the document \" + templateDocFullName);\r\n            return ERROR_TEMPLATE_EMAIL_OBJECT_NOT_FOUND;\r\n        }\r\n        String subjectContent = obj.getStringValue(\"subject\");\r\n        String txtContent = obj.getStringValue(\"text\");\r\n        String htmlContent = obj.getStringValue(\"html\");\r\n\r\n        String subject =\r\n            XWikiVelocityRenderer.evaluate(subjectContent, templateDocFullName,\r\n                updatedVelocityContext);\r\n        String msg =\r\n            XWikiVelocityRenderer.evaluate(txtContent, templateDocFullName,\r\n                updatedVelocityContext);\r\n        String html =\r\n            XWikiVelocityRenderer.evaluate(htmlContent, templateDocFullName,\r\n                updatedVelocityContext);\r\n\r\n        Mail mail = new Mail();\r\n        try {\r\n            mail.setSubject(subject);\r\n            mail.setFrom((String) updatedVelocityContext.get(\"from.address\"));\r\n            mail.setTo((String) updatedVelocityContext.get(\"to.address\"));\r\n            String toBcc = (String) updatedVelocityContext.get(\"to.bcc\");\r\n            if (toBcc != null) {\r\n                mail.setBcc(toBcc);\r\n            }\r\n            mail.setTextPart(msg);\r\n            mail.setHtmlPart(html);\r\n            sendMail(mail, context);\r\n            return 0;\r\n        } catch (Exception e) {\r\n            LOG.error(\"sendEmailFromTemplate: \" + templateDocFullName + \" vcontext: \"\r\n                + updatedVelocityContext, e);\r\n            return ERROR;\r\n        }\r\n    }","id":49847,"modified_method":"/**\r\n     * Uses an XWiki document to build the message subject and context, based on variables stored in\r\n     * the VelocityContext. Sends the email.\r\n     *\r\n     * @param templateDocFullName Full name of the template to be used (example:\r\n     * XWiki.MyEmailTemplate). The template needs to have an XWiki.Email object attached\r\n     * @param from Email sender\r\n     * @param to Email recipient\r\n     * @param cc Email Carbon Copy\r\n     * @param bcc Email Hidden Carbon Copy\r\n     * @param language Language of the email\r\n     * @param vcontext Velocity context passed to the velocity renderer\r\n     * @return True if the email has been sent\r\n     */\r\n    public int sendMailFromTemplate(String templateDocFullName, String from, String to,\r\n        String cc, String bcc, String language, VelocityContext vcontext, XWikiContext context)\r\n        throws XWikiException\r\n    {\r\n\r\n        VelocityContext updatedVelocityContext =\r\n            prepareVelocityContext(from, to, bcc, vcontext, context);\r\n        XWiki xwiki = context.getWiki();\r\n        XWikiDocument doc = xwiki.getDocument(templateDocFullName, context);\r\n        BaseObject obj = doc.getObject(EMAIL_XWIKI_CLASS_NAME, \"language\", language);\r\n        if (obj == null) {\r\n            obj = doc.getObject(EMAIL_XWIKI_CLASS_NAME, \"language\", \"en\");\r\n        }\r\n        if (obj == null) {\r\n            LOG.error(\"No mail object found in the document \" + templateDocFullName);\r\n            return ERROR_TEMPLATE_EMAIL_OBJECT_NOT_FOUND;\r\n        }\r\n        String subjectContent = obj.getStringValue(\"subject\");\r\n        String txtContent = obj.getStringValue(\"text\");\r\n        String htmlContent = obj.getStringValue(\"html\");\r\n\r\n        String subject =\r\n            XWikiVelocityRenderer.evaluate(subjectContent, templateDocFullName,\r\n                updatedVelocityContext);\r\n        String msg =\r\n            XWikiVelocityRenderer.evaluate(txtContent, templateDocFullName,\r\n                updatedVelocityContext);\r\n        String html =\r\n            XWikiVelocityRenderer.evaluate(htmlContent, templateDocFullName,\r\n                updatedVelocityContext);\r\n\r\n        Mail mail = new Mail();\r\n        mail.setFrom((String) updatedVelocityContext.get(\"from.address\"));\r\n        mail.setTo((String) updatedVelocityContext.get(\"to.address\"));\r\n        mail.setBcc((String) updatedVelocityContext.get(\"to.bcc\"));\r\n        mail.setSubject(subject);\r\n        mail.setTextPart(msg);\r\n        mail.setHtmlPart(html);\r\n        try {\r\n            sendMail(mail, context);\r\n            return 0;\r\n        } catch (Exception e) {\r\n            LOG.error(\"sendEmailFromTemplate: \" + templateDocFullName + \" vcontext: \"\r\n                + updatedVelocityContext, e);\r\n            return ERROR;\r\n        }\r\n    }","commit_id":"c2515b11c85796ccec9056cf29f3ef256c0183fe","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * @see MailSender#sendTextMessage(String, String, String, String, String, String, java.util.List)   \n     */\n    public int sendTextMessage(String from, String to, String cc, String bcc, String subject,\n        String message, List attachments)\n    {\n        try {\n            Mail email = new Mail();\n            email.setSubject(subject);\n            email.setTextPart(message);\n            email.setFrom(from);\n            email.setTo(to);\n            email.setCc(cc);\n            email.setBcc(bcc);\n            email.setAttachments(attachments);\n            getMailSenderPlugin().sendMail(email, context);\n            return 0;\n        } catch (Exception e) {\n            context.put(\"error\", e.getMessage());\n            LOG.error(\"sendTextMessage\", e);\n            return -1;\n        }\n    }","id":49848,"modified_method":"/**\n     * {@inheritDoc}\n     * @see MailSender#sendTextMessage(String, String, String, String, String, String, java.util.List)   \n     */\n    public int sendTextMessage(String from, String to, String cc, String bcc, String subject,\n        String message, List attachments)\n    {\n        Mail email = new Mail();\n        email.setSubject(subject);\n        email.setTextPart(message);\n        email.setFrom(from);\n        email.setTo(to);\n        email.setCc(cc);\n        email.setBcc(bcc);\n        email.setAttachments(attachments);\n        return sendMail(email);\n    }","commit_id":"c2515b11c85796ccec9056cf29f3ef256c0183fe","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * @see MailSender#sendMessageFromTemplate(String, String, String, String, String, String, VelocityContext)   \n     */\n    public int sendMessageFromTemplate(String from, String to, String cc, String bcc,\n        String language, String documentFullName, VelocityContext vcontext)\n    {\n        try {\n            return getMailSenderPlugin().sendMailFromTemplate(documentFullName, from, to, cc, bcc,\n                language, vcontext, context);\n        } catch (Exception e) {\n            LOG.error(\"sendMessageFromTemplate\", e);\n            return -1;\n        }\n    }","id":49849,"modified_method":"/**\n     * {@inheritDoc}\n     * @see MailSender#sendMessageFromTemplate(String, String, String, String, String, String, VelocityContext)   \n     */\n    public int sendMessageFromTemplate(String from, String to, String cc, String bcc,\n        String language, String documentFullName, VelocityContext vcontext)\n    {\n        try {\n            return getMailSenderPlugin().sendMailFromTemplate(documentFullName, from, to, cc, bcc,\n                language, vcontext, context);\n        } catch (Exception e) {\n            context.put(\"error\", e.getMessage());\n            LOG.error(\"sendMessageFromTemplate\", e);\n            return -1;\n        }\n    }","commit_id":"c2515b11c85796ccec9056cf29f3ef256c0183fe","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * @see MailSender#sendTextMessage(String, String, String, String)  \n     */\n    public int sendTextMessage(String from, String to, String subject, String message)\n    {\n        try {\n            Mail email = new Mail();\n            email.setSubject(subject);\n            email.setTextPart(message);\n            email.setFrom(from);\n            email.setTo(to);\n\n            getMailSenderPlugin().sendMail(email, context);\n            return 0;\n        } catch (Exception e) {\n            context.put(\"error\", e.getMessage());\n            LOG.error(\"sendTextMessage\", e);\n            return -1;\n        }\n    }","id":49850,"modified_method":"/**\n     * {@inheritDoc}\n     * @see MailSender#sendTextMessage(String, String, String, String)  \n     */\n    public int sendTextMessage(String from, String to, String subject, String message)\n    {\n        Mail email = new Mail();\n        email.setSubject(subject);\n        email.setTextPart(message);\n        email.setFrom(from);\n        email.setTo(to);\n        return sendMail(email);\n    }","commit_id":"c2515b11c85796ccec9056cf29f3ef256c0183fe","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * @see MailSender#sendHtmlMessage(String, String, String, String, String, String, String, java.util.List) \n     */\n    public int sendHtmlMessage(String from, String to, String cc, String bcc, String subject,\n        String body, String alternative, List attachments)\n    {\n        try {\n            Mail email = new Mail();\n            email.setSubject(subject);\n            email.setFrom(from);\n            email.setTo(to);\n            email.setCc(cc);\n            email.setBcc(bcc);\n            email.setTextPart(alternative);\n            email.setHtmlPart(body);\n            email.setAttachments(attachments);\n            getMailSenderPlugin().sendMail(email, context);\n            return 0;\n        } catch (Exception e) {\n            context.put(\"error\", e.getMessage());\n            LOG.error(\"sendHtmlMessage\", e);\n            return -1;\n        }\n    }","id":49851,"modified_method":"/**\n     * {@inheritDoc}\n     * @see MailSender#sendHtmlMessage(String, String, String, String, String, String, String, java.util.List) \n     */\n    public int sendHtmlMessage(String from, String to, String cc, String bcc, String subject,\n        String body, String alternative, List attachments)\n    {\n        Mail email = new Mail();\n        email.setSubject(subject);\n        email.setFrom(from);\n        email.setTo(to);\n        email.setCc(cc);\n        email.setBcc(bcc);\n        email.setTextPart(alternative);\n        email.setHtmlPart(body);\n        email.setAttachments(attachments);\n        return sendMail(email);\n    }","commit_id":"c2515b11c85796ccec9056cf29f3ef256c0183fe","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get the MailSenderPlugin\n     *\n     * @return The MailSenderPlugin\n     */\n    protected MailSenderPlugin getMailSenderPlugin()\n    {\n        return (MailSenderPlugin) getInternalPlugin();\n    }","id":49852,"modified_method":"/**\n     * Get the MailSenderPlugin\n     *\n     * @return The MailSenderPlugin\n     */\n    private MailSenderPlugin getMailSenderPlugin()\n    {\n        return (MailSenderPlugin) getProtectedPlugin();\n    }","commit_id":"c2515b11c85796ccec9056cf29f3ef256c0183fe","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public String toFullString()\r\n    {\r\n        return \"From: \" + from + \"\\nTo: \" + to + \"\\nCc: \" + cc + \"\\nBcc: \" + bcc + \"\\nSubject:\"\r\n            + subject + \"\\nText: \" + textPart+\" \\nHTML:\"+htmlPart;\r\n    }","id":49853,"modified_method":"public String toString()\r\n    {\r\n        StringBuffer buffer = new StringBuffer();\r\n\r\n        if (getFrom() != null) {\r\n            buffer.append(\"From [\" + getFrom() + \"]\");\r\n        }\r\n\r\n        if (getTo() != null) {\r\n            buffer.append(\", To [\" + getTo() + \"]\");\r\n        }\r\n\r\n        if (getCc() != null) {\r\n            buffer.append(\", Cc [\" + getCc() + \"]\");\r\n        }\r\n\r\n        if (getBcc() != null) {\r\n            buffer.append(\", Bcc [\" + getBcc() + \"]\");\r\n        }\r\n\r\n        if (getSubject() != null) {\r\n            buffer.append(\", Subject [\" + getSubject() + \"]\");\r\n        }\r\n\r\n        if (getTextPart() != null) {\r\n            buffer.append(\", Text [\" + getTextPart() + \"]\");\r\n        }\r\n\r\n        if (getHtmlPart() != null) {\r\n            buffer.append(\", HTML [\" + getHtmlPart() + \"]\");\r\n        }\r\n\r\n        if (!getHeaders().isEmpty()) {\r\n            buffer.append(\", Headers [\" + toStringHeaders() + \"]\");\r\n        }\r\n\r\n        return buffer.toString();\r\n    }","commit_id":"04a7b2e5678cb619ef1495a559b7e90b21b54d85","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Mail(String from, String to, String cc, String bcc, String subject, String message, String htmlPart)\r\n    {\r\n        super();\r\n        this.from = from;\r\n        this.to = to;\r\n        this.cc = cc;\r\n        this.bcc = bcc;\r\n        this.subject = subject;\r\n        this.textPart = message;\r\n        this.htmlPart = htmlPart;\r\n    }","id":49854,"modified_method":"public Mail(String from, String to, String cc, String bcc, String subject, String textPart, String htmlPart)\r\n    {\r\n        this();\r\n        \r\n        this.from = from;\r\n        this.to = to;\r\n        this.cc = cc;\r\n        this.bcc = bcc;\r\n        this.subject = subject;\r\n        this.textPart = textPart;\r\n        this.htmlPart = htmlPart;\r\n    }","commit_id":"04a7b2e5678cb619ef1495a559b7e90b21b54d85","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Mail()\r\n    {\r\n        super();\r\n    }","id":49855,"modified_method":"public Mail()\r\n    {\r\n        headers = new HashMap<String, String>();\r\n    }","commit_id":"04a7b2e5678cb619ef1495a559b7e90b21b54d85","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Send a Collection of Mails (multiple emails)\r\n     *\r\n     * @param emails Mail Collection\r\n     * @return True in any case (TODO ?)\r\n     */\r\n    public boolean sendMails(Collection emails, XWikiContext context) throws MessagingException,\r\n        UnsupportedEncodingException\r\n    {\r\n        Session session = null;\r\n        Transport transport = null;\r\n        int emailCount = emails.size();\r\n        int count = 0;\r\n        int sendFailedCount = 0;\r\n        try {\r\n            for (Iterator emailIt = emails.iterator(); emailIt.hasNext();) {\r\n                count++;\r\n                if ((transport == null) || (session == null)) {\r\n                    Properties props = initProperties(context);\r\n                    session = Session.getDefaultInstance(props, null);\r\n                    transport = session.getTransport(\"smtp\");\r\n                    transport.connect();\r\n                }\r\n\r\n                Mail mail = (Mail) emailIt.next();\r\n                LOG.info(\"Sending email: \" + mail.toFullString());\r\n\r\n                try {\r\n\r\n                    MimeMessage message = createMimeMessage(mail, session, context);\r\n                    if (message == null) {\r\n                        continue;\r\n                    }\r\n\r\n                    transport.sendMessage(message, message.getAllRecipients());\r\n\r\n                    // close the connection every other 100 emails\r\n                    if ((count % 100) == 0) {\r\n                        try {\r\n                            if (transport != null) {\r\n                                transport.close();\r\n                            }\r\n                        } catch (MessagingException ex) {\r\n                            LOG.error(\"MessagingException has occured.\", ex);\r\n                        }\r\n                        transport = null;\r\n                        session = null;\r\n                    }\r\n                } catch (SendFailedException ex) {\r\n                    sendFailedCount++;\r\n                    LOG.error(\"SendFailedException has occured.\", ex);\r\n                    LOG.error(\"Detailed email information\" + mail.toFullString());\r\n                    if (emailCount == 1) {\r\n                        throw ex;\r\n                    }\r\n                    if ((emailCount != 1) && (sendFailedCount > 10)) {\r\n                        throw ex;\r\n                    }\r\n                } catch (MessagingException mex) {\r\n                    LOG.error(\"MessagingException has occured.\", mex);\r\n                    LOG.error(\"Detailed email information\" + mail.toFullString());\r\n                    if (emailCount == 1) {\r\n                        throw mex;\r\n                    }\r\n                } catch (XWikiException e) {\r\n                    LOG.error(\"XWikiException has occured.\", e);\r\n                } catch (IOException e) {\r\n                    LOG.error(\"IOException has occured.\", e);\r\n                }\r\n            }\r\n        } finally {\r\n            try {\r\n                if (transport != null) {\r\n                    transport.close();\r\n                }\r\n            } catch (MessagingException ex) {\r\n                LOG.error(\"MessagingException has occured.\", ex);\r\n            }\r\n\r\n            LOG.info(\"sendEmails: Email count = \" + emailCount + \" sent count = \" + count);\r\n        }\r\n        return true;\r\n    }","id":49856,"modified_method":"/**\r\n     * Send a Collection of Mails (multiple emails)\r\n     *\r\n     * @param emails Mail Collection\r\n     * @return True in any case (TODO ?)\r\n     */\r\n    public boolean sendMails(Collection emails, XWikiContext context)\r\n        throws MessagingException, UnsupportedEncodingException\r\n    {\r\n        // TODO: Fix the need to instantiate a new XWiki API object\r\n        com.xpn.xwiki.api.XWiki xwikiApi = new com.xpn.xwiki.api.XWiki(context.getWiki(), context);\r\n        return sendMails(emails, new MailConfiguration(xwikiApi), context);\r\n    }","commit_id":"04a7b2e5678cb619ef1495a559b7e90b21b54d85","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Uses an XWiki document to build the message subject and context, based on variables stored in\r\n     * the VelocityContext. Sends the email.\r\n     *\r\n     * @param templateDocFullName Full name of the template to be used (example:\r\n     * XWiki.MyEmailTemplate). The template needs to have an XWiki.Email object attached\r\n     * @param from Email sender\r\n     * @param to Email recipient\r\n     * @param cc Email Carbon Copy\r\n     * @param bcc Email Hidden Carbon Copy\r\n     * @param language Language of the email\r\n     * @param vcontext Velocity context passed to the velocity renderer\r\n     * @return True if the email has been sent\r\n     */\r\n    public int sendMailFromTemplate(String templateDocFullName, String from, String to,\r\n        String cc, String bcc, String language, VelocityContext vcontext, XWikiContext context)\r\n        throws XWikiException\r\n    {\r\n\r\n        VelocityContext updatedVelocityContext =\r\n            prepareVelocityContext(from, to, bcc, vcontext, context);\r\n        XWiki xwiki = context.getWiki();\r\n        XWikiDocument doc = xwiki.getDocument(templateDocFullName, context);\r\n        BaseObject obj = doc.getObject(EMAIL_XWIKI_CLASS_NAME, \"language\", language);\r\n        if (obj == null) {\r\n            obj = doc.getObject(EMAIL_XWIKI_CLASS_NAME, \"language\", \"en\");\r\n        }\r\n        if (obj == null) {\r\n            LOG.error(\"No mail object found in the document \" + templateDocFullName);\r\n            return ERROR_TEMPLATE_EMAIL_OBJECT_NOT_FOUND;\r\n        }\r\n        String subjectContent = obj.getStringValue(\"subject\");\r\n        String txtContent = obj.getStringValue(\"text\");\r\n        String htmlContent = obj.getStringValue(\"html\");\r\n\r\n        String subject =\r\n            XWikiVelocityRenderer.evaluate(subjectContent, templateDocFullName,\r\n                updatedVelocityContext);\r\n        String msg =\r\n            XWikiVelocityRenderer.evaluate(txtContent, templateDocFullName,\r\n                updatedVelocityContext);\r\n        String html =\r\n            XWikiVelocityRenderer.evaluate(htmlContent, templateDocFullName,\r\n                updatedVelocityContext);\r\n\r\n        Mail mail = new Mail();\r\n        try {\r\n            mail.setSubject(subject);\r\n            mail.setFrom((String) updatedVelocityContext.get(\"from.address\"));\r\n            mail.setTo((String) updatedVelocityContext.get(\"to.address\"));\r\n            String toBcc = (String) updatedVelocityContext.get(\"to.bcc\");\r\n            if (toBcc != null) {\r\n                mail.setBcc(toBcc);\r\n            }\r\n            mail.setTextPart(msg);\r\n            mail.setHtmlPart(html);\r\n            sendMail(mail, context);\r\n            return 0;\r\n        } catch (Exception e) {\r\n            LOG.error(\"sendEmailFromTemplate: \" + templateDocFullName + \" vcontext: \"\r\n                + updatedVelocityContext, e);\r\n            return ERROR;\r\n        }\r\n    }","id":49857,"modified_method":"/**\r\n     * Uses an XWiki document to build the message subject and context, based on variables stored in\r\n     * the VelocityContext. Sends the email.\r\n     *\r\n     * @param templateDocFullName Full name of the template to be used (example:\r\n     * XWiki.MyEmailTemplate). The template needs to have an XWiki.Email object attached\r\n     * @param from Email sender\r\n     * @param to Email recipient\r\n     * @param cc Email Carbon Copy\r\n     * @param bcc Email Hidden Carbon Copy\r\n     * @param language Language of the email\r\n     * @param vcontext Velocity context passed to the velocity renderer\r\n     * @return True if the email has been sent\r\n     */\r\n    public int sendMailFromTemplate(String templateDocFullName, String from, String to,\r\n        String cc, String bcc, String language, VelocityContext vcontext, XWikiContext context)\r\n        throws XWikiException\r\n    {\r\n\r\n        VelocityContext updatedVelocityContext =\r\n            prepareVelocityContext(from, to, bcc, vcontext, context);\r\n        XWiki xwiki = context.getWiki();\r\n        XWikiDocument doc = xwiki.getDocument(templateDocFullName, context);\r\n        BaseObject obj = doc.getObject(EMAIL_XWIKI_CLASS_NAME, \"language\", language);\r\n        if (obj == null) {\r\n            obj = doc.getObject(EMAIL_XWIKI_CLASS_NAME, \"language\", \"en\");\r\n        }\r\n        if (obj == null) {\r\n            LOG.error(\"No mail object found in the document \" + templateDocFullName);\r\n            return ERROR_TEMPLATE_EMAIL_OBJECT_NOT_FOUND;\r\n        }\r\n        String subjectContent = obj.getStringValue(\"subject\");\r\n        String txtContent = obj.getStringValue(\"text\");\r\n        String htmlContent = obj.getStringValue(\"html\");\r\n\r\n        String subject =\r\n            XWikiVelocityRenderer.evaluate(subjectContent, templateDocFullName,\r\n                updatedVelocityContext);\r\n        String msg =\r\n            XWikiVelocityRenderer.evaluate(txtContent, templateDocFullName,\r\n                updatedVelocityContext);\r\n        String html =\r\n            XWikiVelocityRenderer.evaluate(htmlContent, templateDocFullName,\r\n                updatedVelocityContext);\r\n\r\n        Mail mail = new Mail();\r\n        mail.setFrom((String) updatedVelocityContext.get(\"from.address\"));\r\n        mail.setTo((String) updatedVelocityContext.get(\"to.address\"));\r\n        mail.setBcc((String) updatedVelocityContext.get(\"to.bcc\"));\r\n        mail.setSubject(subject);\r\n        mail.setTextPart(msg);\r\n        mail.setHtmlPart(html);\r\n        try {\r\n            sendMail(mail, context);\r\n            return 0;\r\n        } catch (Exception e) {\r\n            LOG.error(\"sendEmailFromTemplate: \" + templateDocFullName + \" vcontext: \"\r\n                + updatedVelocityContext, e);\r\n            return ERROR;\r\n        }\r\n    }","commit_id":"04a7b2e5678cb619ef1495a559b7e90b21b54d85","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Send a single Mail\r\n     *\r\n     * @param mailItem The Mail to send\r\n     * @return True if the the email has been sent\r\n     */\r\n    public boolean sendMail(Mail mailItem, XWikiContext context) throws MessagingException,\r\n        UnsupportedEncodingException\r\n    {\r\n        ArrayList mailList = new ArrayList();\r\n        mailList.add(mailItem);\r\n        return sendMails(mailList, context);\r\n    }","id":49858,"modified_method":"/**\r\n     * Send a single Mail\r\n     *\r\n     * @param mailItem The Mail to send\r\n     * @return True if the the email has been sent\r\n     */\r\n    public boolean sendMail(Mail mailItem, XWikiContext context)\r\n        throws MessagingException, UnsupportedEncodingException\r\n    {\r\n        // TODO: Fix the need to instantiate a new XWiki API object\r\n        com.xpn.xwiki.api.XWiki xwikiApi = new com.xpn.xwiki.api.XWiki(context.getWiki(), context);\r\n        return sendMail(mailItem, new MailConfiguration(xwikiApi), context);\r\n    }","commit_id":"04a7b2e5678cb619ef1495a559b7e90b21b54d85","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Creates a MIME message (message with binary content carrying capabilities) from an existing\r\n     * Mail\r\n     *\r\n     * @param mail The original Mail object\r\n     * @param session Mail session\r\n     * @return The MIME message\r\n     */\r\n    private MimeMessage createMimeMessage(Mail mail, Session session, XWikiContext context)\r\n        throws MessagingException,\r\n        XWikiException, IOException\r\n    {\r\n        // this will also check for email error\r\n        InternetAddress from = new InternetAddress(mail.getFrom());\r\n        InternetAddress[] to = toInternetAddresses(mail.getTo());\r\n        InternetAddress[] cc = toInternetAddresses(mail.getCc());\r\n        InternetAddress[] bcc = toInternetAddresses(mail.getBcc());\r\n\r\n        if ((to == null) && (cc == null) && (bcc == null)) {\r\n            LOG.info(\"No recipient -> skipping this email\");\r\n            return null;\r\n        }\r\n\r\n        MimeMessage message = new MimeMessage(session);\r\n        message.setSentDate(new Date());\r\n        message.setFrom(from);\r\n\r\n        if (to != null) {\r\n            message.setRecipients(javax.mail.Message.RecipientType.TO, to);\r\n        }\r\n\r\n        if (cc != null) {\r\n            message.setRecipients(javax.mail.Message.RecipientType.CC, cc);\r\n        }\r\n\r\n        if (bcc != null) {\r\n            message.setRecipients(javax.mail.Message.RecipientType.BCC, bcc);\r\n        }\r\n\r\n        message.setSubject(mail.getSubject(), \"UTF-8\");\r\n\r\n        if (mail.getHtmlPart() != null || mail.getAttachments() != null) {\r\n            Multipart multipart = createMimeMultipart(mail, context);\r\n            message.setContent(multipart);\r\n        } else {\r\n            message.setText(mail.getTextPart());\r\n        }\r\n\r\n        message.setSentDate(new Date());\r\n        message.saveChanges();\r\n        return message;\r\n    }","id":49859,"modified_method":"/**\r\n     * Creates a MIME message (message with binary content carrying capabilities) from an existing\r\n     * Mail\r\n     *\r\n     * @param mail The original Mail object\r\n     * @param session Mail session\r\n     * @return The MIME message\r\n     */\r\n    private MimeMessage createMimeMessage(Mail mail, Session session, XWikiContext context)\r\n        throws MessagingException,\r\n        XWikiException, IOException\r\n    {\r\n        // this will also check for email error\r\n        InternetAddress from = new InternetAddress(mail.getFrom());\r\n        InternetAddress[] to = toInternetAddresses(mail.getTo());\r\n        InternetAddress[] cc = toInternetAddresses(mail.getCc());\r\n        InternetAddress[] bcc = toInternetAddresses(mail.getBcc());\r\n\r\n        if ((to == null) && (cc == null) && (bcc == null)) {\r\n            LOG.info(\"No recipient -> skipping this email\");\r\n            return null;\r\n        }\r\n\r\n        MimeMessage message = new MimeMessage(session);\r\n        message.setSentDate(new Date());\r\n        message.setFrom(from);\r\n\r\n        if (to != null) {\r\n            message.setRecipients(javax.mail.Message.RecipientType.TO, to);\r\n        }\r\n\r\n        if (cc != null) {\r\n            message.setRecipients(javax.mail.Message.RecipientType.CC, cc);\r\n        }\r\n\r\n        if (bcc != null) {\r\n            message.setRecipients(javax.mail.Message.RecipientType.BCC, bcc);\r\n        }\r\n\r\n        message.setSubject(mail.getSubject(), \"UTF-8\");\r\n\r\n        for(Map.Entry<String,String> header : mail.getHeaders().entrySet()) {\r\n            message.setHeader(header.getKey(), header.getValue());\r\n        }\r\n\r\n        if (mail.getHtmlPart() != null || mail.getAttachments() != null) {\r\n            Multipart multipart = createMimeMultipart(mail, context);\r\n            message.setContent(multipart);\r\n        } else {\r\n            message.setText(mail.getTextPart());\r\n        }\r\n\r\n        message.setSentDate(new Date());\r\n        message.saveChanges();\r\n        return message;\r\n    }","commit_id":"04a7b2e5678cb619ef1495a559b7e90b21b54d85","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * @see MailSender#sendTextMessage(String, String, String, String, String, String, java.util.List)   \n     */\n    public int sendTextMessage(String from, String to, String cc, String bcc, String subject,\n        String message, List attachments)\n    {\n        try {\n            Mail email = new Mail();\n            email.setSubject(subject);\n            email.setTextPart(message);\n            email.setFrom(from);\n            email.setTo(to);\n            email.setCc(cc);\n            email.setBcc(bcc);\n            email.setAttachments(attachments);\n            getMailSenderPlugin().sendMail(email, context);\n            return 0;\n        } catch (Exception e) {\n            context.put(\"error\", e.getMessage());\n            LOG.error(\"sendTextMessage\", e);\n            return -1;\n        }\n    }","id":49860,"modified_method":"/**\n     * {@inheritDoc}\n     * @see MailSender#sendTextMessage(String, String, String, String, String, String, java.util.List)   \n     */\n    public int sendTextMessage(String from, String to, String cc, String bcc, String subject,\n        String message, List attachments)\n    {\n        Mail email = new Mail();\n        email.setSubject(subject);\n        email.setTextPart(message);\n        email.setFrom(from);\n        email.setTo(to);\n        email.setCc(cc);\n        email.setBcc(bcc);\n        email.setAttachments(attachments);\n        return sendMail(email);\n    }","commit_id":"04a7b2e5678cb619ef1495a559b7e90b21b54d85","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get the MailSenderPlugin\n     *\n     * @return The MailSenderPlugin\n     */\n    protected MailSenderPlugin getMailSenderPlugin()\n    {\n        return (MailSenderPlugin) getInternalPlugin();\n    }","id":49861,"modified_method":"/**\n     * Get the MailSenderPlugin\n     *\n     * @return The MailSenderPlugin\n     */\n    private MailSenderPlugin getMailSenderPlugin()\n    {\n        return (MailSenderPlugin) getProtectedPlugin();\n    }","commit_id":"04a7b2e5678cb619ef1495a559b7e90b21b54d85","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * @see MailSender#sendMessageFromTemplate(String, String, String, String, String, String, VelocityContext)   \n     */\n    public int sendMessageFromTemplate(String from, String to, String cc, String bcc,\n        String language, String documentFullName, VelocityContext vcontext)\n    {\n        try {\n            return getMailSenderPlugin().sendMailFromTemplate(documentFullName, from, to, cc, bcc,\n                language, vcontext, context);\n        } catch (Exception e) {\n            LOG.error(\"sendMessageFromTemplate\", e);\n            return -1;\n        }\n    }","id":49862,"modified_method":"/**\n     * {@inheritDoc}\n     * @see MailSender#sendMessageFromTemplate(String, String, String, String, String, String, VelocityContext)   \n     */\n    public int sendMessageFromTemplate(String from, String to, String cc, String bcc,\n        String language, String documentFullName, VelocityContext vcontext)\n    {\n        try {\n            return getMailSenderPlugin().sendMailFromTemplate(documentFullName, from, to, cc, bcc,\n                language, vcontext, context);\n        } catch (Exception e) {\n            context.put(\"error\", e.getMessage());\n            LOG.error(\"sendMessageFromTemplate\", e);\n            return -1;\n        }\n    }","commit_id":"04a7b2e5678cb619ef1495a559b7e90b21b54d85","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * @see MailSender#sendTextMessage(String, String, String, String)  \n     */\n    public int sendTextMessage(String from, String to, String subject, String message)\n    {\n        try {\n            Mail email = new Mail();\n            email.setSubject(subject);\n            email.setTextPart(message);\n            email.setFrom(from);\n            email.setTo(to);\n\n            getMailSenderPlugin().sendMail(email, context);\n            return 0;\n        } catch (Exception e) {\n            context.put(\"error\", e.getMessage());\n            LOG.error(\"sendTextMessage\", e);\n            return -1;\n        }\n    }","id":49863,"modified_method":"/**\n     * {@inheritDoc}\n     * @see MailSender#sendTextMessage(String, String, String, String)  \n     */\n    public int sendTextMessage(String from, String to, String subject, String message)\n    {\n        Mail email = new Mail();\n        email.setSubject(subject);\n        email.setTextPart(message);\n        email.setFrom(from);\n        email.setTo(to);\n        return sendMail(email);\n    }","commit_id":"04a7b2e5678cb619ef1495a559b7e90b21b54d85","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * @see MailSender#sendHtmlMessage(String, String, String, String, String, String, String, java.util.List) \n     */\n    public int sendHtmlMessage(String from, String to, String cc, String bcc, String subject,\n        String body, String alternative, List attachments)\n    {\n        try {\n            Mail email = new Mail();\n            email.setSubject(subject);\n            email.setFrom(from);\n            email.setTo(to);\n            email.setCc(cc);\n            email.setBcc(bcc);\n            email.setTextPart(alternative);\n            email.setHtmlPart(body);\n            email.setAttachments(attachments);\n            getMailSenderPlugin().sendMail(email, context);\n            return 0;\n        } catch (Exception e) {\n            context.put(\"error\", e.getMessage());\n            LOG.error(\"sendHtmlMessage\", e);\n            return -1;\n        }\n    }","id":49864,"modified_method":"/**\n     * {@inheritDoc}\n     * @see MailSender#sendHtmlMessage(String, String, String, String, String, String, String, java.util.List) \n     */\n    public int sendHtmlMessage(String from, String to, String cc, String bcc, String subject,\n        String body, String alternative, List attachments)\n    {\n        Mail email = new Mail();\n        email.setSubject(subject);\n        email.setFrom(from);\n        email.setTo(to);\n        email.setCc(cc);\n        email.setBcc(bcc);\n        email.setTextPart(alternative);\n        email.setHtmlPart(body);\n        email.setAttachments(attachments);\n        return sendMail(email);\n    }","commit_id":"04a7b2e5678cb619ef1495a559b7e90b21b54d85","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private static NodeStore createNodeStore(String uri, BlobStore blobStore) {\n            MongoConnection connection;\n            try {\n                connection = new MongoConnection(uri);\n                DB mongoDB = connection.getDB();\n                DocumentMK.Builder builder = new DocumentMK.Builder();\n                if(blobStore != null){\n                    builder.setBlobStore(blobStore);\n                }\n                builder.setMongoDB(mongoDB);\n                return builder.getNodeStore();\n            } catch (Exception e) {\n                return null;\n            }\n        }","id":49865,"modified_method":"private static NodeStore createNodeStore(String uri, BlobStore blobStore) {\n            MongoConnection connection;\n            try {\n                connection = new MongoConnection(uri);\n                DB mongoDB = connection.getDB();\n                DocumentMK.Builder builder = new DocumentMK.Builder();\n                if(blobStore != null){\n                    builder.setBlobStore(blobStore);\n                }\n                builder.setPersistentCache(\"target/persistentCache,time\");\n                builder.setMongoDB(mongoDB);\n                return builder.getNodeStore();\n            } catch (Exception e) {\n                return null;\n            }\n        }","commit_id":"dc979b150b6937f10e6fabaa638506f57e10ecbb","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected Repository createRepository(String url, String username, String password) {\n        DocumentNodeStore m = new DocumentMK.Builder()\n                .setClusterId(1)\n                .memoryCacheSize(64 * 1024 * 1024)\n                .setRDBConnection(RDBDataSourceFactory.forJdbcUrl(url, username, password))\n                .getNodeStore();\n        QueryEngineSettings qs = new QueryEngineSettings();\n        qs.setFullTextComparisonWithoutIndex(true);\n        return new Jcr(m).with(qs).createRepository();\n    }","id":49866,"modified_method":"protected Repository createRepository(String url, String username, String password) {\n        DocumentNodeStore m = new DocumentMK.Builder().\n                setClusterId(1).\n                memoryCacheSize(64 * 1024 * 1024).\n                setPersistentCache(\"target/persistentCache,time\").\n                setRDBConnection(RDBDataSourceFactory.forJdbcUrl(url, username, password)).\n                getNodeStore();\n        QueryEngineSettings qs = new QueryEngineSettings();\n        qs.setFullTextComparisonWithoutIndex(true);\n        return new Jcr(m).with(qs).createRepository();\n    }","commit_id":"dc979b150b6937f10e6fabaa638506f57e10ecbb","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static Repository createRepository(MongoConnection connection) {\n        DocumentNodeStore store = new DocumentMK.Builder().setClusterId(1).\n                memoryCacheSize(64 * 1024 * 1024).\n                setMongoDB(connection.getDB()).getNodeStore();\n        QueryEngineSettings qs = new QueryEngineSettings();\n        qs.setFullTextComparisonWithoutIndex(true);\n        return new Jcr(store).with(qs).createRepository();\n    }","id":49867,"modified_method":"private static Repository createRepository(MongoConnection connection) {\n        DocumentNodeStore store = new DocumentMK.Builder().\n                setClusterId(1).\n                memoryCacheSize(64 * 1024 * 1024).\n                setPersistentCache(\"target/persistentCache,time\").                \n                setMongoDB(connection.getDB()).\n                getNodeStore();\n        QueryEngineSettings qs = new QueryEngineSettings();\n        qs.setFullTextComparisonWithoutIndex(true);\n        return new Jcr(store).with(qs).createRepository();\n    }","commit_id":"dc979b150b6937f10e6fabaa638506f57e10ecbb","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Ignore(\"OAK-2075\")\n    @Test\n    public void deleteConcurrently() throws Exception {\n        final int loop = 1400;\n        final int count = COUNT;\n        final int clusters = NUM_CLUSTER_NODES;\n\n        LOG.debug(\n            \"Adding a total of {} nodes evely spread across cluster. Loop: {}, Count: {}, Cluster nodes: {}\",\n            new Object[] { loop * count * clusters, loop, count, clusters });\n\n        // creating instances\n        for (int i = 1; i <= clusters; i++) {\n            DocumentMK mk = new DocumentMK.Builder()\n                    .memoryCacheSize(CACHE_SIZE)\n                    .setMongoDB(createConnection().getDB())\n                    .setClusterId(i).open();\n            mks.add(mk);\n        }\n\n        Map<String, Exception> exceptions = Collections.synchronizedMap(\n            new HashMap<String, Exception>());\n\n        // initialising repositories and creating workers\n        for (int i = 0; i < mks.size(); i++) {\n            DocumentMK mk = mks.get(i);\n            Repository repo = new Jcr(mk.getNodeStore()).createRepository();\n            Session session = repo.login(ADMIN);\n            ensureIndex(session);\n            session.logout();\n            repos.add(repo);\n            workers.add(new Thread(new Worker(repo, exceptions), \"Worker-\" + (i + 1)));\n        }\n\n        // we know we have at least repos[0]\n        Repository repo = repos.get(0);\n        Session session = repo.login(ADMIN);\n        ensureIndex(session);\n        \n        // initialising the repository sequentially to avoid any possible\n        // concurrency errors during inserts\n        for (Thread w : workers) {\n            String nodeName = getNodeName(w);\n            createNodes(session, nodeName, loop, count, exceptions);\n        }\n        \n        // extra save for being sure.\n        session.save();\n        \n        if (exceptions.isEmpty()) {\n            // ensuring the cluster is aligned before triggering in order to avoid any\n            // PathNotFoundException\n            for (DocumentMK mk : mks) {\n                mk.getNodeStore().runBackgroundOperations();\n            }\n            for (Thread t : workers) {\n                t.start();\n            }\n            for (Thread t : workers) {\n                t.join();\n            }\n        } else {\n            // something where wrong during the insert. halting\n            LOG.error(\"Something went wrong during insert\");\n        }\n        \n        raiseExceptions(exceptions);\n    }","id":49868,"modified_method":"@Ignore(\"OAK-2075\")\n    @Test\n    public void deleteConcurrently() throws Exception {\n        final int loop = 1400;\n        final int count = COUNT;\n        final int clusters = NUM_CLUSTER_NODES;\n\n        LOG.debug(\n            \"Adding a total of {} nodes evely spread across cluster. Loop: {}, Count: {}, Cluster nodes: {}\",\n            new Object[] { loop * count * clusters, loop, count, clusters });\n\n        // creating instances\n        for (int i = 1; i <= clusters; i++) {\n            DocumentMK mk = new DocumentMK.Builder().\n                    memoryCacheSize(CACHE_SIZE).\n                    setPersistentCache(\"target/persistentCache,time\").\n                    setMongoDB(createConnection().getDB()).\n                    setClusterId(i).\n                    open();\n            mks.add(mk);\n        }\n\n        Map<String, Exception> exceptions = Collections.synchronizedMap(\n            new HashMap<String, Exception>());\n\n        // initialising repositories and creating workers\n        for (int i = 0; i < mks.size(); i++) {\n            DocumentMK mk = mks.get(i);\n            Repository repo = new Jcr(mk.getNodeStore()).createRepository();\n            Session session = repo.login(ADMIN);\n            ensureIndex(session);\n            session.logout();\n            repos.add(repo);\n            workers.add(new Thread(new Worker(repo, exceptions), \"Worker-\" + (i + 1)));\n        }\n\n        // we know we have at least repos[0]\n        Repository repo = repos.get(0);\n        Session session = repo.login(ADMIN);\n        ensureIndex(session);\n        \n        // initialising the repository sequentially to avoid any possible\n        // concurrency errors during inserts\n        for (Thread w : workers) {\n            String nodeName = getNodeName(w);\n            createNodes(session, nodeName, loop, count, exceptions);\n        }\n        \n        // extra save for being sure.\n        session.save();\n        \n        if (exceptions.isEmpty()) {\n            // ensuring the cluster is aligned before triggering in order to avoid any\n            // PathNotFoundException\n            for (DocumentMK mk : mks) {\n                mk.getNodeStore().runBackgroundOperations();\n            }\n            for (Thread t : workers) {\n                t.start();\n            }\n            for (Thread t : workers) {\n                t.join();\n            }\n        } else {\n            // something where wrong during the insert. halting\n            LOG.error(\"Something went wrong during insert\");\n        }\n        \n        raiseExceptions(exceptions);\n    }","commit_id":"dc979b150b6937f10e6fabaa638506f57e10ecbb","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static void initRepository() throws Exception {\n        MongoConnection con = createConnection();\n        DocumentMK mk = new DocumentMK.Builder()\n                .setMongoDB(con.getDB())\n                .setClusterId(1).open();\n        Repository repository = new Jcr(mk.getNodeStore()).createRepository();\n        Session session = repository.login(ADMIN);\n        ensureIndex(session);\n        session.logout();\n        dispose(repository);\n        mk.dispose(); // closes connection as well\n    }","id":49869,"modified_method":"private static void initRepository() throws Exception {\n        MongoConnection con = createConnection();\n        DocumentMK mk = new DocumentMK.Builder().\n                setMongoDB(con.getDB()).\n                setClusterId(1).\n                setPersistentCache(\"target/persistentCache,time\").\n                open();\n        Repository repository = new Jcr(mk.getNodeStore()).createRepository();\n        Session session = repository.login(ADMIN);\n        ensureIndex(session);\n        session.logout();\n        dispose(repository);\n        mk.dispose(); // closes connection as well\n    }","commit_id":"dc979b150b6937f10e6fabaa638506f57e10ecbb","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static NodeStoreFixture getMongo() {\n        return new NodeStoreFixture() {\n            @Override\n            public NodeStore createNodeStore() {\n                MongoConnection connection;\n                try {\n                    connection = new MongoConnection(\"mongodb://localhost:27017/oak\");\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                DB mongoDB = connection.getDB();                \n                return new DocumentMK.Builder().\n                            memoryCacheSize(0).\n                            setMongoDB(mongoDB, 1, 16).\n                            getNodeStore();\n            }\n    \n            @Override\n            public NodeStore createNodeStore(int clusterNodeId) {\n                return null;\n            }\n    \n            @Override\n            public void dispose(NodeStore nodeStore) {\n                if (nodeStore instanceof Closeable) {\n                    try {\n                        ((Closeable) nodeStore).close();\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n        };\n    }","id":49870,"modified_method":"private static NodeStoreFixture getMongo() {\n        return new NodeStoreFixture() {\n            @Override\n            public NodeStore createNodeStore() {\n                MongoConnection connection;\n                try {\n                    connection = new MongoConnection(\"mongodb://localhost:27017/oak\");\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n                DB mongoDB = connection.getDB();                \n                return new DocumentMK.Builder().\n                            memoryCacheSize(0).\n                            setMongoDB(mongoDB, 1, 16).\n                            setPersistentCache(\"target/persistentCache,time\").\n                            getNodeStore();\n            }\n    \n            @Override\n            public NodeStore createNodeStore(int clusterNodeId) {\n                return null;\n            }\n    \n            @Override\n            public void dispose(NodeStore nodeStore) {\n                if (nodeStore instanceof Closeable) {\n                    try {\n                        ((Closeable) nodeStore).close();\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n        };\n    }","commit_id":"dc979b150b6937f10e6fabaa638506f57e10ecbb","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void add(HostsType hostsType, String service,\n        boolean forUpgrade, boolean clientOnly, ProcessingComponent pc) {\n      // !!! no-op in this case\n    }","id":49871,"modified_method":"@Override\n    public void add(UpgradeContext ctx, HostsType hostsType, String service,\n        boolean clientOnly, ProcessingComponent pc) {\n      // !!! no-op in this case\n    }","commit_id":"345290d808246ad09a95f835c181e51462fa0dcd","url":"https://github.com/apache/ambari"},{"original_method":"private List<StageWrapper> fromProxies(Direction direction,\n        Map<String, List<TaskProxy>> wrappers) {\n      List<StageWrapper> results = new ArrayList<StageWrapper>();\n\n      Set<String> serviceChecks = new HashSet<String>();\n\n      for (Entry<String, List<TaskProxy>> entry : wrappers.entrySet()) {\n\n        // !!! stage per host, per type\n        StageWrapper wrapper = null;\n        List<StageWrapper> execwrappers = new ArrayList<StageWrapper>();\n\n        for (TaskProxy t : entry.getValue()) {\n          if (!t.clientOnly) {\n            serviceChecks.add(t.service);\n          }\n\n          if (!t.restart) {\n            if (null == wrapper) {\n              wrapper = new StageWrapper(StageWrapper.Type.RU_TASKS, t.message, t.getTasksArray());\n            }\n          } else {\n            execwrappers.add(new StageWrapper(StageWrapper.Type.RESTART, t.message, t.getTasksArray()));\n          }\n        }\n\n        if (null != wrapper) {\n          results.add(wrapper);\n        }\n\n        if (execwrappers.size() > 0) {\n          results.addAll(execwrappers);\n        }\n\n      }\n\n      if (Direction.UPGRADE == direction && m_serviceCheck &&\n          serviceChecks.size() > 0) {\n        // !!! add the service check task\n        List<TaskWrapper> tasks = new ArrayList<TaskWrapper>();\n        for (String service : serviceChecks) {\n          tasks.add(new TaskWrapper(service, \"\", Collections.<String>emptySet(), new ServiceCheckTask()));\n        }\n\n        StageWrapper wrapper = new StageWrapper(\n            StageWrapper.Type.SERVICE_CHECK,\n            \"Service Check \" + StringUtils.join(serviceChecks, \", \"),\n            tasks.toArray(new TaskWrapper[tasks.size()]));\n\n        results.add(wrapper);\n      }\n\n      return results;\n    }","id":49872,"modified_method":"private List<StageWrapper> fromProxies(Direction direction,\n        Map<String, List<TaskProxy>> wrappers) {\n      List<StageWrapper> results = new ArrayList<StageWrapper>();\n\n      Set<String> serviceChecks = new HashSet<String>();\n\n      for (Entry<String, List<TaskProxy>> entry : wrappers.entrySet()) {\n\n        // !!! stage per host, per type\n        StageWrapper wrapper = null;\n        List<StageWrapper> execwrappers = new ArrayList<StageWrapper>();\n\n        for (TaskProxy t : entry.getValue()) {\n          if (!t.clientOnly) {\n            serviceChecks.add(t.service);\n          }\n\n          if (!t.restart) {\n            if (null == wrapper) {\n              wrapper = new StageWrapper(StageWrapper.Type.RU_TASKS, t.message, t.getTasksArray());\n            }\n          } else {\n            execwrappers.add(new StageWrapper(StageWrapper.Type.RESTART, t.message, t.getTasksArray()));\n          }\n        }\n\n        if (null != wrapper) {\n          results.add(wrapper);\n        }\n\n        if (execwrappers.size() > 0) {\n          results.addAll(execwrappers);\n        }\n\n      }\n\n      if (direction.isUpgrade() && m_serviceCheck && serviceChecks.size() > 0) {\n        // !!! add the service check task\n        List<TaskWrapper> tasks = new ArrayList<TaskWrapper>();\n        Set<String> displays = new HashSet<String>();\n        for (String service : serviceChecks) {\n          tasks.add(new TaskWrapper(service, \"\", Collections.<String>emptySet(), new ServiceCheckTask()));\n          displays.add(service);\n        }\n\n        StageWrapper wrapper = new StageWrapper(\n            StageWrapper.Type.SERVICE_CHECK,\n            \"Service Check \" + StringUtils.join(displays, \", \"),\n            tasks.toArray(new TaskWrapper[tasks.size()]));\n\n        results.add(wrapper);\n      }\n\n      return results;\n    }","commit_id":"345290d808246ad09a95f835c181e51462fa0dcd","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n    public void add(HostsType hostsType, String service,\n        boolean forUpgrade, boolean clientOnly, ProcessingComponent pc) {\n\n      int count = Double.valueOf(Math.ceil(\n          (double) m_batch.percent / 100 * hostsType.hosts.size())).intValue();\n\n      int i = 0;\n      for (String host : hostsType.hosts) {\n        // This class required inserting a single host into the collection\n        HostsType singleHostsType = new HostsType();\n        singleHostsType.hosts = Collections.singleton(host);\n\n        Map<String, List<TaskProxy>> targetMap = ((i++) < count) ? initialBatch : finalBatches;\n        List<TaskProxy> targetList = targetMap.get(host);\n        if (null == targetList) {\n          targetList = new ArrayList<TaskProxy>();\n          targetMap.put(host, targetList);\n        }\n\n        TaskProxy proxy = null;\n\n        List<Task> tasks = resolveTasks(forUpgrade, true, pc);\n\n        if (null != tasks && tasks.size() > 0) {\n          proxy = new TaskProxy();\n          proxy.clientOnly = clientOnly;\n          proxy.message = getStageText(\"Preparing\", pc.name, Collections.singleton(host));\n          proxy.tasks.addAll(TaskWrapperBuilder.getTaskList(service, pc.name, singleHostsType, tasks));\n          proxy.service = service;\n          proxy.component = pc.name;\n          targetList.add(proxy);\n        }\n\n        // !!! FIXME upgrade definition have only one step, and it better be a restart\n        if (null != pc.tasks && 1 == pc.tasks.size()) {\n          Task t = pc.tasks.get(0);\n          if (RestartTask.class.isInstance(t)) {\n            proxy = new TaskProxy();\n            proxy.clientOnly = clientOnly;\n            proxy.tasks.add(new TaskWrapper(service, pc.name, Collections.singleton(host), t));\n            proxy.restart = true;\n            proxy.service = service;\n            proxy.component = pc.name;\n            proxy.message = getStageText(\"Restarting \", pc.name, Collections.singleton(host));\n\n            targetList.add(proxy);\n          }\n        }\n\n        tasks = resolveTasks(forUpgrade, false, pc);\n\n        if (null != tasks && tasks.size() > 0) {\n          proxy = new TaskProxy();\n          proxy.clientOnly = clientOnly;\n          proxy.component = pc.name;\n          proxy.service = service;\n          proxy.tasks.addAll(TaskWrapperBuilder.getTaskList(service, pc.name, singleHostsType, tasks));\n          proxy.message = getStageText(\"Completing\", pc.name, Collections.singleton(host));\n          targetList.add(proxy);\n        }\n      }\n    }","id":49873,"modified_method":"@Override\n    public void add(UpgradeContext ctx, HostsType hostsType, String service,\n        boolean clientOnly, ProcessingComponent pc) {\n\n      boolean forUpgrade = ctx.getDirection().isUpgrade();\n\n      int count = Double.valueOf(Math.ceil(\n          (double) m_batch.percent / 100 * hostsType.hosts.size())).intValue();\n\n      int i = 0;\n      for (String host : hostsType.hosts) {\n        // This class required inserting a single host into the collection\n        HostsType singleHostsType = new HostsType();\n        singleHostsType.hosts = Collections.singleton(host);\n\n        Map<String, List<TaskProxy>> targetMap = ((i++) < count) ? initialBatch : finalBatches;\n        List<TaskProxy> targetList = targetMap.get(host);\n        if (null == targetList) {\n          targetList = new ArrayList<TaskProxy>();\n          targetMap.put(host, targetList);\n        }\n\n        TaskProxy proxy = null;\n\n        List<Task> tasks = resolveTasks(forUpgrade, true, pc);\n\n        if (null != tasks && tasks.size() > 0) {\n          proxy = new TaskProxy();\n          proxy.clientOnly = clientOnly;\n          proxy.message = getStageText(\"Preparing\",\n              ctx.getComponentDisplay(service, pc.name), Collections.singleton(host));\n          proxy.tasks.addAll(TaskWrapperBuilder.getTaskList(service, pc.name, singleHostsType, tasks));\n          proxy.service = service;\n          proxy.component = pc.name;\n          targetList.add(proxy);\n        }\n\n        // !!! FIXME upgrade definition have only one step, and it better be a restart\n        if (null != pc.tasks && 1 == pc.tasks.size()) {\n          Task t = pc.tasks.get(0);\n          if (RestartTask.class.isInstance(t)) {\n            proxy = new TaskProxy();\n            proxy.clientOnly = clientOnly;\n            proxy.tasks.add(new TaskWrapper(service, pc.name, Collections.singleton(host), t));\n            proxy.restart = true;\n            proxy.service = service;\n            proxy.component = pc.name;\n            proxy.message = getStageText(\"Restarting\",\n                ctx.getComponentDisplay(service, pc.name), Collections.singleton(host));\n            targetList.add(proxy);\n          }\n        }\n\n        tasks = resolveTasks(forUpgrade, false, pc);\n\n        if (null != tasks && tasks.size() > 0) {\n          proxy = new TaskProxy();\n          proxy.clientOnly = clientOnly;\n          proxy.component = pc.name;\n          proxy.service = service;\n          proxy.tasks.addAll(TaskWrapperBuilder.getTaskList(service, pc.name, singleHostsType, tasks));\n          proxy.message = getStageText(\"Completing\",\n              ctx.getComponentDisplay(service, pc.name), Collections.singleton(host));\n          targetList.add(proxy);\n        }\n      }\n    }","commit_id":"345290d808246ad09a95f835c181e51462fa0dcd","url":"https://github.com/apache/ambari"},{"original_method":"/**\n     * Add stages where the restart stages are ordered\n     * E.g., preupgrade, restart hosts(0), ..., restart hosts(n-1), postupgrade\n     * @param hostsType the order collection of hosts, which may have a master and secondary\n     * @param service the service name\n     * @param pc the ProcessingComponent derived from the upgrade pack.\n     */\n    @Override\n    public void add(HostsType hostsType, String service,\n        boolean forUpgrade, boolean clientOnly, ProcessingComponent pc) {\n\n      List<TaskBucket> buckets = buckets(resolveTasks(forUpgrade, true, pc));\n      for (TaskBucket bucket : buckets) {\n        List<TaskWrapper> preTasks = TaskWrapperBuilder.getTaskList(service, pc.name, hostsType, bucket.tasks);\n        Set<String> preTasksEffectiveHosts = TaskWrapperBuilder.getEffectiveHosts(preTasks);\n        StageWrapper stage = new StageWrapper(\n            bucket.type,\n            getStageText(\"Preparing\", pc.name, preTasksEffectiveHosts),\n            preTasks\n            );\n        m_stages.add(stage);\n      }\n\n      // !!! FIXME upgrade definition have only one step, and it better be a restart\n      if (null != pc.tasks && 1 == pc.tasks.size()) {\n        Task t = pc.tasks.get(0);\n        if (RestartTask.class.isInstance(t)) {\n          for (String hostName : hostsType.hosts) {\n            StageWrapper stage = new StageWrapper(\n                StageWrapper.Type.RESTART,\n                getStageText(\"Restarting\", pc.name, Collections.singleton(hostName)),\n                new TaskWrapper(service, pc.name, Collections.singleton(hostName), t));\n            m_stages.add(stage);\n          }\n        }\n      }\n\n      buckets = buckets(resolveTasks(forUpgrade, false, pc));\n      for (TaskBucket bucket : buckets) {\n        List<TaskWrapper> postTasks = TaskWrapperBuilder.getTaskList(service, pc.name, hostsType, bucket.tasks);\n        Set<String> postTasksEffectiveHosts = TaskWrapperBuilder.getEffectiveHosts(postTasks);\n        StageWrapper stage = new StageWrapper(\n            bucket.type,\n            getStageText(\"Completing\", pc.name, postTasksEffectiveHosts),\n            postTasks\n            );\n        m_stages.add(stage);\n      }\n\n      if (!clientOnly) {\n        m_servicesToCheck.add(service);\n      }\n    }","id":49874,"modified_method":"/**\n     * Add stages where the restart stages are ordered\n     * E.g., preupgrade, restart hosts(0), ..., restart hosts(n-1), postupgrade\n     * @param hostsType the order collection of hosts, which may have a master and secondary\n     * @param service the service name\n     * @param pc the ProcessingComponent derived from the upgrade pack.\n     */\n    @Override\n    public void add(UpgradeContext ctx, HostsType hostsType, String service,\n       boolean clientOnly, ProcessingComponent pc) {\n\n      boolean forUpgrade = ctx.getDirection().isUpgrade();\n\n      List<TaskBucket> buckets = buckets(resolveTasks(forUpgrade, true, pc));\n      for (TaskBucket bucket : buckets) {\n        List<TaskWrapper> preTasks = TaskWrapperBuilder.getTaskList(service, pc.name, hostsType, bucket.tasks);\n        Set<String> preTasksEffectiveHosts = TaskWrapperBuilder.getEffectiveHosts(preTasks);\n        StageWrapper stage = new StageWrapper(\n            bucket.type,\n            getStageText(\"Preparing\", ctx.getComponentDisplay(service, pc.name), preTasksEffectiveHosts),\n            preTasks\n            );\n        m_stages.add(stage);\n      }\n\n      // !!! FIXME upgrade definition have only one step, and it better be a restart\n      if (null != pc.tasks && 1 == pc.tasks.size()) {\n        Task t = pc.tasks.get(0);\n        if (RestartTask.class.isInstance(t)) {\n          for (String hostName : hostsType.hosts) {\n            StageWrapper stage = new StageWrapper(\n                StageWrapper.Type.RESTART,\n                getStageText(\"Restarting\", ctx.getComponentDisplay(service, pc.name), Collections.singleton(hostName)),\n                new TaskWrapper(service, pc.name, Collections.singleton(hostName), t));\n            m_stages.add(stage);\n          }\n        }\n      }\n\n      buckets = buckets(resolveTasks(forUpgrade, false, pc));\n      for (TaskBucket bucket : buckets) {\n        List<TaskWrapper> postTasks = TaskWrapperBuilder.getTaskList(service, pc.name, hostsType, bucket.tasks);\n        Set<String> postTasksEffectiveHosts = TaskWrapperBuilder.getEffectiveHosts(postTasks);\n        StageWrapper stage = new StageWrapper(\n            bucket.type,\n            getStageText(\"Completing\", ctx.getComponentDisplay(service, pc.name), postTasksEffectiveHosts),\n            postTasks\n            );\n        m_stages.add(stage);\n      }\n\n      if (!clientOnly) {\n        m_servicesToCheck.add(service);\n      }\n    }","commit_id":"345290d808246ad09a95f835c181e51462fa0dcd","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n    public List<StageWrapper> build(UpgradeContext ctx) {\n\n      List<TaskWrapper> tasks = new ArrayList<TaskWrapper>();\n      for (String service : m_servicesToCheck) {\n        tasks.add(new TaskWrapper(\n            service, \"\", Collections.<String>emptySet(), new ServiceCheckTask()));\n      }\n\n      if (Direction.UPGRADE == ctx.getDirection() && m_serviceCheck &&\n          m_servicesToCheck.size() > 0) {\n        StageWrapper wrapper = new StageWrapper(\n            StageWrapper.Type.SERVICE_CHECK,\n            \"Service Check \" + StringUtils.join(m_servicesToCheck, \", \"),\n            tasks.toArray(new TaskWrapper[0])\n            );\n\n        m_stages.add(wrapper);\n      }\n\n      return m_stages;\n    }","id":49875,"modified_method":"@Override\n    public List<StageWrapper> build(UpgradeContext ctx) {\n\n      List<TaskWrapper> tasks = new ArrayList<TaskWrapper>();\n      List<String> displays = new ArrayList<String>();\n      for (String service : m_servicesToCheck) {\n        tasks.add(new TaskWrapper(\n            service, \"\", Collections.<String>emptySet(), new ServiceCheckTask()));\n        displays.add(ctx.getServiceDisplay(service));\n      }\n\n      if (ctx.getDirection().isUpgrade() && m_serviceCheck && m_servicesToCheck.size() > 0) {\n        StageWrapper wrapper = new StageWrapper(\n            StageWrapper.Type.SERVICE_CHECK,\n            \"Service Check \" + StringUtils.join(displays, \", \"),\n            tasks.toArray(new TaskWrapper[0])\n            );\n\n        m_stages.add(wrapper);\n      }\n\n      return m_stages;\n    }","commit_id":"345290d808246ad09a95f835c181e51462fa0dcd","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n    public void add(HostsType hostsType, String service, boolean forUpgrade, boolean clientOnly,\n        ProcessingComponent pc) {\n      // !!! nothing to do here\n    }","id":49876,"modified_method":"@Override\n    public void add(UpgradeContext ctx, HostsType hostsType, String service,\n        boolean clientOnly, ProcessingComponent pc) {\n      // !!! nothing to do here\n    }","commit_id":"345290d808246ad09a95f835c181e51462fa0dcd","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n    public List<StageWrapper> build(UpgradeContext ctx) {\n      m_cluster = ctx.getCluster();\n      m_metaInfo = ctx.getAmbariMetaInfo();\n\n      List<StageWrapper> result = new ArrayList<StageWrapper>();\n      if (Direction.DOWNGRADE == ctx.getDirection()) {\n        return result;\n      }\n\n      Map<String, Service> serviceMap = m_cluster.getServices();\n\n      Set<String> clusterServices = new LinkedHashSet<String>(serviceMap.keySet());\n\n      // create stages for the priorities\n      for (String service : ServiceCheckGrouping.this.priorityServices) {\n        if (checkServiceValidity(service, serviceMap)) {\n          StageWrapper wrapper = new StageWrapper(\n              StageWrapper.Type.SERVICE_CHECK,\n              \"Service Check \" + service,\n              new TaskWrapper(service, \"\", Collections.<String>emptySet(),\n                  new ServiceCheckTask()));\n          result.add(wrapper);\n\n          clusterServices.remove(service);\n        }\n      }\n\n      // create stages for everything else\n      for (String service : clusterServices) {\n        if (checkServiceValidity(service, serviceMap)) {\n          StageWrapper wrapper = new StageWrapper(\n              StageWrapper.Type.SERVICE_CHECK,\n              \"Service Check \" + service,\n              new TaskWrapper(service, \"\", Collections.<String>emptySet(),\n                  new ServiceCheckTask()));\n          result.add(wrapper);\n        }\n      }\n      return result;\n    }","id":49877,"modified_method":"@Override\n    public List<StageWrapper> build(UpgradeContext ctx) {\n      m_cluster = ctx.getCluster();\n      m_metaInfo = ctx.getAmbariMetaInfo();\n\n      List<StageWrapper> result = new ArrayList<StageWrapper>();\n      if (ctx.getDirection().isDowngrade()) {\n        return result;\n      }\n\n      Map<String, Service> serviceMap = m_cluster.getServices();\n\n      Set<String> clusterServices = new LinkedHashSet<String>(serviceMap.keySet());\n\n      // create stages for the priorities\n      for (String service : ServiceCheckGrouping.this.priorityServices) {\n        if (checkServiceValidity(service, serviceMap)) {\n          StageWrapper wrapper = new StageWrapper(\n              StageWrapper.Type.SERVICE_CHECK,\n              \"Service Check \" + ctx.getServiceDisplay(service),\n              new TaskWrapper(service, \"\", Collections.<String>emptySet(),\n                  new ServiceCheckTask()));\n          result.add(wrapper);\n\n          clusterServices.remove(service);\n        }\n      }\n\n      // create stages for everything else\n      for (String service : clusterServices) {\n        if (checkServiceValidity(service, serviceMap)) {\n          StageWrapper wrapper = new StageWrapper(\n              StageWrapper.Type.SERVICE_CHECK,\n              \"Service Check \" + ctx.getServiceDisplay(service),\n              new TaskWrapper(service, \"\", Collections.<String>emptySet(),\n                  new ServiceCheckTask()));\n          result.add(wrapper);\n        }\n      }\n      return result;\n    }","commit_id":"345290d808246ad09a95f835c181e51462fa0dcd","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Adds a processing component that will be built into stage wrappers.\n   *\n   * @param hostsType   the hosts, along with their type\n   * @param service     the service name\n   * @param forUpgrade  {@code true} when performing an upgrade, {@code false} for a downgrade\n   * @param clientOnly  whether the service is client only, no service checks\n   * @param pc          the ProcessingComponent derived from the upgrade pack\n   */\n  public abstract void add(HostsType hostsType, String service,\n      boolean forUpgrade, boolean clientOnly, ProcessingComponent pc);","id":49878,"modified_method":"/**\n   * Adds a processing component that will be built into stage wrappers.\n   *\n   * @param ctx         the upgrade context\n   * @param hostsType   the hosts, along with their type\n   * @param service     the service name\n   * @param clientOnly  whether the service is client only, no service checks\n   * @param pc          the ProcessingComponent derived from the upgrade pack\n   */\n  public abstract void add(UpgradeContext ctx, HostsType hostsType, String service,\n      boolean clientOnly, ProcessingComponent pc);","commit_id":"345290d808246ad09a95f835c181e51462fa0dcd","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Generates a list of UpgradeGroupHolder items that are used to execute either\n   * an upgrade or a downgrade.\n   *\n   * @param upgradePack\n   *          the upgrade pack\n   * @param context\n   *          the context that wraps key fields required to perform an upgrade\n   * @return the list of holders\n   */\n  public List<UpgradeGroupHolder> createSequence(UpgradePack upgradePack,\n      UpgradeContext context) throws AmbariException {\n\n    context.setAmbariMetaInfo(m_ambariMetaInfo.get());\n    Cluster cluster = context.getCluster();\n    boolean forUpgrade = context.getDirection() == Direction.UPGRADE;\n    MasterHostResolver mhr = context.getResolver();\n\n    Map<String, Map<String, ProcessingComponent>> allTasks = upgradePack.getTasks();\n    List<UpgradeGroupHolder> groups = new ArrayList<UpgradeGroupHolder>();\n\n    for (Grouping group : upgradePack.getGroups(forUpgrade)) {\n\n      UpgradeGroupHolder groupHolder = new UpgradeGroupHolder();\n      groupHolder.name = group.name;\n      groupHolder.title = group.title;\n      groupHolder.skippable = group.skippable;\n      groupHolder.allowRetry = group.allowRetry;\n\n      // !!! all downgrades are skippable\n      if (Direction.DOWNGRADE == context.getDirection()) {\n        groupHolder.skippable = true;\n      }\n\n      StageWrapperBuilder builder = group.getBuilder();\n\n      List<UpgradePack.OrderService> services = group.services;\n\n      if (context.getDirection() == Direction.DOWNGRADE && !services.isEmpty()) {\n        List<UpgradePack.OrderService> reverse = new ArrayList<UpgradePack.OrderService>(services);\n        Collections.reverse(reverse);\n        services = reverse;\n      }\n\n      // !!! cluster and service checks are empty here\n      for (UpgradePack.OrderService service : services) {\n\n        if (!allTasks.containsKey(service.serviceName)) {\n          continue;\n        }\n\n        for (String component : service.components) {\n          if (!allTasks.get(service.serviceName).containsKey(component)) {\n            continue;\n          }\n\n          HostsType hostsType = mhr.getMasterAndHosts(service.serviceName, component);\n          if (null == hostsType) {\n            continue;\n          }\n\n          if (!hostsType.unhealthy.isEmpty()) {\n            context.addUnhealthy(hostsType.unhealthy);\n          }\n\n          Service svc = cluster.getService(service.serviceName);\n          ProcessingComponent pc = allTasks.get(service.serviceName).get(component);\n\n          // Special case for NAMENODE\n          if (service.serviceName.equalsIgnoreCase(\"HDFS\") && component.equalsIgnoreCase(\"NAMENODE\")) {\n            // !!! revisit if needed\n            if (hostsType.master != null && hostsType.secondary != null) {\n              // The order is important, first do the standby, then the active namenode.\n              Set<String> order = new LinkedHashSet<String>();\n\n              order.add(hostsType.secondary);\n              order.add(hostsType.master);\n\n              // Override the hosts with the ordered collection\n              hostsType.hosts = order;\n            } else {\n                throw new AmbariException(MessageFormat.format(\"Could not find active and standby namenodes using hosts: {0}\", StringUtils.join(hostsType.hosts, \", \").toString()));\n            }\n\n            builder.add(hostsType, service.serviceName, forUpgrade,\n                svc.isClientOnlyService(), pc);\n\n          } else {\n            builder.add(hostsType, service.serviceName, forUpgrade,\n                svc.isClientOnlyService(), pc);\n          }\n        }\n      }\n\n      List<StageWrapper> proxies = builder.build(context);\n\n      if (!proxies.isEmpty()) {\n        groupHolder.items = proxies;\n        postProcess(context, groupHolder);\n        groups.add(groupHolder);\n      }\n    }\n\n    if (LOG.isDebugEnabled()) {\n      for (UpgradeGroupHolder group : groups) {\n        LOG.debug(group.name);\n\n        int i = 0;\n        for (StageWrapper proxy : group.items) {\n          LOG.debug(\"  Stage {}\", Integer.valueOf(i++));\n          int j = 0;\n\n          for (TaskWrapper task : proxy.getTasks()) {\n            LOG.debug(\"    Task {} {}\", Integer.valueOf(j++), task);\n          }\n        }\n      }\n    }\n\n    return groups;\n  }","id":49879,"modified_method":"/**\n   * Generates a list of UpgradeGroupHolder items that are used to execute either\n   * an upgrade or a downgrade.\n   *\n   * @param upgradePack\n   *          the upgrade pack\n   * @param context\n   *          the context that wraps key fields required to perform an upgrade\n   * @return the list of holders\n   */\n  public List<UpgradeGroupHolder> createSequence(UpgradePack upgradePack,\n      UpgradeContext context) throws AmbariException {\n\n    context.setAmbariMetaInfo(m_ambariMetaInfo.get());\n    Cluster cluster = context.getCluster();\n    MasterHostResolver mhr = context.getResolver();\n\n    Map<String, Map<String, ProcessingComponent>> allTasks = upgradePack.getTasks();\n    List<UpgradeGroupHolder> groups = new ArrayList<UpgradeGroupHolder>();\n\n    for (Grouping group : upgradePack.getGroups(context.getDirection().isUpgrade())) {\n\n      UpgradeGroupHolder groupHolder = new UpgradeGroupHolder();\n      groupHolder.name = group.name;\n      groupHolder.title = group.title;\n      groupHolder.skippable = group.skippable;\n      groupHolder.allowRetry = group.allowRetry;\n\n      // !!! all downgrades are skippable\n      if (context.getDirection().isDowngrade()) {\n        groupHolder.skippable = true;\n      }\n\n      StageWrapperBuilder builder = group.getBuilder();\n\n      List<UpgradePack.OrderService> services = group.services;\n\n      if (context.getDirection().isDowngrade() && !services.isEmpty()) {\n        List<UpgradePack.OrderService> reverse = new ArrayList<UpgradePack.OrderService>(services);\n        Collections.reverse(reverse);\n        services = reverse;\n      }\n\n      // !!! cluster and service checks are empty here\n      for (UpgradePack.OrderService service : services) {\n\n        if (!allTasks.containsKey(service.serviceName)) {\n          continue;\n        }\n\n        for (String component : service.components) {\n          if (!allTasks.get(service.serviceName).containsKey(component)) {\n            continue;\n          }\n\n          HostsType hostsType = mhr.getMasterAndHosts(service.serviceName, component);\n          if (null == hostsType) {\n            continue;\n          }\n\n          if (!hostsType.unhealthy.isEmpty()) {\n            context.addUnhealthy(hostsType.unhealthy);\n          }\n\n          Service svc = cluster.getService(service.serviceName);\n          ProcessingComponent pc = allTasks.get(service.serviceName).get(component);\n\n          setDisplayNames(context, service.serviceName, component);\n\n          // Special case for NAMENODE\n          if (service.serviceName.equalsIgnoreCase(\"HDFS\") && component.equalsIgnoreCase(\"NAMENODE\")) {\n            // !!! revisit if needed\n            if (hostsType.master != null && hostsType.secondary != null) {\n              // The order is important, first do the standby, then the active namenode.\n              Set<String> order = new LinkedHashSet<String>();\n\n              order.add(hostsType.secondary);\n              order.add(hostsType.master);\n\n              // Override the hosts with the ordered collection\n              hostsType.hosts = order;\n            } else {\n                throw new AmbariException(MessageFormat.format(\"Could not find active and standby namenodes using hosts: {0}\", StringUtils.join(hostsType.hosts, \", \").toString()));\n            }\n\n            builder.add(context, hostsType, service.serviceName,\n                svc.isClientOnlyService(), pc);\n\n          } else {\n            builder.add(context, hostsType, service.serviceName,\n                svc.isClientOnlyService(), pc);\n          }\n        }\n      }\n\n      List<StageWrapper> proxies = builder.build(context);\n\n      if (!proxies.isEmpty()) {\n        groupHolder.items = proxies;\n        postProcess(context, groupHolder);\n        groups.add(groupHolder);\n      }\n    }\n\n    if (LOG.isDebugEnabled()) {\n      for (UpgradeGroupHolder group : groups) {\n        LOG.debug(group.name);\n\n        int i = 0;\n        for (StageWrapper proxy : group.items) {\n          LOG.debug(\"  Stage {}\", Integer.valueOf(i++));\n          int j = 0;\n\n          for (TaskWrapper task : proxy.getTasks()) {\n            LOG.debug(\"    Task {} {}\", Integer.valueOf(j++), task);\n          }\n        }\n      }\n    }\n\n    return groups;\n  }","commit_id":"345290d808246ad09a95f835c181e51462fa0dcd","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testUpgradeOrchestration() throws Exception {\n    Map<String, UpgradePack> upgrades = ambariMetaInfo.getUpgradePacks(\"foo\", \"bar\");\n    assertTrue(upgrades.isEmpty());\n\n    upgrades = ambariMetaInfo.getUpgradePacks(\"HDP\", \"2.1.1\");\n    assertTrue(upgrades.containsKey(\"upgrade_test\"));\n    UpgradePack upgrade = upgrades.get(\"upgrade_test\");\n    assertNotNull(upgrade);\n\n    makeCluster();\n\n    UpgradeContext context = new UpgradeContext(m_masterHostResolver,\n        UPGRADE_VERSION, Direction.UPGRADE);\n\n    List<UpgradeGroupHolder> groups = m_upgradeHelper.createSequence(upgrade, context);\n\n    assertEquals(6, groups.size());\n\n    assertEquals(\"PRE_CLUSTER\", groups.get(0).name);\n    assertEquals(\"ZOOKEEPER\", groups.get(1).name);\n    assertEquals(\"CORE_MASTER\", groups.get(2).name);\n    assertEquals(\"CORE_SLAVES\", groups.get(3).name);\n    assertEquals(\"HIVE\", groups.get(4).name);\n\n    UpgradeGroupHolder holder = groups.get(2);\n    boolean found = false;\n    for (StageWrapper sw : holder.items) {\n      if (sw.getTasksJson().contains(\"Upgrading your database\")) {\n        found = true;\n      }\n    }\n    assertTrue(\"Expected to find replaced text for Upgrading\", found);\n\n\n    UpgradeGroupHolder postGroup = groups.get(5);\n    assertEquals(postGroup.name, \"POST_CLUSTER\");\n    assertEquals(postGroup.title, \"Finalize Upgrade\");\n    assertEquals(postGroup.items.size(), 3);\n    assertEquals(postGroup.items.get(0).getText(), \"Confirm Finalize\");\n    assertEquals(postGroup.items.get(1).getText(), \"Execute HDFS Finalize\");\n    assertEquals(postGroup.items.get(2).getText(), \"Save Cluster State\");\n    assertEquals(postGroup.items.get(2).getType(), StageWrapper.Type.SERVER_SIDE_ACTION);\n\n    assertEquals(4, groups.get(0).items.size());\n    assertEquals(6, groups.get(1).items.size());\n    assertEquals(8, groups.get(2).items.size());\n    assertEquals(8, groups.get(3).items.size());\n  }","id":49880,"modified_method":"@Test\n  public void testUpgradeOrchestration() throws Exception {\n    Map<String, UpgradePack> upgrades = ambariMetaInfo.getUpgradePacks(\"foo\", \"bar\");\n    assertTrue(upgrades.isEmpty());\n\n    upgrades = ambariMetaInfo.getUpgradePacks(\"HDP\", \"2.1.1\");\n\n    ServiceInfo si = ambariMetaInfo.getService(\"HDP\", \"2.1.1\", \"ZOOKEEPER\");\n    si.setDisplayName(\"Zk\");\n    ComponentInfo ci = si.getComponentByName(\"ZOOKEEPER_SERVER\");\n    ci.setDisplayName(\"ZooKeeper1 Server2\");\n\n\n    assertTrue(upgrades.containsKey(\"upgrade_test\"));\n    UpgradePack upgrade = upgrades.get(\"upgrade_test\");\n    assertNotNull(upgrade);\n\n    makeCluster();\n\n    UpgradeContext context = new UpgradeContext(m_masterHostResolver,\n        UPGRADE_VERSION, Direction.UPGRADE);\n\n    List<UpgradeGroupHolder> groups = m_upgradeHelper.createSequence(upgrade, context);\n\n    assertEquals(6, groups.size());\n\n    assertEquals(\"PRE_CLUSTER\", groups.get(0).name);\n    assertEquals(\"ZOOKEEPER\", groups.get(1).name);\n    assertEquals(\"CORE_MASTER\", groups.get(2).name);\n    assertEquals(\"CORE_SLAVES\", groups.get(3).name);\n    assertEquals(\"HIVE\", groups.get(4).name);\n\n    UpgradeGroupHolder holder = groups.get(2);\n    boolean found = false;\n    for (StageWrapper sw : holder.items) {\n      if (sw.getTasksJson().contains(\"Upgrading your database\")) {\n        found = true;\n      }\n    }\n    assertTrue(\"Expected to find replaced text for Upgrading\", found);\n\n\n    UpgradeGroupHolder group = groups.get(1);\n    // check that the display name is being used\n    assertTrue(group.items.get(1).getText().contains(\"ZooKeeper1 Server2\"));\n    assertEquals(group.items.get(5).getText(), \"Service Check Zk\");\n\n    UpgradeGroupHolder postGroup = groups.get(5);\n    assertEquals(postGroup.name, \"POST_CLUSTER\");\n    assertEquals(postGroup.title, \"Finalize Upgrade\");\n    assertEquals(postGroup.items.size(), 3);\n    assertEquals(postGroup.items.get(0).getText(), \"Confirm Finalize\");\n    assertEquals(postGroup.items.get(1).getText(), \"Execute HDFS Finalize\");\n    assertEquals(postGroup.items.get(2).getText(), \"Save Cluster State\");\n    assertEquals(postGroup.items.get(2).getType(), StageWrapper.Type.SERVER_SIDE_ACTION);\n\n    assertEquals(4, groups.get(0).items.size());\n    assertEquals(6, groups.get(1).items.size());\n    assertEquals(8, groups.get(2).items.size());\n    assertEquals(8, groups.get(3).items.size());\n  }","commit_id":"345290d808246ad09a95f835c181e51462fa0dcd","url":"https://github.com/apache/ambari"},{"original_method":"private UpgradeEntity createUpgrade(Direction direction, UpgradePack pack,\n                                      Map<String, Object> requestMap) throws AmbariException {\n\n    String clusterName = (String) requestMap.get(UPGRADE_CLUSTER_NAME);\n\n    if (null == clusterName) {\n      throw new AmbariException(String.format(\"%s is required\", UPGRADE_CLUSTER_NAME));\n    }\n\n    Cluster cluster = getManagementController().getClusters().getCluster(clusterName);\n    ConfigHelper configHelper = getManagementController().getConfigHelper();\n\n    // the version being upgraded or downgraded to (ie hdp-2.2.1.0-1234)\n    final String version = (String) requestMap.get(UPGRADE_VERSION);\n\n    MasterHostResolver resolver = Direction.UPGRADE == direction ?\n        new MasterHostResolver(configHelper, cluster) : new MasterHostResolver(configHelper, cluster, version);\n\n    UpgradeContext ctx = new UpgradeContext(resolver, version, direction);\n\n    List<UpgradeGroupHolder> groups = s_upgradeHelper.createSequence(pack, ctx);\n\n    if (groups.isEmpty()) {\n      throw new AmbariException(\"There are no groupings available\");\n    }\n\n    List<UpgradeGroupEntity> groupEntities = new ArrayList<UpgradeGroupEntity>();\n    RequestStageContainer req = createRequest(direction, version);\n\n    for (UpgradeGroupHolder group : groups) {\n      UpgradeGroupEntity groupEntity = new UpgradeGroupEntity();\n      groupEntity.setName(group.name);\n      groupEntity.setTitle(group.title);\n      boolean skippable = group.skippable;\n      boolean allowRetry = group.allowRetry;\n\n      List<UpgradeItemEntity> itemEntities = new ArrayList<UpgradeItemEntity>();\n\n      for (StageWrapper wrapper : group.items) {\n        if (wrapper.getType() == StageWrapper.Type.SERVER_SIDE_ACTION) {\n          // !!! each stage is guaranteed to be of one type.  but because there\n          // is a bug that prevents one stage with multiple tasks assigned for the same host,\n          // break them out into individual stages.\n\n          for (TaskWrapper taskWrapper : wrapper.getTasks()) {\n            for (Task task : taskWrapper.getTasks()) {\n              UpgradeItemEntity itemEntity = new UpgradeItemEntity();\n              itemEntity.setText(wrapper.getText());\n              itemEntity.setTasks(wrapper.getTasksJson());\n              itemEntity.setHosts(wrapper.getHostsJson());\n              itemEntities.add(itemEntity);\n\n              injectVariables(configHelper, cluster, itemEntity);\n\n              makeServerSideStage(ctx, req, itemEntity, (ServerSideActionTask) task, skippable, allowRetry);\n            }\n          }\n        } else {\n          UpgradeItemEntity itemEntity = new UpgradeItemEntity();\n          itemEntity.setText(wrapper.getText());\n          itemEntity.setTasks(wrapper.getTasksJson());\n          itemEntity.setHosts(wrapper.getHostsJson());\n          itemEntities.add(itemEntity);\n\n          injectVariables(configHelper, cluster, itemEntity);\n\n          // upgrade items match a stage\n          createStage(ctx, req, itemEntity, wrapper, skippable, allowRetry);\n        }\n      }\n\n      groupEntity.setItems(itemEntities);\n\n      groupEntities.add(groupEntity);\n\n    }\n\n    UpgradeEntity entity = new UpgradeEntity();\n    entity.setFromVersion(cluster.getCurrentClusterVersion().getRepositoryVersion().getVersion());\n    entity.setToVersion(version);\n    entity.setUpgradeGroups(groupEntities);\n    entity.setClusterId(Long.valueOf(cluster.getClusterId()));\n    entity.setDirection(direction);\n\n    req.getRequestStatusResponse();\n\n    entity.setRequestId(req.getId());\n\n    req.persist();\n\n    s_upgradeDAO.create(entity);\n\n    return entity;\n  }","id":49881,"modified_method":"private UpgradeEntity createUpgrade(Direction direction, UpgradePack pack,\n                                      Map<String, Object> requestMap) throws AmbariException {\n\n    String clusterName = (String) requestMap.get(UPGRADE_CLUSTER_NAME);\n\n    if (null == clusterName) {\n      throw new AmbariException(String.format(\"%s is required\", UPGRADE_CLUSTER_NAME));\n    }\n\n    Cluster cluster = getManagementController().getClusters().getCluster(clusterName);\n    ConfigHelper configHelper = getManagementController().getConfigHelper();\n\n    // the version being upgraded or downgraded to (ie hdp-2.2.1.0-1234)\n    final String version = (String) requestMap.get(UPGRADE_VERSION);\n\n    MasterHostResolver resolver = direction.isUpgrade() ?\n        new MasterHostResolver(configHelper, cluster) : new MasterHostResolver(configHelper, cluster, version);\n\n    UpgradeContext ctx = new UpgradeContext(resolver, version, direction);\n\n    List<UpgradeGroupHolder> groups = s_upgradeHelper.createSequence(pack, ctx);\n\n    if (groups.isEmpty()) {\n      throw new AmbariException(\"There are no groupings available\");\n    }\n\n    List<UpgradeGroupEntity> groupEntities = new ArrayList<UpgradeGroupEntity>();\n    RequestStageContainer req = createRequest(direction, version);\n\n    for (UpgradeGroupHolder group : groups) {\n      UpgradeGroupEntity groupEntity = new UpgradeGroupEntity();\n      groupEntity.setName(group.name);\n      groupEntity.setTitle(group.title);\n      boolean skippable = group.skippable;\n      boolean allowRetry = group.allowRetry;\n\n      List<UpgradeItemEntity> itemEntities = new ArrayList<UpgradeItemEntity>();\n\n      for (StageWrapper wrapper : group.items) {\n        if (wrapper.getType() == StageWrapper.Type.SERVER_SIDE_ACTION) {\n          // !!! each stage is guaranteed to be of one type.  but because there\n          // is a bug that prevents one stage with multiple tasks assigned for the same host,\n          // break them out into individual stages.\n\n          for (TaskWrapper taskWrapper : wrapper.getTasks()) {\n            for (Task task : taskWrapper.getTasks()) {\n              UpgradeItemEntity itemEntity = new UpgradeItemEntity();\n              itemEntity.setText(wrapper.getText());\n              itemEntity.setTasks(wrapper.getTasksJson());\n              itemEntity.setHosts(wrapper.getHostsJson());\n              itemEntities.add(itemEntity);\n\n              injectVariables(configHelper, cluster, itemEntity);\n\n              makeServerSideStage(ctx, req, itemEntity, (ServerSideActionTask) task, skippable, allowRetry);\n            }\n          }\n        } else {\n          UpgradeItemEntity itemEntity = new UpgradeItemEntity();\n          itemEntity.setText(wrapper.getText());\n          itemEntity.setTasks(wrapper.getTasksJson());\n          itemEntity.setHosts(wrapper.getHostsJson());\n          itemEntities.add(itemEntity);\n\n          injectVariables(configHelper, cluster, itemEntity);\n\n          // upgrade items match a stage\n          createStage(ctx, req, itemEntity, wrapper, skippable, allowRetry);\n        }\n      }\n\n      groupEntity.setItems(itemEntities);\n\n      groupEntities.add(groupEntity);\n\n    }\n\n    UpgradeEntity entity = new UpgradeEntity();\n    entity.setFromVersion(cluster.getCurrentClusterVersion().getRepositoryVersion().getVersion());\n    entity.setToVersion(version);\n    entity.setUpgradeGroups(groupEntities);\n    entity.setClusterId(Long.valueOf(cluster.getClusterId()));\n    entity.setDirection(direction);\n\n    req.getRequestStatusResponse();\n\n    entity.setRequestId(req.getId());\n\n    req.persist();\n\n    s_upgradeDAO.create(entity);\n\n    return entity;\n  }","commit_id":"345290d808246ad09a95f835c181e51462fa0dcd","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Validates a singular API request.\n   *\n   * @param requestMap the map of properties\n   * @return the validated upgrade pack\n   * @throws AmbariException\n   */\n  private UpgradePack validateRequest(Direction direction, Map<String, Object> requestMap)\n      throws AmbariException {\n    String clusterName = (String) requestMap.get(UPGRADE_CLUSTER_NAME);\n    String version = (String) requestMap.get(UPGRADE_VERSION);\n    String versionForUpgradePack = (String) requestMap.get(UPGRADE_FROM_VERSION);\n\n\n    if (null == clusterName) {\n      throw new AmbariException(String.format(\"%s is required\", UPGRADE_CLUSTER_NAME));\n    }\n\n    if (null == version) {\n      throw new AmbariException(String.format(\"%s is required\", UPGRADE_VERSION));\n    }\n\n    Cluster cluster = getManagementController().getClusters().getCluster(clusterName);\n    StackId stack = cluster.getDesiredStackVersion();\n\n    String repoVersion = version;\n\n    if (direction == Direction.DOWNGRADE && null != versionForUpgradePack) {\n      repoVersion = versionForUpgradePack;\n    }\n\n    RepositoryVersionEntity versionEntity = s_repoVersionDAO.findByStackAndVersion(\n        stack.getStackId(), repoVersion);\n\n    if (null == versionEntity) {\n      throw new AmbariException(String.format(\"Version %s for stack %s was not found\",\n          repoVersion, stack.getStackVersion()));\n    }\n\n    Map<String, UpgradePack> packs = s_metaProvider.get().getUpgradePacks(\n        stack.getStackName(), stack.getStackVersion());\n\n    UpgradePack up = packs.get(versionEntity.getUpgradePackage());\n\n    if (null == up) {\n      throw new AmbariException(String.format(\n          \"Unable to perform %s.  Could not locate upgrade pack %s for version %s\",\n          direction.getText(false),\n          versionEntity.getUpgradePackage(),\n          repoVersion));\n    }\n\n    // !!! validate all hosts have the version installed\n\n    return up;\n  }","id":49882,"modified_method":"/**\n   * Validates a singular API request.\n   *\n   * @param requestMap the map of properties\n   * @return the validated upgrade pack\n   * @throws AmbariException\n   */\n  private UpgradePack validateRequest(Direction direction, Map<String, Object> requestMap)\n      throws AmbariException {\n    String clusterName = (String) requestMap.get(UPGRADE_CLUSTER_NAME);\n    String version = (String) requestMap.get(UPGRADE_VERSION);\n    String versionForUpgradePack = (String) requestMap.get(UPGRADE_FROM_VERSION);\n\n\n    if (null == clusterName) {\n      throw new AmbariException(String.format(\"%s is required\", UPGRADE_CLUSTER_NAME));\n    }\n\n    if (null == version) {\n      throw new AmbariException(String.format(\"%s is required\", UPGRADE_VERSION));\n    }\n\n    Cluster cluster = getManagementController().getClusters().getCluster(clusterName);\n    StackId stack = cluster.getDesiredStackVersion();\n\n    String repoVersion = version;\n\n    if (direction.isDowngrade() && null != versionForUpgradePack) {\n      repoVersion = versionForUpgradePack;\n    }\n\n    RepositoryVersionEntity versionEntity = s_repoVersionDAO.findByStackAndVersion(\n        stack.getStackId(), repoVersion);\n\n    if (null == versionEntity) {\n      throw new AmbariException(String.format(\"Version %s for stack %s was not found\",\n          repoVersion, stack.getStackVersion()));\n    }\n\n    Map<String, UpgradePack> packs = s_metaProvider.get().getUpgradePacks(\n        stack.getStackName(), stack.getStackVersion());\n\n    UpgradePack up = packs.get(versionEntity.getUpgradePackage());\n\n    if (null == up) {\n      throw new AmbariException(String.format(\n          \"Unable to perform %s.  Could not locate upgrade pack %s for version %s\",\n          direction.getText(false),\n          versionEntity.getUpgradePackage(),\n          repoVersion));\n    }\n\n    // !!! validate all hosts have the version installed\n\n    return up;\n  }","commit_id":"345290d808246ad09a95f835c181e51462fa0dcd","url":"https://github.com/apache/ambari"},{"original_method":"private static void checkAnnotationsJarAttached(@NotNull LocalInspectionToolSession session) {\n    PsiFile file = session.getFile();\n    Project project = file.getProject();\n    PsiClass event = JavaPsiFacade.getInstance(project).findClass(\"java.awt.event.InputEvent\", GlobalSearchScope.allScope(project));\n    PsiMethod[] methods = event == null ? null : event.findMethodsByName(\"getModifiers\", false);\n    PsiMethod getModifiers = methods == null || methods.length != 1 ? null : methods[0];\n    PsiAnnotation annotation = getModifiers == null ? null :\n      ExternalAnnotationsManager.getInstance(project).findExternalAnnotation(getModifiers, MagicConstant.class.getName());\n    if (annotation != null) return;\n    ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n    final Module module = fileIndex.getModuleForFile(file.getVirtualFile());\n    if (module == null) {\n      return;\n    }\n    if (!ApplicationManager.getApplication().isUnitTestMode()) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        @Override\n        public void run() {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              attachJdkAnnotations(module);\n            }\n          });\n        }\n      }, ModalityState.NON_MODAL, module.getDisposed());\n    }\n  }","id":49883,"modified_method":"private static void checkAnnotationsJarAttached(@NotNull LocalInspectionToolSession session) {\n    PsiFile file = session.getFile();\n    final Project project = file.getProject();\n    PsiClass event = JavaPsiFacade.getInstance(project).findClass(\"java.awt.event.InputEvent\", GlobalSearchScope.allScope(project));\n    if (event == null) return; // no jdk to attach\n    PsiMethod[] methods = event.findMethodsByName(\"getModifiers\", false);\n    if (methods.length != 1) return; // no jdk to attach\n    PsiMethod getModifiers = methods[0];\n    PsiAnnotation annotation = ExternalAnnotationsManager.getInstance(project).findExternalAnnotation(getModifiers, MagicConstant.class.getName());\n    if (annotation != null) return;\n    final VirtualFile virtualFile = PsiUtilCore.getVirtualFile(getModifiers);\n    if (virtualFile == null) return; // no jdk to attach\n    final List<OrderEntry> entries = ProjectRootManager.getInstance(project).getFileIndex().getOrderEntriesForFile(virtualFile);\n    Sdk jdk = null;\n    for (OrderEntry orderEntry : entries) {\n      if (orderEntry instanceof JdkOrderEntry) {\n        jdk = ((JdkOrderEntry)orderEntry).getJdk();\n        if (jdk != null) break;\n      }\n    }\n    if (jdk == null) return; // no jdk to attach\n\n    if (!ApplicationManager.getApplication().isUnitTestMode()) {\n      final Sdk finalJdk = jdk;\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        @Override\n        public void run() {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              attachJdkAnnotations(finalJdk);\n            }\n          });\n        }\n      }, ModalityState.NON_MODAL, project.getDisposed());\n    }\n  }","commit_id":"2628555b721996ce4785918b7b7d3a16875879f7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void attachJdkAnnotations(Module module) {\n    OrderEntry[] entries = ModuleRootManager.getInstance(module).getOrderEntries();\n    Sdk jdk = null;\n    for (OrderEntry orderEntry : entries) {\n      if (orderEntry instanceof JdkOrderEntry) {\n        jdk = ((JdkOrderEntry)orderEntry).getJdk();\n      }\n    }\n    LOG.assertTrue(jdk != null, \"JDK not configured for module \"+module);\n    LocalFileSystem lfs = LocalFileSystem.getInstance();\n    VirtualFile root = null;\n    if (root == null) { // community idea under idea\n      root = lfs.findFileByPath(FileUtil.toSystemIndependentName(PathManager.getHomePath()) + \"/java/jdkAnnotations\");\n    }\n    if (root == null) {  // idea under idea\n      root = lfs.findFileByPath(FileUtil.toSystemIndependentName(PathManager.getHomePath()) + \"/community/java/jdkAnnotations\");\n    }\n    if (root == null) { // build\n      root = VirtualFileManager.getInstance().findFileByUrl(\"jar://\"+ FileUtil.toSystemIndependentName(PathManager.getHomePath()) + \"/lib/jdkAnnotations.jar!/\");\n    }\n    if (root == null) {\n      LOG.error(\"jdk annotations not found in: \"+ FileUtil.toSystemIndependentName(PathManager.getHomePath()) + \"/lib/jdkAnnotations.jar!/\");\n      return;\n    }\n\n    SdkModificator modificator = jdk.getSdkModificator();\n    modificator.addRoot(root, AnnotationOrderRootType.getInstance());\n    modificator.commitChanges();\n  }","id":49884,"modified_method":"private static void attachJdkAnnotations(Sdk jdk) {\n    LocalFileSystem lfs = LocalFileSystem.getInstance();\n    VirtualFile root = null;\n    if (root == null) { // community idea under idea\n      root = lfs.findFileByPath(FileUtil.toSystemIndependentName(PathManager.getHomePath()) + \"/java/jdkAnnotations\");\n    }\n    if (root == null) {  // idea under idea\n      root = lfs.findFileByPath(FileUtil.toSystemIndependentName(PathManager.getHomePath()) + \"/community/java/jdkAnnotations\");\n    }\n    if (root == null) { // build\n      root = VirtualFileManager.getInstance().findFileByUrl(\"jar://\"+ FileUtil.toSystemIndependentName(PathManager.getHomePath()) + \"/lib/jdkAnnotations.jar!/\");\n    }\n    if (root == null) {\n      LOG.error(\"jdk annotations not found in: \"+ FileUtil.toSystemIndependentName(PathManager.getHomePath()) + \"/lib/jdkAnnotations.jar!/\");\n      return;\n    }\n\n    SdkModificator modificator = jdk.getSdkModificator();\n    modificator.removeRoot(root, AnnotationOrderRootType.getInstance());\n    modificator.addRoot(root, AnnotationOrderRootType.getInstance());\n    modificator.commitChanges();\n  }","commit_id":"2628555b721996ce4785918b7b7d3a16875879f7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doInsert(String fqn,\n                               PsiNamedElement elementToInsert,\n                               final Editor editor,\n                               final Project project) throws IncorrectOperationException {\n    final PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);\n    Document document = editor.getDocument();\n\n    final PsiFile file = documentManager.getPsiFile(document);\n\n    final int offset = editor.getCaretModel().getOffset();\n    PsiElement elementAtCaret = file.findElementAt(offset);\n    if (elementAtCaret == null) return;\n\n    fqn = fqn.replace('#', '.');\n    String toInsert;\n    String suffix = \"\";\n    if (elementToInsert instanceof PsiMethod && PsiTreeUtil.getParentOfType(elementAtCaret, PsiDocComment.class) != null) {\n      // fqn#methodName(ParamType)\n      PsiMethod method = (PsiMethod)elementToInsert;\n      PsiClass aClass = method.getContainingClass();\n      String className = aClass == null ? \"\" : aClass.getQualifiedName();\n      toInsert = className == null ? \"\" : className;\n      if (toInsert.length() != 0) toInsert += \"#\";\n      toInsert += method.getName() + \"(\";\n      PsiParameter[] parameters = method.getParameterList().getParameters();\n      for (int i = 0; i < parameters.length; i++) {\n        PsiParameter parameter = parameters[i];\n        if (i != 0) toInsert += \", \";\n        toInsert += parameter.getType().getCanonicalText();\n      }\n      toInsert += \")\";\n    }\n    else if (elementToInsert == null ||\n             PsiTreeUtil.getNonStrictParentOfType(elementAtCaret, PsiLiteralExpression.class, PsiComment.class) != null ||\n             PsiTreeUtil.getNonStrictParentOfType(elementAtCaret, PsiJavaFile.class) == null) {\n      toInsert = fqn;\n    }\n    else {\n      toInsert = elementToInsert.getName();\n      if (elementToInsert instanceof PsiMethod) {\n        suffix = \"()\";\n      }\n      final PsiElementFactory factory = PsiManager.getInstance(project).getElementFactory();\n      final PsiExpression expression = factory.createExpressionFromText(toInsert + suffix, elementAtCaret);\n      final PsiReferenceExpression referenceExpression = expression instanceof PsiMethodCallExpression\n                                                         ? ((PsiMethodCallExpression)expression).getMethodExpression()\n                                                         : expression instanceof PsiReferenceExpression\n                                                           ? (PsiReferenceExpression)expression\n                                                           : null;\n      if (referenceExpression == null || referenceExpression.advancedResolve(true).getElement() != elementToInsert) {\n        toInsert = fqn;\n      }\n    }\n    if (toInsert == null) toInsert = \"\";\n\n    document.insertString(offset, toInsert+suffix);\n    documentManager.commitDocument(document);\n    int endOffset = offset + toInsert.length() + suffix.length();\n    RangeMarker rangeMarker = document.createRangeMarker(endOffset, endOffset);\n    elementAtCaret = file.findElementAt(offset);\n\n    if (elementAtCaret != null) {\n      shortenReference(elementAtCaret);\n    }\n    CodeInsightUtil.forcePsiPostprocessAndRestoreElement(file);\n    CodeStyleManager.getInstance(project).adjustLineIndent(file, offset);\n\n    int caretOffset = rangeMarker.getEndOffset();\n    if (elementToInsert instanceof PsiMethod && StringUtil.endsWithChar(toInsert+suffix,')')) {\n      caretOffset --;\n    }\n    editor.getCaretModel().moveToOffset(caretOffset);\n  }","id":49885,"modified_method":"private static void doInsert(String fqn,\n                               PsiNamedElement elementToInsert,\n                               final Editor editor,\n                               final Project project) throws IncorrectOperationException {\n    final PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);\n    Document document = editor.getDocument();\n\n    final PsiFile file = documentManager.getPsiFile(document);\n\n    final int offset = editor.getCaretModel().getOffset();\n    PsiElement elementAtCaret = file.findElementAt(offset);\n    if (elementAtCaret == null) return;\n\n    fqn = fqn.replace('#', '.');\n    String toInsert;\n    String suffix = \"\";\n    if (elementToInsert instanceof PsiMethod && PsiTreeUtil.getParentOfType(elementAtCaret, PsiDocComment.class) != null) {\n      // fqn#methodName(ParamType)\n      PsiMethod method = (PsiMethod)elementToInsert;\n      PsiClass aClass = method.getContainingClass();\n      String className = aClass == null ? \"\" : aClass.getQualifiedName();\n      toInsert = className == null ? \"\" : className;\n      if (toInsert.length() != 0) toInsert += \"#\";\n      toInsert += method.getName() + \"(\";\n      PsiParameter[] parameters = method.getParameterList().getParameters();\n      for (int i = 0; i < parameters.length; i++) {\n        PsiParameter parameter = parameters[i];\n        if (i != 0) toInsert += \", \";\n        toInsert += parameter.getType().getCanonicalText();\n      }\n      toInsert += \")\";\n    }\n    else if (elementToInsert == null ||\n             PsiTreeUtil.getNonStrictParentOfType(elementAtCaret, PsiLiteralExpression.class, PsiComment.class) != null ||\n             PsiTreeUtil.getNonStrictParentOfType(elementAtCaret, PsiJavaFile.class) == null) {\n      toInsert = fqn;\n    }\n    else {\n      toInsert = elementToInsert.getName();\n      if (elementToInsert instanceof PsiMethod) {\n        suffix = \"()\";\n      }\n      final PsiElementFactory factory = PsiManager.getInstance(project).getElementFactory();\n      final PsiExpression expression = factory.createExpressionFromText(toInsert + suffix, elementAtCaret);\n      final PsiReferenceExpression referenceExpression = expression instanceof PsiMethodCallExpression\n                                                         ? ((PsiMethodCallExpression)expression).getMethodExpression()\n                                                         : expression instanceof PsiReferenceExpression\n                                                           ? (PsiReferenceExpression)expression\n                                                           : null;\n      if (referenceExpression == null || referenceExpression.advancedResolve(true).getElement() != elementToInsert) {\n        toInsert = fqn;\n      }\n    }\n    if (toInsert == null) toInsert = \"\";\n\n    document.insertString(offset, toInsert+suffix);\n    documentManager.commitDocument(document);\n    int endOffset = offset + toInsert.length() + suffix.length();\n    RangeMarker rangeMarker = document.createRangeMarker(endOffset, endOffset);\n    elementAtCaret = file.findElementAt(offset);\n\n    if (elementAtCaret != null && elementAtCaret.isValid()) {\n      shortenReference(elementAtCaret);\n    }\n    CodeInsightUtil.forcePsiPostprocessAndRestoreElement(file);\n    CodeStyleManager.getInstance(project).adjustLineIndent(file, offset);\n\n    int caretOffset = rangeMarker.getEndOffset();\n    if (elementToInsert instanceof PsiMethod && StringUtil.endsWithChar(toInsert+suffix,')')) {\n      caretOffset --;\n    }\n    editor.getCaretModel().moveToOffset(caretOffset);\n  }","commit_id":"08feed8603b0389d6e3157c25b1eaf672d56c7f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static String elementToFqn(final PsiElement element) {\n    final String fqn;\n    if (element instanceof PsiClass) {\n      fqn = ((PsiClass)element).getQualifiedName();\n    }\n    else if (element instanceof PsiMember) {\n      final PsiMember member = (PsiMember)element;\n      fqn = member.getContainingClass().getQualifiedName() + \"#\" + member.getName();\n    }\n    else if (element instanceof PsiFile) {\n      final PsiFile file = (PsiFile)element;\n      fqn = FileUtil.toSystemIndependentName(getFileFqn(file));\n    }\n    else {\n      fqn = element.getClass().getName();\n    }\n    return fqn;\n  }","id":49886,"modified_method":"@Nullable\n  private static String elementToFqn(final PsiElement element) {\n    final String fqn;\n    if (element instanceof PsiClass) {\n      fqn = ((PsiClass)element).getQualifiedName();\n    }\n    else if (element instanceof PsiMember) {\n      final PsiMember member = (PsiMember)element;\n      fqn = member.getContainingClass().getQualifiedName() + \"#\" + member.getName();\n    }\n    else if (element instanceof PsiFile) {\n      final PsiFile file = (PsiFile)element;\n      fqn = FileUtil.toSystemIndependentName(getFileFqn(file));\n    }\n    else {\n      fqn = element.getClass().getName();\n    }\n    return fqn;\n  }","commit_id":"08feed8603b0389d6e3157c25b1eaf672d56c7f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiNamedElement fqnToElement(final Project project, final String fqn) {\n    PsiClass aClass = PsiManager.getInstance(project).findClass(fqn, GlobalSearchScope.allScope(project));\n    if (aClass != null) {\n      return aClass;\n    }\n    final int endIndex = fqn.indexOf('#');\n    if (endIndex == -1) return null;\n    String className = fqn.substring(0, endIndex);\n    if (className == null) return null;\n    aClass = PsiManager.getInstance(project).findClass(className, GlobalSearchScope.allScope(project));\n    if (aClass == null) return null;\n    String memberName = fqn.substring(endIndex + 1);\n    PsiNamedElement element = aClass.findFieldByName(memberName, false);\n    if (element != null) {\n      return element;\n    }\n    element = aClass.findMethodsByName(memberName, false)[0];\n    return element;\n  }","id":49887,"modified_method":"@Nullable\n  private static PsiNamedElement fqnToElement(final Project project, final String fqn) {\n    PsiClass aClass = PsiManager.getInstance(project).findClass(fqn, GlobalSearchScope.allScope(project));\n    if (aClass != null) {\n      return aClass;\n    }\n    final int endIndex = fqn.indexOf('#');\n    if (endIndex == -1) return null;\n    String className = fqn.substring(0, endIndex);\n    if (className == null) return null;\n    aClass = PsiManager.getInstance(project).findClass(className, GlobalSearchScope.allScope(project));\n    if (aClass == null) return null;\n    String memberName = fqn.substring(endIndex + 1);\n    PsiNamedElement element = aClass.findFieldByName(memberName, false);\n    if (element != null) {\n      return element;\n    }\n    PsiMethod[] methods = aClass.findMethodsByName(memberName, false);\n    if (methods.length == 0) return null;\n    element = methods[0];\n    return element;\n  }","commit_id":"08feed8603b0389d6e3157c25b1eaf672d56c7f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiMethod ensureNonAmbiguousMethod(PsiParameter[] parameters, @NotNull PsiMethod psiMethod) {\n    String methodName = psiMethod.getName();\n    PsiClass containingClass = psiMethod.getContainingClass();\n    if (containingClass == null) return null;\n    for (PsiMethod method : containingClass.findMethodsByName(methodName, false)) {\n      PsiParameter[] candidateParams = method.getParameterList().getParameters();\n      if (candidateParams.length == 1) {\n        if (TypeConversionUtil.areTypesConvertible(candidateParams[0].getType(), parameters[0].getType())) {\n          final PsiMethod[] deepestSuperMethods = psiMethod.findDeepestSuperMethods();\n          if (deepestSuperMethods.length > 0) {\n            for (PsiMethod superMethod : deepestSuperMethods) {\n              PsiMethod validSuperMethod = ensureNonAmbiguousMethod(parameters, superMethod);\n              if (validSuperMethod != null) return validSuperMethod;\n            }\n            return null;\n          }\n        }\n      }\n    }\n    return psiMethod;\n  }","id":49888,"modified_method":"@Nullable\n  private static PsiMethod ensureNonAmbiguousMethod(PsiParameter[] parameters, @NotNull PsiMethod psiMethod) {\n    String methodName = psiMethod.getName();\n    PsiClass containingClass = psiMethod.getContainingClass();\n    if (containingClass == null) return null;\n    final PsiMethod[] psiMethods = containingClass.findMethodsByName(methodName, false);\n    if (psiMethods.length == 1) return psiMethod;\n    for (PsiMethod method : psiMethods) {\n      PsiParameter[] candidateParams = method.getParameterList().getParameters();\n      if (candidateParams.length == parameters.length) {\n        if (TypeConversionUtil.areTypesConvertible(candidateParams[0].getType(), parameters[0].getType())) {\n          final PsiMethod[] deepestSuperMethods = psiMethod.findDeepestSuperMethods();\n          if (deepestSuperMethods.length > 0) {\n            for (PsiMethod superMethod : deepestSuperMethods) {\n              PsiMethod validSuperMethod = ensureNonAmbiguousMethod(parameters, superMethod);\n              if (validSuperMethod != null) return validSuperMethod;\n            }\n          }\n        }\n        return null;\n      }\n    }\n    return psiMethod;\n  }","commit_id":"3e13cddf2b7c939b538759baca1ec860fed59ab8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JCExpression convert(Tree.BaseMemberExpression member) {\n        Declaration decl = member.getDeclaration();\n        if(decl instanceof Value){\n            Scope container = decl.getContainer();\n            if(container instanceof Package){\n                // it's a toplevel attribute\n                java.util.List<String> path = new LinkedList<String>();\n                path.addAll(container.getQualifiedName());\n                path.add(\"_\"+decl.getName());\n                path.add(\"value\");\n                return makeIdent(path);\n            }\n        }\n        return at(member).Ident(names().fromString(member.getIdentifier().getText()));\n    }","id":49889,"modified_method":"private JCExpression convert(Tree.BaseMemberExpression member) {\n        Declaration decl = member.getDeclaration();\n        if(decl instanceof Value){\n            Scope container = decl.getContainer();\n            if(container instanceof Package){\n                // it's a toplevel attribute\n                java.util.List<String> path = new LinkedList<String>();\n                path.addAll(container.getQualifiedName());\n                path.add(\"$\"+decl.getName());\n                path.add(Util.getGetterName(decl.getName()));\n                return at(member).Apply(List.<JCExpression>nil(), makeIdent(path), List.<JCExpression>nil());\n            }\n        }\n        return make().Ident(names().fromString(member.getIdentifier().getText()));\n    }","commit_id":"67a06cd0a98135988fe02be2f01144c857d56f85","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n        public JCExpression makeResultExpr() {\n            Value decl = this.cond.getVariable().getDeclarationModel();\n            return expressionGen().applyErasureAndBoxing(testVar.makeIdent(), \n                    toType, true, \n                    CodegenUtil.getBoxingStrategy(decl), \n                    decl.getType());\n        }","id":49890,"modified_method":"@Override\n        public JCExpression makeResultExpr() {\n            Value decl = this.cond.getVariable().getDeclarationModel();\n            return expressionGen().applyErasureAndBoxing(testVar.makeIdent(),\n                    typeFact().getDefiniteType(this.specifierExpr.getTypeModel()), true,\n                    CodegenUtil.getBoxingStrategy(decl),\n                    decl.getType());\n        }","commit_id":"c80f447b77db1fe90959189f1245d81927f49075","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n        public JCExpression makeResultExpr() {\n            return make().TypeCast(makeTypeExpr(), testVar.makeIdent());\n        }","id":49891,"modified_method":"@Override\n        public JCExpression makeResultExpr() {\n            Value decl = this.cond.getVariable().getDeclarationModel();\n            return expressionGen().applyErasureAndBoxing(testVar.makeIdent(),\n                    typeFact().getDefiniteType(this.specifierExpr.getTypeModel()), true,\n                    BoxingStrategy.BOXED,\n                    decl.getType());\n        }","commit_id":"c80f447b77db1fe90959189f1245d81927f49075","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"void run(String comment,\n           boolean consumeTree,\n           boolean generateCode,\n           String filename)\n    throws Exception\n  {\n    ANTLRInputStream input\n      = new ANTLRInputStream(is);\n\n    CeylonLexer lexer = new CeylonLexer(input);\n\n    CommonTokenStream tokens = new CommonTokenStream(lexer);\n\n    CeylonParser parser = new CeylonParser(tokens);\n    CeylonParser.compilationUnit_return r = parser.compilationUnit();\n\n    CommonTree t = (CommonTree)r.getTree();\n\n    if (comment != null)\n      out.println(\"# \"+ comment);\n\n    new TreeVisitor().visit(t, new PrintTree());\n    out.println();\n\n    if (consumeTree) {\n      CeylonTree.CompilationUnit cu = CeylonTree.build(t, filename);\n\n      PrintWriter w = new PrintWriter(out);\n      cu.accept(new CeylonTreePrinter(w));\n      w.flush();\n      out.println();\n\n      cu.accept(new Grok());\n      out.print(cu);\n      out.println();\n\n      if (generateCode) {\n          out.println();\n          cu.accept(new EmptyWalker());\n          new Gen().run(cu);\n      }\n    }\n  }","id":49892,"modified_method":"void run(String comment,\n           boolean consumeTree,\n           boolean generateCode,\n           String filename)\n    throws Exception\n  {\n    ANTLRInputStream input\n      = new ANTLRInputStream(is);\n\n    CeylonLexer lexer = new CeylonLexer(input);\n\n    CommonTokenStream tokens = new CommonTokenStream(lexer);\n\n    CeylonParser parser = new CeylonParser(tokens);\n    CeylonParser.compilationUnit_return r = parser.compilationUnit();\n\n    CommonTree t = (CommonTree)r.getTree();\n\n    if (comment != null)\n      out.println(\"# \"+ comment);\n\n    new TreeVisitor().visit(t, new PrintTree());\n    out.println();\n\n    if (parser.getNumberOfSyntaxErrors() == 0 &&\n            lexer.getNumberOfSyntaxErrors() == 0 &&\n            consumeTree) {\n      CeylonTree.CompilationUnit cu = CeylonTree.build(t, filename);\n\n      PrintWriter w = new PrintWriter(out);\n      cu.accept(new CeylonTreePrinter(w));\n      w.flush();\n      out.println();\n\n      cu.accept(new Grok());\n      out.print(cu);\n      out.println();\n\n      if (generateCode) {\n          out.println();\n          new Gen().run(cu);\n      }\n    }\n  }","commit_id":"71032f9627c120d8c423c01733ca9a9b7466f439","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"JCExpression convert(CeylonTree.CallExpression ce) {\n        final Singleton<JCExpression> expr =\n            new Singleton<JCExpression>();\n        final ListBuffer<JCExpression> args =\n            new ListBuffer<JCExpression>();\n        \n        ce.getMethod().accept (new CeylonTree.Visitor () {\n            public void visit(CeylonTree.OperatorDot access) {\n                expr.append(convert(access));\n            }});\n        \n        for (CeylonTree arg: ce.args())\n            args.append(convertArg(arg));\n          \n        return make.Apply(null, expr.thing(), args.toList());\n    }","id":49893,"modified_method":"JCExpression convert(CeylonTree.CallExpression ce) {\n        final Singleton<JCExpression> expr =\n            new Singleton<JCExpression>();\n        final ListBuffer<JCExpression> args =\n            new ListBuffer<JCExpression>();\n        \n        ce.getMethod().accept (new CeylonTree.Visitor () {\n            public void visit(CeylonTree.OperatorDot access) {\n                expr.append(convert(access));\n            }});\n        \n        for (CeylonTree arg: ce.args())\n            args.append(convertArg(arg));\n          \n        JCExpression call = make.Apply(null, expr.thing(), args.toList());\n        call.setPos(Position.encodePosition(ce.source.line, ce.source.column));\n        return call;\n    }","commit_id":"71032f9627c120d8c423c01733ca9a9b7466f439","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCCompilationUnit convert(CeylonTree.CompilationUnit t) {\n        final ListBuffer<JCTree> defs = new ListBuffer<JCTree>();\n        \n        defs.append(make.Import(makeIdent(Arrays.asList(\"ceylon\", \"*\")), false));\n                \n        t.visitChildren(new CeylonTree.Visitor () {\n            public void visit(CeylonTree.ClassDeclaration decl) {\n                defs.append(convert(decl));\n            }\n            public void visit(CeylonTree.MethodDeclaration decl) {\n                // This is a top-level method.  Generate a class with the\n                // name of the method and a corresponding run() method.\n                \n                final ListBuffer<JCVariableDecl> params = \n                    new ListBuffer<JCVariableDecl>();\n                final ListBuffer<JCStatement> annotations = \n                    new ListBuffer<JCStatement>();\n                final Singleton<JCBlock> body = \n                    new Singleton<JCBlock>();\n                Singleton<JCExpression> restype =\n                    new Singleton<JCExpression>();\n                \n                processMethodDeclaration(decl, params, body, restype, (ListBuffer<JCTypeParameter>)null,\n                        annotations);\n                \n                JCMethodDecl meth = make.MethodDef(make.Modifiers(PUBLIC|STATIC),\n                        names.fromString(\"run\"),\n                        make.TypeIdent(VOID),\n                        List.<JCTypeParameter>nil(),\n                        params.toList(),\n                        List.<JCExpression>nil(), body.thing(), null);\n                \n                List<JCTree> innerDefs = List.<JCTree>of(meth);\n                \n                // FIXME: This is wrong because the annotation registration is done\n                // within the scope of the class, but the annotations are lexically\n                // outside it.\n                if (annotations.length() > 0) {\n                    innerDefs = innerDefs.append(registerAnnotations(annotations.toList()));\n                }\n                \n                JCClassDecl classDef = \n                    make.ClassDef(make.Modifiers(PUBLIC, List.<JCAnnotation>nil()),\n                            names.fromString(decl.nameAsString()),\n                            List.<JCTypeParameter>nil(), null,\n                            List.<JCExpression>nil(),\n                            innerDefs);\n                \n                defs.append(classDef);\n            }\n        });\n\n        JCCompilationUnit topLev =\n            make.TopLevel(List.<JCTree.JCAnnotation>nil(),\n                    /* package id*/ null, defs.toList());\n\n        System.out.println(topLev);\n        return topLev;\n    }","id":49894,"modified_method":"public JCCompilationUnit convert(CeylonTree.CompilationUnit t) {\n        final ListBuffer<JCTree> defs = new ListBuffer<JCTree>();\n        \n        defs.append(make.Import(makeIdent(Arrays.asList(\"ceylon\", \"*\")), false));\n                \n        t.visitChildren(new CeylonTree.Visitor () {\n            public void visit(CeylonTree.ClassDeclaration decl) {\n                defs.append(convert(decl));\n            }\n            public void visit(CeylonTree.MethodDeclaration decl) {\n                // This is a top-level method.  Generate a class with the\n                // name of the method and a corresponding run() method.\n                \n                final ListBuffer<JCVariableDecl> params = \n                    new ListBuffer<JCVariableDecl>();\n                final ListBuffer<JCStatement> annotations = \n                    new ListBuffer<JCStatement>();\n                final Singleton<JCBlock> body = \n                    new Singleton<JCBlock>();\n                Singleton<JCExpression> restype =\n                    new Singleton<JCExpression>();\n                \n                processMethodDeclaration(decl, params, body, restype, (ListBuffer<JCTypeParameter>)null,\n                        annotations);\n                \n                JCMethodDecl meth = make.MethodDef(make.Modifiers(PUBLIC|STATIC),\n                        names.fromString(\"run\"),\n                        make.TypeIdent(VOID),\n                        List.<JCTypeParameter>nil(),\n                        params.toList(),\n                        List.<JCExpression>nil(), body.thing(), null);\n                \n                meth.setPos(Position.encodePosition(decl.source.line, decl.source.column));\n                \n                List<JCTree> innerDefs = List.<JCTree>of(meth);\n                \n                // FIXME: This is wrong because the annotation registration is done\n                // within the scope of the class, but the annotations are lexically\n                // outside it.\n                if (annotations.length() > 0) {\n                    innerDefs = innerDefs.append(registerAnnotations(annotations.toList()));\n                }\n                \n                JCClassDecl classDef = \n                    make.ClassDef(make.Modifiers(PUBLIC, List.<JCAnnotation>nil()),\n                            names.fromString(decl.nameAsString()),\n                            List.<JCTypeParameter>nil(), null,\n                            List.<JCExpression>nil(),\n                            innerDefs);\n                \n                defs.append(classDef);\n            }\n        });\n\n        JCCompilationUnit topLev =\n            make.TopLevel(List.<JCTree.JCAnnotation>nil(),\n                    /* package id*/ null, defs.toList());\n\n        System.out.println(topLev);\n        return topLev;\n    }","commit_id":"71032f9627c120d8c423c01733ca9a9b7466f439","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"JCExpression convert(CeylonTree.ReflectedLiteral value) {\n        ListVisitor<String> v = new ListVisitor<String>() {\n            public void visit(CeylonTree.Type type) {\n                TypeName name = type.name();\n                for (String component: name.components) {\n                    result = result.append(component);\n                }\n            }\n            public void visit(CeylonTree.MemberName name) {\n                result = result.append(name.name);\n            }\n        };\n        \n        for (CeylonTree op: value.operands())\n            op.accept(v);\n        \n        if (Character.isUpperCase(v.result.last().charAt(0))) {\n            // This looks like something of a kludge, but I think\n            // it's a legitimate way to determine if this is the\n            // name of a class.\n            v.result = v.result.append(\"class\");\n        }\n        \n        // FIXME: method literals are going to need some special\n        // processing.  At present you'll just get a compile-time\n        // error.\n        \n        return makeIdent(v.result);\n    }","id":49895,"modified_method":"JCExpression convert(CeylonTree.ReflectedLiteral value) {\n        \n        ListVisitor<String> v = new ListVisitor<String>() {\n            public void visit(CeylonTree.Type type) {\n                TypeName name = type.name();\n                for (String component: name.components) {\n                    result = result.append(component);\n                }\n            }\n            public void visit(CeylonTree.MemberName name) {\n                result = result.append(name.name);\n            }\n        };\n        \n        for (CeylonTree op: value.operands())\n            op.accept(v);\n\n        JCExpression result;\n\n        if (Character.isUpperCase(v.result.last().charAt(0))) {\n            // This looks like something of a kludge, but I think\n            // it's a legitimate way to determine if this is the\n            // name of a class.\n\n            v.result = v.result.append(\"class\");\n            result = makeIdent(v.result);\n       } else {\n           // In the case of method literals, we're going to do this lazily.\n           // To do otherwise would be very expensive\n           \n            result = make.Apply (null, makeSelect(\"ceylon\", \"Method\", \"instance\"),\n                    List.<JCExpression>of(\n                            make.Literal(toFlatName(v.result))));\n        }\n\n        result.setPos(Position.encodePosition(value.source.line, value.source.column));\n        return result;\n    }","commit_id":"71032f9627c120d8c423c01733ca9a9b7466f439","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public SourceLocation(Tree src, String path) {\n        this.path = path;\n        this.line = src.getLine();\n        this.column = src.getCharPositionInLine();\n    }","id":49896,"modified_method":"public SourceLocation(Tree src, String path) {\n        this.path = path;\n        this.line = src.getLine();\n        this.column = src.getCharPositionInLine() + 1;\n    }","commit_id":"71032f9627c120d8c423c01733ca9a9b7466f439","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n   * Somitimes we wonder, why the hell this jar is in dependency classpath?\n   * Here is the answer.\n   * This procedure find all dependencies of rootModule that contain given path in classpath and return path in dependency graph to them.\n   * \n   * @param rootModule module from which to start\n   * @param path path to find\n   * @param g dependency graph\n   * @return list of paths in the graph to modules that contain path in classpath\n   */\n  public static Iterable<List<IModule>> findAllDependenciesContainigPatternInClasspath(final IModule rootModule, String path, final ModuleGraph g) {\n    Set<IModule> modules = SetSequence.fromSet(new LinkedHashSet<IModule>());\n    for (ModuleGraph.ModuleVertex vertex : SetSequence.fromSet(g.getData())) {\n      ClasspathStringCollector collector = new ClasspathStringCollector(false);\n      vertex.getModule().getClassPathItem().accept(collector);\n      for (String cp : SetSequence.fromSet(collector.getClasspath())) {\n        if (cp.contains(path)) {\n          SetSequence.fromSet(modules).addElement(vertex.getModule());\n          break;\n        }\n      }\n    }\n    return SetSequence.fromSet(modules).select(new ISelector<IModule, List<IModule>>() {\n      public List<IModule> select(IModule it) {\n        return g.findPath(rootModule, it);\n      }\n    });\n  }","id":49897,"modified_method":"/**\n   * Somitimes we wonder, why the hell this jar is in dependency classpath?\n   * Here is the answer.\n   * This procedure find all dependencies of rootModule that contain given path in classpath and return path in dependency graph to them.\n   * \n   * @param rootModule module from which to start\n   * @param path path to find\n   * @param g dependency graph\n   * @return list of paths in the graph to modules that contain path in classpath\n   */\n  public static Iterable<List<IModule>> findAllDependenciesContainigPatternInClasspath(final IModule rootModule, String path, final ModuleGraph g) {\n    Set<IModule> modules = SetSequence.fromSet(new LinkedHashSet<IModule>());\n    for (ModuleGraph.ModuleVertex vertex : SetSequence.fromSet(g.getData())) {\n      for (String cp : CollectionSequence.fromCollection(vertex.getModule().getFacet(JavaModuleFacet.class).getClassPath())) {\n        if (cp.contains(path)) {\n          SetSequence.fromSet(modules).addElement(vertex.getModule());\n          break;\n        }\n      }\n    }\n    return SetSequence.fromSet(modules).select(new ISelector<IModule, List<IModule>>() {\n      public List<IModule> select(IModule it) {\n        return g.findPath(rootModule, it);\n      }\n    });\n  }","commit_id":"5c73ae1a7da78c2e7bb6836af39456de2860ebee","url":"https://github.com/JetBrains/MPS"},{"original_method":"@BaseDialog.Button(position = 0, name = \"Find\", mnemonic = 'F', defaultButton = true)\n  public void buttonFind() {\n    final Wrappers._T<Language> language = new Wrappers._T<Language>();\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        language.value = SModelUtil.getDeclaringLanguage(SNodeOperations.getConceptDeclaration(FindInstancesDialog.this.myNode));\n      }\n    });\n    // <node> \n    myEditor.make(Collections.singleton(language.value.getClassPathItem()));\n  }","id":49898,"modified_method":"@BaseDialog.Button(position = 0, name = \"Find\", mnemonic = 'F', defaultButton = true)\n  public void buttonFind() {\n    final Wrappers._T<Language> language = new Wrappers._T<Language>();\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        language.value = SModelUtil.getDeclaringLanguage(SNodeOperations.getConceptDeclaration(FindInstancesDialog.this.myNode));\n      }\n    });\n    // <node> \n    myEditor.make(Collections.<IClassPathItem>singleton(JavaModuleOperations.createClassPathItem(language.value.getFacet(JavaModuleFacet.class).getClassPath(), FindInstancesDialog.class.getName())));\n  }","commit_id":"5c73ae1a7da78c2e7bb6836af39456de2860ebee","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static ClassLoader getTestClassLoaderForModule(IModule module) {\n      List<String> paths = ListSequence.fromList(new ArrayList<String>());\n      // <node> \n      ListSequence.fromList(paths).addSequence(ListSequence.fromList(getClasspathForModule(module)));\n\n      URL[] urls = ListSequence.fromList(paths).select(new ISelector<String, URL>() {\n        public URL select(String it) {\n          try {\n            return new File(it).toURL();\n          } catch (MalformedURLException e) {\n            // todo: ? \n            return null;\n          }\n        }\n      }).toGenericArray(URL.class);\n\n      return new URLClassLoader(urls);\n    }","id":49899,"modified_method":"private static ClassLoader getTestClassLoaderForModule(SModule module) {\n      List<String> paths = ListSequence.fromList(new ArrayList<String>());\n      ListSequence.fromList(paths).addSequence(SetSequence.fromSet(JavaModuleOperations.collectExecuteClasspath(module)));\n      ListSequence.fromList(paths).removeSequence(CollectionSequence.fromCollection(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"6354ebe7-c22a-4a0f-ac54-50b52ab9b065\")).getFacet(JavaModuleFacet.class).getClassPath()));\n      URL[] urls = ListSequence.fromList(paths).select(new ISelector<String, URL>() {\n        public URL select(String it) {\n          try {\n            return new File(it).toURL();\n          } catch (MalformedURLException e) {\n            // todo: ? \n            return null;\n          }\n        }\n      }).toGenericArray(URL.class);\n\n      return new URLClassLoader(urls);\n    }","commit_id":"5c73ae1a7da78c2e7bb6836af39456de2860ebee","url":"https://github.com/JetBrains/MPS"},{"original_method":"@BaseDialog.Button(position = 0, name = \"Modify\", mnemonic = 'M', defaultButton = true)\n  public void buttonReplace() {\n    final Wrappers._T<Language> language = new Wrappers._T<Language>();\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        language.value = SModelUtil.getDeclaringLanguage(SNodeOperations.getConceptDeclaration(ReplaceDialog.this.myNode));\n      }\n    });\n    // <node> \n    myEditor.make(Collections.singleton(language.value.getClassPathItem()));\n  }","id":49900,"modified_method":"@BaseDialog.Button(position = 0, name = \"Modify\", mnemonic = 'M', defaultButton = true)\n  public void buttonReplace() {\n    final Wrappers._T<Language> language = new Wrappers._T<Language>();\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        language.value = SModelUtil.getDeclaringLanguage(SNodeOperations.getConceptDeclaration(ReplaceDialog.this.myNode));\n      }\n    });\n    // <node> \n    myEditor.make(Collections.<IClassPathItem>singleton(JavaModuleOperations.createClassPathItem(language.value.getFacet(JavaModuleFacet.class).getClassPath(), FindInstancesDialog.class.getName())));\n  }","commit_id":"5c73ae1a7da78c2e7bb6836af39456de2860ebee","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Deprecated\n  public TestRunParameters() {\n    myTestRunner = \"jetbrains.mps.baseLanguage.unitTest.execution.server.TestRunner\";\n    myVmParameters = ListSequence.fromList(new ArrayList<String>());\n    ClasspathStringCollector collector = new ClasspathStringCollector();\n    MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"f618e99a-2641-465c-bb54-31fe76f9e285\")).getClassPathItem().accept(collector);\n    myClassPath = ListSequence.fromList(new ArrayList<String>());\n    ListSequence.fromList(myClassPath).addSequence(SetSequence.fromSet(collector.getClasspath()));\n  }","id":49901,"modified_method":"@Deprecated\n  public TestRunParameters() {\n    myTestRunner = \"jetbrains.mps.baseLanguage.unitTest.execution.server.TestRunner\";\n    myVmParameters = ListSequence.fromList(new ArrayList<String>());\n    myClassPath = ListSequence.fromList(new ArrayList<String>());\n    ListSequence.fromList(myClassPath).addSequence(CollectionSequence.fromCollection(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(\"f618e99a-2641-465c-bb54-31fe76f9e285\")).getFacet(JavaModuleFacet.class).getClassPath()));\n  }","commit_id":"5c73ae1a7da78c2e7bb6836af39456de2860ebee","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  @Override\n  protected RunContentDescriptor doExecute(Project project,\n                                           Executor executor,\n                                           RunProfileState state,\n                                           RunContentDescriptor contentToReuse,\n                                           ExecutionEnvironment env) throws ExecutionException {\n    FileDocumentManager.getInstance().saveAllDocuments();\n    ExecutionResult executionResult = state.execute(executor, this);\n    if (executionResult == null) return null;\n    KarmaServer karmaServer = null;\n    if (state instanceof KarmaTestRunnerState) {\n      karmaServer = ((KarmaTestRunnerState) state).getKarmaServer();\n    }\n\n    final RunContentBuilder contentBuilder = new RunContentBuilder(project, this, executor, executionResult, env);\n    RunContentDescriptor descriptor = contentBuilder.showRunContent(contentToReuse);\n    if (karmaServer != null) {\n      KarmaServerLogComponent logComponent = new KarmaServerLogComponent(project, karmaServer);\n      contentBuilder.addAdditionalTabComponent(logComponent, karmaServer.getConfigurationFile().getAbsolutePath());\n    }\n    return descriptor;\n  }","id":49902,"modified_method":"@Nullable\n  @Override\n  protected RunContentDescriptor doExecute(Project project,\n                                           Executor executor,\n                                           RunProfileState state,\n                                           RunContentDescriptor contentToReuse,\n                                           ExecutionEnvironment env) throws ExecutionException {\n    FileDocumentManager.getInstance().saveAllDocuments();\n    ExecutionResult executionResult = state.execute(executor, this);\n    if (executionResult == null) return null;\n    KarmaServer karmaServer = null;\n    if (state instanceof KarmaTestRunnerState) {\n      karmaServer = ((KarmaTestRunnerState) state).getKarmaServer();\n    }\n\n    final MyRunContentBuilder contentBuilder = new MyRunContentBuilder(project, this, executor, executionResult, env);\n    RunContentDescriptor descriptor = contentBuilder.showRunContent(contentToReuse);\n    if (contentToReuse != null) {\n      System.out.println(\"content to reuse\");\n    }\n    if (karmaServer != null) {\n      KarmaServerLogComponent logComponent = new KarmaServerLogComponent(project, descriptor, karmaServer);\n      logComponent.installOn(contentBuilder.getUi());\n    }\n    return descriptor;\n  }","commit_id":"245eeb869028fd45acb8eacab00b61a7de59044f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private KillableColoredProcessHandler startServer(@NotNull File nodeInterpreter,\n                                                    @NotNull File configurationFile) throws IOException, ExecutionException {\n    GeneralCommandLine commandLine = new GeneralCommandLine();\n    commandLine.setPassParentEnvironment(true);\n    commandLine.setWorkDirectory(configurationFile.getParentFile());\n    commandLine.setExePath(nodeInterpreter.getAbsolutePath());\n    File serverFile = getServerAppFile();\n    commandLine.addParameter(serverFile.getAbsolutePath());\n    commandLine.addParameter(\"--configFile=\" + configurationFile.getAbsolutePath());\n\n    LOG.info(\"Starting karma server: \" + commandLine.getCommandLineString());\n    final Process process = commandLine.createProcess();\n    KillableColoredProcessHandler processHandler = new KillableColoredProcessHandler(\n      process,\n      commandLine.getCommandLineString(),\n      CharsetToolkit.UTF8_CHARSET\n    );\n\n    processHandler.addProcessListener(new ProcessAdapter() {\n      @Override\n      public void onTextAvailable(ProcessEvent event, Key outputType) {\n        String text = event.getText().trim();\n        if (text != null && outputType == ProcessOutputTypes.STDOUT) {\n          handleStdout(text);\n        }\n      }\n\n      @Override\n      public void processTerminated(ProcessEvent event) {\n        KarmaServerRegistry.serverTerminated(KarmaServer.this);\n      }\n    });\n    ProcessTerminatedListener.attach(processHandler);\n    processHandler.setShouldDestroyProcessRecursively(true);\n    return processHandler;\n  }","id":49903,"modified_method":"private KillableColoredProcessHandler startServer(@NotNull File nodeInterpreter,\n                                                    @NotNull File configurationFile) throws IOException, ExecutionException {\n    GeneralCommandLine commandLine = new GeneralCommandLine();\n    commandLine.setPassParentEnvironment(true);\n    commandLine.setWorkDirectory(configurationFile.getParentFile());\n    commandLine.setExePath(nodeInterpreter.getAbsolutePath());\n    File serverFile = getServerAppFile();\n    commandLine.addParameter(serverFile.getAbsolutePath());\n    commandLine.addParameter(\"--configFile=\" + configurationFile.getAbsolutePath());\n\n    LOG.info(\"Starting karma server: \" + commandLine.getCommandLineString());\n    final Process process = commandLine.createProcess();\n    KillableColoredProcessHandler processHandler = new KillableColoredProcessHandler(\n      process,\n      commandLine.getCommandLineString(),\n      CharsetToolkit.UTF8_CHARSET\n    );\n\n    processHandler.addProcessListener(new ProcessAdapter() {\n      @Override\n      public void onTextAvailable(ProcessEvent event, Key outputType) {\n        String text = event.getText().trim();\n        if (text != null && outputType == ProcessOutputTypes.STDOUT) {\n          handleStdout(text);\n        }\n      }\n\n      @Override\n      public void processTerminated(ProcessEvent event) {\n        KarmaServerRegistry.serverTerminated(KarmaServer.this);\n        fireOnTerminated(event.getExitCode());\n      }\n    });\n    ProcessTerminatedListener.attach(processHandler);\n    processHandler.setShouldDestroyProcessRecursively(true);\n    return processHandler;\n  }","commit_id":"245eeb869028fd45acb8eacab00b61a7de59044f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public KarmaServerLogComponent(@NotNull Project project, @NotNull KarmaServer karmaServer) {\n    super(new BorderLayout());\n    myProcessEventStore = karmaServer.getProcessEventStore();\n    GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n    TextConsoleBuilder builder = TextConsoleBuilderFactory.getInstance().createBuilder(project, scope);\n    myConsole = builder.getConsole();\n    if (myConsole == null) {\n      throw new RuntimeException(\"Console shouldn't be null!\");\n    }\n    myProcessListener = new ProcessAdapter() {\n      @Override\n      public void onTextAvailable(ProcessEvent event, Key outputType) {\n        myConsole.print(event.getText(), ConsoleViewContentType.getConsoleViewType(outputType));\n      }\n    };\n    myProcessEventStore.addProcessListener(myProcessListener);\n    add(myConsole.getComponent(), BorderLayout.CENTER);\n    Disposer.register(this, myConsole);\n  }","id":49904,"modified_method":"public KarmaServerLogComponent(@NotNull Project project,\n                                 @NotNull RunContentDescriptor descriptor,\n                                 @NotNull KarmaServer karmaServer) {\n    myProcessEventStore = karmaServer.getProcessEventStore();\n    GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n    TextConsoleBuilder builder = TextConsoleBuilderFactory.getInstance().createBuilder(project, scope);\n    myConsole = builder.getConsole();\n    if (myConsole == null) {\n      throw new RuntimeException(\"Console shouldn't be null!\");\n    }\n    ProcessAdapter processListener = new ProcessAdapter() {\n      @Override\n      public void onTextAvailable(ProcessEvent event, Key outputType) {\n        myConsole.print(event.getText(), ConsoleViewContentType.getConsoleViewType(outputType));\n      }\n    };\n    myProcessEventStore.addProcessListener(processListener);\n    Disposer.register(descriptor, myConsole);\n  }","commit_id":"245eeb869028fd45acb8eacab00b61a7de59044f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  @NotNull\n  public ExecutionResult execute(@NotNull Executor executor, @NotNull ProgramRunner runner) throws ExecutionException {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    File configurationFile = new File(myRunSettings.getConfigPath());\n    KarmaServer server = KarmaServerRegistry.getServerByConfigurationFile(configurationFile);\n    if (server == null) {\n      try {\n        server = new KarmaServer(new File(myNodeInterpreterPath), new File(myKarmaPackageDir), configurationFile);\n        KarmaServerRegistry.registerServer(server);\n      }\n      catch (IOException e) {\n        throw new ExecutionException(e);\n      }\n    }\n    myKarmaServer = server;\n\n    KarmaTestTreeConsole testTreeConsole = new KarmaTestTreeConsole(myProject,\n                                                                    myExecutionEnvironment,\n                                                                    executor,\n                                                                    myKarmaServer,\n                                                                    myNodeInterpreterPath,\n                                                                    myRunSettings);\n\n    ProcessHandler processHandler = testTreeConsole.getProcessHandler();\n    DefaultExecutionResult executionResult = new DefaultExecutionResult(testTreeConsole, processHandler);\n    executionResult.setRestartActions(new ToggleAutoTestAction());\n    return executionResult;\n  }","id":49905,"modified_method":"@Override\n  @NotNull\n  public ExecutionResult execute(@NotNull Executor executor, @NotNull ProgramRunner runner) throws ExecutionException {\n    File configurationFile = new File(myRunSettings.getConfigPath());\n    KarmaServer server = KarmaServerRegistry.getServerByConfigurationFile(configurationFile);\n    if (server == null) {\n      try {\n        server = new KarmaServer(new File(myNodeInterpreterPath), new File(myKarmaPackageDir), configurationFile);\n        KarmaServerRegistry.registerServer(server);\n      }\n      catch (IOException e) {\n        throw new ExecutionException(e);\n      }\n    }\n    myKarmaServer = server;\n\n    KarmaTestTreeConsole testTreeConsole = new KarmaTestTreeConsole(myExecutionEnvironment,\n                                                                    executor,\n                                                                    myKarmaServer,\n                                                                    myNodeInterpreterPath,\n                                                                    myRunSettings);\n    Disposer.register(myProject, testTreeConsole);\n\n    ProcessHandler processHandler = testTreeConsole.getProcessHandler();\n    DefaultExecutionResult executionResult = new DefaultExecutionResult(testTreeConsole, processHandler);\n    executionResult.setRestartActions(new ToggleAutoTestAction());\n    return executionResult;\n  }","commit_id":"245eeb869028fd45acb8eacab00b61a7de59044f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  public ProcessHandler getProcessHandler() {\n    return myProcessHandler;\n  }","id":49906,"modified_method":"@NotNull\n  public ProcessHandler getProcessHandler() {\n    return myProcessHandlerInfo.myProcessHandler;\n  }","commit_id":"245eeb869028fd45acb8eacab00b61a7de59044f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void buildUi(RunnerLayoutUi layoutUi) {\n    if (myKarmaServer.isReady()) {\n\n    }\n  }","id":49907,"modified_method":"@Override\n  public void buildUi(final RunnerLayoutUi ui) {\n    if (myProcessHandlerInfo.myProcessHandler instanceof DelegatingProcessHandler) {\n      myKarmaServer.addListener(new KarmaServerAdapter() {\n        @Override\n        public void onReady(int webServerPort, int runnerPort) {\n          addTabOn(ui);\n        }\n      });\n    }\n    else {\n      addTabOn(ui);\n    }\n  }","commit_id":"245eeb869028fd45acb8eacab00b61a7de59044f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public JComponent getPreferredFocusableComponent() {\n    return null;\n  }","id":49908,"modified_method":"@Override\n  public JComponent getPreferredFocusableComponent() {\n    return mySmtConsoleView.getPreferredFocusableComponent();\n  }","commit_id":"245eeb869028fd45acb8eacab00b61a7de59044f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void dispose() {\n  }","id":49909,"modified_method":"@Override\n  public void dispose() {\n    Disposer.dispose(mySmtConsoleView);\n  }","commit_id":"245eeb869028fd45acb8eacab00b61a7de59044f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  private SMTRunnerConsoleView createConsole() {\n    KarmaRunConfiguration runConfiguration = (KarmaRunConfiguration) myEnvironment.getRunProfile();\n    TestConsoleProperties testConsoleProperties = new SMTRunnerConsoleProperties(\n      new RuntimeConfigurationProducer.DelegatingRuntimeConfiguration<KarmaRunConfiguration>(runConfiguration),\n      FRAMEWORK_NAME,\n      myExecutor\n    );\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.HIDE_PASSED_TESTS, false);\n\n    SMTRunnerConsoleView smtConsoleView = SMTestRunnerConnectionUtil.createConsoleWithCustomLocator(\n      FRAMEWORK_NAME,\n      testConsoleProperties,\n      myEnvironment.getRunnerSettings(),\n      myEnvironment.getConfigurationSettings(),\n      new KarmaTestLocationProvider(),\n      true,\n      null\n    );\n\n    Disposer.register(myProject, smtConsoleView);\n    return smtConsoleView;\n  }","id":49910,"modified_method":"@NotNull\n  private SMTRunnerConsoleView createConsole() {\n    KarmaRunConfiguration runConfiguration = (KarmaRunConfiguration) myEnvironment.getRunProfile();\n    TestConsoleProperties testConsoleProperties = new SMTRunnerConsoleProperties(\n      new RuntimeConfigurationProducer.DelegatingRuntimeConfiguration<KarmaRunConfiguration>(runConfiguration),\n      FRAMEWORK_NAME,\n      myExecutor\n    );\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.HIDE_PASSED_TESTS, false);\n\n    return SMTestRunnerConnectionUtil.createConsoleWithCustomLocator(\n      FRAMEWORK_NAME,\n      testConsoleProperties,\n      myEnvironment.getRunnerSettings(),\n      myEnvironment.getConfigurationSettings(),\n      new KarmaTestLocationProvider(),\n      true,\n      null\n    );\n  }","commit_id":"245eeb869028fd45acb8eacab00b61a7de59044f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  @Override\n  public String getExecutionConsoleId() {\n    return FRAMEWORK_NAME;\n  }","id":49911,"modified_method":"@Nullable\n  @Override\n  public String getExecutionConsoleId() {\n    return ExecutionConsole.CONSOLE_CONTENT_ID;\n  }","commit_id":"245eeb869028fd45acb8eacab00b61a7de59044f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public JComponent getComponent() {\n    return null;\n  }","id":49912,"modified_method":"@Override\n  public JComponent getComponent() {\n    return mySmtConsoleView.getComponent();\n  }","commit_id":"245eeb869028fd45acb8eacab00b61a7de59044f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public KarmaTestTreeConsole(@NotNull Project project,\n                              @NotNull ExecutionEnvironment environment,\n                              @NotNull Executor executor,\n                              @NotNull KarmaServer karmaServer,\n                              @NotNull String nodeInterpreterPath,\n                              @NotNull KarmaRunSettings runSettings) throws ExecutionException {\n    myProject = project;\n    myEnvironment = environment;\n    myExecutor = executor;\n    myKarmaServer = karmaServer;\n    myNodeInterpreterPath = nodeInterpreterPath;\n    myRunSettings = runSettings;\n    mySmtConsoleView = createConsole();\n    myProcessHandler = createProcessHandler(karmaServer);\n  }","id":49913,"modified_method":"public KarmaTestTreeConsole(@NotNull ExecutionEnvironment environment,\n                              @NotNull Executor executor,\n                              @NotNull KarmaServer karmaServer,\n                              @NotNull String nodeInterpreterPath,\n                              @NotNull KarmaRunSettings runSettings) throws ExecutionException {\n    myEnvironment = environment;\n    myExecutor = executor;\n    myKarmaServer = karmaServer;\n    myNodeInterpreterPath = nodeInterpreterPath;\n    myRunSettings = runSettings;\n    mySmtConsoleView = createConsole();\n    myProcessHandlerInfo = createProcessHandler(karmaServer);\n  }","commit_id":"245eeb869028fd45acb8eacab00b61a7de59044f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  private ProcessHandler createProcessHandler(@NotNull KarmaServer server) throws ExecutionException {\n    final File clientAppFile;\n    try {\n      clientAppFile = server.getClientAppFile();\n    }\n    catch (IOException e) {\n      throw new ExecutionException(\"Can't find karma-intellij test runner\", e);\n    }\n    if (server.isReady()) {\n      int runnerPort = server.getRunnerPort();\n      return createOSProcessHandler(runnerPort, clientAppFile);\n    }\n    final FakeProcessHandler fakeProcessHandler = new FakeProcessHandler();\n    server.addListener(new KarmaServerListener() {\n      @Override\n      public void onReady(int webServerPort, int runnerPort) {\n        try {\n          OSProcessHandler osProcessHandler = createOSProcessHandler(runnerPort, clientAppFile);\n          fakeProcessHandler.setPeer(osProcessHandler);\n        }\n        catch (ExecutionException e) {\n          LOG.warn(e);\n          // TODO handle\n        }\n      }\n    });\n    return fakeProcessHandler;\n  }","id":49914,"modified_method":"@NotNull\n  private ProcessHandlerInfo createProcessHandler(@NotNull KarmaServer server) throws ExecutionException {\n    final File clientAppFile;\n    try {\n      clientAppFile = server.getClientAppFile();\n    }\n    catch (IOException e) {\n      throw new ExecutionException(\"Can't find karma-intellij test runner\", e);\n    }\n    if (server.isReady()) {\n      int runnerPort = server.getRunnerPort();\n      OSProcessHandler processHandler = createOSProcessHandler(runnerPort, clientAppFile);\n      return new ProcessHandlerInfo(processHandler, new AsyncResult.Done<OSProcessHandler>(processHandler));\n    }\n    final AsyncResult<OSProcessHandler> asyncResult = new AsyncResult<OSProcessHandler>();\n    final DelegatingProcessHandler delegatingProcessHandler = new DelegatingProcessHandler();\n    server.addListener(new KarmaServerListener() {\n      @Override\n      public void onReady(int webServerPort, int runnerPort) {\n        try {\n          OSProcessHandler osProcessHandler = createOSProcessHandler(runnerPort, clientAppFile);\n          delegatingProcessHandler.setDelegate(osProcessHandler);\n          asyncResult.setDone(osProcessHandler);\n        }\n        catch (ExecutionException e) {\n          LOG.warn(e);\n          // TODO handle\n        }\n      }\n\n      @Override\n      public void onTerminated(int exitCode) {\n        delegatingProcessHandler.onDelegateTerminated(exitCode);\n      }\n    });\n    return new ProcessHandlerInfo(delegatingProcessHandler, asyncResult);\n  }","commit_id":"245eeb869028fd45acb8eacab00b61a7de59044f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  private OSProcessHandler createOSProcessHandler(int runnerPort, @NotNull File clientAppFile) throws ExecutionException {\n    GeneralCommandLine commandLine = createCommandLine(runnerPort, clientAppFile);\n    Process process = commandLine.createProcess();\n    OSProcessHandler processHandler = new KillableColoredProcessHandler(process, commandLine.getCommandLineString());\n    ProcessTerminatedListener.attach(processHandler);\n    return processHandler;\n  }","id":49915,"modified_method":"@NotNull\n  private OSProcessHandler createOSProcessHandler(int runnerPort, @NotNull File clientAppFile) throws ExecutionException {\n    GeneralCommandLine commandLine = createCommandLine(runnerPort, clientAppFile);\n    Process process = commandLine.createProcess();\n    OSProcessHandler processHandler = new KillableColoredProcessHandler(process, commandLine.getCommandLineString());\n    ProcessTerminatedListener.attach(processHandler);\n    mySmtConsoleView.attachToProcess(processHandler);\n    return processHandler;\n  }","commit_id":"245eeb869028fd45acb8eacab00b61a7de59044f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  private SMTRunnerConsoleView createSMTRunnerConsoleView() {\n    KarmaRunConfiguration runConfiguration = (KarmaRunConfiguration) myEnvironment.getRunProfile();\n    TestConsoleProperties testConsoleProperties = new SMTRunnerConsoleProperties(\n      new RuntimeConfigurationProducer.DelegatingRuntimeConfiguration<KarmaRunConfiguration>(runConfiguration),\n      FRAMEWORK_NAME,\n      myExecutor\n    );\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.HIDE_PASSED_TESTS, false);\n\n    return SMTestRunnerConnectionUtil.createConsoleWithCustomLocator(\n      FRAMEWORK_NAME,\n      testConsoleProperties,\n      myEnvironment.getRunnerSettings(),\n      myEnvironment.getConfigurationSettings(),\n      new KarmaTestLocationProvider(),\n      true,\n      null\n    );\n  }","id":49916,"modified_method":"@NotNull\n  private SMTRunnerConsoleView createSMTRunnerConsoleView() {\n    KarmaRunConfiguration runConfiguration = (KarmaRunConfiguration) myEnvironment.getRunProfile();\n    TestConsoleProperties testConsoleProperties = new SMTRunnerConsoleProperties(\n      new RuntimeConfigurationProducer.DelegatingRuntimeConfiguration<KarmaRunConfiguration>(runConfiguration),\n      FRAMEWORK_NAME,\n      myExecutor\n    );\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.HIDE_PASSED_TESTS, false);\n\n    KarmaProxyPrinterProvider printerProvider = new KarmaProxyPrinterProvider();\n    SMTRunnerConsoleView consoleView = SMTestRunnerConnectionUtil.createConsoleWithCustomLocator(\n      FRAMEWORK_NAME,\n      testConsoleProperties,\n      myEnvironment.getRunnerSettings(),\n      myEnvironment.getConfigurationSettings(),\n      new KarmaTestLocationProvider(),\n      true,\n      printerProvider\n    );\n    printerProvider.setConsoleView(consoleView);\n    return consoleView;\n  }","commit_id":"4e6c5c713adeaf1ca567586b12a790a101c1830e","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static ConsoleView createConsole(@NotNull Project project,\n                                           @NotNull ExecutionEnvironment env,\n                                           Executor executor)\n    throws ExecutionException {\n    JstdRunConfiguration runConfiguration = (JstdRunConfiguration) env.getRunProfile();\n    TestConsoleProperties testConsoleProperties = new SMTRunnerConsoleProperties(\n      new RuntimeConfigurationProducer.DelegatingRuntimeConfiguration<JstdRunConfiguration>(runConfiguration),\n      JSTD_FRAMEWORK_NAME,\n      executor\n    );\n    testConsoleProperties.setUsePredefinedMessageFilter(false);\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.HIDE_PASSED_TESTS, false);\n\n    JstdTestProxyPrinterProvider printerProvider = new JstdTestProxyPrinterProvider();\n    SMTRunnerConsoleView smtConsoleView = SMTestRunnerConnectionUtil.createConsoleWithCustomLocator(\n      JSTD_FRAMEWORK_NAME,\n      testConsoleProperties,\n      env.getRunnerSettings(),\n      env.getConfigurationSettings(),\n      new JstdTestLocationProvider(),\n      true,\n      printerProvider\n    );\n    printerProvider.setConsoleView(smtConsoleView);\n\n    Disposer.register(project, smtConsoleView);\n    return smtConsoleView;\n  }","id":49917,"modified_method":"private static ConsoleView createConsole(@NotNull Project project,\n                                           @NotNull ExecutionEnvironment env,\n                                           Executor executor)\n    throws ExecutionException {\n    JstdRunConfiguration runConfiguration = (JstdRunConfiguration) env.getRunProfile();\n    TestConsoleProperties testConsoleProperties = new SMTRunnerConsoleProperties(\n      new RuntimeConfigurationProducer.DelegatingRuntimeConfiguration<JstdRunConfiguration>(runConfiguration),\n      JSTD_FRAMEWORK_NAME,\n      executor\n    );\n    testConsoleProperties.setUsePredefinedMessageFilter(false);\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.HIDE_PASSED_TESTS, false);\n\n    SMTRunnerConsoleView smtConsoleView = SMTestRunnerConnectionUtil.createConsoleWithCustomLocator(\n      JSTD_FRAMEWORK_NAME,\n      testConsoleProperties,\n      env.getRunnerSettings(),\n      env.getConfigurationSettings(),\n      new JstdTestLocationProvider(),\n      true,\n      new JstdTestProxyFilterProvider(testConsoleProperties.getProject())\n    );\n\n    Disposer.register(project, smtConsoleView);\n    return smtConsoleView;\n  }","commit_id":"536e9f683b6862de00b8886c35fc82d6281acc7b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  private SMTRunnerConsoleView createSMTRunnerConsoleView() {\n    KarmaRunConfiguration runConfiguration = (KarmaRunConfiguration) myEnvironment.getRunProfile();\n    TestConsoleProperties testConsoleProperties = new SMTRunnerConsoleProperties(\n      new RuntimeConfigurationProducer.DelegatingRuntimeConfiguration<KarmaRunConfiguration>(runConfiguration),\n      FRAMEWORK_NAME,\n      myExecutor\n    );\n    testConsoleProperties.setUsePredefinedMessageFilter(false);\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.HIDE_PASSED_TESTS, false);\n\n    KarmaProxyPrinterProvider printerProvider = new KarmaProxyPrinterProvider(myKarmaServer);\n    SMTRunnerConsoleView consoleView = SMTestRunnerConnectionUtil.createConsoleWithCustomLocator(\n      FRAMEWORK_NAME,\n      testConsoleProperties,\n      myEnvironment.getRunnerSettings(),\n      myEnvironment.getConfigurationSettings(),\n      new KarmaTestLocationProvider(),\n      true,\n      printerProvider\n    );\n    printerProvider.setConsoleView(consoleView);\n    return consoleView;\n  }","id":49918,"modified_method":"@NotNull\n  private SMTRunnerConsoleView createSMTRunnerConsoleView() {\n    KarmaRunConfiguration runConfiguration = (KarmaRunConfiguration) myEnvironment.getRunProfile();\n    TestConsoleProperties testConsoleProperties = new SMTRunnerConsoleProperties(\n      new RuntimeConfigurationProducer.DelegatingRuntimeConfiguration<KarmaRunConfiguration>(runConfiguration),\n      FRAMEWORK_NAME,\n      myExecutor\n    );\n    testConsoleProperties.setUsePredefinedMessageFilter(false);\n    testConsoleProperties.setIfUndefined(TestConsoleProperties.HIDE_PASSED_TESTS, false);\n\n    Project project = testConsoleProperties.getProject();\n    return SMTestRunnerConnectionUtil.createConsoleWithCustomLocator(\n      FRAMEWORK_NAME,\n      testConsoleProperties,\n      myEnvironment.getRunnerSettings(),\n      myEnvironment.getConfigurationSettings(),\n      new KarmaTestLocationProvider(),\n      true,\n      new KarmaTestProxyFilterProvider(project, myKarmaServer)\n    );\n  }","commit_id":"536e9f683b6862de00b8886c35fc82d6281acc7b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void handle(MappingHttpRequest httpRequest) throws AuthenticationException\n\t{\n\t\tMap<String,String> parameters = httpRequest.getParameters( );\n\t\tString verb = httpRequest.getMethod().getName();\n\t\tString addr = httpRequest.getUri();\n\n\t\tif(httpRequest.containsHeader(StorageProperties.StorageParameters.EucaSignature.toString())) {\n\t\t\t//possible internal request -- perform authentication using internal credentials\n\t\t\tString date = httpRequest.getAndRemoveHeader(SecurityParameter.Date.toString());\n\t\t\tString signature = httpRequest.getAndRemoveHeader(StorageProperties.StorageParameters.EucaSignature.toString());\n\t\t\tString certString = null;\n\t\t\tif( httpRequest.containsHeader( StorageProperties.StorageParameters.EucaCert.toString( ) ) ) {\n\t\t\t\tcertString= httpRequest.getAndRemoveHeader(StorageProperties.StorageParameters.EucaCert.toString());\n\t\t\t}\n\t\t\tString data = verb + \"\\n\" + date + \"\\n\" + addr + \"\\n\";\n\t\t\tString effectiveUserID = httpRequest.getAndRemoveHeader(StorageProperties.StorageParameters.EucaEffectiveUserId.toString());\n\t\t\ttry {\n\t\t\t\tSecurityContext.getLoginContext(new WalrusWrappedComponentCredentials(httpRequest.getCorrelationId(), data, effectiveUserID, signature, certString)).login();\n\t\t\t} catch(Exception ex) {\n\t\t\t\tLOG.error(ex);\n\t\t\t\tthrow new AuthenticationException(ex);\n\t\t\t}\n\t\t}  else {\n\t\t\t//external user request\n\t\t\tString content_md5 = httpRequest.getHeader(\"Content-MD5\");\n\t\t\tcontent_md5 = content_md5 == null ? \"\" : content_md5;\n\t\t\tString content_type = httpRequest.getHeader(WalrusProperties.CONTENT_TYPE);\n\t\t\tcontent_type = content_type == null ? \"\" : content_type;\n\n\t\t\tString targetHost = httpRequest.getHeader(HttpHeaders.Names.HOST);\n\t\t\tif(targetHost.contains(\".walrus\")) {\n\t\t\t\tString bucket = targetHost.substring(0, targetHost.indexOf(\".walrus\"));\n\t\t\t\taddr = \"/\" + bucket + addr;\n\t\t\t}\n\t\t\tString[] addrStrings = addr.split(\"\\\\?\");\n\t\t\tString addrString = addrStrings[0];\n\n\t\t\tif(addrStrings.length > 1) {\n\t\t\t\tfor(WalrusProperties.SubResource subResource : WalrusProperties.SubResource.values()) {\n\t\t\t\t\tif(addr.endsWith(subResource.toString().toLowerCase())) {\n\t\t\t\t\t\taddrString += \"?\" + subResource.toString().toLowerCase();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(httpRequest.containsHeader(SecurityParameter.Authorization.toString())) {\n\t\t\t\tString date;\n\t\t\t\tString verifyDate;\n\t\t\t\tif(httpRequest.containsHeader(\"x-amz-date\")) {\n\t\t\t\t\tdate = \"\";\n\t\t\t\t\tverifyDate = httpRequest.getHeader(\"x-amz-date\");\n\t\t\t\t} else {\n\t\t\t\t\tdate =  httpRequest.getAndRemoveHeader(SecurityParameter.Date.toString());\n\t\t\t\t\tverifyDate = date;\n\t\t\t\t\tif(date == null || date.length() <= 0)\n\t\t\t\t\t\tthrow new AuthenticationException(\"User authentication failed. Date must be specified.\");\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tDate dateToVerify = DateUtil.parseDate(verifyDate);\n\t\t\t\t\tDate currentDate = new Date();\n\t\t\t\t\tif(Math.abs(currentDate.getTime() - dateToVerify.getTime()) > WalrusProperties.EXPIRATION_LIMIT)\n\t\t\t\t\t\tthrow new AuthenticationException(\"Message expired. Sorry.\");\n\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\tthrow new AuthenticationException(\"Unable to parse date.\");\n\t\t\t\t}\n\t\t\t\tString data = verb + \"\\n\" + content_md5 + \"\\n\" + content_type + \"\\n\" + date + \"\\n\" +  getCanonicalizedAmzHeaders(httpRequest) + addrString;\n\t\t\t\tString authPart = httpRequest.getAndRemoveHeader(SecurityParameter.Authorization.toString());\n\t\t\t\tString sigString[] = getSigInfo(authPart);\n\t\t\t\tif(sigString.length < 2) {\n\t\t\t\t\tthrow new AuthenticationException(\"Invalid authentication header\");\n\t\t\t\t}\n\t\t\t\tString accessKeyId = sigString[0];\n\t\t\t\tString signature = sigString[1];\n\n\t\t\t\ttry {\n\t\t\t\t\tSecurityContext.getLoginContext(new WalrusWrappedCredentials(httpRequest.getCorrelationId(), data, accessKeyId, signature)).login();\n\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\tthrow new AuthenticationException(ex);\n\t\t\t\t}\n\t\t\t} else if(parameters.containsKey(SecurityParameter.AWSAccessKeyId.toString())) {\n\t\t\t\t//query string authentication\n\t\t\t\tString accesskeyid = parameters.remove(SecurityParameter.AWSAccessKeyId.toString());\n\t\t\t\ttry {\n\t\t\t\t\tString signature = WalrusUtil.URLdecode(parameters.remove(SecurityParameter.Signature.toString()));\n\t\t\t\t\tif(signature == null) {\n\t\t\t\t\t\tthrow new AuthenticationException(\"User authentication failed. Null signature.\");\n\t\t\t\t\t}\n\t\t\t\t\tString expires = parameters.remove(SecurityParameter.Expires.toString());\n\t\t\t\t\tif(expires == null) {\n\t\t\t\t\t\tthrow new AuthenticationException(\"Authentication failed. Expires must be specified.\");\n\t\t\t\t\t}\n\t\t\t\t\tif(checkExpires(expires)) {\n\t\t\t\t\t\tString stringToSign = verb + \"\\n\" + content_md5 + \"\\n\" + content_type + \"\\n\" + Long.parseLong(expires) + \"\\n\" + getCanonicalizedAmzHeaders(httpRequest) + addrString;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tSecurityContext.getLoginContext(new WalrusWrappedCredentials(httpRequest.getCorrelationId(), stringToSign, accesskeyid, signature)).login();\n\t\t\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\tthrow new AuthenticationException(ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new AuthenticationException(\"Cannot process request. Expired.\");\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tthrow new AuthenticationException(\"Could not verify request \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t} else{\n\t\t\t\t//anonymous request              \n\t\t\t\ttry {\n\t\t\t\t\tContext ctx = Contexts.lookup(httpRequest.getCorrelationId());\n\t\t\t\t\tctx.setUser(Principals.nobodyUser());\n\t\t\t\t} catch (NoSuchContextException e) {\n\t\t\t\t\tLOG.error(e, e);\n\t\t\t\t\tthrow new AuthenticationException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":49919,"modified_method":"public void handle(MappingHttpRequest httpRequest) throws AuthenticationException\n\t{\n\t\tMap<String,String> parameters = httpRequest.getParameters( );\n\t\tString verb = httpRequest.getMethod().getName();\n\t\tString addr = httpRequest.getUri();\n\n\t\tif(httpRequest.containsHeader(StorageProperties.StorageParameters.EucaSignature.toString())) {\n\t\t\t//possible internal request -- perform authentication using internal credentials\n\t\t\tString date = httpRequest.getAndRemoveHeader(SecurityParameter.Date.toString());\n\t\t\tString signature = httpRequest.getAndRemoveHeader(StorageProperties.StorageParameters.EucaSignature.toString());\n\t\t\tString certString = null;\n\t\t\tif( httpRequest.containsHeader( StorageProperties.StorageParameters.EucaCert.toString( ) ) ) {\n\t\t\t\tcertString= httpRequest.getAndRemoveHeader(StorageProperties.StorageParameters.EucaCert.toString());\n\t\t\t}\n\t\t\tString data = verb + \"\\n\" + date + \"\\n\" + addr + \"\\n\";\n\t\t\tString effectiveUserID = httpRequest.getAndRemoveHeader(StorageProperties.StorageParameters.EucaEffectiveUserId.toString());\n\t\t\ttry {\n\t\t\t\tSecurityContext.getLoginContext(new WalrusWrappedComponentCredentials(httpRequest.getCorrelationId(), data, effectiveUserID, signature, certString)).login();\n\t\t\t} catch(Exception ex) {\n\t\t\t\tLOG.error(ex);\n\t\t\t\tthrow new AuthenticationException(ex);\n\t\t\t}\n\t\t}  else {\n\t\t\t//external user request\n\t\t\tString content_md5 = httpRequest.getHeader(\"Content-MD5\");\n\t\t\tcontent_md5 = content_md5 == null ? \"\" : content_md5;\n\t\t\tString content_type = httpRequest.getHeader(WalrusProperties.CONTENT_TYPE);\n\t\t\tcontent_type = content_type == null ? \"\" : content_type;\n\n\t\t\tString targetHost = httpRequest.getHeader(HttpHeaders.Names.HOST);\n\t\t\tif(targetHost.contains(\".walrus\")) {\n\t\t\t\tString bucket = targetHost.substring(0, targetHost.indexOf(\".walrus\"));\n\t\t\t\taddr = \"/\" + bucket + addr;\n\t\t\t}\n\t\t\tString[] addrStrings = addr.split(\"\\\\?\");\n\t\t\tString addrString = addrStrings[0];\n\n\t\t\tif(addrStrings.length > 1) {\n\t\t\t\t//Split into individual parameter=value strings\n\t\t\t\tString[] params = addrStrings[1].split(\"&\");\n\n\t\t\t\t//Sort the query parameters before adding them to the canonical string\n\t\t\t\tArrays.sort(params);\n\t\t\t\tString[] pair = null;\n\t\t\t\tboolean first = true;\n\t\t\t\ttry {\n\t\t\t\t\tfor(String qparam : params) {\n\t\t\t\t\t\tpair = qparam.split(\"=\"); //pair[0] = param name, pair[1] = param value if it is present\n\t\t\t\t\t\n\t\t\t\t\t\tfor(WalrusProperties.SubResource subResource : WalrusProperties.SubResource.values()) {\n\t\t\t\t\t\t\tif(pair[0].equals(subResource.toString())) {\n\t\t\t\t\t\t\t\tif(first) {\n\t\t\t\t\t\t\t\t\taddrString += \"?\";\n\t\t\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\taddrString += \"&\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\taddrString += subResource.toString() + (pair.length > 1 ? \"=\" + WalrusUtil.URLdecode(pair[1]) : \"\");\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t} catch(UnsupportedEncodingException e) {\n\t\t\t\t\tthrow new AuthenticationException(\"Could not verify request. Failed url decoding query parameters: \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(httpRequest.containsHeader(SecurityParameter.Authorization.toString())) {\n\t\t\t\tString date;\n\t\t\t\tString verifyDate;\n\t\t\t\tif(httpRequest.containsHeader(\"x-amz-date\")) {\n\t\t\t\t\tdate = \"\";\n\t\t\t\t\tverifyDate = httpRequest.getHeader(\"x-amz-date\");\n\t\t\t\t} else {\n\t\t\t\t\tdate =  httpRequest.getAndRemoveHeader(SecurityParameter.Date.toString());\n\t\t\t\t\tverifyDate = date;\n\t\t\t\t\tif(date == null || date.length() <= 0)\n\t\t\t\t\t\tthrow new AuthenticationException(\"User authentication failed. Date must be specified.\");\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tDate dateToVerify = DateUtil.parseDate(verifyDate);\n\t\t\t\t\tDate currentDate = new Date();\n\t\t\t\t\tif(Math.abs(currentDate.getTime() - dateToVerify.getTime()) > WalrusProperties.EXPIRATION_LIMIT)\n\t\t\t\t\t\tthrow new AuthenticationException(\"Message expired. Sorry.\");\n\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\tthrow new AuthenticationException(\"Unable to parse date.\");\n\t\t\t\t}\n\t\t\t\tString data = verb + \"\\n\" + content_md5 + \"\\n\" + content_type + \"\\n\" + date + \"\\n\" +  getCanonicalizedAmzHeaders(httpRequest) + addrString;\n\t\t\t\tString authPart = httpRequest.getAndRemoveHeader(SecurityParameter.Authorization.toString());\n\t\t\t\tString sigString[] = getSigInfo(authPart);\n\t\t\t\tif(sigString.length < 2) {\n\t\t\t\t\tthrow new AuthenticationException(\"Invalid authentication header\");\n\t\t\t\t}\n\t\t\t\tString accessKeyId = sigString[0];\n\t\t\t\tString signature = sigString[1];\n\n\t\t\t\ttry {\n\t\t\t\t\tSecurityContext.getLoginContext(new WalrusWrappedCredentials(httpRequest.getCorrelationId(), data, accessKeyId, signature)).login();\n\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\tthrow new AuthenticationException(ex);\n\t\t\t\t}\n\t\t\t} else if(parameters.containsKey(SecurityParameter.AWSAccessKeyId.toString())) {\n\t\t\t\t//query string authentication\n\t\t\t\tString accesskeyid = parameters.remove(SecurityParameter.AWSAccessKeyId.toString());\n\t\t\t\ttry {\n\t\t\t\t\tString signature = WalrusUtil.URLdecode(parameters.remove(SecurityParameter.Signature.toString()));\n\t\t\t\t\tif(signature == null) {\n\t\t\t\t\t\tthrow new AuthenticationException(\"User authentication failed. Null signature.\");\n\t\t\t\t\t}\n\t\t\t\t\tString expires = parameters.remove(SecurityParameter.Expires.toString());\n\t\t\t\t\tif(expires == null) {\n\t\t\t\t\t\tthrow new AuthenticationException(\"Authentication failed. Expires must be specified.\");\n\t\t\t\t\t}\n\t\t\t\t\tif(checkExpires(expires)) {\n\t\t\t\t\t\tString stringToSign = verb + \"\\n\" + content_md5 + \"\\n\" + content_type + \"\\n\" + Long.parseLong(expires) + \"\\n\" + getCanonicalizedAmzHeaders(httpRequest) + addrString;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tSecurityContext.getLoginContext(new WalrusWrappedCredentials(httpRequest.getCorrelationId(), stringToSign, accesskeyid, signature)).login();\n\t\t\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\tthrow new AuthenticationException(ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new AuthenticationException(\"Cannot process request. Expired.\");\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\tthrow new AuthenticationException(\"Could not verify request \" + ex.getMessage());\n\t\t\t\t}\n\t\t\t} else{\n\t\t\t\t//anonymous request              \n\t\t\t\ttry {\n\t\t\t\t\tContext ctx = Contexts.lookup(httpRequest.getCorrelationId());\n\t\t\t\t\tctx.setUser(Principals.nobodyUser());\n\t\t\t\t} catch (NoSuchContextException e) {\n\t\t\t\t\tLOG.error(e, e);\n\t\t\t\t\tthrow new AuthenticationException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"24fdf41f85a21570b69978f7525da803fed6eeec","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\r\n\tpublic void dispose () {\r\n\t\trenderer.dispose();\r\n\t\tshot.dispose();\r\n\t\texplosion.dispose();\r\n\t}","id":49920,"modified_method":"@Override\r\n\tpublic void dispose () {\r\n\t\trenderer.dispose();\r\n\t\tshot.dispose();\r\n\t\texplosion.dispose();\r\n\t\tcontroller.removeListener(listener);\r\n\t}","commit_id":"71cc87409d60e4b2a3e1ad79f3081dd3f63855ef","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void update (float delta) {\r\n\t\tsimulation.update(delta);\r\n\r\n\t\tfloat accelerometerY = Gdx.input.getAccelerometerY();\r\n\t\tif (accelerometerY < 0)\r\n\t\t\tsimulation.moveShipLeft(delta, Math.abs(accelerometerY) / 10);\r\n\t\telse\r\n\t\t\tsimulation.moveShipRight(delta, Math.abs(accelerometerY) / 10);\r\n\t\t\r\n\t\tif(controller != null) {\r\n\t\t\t// if any button is pressed, we shoot.\r\n//\t\t\tfor(int i = 0; i < controller.getControlCount(ControlType.button); i++) {\r\n//\t\t\t\tif(controller.getButton(i)) {\r\n//\t\t\t\t\tsimulation.shot();\r\n//\t\t\t\t\tbreak;\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n\t\t\t// if the dpad pov is pressed, move left/right\r\n\t\t\tif(controller.getPov(0) == PovDirection.west) simulation.moveShipRight(delta, 0.5f);\r\n\t\t\tif(controller.getPov(0) == PovDirection.east) simulation.moveShipRight(delta, 0.5f);\r\n\t\t}\r\n\r\n\t\tif (Gdx.input.isKeyPressed(Keys.DPAD_LEFT) || Gdx.input.isKeyPressed(Keys.A)) simulation.moveShipLeft(delta, 0.5f);\r\n\t\tif (Gdx.input.isKeyPressed(Keys.DPAD_RIGHT) || Gdx.input.isKeyPressed(Keys.D)) simulation.moveShipRight(delta, 0.5f);\r\n\t\tif (Gdx.input.isTouched() || Gdx.input.isKeyPressed(Keys.SPACE)) simulation.shot();\r\n\t}","id":49921,"modified_method":"@Override\r\n\tpublic void update (float delta) {\r\n\t\tsimulation.update(delta);\r\n\r\n\t\tfloat accelerometerY = Gdx.input.getAccelerometerY();\r\n\t\tif (accelerometerY < 0)\r\n\t\t\tsimulation.moveShipLeft(delta, Math.abs(accelerometerY) / 10);\r\n\t\telse\r\n\t\t\tsimulation.moveShipRight(delta, Math.abs(accelerometerY) / 10);\r\n\t\t\r\n\t\tif(controller != null) {\r\n\t\t\t// if any button is pressed, we shoot.\r\n\t\t\tif(buttonsPressed > 0) simulation.shot();\r\n\t\t\t\r\n\t\t\t// if the left stick moved, move the ship\r\n\t\t\tfloat axisValue = controller.getAxis(Ouya.AXIS_LEFT_X) * 0.5f;\r\n\t\t\tif(Math.abs(axisValue) > 0.25f) {\r\n\t\t\t\tif(axisValue > 0) {\r\n\t\t\t\t\tsimulation.moveShipRight(delta, axisValue);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsimulation.moveShipLeft(delta, -axisValue);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (Gdx.input.isKeyPressed(Keys.DPAD_LEFT) || Gdx.input.isKeyPressed(Keys.A)) simulation.moveShipLeft(delta, 0.5f);\r\n\t\tif (Gdx.input.isKeyPressed(Keys.DPAD_RIGHT) || Gdx.input.isKeyPressed(Keys.D)) simulation.moveShipRight(delta, 0.5f);\r\n\t\tif (Gdx.input.isTouched() || Gdx.input.isKeyPressed(Keys.SPACE)) simulation.shot();\r\n\t}","commit_id":"71cc87409d60e4b2a3e1ad79f3081dd3f63855ef","url":"https://github.com/libgdx/libgdx"},{"original_method":"public GameLoop () {\r\n\t\tsimulation = new Simulation();\r\n\t\tsimulation.listener = this;\r\n\t\trenderer = Gdx.graphics.isGL20Available() ? new RendererGL20() : new RendererGL10();\r\n\t\texplosion = Gdx.audio.newSound(Gdx.files.internal(\"data/explosion.wav\"));\r\n\t\tshot = Gdx.audio.newSound(Gdx.files.internal(\"data/shot.wav\"));\r\n\t\t\r\n\t\t// check for attached controllers and if we are on\r\n\t\t// Ouya.\r\n\t\tif(Controllers.getControllers().size > 0) {\r\n\t\t\tController controller = Controllers.getControllers().get(0);\r\n\t\t\tif(controller.getName().toLowerCase().contains(\"ouya\")) {\r\n\t\t\t\tthis.controller = controller;\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":49922,"modified_method":"public GameLoop () {\r\n\t\tsimulation = new Simulation();\r\n\t\tsimulation.listener = this;\r\n\t\trenderer = Gdx.graphics.isGL20Available() ? new RendererGL20() : new RendererGL10();\r\n\t\texplosion = Gdx.audio.newSound(Gdx.files.internal(\"data/explosion.wav\"));\r\n\t\tshot = Gdx.audio.newSound(Gdx.files.internal(\"data/shot.wav\"));\r\n\t\t\r\n\t\t// check for attached controllers and if we are on\r\n\t\t// Ouya, take the first controller. Doesn't handle disconnects :D\r\n\t\tif(Controllers.getControllers().size > 0) {\r\n\t\t\tController controller = Controllers.getControllers().get(0);\r\n\t\t\tif(Ouya.ID.equals(controller.getName())) {\r\n\t\t\t\tthis.controller = controller;\r\n\t\t\t\tcontroller.addListener(listener);\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"71cc87409d60e4b2a3e1ad79f3081dd3f63855ef","url":"https://github.com/libgdx/libgdx"},{"original_method":"public GameOver () {\r\n\t\tspriteBatch = new SpriteBatch();\r\n\t\tbackground = new Texture(Gdx.files.internal(\"data/planet.jpg\"));\r\n\t\tbackground.setFilter(TextureFilter.Linear, TextureFilter.Linear);\r\n\r\n\t\tlogo = new Texture(Gdx.files.internal(\"data/title.png\"));\r\n\t\tlogo.setFilter(TextureFilter.Linear, TextureFilter.Linear);\r\n\r\n\t\tfont = new BitmapFont(Gdx.files.internal(\"data/font16.fnt\"), Gdx.files.internal(\"data/font16.png\"), false);\r\n\t}","id":49923,"modified_method":"public GameOver () {\r\n\t\tspriteBatch = new SpriteBatch();\r\n\t\tbackground = new Texture(Gdx.files.internal(\"data/planet.jpg\"));\r\n\t\tbackground.setFilter(TextureFilter.Linear, TextureFilter.Linear);\r\n\r\n\t\tlogo = new Texture(Gdx.files.internal(\"data/title.png\"));\r\n\t\tlogo.setFilter(TextureFilter.Linear, TextureFilter.Linear);\r\n\r\n\t\tfont = new BitmapFont(Gdx.files.internal(\"data/font16.fnt\"), Gdx.files.internal(\"data/font16.png\"), false);\r\n\t\t\r\n\t\tif(Controllers.getControllers().size > 0) {\r\n\t\t\tController controller = Controllers.getControllers().get(0);\r\n\t\t\tif(Ouya.ID.equals(controller.getName())) {\r\n\t\t\t\tcontroller.addListener(new ControllerAdapter() {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic boolean buttonUp (Controller controller, int buttonIndex) {\r\n\t\t\t\t\t\tisDone = true;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"71cc87409d60e4b2a3e1ad79f3081dd3f63855ef","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void create () {\r\n\t\tsetupUi();\r\n\t\tint a = Ouya.BUTTON_A;\r\n\t\t// print the currently connected controllers to the console\r\n\t\tprint(\"Controllers: \" + Controllers.getControllers().size);\r\n\t\tint i = 0;\r\n\t\tfor(Controller controller: Controllers.getControllers()) {\r\n\t\t\tprint(\"#\" + i++ + \": \" + controller.getName());\r\n\t\t}\r\n\t\tif(Controllers.getControllers().size == 0) print(\"No controllers attached\");\r\n\t\t\r\n\t\t// setup the listener that prints events to the console\r\n\t\tControllers.addListener(new ControllerListener() {\r\n\t\t\tpublic int indexOf(Controller controller) {\r\n\t\t\t\treturn Controllers.getControllers().indexOf(controller, true);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t@Override\r\n\t\t\tpublic void connected (Controller controller) {\r\n\t\t\t\tprint(\"connected \" + controller.getName());\r\n\t\t\t\tint i = 0;\r\n\t\t\t\tfor(Controller c: Controllers.getControllers()) {\r\n\t\t\t\t\tprint(\"#\" + i++ + \": \" + c.getName());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void disconnected (Controller controller) {\r\n\t\t\t\tprint(\"disconnected \" + controller.getName());\r\n\t\t\t\tint i = 0;\r\n\t\t\t\tfor(Controller c: Controllers.getControllers()) {\r\n\t\t\t\t\tprint(\"#\" + i++ + \": \" + c.getName());\r\n\t\t\t\t}\r\n\t\t\t\tif(Controllers.getControllers().size == 0) print(\"No controllers attached\");\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean buttonDown (Controller controller, int buttonIndex) {\r\n\t\t\t\tprint(\"#\" + indexOf(controller) + \", button \" + buttonIndex + \" down\");\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean buttonUp (Controller controller, int buttonIndex) {\r\n\t\t\t\tprint(\"#\" + indexOf(controller) + \", button \" + buttonIndex + \" up\");\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean axisMoved (Controller controller, int axisIndex, float value) {\r\n\t\t\t\tprint(\"#\" + indexOf(controller) + \", axis \" + axisIndex + \": \" + value);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean povMoved (Controller controller, int povIndex, PovDirection value) {\r\n\t\t\t\tprint(\"#\" + indexOf(controller) + \", pov \" + povIndex + \": \" + value);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean xSliderMoved (Controller controller, int sliderIndex, boolean value) {\r\n\t\t\t\tprint(\"#\" + indexOf(controller) + \", x slider \" + sliderIndex + \": \" + value);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean ySliderMoved (Controller controller, int sliderIndex, boolean value) {\r\n\t\t\t\tprint(\"#\" + indexOf(controller) + \", y slider \" + sliderIndex + \": \" + value);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean accelerometerMoved (Controller controller, int accelerometerIndex, Vector3 value) {\r\n\t\t\t\t// not printing this as we get to many values\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t});\r\n\t}","id":49924,"modified_method":"@Override\r\n\tpublic void create () {\r\n\t\tsetupUi();\r\n\t\t\r\n\t\t// print the currently connected controllers to the console\r\n\t\tprint(\"Controllers: \" + Controllers.getControllers().size);\r\n\t\tint i = 0;\r\n\t\tfor(Controller controller: Controllers.getControllers()) {\r\n\t\t\tprint(\"#\" + i++ + \": \" + controller.getName());\r\n\t\t}\r\n\t\tif(Controllers.getControllers().size == 0) print(\"No controllers attached\");\r\n\t\t\r\n\t\t// setup the listener that prints events to the console\r\n\t\tControllers.addListener(new ControllerListener() {\r\n\t\t\tpublic int indexOf(Controller controller) {\r\n\t\t\t\treturn Controllers.getControllers().indexOf(controller, true);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t@Override\r\n\t\t\tpublic void connected (Controller controller) {\r\n\t\t\t\tprint(\"connected \" + controller.getName());\r\n\t\t\t\tint i = 0;\r\n\t\t\t\tfor(Controller c: Controllers.getControllers()) {\r\n\t\t\t\t\tprint(\"#\" + i++ + \": \" + c.getName());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void disconnected (Controller controller) {\r\n\t\t\t\tprint(\"disconnected \" + controller.getName());\r\n\t\t\t\tint i = 0;\r\n\t\t\t\tfor(Controller c: Controllers.getControllers()) {\r\n\t\t\t\t\tprint(\"#\" + i++ + \": \" + c.getName());\r\n\t\t\t\t}\r\n\t\t\t\tif(Controllers.getControllers().size == 0) print(\"No controllers attached\");\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean buttonDown (Controller controller, int buttonIndex) {\r\n\t\t\t\tprint(\"#\" + indexOf(controller) + \", button \" + buttonIndex + \" down\");\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean buttonUp (Controller controller, int buttonIndex) {\r\n\t\t\t\tprint(\"#\" + indexOf(controller) + \", button \" + buttonIndex + \" up\");\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean axisMoved (Controller controller, int axisIndex, float value) {\r\n\t\t\t\tprint(\"#\" + indexOf(controller) + \", axis \" + axisIndex + \": \" + value);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean povMoved (Controller controller, int povIndex, PovDirection value) {\r\n\t\t\t\tprint(\"#\" + indexOf(controller) + \", pov \" + povIndex + \": \" + value);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean xSliderMoved (Controller controller, int sliderIndex, boolean value) {\r\n\t\t\t\tprint(\"#\" + indexOf(controller) + \", x slider \" + sliderIndex + \": \" + value);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean ySliderMoved (Controller controller, int sliderIndex, boolean value) {\r\n\t\t\t\tprint(\"#\" + indexOf(controller) + \", y slider \" + sliderIndex + \": \" + value);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic boolean accelerometerMoved (Controller controller, int accelerometerIndex, Vector3 value) {\r\n\t\t\t\t// not printing this as we get to many values\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t});\r\n\t}","commit_id":"71cc87409d60e4b2a3e1ad79f3081dd3f63855ef","url":"https://github.com/libgdx/libgdx"},{"original_method":"public MainMenu () {\r\n\t\tspriteBatch = new SpriteBatch();\r\n\t\tbackground = new Texture(Gdx.files.internal(\"data/planet.jpg\"));\r\n\t\tbackground.setFilter(TextureFilter.Linear, TextureFilter.Linear);\r\n\r\n\t\tlogo = new Texture(Gdx.files.internal(\"data/title.png\"));\r\n\t\tlogo.setFilter(TextureFilter.Linear, TextureFilter.Linear);\r\n\r\n\t\tfont = new BitmapFont(Gdx.files.internal(\"data/font16.fnt\"), Gdx.files.internal(\"data/font16.png\"), false);\r\n\t\t\r\n\t\t// check for attached controllers and if we are on\r\n\t\t// Ouya.\r\n\t\tif(Controllers.getControllers().size > 0) {\r\n\t\t\tController controller = Controllers.getControllers().get(0);\r\n\t\t\tif(controller.getName().toLowerCase().contains(\"ouya\")) {\r\n\t\t\t\tcontroller.addListener(new ControllerAdapter() {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic boolean buttonUp (Controller controller, int buttonIndex) {\r\n\t\t\t\t\t\tisDone = true;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":49925,"modified_method":"public MainMenu () {\r\n\t\tspriteBatch = new SpriteBatch();\r\n\t\tbackground = new Texture(Gdx.files.internal(\"data/planet.jpg\"));\r\n\t\tbackground.setFilter(TextureFilter.Linear, TextureFilter.Linear);\r\n\r\n\t\tlogo = new Texture(Gdx.files.internal(\"data/title.png\"));\r\n\t\tlogo.setFilter(TextureFilter.Linear, TextureFilter.Linear);\r\n\r\n\t\tfont = new BitmapFont(Gdx.files.internal(\"data/font16.fnt\"), Gdx.files.internal(\"data/font16.png\"), false);\r\n\t\t\r\n\t\t// check for attached controllers and if we are on\r\n\t\t// Ouya.\r\n\t\tif(Controllers.getControllers().size > 0) {\r\n\t\t\tController controller = Controllers.getControllers().get(0);\r\n\t\t\tif(Ouya.ID.equals(controller.getName())) {\r\n\t\t\t\tcontroller.addListener(new ControllerAdapter() {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic boolean buttonUp (Controller controller, int buttonIndex) {\r\n\t\t\t\t\t\tisDone = true;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"71cc87409d60e4b2a3e1ad79f3081dd3f63855ef","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void checkNextLevel () {\r\n\t\tif (invaders.size() == 0 && ship.lives > 0) {\r\n\t\t\tblocks.clear();\r\n\t\t\tshots.clear();\r\n\t\t\tshipShot = null;\r\n\t\t\tVector3 shipPosition = ship.position;\r\n\t\t\tint lives = ship.lives;\r\n\t\t\tpopulate();\r\n\t\t\tship.position.set(shipPosition);\r\n\t\t\tship.lives = lives;\r\n\t\t\tmultiplier += 0.1f;\r\n\t\t\twave++;\r\n\t\t}\r\n\t}","id":49926,"modified_method":"private void checkNextLevel () {\r\n\t\tif (invaders.size() == 0 && ship.lives > 0) {\r\n\t\t\tblocks.clear();\r\n\t\t\tshots.clear();\r\n\t\t\tshipShot = null;\r\n\t\t\tVector3 shipPosition = ship.position;\r\n\t\t\tint lives = ship.lives;\r\n\t\t\tpopulate();\r\n\t\t\tship.position.set(shipPosition);\r\n\t\t\tship.lives = lives;\r\n\t\t\tmultiplier += 0.2f;\r\n\t\t\twave++;\r\n\t\t}\r\n\t}","commit_id":"71cc87409d60e4b2a3e1ad79f3081dd3f63855ef","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n     * Imports Xpp3Dom and associated types into the specified realm. Unlike the other archives that constitute the API\n     * realm, plexus-utils is not excluded from the plugin/project realm, yet we must ensure this class is loaded from\n     * the API realm and not from the plugin/project realm.\n     * \n     * @param importingRealm The realm into which to import Xpp3Dom, must not be {@code null}.\n     */\n    private void importXpp3Dom( ClassRealm importingRealm )\n    {\n        String coreRealmId = container.getContainerRealm().getId();\n        try\n        {\n            importingRealm.importFrom( coreRealmId, \"org.codehaus.plexus.util.xml.Xpp3Dom\" );\n            importingRealm.importFrom( coreRealmId, \"org.codehaus.plexus.util.xml.pull.XmlPullParser\" );\n            importingRealm.importFrom( coreRealmId, \"org.codehaus.plexus.util.xml.pull.XmlPullParserException\" );\n            importingRealm.importFrom( coreRealmId, \"org.codehaus.plexus.util.xml.pull.XmlSerializer\" );\n        }\n        catch ( NoSuchRealmException e )\n        {\n            throw new IllegalStateException( e );\n        }\n    }","id":49927,"modified_method":"/**\n     * Imports Xpp3Dom and associated types into the specified realm. Unlike the other archives that constitute the API\n     * realm, plexus-utils is not excluded from the plugin/project realm, yet we must ensure this class is loaded from\n     * the API realm and not from the plugin/project realm.\n     * \n     * @param importingRealm The realm into which to import Xpp3Dom, must not be {@code null}.\n     */\n    private void importXpp3Dom( ClassRealm importingRealm )\n    {\n        ClassRealm coreRealm = container.getContainerRealm();\n\n        importingRealm.importFrom( coreRealm, \"org.codehaus.plexus.util.xml.Xpp3Dom\" );\n        importingRealm.importFrom( coreRealm, \"org.codehaus.plexus.util.xml.pull.XmlPullParser\" );\n        importingRealm.importFrom( coreRealm, \"org.codehaus.plexus.util.xml.pull.XmlPullParserException\" );\n        importingRealm.importFrom( coreRealm, \"org.codehaus.plexus.util.xml.pull.XmlSerializer\" );\n    }","commit_id":"49e73d3ff615add1634c80bc161b08dc7c5afda9","url":"https://github.com/apache/maven"},{"original_method":"private ClassRealm createRealm( String baseRealmId )\n    {\n        ClassWorld world = getClassWorld();\n\n        String realmId = baseRealmId;\n\n        Random random = new Random();\n\n        synchronized ( world )\n        {\n            ClassRealm classRealm;\n\n            while ( true )\n            {\n                try\n                {\n                    classRealm = world.newRealm( realmId );\n\n                    if ( logger.isDebugEnabled() )\n                    {\n                        logger.debug( \"Created new class realm \" + realmId );\n                    }\n\n                    break;\n                }\n                catch ( DuplicateRealmException e )\n                {\n                    realmId = baseRealmId + '-' + random.nextInt();\n                }\n            }\n\n            classRealm.setParentRealm( getApiRealm() );\n\n            importXpp3Dom( classRealm );\n\n            return classRealm;\n        }\n    }","id":49928,"modified_method":"private ClassRealm createRealm( String baseRealmId )\n    {\n        ClassWorld world = getClassWorld();\n\n        String realmId = baseRealmId;\n\n        Random random = new Random();\n\n        synchronized ( world )\n        {\n            ClassRealm classRealm;\n\n            while ( true )\n            {\n                try\n                {\n                    classRealm = world.newRealm( realmId );\n\n                    if ( logger.isDebugEnabled() )\n                    {\n                        logger.debug( \"Created new class realm \" + realmId );\n                    }\n\n                    break;\n                }\n                catch ( DuplicateRealmException e )\n                {\n                    realmId = baseRealmId + '-' + random.nextInt();\n                }\n            }\n\n            classRealm.setParentRealm( container.getContainerRealm() );\n\n            importXpp3Dom( classRealm );\n\n            importMavenApi( classRealm );\n\n            return classRealm;\n        }\n    }","commit_id":"49e73d3ff615add1634c80bc161b08dc7c5afda9","url":"https://github.com/apache/maven"},{"original_method":"@Nullable\n  public String getSelectedColorName() {\n    ColorButton button = getSelectedButtonInner();\n    return button == null? null : button instanceof CustomColorButton ? ColorUtil.toHex(button.getColor()) : button.getText();\n  }","id":49929,"modified_method":"@Nullable\n  public String getSelectedColorName() {\n    for (String name : myColorToButtonMap.keySet()) {\n      ColorButton button = myColorToButtonMap.get(name);\n      if (!button.isSelected()) continue;\n      if (button instanceof CustomColorButton) return ColorUtil.toHex(button.getColor());\n      return name;\n    }\n    return null;\n  }","commit_id":"decd8d737241dce886e462940629924fe9d0f1d8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Color getSelectedColor() {\n    ColorButton button = getSelectedButtonInner();\n    return button == null? null : button.getColor();\n  }","id":49930,"modified_method":"@Nullable\n  public Color getSelectedColor() {\n    for (String name : myColorToButtonMap.keySet()) {\n      ColorButton button = myColorToButtonMap.get(name);\n      if (!button.isSelected()) continue;\n      return button.getColor();\n    }\n    return null;\n  }","commit_id":"decd8d737241dce886e462940629924fe9d0f1d8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String buildHtml(@NotNull final Notification notification, @Nullable String style) {\n    String result = \"\";\n    if (style != null) {\n      result += \"<div style=\\\"\" + style + \"\\\">\";\n    }\n    result += \"<b color=\\\"#\"+ ColorUtil.toHex(getMessageType(notification).getTitleForeground())+\"\\\">\" + notification.getTitle() + \"<\/b>\" +\n              \"<p>\" + notification.getContent() + \"<\/p>\";\n    if (style != null) {\n      result += \"<\/div>\";\n    }\n    return XmlStringUtil.wrapInHtml(result);\n  }","id":49931,"modified_method":"public static String buildHtml(@NotNull final Notification notification, @Nullable String style) {\n    String title = notification.getTitle();\n    String content = notification.getContent();\n    if (title.length() > TITLE_LIMIT || content.length() > CONTENT_LIMIT) {\n      LOG.info(\"Too large notification \" + notification + \" of \" + notification.getClass() +\n               \"\\nListener=\" + notification.getListener() +\n               \"\\nTitle=\" + title +\n               \"\\nContent=\" + content);\n      title = StringUtil.trimLog(title, TITLE_LIMIT);\n      content = StringUtil.trimLog(content, CONTENT_LIMIT);\n    }\n    return buildHtml(title, content, style, \"#\" + ColorUtil.toHex(getMessageType(notification).getTitleForeground()));\n  }","commit_id":"75f7c3e251736e0d7cf457be45df2caf7a3daef2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String buildHtml(@NotNull final String title, @NotNull final String content, @Nullable String style) {\n    String result = \"\";\n    if (style != null) {\n      result += \"<div style=\\\"\" + style + \"\\\">\";\n    }\n    result += \"<b>\" + title + \"<\/b><p>\" + content + \"<\/p>\";\n    if (style != null) {\n      result += \"<\/div>\";\n    }\n    return XmlStringUtil.wrapInHtml(result);\n  }","id":49932,"modified_method":"public static String buildHtml(@NotNull final String title, @NotNull final String content, @Nullable String style) {\n    return buildHtml(title, content, style, null);\n  }","commit_id":"75f7c3e251736e0d7cf457be45df2caf7a3daef2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Icon getIcon(@NotNull final Notification notification) {\n    Icon icon = notification.getIcon();\n\n    if (icon == null) {\n      icon = getMessageType(notification).getDefaultIcon();\n    }\n\n    return icon;\n  }","id":49933,"modified_method":"public static Icon getIcon(@NotNull final Notification notification) {\n    Icon icon = notification.getIcon();\n    return icon != null ? icon : getMessageType(notification).getDefaultIcon();\n  }","commit_id":"75f7c3e251736e0d7cf457be45df2caf7a3daef2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getSelectedColorName() {\n    for (String name : myColorToButtonMap.keySet()) {\n      ColorButton button = myColorToButtonMap.get(name);\n      if (!button.isSelected()) continue;\n      if (button instanceof CustomColorButton) return ColorUtil.toHex(button.getColor());\n      return name;\n    }\n    return null;\n  }","id":49934,"modified_method":"@Nullable\n  public String getSelectedColorName() {\n    for (String name : myColorToButtonMap.keySet()) {\n      ColorButton button = myColorToButtonMap.get(name);\n      if (!button.isSelected()) continue;\n      if (button instanceof CustomColorButton) {\n        final String color = ColorUtil.toHex(button.getColor());\n        String colorName  = findColorName(button.getColor());\n        return colorName == null ? color : colorName;\n      }\n      return name;\n    }\n    return null;\n  }","commit_id":"69c0175b3e76cbccc6237bddedb9f8f07eee1bee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateCustomButton() {\n    final Object item = myScopeComboBox.getSelectedItem();\n    if (item instanceof String) {\n      Color color = myConfiguration == null ? null : ColorUtil.fromHex(myConfiguration.getColorName(), null);\n      if (color == null) {\n        color = ColorUtil.getColor(myScopeNames.get(item).getClass());\n      }\n      if (color != null) myColorSelectionComponent.setCustomButtonColor(color);\n    }\n  }","id":49935,"modified_method":"private void updateCustomButton() {\n    final Object item = myScopeComboBox.getSelectedItem();\n    if (item instanceof String) {\n      Color color = myConfiguration == null ? null : ColorUtil.fromHex(myConfiguration.getColorName(), null);\n      if (color == null) {\n        color = ColorUtil.getColor(myScopeNames.get(item).getClass());\n      }\n      if (color != null) {\n        final String colorName = ColorSelectionComponent.findColorName(color);\n        if (colorName != null) {\n          myColorSelectionComponent.setSelectedColor(colorName);\n        } else {\n          myColorSelectionComponent.setCustomButtonColor(color);\n        }\n      }\n    }\n  }","commit_id":"69c0175b3e76cbccc6237bddedb9f8f07eee1bee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @SuppressWarnings({\"MethodMayBeStatic\"})\n  @Nullable\n  public Color getColor(@NotNull final String name) {\n    Color color = ourDefaultColors.get(name);\n    return color == null ? ColorUtil.fromHex(name, null) : color;\n  }","id":49936,"modified_method":"@Override\n  @SuppressWarnings({\"MethodMayBeStatic\"})\n  @Nullable\n  public Color getColor(@NotNull final String name) {\n    Color color = ourDefaultColors.get(name);\n    if (color != null) {\n      return color;\n    }\n\n    if (\"ffffe4\".equals(name) || \"494539\".equals(name)) {\n      return new JBColor(0xffffe4, 0x494539);\n    }\n\n    if (\"e7fadb\".equals(name) || \"2a3b2c\".equals(name)) {\n      return new JBColor(0xe7fadb, 0x2a3b2c);\n    }\n\n    return ColorUtil.fromHex(name, null);\n\n  }","commit_id":"69c0175b3e76cbccc6237bddedb9f8f07eee1bee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n    public void testResourceAdapters() throws Exception {\n\n        ModelNode model = getModel(\"ra.xml\", \"some.rar\");\n        if (model == null)\n            return;\n        // Check model..\n        Properties params = ParseUtils.raCommonProperties();\n        ModelNode raCommonModel = model.get(\"subsystem\", \"resource-adapters\", \"resource-adapter\", \"some.rar\");\n        ParseUtils.checkModelParams(raCommonModel, params);\n        Assert.assertEquals(raCommonModel.asString(), \"A\", raCommonModel.get(\"config-properties\", \"Property\", \"value\")\n                .asString());\n        Assert.assertEquals(raCommonModel.get(\"beanvalidationgroups\").asString(), raCommonModel.get(\"beanvalidationgroups\")\n                .asString(), \"[\\\"Class0\\\",\\\"Class00\\\"]\");\n\n        params = ParseUtils.raAdminProperties();\n        ModelNode raAdminModel = raCommonModel.get(\"admin-objects\", \"Pool2\");\n        ParseUtils.checkModelParams(raAdminModel, params);\n        Assert.assertEquals(raAdminModel.asString(), \"D\", raAdminModel.get(\"config-properties\", \"Property\", \"value\").asString());\n\n        params = ParseUtils.raConnectionProperties();\n        ModelNode raConnModel = raCommonModel.get(\"connection-definitions\", \"Pool1\");\n        ParseUtils.checkModelParams(raConnModel, params);\n        Assert.assertEquals(raConnModel.asString(), \"B\", raConnModel.get(\"config-properties\", \"Property\", \"value\").asString());\n        Assert.assertEquals(raConnModel.asString(), \"C\", raConnModel.get(\"recovery-plugin-properties\", \"Property\").asString());\n    }","id":49937,"modified_method":"@Test\n    public void testResourceAdapters() throws Exception {\n\n        ModelNode model = getModel(\"ra.xml\", \"some.rar\");\n        if (model == null)\n            return;\n        // Check model..\n        Properties params = ParseUtils.raCommonProperties();\n        ModelNode raCommonModel = model.get(\"subsystem\", \"resource-adapters\", \"resource-adapter\", \"myRA\");\n        ParseUtils.checkModelParams(raCommonModel, params);\n        Assert.assertEquals(raCommonModel.asString(), \"A\", raCommonModel.get(\"config-properties\", \"Property\", \"value\")\n                .asString());\n        Assert.assertEquals(raCommonModel.get(\"beanvalidationgroups\").asString(), raCommonModel.get(\"beanvalidationgroups\")\n                .asString(), \"[\\\"Class0\\\",\\\"Class00\\\"]\");\n\n        params = ParseUtils.raAdminProperties();\n        ModelNode raAdminModel = raCommonModel.get(\"admin-objects\", \"Pool2\");\n        ParseUtils.checkModelParams(raAdminModel, params);\n        Assert.assertEquals(raAdminModel.asString(), \"D\", raAdminModel.get(\"config-properties\", \"Property\", \"value\").asString());\n\n        params = ParseUtils.raConnectionProperties();\n        ModelNode raConnModel = raCommonModel.get(\"connection-definitions\", \"Pool1\");\n        ParseUtils.checkModelParams(raConnModel, params);\n        Assert.assertEquals(raConnModel.asString(), \"B\", raConnModel.get(\"config-properties\", \"Property\", \"value\").asString());\n        Assert.assertEquals(raConnModel.asString(), \"C\", raConnModel.get(\"recovery-plugin-properties\", \"Property\").asString());\n    }","commit_id":"b09fcae878c3504dda10343bde28b71864590212","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void performRuntime(final OperationContext context, ModelNode operation, ModelNode model, final ServiceVerificationHandler verificationHandler,\n                               final List<ServiceController<?>> controllers) throws OperationFailedException {\n        // Compensating is remove\n        final ModelNode address = operation.require(OP_ADDR);\n        final String name = PathAddress.pathAddress(address).getLastElement().getValue();\n        String archiveOrModuleName;\n        if (model.get(ARCHIVE.getName()).isDefined()) {\n            archiveOrModuleName = model.get(ARCHIVE.getName()).asString();\n        } else {\n            archiveOrModuleName = model.get(MODULE.getName()).asString();\n        }\n\n        if (name.startsWith(archiveOrModuleName) && (name.substring(archiveOrModuleName.length()).contains(ConnectorServices.RA_SERVICE_NAME_SEPARATOR) || name.equals(archiveOrModuleName))) {\n            archiveOrModuleName = name;\n        } else {\n           Integer identifier = ConnectorServices.getResourceIdentifier(archiveOrModuleName);\n            if (identifier != null && identifier != 0) {\n                archiveOrModuleName = archiveOrModuleName + ConnectorServices.RA_SERVICE_NAME_SEPARATOR + identifier;\n            }\n        }\n\n        if (model.get(ARCHIVE.getName()).isDefined()) {\n            model.get(ARCHIVE.getName()).set(archiveOrModuleName);\n        } else {\n            model.get(MODULE.getName()).set(archiveOrModuleName);\n        }\n\n        ModifiableResourceAdapter resourceAdapter = RaOperationUtil.buildResourceAdaptersObject(context, operation, archiveOrModuleName);\n\n        if (model.get(ARCHIVE.getName()).isDefined()) {\n            RaOperationUtil.installRaServices(context, verificationHandler, name, resourceAdapter);\n        } else {\n            RaOperationUtil.installRaServicesAndDeployFromModule(context, verificationHandler, name, resourceAdapter, archiveOrModuleName);\n        }\n\n\n    }","id":49938,"modified_method":"@Override\n    public void performRuntime(final OperationContext context, ModelNode operation, ModelNode model, final ServiceVerificationHandler verificationHandler,\n                               final List<ServiceController<?>> controllers) throws OperationFailedException {\n        // Compensating is remove\n        final ModelNode address = operation.require(OP_ADDR);\n        final String name = PathAddress.pathAddress(address).getLastElement().getValue();\n        String archiveOrModuleName;\n        if (!model.hasDefined(ARCHIVE.getName()) && ! model.hasDefined(MODULE.getName())) {\n            throw ConnectorMessages.MESSAGES.archiveOrModuleRequired();\n        }\n        if (model.get(ARCHIVE.getName()).isDefined()) {\n            archiveOrModuleName = model.get(ARCHIVE.getName()).asString();\n        } else {\n            archiveOrModuleName = model.get(MODULE.getName()).asString();\n        }\n\n\n        ModifiableResourceAdapter resourceAdapter = RaOperationUtil.buildResourceAdaptersObject(context, operation, archiveOrModuleName);\n\n        if (model.get(ARCHIVE.getName()).isDefined()) {\n            RaOperationUtil.installRaServices(context, verificationHandler, name, resourceAdapter);\n        } else {\n            RaOperationUtil.installRaServicesAndDeployFromModule(context, verificationHandler, name, resourceAdapter, archiveOrModuleName);\n        }\n\n\n    }","commit_id":"b09fcae878c3504dda10343bde28b71864590212","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void activate(OperationContext context, String raName, String rarName, final ServiceVerificationHandler serviceVerificationHandler) throws OperationFailedException {\n        ServiceRegistry registry = context.getServiceRegistry(true);\n        if (rarName.contains(ConnectorServices.RA_SERVICE_NAME_SEPARATOR)) {\n            rarName = rarName.substring(0, rarName.indexOf(ConnectorServices.RA_SERVICE_NAME_SEPARATOR));\n        }\n        final ServiceController<?> inactiveRaController = registry.getService(ConnectorServices.INACTIVE_RESOURCE_ADAPTER_SERVICE.append(rarName));\n        if (inactiveRaController == null) {\n            throw new OperationFailedException(\"rar not yet deployed\");\n        }\n        InactiveResourceAdapterDeploymentService.InactiveResourceAdapterDeployment inactive = (InactiveResourceAdapterDeploymentService.InactiveResourceAdapterDeployment) inactiveRaController.getValue();\n        final ServiceController<?> RaxmlController = registry.getService(ServiceName.of(ConnectorServices.RA_SERVICE, raName));\n\n        ResourceAdapter raxml = (ResourceAdapter) RaxmlController.getValue();\n        RaServicesFactory.createDeploymentService(inactive.getRegistration(), inactive.getConnectorXmlDescriptor(), inactive.getModule(), inactive.getServiceTarget(), raName, inactive.getDeploymentUnitServiceName(), inactive.getDeployment(), raxml, inactive.getResource(), serviceVerificationHandler);\n    }","id":49939,"modified_method":"public static void activate(OperationContext context, String raName, String rarName, final ServiceVerificationHandler serviceVerificationHandler) throws OperationFailedException {\n        ServiceRegistry registry = context.getServiceRegistry(true);\n        if (rarName.contains(ConnectorServices.RA_SERVICE_NAME_SEPARATOR)) {\n            rarName = rarName.substring(0, rarName.indexOf(ConnectorServices.RA_SERVICE_NAME_SEPARATOR));\n        }\n        final ServiceController<?> inactiveRaController = registry.getService(ConnectorServices.INACTIVE_RESOURCE_ADAPTER_SERVICE.append(raName));\n        if (inactiveRaController == null) {\n            throw new OperationFailedException(\"rar not yet deployed\");\n        }\n        InactiveResourceAdapterDeploymentService.InactiveResourceAdapterDeployment inactive = (InactiveResourceAdapterDeploymentService.InactiveResourceAdapterDeployment) inactiveRaController.getValue();\n        final ServiceController<?> RaxmlController = registry.getService(ServiceName.of(ConnectorServices.RA_SERVICE, raName));\n\n        ResourceAdapter raxml = (ResourceAdapter) RaxmlController.getValue();\n        RaServicesFactory.createDeploymentService(inactive.getRegistration(), inactive.getConnectorXmlDescriptor(), inactive.getModule(), inactive.getServiceTarget(), raName, inactive.getDeploymentUnitServiceName(), inactive.getDeployment(), raxml, inactive.getResource(), serviceVerificationHandler);\n    }","commit_id":"b09fcae878c3504dda10343bde28b71864590212","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static boolean deactivateIfActive(OperationContext context, String raName) throws OperationFailedException {\n        boolean wasActive = false;\n        final ServiceName raDeploymentServiceName = ConnectorServices.getDeploymentServiceName(raName);\n        Integer identifier = 0;\n        if (raName.contains(\"->\")) {\n            identifier = Integer.valueOf(raName.substring(raName.indexOf(\"->\") + 2));\n            raName = raName.substring(0, raName.indexOf(\"->\"));\n        }\n        if (raDeploymentServiceName != null) {\n            context.removeService(raDeploymentServiceName);\n            ConnectorServices.unregisterDeployment(raName, raDeploymentServiceName);\n            wasActive = true;\n        }\n        ConnectorServices.unregisterResourceIdentifier(raName, identifier);\n\n        ServiceName deploymentServiceName = ConnectorServices.getDeploymentServiceName(raName);\n\n        return wasActive;\n\n    }","id":49940,"modified_method":"public static boolean deactivateIfActive(OperationContext context, String raName) throws OperationFailedException {\n        boolean wasActive = false;\n        final ServiceName raDeploymentServiceName = ConnectorServices.getDeploymentServiceName(raName);\n        Integer identifier = 0;\n        if (raName.contains(\"->\")) {\n            identifier = Integer.valueOf(raName.substring(raName.indexOf(\"->\") + 2));\n            raName = raName.substring(0, raName.indexOf(\"->\"));\n        }\n        if (raDeploymentServiceName != null) {\n            context.removeService(raDeploymentServiceName);\n            ConnectorServices.unregisterDeployment(raName, raDeploymentServiceName);\n            wasActive = true;\n        }\n        ConnectorServices.unregisterResourceIdentifier(raName, identifier);\n\n        return wasActive;\n\n    }","commit_id":"b09fcae878c3504dda10343bde28b71864590212","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void installRaServicesAndDeployFromModule(OperationContext context, ServiceVerificationHandler verificationHandler, String name, ModifiableResourceAdapter resourceAdapter, String moduleName) throws OperationFailedException{\n        ServiceName raServiceName =  installRaServices(context, verificationHandler, name, resourceAdapter);\n        final boolean resolveProperties = true;\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        String deploymentName = moduleName;//.substring(0, deploymentRoot.getName().indexOf(\".rar\"));\n\n        if (moduleName.contains(\"->\")) {\n            moduleName = moduleName.substring(0, moduleName.indexOf(\"->\"));\n        }\n        //load module\n        String slot = \"main\";\n        if (moduleName.contains(\":\")) {\n            slot = moduleName.substring(moduleName.indexOf(\":\") + 1);\n            moduleName = moduleName.substring(0, moduleName.indexOf(\":\"));\n        }\n\n        Module module;\n        try {\n            ModuleIdentifier moduleId = ModuleIdentifier.create(moduleName, slot);\n            module = Module.getCallerModuleLoader().loadModule(moduleId);\n        } catch (ModuleLoadException e) {\n            throw new OperationFailedException(MESSAGES.failedToLoadModuleRA(moduleName), e);\n        }\n        URL path = module.getExportedResource(\"META-INF/ra.xml\");\n        Closeable closable = null;\n            try {\n                VirtualFile child;\n                if (path.getPath().contains(\"!\")) {\n                    child = VFS.getChild(path.getPath().split(\"!\")[0].split(\"file:\")[1]);\n\n                    closable = VFS.mountZip(new File(path.getPath().split(\"!\")[0].split(\"file:\")[1]), child, TempFileProviderService.provider());\n                } else {\n                    child = VFS.getChild(path.getPath().split(\"META-INF\")[0]);\n\n                    closable = VFS.mountReal(new File(path.getPath().split(\"META-INF\")[0]), child);\n                }\n                //final Closeable closable = VFS.mountZip((InputStream) new JarInputStream(new FileInputStream(path.getPath().split(\"!\")[0].split(\":\")[1])), path.getPath().split(\"!\")[0].split(\":\")[1], child, TempFileProviderService.provider());\n\n                final MountHandle mountHandle = new MountHandle(closable);\n                final ResourceRoot resourceRoot = new ResourceRoot(child, mountHandle);\n\n                final VirtualFile deploymentRoot = resourceRoot.getRoot();\n                if (deploymentRoot == null || !deploymentRoot.exists())\n                    return;\n                ConnectorXmlDescriptor connectorXmlDescriptor = RaDeploymentParsingProcessor.process(resolveProperties, deploymentRoot, null, deploymentName);\n                IronJacamarXmlDescriptor ironJacamarXmlDescriptor = IronJacamarDeploymentParsingProcessor.process(deploymentRoot, resolveProperties);\n                RaNativeProcessor.process(deploymentRoot);\n                Map<ResourceRoot, Index> annotationIndexes = new HashMap<ResourceRoot, Index>();\n                ResourceRootIndexer.indexResourceRoot(resourceRoot);\n                Index index = resourceRoot.getAttachment(Attachments.ANNOTATION_INDEX);\n                if (index != null) {\n                    annotationIndexes.put(resourceRoot, index);\n                }\n                if (ironJacamarXmlDescriptor != null) {\n                    ConnectorLogger.SUBSYSTEM_RA_LOGGER.forceIJToNull();\n                    ironJacamarXmlDescriptor = null;\n                }\n                ServiceBuilder builder = ParsedRaDeploymentProcessor.process(connectorXmlDescriptor, ironJacamarXmlDescriptor, module.getClassLoader(), serviceTarget, annotationIndexes, RAR_MODULE.append(deploymentName), verificationHandler);\n                builder.addDependency(raServiceName).setInitialMode(ServiceController.Mode.ACTIVE).install();\n                String rarName = resourceAdapter.getArchive();\n                Integer identifier = null;\n                if (rarName.contains(ConnectorServices.RA_SERVICE_NAME_SEPARATOR)) {\n                    rarName = rarName.substring(0, rarName.indexOf(ConnectorServices.RA_SERVICE_NAME_SEPARATOR));\n                }\n                if (deploymentName.equals(rarName)) {\n                    RaServicesFactory.createDeploymentService(connectorXmlDescriptor, module, serviceTarget, deploymentName, RAR_MODULE.append(deploymentName), resourceAdapter, verificationHandler);\n\n\n                }\n\n            } catch (Exception e) {\n                throw new OperationFailedException(MESSAGES.failedToLoadModuleRA(moduleName), e);\n            } finally {\n                if (closable != null) {\n                    try {\n                        closable.close();\n                    } catch (IOException e) {\n\n                    }\n                }\n            }\n\n\n    }","id":49941,"modified_method":"public static void installRaServicesAndDeployFromModule(OperationContext context, ServiceVerificationHandler verificationHandler, String name, ModifiableResourceAdapter resourceAdapter, String fullModuleName) throws OperationFailedException{\n        ServiceName raServiceName =  installRaServices(context, verificationHandler, name, resourceAdapter);\n        final boolean resolveProperties = true;\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final String moduleName;\n\n\n        //load module\n        String slot = \"main\";\n        if (fullModuleName.contains(\":\")) {\n            slot = fullModuleName.substring(fullModuleName.indexOf(\":\") + 1);\n            moduleName = fullModuleName.substring(0, fullModuleName.indexOf(\":\"));\n        } else {\n            moduleName = fullModuleName;\n        }\n\n        Module module;\n        try {\n            ModuleIdentifier moduleId = ModuleIdentifier.create(moduleName, slot);\n            module = Module.getCallerModuleLoader().loadModule(moduleId);\n        } catch (ModuleLoadException e) {\n            throw new OperationFailedException(MESSAGES.failedToLoadModuleRA(moduleName), e);\n        }\n        URL path = module.getExportedResource(\"META-INF/ra.xml\");\n        Closeable closable = null;\n            try {\n                VirtualFile child;\n                if (path.getPath().contains(\"!\")) {\n                    throw new OperationFailedException(MESSAGES.compressedRarNotSupportedInModuleRA(moduleName));\n                } else {\n                    child = VFS.getChild(path.getPath().split(\"META-INF\")[0]);\n\n                    closable = VFS.mountReal(new File(path.getPath().split(\"META-INF\")[0]), child);\n                }\n                //final Closeable closable = VFS.mountZip((InputStream) new JarInputStream(new FileInputStream(path.getPath().split(\"!\")[0].split(\":\")[1])), path.getPath().split(\"!\")[0].split(\":\")[1], child, TempFileProviderService.provider());\n\n                final MountHandle mountHandle = new MountHandle(closable);\n                final ResourceRoot resourceRoot = new ResourceRoot(child, mountHandle);\n\n                final VirtualFile deploymentRoot = resourceRoot.getRoot();\n                if (deploymentRoot == null || !deploymentRoot.exists())\n                    return;\n                ConnectorXmlDescriptor connectorXmlDescriptor = RaDeploymentParsingProcessor.process(resolveProperties, deploymentRoot, null, name);\n                IronJacamarXmlDescriptor ironJacamarXmlDescriptor = IronJacamarDeploymentParsingProcessor.process(deploymentRoot, resolveProperties);\n                RaNativeProcessor.process(deploymentRoot);\n                Map<ResourceRoot, Index> annotationIndexes = new HashMap<ResourceRoot, Index>();\n                ResourceRootIndexer.indexResourceRoot(resourceRoot);\n                Index index = resourceRoot.getAttachment(Attachments.ANNOTATION_INDEX);\n                if (index != null) {\n                    annotationIndexes.put(resourceRoot, index);\n                }\n                if (ironJacamarXmlDescriptor != null) {\n                    ConnectorLogger.SUBSYSTEM_RA_LOGGER.forceIJToNull();\n                    ironJacamarXmlDescriptor = null;\n                }\n                final ServiceName deployerServiceName = ConnectorServices.RESOURCE_ADAPTER_DEPLOYER_SERVICE_PREFIX.append(connectorXmlDescriptor.getDeploymentName());\n                final ServiceController<?> deployerService = context.getServiceRegistry(true).getService(deployerServiceName);\n                if (deployerService == null) {\n                    ServiceBuilder builder = ParsedRaDeploymentProcessor.process(connectorXmlDescriptor, ironJacamarXmlDescriptor, module.getClassLoader(), serviceTarget, annotationIndexes, RAR_MODULE.append(name), verificationHandler);\n                    builder.addDependency(raServiceName).setInitialMode(ServiceController.Mode.ACTIVE).install();\n                }\n                String rarName = resourceAdapter.getArchive();\n\n                if (fullModuleName.equals(rarName)) {\n\n                    ServiceName serviceName = ConnectorServices.INACTIVE_RESOURCE_ADAPTER_SERVICE.append(name);\n\n                    InactiveResourceAdapterDeploymentService service = new InactiveResourceAdapterDeploymentService(connectorXmlDescriptor, module, name, name, RAR_MODULE.append(name), null, serviceTarget, null);\n                    ServiceBuilder builder = serviceTarget\n                            .addService(serviceName, service);\n                    builder.setInitialMode(ServiceController.Mode.ACTIVE).install();\n\n                }\n\n            } catch (Exception e) {\n                throw new OperationFailedException(MESSAGES.failedToLoadModuleRA(moduleName), e);\n            } finally {\n                if (closable != null) {\n                    try {\n                        closable.close();\n                    } catch (IOException e) {\n\n                    }\n                }\n            }\n\n\n    }","commit_id":"b09fcae878c3504dda10343bde28b71864590212","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ServiceName installRaServices(OperationContext context, ServiceVerificationHandler verificationHandler, String name, ModifiableResourceAdapter resourceAdapter) {\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n        final ServiceController<?> resourceAdaptersService = context.getServiceRegistry(false).getService(\n                ConnectorServices.RESOURCEADAPTERS_SERVICE);\n        ServiceController<?> controller = null;\n        if (resourceAdaptersService == null) {\n            controller = serviceTarget.addService(ConnectorServices.RESOURCEADAPTERS_SERVICE,\n                    new ResourceAdaptersService()).setInitialMode(ServiceController.Mode.ACTIVE).addListener(verificationHandler).install();\n        }\n        ServiceName raServiceName = ServiceName.of(ConnectorServices.RA_SERVICE, name);\n        String bootStrapCtxName = DEFAULT_NAME;\n        if (resourceAdapter.getBootstrapContext() != null && ! resourceAdapter.getBootstrapContext().equals(\"undefined\")) {\n            bootStrapCtxName = resourceAdapter.getBootstrapContext();\n        }\n        ResourceAdapterService raService = new ResourceAdapterService(resourceAdapter);\n        serviceTarget.addService(raServiceName, raService).setInitialMode(ServiceController.Mode.ACTIVE)\n                .addDependency(ConnectorServices.RESOURCEADAPTERS_SERVICE, ResourceAdaptersService.ModifiableResourceAdaptors.class, raService.getResourceAdaptersInjector())\n                .addDependency(ConnectorServices.BOOTSTRAP_CONTEXT_SERVICE.append(bootStrapCtxName))\n                .addListener(verificationHandler).install();\n        return raServiceName;\n    }","id":49942,"modified_method":"public static ServiceName installRaServices(OperationContext context, ServiceVerificationHandler verificationHandler, String name, ModifiableResourceAdapter resourceAdapter) {\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n        final ServiceController<?> resourceAdaptersService = context.getServiceRegistry(false).getService(\n                ConnectorServices.RESOURCEADAPTERS_SERVICE);\n        ServiceController<?> controller = null;\n        if (resourceAdaptersService == null) {\n            controller = serviceTarget.addService(ConnectorServices.RESOURCEADAPTERS_SERVICE,\n                    new ResourceAdaptersService()).setInitialMode(ServiceController.Mode.ACTIVE).addListener(verificationHandler).install();\n        }\n        ServiceName raServiceName = ServiceName.of(ConnectorServices.RA_SERVICE, name);\n        String bootStrapCtxName = DEFAULT_NAME;\n        if (resourceAdapter.getBootstrapContext() != null && ! resourceAdapter.getBootstrapContext().equals(\"undefined\")) {\n            bootStrapCtxName = resourceAdapter.getBootstrapContext();\n        }\n        final ServiceController<?> service = context.getServiceRegistry(true).getService(raServiceName);\n        if (service == null) {\n            ResourceAdapterService raService = new ResourceAdapterService(resourceAdapter);\n            serviceTarget.addService(raServiceName, raService).setInitialMode(ServiceController.Mode.ACTIVE)\n                    .addDependency(ConnectorServices.RESOURCEADAPTERS_SERVICE, ResourceAdaptersService.ModifiableResourceAdaptors.class, raService.getResourceAdaptersInjector())\n                    .addDependency(ConnectorServices.BOOTSTRAP_CONTEXT_SERVICE.append(bootStrapCtxName))\n                    .addListener(verificationHandler).install();\n        }\n        return raServiceName;\n    }","commit_id":"b09fcae878c3504dda10343bde28b71864590212","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        final ModelNode opAddr = operation.require(OP_ADDR);\n        final String name = PathAddress.pathAddress(opAddr).getLastElement().getValue();\n\n        // Compensating is add\n        final ModelNode model = context.readModel(PathAddress.EMPTY_ADDRESS);\n        final String archiveOrModuleName;\n        if (model.get(ARCHIVE.getName()).isDefined()) {\n            archiveOrModuleName = ARCHIVE.resolveModelAttribute(context, model).asString();\n        } else {\n            archiveOrModuleName = MODULE.resolveModelAttribute(context, model).asString();\n        }\n        final ModelNode compensating = Util.getEmptyOperation(ADD, opAddr);\n\n        if (model.hasDefined(RESOURCEADAPTERS_NAME)) {\n            for (ModelNode raNode : model.get(RESOURCEADAPTERS_NAME).asList()) {\n                ModelNode raCompensatingNode = raNode.clone();\n                compensating.get(RESOURCEADAPTERS_NAME).add(raCompensatingNode);\n            }\n        }\n\n\n        context.removeResource(PathAddress.EMPTY_ADDRESS);\n\n        context.addStep(new OperationStepHandler() {\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n                final boolean wasActive = RaOperationUtil.deactivateIfActive(context, archiveOrModuleName);\n                ServiceName raServiceName = ServiceName.of(ConnectorServices.RA_SERVICE, archiveOrModuleName);\n                ServiceController<?> serviceController =  context.getServiceRegistry(false).getService(raServiceName);\n                final ModifiableResourceAdapter resourceAdapter;\n                if (serviceController != null) {\n                    resourceAdapter = (ModifiableResourceAdapter) serviceController.getValue();\n                } else {\n                    resourceAdapter = null;\n                }\n                final List<ServiceName> serviceNameList = context.getServiceRegistry(false).getServiceNames();\n                for (ServiceName name : serviceNameList) {\n                    if (raServiceName.isParentOf(name)) {\n                        context.removeService(name);\n                    }\n\n                }\n\n                if (model.get(MODULE.getName()).isDefined()) {\n                    //ServiceName deploymentServiceName = ConnectorServices.getDeploymentServiceName(model.get(MODULE.getName()).asString());\n                    //context.removeService(deploymentServiceName);\n                    ServiceName deployerServiceName = ConnectorServices.RESOURCE_ADAPTER_DEPLOYER_SERVICE_PREFIX.append(model.get(MODULE.getName()).asString());\n                    context.removeService(deployerServiceName);\n                }\n\n                context.removeService(raServiceName);\n                context.completeStep(new OperationContext.RollbackHandler() {\n                    @Override\n                    public void handleRollback(OperationContext context, ModelNode operation) {\n                        if (resourceAdapter != null) {\n                            RaOperationUtil.installRaServices(context, new ServiceVerificationHandler(), archiveOrModuleName, resourceAdapter);\n                            try {\n                                if (wasActive)\n                                    RaOperationUtil.activate(context, archiveOrModuleName, archiveOrModuleName, null);\n                            } catch (OperationFailedException e) {\n\n                            }\n                        }\n\n                    }\n                });\n            }\n        }, OperationContext.Stage.RUNTIME);\n        context.stepCompleted();\n    }","id":49943,"modified_method":"public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        final ModelNode opAddr = operation.require(OP_ADDR);\n        final String name = PathAddress.pathAddress(opAddr).getLastElement().getValue();\n\n        // Compensating is add\n        final ModelNode model = context.readModel(PathAddress.EMPTY_ADDRESS);\n        final String archiveOrModuleName;\n        if (model.get(ARCHIVE.getName()).isDefined()) {\n            archiveOrModuleName = ARCHIVE.resolveModelAttribute(context, model).asString();\n        } else {\n            archiveOrModuleName = MODULE.resolveModelAttribute(context, model).asString();\n        }\n        final ModelNode compensating = Util.getEmptyOperation(ADD, opAddr);\n\n        if (model.hasDefined(RESOURCEADAPTERS_NAME)) {\n            for (ModelNode raNode : model.get(RESOURCEADAPTERS_NAME).asList()) {\n                ModelNode raCompensatingNode = raNode.clone();\n                compensating.get(RESOURCEADAPTERS_NAME).add(raCompensatingNode);\n            }\n        }\n\n\n        context.removeResource(PathAddress.EMPTY_ADDRESS);\n\n        context.addStep(new OperationStepHandler() {\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n                final boolean wasActive = RaOperationUtil.deactivateIfActive(context, name);\n                ServiceName raServiceName = ServiceName.of(ConnectorServices.RA_SERVICE, name);\n                ServiceController<?> serviceController =  context.getServiceRegistry(false).getService(raServiceName);\n                final ModifiableResourceAdapter resourceAdapter;\n                if (serviceController != null) {\n                    resourceAdapter = (ModifiableResourceAdapter) serviceController.getValue();\n                } else {\n                    resourceAdapter = null;\n                }\n                final List<ServiceName> serviceNameList = context.getServiceRegistry(false).getServiceNames();\n                for (ServiceName name : serviceNameList) {\n                    if (raServiceName.isParentOf(name)) {\n                        context.removeService(name);\n                    }\n\n                }\n\n                if (model.get(MODULE.getName()).isDefined()) {\n                    //ServiceName deploymentServiceName = ConnectorServices.getDeploymentServiceName(model.get(MODULE.getName()).asString());\n                    //context.removeService(deploymentServiceName);\n                    ServiceName deployerServiceName = ConnectorServices.RESOURCE_ADAPTER_DEPLOYER_SERVICE_PREFIX.append(name);\n                    context.removeService(deployerServiceName);\n                    ServiceName inactiveServiceName = ConnectorServices.INACTIVE_RESOURCE_ADAPTER_SERVICE.append(name);\n                    context.removeService(inactiveServiceName);\n                }\n\n                context.removeService(raServiceName);\n                context.completeStep(new OperationContext.RollbackHandler() {\n                    @Override\n                    public void handleRollback(OperationContext context, ModelNode operation) {\n                        if (resourceAdapter != null) {\n                            if (model.get(ARCHIVE.getName()).isDefined()) {\n                                RaOperationUtil.installRaServices(context, new ServiceVerificationHandler(), name, resourceAdapter);\n                            } else {\n                                try {\n                                    RaOperationUtil.installRaServicesAndDeployFromModule(context, new ServiceVerificationHandler(), name, resourceAdapter, archiveOrModuleName);\n                                } catch (OperationFailedException e) {\n\n                                }\n                            }\n                            try {\n                                if (wasActive)\n                                    RaOperationUtil.activate(context, archiveOrModuleName, archiveOrModuleName, null);\n                            } catch (OperationFailedException e) {\n\n                            }\n                        }\n\n                    }\n                });\n            }\n        }, OperationContext.Stage.RUNTIME);\n        context.stepCompleted();\n    }","commit_id":"b09fcae878c3504dda10343bde28b71864590212","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseResourceAdapter(final XMLExtendedStreamReader reader, final List<ModelNode> list, ModelNode parentAddress) throws XMLStreamException, ParserException,\n            ValidateException {\n        final ModelNode raAddress = parentAddress.clone();\n        final ModelNode operation = new ModelNode();\n        operation.get(OP).set(ADD);\n\n        String archiveOrModuleName = null;\n        HashMap<String, ModelNode> configPropertiesOperations = new HashMap<String, ModelNode>();\n        HashMap<String, ModelNode> connectionDefinitionsOperations = new HashMap<String, ModelNode>();\n        HashMap<String, HashMap<String, ModelNode>> cfConfigPropertiesOperations = new HashMap<String, HashMap<String, ModelNode>>();\n\n        HashMap<String, ModelNode> adminObjectsOperations = new HashMap<String, ModelNode>();\n        HashMap<String, HashMap<String, ModelNode>> aoConfigPropertiesOperations = new HashMap<String, HashMap<String, ModelNode>>();\n\n\n        boolean archiveOrModuleMatched = false;\n        boolean txSupportMatched = false;\n        boolean isXa = false;\n        while (reader.hasNext()) {\n            switch (reader.nextTag()) {\n                case END_ELEMENT: {\n                    if (ResourceAdapters.Tag.forName(reader.getLocalName()) == ResourceAdapters.Tag.RESOURCE_ADAPTER) {\n                        if (archiveOrModuleName != null) {\n\n                            Integer identifier = ConnectorServices.getResourceIdentifier(archiveOrModuleName);\n                            if (identifier != null && identifier != 0) {\n                                archiveOrModuleName = archiveOrModuleName + ConnectorServices.RA_SERVICE_NAME_SEPARATOR + identifier;\n                            }\n\n                            raAddress.add(RESOURCEADAPTER_NAME, archiveOrModuleName);\n\n                            raAddress.protect();\n\n                            operation.get(OP_ADDR).set(raAddress);\n                            list.add(operation);\n\n                            for (Map.Entry<String, ModelNode> entry : configPropertiesOperations.entrySet()) {\n                                final ModelNode env = raAddress.clone();\n                                env.add(CONFIG_PROPERTIES.getName(), entry.getKey());\n                                env.protect();\n\n                                entry.getValue().get(OP_ADDR).set(env);\n                                list.add(entry.getValue());\n                            }\n\n                            for (Map.Entry<String, ModelNode> entry : connectionDefinitionsOperations.entrySet()) {\n                                final ModelNode env = raAddress.clone();\n                                env.add(CONNECTIONDEFINITIONS_NAME, entry.getKey());\n                                env.protect();\n\n                                entry.getValue().get(OP_ADDR).set(env);\n                                list.add(entry.getValue());\n\n                                final HashMap<String, ModelNode> properties = cfConfigPropertiesOperations.get(entry.getKey());\n                                if (properties != null) {\n                                    for (Map.Entry<String, ModelNode> configEntry : properties.entrySet()) {\n                                        final ModelNode configEnv = env.clone();\n                                        configEnv.add(CONFIG_PROPERTIES.getName(), configEntry.getKey());\n                                        configEnv.protect();\n\n                                        configEntry.getValue().get(OP_ADDR).set(configEnv);\n                                        list.add(configEntry.getValue());\n                                    }\n                                }\n                            }\n\n                            for (Map.Entry<String, ModelNode> entry : adminObjectsOperations.entrySet()) {\n                                final ModelNode env = raAddress.clone();\n                                env.add(ADMIN_OBJECTS_NAME, entry.getKey());\n                                env.protect();\n\n                                entry.getValue().get(OP_ADDR).set(env);\n                                list.add(entry.getValue());\n\n                                final HashMap<String, ModelNode> aoProperties = aoConfigPropertiesOperations.get(entry.getKey());\n                                if (aoProperties != null) {\n                                    for (Map.Entry<String, ModelNode> configEntry : aoProperties.entrySet()) {\n                                        final ModelNode configEnv = env.clone();\n                                        configEnv.add(CONFIG_PROPERTIES.getName(), configEntry.getKey());\n                                        configEnv.protect();\n\n                                        configEntry.getValue().get(OP_ADDR).set(configEnv);\n                                        list.add(configEntry.getValue());\n                                    }\n                                }\n                            }\n\n                            return;\n                        } else {\n                            throw new ParserException(bundle.requiredElementMissing(ARCHIVE.getName(), RESOURCEADAPTER_NAME));\n\n                        }\n                    } else {\n                        if (AS7ResourceAdapterTags.forName(reader.getLocalName()) == AS7ResourceAdapterTags.UNKNOWN) {\n                            throw new ParserException(bundle.unexpectedEndTag(reader.getLocalName()));\n                        }\n                    }\n                    break;\n                }\n                case START_ELEMENT: {\n                    switch (AS7ResourceAdapterTags.forName(reader.getLocalName())) {\n                        case ADMIN_OBJECTS:\n                        case CONNECTION_DEFINITIONS:\n                        case BEAN_VALIDATION_GROUPS: {\n                            //ignore it,we will parse bean-validation-group,admin_object and connection_definition directly\n                            break;\n                        }\n                        case ADMIN_OBJECT: {\n                            parseAdminObjects(reader, adminObjectsOperations, aoConfigPropertiesOperations);\n                            break;\n                        }\n\n                        case CONNECTION_DEFINITION: {\n                            parseConnectionDefinitions(reader, connectionDefinitionsOperations, cfConfigPropertiesOperations, isXa);\n                            break;\n                        }\n                        case BEAN_VALIDATION_GROUP: {\n                            String value = rawElementText(reader);\n                            operation.get(BEANVALIDATION_GROUPS.getName()).add(BEANVALIDATIONGROUP.parse(value, reader));\n                            break;\n                        }\n                        case BOOTSTRAP_CONTEXT: {\n                            String value = rawElementText(reader);\n                            BOOTSTRAP_CONTEXT.parseAndSetParameter(value, operation, reader);\n                            break;\n                        }\n                        case CONFIG_PROPERTY: {\n                            parseConfigProperties(reader, configPropertiesOperations);\n                            break;\n\n                        }\n                        case TRANSACTION_SUPPORT: {\n                            if (txSupportMatched) {\n                                throw new ParserException(bundle.unexpectedElement(TRANSACTION_SUPPORT.getXmlName()));\n                            }\n                            String value = rawElementText(reader);\n                            TRANSACTION_SUPPORT.parseAndSetParameter(value, operation, reader);\n                            isXa = value != null && TransactionSupportEnum.valueOf(value) == TransactionSupportEnum.XATransaction;\n                            txSupportMatched = true;\n                            break;\n                        }\n                        case ARCHIVE: {\n                            if (archiveOrModuleMatched) {\n                                throw new ParserException(bundle.unexpectedElement(ARCHIVE.getXmlName()));\n                            }\n                            archiveOrModuleName = rawElementText(reader);\n                            ARCHIVE.parseAndSetParameter(archiveOrModuleName, operation, reader);\n                            archiveOrModuleMatched = true;\n                            break;\n                        }\n                        case MODULE: {\n\n                            String moduleId = rawAttributeText(reader, \"id\");\n                            String moduleSlot = rawAttributeText(reader, \"slot\", \"main\");\n                            archiveOrModuleName = moduleId + \":\" + moduleSlot;\n                            MODULE.parseAndSetParameter(archiveOrModuleName, operation, reader);\n                            if (archiveOrModuleMatched) {\n                                throw new ParserException(bundle.unexpectedElement(MODULE.getXmlName()));\n                            }\n\n                            archiveOrModuleMatched = true;\n                            break;\n                        }\n                        default:\n                            throw new ParserException(bundle.unexpectedElement(reader.getLocalName()));\n                    }\n                    break;\n                }\n            }\n        }\n\n        throw new ParserException(bundle.unexpectedEndOfDocument());\n    }","id":49944,"modified_method":"private void parseResourceAdapter(final XMLExtendedStreamReader reader, final List<ModelNode> list, ModelNode parentAddress) throws XMLStreamException, ParserException,\n            ValidateException {\n        final ModelNode raAddress = parentAddress.clone();\n        final ModelNode operation = new ModelNode();\n        operation.get(OP).set(ADD);\n\n        String archiveOrModuleName = null;\n        HashMap<String, ModelNode> configPropertiesOperations = new HashMap<String, ModelNode>();\n        HashMap<String, ModelNode> connectionDefinitionsOperations = new HashMap<String, ModelNode>();\n        HashMap<String, HashMap<String, ModelNode>> cfConfigPropertiesOperations = new HashMap<String, HashMap<String, ModelNode>>();\n\n        HashMap<String, ModelNode> adminObjectsOperations = new HashMap<String, ModelNode>();\n        HashMap<String, HashMap<String, ModelNode>> aoConfigPropertiesOperations = new HashMap<String, HashMap<String, ModelNode>>();\n\n\n        boolean archiveOrModuleMatched = false;\n        boolean txSupportMatched = false;\n        boolean isXa = false;\n        boolean isModule = false;\n        String id = null;\n\n        int attributeSize = reader.getAttributeCount();\n\n                for (int i = 0; i < attributeSize; i++) {\n                    Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                    String value = reader.getAttributeValue(i);\n                    switch (attribute) {\n                        case ID: {\n                            id = value;\n                            break;\n                        }\n                        default:\n                            break;\n                    }\n                }\n\n\n        while (reader.hasNext()) {\n            switch (reader.nextTag()) {\n                case END_ELEMENT: {\n                    if (ResourceAdapters.Tag.forName(reader.getLocalName()) == ResourceAdapters.Tag.RESOURCE_ADAPTER) {\n                        if (!archiveOrModuleMatched) {\n                            throw new ParserException(bundle.requiredElementMissing(ARCHIVE.getName(), RESOURCEADAPTER_NAME));\n\n                        }\n\n                        if (id != null) {\n                            raAddress.add(RESOURCEADAPTER_NAME, id);\n                        } else {\n                            Integer identifier = ConnectorServices.getResourceIdentifier(archiveOrModuleName);\n                            if (identifier != null && identifier != 0) {\n                                archiveOrModuleName = archiveOrModuleName + ConnectorServices.RA_SERVICE_NAME_SEPARATOR + identifier;\n                            }\n\n                            raAddress.add(RESOURCEADAPTER_NAME, archiveOrModuleName);\n                        }\n\n                        raAddress.protect();\n\n                        operation.get(OP_ADDR).set(raAddress);\n                        list.add(operation);\n\n                        for (Map.Entry<String, ModelNode> entry : configPropertiesOperations.entrySet()) {\n                            final ModelNode env = raAddress.clone();\n                            env.add(CONFIG_PROPERTIES.getName(), entry.getKey());\n                            env.protect();\n\n                            entry.getValue().get(OP_ADDR).set(env);\n                            list.add(entry.getValue());\n                        }\n\n                        for (Map.Entry<String, ModelNode> entry : connectionDefinitionsOperations.entrySet()) {\n                            final ModelNode env = raAddress.clone();\n                            env.add(CONNECTIONDEFINITIONS_NAME, entry.getKey());\n                            env.protect();\n\n                            entry.getValue().get(OP_ADDR).set(env);\n                            list.add(entry.getValue());\n\n                            final HashMap<String, ModelNode> properties = cfConfigPropertiesOperations.get(entry.getKey());\n                            if (properties != null) {\n                                for (Map.Entry<String, ModelNode> configEntry : properties.entrySet()) {\n                                    final ModelNode configEnv = env.clone();\n                                    configEnv.add(CONFIG_PROPERTIES.getName(), configEntry.getKey());\n                                    configEnv.protect();\n\n                                    configEntry.getValue().get(OP_ADDR).set(configEnv);\n                                    list.add(configEntry.getValue());\n                                }\n                            }\n                        }\n\n                        for (Map.Entry<String, ModelNode> entry : adminObjectsOperations.entrySet()) {\n                            final ModelNode env = raAddress.clone();\n                            env.add(ADMIN_OBJECTS_NAME, entry.getKey());\n                            env.protect();\n\n                            entry.getValue().get(OP_ADDR).set(env);\n                            list.add(entry.getValue());\n\n                            final HashMap<String, ModelNode> aoProperties = aoConfigPropertiesOperations.get(entry.getKey());\n                            if (aoProperties != null) {\n                                for (Map.Entry<String, ModelNode> configEntry : aoProperties.entrySet()) {\n                                    final ModelNode configEnv = env.clone();\n                                    configEnv.add(CONFIG_PROPERTIES.getName(), configEntry.getKey());\n                                    configEnv.protect();\n\n                                    configEntry.getValue().get(OP_ADDR).set(configEnv);\n                                    list.add(configEntry.getValue());\n                                }\n                            }\n                        }\n\n\n                        if (isModule) {\n                            final ModelNode activateOp = new ModelNode();\n                            activateOp.get(OP).set(Constants.ACTIVATE);\n                            activateOp.get(OP_ADDR).set(raAddress);\n                            list.add(activateOp);\n                        }\n\n                        return;\n\n                    } else {\n                        if (AS7ResourceAdapterTags.forName(reader.getLocalName()) == AS7ResourceAdapterTags.UNKNOWN) {\n                            throw new ParserException(bundle.unexpectedEndTag(reader.getLocalName()));\n                        }\n                    }\n                    break;\n                }\n                case START_ELEMENT: {\n                    switch (AS7ResourceAdapterTags.forName(reader.getLocalName())) {\n                        case ADMIN_OBJECTS:\n                        case CONNECTION_DEFINITIONS:\n                        case BEAN_VALIDATION_GROUPS: {\n                            //ignore it,we will parse bean-validation-group,admin_object and connection_definition directly\n                            break;\n                        }\n                        case ADMIN_OBJECT: {\n                            parseAdminObjects(reader, adminObjectsOperations, aoConfigPropertiesOperations);\n                            break;\n                        }\n\n                        case CONNECTION_DEFINITION: {\n                            parseConnectionDefinitions(reader, connectionDefinitionsOperations, cfConfigPropertiesOperations, isXa);\n                            break;\n                        }\n                        case BEAN_VALIDATION_GROUP: {\n                            String value = rawElementText(reader);\n                            operation.get(BEANVALIDATION_GROUPS.getName()).add(BEANVALIDATIONGROUP.parse(value, reader));\n                            break;\n                        }\n                        case BOOTSTRAP_CONTEXT: {\n                            String value = rawElementText(reader);\n                            BOOTSTRAP_CONTEXT.parseAndSetParameter(value, operation, reader);\n                            break;\n                        }\n                        case CONFIG_PROPERTY: {\n                            parseConfigProperties(reader, configPropertiesOperations);\n                            break;\n\n                        }\n                        case TRANSACTION_SUPPORT: {\n                            if (txSupportMatched) {\n                                throw new ParserException(bundle.unexpectedElement(TRANSACTION_SUPPORT.getXmlName()));\n                            }\n                            String value = rawElementText(reader);\n                            TRANSACTION_SUPPORT.parseAndSetParameter(value, operation, reader);\n                            isXa = value != null && TransactionSupportEnum.valueOf(value) == TransactionSupportEnum.XATransaction;\n                            txSupportMatched = true;\n                            break;\n                        }\n                        case ARCHIVE: {\n                            if (archiveOrModuleMatched) {\n                                throw new ParserException(bundle.unexpectedElement(ARCHIVE.getXmlName()));\n                            }\n                            archiveOrModuleName = rawElementText(reader);\n                            ARCHIVE.parseAndSetParameter(archiveOrModuleName, operation, reader);\n                            archiveOrModuleMatched = true;\n                            break;\n                        }\n                        case MODULE: {\n                            if (archiveOrModuleMatched) {\n                                throw new ParserException(bundle.unexpectedElement(MODULE.getXmlName()));\n                            }\n\n                            String moduleId = rawAttributeText(reader, \"id\");\n                            String moduleSlot = rawAttributeText(reader, \"slot\", \"main\");\n                            archiveOrModuleName = moduleId + \":\" + moduleSlot;\n                            MODULE.parseAndSetParameter(archiveOrModuleName, operation, reader);\n                            isModule = true;\n\n                            archiveOrModuleMatched = true;\n                            break;\n                        }\n                        default:\n                            throw new ParserException(bundle.unexpectedElement(reader.getLocalName()));\n                    }\n                    break;\n                }\n            }\n        }\n\n        throw new ParserException(bundle.unexpectedEndOfDocument());\n    }","commit_id":"b09fcae878c3504dda10343bde28b71864590212","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n        ModelNode node = context.getModelNode();\n        boolean hasChildren = node.hasDefined(RESOURCEADAPTER_NAME) && node.get(RESOURCEADAPTER_NAME).asPropertyList().size() > 0;\n\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), !hasChildren);\n\n        if (hasChildren) {\n            writer.writeStartElement(Element.RESOURCE_ADAPTERS.getLocalName());\n            for (Property property : node.get(RESOURCEADAPTER_NAME).asPropertyList()) {\n                final ModelNode ra = property.getValue();\n\n                writeRaElement(writer, ra);\n            }\n            writer.writeEndElement();\n            // Close the subsystem element\n            writer.writeEndElement();\n        }\n    }","id":49945,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n        ModelNode node = context.getModelNode();\n        boolean hasChildren = node.hasDefined(RESOURCEADAPTER_NAME) && node.get(RESOURCEADAPTER_NAME).asPropertyList().size() > 0;\n\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), !hasChildren);\n\n        if (hasChildren) {\n            writer.writeStartElement(Element.RESOURCE_ADAPTERS.getLocalName());\n            for (Property property : node.get(RESOURCEADAPTER_NAME).asPropertyList()) {\n                final ModelNode ra = property.getValue();\n                final String  name = property.getName();\n                writeRaElement(writer, ra, name);\n            }\n            writer.writeEndElement();\n            // Close the subsystem element\n            writer.writeEndElement();\n        }\n    }","commit_id":"b09fcae878c3504dda10343bde28b71864590212","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeRaElement(XMLExtendedStreamWriter streamWriter, ModelNode ra) throws XMLStreamException {\n        streamWriter.writeStartElement(ResourceAdapters.Tag.RESOURCE_ADAPTER.getLocalName());\n\n        ARCHIVE.marshallAsElement(ra, streamWriter);\n        MODULE.marshallAsElement(ra, streamWriter);\n\n        BOOTSTRAP_CONTEXT.marshallAsElement(ra, streamWriter);\n\n        if (ra.hasDefined(BEANVALIDATION_GROUPS.getName())) {\n            streamWriter.writeStartElement(ResourceAdapter.Tag.BEAN_VALIDATION_GROUPS.getLocalName());\n            for (ModelNode bvg : ra.get(BEANVALIDATION_GROUPS.getName()).asList()) {\n                streamWriter.writeStartElement(BEANVALIDATION_GROUPS.getXmlName());\n                streamWriter.writeCharacters(bvg.asString());\n                streamWriter.writeEndElement();\n            }\n            streamWriter.writeEndElement();\n        }\n\n        TRANSACTION_SUPPORT.marshallAsElement(ra, streamWriter);\n        writeNewConfigProperties(streamWriter, ra);\n        TransactionSupportEnum transactionSupport = ra.hasDefined(TRANSACTION_SUPPORT.getName()) ? TransactionSupportEnum\n            .valueOf(ra.get(TRANSACTION_SUPPORT.getName()).asString()) : null;\n        boolean isXa = false;\n        if (transactionSupport == TransactionSupportEnum.XATransaction) {\n            isXa = true;\n        }\n        if (ra.hasDefined(CONNECTIONDEFINITIONS_NAME)) {\n            streamWriter.writeStartElement(ResourceAdapter.Tag.CONNECTION_DEFINITIONS.getLocalName());\n            for (Property conDef : ra.get(CONNECTIONDEFINITIONS_NAME).asPropertyList()) {\n                writeConDef(streamWriter, conDef.getValue(), conDef.getName(), isXa);\n            }\n            streamWriter.writeEndElement();\n        }\n\n        if (ra.hasDefined(ADMIN_OBJECTS_NAME)) {\n            streamWriter.writeStartElement(ResourceAdapter.Tag.ADMIN_OBJECTS.getLocalName());\n            for (Property adminObject : ra.get(ADMIN_OBJECTS_NAME).asPropertyList()) {\n                writeAdminObject(streamWriter, adminObject.getValue(), adminObject.getName());\n            }\n            streamWriter.writeEndElement();\n        }\n        streamWriter.writeEndElement();\n\n    }","id":49946,"modified_method":"private void writeRaElement(XMLExtendedStreamWriter streamWriter, ModelNode ra, final String name) throws XMLStreamException {\n        streamWriter.writeStartElement(ResourceAdapters.Tag.RESOURCE_ADAPTER.getLocalName());\n        streamWriter.writeAttribute(ResourceAdapterParser.Attribute.ID.getLocalName(), name);\n        ARCHIVE.marshallAsElement(ra, streamWriter);\n        MODULE.marshallAsElement(ra, streamWriter);\n\n        BOOTSTRAP_CONTEXT.marshallAsElement(ra, streamWriter);\n\n        if (ra.hasDefined(BEANVALIDATION_GROUPS.getName())) {\n            streamWriter.writeStartElement(ResourceAdapter.Tag.BEAN_VALIDATION_GROUPS.getLocalName());\n            for (ModelNode bvg : ra.get(BEANVALIDATION_GROUPS.getName()).asList()) {\n                streamWriter.writeStartElement(BEANVALIDATION_GROUPS.getXmlName());\n                streamWriter.writeCharacters(bvg.asString());\n                streamWriter.writeEndElement();\n            }\n            streamWriter.writeEndElement();\n        }\n\n        TRANSACTION_SUPPORT.marshallAsElement(ra, streamWriter);\n        writeNewConfigProperties(streamWriter, ra);\n        TransactionSupportEnum transactionSupport = ra.hasDefined(TRANSACTION_SUPPORT.getName()) ? TransactionSupportEnum\n            .valueOf(ra.get(TRANSACTION_SUPPORT.getName()).asString()) : null;\n        boolean isXa = false;\n        if (transactionSupport == TransactionSupportEnum.XATransaction) {\n            isXa = true;\n        }\n        if (ra.hasDefined(CONNECTIONDEFINITIONS_NAME)) {\n            streamWriter.writeStartElement(ResourceAdapter.Tag.CONNECTION_DEFINITIONS.getLocalName());\n            for (Property conDef : ra.get(CONNECTIONDEFINITIONS_NAME).asPropertyList()) {\n                writeConDef(streamWriter, conDef.getValue(), conDef.getName(), isXa);\n            }\n            streamWriter.writeEndElement();\n        }\n\n        if (ra.hasDefined(ADMIN_OBJECTS_NAME)) {\n            streamWriter.writeStartElement(ResourceAdapter.Tag.ADMIN_OBJECTS.getLocalName());\n            for (Property adminObject : ra.get(ADMIN_OBJECTS_NAME).asPropertyList()) {\n                writeAdminObject(streamWriter, adminObject.getValue(), adminObject.getName());\n            }\n            streamWriter.writeEndElement();\n        }\n        streamWriter.writeEndElement();\n\n    }","commit_id":"b09fcae878c3504dda10343bde28b71864590212","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void readElement(final XMLExtendedStreamReader reader, final List<ModelNode> list) throws XMLStreamException {\n\n        final ModelNode address = new ModelNode();\n        address.add(ModelDescriptionConstants.SUBSYSTEM, RESOURCEADAPTERS_NAME);\n        address.protect();\n\n        final ModelNode subsystem = new ModelNode();\n        subsystem.get(OP).set(ADD);\n        subsystem.get(OP_ADDR).set(address);\n\n        list.add(subsystem);\n\n        try {\n            String localName = null;\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case RESOURCEADAPTERS_1_0: {\n                    localName = reader.getLocalName();\n                    final Element element = Element.forName(reader.getLocalName());\n                    SUBSYSTEM_RA_LOGGER.tracef(\"%s -> %s\", localName, element);\n                    switch (element) {\n                        case SUBSYSTEM: {\n                            ResourceAdapterParser parser = new ResourceAdapterParser();\n                            parser.parse(reader, list, address);\n                            ParseUtils.requireNoContent(reader);\n                            break;\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            throw new XMLStreamException(e);\n        }\n\n    }","id":49947,"modified_method":"@Override\n    public void readElement(final XMLExtendedStreamReader reader, final List<ModelNode> list) throws XMLStreamException {\n\n        final ModelNode address = new ModelNode();\n        address.add(ModelDescriptionConstants.SUBSYSTEM, RESOURCEADAPTERS_NAME);\n        address.protect();\n\n        final ModelNode subsystem = new ModelNode();\n        subsystem.get(OP).set(ADD);\n        subsystem.get(OP_ADDR).set(address);\n\n        list.add(subsystem);\n\n        try {\n            String localName;\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case RESOURCEADAPTERS_1_0: {\n                    localName = reader.getLocalName();\n                    final Element element = Element.forName(reader.getLocalName());\n                    SUBSYSTEM_RA_LOGGER.tracef(\"%s -> %s\", localName, element);\n                    switch (element) {\n                        case SUBSYSTEM: {\n                            ResourceAdapterParser parser = new ResourceAdapterParser();\n                            parser.parse(reader, list, address);\n                            ParseUtils.requireNoContent(reader);\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case RESOURCEADAPTERS_1_1: {\n                    localName = reader.getLocalName();\n                    final Element element = Element.forName(reader.getLocalName());\n                    SUBSYSTEM_RA_LOGGER.tracef(\"%s -> %s\", localName, element);\n                    switch (element) {\n                        case SUBSYSTEM: {\n                            ResourceAdapterParser parser = new ResourceAdapterParser();\n                            parser.parse(reader, list, address);\n                            ParseUtils.requireNoContent(reader);\n                            break;\n                        }\n                    }\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            throw new XMLStreamException(e);\n        }\n\n    }","commit_id":"b09fcae878c3504dda10343bde28b71864590212","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void initializeParsers(final ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.CURRENT.getUriString(), ResourceAdapterSubsystemParser.INSTANCE);\n    }","id":49948,"modified_method":"@Override\n    public void initializeParsers(final ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.RESOURCEADAPTERS_1_0.getUriString(), ResourceAdapterSubsystemParser.INSTANCE);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, Namespace.RESOURCEADAPTERS_1_1.getUriString(), ResourceAdapterSubsystemParser.INSTANCE);\n    }","commit_id":"b09fcae878c3504dda10343bde28b71864590212","url":"https://github.com/wildfly/wildfly"},{"original_method":"static String[] jndiBindings(final ModelNode node) {\n        if(node.has(ENTRIES)) {\n            final Set<String> bindings = new HashSet<String>();\n            for(final ModelNode entry : node.get(ENTRIES).asList()) {\n                bindings.add(entry.asString());\n            }\n            return bindings.toArray(new String[bindings.size()]);\n        }\n        return NO_BINDINGS;\n    }","id":49949,"modified_method":"static String[] jndiBindings(final ModelNode node) {\n        if(node.hasDefined(ENTRIES)) {\n            final Set<String> bindings = new HashSet<String>();\n            for(final ModelNode entry : node.get(ENTRIES).asList()) {\n                bindings.add(entry.asString());\n            }\n            return bindings.toArray(new String[bindings.size()]);\n        }\n        return NO_BINDINGS;\n    }","commit_id":"9781b56b035dbb156c04b1ac20ef499f1e4eeb95","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public Cancellable execute(final NewOperationContext context, final ModelNode operation, ResultHandler resultHandler) {\n\n        ModelNode opAddr = operation.require(OP_ADDR);\n        final PathAddress address = PathAddress.pathAddress(opAddr);\n        final String name = address.getLastElement().getValue();\n\n        final ModelNode compensatingOperation = Util.getResourceRemoveOperation(opAddr);\n\n        if(context instanceof NewRuntimeOperationContext) {\n            final NewRuntimeOperationContext runtimeContext = (NewRuntimeOperationContext) context;\n\n            final JMSQueueService service = new JMSQueueService(name, operation.get(SELECTOR).asString(),\n                    operation.get(DURABLE).asBoolean(true), jndiBindings(operation));\n            final ServiceName serviceName = JMSServices.JMS_QUEUE_BASE.append(name);\n            runtimeContext.getServiceTarget().addService(serviceName, service)\n                    .addDependency(JMSServices.JMS_MANAGER, JMSServerManager.class, service.getJmsServer())\n                    .setInitialMode(Mode.ACTIVE)\n                    .install();\n        }\n\n        final ModelNode subModel = context.getSubModel();\n        if (operation.get(SELECTOR).isDefined()) {\n            subModel.get(SELECTOR).set(operation.get(SELECTOR));\n        }\n        if (operation.get(DURABLE).isDefined()) {\n            subModel.get(DURABLE).set(operation.get(DURABLE));\n        }\n        if (operation.get(ENTRIES).isDefined()) {\n            subModel.get(ENTRIES).set(operation.get(ENTRIES));\n        }\n\n        resultHandler.handleResultComplete(compensatingOperation);\n\n        return Cancellable.NULL;\n    }","id":49950,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public Cancellable execute(final NewOperationContext context, final ModelNode operation, ResultHandler resultHandler) {\n\n        ModelNode opAddr = operation.require(OP_ADDR);\n        final PathAddress address = PathAddress.pathAddress(opAddr);\n        final String name = address.getLastElement().getValue();\n\n        final ModelNode compensatingOperation = Util.getResourceRemoveOperation(opAddr);\n\n        String selector = null;\n        final ModelNode subModel = context.getSubModel();\n        if (operation.hasDefined(SELECTOR)) {\n            selector = operation.get(SELECTOR).asString();\n            subModel.get(SELECTOR).set(selector);\n        }\n        if (operation.hasDefined(DURABLE)) {\n            subModel.get(DURABLE).set(operation.get(DURABLE));\n        }\n        if (operation.hasDefined(ENTRIES)) {\n            subModel.get(ENTRIES).set(operation.get(ENTRIES));\n        }\n\n        if(context instanceof NewRuntimeOperationContext) {\n            final NewRuntimeOperationContext runtimeContext = (NewRuntimeOperationContext) context;\n\n            final JMSQueueService service = new JMSQueueService(name, selector,\n                    operation.get(DURABLE).asBoolean(true), jndiBindings(operation));\n            final ServiceName serviceName = JMSServices.JMS_QUEUE_BASE.append(name);\n            runtimeContext.getServiceTarget().addService(serviceName, service)\n                    .addDependency(JMSServices.JMS_MANAGER, JMSServerManager.class, service.getJmsServer())\n                    .setInitialMode(Mode.ACTIVE)\n                    .install();\n        }\n\n        resultHandler.handleResultComplete(compensatingOperation);\n\n        return Cancellable.NULL;\n    }","commit_id":"9781b56b035dbb156c04b1ac20ef499f1e4eeb95","url":"https://github.com/wildfly/wildfly"},{"original_method":"static String[] jndiBindings(final ModelNode node) {\n        if(node.has(ENTRIES)) {\n            final Set<String> bindings = new HashSet<String>();\n            for(final ModelNode entry : node.get(ENTRIES).asList()) {\n                bindings.add(entry.asString());\n            }\n            return bindings.toArray(new String[bindings.size()]);\n        }\n        return NO_BINDINGS;\n    }","id":49951,"modified_method":"static String[] jndiBindings(final ModelNode node) {\n        if(node.hasDefined(ENTRIES)) {\n            final Set<String> bindings = new HashSet<String>();\n            for(final ModelNode entry : node.get(ENTRIES).asList()) {\n                bindings.add(entry.asString());\n            }\n            return bindings.toArray(new String[bindings.size()]);\n        }\n        return NO_BINDINGS;\n    }","commit_id":"9781b56b035dbb156c04b1ac20ef499f1e4eeb95","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public Cancellable execute(final NewOperationContext context, final ModelNode operation, ResultHandler resultHandler) {\n\n        ModelNode opAddr = operation.require(OP_ADDR);\n        final PathAddress address = PathAddress.pathAddress(opAddr);\n        final String name = address.getLastElement().getValue();\n\n        final ModelNode compensatingOperation = Util.getResourceRemoveOperation(opAddr);\n\n        if(context instanceof NewRuntimeOperationContext) {\n            final NewRuntimeOperationContext runtimeContext = (NewRuntimeOperationContext) context;\n            final JMSTopicService service = new JMSTopicService(name, jndiBindings(operation));\n            final ServiceName serviceName = JMSServices.JMS_TOPIC_BASE.append(name);\n            runtimeContext.getServiceTarget().addService(serviceName, service)\n                    .addDependency(JMSServices.JMS_MANAGER, JMSServerManager.class, service.getJmsServer())\n                    .setInitialMode(Mode.ACTIVE)\n                    .install();\n        }\n\n        if(operation.hasDefined(ENTRIES)) {\n            context.getSubModel().get(ENTRIES).set(operation.get(ENTRIES));\n        }\n\n        resultHandler.handleResultComplete(compensatingOperation);\n\n        return Cancellable.NULL;\n    }","id":49952,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public Cancellable execute(final NewOperationContext context, final ModelNode operation, ResultHandler resultHandler) {\n\n        ModelNode opAddr = operation.require(OP_ADDR);\n        final PathAddress address = PathAddress.pathAddress(opAddr);\n        final String name = address.getLastElement().getValue();\n\n        final ModelNode compensatingOperation = Util.getResourceRemoveOperation(opAddr);\n\n        if(operation.hasDefined(ENTRIES)) {\n            context.getSubModel().get(ENTRIES).set(operation.get(ENTRIES));\n        }\n\n        if(context instanceof NewRuntimeOperationContext) {\n            final NewRuntimeOperationContext runtimeContext = (NewRuntimeOperationContext) context;\n            final JMSTopicService service = new JMSTopicService(name, jndiBindings(operation));\n            final ServiceName serviceName = JMSServices.JMS_TOPIC_BASE.append(name);\n            runtimeContext.getServiceTarget().addService(serviceName, service)\n                    .addDependency(JMSServices.JMS_MANAGER, JMSServerManager.class, service.getJmsServer())\n                    .setInitialMode(Mode.ACTIVE)\n                    .install();\n        }\n\n        resultHandler.handleResultComplete(compensatingOperation);\n\n        return Cancellable.NULL;\n    }","commit_id":"9781b56b035dbb156c04b1ac20ef499f1e4eeb95","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n        ModelNode node = context.getModelNode();\n\n        writeAttribute(writer, Attribute.NATIVE.getLocalName(), node);\n        writeAttribute(writer, Attribute.DEFAULT_VIRTUAL_SERVER.getLocalName(), node);\n        writeAttribute(writer, Attribute.INSTANCE_ID.getLocalName(), node);\n        if(node.hasDefined(CONTAINER_CONFIG)) {\n            writeContainerConfig(writer, node.get(CONTAINER_CONFIG));\n        }\n        if(node.hasDefined(CONNECTOR)) {\n            for(final Property connector : node.get(CONNECTOR).asPropertyList()) {\n                final ModelNode config = connector.getValue();\n                writer.writeStartElement(Element.CONNECTOR.getLocalName());\n                writer.writeAttribute(NAME, connector.getName());\n                writeAttribute(writer, Attribute.PROTOCOL.getLocalName(), config);\n                writeAttribute(writer, Attribute.SOCKET_BINDING.getLocalName(), config);\n                writeAttribute(writer, Attribute.SCHEME.getLocalName(), config);\n                writeAttribute(writer, Attribute.ENABLED.getLocalName(), config);\n                writeAttribute(writer, Attribute.ENABLE_LOOKUPS.getLocalName(), config);\n                writeAttribute(writer, Attribute.PROXY_NAME.getLocalName(), config);\n                writeAttribute(writer, Attribute.PROXY_PORT.getLocalName(), config);\n                writeAttribute(writer, Attribute.SECURE.getLocalName(), config);\n                writeAttribute(writer, Attribute.EXECUTOR.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_POST_SIZE.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_SAVE_POST_SIZE.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_CONNECTIONS.getLocalName(), config);\n                writeAttribute(writer, Attribute.REDIRECT_PORT.getLocalName(), config);\n\n                ModelNode sslConfig;\n                if (config.get(SSL).isDefined() && config.get(SSL).has(\"configuration\")) {\n                    sslConfig = config.get(SSL).get(\"configuration\");\n                } else {\n                    sslConfig = config.get(SSL);\n                }\n                if (sslConfig.isDefined() && !sslConfig.keys().isEmpty()) {\n                    writer.writeStartElement(Element.SSL.getLocalName());\n                    writeAttribute(writer, Attribute.NAME.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.KEY_ALIAS.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.PASSWORD.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CERTIFICATE_KEY_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CIPHER_SUITE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.PROTOCOL.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.VERIFY_CLIENT.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.VERIFY_DEPTH.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CERTIFICATE_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CA_CERTIFICATE_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CA_REVOCATION_URL.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.SESSION_CACHE_SIZE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.SESSION_TIMEOUT.getLocalName(), sslConfig);\n                    writer.writeEndElement();\n                }\n                if (config.hasDefined(VIRTUAL_SERVER)) {\n                    for(final ModelNode virtualServer : config.get(VIRTUAL_SERVER).asList()) {\n                        writer.writeEmptyElement(VIRTUAL_SERVER);\n                        writer.writeAttribute(NAME, virtualServer.asString());\n                    }\n                }\n                writer.writeEndElement();\n            }\n        }\n        if(node.hasDefined(VIRTUAL_SERVER)) {\n            for(final Property host : node.get(VIRTUAL_SERVER).asPropertyList()) {\n                final ModelNode config = host.getValue();\n                writer.writeStartElement(Element.VIRTUAL_SERVER.getLocalName());\n                writer.writeAttribute(NAME, host.getName());\n                writeAttribute(writer, Attribute.DEFAULT_WEB_MODULE.getLocalName(), config);\n                if (config.hasDefined(ENABLE_WELCOME_ROOT) && config.get(ENABLE_WELCOME_ROOT).asBoolean())\n                    writer.writeAttribute(ENABLE_WELCOME_ROOT, \"true\");\n\n                if(config.hasDefined(ALIAS)) {\n                    for(final ModelNode alias : config.get(ALIAS).asList()) {\n                        writer.writeEmptyElement(ALIAS);\n                        writer.writeAttribute(NAME, alias.asString());\n                    }\n                }\n                ModelNode accessLog;\n                if (config.get(ACCESS_LOG).isDefined() && config.get(ACCESS_LOG).has(\"configuration\")) {\n                    accessLog = config.get(ACCESS_LOG).get(\"configuration\");\n                } else {\n                    accessLog = config.get(ACCESS_LOG);\n                }\n                if (accessLog.isDefined() && !accessLog.keys().isEmpty()) {\n                    writer.writeStartElement(Element.ACCESS_LOG.getLocalName());\n                    final ModelNode accessLog = config.get(ACCESS_LOG);\n                    writeAttribute(writer, Attribute.PATTERN.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.RESOLVE_HOSTS.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.EXTENDED.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.PREFIX.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.ROTATE.getLocalName(), accessLog);\n                    if(accessLog.has(DIRECTORY)) {\n                        ModelNode directory;\n                        if (accessLog.get(DIRECTORY).has(\"configuration\"))\n                            directory = accessLog.get(DIRECTORY).get(\"configuration\");\n                        else\n                            directory = accessLog.get(DIRECTORY);\n                        if (directory.isDefined()) {\n                            writer.writeStartElement(Element.DIRECTORY.getLocalName());\n                            writeAttribute(writer, Attribute.PATH.getLocalName(), directory);\n                            writeAttribute(writer, Attribute.RELATIVE_TO.getLocalName(), directory);\n                            writer.writeEndElement();\n                        }\n                    }\n                    writer.writeEndElement();\n                }\n\n                if (config.hasDefined(REWRITE)) {\n                    for (final ModelNode rewritenode : config.get(REWRITE).asList()) {\n                        String name = getAddedRule(rewritenode);\n                        ModelNode rewrite;\n                        if (rewritenode.hasDefined(name))\n                            rewrite = rewritenode.get(name);\n                        else\n                            rewrite = rewritenode;\n                        writer.writeStartElement(REWRITE);\n                        writeAttribute(writer, Attribute.PATTERN.getLocalName(), rewrite);\n                        writeAttribute(writer, Attribute.SUBSTITUTION.getLocalName(), rewrite);\n                        writeAttribute(writer, Attribute.FLAGS.getLocalName(), rewrite);\n\n                        if (rewrite.hasDefined(CONDITION)) {\n                            for (final ModelNode conditionnode : rewrite.get(CONDITION).asList()) {\n                                String condname = getAddedConditionName(conditionnode);\n                                ModelNode condition;\n                                if (conditionnode.hasDefined(condname))\n                                    condition = conditionnode.get(condname);\n                                else\n                                    condition = conditionnode;\n                                writer.writeStartElement(CONDITION);\n                                writeAttribute(writer, Attribute.TEST.getLocalName(), condition);\n                                writeAttribute(writer, Attribute.PATTERN.getLocalName(), condition);\n                                writeAttribute(writer, Attribute.FLAGS.getLocalName(), condition);\n                            }\n                        }\n                        writer.writeEndElement();\n                    }\n                }\n                if(config.hasDefined(SSO)) {\n                    final ModelNode sso;\n                    if (config.get(SSO).has(\"configuration\"))\n                        sso = config.get(SSO).get(\"configuration\");\n                    else\n                        sso = config.get(SSO);\n                    if (sso.isDefined()) {\n                        writer.writeStartElement(SSO);\n                        writeAttribute(writer, Attribute.CACHE_CONTAINER.getLocalName(), sso);\n                        writeAttribute(writer, Attribute.DOMAIN.getLocalName(), sso);\n                        writeAttribute(writer, Attribute.REAUTHENTICATE.getLocalName(), sso);\n                        writer.writeEndElement();\n                    }\n                }\n                writer.writeEndElement();\n            }\n        }\n        writer.writeEndElement();\n    }","id":49953,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n        ModelNode node = context.getModelNode();\n\n        writeAttribute(writer, Attribute.NATIVE.getLocalName(), node);\n        writeAttribute(writer, Attribute.DEFAULT_VIRTUAL_SERVER.getLocalName(), node);\n        writeAttribute(writer, Attribute.INSTANCE_ID.getLocalName(), node);\n        if(node.hasDefined(CONTAINER_CONFIG)) {\n            writeContainerConfig(writer, node.get(CONTAINER_CONFIG));\n        }\n        if(node.hasDefined(CONNECTOR)) {\n            for(final Property connector : node.get(CONNECTOR).asPropertyList()) {\n                final ModelNode config = connector.getValue();\n                writer.writeStartElement(Element.CONNECTOR.getLocalName());\n                writer.writeAttribute(NAME, connector.getName());\n                writeAttribute(writer, Attribute.PROTOCOL.getLocalName(), config);\n                writeAttribute(writer, Attribute.SOCKET_BINDING.getLocalName(), config);\n                writeAttribute(writer, Attribute.SCHEME.getLocalName(), config);\n                writeAttribute(writer, Attribute.ENABLED.getLocalName(), config);\n                writeAttribute(writer, Attribute.ENABLE_LOOKUPS.getLocalName(), config);\n                writeAttribute(writer, Attribute.PROXY_NAME.getLocalName(), config);\n                writeAttribute(writer, Attribute.PROXY_PORT.getLocalName(), config);\n                writeAttribute(writer, Attribute.SECURE.getLocalName(), config);\n                writeAttribute(writer, Attribute.EXECUTOR.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_POST_SIZE.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_SAVE_POST_SIZE.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_CONNECTIONS.getLocalName(), config);\n                writeAttribute(writer, Attribute.REDIRECT_PORT.getLocalName(), config);\n                if (config.hasDefined(SSL)) {\n                    writer.writeStartElement(Element.SSL.getLocalName());\n                    final ModelNode sslConfig = config.get(SSL);\n                    writeAttribute(writer, Attribute.NAME.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.KEY_ALIAS.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.PASSWORD.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CERTIFICATE_KEY_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CIPHER_SUITE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.PROTOCOL.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.VERIFY_CLIENT.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.VERIFY_DEPTH.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CERTIFICATE_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CA_CERTIFICATE_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CA_REVOCATION_URL.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.SESSION_CACHE_SIZE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.SESSION_TIMEOUT.getLocalName(), sslConfig);\n                    writer.writeEndElement();\n                }\n                if (config.hasDefined(VIRTUAL_SERVER)) {\n                    for(final ModelNode virtualServer : config.get(VIRTUAL_SERVER).asList()) {\n                        writer.writeEmptyElement(VIRTUAL_SERVER);\n                        writer.writeAttribute(NAME, virtualServer.asString());\n                    }\n                }\n                writer.writeEndElement();\n            }\n        }\n        if(node.hasDefined(VIRTUAL_SERVER)) {\n            for(final Property host : node.get(VIRTUAL_SERVER).asPropertyList()) {\n                final ModelNode config = host.getValue();\n                writer.writeStartElement(Element.VIRTUAL_SERVER.getLocalName());\n                writer.writeAttribute(NAME, host.getName());\n                writeAttribute(writer, Attribute.DEFAULT_WEB_MODULE.getLocalName(), config);\n                if (config.hasDefined(ENABLE_WELCOME_ROOT) && config.get(ENABLE_WELCOME_ROOT).asBoolean())\n                    writer.writeAttribute(ENABLE_WELCOME_ROOT, \"true\");\n\n                if(config.hasDefined(ALIAS)) {\n                    for(final ModelNode alias : config.get(ALIAS).asList()) {\n                        writer.writeEmptyElement(ALIAS);\n                        writer.writeAttribute(NAME, alias.asString());\n                    }\n                }\n                ModelNode accessLog;\n                if (config.get(ACCESS_LOG).isDefined() && config.get(ACCESS_LOG).has(\"configuration\")) {\n                    accessLog = config.get(ACCESS_LOG).get(\"configuration\");\n                } else {\n                    accessLog = config.get(ACCESS_LOG);\n                }\n                if (accessLog.isDefined() && !accessLog.keys().isEmpty()) {\n                    writer.writeStartElement(Element.ACCESS_LOG.getLocalName());\n                    final ModelNode accessLog = config.get(ACCESS_LOG);\n                    writeAttribute(writer, Attribute.PATTERN.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.RESOLVE_HOSTS.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.EXTENDED.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.PREFIX.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.ROTATE.getLocalName(), accessLog);\n                    if(accessLog.has(DIRECTORY)) {\n                        ModelNode directory;\n                        if (accessLog.get(DIRECTORY).has(\"configuration\"))\n                            directory = accessLog.get(DIRECTORY).get(\"configuration\");\n                        else\n                            directory = accessLog.get(DIRECTORY);\n                        if (directory.isDefined()) {\n                            writer.writeStartElement(Element.DIRECTORY.getLocalName());\n                            writeAttribute(writer, Attribute.PATH.getLocalName(), directory);\n                            writeAttribute(writer, Attribute.RELATIVE_TO.getLocalName(), directory);\n                            writer.writeEndElement();\n                        }\n                    }\n                    writer.writeEndElement();\n                }\n\n                if (config.hasDefined(REWRITE)) {\n                    for (final ModelNode rewritenode : config.get(REWRITE).asList()) {\n                        String name = getAddedRule(rewritenode);\n                        ModelNode rewrite;\n                        if (rewritenode.hasDefined(name))\n                            rewrite = rewritenode.get(name);\n                        else\n                            rewrite = rewritenode;\n                        writer.writeStartElement(REWRITE);\n                        writeAttribute(writer, Attribute.PATTERN.getLocalName(), rewrite);\n                        writeAttribute(writer, Attribute.SUBSTITUTION.getLocalName(), rewrite);\n                        writeAttribute(writer, Attribute.FLAGS.getLocalName(), rewrite);\n\n                        if (rewrite.hasDefined(CONDITION)) {\n                            for (final ModelNode conditionnode : rewrite.get(CONDITION).asList()) {\n                                String condname = getAddedConditionName(conditionnode);\n                                ModelNode condition;\n                                if (conditionnode.hasDefined(condname))\n                                    condition = conditionnode.get(condname);\n                                else\n                                    condition = conditionnode;\n                                writer.writeStartElement(CONDITION);\n                                writeAttribute(writer, Attribute.TEST.getLocalName(), condition);\n                                writeAttribute(writer, Attribute.PATTERN.getLocalName(), condition);\n                                writeAttribute(writer, Attribute.FLAGS.getLocalName(), condition);\n                            }\n                        }\n                        writer.writeEndElement();\n                    }\n                }\n                if(config.hasDefined(SSO)) {\n                    final ModelNode sso;\n                    if (config.get(SSO).has(\"configuration\"))\n                        sso = config.get(SSO).get(\"configuration\");\n                    else\n                        sso = config.get(SSO);\n                    if (sso.isDefined()) {\n                        writer.writeStartElement(SSO);\n                        writeAttribute(writer, Attribute.CACHE_CONTAINER.getLocalName(), sso);\n                        writeAttribute(writer, Attribute.DOMAIN.getLocalName(), sso);\n                        writeAttribute(writer, Attribute.REAUTHENTICATE.getLocalName(), sso);\n                        writer.writeEndElement();\n                    }\n                }\n                writer.writeEndElement();\n            }\n        }\n        writer.writeEndElement();\n    }","commit_id":"5025ef613243322f198d036aa15eceedff2f3fbc","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Initialize the configuration model, since add/remove operations would\n     * not make sense. (the operation node should already have the default value set.\n     *\n     * @param context the operation context\n     */\n\n    static void initializeConfiguration(final Resource resource, final ModelNode operation) {\n        // Create the child resources\n        resource.registerChild(JSP, Resource.Factory.create());\n        resource.registerChild(RESOURCE, Resource.Factory.create());\n        resource.registerChild(CONTAINER, Resource.Factory.create());\n\n        final Resource jsp = resource.getChild(JSP);\n        final Resource resources = resource.getChild(RESOURCE);\n\n        final Resource container = resource.getChild(CONTAINER);\n\n        for(final String attribute :  operation.get(CONTAINER_CONFIG).keys()) {\n            if (attribute.equals(JSP_CONFIGURATION)) {\n                populateModel(jsp.getModel(), operation.get(CONTAINER_CONFIG, JSP_CONFIGURATION));\n            } else if (attribute.equals(STATIC_RESOURCES)) {\n                populateModel(resources.getModel(), operation.get(CONTAINER_CONFIG, STATIC_RESOURCES));\n            } else if (attribute.equals(MIME_MAPPING)) {\n                container.getModel().get(MIME_MAPPING).set(operation.get(CONTAINER_CONFIG, MIME_MAPPING));\n            }  else if (attribute.equals(WELCOME_FILE)){\n                for(final ModelNode file : operation.get(CONTAINER_CONFIG, WELCOME_FILE).asList()) {\n                    container.getModel().get(WELCOME_FILE).add(file.asString());\n                }\n            }\n        }\n    }","id":49954,"modified_method":"/**\n     * Initialize the configuration model, since add/remove operations would\n     * not make sense. (the operation node should already have the default value set.\n     *\n     * @param context the operation context\n     */\n\n    static void initializeConfiguration(final Resource resource, final ModelNode operation) {\n        // Create the child resources\n        resource.registerChild(JSP, Resource.Factory.create());\n        resource.registerChild(RESOURCE, Resource.Factory.create());\n\n        final Resource jsp = resource.getChild(JSP);\n        final Resource resources = resource.getChild(RESOURCE);\n\n        System.out.println(\"initializeConfiguration: \" + operation.get(CONTAINER_CONFIG, JSP_CONFIGURATION).keys());\n\n        if(operation.hasDefined(CONTAINER_CONFIG) && operation.get(CONTAINER_CONFIG).hasDefined(JSP_CONFIGURATION)) {\n            populateModel(jsp.getModel(), operation.get(CONTAINER_CONFIG, JSP_CONFIGURATION));\n        }\n\n        if(operation.hasDefined(CONTAINER_CONFIG) && operation.get(CONTAINER_CONFIG).hasDefined(STATIC_RESOURCES)) {\n            populateModel(resources.getModel(), operation.get(CONTAINER_CONFIG, STATIC_RESOURCES));\n        }\n    }","commit_id":"e43f095af905fe811d493a197853ed7e7ebce8ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void initialize(ExtensionContext context) {\n        log.debugf(\"Activating Web Extension\");\n\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(WebSubsystemDescriptionProviders.SUBSYSTEM);\n        registration.registerOperationHandler(ADD, WebSubsystemAdd.INSTANCE, WebSubsystemAdd.INSTANCE, false);\n        registration.registerOperationHandler(DESCRIBE, WebSubsystemDescribe.INSTANCE, WebSubsystemDescribe.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n        // Attributes\n        registration.registerReadWriteAttribute(Constants.NATIVE, null, new WriteAttributeHandlers.ModelTypeValidatingHandler(ModelType.BOOLEAN, true), Storage.CONFIGURATION);\n        registration.registerReadWriteAttribute(Constants.DEFAULT_VIRTUAL_SERVER, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n        subsystem.registerXMLElementWriter(WebSubsystemParser.getInstance());\n\n        // connector\n        final ManagementResourceRegistration connectors = registration.registerSubModel(connectorPath, WebSubsystemDescriptionProviders.CONNECTOR);\n        connectors.registerOperationHandler(ADD, WebConnectorAdd.INSTANCE, WebConnectorAdd.INSTANCE, false);\n        connectors.registerOperationHandler(REMOVE, WebConnectorRemove.INSTANCE, WebConnectorRemove.INSTANCE, false);\n        for(final String attributeName : WebConnectorMetrics.ATTRIBUTES) {\n            connectors.registerMetric(attributeName, WebConnectorMetrics.INSTANCE);\n        }\n        connectors.registerReadWriteAttribute(Constants.PROTOCOL, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n        connectors.registerReadWriteAttribute(Constants.SCHEME, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n        connectors.registerReadWriteAttribute(Constants.SOCKET_BINDING, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1), Storage.CONFIGURATION);\n        connectors.registerReadWriteAttribute(Constants.ENABLE_LOOKUPS, null, new WriteAttributeHandlers.ModelTypeValidatingHandler(ModelType.BOOLEAN, true), Storage.CONFIGURATION);\n        connectors.registerReadWriteAttribute(Constants.PROXY_NAME, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1), Storage.CONFIGURATION);\n        connectors.registerReadWriteAttribute(Constants.PROXY_PORT, null, new WriteAttributeHandlers.IntRangeValidatingHandler(1, true), Storage.CONFIGURATION);\n        connectors.registerReadWriteAttribute(Constants.MAX_POST_SIZE, null, new WriteAttributeHandlers.IntRangeValidatingHandler(1024, true), Storage.CONFIGURATION);\n        connectors.registerReadWriteAttribute(Constants.MAX_SAVE_POST_SIZE, null, new WriteAttributeHandlers.IntRangeValidatingHandler(0, true), Storage.CONFIGURATION);\n        connectors.registerReadWriteAttribute(Constants.ENABLED, null, new WriteAttributeHandlers.ModelTypeValidatingHandler(ModelType.BOOLEAN, true), Storage.CONFIGURATION);\n        connectors.registerReadWriteAttribute(Constants.EXECUTOR, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n        connectors.registerReadWriteAttribute(Constants.MAX_CONNECTIONS, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n        connectors.registerReadWriteAttribute(Constants.VIRTUAL_SERVER, null, new WriteAttributeHandlers. ListValidatatingHandler(new StringLengthValidator(1, false), true), Storage.CONFIGURATION);\n\n        //hosts\n        final ManagementResourceRegistration hosts = registration.registerSubModel(hostPath, WebSubsystemDescriptionProviders.VIRTUAL_SERVER);\n        hosts.registerOperationHandler(ADD, WebVirtualHostAdd.INSTANCE, WebVirtualHostAdd.INSTANCE, false);\n        hosts.registerOperationHandler(REMOVE, WebVirtualHostRemove.INSTANCE, WebVirtualHostRemove.INSTANCE, false);\n        hosts.registerReadWriteAttribute(Constants.ALIAS, null, new WriteAttributeHandlers. ListValidatatingHandler(new StringLengthValidator(1, false), true), Storage.CONFIGURATION);\n        hosts.registerReadWriteAttribute(Constants.ENABLE_WELCOME_ROOT, null, new WriteAttributeHandlers.ModelTypeValidatingHandler(ModelType.BOOLEAN, true), Storage.CONFIGURATION);\n        hosts.registerReadWriteAttribute(Constants.DEFAULT_WEB_MODULE, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n\n        final ManagementResourceRegistration deployments = subsystem.registerDeploymentModel(WebSubsystemDescriptionProviders.DEPLOYMENT);\n        final ManagementResourceRegistration servlets = deployments.registerSubModel(PathElement.pathElement(\"servlet\"), WebSubsystemDescriptionProviders.SERVLET);\n        // Attributes\n        registration.registerReadWriteAttribute(Constants.NATIVE, null, new WriteAttributeHandlers.ModelTypeValidatingHandler(ModelType.BOOLEAN), Storage.CONFIGURATION);\n        registration.registerReadWriteAttribute(Constants.DEFAULT_VIRTUAL_SERVER, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1), Storage.CONFIGURATION);\n        final ManagementResourceRegistration accesslog = hosts.registerSubModel(accesslogPath, WebSubsystemDescriptionProviders.ACCESS_LOG);\n        accesslog.registerOperationHandler(ADD, WebAccessLogAdd.INSTANCE, WebAccessLogAdd.INSTANCE, false);\n        accesslog.registerOperationHandler(REMOVE, WebAccessLogRemove.INSTANCE, WebAccessLogRemove.INSTANCE, false);\n\n        // access-log.\n        // TODO the directory needs one level more\n        final ManagementResourceRegistration directory = accesslog.registerSubModel(directoryPath, WebSubsystemDescriptionProviders.DIRECTORY);\n        directory.registerReadWriteAttribute(Constants.RELATIVE_TO, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n        directory.registerReadWriteAttribute(Constants.PATH, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n\n        accesslog.registerReadWriteAttribute(Constants.PATTERN, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n        accesslog.registerReadWriteAttribute(Constants.RESOLVE_HOSTS, null, new WriteAttributeHandlers.ModelTypeValidatingHandler(ModelType.BOOLEAN, true), Storage.CONFIGURATION);\n        accesslog.registerReadWriteAttribute(Constants.EXTENDED, null, new WriteAttributeHandlers.ModelTypeValidatingHandler(ModelType.BOOLEAN, true), Storage.CONFIGURATION);\n        accesslog.registerReadWriteAttribute(Constants.PREFIX, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n        accesslog.registerReadWriteAttribute(Constants.ROTATE, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n\n        // rewrite valve.\n        final ManagementResourceRegistration rewrite = hosts.registerSubModel(rewritePath, WebSubsystemDescriptionProviders.REWRITE);\n        rewrite.registerOperationHandler(ADD, WebReWriteAdd.INSTANCE, WebReWriteAdd.INSTANCE, false);\n        rewrite.registerOperationHandler(REMOVE, WebReWriteRemove.INSTANCE, WebReWriteRemove.INSTANCE, false);\n\n        // the condition needs one level more\n        final ManagementResourceRegistration rewritecondition = rewrite.registerSubModel(rewritecondPath, WebSubsystemDescriptionProviders.REWRITECOND);\n        rewritecondition.registerOperationHandler(ADD, WebReWriteConditionAdd.INSTANCE, WebReWriteConditionAdd.INSTANCE, false);\n        rewritecondition.registerOperationHandler(REMOVE, WebReWriteConditionRemove.INSTANCE, WebReWriteConditionRemove.INSTANCE, false);\n        rewritecondition.registerReadWriteAttribute(Constants.TEST, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n        rewritecondition.registerReadWriteAttribute(Constants.PATTERN, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n        rewritecondition.registerReadWriteAttribute(Constants.FLAGS, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n\n        rewrite.registerReadWriteAttribute(Constants.CONDITION, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n        rewrite.registerReadWriteAttribute(Constants.PATTERN, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n        rewrite.registerReadWriteAttribute(Constants.SUBSTITUTION, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n        rewrite.registerReadWriteAttribute(Constants.FLAGS, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1, true), Storage.CONFIGURATION);\n\n        // Configuration...\n        final ManagementResourceRegistration conf = registration.registerSubModel(confPath, WebSubsystemDescriptionProviders.CONFIGURATION);\n\n        final ManagementResourceRegistration jsp = registration.registerSubModel(jspconfigurationPath, WebSubsystemDescriptionProviders.JSP_CONFIGURATION);\n        WebConfigurationHandlerUtils.initJSPAttributes(jsp); // Register write attributes\n        final ManagementResourceRegistration resources = registration.registerSubModel(resourcesPath, WebSubsystemDescriptionProviders.STATIC_RESOURCES);\n        WebConfigurationHandlerUtils.initResourcesAttribtues(resources); // Register write attributes\n\n        final ManagementResourceRegistration container = registration.registerSubModel(containerPath, WebSubsystemDescriptionProviders.CONTAINER);\n        container.registerOperationHandler(\"add-mime\", MimeMappingAdd.INSTANCE, MimeMappingAdd.INSTANCE, false);\n        container.registerOperationHandler(\"remove-mime\", MimeMappingRemove.INSTANCE, MimeMappingRemove.INSTANCE, false);\n        container.registerReadWriteAttribute(Constants.WELCOME_FILE, null, new WriteAttributeHandlers. ListValidatatingHandler(new StringLengthValidator(1, false), true), Storage.CONFIGURATION);\n\n        DescriptionProvider NULL = new DescriptionProvider() {\n            @Override\n            public ModelNode getModelDescription(Locale locale) {\n                return new ModelNode();\n            }\n        };\n        final ManagementResourceRegistration deployments = subsystem.registerDeploymentModel(NULL);\n        final ManagementResourceRegistration servlets = deployments.registerSubModel(PathElement.pathElement(\"servlet\"), NULL);\n        ServletDeploymentStats.register(servlets);\n    }","id":49955,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void initialize(ExtensionContext context) {\n        log.debugf(\"Activating Web Extension\");\n\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(WebSubsystemDescriptionProviders.SUBSYSTEM);\n        registration.registerOperationHandler(ADD, WebSubsystemAdd.INSTANCE, WebSubsystemAdd.INSTANCE, false);\n        registration.registerOperationHandler(DESCRIBE, WebSubsystemDescribe.INSTANCE, WebSubsystemDescribe.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n        subsystem.registerXMLElementWriter(WebSubsystemParser.getInstance());\n        // connector\n        final ManagementResourceRegistration connectors = registration.registerSubModel(connectorPath, WebSubsystemDescriptionProviders.CONNECTOR);\n        connectors.registerOperationHandler(ADD, WebConnectorAdd.INSTANCE, WebConnectorAdd.INSTANCE, false);\n        connectors.registerOperationHandler(REMOVE, WebConnectorRemove.INSTANCE, WebConnectorRemove.INSTANCE, false);\n        for(final String attributeName : WebConnectorMetrics.ATTRIBUTES) {\n            connectors.registerMetric(attributeName, WebConnectorMetrics.INSTANCE);\n        }\n        //hosts\n        final ManagementResourceRegistration hosts = registration.registerSubModel(hostPath, WebSubsystemDescriptionProviders.VIRTUAL_SERVER);\n        hosts.registerOperationHandler(ADD, WebVirtualHostAdd.INSTANCE, WebVirtualHostAdd.INSTANCE, false);\n        hosts.registerOperationHandler(REMOVE, WebVirtualHostRemove.INSTANCE, WebVirtualHostRemove.INSTANCE, false);\n\n        final ManagementResourceRegistration deployments = subsystem.registerDeploymentModel(WebSubsystemDescriptionProviders.DEPLOYMENT);\n        final ManagementResourceRegistration servlets = deployments.registerSubModel(PathElement.pathElement(\"servlet\"), WebSubsystemDescriptionProviders.SERVLET);\n        // Attributes\n        registration.registerReadWriteAttribute(Constants.NATIVE, null, new WriteAttributeHandlers.ModelTypeValidatingHandler(ModelType.BOOLEAN), Storage.CONFIGURATION);\n        registration.registerReadWriteAttribute(Constants.DEFAULT_VIRTUAL_SERVER, null, new WriteAttributeHandlers.StringLengthValidatingHandler(1), Storage.CONFIGURATION);\n\n        // Configuration...\n        final ManagementResourceRegistration jsp = registration.registerSubModel(jspconfigurationPath, WebSubsystemDescriptionProviders.JSP_CONFIGURATION);\n        WebConfigurationHandlerUtils.initJSPAttributes(jsp); // Register write attributes\n        final ManagementResourceRegistration resources = registration.registerSubModel(resourcesPath, WebSubsystemDescriptionProviders.STATIC_RESOURCES);\n        WebConfigurationHandlerUtils.initResourcesAttribtues(resources); // Register write attributes\n\n        DescriptionProvider NULL = new DescriptionProvider() {\n            @Override\n            public ModelNode getModelDescription(Locale locale) {\n                return new ModelNode();\n            }\n        };\n        final ManagementResourceRegistration deployments = subsystem.registerDeploymentModel(NULL);\n        final ManagementResourceRegistration servlets = deployments.registerSubModel(PathElement.pathElement(\"servlet\"), NULL);\n        ServletDeploymentStats.register(servlets);\n    }","commit_id":"e43f095af905fe811d493a197853ed7e7ebce8ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n        ModelNode node = context.getModelNode();\n\n        writeAttribute(writer, Attribute.NATIVE.getLocalName(), node);\n        writeAttribute(writer, Attribute.DEFAULT_VIRTUAL_SERVER.getLocalName(), node);\n        writeAttribute(writer, Attribute.INSTANCE_ID.getLocalName(), node);\n        if(node.hasDefined(CONTAINER_CONFIG)) {\n            writeContainerConfig(writer, node.get(CONTAINER_CONFIG));\n        }\n        if(node.hasDefined(CONNECTOR)) {\n            for(final Property connector : node.get(CONNECTOR).asPropertyList()) {\n                final ModelNode config = connector.getValue();\n                writer.writeStartElement(Element.CONNECTOR.getLocalName());\n                writer.writeAttribute(NAME, connector.getName());\n                writeAttribute(writer, Attribute.PROTOCOL.getLocalName(), config);\n                writeAttribute(writer, Attribute.SOCKET_BINDING.getLocalName(), config);\n                writeAttribute(writer, Attribute.SCHEME.getLocalName(), config);\n                writeAttribute(writer, Attribute.ENABLED.getLocalName(), config);\n                writeAttribute(writer, Attribute.ENABLE_LOOKUPS.getLocalName(), config);\n                writeAttribute(writer, Attribute.PROXY_NAME.getLocalName(), config);\n                writeAttribute(writer, Attribute.PROXY_PORT.getLocalName(), config);\n                writeAttribute(writer, Attribute.SECURE.getLocalName(), config);\n                writeAttribute(writer, Attribute.EXECUTOR.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_POST_SIZE.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_SAVE_POST_SIZE.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_CONNECTIONS.getLocalName(), config);\n                writeAttribute(writer, Attribute.REDIRECT_PORT.getLocalName(), config);\n                if (config.hasDefined(SSL)) {\n                    writer.writeStartElement(Element.SSL.getLocalName());\n                    final ModelNode sslConfig = config.get(SSL);\n                    writeAttribute(writer, Attribute.NAME.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.KEY_ALIAS.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.PASSWORD.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CERTIFICATE_KEY_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CIPHER_SUITE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.PROTOCOL.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.VERIFY_CLIENT.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.VERIFY_DEPTH.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CERTIFICATE_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CA_CERTIFICATE_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CA_REVOCATION_URL.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.SESSION_CACHE_SIZE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.SESSION_TIMEOUT.getLocalName(), sslConfig);\n                    writer.writeEndElement();\n                }\n                if (config.hasDefined(VIRTUAL_SERVER)) {\n                    for(final ModelNode virtualServer : config.get(VIRTUAL_SERVER).asList()) {\n                        writer.writeEmptyElement(VIRTUAL_SERVER);\n                        writer.writeAttribute(NAME, virtualServer.asString());\n                    }\n                }\n                writer.writeEndElement();\n            }\n        }\n        if(node.hasDefined(VIRTUAL_SERVER)) {\n            for(final Property host : node.get(VIRTUAL_SERVER).asPropertyList()) {\n                final ModelNode config = host.getValue();\n                writer.writeStartElement(Element.VIRTUAL_SERVER.getLocalName());\n                writer.writeAttribute(NAME, host.getName());\n                writeAttribute(writer, Attribute.DEFAULT_WEB_MODULE.getLocalName(), config);\n                if (config.hasDefined(ENABLE_WELCOME_ROOT) && config.get(ENABLE_WELCOME_ROOT).asBoolean())\n                    writer.writeAttribute(ENABLE_WELCOME_ROOT, \"true\");\n\n                if(config.hasDefined(ALIAS)) {\n                    for(final ModelNode alias : config.get(ALIAS).asList()) {\n                        writer.writeEmptyElement(ALIAS);\n                        writer.writeAttribute(NAME, alias.asString());\n                    }\n                }\n                ModelNode accessLog;\n                if (config.get(ACCESS_LOG).isDefined() && config.get(ACCESS_LOG).has(\"configuration\")) {\n                    accessLog = config.get(ACCESS_LOG).get(\"configuration\");\n                } else {\n                    accessLog = config.get(ACCESS_LOG);\n                }\n                if (accessLog.isDefined() && !accessLog.keys().isEmpty()) {\n                    writer.writeStartElement(Element.ACCESS_LOG.getLocalName());\n                    final ModelNode accessLog = config.get(ACCESS_LOG);\n                    writeAttribute(writer, Attribute.PATTERN.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.RESOLVE_HOSTS.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.EXTENDED.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.PREFIX.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.ROTATE.getLocalName(), accessLog);\n                    if(accessLog.has(DIRECTORY)) {\n                        ModelNode directory;\n                        if (accessLog.get(DIRECTORY).has(\"configuration\"))\n                            directory = accessLog.get(DIRECTORY).get(\"configuration\");\n                        else\n                            directory = accessLog.get(DIRECTORY);\n                        if (directory.isDefined()) {\n                            writer.writeStartElement(Element.DIRECTORY.getLocalName());\n                            writeAttribute(writer, Attribute.PATH.getLocalName(), directory);\n                            writeAttribute(writer, Attribute.RELATIVE_TO.getLocalName(), directory);\n                            writer.writeEndElement();\n                        }\n                    }\n                    writer.writeEndElement();\n                }\n\n                if (config.hasDefined(REWRITE)) {\n                    for (final ModelNode rewritenode : config.get(REWRITE).asList()) {\n                        String name = getAddedRule(rewritenode);\n                        ModelNode rewrite;\n                        if (rewritenode.hasDefined(name))\n                            rewrite = rewritenode.get(name);\n                        else\n                            rewrite = rewritenode;\n                        writer.writeStartElement(REWRITE);\n                        writeAttribute(writer, Attribute.PATTERN.getLocalName(), rewrite);\n                        writeAttribute(writer, Attribute.SUBSTITUTION.getLocalName(), rewrite);\n                        writeAttribute(writer, Attribute.FLAGS.getLocalName(), rewrite);\n\n                        if (rewrite.hasDefined(CONDITION)) {\n                            for (final ModelNode conditionnode : rewrite.get(CONDITION).asList()) {\n                                String condname = getAddedConditionName(conditionnode);\n                                ModelNode condition;\n                                if (conditionnode.hasDefined(condname))\n                                    condition = conditionnode.get(condname);\n                                else\n                                    condition = conditionnode;\n                                writer.writeStartElement(CONDITION);\n                                writeAttribute(writer, Attribute.TEST.getLocalName(), condition);\n                                writeAttribute(writer, Attribute.PATTERN.getLocalName(), condition);\n                                writeAttribute(writer, Attribute.FLAGS.getLocalName(), condition);\n                            }\n                        }\n                        writer.writeEndElement();\n                    }\n                }\n                if(config.hasDefined(SSO)) {\n                    writer.writeEmptyElement(SSO);\n                    final ModelNode sso = config.get(SSO);\n                    writeAttribute(writer, Attribute.CACHE_CONTAINER.getLocalName(), sso);\n                    writeAttribute(writer, Attribute.DOMAIN.getLocalName(), sso);\n                    writeAttribute(writer, Attribute.REAUTHENTICATE.getLocalName(), sso);\n                }\n                writer.writeEndElement();\n            }\n        }\n        writer.writeEndElement();\n    }","id":49956,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n        ModelNode node = context.getModelNode();\n        writeAttribute(writer, Attribute.NATIVE.getLocalName(), node);\n        writeAttribute(writer, Attribute.DEFAULT_VIRTUAL_SERVER.getLocalName(), node);\n        writeAttribute(writer, Attribute.INSTANCE_ID.getLocalName(), node);\n        if(node.hasDefined(CONTAINER_CONFIG)) {\n            writeContainerConfig(writer, node.get(CONTAINER_CONFIG));\n        }\n        if(node.hasDefined(CONNECTOR)) {\n            for(final Property connector : node.get(CONNECTOR).asPropertyList()) {\n                final ModelNode config = connector.getValue();\n                writer.writeStartElement(Element.CONNECTOR.getLocalName());\n                writer.writeAttribute(NAME, connector.getName());\n                writeAttribute(writer, Attribute.PROTOCOL.getLocalName(), config);\n                writeAttribute(writer, Attribute.SOCKET_BINDING.getLocalName(), config);\n                writeAttribute(writer, Attribute.SCHEME.getLocalName(), config);\n                writeAttribute(writer, Attribute.ENABLED.getLocalName(), config);\n                writeAttribute(writer, Attribute.ENABLE_LOOKUPS.getLocalName(), config);\n                writeAttribute(writer, Attribute.PROXY_NAME.getLocalName(), config);\n                writeAttribute(writer, Attribute.PROXY_PORT.getLocalName(), config);\n                writeAttribute(writer, Attribute.SECURE.getLocalName(), config);\n                writeAttribute(writer, Attribute.EXECUTOR.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_POST_SIZE.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_SAVE_POST_SIZE.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_CONNECTIONS.getLocalName(), config);\n                writeAttribute(writer, Attribute.REDIRECT_PORT.getLocalName(), config);\n                if (config.hasDefined(SSL)) {\n                    writer.writeStartElement(Element.SSL.getLocalName());\n                    final ModelNode sslConfig = config.get(SSL);\n                    writeAttribute(writer, Attribute.NAME.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.KEY_ALIAS.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.PASSWORD.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CERTIFICATE_KEY_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CIPHER_SUITE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.PROTOCOL.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.VERIFY_CLIENT.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.VERIFY_DEPTH.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CERTIFICATE_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CA_CERTIFICATE_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CA_REVOCATION_URL.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.SESSION_CACHE_SIZE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.SESSION_TIMEOUT.getLocalName(), sslConfig);\n                    writer.writeEndElement();\n                }\n                if (config.hasDefined(VIRTUAL_SERVER)) {\n                    for(final ModelNode virtualServer : config.get(VIRTUAL_SERVER).asList()) {\n                        writer.writeEmptyElement(VIRTUAL_SERVER);\n                        writer.writeAttribute(NAME, virtualServer.asString());\n                    }\n                }\n                writer.writeEndElement();\n            }\n        }\n        if(node.hasDefined(VIRTUAL_SERVER)) {\n            for(final Property host : node.get(VIRTUAL_SERVER).asPropertyList()) {\n                final ModelNode config = host.getValue();\n                writer.writeStartElement(Element.VIRTUAL_SERVER.getLocalName());\n                writer.writeAttribute(NAME, host.getName());\n                writeAttribute(writer, Attribute.DEFAULT_WEB_MODULE.getLocalName(), config);\n                if (config.hasDefined(ENABLE_WELCOME_ROOT) && config.get(ENABLE_WELCOME_ROOT).asBoolean())\n                    writer.writeAttribute(ENABLE_WELCOME_ROOT, \"true\");\n\n                if(config.hasDefined(ALIAS)) {\n                    for(final ModelNode alias : config.get(ALIAS).asList()) {\n                        writer.writeEmptyElement(ALIAS);\n                        writer.writeAttribute(NAME, alias.asString());\n                    }\n                }\n                if(config.hasDefined(ACCESS_LOG)) {\n                    writer.writeStartElement(Element.ACCESS_LOG.getLocalName());\n                    final ModelNode accessLog = config.get(ACCESS_LOG);\n                    writeAttribute(writer, Attribute.PATTERN.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.RESOLVE_HOSTS.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.EXTENDED.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.PREFIX.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.ROTATE.getLocalName(), accessLog);\n                    if(accessLog.has(DIRECTORY)) {\n                        final ModelNode directory = accessLog.get(DIRECTORY);\n                        writer.writeEmptyElement(DIRECTORY);\n                        writeAttribute(writer, Attribute.PATH.getLocalName(), directory);\n                        writeAttribute(writer, Attribute.RELATIVE_TO.getLocalName(), directory);\n                    }\n                    writer.writeEndElement();\n                }\n                if (config.hasDefined(REWRITE)) {\n                    for (final ModelNode rewrite : config.get(REWRITE).asList()) {\n                        writer.writeStartElement(REWRITE);\n                        writeAttribute(writer, Attribute.PATTERN.getLocalName(), rewrite);\n                        writeAttribute(writer, Attribute.SUBSTITUTION.getLocalName(), rewrite);\n                        writeAttribute(writer, Attribute.FLAGS.getLocalName(), rewrite);\n                        if (rewrite.hasDefined(CONDITION)) {\n                            for (final ModelNode condition : rewrite.get(CONDITION).asList()) {\n                                writer.writeEmptyElement(CONDITION);\n                                writeAttribute(writer, Attribute.TEST.getLocalName(), condition);\n                                writeAttribute(writer, Attribute.PATTERN.getLocalName(), condition);\n                                writeAttribute(writer, Attribute.FLAGS.getLocalName(), condition);\n                            }\n                        }\n                        writer.writeEndElement();\n                    }\n                }\n                if(config.hasDefined(SSO)) {\n                    writer.writeEmptyElement(SSO);\n                    final ModelNode sso = config.get(SSO);\n                    writeAttribute(writer, Attribute.CACHE_CONTAINER.getLocalName(), sso);\n                    writeAttribute(writer, Attribute.DOMAIN.getLocalName(), sso);\n                    writeAttribute(writer, Attribute.REAUTHENTICATE.getLocalName(), sso);\n                }\n                writer.writeEndElement();\n            }\n        }\n        writer.writeEndElement();\n    }","commit_id":"e43f095af905fe811d493a197853ed7e7ebce8ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeContainerConfig(XMLExtendedStreamWriter writer, ModelNode config) throws XMLStreamException {\n        boolean containerConfigStartWritten = false;\n        if(config.hasDefined(STATIC_RESOURCES)) {\n            containerConfigStartWritten = writeStaticResources(writer, config.get(STATIC_RESOURCES));\n        }\n        if(config.hasDefined(JSP_CONFIGURATION)) {\n            containerConfigStartWritten = writeJSPConfiguration(writer, config.get(JSP_CONFIGURATION), containerConfigStartWritten) || containerConfigStartWritten ;\n        }\n        ModelNode container = config;\n        if(config.hasDefined(CONTAINER)) {\n            // this has been added to get the stuff manageable\n            container = config.get(CONTAINER);\n        }\n        if(container.hasDefined(MIME_MAPPING)) {\n            if (!containerConfigStartWritten) {\n                writer.writeStartElement(Element.CONTAINER_CONFIG.getLocalName());\n                containerConfigStartWritten = true;\n            }\n            for(final Property entry : container.get(MIME_MAPPING).asPropertyList()) {\n                writer.writeEmptyElement(Element.MIME_MAPPING.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), entry.getName());\n                writer.writeAttribute(Attribute.VALUE.getLocalName(), entry.getValue().asString());\n            }\n        }\n        if(container.hasDefined(WELCOME_FILE)) {\n            if (!containerConfigStartWritten) {\n                writer.writeStartElement(Element.CONTAINER_CONFIG.getLocalName());\n                containerConfigStartWritten = true;\n            }\n            for(final ModelNode file : container.get(WELCOME_FILE).asList()) {\n                writer.writeStartElement(Element.WELCOME_FILE.getLocalName());\n                writer.writeCharacters(file.asString());\n                writer.writeEndElement();\n            }\n        }\n        if (containerConfigStartWritten) {\n            writer.writeEndElement();\n        }\n    }","id":49957,"modified_method":"private void writeContainerConfig(XMLExtendedStreamWriter writer, ModelNode config) throws XMLStreamException {\n        boolean containerConfigStartWritten = false;\n        if(config.hasDefined(STATIC_RESOURCES)) {\n            containerConfigStartWritten = writeStaticResources(writer, config.get(STATIC_RESOURCES));\n        }\n        if(config.hasDefined(JSP_CONFIGURATION)) {\n            containerConfigStartWritten = writeJSPConfiguration(writer, config.get(JSP_CONFIGURATION), containerConfigStartWritten) || containerConfigStartWritten ;\n        }\n        if(config.hasDefined(MIME_MAPPING)) {\n            if (!containerConfigStartWritten) {\n                writer.writeStartElement(Element.CONTAINER_CONFIG.getLocalName());\n                containerConfigStartWritten = true;\n            }\n            for(final Property entry : config.get(MIME_MAPPING).asPropertyList()) {\n                writer.writeEmptyElement(Element.MIME_MAPPING.getLocalName());\n                writer.writeAttribute(Attribute.NAME.getLocalName(), entry.getName());\n                writer.writeAttribute(Attribute.VALUE.getLocalName(), entry.getValue().asString());\n            }\n        }\n        if(config.hasDefined(WELCOME_FILE)) {\n            if (!containerConfigStartWritten) {\n                writer.writeStartElement(Element.CONTAINER_CONFIG.getLocalName());\n                containerConfigStartWritten = true;\n            }\n            for(final ModelNode file : config.get(WELCOME_FILE).asList()) {\n                writer.writeStartElement(Element.WELCOME_FILE.getLocalName());\n                writer.writeCharacters(file.asString());\n                writer.writeEndElement();\n            }\n        }\n        if (containerConfigStartWritten) {\n            writer.writeEndElement();\n        }\n    }","commit_id":"e43f095af905fe811d493a197853ed7e7ebce8ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"static ModelNode parseHostRewrite(XMLExtendedStreamReader reader) throws XMLStreamException {\n        final ModelNode rewrite = new ModelNode();\n        rewrite.setEmptyObject();\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n            case PATTERN:\n                rewrite.get(PATTERN).set(value);\n                break;\n            case SUBSTITUTION:\n                rewrite.get(SUBSTITUTION).set(value);\n                break;\n            case FLAGS:\n                rewrite.get(FLAGS).set(value);\n                break;\n            default:\n                throw unexpectedAttribute(reader, i);\n            }\n        }\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n            case WEB_1_0: {\n                final Element element = Element.forName(reader.getLocalName());\n                switch (element) {\n                case CONDITION:\n                    final ModelNode condition = new ModelNode();\n                    condition.setEmptyObject();\n                    final int count2 = reader.getAttributeCount();\n                    for (int i = 0; i < count2; i++) {\n                        requireNoNamespaceAttribute(reader, i);\n                        final String value = reader.getAttributeValue(i);\n                        final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                        switch (attribute) {\n                        case TEST:\n                            condition.get(TEST).set(value);\n                            break;\n                        case PATTERN:\n                            condition.get(PATTERN).set(value);\n                            break;\n                        case FLAGS:\n                            condition.get(FLAGS).set(value);\n                            break;\n                        default:\n                            throw unexpectedAttribute(reader, i);\n                        }\n                    }\n                    requireNoContent(reader);\n                    rewrite.get(CONDITION).add(condition);\n                    break;\n                default:\n                    throw unexpectedElement(reader);\n                }\n                break;\n            }\n            default:\n                throw unexpectedElement(reader);\n            }\n        }\n        return rewrite;\n    }","id":49958,"modified_method":"static ModelNode parseHostRewrite(XMLExtendedStreamReader reader) throws XMLStreamException {\n        final ModelNode rewrite = new ModelNode();\n        rewrite.setEmptyObject();\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i++) {\n            requireNoNamespaceAttribute(reader, i);\n            final String value = reader.getAttributeValue(i);\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n            case PATTERN:\n                rewrite.get(PATTERN).set(value);\n                break;\n            case SUBSTITUTION:\n                rewrite.get(SUBSTITUTION).set(value);\n                break;\n            case FLAGS:\n                rewrite.get(REWRITE).set(value);\n                break;\n            default:\n                throw unexpectedAttribute(reader, i);\n            }\n        }\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n            case WEB_1_0: {\n                final Element element = Element.forName(reader.getLocalName());\n                switch (element) {\n                case CONDITION:\n                    final ModelNode condition = new ModelNode();\n                    condition.setEmptyObject();\n                    final int count2 = reader.getAttributeCount();\n                    for (int i = 0; i < count2; i++) {\n                        requireNoNamespaceAttribute(reader, i);\n                        final String value = reader.getAttributeValue(i);\n                        final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n                        switch (attribute) {\n                        case TEST:\n                            condition.get(TEST).set(value);\n                            break;\n                        case PATTERN:\n                            condition.get(PATTERN).set(value);\n                            break;\n                        case FLAGS:\n                            condition.get(FLAGS).set(value);\n                            break;\n                        default:\n                            throw unexpectedAttribute(reader, i);\n                        }\n                    }\n                    requireNoContent(reader);\n                    rewrite.get(CONDITION).add(condition);\n                    break;\n                default:\n                    throw unexpectedElement(reader);\n                }\n                break;\n            }\n            default:\n                throw unexpectedElement(reader);\n            }\n        }\n        return rewrite;\n    }","commit_id":"e43f095af905fe811d493a197853ed7e7ebce8ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) {\n        model.get(Constants.ALIAS).set(operation.get(Constants.ALIAS));\n        model.get(Constants.ACCESS_LOG).set(operation.get(Constants.ACCESS_LOG));\n        model.get(Constants.ACCESS_LOG).get(Constants.DIRECTORY).set(operation.get(Constants.ACCESS_LOG).get(Constants.DIRECTORY));\n        model.get(Constants.REWRITE).set(operation.get(Constants.REWRITE));\n        model.get(Constants.SSO).set(operation.get(Constants.SSO));\n        model.get(Constants.DEFAULT_WEB_MODULE).set(operation.get(Constants.DEFAULT_WEB_MODULE));\n\n        final boolean welcome = operation.hasDefined(Constants.ENABLE_WELCOME_ROOT) && operation.get(Constants.ENABLE_WELCOME_ROOT).asBoolean();\n        model.get(Constants.ENABLE_WELCOME_ROOT).set(welcome);\n    }","id":49959,"modified_method":"protected void populateModel(ModelNode operation, ModelNode model) {\n        model.get(Constants.ALIAS).set(operation.get(Constants.ALIAS));\n        model.get(Constants.ACCESS_LOG).set(operation.get(Constants.ACCESS_LOG));\n        model.get(Constants.REWRITE).set(operation.get(Constants.REWRITE));\n        model.get(Constants.SSO).set(operation.get(Constants.SSO));\n        model.get(Constants.DEFAULT_WEB_MODULE).set(operation.get(Constants.DEFAULT_WEB_MODULE));\n\n        final boolean welcome = operation.hasDefined(Constants.ENABLE_WELCOME_ROOT) && operation.get(Constants.ENABLE_WELCOME_ROOT).asBoolean();\n        model.get(Constants.ENABLE_WELCOME_ROOT).set(welcome);\n    }","commit_id":"e43f095af905fe811d493a197853ed7e7ebce8ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.require(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n        boolean welcome = operation.hasDefined(Constants.ENABLE_WELCOME_ROOT) && operation.get(Constants.ENABLE_WELCOME_ROOT).asBoolean();\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final WebVirtualHostService service = new WebVirtualHostService(name, aliases(operation), welcome);\n        final ServiceBuilder<?> serviceBuilder = serviceTarget.addService(WebSubsystemServices.JBOSS_WEB_HOST.append(name), service)\n                .addDependency(AbstractPathService.pathNameOf(TEMP_DIR), String.class, service.getTempPathInjector())\n                .addDependency(WebSubsystemServices.JBOSS_WEB, WebServer.class, service.getWebServer());\n        if (operation.hasDefined(Constants.ACCESS_LOG)) {\n            final ModelNode accessLog = operation.get(Constants.ACCESS_LOG);\n            service.setAccessLog(accessLog.clone());\n            // Create the access log service\n            accessLogService(name, accessLog, serviceTarget, newControllers, verificationHandler);\n            serviceBuilder.addDependency(WebSubsystemServices.JBOSS_WEB_HOST.append(name, Constants.ACCESS_LOG), String.class, service.getAccessLogPathInjector());\n        }\n        if (operation.hasDefined(Constants.REWRITE)) {\n            // there is a list of rule-n from the management logic\n            service.setRewrite(operation.get(Constants.REWRITE).clone());\n        }\n        if (operation.hasDefined(Constants.SSO)) {\n            service.setSso(operation.get(Constants.SSO).clone());\n            // FIXME: If a cache container is defined, add the dependency and inject it\n        }\n\n        if (operation.hasDefined(Constants.DEFAULT_WEB_MODULE)) {\n            if (welcome)\n                throw new OperationFailedException(new ModelNode().set(\"A default module can not be specified when the welcome root is enabled.\"));\n            service.setDefaultWebModule(operation.get(Constants.DEFAULT_WEB_MODULE).asString());\n        }\n\n        serviceBuilder.addListener(verificationHandler);\n        newControllers.add(serviceBuilder.install());\n\n        if (welcome) {\n            final WelcomeContextService welcomeService = new WelcomeContextService();\n            newControllers.add(context.getServiceTarget().addService(WebSubsystemServices.JBOSS_WEB.append(name).append(\"welcome\"), welcomeService)\n                    .addDependency(AbstractPathService.pathNameOf(HOME_DIR), String.class, welcomeService.getPathInjector())\n                    .addDependency(WebSubsystemServices.JBOSS_WEB_HOST.append(name), VirtualHost.class, welcomeService.getHostInjector())\n                    .addDependency(ServiceBuilder.DependencyType.OPTIONAL, HttpManagementService.SERVICE_NAME, HttpManagement.class, welcomeService.getHttpManagementInjector())\n                    .addListener(verificationHandler)\n                    .setInitialMode(ServiceController.Mode.ACTIVE)\n                    .install());\n        }\n    }","id":49960,"modified_method":"protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.require(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n        boolean welcome = operation.hasDefined(Constants.ENABLE_WELCOME_ROOT) && operation.get(Constants.ENABLE_WELCOME_ROOT).asBoolean();\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final WebVirtualHostService service = new WebVirtualHostService(name, aliases(operation), welcome);\n        final ServiceBuilder<?> serviceBuilder = serviceTarget.addService(WebSubsystemServices.JBOSS_WEB_HOST.append(name), service)\n                .addDependency(AbstractPathService.pathNameOf(TEMP_DIR), String.class, service.getTempPathInjector())\n                .addDependency(WebSubsystemServices.JBOSS_WEB, WebServer.class, service.getWebServer());\n        if (operation.hasDefined(Constants.ACCESS_LOG)) {\n            final ModelNode accessLog = operation.get(Constants.ACCESS_LOG);\n            service.setAccessLog(accessLog.clone());\n            // Create the access log service\n            accessLogService(name, accessLog, serviceTarget, newControllers, verificationHandler);\n            serviceBuilder.addDependency(WebSubsystemServices.JBOSS_WEB_HOST.append(name, Constants.ACCESS_LOG), String.class, service.getAccessLogPathInjector());\n        }\n        if (operation.hasDefined(Constants.REWRITE)) {\n            service.setRewrite(operation.get(Constants.REWRITE).clone());\n        }\n        if (operation.hasDefined(Constants.SSO)) {\n            service.setSso(operation.get(Constants.SSO).clone());\n            // FIXME: If a cache container is defined, add the dependency and inject it\n        }\n\n        if (operation.hasDefined(Constants.DEFAULT_WEB_MODULE)) {\n            if (welcome)\n                throw new OperationFailedException(new ModelNode().set(\"A default module can not be specified when the welcome root is enabled.\"));\n            service.setDefaultWebModule(operation.get(Constants.DEFAULT_WEB_MODULE).asString());\n        }\n\n        serviceBuilder.addListener(verificationHandler);\n        newControllers.add(serviceBuilder.install());\n\n        if (welcome) {\n            final WelcomeContextService welcomeService = new WelcomeContextService();\n            newControllers.add(context.getServiceTarget().addService(WebSubsystemServices.JBOSS_WEB.append(name).append(\"welcome\"), welcomeService)\n                    .addDependency(AbstractPathService.pathNameOf(HOME_DIR), String.class, welcomeService.getPathInjector())\n                    .addDependency(WebSubsystemServices.JBOSS_WEB_HOST.append(name), VirtualHost.class, welcomeService.getHostInjector())\n                    .addDependency(ServiceBuilder.DependencyType.OPTIONAL, HttpManagementService.SERVICE_NAME, HttpManagement.class, welcomeService.getHttpManagementInjector())\n                    .addListener(verificationHandler)\n                    .setInitialMode(ServiceController.Mode.ACTIVE)\n                    .install());\n        }\n    }","commit_id":"e43f095af905fe811d493a197853ed7e7ebce8ee","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void deleteRecursively(File file) {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                for (String name : file.list()) {\n                    deleteRecursively(new File(file, name));\n                }\n            }\n            if (!file.delete()) {\n                log.warn(\"Could not delete \" + file);\n            }\n        }\n    }","id":49961,"modified_method":"private void deleteRecursively(Path file) throws IOException {\n        if (Files.exists(file)) {\n            Files.walkFileTree(file, new SimpleFileVisitor<Path>() {\n                @Override\n                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                    Files.delete(file);\n                    return FileVisitResult.CONTINUE;\n                }\n\n                @Override\n                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n                    Files.delete(dir);\n                    return FileVisitResult.CONTINUE;\n                }\n\n            });\n        }\n    }","commit_id":"cada07592b9498ac5493f206be08ed105cbbf318","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void remove(final ModelNode address, final ManagementClient managementClient) throws IOException, MgmtOperationException {\n        final ModelNode operation = new ModelNode();\n        operation.get(OP).set(\"remove\");\n        operation.get(OP_ADDR).set(address);\n        final ModelNode result = executeOperation(operation, false);\n\n        if (!SUCCESS.equals(result.get(OUTCOME).asString())) {\n            throw new MgmtOperationException(\"Module removal failed: \" + result.get(FAILURE_DESCRIPTION), operation, result);\n        }\n        final ModelNode responseHeaders = result.get(RESPONSE_HEADERS);\n        if (responseHeaders.isDefined() && responseHeaders.get(PROCESS_STATE).isDefined()\n                && ControlledProcessState.State.RELOAD_REQUIRED.toString().equals(responseHeaders.get(PROCESS_STATE).asString())) {\n            reload(managementClient);\n        }\n    }","id":49962,"modified_method":"protected void remove(final ModelNode address, final ManagementClient managementClient) throws IOException, MgmtOperationException {\n        final ModelNode operation = new ModelNode();\n        operation.get(OP).set(\"remove\");\n        operation.get(OP_ADDR).set(address);\n        final ModelNode result = managementClient.getControllerClient().execute(operation);\n\n        if (!SUCCESS.equals(result.get(OUTCOME).asString())) {\n            throw new MgmtOperationException(\"Module removal failed: \" + result.get(FAILURE_DESCRIPTION), operation, result);\n        }\n        final ModelNode responseHeaders = result.get(RESPONSE_HEADERS);\n        if (responseHeaders.hasDefined(PROCESS_STATE) && ControlledProcessState.State.RELOAD_REQUIRED.toString().equals(responseHeaders.get(PROCESS_STATE).asString())) {\n            this.reloadRequired = true;\n        }\n    }","commit_id":"cada07592b9498ac5493f206be08ed105cbbf318","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void tearDown(final ManagementClient managementClient, final String containerId)\n            throws Exception {\n        takeSnapShot();\n        try {\n            remove(address, managementClient);\n        } finally {\n            removeModule(defaultPath, true);\n        }\n    }","id":49963,"modified_method":"@Override\n    public void tearDown(final ManagementClient managementClient, final String containerId) throws Exception {\n        try {\n            remove(address, managementClient);\n        } finally {\n            removeModule(defaultPath, true);\n        }\n        if (reloadRequired){\n            executeReload();\n        }\n        for (Path p:toRemove) {\n            deleteRecursively(p);\n        }\n        toRemove.clear();\n    }","commit_id":"cada07592b9498ac5493f206be08ed105cbbf318","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void removeModule(final String moduleName, boolean deleteParent) throws Exception {\n        testModuleRoot = new File(getModulePath(), moduleName);\n        File file = testModuleRoot;\n        if (deleteParent) {\n            while (!getModulePath().equals(file.getParentFile()))\n                file = file.getParentFile();\n        }\n        deleteRecursively(file);\n    }","id":49964,"modified_method":"public void removeModule(final String moduleName, boolean deleteParent) throws Exception {\n        testModuleRoot = new File(getModulePath(), moduleName);\n        File file = testModuleRoot;\n        if (deleteParent) {\n            while (!getModulePath().equals(file.getParentFile()))\n                file = file.getParentFile();\n        }\n        toRemove.add(file.toPath());\n    }","commit_id":"cada07592b9498ac5493f206be08ed105cbbf318","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void copyModuleXml(File slot, InputStream src) throws IOException {\n        BufferedReader in = null;\n        PrintWriter out = null;\n        try {\n            in = new BufferedReader(new InputStreamReader(src));\n            out = new PrintWriter(new File(slot, \"module.xml\"));\n            String line;\n            while ((line = in.readLine()) != null) {\n                // replace slot name in the module xml file\n                line = MODULE_SLOT_PATTERN.matcher(line).replaceAll(\"slot=\\\"\" + getSlot() + \"\\\"\");\n                out.println(line);\n            }\n        } finally {\n            IoUtils.safeClose(in);\n            IoUtils.safeClose(out);\n        }\n    }","id":49965,"modified_method":"protected void copyModuleXml(File slot, InputStream src) throws IOException {\n        try(BufferedReader in = new BufferedReader(new InputStreamReader(src));\n                PrintWriter out = new PrintWriter(new File(slot, \"module.xml\"));) {\n            String line;\n            while ((line = in.readLine()) != null) {\n                // replace slot name in the module xml file\n                line = MODULE_SLOT_PATTERN.matcher(line).replaceAll(\"slot=\\\"\" + getSlot() + \"\\\"\");\n                out.println(line);\n            }\n        }\n    }","commit_id":"cada07592b9498ac5493f206be08ed105cbbf318","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void setBadModel(String filename) throws Exception{\n        setModel(filename);\n        takeSnapShot();\n        removeDs();\n    }","id":49966,"modified_method":"protected void setBadModel(String filename) throws Exception{\n        setModel(filename);\n        removeDs();\n    }","commit_id":"cada07592b9498ac5493f206be08ed105cbbf318","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n\t\tpublic void tearDown(ManagementClient managementClient,\n\t\t\t\tString containerId) throws Exception {\n            try {\n                super.tearDown(managementClient, containerId);\n            } finally {\n                try {\n                    remove(address1, managementClient);\n                } finally {\n                    removeModule(\"org/jboss/ironjacamar/ra16out1\", true);\n                }\n            }\n\t\t}","id":49967,"modified_method":"@Override\n        public void tearDown(ManagementClient managementClient, String containerId) throws Exception {\n            remove(address1, managementClient);\n            removeModule(\"org/jboss/ironjacamar/ra16out1\", true);\n            super.tearDown(managementClient, containerId);\n        }","commit_id":"cada07592b9498ac5493f206be08ed105cbbf318","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void tearDown(ManagementClient managementClient,\n                             String containerId) throws Exception {\n            try {\n                super.tearDown(managementClient, containerId);\n            } finally {\n                try {\n                    remove(address1, managementClient);\n                } finally {\n                    removeModule(\"org/jboss/ironjacamar/ra16out1\", true);\n                }\n            }\n        }","id":49968,"modified_method":"@Override\n        public void tearDown(ManagementClient managementClient,\n                             String containerId) throws Exception {\n            remove(address1, managementClient);\n            removeModule(\"org/jboss/ironjacamar/ra16out1\", true);\n            super.tearDown(managementClient, containerId);\n        }","commit_id":"cada07592b9498ac5493f206be08ed105cbbf318","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        protected String getSlot() {\n            // change the \"main\" slot to something different, preferably to XXXYourNewTestCase.class.getSimpleName().toLowerCase(),\n            // if you are going to clone this test case\n            return \"main\";\n        }","id":49969,"modified_method":"@Override\n        protected String getSlot() {\n            return TwoModulesOfDifferentTypeTestCase.class.getSimpleName().toLowerCase();\n\n        }","commit_id":"cada07592b9498ac5493f206be08ed105cbbf318","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void tearDown(ManagementClient managementClient,\n                             String containerId) throws Exception {\n            try {\n                super.tearDown(managementClient, containerId);\n            } finally {\n                try {\n                    remove(address1, managementClient);\n                } finally {\n                    removeModule(\"org/jboss/ironjacamar/ra16out1\", true);\n                }\n            }\n        }","id":49970,"modified_method":"@Override\n        public void tearDown(ManagementClient managementClient, String containerId) throws Exception {\n            remove(address1, managementClient);\n            removeModule(\"org/jboss/ironjacamar/ra16out1\", true);\n            super.tearDown(managementClient, containerId);\n        }","commit_id":"cada07592b9498ac5493f206be08ed105cbbf318","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n\t\tpublic void tearDown(ManagementClient managementClient,\n\t\t\t\tString containerId) throws Exception {\n            try {\n                super.tearDown(managementClient, containerId);\n            } finally {\n                remove(address1, managementClient);\n            }\n\t\t}","id":49971,"modified_method":"@Override\n        public void tearDown(ManagementClient managementClient, String containerId) throws Exception {\n            remove(address1, managementClient);\n            super.tearDown(managementClient, containerId);\n        }","commit_id":"cada07592b9498ac5493f206be08ed105cbbf318","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void tearDown(ManagementClient managementClient,\n                             String containerId) throws Exception {\n            try {\n                super.tearDown(managementClient, containerId);\n            } finally {\n                remove(address1, managementClient);\n            }\n        }","id":49972,"modified_method":"@Override\n        public void tearDown(ManagementClient managementClient,\n                             String containerId) throws Exception {\n            remove(address1, managementClient);\n            super.tearDown(managementClient, containerId);\n        }","commit_id":"cada07592b9498ac5493f206be08ed105cbbf318","url":"https://github.com/wildfly/wildfly"},{"original_method":"FindInFilesOptimizingSearchHelper(CompileContext _context, boolean _findMatchngFiles, Project project) {\n    super(_context);\n    findMatchingFiles = _findMatchngFiles;\n\n    if (findMatchingFiles) {\n      helper = PsiSearchHelper.SERVICE.getInstance(project);\n\n      if (filesToScan == null) {\n        filesToScan = new THashMap<PsiFile,PsiFile>();\n        filesToScan2 = new THashMap<PsiFile,PsiFile>();\n      }\n    }\n  }","id":49973,"modified_method":"FindInFilesOptimizingSearchHelper(CompileContext context, boolean findMatchingFiles, Project project) {\n    super(context);\n    myFindMatchingFiles = findMatchingFiles;\n    myProject = project;\n\n    if (myFindMatchingFiles && filesToScan == null) {\n      filesToScan = new THashMap<PsiFile, PsiFile>();\n      filesToScan2 = new THashMap<PsiFile, PsiFile>();\n    }\n  }","commit_id":"6d1c72e20850d5a4a4a2868228754c03a513d36d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doAddSearchWordInComments(final String refname) {\n    helper.processAllFilesWithWordInComments(refname, (GlobalSearchScope)context.getOptions().getScope(), new MyFileProcessor());\n  }","id":49974,"modified_method":"protected void doAddSearchWordInComments(final String refname) {\n    final MatchOptions options = context.getOptions();\n    CacheManager.SERVICE.getInstance(myProject).processFilesWithWord(new MyFileProcessor(), refname, UsageSearchContext.IN_COMMENTS,\n                                                                     (GlobalSearchScope)options.getScope(), options.isCaseSensitiveMatch());\n  }","commit_id":"6d1c72e20850d5a4a4a2868228754c03a513d36d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doAddSearchWordInText(final String refname) {\n    helper.processAllFilesWithWordInText(refname, (GlobalSearchScope)context.getOptions().getScope(), new MyFileProcessor(), true);\n  }","id":49975,"modified_method":"protected void doAddSearchWordInText(final String refname) {\n    final MatchOptions options = context.getOptions();\n    CacheManager.SERVICE.getInstance(myProject).processFilesWithWord(new MyFileProcessor(), refname, UsageSearchContext.IN_PLAIN_TEXT,\n                                                                     (GlobalSearchScope)options.getScope(), options.isCaseSensitiveMatch());\n  }","commit_id":"6d1c72e20850d5a4a4a2868228754c03a513d36d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doAddSearchWordInLiterals(final String refname) {\n    helper.processAllFilesWithWordInLiterals(refname, (GlobalSearchScope)context.getOptions().getScope(), new MyFileProcessor());\n  }","id":49976,"modified_method":"protected void doAddSearchWordInLiterals(final String refname) {\n    final MatchOptions options = context.getOptions();\n    CacheManager.SERVICE.getInstance(myProject).processFilesWithWord(new MyFileProcessor(), refname, UsageSearchContext.IN_STRINGS,\n                                                                     (GlobalSearchScope)options.getScope(), options.isCaseSensitiveMatch());\n  }","commit_id":"6d1c72e20850d5a4a4a2868228754c03a513d36d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void clear() {\n    super.clear();\n\n    if (filesToScan != null) {\n      filesToScan.clear();\n      filesToScan2.clear();\n\n      helper = null;\n    }\n  }","id":49977,"modified_method":"public void clear() {\n    super.clear();\n\n    if (filesToScan != null) {\n      filesToScan.clear();\n      filesToScan2.clear();\n    }\n  }","commit_id":"6d1c72e20850d5a4a4a2868228754c03a513d36d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean doOptimizing() {\n    return findMatchingFiles;\n  }","id":49978,"modified_method":"public boolean doOptimizing() {\n    return myFindMatchingFiles;\n  }","commit_id":"6d1c72e20850d5a4a4a2868228754c03a513d36d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doAddSearchWordInCode(final String refname) {\n    final FileType fileType = context.getOptions().getFileType();\n    final Language language = fileType instanceof LanguageFileType ? ((LanguageFileType)fileType).getLanguage() : Language.ANY;\n    final NamesValidator namesValidator = LanguageNamesValidation.INSTANCE.forLanguage(language);\n    if (namesValidator.isKeyword(refname, context.getProject())) {\n      helper.processAllFilesWithWordInText(refname, (GlobalSearchScope)context.getOptions().getScope(), new MyFileProcessor(), true);\n    } else {\n      helper.processAllFilesWithWord(refname, (GlobalSearchScope)context.getOptions().getScope(), new MyFileProcessor(), true);\n    }\n  }","id":49979,"modified_method":"protected void doAddSearchWordInCode(final String refname) {\n    final MatchOptions options = context.getOptions();\n    final FileType fileType = options.getFileType();\n    final Language language = fileType instanceof LanguageFileType ? ((LanguageFileType)fileType).getLanguage() : Language.ANY;\n    final NamesValidator namesValidator = LanguageNamesValidation.INSTANCE.forLanguage(language);\n    if (namesValidator.isKeyword(refname, context.getProject())) {\n      CacheManager.SERVICE.getInstance(myProject).processFilesWithWord(new MyFileProcessor(), refname, UsageSearchContext.IN_PLAIN_TEXT,\n                                                                       (GlobalSearchScope)options.getScope(),\n                                                                       options.isCaseSensitiveMatch());\n    }\n    else {\n      CacheManager.SERVICE.getInstance(myProject).processFilesWithWord(new MyFileProcessor(), refname, UsageSearchContext.IN_CODE,\n                                                                       (GlobalSearchScope)options.getScope(), options.isCaseSensitiveMatch());\n    }\n  }","commit_id":"6d1c72e20850d5a4a4a2868228754c03a513d36d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\tpublic int read() throws IOException {\n\t\t_rateLimiter.acquire(1);\n\n\t\treturn _inputStream.read();\n\t}","id":49980,"modified_method":"@Override\n\tpublic int read() throws IOException {\n\t\t_rateLimiter.acquire();\n\n\t\treturn _inputStream.read();\n\t}","commit_id":"91f49e773deba488825e2bc9d4b23ab0fe1b3ae7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void write(int byteValue) throws IOException {\n\t\t_rateLimiter.acquire(1);\n\n\t\t_outputStream.write(byteValue);\n\t}","id":49981,"modified_method":"@Override\n\tpublic void write(int byteValue) throws IOException {\n\t\t_rateLimiter.acquire();\n\n\t\t_outputStream.write(byteValue);\n\t}","commit_id":"91f49e773deba488825e2bc9d4b23ab0fe1b3ae7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic ManagedHttpClientConnection create(\n\t\tHttpRoute route, ConnectionConfig connectionConfig) {\n\n\t\tif (connectionConfig == null) {\n\t\t\tconnectionConfig = ConnectionConfig.DEFAULT;\n\t\t}\n\n\t\tCodingErrorAction malformedInputAction =\n\t\t\tconnectionConfig.getMalformedInputAction();\n\n\t\tif (malformedInputAction == null) {\n\t\t\tmalformedInputAction = CodingErrorAction.REPORT;\n\t\t}\n\n\t\tCodingErrorAction unmappableInputAction =\n\t\t\tconnectionConfig.getUnmappableInputAction();\n\n\t\tif (unmappableInputAction == null) {\n\t\t\tunmappableInputAction = CodingErrorAction.REPORT;\n\t\t}\n\n\t\tCharsetDecoder charsetDecoder = null;\n\t\tCharsetEncoder charsetEncoder = null;\n\n\t\tCharset charset = connectionConfig.getCharset();\n\n\t\tif (charset != null) {\n\t\t\tcharsetDecoder = charset.newDecoder();\n\t\t\tcharsetDecoder.onMalformedInput(malformedInputAction);\n\t\t\tcharsetDecoder.onUnmappableCharacter(unmappableInputAction);\n\t\t\tcharsetEncoder = charset.newEncoder();\n\t\t\tcharsetEncoder.onMalformedInput(malformedInputAction);\n\t\t\tcharsetEncoder.onUnmappableCharacter(unmappableInputAction);\n\t\t}\n\n\t\tfinal String id =\n\t\t\t\"http-outgoing-\" + Long.toString(_COUNTER.getAndIncrement());\n\n\t\treturn new SyncManagedHttpClientConnection(\n\t\t\tid, connectionConfig.getBufferSize(),\n\t\t\tconnectionConfig.getFragmentSizeHint(), charsetDecoder,\n\t\t\tcharsetEncoder, connectionConfig.getMessageConstraints(), null,\n\t\t\tnull, null, null);\n\t}","id":49982,"modified_method":"@Override\n\tpublic ManagedHttpClientConnection create(\n\t\tHttpRoute httpRoute, ConnectionConfig connectionConfig) {\n\n\t\tif (connectionConfig == null) {\n\t\t\tconnectionConfig = ConnectionConfig.DEFAULT;\n\t\t}\n\n\t\treturn new SyncManagedHttpClientConnection(\n\t\t\t\"http-outgoing-\" + _counter.getAndIncrement(),\n\t\t\tconnectionConfig.getBufferSize());\n\t}","commit_id":"91f49e773deba488825e2bc9d4b23ab0fe1b3ae7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic ManagedHttpClientConnection create(\n\t\tHttpRoute httpRoute, ConnectionConfig connectionConfig) {\n\n\t\tif (connectionConfig == null) {\n\t\t\tconnectionConfig = ConnectionConfig.DEFAULT;\n\t\t}\n\n\t\treturn new SyncManagedHttpClientConnection(\n\t\t\t\"http-outgoing-\" + _counter.getAndIncrement(),\n\t\t\tconnectionConfig.getBufferSize());\n\t}","id":49983,"modified_method":"@Override\n\tpublic ManagedHttpClientConnection create(\n\t\tHttpRoute route, ConnectionConfig connectionConfig) {\n\n\t\tif (connectionConfig == null) {\n\t\t\tconnectionConfig = ConnectionConfig.DEFAULT;\n\t\t}\n\n\t\tCodingErrorAction malformedInputAction =\n\t\t\tconnectionConfig.getMalformedInputAction();\n\n\t\tif (malformedInputAction == null) {\n\t\t\tmalformedInputAction = CodingErrorAction.REPORT;\n\t\t}\n\n\t\tCodingErrorAction unmappableInputAction =\n\t\t\tconnectionConfig.getUnmappableInputAction();\n\n\t\tif (unmappableInputAction == null) {\n\t\t\tunmappableInputAction = CodingErrorAction.REPORT;\n\t\t}\n\n\t\tCharsetDecoder charsetDecoder = null;\n\t\tCharsetEncoder charsetEncoder = null;\n\n\t\tCharset charset = connectionConfig.getCharset();\n\n\t\tif (charset != null) {\n\t\t\tcharsetDecoder = charset.newDecoder();\n\t\t\tcharsetDecoder.onMalformedInput(malformedInputAction);\n\t\t\tcharsetDecoder.onUnmappableCharacter(unmappableInputAction);\n\t\t\tcharsetEncoder = charset.newEncoder();\n\t\t\tcharsetEncoder.onMalformedInput(malformedInputAction);\n\t\t\tcharsetEncoder.onUnmappableCharacter(unmappableInputAction);\n\t\t}\n\n\t\tfinal String id =\n\t\t\t\"http-outgoing-\" + Long.toString(_counter.getAndIncrement());\n\n\t\treturn new SyncManagedHttpClientConnection(\n\t\t\tid, connectionConfig.getBufferSize(),\n\t\t\tconnectionConfig.getFragmentSizeHint(), charsetDecoder,\n\t\t\tcharsetEncoder, connectionConfig.getMessageConstraints(), null,\n\t\t\tnull, null, null);\n\t}","commit_id":"4908621c3b75fa95f2689c67fabc1209921ddfd1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private EditorCell createDiagramNode_70mnj_a(EditorContext editorContext, SNode node) {\n    MPSBlockView view = new MPSBlockView();\n    GenericViewCell editorCell = GenericViewCell.createViewCell(editorContext, node, view);\n    view.setText(SPropertyOperations.getString(node, \"name\"));\n    view.setX(SPropertyOperations.getInteger(node, \"x\"));\n    view.setY(SPropertyOperations.getInteger(node, \"y\"));\n    for (SNode child : ListSequence.fromList(SLinkOperations.getTargets(node, \"inputPorts\", true))) {\n      GenericViewCell childCell = (GenericViewCell) editorContext.createNodeCell(child);\n      editorCell.addEditorCell(childCell);\n      attach(view.getInputs(), childCell.getView());\n    }\n    for (SNode child : ListSequence.fromList(SLinkOperations.getTargets(node, \"outputPorts\", true))) {\n      GenericViewCell childCell = (GenericViewCell) editorContext.createNodeCell(child);\n      editorCell.addEditorCell(childCell);\n      attach(view.getOutputs(), childCell.getView());\n    }\n    view.dimension().set(Block_diagramGenerated_Editor._StyleParameter_QueryFunction_70mnj_a0a((editorCell == null ?\n      null :\n      editorCell.getContext()\n    ), (editorCell == null ?\n      null :\n      editorCell.getSNode()\n    )));\n    view.visible().set(true);\n    return editorCell;\n\n  }","id":49984,"modified_method":"private EditorCell createDiagramNode_70mnj_a(EditorContext editorContext, SNode node) {\n    MPSBlockView view = new MPSBlockView();\n    GenericViewCell editorCell = GenericViewCell.createViewCell(editorContext, node, view);\n    view.setText(SPropertyOperations.getString(node, \"name\"));\n    view.setX(SPropertyOperations.getInteger(node, \"x\"));\n    view.setY(SPropertyOperations.getInteger(node, \"y\"));\n    for (SNode child : ListSequence.fromList(SLinkOperations.getTargets(node, \"inputPorts\", true))) {\n      createViewForChildNode(child, editorCell, view.getInputs(), editorContext);\n    }\n    for (SNode child : ListSequence.fromList(SLinkOperations.getTargets(node, \"outputPorts\", true))) {\n      createViewForChildNode(child, editorCell, view.getOutputs(), editorContext);\n    }\n    view.dimension().set(Block_diagramGenerated_Editor._StyleParameter_QueryFunction_70mnj_a0a((editorCell == null ?\n      null :\n      editorCell.getContext()\n    ), (editorCell == null ?\n      null :\n      editorCell.getSNode()\n    )));\n    view.visible().set(true);\n    return editorCell;\n\n  }","commit_id":"f94937b3a468cd82735428791c7c16d60e3db1a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_6382742553261333638(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SLinkOperations.getTarget(_context.getNode(), \"link\", false);\n  }","id":49985,"modified_method":"public static Object referenceMacro_GetReferent_5074650623947469575(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SLinkOperations.getTarget(_context.getNode(), \"link\", false);\n  }","commit_id":"f94937b3a468cd82735428791c7c16d60e3db1a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_6382742553261536137(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SLinkOperations.getTarget(_context.getNode(), \"link\", false);\n  }","id":49986,"modified_method":"public static Object referenceMacro_GetReferent_5074650623947469586(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    SNode figureReference = SLinkOperations.getTarget(AbstractFigureParameter_Behavior.call_getDiagramNodeCell_1491555030355957123(_context.getNode()), \"figure\", true);\n    return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), figureReference, \"virtual_getMethodDeclaration_8322026508615817443\", new Object[]{AbstractFigureParameter_Behavior.call_getGetterName_3748979635600013007(_context.getNode())});\n  }","commit_id":"f94937b3a468cd82735428791c7c16d60e3db1a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_6382742553261342167(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    SNode figureReference = SLinkOperations.getTarget(AbstractFigureParameter_Behavior.call_getDiagramNodeCell_1491555030355957123(_context.getNode()), \"figure\", true);\n    return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), figureReference, \"virtual_getMethodDeclaration_8322026508615817443\", new Object[]{AbstractFigureParameter_Behavior.call_getGetterName_3748979635600013007(_context.getNode())});\n  }","id":49987,"modified_method":"public static Object referenceMacro_GetReferent_5074650623947709581(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    SNode figureReference = SLinkOperations.getTarget(AbstractFigureParameter_Behavior.call_getDiagramNodeCell_1491555030355957123(_context.getNode()), \"figure\", true);\n    return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), figureReference, \"virtual_getMethodDeclaration_8322026508615817443\", new Object[]{AbstractFigureParameter_Behavior.call_getSetterName_3748979635600013130(_context.getNode())});\n  }","commit_id":"f94937b3a468cd82735428791c7c16d60e3db1a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_6382742553261118337(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SLinkOperations.getTarget(_context.getNode(), \"property\", false);\n  }","id":49988,"modified_method":"public static Object referenceMacro_GetReferent_5074650623947709574(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SLinkOperations.getTarget(_context.getNode(), \"property\", false);\n  }","commit_id":"f94937b3a468cd82735428791c7c16d60e3db1a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_6382742553261118344(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    SNode figureReference = SLinkOperations.getTarget(AbstractFigureParameter_Behavior.call_getDiagramNodeCell_1491555030355957123(_context.getNode()), \"figure\", true);\n    return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), figureReference, \"virtual_getMethodDeclaration_8322026508615817443\", new Object[]{AbstractFigureParameter_Behavior.call_getSetterName_3748979635600013130(_context.getNode())});\n  }","id":49989,"modified_method":"public static Object referenceMacro_GetReferent_5074650623947392994(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    SNode figureReference = SLinkOperations.getTarget(AbstractFigureParameter_Behavior.call_getDiagramNodeCell_1491555030355957123(_context.getNode()), \"figure\", true);\n    return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), figureReference, \"virtual_getMethodDeclaration_8322026508615817443\", new Object[]{AbstractFigureParameter_Behavior.call_getGetterName_3748979635600013007(_context.getNode())});\n  }","commit_id":"f94937b3a468cd82735428791c7c16d60e3db1a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_6382742553261536062(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    SNode figureReference = SLinkOperations.getTarget(AbstractFigureParameter_Behavior.call_getDiagramNodeCell_1491555030355957123(_context.getNode()), \"figure\", true);\n    return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), figureReference, \"virtual_getMethodDeclaration_8322026508615817443\", new Object[]{AbstractFigureParameter_Behavior.call_getGetterName_3748979635600013007(_context.getNode())});\n  }","id":49990,"modified_method":"public static Object referenceMacro_GetReferent_5074650623947382791(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SLinkOperations.getTarget(_context.getNode(), \"link\", false);\n  }","commit_id":"f94937b3a468cd82735428791c7c16d60e3db1a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override public void visitPyContinueStatement(final PyContinueStatement node) {\n    final PyElement loopStmt = node.getContainingElement(PyElementTypes.LOOPS); // closest loop to contain the 'continue'\n    if (loopStmt == null) {\n      getHolder().createErrorAnnotation(node, message(\"ANN.continue.outside.loop\"));\n      return;\n    }\n    PyTryExceptStatement tryStmt = node.getContainingElement(PyTryExceptStatement.class);\n    if (tryStmt != null) {\n      final PyFinallyPart finallyPart = tryStmt.getFinallyPart();\n      if (finallyPart != null && PsiTreeUtil.isAncestor(loopStmt, finallyPart, true)) {\n          getHolder().createErrorAnnotation(node, message(\"ANN.cant.continue.in.finally\"));\n      }\n    }\n  }","id":49991,"modified_method":"@Override\n  public void visitPyContinueStatement(final PyContinueStatement node) {\n    List<? extends PsiElement> match = SyntaxMatchers.LOOP_CONTROL.search(node);\n    if (match == null) {\n      getHolder().createErrorAnnotation(node, message(\"ANN.continue.outside.loop\"));\n    }\n    else if (SyntaxMatchers.IN_FINALLY_NO_LOOP.search(node) != null) {\n      getHolder().createErrorAnnotation(node, message(\"ANN.cant.continue.in.finally\"));\n    }\n  }","commit_id":"10aec64c1a027e42eebd33242cc0aa2bcf5bc8cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override public void visitPyBreakStatement(final PyBreakStatement node) {\n    if (node.getContainingElement(PyElementTypes.LOOPS) == null) {\n      getHolder().createErrorAnnotation(node, message(\"ANN.break.outside.loop\"));\n    }\n  }","id":49992,"modified_method":"@Override\n  public void visitPyBreakStatement(final PyBreakStatement node) {\n    if (SyntaxMatchers.LOOP_CONTROL.search(node) == null) {\n      getHolder().createErrorAnnotation(node, message(\"ANN.break.outside.loop\"));\n    }\n  }","commit_id":"10aec64c1a027e42eebd33242cc0aa2bcf5bc8cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void addAs() {\n    extend(\n      CompletionType.BASIC, psiElement().withLanguage(PythonLanguage.getInstance())\n        .andNot(AFTER_QUALIFIED_REFERENCE).and(IN_IMPORT_AFTER_REF),\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] space_strings = {\"as\"};\n          addKeywords(space_strings, TailType.SPACE, parameters, result);\n        }\n      }\n    );\n  }","id":49993,"modified_method":"private void addAs() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .andOr(IN_IMPORT_AFTER_REF, IN_WITH_AFTER_REF) \n        .andNot(AFTER_QUALIFIER)\n      ,\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] space_strings = {\"as\"};\n          putKeywords(space_strings, TailType.SPACE, result);\n        }\n      }\n    );\n  }","commit_id":"10aec64c1a027e42eebd33242cc0aa2bcf5bc8cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void addWithinTry() {\n    extend(\n      CompletionType.BASIC, psiElement().withLanguage(PythonLanguage.getInstance()).andNot(AFTER_QUALIFIED_REFERENCE).andOr(IN_TRY, AFTER_TRY),\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] space_strings = {\"except\"};\n          final @NonNls String[] colon_strings = {\"finally\"};\n          addKeywords(space_strings, TailType.SPACE, parameters, result);\n          addKeywords(colon_strings, TailType.CASE_COLON, parameters, result);\n        }\n      }\n    );\n  }","id":49994,"modified_method":"private void addWithinTry() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .and(FIRST_ON_LINE)\n        .andOr(IN_TRY_BODY, AFTER_TRY)\n        //.andNot(RIGHT_AFTER_COLON)\n        .andNot(AFTER_QUALIFIER)\n      ,\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] pre_colon_strings = {\"except\"};\n          final @NonNls String[] colon_strings = {\"finally\"};\n          putKeywords(pre_colon_strings, PRE_COLON, result);\n          putKeywords(colon_strings, TailType.CASE_COLON, result);\n          // TODO: have it dedent properly\n        }\n      }\n    );\n  }","commit_id":"10aec64c1a027e42eebd33242cc0aa2bcf5bc8cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void addWithinFuncs() {\n    extend(\n      CompletionType.BASIC, psiElement().withLanguage(PythonLanguage.getInstance()).andNot(AFTER_QUALIFIED_REFERENCE).and(IN_DEF).andNot(AFTER_DEF_OR_CLASS),\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] space_strings = {\"global\", \"return\", \"yield\"};\n          addKeywords(space_strings, TailType.SPACE, parameters, result);\n        }\n      }\n    );\n  }","id":49995,"modified_method":"private void addWithinFuncs() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .and(IN_DEF_BODY)\n        .and(IN_BEGIN_STMT)\n        .andNot(AFTER_QUALIFIER)\n      ,\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] space_strings = {\"global\", \"return\", \"yield\"};\n          putKeywords(space_strings, TailType.SPACE, result);\n        }\n      }\n    );\n  }","commit_id":"10aec64c1a027e42eebd33242cc0aa2bcf5bc8cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void addImportInFrom() {\n    extend(\n      CompletionType.BASIC, psiElement().withLanguage(PythonLanguage.getInstance())\n        .andNot(AFTER_QUALIFIED_REFERENCE).and(IN_FROM_IMPORT_AFTER_REF),\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] space_strings = {\"import\"};\n          addKeywords(space_strings, TailType.SPACE, parameters, result);\n        }\n      }\n    );\n  }","id":49996,"modified_method":"private void addImportInFrom() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .and(IN_FROM_IMPORT_AFTER_REF)\n        .andNot(AFTER_QUALIFIER)\n      ,\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] space_strings = {\"import\"};\n          putKeywords(space_strings, TailType.SPACE, result);\n        }\n      }\n    );\n  }","commit_id":"10aec64c1a027e42eebd33242cc0aa2bcf5bc8cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PyKeywordCompletionContributor() {\n    addStatements();\n    addWithinLoops();\n    addWithinFuncs();\n    addWithinIf();\n    addWithinTry();\n    addWithinExpr();\n    addElse();\n    addAs();\n    addImportInFrom();\n  }","id":49997,"modified_method":"public PyKeywordCompletionContributor() {\n    addStatements();\n    addPreColonStatements();\n    addWithinIf();\n    addElse();\n    addBreak();\n    addContinue();\n    addWithinFuncs();\n    addWithinTry();\n    addInfixOperators();\n    addNot();\n    addAs();\n    addImportInFrom();\n    //addExprIf();\n    //addExprElse();\n  }","commit_id":"10aec64c1a027e42eebd33242cc0aa2bcf5bc8cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void addKeywords(@NonNls @NotNull String[] words, TailType tail, CompletionParameters parameters, final CompletionResultSet result) {\n    final LookupElementFactory factory = LookupElementFactory.getInstance();\n    for (String s : words) {\n      LookupItem<String> elt = (LookupItem<String>)factory.createLookupElement(s);\n      elt.setBold();\n      elt.setTailType(tail);\n      result.addElement(elt);\n    }\n  }","id":49998,"modified_method":"private static void putKeywords(@NonNls @NotNull String[] words, TailType tail, final CompletionResultSet result) {\n    final LookupElementFactory factory = LookupElementFactory.getInstance();\n    for (String s : words) {\n      LookupItem<String> elt = (LookupItem<String>)factory.createLookupElement(s);\n      elt.setBold();\n      elt.setTailType(tail);\n      result.addElement(elt);\n    }\n  }","commit_id":"10aec64c1a027e42eebd33242cc0aa2bcf5bc8cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void addWithinIf() {\n    extend(\n      CompletionType.BASIC, psiElement().withLanguage(PythonLanguage.getInstance()).andNot(AFTER_QUALIFIED_REFERENCE).andOr(IN_IF, AFTER_IF),\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] space_strings = {\"elif\"};\n          addKeywords(space_strings, TailType.SPACE, parameters, result);\n        }\n      }\n    );\n  }","id":49999,"modified_method":"private void addWithinIf() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .and(FIRST_ON_LINE)\n        .andOr(IN_IF_BODY, AFTER_IF)  // NOTE: does allow 'elif' after 'else', may be useful for easier reordering of branches\n        //.andNot(RIGHT_AFTER_COLON)\n        .andNot(AFTER_QUALIFIER)\n      ,\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] strings = {\"elif\"};\n          putKeywords(strings, PRE_COLON, result);\n          // TODO: have it dedent properly\n        }\n      }\n    );\n  }","commit_id":"10aec64c1a027e42eebd33242cc0aa2bcf5bc8cd","url":"https://github.com/JetBrains/intellij-community"}]