[{"original_method":"@Nullable\n    public ModelPath getParent() {\n        if (components.isEmpty()) {\n            return null;\n        }\n        if (components.size() == 1) {\n            return ROOT;\n        }\n        return path(components.subList(0, components.size() - 1));\n    }","id":73000,"modified_method":"@Nullable\n    public ModelPath getParent() {\n        if (components.isEmpty()) {\n            return null;\n        }\n        if (components.size() == 1) {\n            return ROOT;\n        }\n        // Somewhat optimized implementation\n        List<String> parentComponents = components.subList(0, components.size() - 1);\n        String parentPath = path.substring(0, path.length() - components.get(components.size() - 1).length() - 1);\n        return new ModelPath(parentPath, parentComponents);\n    }","commit_id":"c841213ebb616a61eb343f968b434deb94638be6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        ModelPath modelPath = (ModelPath) o;\n\n        return path.equals(modelPath.path);\n    }","id":73001,"modified_method":"@Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        ModelPath modelPath = (ModelPath) o;\n\n        return components.size() == modelPath.components.size() && path.equals(modelPath.path);\n    }","commit_id":"c841213ebb616a61eb343f968b434deb94638be6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n  public void handle(Request request, Response response) throws Exception {\n    DbSession dbSession = dbClient.openSession(false);\n    String valueAsString = request.mandatoryParam(PARAM_VALUE);\n    String description = request.param(PARAM_DESCRIPTION);\n    long now = system.now();\n\n    try {\n      ComponentDto component = searchProject(dbSession, request);\n      MetricDto metric = searchMetric(dbSession, request);\n      checkPermissions(component);\n      checkIsProjectOrModule(component);\n      checkMeasureDoesNotExistAlready(dbSession, component, metric);\n      UserDoc user = userIndex.getByLogin(userSession.getLogin());\n      CustomMeasureDto measure = new CustomMeasureDto()\n        .setComponentUuid(component.uuid())\n        .setComponentId(component.getId())\n        .setMetricId(metric.getId())\n        .setDescription(description)\n        .setUserLogin(user.login())\n        .setCreatedAt(now)\n        .setUpdatedAt(now);\n      validator.setMeasureValue(measure, valueAsString, metric);\n      dbClient.customMeasureDao().insert(dbSession, measure);\n      dbSession.commit();\n\n      JsonWriter json = response.newJsonWriter();\n      customMeasureJsonWriter.write(json, measure, metric, component, user);\n      json.close();\n    } finally {\n      MyBatis.closeQuietly(dbSession);\n    }\n  }","id":73002,"modified_method":"@Override\n  public void handle(Request request, Response response) throws Exception {\n    DbSession dbSession = dbClient.openSession(false);\n    String valueAsString = request.mandatoryParam(PARAM_VALUE);\n    String description = request.param(PARAM_DESCRIPTION);\n    long now = system.now();\n\n    try {\n      ComponentDto component = searchProject(dbSession, request);\n      MetricDto metric = searchMetric(dbSession, request);\n      checkPermissions(component);\n      checkIsProjectOrModule(component);\n      checkMeasureDoesNotExistAlready(dbSession, component, metric);\n      UserDoc user = userIndex.getByLogin(userSession.getLogin());\n      CustomMeasureDto measure = new CustomMeasureDto()\n        .setComponentUuid(component.uuid())\n        .setMetricId(metric.getId())\n        .setDescription(description)\n        .setUserLogin(user.login())\n        .setCreatedAt(now)\n        .setUpdatedAt(now);\n      validator.setMeasureValue(measure, valueAsString, metric);\n      dbClient.customMeasureDao().insert(dbSession, measure);\n      dbSession.commit();\n\n      JsonWriter json = response.newJsonWriter();\n      customMeasureJsonWriter.write(json, measure, metric, component, user);\n      json.close();\n    } finally {\n      MyBatis.closeQuietly(dbSession);\n    }\n  }","commit_id":"163630e0c9de6278cee233e2d79dfd21fbd9c2c0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void insert() {\n    CustomMeasureDto measure = newCustomMeasureDto();\n\n    sut.insert(session, measure);\n\n    CustomMeasureDto result = sut.selectNullableById(session, measure.getId());\n    assertThat(result.getId()).isEqualTo(measure.getId());\n    assertThat(result.getMetricId()).isEqualTo(measure.getMetricId());\n    assertThat(result.getComponentId()).isEqualTo(measure.getComponentId());\n    assertThat(result.getComponentUuid()).isEqualTo(measure.getComponentUuid());\n    assertThat(result.getDescription()).isEqualTo(measure.getDescription());\n    assertThat(result.getUserLogin()).isEqualTo(measure.getUserLogin());\n    assertThat(result.getTextValue()).isEqualTo(measure.getTextValue());\n    assertThat(result.getValue()).isCloseTo(measure.getValue(), offset(0.001d));\n    assertThat(result.getCreatedAt()).isEqualTo(measure.getCreatedAt());\n    assertThat(result.getUpdatedAt()).isEqualTo(measure.getUpdatedAt());\n  }","id":73003,"modified_method":"@Test\n  public void insert() {\n    CustomMeasureDto measure = newCustomMeasureDto();\n\n    sut.insert(session, measure);\n\n    CustomMeasureDto result = sut.selectNullableById(session, measure.getId());\n    assertThat(result.getId()).isEqualTo(measure.getId());\n    assertThat(result.getMetricId()).isEqualTo(measure.getMetricId());\n    assertThat(result.getComponentUuid()).isEqualTo(measure.getComponentUuid());\n    assertThat(result.getDescription()).isEqualTo(measure.getDescription());\n    assertThat(result.getUserLogin()).isEqualTo(measure.getUserLogin());\n    assertThat(result.getTextValue()).isEqualTo(measure.getTextValue());\n    assertThat(result.getValue()).isCloseTo(measure.getValue(), offset(0.001d));\n    assertThat(result.getCreatedAt()).isEqualTo(measure.getCreatedAt());\n    assertThat(result.getUpdatedAt()).isEqualTo(measure.getUpdatedAt());\n  }","commit_id":"163630e0c9de6278cee233e2d79dfd21fbd9c2c0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static CustomMeasureDto newCustomMeasureDto() {\n    return new CustomMeasureDto()\n      .setDescription(RandomStringUtils.randomAlphanumeric(255))\n      .setTextValue(RandomStringUtils.randomAlphanumeric(255))\n      .setUserLogin(RandomStringUtils.randomAlphanumeric(255))\n      .setValue(RandomUtils.nextDouble())\n      .setMetricId(RandomUtils.nextInt())\n      .setComponentId(RandomUtils.nextInt())\n      .setComponentUuid(RandomStringUtils.randomAlphanumeric(50))\n      .setCreatedAt(System2.INSTANCE.now())\n      .setUpdatedAt(System2.INSTANCE.now());\n  }","id":73004,"modified_method":"public static CustomMeasureDto newCustomMeasureDto() {\n    return new CustomMeasureDto()\n      .setDescription(RandomStringUtils.randomAlphanumeric(255))\n      .setTextValue(RandomStringUtils.randomAlphanumeric(255))\n      .setUserLogin(RandomStringUtils.randomAlphanumeric(255))\n      .setValue(RandomUtils.nextDouble())\n      .setMetricId(RandomUtils.nextInt())\n      .setComponentUuid(RandomStringUtils.randomAlphanumeric(50))\n      .setCreatedAt(System2.INSTANCE.now())\n      .setUpdatedAt(System2.INSTANCE.now());\n  }","commit_id":"163630e0c9de6278cee233e2d79dfd21fbd9c2c0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void checkPermissions(DbSession dbSession, CustomMeasureDto customMeasure) {\n    if (userSession.hasGlobalPermission(GlobalPermissions.SYSTEM_ADMIN)) {\n      return;\n    }\n\n    ComponentDto component = dbClient.componentDao().selectById(customMeasure.getComponentId(), dbSession);\n    userSession.checkLoggedIn().checkProjectUuidPermission(UserRole.ADMIN, component.projectUuid());\n  }","id":73005,"modified_method":"private void checkPermissions(DbSession dbSession, CustomMeasureDto customMeasure) {\n    if (userSession.hasGlobalPermission(GlobalPermissions.SYSTEM_ADMIN)) {\n      return;\n    }\n\n    ComponentDto component = dbClient.componentDao().selectByUuid(dbSession, customMeasure.getComponentUuid());\n    userSession.checkLoggedIn().checkProjectUuidPermission(UserRole.ADMIN, component.projectUuid());\n  }","commit_id":"163630e0c9de6278cee233e2d79dfd21fbd9c2c0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void delete_in_db_when_admin_on_project() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto(\"project-uuid\");\n    dbClient.componentDao().insert(dbSession, project);\n    userSessionRule.login(\"login\").addProjectUuidPermissions(UserRole.ADMIN, \"project-uuid\");\n    long id = insertCustomMeasure(newCustomMeasureDto().setComponentId(project.getId()));\n\n    newRequest().setParam(PARAM_ID, String.valueOf(id)).execute();\n\n    assertThat(dbClient.customMeasureDao().selectNullableById(dbSession, id)).isNull();\n  }","id":73006,"modified_method":"@Test\n  public void delete_in_db_when_admin_on_project() throws Exception {\n    ComponentDto project = ComponentTesting.newProjectDto(\"project-uuid\");\n    dbClient.componentDao().insert(dbSession, project);\n    userSessionRule.login(\"login\").addProjectUuidPermissions(UserRole.ADMIN, \"project-uuid\");\n    long id = insertCustomMeasure(newCustomMeasureDto().setComponentUuid(\"project-uuid\"));\n\n    newRequest().setParam(PARAM_ID, String.valueOf(id)).execute();\n\n    assertThat(dbClient.customMeasureDao().selectNullableById(dbSession, id)).isNull();\n  }","commit_id":"163630e0c9de6278cee233e2d79dfd21fbd9c2c0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_when_insufficient_permissions() throws Exception {\n    expectedException.expect(ForbiddenException.class);\n    userSessionRule.login(\"login\");\n    ComponentDto project = ComponentTesting.newProjectDto(\"any-uuid\");\n    dbClient.componentDao().insert(dbSession, project);\n    long id = insertCustomMeasure(newCustomMeasureDto().setComponentId(project.getId()));\n\n    newRequest().setParam(PARAM_ID, String.valueOf(id)).execute();\n  }","id":73007,"modified_method":"@Test\n  public void fail_when_insufficient_permissions() throws Exception {\n    expectedException.expect(ForbiddenException.class);\n    userSessionRule.login(\"login\");\n    ComponentDto project = ComponentTesting.newProjectDto(\"any-uuid\");\n    dbClient.componentDao().insert(dbSession, project);\n    long id = insertCustomMeasure(newCustomMeasureDto().setComponentUuid(\"any-uuid\"));\n\n    newRequest().setParam(PARAM_ID, String.valueOf(id)).execute();\n  }","commit_id":"163630e0c9de6278cee233e2d79dfd21fbd9c2c0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void list_metrics_based_on_project_key() throws Exception {\n    MetricDto metric = insertCustomMetric(\"metric-key-1\");\n    insertCustomMetric(\"metric-key-2\");\n    ComponentDto project = insertDefaultProject();\n    insertProject(\"project-uuid-2\", \"project-key-2\");\n\n    CustomMeasureDto customMeasure = newCustomMeasureDto()\n      .setComponentUuid(project.uuid())\n      .setComponentId(project.getId())\n      .setMetricId(metric.getId());\n    dbClient.customMeasureDao().insert(dbSession, customMeasure);\n    dbSession.commit();\n\n    String response = ws.newGetRequest(ENDPOINT, ACTION)\n      .setParam(MetricsAction.PARAM_PROJECT_KEY, DEFAULT_PROJECT_KEY)\n      .execute().outputAsString();\n\n    assertThat(response).contains(\"metric-key-2\")\n      .doesNotContain(\"metric-key-1\");\n  }","id":73008,"modified_method":"@Test\n  public void list_metrics_based_on_project_key() throws Exception {\n    MetricDto metric = insertCustomMetric(\"metric-key-1\");\n    insertCustomMetric(\"metric-key-2\");\n    ComponentDto project = insertDefaultProject();\n    insertProject(\"project-uuid-2\", \"project-key-2\");\n\n    CustomMeasureDto customMeasure = newCustomMeasureDto()\n      .setComponentUuid(project.uuid())\n      .setMetricId(metric.getId());\n    dbClient.customMeasureDao().insert(dbSession, customMeasure);\n    dbSession.commit();\n\n    String response = ws.newGetRequest(ENDPOINT, ACTION)\n      .setParam(MetricsAction.PARAM_PROJECT_KEY, DEFAULT_PROJECT_KEY)\n      .execute().outputAsString();\n\n    assertThat(response).contains(\"metric-key-2\")\n      .doesNotContain(\"metric-key-1\");\n  }","commit_id":"163630e0c9de6278cee233e2d79dfd21fbd9c2c0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void list_metrics_where_no_existing_custom_measure() throws Exception {\n    MetricDto metric = insertCustomMetric(\"metric-key-1\");\n    insertCustomMetric(\"metric-key-2\");\n    ComponentDto project = insertDefaultProject();\n    insertProject(\"project-uuid-2\", \"project-key-2\");\n\n    CustomMeasureDto customMeasure = newCustomMeasureDto()\n      .setComponentUuid(project.uuid())\n      .setComponentId(project.getId())\n      .setMetricId(metric.getId());\n    dbClient.customMeasureDao().insert(dbSession, customMeasure);\n    dbSession.commit();\n\n    String response = newRequest().outputAsString();\n\n    assertThat(response).contains(\"metric-key-2\")\n      .doesNotContain(\"metric-key-1\");\n  }","id":73009,"modified_method":"@Test\n  public void list_metrics_where_no_existing_custom_measure() throws Exception {\n    MetricDto metric = insertCustomMetric(\"metric-key-1\");\n    insertCustomMetric(\"metric-key-2\");\n    ComponentDto project = insertDefaultProject();\n    insertProject(\"project-uuid-2\", \"project-key-2\");\n\n    CustomMeasureDto customMeasure = newCustomMeasureDto()\n      .setComponentUuid(project.uuid())\n      .setMetricId(metric.getId());\n    dbClient.customMeasureDao().insert(dbSession, customMeasure);\n    dbSession.commit();\n\n    String response = newRequest().outputAsString();\n\n    assertThat(response).contains(\"metric-key-2\")\n      .doesNotContain(\"metric-key-1\");\n  }","commit_id":"163630e0c9de6278cee233e2d79dfd21fbd9c2c0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void deleteResources(List<IdUuidPair> componentIdUuids) {\n    List<List<Long>> componentIdPartitions = Lists.partition(IdUuidPairs.ids(componentIdUuids), MAX_RESOURCES_PER_QUERY);\n    List<List<String>> componentUuidsPartitions = Lists.partition(IdUuidPairs.uuids(componentIdUuids), MAX_RESOURCES_PER_QUERY);\n    // Note : do not merge the delete statements into a single loop of resource ids. It's\n    // voluntarily grouped by tables in order to benefit from JDBC batch mode.\n    // Batch requests can only relate to the same PreparedStatement.\n\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      deleteSnapshots(purgeMapper.selectSnapshotIdsByResource(partResourceIds));\n    }\n\n    // possible missing optimization: filter requests according to resource scope\n\n    profiler.start(\"deleteResourceLinks (project_links)\");\n    for (List<String> componentUuidPartition : componentUuidsPartitions) {\n      purgeMapper.deleteResourceLinks(componentUuidPartition);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteResourceProperties (properties)\");\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      purgeMapper.deleteResourceProperties(partResourceIds);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteResourceIndex (resource_index)\");\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      purgeMapper.deleteResourceIndex(partResourceIds);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteResourceGroupRoles (group_roles)\");\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      purgeMapper.deleteResourceGroupRoles(partResourceIds);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteResourceUserRoles (user_roles)\");\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      purgeMapper.deleteResourceUserRoles(partResourceIds);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteResourceManualMeasures (manual_measures)\");\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      purgeMapper.deleteResourceManualMeasures(partResourceIds);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteComponentIssueChanges (issue_changes)\");\n    for (List<String> componentUuidPartition : componentUuidsPartitions) {\n      purgeMapper.deleteComponentIssueChanges(componentUuidPartition);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteComponentIssues (issues)\");\n    for (List<String> componentUuidPartition : componentUuidsPartitions) {\n      purgeMapper.deleteComponentIssues(componentUuidPartition);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteResourceActionPlans (action_plans)\");\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      purgeMapper.deleteResourceActionPlans(partResourceIds);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteComponentEvents (events)\");\n    for (List<String> componentUuidPartition : componentUuidsPartitions) {\n      purgeMapper.deleteComponentEvents(componentUuidPartition);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteResource (projects)\");\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      purgeMapper.deleteResource(partResourceIds);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteAuthors (authors)\");\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      purgeMapper.deleteAuthors(partResourceIds);\n    }\n    session.commit();\n    profiler.stop();\n  }","id":73010,"modified_method":"void deleteResources(List<IdUuidPair> componentIdUuids) {\n    List<List<Long>> componentIdPartitions = Lists.partition(IdUuidPairs.ids(componentIdUuids), MAX_RESOURCES_PER_QUERY);\n    List<List<String>> componentUuidsPartitions = Lists.partition(IdUuidPairs.uuids(componentIdUuids), MAX_RESOURCES_PER_QUERY);\n    // Note : do not merge the delete statements into a single loop of resource ids. It's\n    // voluntarily grouped by tables in order to benefit from JDBC batch mode.\n    // Batch requests can only relate to the same PreparedStatement.\n\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      deleteSnapshots(purgeMapper.selectSnapshotIdsByResource(partResourceIds));\n    }\n\n    // possible missing optimization: filter requests according to resource scope\n\n    profiler.start(\"deleteResourceLinks (project_links)\");\n    for (List<String> componentUuidPartition : componentUuidsPartitions) {\n      purgeMapper.deleteResourceLinks(componentUuidPartition);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteResourceProperties (properties)\");\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      purgeMapper.deleteResourceProperties(partResourceIds);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteResourceIndex (resource_index)\");\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      purgeMapper.deleteResourceIndex(partResourceIds);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteResourceGroupRoles (group_roles)\");\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      purgeMapper.deleteResourceGroupRoles(partResourceIds);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteResourceUserRoles (user_roles)\");\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      purgeMapper.deleteResourceUserRoles(partResourceIds);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteResourceManualMeasures (manual_measures)\");\n    for (List<String> componentUuidPartition : componentUuidsPartitions) {\n      purgeMapper.deleteResourceManualMeasures(componentUuidPartition);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteComponentIssueChanges (issue_changes)\");\n    for (List<String> componentUuidPartition : componentUuidsPartitions) {\n      purgeMapper.deleteComponentIssueChanges(componentUuidPartition);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteComponentIssues (issues)\");\n    for (List<String> componentUuidPartition : componentUuidsPartitions) {\n      purgeMapper.deleteComponentIssues(componentUuidPartition);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteResourceActionPlans (action_plans)\");\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      purgeMapper.deleteResourceActionPlans(partResourceIds);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteComponentEvents (events)\");\n    for (List<String> componentUuidPartition : componentUuidsPartitions) {\n      purgeMapper.deleteComponentEvents(componentUuidPartition);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteResource (projects)\");\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      purgeMapper.deleteResource(partResourceIds);\n    }\n    session.commit();\n    profiler.stop();\n\n    profiler.start(\"deleteAuthors (authors)\");\n    for (List<Long> partResourceIds : componentIdPartitions) {\n      purgeMapper.deleteAuthors(partResourceIds);\n    }\n    session.commit();\n    profiler.stop();\n  }","commit_id":"163630e0c9de6278cee233e2d79dfd21fbd9c2c0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_if_insufficient_privileges() throws Exception {\n    userSessionRule.login(\"login\").setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n    expectedException.expect(ForbiddenException.class);\n    MetricDto metric = MetricTesting.newMetricDto().setEnabled(true).setValueType(ValueType.STRING.name());\n    dbClient.metricDao().insert(dbSession, metric);\n    ComponentDto component = ComponentTesting.newProjectDto(\"project-uuid\");\n    dbClient.componentDao().insert(dbSession, component);\n    CustomMeasureDto customMeasure = newCustomMeasureDto()\n      .setMetricId(metric.getId())\n      .setComponentId(component.getId())\n      .setComponentUuid(component.uuid())\n      .setCreatedAt(system.now())\n      .setDescription(\"custom-measure-description\")\n      .setTextValue(\"text-measure-value\");\n    dbClient.customMeasureDao().insert(dbSession, customMeasure);\n    dbSession.commit();\n\n    ws.newPostRequest(CustomMeasuresWs.ENDPOINT, UpdateAction.ACTION)\n      .setParam(PARAM_ID, String.valueOf(customMeasure.getId()))\n      .setParam(PARAM_DESCRIPTION, \"new-custom-measure-description\")\n      .setParam(PARAM_VALUE, \"1984\")\n      .execute();\n  }","id":73011,"modified_method":"@Test\n  public void fail_if_insufficient_privileges() throws Exception {\n    userSessionRule.login(\"login\").setGlobalPermissions(GlobalPermissions.SCAN_EXECUTION);\n    expectedException.expect(ForbiddenException.class);\n    MetricDto metric = MetricTesting.newMetricDto().setEnabled(true).setValueType(ValueType.STRING.name());\n    dbClient.metricDao().insert(dbSession, metric);\n    ComponentDto component = ComponentTesting.newProjectDto(\"project-uuid\");\n    dbClient.componentDao().insert(dbSession, component);\n    CustomMeasureDto customMeasure = newCustomMeasureDto()\n      .setMetricId(metric.getId())\n      .setComponentUuid(component.uuid())\n      .setCreatedAt(system.now())\n      .setDescription(\"custom-measure-description\")\n      .setTextValue(\"text-measure-value\");\n    dbClient.customMeasureDao().insert(dbSession, customMeasure);\n    dbSession.commit();\n\n    ws.newPostRequest(CustomMeasuresWs.ENDPOINT, UpdateAction.ACTION)\n      .setParam(PARAM_ID, String.valueOf(customMeasure.getId()))\n      .setParam(PARAM_DESCRIPTION, \"new-custom-measure-description\")\n      .setParam(PARAM_VALUE, \"1984\")\n      .execute();\n  }","commit_id":"163630e0c9de6278cee233e2d79dfd21fbd9c2c0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private CustomMeasureDto newCustomMeasure(ComponentDto project, MetricDto metric) {\n    return newCustomMeasureDto()\n      .setMetricId(metric.getId())\n      .setComponentId(project.getId())\n      .setComponentUuid(project.uuid())\n      .setCreatedAt(system.now());\n  }","id":73012,"modified_method":"private CustomMeasureDto newCustomMeasure(ComponentDto project, MetricDto metric) {\n    return newCustomMeasureDto()\n      .setMetricId(metric.getId())\n      .setComponentUuid(project.uuid())\n      .setCreatedAt(system.now());\n  }","commit_id":"163630e0c9de6278cee233e2d79dfd21fbd9c2c0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void update_description_only() throws Exception {\n    MetricDto metric = insertNewMetric(ValueType.STRING);\n    ComponentDto component = insertNewProject(\"project-uuid\");\n    CustomMeasureDto customMeasure = newCustomMeasure(component, metric)\n      .setMetricId(metric.getId())\n      .setComponentId(component.getId())\n      .setComponentUuid(component.uuid())\n      .setCreatedAt(system.now())\n      .setDescription(\"custom-measure-description\")\n      .setTextValue(\"text-measure-value\");\n    dbClient.customMeasureDao().insert(dbSession, customMeasure);\n    dbSession.commit();\n    when(system.now()).thenReturn(123_456_789L);\n\n    ws.newPostRequest(CustomMeasuresWs.ENDPOINT, UpdateAction.ACTION)\n      .setParam(PARAM_ID, String.valueOf(customMeasure.getId()))\n      .setParam(PARAM_VALUE, \"new-text-measure-value\")\n      .execute();\n\n    CustomMeasureDto updatedCustomMeasure = dbClient.customMeasureDao().selectById(dbSession, customMeasure.getId());\n    assertThat(updatedCustomMeasure.getTextValue()).isEqualTo(\"new-text-measure-value\");\n    assertThat(updatedCustomMeasure.getDescription()).isEqualTo(\"custom-measure-description\");\n    assertThat(updatedCustomMeasure.getUpdatedAt()).isEqualTo(123_456_789L);\n    assertThat(customMeasure.getCreatedAt()).isEqualTo(updatedCustomMeasure.getCreatedAt());\n  }","id":73013,"modified_method":"@Test\n  public void update_description_only() throws Exception {\n    MetricDto metric = insertNewMetric(ValueType.STRING);\n    ComponentDto component = insertNewProject(\"project-uuid\");\n    CustomMeasureDto customMeasure = newCustomMeasure(component, metric)\n      .setMetricId(metric.getId())\n      .setComponentUuid(component.uuid())\n      .setCreatedAt(system.now())\n      .setDescription(\"custom-measure-description\")\n      .setTextValue(\"text-measure-value\");\n    dbClient.customMeasureDao().insert(dbSession, customMeasure);\n    dbSession.commit();\n    when(system.now()).thenReturn(123_456_789L);\n\n    ws.newPostRequest(CustomMeasuresWs.ENDPOINT, UpdateAction.ACTION)\n      .setParam(PARAM_ID, String.valueOf(customMeasure.getId()))\n      .setParam(PARAM_VALUE, \"new-text-measure-value\")\n      .execute();\n\n    CustomMeasureDto updatedCustomMeasure = dbClient.customMeasureDao().selectById(dbSession, customMeasure.getId());\n    assertThat(updatedCustomMeasure.getTextValue()).isEqualTo(\"new-text-measure-value\");\n    assertThat(updatedCustomMeasure.getDescription()).isEqualTo(\"custom-measure-description\");\n    assertThat(updatedCustomMeasure.getUpdatedAt()).isEqualTo(123_456_789L);\n    assertThat(customMeasure.getCreatedAt()).isEqualTo(updatedCustomMeasure.getCreatedAt());\n  }","commit_id":"163630e0c9de6278cee233e2d79dfd21fbd9c2c0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_if_not_logged_in() throws Exception {\n    userSessionRule.anonymous();\n    expectedException.expect(UnauthorizedException.class);\n    MetricDto metric = MetricTesting.newMetricDto().setEnabled(true).setValueType(ValueType.STRING.name());\n    dbClient.metricDao().insert(dbSession, metric);\n    ComponentDto component = ComponentTesting.newProjectDto(\"project-uuid\");\n    dbClient.componentDao().insert(dbSession, component);\n    CustomMeasureDto customMeasure = newCustomMeasureDto()\n      .setMetricId(metric.getId())\n      .setComponentId(component.getId())\n      .setComponentUuid(component.uuid())\n      .setCreatedAt(system.now())\n      .setDescription(\"custom-measure-description\")\n      .setTextValue(\"text-measure-value\");\n    dbClient.customMeasureDao().insert(dbSession, customMeasure);\n    dbSession.commit();\n\n    ws.newPostRequest(CustomMeasuresWs.ENDPOINT, UpdateAction.ACTION)\n      .setParam(PARAM_ID, String.valueOf(customMeasure.getId()))\n      .setParam(PARAM_DESCRIPTION, \"new-custom-measure-description\")\n      .setParam(PARAM_VALUE, \"1984\")\n      .execute();\n  }","id":73014,"modified_method":"@Test\n  public void fail_if_not_logged_in() throws Exception {\n    userSessionRule.anonymous();\n    expectedException.expect(UnauthorizedException.class);\n    MetricDto metric = MetricTesting.newMetricDto().setEnabled(true).setValueType(ValueType.STRING.name());\n    dbClient.metricDao().insert(dbSession, metric);\n    ComponentDto component = ComponentTesting.newProjectDto(\"project-uuid\");\n    dbClient.componentDao().insert(dbSession, component);\n    CustomMeasureDto customMeasure = newCustomMeasureDto()\n      .setMetricId(metric.getId())\n      .setComponentUuid(component.uuid())\n      .setCreatedAt(system.now())\n      .setDescription(\"custom-measure-description\")\n      .setTextValue(\"text-measure-value\");\n    dbClient.customMeasureDao().insert(dbSession, customMeasure);\n    dbSession.commit();\n\n    ws.newPostRequest(CustomMeasuresWs.ENDPOINT, UpdateAction.ACTION)\n      .setParam(PARAM_ID, String.valueOf(customMeasure.getId()))\n      .setParam(PARAM_DESCRIPTION, \"new-custom-measure-description\")\n      .setParam(PARAM_VALUE, \"1984\")\n      .execute();\n  }","commit_id":"163630e0c9de6278cee233e2d79dfd21fbd9c2c0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public boolean accept(MuleMessage obj)\n    {\n         Object accept = obj.getProperty(toString());\n         \n         if (accept == null && SxcFilteringOutboundRouter.getCurrentMessage() == null) \n         {\n             return false;\n         }\n         else if (accept == null)\n         {\n             throw new UndefinedMatchException();\n         }\n         \n         return ((Boolean) accept).booleanValue();\n    }","id":73015,"modified_method":"public boolean accept(MuleMessage obj)\n    {\n         Object accept = obj.getProperty(toString());\n         \n         if (accept == null && SxcFilteringOutboundRouter.getCurrentMessage() == null) \n         {\n             return false;\n         }\n         else if (accept == null)\n         {\n             throw new UndefinedMatchException();\n         }\n         \n         return (Boolean) accept;\n    }","commit_id":"88707403438770a9fc65029c52fdee4894f2ae9a","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testNotFilter() throws Exception\n    {\n        final MuleClient client = new MuleClient(muleContext);\n\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        IOUtils.copy(getClass().getResourceAsStream(\"/purchase-order.xml\"), out);\n\n        MuleMessage res = client.send(\"vm://not-filter\", out.toByteArray(), null);\n\n        assertEquals(Boolean.TRUE, res.getPayload());\n    }","id":73016,"modified_method":"public void testNotFilter() throws Exception\n    {\n        final MuleClient client = new MuleClient(muleContext);\n\n        final String testData = IOUtils.toString(getClass().getResourceAsStream(\"/purchase-order.xml\"));\n\n        MuleMessage res = client.send(\"vm://not-filter\", testData, null);\n\n        assertEquals(Boolean.TRUE, res.getPayload());\n    }","commit_id":"88707403438770a9fc65029c52fdee4894f2ae9a","url":"https://github.com/mulesoft/mule"},{"original_method":"public void xtestBenchmark() throws Exception\n    {\n        final MuleClient client = new MuleClient(muleContext);\n\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        IOUtils.copy(getClass().getResourceAsStream(\"/purchase-order.xml\"), out);\n\n        System.out.println(\"Warmup\");\n        fire(client, out, 1500);\n\n        System.out.println(\"Running....\");\n\n        fire(client, out, 1000);\n\n        Thread.sleep(1000);\n    }","id":73017,"modified_method":"public void xtestBenchmark() throws Exception\n    {\n        final MuleClient client = new MuleClient(muleContext);\n\n        final String testData = IOUtils.toString(getClass().getResourceAsStream(\"/purchase-order.xml\"));\n\n        System.out.println(\"Warmup\");\n        fire(client, testData, 1500);\n\n        System.out.println(\"Running....\");\n\n        fire(client, testData, 1000);\n\n        Thread.sleep(1000);\n    }","commit_id":"88707403438770a9fc65029c52fdee4894f2ae9a","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testBasicXPath() throws Exception\n    {\n        final MuleClient client = new MuleClient(muleContext);\n\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        IOUtils.copy(getClass().getResourceAsStream(\"/purchase-order.xml\"), out);\n\n        MuleMessage res = client.send(\"vm://in\", out.toByteArray(), null);\n        assertEquals(Boolean.TRUE, res.getPayload());\n    }","id":73018,"modified_method":"public void testBasicXPath() throws Exception\n    {\n        final MuleClient client = new MuleClient(muleContext);\n\n        final String testData = IOUtils.toString(getClass().getResourceAsStream(\"/purchase-order.xml\"));\n\n        MuleMessage res = client.send(\"vm://in\", testData, null);\n        assertEquals(Boolean.TRUE, res.getPayload());\n    }","commit_id":"88707403438770a9fc65029c52fdee4894f2ae9a","url":"https://github.com/mulesoft/mule"},{"original_method":"private void fire(final MuleClient client, final ByteArrayOutputStream out, final int count)\n        throws InterruptedException\n    {\n        long time = System.currentTimeMillis();\n        finished = 0;\n        for (int i = 0; i < 10; i++)\n        {\n            new Thread(new Runnable()\n            {\n                public void run()\n                {\n                    for (int j = 0; j < count; j++)\n                    {\n                        try\n                        {\n                            client.send(\"vm://in\", out.toByteArray(), null);\n                        }\n                        catch (MuleException e)\n                        {\n                            fail(\"Exception in worker thread\");\n                        }\n                    }\n                    finished++;\n                }\n            }).start();\n        }\n\n        while (finished < 10)\n        {\n            Thread.sleep(100);\n        }\n        System.out.println(\"elapsed \" + (System.currentTimeMillis() - time));\n\n    }","id":73019,"modified_method":"private void fire(final MuleClient client, final String testData, final int count)\n        throws InterruptedException\n    {\n        long time = System.currentTimeMillis();\n        finished = 0;\n        for (int i = 0; i < 10; i++)\n        {\n            new Thread(new Runnable()\n            {\n                public void run()\n                {\n                    for (int j = 0; j < count; j++)\n                    {\n                        try\n                        {\n                            client.send(\"vm://in\", testData, null);\n                        }\n                        catch (MuleException e)\n                        {\n                            fail(\"Exception in worker thread\");\n                        }\n                    }\n                    finished++;\n                }\n            }).start();\n        }\n\n        while (finished < 10)\n        {\n            Thread.sleep(100);\n        }\n        System.out.println(\"elapsed \" + (System.currentTimeMillis() - time));\n\n    }","commit_id":"88707403438770a9fc65029c52fdee4894f2ae9a","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testOrFilter() throws Exception\n    {\n        final MuleClient client = new MuleClient(muleContext);\n\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        IOUtils.copy(getClass().getResourceAsStream(\"/purchase-order.xml\"), out);\n\n        MuleMessage res = client.send(\"vm://or-filter\", out.toByteArray(), null);\n\n        assertEquals(Boolean.TRUE, res.getPayload());\n    }","id":73020,"modified_method":"public void testOrFilter() throws Exception\n    {\n        final MuleClient client = new MuleClient(muleContext);\n\n        final String testData = IOUtils.toString(getClass().getResourceAsStream(\"/purchase-order.xml\"));\n\n        MuleMessage res = client.send(\"vm://or-filter\", testData, null);\n\n        assertEquals(Boolean.TRUE, res.getPayload());\n    }","commit_id":"88707403438770a9fc65029c52fdee4894f2ae9a","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testAndFilter() throws Exception\n    {\n        final MuleClient client = new MuleClient(muleContext);\n\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        IOUtils.copy(getClass().getResourceAsStream(\"/purchase-order.xml\"), out);\n\n        MuleMessage res = client.send(\"vm://and-filter\", out.toByteArray(), null);\n\n        assertEquals(Boolean.TRUE, res.getPayload());\n    }","id":73021,"modified_method":"public void testAndFilter() throws Exception\n    {\n        final MuleClient client = new MuleClient(muleContext);\n\n        final String testData = IOUtils.toString(getClass().getResourceAsStream(\"/purchase-order.xml\"));\n\n        MuleMessage res = client.send(\"vm://and-filter\", testData, null);\n\n        assertEquals(Boolean.TRUE, res.getPayload());\n    }","commit_id":"88707403438770a9fc65029c52fdee4894f2ae9a","url":"https://github.com/mulesoft/mule"},{"original_method":"private SAMRecord hardClipByReferenceCoordinates(int refStart, int refStop) {\n        int start = (refStart < 0) ? 0 : ReadUtils.getReadCoordinateForReferenceCoordinate(read, refStart);\n        int stop =  (refStop  < 0) ? read.getReadLength() - 1 : ReadUtils.getReadCoordinateForReferenceCoordinate(read, refStop);\n\n        if (start < 0 || stop > read.getReadLength() - 1)\n            throw new ReviewedStingException(\"Trying to clip before the start or after the end of a read\");\n\n        if ( start > stop ) {\n//            stop = ReadUtils.getReadCoordinateForReferenceCoordinate(read, ReadUtils.getRefCoordSoftUnclippedEnd(read));\n            throw new ReviewedStingException(\"START > STOP -- this should never happen -- call Mauricio!\");\n        }\n\n        //This tries to fix the bug where the deletion is counted a read base and as a result, the hardCLipper runs into\n        //an endless loop when hard clipping the cigar string because the read coordinates are not covered by the read\n//        stop -= numDeletions(read);\n//        if ( start > stop )\n//            start -= numDeletions(read);\n\n\n        //System.out.println(\"Clipping start/stop: \" + start + \"/\" + stop);\n        this.addOp(new ClippingOp(start, stop));\n        SAMRecord clippedRead = clipRead(ClippingRepresentation.HARDCLIP_BASES);\n        this.ops = null;\n        return clippedRead;\n    }","id":73022,"modified_method":"private SAMRecord hardClipByReferenceCoordinates(int refStart, int refStop) {\n        int start = (refStart < 0) ? 0 : ReadUtils.getReadCoordinateForReferenceCoordinate(read, refStart, ReadUtils.ClippingTail.RIGHT_TAIL);\n        int stop =  (refStop  < 0) ? read.getReadLength() - 1 : ReadUtils.getReadCoordinateForReferenceCoordinate(read, refStop, ReadUtils.ClippingTail.LEFT_TAIL);\n\n        if (start < 0 || stop > read.getReadLength() - 1)\n            throw new ReviewedStingException(\"Trying to clip before the start or after the end of a read\");\n\n        if ( start > stop )\n            throw new ReviewedStingException(\"START > STOP -- this should never happen -- call Mauricio!\");\n\n        this.addOp(new ClippingOp(start, stop));\n        SAMRecord clippedRead = clipRead(ClippingRepresentation.HARDCLIP_BASES);\n        this.ops = null;\n        return clippedRead;\n    }","commit_id":"3b6e43b7c4c64df97dfc0fa8d5cdb1db9aeda87b","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Requires({\"refCoord >= read.getUnclippedStart()\", \"refCoord <= read.getUnclippedEnd()\"})\n    @Ensures({\"result >= 0\", \"result < read.getReadLength()\"})\n    public static int getReadCoordinateForReferenceCoordinate(SAMRecord read, int refCoord) {\n        int readBases = 0;\n        int refBases = 0;\n\n        if (refCoord < read.getAlignmentStart()) {\n            readBases = getReadCoordinateForReferenceCoordinateBeforeAlignmentStart(read, refCoord);\n            if (readBases < 0)\n                throw new ReviewedStingException(\"Requested a coordinate in a hard clipped area of the read. No equivalent read coordinate.\");\n        }\n        else if (refCoord > read.getAlignmentEnd()) {\n            readBases = getReadCoordinateForReferenceCoordinateBeforeAlignmentEnd(read, refCoord);\n            if (readBases < 0)\n                throw new ReviewedStingException(\"Requested a coordinate in a hard clipped area of the read. No equivalent read coordinate.\");\n        }\n        else {\n            int goal = refCoord - read.getAlignmentStart();  // The goal is to move this many reference bases\n            boolean goalReached = refBases == goal;\n\n            Iterator<CigarElement> cigarElementIterator = read.getCigar().getCigarElements().iterator();\n            while (!goalReached && cigarElementIterator.hasNext()) {\n                CigarElement cigarElement = cigarElementIterator.next();\n                int shift = 0;\n\n                if (cigarElement.getOperator().consumesReferenceBases()) {\n                    if (refBases + cigarElement.getLength() < goal) {\n                        shift = cigarElement.getLength();\n                    }\n                    else {\n                        shift = goal - refBases;\n                    }\n                    refBases += shift;\n                }\n                goalReached = refBases == goal;\n\n                if (cigarElement.getOperator().consumesReadBases()) {\n                    readBases += goalReached ? shift : cigarElement.getLength();\n                }\n            }\n\n            if (!goalReached)\n                throw new ReviewedStingException(\"Somehow the requested coordinate is not covered by the read. Too many deletions?\");\n        }\n\n        return readBases;\n    }","id":73023,"modified_method":"/**\n     * Returns the read coordinate corresponding to the requested reference coordinate.\n     *\n     * WARNING: if the requested reference coordinate happens to fall inside a deletion in the read, this function\n     * will return the last read base before the deletion. This function returns a\n     * Pair(int readCoord, boolean fallsInsideDeletion) so you can choose which readCoordinate to use when faced with\n     * a deletion.\n     *\n     * SUGGESTION: Use getReadCoordinateForReferenceCoordinate(SAMRecord, int, ClippingTail) instead to get a\n     * pre-processed result according to normal clipping needs. Or you can use this function and tailor the\n     * behavior to your needs.\n     *\n     * @param read\n     * @param refCoord\n     * @return the read coordinate corresponding to the requested reference coordinate. (see warning!)\n     */\n    @Requires({\"refCoord >= read.getUnclippedStart()\", \"refCoord <= read.getUnclippedEnd()\"})\n    @Ensures({\"result >= 0\", \"result < read.getReadLength()\"})\n    public static Pair<Integer, Boolean> getReadCoordinateForReferenceCoordinate(SAMRecord read, int refCoord) {\n        int readBases = 0;\n        int refBases = 0;\n        boolean fallsInsideDeletion = false;\n\n        if (refCoord < read.getAlignmentStart()) {\n            readBases = getReadCoordinateForReferenceCoordinateBeforeAlignmentStart(read, refCoord);\n            if (readBases < 0)\n                throw new ReviewedStingException(\"Requested a coordinate in a hard clipped area of the read. No equivalent read coordinate.\");\n        }\n        else if (refCoord > read.getAlignmentEnd()) {\n            readBases = getReadCoordinateForReferenceCoordinateBeforeAlignmentEnd(read, refCoord);\n            if (readBases < 0)\n                throw new ReviewedStingException(\"Requested a coordinate in a hard clipped area of the read. No equivalent read coordinate.\");\n        }\n        else {\n            int goal = refCoord - read.getAlignmentStart();  // The goal is to move this many reference bases\n            boolean goalReached = refBases == goal;\n\n            Iterator<CigarElement> cigarElementIterator = read.getCigar().getCigarElements().iterator();\n            while (!goalReached && cigarElementIterator.hasNext()) {\n                CigarElement cigarElement = cigarElementIterator.next();\n                int shift = 0;\n\n                if (cigarElement.getOperator().consumesReferenceBases()) {\n                    if (refBases + cigarElement.getLength() < goal)\n                        shift = cigarElement.getLength();\n                    else\n                        shift = goal - refBases;\n\n                    refBases += shift;\n                }\n                goalReached = refBases == goal;\n\n                if (!goalReached && cigarElement.getOperator().consumesReadBases())\n                    readBases += cigarElement.getLength();\n\n                if (goalReached) {\n                    // Is this base's reference position within this cigar element? Or did we use it all?\n                    boolean endsWithinCigar = shift <  cigarElement.getLength();\n\n                    // If it isn't, we need to check the next one. There should *ALWAYS* be a next one\n                    // since we checked if the goal coordinate is within the read length, so this is just a sanity check.\n                    if (!endsWithinCigar && !cigarElementIterator.hasNext())\n                        throw new ReviewedStingException(\"Reference coordinate corresponds to a non-existent base in the read. This should never happen -- call Mauricio\");\n\n                    CigarElement nextCigarElement;\n\n                    // if we end inside the current cigar element, we just have to check if it is a deletion\n                    if (endsWithinCigar)\n                        fallsInsideDeletion = cigarElement.getOperator() == CigarOperator.DELETION;\n\n                    // if we end outside the current cigar element, we need to check if the next element is a deletion.\n                    else {\n                        nextCigarElement = cigarElementIterator.next();\n                        fallsInsideDeletion = nextCigarElement.getOperator() == CigarOperator.DELETION;\n                    }\n\n                    // If we reached our goal outside a deletion, add the shift\n                    if (!fallsInsideDeletion && cigarElement.getOperator().consumesReadBases())\n                        readBases += shift;\n\n                    // If we reached our goal inside a deletion, but the deletion is the next cigar element then we need\n                    // to add the shift of the current cigar element but go back to it's last element to return the last\n                    // base before the deletion (see warning in function contracts)\n                    else if (fallsInsideDeletion && !endsWithinCigar)\n                        readBases += shift - 1;\n                    }\n            }\n\n            if (!goalReached)\n                throw new ReviewedStingException(\"Somehow the requested coordinate is not covered by the read. Too many deletions?\");\n        }\n\n        return new Pair<Integer, Boolean>(readBases, fallsInsideDeletion);\n    }","commit_id":"3b6e43b7c4c64df97dfc0fa8d5cdb1db9aeda87b","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** Computes the smallest period >= minPeriod for the specified string. The period is defined as such p, \n     * that for all  i = 0... seq.length-1,  seq[ i % p ] = seq[i] (or equivalently seq[i] = seq[i+p] for i=0...seq.length-1-p).\n     *  The sequence does <i>not<\/i> have to contain whole number of periods. For instance, \"ACACACAC\" has a period \n     *  of 2 (it has a period of 4 as well), and so does\n     * \"ACACA\"; similarly, smallest periods of \"CTCCTC\", \"CTCCT\", and \"CTCC\" are all equal to 3. The \"trivial\" period is \n     * the length of the string itself, and it will always be returned if no smaller period can be found in the specified period range\n     * or if specified minPeriod is greater than the sequence length.\n     *   \n     * @param seq\n     * @return\n     */\n    public static int sequencePeriod(String seq, int minPeriod) {\n    \tint period = ( minPeriod > seq.length() ? seq.length() : minPeriod ); \n    \t// we assume that bases [0,period-1] repeat themselves and check this assumption\n    \t// until we find correct period\n    \t\n    \tfor ( int pos = period ; pos < seq.length() ; pos++ ) {\n    \t\t\n    \t\tint offset = pos % period; // we are currenlty 'offset' bases into the putative repeat of period 'period'\n    \t\t                                                // if our current hypothesis holds, base[pos] must be the same as base[offset]\n    \t\t\n    \t\tif ( Character.toUpperCase( seq.charAt(pos) ) !=\n    \t\t\t\tCharacter.toUpperCase( seq.charAt( offset ) )\n    \t\t\t) {\n    \t\t\t\n    \t\t\t// period we have been trying so far does not work.\n    \t\t\t// two possibilities:\n    \t\t\t// A) offset = 0, i.e. current position pos must be start of the next repeat, but it is not;\n    \t\t\t//      in this case only bases from start up to the current one, inclusive, may form a repeat, if at all;\n    \t\t   //       so period is at least pos+1 (remember, pos is 0-based), then on the next loop re-entrance \n    \t\t\t//      pos will be autoincremented and we will be checking next base\n    \t\t\t// B) offset != 0, i.e. the current base breaks the repeat, but maybe it starts a new one?\n    \t\t\t//     hence we should first check if it matches the first base of the sequence, and to do that\n    \t\t\t//     we set period to pos  (thus trying the hypothesis that bases from start up to the current one,\n    \t\t\t//     non-inclusive are repeated hereafter), and decrement pos (this will re-test current base against the first base\n    \t\t\t// on the next loop re-entrance after pos is autoincremented)\n    \t\t\tif ( offset == 0 ) period = pos+1;\n    \t\t\telse period = pos-- ;\n    \t\t\n    \t\t} \n    \t}\n    \treturn period;\n    }","id":73024,"modified_method":"/** Computes the smallest period >= minPeriod for the specified string. The period is defined as such p, \n     * that for all  i = 0... seq.length-1,  seq[ i % p ] = seq[i] (or equivalently seq[i] = seq[i+p] for i=0...seq.length-1-p).\n     *  The sequence does <i>not<\/i> have to contain whole number of periods. For instance, \"ACACACAC\" has a period \n     *  of 2 (it has a period of 4 as well), and so does\n     * \"ACACA\"; similarly, smallest periods of \"CTCCTC\", \"CTCCT\", and \"CTCC\" are all equal to 3. The \"trivial\" period is \n     * the length of the string itself, and it will always be returned if no smaller period can be found in the specified period range\n     * or if specified minPeriod is greater than the sequence length.\n     *   \n     * @param seq\n     * @return\n     */\n    public static int sequencePeriod(byte[] seq, int minPeriod) {\n    \tint period = ( minPeriod > seq.length ? seq.length : minPeriod );\n    \t// we assume that bases [0,period-1] repeat themselves and check this assumption\n    \t// until we find correct period\n    \t\n    \tfor ( int pos = period ; pos < seq.length ; pos++ ) {\n    \t\t\n    \t\tint offset = pos % period; // we are currenlty 'offset' bases into the putative repeat of period 'period'\n    \t\t                                                // if our current hypothesis holds, base[pos] must be the same as base[offset]\n    \t\t\n    \t\tif ( Character.toUpperCase( seq[pos] ) !=\n    \t\t\t\tCharacter.toUpperCase( seq[offset] )\n    \t\t\t) {\n    \t\t\t\n    \t\t\t// period we have been trying so far does not work.\n    \t\t\t// two possibilities:\n    \t\t\t// A) offset = 0, i.e. current position pos must be start of the next repeat, but it is not;\n    \t\t\t//      in this case only bases from start up to the current one, inclusive, may form a repeat, if at all;\n    \t\t   //       so period is at least pos+1 (remember, pos is 0-based), then on the next loop re-entrance \n    \t\t\t//      pos will be autoincremented and we will be checking next base\n    \t\t\t// B) offset != 0, i.e. the current base breaks the repeat, but maybe it starts a new one?\n    \t\t\t//     hence we should first check if it matches the first base of the sequence, and to do that\n    \t\t\t//     we set period to pos  (thus trying the hypothesis that bases from start up to the current one,\n    \t\t\t//     non-inclusive are repeated hereafter), and decrement pos (this will re-test current base against the first base\n    \t\t\t// on the next loop re-entrance after pos is autoincremented)\n    \t\t\tif ( offset == 0 ) period = pos+1;\n    \t\t\telse period = pos-- ;\n    \t\t\n    \t\t} \n    \t}\n    \treturn period;\n    }","commit_id":"1dd9996f3a2339a9a197cd5341d9b7d38fd879e9","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Integer map(char[] ref, SAMRecord read) {\n        if ( currentInterval == null ) {\n            emit(read);\n            return 0;\n        }\n\n        GenomeLoc readLoc = GenomeLocParser.createGenomeLoc(read);\n\n        if ( readLoc.isBefore(currentInterval) ) {\n            emit(read);\n            return 0;\n        }\n        else if ( readLoc.overlapsP(currentInterval) ) {\n            if ( read.getReadUnmappedFlag() ||\n                 read.getDuplicateReadFlag() ||\n                 read.getNotPrimaryAlignmentFlag() ||\n                 read.getMappingQuality() == 0 ||\n                 read.getAlignmentStart() == SAMRecord.NO_ALIGNMENT_START ||\n\t\t         Utils.is454Read(read) ) {\n                emit(read);\n            }\n\n            readsToClean.add(read, ref);\n            if ( readsToClean.size() >= MAX_READS ) {\n                emit(readsToClean.getReads());\n                readsToClean.clear();\n                currentInterval = intervals.hasNext() ? intervals.next() : null;\n            }\n        }\n        else {  // the read is past the current interval\n            clean(readsToClean);\n            emit(readsToClean.getReads());\n            readsToClean.clear();\n            currentInterval = intervals.hasNext() ? intervals.next() : null;\n\n            // call back into map now that the state has been updated\n            map(ref, read);\n        }\n\n        return 0;\n    }","id":73025,"modified_method":"public Integer map(char[] ref, SAMRecord read) {\n        if ( currentInterval == null ) {\n            emit(read);\n            return 0;\n        }\n\n        GenomeLoc readLoc = GenomeLocParser.createGenomeLoc(read);\n        // hack to get around unmapped reads having screwy locations\n        if ( readLoc.getStop() == 0 )\n            readLoc = GenomeLocParser.createGenomeLoc(readLoc.getContig(), readLoc.getStart(), readLoc.getStart());\n\n        if ( readLoc.isBefore(currentInterval) ) {\n            emit(read);\n            return 0;\n        }\n        else if ( readLoc.overlapsP(currentInterval) ) {\n            if ( read.getReadUnmappedFlag() ||\n                 read.getDuplicateReadFlag() ||\n                 read.getNotPrimaryAlignmentFlag() ||\n                 read.getMappingQuality() == 0 ||\n                 read.getAlignmentStart() == SAMRecord.NO_ALIGNMENT_START ||\n\t\t         Utils.is454Read(read) ) {\n                readsNotToClean.add(read);\n            } else {\n                readsToClean.add(read, ref);\n            }\n\n            if ( readsToClean.size() + readsNotToClean.size() >= MAX_READS ) {\n                // merge the two sets for emission\n                readsNotToClean.addAll(readsToClean.getReads());\n                emit(readsNotToClean);\n                readsToClean.clear();\n                readsNotToClean.clear();\n                currentInterval = intervals.hasNext() ? intervals.next() : null;\n            }\n        }\n        else {  // the read is past the current interval\n            clean(readsToClean);\n\n            // merge the two sets for emission\n            readsNotToClean.addAll(readsToClean.getReads());\n            emit(readsNotToClean);\n            readsToClean.clear();\n            readsNotToClean.clear();\n\n            currentInterval = intervals.hasNext() ? intervals.next() : null;\n\n            // call back into map now that the state has been updated\n            map(ref, read);\n        }\n\n        return 0;\n    }","commit_id":"1dd9996f3a2339a9a197cd5341d9b7d38fd879e9","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void add(SAMRecord read, char[] ref) {\n            reads.add(read);\n\n            // set up the reference\n            if ( reference == null ) {\n                reference = ref;\n                loc = GenomeLocParser.createGenomeLoc(read);\n            } else {\n                long lastPosWithRefBase = loc.getStart() + reference.length -1;\n                int neededBases = (int)(read.getAlignmentEnd() - lastPosWithRefBase);\n                char[] newReference = new char[reference.length + neededBases];\n                System.arraycopy(reference, 0, newReference, 0, reference.length);\n                System.arraycopy(ref, ref.length-neededBases, newReference, reference.length, neededBases);\n                reference = newReference;\n            }\n        }","id":73026,"modified_method":"public void add(SAMRecord read, char[] ref) {\n            reads.add(read);\n\n            // set up the reference\n            if ( reference == null ) {\n                reference = ref;\n                loc = GenomeLocParser.createGenomeLoc(read);\n            } else {\n                long lastPosWithRefBase = loc.getStart() + reference.length -1;\n                int neededBases = (int)(read.getAlignmentEnd() - lastPosWithRefBase);\n                if ( neededBases > 0 ) {\n                    char[] newReference = new char[reference.length + neededBases];\n                    System.arraycopy(reference, 0, newReference, 0, reference.length);\n                    System.arraycopy(ref, ref.length-neededBases, newReference, reference.length, neededBases);\n                    reference = newReference;\n                }\n            }\n        }","commit_id":"1dd9996f3a2339a9a197cd5341d9b7d38fd879e9","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void onTraversalDone(Integer result) {\n        if ( readsToClean.size() > 0 ) {\n            clean(readsToClean);\n            emit(readsToClean.getReads());\n        }\n\n        writer.close();\n\n        if ( OUT_INDELS != null ) {\n            try {\n                indelOutput.close();\n            } catch (Exception e) {\n                logger.error(\"Failed to close \"+OUT_INDELS+\" gracefully. Data may be corrupt.\");\n            }\n        }\n        if ( OUT_STATS != null ) {\n            try {\n                statsOutput.close();\n            } catch (Exception e) {\n                logger.error(\"Failed to close \"+OUT_STATS+\" gracefully. Data may be corrupt.\");\n            }\n        }\n        if ( OUT_SNPS != null ) {\n            try {\n                snpsOutput.close();\n            } catch (Exception e) {\n                logger.error(\"Failed to close \"+OUT_SNPS+\" gracefully. Data may be corrupt.\");\n            }\n        }\n    }","id":73027,"modified_method":"public void onTraversalDone(Integer result) {\n        if ( readsToClean.size() > 0 || readsNotToClean.size() > 0 ) {\n            clean(readsToClean);\n\n            // merge the two sets for emission\n            readsNotToClean.addAll(readsToClean.getReads());\n            emit(readsNotToClean);\n        }\n\n        writer.close();\n\n        if ( OUT_INDELS != null ) {\n            try {\n                indelOutput.close();\n            } catch (Exception e) {\n                logger.error(\"Failed to close \"+OUT_INDELS+\" gracefully. Data may be corrupt.\");\n            }\n        }\n        if ( OUT_STATS != null ) {\n            try {\n                statsOutput.close();\n            } catch (Exception e) {\n                logger.error(\"Failed to close \"+OUT_STATS+\" gracefully. Data may be corrupt.\");\n            }\n        }\n        if ( OUT_SNPS != null ) {\n            try {\n                snpsOutput.close();\n            } catch (Exception e) {\n                logger.error(\"Failed to close \"+OUT_SNPS+\" gracefully. Data may be corrupt.\");\n            }\n        }\n    }","commit_id":"1dd9996f3a2339a9a197cd5341d9b7d38fd879e9","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** Takes the alignment of the read sequence <code>readSeq<\/code> to the reference sequence <code>refSeq<\/code>\n     * starting at 0-based position <code>refIndex<\/code> on the <code>refSeq<\/code> and specified by its <code>cigar<\/code>.\n     * The last argument <code>readIndex<\/code> specifies 0-based position on the read where the alignment described by the\n     * <code>cigar<\/code> starts. Usually cigars specify alignments of the whole read to the ref, so that readIndex is normally 0.\n     * Use non-zero readIndex only when the alignment cigar represents alignment of a part of the read. The refIndex in this case\n     * should be the position where the alignment of that part of the read starts at. In other words, both refIndex and readIndex are\n     * always the positions where the cigar starts on the ref and on the read, respectively.\n     *\n     * If the alignment has an indel, then this method attempts moving this indel left across a stretch of repetitive bases. For instance, if the original cigar\n     * specifies that (any) one AT  is deleted from a repeat sequence TATATATA, the output cigar will always mark the leftmost AT\n     * as deleted. If there is no indel in the original cigar, or the indel position is determined unambiguously (i.e. inserted/deleted sequence\n     * is not repeated), the original cigar is returned.\n     * @param cigar structure of the original alignment\n     * @param refSeq reference sequence the read is aligned to\n     * @param readSeq read sequence\n     * @param refIndex 0-based alignment start position on ref\n     * @param readIndex 0-based alignment start position on read\n     * @return a cigar, in which indel is guaranteed to be placed at the leftmost possible position across a repeat (if any)\n     */\n    private Cigar indelRealignment(Cigar cigar, byte[] refSeq, byte[] readSeq, int refIndex, int readIndex) {\n        if ( cigar.numCigarElements() < 2 ) return cigar; // no indels, nothing to do\n\n        CigarElement ce1 = cigar.getCigarElement(0);\n        CigarElement ce2 = cigar.getCigarElement(1);\n\n        // we currently can not handle clipped reads; alternatively, if the alignment starts from insertion, there\n        // is no place on the read to move that insertion further left; so we are done:\n        if ( ce1.getOperator() != CigarOperator.M ) return cigar;\n\n        int difference = 0; // we can move indel 'difference' bases left\n        final int indel_length = ce2.getLength();\n\n        String indelString; // inserted or deleted sequence\n        int period = 0; // period of the inserted/deleted sequence\n        int indelIndexOnRef = refIndex+ce1.getLength() ; // position of the indel on the REF (first deleted base or first base after insertion)\n        int indelIndexOnRead = readIndex+ce1.getLength(); // position of the indel on the READ (first insterted base, of first base after deletion)\n\n        if ( ce2.getOperator() == CigarOperator.D )\n            indelString = new String(refSeq, indelIndexOnRef, ce2.getLength()).toUpperCase(); // deleted bases\n        else if ( ce2.getOperator() == CigarOperator.I )\n            indelString = new String(readSeq, indelIndexOnRead, ce2.getLength()).toUpperCase(); // get the inserted bases\n        else\n            // we can get here if there is soft clipping done at the beginning of the read\n            // for now, we'll just punt the issue and not try to realign these\n            return cigar;\n\n        // now we have to check all WHOLE periods of the indel sequence:\n        //  for instance, if\n        //   REF:   AGCTATATATAGCC\n        //   READ:   GCTAT***TAGCC\n        // the deleted sequence ATA does have period of 2, but deletion obviously can not be\n        // shifted left by 2 bases (length 3 does not contain whole number of periods of 2);\n        // however if 4 bases are deleted:\n        //   REF:   AGCTATATATAGCC\n        //   READ:   GCTA****TAGCC\n        // the length 4 is a multiple of the period of 2, and indeed deletion site can be moved left by 2 bases!\n        //  Also, we will always have to check the length of the indel sequence itself (trivial period). If the smallest\n        // period is 1 (which means that indel sequence is a homo-nucleotide sequence), we obviously do not have to check\n        // any other periods.\n\n        // NOTE: we treat both insertions and deletions in the same way below: we always check if the indel sequence\n        // repeats itsels on the REF (never on the read!), even for insertions: if we see TA inserted and REF has, e.g., CATATA prior to the insertion\n        // position, we will move insertion left, to the position right after CA. This way, while moving the indel across the repeat\n        // on the ref, we can theoretically move it across a non-repeat on the read if the latter has a mismtach.\n\n        while ( period < indel_length ) { // we will always get at least trivial period = indelStringLength\n\n                period = BaseUtils.sequencePeriod(indelString, period+1);\n\n                if ( indel_length % period != 0 ) continue; // if indel sequence length is not a multiple of the period, it's not gonna work\n\n                int newIndex = indelIndexOnRef;\n\n                while ( newIndex >= period ) { // let's see if there is a repeat, i.e. if we could also say that same bases at lower position are deleted\n\n                    // lets check if bases [newIndex-period,newIndex) immediately preceding the indel on the ref\n                    // are the same as the currently checked period of the inserted sequence:\n\n                    boolean match = true;\n\n                    for ( int testRefPos = newIndex - period, indelPos = 0 ; testRefPos < newIndex; testRefPos++, indelPos++) {\n                        char indelChr = indelString.charAt(indelPos);\n                        if ( Character.toUpperCase(refSeq[testRefPos]) != indelChr || BaseUtils.simpleBaseToBaseIndex(indelChr) == -1 ) {\n                            match = false;\n                            break;\n                        }\n                    }\n                    if ( match )\n                        newIndex -= period; // yes, they are the same, we can move indel farther left by at least period bases, go check if we can do more...\n                    else break; // oops, no match, can not push indel farther left\n                }\n\n                final int newDifference = indelIndexOnRef - newIndex;\n                if ( newDifference > difference ) difference = newDifference; // deletion should be moved 'difference' bases left\n\n                if ( period == 1 ) break; // we do not have to check all periods of homonucleotide sequences, we already\n                                          // got maximum possible shift after checking period=1 above.\n        }\n\n        //        if ( ce2.getLength() >= 2 )\n        //            System.out.println(\"-----------------------------------\\n  FROM:\\n\"+AlignmentUtils.alignmentToString(cigar,readSeq,refSeq,refIndex, (readIsConsensusSequence?refIndex:0)));\n\n\n        if ( difference > 0 ) {\n\n            // The following if() statement: this should've never happened, unless the alignment is really screwed up.\n            // A real life example:\n            //\n            //   ref:    TTTTTTTTTTTTTTTTTT******TTTTTACTTATAGAAGAAAT...\n            //  read:       GTCTTTTTTTTTTTTTTTTTTTTTTTACTTATAGAAGAAAT...\n            //\n            //  i.e. the alignment claims 6 T's to be inserted. The alignment is clearly malformed/non-conforming since we could\n            // have just 3 T's inserted (so that the beginning of the read maps right onto the beginning of the\n            // reference fragment shown): that would leave us with same 2 mismatches at the beginning of the read\n            // (G and C) but lower gap penalty. Note that this has nothing to do with the alignment being \"right\" or \"wrong\"\n            // with respect to where on the DNA the read actually came from. It is the assumptions of *how* the alignments are\n            // built and represented that are broken here. While it is unclear how the alignment shown above could be generated\n            // in the first place, we are not in the business of fixing incorrect alignments in this method; all we are\n            // trying to do is to left-adjust correct ones. So if something like that happens, we refuse to change the cigar\n            // and bail out.\n            if ( ce1.getLength()-difference < 0 ) return cigar;\n\n            Cigar newCigar = new Cigar();\n            // do not add leading M cigar element if its length is zero (i.e. if we managed to left-shift the\n            // insertion all the way to the read start):\n            if ( ce1.getLength() - difference > 0 )\n                newCigar.add(new CigarElement(ce1.getLength()-difference, CigarOperator.M));\n            newCigar.add(ce2);  // add the indel, now it's left shifted since we decreased the number of preceding matching bases\n\n            if ( cigar.numCigarElements() > 2 ) {\n                // if we got something following the indel element:\n\n                if ( cigar.getCigarElement(2).getOperator() == CigarOperator.M  ) {\n                    // if indel was followed by matching bases (that's the most common situation),\n                    // increase the length of the matching section after the indel by the amount of left shift\n                    // (matching bases that were on the left are now *after* the indel; we have also checked at the beginning\n                    // that the first cigar element was also M):\n                    newCigar.add(new CigarElement(cigar.getCigarElement(2).getLength()+difference, CigarOperator.M));\n                } else {\n                    // if the element after the indel was not M, we have to add just the matching bases that were on the left\n                    // and now appear after the indel after we performed the shift. Then add the original element that followed the indel.\n                    newCigar.add(new CigarElement(difference, CigarOperator.M));\n                    newCigar.add(new CigarElement(cigar.getCigarElement(2).getLength(),cigar.getCigarElement(2).getOperator()));\n                }\n                // now add remaining (unchanged) cigar elements, if any:\n                for ( int i = 3 ; i < cigar.numCigarElements() ; i++ )  {\n                    newCigar.add(new CigarElement(cigar.getCigarElement(i).getLength(),cigar.getCigarElement(i).getOperator()));\n                }\n            }\n\n            //logger.debug(\"Realigning indel: \" + AlignmentUtils.cigarToString(cigar) + \" to \" + AlignmentUtils.cigarToString(newCigar));\n            cigar = newCigar;\n\n        }\n        return cigar;\n    }","id":73028,"modified_method":"/** Takes the alignment of the read sequence <code>readSeq<\/code> to the reference sequence <code>refSeq<\/code>\n     * starting at 0-based position <code>refIndex<\/code> on the <code>refSeq<\/code> and specified by its <code>cigar<\/code>.\n     * The last argument <code>readIndex<\/code> specifies 0-based position on the read where the alignment described by the\n     * <code>cigar<\/code> starts. Usually cigars specify alignments of the whole read to the ref, so that readIndex is normally 0.\n     * Use non-zero readIndex only when the alignment cigar represents alignment of a part of the read. The refIndex in this case\n     * should be the position where the alignment of that part of the read starts at. In other words, both refIndex and readIndex are\n     * always the positions where the cigar starts on the ref and on the read, respectively.\n     *\n     * If the alignment has an indel, then this method attempts moving this indel left across a stretch of repetitive bases. For instance, if the original cigar\n     * specifies that (any) one AT  is deleted from a repeat sequence TATATATA, the output cigar will always mark the leftmost AT\n     * as deleted. If there is no indel in the original cigar, or the indel position is determined unambiguously (i.e. inserted/deleted sequence\n     * is not repeated), the original cigar is returned.\n     * @param cigar structure of the original alignment\n     * @param refSeq reference sequence the read is aligned to\n     * @param readSeq read sequence\n     * @param refIndex 0-based alignment start position on ref\n     * @param readIndex 0-based alignment start position on read\n     * @return a cigar, in which indel is guaranteed to be placed at the leftmost possible position across a repeat (if any)\n     */\n    private Cigar indelRealignment(Cigar cigar, byte[] refSeq, byte[] readSeq, int refIndex, int readIndex) {\n        if ( cigar.numCigarElements() < 2 ) return cigar; // no indels, nothing to do\n\n        CigarElement ce1 = cigar.getCigarElement(0);\n        CigarElement ce2 = cigar.getCigarElement(1);\n\n        // we currently can not handle clipped reads; alternatively, if the alignment starts from insertion, there\n        // is no place on the read to move that insertion further left; so we are done:\n        if ( ce1.getOperator() != CigarOperator.M ) return cigar;\n\n        int difference = 0; // we can move indel 'difference' bases left\n        final int indel_length = ce2.getLength();\n\n        int period = 0; // period of the inserted/deleted sequence\n        int indelIndexOnRef = refIndex+ce1.getLength() ; // position of the indel on the REF (first deleted base or first base after insertion)\n        int indelIndexOnRead = readIndex+ce1.getLength(); // position of the indel on the READ (first insterted base, of first base after deletion)\n\n        byte[] indelString = new byte[ce2.getLength()];  // inserted or deleted sequence\n        if ( ce2.getOperator() == CigarOperator.D )\n            System.arraycopy(refSeq, indelIndexOnRef, indelString, 0, ce2.getLength());\n        else if ( ce2.getOperator() == CigarOperator.I )\n            System.arraycopy(readSeq, indelIndexOnRead, indelString, 0, ce2.getLength());\n        else\n            // we can get here if there is soft clipping done at the beginning of the read\n            // for now, we'll just punt the issue and not try to realign these\n            return cigar;\n\n        // now we have to check all WHOLE periods of the indel sequence:\n        //  for instance, if\n        //   REF:   AGCTATATATAGCC\n        //   READ:   GCTAT***TAGCC\n        // the deleted sequence ATA does have period of 2, but deletion obviously can not be\n        // shifted left by 2 bases (length 3 does not contain whole number of periods of 2);\n        // however if 4 bases are deleted:\n        //   REF:   AGCTATATATAGCC\n        //   READ:   GCTA****TAGCC\n        // the length 4 is a multiple of the period of 2, and indeed deletion site can be moved left by 2 bases!\n        //  Also, we will always have to check the length of the indel sequence itself (trivial period). If the smallest\n        // period is 1 (which means that indel sequence is a homo-nucleotide sequence), we obviously do not have to check\n        // any other periods.\n\n        // NOTE: we treat both insertions and deletions in the same way below: we always check if the indel sequence\n        // repeats itsels on the REF (never on the read!), even for insertions: if we see TA inserted and REF has, e.g., CATATA prior to the insertion\n        // position, we will move insertion left, to the position right after CA. This way, while moving the indel across the repeat\n        // on the ref, we can theoretically move it across a non-repeat on the read if the latter has a mismtach.\n\n        while ( period < indel_length ) { // we will always get at least trivial period = indelStringLength\n\n                period = BaseUtils.sequencePeriod(indelString, period+1);\n\n                if ( indel_length % period != 0 ) continue; // if indel sequence length is not a multiple of the period, it's not gonna work\n\n                int newIndex = indelIndexOnRef;\n\n                while ( newIndex >= period ) { // let's see if there is a repeat, i.e. if we could also say that same bases at lower position are deleted\n\n                    // lets check if bases [newIndex-period,newIndex) immediately preceding the indel on the ref\n                    // are the same as the currently checked period of the inserted sequence:\n\n                    boolean match = true;\n\n                    for ( int testRefPos = newIndex - period, indelPos = 0 ; testRefPos < newIndex; testRefPos++, indelPos++) {\n                        byte indelChr = indelString[indelPos];\n                        if ( refSeq[testRefPos] != indelChr || BaseUtils.simpleBaseToBaseIndex(indelChr) == -1 ) {\n                            match = false;\n                            break;\n                        }\n                    }\n                    if ( match )\n                        newIndex -= period; // yes, they are the same, we can move indel farther left by at least period bases, go check if we can do more...\n                    else break; // oops, no match, can not push indel farther left\n                }\n\n                final int newDifference = indelIndexOnRef - newIndex;\n                if ( newDifference > difference ) difference = newDifference; // deletion should be moved 'difference' bases left\n\n                if ( period == 1 ) break; // we do not have to check all periods of homonucleotide sequences, we already\n                                          // got maximum possible shift after checking period=1 above.\n        }\n\n        //        if ( ce2.getLength() >= 2 )\n        //            System.out.println(\"-----------------------------------\\n  FROM:\\n\"+AlignmentUtils.alignmentToString(cigar,readSeq,refSeq,refIndex, (readIsConsensusSequence?refIndex:0)));\n\n\n        if ( difference > 0 ) {\n\n            // The following if() statement: this should've never happened, unless the alignment is really screwed up.\n            // A real life example:\n            //\n            //   ref:    TTTTTTTTTTTTTTTTTT******TTTTTACTTATAGAAGAAAT...\n            //  read:       GTCTTTTTTTTTTTTTTTTTTTTTTTACTTATAGAAGAAAT...\n            //\n            //  i.e. the alignment claims 6 T's to be inserted. The alignment is clearly malformed/non-conforming since we could\n            // have just 3 T's inserted (so that the beginning of the read maps right onto the beginning of the\n            // reference fragment shown): that would leave us with same 2 mismatches at the beginning of the read\n            // (G and C) but lower gap penalty. Note that this has nothing to do with the alignment being \"right\" or \"wrong\"\n            // with respect to where on the DNA the read actually came from. It is the assumptions of *how* the alignments are\n            // built and represented that are broken here. While it is unclear how the alignment shown above could be generated\n            // in the first place, we are not in the business of fixing incorrect alignments in this method; all we are\n            // trying to do is to left-adjust correct ones. So if something like that happens, we refuse to change the cigar\n            // and bail out.\n            if ( ce1.getLength()-difference < 0 ) return cigar;\n\n            Cigar newCigar = new Cigar();\n            // do not add leading M cigar element if its length is zero (i.e. if we managed to left-shift the\n            // insertion all the way to the read start):\n            if ( ce1.getLength() - difference > 0 )\n                newCigar.add(new CigarElement(ce1.getLength()-difference, CigarOperator.M));\n            newCigar.add(ce2);  // add the indel, now it's left shifted since we decreased the number of preceding matching bases\n\n            if ( cigar.numCigarElements() > 2 ) {\n                // if we got something following the indel element:\n\n                if ( cigar.getCigarElement(2).getOperator() == CigarOperator.M  ) {\n                    // if indel was followed by matching bases (that's the most common situation),\n                    // increase the length of the matching section after the indel by the amount of left shift\n                    // (matching bases that were on the left are now *after* the indel; we have also checked at the beginning\n                    // that the first cigar element was also M):\n                    newCigar.add(new CigarElement(cigar.getCigarElement(2).getLength()+difference, CigarOperator.M));\n                } else {\n                    // if the element after the indel was not M, we have to add just the matching bases that were on the left\n                    // and now appear after the indel after we performed the shift. Then add the original element that followed the indel.\n                    newCigar.add(new CigarElement(difference, CigarOperator.M));\n                    newCigar.add(new CigarElement(cigar.getCigarElement(2).getLength(),cigar.getCigarElement(2).getOperator()));\n                }\n                // now add remaining (unchanged) cigar elements, if any:\n                for ( int i = 3 ; i < cigar.numCigarElements() ; i++ )  {\n                    newCigar.add(new CigarElement(cigar.getCigarElement(i).getLength(),cigar.getCigarElement(i).getOperator()));\n                }\n            }\n\n            //logger.debug(\"Realigning indel: \" + AlignmentUtils.cigarToString(cigar) + \" to \" + AlignmentUtils.cigarToString(newCigar));\n            cigar = newCigar;\n\n        }\n        return cigar;\n    }","commit_id":"1dd9996f3a2339a9a197cd5341d9b7d38fd879e9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private static int mismatchQualitySumIgnoreCigar(AlignedRead aRead, byte[] refSeq, int refIndex) {\n        byte[] readSeq = aRead.getRead().getReadBases();\n        byte[] quals = aRead.getRead().getBaseQualities();\n        int sum = 0;\n        for (int readIndex = 0 ; readIndex < readSeq.length ; refIndex++, readIndex++ ) {\n            if ( refIndex >= refSeq.length )\n                sum += MAX_QUAL;\n            else {\n                byte refChr = refSeq[refIndex];\n                byte readChr = readSeq[readIndex];\n                if ( BaseUtils.simpleBaseToBaseIndex(readChr) == -1 ||\n                     BaseUtils.simpleBaseToBaseIndex(refChr)  == -1 )\n                    continue; // do not count Ns/Xs/etc ?\n                if ( Character.toUpperCase(readChr) != Character.toUpperCase(refChr) )\n                    sum += (int)quals[readIndex];\n            }\n        }\n        return sum;\n    }","id":73029,"modified_method":"private static int mismatchQualitySumIgnoreCigar(AlignedRead aRead, byte[] refSeq, int refIndex) {\n        byte[] readSeq = aRead.getRead().getReadBases();\n        byte[] quals = aRead.getRead().getBaseQualities();\n        int sum = 0;\n        for (int readIndex = 0 ; readIndex < readSeq.length ; refIndex++, readIndex++ ) {\n            if ( refIndex >= refSeq.length )\n                sum += MAX_QUAL;\n            else {\n                byte refChr = refSeq[refIndex];\n                byte readChr = readSeq[readIndex];\n                if ( BaseUtils.simpleBaseToBaseIndex(readChr) == -1 ||\n                     BaseUtils.simpleBaseToBaseIndex(refChr)  == -1 )\n                    continue; // do not count Ns/Xs/etc ?\n                if ( readChr != refChr )\n                    sum += (int)quals[readIndex];\n            }\n        }\n        return sum;\n    }","commit_id":"1dd9996f3a2339a9a197cd5341d9b7d38fd879e9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Consensus createAlternateConsensus(int indexOnRef, Cigar c, byte[] reference, byte[] readStr) {\n        if ( indexOnRef < 0 )\n            return null;\n\n        // create the new consensus\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < indexOnRef; i++)\n            sb.append(reference[i]);        \n        //logger.debug(\"CIGAR = \" + AlignmentUtils.cigarToString(c));\n\n        int indelCount = 0;\n        int altIdx = 0;\n        int refIdx = indexOnRef;\n        boolean ok_flag = true;\n        for ( int i = 0 ; i < c.numCigarElements() ; i++ ) {\n            CigarElement ce = c.getCigarElement(i);\n            int elementLength = ce.getLength();\n            switch( ce.getOperator() ) {\n            case D:\n                indelCount++;\n                refIdx += elementLength;\n                break;\n            case M:\n                if ( reference.length < refIdx + elementLength )\n                    ok_flag = false;\n                else  {\n                    for (int j = 0; j < elementLength; j++)\n                        sb.append(reference[refIdx+j]);\n                }\n                refIdx += elementLength;\n                altIdx += elementLength;\n                break;\n            case I:\n                for (int j = 0; j < elementLength; j++)\n                    sb.append((char)readStr[altIdx + j]);\n                altIdx += elementLength;\n                indelCount++;\n                break;\n            }\n        }\n        // make sure that there is at most only a single indel and it aligns appropriately!\n        if ( !ok_flag || indelCount != 1 || reference.length < refIdx )\n            return null;\n\n        for (int i = refIdx; i < reference.length; i++)\n            sb.append(reference[i]);\n        byte[] altConsensus =  StringUtil.stringToBytes(sb.toString()); // alternative consensus sequence we just built from the cuurent read\n\n        // if ( debugOn ) System.out.println(\"Alt consensus generated: \"+altConsensus);\n\n        return new Consensus(altConsensus, c, indexOnRef);\n    }","id":73030,"modified_method":"private Consensus createAlternateConsensus(int indexOnRef, Cigar c, byte[] reference, byte[] readStr) {\n        if ( indexOnRef < 0 )\n            return null;\n\n        // create the new consensus\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < indexOnRef; i++)\n            sb.append((char)reference[i]);\n        //logger.debug(\"CIGAR = \" + AlignmentUtils.cigarToString(c));\n\n        int indelCount = 0;\n        int altIdx = 0;\n        int refIdx = indexOnRef;\n        boolean ok_flag = true;\n        for ( int i = 0 ; i < c.numCigarElements() ; i++ ) {\n            CigarElement ce = c.getCigarElement(i);\n            int elementLength = ce.getLength();\n            switch( ce.getOperator() ) {\n            case D:\n                indelCount++;\n                refIdx += elementLength;\n                break;\n            case M:\n                if ( reference.length < refIdx + elementLength )\n                    ok_flag = false;\n                else  {\n                    for (int j = 0; j < elementLength; j++)\n                        sb.append((char)reference[refIdx+j]);\n                }\n                refIdx += elementLength;\n                altIdx += elementLength;\n                break;\n            case I:\n                for (int j = 0; j < elementLength; j++)\n                    sb.append((char)readStr[altIdx + j]);\n                altIdx += elementLength;\n                indelCount++;\n                break;\n            }\n        }\n        // make sure that there is at most only a single indel and it aligns appropriately!\n        if ( !ok_flag || indelCount != 1 || reference.length < refIdx )\n            return null;\n\n        for (int i = refIdx; i < reference.length; i++)\n            sb.append((char)reference[i]);\n        byte[] altConsensus =  StringUtil.stringToBytes(sb.toString()); // alternative consensus sequence we just built from the cuurent read\n\n        // if ( debugOn ) System.out.println(\"Alt consensus generated: \"+altConsensus);\n\n        return new Consensus(altConsensus, c, indexOnRef);\n    }","commit_id":"1dd9996f3a2339a9a197cd5341d9b7d38fd879e9","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void clean(ReadBin readsToClean) {\n\n        List<SAMRecord> reads = readsToClean.getReads();\n        byte[] reference = readsToClean.getRereference();\n        long leftmostIndex = readsToClean.getLocation().getStart();\n\n        ArrayList<SAMRecord> refReads = new ArrayList<SAMRecord>();                   // reads that perfectly match ref\n        ArrayList<AlignedRead> altReads = new ArrayList<AlignedRead>();               // reads that don't perfectly match\n        LinkedList<AlignedRead> altAlignmentsToTest = new LinkedList<AlignedRead>();  // should we try to make an alt consensus from the read?\n        ArrayList<AlignedRead> leftMovedIndels = new ArrayList<AlignedRead>();\n        Set<Consensus> altConsenses = new LinkedHashSet<Consensus>();                   // list of alt consenses\n        int totalMismatchSum = 0;\n\n\n        // decide which reads potentially need to be cleaned\n        for ( SAMRecord read : reads ) {\n\n            //            if ( debugOn ) {\n            //                System.out.println(read.getReadName()+\" \"+read.getCigarString()+\" \"+read.getAlignmentStart()+\"-\"+read.getAlignmentEnd());\n            //                System.out.println(reference.substring((int)(read.getAlignmentStart()-leftmostIndex),(int)(read.getAlignmentEnd()-leftmostIndex)));\n            //                System.out.println(read.getReadString());\n            //            }\n\n            // we currently can not deal with clipped reads correctly (or screwy record)\n            if ( read.getCigar().numCigarElements() == 0 || readIsClipped(read) ) {\n                refReads.add(read);\n                continue;\n            }\n\n            AlignedRead aRead = new AlignedRead(read);\n\n            // first, move existing indels (for 1 indel reads only) to leftmost position within identical sequence\n            int numBlocks = AlignmentUtils.getNumAlignmentBlocks(read);\n            if ( numBlocks == 2 ) {\n                Cigar newCigar = indelRealignment(read.getCigar(), reference, read.getReadBases(), read.getAlignmentStart()-(int)leftmostIndex, 0);\n                if ( aRead.setCigar(newCigar) ) {\n                    leftMovedIndels.add(aRead);\n                }\n            }\n\n            int mismatchScore = mismatchQualitySumIgnoreCigar(aRead, reference, read.getAlignmentStart()-(int)leftmostIndex);\n            //            if ( debugOn ) System.out.println(\"mismatchScore=\"+mismatchScore);\n\n            // if this doesn't match perfectly to the reference, let's try to clean it\n            if ( mismatchScore > 0 ) {\n                altReads.add(aRead);\n                if ( !read.getDuplicateReadFlag() )\n                    totalMismatchSum += mismatchScore;\n                aRead.setMismatchScoreToReference(mismatchScore);\n                // if it has an indel, let's see if that's the best consensus\n                if ( numBlocks == 2 )  {\n                    Consensus c = createAlternateConsensus(aRead.getAlignmentStart() - (int)leftmostIndex, aRead.getCigar(), reference, aRead.getRead().getReadBases());\n                    if ( c==null) {} //System.out.println(\"ERROR: Failed to create alt consensus for read \"+aRead.getRead().getReadName());\n                    else altConsenses.add(c);\n                }\n                else {\n                    //                    if ( debugOn ) System.out.println(\"Going to test...\");\n                    altAlignmentsToTest.add(aRead);\n                }\n            }\n            // otherwise, we can emit it as is\n            else {\n                // if ( debugOn ) System.out.println(\"Emitting as is...\");\n                refReads.add(read);\n            }\n        }\n\n        // choose alternate consensuses\n        if ( altAlignmentsToTest.size() <= MAX_READS_FOR_CONSENSUSES ) {\n            for ( AlignedRead aRead : altAlignmentsToTest ) {\n                // do a pairwise alignment against the reference\n                SWPairwiseAlignment swConsensus = new SWPairwiseAlignment(reference, aRead.getRead().getReadBases(), SW_MATCH, SW_MISMATCH, SW_GAP, SW_GAP_EXTEND);\n                Consensus c = createAlternateConsensus(swConsensus.getAlignmentStart2wrt1(), swConsensus.getCigar(), reference, aRead.getRead().getReadBases());\n                if ( c != null) {\n                    //                    if ( debugOn ) System.out.println(\"NEW consensus generated by SW: \"+c.str ) ;\n                    altConsenses.add(c);\n                } else {\n                    //   if ( debugOn ) System.out.println(\"FAILED to create Alt consensus from SW\");\n                }\n            }\n        } else {\n            // choose alternate consenses randomly\n            int readsSeen = 0;\n            while ( readsSeen++ < MAX_READS_FOR_CONSENSUSES && altConsenses.size() <= MAX_CONSENSUSES) {\n                int index = generator.nextInt(altAlignmentsToTest.size());\n                AlignedRead aRead = altAlignmentsToTest.remove(index);\n                // do a pairwise alignment against the reference\n                SWPairwiseAlignment swConsensus = new SWPairwiseAlignment(reference, aRead.getRead().getReadBases(), SW_MATCH, SW_MISMATCH, SW_GAP, SW_GAP_EXTEND);\n                Consensus c = createAlternateConsensus(swConsensus.getAlignmentStart2wrt1(), swConsensus.getCigar(), reference, aRead.getRead().getReadBases());\n                if ( c != null)\n                    altConsenses.add(c);\n            }\n        }\n\n        Consensus bestConsensus = null;\n        Iterator<Consensus> iter = altConsenses.iterator();\n\n        // if ( debugOn ) System.out.println(\"------\\nChecking consenses...\\n--------\\n\");\n\n        while ( iter.hasNext() ) {\n            Consensus consensus = iter.next();\n\n            // if ( debugOn ) System.out.println(\"Consensus: \"+consensus.str);\n\n            for ( int j = 0; j < altReads.size(); j++ ) {\n                AlignedRead toTest = altReads.get(j);\n                Pair<Integer, Integer> altAlignment = findBestOffset(consensus.str, toTest);\n\n                // the mismatch score is the min of its alignment vs. the reference and vs. the alternate\n                int myScore = altAlignment.second;\n                if ( myScore >= toTest.getMismatchScoreToReference() )\n                    myScore = toTest.getMismatchScoreToReference();\n                // keep track of reads that align better to the alternate consensus.\n                // By pushing alignments with equal scores to the alternate, it means we'll over-call (het -> hom non ref) but are less likely to under-call (het -> ref, het non ref -> het)\n                else\n                    consensus.readIndexes.add(new Pair<Integer, Integer>(j, altAlignment.first));\n\n                //logger.debug(consensus.str +  \" vs. \" + toTest.getRead().getReadString() + \" => \" + myScore + \" - \" + altAlignment.first);\n                if ( !toTest.getRead().getDuplicateReadFlag() )\n                    consensus.mismatchSum += myScore;\n            }\n\n            //logger.debug(consensus.str +  \" \" + consensus.mismatchSum);\n            if ( bestConsensus == null || bestConsensus.mismatchSum > consensus.mismatchSum) {\n                bestConsensus = consensus;\n                //logger.debug(consensus.str +  \" \" + consensus.mismatchSum);\n            }\n        }\n\n        // if the best alternate consensus has a smaller sum of quality score mismatches (more than\n        // the LOD threshold), and it didn't just move around the mismatching columns, then clean!\n        double improvement = (bestConsensus == null ? -1 : ((double)(totalMismatchSum - bestConsensus.mismatchSum))/10.0);\n        if ( improvement >= LOD_THRESHOLD ) {\n\n            bestConsensus.cigar = indelRealignment(bestConsensus.cigar, reference, bestConsensus.str, bestConsensus.positionOnReference, bestConsensus.positionOnReference);\n\n           // start cleaning the appropriate reads\n            for ( Pair<Integer, Integer> indexPair : bestConsensus.readIndexes ) {\n                AlignedRead aRead = altReads.get(indexPair.first);\n                updateRead(bestConsensus.cigar, bestConsensus.positionOnReference, indexPair.second, aRead, (int)leftmostIndex);\n            }\n            if ( !alternateReducesEntropy(altReads, reference, leftmostIndex) ) {\n                if ( statsOutput != null ) {\n                    try {\n                        statsOutput.write(readsToClean.getLocation().toString());\n                        statsOutput.write(\"\\tFAIL (bad indel)\\t\"); // if improvement > LOD_THRESHOLD *BUT* entropy is not reduced (SNPs still exist)\n                        statsOutput.write(Double.toString(improvement));\n                        statsOutput.write(\"\\n\");\n                        statsOutput.flush();\n                    } catch (Exception e) {}\n                }\n            } else {\n                //logger.debug(\"CLEAN: \" + AlignmentUtils.cigarToString(bestConsensus.cigar) + \" \" + bestConsensus.str );\n                if ( indelOutput != null && bestConsensus.cigar.numCigarElements() > 1 ) {\n                    // NOTE: indels are printed out in the format specified for the low-coverage pilot1\n                    //  indel calls (tab-delimited): chr position size type sequence\n                    StringBuilder str = new StringBuilder();\n                    str.append(reads.get(0).getReferenceName());\n                    int position = bestConsensus.positionOnReference + bestConsensus.cigar.getCigarElement(0).getLength();\n                    str.append(\"\\t\" + (leftmostIndex + position - 1));\n                    CigarElement ce = bestConsensus.cigar.getCigarElement(1);\n                    str.append(\"\\t\" + ce.getLength() + \"\\t\" + ce.getOperator() + \"\\t\");\n                    int length = ce.getLength();\n                    if ( ce.getOperator() == CigarOperator.D ) {\n                        for ( int i = 0; i < length; i++)\n                            str.append(reference[position+i]);\n                    } else {\n                        for ( int i = 0; i < length; i++)\n                            str.append(bestConsensus.str[position+i]);\n                    }\n                    str.append(\"\\t\" + (((double)(totalMismatchSum - bestConsensus.mismatchSum))/10.0) + \"\\n\");\n                    try {\n                        indelOutput.write(str.toString());\n                        indelOutput.flush();\n                    } catch (Exception e) {}\n                }\n                if ( statsOutput != null ) {\n                    try {\n                        statsOutput.write(readsToClean.getLocation().toString());\n                        statsOutput.write(\"\\tCLEAN\"); // if improvement > LOD_THRESHOLD *AND* entropy is reduced\n                        if ( bestConsensus.cigar.numCigarElements() > 1 )\n                            statsOutput.write(\" (found indel)\");\n                        statsOutput.write(\"\\t\");\n                        statsOutput.write(Double.toString(improvement));\n                        statsOutput.write(\"\\n\");\n                        statsOutput.flush();\n                    } catch (Exception e) {}\n                }\n\n                // We need to update the mapping quality score of the cleaned reads;\n                // however we don't have enough info to use the proper MAQ scoring system.\n                // For now, we'll use a heuristic:\n                // the mapping quality score is improved by the LOD difference in mismatching\n                // bases between the reference and alternate consensus (divided by 10)\n\n                // finish cleaning the appropriate reads\n                for ( Pair<Integer, Integer> indexPair : bestConsensus.readIndexes ) {\n                    AlignedRead aRead = altReads.get(indexPair.first);\n                    if ( aRead.finalizeUpdate() ) {\n                        aRead.getRead().setMappingQuality(Math.min(aRead.getRead().getMappingQuality() + (int)(improvement/10.0), 255));\n                        aRead.getRead().setAttribute(\"NM\", AlignmentUtils.numMismatches(aRead.getRead(), reference, aRead.getRead().getAlignmentStart()-(int)leftmostIndex));\n                    }\n                }\n            }\n\n            // END IF ( improvement >= LOD_THRESHOLD )\n\n        } else if ( statsOutput != null ) {\n            try {\n                statsOutput.write(readsToClean.getLocation().toString());\n                statsOutput.write(\"\\tFAIL\\t\"); // if improvement < LOD_THRESHOLD\n                statsOutput.write(Double.toString(improvement));\n                statsOutput.write(\"\\n\");\n                statsOutput.flush();\n            } catch (Exception e) {}\n        }\n    }","id":73031,"modified_method":"private void clean(ReadBin readsToClean) {\n\n        List<SAMRecord> reads = readsToClean.getReads();\n        if ( reads.size() == 0 )\n            return;\n\n        byte[] reference = readsToClean.getRereference();\n        long leftmostIndex = readsToClean.getLocation().getStart();\n\n        ArrayList<SAMRecord> refReads = new ArrayList<SAMRecord>();                   // reads that perfectly match ref\n        ArrayList<AlignedRead> altReads = new ArrayList<AlignedRead>();               // reads that don't perfectly match\n        LinkedList<AlignedRead> altAlignmentsToTest = new LinkedList<AlignedRead>();  // should we try to make an alt consensus from the read?\n        ArrayList<AlignedRead> leftMovedIndels = new ArrayList<AlignedRead>();\n        Set<Consensus> altConsenses = new LinkedHashSet<Consensus>();                   // list of alt consenses\n        int totalMismatchSum = 0;\n\n\n        // decide which reads potentially need to be cleaned\n        for ( SAMRecord read : reads ) {\n\n            //            if ( debugOn ) {\n            //                System.out.println(read.getReadName()+\" \"+read.getCigarString()+\" \"+read.getAlignmentStart()+\"-\"+read.getAlignmentEnd());\n            //                System.out.println(reference.substring((int)(read.getAlignmentStart()-leftmostIndex),(int)(read.getAlignmentEnd()-leftmostIndex)));\n            //                System.out.println(read.getReadString());\n            //            }\n\n            // we currently can not deal with clipped reads correctly (or screwy record)\n            if ( read.getCigar().numCigarElements() == 0 || readIsClipped(read) ) {\n                refReads.add(read);\n                continue;\n            }\n\n            AlignedRead aRead = new AlignedRead(read);\n\n            // first, move existing indels (for 1 indel reads only) to leftmost position within identical sequence\n            int numBlocks = AlignmentUtils.getNumAlignmentBlocks(read);\n            if ( numBlocks == 2 ) {\n                Cigar newCigar = indelRealignment(read.getCigar(), reference, read.getReadBases(), read.getAlignmentStart()-(int)leftmostIndex, 0);\n                if ( aRead.setCigar(newCigar) ) {\n                    leftMovedIndels.add(aRead);\n                }\n            }\n\n            int mismatchScore = mismatchQualitySumIgnoreCigar(aRead, reference, read.getAlignmentStart()-(int)leftmostIndex);\n            //            if ( debugOn ) System.out.println(\"mismatchScore=\"+mismatchScore);\n\n            // if this doesn't match perfectly to the reference, let's try to clean it\n            if ( mismatchScore > 0 ) {\n                altReads.add(aRead);\n                if ( !read.getDuplicateReadFlag() )\n                    totalMismatchSum += mismatchScore;\n                aRead.setMismatchScoreToReference(mismatchScore);\n                // if it has an indel, let's see if that's the best consensus\n                if ( numBlocks == 2 )  {\n                    Consensus c = createAlternateConsensus(aRead.getAlignmentStart() - (int)leftmostIndex, aRead.getCigar(), reference, aRead.getRead().getReadBases());\n                    if ( c==null) {} //System.out.println(\"ERROR: Failed to create alt consensus for read \"+aRead.getRead().getReadName());\n                    else altConsenses.add(c);\n                }\n                else {\n                    //                    if ( debugOn ) System.out.println(\"Going to test...\");\n                    altAlignmentsToTest.add(aRead);\n                }\n            }\n            // otherwise, we can emit it as is\n            else {\n                // if ( debugOn ) System.out.println(\"Emitting as is...\");\n                refReads.add(read);\n            }\n        }\n\n        // choose alternate consensuses\n        if ( altAlignmentsToTest.size() <= MAX_READS_FOR_CONSENSUSES ) {\n            for ( AlignedRead aRead : altAlignmentsToTest ) {\n                // do a pairwise alignment against the reference\n                SWPairwiseAlignment swConsensus = new SWPairwiseAlignment(reference, aRead.getRead().getReadBases(), SW_MATCH, SW_MISMATCH, SW_GAP, SW_GAP_EXTEND);\n                Consensus c = createAlternateConsensus(swConsensus.getAlignmentStart2wrt1(), swConsensus.getCigar(), reference, aRead.getRead().getReadBases());\n                if ( c != null) {\n                    //                    if ( debugOn ) System.out.println(\"NEW consensus generated by SW: \"+c.str ) ;\n                    altConsenses.add(c);\n                } else {\n                    //   if ( debugOn ) System.out.println(\"FAILED to create Alt consensus from SW\");\n                }\n            }\n        } else {\n            // choose alternate consenses randomly\n            int readsSeen = 0;\n            while ( readsSeen++ < MAX_READS_FOR_CONSENSUSES && altConsenses.size() <= MAX_CONSENSUSES) {\n                int index = generator.nextInt(altAlignmentsToTest.size());\n                AlignedRead aRead = altAlignmentsToTest.remove(index);\n                // do a pairwise alignment against the reference\n                SWPairwiseAlignment swConsensus = new SWPairwiseAlignment(reference, aRead.getRead().getReadBases(), SW_MATCH, SW_MISMATCH, SW_GAP, SW_GAP_EXTEND);\n                Consensus c = createAlternateConsensus(swConsensus.getAlignmentStart2wrt1(), swConsensus.getCigar(), reference, aRead.getRead().getReadBases());\n                if ( c != null)\n                    altConsenses.add(c);\n            }\n        }\n\n        Consensus bestConsensus = null;\n        Iterator<Consensus> iter = altConsenses.iterator();\n\n        // if ( debugOn ) System.out.println(\"------\\nChecking consenses...\\n--------\\n\");\n\n        while ( iter.hasNext() ) {\n            Consensus consensus = iter.next();\n\n            // if ( debugOn ) System.out.println(\"Consensus: \"+consensus.str);\n\n            for ( int j = 0; j < altReads.size(); j++ ) {\n                AlignedRead toTest = altReads.get(j);\n                Pair<Integer, Integer> altAlignment = findBestOffset(consensus.str, toTest);\n\n                // the mismatch score is the min of its alignment vs. the reference and vs. the alternate\n                int myScore = altAlignment.second;\n                if ( myScore >= toTest.getMismatchScoreToReference() )\n                    myScore = toTest.getMismatchScoreToReference();\n                // keep track of reads that align better to the alternate consensus.\n                // By pushing alignments with equal scores to the alternate, it means we'll over-call (het -> hom non ref) but are less likely to under-call (het -> ref, het non ref -> het)\n                else\n                    consensus.readIndexes.add(new Pair<Integer, Integer>(j, altAlignment.first));\n\n                //logger.debug(consensus.str +  \" vs. \" + toTest.getRead().getReadString() + \" => \" + myScore + \" - \" + altAlignment.first);\n                if ( !toTest.getRead().getDuplicateReadFlag() )\n                    consensus.mismatchSum += myScore;\n            }\n\n            //logger.debug(consensus.str +  \" \" + consensus.mismatchSum);\n            if ( bestConsensus == null || bestConsensus.mismatchSum > consensus.mismatchSum) {\n                bestConsensus = consensus;\n                //logger.debug(consensus.str +  \" \" + consensus.mismatchSum);\n            }\n        }\n\n        // if the best alternate consensus has a smaller sum of quality score mismatches (more than\n        // the LOD threshold), and it didn't just move around the mismatching columns, then clean!\n        double improvement = (bestConsensus == null ? -1 : ((double)(totalMismatchSum - bestConsensus.mismatchSum))/10.0);\n        if ( improvement >= LOD_THRESHOLD ) {\n\n            bestConsensus.cigar = indelRealignment(bestConsensus.cigar, reference, bestConsensus.str, bestConsensus.positionOnReference, bestConsensus.positionOnReference);\n\n           // start cleaning the appropriate reads\n            for ( Pair<Integer, Integer> indexPair : bestConsensus.readIndexes ) {\n                AlignedRead aRead = altReads.get(indexPair.first);\n                updateRead(bestConsensus.cigar, bestConsensus.positionOnReference, indexPair.second, aRead, (int)leftmostIndex);\n            }\n            if ( !alternateReducesEntropy(altReads, reference, leftmostIndex) ) {\n                if ( statsOutput != null ) {\n                    try {\n                        statsOutput.write(readsToClean.getLocation().toString());\n                        statsOutput.write(\"\\tFAIL (bad indel)\\t\"); // if improvement > LOD_THRESHOLD *BUT* entropy is not reduced (SNPs still exist)\n                        statsOutput.write(Double.toString(improvement));\n                        statsOutput.write(\"\\n\");\n                        statsOutput.flush();\n                    } catch (Exception e) {}\n                }\n            } else {\n                //logger.debug(\"CLEAN: \" + AlignmentUtils.cigarToString(bestConsensus.cigar) + \" \" + bestConsensus.str );\n                if ( indelOutput != null && bestConsensus.cigar.numCigarElements() > 1 ) {\n                    // NOTE: indels are printed out in the format specified for the low-coverage pilot1\n                    //  indel calls (tab-delimited): chr position size type sequence\n                    StringBuilder str = new StringBuilder();\n                    str.append(reads.get(0).getReferenceName());\n                    int position = bestConsensus.positionOnReference + bestConsensus.cigar.getCigarElement(0).getLength();\n                    str.append(\"\\t\" + (leftmostIndex + position - 1));\n                    CigarElement ce = bestConsensus.cigar.getCigarElement(1);\n                    str.append(\"\\t\" + ce.getLength() + \"\\t\" + ce.getOperator() + \"\\t\");\n                    int length = ce.getLength();\n                    if ( ce.getOperator() == CigarOperator.D ) {\n                        for ( int i = 0; i < length; i++)\n                            str.append((char)reference[position+i]);\n                    } else {\n                        for ( int i = 0; i < length; i++)\n                            str.append((char)bestConsensus.str[position+i]);\n                    }\n                    str.append(\"\\t\" + (((double)(totalMismatchSum - bestConsensus.mismatchSum))/10.0) + \"\\n\");\n                    try {\n                        indelOutput.write(str.toString());\n                        indelOutput.flush();\n                    } catch (Exception e) {}\n                }\n                if ( statsOutput != null ) {\n                    try {\n                        statsOutput.write(readsToClean.getLocation().toString());\n                        statsOutput.write(\"\\tCLEAN\"); // if improvement > LOD_THRESHOLD *AND* entropy is reduced\n                        if ( bestConsensus.cigar.numCigarElements() > 1 )\n                            statsOutput.write(\" (found indel)\");\n                        statsOutput.write(\"\\t\");\n                        statsOutput.write(Double.toString(improvement));\n                        statsOutput.write(\"\\n\");\n                        statsOutput.flush();\n                    } catch (Exception e) {}\n                }\n\n                // We need to update the mapping quality score of the cleaned reads;\n                // however we don't have enough info to use the proper MAQ scoring system.\n                // For now, we'll use a heuristic:\n                // the mapping quality score is improved by the LOD difference in mismatching\n                // bases between the reference and alternate consensus (divided by 10)\n\n                // finish cleaning the appropriate reads\n                for ( Pair<Integer, Integer> indexPair : bestConsensus.readIndexes ) {\n                    AlignedRead aRead = altReads.get(indexPair.first);\n                    if ( aRead.finalizeUpdate() ) {\n                        aRead.getRead().setMappingQuality(Math.min(aRead.getRead().getMappingQuality() + (int)(improvement/10.0), 255));\n                        aRead.getRead().setAttribute(\"NM\", AlignmentUtils.numMismatches(aRead.getRead(), reference, aRead.getRead().getAlignmentStart()-(int)leftmostIndex));\n                    }\n                }\n            }\n\n            // END IF ( improvement >= LOD_THRESHOLD )\n\n        } else if ( statsOutput != null ) {\n            try {\n                statsOutput.write(readsToClean.getLocation().toString());\n                statsOutput.write(\"\\tFAIL\\t\"); // if improvement < LOD_THRESHOLD\n                statsOutput.write(Double.toString(improvement));\n                statsOutput.write(\"\\n\");\n                statsOutput.flush();\n            } catch (Exception e) {}\n        }\n    }","commit_id":"1dd9996f3a2339a9a197cd5341d9b7d38fd879e9","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize() {\n\n        if ( LOD_THRESHOLD < 0.0 )\n            throw new RuntimeException(\"LOD threshold cannot be a negative number\");\n        if ( MISMATCH_THRESHOLD <= 0.0 || MISMATCH_THRESHOLD > 1.0 )\n            throw new RuntimeException(\"Entropy threshold must be a fraction between 0 and 1\");\n\n        List<GenomeLoc> locs = GenomeAnalysisEngine.parseIntervalRegion(Arrays.asList(intervalsFile));\n        intervals = GenomeLocSortedSet.createSetFromList(locs).iterator();\n        currentInterval = intervals.hasNext() ? intervals.next() : null;\n\n        if ( baseWriter != null )\n            writer = new SortingSAMFileWriter(baseWriter, 50);\n\n        generator = new Random(RANDOM_SEED);\n\n        if ( OUT_INDELS != null ) {\n            try {\n                indelOutput = new FileWriter(new File(OUT_INDELS));\n            } catch (Exception e) {\n                logger.warn(\"Failed to create output file \"+ OUT_INDELS+\". Indel output will be suppressed\");\n                err.println(e.getMessage());\n                indelOutput = null;\n            }\n        }\n        if ( OUT_STATS != null ) {\n            try {\n                statsOutput = new FileWriter(new File(OUT_STATS));\n            } catch (Exception e) {\n                logger.warn(\"Failed to create output file \"+ OUT_STATS+\". Cleaning stats output will be suppressed\");\n                err.println(e.getMessage());\n                statsOutput = null;\n            }\n        }\n        if ( OUT_SNPS != null ) {\n            try {\n                snpsOutput = new FileWriter(new File(OUT_SNPS));\n            } catch (Exception e) {\n                logger.warn(\"Failed to create output file \"+ OUT_SNPS+\". Cleaning snps output will be suppressed\");\n                err.println(e.getMessage());\n                snpsOutput = null;\n            }\n        }\n    }","id":73032,"modified_method":"public void initialize() {\n\n        if ( LOD_THRESHOLD < 0.0 )\n            throw new RuntimeException(\"LOD threshold cannot be a negative number\");\n        if ( MISMATCH_THRESHOLD <= 0.0 || MISMATCH_THRESHOLD > 1.0 )\n            throw new RuntimeException(\"Entropy threshold must be a fraction between 0 and 1\");\n\n        List<GenomeLoc> locs = GenomeAnalysisEngine.parseIntervalRegion(Arrays.asList(intervalsFile));\n        intervals = GenomeLocSortedSet.createSetFromList(locs).iterator();\n        currentInterval = intervals.hasNext() ? intervals.next() : null;\n\n        if ( baseWriter != null )\n            writer = new SortingSAMFileWriter(baseWriter, SORTING_WRITER_WINDOW);\n\n        generator = new Random(RANDOM_SEED);\n\n        if ( OUT_INDELS != null ) {\n            try {\n                indelOutput = new FileWriter(new File(OUT_INDELS));\n            } catch (Exception e) {\n                logger.warn(\"Failed to create output file \"+ OUT_INDELS+\". Indel output will be suppressed\");\n                err.println(e.getMessage());\n                indelOutput = null;\n            }\n        }\n        if ( OUT_STATS != null ) {\n            try {\n                statsOutput = new FileWriter(new File(OUT_STATS));\n            } catch (Exception e) {\n                logger.warn(\"Failed to create output file \"+ OUT_STATS+\". Cleaning stats output will be suppressed\");\n                err.println(e.getMessage());\n                statsOutput = null;\n            }\n        }\n        if ( OUT_SNPS != null ) {\n            try {\n                snpsOutput = new FileWriter(new File(OUT_SNPS));\n            } catch (Exception e) {\n                logger.warn(\"Failed to create output file \"+ OUT_SNPS+\". Cleaning snps output will be suppressed\");\n                err.println(e.getMessage());\n                snpsOutput = null;\n            }\n        }\n    }","commit_id":"1dd9996f3a2339a9a197cd5341d9b7d38fd879e9","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** Takes the alignment of the read sequence <code>readSeq<\/code> to the reference sequence <code>refSeq<\/code>\n     * starting at 0-based position <code>refIndex<\/code> on the <code>refSeq<\/code> and specified by its <code>cigar<\/code>.\n     * The last argument <code>readIndex<\/code> specifies 0-based position on the read where the alignment described by the \n     * <code>cigar<\/code> starts. Usually cigars specify alignments of the whole read to the ref, so that readIndex is normally 0.\n     * Use non-zero readIndex only when the alignment cigar represents alignment of a part of the read. The refIndex in this case\n     * should be the position where the alignment of that part of the read starts at. In other words, both refIndex and readIndex are\n     * always the positions where the cigar starts on the ref and on the read, respectively.\n     *\n     * If the alignment has an indel, then this method attempts moving this indel left across a stretch of repetitive bases. For instance, if the original cigar\n     * specifies that (any) one AT  is deleted from a repeat sequence TATATATA, the output cigar will always mark the leftmost AT\n     * as deleted. If there is no indel in the original cigar, or the indel position is determined unambiguously (i.e. inserted/deleted sequence\n     * is not repeated), the original cigar is returned. \n     * @param cigar structure of the original alignment\n     * @param refSeq reference sequence the read is aligned to\n     * @param readSeq read sequence\n     * @param refIndex 0-based alignment start position on ref\n     * @param readIndex 0-based alignment start position on read\n     * @return a cigar, in which indel is guaranteed to be placed at the leftmost possible position across a repeat (if any)\n     */\n    private Cigar indelRealignment(Cigar cigar, String refSeq, String readSeq, int refIndex, int readIndex) {\n        if ( cigar.numCigarElements() < 2 ) return cigar; // no indels, nothing to do\n        \n        CigarElement ce1 = cigar.getCigarElement(0);\n        CigarElement ce2 = cigar.getCigarElement(1);\n\n        // we currently can not handle clipped reads; alternatively, if the alignment starts from insertion, there\n        // is no place on the read to move that insertion further left; so we are done:\n        if ( ce1.getOperator() != CigarOperator.M ) return cigar;\n\n        int difference = 0; // we can move indel 'difference' bases left\n        final int indel_length = ce2.getLength();\n\n        String indelString; // inserted or deleted sequence\n        int period = 0; // period of the inserted/deleted sequence\n        int indelIndexOnRef = refIndex+ce1.getLength() ; // position of the indel on the REF (first deleted base or first base after insertion)\n        int indelIndexOnRead = readIndex+ce1.getLength(); // position of the indel on the READ (first insterted base, of first base after deletion)\n\n        if ( ce2.getOperator() == CigarOperator.D )\n            indelString = refSeq.substring(indelIndexOnRef, indelIndexOnRef+ce2.getLength()).toUpperCase(); // deleted bases\n        else if ( ce2.getOperator() == CigarOperator.I )\n            indelString = readSeq.substring(indelIndexOnRead, indelIndexOnRead+ce2.getLength()).toUpperCase(); // get the inserted bases\n        else\n            // we can get here if there is soft clipping done at the beginning of the read\n            // for now, we'll just punt the issue and not try to realign these\n            return cigar;\n\n        // now we have to check all WHOLE periods of the indel sequence:\n        //  for instance, if \n        //   REF:   AGCTATATATAGCC\n        //   READ:   GCTAT***TAGCC\n        // the deleted sequence ATA does have period of 2, but deletion obviously can not be\n        // shifted left by 2 bases (length 3 does not contain whole number of periods of 2);\n        // however if 4 bases are deleted:\n        //   REF:   AGCTATATATAGCC\n        //   READ:   GCTA****TAGCC\n        // the length 4 is a multiple of the period of 2, and indeed deletion site can be moved left by 2 bases! \n        //  Also, we will always have to check the length of the indel sequence itself (trivial period). If the smallest\n        // period is 1 (which means that indel sequence is a homo-nucleotide sequence), we obviously do not have to check\n        // any other periods.\n\n        // NOTE: we treat both insertions and deletions in the same way below: we always check if the indel sequence\n        // repeats itsels on the REF (never on the read!), even for insertions: if we see TA inserted and REF has, e.g., CATATA prior to the insertion\n        // position, we will move insertion left, to the position right after CA. This way, while moving the indel across the repeat\n        // on the ref, we can theoretically move it across a non-repeat on the read if the latter has a mismtach.\n\n        while ( period < indel_length ) { // we will always get at least trivial period = indelStringLength\n                \n                period = BaseUtils.sequencePeriod(indelString, period+1);\n\n                if ( indel_length % period != 0 ) continue; // if indel sequence length is not a multiple of the period, it's not gonna work\n\n                int newIndex = indelIndexOnRef;\n\n                while ( newIndex >= period ) { // let's see if there is a repeat, i.e. if we could also say that same bases at lower position are deleted\n\n                    // lets check if bases [newIndex-period,newIndex) immediately preceding the indel on the ref\n                    // are the same as the currently checked period of the inserted sequence:\n                \n                    boolean match = true;\n                \n                    for ( int testRefPos = newIndex - period, indelPos = 0 ; testRefPos < newIndex; testRefPos++, indelPos++) {\n                        char indelChr = indelString.charAt(indelPos);\n                        if ( Character.toUpperCase(refSeq.charAt(testRefPos)) != indelChr || BaseUtils.simpleBaseToBaseIndex(indelChr) == -1 ) {\n                            match = false;\n                            break;\n                        }\n                    }\n                    if ( match )\n                        newIndex -= period; // yes, they are the same, we can move indel farther left by at least period bases, go check if we can do more...\n                    else break; // oops, no match, can not push indel farther left\n                }\n            \n                final int newDifference = indelIndexOnRef - newIndex;\n                if ( newDifference > difference ) difference = newDifference; // deletion should be moved 'difference' bases left\n            \n                if ( period == 1 ) break; // we do not have to check all periods of homonucleotide sequences, we already\n                                          // got maximum possible shift after checking period=1 above.\n        }\n        \n        //        if ( ce2.getLength() >= 2 )\n        //            System.out.println(\"-----------------------------------\\n  FROM:\\n\"+AlignmentUtils.alignmentToString(cigar,readSeq,refSeq,refIndex, (readIsConsensusSequence?refIndex:0)));\n\n                        \n        if ( difference > 0 ) {\n\n            // The following if() statement: this should've never happened, unless the alignment is really screwed up.\n            // A real life example:\n            //\n            //   ref:    TTTTTTTTTTTTTTTTTT******TTTTTACTTATAGAAGAAAT...\n            //  read:       GTCTTTTTTTTTTTTTTTTTTTTTTTACTTATAGAAGAAAT...\n            //\n            //  i.e. the alignment claims 6 T's to be inserted. The alignment is clearly malformed/non-conforming since we could\n            // have just 3 T's inserted (so that the beginning of the read maps right onto the beginning of the\n            // reference fragment shown): that would leave us with same 2 mismatches at the beginning of the read\n            // (G and C) but lower gap penalty. Note that this has nothing to do with the alignment being \"right\" or \"wrong\"\n            // with respect to where on the DNA the read actually came from. It is the assumptions of *how* the alignments are\n            // built and represented that are broken here. While it is unclear how the alignment shown above could be generated\n            // in the first place, we are not in the business of fixing incorrect alignments in this method; all we are\n            // trying to do is to left-adjust correct ones. So if something like that happens, we refuse to change the cigar\n            // and bail out.\n            if ( ce1.getLength()-difference < 0 ) return cigar;\n\n            Cigar newCigar = new Cigar();\n            // do not add leading M cigar element if its length is zero (i.e. if we managed to left-shift the\n            // insertion all the way to the read start):\n            if ( ce1.getLength() - difference > 0 )\n                newCigar.add(new CigarElement(ce1.getLength()-difference, CigarOperator.M));\n            newCigar.add(ce2);  // add the indel, now it's left shifted since we decreased the number of preceding matching bases\n\n            if ( cigar.numCigarElements() > 2 ) {\n                // if we got something following the indel element:\n\n                if ( cigar.getCigarElement(2).getOperator() == CigarOperator.M  ) {\n                    // if indel was followed by matching bases (that's the most common situation),\n                    // increase the length of the matching section after the indel by the amount of left shift\n                    // (matching bases that were on the left are now *after* the indel; we have also checked at the beginning\n                    // that the first cigar element was also M):\n                    newCigar.add(new CigarElement(cigar.getCigarElement(2).getLength()+difference, CigarOperator.M));\n                } else {\n                    // if the element after the indel was not M, we have to add just the matching bases that were on the left\n                    // and now appear after the indel after we performed the shift. Then add the original element that followed the indel.\n                    newCigar.add(new CigarElement(difference, CigarOperator.M));\n                    newCigar.add(new CigarElement(cigar.getCigarElement(2).getLength(),cigar.getCigarElement(2).getOperator()));\n                }\n                // now add remaining (unchanged) cigar elements, if any:\n                for ( int i = 3 ; i < cigar.numCigarElements() ; i++ )  {\n                    newCigar.add(new CigarElement(cigar.getCigarElement(i).getLength(),cigar.getCigarElement(i).getOperator()));                    \n                }\n            }\n\n            //logger.debug(\"Realigning indel: \" + AlignmentUtils.cigarToString(cigar) + \" to \" + AlignmentUtils.cigarToString(newCigar));\n            cigar = newCigar;\n\n        }\n        return cigar;\n    }","id":73033,"modified_method":"/** Takes the alignment of the read sequence <code>readSeq<\/code> to the reference sequence <code>refSeq<\/code>\n     * starting at 0-based position <code>refIndex<\/code> on the <code>refSeq<\/code> and specified by its <code>cigar<\/code>.\n     * The last argument <code>readIndex<\/code> specifies 0-based position on the read where the alignment described by the \n     * <code>cigar<\/code> starts. Usually cigars specify alignments of the whole read to the ref, so that readIndex is normally 0.\n     * Use non-zero readIndex only when the alignment cigar represents alignment of a part of the read. The refIndex in this case\n     * should be the position where the alignment of that part of the read starts at. In other words, both refIndex and readIndex are\n     * always the positions where the cigar starts on the ref and on the read, respectively.\n     *\n     * If the alignment has an indel, then this method attempts moving this indel left across a stretch of repetitive bases. For instance, if the original cigar\n     * specifies that (any) one AT  is deleted from a repeat sequence TATATATA, the output cigar will always mark the leftmost AT\n     * as deleted. If there is no indel in the original cigar, or the indel position is determined unambiguously (i.e. inserted/deleted sequence\n     * is not repeated), the original cigar is returned. \n     * @param cigar structure of the original alignment\n     * @param refSeq reference sequence the read is aligned to\n     * @param readSeq read sequence\n     * @param refIndex 0-based alignment start position on ref\n     * @param readIndex 0-based alignment start position on read\n     * @return a cigar, in which indel is guaranteed to be placed at the leftmost possible position across a repeat (if any)\n     */\n    private Cigar indelRealignment(Cigar cigar, String refSeq, String readSeq, int refIndex, int readIndex) {\n        if ( cigar.numCigarElements() < 2 ) return cigar; // no indels, nothing to do\n        \n        CigarElement ce1 = cigar.getCigarElement(0);\n        CigarElement ce2 = cigar.getCigarElement(1);\n\n        // we currently can not handle clipped reads; alternatively, if the alignment starts from insertion, there\n        // is no place on the read to move that insertion further left; so we are done:\n        if ( ce1.getOperator() != CigarOperator.M ) return cigar;\n\n        int difference = 0; // we can move indel 'difference' bases left\n        final int indel_length = ce2.getLength();\n\n        String indelString; // inserted or deleted sequence\n        int period = 0; // period of the inserted/deleted sequence\n        int indelIndexOnRef = refIndex+ce1.getLength() ; // position of the indel on the REF (first deleted base or first base after insertion)\n        int indelIndexOnRead = readIndex+ce1.getLength(); // position of the indel on the READ (first insterted base, of first base after deletion)\n\n        if ( ce2.getOperator() == CigarOperator.D )\n            indelString = refSeq.substring(indelIndexOnRef, indelIndexOnRef+ce2.getLength()).toUpperCase(); // deleted bases\n        else if ( ce2.getOperator() == CigarOperator.I )\n            indelString = readSeq.substring(indelIndexOnRead, indelIndexOnRead+ce2.getLength()).toUpperCase(); // get the inserted bases\n        else\n            // we can get here if there is soft clipping done at the beginning of the read\n            // for now, we'll just punt the issue and not try to realign these\n            return cigar;\n\n        // now we have to check all WHOLE periods of the indel sequence:\n        //  for instance, if \n        //   REF:   AGCTATATATAGCC\n        //   READ:   GCTAT***TAGCC\n        // the deleted sequence ATA does have period of 2, but deletion obviously can not be\n        // shifted left by 2 bases (length 3 does not contain whole number of periods of 2);\n        // however if 4 bases are deleted:\n        //   REF:   AGCTATATATAGCC\n        //   READ:   GCTA****TAGCC\n        // the length 4 is a multiple of the period of 2, and indeed deletion site can be moved left by 2 bases! \n        //  Also, we will always have to check the length of the indel sequence itself (trivial period). If the smallest\n        // period is 1 (which means that indel sequence is a homo-nucleotide sequence), we obviously do not have to check\n        // any other periods.\n\n        // NOTE: we treat both insertions and deletions in the same way below: we always check if the indel sequence\n        // repeats itsels on the REF (never on the read!), even for insertions: if we see TA inserted and REF has, e.g., CATATA prior to the insertion\n        // position, we will move insertion left, to the position right after CA. This way, while moving the indel across the repeat\n        // on the ref, we can theoretically move it across a non-repeat on the read if the latter has a mismtach.\n\n        while ( period < indel_length ) { // we will always get at least trivial period = indelStringLength\n                \n                period = BaseUtils.sequencePeriod(StringUtil.stringToBytes(indelString), period+1);\n\n                if ( indel_length % period != 0 ) continue; // if indel sequence length is not a multiple of the period, it's not gonna work\n\n                int newIndex = indelIndexOnRef;\n\n                while ( newIndex >= period ) { // let's see if there is a repeat, i.e. if we could also say that same bases at lower position are deleted\n\n                    // lets check if bases [newIndex-period,newIndex) immediately preceding the indel on the ref\n                    // are the same as the currently checked period of the inserted sequence:\n                \n                    boolean match = true;\n                \n                    for ( int testRefPos = newIndex - period, indelPos = 0 ; testRefPos < newIndex; testRefPos++, indelPos++) {\n                        char indelChr = indelString.charAt(indelPos);\n                        if ( Character.toUpperCase(refSeq.charAt(testRefPos)) != indelChr || BaseUtils.simpleBaseToBaseIndex(indelChr) == -1 ) {\n                            match = false;\n                            break;\n                        }\n                    }\n                    if ( match )\n                        newIndex -= period; // yes, they are the same, we can move indel farther left by at least period bases, go check if we can do more...\n                    else break; // oops, no match, can not push indel farther left\n                }\n            \n                final int newDifference = indelIndexOnRef - newIndex;\n                if ( newDifference > difference ) difference = newDifference; // deletion should be moved 'difference' bases left\n            \n                if ( period == 1 ) break; // we do not have to check all periods of homonucleotide sequences, we already\n                                          // got maximum possible shift after checking period=1 above.\n        }\n        \n        //        if ( ce2.getLength() >= 2 )\n        //            System.out.println(\"-----------------------------------\\n  FROM:\\n\"+AlignmentUtils.alignmentToString(cigar,readSeq,refSeq,refIndex, (readIsConsensusSequence?refIndex:0)));\n\n                        \n        if ( difference > 0 ) {\n\n            // The following if() statement: this should've never happened, unless the alignment is really screwed up.\n            // A real life example:\n            //\n            //   ref:    TTTTTTTTTTTTTTTTTT******TTTTTACTTATAGAAGAAAT...\n            //  read:       GTCTTTTTTTTTTTTTTTTTTTTTTTACTTATAGAAGAAAT...\n            //\n            //  i.e. the alignment claims 6 T's to be inserted. The alignment is clearly malformed/non-conforming since we could\n            // have just 3 T's inserted (so that the beginning of the read maps right onto the beginning of the\n            // reference fragment shown): that would leave us with same 2 mismatches at the beginning of the read\n            // (G and C) but lower gap penalty. Note that this has nothing to do with the alignment being \"right\" or \"wrong\"\n            // with respect to where on the DNA the read actually came from. It is the assumptions of *how* the alignments are\n            // built and represented that are broken here. While it is unclear how the alignment shown above could be generated\n            // in the first place, we are not in the business of fixing incorrect alignments in this method; all we are\n            // trying to do is to left-adjust correct ones. So if something like that happens, we refuse to change the cigar\n            // and bail out.\n            if ( ce1.getLength()-difference < 0 ) return cigar;\n\n            Cigar newCigar = new Cigar();\n            // do not add leading M cigar element if its length is zero (i.e. if we managed to left-shift the\n            // insertion all the way to the read start):\n            if ( ce1.getLength() - difference > 0 )\n                newCigar.add(new CigarElement(ce1.getLength()-difference, CigarOperator.M));\n            newCigar.add(ce2);  // add the indel, now it's left shifted since we decreased the number of preceding matching bases\n\n            if ( cigar.numCigarElements() > 2 ) {\n                // if we got something following the indel element:\n\n                if ( cigar.getCigarElement(2).getOperator() == CigarOperator.M  ) {\n                    // if indel was followed by matching bases (that's the most common situation),\n                    // increase the length of the matching section after the indel by the amount of left shift\n                    // (matching bases that were on the left are now *after* the indel; we have also checked at the beginning\n                    // that the first cigar element was also M):\n                    newCigar.add(new CigarElement(cigar.getCigarElement(2).getLength()+difference, CigarOperator.M));\n                } else {\n                    // if the element after the indel was not M, we have to add just the matching bases that were on the left\n                    // and now appear after the indel after we performed the shift. Then add the original element that followed the indel.\n                    newCigar.add(new CigarElement(difference, CigarOperator.M));\n                    newCigar.add(new CigarElement(cigar.getCigarElement(2).getLength(),cigar.getCigarElement(2).getOperator()));\n                }\n                // now add remaining (unchanged) cigar elements, if any:\n                for ( int i = 3 ; i < cigar.numCigarElements() ; i++ )  {\n                    newCigar.add(new CigarElement(cigar.getCigarElement(i).getLength(),cigar.getCigarElement(i).getOperator()));                    \n                }\n            }\n\n            //logger.debug(\"Realigning indel: \" + AlignmentUtils.cigarToString(cigar) + \" to \" + AlignmentUtils.cigarToString(newCigar));\n            cigar = newCigar;\n\n        }\n        return cigar;\n    }","commit_id":"1dd9996f3a2339a9a197cd5341d9b7d38fd879e9","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n   * Gets a stream to read the data of a block. The stream is backed by Tachyon storage.\n   *\n   * @param blockId the block to read from\n   * @return a BlockInStream which can be used to read the data in a streaming fashion\n   * @throws IOException if the block does not exist\n   */\n  public BufferedBlockInStream getInStream(long blockId) throws IOException {\n    BlockMasterClient masterClient = mContext.acquireMasterClient();\n    try {\n      // TODO(calvin): Fix this RPC.\n      BlockInfo blockInfo = masterClient.getBlockInfo(blockId);\n      // TODO(calvin): Get location via a policy.\n      if (blockInfo.locations.isEmpty()) {\n        // TODO(calvin): Maybe this shouldn't be an exception.\n        throw new IOException(\"No block \" + blockId + \" is not available in Tachyon\");\n      }\n      return BufferedBlockInStream.get(blockId, blockInfo.getLength(), blockInfo.locations.get(0)\n          .getWorkerAddress());\n    } finally {\n      mContext.releaseMasterClient(masterClient);\n    }\n  }","id":73034,"modified_method":"/**\n   * Gets a stream to read the data of a block. The stream is backed by Tachyon storage.\n   *\n   * @param blockId the block to read from\n   * @return a BlockInStream which can be used to read the data in a streaming fashion\n   * @throws IOException if the block does not exist\n   */\n  public BufferedBlockInStream getInStream(long blockId) throws IOException {\n    BlockMasterClient masterClient = mContext.acquireMasterClient();\n    try {\n      // TODO(calvin): Fix this RPC.\n      BlockInfo blockInfo = masterClient.getBlockInfo(blockId);\n      // TODO(calvin): Get location via a policy.\n      if (blockInfo.locations.isEmpty()) {\n        // TODO(calvin): Maybe this shouldn't be an exception.\n        throw new IOException(\"No block \" + blockId + \" is not available in Tachyon\");\n      }\n      // TODO(calvin): Investigate making this a Factory method\n      NetAddress workerNetAddress = blockInfo.locations.get(0).getWorkerAddress();\n      InetSocketAddress workerAddr =\n          new InetSocketAddress(workerNetAddress.getHost(), workerNetAddress.getDataPort());\n      if (NetworkAddressUtils.getLocalHostName(ClientContext.getConf()).equals(\n          workerAddr.getHostName())) {\n        return new LocalBlockInStream(blockId, blockInfo.getLength(), workerAddr);\n      } else {\n        return new RemoteBlockInStream(blockId, blockInfo.getLength(), workerAddr);\n      }\n    } finally {\n      mContext.releaseMasterClient(masterClient);\n    }\n  }","commit_id":"cbda4a7ca66b8e76e400820ed80fb33fc499d152","url":"https://github.com/amplab/tachyon"},{"original_method":"public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n            super.visitAssignmentExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (sign.getTokenType() != JavaTokenType.EQ) {\n                return;\n            }\n            final PsiExpression lhs = expression.getLExpression();\n            if (lhs == null) {\n                return;\n            }\n            if (!CollectionUtils.isArrayOrCollectionField(lhs)) {\n                return;\n            }\n            final PsiExpression rhs = expression.getRExpression();\n            if (rhs == null) {\n                return;\n            }\n            if (!(rhs instanceof PsiReferenceExpression)) {\n                return;\n            }\n            final PsiElement element = ((PsiReference) rhs).resolve();\n            if (!(element instanceof PsiParameter)) {\n                return;\n            }\n            if (!(element.getParent() instanceof PsiParameterList)) {\n                return;\n            }\n            registerError(lhs);\n        }","id":73035,"modified_method":"public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n            super.visitAssignmentExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (!(sign.getTokenType() == JavaTokenType.EQ)) {\n                return;\n            }\n            final PsiExpression lhs = expression.getLExpression();\n            if (lhs == null) {\n                return;\n            }\n            if (!CollectionUtils.isArrayOrCollectionField(lhs)) {\n                return;\n            }\n            final PsiExpression rhs = expression.getRExpression();\n            if (rhs == null) {\n                return;\n            }\n            if (!(rhs instanceof PsiReferenceExpression)) {\n                return;\n            }\n            final PsiElement element = ((PsiReference) rhs).resolve();\n            if (!(element instanceof PsiParameter)) {\n                return;\n            }\n            if (!(element.getParent() instanceof PsiParameterList)) {\n                return;\n            }\n            registerError(lhs);\n        }","commit_id":"114659b7e898b05342ae133184db4d98b9e226a1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n            super.visitAssignmentExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (sign.getTokenType() != JavaTokenType.EQ) {\n                return;\n            }\n            final PsiExpression lhs = expression.getLExpression();\n            if (lhs == null) {\n                return;\n            }\n            if (!TypeUtils.expressionHasTypeOrSubtype(\"java.util.Date\", lhs)\n                    && !TypeUtils.expressionHasTypeOrSubtype(\"java.util.Calendar\", lhs)) {\n                return;\n            }\n            final PsiExpression rhs = expression.getRExpression();\n            if (rhs == null) {\n                return;\n            }\n            if (!(rhs instanceof PsiReferenceExpression)) {\n                return;\n            }\n            final PsiElement element = ((PsiReference) rhs).resolve();\n            if (!(element instanceof PsiParameter)) {\n                return;\n            }\n            if (!(element.getParent() instanceof PsiParameterList)) {\n                return;\n            }\n            registerError(lhs);\n        }","id":73036,"modified_method":"public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n            super.visitAssignmentExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (!sign.getTokenType().equals(JavaTokenType.EQ)) {\n                return;\n            }\n            final PsiExpression lhs = expression.getLExpression();\n            if (lhs == null) {\n                return;\n            }\n            if (!TypeUtils.expressionHasTypeOrSubtype(\"java.util.Date\", lhs)\n                    && !TypeUtils.expressionHasTypeOrSubtype(\"java.util.Calendar\", lhs)) {\n                return;\n            }\n            final PsiExpression rhs = expression.getRExpression();\n            if (rhs == null) {\n                return;\n            }\n            if (!(rhs instanceof PsiReferenceExpression)) {\n                return;\n            }\n            final PsiElement element = ((PsiReference) rhs).resolve();\n            if (!(element instanceof PsiParameter)) {\n                return;\n            }\n            if (!(element.getParent() instanceof PsiParameterList)) {\n                return;\n            }\n            registerError(lhs);\n        }","commit_id":"114659b7e898b05342ae133184db4d98b9e226a1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n            super.visitAssignmentExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (sign.getTokenType() != JavaTokenType.EQ) {\n                return;\n            }\n            final PsiElement parent = expression.getParent();\n            if (parent instanceof PsiIfStatement) {\n                checkIfStatementCondition((PsiIfStatement) parent, expression);\n            }\n            if (parent instanceof PsiWhileStatement) {\n                checkWhileStatementCondition((PsiWhileStatement) parent, expression);\n            }\n            if (parent instanceof PsiForStatement) {\n                checkForStatementCondition((PsiForStatement) parent, expression);\n            }\n            if (parent instanceof PsiDoWhileStatement) {\n                checkDoWhileStatementCondition((PsiDoWhileStatement) parent, expression);\n            }\n        }","id":73037,"modified_method":"public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n            super.visitAssignmentExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (!sign.getTokenType().equals(JavaTokenType.EQ)) {\n                return;\n            }\n            final PsiElement parent = expression.getParent();\n            if (parent instanceof PsiIfStatement) {\n                checkIfStatementCondition((PsiIfStatement) parent, expression);\n            }\n            if (parent instanceof PsiWhileStatement) {\n                checkWhileStatementCondition((PsiWhileStatement) parent, expression);\n            }\n            if (parent instanceof PsiForStatement) {\n                checkForStatementCondition((PsiForStatement) parent, expression);\n            }\n            if (parent instanceof PsiDoWhileStatement) {\n                checkDoWhileStatementCondition((PsiDoWhileStatement) parent, expression);\n            }\n        }","commit_id":"2eaf661d1b04c6b3eed6f70b2d6d9ed5dd7d67ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isFloatingPointType(PsiExpression expression) {\n            if(expression == null)\n            {\n                return false;\n            }\n            final PsiType type = expression.getType();\n            return TypeConversionUtil.isDoubleType(type) ||\n                    TypeConversionUtil.isFloatType(type);\n\n        }","id":73038,"modified_method":"private static boolean isFloatingPointType(PsiExpression expression) {\n            if(expression == null)\n            {\n                return false;\n            }\n            final PsiType type = expression.getType();\n            if(type== null)\n            {\n                return false;\n            }\n            return TypeConversionUtil.isDoubleType(type) ||\n                    TypeConversionUtil.isFloatType(type);\n\n        }","commit_id":"2eaf661d1b04c6b3eed6f70b2d6d9ed5dd7d67ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(Project project, ProblemDescriptor descriptor) {\n            if (descriptor.getPsiElement() instanceof PsiBinaryExpression) {\n                final PsiBinaryExpression expression = (PsiBinaryExpression) descriptor.getPsiElement();\n                final PsiExpression lhs = expression.getLOperand();\n                final PsiExpression rhs = expression.getROperand();\n                final PsiJavaToken operationSign = expression.getOperationSign();\n                final IElementType tokenType = operationSign.getTokenType();\n                final String newExpression = lhs.getText() + getShortCircuitOperand(tokenType) + rhs.getText();\n                replaceExpression(project, expression, newExpression);\n            } else {\n                final PsiAssignmentExpression expression = (PsiAssignmentExpression) descriptor.getPsiElement();\n                final PsiExpression lhs = expression.getLExpression();\n                final PsiExpression rhs = expression.getRExpression();\n                final PsiJavaToken operationSign = expression.getOperationSign();\n                final IElementType tokenType = operationSign.getTokenType();\n                final String newExpression = lhs.getText() + getShortCircuitOperand(tokenType) + rhs.getText();\n                replaceExpression(project, expression, newExpression);\n            }\n        }","id":73039,"modified_method":"public void applyFix(Project project, ProblemDescriptor descriptor) {\n            final PsiBinaryExpression expression = (PsiBinaryExpression) descriptor.getPsiElement();\n            final PsiExpression lhs = expression.getLOperand();\n            final PsiExpression rhs = expression.getROperand();\n            final PsiJavaToken operationSign = expression.getOperationSign();\n            final IElementType tokenType = operationSign.getTokenType();\n            final String newExpression = lhs.getText() + getShortCircuitOperand(tokenType) + rhs.getText();\n            replaceExpression(project, expression, newExpression);\n        }","commit_id":"2eaf661d1b04c6b3eed6f70b2d6d9ed5dd7d67ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(Project project, ProblemDescriptor descriptor) {\n            final PsiElement comparisonToken = descriptor.getPsiElement();\n            final PsiBinaryExpression\n                    expression = (PsiBinaryExpression) comparisonToken.getParent();\n            boolean negated = false;\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (sign.getTokenType() == JavaTokenType.NE) {\n                negated = true;\n            }\n            final PsiExpression lhs = expression.getLOperand();\n            if (lhs == null) {\n                return;\n            }\n            final PsiExpression strippedLhs = ParenthesesUtils.stripParentheses(lhs);\n            final PsiExpression rhs = expression.getROperand();\n            if (rhs == null) {\n                return;\n            }\n            final PsiExpression strippedRhs = ParenthesesUtils.stripParentheses(rhs);\n\n            final String expString;\n            if (ParenthesesUtils.getPrecendence(strippedLhs) > ParenthesesUtils.METHOD_CALL_PRECEDENCE) {\n                expString = '(' + strippedLhs.getText() + \").equals(\" + strippedRhs.getText() + ')';\n            } else {\n                expString = strippedLhs.getText() + \".equals(\" + strippedRhs.getText() + ')';\n            }\n            final String newExpression;\n            if (negated) {\n                newExpression = '!' + expString;\n            } else {\n                newExpression = expString;\n            }\n            replaceExpression(project, expression, newExpression);\n        }","id":73040,"modified_method":"public void applyFix(Project project, ProblemDescriptor descriptor) {\n            final PsiElement comparisonToken = descriptor.getPsiElement();\n            final PsiBinaryExpression\n                    expression = (PsiBinaryExpression) comparisonToken.getParent();\n            boolean negated = false;\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (sign.getTokenType().equals(JavaTokenType.NE)) {\n                negated = true;\n            }\n            final PsiExpression lhs = expression.getLOperand();\n            if (lhs == null) {\n                return;\n            }\n            final PsiExpression strippedLhs = ParenthesesUtils.stripParentheses(lhs);\n            final PsiExpression rhs = expression.getROperand();\n            if (rhs == null) {\n                return;\n            }\n            final PsiExpression strippedRhs = ParenthesesUtils.stripParentheses(rhs);\n\n            final String expString;\n            if (ParenthesesUtils.getPrecendence(strippedLhs) > ParenthesesUtils.METHOD_CALL_PRECEDENCE) {\n                expString = '(' + strippedLhs.getText() + \").equals(\" + strippedRhs.getText() + ')';\n            } else {\n                expString = strippedLhs.getText() + \".equals(\" + strippedRhs.getText() + ')';\n            }\n            final String newExpression;\n            if (negated) {\n                newExpression = '!' + expString;\n            } else {\n                newExpression = expString;\n            }\n            replaceExpression(project, expression, newExpression);\n        }","commit_id":"2eaf661d1b04c6b3eed6f70b2d6d9ed5dd7d67ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JComponent createOptionsPanel() {\n        return new SingleCheckboxOptionsPanel(\"Ignore == between enumerated types\",\n                this, \"m_ignoreEnums\");\n    }","id":73041,"modified_method":"public JComponent createOptionsPanel() {\n        final GridBagLayout layout = new GridBagLayout();\n        final JPanel panel = new JPanel(layout);\n        final JCheckBox arrayCheckBox = new JCheckBox(\"Ignore == between enumerated types\", m_ignoreEnums);\n        final ButtonModel enumeratedObjectModel = arrayCheckBox.getModel();\n        enumeratedObjectModel.addChangeListener(new ChangeListener() {\n\n            public void stateChanged(ChangeEvent e) {\n                m_ignoreEnums = enumeratedObjectModel.isSelected();\n            }\n        });\n        final JCheckBox classObjectCheckbox = new JCheckBox(\"Ignore == on java.lang.Class objects\", m_ignoreClassObjects);\n        final ButtonModel classObjectModel = classObjectCheckbox.getModel();\n        classObjectModel.addChangeListener(new ChangeListener() {\n\n            public void stateChanged(ChangeEvent e) {\n                m_ignoreClassObjects = classObjectModel.isSelected();\n            }\n        });\n        final GridBagConstraints constraints = new GridBagConstraints();\n        constraints.gridx = 0;\n        constraints.gridy = 0;\n        constraints.fill = GridBagConstraints.HORIZONTAL;\n        panel.add(arrayCheckBox, constraints);\n\n        constraints.gridx = 0;\n        constraints.gridy = 1;\n        panel.add(classObjectCheckbox, constraints);\n        return panel;\n    }","commit_id":"2eaf661d1b04c6b3eed6f70b2d6d9ed5dd7d67ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            if (!ComparisonUtils.isEqualityComparison(expression)) {\n                return;\n            }\n            final PsiExpression rhs = expression.getROperand();\n            if (!isObjectType(rhs)) {\n                return;\n            }\n\n            final PsiExpression lhs = expression.getLOperand();\n            if (!isObjectType(lhs)) {\n                return;\n            }\n            if (m_ignoreEnums && isEnumType(rhs) && isEnumType(lhs)) {\n                return;\n            }\n            final PsiMethod method = (PsiMethod) PsiTreeUtil.getParentOfType(expression, PsiMethod.class);\n            final String methodName = method.getName();\n            if (\"equals\".equals(methodName)) {\n                return;\n            }\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            registerError(sign);\n        }","id":73042,"modified_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            if (!ComparisonUtils.isEqualityComparison(expression)) {\n                return;\n            }\n            final PsiExpression rhs = expression.getROperand();\n            if (!isObjectType(rhs)) {\n                return;\n            }\n\n            final PsiExpression lhs = expression.getLOperand();\n            if (!isObjectType(lhs)) {\n                return;\n            }\n            if (m_ignoreEnums && (isEnumType(rhs) || isEnumType(lhs))) {\n                return;\n            }\n            if (m_ignoreClassObjects && (isJavaLangClass(rhs) || isJavaLangClass(lhs))) {\n                return;\n            }\n            final PsiMethod method = (PsiMethod) PsiTreeUtil.getParentOfType(expression, PsiMethod.class);\n            final String methodName = method.getName();\n            if (\"equals\".equals(methodName)) {\n                return;\n            }\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            registerError(sign);\n        }","commit_id":"2eaf661d1b04c6b3eed6f70b2d6d9ed5dd7d67ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(Project project, ProblemDescriptor descriptor) {\n            final PsiElement comparisonToken = descriptor.getPsiElement();\n            boolean negated = false;\n            final PsiBinaryExpression expression =\n                    (PsiBinaryExpression) comparisonToken.getParent();\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign.getTokenType() == JavaTokenType.NE) {\n                negated = true;\n            }\n            final PsiExpression lhs = expression.getLOperand();\n            if (lhs == null) {\n                return;\n            }\n            final PsiExpression strippedLhs = ParenthesesUtils.stripParentheses(lhs);\n            final PsiExpression rhs = expression.getROperand();\n            if (rhs == null) {\n                return;\n            }\n            final PsiExpression strippedRhs = ParenthesesUtils.stripParentheses(rhs);\n\n            final String expString;\n            if (ParenthesesUtils.getPrecendence(strippedLhs) > ParenthesesUtils.METHOD_CALL_PRECEDENCE) {\n                expString = '(' + strippedLhs.getText() + \").equals(\" + strippedRhs.getText() + ')';\n            } else {\n                expString = strippedLhs.getText() + \".equals(\" + strippedRhs.getText() + ')';\n            }\n            final String newExpression;\n            if (negated) {\n                newExpression = '!' + expString;\n            } else {\n                newExpression = expString;\n            }\n            replaceExpression(project, expression, newExpression);\n        }","id":73043,"modified_method":"public void applyFix(Project project, ProblemDescriptor descriptor) {\n            final PsiElement comparisonToken = descriptor.getPsiElement();\n            boolean negated = false;\n            final PsiBinaryExpression expression =\n                    (PsiBinaryExpression) comparisonToken.getParent();\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (!(sign.getTokenType() != JavaTokenType.NE)) {\n                negated = true;\n            }\n            final PsiExpression lhs = expression.getLOperand();\n            if (lhs == null) {\n                return;\n            }\n            final PsiExpression strippedLhs = ParenthesesUtils.stripParentheses(lhs);\n            final PsiExpression rhs = expression.getROperand();\n            if (rhs == null) {\n                return;\n            }\n            final PsiExpression strippedRhs = ParenthesesUtils.stripParentheses(rhs);\n\n            final String expString;\n            if (ParenthesesUtils.getPrecendence(strippedLhs) > ParenthesesUtils.METHOD_CALL_PRECEDENCE) {\n                expString = '(' + strippedLhs.getText() + \").equals(\" + strippedRhs.getText() + ')';\n            } else {\n                expString = strippedLhs.getText() + \".equals(\" + strippedRhs.getText() + ')';\n            }\n            final String newExpression;\n            if (negated) {\n                newExpression = '!' + expString;\n            } else {\n                newExpression = expString;\n            }\n            replaceExpression(project, expression, newExpression);\n        }","commit_id":"2eaf661d1b04c6b3eed6f70b2d6d9ed5dd7d67ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitPostfixExpression(PsiPostfixExpression expression) {\n            super.visitPostfixExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (sign.getTokenType() != JavaTokenType.PLUSPLUS &&\n                    sign.getTokenType() != JavaTokenType.MINUSMINUS) {\n                return;\n            }\n            final PsiExpression operand = expression.getOperand();\n            if (operand == null) {\n                return;\n            }\n            checkForForLoopParam(operand);\n        }","id":73044,"modified_method":"public void visitPostfixExpression(PsiPostfixExpression expression) {\n            super.visitPostfixExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (!sign.getTokenType().equals(JavaTokenType.PLUSPLUS) &&\n                    !sign.getTokenType().equals(JavaTokenType.MINUSMINUS)) {\n                return;\n            }\n            final PsiExpression operand = expression.getOperand();\n            if (operand == null) {\n                return;\n            }\n            checkForForLoopParam(operand);\n        }","commit_id":"824218c4b65865d498aa50adad083adab83aff7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitPrefixExpression(PsiPrefixExpression expression) {\n            super.visitPrefixExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (sign.getTokenType() != JavaTokenType.PLUSPLUS &&\n                    sign.getTokenType() != JavaTokenType.MINUSMINUS) {\n                return;\n            }\n            final PsiExpression operand = expression.getOperand();\n            if (operand == null) {\n                return;\n            }\n            checkForForLoopParam(operand);\n        }","id":73045,"modified_method":"public void visitPrefixExpression(PsiPrefixExpression expression) {\n            super.visitPrefixExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (!sign.getTokenType().equals(JavaTokenType.PLUSPLUS) &&\n                    !sign.getTokenType().equals(JavaTokenType.MINUSMINUS)) {\n                return;\n            }\n            final PsiExpression operand = expression.getOperand();\n            if (operand == null) {\n                return;\n            }\n            checkForForLoopParam(operand);\n        }","commit_id":"824218c4b65865d498aa50adad083adab83aff7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitExpression(PsiExpression exp) {\n            super.visitExpression(exp);\n            final PsiType expressionType = exp.getType();\n            if (expressionType == null) {\n                return;\n            }\n            if (!ClassUtils.isPrimitiveNumericType(expressionType)) {\n                return;\n            }\n\n            final PsiType expectedType = ExpectedTypeUtils.findExpectedType(exp);\n            if (expectedType == null) {\n                return;\n            }\n            if (!ClassUtils.isPrimitiveNumericType(expectedType)) {\n                return;\n            }\n\n            if (expectedType.equals(expressionType)) {\n                return;\n            }\n            registerError(exp);\n        }","id":73046,"modified_method":"public void visitExpression(PsiExpression exp) {\n            super.visitExpression(exp);\n            final PsiType expressionType = exp.getType();\n            if (expressionType == null) {\n                return;\n            }\n            if (!ClassUtils.isPrimitiveNumericType(expressionType)) {\n                return;\n            }\n\n            final PsiType expectedType = ExpectedTypeUtils.findExpectedType(exp);\n            if (expectedType == null) {\n                return;\n            }\n            if (!ClassUtils.isPrimitiveNumericType(expectedType)) {\n                return;\n            }\n\n            if (expectedType.equals(expressionType)) {\n                return;\n            }\n\n            if (m_ignoreWideningConversions && hasLowerPrecision(expressionType, expectedType)) {\n                return;\n            }\n            registerError(exp);\n        }","commit_id":"824218c4b65865d498aa50adad083adab83aff7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitReferenceExpression(PsiReferenceExpression exp) {\n            super.visitReferenceExpression(exp);\n            final PsiType expressionType = exp.getType();\n            if (expressionType == null) {\n                return;\n            }\n            if (!ClassUtils.isPrimitiveNumericType(expressionType)) {\n                return;\n            }\n\n            final PsiType expectedType = ExpectedTypeUtils.findExpectedType(exp);\n            if (expectedType == null) {\n                return;\n            }\n\n            if (!ClassUtils.isPrimitiveNumericType(expectedType)) {\n                return;\n            }\n            if (expectedType.equals(expressionType)) {\n                return;\n            }\n            registerError(exp);\n        }","id":73047,"modified_method":"public void visitReferenceExpression(PsiReferenceExpression expression) {\n            super.visitReferenceExpression(expression);\n            final PsiType expressionType = expression.getType();\n            if (expressionType == null) {\n                return;\n            }\n            if (!ClassUtils.isPrimitiveNumericType(expressionType)) {\n                return;\n            }\n\n            final PsiType expectedType = ExpectedTypeUtils.findExpectedType(expression);\n            if (expectedType == null) {\n                return;\n            }\n\n            if (!ClassUtils.isPrimitiveNumericType(expectedType)) {\n                return;\n            }\n            if (expectedType.equals(expressionType)) {\n                return;\n            }\n            if (m_ignoreWideningConversions && hasLowerPrecision(expressionType, expectedType)) {\n                return;\n            }\n            registerError(expression);\n        }","commit_id":"824218c4b65865d498aa50adad083adab83aff7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isConvertible(PsiExpression expression, PsiType expectedType) {\n            if (!(expression instanceof PsiLiteralExpression)) {\n                return false;\n            }\n            final PsiType expressionType = expression.getType();\n            if (expressionType == null) {\n                return false;\n            }\n            if (isIntegral(expressionType) && isIntegral(expectedType)) {\n                return true;\n            }\n            if (isIntegral(expressionType) && isFloatingPoint(expectedType)) {\n                return true;\n            }\n            if (isFloatingPoint(expressionType) && isFloatingPoint(expectedType)) {\n                return true;\n            }\n\n            return false;\n        }","id":73048,"modified_method":"private static boolean isConvertible(PsiExpression expression, PsiType expectedType) {\n            if (!(expression instanceof PsiLiteralExpression) && !isNegatedLiteral(expression)) {\n                return false;\n            }\n            final PsiType expressionType = expression.getType();\n            if (expressionType == null) {\n                return false;\n            }\n            if(hasLowerPrecision(expectedType,  expressionType))\n            {\n                return false;\n            }\n            if (isIntegral(expressionType) && isIntegral(expectedType)) {\n                return true;\n            }\n            if (isIntegral(expressionType) && isFloatingPoint(expectedType)) {\n                return true;\n            }\n            if (isFloatingPoint(expressionType) && isFloatingPoint(expectedType)) {\n                return true;\n            }\n\n            return false;\n        }","commit_id":"824218c4b65865d498aa50adad083adab83aff7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String buildErrorString(PsiElement location) {\n        final String expressionType;\n        if (location instanceof PsiPostfixExpression) {\n            final PsiJavaToken sign = ((PsiPostfixExpression) location).getOperationSign();\n            if (sign.getTokenType() == JavaTokenType.PLUSPLUS) {\n                expressionType = \"post-increment\";\n            } else {\n                expressionType = \"post-decrement\";\n            }\n        } else {\n            final PsiJavaToken sign = ((PsiPrefixExpression) location).getOperationSign();\n            if (sign.getTokenType() == JavaTokenType.PLUSPLUS) {\n                expressionType = \"pre-increment\";\n            } else {\n                expressionType = \"pre-decrement\";\n            }\n        }\n        return \"Value of \" + expressionType + \" expression #ref is used #loc\";\n    }","id":73049,"modified_method":"public String buildErrorString(PsiElement location) {\n        final String expressionType;\n        if (location instanceof PsiPostfixExpression) {\n            final PsiJavaToken sign = ((PsiPostfixExpression) location).getOperationSign();\n            if (sign.getTokenType().equals(JavaTokenType.PLUSPLUS)) {\n                expressionType = \"post-increment\";\n            } else {\n                expressionType = \"post-decrement\";\n            }\n        } else {\n            final PsiJavaToken sign = ((PsiPrefixExpression) location).getOperationSign();\n            if (sign.getTokenType().equals(JavaTokenType.PLUSPLUS)) {\n                expressionType = \"pre-increment\";\n            } else {\n                expressionType = \"pre-decrement\";\n            }\n        }\n        return \"Value of \" + expressionType + \" expression #ref is used #loc\";\n    }","commit_id":"824218c4b65865d498aa50adad083adab83aff7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String buildErrorString(Object val) {\n        return \"Method names '#ref' and '\" + val + \"' differ only by case\";\n    }","id":73050,"modified_method":"public String buildErrorString(Object arg) {\n        return \"Method names '#ref' and '\" + arg + \"' differ only by case\";\n    }","commit_id":"824218c4b65865d498aa50adad083adab83aff7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int calculateParamCount(PsiMethod method) {\n            final PsiParameterList paramList = method.getParameterList();\n            final PsiParameter[] parameters = paramList.getParameters();\n            final int parameterCount = parameters.length;\n            return parameterCount;\n        }","id":73051,"modified_method":"private static int calculateParamCount(PsiMethod method) {\n            final PsiParameterList paramList = method.getParameterList();\n            final PsiParameter[] parameters = paramList.getParameters();\n            return parameters.length;\n        }","commit_id":"824218c4b65865d498aa50adad083adab83aff7e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isArgumentOfConcatenation(PsiExpression expression) {\n            final PsiElement parent = expression.getParent();\n            if (!(parent instanceof PsiBinaryExpression)) {\n                return false;\n            }\n            final PsiBinaryExpression binaryExp = (PsiBinaryExpression) parent;\n            final PsiJavaToken sign = binaryExp.getOperationSign();\n            if (sign == null) {\n                return false;\n            }\n            if (sign.getTokenType() != JavaTokenType.PLUS) {\n                return false;\n            }\n            final PsiExpression sibling;\n            final PsiExpression lhs = binaryExp.getLOperand();\n            if (lhs.equals(expression)) {\n                sibling = binaryExp.getROperand();\n            } else {\n                sibling = lhs;\n            }\n            if (sibling == null) {\n                return false;\n            }\n            final PsiType siblingType = sibling.getType();\n            if (!TypeUtils.isJavaLangString(siblingType)) {\n                return false;\n            }\n            return true;\n        }","id":73052,"modified_method":"private static boolean isArgumentOfConcatenation(PsiExpression expression) {\n            final PsiElement parent = expression.getParent();\n            if (!(parent instanceof PsiBinaryExpression)) {\n                return false;\n            }\n            final PsiBinaryExpression binaryExp = (PsiBinaryExpression) parent;\n            final PsiJavaToken sign = binaryExp.getOperationSign();\n            if (sign == null) {\n                return false;\n            }\n            if (!sign.getTokenType().equals(JavaTokenType.PLUS)) {\n                return false;\n            }\n            final PsiExpression sibling;\n            final PsiExpression lhs = binaryExp.getLOperand();\n            if (lhs.equals(expression)) {\n                sibling = binaryExp.getROperand();\n            } else {\n                sibling = lhs;\n            }\n            if (sibling == null) {\n                return false;\n            }\n            final PsiType siblingType = sibling.getType();\n            if (!TypeUtils.isJavaLangString(siblingType)) {\n                return false;\n            }\n            return true;\n        }","commit_id":"04dcacfa38a6229c5b6a65447f8abdec6a9a7ecb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean expressionIsArrayMove(PsiExpression exp, PsiLocalVariable var) {\n            final PsiExpression strippedExpression = ParenthesesUtils.stripParentheses(exp);\n            if (strippedExpression == null) {\n                return false;\n            }\n            if (!(strippedExpression instanceof PsiAssignmentExpression)) {\n                return false;\n            }\n            final PsiAssignmentExpression assignment = (PsiAssignmentExpression) strippedExpression;\n            final PsiJavaToken sign = assignment.getOperationSign();\n            if (sign == null) {\n                return false;\n            }\n            if (sign.getTokenType() != JavaTokenType.EQ) {\n                return false;\n            }\n            final PsiExpression lhs = assignment.getLExpression();\n            if (lhs == null) {\n                return false;\n            }\n            if (SideEffectChecker.mayHaveSideEffects(lhs)) {\n                return false;\n            }\n            if (!isOffsetArrayAccess(lhs, var)) {\n                return false;\n            }\n            final PsiExpression rhs = assignment.getRExpression();\n            if (rhs == null) {\n                return false;\n            }\n            if (SideEffectChecker.mayHaveSideEffects(rhs)) {\n                return false;\n            }\n            if (!isOffsetArrayAccess(rhs, var)) {\n                return false;\n            }\n            return true;\n        }","id":73053,"modified_method":"private static boolean expressionIsArrayMove(PsiExpression exp, PsiLocalVariable var) {\n            final PsiExpression strippedExpression = ParenthesesUtils.stripParentheses(exp);\n            if (strippedExpression == null) {\n                return false;\n            }\n            if (!(strippedExpression instanceof PsiAssignmentExpression)) {\n                return false;\n            }\n            final PsiAssignmentExpression assignment = (PsiAssignmentExpression) strippedExpression;\n            final PsiJavaToken sign = assignment.getOperationSign();\n            if (sign == null) {\n                return false;\n            }\n            if (!(sign.getTokenType() == JavaTokenType.EQ)) {\n                return false;\n            }\n            final PsiExpression lhs = assignment.getLExpression();\n            if (lhs == null) {\n                return false;\n            }\n            if (SideEffectChecker.mayHaveSideEffects(lhs)) {\n                return false;\n            }\n            if (!isOffsetArrayAccess(lhs, var)) {\n                return false;\n            }\n            final PsiExpression rhs = assignment.getRExpression();\n            if (rhs == null) {\n                return false;\n            }\n            if (SideEffectChecker.mayHaveSideEffects(rhs)) {\n                return false;\n            }\n            if (!isOffsetArrayAccess(rhs, var)) {\n                return false;\n            }\n            return true;\n        }","commit_id":"04dcacfa38a6229c5b6a65447f8abdec6a9a7ecb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isComparison(PsiExpression condition, PsiLocalVariable var) {\n            final PsiExpression strippedCondition = ParenthesesUtils.stripParentheses(condition);\n\n            if (!(strippedCondition instanceof PsiBinaryExpression)) {\n                return false;\n            }\n            final PsiBinaryExpression binaryExp = (PsiBinaryExpression) strippedCondition;\n            final PsiJavaToken sign = binaryExp.getOperationSign();\n            if (sign == null) {\n                return false;\n            }\n            if (sign.getTokenType() != JavaTokenType.LT) {\n                return false;\n            }\n            final PsiExpression lhs = binaryExp.getLOperand();\n            if (!expressionIsVariableLookup(lhs, var)) {\n                return false;\n            }\n            return true;\n        }","id":73054,"modified_method":"private static boolean isComparison(PsiExpression condition, PsiLocalVariable var) {\n            final PsiExpression strippedCondition = ParenthesesUtils.stripParentheses(condition);\n\n            if (!(strippedCondition instanceof PsiBinaryExpression)) {\n                return false;\n            }\n            final PsiBinaryExpression binaryExp = (PsiBinaryExpression) strippedCondition;\n            final PsiJavaToken sign = binaryExp.getOperationSign();\n            if (sign == null) {\n                return false;\n            }\n            if (!sign.getTokenType().equals(JavaTokenType.LT)) {\n                return false;\n            }\n            final PsiExpression lhs = binaryExp.getLOperand();\n            if (!expressionIsVariableLookup(lhs, var)) {\n                return false;\n            }\n            return true;\n        }","commit_id":"04dcacfa38a6229c5b6a65447f8abdec6a9a7ecb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitMethod(PsiMethod method) {\n            super.visitMethod(method);\n            if (method.hasModifierProperty(PsiModifier.STATIC)) {\n                return;\n            }\n            if (method.isConstructor()) {\n                return;\n            }\n            if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {\n                return;\n            }\n            if (m_ignoreEmptyMethods) {\n                final PsiCodeBlock methodBody = method.getBody();\n                if (methodBody == null) {\n                    return;\n                }\n                final PsiStatement[] methodStatements = methodBody.getStatements();\n                if (methodStatements.length == 0) {\n                    return;\n                }\n            }\n            final PsiClass containingClass = ClassUtils.getContainingClass(method);\n            final PsiElement scope = containingClass.getScope();\n            if (!(scope instanceof PsiJavaFile) &&\n                    !containingClass.hasModifierProperty(PsiModifier.STATIC)) {\n                return;\n            }\n            if (!method.hasModifierProperty(PsiModifier.PRIVATE) &&\n                    !method.hasModifierProperty(PsiModifier.FINAL)) {\n                if (m_onlyPrivateOrFinal) {\n                    return;\n                } else {\n                    final PsiMethod[] superMethods = method.findSuperMethods();\n                    if (superMethods.length > 0) {\n                        return;\n                    }\n                    final OverridingMethodChecker overridingMethodChecker =\n                            new OverridingMethodChecker(method);\n                    if (overridingMethodChecker.hasOverridingMethods()) {\n                        return;\n                    }\n                }\n            }\n            final MethodReferenceVisitor visitor = new MethodReferenceVisitor(method);\n            method.accept(visitor);\n            if (!visitor.areReferencesStaticallyAccessible()) {\n                return;\n            }\n            registerMethodError(method);\n        }","id":73055,"modified_method":"public void visitMethod(PsiMethod method) {\n            super.visitMethod(method);\n            if (method.hasModifierProperty(PsiModifier.STATIC)) {\n                return;\n            }\n            if (method.isConstructor()) {\n                return;\n            }\n            if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {\n                return;\n            }\n            if (m_ignoreEmptyMethods) {\n                final PsiCodeBlock methodBody = method.getBody();\n                if (methodBody == null) {\n                    return;\n                }\n                final PsiStatement[] methodStatements = methodBody.getStatements();\n                if (methodStatements.length == 0) {\n                    return;\n                }\n            }\n            final PsiClass containingClass = ClassUtils.getContainingClass(method);\n            final PsiElement scope = containingClass.getScope();\n            if (!(scope instanceof PsiJavaFile) &&\n                    !containingClass.hasModifierProperty(PsiModifier.STATIC)) {\n                return;\n            }\n            if (m_onlyPrivateOrFinal &&\n                    !method.hasModifierProperty(PsiModifier.FINAL) &&\n                    !method.hasModifierProperty(PsiModifier.PRIVATE)) {\n                return;\n            }\n            final PsiMethod[] superMethods = method.findSuperMethods();\n            if (superMethods.length > 0) {\n                return;\n            }\n            final OverridingMethodChecker overridingMethodChecker =\n                    new OverridingMethodChecker(method);\n            if (overridingMethodChecker.hasOverridingMethods()) {\n                return;\n            }\n            final MethodReferenceVisitor visitor = new MethodReferenceVisitor(method);\n            method.accept(visitor);\n            if (!visitor.areReferencesStaticallyAccessible()) {\n                return;\n            }\n            registerMethodError(method);\n        }","commit_id":"04dcacfa38a6229c5b6a65447f8abdec6a9a7ecb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String calculateReplacementShift(PsiExpression expression) {\n        final PsiExpression lhs;\n        final PsiExpression rhs;\n        final String operator;\n        if (expression instanceof PsiAssignmentExpression) {\n            final PsiAssignmentExpression exp = (PsiAssignmentExpression) expression;\n\n            final PsiJavaToken sign = exp.getOperationSign();\n            lhs = exp.getLExpression();\n            rhs = exp.getRExpression();\n            if (sign.getTokenType() == JavaTokenType.ASTERISKEQ) {\n                operator = \"<<=\";\n            } else {\n                operator = \">>=\";\n            }\n        } else {\n            final PsiBinaryExpression exp = (PsiBinaryExpression) expression;\n            final PsiJavaToken sign = exp.getOperationSign();\n            lhs = exp.getLOperand();\n            rhs = exp.getROperand();\n            if (sign.getTokenType() == JavaTokenType.ASTERISK) {\n                operator = \"<<\";\n            } else {\n                operator = \">>\";\n            }\n        }\n        final String newExpression = lhs.getText() + ' ' + operator + ' ' + ShiftUtils.getLogBaseTwo(rhs);\n        return newExpression;\n    }","id":73056,"modified_method":"private static String calculateReplacementShift(PsiExpression expression) {\n        final PsiExpression lhs;\n        final PsiExpression rhs;\n        final String operator;\n        if (expression instanceof PsiAssignmentExpression) {\n            final PsiAssignmentExpression exp = (PsiAssignmentExpression) expression;\n\n            final PsiJavaToken sign = exp.getOperationSign();\n            lhs = exp.getLExpression();\n            rhs = exp.getRExpression();\n            if (sign.getTokenType().equals(JavaTokenType.ASTERISKEQ)) {\n                operator = \"<<=\";\n            } else {\n                operator = \">>=\";\n            }\n        } else {\n            final PsiBinaryExpression exp = (PsiBinaryExpression) expression;\n            final PsiJavaToken sign = exp.getOperationSign();\n            lhs = exp.getLOperand();\n            rhs = exp.getROperand();\n            if (!(sign.getTokenType() != JavaTokenType.ASTERISK)) {\n                operator = \"<<\";\n            } else {\n                operator = \">>\";\n            }\n        }\n        return lhs.getText() + ' ' + operator + ' ' + ShiftUtils.getLogBaseTwo(rhs);\n    }","commit_id":"04dcacfa38a6229c5b6a65447f8abdec6a9a7ecb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (sign.getTokenType() != JavaTokenType.ASTERISK &&\n                    sign.getTokenType() != JavaTokenType.DIV) {\n                return;\n            }\n            final PsiExpression rhs = expression.getROperand();\n            if (!ShiftUtils.isPowerOfTwo(rhs)) {\n                return;\n            }\n            final PsiType type = expression.getType();\n            if (type == null) {\n                return;\n            }\n            if (!ClassUtils.isIntegral(type)) {\n                return;\n            }\n            registerError(expression);\n        }","id":73057,"modified_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (!sign.getTokenType().equals(JavaTokenType.ASTERISK) &&\n                    !sign.getTokenType().equals(JavaTokenType.DIV)) {\n                return;\n            }\n            final PsiExpression rhs = expression.getROperand();\n            if (!ShiftUtils.isPowerOfTwo(rhs)) {\n                return;\n            }\n            final PsiType type = expression.getType();\n            if (type == null) {\n                return;\n            }\n            if (!ClassUtils.isIntegral(type)) {\n                return;\n            }\n            registerError(expression);\n        }","commit_id":"04dcacfa38a6229c5b6a65447f8abdec6a9a7ecb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n            super.visitAssignmentExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign.getTokenType() != JavaTokenType.ASTERISKEQ &&\n                    sign.getTokenType() != JavaTokenType.DIVEQ) {\n                return;\n            }\n            final PsiExpression rhs = expression.getRExpression();\n            if (!ShiftUtils.isPowerOfTwo(rhs)) {\n                return;\n            }\n\n            final PsiType type = expression.getType();\n            if (type == null) {\n                return;\n            }\n            if (!ClassUtils.isIntegral(type)) {\n                return;\n            }\n            registerError(expression);\n        }","id":73058,"modified_method":"public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n            super.visitAssignmentExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (!sign.getTokenType().equals(JavaTokenType.ASTERISKEQ) &&\n                    !sign.getTokenType().equals(JavaTokenType.DIVEQ)) {\n                return;\n            }\n            final PsiExpression rhs = expression.getRExpression();\n            if (!ShiftUtils.isPowerOfTwo(rhs)) {\n                return;\n            }\n\n            final PsiType type = expression.getType();\n            if (type == null) {\n                return;\n            }\n            if (!ClassUtils.isIntegral(type)) {\n                return;\n            }\n            registerError(expression);\n        }","commit_id":"04dcacfa38a6229c5b6a65447f8abdec6a9a7ecb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitMethodCallExpression(PsiMethodCallExpression expression) {\n            super.visitMethodCallExpression(expression);\n            final PsiElement parent = expression.getParent();\n            if (!(parent instanceof PsiBinaryExpression)) {\n                return;\n            }\n            final PsiBinaryExpression parentBinary = (PsiBinaryExpression) parent;\n            final PsiJavaToken sign = parentBinary.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (sign.getTokenType() != JavaTokenType.PLUS) {\n                return;\n            }\n            final PsiExpression rhs = parentBinary.getROperand();\n            if (rhs == null) {\n                return;\n            }\n            if (!rhs.equals(expression)) {\n                return;\n            }\n            if (!isStringBufferToString(expression)) {\n                return;\n            }\n            final PsiReferenceExpression methodExpression = expression.getMethodExpression();\n            if (methodExpression == null) {\n                return;\n            }\n            registerMethodCallError(expression);\n        }","id":73059,"modified_method":"public void visitMethodCallExpression(PsiMethodCallExpression expression) {\n            super.visitMethodCallExpression(expression);\n            final PsiElement parent = expression.getParent();\n            if (!(parent instanceof PsiBinaryExpression)) {\n                return;\n            }\n            final PsiBinaryExpression parentBinary = (PsiBinaryExpression) parent;\n            final PsiJavaToken sign = parentBinary.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (!(sign.getTokenType() == JavaTokenType.PLUS)) {\n                return;\n            }\n            final PsiExpression rhs = parentBinary.getROperand();\n            if (rhs == null) {\n                return;\n            }\n            if (!rhs.equals(expression)) {\n                return;\n            }\n            if (!isStringBufferToString(expression)) {\n                return;\n            }\n            final PsiReferenceExpression methodExpression = expression.getMethodExpression();\n            if (methodExpression == null) {\n                return;\n            }\n            registerMethodCallError(expression);\n        }","commit_id":"04dcacfa38a6229c5b6a65447f8abdec6a9a7ecb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n            super.visitAssignmentExpression(expression);\n\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (sign.getTokenType() != JavaTokenType.PLUSEQ) {\n                return;\n            }\n            final PsiExpression lhs = expression.getLExpression();\n            if (lhs == null) {\n                return;\n            }\n            final PsiType type = lhs.getType();\n            if (type == null) {\n                return;\n            }\n            if (!TypeUtils.isJavaLangString(type)) {\n                return;\n            }\n            if (!ControlFlowUtils.isInLoop(expression)) {\n                return;\n            }\n            if (ControlFlowUtils.isInExitStatement(expression)) {\n                return;\n            }\n            registerError(sign);\n        }","id":73060,"modified_method":"public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n            super.visitAssignmentExpression(expression);\n\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (!sign.getTokenType().equals(JavaTokenType.PLUSEQ)) {\n                return;\n            }\n            final PsiExpression lhs = expression.getLExpression();\n            if (lhs == null) {\n                return;\n            }\n            final PsiType type = lhs.getType();\n            if (type == null) {\n                return;\n            }\n            if (!TypeUtils.isJavaLangString(type)) {\n                return;\n            }\n            if (!ControlFlowUtils.isInLoop(expression)) {\n                return;\n            }\n            if (ControlFlowUtils.isInExitStatement(expression)) {\n                return;\n            }\n            registerError(sign);\n        }","commit_id":"04dcacfa38a6229c5b6a65447f8abdec6a9a7ecb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (sign.getTokenType() != JavaTokenType.PLUS) {\n                return;\n            }\n            final PsiType type = expression.getType();\n            if (type == null) {\n                return;\n            }\n            if (!TypeUtils.isJavaLangString(type)) {\n                return;\n            }\n            if (!ControlFlowUtils.isInLoop(expression)) {\n                return;\n            }\n            if (ControlFlowUtils.isInExitStatement(expression)) {\n                return;\n            }\n            if (isEvaluatedAtCompileTime(expression)) {\n                return;\n            }\n            if (m_ignoreUnlessAssigned && !isOnRHSOfAssignment(expression)) {\n                return;\n            }\n            registerError(sign);\n        }","id":73061,"modified_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (!sign.getTokenType().equals(JavaTokenType.PLUS)) {\n                return;\n            }\n            final PsiType type = expression.getType();\n            if (type == null) {\n                return;\n            }\n            if (!TypeUtils.isJavaLangString(type)) {\n                return;\n            }\n            if (!ControlFlowUtils.isInLoop(expression)) {\n                return;\n            }\n            if (ControlFlowUtils.isInExitStatement(expression)) {\n                return;\n            }\n            if (isEvaluatedAtCompileTime(expression)) {\n                return;\n            }\n            if (m_ignoreUnlessAssigned && !isOnRHSOfAssignment(expression)) {\n                return;\n            }\n            registerError(sign);\n        }","commit_id":"04dcacfa38a6229c5b6a65447f8abdec6a9a7ecb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isNegation(PsiExpression exp){\n        if(!(exp instanceof PsiPrefixExpression)){\n            return false;\n        }\n        final PsiPrefixExpression prefixExp = (PsiPrefixExpression) exp;\n        final PsiJavaToken sign = prefixExp.getOperationSign();\n        return sign.getTokenType() == JavaTokenType.EXCL;\n    }","id":73062,"modified_method":"public static boolean isNegation(PsiExpression exp){\n        if(!(exp instanceof PsiPrefixExpression)){\n            return false;\n        }\n        final PsiPrefixExpression prefixExp = (PsiPrefixExpression) exp;\n        final PsiJavaToken sign = prefixExp.getOperationSign();\n        return sign.getTokenType().equals(JavaTokenType.EXCL);\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isNegated(PsiExpression exp){\n        PsiExpression ancestor = exp;\n        while(ancestor.getParent() instanceof PsiParenthesizedExpression){\n            ancestor = (PsiExpression) ancestor.getParent();\n        }\n        if(ancestor.getParent() instanceof PsiPrefixExpression){\n            final PsiPrefixExpression prefixAncestor =\n                    (PsiPrefixExpression) ancestor.getParent();\n            final PsiJavaToken sign = prefixAncestor.getOperationSign();\n            if(sign.getTokenType() == JavaTokenType.EXCL){\n                return true;\n            }\n        }\n        return false;\n    }","id":73063,"modified_method":"public static boolean isNegated(PsiExpression exp){\n        PsiExpression ancestor = exp;\n        while(ancestor.getParent() instanceof PsiParenthesizedExpression){\n            ancestor = (PsiExpression) ancestor.getParent();\n        }\n        if(ancestor.getParent() instanceof PsiPrefixExpression){\n            final PsiPrefixExpression prefixAncestor =\n                    (PsiPrefixExpression) ancestor.getParent();\n            final PsiJavaToken sign = prefixAncestor.getOperationSign();\n            if(sign.getTokenType().equals(JavaTokenType.EXCL)){\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement exp){\n        if(!(exp instanceof PsiBinaryExpression)){\n            return false;\n        }\n        final PsiBinaryExpression expression = (PsiBinaryExpression) exp;\n        final PsiJavaToken sign = expression.getOperationSign();\n        final IElementType tokenType = sign.getTokenType();\n        return tokenType.equals(JavaTokenType.ANDAND) ||\n                       tokenType.equals(JavaTokenType.OROR);\n    }","id":73064,"modified_method":"public boolean satisfiedBy(PsiElement element){\n        if(!(element instanceof PsiBinaryExpression)){\n            return false;\n        }\n        final PsiBinaryExpression expression = (PsiBinaryExpression) element;\n        final PsiJavaToken sign = expression.getOperationSign();\n        final IElementType tokenType = sign.getTokenType();\n        return tokenType.equals(JavaTokenType.ANDAND) ||\n                       tokenType.equals(JavaTokenType.OROR);\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(Project project, Editor editor, PsiFile file)\n            throws IncorrectOperationException{\n        if(isFileReadOnly(project, file)){\n            return;\n        }\n        final PsiJavaToken token =\n                (PsiJavaToken) findMatchingElement(file, editor);\n        final PsiTryStatement tryStatement =\n                (PsiTryStatement) token.getParent();\n\n        final String text = tryStatement.getText();\n        final int length = text.length();\n        final StringBuffer newTryStatement = new StringBuffer(length);\n        newTryStatement.append(\"try\");\n        final PsiCodeBlock tryBlock = tryStatement.getTryBlock();\n        final String tryBlockText = tryBlock.getText();\n        newTryStatement.append(tryBlockText);\n\n        final Set exceptionsThrown = new HashSet(10);\n\n        final PsiManager mgr = PsiManager.getInstance(project);\n        final PsiElementFactory factory = mgr.getElementFactory();\n        ExceptionUtils.calculateExceptionsThrownForCodeBlock(tryBlock,\n                                                             exceptionsThrown,\n                                                             factory);\n\n        final HeirarchicalTypeComparator comparator =\n                new HeirarchicalTypeComparator();\n        final PsiCatchSection[] catchSections = tryStatement.getCatchSections();\n        for(int i = 0; i < catchSections.length; i++){\n            final PsiParameter param = catchSections[i].getParameter();\n            final PsiCodeBlock block = catchSections[i].getCatchBlock();\n            if(param == null || block == null){\n                continue;\n            }\n\n            final PsiType caughtType = param.getType();\n            final List exceptionsToExpand = new ArrayList(10);\n            for(Iterator iterator = exceptionsThrown.iterator();\n                iterator.hasNext();){\n                final PsiType thrownType = (PsiType) iterator.next();\n                if(caughtType.isAssignableFrom(thrownType)){\n                    exceptionsToExpand.add(thrownType);\n                }\n            }\n            Collections.sort(exceptionsToExpand, comparator);\n            for(Iterator iterator = exceptionsToExpand.iterator();\n                iterator.hasNext();){\n                final PsiType thrownType = (PsiType) iterator.next();\n                newTryStatement.append(\"catch(\");\n                final String exceptionType = thrownType.getPresentableText();\n                newTryStatement.append(exceptionType);\n                newTryStatement.append(' ');\n                final String parameterName = param.getName();\n                newTryStatement.append(parameterName);\n                newTryStatement.append(')');\n                final String blockText = block.getText();\n                newTryStatement.append(blockText);\n            }\n        }\n        final PsiCodeBlock finallyBlock = tryStatement.getFinallyBlock();\n        if(finallyBlock != null){\n            newTryStatement.append(\"finally\");\n            final String finallyBlockText = finallyBlock.getText();\n            newTryStatement.append(finallyBlockText);\n        }\n        final String newStatement = newTryStatement.toString();\n        replaceStatement(project, newStatement, tryStatement);\n    }","id":73065,"modified_method":"public void invoke(Project project, Editor editor, PsiFile file)\n            throws IncorrectOperationException{\n        if(isFileReadOnly(project, file)){\n            return;\n        }\n        final PsiJavaToken token =\n                (PsiJavaToken) findMatchingElement(file, editor);\n        final PsiTryStatement tryStatement =\n                (PsiTryStatement) token.getParent();\n\n        final String text = tryStatement.getText();\n        final int length = text.length();\n        final StringBuffer newTryStatement = new StringBuffer(length);\n        newTryStatement.append(\"try\");\n        final PsiCodeBlock tryBlock = tryStatement.getTryBlock();\n        final String tryBlockText = tryBlock.getText();\n        newTryStatement.append(tryBlockText);\n\n        final Set exceptionsThrown = new HashSet(10);\n\n        final PsiManager mgr = PsiManager.getInstance(project);\n        final PsiElementFactory factory = mgr.getElementFactory();\n        ExceptionUtils.calculateExceptionsThrownForCodeBlock(tryBlock,\n                                                             exceptionsThrown,\n                                                             factory);\n\n        final HeirarchicalTypeComparator comparator =\n                new HeirarchicalTypeComparator();\n        final PsiCatchSection[] catchSections = tryStatement.getCatchSections();\n        for(int i = 0; i < catchSections.length; i++){\n            final PsiParameter param = catchSections[i].getParameter();\n            final PsiCodeBlock block = catchSections[i].getCatchBlock();\n            if(param != null && block != null){\n                final PsiType caughtType = param.getType();\n                final List exceptionsToExpand = new ArrayList(10);\n                for(Iterator iterator = exceptionsThrown.iterator();\n                    iterator.hasNext();){\n                    final PsiType thrownType = (PsiType) iterator.next();\n                    if(caughtType.isAssignableFrom(thrownType)){\n                        exceptionsToExpand.add(thrownType);\n                    }\n                }\n                Collections.sort(exceptionsToExpand, comparator);\n                for(Iterator iterator = exceptionsToExpand.iterator();\n                    iterator.hasNext();){\n                    final PsiType thrownType = (PsiType) iterator.next();\n                    newTryStatement.append(\"catch(\");\n                    final String exceptionType =\n                            thrownType.getPresentableText();\n                    newTryStatement.append(exceptionType);\n                    newTryStatement.append(' ');\n                    final String parameterName = param.getName();\n                    newTryStatement.append(parameterName);\n                    newTryStatement.append(')');\n                    final String blockText = block.getText();\n                    newTryStatement.append(blockText);\n                }\n            }\n        }\n        final PsiCodeBlock finallyBlock = tryStatement.getFinallyBlock();\n        if(finallyBlock != null){\n            newTryStatement.append(\"finally\");\n            final String finallyBlockText = finallyBlock.getText();\n            newTryStatement.append(finallyBlockText);\n        }\n        final String newStatement = newTryStatement.toString();\n        replaceStatement(project, newStatement, tryStatement);\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean prefixExpressionsAreEquivalent(PsiPrefixExpression prefixExp1,\n                                                          PsiPrefixExpression prefixExp2){\n        final PsiJavaToken sign1 = prefixExp1.getOperationSign();\n        final PsiJavaToken sign2 = prefixExp2.getOperationSign();\n        if(sign1.getTokenType() != sign2.getTokenType()){\n            return false;\n        }\n        final PsiExpression operand1 = prefixExp1.getOperand();\n        final PsiExpression operand2 = prefixExp2.getOperand();\n        return expressionsAreEquivalent(operand1, operand2);\n    }","id":73066,"modified_method":"private static boolean prefixExpressionsAreEquivalent(PsiPrefixExpression prefixExp1,\n                                                          PsiPrefixExpression prefixExp2){\n        final PsiJavaToken sign1 = prefixExp1.getOperationSign();\n        final PsiJavaToken sign2 = prefixExp2.getOperationSign();\n        if(!sign1.getTokenType().equals(sign2.getTokenType())){\n            return false;\n        }\n        final PsiExpression operand1 = prefixExp1.getOperand();\n        final PsiExpression operand2 = prefixExp2.getOperand();\n        return expressionsAreEquivalent(operand1, operand2);\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean assignmentExpressionsAreEquivalent(PsiAssignmentExpression assignExp1,\n                                                              PsiAssignmentExpression assignExp2){\n        final PsiJavaToken sign1 = assignExp1.getOperationSign();\n        final PsiJavaToken sign2 = assignExp2.getOperationSign();\n        if(sign1.getTokenType() != sign2.getTokenType()){\n            return false;\n        }\n        final PsiExpression lhs1 = assignExp1.getLExpression();\n        final PsiExpression lhs2 = assignExp2.getLExpression();\n        final PsiExpression rhs1 = assignExp1.getRExpression();\n        final PsiExpression rhs2 = assignExp2.getRExpression();\n        return expressionsAreEquivalent(lhs1, lhs2)\n                       && expressionsAreEquivalent(rhs1, rhs2);\n    }","id":73067,"modified_method":"private static boolean assignmentExpressionsAreEquivalent(PsiAssignmentExpression assignExp1,\n                                                              PsiAssignmentExpression assignExp2){\n        final PsiJavaToken sign1 = assignExp1.getOperationSign();\n        final PsiJavaToken sign2 = assignExp2.getOperationSign();\n        if(!sign1.getTokenType().equals(sign2.getTokenType())){\n            return false;\n        }\n        final PsiExpression lhs1 = assignExp1.getLExpression();\n        final PsiExpression lhs2 = assignExp2.getLExpression();\n        final PsiExpression rhs1 = assignExp1.getRExpression();\n        final PsiExpression rhs2 = assignExp2.getRExpression();\n        return expressionsAreEquivalent(lhs1, lhs2)\n                       && expressionsAreEquivalent(rhs1, rhs2);\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean postfixExpressionsAreEquivalent(PsiPostfixExpression postfixExp1,\n                                                           PsiPostfixExpression postfixExp2){\n        final PsiJavaToken sign1 = postfixExp1.getOperationSign();\n        final PsiJavaToken sign2 = postfixExp2.getOperationSign();\n        if(sign1.getTokenType() != sign2.getTokenType()){\n            return false;\n        }\n        final PsiExpression operand1 = postfixExp1.getOperand();\n        final PsiExpression operand2 = postfixExp2.getOperand();\n        return expressionsAreEquivalent(operand1, operand2);\n    }","id":73068,"modified_method":"private static boolean postfixExpressionsAreEquivalent(PsiPostfixExpression postfixExp1,\n                                                           PsiPostfixExpression postfixExp2){\n        final PsiJavaToken sign1 = postfixExp1.getOperationSign();\n        final PsiJavaToken sign2 = postfixExp2.getOperationSign();\n        if(!sign1.getTokenType().equals(sign2.getTokenType())){\n            return false;\n        }\n        final PsiExpression operand1 = postfixExp1.getOperand();\n        final PsiExpression operand2 = postfixExp2.getOperand();\n        return expressionsAreEquivalent(operand1, operand2);\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean binaryExpressionsAreEquivalent(PsiBinaryExpression binaryExp1,\n                                                          PsiBinaryExpression binaryExp2){\n        final PsiJavaToken sign1 = binaryExp1.getOperationSign();\n        final PsiJavaToken sign2 = binaryExp2.getOperationSign();\n        if(sign1.getTokenType() != sign2.getTokenType()){\n            return false;\n        }\n        final PsiExpression lhs1 = binaryExp1.getLOperand();\n        final PsiExpression lhs2 = binaryExp2.getLOperand();\n        final PsiExpression rhs1 = binaryExp1.getROperand();\n        final PsiExpression rhs2 = binaryExp2.getROperand();\n        return expressionsAreEquivalent(lhs1, lhs2)\n                       && expressionsAreEquivalent(rhs1, rhs2);\n    }","id":73069,"modified_method":"private static boolean binaryExpressionsAreEquivalent(PsiBinaryExpression binaryExp1,\n                                                          PsiBinaryExpression binaryExp2){\n        final PsiJavaToken sign1 = binaryExp1.getOperationSign();\n        final PsiJavaToken sign2 = binaryExp2.getOperationSign();\n        if(!sign1.getTokenType().equals(sign2.getTokenType())){\n            return false;\n        }\n        final PsiExpression lhs1 = binaryExp1.getLOperand();\n        final PsiExpression lhs2 = binaryExp2.getLOperand();\n        final PsiExpression rhs1 = binaryExp1.getROperand();\n        final PsiExpression rhs2 = binaryExp2.getROperand();\n        return expressionsAreEquivalent(lhs1, lhs2)\n                       && expressionsAreEquivalent(rhs1, rhs2);\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement exp){\n        if(!(exp instanceof PsiJavaToken)){\n            return false;\n        }\n        final String text = exp.getText();\n        if(!\"if\".equals(text)){\n            return false;\n        }\n        if(!(exp.getParent() instanceof PsiIfStatement)){\n            return false;\n        }\n        final PsiIfStatement statement = (PsiIfStatement) exp.getParent();\n        return CaseUtil.getCaseExpression(statement) != null;\n    }","id":73070,"modified_method":"public boolean satisfiedBy(PsiElement element){\n        if(!(element instanceof PsiJavaToken)){\n            return false;\n        }\n        final String text = element.getText();\n        if(!\"if\".equals(text)){\n            return false;\n        }\n        if(!(element.getParent() instanceof PsiIfStatement)){\n            return false;\n        }\n        final PsiIfStatement statement = (PsiIfStatement) element.getParent();\n        return CaseUtil.getCaseExpression(statement) != null;\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isFileReadOnly(Project project, PsiFile file){\n        return ReadonlyStatusHandler.getInstance(project)\n                .ensureFilesWritable(new VirtualFile[]{file.getVirtualFile()})\n                .hasReadonlyFiles();\n    }","id":73071,"modified_method":"protected static boolean isFileReadOnly(Project project, PsiFile file){\n        return ReadonlyStatusHandler.getInstance(project)\n                .ensureFilesWritable(new VirtualFile[]{file.getVirtualFile()})\n                .hasReadonlyFiles();\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isMergableImplicitIf(PsiElement element){\n        if(!(element instanceof PsiJavaToken)){\n            return false;\n        }\n        final PsiJavaToken token = (PsiJavaToken) element;\n\n        final PsiElement parent = token.getParent();\n        if(!(parent instanceof PsiIfStatement)){\n            return false;\n        }\n        final PsiIfStatement ifStatement = (PsiIfStatement) parent;\n        final PsiStatement thenBranch = ifStatement.getThenBranch();\n        final PsiStatement elseBranch = ifStatement.getElseBranch();\n        if(thenBranch == null){\n            return false;\n        }\n        if(elseBranch != null){\n            return false;\n        }\n\n        if(ControlFlowUtils.statementMayCompleteNormally(thenBranch)){\n            return false;\n        }\n        final PsiElement nextStatement =\n                PsiTreeUtil.skipSiblingsForward(ifStatement,\n                                                new Class[]{PsiWhiteSpace.class});\n        if(!(nextStatement instanceof PsiIfStatement)){\n            return false;\n        }\n        final PsiIfStatement childIfStatement = (PsiIfStatement) nextStatement;\n        final PsiStatement childThenBranch = childIfStatement.getThenBranch();\n        return EquivalenceChecker.statementsAreEquivalent(thenBranch,\n                                                          childThenBranch);\n    }","id":73072,"modified_method":"private static boolean isMergableImplicitIf(PsiElement element){\n        if(!(element instanceof PsiJavaToken)){\n            return false;\n        }\n        final PsiJavaToken token = (PsiJavaToken) element;\n\n        final PsiElement parent = token.getParent();\n        if(!(parent instanceof PsiIfStatement)){\n            return false;\n        }\n        final PsiIfStatement ifStatement = (PsiIfStatement) parent;\n        final PsiStatement thenBranch = ifStatement.getThenBranch();\n        final PsiStatement elseBranch = ifStatement.getElseBranch();\n        if(thenBranch == null){\n            return false;\n        }\n        if(elseBranch != null){\n            return false;\n        }\n\n        if(ControlFlowUtils.statementMayCompleteNormally(thenBranch)){\n            return false;\n        }\n        final PsiElement nextStatement =\n                PsiTreeUtil.skipSiblingsForward(ifStatement,\n                                                new Class[]{PsiWhiteSpace.class});\n        if(!(nextStatement instanceof PsiIfStatement)){\n            return false;\n        }\n        final PsiIfStatement childIfStatement = (PsiIfStatement) nextStatement;\n        final PsiStatement childThenBranch = childIfStatement.getThenBranch();\n        return EquivalenceChecker.statementsAreEquivalent(thenBranch,\n                                                          childThenBranch);\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String removeParensFromParenthesizedExpression(\n            PsiParenthesizedExpression parenthesizedExp){\n        PsiExpression body = parenthesizedExp.getExpression();\n        while(body instanceof PsiParenthesizedExpression){\n            body = ((PsiParenthesizedExpression) body).getExpression();\n        }\n        if(!(parenthesizedExp.getParent() instanceof PsiExpression)){\n            return removeParentheses(body);\n        }\n        final PsiExpression parentExp =\n                (PsiExpression) parenthesizedExp.getParent();\n        final int parentPrecedence = getPrecendence(parentExp);\n        final int childPrecedence = getPrecendence(body);\n        if(parentPrecedence < childPrecedence){\n            return '(' + removeParentheses(body) + ')';\n        } else if(parentPrecedence == childPrecedence){\n            if(parentExp instanceof PsiBinaryExpression &&\n                                    body instanceof PsiBinaryExpression){\n                final IElementType parentOperator =\n                        ((PsiBinaryExpression) parentExp).getOperationSign()\n                                .getTokenType();\n                final IElementType bodyOperator =\n                        ((PsiBinaryExpression) body).getOperationSign()\n                                .getTokenType();\n\n                final PsiExpression lhs =\n                        ((PsiBinaryExpression) parentExp).getLOperand();\n\n                if(lhs.equals(parenthesizedExp) &&\n                           parentOperator == bodyOperator){\n                    return removeParentheses(body);\n                } else{\n                    return '(' + removeParentheses(body) + ')';\n                }\n            } else{\n                return removeParentheses(body);\n            }\n        } else{\n            return removeParentheses(body);\n        }\n    }","id":73073,"modified_method":"private static String removeParensFromParenthesizedExpression(\n            PsiParenthesizedExpression parenthesizedExp){\n        PsiExpression body = parenthesizedExp.getExpression();\n        while(body instanceof PsiParenthesizedExpression){\n            body = ((PsiParenthesizedExpression) body).getExpression();\n        }\n        if(!(parenthesizedExp.getParent() instanceof PsiExpression)){\n            return removeParentheses(body);\n        }\n        final PsiExpression parentExp =\n                (PsiExpression) parenthesizedExp.getParent();\n        final int parentPrecedence = getPrecendence(parentExp);\n        final int childPrecedence = getPrecendence(body);\n        if(parentPrecedence < childPrecedence){\n            return '(' + removeParentheses(body) + ')';\n        } else if(parentPrecedence == childPrecedence){\n            if(parentExp instanceof PsiBinaryExpression &&\n                                    body instanceof PsiBinaryExpression){\n                final IElementType parentOperator =\n                        ((PsiBinaryExpression) parentExp).getOperationSign()\n                                .getTokenType();\n                final IElementType bodyOperator =\n                        ((PsiBinaryExpression) body).getOperationSign()\n                                .getTokenType();\n\n                final PsiExpression lhs =\n                        ((PsiBinaryExpression) parentExp).getLOperand();\n\n                if(lhs.equals(parenthesizedExp) &&\n                           parentOperator.equals(bodyOperator)){\n                    return removeParentheses(body);\n                } else{\n                    return '(' + removeParentheses(body) + ')';\n                }\n            } else{\n                return removeParentheses(body);\n            }\n        } else{\n            return removeParentheses(body);\n        }\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String removeParenthesesForArrayInitializer(PsiArrayInitializerExpression init){\n        final PsiExpression[] contents = init.getInitializers();\n        final String text = init.getText();\n        final int originalLength = text.length();\n        final StringBuffer out = new StringBuffer(originalLength);\n        out.append(\"{\");\n        for(int i = 0; i < contents.length; i++){\n            final PsiExpression arg = contents[i];\n            if(i != 0){\n                out.append(\",\");\n            }\n            final String strippedArg = removeParentheses(arg);\n            out.append(strippedArg);\n        }\n        out.append(\"}\");\n        return out.toString();\n    }","id":73074,"modified_method":"private static String removeParenthesesForArrayInitializer(PsiArrayInitializerExpression init){\n        final PsiExpression[] contents = init.getInitializers();\n        final String text = init.getText();\n        final int originalLength = text.length();\n        final StringBuffer out = new StringBuffer(originalLength);\n        out.append('{');\n        for(int i = 0; i < contents.length; i++){\n            final PsiExpression arg = contents[i];\n            if(i != 0){\n                out.append(',');\n            }\n            final String strippedArg = removeParentheses(arg);\n            out.append(strippedArg);\n        }\n        out.append('}');\n        return out.toString();\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String removeParenthesesForMethodCall(PsiMethodCallExpression methCall){\n        final PsiReferenceExpression target = methCall.getMethodExpression();\n        final PsiExpressionList argumentList = methCall.getArgumentList();\n        final PsiExpression[] args = argumentList.getExpressions();\n\n        final String text = methCall.getText();\n        final int length = text.length();\n        final StringBuffer out = new StringBuffer(length);\n        final String strippedTarget = removeParentheses(target);\n        out.append(strippedTarget);\n        out.append(\"(\");\n        for(int i = 0; i < args.length; i++){\n            final PsiExpression arg = args[i];\n            if(i != 0){\n                out.append(\",\");\n            }\n            final String strippedArg = removeParentheses(arg);\n            out.append(strippedArg);\n        }\n        out.append(\")\");\n        return out.toString();\n    }","id":73075,"modified_method":"private static String removeParenthesesForMethodCall(PsiMethodCallExpression methCall){\n        final PsiReferenceExpression target = methCall.getMethodExpression();\n        final PsiExpressionList argumentList = methCall.getArgumentList();\n        final PsiExpression[] args = argumentList.getExpressions();\n\n        final String text = methCall.getText();\n        final int length = text.length();\n        final StringBuffer out = new StringBuffer(length);\n        final String strippedTarget = removeParentheses(target);\n        out.append(strippedTarget);\n        out.append('(');\n        for(int i = 0; i < args.length; i++){\n            final PsiExpression arg = args[i];\n            if(i != 0){\n                out.append(',');\n            }\n            final String strippedArg = removeParentheses(arg);\n            out.append(strippedArg);\n        }\n        out.append(')');\n        return out.toString();\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String removeParenthesesForNewExpression(PsiNewExpression newExp){\n        final PsiExpression[] dimensions = newExp.getArrayDimensions();\n        String[] strippedDimensions = null;\n        if(dimensions != null){\n            strippedDimensions = new String[dimensions.length];\n            for(int i = 0; i < dimensions.length; i++){\n                strippedDimensions[i] = removeParentheses(dimensions[i]);\n            }\n        }\n\n        final PsiExpression qualifier = newExp.getQualifier();\n        final PsiExpression arrayInitializer = newExp.getArrayInitializer();\n        String strippedArrayInitializer = null;\n        if(arrayInitializer != null){\n            strippedArrayInitializer = removeParentheses(arrayInitializer);\n        }\n\n        final PsiExpressionList argumentList = newExp.getArgumentList();\n        final PsiExpression[] args = argumentList == null?null:\n                argumentList.getExpressions();\n        String[] strippedArgs = null;\n        if(args != null){\n            strippedArgs = new String[args.length];\n            for(int i = 0; i < args.length; i++){\n                strippedArgs[i] = removeParentheses(args[i]);\n            }\n        }\n        if(qualifier != null){\n            return newExp.getText();\n        }\n        final PsiElement[] children = newExp.getChildren();\n        for(int i = 0; i < children.length; i++){\n            final PsiElement child = children[i];\n            if(child instanceof PsiAnonymousClass){\n                return newExp.getText();\n            }\n        }\n        final StringBuffer out = new StringBuffer(128);\n        out.append(\"new \");\n        final PsiJavaCodeReferenceElement classReference =\n                newExp.getClassReference();\n        final String classReferenceText = classReference.getText();\n        out.append(classReferenceText);\n        if(strippedArgs != null){\n            out.append(\"(\");\n            for(int i = 0; i < strippedArgs.length; i++){\n                if(i != 0){\n                    out.append(\",\");\n                }\n                out.append(strippedArgs[i]);\n            }\n            out.append(\")\");\n        }\n\n        if(strippedDimensions != null){\n            for(int i = 0; i < strippedDimensions.length; i++){\n                out.append(\"[\");\n                out.append(strippedDimensions[i]);\n                out.append(\"]\");\n            }\n        }\n        if(strippedArrayInitializer != null){\n            out.append(strippedArrayInitializer);\n        }\n        return out.toString();\n    }","id":73076,"modified_method":"private static String removeParenthesesForNewExpression(PsiNewExpression newExp){\n        final PsiExpression[] dimensions = newExp.getArrayDimensions();\n        String[] strippedDimensions = null;\n        if(dimensions != null){\n            strippedDimensions = new String[dimensions.length];\n            for(int i = 0; i < dimensions.length; i++){\n                strippedDimensions[i] = removeParentheses(dimensions[i]);\n            }\n        }\n\n        final PsiExpression qualifier = newExp.getQualifier();\n        final PsiExpression arrayInitializer = newExp.getArrayInitializer();\n        String strippedArrayInitializer = null;\n        if(arrayInitializer != null){\n            strippedArrayInitializer = removeParentheses(arrayInitializer);\n        }\n\n        final PsiExpressionList argumentList = newExp.getArgumentList();\n        final PsiExpression[] args = argumentList == null?null:\n                argumentList.getExpressions();\n        String[] strippedArgs = null;\n        if(args != null){\n            strippedArgs = new String[args.length];\n            for(int i = 0; i < args.length; i++){\n                strippedArgs[i] = removeParentheses(args[i]);\n            }\n        }\n        if(qualifier != null){\n            return newExp.getText();\n        }\n        final PsiElement[] children = newExp.getChildren();\n        for(int i = 0; i < children.length; i++){\n            final PsiElement child = children[i];\n            if(child instanceof PsiAnonymousClass){\n                return newExp.getText();\n            }\n        }\n        final StringBuffer out = new StringBuffer(128);\n        out.append(\"new \");\n        final PsiJavaCodeReferenceElement classReference =\n                newExp.getClassReference();\n        final String classReferenceText = classReference.getText();\n        out.append(classReferenceText);\n        if(strippedArgs != null){\n            out.append('(');\n            for(int i = 0; i < strippedArgs.length; i++){\n                if(i != 0){\n                    out.append(',');\n                }\n                out.append(strippedArgs[i]);\n            }\n            out.append(')');\n        }\n\n        if(strippedDimensions != null){\n            for(int i = 0; i < strippedDimensions.length; i++){\n                out.append('[');\n                out.append(strippedDimensions[i]);\n                out.append(']');\n            }\n        }\n        if(strippedArrayInitializer != null){\n            out.append(strippedArrayInitializer);\n        }\n        return out.toString();\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void getValuesFromExpression(PsiBinaryExpression binaryCond,\n                                         PsiExpression caseExpression,\n                                         List values){\n        final PsiExpression lhs = binaryCond.getLOperand();\n        final PsiExpression rhs = binaryCond.getROperand();\n        final PsiJavaToken sign = binaryCond.getOperationSign();\n        if(sign.getTokenType().equals(JavaTokenType.OROR)){\n            getValuesFromExpression((PsiBinaryExpression) lhs, caseExpression,\n                                    values);\n            getValuesFromExpression((PsiBinaryExpression) rhs, caseExpression,\n                                    values);\n        } else{\n            if(EquivalenceChecker.expressionsAreEquivalent(caseExpression,\n                                                           rhs)){\n                values.add(lhs);\n            } else{\n                values.add(rhs);\n            }\n        }\n    }","id":73077,"modified_method":"private void getValuesFromExpression(PsiBinaryExpression binaryCond,\n                                         PsiExpression caseExpression,\n                                         List values){\n        final PsiExpression lhs = binaryCond.getLOperand();\n        final PsiExpression rhs = binaryCond.getROperand();\n        final PsiJavaToken sign = binaryCond.getOperationSign();\n        final IElementType tokenType = sign.getTokenType();\n        if(JavaTokenType.OROR.equals(tokenType)){\n            getValuesFromExpression((PsiBinaryExpression) lhs, caseExpression,\n                                    values);\n            getValuesFromExpression((PsiBinaryExpression) rhs, caseExpression,\n                                    values);\n        } else{\n            if(EquivalenceChecker.expressionsAreEquivalent(caseExpression,\n                                                           rhs)){\n                values.add(lhs);\n            } else{\n                values.add(rhs);\n            }\n        }\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean mayHaveSideEffects(PsiExpression exp){\n        if(exp instanceof PsiThisExpression ||\n                                exp instanceof PsiLiteralExpression ||\n                                exp instanceof PsiClassObjectAccessExpression ||\n                                exp instanceof PsiReferenceExpression ||\n                                exp instanceof PsiSuperExpression){\n            return false;\n        } else if(exp instanceof PsiMethodCallExpression ||\n                                exp instanceof PsiNewExpression ||\n                                exp instanceof PsiAssignmentExpression ||\n                                exp instanceof PsiArrayInitializerExpression){\n            return true;\n        } else if(exp instanceof PsiTypeCastExpression){\n            final PsiExpression body =\n                    ((PsiTypeCastExpression) exp).getOperand();\n            return mayHaveSideEffects(body);\n        } else if(exp instanceof PsiArrayAccessExpression){\n            final PsiArrayAccessExpression arrayAccessExp =\n                    (PsiArrayAccessExpression) exp;\n            final PsiExpression arrayExp = arrayAccessExp.getArrayExpression();\n            final PsiExpression indexExp = arrayAccessExp.getIndexExpression();\n            return mayHaveSideEffects(arrayExp) || mayHaveSideEffects(indexExp);\n        } else if(exp instanceof PsiPrefixExpression){\n            final PsiPrefixExpression prefixExp = (PsiPrefixExpression) exp;\n            final PsiExpression body = prefixExp.getOperand();\n            if(mayHaveSideEffects(body)){\n                return true;\n            }\n            final PsiJavaToken sign = prefixExp.getOperationSign();\n            final IElementType tokenType = sign.getTokenType();\n            return tokenType == JavaTokenType.PLUSPLUS ||\n                           tokenType == JavaTokenType.MINUSMINUS;\n        } else if(exp instanceof PsiPostfixExpression){\n            final PsiPostfixExpression postfixExp = (PsiPostfixExpression) exp;\n            final PsiExpression body = postfixExp.getOperand();\n            if(mayHaveSideEffects(body)){\n                return true;\n            }\n            final PsiJavaToken sign = postfixExp.getOperationSign();\n            final IElementType tokenType = sign.getTokenType();\n            return tokenType == JavaTokenType.PLUSPLUS ||\n                           tokenType == JavaTokenType.MINUSMINUS;\n        } else if(exp instanceof PsiBinaryExpression){\n            final PsiBinaryExpression binaryExp = (PsiBinaryExpression) exp;\n            final PsiExpression lhs = binaryExp.getLOperand();\n            final PsiExpression rhs = binaryExp.getROperand();\n            return mayHaveSideEffects(lhs) ||\n                           mayHaveSideEffects(rhs);\n        } else if(exp instanceof PsiInstanceOfExpression){\n            final PsiExpression body =\n                    ((PsiInstanceOfExpression) exp).getOperand();\n            return mayHaveSideEffects(body);\n        } else if(exp instanceof PsiConditionalExpression){\n            final PsiConditionalExpression conditionalExp =\n                    (PsiConditionalExpression) exp;\n            final PsiExpression condition = conditionalExp.getCondition();\n            final PsiExpression thenBranch = conditionalExp.getThenExpression();\n            final PsiExpression elseBranch = conditionalExp.getElseExpression();\n            return mayHaveSideEffects(condition) ||\n                           mayHaveSideEffects(thenBranch) ||\n                           mayHaveSideEffects(elseBranch);\n        } else if(exp instanceof PsiParenthesizedExpression){\n            final PsiExpression body =\n                    ((PsiParenthesizedExpression) exp).getExpression();\n            return mayHaveSideEffects(body);\n        }\n        return true;   // this shouldn't happen\n    }","id":73078,"modified_method":"public static boolean mayHaveSideEffects(PsiExpression exp){\n        if(exp instanceof PsiThisExpression ||\n                                exp instanceof PsiLiteralExpression ||\n                                exp instanceof PsiClassObjectAccessExpression ||\n                                exp instanceof PsiReferenceExpression ||\n                                exp instanceof PsiSuperExpression){\n            return false;\n        } else if(exp instanceof PsiMethodCallExpression ||\n                                exp instanceof PsiNewExpression ||\n                                exp instanceof PsiAssignmentExpression ||\n                                exp instanceof PsiArrayInitializerExpression){\n            return true;\n        } else if(exp instanceof PsiTypeCastExpression){\n            final PsiExpression body =\n                    ((PsiTypeCastExpression) exp).getOperand();\n            return mayHaveSideEffects(body);\n        } else if(exp instanceof PsiArrayAccessExpression){\n            final PsiArrayAccessExpression arrayAccessExp =\n                    (PsiArrayAccessExpression) exp;\n            final PsiExpression arrayExp = arrayAccessExp.getArrayExpression();\n            final PsiExpression indexExp = arrayAccessExp.getIndexExpression();\n            return mayHaveSideEffects(arrayExp) || mayHaveSideEffects(indexExp);\n        } else if(exp instanceof PsiPrefixExpression){\n            final PsiPrefixExpression prefixExp = (PsiPrefixExpression) exp;\n            final PsiExpression body = prefixExp.getOperand();\n            if(mayHaveSideEffects(body)){\n                return true;\n            }\n            final PsiJavaToken sign = prefixExp.getOperationSign();\n            final IElementType tokenType = sign.getTokenType();\n            return tokenType.equals(JavaTokenType.PLUSPLUS) ||\n                           tokenType.equals(JavaTokenType.MINUSMINUS);\n        } else if(exp instanceof PsiPostfixExpression){\n            final PsiPostfixExpression postfixExp = (PsiPostfixExpression) exp;\n            final PsiExpression body = postfixExp.getOperand();\n            if(mayHaveSideEffects(body)){\n                return true;\n            }\n            final PsiJavaToken sign = postfixExp.getOperationSign();\n            final IElementType tokenType = sign.getTokenType();\n            return tokenType.equals(JavaTokenType.PLUSPLUS) ||\n                           tokenType.equals(JavaTokenType.MINUSMINUS);\n        } else if(exp instanceof PsiBinaryExpression){\n            final PsiBinaryExpression binaryExp = (PsiBinaryExpression) exp;\n            final PsiExpression lhs = binaryExp.getLOperand();\n            final PsiExpression rhs = binaryExp.getROperand();\n            return mayHaveSideEffects(lhs) ||\n                           mayHaveSideEffects(rhs);\n        } else if(exp instanceof PsiInstanceOfExpression){\n            final PsiExpression body =\n                    ((PsiInstanceOfExpression) exp).getOperand();\n            return mayHaveSideEffects(body);\n        } else if(exp instanceof PsiConditionalExpression){\n            final PsiConditionalExpression conditionalExp =\n                    (PsiConditionalExpression) exp;\n            final PsiExpression condition = conditionalExp.getCondition();\n            final PsiExpression thenBranch = conditionalExp.getThenExpression();\n            final PsiExpression elseBranch = conditionalExp.getElseExpression();\n            return mayHaveSideEffects(condition) ||\n                           mayHaveSideEffects(thenBranch) ||\n                           mayHaveSideEffects(elseBranch);\n        } else if(exp instanceof PsiParenthesizedExpression){\n            final PsiExpression body =\n                    ((PsiParenthesizedExpression) exp).getExpression();\n            return mayHaveSideEffects(body);\n        }\n        return true;   // this shouldn't happen\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement exp){\n        if(!(exp instanceof PsiJavaToken)){\n            return false;\n        }\n        final PsiJavaToken token = (PsiJavaToken) exp;\n        final IElementType tokenType = token.getTokenType();\n        return JavaTokenType.SWITCH_KEYWORD.equals(tokenType);\n    }","id":73079,"modified_method":"public boolean satisfiedBy(PsiElement element){\n        if(!(element instanceof PsiJavaToken)){\n            return false;\n        }\n        final PsiJavaToken token = (PsiJavaToken) element;\n        final IElementType tokenType = token.getTokenType();\n        return JavaTokenType.SWITCH_KEYWORD.equals(tokenType);\n    }","commit_id":"b3c7d9ebc18496180400ce93f4c378c619c3c4e7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkIfStatementCondition(PsiIfStatement ifStatement, PsiAssignmentExpression expression) {\n            final PsiExpression condition = ifStatement.getCondition();\n            if (condition != null && condition.equals(expression)) {\n                registerError(expression);\n            }\n        }","id":73080,"modified_method":"private void checkIfStatementCondition(PsiIfStatement ifStatement, PsiAssignmentExpression expression) {\n            final PsiExpression condition = ifStatement.getCondition();\n            if (expression.equals(condition)) {\n                registerError(expression);\n            }\n        }","commit_id":"f956b59ca1dc240bc51197eb46e7d271f502063f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n            super.visitAssignmentExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            if (!sign.getTokenType().equals(JavaTokenType.EQ)) {\n                return;\n            }\n            final PsiElement parent = expression.getParent();\n            if (parent instanceof PsiIfStatement) {\n                checkIfStatementCondition((PsiIfStatement) parent, expression);\n            }\n            if (parent instanceof PsiWhileStatement) {\n                checkWhileStatementCondition((PsiWhileStatement) parent, expression);\n            }\n            if (parent instanceof PsiForStatement) {\n                checkForStatementCondition((PsiForStatement) parent, expression);\n            }\n            if (parent instanceof PsiDoWhileStatement) {\n                checkDoWhileStatementCondition((PsiDoWhileStatement) parent, expression);\n            }\n        }","id":73081,"modified_method":"public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n            super.visitAssignmentExpression(expression);\n            if(!WellFormednessUtils.isWellFormed(expression)){\n                return;\n            }\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            final PsiElement parent = expression.getParent();\n            if(parent == null)\n            {\n                return;\n            }\n            if (parent instanceof PsiIfStatement) {\n                checkIfStatementCondition((PsiIfStatement) parent, expression);\n            }\n            if (parent instanceof PsiWhileStatement) {\n                checkWhileStatementCondition((PsiWhileStatement) parent, expression);\n            }\n            if (parent instanceof PsiForStatement) {\n                checkForStatementCondition((PsiForStatement) parent, expression);\n            }\n            if (parent instanceof PsiDoWhileStatement) {\n                checkDoWhileStatementCondition((PsiDoWhileStatement) parent, expression);\n            }\n        }","commit_id":"f956b59ca1dc240bc51197eb46e7d271f502063f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkWhileStatementCondition(PsiWhileStatement whileStatement, PsiAssignmentExpression expression) {\n            final PsiExpression condition = whileStatement.getCondition();\n            if (condition != null && condition.equals(expression)) {\n                registerError(expression);\n            }\n        }","id":73082,"modified_method":"private void checkWhileStatementCondition(PsiWhileStatement whileStatement, PsiAssignmentExpression expression) {\n            final PsiExpression condition = whileStatement.getCondition();\n            if(expression.equals(condition)){\n                registerError(expression);\n            }\n        }","commit_id":"f956b59ca1dc240bc51197eb46e7d271f502063f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkDoWhileStatementCondition(PsiDoWhileStatement doWhileStatement, PsiAssignmentExpression expression) {\n            final PsiExpression condition = doWhileStatement.getCondition();\n            if (condition != null && condition.equals(expression)) {\n                registerError(expression);\n            }\n        }","id":73083,"modified_method":"private void checkDoWhileStatementCondition(PsiDoWhileStatement doWhileStatement, PsiAssignmentExpression expression) {\n            final PsiExpression condition = doWhileStatement.getCondition();\n            if(expression.equals(condition)){\n                registerError(expression);\n            }\n        }","commit_id":"f956b59ca1dc240bc51197eb46e7d271f502063f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkForStatementCondition(PsiForStatement forStatement, PsiAssignmentExpression expression) {\n            final PsiExpression condition = forStatement.getCondition();\n            if (condition != null && condition.equals(expression)) {\n                registerError(expression);\n            }\n        }","id":73084,"modified_method":"private void checkForStatementCondition(PsiForStatement forStatement, PsiAssignmentExpression expression) {\n            final PsiExpression condition = forStatement.getCondition();\n            if(expression.equals(condition)){\n                registerError(expression);\n            }\n        }","commit_id":"f956b59ca1dc240bc51197eb46e7d271f502063f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            if (!ComparisonUtils.isEqualityComparison(expression)) {\n                return;\n            }\n            final PsiExpression lhs = expression.getLOperand();\n            final PsiExpression rhs = expression.getROperand();\n            if (TypeUtils.expressionHasType(SHORT, lhs) && TypeUtils.expressionHasType(CHAR, rhs)) {\n                registerError(expression);\n            } else if (TypeUtils.expressionHasType(CHAR, lhs) && TypeUtils.expressionHasType(SHORT, rhs)) {\n                registerError(expression);\n            }\n        }","id":73085,"modified_method":"public void visitBinaryExpression(PsiBinaryExpression expression){\n            super.visitBinaryExpression(expression);\n            if(!WellFormednessUtils.isWellFormed(expression)){\n                return;\n            }\n            if(!ComparisonUtils.isEqualityComparison(expression)){\n                return;\n            }\n            final PsiExpression lhs = expression.getLOperand();\n            final PsiExpression rhs = expression.getROperand();\n            if(TypeUtils.expressionHasType(SHORT, lhs) &&\n                    TypeUtils.expressionHasType(CHAR, rhs)){\n                registerError(expression);\n            } else if(TypeUtils.expressionHasType(CHAR, lhs) &&\n                    TypeUtils.expressionHasType(SHORT, rhs)){\n                registerError(expression);\n            }\n        }","commit_id":"f956b59ca1dc240bc51197eb46e7d271f502063f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            final IElementType tokenType = sign.getTokenType();\n            if (!(tokenType.equals(JavaTokenType.EQEQ) ||\n                    tokenType.equals(JavaTokenType.NE))) {\n                return;\n            }\n            final PsiExpression lhs = expression.getLOperand();\n            if (isFloatingPointType(lhs)) {\n                registerError(expression);\n                return;\n            }\n            final PsiExpression rhs = expression.getROperand();\n            if (isFloatingPointType(rhs)) {\n                registerError(expression);\n                return;\n            }\n        }","id":73086,"modified_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            if(!WellFormednessUtils.isWellFormed(expression)){\n                return;\n            }\n            if(!ComparisonUtils.isEqualityComparison(expression))\n            {\n                return;\n            }\n            final PsiExpression lhs = expression.getLOperand();\n            if (isFloatingPointType(lhs)) {\n                registerError(expression);\n                return;\n            }\n            final PsiExpression rhs = expression.getROperand();\n            if (isFloatingPointType(rhs)) {\n                registerError(expression);\n                return;\n            }\n        }","commit_id":"f956b59ca1dc240bc51197eb46e7d271f502063f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            final PsiType expressionType = expression.getType();\n            if (expressionType == null) {\n                return;\n            }\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            final IElementType tokenType = sign.getTokenType();\n            if (!tokenType.equals(JavaTokenType.EQEQ) && !tokenType.equals(JavaTokenType.NE)) {\n                return;\n            }\n            final PsiExpression rhs = expression.getROperand();\n            final PsiExpression strippedRhs = stripExpression(rhs);\n            if (strippedRhs == null) {\n                return;\n            }\n            final PsiExpression lhs = expression.getLOperand();\n            final PsiExpression strippedLhs = stripExpression(lhs);\n            if (strippedLhs == null) {\n                return;\n            }\n            if (isConstantMask(strippedLhs) && isConstant(strippedRhs)) {\n                if (isIncompatibleMask((PsiBinaryExpression) strippedLhs, strippedRhs)) {\n                    registerError(expression);\n                }\n            } else if (isConstantMask(strippedRhs) && isConstant(strippedLhs)) {\n                if (isIncompatibleMask((PsiBinaryExpression) strippedRhs, strippedLhs)) {\n                    registerError(expression);\n                }\n            }\n        }","id":73087,"modified_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            if(!WellFormednessUtils.isWellFormed(expression)){\n                return;\n            }\n            if(!ComparisonUtils.isEqualityComparison(expression)){\n                return;\n            }\n            final PsiType expressionType = expression.getType();\n            if (expressionType == null) {\n                return;\n            }\n            final PsiExpression rhs = expression.getROperand();\n            final PsiExpression strippedRhs = stripExpression(rhs);\n            if (strippedRhs == null) {\n                return;\n            }\n            final PsiExpression lhs = expression.getLOperand();\n            final PsiExpression strippedLhs = stripExpression(lhs);\n            if (strippedLhs == null) {\n                return;\n            }\n            if (isConstantMask(strippedLhs) && isConstant(strippedRhs)) {\n                if (isIncompatibleMask((PsiBinaryExpression) strippedLhs, strippedRhs)) {\n                    registerError(expression);\n                }\n            } else if (isConstantMask(strippedRhs) && isConstant(strippedLhs)) {\n                if (isIncompatibleMask((PsiBinaryExpression) strippedRhs, strippedLhs)) {\n                    registerError(expression);\n                }\n            }\n        }","commit_id":"f956b59ca1dc240bc51197eb46e7d271f502063f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            final IElementType tokenType = sign.getTokenType();\n            if (!tokenType.equals(JavaTokenType.DIV)) {\n                return;\n            }\n            final PsiExpression lhs = expression.getLOperand();\n            if (lhs == null) {\n                return;\n            }\n            final PsiType lhsType = lhs.getType();\n            if (!isIntegral(lhsType)) {\n                return;\n            }\n            final PsiExpression rhs = expression.getROperand();\n            if (rhs == null) {\n                return;\n            }\n            final PsiType rhsType = rhs.getType();\n            if (!isIntegral(rhsType)) {\n                return;\n            }\n            final PsiExpression context = getContainingExpression(expression);\n            if (context == null) {\n                return;\n            }\n            final PsiType contextType = ExpectedTypeUtils.findExpectedType(context);\n            if (contextType == null) {\n                return;\n            }\n            if (!(contextType.equals(PsiType.FLOAT)\n                    || contextType.equals(PsiType.DOUBLE))) {\n                return;\n            }\n            registerError(expression);\n        }","id":73088,"modified_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            if(!WellFormednessUtils.isWellFormed(expression)){\n                return;\n            }\n            final PsiJavaToken sign = expression.getOperationSign();\n            final IElementType tokenType = sign.getTokenType();\n            if (!tokenType.equals(JavaTokenType.DIV)) {\n                return;\n            }\n            final PsiExpression lhs = expression.getLOperand();\n            final PsiType lhsType = lhs.getType();\n            if (!isIntegral(lhsType)) {\n                return;\n            }\n            final PsiExpression rhs = expression.getROperand();\n            final PsiType rhsType = rhs.getType();\n            if (!isIntegral(rhsType)) {\n                return;\n            }\n            final PsiExpression context = getContainingExpression(expression);\n            if (context == null) {\n                return;\n            }\n            final PsiType contextType = ExpectedTypeUtils.findExpectedType(context);\n            if (contextType == null) {\n                return;\n            }\n            if (!(contextType.equals(PsiType.FLOAT)\n                    || contextType.equals(PsiType.DOUBLE))) {\n                return;\n            }\n            registerError(expression);\n        }","commit_id":"f956b59ca1dc240bc51197eb46e7d271f502063f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (sign == null) {\n                return;\n            }\n            final IElementType tokenType = sign.getTokenType();\n            if (!tokenType.equals(JavaTokenType.AND) &&\n                    !tokenType.equals(JavaTokenType.OR)) {\n                return;\n            }\n            final PsiType type = expression.getType();\n            if (type == null) {\n                return;\n            }\n            if (!type.equals(PsiType.BOOLEAN)) {\n                return;\n            }\n            registerError(expression);\n        }","id":73089,"modified_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            if(!WellFormednessUtils.isWellFormed(expression)){\n                return;\n            }\n\n            final PsiJavaToken sign = expression.getOperationSign();\n            final IElementType tokenType = sign.getTokenType();\n            if (!tokenType.equals(JavaTokenType.AND) &&\n                    !tokenType.equals(JavaTokenType.OR)) {\n                return;\n            }\n            final PsiType type = expression.getType();\n            if (type == null) {\n                return;\n            }\n            if (!type.equals(PsiType.BOOLEAN)) {\n                return;\n            }\n            registerError(expression);\n        }","commit_id":"f956b59ca1dc240bc51197eb46e7d271f502063f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isDecimalLiteral(PsiLiteralExpression literal) {\n            final PsiType type = literal.getType();\n            if (type == null) {\n                return false;\n            }\n            if (!type.equals(PsiType.INT) &&\n                    !type.equals(PsiType.LONG)) {\n                return false;\n            }\n            final String text = literal.getText();\n            if (\"0\".equals(text)) {\n                return false;\n            }\n            return text.charAt(0) != '0';\n        }","id":73090,"modified_method":"private static boolean isDecimalLiteral(PsiLiteralExpression literal) {\n            final PsiType type = literal.getType();\n            if (!PsiType.INT.equals(type) &&\n                    !PsiType.LONG.equals(type)) {\n                return false;\n            }\n            final String text = literal.getText();\n            if (\"0\".equals(text)) {\n                return false;\n            }\n            return text.charAt(0) != '0';\n        }","commit_id":"f956b59ca1dc240bc51197eb46e7d271f502063f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isOctalLiteral(PsiLiteralExpression literal) {\n            final PsiType type = literal.getType();\n            if (type == null) {\n                return false;\n            }\n            if (!(type.equals(PsiType.INT)\n                    || type.equals(PsiType.LONG))) {\n                return false;\n            }\n            final String text = literal.getText();\n            if (\"0\".equals(text) || \"0L\".equals(text)) {\n                return false;\n            }\n            return text.charAt(0) == '0' && !text.startsWith(\"0x\") && !text.startsWith(\"0X\");\n        }","id":73091,"modified_method":"private static boolean isOctalLiteral(PsiLiteralExpression literal) {\n            final PsiType type = literal.getType();\n            if (!PsiType.INT.equals(type) && !PsiType.LONG.equals(type)) {\n                return false;\n            }\n            final String text = literal.getText();\n            if (\"0\".equals(text) || \"0L\".equals(text)) {\n                return false;\n            }\n            return text.charAt(0) == '0' && !text.startsWith(\"0x\") && !text.startsWith(\"0X\");\n        }","commit_id":"f956b59ca1dc240bc51197eb46e7d271f502063f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            if (!ComparisonUtils.isEqualityComparison(expression)) {\n                return;\n            }\n            final PsiExpression lhs = expression.getLOperand();\n            if (!isStringType(lhs)) {\n                return;\n            }\n            final PsiExpression rhs = expression.getROperand();\n            if (!isStringType(rhs)) {\n                return;\n            }\n            final String lhsText = lhs.getText();\n            if (\"null\".equals(lhsText)) {\n                return;\n            }\n            final String rhsText = rhs.getText();\n            if (\"null\".equals(rhsText)) {\n                return;\n            }\n            final PsiJavaToken sign = expression.getOperationSign();\n            registerError(sign);\n        }","id":73092,"modified_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            if(!WellFormednessUtils.isWellFormed(expression)){\n                return;\n            }\n            if (!ComparisonUtils.isEqualityComparison(expression)) {\n                return;\n            }\n            final PsiExpression lhs = expression.getLOperand();\n            if (!isStringType(lhs)) {\n                return;\n            }\n            final PsiExpression rhs = expression.getROperand();\n            if (!isStringType(rhs)) {\n                return;\n            }\n            final String lhsText = lhs.getText();\n            if (\"null\".equals(lhsText)) {\n                return;\n            }\n            final String rhsText = rhs.getText();\n            if (\"null\".equals(rhsText)) {\n                return;\n            }\n            final PsiJavaToken sign = expression.getOperationSign();\n            registerError(sign);\n        }","commit_id":"f956b59ca1dc240bc51197eb46e7d271f502063f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(Project project, ProblemDescriptor descriptor) {\n            final PsiElement comparisonToken = descriptor.getPsiElement();\n            boolean negated = false;\n            final PsiBinaryExpression expression =\n                    (PsiBinaryExpression) comparisonToken.getParent();\n            final PsiJavaToken sign = expression.getOperationSign();\n            if (!(sign.getTokenType() != JavaTokenType.NE)) {\n                negated = true;\n            }\n            final PsiExpression lhs = expression.getLOperand();\n            if (lhs == null) {\n                return;\n            }\n            final PsiExpression strippedLhs = ParenthesesUtils.stripParentheses(lhs);\n            final PsiExpression rhs = expression.getROperand();\n            if (rhs == null) {\n                return;\n            }\n            final PsiExpression strippedRhs = ParenthesesUtils.stripParentheses(rhs);\n\n            final String expString;\n            if (ParenthesesUtils.getPrecendence(strippedLhs) > ParenthesesUtils.METHOD_CALL_PRECEDENCE) {\n                expString = '(' + strippedLhs.getText() + \").equals(\" + strippedRhs.getText() + ')';\n            } else {\n                expString = strippedLhs.getText() + \".equals(\" + strippedRhs.getText() + ')';\n            }\n            final String newExpression;\n            if (negated) {\n                newExpression = '!' + expString;\n            } else {\n                newExpression = expString;\n            }\n            replaceExpression(project, expression, newExpression);\n        }","id":73093,"modified_method":"public void applyFix(Project project, ProblemDescriptor descriptor) {\n            final PsiElement comparisonToken = descriptor.getPsiElement();\n            boolean negated = false;\n            final PsiBinaryExpression expression =\n                    (PsiBinaryExpression) comparisonToken.getParent();\n            final PsiJavaToken sign = expression.getOperationSign();\n            final IElementType tokenType = sign.getTokenType();\n            if (tokenType.equals(JavaTokenType.NE)) {\n                negated = true;\n            }\n            final PsiExpression lhs = expression.getLOperand();\n            final PsiExpression strippedLhs = ParenthesesUtils.stripParentheses(lhs);\n            final PsiExpression rhs = expression.getROperand();\n\n            final PsiExpression strippedRhs = ParenthesesUtils.stripParentheses(rhs);\n\n            final String expString;\n            if (ParenthesesUtils.getPrecendence(strippedLhs) > ParenthesesUtils.METHOD_CALL_PRECEDENCE) {\n                expString = '(' + strippedLhs.getText() + \").equals(\" + strippedRhs.getText() + ')';\n            } else {\n                expString = strippedLhs.getText() + \".equals(\" + strippedRhs.getText() + ')';\n            }\n            final String newExpression;\n            if (negated) {\n                newExpression = '!' + expString;\n            } else {\n                newExpression = expString;\n            }\n            replaceExpression(project, expression, newExpression);\n        }","commit_id":"f956b59ca1dc240bc51197eb46e7d271f502063f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitBinaryExpression(PsiBinaryExpression exp) {\n            super.visitBinaryExpression(exp);\n            if (!isSubtraction(exp)) {\n                return;\n            }\n            final PsiMethod method =\n                    (PsiMethod) PsiTreeUtil.getParentOfType(exp, PsiMethod.class);\n            if (!isCompareTo(method)) {\n                return;\n            }\n            registerError(exp);\n        }","id":73094,"modified_method":"public void visitBinaryExpression(PsiBinaryExpression exp) {\n            super.visitBinaryExpression(exp);\n            if(!WellFormednessUtils.isWellFormed(exp)){\n                return;\n            }\n            if (!isSubtraction(exp)) {\n                return;\n            }\n            final PsiMethod method =\n                    (PsiMethod) PsiTreeUtil.getParentOfType(exp, PsiMethod.class);\n            if (!isCompareTo(method)) {\n                return;\n            }\n            registerError(exp);\n        }","commit_id":"f956b59ca1dc240bc51197eb46e7d271f502063f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitPrefixExpression(PsiPrefixExpression expression) {\n        super.visitPrefixExpression(expression);\n        final PsiJavaToken sign = expression.getOperationSign();\n        if (sign == null) {\n            return;\n        }\n        if (sign.getTokenType() == JavaTokenType.EXCL) {\n            m_count++;\n        }\n    }","id":73095,"modified_method":"public void visitPrefixExpression(PsiPrefixExpression expression) {\n        super.visitPrefixExpression(expression);\n        final PsiJavaToken sign = expression.getOperationSign();\n        if (sign == null) {\n            return;\n        }\n        if (sign.getTokenType().equals(JavaTokenType.EXCL)) {\n            m_count++;\n        }\n    }","commit_id":"7fcb59d194a29944fac2979554811c25a76dd2a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n        super.visitBinaryExpression(expression);\n        final PsiJavaToken sign = expression.getOperationSign();\n        if (sign == null) {\n            return;\n        }\n        if (sign.getTokenType() == JavaTokenType.NE) {\n            m_count++;\n        }\n    }","id":73096,"modified_method":"public void visitBinaryExpression(PsiBinaryExpression expression) {\n        super.visitBinaryExpression(expression);\n        final PsiJavaToken sign = expression.getOperationSign();\n        if (sign == null) {\n            return;\n        }\n        if (!(sign.getTokenType() != JavaTokenType.NE)) {\n            m_count++;\n        }\n    }","commit_id":"7fcb59d194a29944fac2979554811c25a76dd2a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitMethod(PsiMethod method) {\n            // note: no call to super\n            if (method.getParameterList().getParameters().length <= getLimit()) {\n                return;\n            }\n\n            final PsiMethod[] superMethods = PsiSuperMethodUtil.findSuperMethods(method);\n            for (int i = 0; i < superMethods.length; i++) {\n                final PsiMethod superMethod = superMethods[i];\n                final PsiClass containingClass = superMethod.getContainingClass();\n                if (containingClass != null) {\n                    if (LibraryUtil.classIsInLibrary(containingClass)) {\n                        return;\n                    }\n                }\n            }\n            registerMethodError(method);\n        }","id":73097,"modified_method":"public void visitMethod(PsiMethod method) {\n            // note: no call to super\n            final PsiParameterList parameterList = method.getParameterList();\n            if(parameterList == null)\n            {\n                return;\n            }\n            final PsiParameter[] parameters = parameterList.getParameters();\n            if(parameters== null)\n            {\n                return;\n            }\n            if (parameters.length <= getLimit()) {\n                return;\n            }\n\n            final PsiMethod[] superMethods = PsiSuperMethodUtil.findSuperMethods(method);\n            for (int i = 0; i < superMethods.length; i++) {\n                final PsiMethod superMethod = superMethods[i];\n                final PsiClass containingClass = superMethod.getContainingClass();\n                if (containingClass != null) {\n                    if (LibraryUtil.classIsInLibrary(containingClass)) {\n                        return;\n                    }\n                }\n            }\n            registerMethodError(method);\n        }","commit_id":"7fcb59d194a29944fac2979554811c25a76dd2a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Creates new instance of {@link org.jetbrains.jet.cli.jvm.compiler.CompileEnvironmentConfiguration} instance using the arguments specified.\n     *\n     * @param stdlib    path to \"kotlin-runtime.jar\", only used if not null and not empty\n     * @param classpath compilation classpath, only used if not null and not empty\n     *\n     * @return compile environment instance\n     */\n    private CompileEnvironmentConfiguration env( String stdlib, String[] classpath ) {\n        CompilerDependencies dependencies = CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR);\n        JetCoreEnvironment environment = new JetCoreEnvironment(CompileEnvironmentUtil.createMockDisposable(), dependencies);\n        CompileEnvironmentConfiguration env = new CompileEnvironmentConfiguration(environment, dependencies, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);\n\n        if (( stdlib != null ) && ( stdlib.trim().length() > 0 )) {\n            File file = new File(stdlib);\n            CompileEnvironmentUtil.addToClasspath(env.getEnvironment(), file);\n        }\n\n        if (( classpath != null ) && ( classpath.length > 0 )) {\n            CompileEnvironmentUtil.addToClasspath(env.getEnvironment(), classpath);\n        }\n\n        // lets register any compiler plugins\n        env.getCompilerPlugins().addAll(getCompilerPlugins());\n\n        return env;\n    }","id":73098,"modified_method":"/**\n     * Creates new instance of {@link org.jetbrains.jet.cli.jvm.compiler.CompileEnvironmentConfiguration} instance using the arguments specified.\n     *\n     * @param stdlib    path to \"kotlin-runtime.jar\", only used if not null and not empty\n     * @param classpath compilation classpath, only used if not null and not empty\n     *\n     * @return compile environment instance\n     */\n    private CompileEnvironmentConfiguration env( String stdlib, String[] classpath ) {\n        CompilerDependencies dependencies = CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR);\n        JetCoreEnvironment environment = JetCoreEnvironment.getCoreEnvironmentForJVM(CompileEnvironmentUtil.createMockDisposable(), dependencies);\n        CompileEnvironmentConfiguration env = new CompileEnvironmentConfiguration(environment, dependencies, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);\n\n        if (( stdlib != null ) && ( stdlib.trim().length() > 0 )) {\n            File file = new File(stdlib);\n            CompileEnvironmentUtil.addToClasspath(env.getEnvironment(), file);\n        }\n\n        if (( classpath != null ) && ( classpath.length > 0 )) {\n            CompileEnvironmentUtil.addToClasspath(env.getEnvironment(), classpath);\n        }\n\n        // lets register any compiler plugins\n        env.getCompilerPlugins().addAll(getCompilerPlugins());\n\n        return env;\n    }","commit_id":"66e10a18a34e7ae2911e9aaf92c15782da925ae5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static List<Module> loadModuleScript(String moduleScriptFile, MessageCollector messageCollector) {\n        Disposable disposable = new Disposable() {\n            @Override\n            public void dispose() {\n\n            }\n        };\n        CompilerDependencies dependencies = CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR);\n        JetCoreEnvironment scriptEnvironment = new JetCoreEnvironment(disposable, dependencies);\n        ensureRuntime(scriptEnvironment, dependencies);\n        scriptEnvironment.addSources(moduleScriptFile);\n\n        GenerationState generationState = KotlinToJVMBytecodeCompiler\n                .analyzeAndGenerate(new CompileEnvironmentConfiguration(scriptEnvironment, dependencies, messageCollector), false);\n        if (generationState == null) {\n            return null;\n        }\n\n        List<Module> modules = runDefineModules(dependencies, moduleScriptFile, generationState.getFactory());\n\n        Disposer.dispose(disposable);\n\n        if (modules == null) {\n            throw new CompileEnvironmentException(\"Module script \" + moduleScriptFile + \" compilation failed\");\n        }\n\n        if (modules.isEmpty()) {\n            throw new CompileEnvironmentException(\"No modules where defined by \" + moduleScriptFile);\n        }\n        return modules;\n    }","id":73099,"modified_method":"public static List<Module> loadModuleScript(String moduleScriptFile, MessageCollector messageCollector) {\n        Disposable disposable = new Disposable() {\n            @Override\n            public void dispose() {\n\n            }\n        };\n        CompilerDependencies dependencies = CompilerDependencies.compilerDependenciesForProduction(CompilerSpecialMode.REGULAR);\n        JetCoreEnvironment scriptEnvironment = JetCoreEnvironment.getCoreEnvironmentForJVM(disposable, dependencies);\n        ensureRuntime(scriptEnvironment, dependencies);\n        scriptEnvironment.addSources(moduleScriptFile);\n\n        GenerationState generationState = KotlinToJVMBytecodeCompiler\n                .analyzeAndGenerate(new CompileEnvironmentConfiguration(scriptEnvironment, dependencies, messageCollector), false);\n        if (generationState == null) {\n            return null;\n        }\n\n        List<Module> modules = runDefineModules(dependencies, moduleScriptFile, generationState.getFactory());\n\n        Disposer.dispose(disposable);\n\n        if (modules == null) {\n            throw new CompileEnvironmentException(\"Module script \" + moduleScriptFile + \" compilation failed\");\n        }\n\n        if (modules.isEmpty()) {\n            throw new CompileEnvironmentException(\"No modules where defined by \" + moduleScriptFile);\n        }\n        return modules;\n    }","commit_id":"66e10a18a34e7ae2911e9aaf92c15782da925ae5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void testMe() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        String text = \"import org.jetbrains.jet.codegen.CompileTextTest; fun x() = CompileTextTest()\";\n        CompilerDependencies dependencies = CompileCompilerDependenciesTest.compilerDependenciesForTests(CompilerSpecialMode.REGULAR, false);\n        JetCoreEnvironment environment = new JetCoreEnvironment(CompileEnvironmentUtil.createMockDisposable(), dependencies);\n        CompileEnvironmentConfiguration configuration = new CompileEnvironmentConfiguration(environment, dependencies, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);\n        configuration.getEnvironment().addToClasspathFromClassLoader(getClass().getClassLoader());\n        ClassLoader classLoader = KotlinToJVMBytecodeCompiler.compileText(configuration, text);\n        Class<?> namespace = classLoader.loadClass(\"namespace\");\n        Method x = namespace.getDeclaredMethod(\"x\");\n        Object invoke = x.invoke(null);\n        assertTrue(invoke instanceof CompileTextTest);\n    }","id":73100,"modified_method":"public void testMe() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        String text = \"import org.jetbrains.jet.codegen.CompileTextTest; fun x() = CompileTextTest()\";\n        CompilerDependencies dependencies = CompileCompilerDependenciesTest.compilerDependenciesForTests(CompilerSpecialMode.REGULAR, false);\n        JetCoreEnvironment environment = JetCoreEnvironment.getCoreEnvironmentForJVM(CompileEnvironmentUtil.createMockDisposable(), dependencies);\n        CompileEnvironmentConfiguration configuration = new CompileEnvironmentConfiguration(environment, dependencies, MessageCollector.PLAIN_TEXT_TO_SYSTEM_ERR);\n        configuration.getEnvironment().addToClasspathFromClassLoader(getClass().getClassLoader());\n        ClassLoader classLoader = KotlinToJVMBytecodeCompiler.compileText(configuration, text);\n        Class<?> namespace = classLoader.loadClass(\"namespace\");\n        Method x = namespace.getDeclaredMethod(\"x\");\n        Object invoke = x.invoke(null);\n        assertTrue(invoke instanceof CompileTextTest);\n    }","commit_id":"66e10a18a34e7ae2911e9aaf92c15782da925ae5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public JetCoreEnvironment(Disposable parentDisposable, @NotNull CompilerDependencies compilerDependencies) {\n        super(parentDisposable);\n        registerFileType(JetFileType.INSTANCE, \"kt\");\n        registerFileType(JetFileType.INSTANCE, \"kts\");\n        registerFileType(JetFileType.INSTANCE, \"ktm\");\n        registerFileType(JetFileType.INSTANCE, \"jet\");\n        registerParserDefinition(new JavaParserDefinition());\n        registerParserDefinition(new JetParserDefinition());\n\n\n        myProject.registerService(JetFilesProvider.class, new CliJetFilesProvider(this));\n        Extensions.getArea(myProject)\n                .getExtensionPoint(PsiElementFinder.EP_NAME)\n                .registerExtension(new JavaElementFinder(myProject));\n\n        CompilerSpecialMode compilerSpecialMode = compilerDependencies.getCompilerSpecialMode();\n\n        addToClasspath(compilerDependencies.getJdkJar());\n\n        if (compilerSpecialMode.includeJdkHeaders()) {\n            for (VirtualFile root : compilerDependencies.getJdkHeaderRoots()) {\n                addLibraryRoot(root);\n            }\n        }\n        if (compilerSpecialMode.includeKotlinRuntime()) {\n            for (VirtualFile root : compilerDependencies.getRuntimeRoots()) {\n                addLibraryRoot(root);\n            }\n        }\n\n        JetStandardLibrary.initialize(getProject());\n    }","id":73101,"modified_method":"private JetCoreEnvironment(Disposable parentDisposable) {\n        super(parentDisposable);\n        registerFileType(JetFileType.INSTANCE, \"kt\");\n        registerFileType(JetFileType.INSTANCE, \"kts\");\n        registerFileType(JetFileType.INSTANCE, \"ktm\");\n        registerFileType(JetFileType.INSTANCE, \"jet\");\n        registerParserDefinition(new JavaParserDefinition());\n        registerParserDefinition(new JetParserDefinition());\n\n\n        myProject.registerService(JetFilesProvider.class, new CliJetFilesProvider(this));\n        Extensions.getArea(myProject)\n                .getExtensionPoint(PsiElementFinder.EP_NAME)\n                .registerExtension(new JavaElementFinder(myProject));\n\n        JetStandardLibrary.initialize(getProject());\n    }","commit_id":"66e10a18a34e7ae2911e9aaf92c15782da925ae5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static JetCoreEnvironment createEnvironmentWithMockJdk(Disposable disposable, @NotNull CompilerSpecialMode compilerSpecialMode) {\n        return new JetCoreEnvironment(disposable, CompileCompilerDependenciesTest.compilerDependenciesForTests(compilerSpecialMode, true));\n    }","id":73102,"modified_method":"public static JetCoreEnvironment createEnvironmentWithMockJdk(Disposable disposable, @NotNull CompilerSpecialMode compilerSpecialMode) {\n        return JetCoreEnvironment.getCoreEnvironmentForJVM(disposable, CompileCompilerDependenciesTest\n                .compilerDependenciesForTests(compilerSpecialMode, true));\n    }","commit_id":"66e10a18a34e7ae2911e9aaf92c15782da925ae5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Executes the compiler on the parsed arguments\n     */\n    @NotNull\n    @Override\n    public ExitCode exec(final PrintStream errStream, K2JVMCompilerArguments arguments) {\n        if (arguments.help) {\n            usage(errStream);\n            return OK;\n        }\n        System.setProperty(\"java.awt.headless\", \"true\");\n\n        final MessageRenderer messageRenderer = arguments.tags ? MessageRenderer.TAGS : MessageRenderer.PLAIN;\n\n        errStream.print(messageRenderer.renderPreamble());\n\n        try {\n            if (arguments.version) {\n                errStream.println(messageRenderer\n                                          .render(CompilerMessageSeverity.INFO, \"Kotlin Compiler version \" + K2JVMCompilerVersion.VERSION,\n                                                  CompilerMessageLocation.NO_LOCATION));\n            }\n\n            CompilerSpecialMode mode = parseCompilerSpecialMode(arguments);\n\n            File jdkHeadersJar;\n            if (mode.includeJdkHeaders()) {\n                if (arguments.jdkHeaders != null) {\n                    jdkHeadersJar = new File(arguments.jdkHeaders);\n                }\n                else {\n                    jdkHeadersJar = PathUtil.getAltHeadersPath();\n                }\n            }\n            else {\n                jdkHeadersJar = null;\n            }\n            File runtimeJar;\n\n            if (mode.includeKotlinRuntime()) {\n                if (arguments.stdlib != null) {\n                    runtimeJar = new File(arguments.stdlib);\n                }\n                else {\n                    runtimeJar = PathUtil.getDefaultRuntimePath();\n                }\n            }\n            else {\n                runtimeJar = null;\n            }\n\n            CompilerDependencies dependencies = new CompilerDependencies(mode, CompilerDependencies.findRtJar(), jdkHeadersJar, runtimeJar);\n            PrintingMessageCollector messageCollector = new PrintingMessageCollector(errStream, messageRenderer, arguments.verbose);\n            Disposable rootDisposable = CompileEnvironmentUtil.createMockDisposable();\n\n            JetCoreEnvironment environment = new JetCoreEnvironment(rootDisposable, dependencies);\n            CompileEnvironmentConfiguration configuration =\n                    new CompileEnvironmentConfiguration(environment, dependencies, messageCollector);\n\n            messageCollector.report(CompilerMessageSeverity.LOGGING, \"Configuring the compilation environment\",\n                                    CompilerMessageLocation.NO_LOCATION);\n            try {\n                configureEnvironment(configuration, arguments);\n\n                boolean noErrors;\n                if (arguments.module != null) {\n                    List<Module> modules = CompileEnvironmentUtil\n                            .loadModuleScript(arguments.module, new PrintingMessageCollector(errStream, messageRenderer, false));\n                    File directory = new File(arguments.module).getParentFile();\n                    noErrors = KotlinToJVMBytecodeCompiler.compileModules(configuration, modules,\n                                                                          directory, arguments.jar, arguments.outputDir,\n                                                                          arguments.includeRuntime);\n                }\n                else {\n                    // TODO ideally we'd unify to just having a single field that supports multiple files/dirs\n                    if (arguments.getSourceDirs() != null) {\n                        noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSourceDirectories(configuration,\n                                                                                               arguments.getSourceDirs(), arguments.jar,\n                                                                                               arguments.outputDir,\n                                                                                               arguments.includeRuntime);\n                    }\n                    else {\n                        noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSources(configuration,\n                                                                                     arguments.src, arguments.jar, arguments.outputDir,\n                                                                                     arguments.includeRuntime);\n                    }\n                }\n                return noErrors ? OK : COMPILATION_ERROR;\n            }\n            catch (CompilationException e) {\n                messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(e),\n                                        MessageUtil.psiElementToMessageLocation(e.getElement()));\n                return INTERNAL_ERROR;\n            }\n            catch (Throwable t) {\n                messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(t),\n                                        CompilerMessageLocation.NO_LOCATION);\n                return INTERNAL_ERROR;\n            }\n            finally {\n                Disposer.dispose(rootDisposable);\n                messageCollector.printToErrStream();\n            }\n        }\n        finally {\n            errStream.print(messageRenderer.renderConclusion());\n        }\n    }","id":73103,"modified_method":"/**\n     * Executes the compiler on the parsed arguments\n     */\n    @NotNull\n    @Override\n    public ExitCode exec(final PrintStream errStream, K2JVMCompilerArguments arguments) {\n        if (arguments.help) {\n            usage(errStream);\n            return OK;\n        }\n        System.setProperty(\"java.awt.headless\", \"true\");\n\n        final MessageRenderer messageRenderer = arguments.tags ? MessageRenderer.TAGS : MessageRenderer.PLAIN;\n\n        errStream.print(messageRenderer.renderPreamble());\n\n        try {\n            if (arguments.version) {\n                errStream.println(messageRenderer\n                                          .render(CompilerMessageSeverity.INFO, \"Kotlin Compiler version \" + K2JVMCompilerVersion.VERSION,\n                                                  CompilerMessageLocation.NO_LOCATION));\n            }\n\n            CompilerSpecialMode mode = parseCompilerSpecialMode(arguments);\n\n            File jdkHeadersJar;\n            if (mode.includeJdkHeaders()) {\n                if (arguments.jdkHeaders != null) {\n                    jdkHeadersJar = new File(arguments.jdkHeaders);\n                }\n                else {\n                    jdkHeadersJar = PathUtil.getAltHeadersPath();\n                }\n            }\n            else {\n                jdkHeadersJar = null;\n            }\n            File runtimeJar;\n\n            if (mode.includeKotlinRuntime()) {\n                if (arguments.stdlib != null) {\n                    runtimeJar = new File(arguments.stdlib);\n                }\n                else {\n                    runtimeJar = PathUtil.getDefaultRuntimePath();\n                }\n            }\n            else {\n                runtimeJar = null;\n            }\n\n            CompilerDependencies dependencies = new CompilerDependencies(mode, CompilerDependencies.findRtJar(), jdkHeadersJar, runtimeJar);\n            PrintingMessageCollector messageCollector = new PrintingMessageCollector(errStream, messageRenderer, arguments.verbose);\n            Disposable rootDisposable = CompileEnvironmentUtil.createMockDisposable();\n\n            JetCoreEnvironment environment = JetCoreEnvironment.getCoreEnvironmentForJVM(rootDisposable, dependencies);\n            CompileEnvironmentConfiguration configuration =\n                    new CompileEnvironmentConfiguration(environment, dependencies, messageCollector);\n\n            messageCollector.report(CompilerMessageSeverity.LOGGING, \"Configuring the compilation environment\",\n                                    CompilerMessageLocation.NO_LOCATION);\n            try {\n                configureEnvironment(configuration, arguments);\n\n                boolean noErrors;\n                if (arguments.module != null) {\n                    List<Module> modules = CompileEnvironmentUtil\n                            .loadModuleScript(arguments.module, new PrintingMessageCollector(errStream, messageRenderer, false));\n                    File directory = new File(arguments.module).getParentFile();\n                    noErrors = KotlinToJVMBytecodeCompiler.compileModules(configuration, modules,\n                                                                          directory, arguments.jar, arguments.outputDir,\n                                                                          arguments.includeRuntime);\n                }\n                else {\n                    // TODO ideally we'd unify to just having a single field that supports multiple files/dirs\n                    if (arguments.getSourceDirs() != null) {\n                        noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSourceDirectories(configuration,\n                                                                                               arguments.getSourceDirs(), arguments.jar,\n                                                                                               arguments.outputDir,\n                                                                                               arguments.includeRuntime);\n                    }\n                    else {\n                        noErrors = KotlinToJVMBytecodeCompiler.compileBunchOfSources(configuration,\n                                                                                     arguments.src, arguments.jar, arguments.outputDir,\n                                                                                     arguments.includeRuntime);\n                    }\n                }\n                return noErrors ? OK : COMPILATION_ERROR;\n            }\n            catch (CompilationException e) {\n                messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(e),\n                                        MessageUtil.psiElementToMessageLocation(e.getElement()));\n                return INTERNAL_ERROR;\n            }\n            catch (Throwable t) {\n                messageCollector.report(CompilerMessageSeverity.EXCEPTION, MessageRenderer.PLAIN.renderException(t),\n                                        CompilerMessageLocation.NO_LOCATION);\n                return INTERNAL_ERROR;\n            }\n            finally {\n                Disposer.dispose(rootDisposable);\n                messageCollector.printToErrStream();\n            }\n        }\n        finally {\n            errStream.print(messageRenderer.renderConclusion());\n        }\n    }","commit_id":"66e10a18a34e7ae2911e9aaf92c15782da925ae5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public static ClassFileFactory compileModule(\n            CompileEnvironmentConfiguration configuration,\n            Module moduleBuilder,\n            File directory\n    ) {\n        if (moduleBuilder.getSourceFiles().isEmpty()) {\n            throw new CompileEnvironmentException(\"No source files where defined\");\n        }\n\n        for (String sourceFile : moduleBuilder.getSourceFiles()) {\n            File source = new File(sourceFile);\n            if (!source.isAbsolute()) {\n                source = new File(directory, sourceFile);\n            }\n\n            if (!source.exists()) {\n                throw new CompileEnvironmentException(\"'\" + source + \"' does not exist\");\n            }\n\n            configuration.getEnvironment().addSources(source.getPath());\n        }\n        for (String classpathRoot : moduleBuilder.getClasspathRoots()) {\n            configuration.getEnvironment().addToClasspath(new File(classpathRoot));\n        }\n\n        CompileEnvironmentUtil.ensureRuntime(configuration.getEnvironment(), configuration.getCompilerDependencies());\n\n        GenerationState generationState = analyzeAndGenerate(configuration);\n        if (generationState == null) {\n            return null;\n        }\n        return generationState.getFactory();\n    }","id":73104,"modified_method":"@Nullable\n    public static ClassFileFactory compileModule(\n            CompileEnvironmentConfiguration configuration,\n            Module moduleBuilder,\n            File directory\n    ) {\n        if (moduleBuilder.getSourceFiles().isEmpty()) {\n            throw new CompileEnvironmentException(\"No source files where defined\");\n        }\n\n        CompileEnvironmentUtil.addSourcesFromModuleToEnvironment(configuration.getEnvironment(), moduleBuilder, directory);\n        for (String classpathRoot : moduleBuilder.getClasspathRoots()) {\n            configuration.getEnvironment().addToClasspath(new File(classpathRoot));\n        }\n\n        CompileEnvironmentUtil.ensureRuntime(configuration.getEnvironment(), configuration.getCompilerDependencies());\n\n        GenerationState generationState = analyzeAndGenerate(configuration);\n        if (generationState == null) {\n            return null;\n        }\n        return generationState.getFactory();\n    }","commit_id":"66e10a18a34e7ae2911e9aaf92c15782da925ae5","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static CharSequence generateText() throws IOException {\n        CompilerConfiguration configuration = new CompilerConfiguration();\n        configuration.add(CLASSPATH_KEY, PathUtil.findRtJar());\n\n        JetCoreEnvironment coreEnvironment = new JetCoreEnvironment(CompileEnvironmentUtil.createMockDisposable(), configuration);\n\n        StringBuilder buf = new StringBuilder();\n        Printer printer = new Printer(buf);\n\n        printer.print(FileUtil.loadFile(new File(\"injector-generator/copyright.txt\")))\n                .println()\n                .println(\"package org.jetbrains.jet.lang.resolve.java.kotlinSignature;\")\n                .println()\n                .println(\"import com.google.common.collect.ImmutableMultimap;\")\n                .println()\n                .println(\"import static org.jetbrains.jet.lang.resolve.java.kotlinSignature.JavaToKotlinMethodMap.*;\")\n                .println()\n                .println(\"/* This file is generated by \", GenerateJavaToKotlinMethodMap.class.getName(), \". DO NOT EDIT! */\")\n                .println(\"@SuppressWarnings(\\\"unchecked\\\")\")\n                .println(\"class JavaToKotlinMethodMapGenerated {\").pushIndent()\n                .println(\"final ImmutableMultimap<String, JavaToKotlinMethodMap.ClassData> map;\")\n                .println()\n                .println(\"JavaToKotlinMethodMapGenerated() {\").pushIndent()\n                .println(\"ImmutableMultimap.Builder<String, JavaToKotlinMethodMap.ClassData> b = ImmutableMultimap.builder();\")\n                .println();\n\n        MyMapBuilder builder = new MyMapBuilder(coreEnvironment.getProject());\n        printer.printWithNoIndent(builder.toString());\n\n        printer.println(\"map = b.build();\");\n        printer.popIndent().println(\"}\");\n        printer.popIndent().println(\"}\");\n        return buf;\n    }","id":73105,"modified_method":"public static CharSequence generateText() throws IOException {\n        CompilerConfiguration configuration = new CompilerConfiguration();\n        configuration.add(CLASSPATH_KEY, PathUtil.findRtJar());\n\n        Disposable disposable = CompileEnvironmentUtil.createMockDisposable();\n        try {\n            JetCoreEnvironment coreEnvironment = new JetCoreEnvironment(disposable, configuration);\n\n            StringBuilder buf = new StringBuilder();\n            Printer printer = new Printer(buf);\n\n            printer.print(FileUtil.loadFile(new File(\"injector-generator/copyright.txt\")))\n                    .println()\n                    .println(\"package org.jetbrains.jet.lang.resolve.java.kotlinSignature;\")\n                    .println()\n                    .println(\"import com.google.common.collect.ImmutableMultimap;\")\n                    .println()\n                    .println(\"import static org.jetbrains.jet.lang.resolve.java.kotlinSignature.JavaToKotlinMethodMap.*;\")\n                    .println()\n                    .println(\"/* This file is generated by \", GenerateJavaToKotlinMethodMap.class.getName(), \". DO NOT EDIT! */\")\n                    .println(\"@SuppressWarnings(\\\"unchecked\\\")\")\n                    .println(\"class JavaToKotlinMethodMapGenerated {\").pushIndent()\n                    .println(\"final ImmutableMultimap<String, JavaToKotlinMethodMap.ClassData> map;\")\n                    .println()\n                    .println(\"JavaToKotlinMethodMapGenerated() {\").pushIndent()\n                    .println(\"ImmutableMultimap.Builder<String, JavaToKotlinMethodMap.ClassData> b = ImmutableMultimap.builder();\")\n                    .println();\n\n            MyMapBuilder builder = new MyMapBuilder(coreEnvironment.getProject());\n            printer.printWithNoIndent(builder.toString());\n\n            printer.println(\"map = b.build();\");\n            printer.popIndent().println(\"}\");\n            printer.popIndent().println(\"}\");\n            return buf;\n        }\n        finally {\n            Disposer.dispose(disposable);\n        }\n\n    }","commit_id":"c94f97bf577c6c854f73083da713db68aac7c49f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void addTypeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addTypeButtonActionPerformed\n        String newMime = userTypeTextField.getText();\n        if (newMime.isEmpty()) {\n            mimeErrLabel.setForeground(Color.red);\n            mimeErrLabel.setText(NbBundle.getMessage(this.getClass(), \"FileExtMismatchConfigPanel.addTypeButton.empty\"));\n            return;\n        }\n        if (newMime.equals(\"application/octet-stream\")) { //NON-NLS\n            mimeErrLabel.setForeground(Color.red);\n            mimeErrLabel.setText(NbBundle.getMessage(this.getClass(),\n                    \"FileExtMismatchConfigPanel.addTypeButton.mimeTypeNotSupported\"));\n            return;\n        }\n        if (mimeList.contains(newMime)) {\n            mimeErrLabel.setForeground(Color.red);\n            mimeErrLabel.setText(\n                    NbBundle.getMessage(this.getClass(), \"FileExtMismatchConfigPanel.addTypeButton.mimeTypeExists\"));\n            return;\n        }\n\n        if (!FileTypeIdIngestModule.isMimeTypeDetectable(newMime)) {\n            mimeErrLabel.setForeground(Color.red);\n            mimeErrLabel.setText(NbBundle.getMessage(this.getClass(),\n                    \"FileExtMismatchConfigPanel.addTypeButton.mimeTypeNotDetectable\"));\n            return;\n        }\n\n        editableMap.put(newMime, new String[0]);\n\n        // Refresh table\n        updateMimeList();\n        mimeTableModel.resync();\n\n        // user feedback for successful add\n        //selectByMimeString(newMime);\n        mimeErrLabel.setForeground(Color.blue);\n        mimeErrLabel.setText(\n                NbBundle.getMessage(this.getClass(), \"FileExtMismatchConfigPanel.addTypeButton.mimeTypeAdded\", newMime));\n        mimeRemoveErrLabel.setText(\" \");\n        userTypeTextField.setText(\"\");\n        setIsModified();\n    }","id":73106,"modified_method":"private void addTypeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addTypeButtonActionPerformed\n        String newMime = userTypeTextField.getText();\n        if (newMime.isEmpty()) {\n            mimeErrLabel.setForeground(Color.red);\n            mimeErrLabel.setText(NbBundle.getMessage(this.getClass(), \"FileExtMismatchConfigPanel.addTypeButton.empty\"));\n            return;\n        }\n        if (newMime.equals(\"application/octet-stream\")) { //NON-NLS\n            mimeErrLabel.setForeground(Color.red);\n            mimeErrLabel.setText(NbBundle.getMessage(this.getClass(),\n                    \"FileExtMismatchConfigPanel.addTypeButton.mimeTypeNotSupported\"));\n            return;\n        }\n        if (mimeList.contains(newMime)) {\n            mimeErrLabel.setForeground(Color.red);\n            mimeErrLabel.setText(\n                    NbBundle.getMessage(this.getClass(), \"FileExtMismatchConfigPanel.addTypeButton.mimeTypeExists\"));\n            return;\n        }\n\n        if (!TikaFileTypeDetector.mimeTypeIsDetectable(newMime)) {\n            mimeErrLabel.setForeground(Color.red);\n            mimeErrLabel.setText(NbBundle.getMessage(this.getClass(),\n                    \"FileExtMismatchConfigPanel.addTypeButton.mimeTypeNotDetectable\"));\n            return;\n        }\n\n        editableMap.put(newMime, new String[0]);\n\n        // Refresh table\n        updateMimeList();\n        mimeTableModel.resync();\n\n        // user feedback for successful add\n        //selectByMimeString(newMime);\n        mimeErrLabel.setForeground(Color.blue);\n        mimeErrLabel.setText(\n                NbBundle.getMessage(this.getClass(), \"FileExtMismatchConfigPanel.addTypeButton.mimeTypeAdded\", newMime));\n        mimeRemoveErrLabel.setText(\" \");\n        userTypeTextField.setText(\"\");\n        setIsModified();\n    }","commit_id":"bbfb0b187201d6d179c4218c6e1db37df04ce796","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Creates an ingest module that detects the type of a file based on\n     * signature (magic) values. Posts results to the blackboard.\n     *\n     * @param settings The ingest module settings.\n     */\n    FileTypeIdIngestModule(FileTypeIdModuleSettings settings) {\n        this.settings = settings;\n        userDefinedFileTypeIdentifier = new UserDefinedFileTypeDetector();\n        try {\n            userDefinedFileTypeIdentifier.loadFileTypes();\n        } catch (UserDefinedFileTypesManager.UserDefinedFileTypesException ex) {\n            logger.log(Level.SEVERE, \"Failed to load file types\", ex);\n            MessageNotifyUtil.Notify.error(FileTypeIdModuleFactory.getModuleName(), ex.getMessage());            \n        }\n    }","id":73107,"modified_method":"/**\n     * Creates an ingest module that detects the type of a file based on\n     * signature (magic) values. Posts results to the blackboard.\n     *\n     * @param settings The ingest module settings.\n     */\n    FileTypeIdIngestModule(FileTypeIdModuleSettings settings) {\n        this.settings = settings;\n        if (!tikaDetector.userDefinedTypesAreLoaded()) {\n            MessageNotifyUtil.Notify.error(FileTypeIdModuleFactory.getModuleName(), \"Failed to load user-defined file types for use in file type indentification.\");\n        }\n    }","commit_id":"bbfb0b187201d6d179c4218c6e1db37df04ce796","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public ProcessResult process(AbstractFile file) {\n        \n        String name = file.getName();\n        \n        /**\n         * Skip unallocated space and unused blocks files.\n         */\n        if ((file.getType() == TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS)\n                || (file.getType() == TskData.TSK_DB_FILES_TYPE_ENUM.UNUSED_BLOCKS)) {\n\n            return ProcessResult.OK;\n        }\n\n        /**\n         * Skip known files if configured to do so.\n         */\n        if (settings.skipKnownFiles() && (file.getKnown() == FileKnown.KNOWN)) {\n            return ProcessResult.OK;\n        }\n\n        /**\n         * Filter out very small files to minimize false positives.\n         */\n        if (settings.skipSmallFiles() && file.getSize() < settings.minFileSizeInBytes()) {\n            return ProcessResult.OK;\n        }\n        \n        try {\n            long startTime = System.currentTimeMillis();\n            FileType fileType = this.userDefinedFileTypeIdentifier.identify(file);\n            if (null != fileType) {\n                String moduleName = FileTypeIdModuleFactory.getModuleName();\n                BlackboardArtifact getInfoArtifact = file.getGenInfoArtifact();\n                BlackboardAttribute typeAttr = new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_FILE_TYPE_SIG.getTypeID(), moduleName, fileType.getMimeType());\n                getInfoArtifact.addAttribute(typeAttr);\n\n                if (fileType.alertOnMatch()) {\n                    BlackboardArtifact artifact = file.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_INTERESTING_FILE_HIT);\n                    BlackboardAttribute setNameAttribute = new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_SET_NAME.getTypeID(), moduleName, fileType.getFilesSetName());\n                    artifact.addAttribute(setNameAttribute);\n\n                    /**\n                     * Use the MIME type as the category, i.e., the rule that\n                     * determined this file belongs to the interesting files\n                     * set.\n                     */\n                    BlackboardAttribute ruleNameAttribute = new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_CATEGORY.getTypeID(), moduleName, fileType.getMimeType());\n                    artifact.addAttribute(ruleNameAttribute);\n                }\n\n            } else {\n                tikaDetector.detectAndSave(file);\n            }\n            addToTotals(jobId, (System.currentTimeMillis() - startTime));\n            return ProcessResult.OK;\n        } catch (TskException ex) {\n            logger.log(Level.WARNING, \"Error matching file signature\", ex); //NON-NLS\n            return ProcessResult.ERROR;\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error matching file signature\", e); //NON-NLS\n            return ProcessResult.ERROR;\n        }\n    }","id":73108,"modified_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public ProcessResult process(AbstractFile file) {\n\n        /**\n         * Skip unallocated space and unused blocks files.\n         */\n        if ((file.getType() == TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS)\n                || (file.getType() == TskData.TSK_DB_FILES_TYPE_ENUM.UNUSED_BLOCKS)) {\n\n            return ProcessResult.OK;\n        }\n\n        /**\n         * Skip known files if configured to do so.\n         */\n        if (settings.skipKnownFiles() && (file.getKnown() == FileKnown.KNOWN)) {\n            return ProcessResult.OK;\n        }\n\n        /**\n         * Filter out very small files to minimize false positives.\n         */\n        if (settings.skipSmallFiles() && file.getSize() < settings.minFileSizeInBytes()) {\n            return ProcessResult.OK;\n        }\n\n        /**\n         * Attempt to detect the file type. Do it within an exception firewall,\n         * so that any issues with reading file content or complaints from tika\n         * do not take the module down.\n         */\n        try {\n            long startTime = System.currentTimeMillis();\n            tikaDetector.detectAndPostToBlackboard(file, FileTypeIdModuleFactory.getModuleName());\n            addToTotals(jobId, (System.currentTimeMillis() - startTime));\n            return ProcessResult.OK;\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error matching file signature\", e); //NON-NLS\n            return ProcessResult.ERROR;\n        }\n    }","commit_id":"bbfb0b187201d6d179c4218c6e1db37df04ce796","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Validate if a given mime type is in the detector's registry.\n     *\n     * @param mimeType Full string of mime type, e.g. \"text/html\"\n     * @return true if detectable\n     */\n    public static boolean isMimeTypeDetectable(String mimeType) {\n        /* This is an awkward place for this method because it is used only\n         * by the file extension mismatch panel.  But, it works.  \n         * We probabl dont' want to expose the tika class as the public\n         * method to do this and a single class just for this method\n         * seems a bit silly.\n         */\n        TikaFileTypeDetector detector = new TikaFileTypeDetector();\n        return detector.isMimeTypeDetectable(mimeType);\n    }","id":73109,"modified_method":"/**\n     * Validate if a given mime type is in the detector's registry.\n     *\n     * @deprecated Use TikaFileTypeDetector.mimeTypeIsDetectable instead.\n     * @param mimeType Full string of mime type, e.g. \"text/html\"\n     * @return true if detectable\n     */\n    @Deprecated\n    public static boolean isMimeTypeDetectable(String mimeType) {\n        /**\n         * TODO: This is an awkward place for this method because it is used\n         * only by the file extension mismatch global settings panel. There used\n         * to be a comment here about not exposing the TikaFileTypeDetector\n         * class publicly, but this has already been done and actually makes\n         * more sense, given that the question is being asked of Apache's tika\n         * code. The cleanest approach would be to move the file type\n         * identification code into its own package, with the file type\n         * identification, the file extension mismatch identification, keyword\n         * search, and possibly the interesting items ingest modules as clients.\n         * I (RJC) recommend this for Autopsy 3.2.\n         */\n        return TikaFileTypeDetector.mimeTypeIsDetectable(mimeType);\n    }","commit_id":"bbfb0b187201d6d179c4218c6e1db37df04ce796","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * Adds the file to the index. Detects file type, calls extractors, etc.\n         *\n         * @param aFile File to analyze\n         * @param indexContent False if only metadata should be text_ingested.\n         * True if content and metadata should be index.\n         */\n        private void indexFile(AbstractFile aFile, boolean indexContent) {\n            //logger.log(Level.INFO, \"Processing AbstractFile: \" + abstractFile.getName());\n\n            TskData.TSK_DB_FILES_TYPE_ENUM aType = aFile.getType();\n\n            // unallocated and unused blocks can only have strings extracted from them. \n            if ((aType.equals(TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS) || aType.equals(TskData.TSK_DB_FILES_TYPE_ENUM.UNUSED_BLOCKS))) {\n                extractStringsAndIndex(aFile);\n            }\n\n            final long size = aFile.getSize();\n            //if not to index content, or a dir, or 0 content, index meta data only\n            if ((indexContent == false || aFile.isDir() || size == 0)) {\n                try {\n                    ingester.ingest(aFile, false); //meta-data only\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.METADATA_INGESTED);\n                } catch (IngesterException ex) {\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_INDEXING);\n                    logger.log(Level.WARNING, \"Unable to index meta-data for file: \" + aFile.getId(), ex); //NON-NLS\n                }\n                return;\n            }\n\n            \n            \n            // try to get the file type from the BB\n            String detectedFormat = null;\n            try {\n                ArrayList<BlackboardAttribute> attributes = aFile.getGenInfoAttributes(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_FILE_TYPE_SIG);\n                for (BlackboardAttribute attribute : attributes) {\n                    detectedFormat = attribute.getValueString();\n                    break;\n                }\n            } catch (TskCoreException ex) {\n            }\n            // else, use FileType module to detect the format\n            if (detectedFormat == null) {\n                TikaFileTypeDetector tikaFileTypeDetector = new TikaFileTypeDetector();\n                try {\n                    detectedFormat = tikaFileTypeDetector.detectAndSave(aFile);\n                } catch (TskCoreException ex) {\n                    logger.log(Level.WARNING, \"Could not detect format using tika for file: \" + aFile); //NON-NLS\n                    return;\n                }\n                if (detectedFormat == null) {\n                    logger.log(Level.WARNING, \"Could not detect format using tika for file: \" + aFile); //NON-NLS\n                    return;\n                } \n            }\n\n            // we skip archive formats that are opened by the archive module. \n            // @@@ We could have a check here to see if the archive module was enabled though...\n            if (TextExtractor.ARCHIVE_MIME_TYPES.contains(detectedFormat)) {\n                try {\n                    ingester.ingest(aFile, false); //meta-data only\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.METADATA_INGESTED);\n                } catch (IngesterException ex) {\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_INDEXING);\n                    logger.log(Level.WARNING, \"Unable to index meta-data for file: \" + aFile.getId(), ex); //NON-NLS\n                }\n                return;\n            }\n\n            boolean wasTextAdded = false;\n            if (isTextExtractSupported(aFile, detectedFormat)) {\n                //extract text with one of the extractors, divide into chunks and index with Solr\n                try {\n                    //logger.log(Level.INFO, \"indexing: \" + aFile.getName());\n                    if (!extractTextAndIndex(aFile, detectedFormat)) {\n                        logger.log(Level.WARNING, \"Failed to extract text and ingest, file ''{0}'' (id: {1}).\", new Object[]{aFile.getName(), aFile.getId()}); //NON-NLS\n                        putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_TEXTEXTRACT);\n                    } else {\n                        putIngestStatus(jobId, aFile.getId(), IngestStatus.TEXT_INGESTED);\n                        wasTextAdded = true;\n                    }\n\n                } catch (IngesterException e) {\n                    logger.log(Level.INFO, \"Could not extract text with Tika, \" + aFile.getId() + \", \" //NON-NLS\n                            + aFile.getName(), e);\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_INDEXING);\n                } catch (Exception e) {\n                    logger.log(Level.WARNING, \"Error extracting text with Tika, \" + aFile.getId() + \", \" //NON-NLS\n                            + aFile.getName(), e);\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_TEXTEXTRACT);\n                }\n            }\n\n            // if it wasn't supported or had an error, default to strings\n            if (wasTextAdded == false) {\n                extractStringsAndIndex(aFile);\n            }\n        }","id":73110,"modified_method":"/**\n         * Adds the file to the index. Detects file type, calls extractors, etc.\n         *\n         * @param aFile File to analyze\n         * @param indexContent False if only metadata should be text_ingested.\n         * True if content and metadata should be index.\n         */\n        private void indexFile(AbstractFile aFile, boolean indexContent) {\n            //logger.log(Level.INFO, \"Processing AbstractFile: \" + abstractFile.getName());\n\n            TskData.TSK_DB_FILES_TYPE_ENUM aType = aFile.getType();\n\n            // unallocated and unused blocks can only have strings extracted from them. \n            if ((aType.equals(TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS) || aType.equals(TskData.TSK_DB_FILES_TYPE_ENUM.UNUSED_BLOCKS))) {\n                extractStringsAndIndex(aFile);\n            }\n\n            final long size = aFile.getSize();\n            //if not to index content, or a dir, or 0 content, index meta data only\n            if ((indexContent == false || aFile.isDir() || size == 0)) {\n                try {\n                    ingester.ingest(aFile, false); //meta-data only\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.METADATA_INGESTED);\n                } catch (IngesterException ex) {\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_INDEXING);\n                    logger.log(Level.WARNING, \"Unable to index meta-data for file: \" + aFile.getId(), ex); //NON-NLS\n                }\n                return;\n            }\n\n            \n            \n            // try to get the file type from the BB\n            String detectedFormat = null;\n            try {\n                ArrayList<BlackboardAttribute> attributes = aFile.getGenInfoAttributes(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_FILE_TYPE_SIG);\n                for (BlackboardAttribute attribute : attributes) {\n                    detectedFormat = attribute.getValueString();\n                    break;\n                }\n            } catch (TskCoreException ex) {\n            }\n            // else, use FileType module to detect the format\n            if (detectedFormat == null) {\n                TikaFileTypeDetector tikaFileTypeDetector = new TikaFileTypeDetector();\n                try {\n                    detectedFormat = tikaFileTypeDetector.detectAndPostToBlackboard(aFile, KeywordSearchModuleFactory.getModuleName());\n                } catch (TskCoreException ex) {\n                    logger.log(Level.WARNING, \"Could not detect format using tika for file: \" + aFile); //NON-NLS\n                    return;\n                }\n                if (detectedFormat == null) {\n                    logger.log(Level.WARNING, \"Could not detect format using tika for file: \" + aFile); //NON-NLS\n                    return;\n                } \n            }\n\n            // we skip archive formats that are opened by the archive module. \n            // @@@ We could have a check here to see if the archive module was enabled though...\n            if (TextExtractor.ARCHIVE_MIME_TYPES.contains(detectedFormat)) {\n                try {\n                    ingester.ingest(aFile, false); //meta-data only\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.METADATA_INGESTED);\n                } catch (IngesterException ex) {\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_INDEXING);\n                    logger.log(Level.WARNING, \"Unable to index meta-data for file: \" + aFile.getId(), ex); //NON-NLS\n                }\n                return;\n            }\n\n            boolean wasTextAdded = false;\n            if (isTextExtractSupported(aFile, detectedFormat)) {\n                //extract text with one of the extractors, divide into chunks and index with Solr\n                try {\n                    //logger.log(Level.INFO, \"indexing: \" + aFile.getName());\n                    if (!extractTextAndIndex(aFile, detectedFormat)) {\n                        logger.log(Level.WARNING, \"Failed to extract text and ingest, file ''{0}'' (id: {1}).\", new Object[]{aFile.getName(), aFile.getId()}); //NON-NLS\n                        putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_TEXTEXTRACT);\n                    } else {\n                        putIngestStatus(jobId, aFile.getId(), IngestStatus.TEXT_INGESTED);\n                        wasTextAdded = true;\n                    }\n\n                } catch (IngesterException e) {\n                    logger.log(Level.INFO, \"Could not extract text with Tika, \" + aFile.getId() + \", \" //NON-NLS\n                            + aFile.getName(), e);\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_INDEXING);\n                } catch (Exception e) {\n                    logger.log(Level.WARNING, \"Error extracting text with Tika, \" + aFile.getId() + \", \" //NON-NLS\n                            + aFile.getName(), e);\n                    putIngestStatus(jobId, aFile.getId(), IngestStatus.SKIPPED_ERROR_TEXTEXTRACT);\n                }\n            }\n\n            // if it wasn't supported or had an error, default to strings\n            if (wasTextAdded == false) {\n                extractStringsAndIndex(aFile);\n            }\n        }","commit_id":"bbfb0b187201d6d179c4218c6e1db37df04ce796","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Validate if a given mime type is in the registry. For Tika, we remove the\n     * string \"tika\" from all MIME names, e.g. use \"application/x-msoffice\" NOT\n     * \"application/x-tika-msoffice\"\n     *\n     * @param mimeType Full string of mime type, e.g. \"text/html\"\n     * @return true if detectable\n     */\n    public boolean isMimeTypeDetectable(String mimeType) {\n        boolean ret = false;\n\n        SortedSet<MediaType> m = MimeTypes.getDefaultMimeTypes().getMediaTypeRegistry().getTypes();\n        String[] split = mimeType.split(\"/\");\n\n        if (split.length == 2) {\n            String type = split[0];\n            String subtype = split[1];\n            MediaType mediaType = new MediaType(type, subtype);\n            ret = m.contains(mediaType);\n        }\n\n        return ret;\n    }","id":73111,"modified_method":"/**\n     * Validate if a given mime type is in the registry. For Tika, we remove the\n     * string \"tika\" from all MIME names, e.g. use \"application/x-msoffice\" NOT\n     * \"application/x-tika-msoffice\"\n     *\n     * @deprecated Use TikaFileTypeDetector.mimeTypeIsDetectable instead.\n     * @param mimeType Full string of mime type, e.g. \"text/html\"\n     * @return true if detectable\n     */\n    @Deprecated\n    public boolean isMimeTypeDetectable(String mimeType\n    ) {\n        return mimeTypeIsDetectable(mimeType);\n    }","commit_id":"bbfb0b187201d6d179c4218c6e1db37df04ce796","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Detect the mime type of the passed in file and save it to the blackboard\n     * @param abstractFile\n     * @return mime type or null\n     * @throws TskCoreException \n     */\n    public synchronized String detectAndSave(AbstractFile abstractFile) throws TskCoreException {\n        String mimeType = detect(abstractFile);\n        if (mimeType != null) {\n            // add artifact\n            BlackboardArtifact getInfoArt = abstractFile.getGenInfoArtifact();\n            BlackboardAttribute batt = new BlackboardAttribute(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_FILE_TYPE_SIG.getTypeID(), FileTypeIdModuleFactory.getModuleName(), mimeType);\n            getInfoArt.addAttribute(batt);\n\n            // we don't fire the event because we just updated TSK_GEN_INFO, which isn't displayed in the tree and is vague.\n        }\n        return mimeType;\n    }","id":73112,"modified_method":"/**\n     * Detect the MIME type of a file, posting it to the blackboard if detection succeeds.\n     *\n     * @deprecated Use detectAndPostToBlackboard instead.\n     * @param file The file to test.\n     * @return The MIME type name id detection was successful, null otherwise.\n     * @throws TskCoreException if there is an error posting to the blackboard.\n     */\n    @Deprecated\n    public synchronized String detectAndSave(AbstractFile file) throws TskCoreException {\n        return detectAndPostToBlackboard(file, FileTypeIdModuleFactory.getModuleName());\n    }","commit_id":"bbfb0b187201d6d179c4218c6e1db37df04ce796","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Detect the mime type of the passed in file\n     * @param abstractFile\n     * @return mime type of detected format or null\n     */\n    public synchronized String detect(AbstractFile abstractFile) {\n        try {\n            byte buf[];\n            int len = abstractFile.read(buffer, 0, BUFFER_SIZE);\n            if (len < BUFFER_SIZE) {\n                buf = new byte[len];\n                System.arraycopy(buffer, 0, buf, 0, len);\n            } else {\n                buf = buffer;\n            }\n            \n            String mimetype = tikaInst.detect(buf, abstractFile.getName());\n            // Remove tika's name out of the general types like msoffice and ooxml\n            return mimetype.replace(\"tika-\", \"\"); //NON-NLS\n        } catch (Exception ex) {\n            //do nothing\n        }\n        return null;\n    }","id":73113,"modified_method":"/**\n     * Detect the MIME type of a file.\n     *\n     * @param file The file to test.\n     * @return The MIME type name id detection was successful, null otherwise.\n     * @throws TskCoreException\n     */\n    public synchronized String detect(AbstractFile file) {\n        String fileType = detectUserDefinedType(file);\n        if (null == fileType) {\n            try {\n                byte buf[];\n                int len = file.read(buffer, 0, BUFFER_SIZE);\n                if (len < BUFFER_SIZE) {\n                    buf = new byte[len];\n                    System.arraycopy(buffer, 0, buf, 0, len);\n                } else {\n                    buf = buffer;\n                }\n\n                String mimetype = tikaInst.detect(buf, file.getName());\n                // Remove tika's name out of the general types like msoffice and ooxml\n                return mimetype.replace(\"tika-\", \"\"); //NON-NLS\n            } catch (Exception ex) {\n                //do nothing\n            }\n        }\n        return fileType;\n    }","commit_id":"bbfb0b187201d6d179c4218c6e1db37df04ce796","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void testRunningJUnit() throws ExecutionException {\n    PsiClass testA = findTestA(getModule1());\n    JUnitConfiguration configuration = createConfiguration(testA);\n    JavaParameters parameters = checkCanRun(configuration);\n    CHECK.empty(parameters.getVMParametersList().getList());\n    assertTrue(JUnitStarter.checkVersion(parameters.getProgramParametersList().getArray(),\n                                         new SegmentedOutputStream(System.out)));\n    assertTrue(parameters.getProgramParametersList().getList().contains(testA.getQualifiedName()));\n    assertEquals(JUnitStarter.class.getName(), parameters.getMainClass());\n    assertEquals(myJdk.getHomeDirectory().getPresentableUrl(), parameters.getJdkPath());\n  }","id":73114,"modified_method":"public void testRunningJUnit() throws ExecutionException {\n    PsiClass testA = findTestA(getModule1());\n    JUnitConfiguration configuration = createConfiguration(testA);\n    JavaParameters parameters = checkCanRun(configuration);\n    CHECK.empty(parameters.getVMParametersList().getList());\n    final SegmentedOutputStream notifications = new SegmentedOutputStream(System.out);\n    assertTrue(JUnitStarter.checkVersion(parameters.getProgramParametersList().getArray(),\n                                         new PrintStream(notifications)));\n    assertTrue(parameters.getProgramParametersList().getList().contains(testA.getQualifiedName()));\n    assertEquals(JUnitStarter.class.getName(), parameters.getMainClass());\n    assertEquals(myJdk.getHomeDirectory().getPresentableUrl(), parameters.getJdkPath());\n  }","commit_id":"b062b8061a8a5e32d2f286ae214fe699b3a68484","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TestResult doRun(Test suite, boolean wait) {  //todo\n    try {\n      TreeSender.sendTree(this, suite, mySendTree);\n    }\n    catch (Exception e) {\n      //noinspection HardCodedStringLiteral\n      System.err.println(\"Internal Error occured.\");\n      e.printStackTrace(System.err);\n    }\n    return super.doRun(suite, wait);\n  }","id":73115,"modified_method":"public TestResult doRun(Test suite, boolean wait) {  //todo\n    try {\n      TreeSender.sendTree(this, suite, mySendTree);\n    }\n    catch (Exception e) {\n      //noinspection HardCodedStringLiteral\n      System.err.println(\"Internal Error occured.\");\n      e.printStackTrace(System.err);\n    }\n    final TestResult testResult = super.doRun(suite, wait);\n    if (myTestsListener instanceof SMTestListener) {\n      ((SMTestListener)myTestsListener).finishSuite();\n    }\n    return testResult;\n  }","commit_id":"b062b8061a8a5e32d2f286ae214fe699b3a68484","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int startRunnerWithArgs(String[] args, ArrayList listeners, String name, int count, boolean sendTree) {\n    myListeners = listeners;\n    mySendTree = sendTree;\n    if (sendTree) {\n      setPrinter(new TimeSender(myRegistry));\n    }\n    else {\n      setPrinter(new MockResultPrinter());\n    }\n    try {\n      Test suite = TestRunnerUtil.getTestSuite(this, args);\n      if (suite == null) return -1;\n      TestResult result = doRun(suite);\n      if (!result.wasSuccessful()) {\n        return -1;\n      }\n      return 0;\n    }\n    catch (Exception e) {\n      e.printStackTrace(System.err);\n      return -2;\n    }\n  }","id":73116,"modified_method":"public int startRunnerWithArgs(String[] args, ArrayList listeners, String name, int count, boolean sendTree) {\n    myListeners = listeners;\n    mySendTree = sendTree && !(myTestsListener instanceof SMTestListener);\n    if (sendTree) {\n      setPrinter(new TimeSender(myRegistry));\n    }\n    else {\n      setPrinter(new MockResultPrinter());\n    }\n    try {\n      Test suite = TestRunnerUtil.getTestSuite(this, args);\n      if (suite == null) return -1;\n      TestResult result = doRun(suite);\n      if (!result.wasSuccessful()) {\n        return -1;\n      }\n      return 0;\n    }\n    catch (Exception e) {\n      e.printStackTrace(System.err);\n      return -2;\n    }\n  }","commit_id":"b062b8061a8a5e32d2f286ae214fe699b3a68484","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int processChildren(boolean isJUnit4,\n                                     List listeners,\n                                     SegmentedOutputStream out,\n                                     SegmentedOutputStream err,\n                                     List parameters,\n                                     IdeaTestRunner testRunner,\n                                     List children,\n                                     int result,\n                                     boolean forkTillMethod, File workingDir, String classpath, String dynamicClasspath) throws IOException, InterruptedException {\n    for (int i = 0, argsLength = children.size(); i < argsLength; i++) {\n      final Object child = children.get(i);\n      final List childTests = testRunner.getChildTests(child);\n      final int childResult;\n      if (childTests.isEmpty() || !forkTillMethod) {\n        final OutputObjectRegistry registry = testRunner.getRegistry();\n        final int startIndex = registry != null ? registry.getKnownObject(child) : -1;\n        childResult =\n          runChild(isJUnit4, listeners, out, err, parameters, testRunner.getStartDescription(child), workingDir, String.valueOf(startIndex), classpath, dynamicClasspath);\n      }\n      else {\n        childResult =\n          processChildren(isJUnit4, listeners, out, err, parameters, testRunner, childTests, result, forkTillMethod, workingDir, classpath, dynamicClasspath);\n      }\n      result = Math.min(childResult, result);\n    }\n    return result;\n  }","id":73117,"modified_method":"private static int processChildren(boolean isJUnit4,\n                                     List listeners,\n                                     Object out,\n                                     Object err,\n                                     List parameters,\n                                     IdeaTestRunner testRunner,\n                                     List children,\n                                     int result,\n                                     boolean forkTillMethod, File workingDir, String classpath, String dynamicClasspath) throws IOException, InterruptedException {\n    for (int i = 0, argsLength = children.size(); i < argsLength; i++) {\n      final Object child = children.get(i);\n      final List childTests = testRunner.getChildTests(child);\n      final int childResult;\n      if (childTests.isEmpty() || !forkTillMethod) {\n        final OutputObjectRegistry registry = testRunner.getRegistry();\n        final int startIndex = registry != null ? registry.getKnownObject(child) : -1;\n        childResult =\n          runChild(isJUnit4, listeners, out, err, parameters, testRunner.getStartDescription(child), workingDir, String.valueOf(startIndex), classpath, dynamicClasspath);\n      }\n      else {\n        childResult =\n          processChildren(isJUnit4, listeners, out, err, parameters, testRunner, childTests, result, forkTillMethod, workingDir, classpath, dynamicClasspath);\n      }\n      result = Math.min(childResult, result);\n    }\n    return result;\n  }","commit_id":"b062b8061a8a5e32d2f286ae214fe699b3a68484","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static int startForkedVMs(String workingDirsPath,\n                            String[] args,\n                            boolean isJUnit4,\n                            List listeners,\n                            String params, SegmentedOutputStream out,\n                            SegmentedOutputStream err,\n                            String forkMode,\n                            String path) throws Exception {\n    final List parameters = new ArrayList();\n    final BufferedReader bufferedReader = new BufferedReader(new FileReader(path));\n    final String dynamicClasspath = bufferedReader.readLine();\n    try {\n      String line;\n      while ((line = bufferedReader.readLine()) != null) {\n        parameters.add(line);\n      }\n    }\n    finally {\n      bufferedReader.close();\n    }\n\n    IdeaTestRunner testRunner = (IdeaTestRunner)JUnitStarter.getAgentClass(isJUnit4).newInstance();\n    testRunner.setStreams(out, err, 0);\n    final Object description = testRunner.getTestToStart(args, params);\n    if (description == null) return -1;\n\n    TreeSender.sendTree(testRunner, description, !JUnitStarter.SM_RUNNER);\n\n    long time = System.currentTimeMillis();\n\n    int result = 0;\n    if (workingDirsPath == null || new File(workingDirsPath).length() == 0) {\n       final List children = testRunner.getChildTests(description);\n       final boolean forkTillMethod = forkMode.equalsIgnoreCase(\"method\");\n       result = processChildren(isJUnit4, listeners, out, err, parameters, testRunner, children, 0, forkTillMethod, null, System.getProperty(\"java.class.path\"), dynamicClasspath);\n    } else {\n      final BufferedReader perDirReader = new BufferedReader(new FileReader(workingDirsPath));\n      try {\n        final String packageName = perDirReader.readLine();\n        String workingDir;\n        while ((workingDir = perDirReader.readLine()) != null) {\n          final String classpath = perDirReader.readLine();\n          try {\n\n            List classNames = new ArrayList();\n            final int classNamesSize = Integer.parseInt(perDirReader.readLine());\n            for (int i = 0; i < classNamesSize; i++) {\n              String className = perDirReader.readLine();\n              if (className == null) {\n                System.err.println(\"Class name is expected. Working dir: \" + workingDir);\n                return -1;\n              }\n              classNames.add(className);\n            }\n\n            final Object rootDescriptor = findByClassName(testRunner, (String)classNames.get(0), description);\n            final int childResult;\n            final File dir = new File(workingDir);\n            if (forkMode.equals(\"none\")) {\n              File tempFile = File.createTempFile(\"idea_junit\", \".tmp\");\n              tempFile.deleteOnExit();\n              JUnitStarter.printClassesList(classNames, packageName + \", working directory: \\'\" + workingDir + \"\\'\", \"\", tempFile);\n              final OutputObjectRegistry registry = testRunner.getRegistry();\n              final String startIndex = String.valueOf(registry != null ? registry.getKnownObject(rootDescriptor) - 1 : -1);\n              childResult =\n                runChild(isJUnit4, listeners, out, err, parameters, \"@\" + tempFile.getAbsolutePath(), dir, startIndex, classpath, dynamicClasspath);\n            } else {\n              final List children = new ArrayList(testRunner.getChildTests(description));\n              for (Iterator iterator = children.iterator(); iterator.hasNext(); ) {\n                if (!classNames.contains(testRunner.getTestClassName(iterator.next()))) {\n                  iterator.remove();\n                }\n              }\n              final boolean forkTillMethod = forkMode.equalsIgnoreCase(\"method\");\n              childResult = processChildren(isJUnit4, listeners, out, err, parameters, testRunner, children, result, forkTillMethod, dir, classpath, dynamicClasspath);\n            }\n            result = Math.min(childResult, result);\n          }\n          catch (Exception e) {\n            e.printStackTrace();\n          }\n        }\n      }\n      finally {\n        perDirReader.close();\n      }\n    }\n\n    time = System.currentTimeMillis() - time;\n    if (!JUnitStarter.SM_RUNNER) new TimeSender(testRunner.getRegistry()).printHeader(time);\n    return result;\n  }","id":73118,"modified_method":"static int startForkedVMs(String workingDirsPath,\n                            String[] args,\n                            boolean isJUnit4,\n                            List listeners,\n                            String params, Object out,\n                            Object err,\n                            String forkMode,\n                            String path) throws Exception {\n    final List parameters = new ArrayList();\n    final BufferedReader bufferedReader = new BufferedReader(new FileReader(path));\n    final String dynamicClasspath = bufferedReader.readLine();\n    try {\n      String line;\n      while ((line = bufferedReader.readLine()) != null) {\n        parameters.add(line);\n      }\n    }\n    finally {\n      bufferedReader.close();\n    }\n\n    IdeaTestRunner testRunner = (IdeaTestRunner)JUnitStarter.getAgentClass(isJUnit4).newInstance();\n    testRunner.setStreams(out, err, 0);\n    final Object description = testRunner.getTestToStart(args, params);\n    if (description == null) return -1;\n\n    TreeSender.sendTree(testRunner, description, !JUnitStarter.SM_RUNNER);\n\n    long time = System.currentTimeMillis();\n\n    int result = 0;\n    if (workingDirsPath == null || new File(workingDirsPath).length() == 0) {\n       final List children = testRunner.getChildTests(description);\n       final boolean forkTillMethod = forkMode.equalsIgnoreCase(\"method\");\n       result = processChildren(isJUnit4, listeners, out, err, parameters, testRunner, children, 0, forkTillMethod, null, System.getProperty(\"java.class.path\"), dynamicClasspath);\n    } else {\n      final BufferedReader perDirReader = new BufferedReader(new FileReader(workingDirsPath));\n      try {\n        final String packageName = perDirReader.readLine();\n        String workingDir;\n        while ((workingDir = perDirReader.readLine()) != null) {\n          final String classpath = perDirReader.readLine();\n          try {\n\n            List classNames = new ArrayList();\n            final int classNamesSize = Integer.parseInt(perDirReader.readLine());\n            for (int i = 0; i < classNamesSize; i++) {\n              String className = perDirReader.readLine();\n              if (className == null) {\n                System.err.println(\"Class name is expected. Working dir: \" + workingDir);\n                return -1;\n              }\n              classNames.add(className);\n            }\n\n            final Object rootDescriptor = findByClassName(testRunner, (String)classNames.get(0), description);\n            final int childResult;\n            final File dir = new File(workingDir);\n            if (forkMode.equals(\"none\")) {\n              File tempFile = File.createTempFile(\"idea_junit\", \".tmp\");\n              tempFile.deleteOnExit();\n              JUnitStarter.printClassesList(classNames, packageName + \", working directory: \\'\" + workingDir + \"\\'\", \"\", tempFile);\n              final OutputObjectRegistry registry = testRunner.getRegistry();\n              final String startIndex = String.valueOf(registry != null ? registry.getKnownObject(rootDescriptor) - 1 : -1);\n              childResult =\n                runChild(isJUnit4, listeners, out, err, parameters, \"@\" + tempFile.getAbsolutePath(), dir, startIndex, classpath, dynamicClasspath);\n            } else {\n              final List children = new ArrayList(testRunner.getChildTests(description));\n              for (Iterator iterator = children.iterator(); iterator.hasNext(); ) {\n                if (!classNames.contains(testRunner.getTestClassName(iterator.next()))) {\n                  iterator.remove();\n                }\n              }\n              final boolean forkTillMethod = forkMode.equalsIgnoreCase(\"method\");\n              childResult = processChildren(isJUnit4, listeners, out, err, parameters, testRunner, children, result, forkTillMethod, dir, classpath, dynamicClasspath);\n            }\n            result = Math.min(childResult, result);\n          }\n          catch (Exception e) {\n            e.printStackTrace();\n          }\n        }\n      }\n      finally {\n        perDirReader.close();\n      }\n    }\n\n    time = System.currentTimeMillis() - time;\n    if (!JUnitStarter.SM_RUNNER) new TimeSender(testRunner.getRegistry()).printHeader(time);\n    return result;\n  }","commit_id":"b062b8061a8a5e32d2f286ae214fe699b3a68484","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int runChild(boolean isJUnit4,\n                              List listeners,\n                              SegmentedOutputStream out,\n                              SegmentedOutputStream err,\n                              List parameters,\n                              String description,\n                              File workingDir,\n                              String startIndex,\n                              String classpath,\n                              String dynamicClasspath) throws IOException, InterruptedException {\n    //noinspection SSBasedInspection\n    final File tempFile = File.createTempFile(\"fork\", \"test\");\n    tempFile.deleteOnExit();\n    final String testOutputPath = tempFile.getAbsolutePath();\n\n    final ProcessBuilder builder = new ProcessBuilder();\n    builder.add(parameters);\n    builder.add(\"-classpath\");\n    if (dynamicClasspath.length() > 0) {\n      try {\n        final File classpathFile = File.createTempFile(\"classpath\", null);\n        classpathFile.deleteOnExit();\n        final PrintWriter writer = new PrintWriter(new OutputStreamWriter(new FileOutputStream(classpathFile), \"UTF-8\"));\n        try {\n          int idx = 0;\n          while (idx < classpath.length()) {\n            final int endIdx = classpath.indexOf(File.pathSeparator, idx);\n            if (endIdx < 0) {\n              writer.println(classpath.substring(idx));\n              break;\n            }\n            writer.println(classpath.substring(idx, endIdx));\n            idx = endIdx + File.pathSeparator.length();\n          }\n        }\n        finally {\n          writer.close();\n        }\n\n        builder.add(dynamicClasspath);\n        builder.add(CommandLineWrapper.class.getName());\n        builder.add(classpathFile.getAbsolutePath());\n      }\n      catch (Throwable e) {\n        builder.add(classpath);\n      }\n    }\n    else {\n      builder.add(classpath);\n    }\n\n    builder.add(JUnitForkedStarter.class.getName());\n    builder.add(testOutputPath);\n    builder.add(startIndex);\n    builder.add(String.valueOf(isJUnit4));\n    builder.add(description);\n    builder.add(listeners);\n    builder.setWorkingDir(workingDir);\n\n    final Process exec = builder.createProcess();\n    final int result = exec.waitFor();\n    ForkedVMWrapper.readWrapped(testOutputPath, out.getPrintStream(), err.getPrintStream());\n    return result;\n  }","id":73119,"modified_method":"private static int runChild(boolean isJUnit4,\n                              List listeners,\n                              Object out,\n                              Object err,\n                              List parameters,\n                              String description,\n                              File workingDir,\n                              String startIndex,\n                              String classpath,\n                              String dynamicClasspath) throws IOException, InterruptedException {\n    //noinspection SSBasedInspection\n    final File tempFile = File.createTempFile(\"fork\", \"test\");\n    tempFile.deleteOnExit();\n    final String testOutputPath = tempFile.getAbsolutePath();\n\n    final ProcessBuilder builder = new ProcessBuilder();\n    builder.add(parameters);\n    builder.add(\"-classpath\");\n    if (dynamicClasspath.length() > 0) {\n      try {\n        final File classpathFile = File.createTempFile(\"classpath\", null);\n        classpathFile.deleteOnExit();\n        final PrintWriter writer = new PrintWriter(new OutputStreamWriter(new FileOutputStream(classpathFile), \"UTF-8\"));\n        try {\n          int idx = 0;\n          while (idx < classpath.length()) {\n            final int endIdx = classpath.indexOf(File.pathSeparator, idx);\n            if (endIdx < 0) {\n              writer.println(classpath.substring(idx));\n              break;\n            }\n            writer.println(classpath.substring(idx, endIdx));\n            idx = endIdx + File.pathSeparator.length();\n          }\n        }\n        finally {\n          writer.close();\n        }\n\n        builder.add(dynamicClasspath);\n        builder.add(CommandLineWrapper.class.getName());\n        builder.add(classpathFile.getAbsolutePath());\n      }\n      catch (Throwable e) {\n        builder.add(classpath);\n      }\n    }\n    else {\n      builder.add(classpath);\n    }\n\n    builder.add(JUnitForkedStarter.class.getName());\n    builder.add(testOutputPath);\n    builder.add(startIndex);\n    builder.add(String.valueOf(isJUnit4));\n    builder.add(description);\n    builder.add(listeners);\n    builder.setWorkingDir(workingDir);\n\n    final Process exec = builder.createProcess();\n    final int result = exec.waitFor();\n    ForkedVMWrapper.readWrapped(testOutputPath,\n                                JUnitStarter.SM_RUNNER ? ((PrintStream)out) : ((SegmentedOutputStream)out).getPrintStream(),\n                                JUnitStarter.SM_RUNNER ? ((PrintStream)err) : ((SegmentedOutputStream)err).getPrintStream());\n    return result;\n  }","commit_id":"b062b8061a8a5e32d2f286ae214fe699b3a68484","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int prepareStreamsAndStart(String[] args,\n                                            final boolean isJUnit4,\n                                            ArrayList listeners,\n                                            String name,\n                                            SegmentedOutputStream out,\n                                            SegmentedOutputStream err) {\n    PrintStream oldOut = System.out;\n    PrintStream oldErr = System.err;\n    try {\n      System.setOut(new PrintStream(out));\n      System.setErr(new PrintStream(err));\n      if (ourCommandFileName != null) {\n        if (!\"none\".equals(ourForkMode) || ourWorkingDirs != null && new File(ourWorkingDirs).length() > 0) {\n          return JUnitForkedStarter.startForkedVMs(ourWorkingDirs, args, isJUnit4, listeners, name, out, err, ourForkMode, ourCommandFileName);\n        }\n      }\n      IdeaTestRunner testRunner = (IdeaTestRunner)getAgentClass(isJUnit4).newInstance();\n      testRunner.setStreams(out, err, 0);\n      return testRunner.startRunnerWithArgs(args, listeners, name, ourCount, !SM_RUNNER);\n    }\n    catch (Exception e) {\n      e.printStackTrace(System.err);\n      return -2;\n    }\n    finally {\n      System.setOut(oldOut);\n      System.setErr(oldErr);\n    }\n  }","id":73120,"modified_method":"private static int prepareStreamsAndStart(String[] args,\n                                            final boolean isJUnit4,\n                                            ArrayList listeners,\n                                            String name) {\n    PrintStream oldOut = System.out;\n    PrintStream oldErr = System.err;\n    try {\n      IdeaTestRunner testRunner = (IdeaTestRunner)getAgentClass(isJUnit4).newInstance();\n      Object out = SM_RUNNER ? System.out : (Object)new SegmentedOutputStream(System.out);\n      Object err = SM_RUNNER ? System.err : (Object)new SegmentedOutputStream(System.err);\n      if (!SM_RUNNER) {\n        System.setOut(new PrintStream((OutputStream)out));\n        System.setErr(new PrintStream((OutputStream)err));\n      }\n      if (ourCommandFileName != null) {\n        if (!\"none\".equals(ourForkMode) || ourWorkingDirs != null && new File(ourWorkingDirs).length() > 0) {\n          return JUnitForkedStarter.startForkedVMs(ourWorkingDirs, args, isJUnit4, listeners, name, out, err, ourForkMode, ourCommandFileName);\n        }\n      }\n      testRunner.setStreams(out, err, 0);\n      return testRunner.startRunnerWithArgs(args, listeners, name, ourCount, !SM_RUNNER);\n    }\n    catch (Exception e) {\n      e.printStackTrace(System.err);\n      return -2;\n    }\n    finally {\n      System.setOut(oldOut);\n      System.setErr(oldErr);\n    }\n  }","commit_id":"b062b8061a8a5e32d2f286ae214fe699b3a68484","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean checkVersion(String[] args, SegmentedOutputStream notifications) {\n    for (int i = 0; i < args.length; i++) {\n      String arg = args[i];\n      if (arg.startsWith(IDE_VERSION)) {\n        int ideVersion = Integer.parseInt(arg.substring(IDE_VERSION.length(), arg.length()));\n        if (ideVersion != VERSION) {\n          PrintStream stream = new PrintStream(notifications);\n          stream.println(\"Wrong agent version: \" + VERSION + \". IDE expects version: \" + ideVersion);\n          stream.flush();\n          return false;\n        } else\n          return true;\n      }\n    }\n    return false;\n  }","id":73121,"modified_method":"public static boolean checkVersion(String[] args, PrintStream printStream) {\n    for (int i = 0; i < args.length; i++) {\n      String arg = args[i];\n      if (arg.startsWith(IDE_VERSION)) {\n        int ideVersion = Integer.parseInt(arg.substring(IDE_VERSION.length(), arg.length()));\n        if (ideVersion != VERSION) {\n          printStream.println(\"Wrong agent version: \" + VERSION + \". IDE expects version: \" + ideVersion);\n          printStream.flush();\n          return false;\n        } else\n          return true;\n      }\n    }\n    return false;\n  }","commit_id":"b062b8061a8a5e32d2f286ae214fe699b3a68484","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean canWorkWithJUnitVersion(OutputStream notifications, boolean isJUnit4) {\n    final PrintStream stream = new PrintStream(notifications);\n    try {\n      junitVersionChecks(isJUnit4);\n    } catch (Throwable e) {\n      stream.println(\"!!! JUnit version 3.8 or later expected:\");\n      stream.println();\n      e.printStackTrace(stream);\n      stream.flush();\n      return false;\n    } finally {\n      stream.flush();\n    }\n    return true;\n  }","id":73122,"modified_method":"private static boolean canWorkWithJUnitVersion(PrintStream printStream, boolean isJUnit4) {\n    try {\n      junitVersionChecks(isJUnit4);\n    } catch (Throwable e) {\n      printStream.println(\"!!! JUnit version 3.8 or later expected:\");\n      printStream.println();\n      e.printStackTrace(printStream);\n      printStream.flush();\n      return false;\n    } finally {\n      printStream.flush();\n    }\n    return true;\n  }","commit_id":"b062b8061a8a5e32d2f286ae214fe699b3a68484","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void main(String[] args) throws IOException {\n    SegmentedOutputStream out = new SegmentedOutputStream(System.out);\n    SegmentedOutputStream err = new SegmentedOutputStream(System.err);\n    Vector argList = new Vector();\n    for (int i = 0; i < args.length; i++) {\n      String arg = args[i];\n      argList.addElement(arg);\n    }\n\n    final ArrayList listeners = new ArrayList();\n    final String[] name = new String[1];\n\n    boolean isJUnit4 = processParameters(argList, listeners, name);\n\n    if (!canWorkWithJUnitVersion(err, isJUnit4)) {\n      err.flush();\n      System.exit(-3);\n    }\n    if (!checkVersion(args, err)) {\n      err.flush();\n      System.exit(-3);\n    }\n\n    String[] array = new String[argList.size()];\n    argList.copyInto(array);\n    int exitCode = prepareStreamsAndStart(array, isJUnit4, listeners, name[0], out, err);\n    System.exit(exitCode);\n  }","id":73123,"modified_method":"public static void main(String[] args) throws IOException {\n    Vector argList = new Vector();\n    for (int i = 0; i < args.length; i++) {\n      String arg = args[i];\n      argList.addElement(arg);\n    }\n\n    final ArrayList listeners = new ArrayList();\n    final String[] name = new String[1];\n\n    boolean isJUnit4 = processParameters(argList, listeners, name);\n\n    if (!canWorkWithJUnitVersion(System.err, isJUnit4)) {\n      System.exit(-3);\n    }\n    if (!checkVersion(args, System.err)) {\n      System.exit(-3);\n    }\n\n    String[] array = new String[argList.size()];\n    argList.copyInto(array);\n    int exitCode = prepareStreamsAndStart(array, isJUnit4, listeners, name[0]);\n    System.exit(exitCode);\n  }","commit_id":"b062b8061a8a5e32d2f286ae214fe699b3a68484","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Determines, when the ANT Task that is represented by the \"node\" should perform.\n     * Node must be an ANT Task or no \"perform\" is called.\n     * If node is an ANT Task, it performs right after complete construction.\n     * If node is nested in a TaskContainer, calling \"perform\" is delegated to that\n     * TaskContainer.\n     *\n     * @param parent note: null when node is root\n     * @param node   the node that now has all its children applied\n     */\n    protected void nodeCompleted(final Object parent, final Object node) {\n        if (parent == null) insideTask = false;\n        antElementHandler.onEndElement(null, null, antXmlContext);\n\n        lastCompletedNode = node;\n        if (parent != null && !(parent instanceof Target)) {\n            log.finest(\"parent is not null: no perform on nodeCompleted\");\n            return; // parent will care about when children perform\n        }\n\n        // as in Target.execute()\n        if (node instanceof Task) {\n            Task task = (Task) node;\n            final String taskName = task.getTaskName();\n\n            if (\"antcall\".equals(taskName) && parent == null) {\n                throw new BuildException(\"antcall not supported within AntBuilder, consider using 'ant.project.executeTarget('targetName')' instead.\");\n            }\n\n            // save original streams\n            InputStream savedProjectInputStream = project.getDefaultInputStream();\n            InputStream savedIn = System.in;\n            PrintStream savedErr = System.err;\n            PrintStream savedOut = System.out;\n\n            if (!(savedIn instanceof DemuxInputStream)) {\n                project.setDefaultInputStream(savedIn);\n                System.setIn(new DemuxInputStream(project));\n            }\n            System.setOut(new PrintStream(new DemuxOutputStream(project, false)));\n            System.setErr(new PrintStream(new DemuxOutputStream(project, true)));\n\n            try {\n                lastCompletedNode = performTask(task);\n            } finally {\n                // restore original streams\n                project.setDefaultInputStream(savedProjectInputStream);\n                System.setIn(savedIn);\n                System.setOut(savedOut);\n                System.setErr(savedErr);\n            }\n\n            // restore dummy collector target\n            if (\"import\".equals(taskName)) {\n                antXmlContext.setCurrentTarget(collectorTarget);\n            }\n        } else if (node instanceof Target) {\n            // restore dummy collector target\n            antXmlContext.setCurrentTarget(collectorTarget);\n        } else {\n            final RuntimeConfigurable r = (RuntimeConfigurable) node;\n            r.maybeConfigure(project);\n        }\n    }","id":73124,"modified_method":"/**\n     * Determines, when the ANT Task that is represented by the \"node\" should perform.\n     * Node must be an ANT Task or no \"perform\" is called.\n     * If node is an ANT Task, it performs right after complete construction.\n     * If node is nested in a TaskContainer, calling \"perform\" is delegated to that\n     * TaskContainer.\n     *\n     * @param parent note: null when node is root\n     * @param node   the node that now has all its children applied\n     */\n    protected void nodeCompleted(final Object parent, final Object node) {\n        if (parent == null) insideTask = false;\n        antElementHandler.onEndElement(null, null, antXmlContext);\n\n        lastCompletedNode = node;\n        if (parent != null && !(parent instanceof Target)) {\n            log.finest(\"parent is not null: no perform on nodeCompleted\");\n            return; // parent will care about when children perform\n        }\n\n        // as in Target.execute()\n        if (node instanceof Task) {\n            Task task = (Task) node;\n            final String taskName = task.getTaskName();\n\n            if (\"antcall\".equals(taskName) && parent == null) {\n                throw new BuildException(\"antcall not supported within AntBuilder, consider using 'ant.project.executeTarget('targetName')' instead.\");\n            }\n\n            if (savingStreams) {\n                // save original streams\n                int currentStreamCount = streamCount.getAndIncrement();\n                if (currentStreamCount == 0) {\n                    // we are first, save the streams\n                    savedProjectInputStream = project.getDefaultInputStream();\n                    savedIn = System.in;\n                    savedErr = System.err;\n                    savedOut = System.out;\n\n                    if (!(savedIn instanceof DemuxInputStream)) {\n                        project.setDefaultInputStream(savedIn);\n                        demuxInputStream = new DemuxInputStream(project);\n                        System.setIn(demuxInputStream);\n                    }\n                    demuxOutputStream = new DemuxOutputStream(project, false);\n                    System.setOut(new PrintStream(demuxOutputStream));\n                    demuxErrorStream = new DemuxOutputStream(project, true);\n                    System.setErr(new PrintStream(demuxErrorStream));\n                }\n            }\n\n            try {\n                lastCompletedNode = performTask(task);\n            } finally {\n                if (savingStreams) {\n                    int currentStreamCount = streamCount.decrementAndGet();\n                    if (currentStreamCount == 0) {\n                        // last to leave, turn out the lights: restore original streams\n                        project.setDefaultInputStream(savedProjectInputStream);\n                        System.setIn(savedIn);\n                        System.setOut(savedOut);\n                        System.setErr(savedErr);\n                        if (demuxInputStream != null) DefaultGroovyMethodsSupport.closeQuietly(demuxInputStream);\n                        DefaultGroovyMethodsSupport.closeQuietly(demuxOutputStream);\n                        DefaultGroovyMethodsSupport.closeQuietly(demuxErrorStream);\n                        demuxInputStream = null;\n                        demuxOutputStream = null;\n                        demuxErrorStream = null;\n                    }\n                }\n            }\n\n            // restore dummy collector target\n            if (\"import\".equals(taskName)) {\n                antXmlContext.setCurrentTarget(collectorTarget);\n            }\n        } else if (node instanceof Target) {\n            // restore dummy collector target\n            antXmlContext.setCurrentTarget(collectorTarget);\n        } else {\n            final RuntimeConfigurable r = (RuntimeConfigurable) node;\n            r.maybeConfigure(project);\n        }\n    }","commit_id":"ac9547d3df76c65d5653728d3fc404687e158ba9","url":"https://github.com/apache/groovy"},{"original_method":"public AntBuilder(final Project project, final Target owningTarget) {\n        this.project = project;\n\n        /*\n         * GROOVY-4524: The following is not needed anymore as an ant Project already by default has inputhandler\n         * set to DefaultInputHandler. And if it is again set here, it mistakenly overrides the custom input handler\n         * if set using -inputhandler switch. \n         */\n        //this.project.setInputHandler(new DefaultInputHandler());\n\n        collectorTarget = owningTarget;\n        antXmlContext = new AntXMLContext(project);\n        collectorTarget.setProject(project);\n        antXmlContext.setCurrentTarget(collectorTarget);\n        antXmlContext.setLocator(new AntBuilderLocator());\n        antXmlContext.setCurrentTargets(new HashMap());\n\n        implicitTarget = new Target();\n        implicitTarget.setProject(project);\n        implicitTarget.setName(\"\");\n        antXmlContext.setImplicitTarget(implicitTarget);\n\n        // FileScanner is a Groovy hack (utility?)\n        project.addDataTypeDefinition(\"fileScanner\", FileScanner.class);\n    }","id":73125,"modified_method":"public AntBuilder(final Project project, final Target owningTarget) {\n        this.project = project;\n\n        /*\n         * GROOVY-4524: The following is not needed anymore as an ant Project already by default has inputhandler\n         * set to DefaultInputHandler. And if it is again set here, it mistakenly overrides the custom input handler\n         * if set using -inputhandler switch. \n         */\n        //this.project.setInputHandler(new DefaultInputHandler());\n\n        collectorTarget = owningTarget;\n        antXmlContext = new AntXMLContext(project);\n        collectorTarget.setProject(project);\n        antXmlContext.setCurrentTarget(collectorTarget);\n        antXmlContext.setLocator(new AntBuilderLocator());\n        antXmlContext.setCurrentTargets(new HashMap<String, Target>());\n\n        implicitTarget = new Target();\n        implicitTarget.setProject(project);\n        implicitTarget.setName(\"\");\n        antXmlContext.setImplicitTarget(implicitTarget);\n\n        // FileScanner is a Groovy utility\n        project.addDataTypeDefinition(\"fileScanner\", FileScanner.class);\n    }","commit_id":"ac9547d3df76c65d5653728d3fc404687e158ba9","url":"https://github.com/apache/groovy"},{"original_method":"public void start(List<String> xmls) throws FileNotFoundException, IOException, InterruptedException\n    {\n        // Setup Start / Stop Monitoring\n        startMonitor();\n\n        // Load potential Config (start.config)\n        List<String> configuredXmls = loadConfig(xmls);\n\n        // No XML defined in start.config or command line.  Can't execute.\n        if (configuredXmls.isEmpty())\n        {\n            throw new FileNotFoundException(\"No XML configuration files specified in start.config or command line.\");\n        }\n\n        // Add mandatory options for secure mode\n        if (_secure)\n        {\n            _config.addActiveOption(\"policy\");\n            _config.addActiveOption(\"security\");\n        }\n\n        // Normalize the XML config options passed on the command line.\n        configuredXmls = resolveXmlConfigs(configuredXmls);\n\n        // Get Desired Classpath based on user provided Active Options.\n        Classpath classpath = _config.getActiveClasspath();\n\n        System.setProperty(\"java.class.path\",classpath.toString());\n        ClassLoader cl = classpath.getClassLoader();\n        if (Config.isDebug())\n        {\n            System.err.println(\"java.class.path=\" + System.getProperty(\"java.class.path\"));\n            System.err.println(\"jetty.home=\" + System.getProperty(\"jetty.home\"));\n            System.err.println(\"java.home=\" + System.getProperty(\"java.home\"));\n            System.err.println(\"java.io.tmpdir=\" + System.getProperty(\"java.io.tmpdir\"));\n            System.err.println(\"java.class.path=\" + classpath);\n            System.err.println(\"classloader=\" + cl);\n            System.err.println(\"classloader.parent=\" + cl.getParent());\n        }\n\n        // Show the usage information and return\n        if (_showUsage)\n        {\n            usage();\n            return;\n        }\n\n        // Show the version information and return\n        if (_dumpVersions)\n        {\n            showClasspathWithVersions(classpath);\n            showActiveSecurityPolicies(cl);\n            return;\n        }\n\n        // Show all options with version information\n        if (_listOptions)\n        {\n            showAllOptionsWithVersions(classpath);\n            return;\n        }\n        \n        if (_listConfig)\n        {\n            listConfig();\n            return;\n        }\n\n        // Show Command Line to execute Jetty\n        if (_dryRun)\n        {\n            System.out.println(buildCommandLine(classpath,configuredXmls));\n            return;\n        }\n        \n        // Show Command Line to execute Jetty\n        if (_exec)\n        {\n            String cmd = buildCommandLine(classpath,configuredXmls);\n            Process process = Runtime.getRuntime().exec(cmd);\n            copyInThread(process.getErrorStream(),System.err);\n            copyInThread(process.getInputStream(),System.out);\n            copyInThread(System.in,process.getOutputStream());\n            process.waitFor();\n            return;\n        }\n        \n        if (_jvmArgs.size()>0 || _sysProps.size()>0)\n            System.err.println(\"WARNING: System properties and/or JVM args set.  Consider using --dry-run or --exec\");\n\n        // Set current context class loader to what is selected.\n        Thread.currentThread().setContextClassLoader(cl);\n\n        // Initialize the Security\n        initSecurity(cl);\n\n        // Invoke the Main Class\n        try\n        {\n            // Get main class as defined in start.config\n            String classname = _config.getMainClassname();\n\n            // Check for override of start class (via \"jetty.server\" property)\n            String mainClass = System.getProperty(\"jetty.server\");\n            if (mainClass != null)\n                classname = mainClass;\n\n            // Check for override of start class (via \"main.class\" property)\n            mainClass = System.getProperty(\"main.class\");\n            if (mainClass != null)\n                classname = mainClass;\n\n            Config.debug(\"main.class=\" + classname);\n\n            invokeMain(cl,classname,configuredXmls);\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n    }","id":73126,"modified_method":"public void start(List<String> xmls) throws FileNotFoundException, IOException, InterruptedException\n    {\n        // Setup Start / Stop Monitoring\n        startMonitor();\n\n        // Load potential Config (start.config)\n        List<String> configuredXmls = loadConfig(xmls);\n\n        // No XML defined in start.config or command line.  Can't execute.\n        if (configuredXmls.isEmpty())\n        {\n            throw new FileNotFoundException(\"No XML configuration files specified in start.config or command line.\");\n        }\n\n        // Add mandatory options for secure mode\n        if (_secure)\n        {\n            _config.addActiveOption(\"policy\");\n            _config.addActiveOption(\"security\");\n        }\n\n        // Normalize the XML config options passed on the command line.\n        configuredXmls = resolveXmlConfigs(configuredXmls);\n\n        // Get Desired Classpath based on user provided Active Options.\n        Classpath classpath = _config.getActiveClasspath();\n\n        System.setProperty(\"java.class.path\",classpath.toString());\n        ClassLoader cl = classpath.getClassLoader();\n        if (Config.isDebug())\n        {\n            System.err.println(\"java.class.path=\" + System.getProperty(\"java.class.path\"));\n            System.err.println(\"jetty.home=\" + System.getProperty(\"jetty.home\"));\n            System.err.println(\"java.home=\" + System.getProperty(\"java.home\"));\n            System.err.println(\"java.io.tmpdir=\" + System.getProperty(\"java.io.tmpdir\"));\n            System.err.println(\"java.class.path=\" + classpath);\n            System.err.println(\"classloader=\" + cl);\n            System.err.println(\"classloader.parent=\" + cl.getParent());\n        }\n\n        // Show the usage information and return\n        if (_showUsage)\n        {\n            usage();\n            return;\n        }\n\n        // Show the version information and return\n        if (_dumpVersions)\n        {\n            showClasspathWithVersions(classpath);\n            showActiveSecurityPolicies(cl);\n            return;\n        }\n\n        // Show all options with version information\n        if (_listOptions)\n        {\n            showAllOptionsWithVersions(classpath);\n            return;\n        }\n        \n        if (_listConfig)\n        {\n            listConfig();\n            return;\n        }\n\n        // Show Command Line to execute Jetty\n        if (_dryRun)\n        {\n            System.out.println(buildCommandLine(classpath,configuredXmls));\n            return;\n        }\n        \n        // Show Command Line to execute Jetty\n        if (_exec)\n        {\n            String cmd = buildCommandLine(classpath,configuredXmls);\n            Process process = Runtime.getRuntime().exec(cmd);\n            copyInThread(process.getErrorStream(),System.err);\n            copyInThread(process.getInputStream(),System.out);\n            copyInThread(System.in,process.getOutputStream());\n            process.waitFor();\n            return;\n        }\n        \n        if (_jvmArgs.size() > 0 || _sysProps.size() > 0)\n        {\n            System.err.println(\"WARNING: System properties and/or JVM args set.  Consider using --dry-run or --exec\");\n        }\n\n        // Set current context class loader to what is selected.\n        Thread.currentThread().setContextClassLoader(cl);\n\n        // Initialize the Security\n        initSecurity(cl);\n\n        // Invoke the Main Class\n        try\n        {\n            // Get main class as defined in start.config\n            String classname = _config.getMainClassname();\n\n            // Check for override of start class (via \"jetty.server\" property)\n            String mainClass = System.getProperty(\"jetty.server\");\n            if (mainClass != null)\n            {\n                classname = mainClass;\n            }\n\n            // Check for override of start class (via \"main.class\" property)\n            mainClass = System.getProperty(\"main.class\");\n            if (mainClass != null)\n            {\n                classname = mainClass;\n            }\n\n            Config.debug(\"main.class=\" + classname);\n\n            invokeMain(cl,classname,configuredXmls);\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace(System.err);\n            System.exit(ERR_INVOKE_MAIN);\n        }\n    }","commit_id":"2dee039305a6d1a867f069e73c42e8cbbdcfeb16","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void listConfig()\n    {\n        InputStream cfgstream = null;\n        try\n        {\n            cfgstream=getConfigStream();\n            byte[] buf=new byte[4096];\n            \n            int len=0;\n            \n            while (len>=0)\n            {\n                len=cfgstream.read(buf);\n                if (len>0)\n                    System.out.write(buf,0,len);\n            }\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n            System.exit(1);\n        }\n        finally\n        {\n            close(cfgstream);\n        }\n    }","id":73127,"modified_method":"private void listConfig()\n    {\n        InputStream cfgstream = null;\n        try\n        {\n            cfgstream=getConfigStream();\n            byte[] buf=new byte[4096];\n            \n            int len=0;\n            \n            while (len>=0)\n            {\n                len=cfgstream.read(buf);\n                if (len>0)\n                    System.out.write(buf,0,len);\n            }\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace(System.err);\n            System.exit(ERR_UNKNOWN);\n        }\n        finally\n        {\n            close(cfgstream);\n        }\n    }","commit_id":"2dee039305a6d1a867f069e73c42e8cbbdcfeb16","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void initSecurity(ClassLoader cl)\n    {\n        // Init the Security Policies\n        try\n        {\n            if (_secure)\n            {\n                Policy.setPolicy(_config.getPolicyInstance(cl));\n                System.setSecurityManager(new SecurityManager());\n                // Policy.getPolicy().refresh();\n            }\n            else\n            {\n                Policy policy = Policy.getPolicy();\n                if (policy != null)\n                    policy.refresh();\n            }\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n    }","id":73128,"modified_method":"private void initSecurity(ClassLoader cl)\n    {\n        // Init the Security Policies\n        try\n        {\n            if (_secure)\n            {\n                Policy.setPolicy(_config.getPolicyInstance(cl));\n                System.setSecurityManager(new SecurityManager());\n                // Policy.getPolicy().refresh();\n            }\n            else\n            {\n                Policy policy = Policy.getPolicy();\n                if (policy != null)\n                {\n                    policy.refresh();\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace(System.err);\n            System.exit(ERR_SECURITY);\n        }\n    }","commit_id":"2dee039305a6d1a867f069e73c42e8cbbdcfeb16","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Load Configuration.\n     * \n     * No specific configuration is real until a {@link Config#getCombinedClasspath(java.util.Collection)} is used to\n     * execute the {@link Class} specified by {@link Config#getMainClassname()} is executed.\n     * \n     * @param xmls\n     *            the command line specified xml configuration options.\n     * @return the list of xml configurations arriving via command line and start.config choices.\n     */\n    private List<String> loadConfig(List<String> xmls)\n    {\n        InputStream cfgstream = null;\n        try\n        {\n            // Pass in xmls.size into Config so that conditions based on \"nargs\" work.\n            _config.setArgCount(xmls.size());\n            \n            cfgstream=getConfigStream();\n                \n            // parse the config\n            _config.parse(cfgstream);\n            \n            _jettyHome = _config.getProperty(\"jetty.home\");\n            if (_jettyHome != null)\n            {\n                _jettyHome = new File(_jettyHome).getCanonicalPath();\n                System.setProperty(\"jetty.home\",_jettyHome);\n            }\n\n            // Collect the configured xml configurations.\n            List<String> ret = new ArrayList<String>();\n            ret.addAll(xmls); // add command line provided xmls first.\n            for (String xmlconfig : _config.getXmlConfigs())\n            {\n                // add xmlconfigs arriving via start.config\n                if (!ret.contains(xmlconfig))\n                {\n                    ret.add(xmlconfig);\n                }\n            }\n\n            return ret;\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n            System.exit(1);\n            return null; // never executed (just to satisfy javac compiler)\n        }\n        finally\n        {\n            close(cfgstream);\n        }\n    }","id":73129,"modified_method":"/**\n     * Load Configuration.\n     * \n     * No specific configuration is real until a {@link Config#getCombinedClasspath(java.util.Collection)} is used to\n     * execute the {@link Class} specified by {@link Config#getMainClassname()} is executed.\n     * \n     * @param xmls\n     *            the command line specified xml configuration options.\n     * @return the list of xml configurations arriving via command line and start.config choices.\n     */\n    private List<String> loadConfig(List<String> xmls)\n    {\n        InputStream cfgstream = null;\n        try\n        {\n            // Pass in xmls.size into Config so that conditions based on \"nargs\" work.\n            _config.setArgCount(xmls.size());\n            \n            cfgstream=getConfigStream();\n                \n            // parse the config\n            _config.parse(cfgstream);\n            \n            _jettyHome = _config.getProperty(\"jetty.home\");\n            if (_jettyHome != null)\n            {\n                _jettyHome = new File(_jettyHome).getCanonicalPath();\n                System.setProperty(\"jetty.home\",_jettyHome);\n            }\n\n            // Collect the configured xml configurations.\n            List<String> ret = new ArrayList<String>();\n            ret.addAll(xmls); // add command line provided xmls first.\n            for (String xmlconfig : _config.getXmlConfigs())\n            {\n                // add xmlconfigs arriving via start.config\n                if (!ret.contains(xmlconfig))\n                {\n                    ret.add(xmlconfig);\n                }\n            }\n\n            return ret;\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n            System.exit(ERR_UNKNOWN);\n            return null; // never executed (just here to satisfy javac compiler)\n        }\n        finally\n        {\n            close(cfgstream);\n        }\n    }","commit_id":"2dee039305a6d1a867f069e73c42e8cbbdcfeb16","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Stop a running jetty instance.\n     */\n    public void stop(int port, String key)\n    {\n        int _port = port;\n        String _key = key;\n\n        try\n        {\n            if (_port <= 0)\n                System.err.println(\"STOP.PORT system property must be specified\");\n            if (_key == null)\n            {\n                _key = \"\";\n                System.err.println(\"STOP.KEY system property must be specified\");\n                System.err.println(\"Using empty key\");\n            }\n\n            Socket s = new Socket(InetAddress.getByName(\"127.0.0.1\"),_port);\n            OutputStream out = s.getOutputStream();\n            out.write((_key + \"\\r\\nstop\\r\\n\").getBytes());\n            out.flush();\n            s.close();\n        }\n        catch (ConnectException e)\n        {\n            System.err.println(\"ERROR: Not running!\");\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n    }","id":73130,"modified_method":"/**\n     * Stop a running jetty instance.\n     */\n    public void stop(int port, String key)\n    {\n        int _port = port;\n        String _key = key;\n\n        try\n        {\n            if (_port <= 0)\n            {\n                System.err.println(\"STOP.PORT system property must be specified\");\n            }\n            if (_key == null)\n            {\n                _key = \"\";\n                System.err.println(\"STOP.KEY system property must be specified\");\n                System.err.println(\"Using empty key\");\n            }\n\n            Socket s = new Socket(InetAddress.getByName(\"127.0.0.1\"),_port);\n            try\n            {\n                OutputStream out = s.getOutputStream();\n                out.write((_key + \"\\r\\nstop\\r\\n\").getBytes());\n                out.flush();\n            }\n            finally\n            {\n                s.close();\n            }\n        }\n        catch (ConnectException e)\n        {\n            System.err.println(\"ERROR: Not running!\");\n            System.exit(ERR_NOT_STOPPED);\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace(System.err);\n            System.exit(ERR_UNKNOWN);\n        }\n    }","commit_id":"2dee039305a6d1a867f069e73c42e8cbbdcfeb16","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void parseCommandLine(String[] args)\n    {\n        try\n        {\n            List<String> arguments = new ArrayList<String>();\n\n            // add the command line args and look for start.ini args\n            boolean ini=false;\n            for (String arg : args)\n            {\n                if (arg.startsWith(\"--ini=\")||arg.equals(\"--ini\"))\n                {\n                    ini=true;\n                    if (arg.length()>6)\n                    {\n                        arguments.addAll(loadStartIni(arg.substring(6)));\n                        continue;\n                    }\n                }\n                else if (arg.startsWith(\"--config=\"))\n                {\n                    _startConfig=arg.substring(9);\n                }\n                else\n                    arguments.add(arg);\n            }\n            \n            // if no non-option inis, add the start.ini\n            if (!ini)\n                arguments.addAll(0,loadStartIni(null));\n            \n            // The XML Configuration Files to initialize with\n            List<String> xmls = new ArrayList<String>();\n\n            // Process the arguments\n            for (String arg : arguments)\n            {\n                \n                if (\"--help\".equals(arg) || \"-?\".equals(arg))\n                {\n                    _showUsage = true;\n                    continue;\n                }\n\n                if (\"--stop\".equals(arg))\n                {\n                    int port = Integer.parseInt(_config.getProperty(\"STOP.PORT\",System.getProperty(\"STOP.PORT\",\"-1\")));\n                    String key = _config.getProperty(\"STOP.KEY\",System.getProperty(\"STOP.KEY\",null));\n                    stop(port,key);\n                    return;\n                }\n\n                if (\"--version\".equals(arg) || \"-v\".equals(arg) || \"--info\".equals(arg))\n                {\n                    _dumpVersions = true;\n                    continue;\n                }\n\n                if (\"--list-modes\".equals(arg) || \"--list-options\".equals(arg))\n                {\n                    _listOptions = true;\n                    continue;\n                }\n\n                if (\"--list-config\".equals(arg))\n                {\n                    _listConfig=true;\n                    continue;\n                }\n\n                if (\"--exec-print\".equals(arg)||\"--dry-run\".equals(arg))\n                {\n                    _dryRun = true;\n                    continue;\n                }\n\n                if (\"--exec\".equals(arg))\n                {\n                    _exec = true;\n                    continue;\n                }\n\n                // Special internal indicator that jetty was started by the jetty.sh Daemon\n                if (\"--daemon\".equals(arg))\n                {\n                    PrintStream logger = new PrintStream(new FileOutputStream(new File(System.getProperty(\"jetty.log\",\".\"),\"start.log\")));\n                    System.setOut(logger);\n                    System.setErr(logger);\n                    continue;\n                }\n\n                if (\"--secure\".equals(arg))\n                {\n                    _secure = true;\n                    continue;\n                }\n                \n                if (arg.startsWith(\"-D\"))\n                {\n                    String[] assign = arg.substring(2).split(\"=\",2);\n                    _sysProps.add(assign[0]);\n                    switch(assign.length)\n                    {\n                        case 2:\n                            System.setProperty(assign[0],assign[1]);\n                            break;\n                        case 1:\n                            System.setProperty(assign[0],\"\");\n                            break;\n                        default:\n                            break;\n                    }\n                    continue;\n                }\n\n                if (arg.startsWith(\"-\"))\n                {\n                    _jvmArgs.add(arg);\n                    continue;\n                }\n\n                // Is this a Property?\n                if (arg.indexOf('=') >= 0)\n                {\n                    String[] assign = arg.split(\"=\",2);\n\n                    switch(assign.length)\n                    {\n                        case 2:\n                            if (\"OPTIONS\".equals(assign[0]))\n                            {\n                                String opts[] = assign[1].split(\",\");\n                                for (String opt : opts)\n                                    _config.addActiveOption(opt);\n                            }\n                            else\n                                this._config.setProperty(assign[0],assign[1]);\n                            break;\n                        case 1:\n                            this._config.setProperty(assign[0],null);\n                            break;\n                        default:\n                            break;\n                    }\n                    \n                    continue;\n                }\n\n                // Anything else is considered an XML file.\n                xmls.add(arg);\n            }\n            \n            start(xmls);\n        }\n        catch (Throwable t)\n        {\n            t.printStackTrace(System.err);\n            System.out.println(\"Use java -jar start.jar --help for usage information.\");\n        }\n    }","id":73131,"modified_method":"public void parseCommandLine(String[] args)\n    {\n        try\n        {\n            List<String> arguments = new ArrayList<String>();\n\n            // add the command line args and look for start.ini args\n            boolean ini=false;\n            for (String arg : args)\n            {\n                if (arg.startsWith(\"--ini=\")||arg.equals(\"--ini\"))\n                {\n                    ini=true;\n                    if (arg.length()>6)\n                    {\n                        arguments.addAll(loadStartIni(arg.substring(6)));\n                        continue;\n                    }\n                }\n                else if (arg.startsWith(\"--config=\"))\n                {\n                    _startConfig=arg.substring(9);\n                }\n                else\n                {\n                    arguments.add(arg);\n                }\n            }\n            \n            // if no non-option inis, add the start.ini\n            if (!ini)\n            {\n                arguments.addAll(0,loadStartIni(null));\n            }\n            \n            // The XML Configuration Files to initialize with\n            List<String> xmls = new ArrayList<String>();\n\n            // Process the arguments\n            for (String arg : arguments)\n            {\n                \n                if (\"--help\".equals(arg) || \"-?\".equals(arg))\n                {\n                    _showUsage = true;\n                    continue;\n                }\n\n                if (\"--stop\".equals(arg))\n                {\n                    int port = Integer.parseInt(_config.getProperty(\"STOP.PORT\",System.getProperty(\"STOP.PORT\",\"-1\")));\n                    String key = _config.getProperty(\"STOP.KEY\",System.getProperty(\"STOP.KEY\",null));\n                    stop(port,key);\n                    return;\n                }\n\n                if (\"--version\".equals(arg) || \"-v\".equals(arg) || \"--info\".equals(arg))\n                {\n                    _dumpVersions = true;\n                    continue;\n                }\n\n                if (\"--list-modes\".equals(arg) || \"--list-options\".equals(arg))\n                {\n                    _listOptions = true;\n                    continue;\n                }\n\n                if (\"--list-config\".equals(arg))\n                {\n                    _listConfig=true;\n                    continue;\n                }\n\n                if (\"--exec-print\".equals(arg)||\"--dry-run\".equals(arg))\n                {\n                    _dryRun = true;\n                    continue;\n                }\n\n                if (\"--exec\".equals(arg))\n                {\n                    _exec = true;\n                    continue;\n                }\n\n                // Special internal indicator that jetty was started by the jetty.sh Daemon\n                if (\"--daemon\".equals(arg))\n                {\n                    File startLog = new File(System.getProperty(\"jetty.logs\",\".\"),\"start.log\");\n                    if (!startLog.exists() && !startLog.createNewFile())\n                    {\n                        // Output about error is lost in majority of cases.\n                        System.err.println(\"Unable to create: \" + startLog.getAbsolutePath());\n                        // Toss a unique exit code indicating this failure.\n                        System.exit(ERR_LOGGING);\n                    }\n\n                    if (!startLog.canWrite())\n                    {\n                        // Output about error is lost in majority of cases.\n                        System.err.println(\"Unable to write to: \" + startLog.getAbsolutePath());\n                        // Toss a unique exit code indicating this failure.\n                        System.exit(ERR_LOGGING);\n                    }\n                    PrintStream logger = new PrintStream(new FileOutputStream(startLog,true));\n                    System.setOut(logger);\n                    System.setErr(logger);\n                    System.out.println(\"Establishing start.log on \" + new Date());\n                    continue;\n                }\n\n                if (\"--secure\".equals(arg))\n                {\n                    _secure = true;\n                    continue;\n                }\n                \n                if (arg.startsWith(\"-D\"))\n                {\n                    String[] assign = arg.substring(2).split(\"=\",2);\n                    _sysProps.add(assign[0]);\n                    switch(assign.length)\n                    {\n                        case 2:\n                            System.setProperty(assign[0],assign[1]);\n                            break;\n                        case 1:\n                            System.setProperty(assign[0],\"\");\n                            break;\n                        default:\n                            break;\n                    }\n                    continue;\n                }\n\n                if (arg.startsWith(\"-\"))\n                {\n                    _jvmArgs.add(arg);\n                    continue;\n                }\n\n                // Is this a Property?\n                if (arg.indexOf('=') >= 0)\n                {\n                    String[] assign = arg.split(\"=\",2);\n\n                    switch(assign.length)\n                    {\n                        case 2:\n                            if (\"OPTIONS\".equals(assign[0]))\n                            {\n                                String opts[] = assign[1].split(\",\");\n                                for (String opt : opts)\n                                    _config.addActiveOption(opt);\n                            }\n                            else\n                            {\n                                this._config.setProperty(assign[0],assign[1]);\n                            }\n                            break;\n                        case 1:\n                            this._config.setProperty(assign[0],null);\n                            break;\n                        default:\n                            break;\n                    }\n                    \n                    continue;\n                }\n\n                // Anything else is considered an XML file.\n                xmls.add(arg);\n            }\n            \n            start(xmls);\n        }\n        catch (Throwable t)\n        {\n            t.printStackTrace(System.err);\n            System.out.println(\"Use java -jar start.jar --help for usage information.\");\n            System.exit(ERR_UNKNOWN);\n        }\n    }","commit_id":"2dee039305a6d1a867f069e73c42e8cbbdcfeb16","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public static void main(String[] args)\n    {\n        Main main = new Main();\n        try\n        {\n            main.parseCommandLine(args);\n        }\n        catch (Throwable t)\n        {\n            t.printStackTrace(System.err);\n        }\n    }","id":73132,"modified_method":"public static void main(String[] args)\n    {\n        Main main = new Main();\n        try\n        {\n            main.parseCommandLine(args);\n        }\n        catch (Throwable t)\n        {\n            t.printStackTrace(System.err);\n            System.exit(ERR_UNKNOWN);\n        }\n    }","commit_id":"2dee039305a6d1a867f069e73c42e8cbbdcfeb16","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void showActiveSecurityPolicies(ClassLoader cl)\n    {\n\n        initSecurity(cl);\n\n        Policy policy = Policy.getPolicy();\n\n        if (policy != null && policy.getClass().getName().contains(\"JettyPolicy\"))\n        {\n            System.out.println(\"Active Security Policies: \");\n\n            try\n            {\n                Method m = policy.getClass().getMethod(\"dump\",new Class[]{ PrintStream.class });\n                m.invoke(policy,new Object[]\n                { System.out });\n            }\n            catch (SecurityException e)\n            {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            catch (NoSuchMethodException e)\n            {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            catch (IllegalArgumentException e)\n            {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            catch (IllegalAccessException e)\n            {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            catch (InvocationTargetException e)\n            {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }","id":73133,"modified_method":"private void showActiveSecurityPolicies(ClassLoader cl)\n    {\n\n        initSecurity(cl);\n\n        Policy policy = Policy.getPolicy();\n\n        if (policy != null && policy.getClass().getName().contains(\"JettyPolicy\"))\n        {\n            System.out.println(\"Active Security Policies: \");\n\n            try\n            {\n                Method m = policy.getClass().getMethod(\"dump\",new Class[]{ PrintStream.class });\n                m.invoke(policy,new Object[]\n                { System.out });\n            }\n            catch (SecurityException e)\n            {\n                e.printStackTrace(System.err);\n            }\n            catch (NoSuchMethodException e)\n            {\n                e.printStackTrace(System.err);\n            }\n            catch (IllegalArgumentException e)\n            {\n                e.printStackTrace(System.err);\n            }\n            catch (IllegalAccessException e)\n            {\n                e.printStackTrace(System.err);\n            }\n            catch (InvocationTargetException e)\n            {\n                e.printStackTrace(System.err);\n            }\n        }\n    }","commit_id":"2dee039305a6d1a867f069e73c42e8cbbdcfeb16","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void invokeMain(ClassLoader classloader, String classname, List<String> args) throws IllegalAccessException, InvocationTargetException,\n    NoSuchMethodException, ClassNotFoundException\n    {\n        Class<?> invoked_class = null;\n\n        try\n        {\n            invoked_class = classloader.loadClass(classname);\n        }\n        catch (ClassNotFoundException e)\n        {\n            e.printStackTrace();\n        }\n\n        if (Config.isDebug() || invoked_class == null)\n        {\n            if (invoked_class == null)\n                System.err.println(\"ClassNotFound: \" + classname);\n            else\n                System.err.println(classname + \" \" + invoked_class.getPackage().getImplementationVersion());\n\n            if (invoked_class == null)\n            {\n                System.err.println(\"Usage: java -jar start.jar [options] [properties] [configs]\");\n                System.err.println(\"       java -jar start.jar --help  # for more information\");\n                return;\n            }\n        }\n\n        String argArray[] = args.toArray(new String[0]);\n\n        Class<?>[] method_param_types = new Class[] { argArray.getClass() };\n\n        Method main = invoked_class.getDeclaredMethod(\"main\",method_param_types);\n        Object[] method_params = new Object[] { argArray };\n        main.invoke(null,method_params);\n    }","id":73134,"modified_method":"public void invokeMain(ClassLoader classloader, String classname, List<String> args) throws IllegalAccessException, InvocationTargetException,\n    NoSuchMethodException, ClassNotFoundException\n    {\n        Class<?> invoked_class = null;\n\n        try\n        {\n            invoked_class = classloader.loadClass(classname);\n        }\n        catch (ClassNotFoundException e)\n        {\n            e.printStackTrace();\n        }\n\n        if (Config.isDebug() || invoked_class == null)\n        {\n            if (invoked_class == null)\n            {\n                System.err.println(\"ClassNotFound: \" + classname);\n            }\n            else\n            {\n                System.err.println(classname + \" \" + invoked_class.getPackage().getImplementationVersion());\n            }\n\n            if (invoked_class == null)\n            {\n                System.err.println(\"Usage: java -jar start.jar [options] [properties] [configs]\");\n                System.err.println(\"       java -jar start.jar --help  # for more information\");\n                System.exit(ERR_INVOKE_MAIN);\n                return;\n            }\n        }\n\n        String argArray[] = args.toArray(new String[0]);\n\n        Class<?>[] method_param_types = new Class[] { argArray.getClass() };\n\n        Method main = invoked_class.getDeclaredMethod(\"main\",method_param_types);\n        Object[] method_params = new Object[] { argArray };\n        main.invoke(null,method_params);\n    }","commit_id":"2dee039305a6d1a867f069e73c42e8cbbdcfeb16","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void usage()\n    {\n        String usageResource = \"org/eclipse/jetty/start/usage.txt\";\n        InputStream usageStream = getClass().getClassLoader().getResourceAsStream(usageResource);\n\n        if (usageStream == null)\n        {\n            System.err.println(\"Usage: java -jar start.jar [options] [properties] [configs]\");\n            System.err.println(\"ERROR: detailed usage resource unavailable\");\n            System.exit(1);\n        }\n\n        BufferedReader buf = null;\n        try\n        {\n            buf = new BufferedReader(new InputStreamReader(usageStream));\n            String line;\n\n            while ((line = buf.readLine()) != null)\n            {\n                if (line.endsWith(\"@\") && line.indexOf('@')!=line.lastIndexOf('@'))\n                {\n                    String indent=line.substring(0,line.indexOf(\"@\"));\n                    String info=line.substring(line.indexOf('@'),line.lastIndexOf('@'));\n\n                    if (info.equals(\"@OPTIONS\"))\n                    {\n                        List<String> sortedOptions = new ArrayList<String>();\n                        sortedOptions.addAll(_config.getSectionIds());\n                        Collections.sort(sortedOptions);\n\n                        for (String option : sortedOptions)\n                        {\n                            if (\"*\".equals(option) || option.trim().length()==0)\n                                continue;\n                            System.out.print(indent);\n                            System.out.println(option);\n                        }\n                    }\n                    else if (info.equals(\"@CONFIGS\"))\n                    {\n                        File etc = new File(System.getProperty(\"jetty.home\",\".\"),\"etc\");\n                        if (!etc.exists() || !etc.isDirectory())\n                        {\n                            System.out.print(indent);\n                            System.out.println(\"Unable to find/list \" + etc);\n                            continue;\n                        }\n\n                        File configs[] = etc.listFiles(new FileFilter()\n                        {\n                            public boolean accept(File path)\n                            {\n                                if (!path.isFile())\n                                {\n                                    return false;\n                                }\n\n                                String name = path.getName().toLowerCase();\n                                return (name.startsWith(\"jetty\") && name.endsWith(\".xml\"));\n                            }\n                        });\n\n                        List<File> configFiles = new ArrayList<File>();\n                        configFiles.addAll(Arrays.asList(configs));\n                        Collections.sort(configFiles);\n\n                        for (File configFile : configFiles)\n                        {\n                            System.out.print(indent);\n                            System.out.print(\"etc/\");\n                            System.out.println(configFile.getName());\n                        }\n                    }\n                    else if (info.equals(\"@STARTINI\"))\n                    {\n                        List<String> ini = loadStartIni(null);\n                        if (ini!=null && ini.size()>0)\n                        {\n                            for (String a : ini)\n                            {\n                                System.out.print(indent);\n                                System.out.println(a);\n                            }\n                        }\n                        else\n                        {\n                            System.out.print(indent);\n                            System.out.println(\"none\");\n                        }\n                    }\n                }\n                else\n                {\n                    System.out.println(line);\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace(System.err);\n        }\n        finally\n        {\n            if (buf != null)\n            {\n                try\n                {\n                    buf.close();\n                }\n                catch (IOException ignore)\n                {\n                    /* ignore */\n                }\n            }\n        }\n        System.exit(1);\n    }","id":73135,"modified_method":"private void usage()\n    {\n        String usageResource = \"org/eclipse/jetty/start/usage.txt\";\n        InputStream usageStream = getClass().getClassLoader().getResourceAsStream(usageResource);\n\n        if (usageStream == null)\n        {\n            System.err.println(\"Usage: java -jar start.jar [options] [properties] [configs]\");\n            System.err.println(\"ERROR: detailed usage resource unavailable\");\n            System.exit(EXIT_USAGE);\n        }\n\n        BufferedReader buf = null;\n        try\n        {\n            buf = new BufferedReader(new InputStreamReader(usageStream));\n            String line;\n\n            while ((line = buf.readLine()) != null)\n            {\n                if (line.endsWith(\"@\") && line.indexOf('@')!=line.lastIndexOf('@'))\n                {\n                    String indent=line.substring(0,line.indexOf(\"@\"));\n                    String info=line.substring(line.indexOf('@'),line.lastIndexOf('@'));\n\n                    if (info.equals(\"@OPTIONS\"))\n                    {\n                        List<String> sortedOptions = new ArrayList<String>();\n                        sortedOptions.addAll(_config.getSectionIds());\n                        Collections.sort(sortedOptions);\n\n                        for (String option : sortedOptions)\n                        {\n                            if (\"*\".equals(option) || option.trim().length()==0)\n                                continue;\n                            System.out.print(indent);\n                            System.out.println(option);\n                        }\n                    }\n                    else if (info.equals(\"@CONFIGS\"))\n                    {\n                        File etc = new File(System.getProperty(\"jetty.home\",\".\"),\"etc\");\n                        if (!etc.exists() || !etc.isDirectory())\n                        {\n                            System.out.print(indent);\n                            System.out.println(\"Unable to find/list \" + etc);\n                            continue;\n                        }\n\n                        File configs[] = etc.listFiles(new FileFilter()\n                        {\n                            public boolean accept(File path)\n                            {\n                                if (!path.isFile())\n                                {\n                                    return false;\n                                }\n\n                                String name = path.getName().toLowerCase();\n                                return (name.startsWith(\"jetty\") && name.endsWith(\".xml\"));\n                            }\n                        });\n\n                        List<File> configFiles = new ArrayList<File>();\n                        configFiles.addAll(Arrays.asList(configs));\n                        Collections.sort(configFiles);\n\n                        for (File configFile : configFiles)\n                        {\n                            System.out.print(indent);\n                            System.out.print(\"etc/\");\n                            System.out.println(configFile.getName());\n                        }\n                    }\n                    else if (info.equals(\"@STARTINI\"))\n                    {\n                        List<String> ini = loadStartIni(null);\n                        if (ini!=null && ini.size()>0)\n                        {\n                            for (String a : ini)\n                            {\n                                System.out.print(indent);\n                                System.out.println(a);\n                            }\n                        }\n                        else\n                        {\n                            System.out.print(indent);\n                            System.out.println(\"none\");\n                        }\n                    }\n                }\n                else\n                {\n                    System.out.println(line);\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace(System.err);\n        }\n        finally\n        {\n            close(buf);\n        }\n        System.exit(EXIT_USAGE);\n    }","commit_id":"2dee039305a6d1a867f069e73c42e8cbbdcfeb16","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * If a start.ini is present in the CWD, then load it into the argument list.\n     */\n    private List<String> loadStartIni(String ini)\n    {\n        String jettyHome=System.getProperty(\"jetty.home\");\n        File startIniFile = ini==null?((jettyHome!=null)?  new File(jettyHome,\"start.ini\"):new File(\"start.ini\")):new File(ini);\n        if (!startIniFile.exists() || !startIniFile.canRead())\n        {\n            if (ini!=null)\n                System.err.println(\"Warning - can't find ini file: \"+ini);\n            // No start.ini found, skip load.\n            return Collections.emptyList();\n        }\n\n        List<String> args = new ArrayList<String>();\n\n        FileReader reader = null;\n        BufferedReader buf = null;\n        try\n        {\n            reader = new FileReader(startIniFile);\n            buf = new BufferedReader(reader);\n\n            String arg;\n            while ((arg = buf.readLine()) != null)\n            {\n                arg=arg.trim();\n                if (arg.length()==0 || arg.startsWith(\"#\"))\n                    continue;\n                args.add(arg);\n            }\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n        finally\n        {\n            close(buf);\n            close(reader);\n        }\n\n        return args;\n    }","id":73136,"modified_method":"/**\n     * If a start.ini is present in the CWD, then load it into the argument list.\n     */\n    private List<String> loadStartIni(String ini)\n    {\n        String jettyHome=System.getProperty(\"jetty.home\");\n        File startIniFile = ini==null?((jettyHome!=null)?  new File(jettyHome,\"start.ini\"):new File(\"start.ini\")):new File(ini);\n        if (!startIniFile.exists() || !startIniFile.canRead())\n        {\n            if (ini != null)\n            {\n                System.err.println(\"Warning - can't find ini file: \" + ini);\n            }\n            // No start.ini found, skip load.\n            return Collections.emptyList();\n        }\n\n        List<String> args = new ArrayList<String>();\n\n        FileReader reader = null;\n        BufferedReader buf = null;\n        try\n        {\n            reader = new FileReader(startIniFile);\n            buf = new BufferedReader(reader);\n\n            String arg;\n            while ((arg = buf.readLine()) != null)\n            {\n                arg = arg.trim();\n                if (arg.length() == 0 || arg.startsWith(\"#\"))\n                {\n                    continue;\n                }\n                args.add(arg);\n            }\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace(System.err);\n            System.exit(ERR_UNKNOWN);\n        }\n        finally\n        {\n            close(buf);\n            close(reader);\n        }\n\n        return args;\n    }","commit_id":"2dee039305a6d1a867f069e73c42e8cbbdcfeb16","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @return the controllerClass\n     */\n    public GrailsControllerClass getControllerClass() {\n        return (GrailsControllerClass)getCurrentRequest().getAttribute(GrailsApplicationAttributes.GRAILS_CONTROLLER_CLASS);\n    }","id":73137,"modified_method":"/**\n     * @return the controllerClass\n     */\n    public GrailsControllerClass getControllerClass() {\n        HttpServletRequest currentRequest = getCurrentRequest();\n        GrailsControllerClass controllerClass = (GrailsControllerClass) currentRequest.getAttribute(GrailsApplicationAttributes.GRAILS_CONTROLLER_CLASS);\n        if(controllerClass == null) {\n            Object controllerNameObject = currentRequest.getAttribute(GrailsApplicationAttributes.CONTROLLER_NAME_ATTRIBUTE);\n            if(controllerNameObject != null) {\n                controllerClass = (GrailsControllerClass)getAttributes()\n                                                            .getGrailsApplication()\n                                                            .getArtefactByLogicalPropertyName(ControllerArtefactHandler.TYPE, controllerNameObject.toString());\n                if(controllerClass != null) {\n                    currentRequest.setAttribute(GrailsApplicationAttributes.GRAILS_CONTROLLER_CLASS, controllerClass);\n                }\n            }\n        }\n        return controllerClass;\n    }","commit_id":"f2be56ccb7fb1794227a571ee6675431acce9bd0","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * For reusing code between text/html and text/plain, we run them both through the same code path\n     * and use this request attribute to differentiate. \n     */\n    private boolean isHtml() {\n        return Stapler.getCurrentRequest().getAttribute(\"html\")!=null;\n    }","id":73138,"modified_method":"/**\n     * For reusing code between text/html and text/plain, we run them both through the same code path\n     * and use this request attribute to differentiate. \n     */\n    private boolean isHtml() {\n        StaplerRequest req = Stapler.getCurrentRequest();\n        return req!=null && req.getAttribute(\"html\")!=null;\n    }","commit_id":"bac28a5ae5c79860a25c629c27268f73588191bc","url":"https://github.com/kohsuke/hudson"},{"original_method":"public void objectCreated(Object value)\n\t{\n\t\tRequestData rd = getCurrentRequest();\n\n\t\tif (value instanceof Session)\n\t\t{\n\t\t\tSession session = (Session)value;\n\t\t\trd.addEntry(\"Session created, id: \" + session.getId());\n\t\t}\n\t\telse if (value instanceof Page)\n\t\t{\n\t\t\tPage page = (Page)value;\n\t\t\trd.addEntry(\"Page created, id: \" + page.getId() + \", class:\" + page.getClass());\n\t\t}\n\t\telse\n\t\t{\n\t\t\trd.addEntry(\"Custom object created: \" + value);\n\t\t}\n\t}","id":73139,"modified_method":"public void objectCreated(Object value)\n\t{\n\t\tRequestData rd = getCurrentRequest();\n\n\t\tif (value instanceof Session)\n\t\t{\n\t\t\trd.addEntry(\"Session created\");\n\t\t}\n\t\telse if (value instanceof Page)\n\t\t{\n\t\t\tPage page = (Page)value;\n\t\t\trd.addEntry(\"Page created, id: \" + page.getId() + \", class:\" + page.getClass());\n\t\t}\n\t\telse\n\t\t{\n\t\t\trd.addEntry(\"Custom object created: \" + value);\n\t\t}\n\t}","commit_id":"f13d28c69d75d7a96b65a384a30bea5f8c23182e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param requestHandler\n\t * @return The request target nice display string\n\t */\n\tprivate String getRequestHandlerString(final IRequestHandler requestHandler)\n\t{\n\t\tAppendingStringBuffer sb = new AppendingStringBuffer(128);\n\t\tif (requestHandler instanceof ListenerInterfaceRequestHandler)\n\t\t{\n\t\t\tListenerInterfaceRequestHandler listener = (ListenerInterfaceRequestHandler)requestHandler;\n\t\t\tsb.append(\"Interface[component: \");\n\t\t\tsb.append(Classes.simpleName(listener.getComponent().getClass()));\n\t\t\tsb.append(\"(\");\n\t\t\tsb.append(listener.getComponent().getPageRelativePath());\n\t\t\tsb.append(\"), page: \");\n\t\t\tsb.append(listener.getPage().getClass().getName());\n\t\t\tsb.append(\"(\");\n\t\t\tsb.append(listener.getPage().getId());\n\t\t\tsb.append(\"), interface: \");\n\t\t\tsb.append(listener.getListenerInterface().getName());\n\t\t\tsb.append(\".\");\n\t\t\tsb.append(listener.getListenerInterface().getMethod().getName());\n\t\t\tsb.append(\"]\");\n\t\t}\n\t\telse if (requestHandler instanceof BookmarkablePageRequestHandler)\n\t\t{\n\t\t\tBookmarkablePageRequestHandler pageRequestHandler = (BookmarkablePageRequestHandler)requestHandler;\n\t\t\tsb.append(\"BookmarkablePage[\");\n\t\t\tsb.append(pageRequestHandler.getPageClass().getName());\n\t\t\tsb.append(\"(\").append(pageRequestHandler.getPageParameters()).append(\")\");\n\t\t\tsb.append(\"]\");\n\t\t}\n\t\telse if (requestHandler instanceof IPageRequestHandler)\n\t\t{\n\t\t\tIPageRequestHandler pageRequestHandler = (IPageRequestHandler)requestHandler;\n\t\t\tsb.append(\"PageRequest[\");\n\t\t\tsb.append(pageRequestHandler.getPageClass().getName());\n\t\t\tsb.append(\"(\");\n\t\t\tsb.append(pageRequestHandler.getPageId());\n\t\t\tsb.append(\")]\");\n\t\t}\n\t\telse if (requestHandler instanceof ResourceReferenceRequestHandler)\n\t\t{\n\t\t\tResourceReferenceRequestHandler resourceRefenceHandler = (ResourceReferenceRequestHandler)requestHandler;\n\t\t\tsb.append(\"ResourceReference[\");\n\t\t\tsb.append(resourceRefenceHandler.getResourceReference());\n\t\t\tsb.append(\"]\");\n\t\t}\n\t\telse if (requestHandler instanceof IRequestHandlerDelegate)\n\t\t{\n\t\t\tsb.append(requestHandler.getClass().getSimpleName())\n\t\t\t\t.append(\".\")\n\t\t\t\t.append(\n\t\t\t\t\tgetRequestHandlerString(((IRequestHandlerDelegate)requestHandler).getDelegateHandler()));\n\t\t}\n\t\telse if (requestHandler instanceof BufferedResponseRequestHandler)\n\t\t{\n\t\t\tBufferedResponseRequestHandler bufferedResponseHandler = (BufferedResponseRequestHandler)requestHandler;\n\t\t\tsb.append(bufferedResponseHandler.getClass().getSimpleName());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsb.append(requestHandler.toString());\n\t\t}\n\t\treturn sb.toString();\n\t}","id":73140,"modified_method":"private String getRequestHandlerString(IRequestHandler handler)\n\t{\n\t\tAppendingStringBuffer sb = new AppendingStringBuffer(128);\n\t\tsb.append(handler.getClass().getSimpleName());\n\t\tsb.append(\"[\");\n\t\tif (handler instanceof ListenerInterfaceRequestHandler)\n\t\t{\n\t\t\tgetListenerString(sb, (ListenerInterfaceRequestHandler)handler);\n\t\t}\n\t\telse if (handler instanceof BookmarkablePageRequestHandler)\n\t\t{\n\t\t\tgetBookmarkableString(sb, (BookmarkablePageRequestHandler)handler);\n\t\t}\n\t\telse if (handler instanceof RenderPageRequestHandler)\n\t\t{\n\t\t\tgetRendererString(sb, (RenderPageRequestHandler)handler);\n\t\t}\n\t\telse if (handler instanceof AjaxRequestTarget)\n\t\t{\n\t\t\tgetAjaxString(sb, (AjaxRequestTarget)handler);\n\t\t}\n\t\telse if (handler instanceof ResourceReferenceRequestHandler)\n\t\t{\n\t\t\tgetResourceString(sb, (ResourceReferenceRequestHandler)handler);\n\t\t}\n\t\telse if (handler instanceof IRequestHandlerDelegate)\n\t\t{\n\t\t\tgetDelegateString(sb, (IRequestHandlerDelegate)handler);\n\t\t}\n\t\telse if (handler instanceof BufferedResponseRequestHandler)\n\t\t{\n\t\t\t// nothing extra to log... BufferedResponse doesn't have identifiable information about\n\t\t\t// which request was buffered\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsb.append(handler.toString());\n\t\t}\n\t\tsb.append(\"]\");\n\t\treturn sb.toString();\n\t}","commit_id":"f13d28c69d75d7a96b65a384a30bea5f8c23182e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param rd\n\t * @param sd\n\t */\n\tprotected void log(RequestData rd, SessionData sd)\n\t{\n\t\tif (log.isInfoEnabled())\n\t\t{\n\t\t\tlog.info(createLogString(rd, sd, true).toString());\n\t\t}\n\t}","id":73141,"modified_method":"protected void log(RequestData rd, SessionData sd)\n\t{\n\t\tif (log.isInfoEnabled())\n\t\t{\n\t\t\tlog.info(createLogString(rd, sd, true).toString());\n\t\t}\n\t}","commit_id":"f13d28c69d75d7a96b65a384a30bea5f8c23182e","url":"https://github.com/apache/wicket"},{"original_method":"public List<RequestData> getRequests()\n\t{\n\t\treturn Collections.unmodifiableList(requests);\n\t}","id":73142,"modified_method":"public List<RequestData> getRequests()\n\t{\n\t\tsynchronized (requestWindow)\n\t\t{\n\t\t\tRequestData[] result = new RequestData[hasBufferRolledOver() ? requestWindow.length\n\t\t\t\t: indexInWindow];\n\t\t\tcopyRequestsInOrder(result);\n\t\t\treturn Arrays.asList(result);\n\t\t}\n\t}","commit_id":"f13d28c69d75d7a96b65a384a30bea5f8c23182e","url":"https://github.com/apache/wicket"},{"original_method":"public void logEventTarget(IRequestHandler requestHandler)\n\t{\n\t\tgetCurrentRequest().addEventTarget(getRequestHandlerString(requestHandler));\n\t}","id":73143,"modified_method":"public void logEventTarget(IRequestHandler requestHandler)\n\t{\n\t\tRequestData requestData = getCurrentRequest();\n\t\tif (requestData != null)\n\t\t{\n\t\t\trequestData.addEventTarget(getRequestHandlerString(requestHandler));\n\t\t}\n\t}","commit_id":"f13d28c69d75d7a96b65a384a30bea5f8c23182e","url":"https://github.com/apache/wicket"},{"original_method":"public void objectRemoved(Object value)\n\t{\n\t\tRequestData rd = getCurrentRequest();\n\t\tif (value instanceof Page)\n\t\t{\n\t\t\tPage page = (Page)value;\n\t\t\trd.addEntry(\"Page removed, id: \" + page.getId() + \", class:\" + page.getClass());\n\t\t}\n\t\telse if (value instanceof Session)\n\t\t{\n\t\t\trd.addEntry(\"Session removed\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\trd.addEntry(\"Custom object removed: \" + value);\n\t\t}\n\t}","id":73144,"modified_method":"public void objectRemoved(Object value)\n\t{\n\t\tRequestData rd = getCurrentRequest();\n\t\tif (value instanceof Page)\n\t\t{\n\t\t\tPage page = (Page)value;\n\t\t\trd.addEntry(\"Page removed, id: \" + page.getId() + \", class:\" + page.getClass());\n\t\t}\n\t\telse if (value instanceof WebSession)\n\t\t{\n\t\t\trd.addEntry(\"Session removed\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\trd.addEntry(\"Custom object removed: \" + value);\n\t\t}\n\t}","commit_id":"f13d28c69d75d7a96b65a384a30bea5f8c23182e","url":"https://github.com/apache/wicket"},{"original_method":"public void logResponseTarget(IRequestHandler requestHandler)\n\t{\n\t\tgetCurrentRequest().addResponseTarget(getRequestHandlerString(requestHandler));\n\t}","id":73145,"modified_method":"public void logResponseTarget(IRequestHandler requestHandler)\n\t{\n\t\tRequestData requestData = getCurrentRequest();\n\t\tif (requestData != null)\n\t\t\trequestData.addResponseTarget(getRequestHandlerString(requestHandler));\n\t}","commit_id":"f13d28c69d75d7a96b65a384a30bea5f8c23182e","url":"https://github.com/apache/wicket"},{"original_method":"public void sessionDestroyed(String sessionId)\n\t{\n\t\tliveSessions.remove(sessionId);\n\t}","id":73146,"modified_method":"public void sessionDestroyed(String sessionId)\n\t{\n\t\tRequestCycle.get().setMetaData(SESSION_DATA, liveSessions.remove(sessionId));\n\t}","commit_id":"f13d28c69d75d7a96b65a384a30bea5f8c23182e","url":"https://github.com/apache/wicket"},{"original_method":"RequestData getCurrentRequest()\n\t{\n\t\tRequestCycle requestCycle = RequestCycle.get();\n\t\tRequestData rd = requestCycle.getMetaData(REQUEST_DATA);\n\t\tif (rd == null)\n\t\t{\n\t\t\trd = new RequestData();\n\t\t\trequestCycle.setMetaData(REQUEST_DATA, rd);\n\t\t\tint activeCount = activeRequests.incrementAndGet();\n\n\t\t\tif (activeCount > peakActiveRequests.get())\n\t\t\t{\n\t\t\t\tpeakActiveRequests.set(activeCount);\n\t\t\t}\n\t\t}\n\t\treturn rd;\n\t}","id":73147,"modified_method":"protected RequestData getCurrentRequest()\n\t{\n\t\tRequestCycle requestCycle = RequestCycle.get();\n\t\tRequestData rd = requestCycle.getMetaData(REQUEST_DATA);\n\t\tif (rd == null)\n\t\t{\n\t\t\trd = new RequestData();\n\t\t\trequestCycle.setMetaData(REQUEST_DATA, rd);\n\t\t\tint activeCount = activeRequests.incrementAndGet();\n\n\t\t\tif (activeCount > peakActiveRequests.get())\n\t\t\t{\n\t\t\t\tpeakActiveRequests.set(activeCount);\n\t\t\t}\n\t\t}\n\t\treturn rd;\n\t}","commit_id":"f13d28c69d75d7a96b65a384a30bea5f8c23182e","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t */\n\tpublic RequestLogger()\n\t{\n\t\trequests = Collections.synchronizedList(new LinkedList<RequestData>()\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t/**\n\t\t\t * @see java.util.LinkedList#add(java.lang.Object)\n\t\t\t */\n\t\t\t@Override\n\t\t\tpublic void add(int index, RequestData o)\n\t\t\t{\n\t\t\t\tsuper.add(index, o);\n\n\t\t\t\t// should not happen often that the requests window size changes, but now we can\n\t\t\t\t// increase and shrink the list at will.\n\t\t\t\tIRequestLoggerSettings settings = Application.get().getRequestLoggerSettings();\n\t\t\t\twhile (size() > Math.max(0, settings.getRequestsWindowSize()))\n\t\t\t\t{\n\t\t\t\t\tremoveLast();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tliveSessions = new ConcurrentHashMap<String, SessionData>();\n\t}","id":73148,"modified_method":"/**\n\t * Construct.\n\t */\n\tpublic RequestLogger()\n\t{\n\t\tint requestsWindowSize = Application.get()\n\t\t\t.getRequestLoggerSettings()\n\t\t\t.getRequestsWindowSize();\n\t\trequestWindow = new RequestData[requestsWindowSize];\n\t\tliveSessions = new ConcurrentHashMap<String, SessionData>();\n\t}","commit_id":"f13d28c69d75d7a96b65a384a30bea5f8c23182e","url":"https://github.com/apache/wicket"},{"original_method":"public void requestTime(long timeTaken)\n\t{\n\t\tRequestData requestdata = RequestCycle.get().getMetaData(REQUEST_DATA);\n\t\tif (requestdata != null)\n\t\t{\n\t\t\tif (activeRequests.get() > 0)\n\t\t\t{\n\t\t\t\trequestdata.setActiveRequest(activeRequests.decrementAndGet());\n\t\t\t}\n\t\t\tSession session = Session.get();\n\t\t\tString sessionId = session.getId();\n\t\t\trequestdata.setSessionId(sessionId);\n\n\t\t\tObject sessionInfo = getSessionInfo(session);\n\t\t\trequestdata.setSessionInfo(sessionInfo);\n\n\t\t\tlong sizeInBytes = -1;\n\t\t\tif (Application.get().getRequestLoggerSettings().getRecordSessionSize())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tsizeInBytes = session.getSizeInBytes();\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\t// log the error and let the request logging continue (this is what happens in\n\t\t\t\t\t// the detach phase of the request cycle anyway. This provides better\n\t\t\t\t\t// diagnostics).\n\t\t\t\t\tlog.error(\n\t\t\t\t\t\t\"Exception while determining the size of the session in the request logger: \" +\n\t\t\t\t\t\t\te.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t\trequestdata.setSessionSize(sizeInBytes);\n\t\t\trequestdata.setTimeTaken(timeTaken);\n\n\t\t\trequests.add(0, requestdata);\n\n\t\t\tSessionData sessiondata = null;\n\t\t\tif (sessionId != null)\n\t\t\t{\n\t\t\t\tsessiondata = liveSessions.get(sessionId);\n\t\t\t\tif (sessiondata == null)\n\t\t\t\t{\n\t\t\t\t\t// passivated session or logger only started after it.\n\t\t\t\t\tsessionCreated(sessionId);\n\t\t\t\t\tsessiondata = liveSessions.get(sessionId);\n\t\t\t\t}\n\t\t\t\tif (sessiondata != null)\n\t\t\t\t{\n\t\t\t\t\tsessiondata.setSessionInfo(sessionInfo);\n\t\t\t\t\tsessiondata.setSessionSize(sizeInBytes);\n\t\t\t\t\tsessiondata.addTimeTaken(timeTaken);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// log the request- and sessiondata (the latter can be null)\n\t\t\tlog(requestdata, sessiondata);\n\t\t}\n\t}","id":73149,"modified_method":"public void requestTime(long timeTaken)\n\t{\n\t\tRequestData requestdata = RequestCycle.get().getMetaData(REQUEST_DATA);\n\t\tif (requestdata != null)\n\t\t{\n\t\t\tif (activeRequests.get() > 0)\n\t\t\t{\n\t\t\t\trequestdata.setActiveRequest(activeRequests.decrementAndGet());\n\t\t\t}\n\t\t\tSession session = Session.get();\n\t\t\tString sessionId = session.getId();\n\t\t\trequestdata.setSessionId(sessionId);\n\n\t\t\tObject sessionInfo = getSessionInfo(session);\n\t\t\trequestdata.setSessionInfo(sessionInfo);\n\n\t\t\tlong sizeInBytes = -1;\n\t\t\tif (Application.get().getRequestLoggerSettings().getRecordSessionSize())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tsizeInBytes = session.getSizeInBytes();\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\t// log the error and let the request logging continue (this is what happens in\n\t\t\t\t\t// the detach phase of the request cycle anyway. This provides better\n\t\t\t\t\t// diagnostics).\n\t\t\t\t\tlog.error(\n\t\t\t\t\t\t\"Exception while determining the size of the session in the request logger: \" +\n\t\t\t\t\t\t\te.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t\trequestdata.setSessionSize(sizeInBytes);\n\t\t\trequestdata.setTimeTaken(timeTaken);\n\n\t\t\taddRequest(requestdata);\n\n\t\t\tSessionData sessiondata = null;\n\t\t\tif (sessionId != null)\n\t\t\t{\n\t\t\t\tsessiondata = liveSessions.get(sessionId);\n\t\t\t\tif (sessiondata == null)\n\t\t\t\t{\n\t\t\t\t\t// if the session has been destroyed during the request by\n\t\t\t\t\t// Session#invalidateNow, retrieve the old session data from the RequestCycle.\n\t\t\t\t\tsessiondata = RequestCycle.get().getMetaData(SESSION_DATA);\n\t\t\t\t}\n\t\t\t\tif (sessiondata == null)\n\t\t\t\t{\n\t\t\t\t\t// passivated session or logger only started after it.\n\t\t\t\t\tsessionCreated(sessionId);\n\t\t\t\t\tsessiondata = liveSessions.get(sessionId);\n\t\t\t\t}\n\t\t\t\tif (sessiondata != null)\n\t\t\t\t{\n\t\t\t\t\tsessiondata.setSessionInfo(sessionInfo);\n\t\t\t\t\tsessiondata.setSessionSize(sizeInBytes);\n\t\t\t\t\tsessiondata.addTimeTaken(timeTaken);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// log the request- and sessiondata (the latter can be null)\n\t\t\tlog(requestdata, sessiondata);\n\t\t}\n\t}","commit_id":"f13d28c69d75d7a96b65a384a30bea5f8c23182e","url":"https://github.com/apache/wicket"},{"original_method":"@Nullable\n  public static PsiType extractIterableTypeParameter(@Nullable PsiType psiType) {\n    return substituteTypeParameter(psiType, CommonClassNames.JAVA_LANG_ITERABLE, 0);\n  }","id":73150,"modified_method":"@Nullable\n  public static PsiType extractIterableTypeParameter(@Nullable PsiType psiType) {\n    final PsiType type = substituteTypeParameter(psiType, CommonClassNames.JAVA_LANG_ITERABLE, 0);\n    return type != null ? type : substituteTypeParameter(psiType, CommonClassNames.JAVA_UTIL_COLLECTION, 0);\n  }","commit_id":"b0b48b1fa5aa407d185943b981ffa2b4ccfbcc76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiType getType() {\n    GrExpression selected = getSelectedExpression();\n    PsiType thisType = selected.getType();\n\n    if (thisType != null) {\n      GrArgumentList argList = getArgumentList();\n      if (argList != null) {\n        GrExpression[] arguments = argList.getExpressionArguments();\n        PsiType[] argTypes = new PsiType[arguments.length];\n        for (int i = 0; i < arguments.length; i++) {\n          PsiType argType = arguments[i].getType();\n          if (argType == null) argType = TypesUtil.getJavaLangObject(argList);\n          argTypes[i] = argType;\n        }\n\n        if (thisType instanceof GrTupleType) {\n          PsiType[] types = ((GrTupleType)thisType).getParameters();\n          return types.length == 1 ? types[0] : null;\n        }\n\n        PsiType overloadedOperatorType = null;\n        final GroovyResolveResult[] candidates = TypesUtil.getOverloadedOperatorCandidates(thisType, \"getAt\", this, argTypes);\n        if (candidates.length == 1) {\n          final PsiElement element = candidates[0].getElement();\n          if (element instanceof PsiMethod) {\n            overloadedOperatorType = candidates[0].getSubstitutor().substitute(org.jetbrains.plugins.groovy.lang.psi.util.PsiUtil.getSmartReturnType((PsiMethod)element));\n            if (overloadedOperatorType != null && !(element instanceof GrGdkMethod)) {   //gdk 'getAt' methods don't have information about type parameters\n              return overloadedOperatorType;\n            }\n          }\n        }\n\n        if (thisType instanceof PsiArrayType) {\n          PsiType componentType = ((PsiArrayType)thisType).getComponentType();\n          return TypesUtil.boxPrimitiveType(componentType, getManager(), getResolveScope());\n        }\n\n        if (InheritanceUtil.isInheritor(thisType, CommonClassNames.JAVA_UTIL_LIST)) {\n          PsiType iterType = PsiUtil.extractIterableTypeParameter(thisType, true);\n          if (iterType != null) return iterType;\n        }\n\n        if (InheritanceUtil.isInheritor(thisType, CommonClassNames.JAVA_UTIL_MAP)) {\n          return PsiUtil.substituteTypeParameter(thisType, CommonClassNames.JAVA_UTIL_MAP, 1, true);\n        }\n\n        return overloadedOperatorType;\n      }\n    }\n    return null;\n  }","id":73151,"modified_method":"public PsiType getType() {\n    GrExpression selected = getSelectedExpression();\n    PsiType thisType = selected.getType();\n\n    if (thisType != null) {\n      GrArgumentList argList = getArgumentList();\n      if (argList != null) {\n        GrExpression[] arguments = argList.getExpressionArguments();\n        PsiType[] argTypes = new PsiType[arguments.length];\n        for (int i = 0; i < arguments.length; i++) {\n          PsiType argType = arguments[i].getType();\n          if (argType == null) argType = TypesUtil.getJavaLangObject(argList);\n          argTypes[i] = argType;\n        }\n\n        if (thisType instanceof GrTupleType &&\n            argTypes.length == 1 &&\n            TypesUtil.isAssignable(PsiType.INT, argTypes[0], getManager(), getResolveScope())) {\n          PsiType[] types = ((GrTupleType)thisType).getParameters();\n          return types.length == 1 ? types[0] : null;\n        }\n\n        PsiType overloadedOperatorType = null;\n        GroovyResolveResult[] candidates = TypesUtil.getOverloadedOperatorCandidates(thisType, \"getAt\", this, argTypes);\n        if (candidates.length != 1) {\n          candidates = TypesUtil.getOverloadedOperatorCandidates(thisType, \"getAt\", this, new PsiType[]{\n            new GrTupleType(argTypes, JavaPsiFacade.getInstance(getProject()), getResolveScope())});\n        }\n        if (candidates.length == 1) {\n          final PsiElement element = candidates[0].getElement();\n          if (element instanceof PsiMethod) {\n            overloadedOperatorType = candidates[0].getSubstitutor().substitute(getSmartReturnType((PsiMethod)element));\n          }\n        }\n\n        PsiType componentType = null;\n        if (thisType instanceof PsiArrayType &&\n            argTypes.length == 1 &&\n            TypesUtil.isAssignable(PsiType.INT, argTypes[0], getManager(), getResolveScope())) {\n          componentType = TypesUtil.boxPrimitiveType(((PsiArrayType)thisType).getComponentType(), getManager(), getResolveScope());\n        }\n        else if (InheritanceUtil.isInheritor(thisType, CommonClassNames.JAVA_UTIL_MAP) && argTypes.length == 1) {\n          componentType = substituteTypeParameter(thisType, CommonClassNames.JAVA_UTIL_MAP, 1, true);\n        }\n\n        if (overloadedOperatorType != null &&\n            (componentType == null || !TypesUtil.isAssignable(overloadedOperatorType, componentType, getManager(), getResolveScope()))) {\n          return overloadedOperatorType;\n        }\n        return componentType;\n      }\n    }\n    return null;\n  }","commit_id":"dbcf1c6781fc3e80e918675f7e52f4d704471372","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * @param remoteData the serialized version of the context\n     * @return the XWiki context\n     */\n    protected XWikiContext unserializeXWikiContext(Serializable remoteData)\n    {\n        Map<String, Serializable> remoteDataMap = (Map<String, Serializable>) remoteData;\n\n        XWikiContext context = (XWikiContext) this.execution.getContext().getProperty(\"xwikicontext\");\n        context.setDatabase((String) remoteDataMap.get(CONTEXT_WIKI));\n        context.setUser((String) remoteDataMap.get(CONTEXT_USER));\n\n        return context;\n    }","id":73152,"modified_method":"/**\n     * @param remoteData the serialized version of the context\n     * @return the XWiki context\n     */\n    protected XWikiContext unserializeXWikiContext(Serializable remoteData)\n    {\n        Map<String, Serializable> remoteDataMap = (Map<String, Serializable>) remoteData;\n\n        XWikiContext context = (XWikiContext) this.execution.getContext().getProperty(\"xwikicontext\");\n\n        if (context != null) {\n            context.setDatabase((String) remoteDataMap.get(CONTEXT_WIKI));\n            context.setUser((String) remoteDataMap.get(CONTEXT_USER));\n        }\n\n        return context;\n    }","commit_id":"5f6886a98748cde54cbc6921af37ed364529cc0e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.converter.RemoteEventConverter#fromRemote(org.xwiki.observation.remote.RemoteEventData,\n     *      org.xwiki.observation.remote.LocalEventData)\n     */\n    public boolean fromRemote(RemoteEventData remoteEvent, LocalEventData localEvent)\n    {\n        if (remoteEvent.getEvent() instanceof ActionExecutionEvent) {\n            // fill the local event\n            localEvent.setEvent((Event) remoteEvent.getEvent());\n            localEvent.setSource(unserializeDocument(remoteEvent.getSource()));\n            localEvent.setData(unserializeXWikiContext(remoteEvent.getData()));\n\n            return true;\n        }\n\n        return false;\n    }","id":73153,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.converter.RemoteEventConverter#fromRemote(org.xwiki.observation.remote.RemoteEventData,\n     *      org.xwiki.observation.remote.LocalEventData)\n     */\n    public boolean fromRemote(RemoteEventData remoteEvent, LocalEventData localEvent)\n    {\n        if (remoteEvent.getEvent() instanceof ActionExecutionEvent) {\n         // fill the local event\n            XWikiContext context = unserializeXWikiContext(remoteEvent.getData());\n\n            if (context != null) {\n                localEvent.setEvent((Event) remoteEvent.getEvent());\n                localEvent.setSource(unserializeDocument(remoteEvent.getSource()));\n                localEvent.setData(unserializeXWikiContext(remoteEvent.getData()));\n            } else {\n                getLogger().warn(\n                    \"Can't get a proper XWikiContext.\"\n                        + \" It generally mean that the wiki has never been fully initialized,\"\n                        + \" i.e. has never been accesses at least once\");\n            }\n\n            return true;\n        }\n\n        return false;\n    }","commit_id":"5f6886a98748cde54cbc6921af37ed364529cc0e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.converter.RemoteEventConverter#fromRemote(org.xwiki.observation.remote.RemoteEventData,\n     *      org.xwiki.observation.remote.LocalEventData)\n     */\n    public boolean fromRemote(RemoteEventData remoteEvent, LocalEventData localEvent)\n    {\n        if (this.events.contains(remoteEvent.getEvent().getClass())) {\n            // fill the local event\n            localEvent.setEvent((Event) remoteEvent.getEvent());\n            localEvent.setSource(unserializeDocument(remoteEvent.getSource()));\n            localEvent.setData(unserializeXWikiContext(remoteEvent.getData()));\n\n            return true;\n        }\n\n        return false;\n    }","id":73154,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see org.xwiki.observation.remote.converter.RemoteEventConverter#fromRemote(org.xwiki.observation.remote.RemoteEventData,\n     *      org.xwiki.observation.remote.LocalEventData)\n     */\n    public boolean fromRemote(RemoteEventData remoteEvent, LocalEventData localEvent)\n    {\n        if (this.events.contains(remoteEvent.getEvent().getClass())) {\n            // fill the local event\n            XWikiContext context = unserializeXWikiContext(remoteEvent.getData());\n\n            if (context != null) {\n                localEvent.setEvent((Event) remoteEvent.getEvent());\n                localEvent.setSource(unserializeDocument(remoteEvent.getSource()));\n                localEvent.setData(unserializeXWikiContext(remoteEvent.getData()));\n            } else {\n                getLogger().warn(\n                    \"Can't get a proper XWikiContext.\"\n                        + \" It generally mean that the wiki has never been fully initialized,\"\n                        + \" i.e. has never been accesses at least once\");\n            }\n\n            return true;\n        }\n\n        return false;\n    }","commit_id":"5f6886a98748cde54cbc6921af37ed364529cc0e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public SearchResults search(String wikiName, String keywords, List<String> searchScopeStrings, Integer number,\n            Integer start, String orderField, String order, Boolean withPrettyNames)\n            throws XWikiRestException\n    {\n        try {\n            SearchResults searchResults = objectFactory.createSearchResults();\n            searchResults.setTemplate(String.format(\"%s?%s\",\n                    UriBuilder.fromUri(uriInfo.getBaseUri()).path(WikiSearchResource.class).build(wikiName).toString(),\n                    SEARCH_TEMPLATE_INFO));\n\n            Utils.getXWikiContext(componentManager).setDatabase(wikiName);\n\n            List<SearchScope> searchScopes = parseSearchScopeStrings(searchScopeStrings);\n\n            searchResults.getSearchResults().addAll(search(searchScopes, keywords, wikiName, null,\n                    Utils.getXWiki(componentManager).getRightService().hasProgrammingRights(\n                            Utils.getXWikiContext(componentManager)), number, start, true, orderField, order,\n                    withPrettyNames));\n\n            return searchResults;\n        } catch (Exception e) {\n            throw new XWikiRestException(e);\n        }\n    }","id":73155,"modified_method":"@Override\n    public SearchResults search(String wikiName, String keywords, List<String> searchScopeStrings, Integer number,\n        Integer start, String orderField, String order, Boolean withPrettyNames) throws XWikiRestException\n    {\n        try {\n            SearchResults searchResults = objectFactory.createSearchResults();\n            searchResults.setTemplate(String.format(\"%s?%s\",\n                UriBuilder.fromUri(uriInfo.getBaseUri()).path(WikiSearchResource.class).build(wikiName).toString(),\n                SEARCH_TEMPLATE_INFO));\n\n            String contextWiki = wikiName;\n            if (contextWiki == null) {\n                contextWiki = getXWikiContext().getDatabase();\n            } else {\n                Utils.getXWikiContext(componentManager).setDatabase(wikiName);\n            }\n\n            List<SearchScope> searchScopes = parseSearchScopeStrings(searchScopeStrings);\n\n            searchResults.getSearchResults().addAll(\n                search(searchScopes, keywords, contextWiki, null, Utils.getXWiki(componentManager).getRightService()\n                    .hasProgrammingRights(Utils.getXWikiContext(componentManager)), number, start, true, orderField,\n                    order, withPrettyNames));\n\n            return searchResults;\n        } catch (Exception e) {\n            throw new XWikiRestException(e);\n        }\n    }","commit_id":"33948d71e9b83968dadc46fbd60a14abfe7b4960","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n\t * Serialize the link.\r\n\t * \r\n\t * @param buffer\r\n\t * @param iParentRecord\r\n\t * @param iFieldName\r\n\t *          TODO\r\n\t * @param iLinked\r\n\t *          Can be an instance of ORID or a Record<?>\r\n\t * @return\r\n\t */\r\n\tprivate ORID linkToStream(final StringBuilder buffer, final ORecordSchemaAware<?> iParentRecord, Object iLinked) {\r\n\t\tif (iLinked == null)\r\n\t\t\t// NULL REFERENCE\r\n\t\t\treturn null;\r\n\r\n\t\tORID resultRid = null;\r\n\t\tORID rid;\r\n\r\n\t\tif (iLinked instanceof ORID) {\r\n\t\t\t// JUST THE REFERENCE\r\n\t\t\trid = (ORID) iLinked;\r\n\t\t} else {\r\n\t\t\tif (!(iLinked instanceof ORecordInternal<?>)) {\r\n\t\t\t\t// NOT RECORD: TRY TO EXTRACT THE DOCUMENT IF ANY\r\n\t\t\t\tfinal String boundDocumentField = OObjectSerializerHelper.getDocumentBoundField(iLinked.getClass());\r\n\t\t\t\tif (boundDocumentField != null)\r\n\t\t\t\t\tiLinked = OObjectSerializerHelper.getFieldValue(iLinked, boundDocumentField);\r\n\t\t\t}\r\n\r\n\t\t\tif (!(iLinked instanceof ORecordInternal<?>))\r\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid object received. Expected a record but received type=\"\r\n\t\t\t\t\t\t+ iLinked.getClass().getName() + \" and value=\" + iLinked);\r\n\r\n\t\t\t// RECORD\r\n\t\t\tORecordInternal<?> iLinkedRecord = (ORecordInternal<?>) iLinked;\r\n\t\t\trid = iLinkedRecord.getIdentity();\r\n\t\t\tif (rid.isNew() || iLinkedRecord.isDirty()) {\r\n\t\t\t\t// OVERWRITE THE DATABASE TO THE SAME OF THE PARENT ONE\r\n\t\t\t\tiLinkedRecord.setDatabase(iParentRecord.getDatabase());\r\n\r\n\t\t\t\t// STORE THE TRAVERSED OBJECT TO KNOW THE RECORD ID. CALL THIS VERSION TO AVOID CLEAR OF STACK IN THREAD-LOCAL\r\n\t\t\t\t((ODatabaseRecord<ORecordInternal<?>>) iLinkedRecord.getDatabase()).save((ORecordInternal<?>) iLinkedRecord);\r\n\t\t\t}\r\n\r\n\t\t\tif (iParentRecord.getDatabase() instanceof ODatabaseRecord<?>) {\r\n\t\t\t\tfinal ODatabaseRecord<?> db = (ODatabaseRecord<?>) iParentRecord.getDatabase();\r\n\t\t\t\tif (!db.isRetainRecords())\r\n\t\t\t\t\t// REPLACE CURRENT RECORD WITH ITS ID: THIS SAVES A LOT OF MEMORY\r\n\t\t\t\t\tresultRid = iLinkedRecord.getIdentity();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (rid.isValid()) {\r\n\t\t\tbuffer.append(OStringSerializerHelper.LINK);\r\n\t\t\tbuffer.append(rid.toString());\r\n\t\t}\r\n\r\n\t\treturn resultRid;\r\n\t}","id":73156,"modified_method":"/**\r\n\t * Serialize the link.\r\n\t * \r\n\t * @param buffer\r\n\t * @param iParentRecord\r\n\t * @param iFieldName\r\n\t *          TODO\r\n\t * @param iLinked\r\n\t *          Can be an instance of ORID or a Record<?>\r\n\t * @return\r\n\t */\r\n\tprivate ORID linkToStream(final StringBuilder buffer, final ORecordSchemaAware<?> iParentRecord, Object iLinked) {\r\n\t\tif (iLinked == null)\r\n\t\t\t// NULL REFERENCE\r\n\t\t\treturn null;\r\n\r\n\t\tORID resultRid = null;\r\n\t\tORID rid;\r\n\r\n\t\tif (iLinked instanceof ORID) {\r\n\t\t\t// JUST THE REFERENCE\r\n\t\t\trid = (ORID) iLinked;\r\n\t\t} else {\r\n\t\t\tif (!(iLinked instanceof ORecordInternal<?>)) {\r\n\t\t\t\t// NOT RECORD: TRY TO EXTRACT THE DOCUMENT IF ANY\r\n\t\t\t\tfinal String boundDocumentField = OObjectSerializerHelper.getDocumentBoundField(iLinked.getClass());\r\n\t\t\t\tif (boundDocumentField != null)\r\n\t\t\t\t\tiLinked = OObjectSerializerHelper.getFieldValue(iLinked, boundDocumentField);\r\n\t\t\t}\r\n\r\n\t\t\tif (!(iLinked instanceof ORecordInternal<?>))\r\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid object received. Expected a record but received type=\"\r\n\t\t\t\t\t\t+ iLinked.getClass().getName() + \" and value=\" + iLinked);\r\n\r\n\t\t\t// RECORD\r\n\t\t\tORecordInternal<?> iLinkedRecord = (ORecordInternal<?>) iLinked;\r\n\t\t\trid = iLinkedRecord.getIdentity();\r\n\t\t\tif (rid.isNew() || iLinkedRecord.isDirty()) {\r\n\t\t\t\tif (iLinkedRecord.getDatabase() == null)\r\n\t\t\t\t\t// OVERWRITE THE DATABASE TO THE SAME OF THE PARENT ONE\r\n\t\t\t\t\tiLinkedRecord.setDatabase(iParentRecord.getDatabase());\r\n\r\n\t\t\t\t// STORE THE TRAVERSED OBJECT TO KNOW THE RECORD ID. CALL THIS VERSION TO AVOID CLEAR OF STACK IN THREAD-LOCAL\r\n\t\t\t\t((ODatabaseRecord<ORecordInternal<?>>) iLinkedRecord.getDatabase()).save((ORecordInternal<?>) iLinkedRecord);\r\n\t\t\t}\r\n\r\n\t\t\tif (iParentRecord.getDatabase() instanceof ODatabaseRecord<?>) {\r\n\t\t\t\tfinal ODatabaseRecord<?> db = (ODatabaseRecord<?>) iParentRecord.getDatabase();\r\n\t\t\t\tif (!db.isRetainRecords())\r\n\t\t\t\t\t// REPLACE CURRENT RECORD WITH ITS ID: THIS SAVES A LOT OF MEMORY\r\n\t\t\t\t\tresultRid = iLinkedRecord.getIdentity();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (rid.isValid()) {\r\n\t\t\tbuffer.append(OStringSerializerHelper.LINK);\r\n\t\t\tbuffer.append(rid.toString());\r\n\t\t}\r\n\r\n\t\treturn resultRid;\r\n\t}","commit_id":"15867d63881166d4d6429f314961220539bf86f1","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Result<R> search(Q query, QueryOptions options) {\n\n    SearchRequestBuilder esSearch = this.buildRequest(query, options);\n    FilterBuilder fb = this.getFilter(query, options);\n    QueryBuilder qb = this.getQuery(query, options);\n\n    esSearch.setQuery(QueryBuilders.filteredQuery(qb, fb));\n\n    SearchResponse esResult = esSearch.get();\n\n    Result<R> result = new Result<R>(esResult)\n      .setTotal((int) esResult.getHits().totalHits())\n      .setTime(esResult.getTookInMillis());\n\n    for (SearchHit hit : esResult.getHits()) {\n      result.getHits().add(this.getSearchResult(hit));\n    }\n\n    return result;\n  }","id":73157,"modified_method":"public Result<R> search(Q query, QueryOptions options) {\n\n    SearchRequestBuilder esSearch = this.buildRequest(query, options);\n    FilterBuilder fb = this.getFilter(query, options);\n    QueryBuilder qb = this.getQuery(query, options);\n\n    esSearch.setQuery(QueryBuilders.filteredQuery(qb, fb));\n\n    SearchResponse esResult = esSearch.get();\n\n    Result<R> result = new Result<R>(esResult);\n\n    if(esResult != null){\n      result\n        .setTotal((int) esResult.getHits().totalHits())\n        .setTime(esResult.getTookInMillis());\n\n      for (SearchHit hit : esResult.getHits()) {\n        result.getHits().add(this.getSearchResult(hit));\n      }\n    }\n\n    return result;\n  }","commit_id":"62e1130a48649c6b061e934214043cd693560556","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public R getByKey(K key) {\n    GetResponse result = getClient().prepareGet(this.getIndexName(),\n      this.indexDefinition.getIndexType(), this.getKeyValue(key))\n      .get();\n    return this.getSearchResult(result.getSourceAsMap());\n  }","id":73158,"modified_method":"@Override\n  public R getByKey(K key) {\n    GetResponse result = getClient().prepareGet(this.getIndexName(),\n      this.indexDefinition.getIndexType(), this.getKeyValue(key))\n      .get();\n    return this.getSearchResult(result.getSource());\n  }","commit_id":"62e1130a48649c6b061e934214043cd693560556","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  @CheckForNull\n  public Date createdAt() {\n    return (Date) fields.get(RuleField.CREATED_AT.key());\n  }","id":73159,"modified_method":"@Override\n  @CheckForNull\n  public Date createdAt() {\n    SimpleDateFormat sdf = new SimpleDateFormat( \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\" );\n    try {\n      return sdf.parse((String) fields.get(RuleField.CREATED_AT.key()));\n    } catch (ParseException e) {\n      throw new IllegalStateException(\"Cannot parse date\", e);\n    }\n  }","commit_id":"62e1130a48649c6b061e934214043cd693560556","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  @CheckForNull\n  public Date updatedAt() {\n    return (Date) fields.get(RuleField.UPDATED_AT.key());\n  }","id":73160,"modified_method":"@Override\n  @CheckForNull\n  public Date updatedAt() {\n    SimpleDateFormat sdf = new SimpleDateFormat( \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\" );\n    try {\n      return sdf.parse((String) fields.get(RuleField.UPDATED_AT.key()));\n    } catch (ParseException e) {\n      throw new IllegalStateException(\"Cannot parse date\", e);\n    }\n  }","commit_id":"62e1130a48649c6b061e934214043cd693560556","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  protected XContentBuilder getMapping() throws IOException {\n    XContentBuilder mapping = jsonBuilder().startObject()\n      .startObject(this.indexDefinition.getIndexType())\n      .field(\"dynamic\", true)\n      .startObject(\"properties\");\n\n    addMatchField(mapping, RuleField.KEY.key(), \"string\");\n    addMatchField(mapping, RuleField.REPOSITORY.key(), \"string\");\n    addMatchField(mapping, RuleField.SEVERITY.key(), \"string\");\n    addMatchField(mapping, RuleField.STATUS.key(), \"string\");\n\n    mapping.startObject(RuleField.NAME.key())\n        .field(\"type\", \"multi_field\")\n        .startObject(\"fields\")\n          .startObject(RuleField.NAME.key())\n            .field(\"type\", \"string\")\n            .field(\"index\", \"analyzed\")\n          .endObject()\n          .startObject(\"search\")\n            .field(\"type\", \"string\")\n            .field(\"index\", \"analyzed\")\n            .field(\"index_analyzer\", \"rule_name\")\n            .field(\"search_analyzer\", \"standard\")\n          .endObject()\n        .endObject()\n      .endObject();\n\n    mapping.startObject(RuleField.ACTIVE.key())\n      .field(\"type\", \"nested\")\n      .field(\"dynamic\", true)\n      .endObject();\n\n    mapping.startObject(RuleField.PARAMS.key())\n      .field(\"type\", \"nested\")\n      .field(\"dynamic\", true)\n      .endObject();\n\n    return mapping.endObject()\n      .endObject().endObject();\n  }","id":73161,"modified_method":"@Override\n  protected XContentBuilder getMapping() throws IOException {\n    XContentBuilder mapping = jsonBuilder().startObject()\n      .startObject(this.indexDefinition.getIndexType())\n      .field(\"dynamic\", true)\n      .startObject(\"properties\");\n\n    addMatchField(mapping, RuleField.KEY.key(), \"string\");\n    addMatchField(mapping, RuleField.REPOSITORY.key(), \"string\");\n    addMatchField(mapping, RuleField.SEVERITY.key(), \"string\");\n    addMatchField(mapping, RuleField.STATUS.key(), \"string\");\n\n    mapping.startObject(RuleField.CREATED_AT.key())\n      .field(\"type\", \"date\")\n      .field(\"format\", \"date_time\")\n      .endObject();\n\n    mapping.startObject(RuleField.UPDATED_AT.key())\n      .field(\"type\", \"date\")\n      .field(\"format\", \"date_time\")\n      .endObject();\n\n    mapping.startObject(RuleField.NAME.key())\n        .field(\"type\", \"multi_field\")\n        .startObject(\"fields\")\n          .startObject(RuleField.NAME.key())\n            .field(\"type\", \"string\")\n            .field(\"index\", \"analyzed\")\n          .endObject()\n          .startObject(\"search\")\n            .field(\"type\", \"string\")\n            .field(\"index\", \"analyzed\")\n            .field(\"index_analyzer\", \"rule_name\")\n            .field(\"search_analyzer\", \"standard\")\n          .endObject()\n        .endObject()\n      .endObject();\n\n    mapping.startObject(RuleField.ACTIVE.key())\n      .field(\"type\", \"nested\")\n      .field(\"dynamic\", true)\n      .endObject();\n\n    mapping.startObject(RuleField.PARAMS.key())\n      .field(\"type\", \"nested\")\n      .field(\"dynamic\", true)\n      .endObject();\n\n    return mapping.endObject()\n      .endObject().endObject();\n  }","commit_id":"62e1130a48649c6b061e934214043cd693560556","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void insert_in_db_and_index_in_es() {\n    // insert db\n    RuleKey ruleKey = RuleKey.of(\"javascript\", \"S001\");\n    dao.insert(newRuleDto(ruleKey), dbSession);\n    dbSession.commit();\n\n    // verify that rule is persisted in db\n    RuleDto persistedDto = dao.getByKey(ruleKey, dbSession);\n    assertThat(persistedDto).isNotNull();\n    assertThat(persistedDto.getId()).isGreaterThanOrEqualTo(0);\n    assertThat(persistedDto.getRuleKey()).isEqualTo(ruleKey.rule());\n    assertThat(persistedDto.getLanguage()).isEqualTo(\"js\");\n    assertThat(persistedDto.getTags()).containsOnly(\"tag1\", \"tag2\");\n    assertThat(persistedDto.getSystemTags()).containsOnly(\"systag1\", \"systag2\");\n\n    // verify that rule is indexed in es\n    index.refresh();\n    Rule hit = index.getByKey(ruleKey);\n    assertThat(hit).isNotNull();\n    assertThat(hit.key().repository()).isEqualTo(ruleKey.repository());\n    assertThat(hit.key().rule()).isEqualTo(ruleKey.rule());\n    assertThat(hit.language()).isEqualTo(\"js\");\n    assertThat(hit.name()).isEqualTo(\"Rule S001\");\n    assertThat(hit.htmlDescription()).isEqualTo(\"Description S001\");\n    assertThat(hit.status()).isEqualTo(RuleStatus.READY);\n    //TODO fix date in ES\n//    assertThat(hit.createdAt()).isNotNull();\n//    assertThat(hit.updatedAt()).isNotNull();\n    assertThat(hit.internalKey()).isEqualTo(\"InternalKeyS001\");\n    assertThat(hit.severity()).isEqualTo(\"INFO\");\n    assertThat(hit.template()).isFalse();\n    assertThat(hit.tags()).containsOnly(\"tag1\", \"tag2\");\n    assertThat(hit.systemTags()).containsOnly(\"systag1\", \"systag2\");\n\n  }","id":73162,"modified_method":"@Test\n  public void insert_in_db_and_index_in_es() throws InterruptedException {\n    // insert db\n    RuleKey ruleKey = RuleKey.of(\"javascript\", \"S001\");\n    dao.insert(newRuleDto(ruleKey), dbSession);\n    dbSession.commit();\n\n    // verify that rule is persisted in db\n    RuleDto persistedDto = dao.getByKey(ruleKey, dbSession);\n    assertThat(persistedDto).isNotNull();\n    assertThat(persistedDto.getId()).isGreaterThanOrEqualTo(0);\n    assertThat(persistedDto.getRuleKey()).isEqualTo(ruleKey.rule());\n    assertThat(persistedDto.getLanguage()).isEqualTo(\"js\");\n    assertThat(persistedDto.getTags()).containsOnly(\"tag1\", \"tag2\");\n    assertThat(persistedDto.getSystemTags()).containsOnly(\"systag1\", \"systag2\");\n\n    // verify that rule is indexed in es\n    index.refresh();\n\n//    Thread.sleep(10000000);\n\n\n    Rule hit = index.getByKey(ruleKey);\n    assertThat(hit).isNotNull();\n    assertThat(hit.key().repository()).isEqualTo(ruleKey.repository());\n    assertThat(hit.key().rule()).isEqualTo(ruleKey.rule());\n    assertThat(hit.language()).isEqualTo(\"js\");\n    assertThat(hit.name()).isEqualTo(\"Rule S001\");\n    assertThat(hit.htmlDescription()).isEqualTo(\"Description S001\");\n    assertThat(hit.status()).isEqualTo(RuleStatus.READY);\n    assertThat(hit.createdAt()).isNotNull();\n    assertThat(hit.updatedAt()).isNotNull();\n    assertThat(hit.internalKey()).isEqualTo(\"InternalKeyS001\");\n    assertThat(hit.severity()).isEqualTo(\"INFO\");\n    assertThat(hit.template()).isFalse();\n    assertThat(hit.tags()).containsOnly(\"tag1\", \"tag2\");\n    assertThat(hit.systemTags()).containsOnly(\"systag1\", \"systag2\");\n\n  }","commit_id":"62e1130a48649c6b061e934214043cd693560556","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static JobStatus createJobStatus(ObjectFactory objectFactory, URI self,\n        org.xwiki.job.event.status.JobStatus jobStatus)\n    {\n        JobStatus status = objectFactory.createJobStatus();\n        status.setId(StringUtils.join(jobStatus.getRequest().getId(), \"/\"));\n        status.setState(jobStatus.getState().name());\n        status.setProgress(createJobProgress(objectFactory, jobStatus.getProgress()));\n        Calendar calendarStartDate = Calendar.getInstance();\n        calendarStartDate.setTime(jobStatus.getStartDate());\n        status.setStartDate(calendarStartDate);\n        if (jobStatus.getEndDate() != null) {\n            Calendar calendarEndDate = Calendar.getInstance();\n            calendarEndDate.setTime(jobStatus.getEndDate());\n            status.setEndDate(calendarEndDate);\n        }\n        if (self != null) {\n            Link link = objectFactory.createLink();\n            link.setHref(self.toString());\n            link.setRel(Relations.SELF);\n            status.getLinks().add(link);\n        }\n\n        return status;\n    }","id":73163,"modified_method":"public static JobStatus createJobStatus(ObjectFactory objectFactory, URI self,\n        org.xwiki.job.event.status.JobStatus jobStatus)\n    {\n        JobStatus status = objectFactory.createJobStatus();\n        status.setId(StringUtils.join(jobStatus.getRequest().getId(), \"/\"));\n        status.setState(jobStatus.getState().name());\n        status.setProgress(createJobProgress(objectFactory, jobStatus.getProgress()));\n        if (jobStatus.getStartDate() != null) {\n            Calendar calendarStartDate = Calendar.getInstance();\n            calendarStartDate.setTime(jobStatus.getStartDate());\n            status.setStartDate(calendarStartDate);\n        }\n        if (jobStatus.getEndDate() != null) {\n            Calendar calendarEndDate = Calendar.getInstance();\n            calendarEndDate.setTime(jobStatus.getEndDate());\n            status.setEndDate(calendarEndDate);\n        }\n        if (self != null) {\n            Link link = objectFactory.createLink();\n            link.setHref(self.toString());\n            link.setRel(Relations.SELF);\n            status.getLinks().add(link);\n        }\n\n        return status;\n    }","commit_id":"723528233741e38faedf307d08f9c033a1bf9193","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static JobStatus createJobStatus(ObjectFactory objectFactory, URI self, \n            org.xwiki.job.event.status.JobStatus jobStatus) throws XWikiException\n    {\n        JobStatus status = objectFactory.createJobStatus();\n        status.setId(StringUtils.join(jobStatus.getRequest().getId(), \"/\"));\n        status.setState(jobStatus.getState().name());\n        status.setProgress(createJobProgress(objectFactory, jobStatus.getProgress()));\n        Calendar calendarStartDate = Calendar.getInstance();\n        calendarStartDate.setTime(jobStatus.getStartDate());\n        Calendar calendarEndDate = Calendar.getInstance();\n        calendarEndDate.setTime(jobStatus.getEndDate());\n        status.setStartDate(calendarStartDate);\n        status.setEndDate(calendarEndDate);\n        if (self != null) {\n            Link link = objectFactory.createLink();\n            link.setHref(self.toString());\n            link.setRel(Relations.SELF);\n            status.getLinks().add(link);\n        }\n        return status;\n    }","id":73164,"modified_method":"public static JobStatus createJobStatus(ObjectFactory objectFactory, URI self, \n            org.xwiki.job.event.status.JobStatus jobStatus) throws XWikiException\n    {\n        JobStatus status = objectFactory.createJobStatus();\n        status.setId(StringUtils.join(jobStatus.getRequest().getId(), \"/\"));\n        status.setState(jobStatus.getState().name());\n        status.setProgress(createJobProgress(objectFactory, jobStatus.getProgress()));\n        Calendar calendarStartDate = Calendar.getInstance();\n        calendarStartDate.setTime(jobStatus.getStartDate());\n        status.setStartDate(calendarStartDate);\n        Calendar calendarEndDate = Calendar.getInstance();\n        if (jobStatus.getEndDate() != null) {\n            calendarEndDate.setTime(jobStatus.getEndDate());\n            status.setEndDate(calendarEndDate);\n        }\n        if (self != null) {\n            Link link = objectFactory.createLink();\n            link.setHref(self.toString());\n            link.setRel(Relations.SELF);\n            status.getLinks().add(link);\n        }\n        return status;\n    }","commit_id":"fe36b0e93dd9025f760bf263638e214883800c75","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public JobStatus getJobStatus(String jobId) throws XWikiRestException\n    {\n        try {\n            org.xwiki.job.event.status.JobStatus jobStatus;\n\n            List<String> id = Arrays.asList(jobId.split(\"/\"));\n\n            Job job = this.jobExecutor.getJob(id);\n            if (job == null) {\n                jobStatus = this.jobStore.getJobStatus(id);\n            } else {\n                jobStatus = job.getStatus();\n            }\n\n            return DomainObjectFactory.createJobStatus(objectFactory, uriInfo.getAbsolutePath(), jobStatus);\n        } catch (XWikiException e) {\n            throw new XWikiRestException(e);\n        }\n    }","id":73165,"modified_method":"@Override\n    public JobStatus getJobStatus(String jobId) throws XWikiRestException\n    {\n        try {\n            org.xwiki.job.event.status.JobStatus jobStatus;\n\n            List<String> id = Arrays.asList(jobId.split(\"/\"));\n\n            Job job = this.jobExecutor.getJob(id);\n            if (job == null) {\n                jobStatus = this.jobStore.getJobStatus(id);\n            } else {\n                jobStatus = job.getStatus();\n            }\n            \n            if (jobStatus == null) {\n                throw new WebApplicationException(Response.Status.NOT_FOUND);\n            }\n\n            return DomainObjectFactory.createJobStatus(objectFactory, uriInfo.getAbsolutePath(), jobStatus);\n        } catch (XWikiException e) {\n            throw new XWikiRestException(e);\n        }\n    }","commit_id":"fe36b0e93dd9025f760bf263638e214883800c75","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n\t\tpublic void validate(Component comp, Object value) throws WrongValueException {\n\t\t\tDate date = (Date)value;\n\t\t\tCalendar c = Calendar.getInstance();\n\t\t\tc.setTime(date);\n\t\t\tint h = c.get(Calendar.HOUR_OF_DAY);\n\t\t\tif(h < 12){\n\t\t\t\tthrow new WrongValueException(comp,\"Hours must large than 12, but is \"+h);\n\t\t\t}\n\t\t}","id":73166,"modified_method":"@Override\n\t\tpublic void validate(Component comp, Object value) throws WrongValueException {\n\t\t\tDate date = (Date)value;\n\t\t\tint h = -1;\n\t\t\tif(date!=null){\n\t\t\t\tCalendar c = Calendar.getInstance();\n\t\t\t\tc.setTime(date);\n\t\t\t\th = c.get(Calendar.HOUR_OF_DAY);\n\t\t\t}\n\t\t\tif(h < 12){\n\t\t\t\tthrow new WrongValueException(comp,\"Hours must large than 12, but is \"+h);\n\t\t\t}\n\t\t}","commit_id":"a8f0b7ac3a9a8c05ed4c7e8b7eefc5b154a08d77","url":"https://github.com/zkoss/zk"},{"original_method":"private static boolean hasLineInfo(SourceLineAnnotation annotation) {\n        return annotation != null && annotation.getStartLine() > 0;\n    }","id":73167,"modified_method":"private static boolean hasLineInfo(SourceLineAnnotation annotation) {\n        // XXX don't use \"1\", use \"0\" ?\n        return annotation != null && annotation.getStartLine() > 1;\n    }","commit_id":"fda77a8582ce18402e09b0303d67f29089676402","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static int findInnerAnonymousClassSourceLine(IJavaElement parentType, String innerName) throws JavaModelException {\n        IType anon = JdtUtils.findAnonymous((IType) parentType, innerName);\n        if (anon != null) {\n            return getLineStart(anon);\n        }\n        return START_LINE_OF_ENCLOSING_TYPE;\n    }","id":73168,"modified_method":"private static int findInnerAnonymousClassSourceLine(IJavaElement parentType, String innerName) throws JavaModelException {\n        IType anon = JdtUtils.findAnonymous((IType) parentType, innerName);\n        if (anon != null) {\n            return getLineStart(anon);\n        }\n        return DONT_KNOW_LINE;\n    }","commit_id":"fda77a8582ce18402e09b0303d67f29089676402","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static void completeInnerClassInfo(String qualifiedClassName, String innerName, @Nonnull IType type, BugInstance bug)\n            throws JavaModelException {\n        int lineNbr = findChildSourceLine(type, innerName, bug);\n        // should be always first line, if not found\n        lineNbr = lineNbr <= 0 ? 1 : lineNbr;\n        String sourceFileStr = getSourceFileHint(type, qualifiedClassName);\n        if (sourceFileStr != null && sourceFileStr.length() > 0) {\n            bug.addSourceLine(new SourceLineAnnotation(qualifiedClassName, sourceFileStr, lineNbr, lineNbr, 0, 0));\n        }\n    }","id":73169,"modified_method":"private static void completeInnerClassInfo(String qualifiedClassName, String innerName, @Nonnull IType type, BugInstance bug) throws JavaModelException {\n        int lineNbr = findChildSourceLine(type, innerName, bug);\n        if(lineNbr > 0){\n            String sourceFileStr = getSourceFileHint(type, qualifiedClassName);\n            if (sourceFileStr != null && sourceFileStr.length() > 0) {\n                bug.addSourceLine(new SourceLineAnnotation(qualifiedClassName, sourceFileStr, lineNbr, lineNbr, 0, 0));\n                if (Reporter.DEBUG) {\n                    System.out.println(\"1. Fixed start line to: \" + lineNbr + \" on \" + qualifiedClassName + \"$\" + innerName);\n                }\n            }\n        }\n    }","commit_id":"fda77a8582ce18402e09b0303d67f29089676402","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * @return start line of given type, or 1 if line could not be found\n     */\n    private static int getLineStart(IType source) throws JavaModelException {\n        ISourceRange range = source.getNameRange();\n        if (range == null) {\n            range = source.getSourceRange();\n        }\n        IScanner scanner = initScanner(source, range);\n        if (scanner != null && range != null) {\n            return scanner.getLineNumber(range.getOffset());\n        }\n        return START_LINE_OF_ENCLOSING_TYPE;\n    }","id":73170,"modified_method":"/**\n     * @return start line of given type, or {@link #DONT_KNOW_LINE} if line could not be found\n     */\n    private static int getLineStart(IType source) throws JavaModelException {\n        ISourceRange range = source.getNameRange();\n        if (range == null) {\n            range = source.getSourceRange();\n        }\n        IScanner scanner = initScanner(source, range);\n        if (scanner != null && range != null) {\n            return scanner.getLineNumber(range.getOffset());\n        }\n        return DONT_KNOW_LINE;\n    }","commit_id":"fda77a8582ce18402e09b0303d67f29089676402","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static int findInnerClassSourceLine(IJavaElement parentType, String name) throws JavaModelException {\n        String elemName = parentType.getElementName();\n        if (name.equals(elemName)) {\n            if (parentType instanceof IType) {\n                return getLineStart((IType) parentType);\n            }\n        }\n        if (parentType instanceof IParent) {\n            IJavaElement[] children = ((IParent) parentType).getChildren();\n            for (int i = 0; i < children.length; i++) {\n                // recursive call\n                int line = findInnerClassSourceLine(children[i], name);\n                if (line > 0) {\n                    return line;\n                }\n            }\n        }\n        return START_LINE_OF_ENCLOSING_TYPE;\n    }","id":73171,"modified_method":"private static int findInnerClassSourceLine(IJavaElement type, String name) throws JavaModelException {\n        String elemName = type.getElementName();\n        if (name.equals(elemName)) {\n            if (type instanceof IType) {\n                return getLineStart((IType) type);\n            }\n        }\n        if (type instanceof IParent) {\n            IJavaElement[] children = ((IParent) type).getChildren();\n            for (int i = 0; i < children.length; i++) {\n                // recursive call\n                int line = findInnerClassSourceLine(children[i], name);\n                if (line > 0) {\n                    return line;\n                }\n            }\n        }\n        return DONT_KNOW_LINE;\n    }","commit_id":"fda77a8582ce18402e09b0303d67f29089676402","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static MarkerParameter createMarkerParameter(IJavaProject project, BugInstance bug) {\n        IJavaElement type = null;\n        WorkItem resource = null;\n        try {\n            type = getJavaElement(bug, project);\n            if (type != null) {\n                resource = new WorkItem(type);\n            }\n        } catch (JavaModelException e1) {\n            FindbugsPlugin.getDefault().logException(e1, \"Could not find Java type for FindBugs warning\");\n        }\n        if (resource == null) {\n            if (Reporter.DEBUG) {\n                reportNoResourceFound(bug);\n            }\n            return null;\n        }\n\n        // default - first class line\n        int primaryLine = bug.getPrimarySourceLineAnnotation().getStartLine();\n\n        // FindBugs needs originally generated primary line in order to find the\n        // bug again.\n        // Sometimes this primary line is <= 0, which causes Eclipse editor to\n        // ignore it\n        // So we check if we can replace the \"wrong\" primary line with a\n        // \"better\" start line\n        // If not, we just provide two values - one for Eclipse, another for\n        // FindBugs itself.\n\n        int startLine = -1;\n        if (primaryLine <= 0) {\n            FieldAnnotation primaryField = bug.getPrimaryField();\n            if (primaryField != null && primaryField.getSourceLines() != null) {\n                startLine = primaryField.getSourceLines().getStartLine();\n            }\n            if (startLine < 0) {\n                // We have to provide line number, otherwise editor wouldn't\n                // show it\n                startLine = 1;\n            }\n        }\n\n        // \"first line of a file\" is too simplistic. What if we have inner types?\n        if(primaryLine <= 1 && startLine <= 1 && type instanceof IType){\n            IType iType = (IType) type;\n            try {\n                startLine = getLineStart(iType);\n//                    System.out.println(\"Fixed start line to: \" + startLine + \" on \" + type.getElementName());\n            } catch (JavaModelException e1) {\n                FindbugsPlugin.getDefault().logException(e1, \"Could not find source line for Java type \" + type\n                        + \"for FindBugs warning: \" + bug);\n            }\n        }\n\n        MarkerParameter parameter;\n        if (startLine > 0) {\n            parameter = new MarkerParameter(bug, resource, startLine, primaryLine);\n        } else {\n            parameter = new MarkerParameter(bug, resource, primaryLine, primaryLine);\n        }\n        if (Reporter.DEBUG) {\n            System.out\n            .println(\"Creating marker for \" + resource.getPath() + \": line \" + parameter.primaryLine + bug.getMessage());\n        }\n        return parameter;\n    }","id":73172,"modified_method":"private static MarkerParameter createMarkerParameter(IJavaProject project, BugInstance bug) {\n        IJavaElement type = null;\n        WorkItem resource = null;\n        try {\n            type = getJavaElement(bug, project);\n            if (type != null) {\n                resource = new WorkItem(type);\n            }\n        } catch (JavaModelException e1) {\n            FindbugsPlugin.getDefault().logException(e1, \"Could not find Java type for FindBugs warning\");\n        }\n        if (resource == null) {\n            if (Reporter.DEBUG) {\n                reportNoResourceFound(bug);\n            }\n            return null;\n        }\n\n        // default - first class line\n        int primaryLine = bug.getPrimarySourceLineAnnotation().getStartLine();\n\n        // FindBugs needs originally generated primary line in order to find the\n        // bug again.\n        // Sometimes this primary line is <= 0, which causes Eclipse editor to\n        // ignore it\n        // So we check if we can replace the \"wrong\" primary line with a\n        // \"better\" start line\n        // If not, we just provide two values - one for Eclipse, another for\n        // FindBugs itself.\n\n        int startLine = DONT_KNOW_LINE;\n\n        // only update if we don't already tried it\n        if(primaryLine != DONT_KNOW_LINE) {\n            // XXX \"first line of a file\" is too simplistic. What if we have inner types?\n            if (primaryLine <= 1 && type instanceof IType) {\n                IType iType = (IType) type;\n                try {\n                    startLine = getLineStart(iType);\n                    if(startLine > 0) {\n                        if (Reporter.DEBUG) {\n                            System.out.println(\"4. Fixed start line to: \" + startLine + \" on \" + type.getElementName());\n                        }\n                    }\n                } catch (JavaModelException e1) {\n                    FindbugsPlugin.getDefault().logException(e1, \"Could not find source line for Java type \" + type\n                            + \"for FindBugs warning: \" + bug);\n                }\n            }\n        }\n\n        if (primaryLine <= 0 && startLine <= 0) {\n            // We have to provide line number, otherwise editor wouldn't show it\n            startLine = 1;\n            if (Reporter.DEBUG) {\n                System.out.println(\"5. Fixed start line to *default* (1) on \" + type);\n            }\n        }\n\n        MarkerParameter parameter;\n        if (startLine > 0) {\n            parameter = new MarkerParameter(bug, resource, startLine, primaryLine);\n        } else {\n            parameter = new MarkerParameter(bug, resource, primaryLine, primaryLine);\n        }\n//        if (Reporter.DEBUG) {\n//            System.out\n//            .println(\"Creating marker for \" + resource.getPath() + \": line \" + parameter.primaryLine + bug.getMessage());\n//        }\n        return parameter;\n    }","commit_id":"fda77a8582ce18402e09b0303d67f29089676402","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static void completeFieldInfo(String qualifiedClassName, String innerName, IType type, BugInstance bug) {\n        FieldAnnotation field = bug.getPrimaryField();\n        if (field == null || type == null) {\n            return;\n        }\n\n        IField ifield = type.getField(field.getFieldName());\n        ISourceRange sourceRange = null;\n        IScanner scanner = null;\n        JavaModelException ex = null;\n        try {\n            sourceRange = ifield.getNameRange();\n        } catch (JavaModelException e) {\n            ex = e;\n        }\n        try {\n            // second try...\n            if (sourceRange == null) {\n                sourceRange = ifield.getSourceRange();\n            }\n            scanner = initScanner(type, sourceRange);\n        } catch (JavaModelException e) {\n            String message = \"Can not complete field annotation \" + field + \" for the field: \" + ifield + \" in class: \"\n                    + qualifiedClassName + \", type \" + type + \", bug \" + bug;\n            if (ex != null) {\n                // report only first one\n                e = ex;\n            }\n            FindbugsPlugin.getDefault().logMessage(IStatus.WARNING, message, e);\n        }\n        if (scanner == null || sourceRange == null) {\n            return;\n        }\n        int lineNbr = scanner.getLineNumber(sourceRange.getOffset());\n        lineNbr = lineNbr <= 0 ? 1 : lineNbr;\n        String sourceFileStr = getSourceFileHint(type, qualifiedClassName);\n        field.setSourceLines(new SourceLineAnnotation(qualifiedClassName, sourceFileStr, lineNbr, lineNbr, 0, 0));\n    }","id":73173,"modified_method":"private static void completeFieldInfo(String qualifiedClassName,\n            @Nonnull IType type, @Nonnull BugInstance bug, @Nonnull FieldAnnotation field) {\n\n        IField ifield = type.getField(field.getFieldName());\n        ISourceRange sourceRange = null;\n        JavaModelException ex = null;\n        try {\n            sourceRange = ifield.getNameRange();\n        } catch (JavaModelException e) {\n            ex = e;\n        }\n        IScanner scanner = null;\n        try {\n            // second try...\n            if (sourceRange == null) {\n                sourceRange = ifield.getSourceRange();\n            }\n            scanner = initScanner(type, sourceRange);\n        } catch (JavaModelException e) {\n            String message = \"Can not complete field annotation \" + field + \" for the field: \" + ifield + \" in class: \"\n                    + qualifiedClassName + \", type \" + type + \", bug \" + bug;\n            if (ex != null) {\n                // report only first one\n                e = ex;\n            }\n            FindbugsPlugin.getDefault().logMessage(IStatus.WARNING, message, e);\n        }\n        if (scanner == null || sourceRange == null) {\n            return;\n        }\n        int lineNbr = scanner.getLineNumber(sourceRange.getOffset());\n        if(lineNbr > 0){\n            String sourceFileStr = getSourceFileHint(type, qualifiedClassName);\n            field.setSourceLines(new SourceLineAnnotation(qualifiedClassName, sourceFileStr, lineNbr, lineNbr, 0, 0));\n            if (Reporter.DEBUG) {\n                System.out.println(\"2. Fixed start line to: \" + lineNbr + \" on \" + qualifiedClassName);\n            }\n        }\n    }","commit_id":"fda77a8582ce18402e09b0303d67f29089676402","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * Get the underlying resource (Java class) for given BugInstance.\n     *\n     * @param bug\n     *            the BugInstance\n     * @param project\n     *            the project\n     * @return the IResource representing the Java class\n     */\n    private static @CheckForNull\n    IJavaElement getJavaElement(BugInstance bug, IJavaProject project) throws JavaModelException {\n\n        SourceLineAnnotation primarySourceLineAnnotation = bug.getPrimarySourceLineAnnotation();\n        PackageMemberAnnotation packageAnnotation = null;\n        String packageName = null;\n        String qualifiedClassName = null;\n        if (primarySourceLineAnnotation == null) {\n            packageAnnotation = bug.getPrimaryClass();\n            if (packageAnnotation != null) {\n                packageName = packageAnnotation.getPackageName();\n                qualifiedClassName = packageAnnotation.getClassName();\n            }\n        } else {\n            packageName = primarySourceLineAnnotation.getPackageName();\n            qualifiedClassName = primarySourceLineAnnotation.getClassName();\n        }\n        if (qualifiedClassName == null) {\n            return null;\n        }\n\n        if (Reporter.DEBUG) {\n            System.out.println(\"Looking up class: \" + packageName + \", \" + qualifiedClassName);\n        }\n\n        Matcher m = fullName.matcher(qualifiedClassName);\n        IType type;\n        String innerName = null;\n        if (m.matches() && m.group(2).length() > 0) {\n\n            String outerQualifiedClassName = m.group(1).replace('$', '.');\n            innerName = m.group(2).substring(1);\n            // second argument is required to find also secondary types\n            type = project.findType(outerQualifiedClassName, (IProgressMonitor) null);\n\n            /*\n             * code below only points to the first line of inner class even if\n             * this is not a class bug but field bug\n             */\n            if (type != null && !hasLineInfo(primarySourceLineAnnotation)) {\n                completeInnerClassInfo(qualifiedClassName, innerName, type, bug);\n            }\n        } else {\n            // second argument is required to find also secondary types\n            type = project.findType(qualifiedClassName.replace('$', '.'), (IProgressMonitor) null);\n\n            // for inner classes, some detectors does not properly report source\n            // lines:\n            // instead of reporting the first line of inner class, they report\n            // first line of parent class\n            // in this case we will try to fix this here and point to the right\n            // start line\n            if (type != null && type.isMember()) {\n                if (!hasLineInfo(primarySourceLineAnnotation)) {\n                    completeInnerClassInfo(qualifiedClassName, type.getElementName(), type, bug);\n                }\n            }\n        }\n\n        // reassign it as it may be changed for inner classes\n        primarySourceLineAnnotation = bug.getPrimarySourceLineAnnotation();\n\n        int startLine;\n        /*\n         * Eclipse can help us find the line number for fields => we trying to\n         * add line info for fields here\n         */\n        if (primarySourceLineAnnotation != null) {\n            startLine = primarySourceLineAnnotation.getStartLine();\n            if (startLine <= 0 && bug.getPrimaryField() != null) {\n                completeFieldInfo(qualifiedClassName, innerName, type, bug);\n            }\n        } else {\n            if (bug.getPrimaryField() != null) {\n                completeFieldInfo(qualifiedClassName, innerName, type, bug);\n            }\n        }\n\n        return type;\n    }","id":73174,"modified_method":"/**\n     * Get the underlying resource (Java class) for given BugInstance.\n     *\n     * @param bug\n     *            the BugInstance\n     * @param project\n     *            the project\n     * @return the IResource representing the Java class\n     */\n    private static @CheckForNull\n    IJavaElement getJavaElement(BugInstance bug, IJavaProject project) throws JavaModelException {\n\n        SourceLineAnnotation primarySourceLineAnnotation = bug.getPrimarySourceLineAnnotation();\n        String qualifiedClassName = primarySourceLineAnnotation.getClassName();\n\n//        if (Reporter.DEBUG) {\n//            System.out.println(\"Looking up class: \" + packageName + \", \" + qualifiedClassName);\n//        }\n\n        Matcher m = fullName.matcher(qualifiedClassName);\n        IType type;\n        String innerName = null;\n        if (m.matches() && m.group(2).length() > 0) {\n\n            String outerQualifiedClassName = m.group(1).replace('$', '.');\n            innerName = m.group(2).substring(1);\n            // second argument is required to find also secondary types\n            type = project.findType(outerQualifiedClassName, (IProgressMonitor) null);\n\n            /*\n             * code below only points to the first line of inner class even if\n             * this is not a class bug but field bug\n             */\n            if (type != null && !hasLineInfo(primarySourceLineAnnotation)) {\n                completeInnerClassInfo(qualifiedClassName, innerName, type, bug);\n            }\n        } else {\n            // second argument is required to find also secondary types\n            type = project.findType(qualifiedClassName.replace('$', '.'), (IProgressMonitor) null);\n\n            // for inner classes, some detectors does not properly report source\n            // lines:\n            // instead of reporting the first line of inner class, they report\n            // first line of parent class\n            // in this case we will try to fix this here and point to the right\n            // start line\n            if (type != null && type.isMember()) {\n                if (!hasLineInfo(primarySourceLineAnnotation)) {\n                    completeInnerClassInfo(qualifiedClassName, type.getElementName(), type, bug);\n                }\n            }\n        }\n\n        // reassign it as it may be changed for inner classes\n        primarySourceLineAnnotation = bug.getPrimarySourceLineAnnotation();\n\n        /*\n         * Eclipse can help us find the line number for fields => we trying to\n         * add line info for fields here\n         */\n        int startLine = primarySourceLineAnnotation.getStartLine();\n        // TODO don't use \"1\", use \"0\" ?\n        if (startLine <= 1 && type != null) {\n            FieldAnnotation primaryField = bug.getPrimaryField();\n            if(primaryField != null) {\n                completeFieldInfo(qualifiedClassName, type, bug, primaryField);\n            }\n        }\n\n        return type;\n    }","commit_id":"fda77a8582ce18402e09b0303d67f29089676402","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void writeXML(XMLOutput xmlOutput, boolean addMessages) throws IOException {\n\t\tString classname = getClassName();\n\t\tString packageName = \"\";\n\t\tif (classname.indexOf('.') > 0) \n\t\t\tpackageName = classname.substring(0,1+classname.lastIndexOf('.'));\n\t\tXMLAttributeList attributeList = new XMLAttributeList()\n\t\t\t.addAttribute(\"classname\", classname)\n\t\t\t.addAttribute(\"start\", String.valueOf(getStartLine()))\n\t\t\t.addAttribute(\"end\", String.valueOf(getEndLine()))\n\t\t\t.addAttribute(\"startBytecode\", String.valueOf(getStartBytecode()))\n\t\t\t.addAttribute(\"endBytecode\", String.valueOf(getEndBytecode()));\n\t\t\n\t\tif (isSourceFileKnown()) {\n\t\t\tattributeList.addAttribute(\"sourcefile\", sourceFile);\n\t\t\tattributeList.addAttribute(\"sourcepath\", packageName.replace('.', '/')+sourceFile);\n\t\t}\n\t\t\n\t\tString role = getDescription();\n\t\tif (!role.equals(DEFAULT_ROLE))\n\t\t\tattributeList.addAttribute(\"role\", getDescription());\n\t\tif (synthetic) \n\t\t\tattributeList.addAttribute(\"synthetic\", \"true\");\n\t\tif (addMessages) {\n\t\t\txmlOutput.openTag(ELEMENT_NAME, attributeList);\n\t\t\txmlOutput.openTag(\"Message\");\n\t\t\txmlOutput.writeText(this.toString());\n\t\t\txmlOutput.closeTag(\"Message\");\n\t\t\txmlOutput.closeTag(ELEMENT_NAME);\n\t\t} else {\n\t\t\txmlOutput.openCloseTag(ELEMENT_NAME, attributeList);\n\t\t}\n\t}","id":73175,"modified_method":"public void writeXML(XMLOutput xmlOutput, boolean addMessages) throws IOException {\n\t\tString classname = getClassName();\n\t\tString packageName = \"\";\n\t\tif (classname.indexOf('.') > 0) \n\t\t\tpackageName = classname.substring(0,1+classname.lastIndexOf('.'));\n\t\tXMLAttributeList attributeList = new XMLAttributeList()\n\t\t\t.addAttribute(\"classname\", classname);\n\t\tint n = getStartLine(); // start/end are now optional (were too many \"-1\"s in the xml)\n\t\tif (n >= 0) attributeList.addAttribute(\"start\", String.valueOf(n));\n\t\tn = getEndLine();\n\t\tif (n >= 0) attributeList.addAttribute(\"end\", String.valueOf(n));\n\t\tn = getStartBytecode(); // startBytecode/endBytecode haven't been set for a while now\n\t\tif (n >= 0) attributeList.addAttribute(\"startBytecode\", String.valueOf(n));\n\t\tn = getEndBytecode();\n\t\tif (n >= 0) attributeList.addAttribute(\"endBytecode\", String.valueOf(n));\n\t\t\n\t\tif (isSourceFileKnown()) {\n\t\t\tattributeList.addAttribute(\"sourcefile\", sourceFile);\n\t\t\tattributeList.addAttribute(\"sourcepath\", packageName.replace('.', '/')+sourceFile);\n\t\t}\n\t\t\n\t\tString role = getDescription();\n\t\tif (!role.equals(DEFAULT_ROLE))\n\t\t\tattributeList.addAttribute(\"role\", getDescription());\n\t\tif (synthetic) \n\t\t\tattributeList.addAttribute(\"synthetic\", \"true\");\n\t\tif (addMessages) {\n\t\t\txmlOutput.openTag(ELEMENT_NAME, attributeList);\n\t\t\txmlOutput.openTag(\"Message\");\n\t\t\txmlOutput.writeText(this.toString());\n\t\t\txmlOutput.closeTag(\"Message\");\n\t\t\txmlOutput.closeTag(ELEMENT_NAME);\n\t\t} else {\n\t\t\txmlOutput.openCloseTag(ELEMENT_NAME, attributeList);\n\t\t}\n\t}","commit_id":"d4d7072d9f5652b65128709429e102035969c389","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tIsNullValueDataflow nullValueDataflow = classContext\n\t\t\t\t.getIsNullValueDataflow(method);\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tString sourceFile = classContext.getJavaClass().getSourceFileName();\n\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tInstruction ins = handle.getInstruction();\n\t\t\tif (!(ins instanceof ALOAD))\n\t\t\t\tcontinue;\n\t\t\tALOAD load = (ALOAD) ins;\n\n\t\t\tIsNullValueFrame frame = nullValueDataflow\n\t\t\t\t\t.getFactAtLocation(location);\n\t\t\tif (!frame.isValid()) {\n\t\t\t\t// This basic block is probably dead\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint index = load.getIndex();\n\t\t\tIsNullValue v = frame.getValue(index);\n\t\t\tif (v.isDefinitelyNull()) {\n\t\t\t\tInstruction next = handle.getNext().getInstruction();\n\t\t\t\tInstructionHandle prevHandle = handle.getPrev();\n\t\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\t\t\t\tSourceLineAnnotation prevSourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, prevHandle);\n\t\n\t\t\t\tif (next instanceof ARETURN) {\n\t\t\t\t\t// probably stored for duration of finally block\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (sourceLineAnnotation.getStartLine() > prevSourceLineAnnotation.getEndLine()) {\n\t\t\t\t\t// probably stored for duration of finally block\n\t\t\t\t\t// System.out.println(\"Inverted line\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\t\n\t\t\t\tif (!v.isChecked()) priority++;\n\t\t\t\t\n\t\t\t\tbugReporter.reportBug(new BugInstance(this,\n\t\t\t\t\t\t\"NP_LOAD_OF_KNOWN_NULL_VALUE\",\n\t\t\t\t\t\tpriority)\n\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t.addSourceLine(sourceLineAnnotation));\n\t\t\t}\n\n\t\t}\n\t}","id":73176,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\t\tBitSet lineMentionedMultipleTimes = ClassContext.linesMentionedMultipleTimes(method);\n\t\tBitSet linesWithLoadsOfNotDefinitelyNullValues = null;\n\t\t\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tIsNullValueDataflow nullValueDataflow = classContext\n\t\t\t\t.getIsNullValueDataflow(method);\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tString sourceFile = classContext.getJavaClass().getSourceFileName();\n\n\t\tif (lineMentionedMultipleTimes.cardinality() > 0) {\n\t\t\tlinesWithLoadsOfNotDefinitelyNullValues = new BitSet();\n\t\t\tLineNumberTable lineNumbers = method.getLineNumberTable();\n\t\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\t\tLocation location = i.next();\n\n\t\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\t\tInstruction ins = handle.getInstruction();\n\t\t\t\tif (!(ins instanceof ALOAD))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tIsNullValueFrame frame = nullValueDataflow\n\t\t\t\t\t\t.getFactAtLocation(location);\n\t\t\t\tif (!frame.isValid()) {\n\t\t\t\t\t// This basic block is probably dead\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// System.out.println(handle.getPosition() + \"\\t\" + ins.getName() +  \"\\t\" + frame);\n\t\t\t\t\n\t\t\t\tALOAD load = (ALOAD) ins;\n\n\t\t\t\tint index = load.getIndex();\n\t\t\t\tIsNullValue v = frame.getValue(index);\n\t\t\t\tif (!v.isDefinitelyNull()) {\n\t\t\t\t\tlinesWithLoadsOfNotDefinitelyNullValues.set(lineNumbers.getSourceLine(handle.getPosition()));\n\t\t\t\t}\n\t\t}\n\t\t}\n\t\t// System.out.println(nullValueDataflow);\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tInstruction ins = handle.getInstruction();\n\t\t\tif (!(ins instanceof ALOAD))\n\t\t\t\tcontinue;\n\n\t\t\tIsNullValueFrame frame = nullValueDataflow\n\t\t\t\t\t.getFactAtLocation(location);\n\t\t\tif (!frame.isValid()) {\n\t\t\t\t// This basic block is probably dead\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// System.out.println(handle.getPosition() + \"\\t\" + ins.getName() +  \"\\t\" + frame);\n\t\t\t\n\t\t\tALOAD load = (ALOAD) ins;\n\n\t\t\tint index = load.getIndex();\n\t\t\tIsNullValue v = frame.getValue(index);\n\t\t\tif (v.isDefinitelyNull()) {\n\t\t\t\tInstruction next = handle.getNext().getInstruction();\n\t\t\t\tInstructionHandle prevHandle = handle.getPrev();\n\t\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, handle);\n\t\t\t\tSourceLineAnnotation prevSourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t.fromVisitedInstruction(classContext, methodGen, sourceFile, prevHandle);\n\t\n\t\t\t\tif (next instanceof ARETURN) {\n\t\t\t\t\t// probably stored for duration of finally block\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint startLine = sourceLineAnnotation.getStartLine();\n\t\t\t\tif (startLine > 0 && lineMentionedMultipleTimes.get(startLine) && linesWithLoadsOfNotDefinitelyNullValues.get(startLine))\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif (startLine > prevSourceLineAnnotation.getEndLine()) {\n\t\t\t\t\t// probably stored for duration of finally block\n\t\t\t\t\t// System.out.println(\"Inverted line\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\t\n\t\t\t\tif (!v.isChecked()) priority++;\n\t\t\t\t// System.out.println(\"lineMentionedMultipleTimes: \" + lineMentionedMultipleTimes);\n\t\t\t\t// System.out.println(\"linesWithLoadsOfNonNullValues: \" + linesWithLoadsOfNotDefinitelyNullValues);\n\t\t\t\t\n\t\t\t\tbugReporter.reportBug(new BugInstance(this,\n\t\t\t\t\t\t\"NP_LOAD_OF_KNOWN_NULL_VALUE\",\n\t\t\t\t\t\tpriority)\n\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t.addSourceLine(sourceLineAnnotation));\n\t\t\t}\n\n\t\t}\n\t}","commit_id":"cdd6f180ac876d30ba356bcf7327f7d93138f0a4","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static void processStatus(final FilePath filePath, final SVNStatus status, final ChangelistBuilder builder) {\n    SvnFileStatusProvider.loadEntriesFile(filePath);\n    if (status != null) {\n      FileStatus fStatus = SvnFileStatusProvider.convertStatus(status, filePath.getIOFile());\n\n      final SVNStatusType statusType = status.getContentsStatus();\n      final SVNStatusType propStatus = status.getPropertiesStatus();\n      if (statusType == SVNStatusType.STATUS_UNVERSIONED || statusType == SVNStatusType.UNKNOWN) {\n        builder.processUnversionedFile(filePath.getVirtualFile());\n      }\n      else if (statusType == SVNStatusType.STATUS_CONFLICTED ||\n               statusType == SVNStatusType.STATUS_MODIFIED ||\n               statusType == SVNStatusType.STATUS_REPLACED ||\n               propStatus == SVNStatusType.STATUS_MODIFIED) {\n        builder.processChange(new Change(new SvnUpToDateRevision(filePath, status.getRevision()), new CurrentContentRevision(filePath), fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_ADDED) {\n        builder.processChange(new Change(null, new CurrentContentRevision(filePath), fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_DELETED) {\n        builder.processChange(new Change(new SvnUpToDateRevision(filePath, status.getRevision()), null, fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_MISSING) {\n        builder.processLocallyDeletedFile(filePath);\n      }\n      else if (fStatus == FileStatus.NOT_CHANGED) {\n        VirtualFile file = filePath.getVirtualFile();\n        if (file != null) {\n          final Document document = FileDocumentManager.getInstance().getCachedDocument(file);\n          if (document != null && FileDocumentManager.getInstance().isDocumentUnsaved(document)) {\n            builder.processChange(new Change(new SvnUpToDateRevision(filePath, status.getRevision()), new CurrentContentRevision(filePath), FileStatus.MODIFIED));\n          }\n        }\n      }\n    }\n  }","id":73177,"modified_method":"private static void processStatus(final FilePath filePath, final SVNStatus status, final ChangelistBuilder builder) {\n    SvnFileStatusProvider.loadEntriesFile(filePath);\n    if (status != null) {\n      FileStatus fStatus = SvnFileStatusProvider.convertStatus(status, filePath.getIOFile());\n\n      final SVNStatusType statusType = status.getContentsStatus();\n      final SVNStatusType propStatus = status.getPropertiesStatus();\n      if (statusType == SVNStatusType.STATUS_UNVERSIONED || statusType == SVNStatusType.UNKNOWN) {\n        builder.processUnversionedFile(filePath.getVirtualFile());\n      }\n      else if (statusType == SVNStatusType.STATUS_CONFLICTED ||\n               statusType == SVNStatusType.STATUS_MODIFIED ||\n               statusType == SVNStatusType.STATUS_REPLACED ||\n               propStatus == SVNStatusType.STATUS_MODIFIED) {\n        builder.processChange(new Change(new SvnUpToDateRevision(filePath, status.getRevision()), new CurrentContentRevision(filePath), fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_ADDED) {\n        builder.processChange(new Change(null, new CurrentContentRevision(filePath), fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_DELETED) {\n        builder.processChange(new Change(new SvnUpToDateRevision(filePath, status.getRevision()), null, fStatus));\n      }\n      else if (statusType == SVNStatusType.STATUS_MISSING) {\n        builder.processLocallyDeletedFile(filePath);\n      }\n      else if (fStatus == FileStatus.NOT_CHANGED) {\n        VirtualFile file = filePath.getVirtualFile();\n        if (file != null && FileDocumentManager.getInstance().isFileModified(file)) {\n          builder.processChange(new Change(new SvnUpToDateRevision(filePath, status.getRevision()), new CurrentContentRevision(filePath), FileStatus.MODIFIED));\n        }\n      }\n    }\n  }","commit_id":"b933592cb02b58b8bd32c1a6c389076776c5b3b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean documentIsModified(final VirtualFile file) {\n    final boolean[] result = new boolean[]{false};\n    ApplicationManager.getApplication().runReadAction(new Runnable() {\n      public void run() {\n        Document document = FileDocumentManager.getInstance().getCachedDocument(file);\n        if (document == null) {\n          result[0] = false;\n        }\n        else {\n          result[0] = document.getModificationStamp() != file.getModificationStamp();\n        }\n      }\n    });\n    return result[0];\n  }","id":73178,"modified_method":"private static boolean documentIsModified(final VirtualFile file) {\n    final boolean[] result = new boolean[]{false};\n    ApplicationManager.getApplication().runReadAction(new Runnable() {\n      public void run() {\n        result[0] = FileDocumentManager.getInstance().isFileModified(file);\n      }\n    });\n    return result[0];\n  }","commit_id":"08ed93554cd3ac8e4250994b19ad107fe0b27309","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static String getUnmodifiedDocument(final VirtualFile file, Project project) {\n    final Change change = ChangeListManager.getInstance(project).getChange(file);\n    if (change != null) {\n      final ContentRevision beforeRevision = change.getBeforeRevision();\n      if (beforeRevision instanceof BinaryContentRevision) {\n        return null;\n      }\n      if (beforeRevision != null) {\n        String content;\n        try {\n          content = beforeRevision.getContent();\n        }\n        catch (VcsException ex) {\n          content = null;\n        }\n        return content == null ? null : StringUtil.convertLineSeparators(content);\n      }\n      return null;\n    }\n\n    final Document document = FileDocumentManager.getInstance().getCachedDocument(file);\n    if (document != null && document.getModificationStamp() != file.getModificationStamp()) {\n      return ApplicationManager.getApplication().runReadAction(new Computable<String>() {\n        public String compute() {\n          return LoadTextUtil.loadText(file).toString();\n        }\n      });\n    }\n\n    return null;\n  }","id":73179,"modified_method":"@Nullable\n  private static String getUnmodifiedDocument(final VirtualFile file, Project project) {\n    final Change change = ChangeListManager.getInstance(project).getChange(file);\n    if (change != null) {\n      final ContentRevision beforeRevision = change.getBeforeRevision();\n      if (beforeRevision instanceof BinaryContentRevision) {\n        return null;\n      }\n      if (beforeRevision != null) {\n        String content;\n        try {\n          content = beforeRevision.getContent();\n        }\n        catch (VcsException ex) {\n          content = null;\n        }\n        return content == null ? null : StringUtil.convertLineSeparators(content);\n      }\n      return null;\n    }\n\n    if (FileDocumentManager.getInstance().isFileModified(file)) {\n      return ApplicationManager.getApplication().runReadAction(new Computable<String>() {\n        public String compute() {\n          return LoadTextUtil.loadText(file).toString();\n        }\n      });\n    }\n\n    return null;\n  }","commit_id":"08ed93554cd3ac8e4250994b19ad107fe0b27309","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isDocumentModified(VirtualFile virtualFile) {\n    if (virtualFile.isDirectory()) return false;\n    final FileDocumentManager fdm = FileDocumentManager.getInstance();\n    final Document editorDocument = fdm.getCachedDocument(virtualFile);\n\n    if (editorDocument != null && editorDocument.getModificationStamp() != virtualFile.getModificationStamp()) {\n      return fdm.isDocumentUnsaved(editorDocument);\n    }\n\n    return false;\n  }","id":73180,"modified_method":"private static boolean isDocumentModified(VirtualFile virtualFile) {\n    if (virtualFile.isDirectory()) return false;\n    return FileDocumentManager.getInstance().isFileModified(virtualFile);\n  }","commit_id":"08ed93554cd3ac8e4250994b19ad107fe0b27309","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void refreshFileStatusFromDocument(final VirtualFile file, final Document doc) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"refreshFileStatusFromDocument: file.getModificationStamp()=\" + file.getModificationStamp() + \", document.getModificationStamp()=\" + doc.getModificationStamp());\n    }\n    FileStatus cachedStatus = myFileStatusManager.getCachedStatus(file);\n    if (cachedStatus == null || cachedStatus == FileStatus.NOT_CHANGED || file.getModificationStamp() == doc.getModificationStamp()) {\n      final AbstractVcs vcs = myVcsManager.getVcsFor(file);\n      if (vcs == null) return;\n      if (cachedStatus == FileStatus.MODIFIED && file.getModificationStamp() == doc.getModificationStamp()) {\n        if (!((ReadonlyStatusHandlerImpl) ReadonlyStatusHandlerImpl.getInstance(myProject)).getState().SHOW_DIALOG) {\n          RollbackEnvironment rollbackEnvironment = vcs.getRollbackEnvironment();\n          if (rollbackEnvironment != null) {\n            rollbackEnvironment.rollbackIfUnchanged(file);\n          }\n        }\n      }\n      myFileStatusManager.fileStatusChanged(file);\n      ChangeProvider cp = vcs.getChangeProvider();\n      if (cp != null && cp.isModifiedDocumentTrackingRequired()) {\n        myDirtyScopeManager.fileDirty(file);\n      }\n    }\n  }","id":73181,"modified_method":"public void refreshFileStatusFromDocument(final VirtualFile file, final Document doc) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"refreshFileStatusFromDocument: file.getModificationStamp()=\" + file.getModificationStamp() + \", document.getModificationStamp()=\" + doc.getModificationStamp());\n    }\n    FileStatus cachedStatus = myFileStatusManager.getCachedStatus(file);\n    if (cachedStatus == null || cachedStatus == FileStatus.NOT_CHANGED || !isDocumentModified(file)) {\n      final AbstractVcs vcs = myVcsManager.getVcsFor(file);\n      if (vcs == null) return;\n      if (cachedStatus == FileStatus.MODIFIED && !isDocumentModified(file)) {\n        if (!((ReadonlyStatusHandlerImpl) ReadonlyStatusHandlerImpl.getInstance(myProject)).getState().SHOW_DIALOG) {\n          RollbackEnvironment rollbackEnvironment = vcs.getRollbackEnvironment();\n          if (rollbackEnvironment != null) {\n            rollbackEnvironment.rollbackIfUnchanged(file);\n          }\n        }\n      }\n      myFileStatusManager.fileStatusChanged(file);\n      ChangeProvider cp = vcs.getChangeProvider();\n      if (cp != null && cp.isModifiedDocumentTrackingRequired()) {\n        myDirtyScopeManager.fileDirty(file);\n      }\n    }\n  }","commit_id":"08ed93554cd3ac8e4250994b19ad107fe0b27309","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public String getBaseVersionContent(final VirtualFile file) {\n    final Change change = ChangeListManager.getInstance(myProject).getChange(file);\n    if (change != null) {\n      final ContentRevision beforeRevision = change.getBeforeRevision();\n      if (beforeRevision instanceof BinaryContentRevision) {\n        return null;\n      }\n      if (beforeRevision != null) {\n        String content;\n        try {\n          content = beforeRevision.getContent();\n        }\n        catch(VcsException ex) {\n          content = null;\n        }\n        if (content == null) myHaveEmptyContentRevisions = true;\n        return content;\n      }\n      return null;\n    }\n\n    final Document document = FileDocumentManager.getInstance().getCachedDocument(file);\n    if (document != null && document.getModificationStamp() != file.getModificationStamp()) {\n      return ApplicationManager.getApplication().runReadAction(new Computable<String>() {\n        public String compute() {\n          return LoadTextUtil.loadText(file).toString();\n        }\n      });\n    }\n\n    return null;\n  }","id":73182,"modified_method":"@Override\n  @Nullable\n  public String getBaseVersionContent(final VirtualFile file) {\n    final Change change = ChangeListManager.getInstance(myProject).getChange(file);\n    if (change != null) {\n      final ContentRevision beforeRevision = change.getBeforeRevision();\n      if (beforeRevision instanceof BinaryContentRevision) {\n        return null;\n      }\n      if (beforeRevision != null) {\n        String content;\n        try {\n          content = beforeRevision.getContent();\n        }\n        catch(VcsException ex) {\n          content = null;\n        }\n        if (content == null) myHaveEmptyContentRevisions = true;\n        return content;\n      }\n      return null;\n    }\n\n    if (isDocumentModified(file)) {\n      return ApplicationManager.getApplication().runReadAction(new Computable<String>() {\n        public String compute() {\n          return LoadTextUtil.loadText(file).toString();\n        }\n      });\n    }\n\n    return null;\n  }","commit_id":"08ed93554cd3ac8e4250994b19ad107fe0b27309","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processStatus(final FilePath filePath,\n                             final VirtualFile file,\n                             final FileStatus status,\n                             final VcsRevisionNumber number,\n                             final ChangelistBuilder builder) {\n    if (status == FileStatus.NOT_CHANGED) {\n      if (file != null) {\n        final Document document = FileDocumentManager.getInstance().getCachedDocument(file);\n        if (document != null && FileDocumentManager.getInstance().isDocumentUnsaved(document)) {\n          builder.processChange(new Change(new CvsUpToDateRevision(filePath, number), new CurrentContentRevision(filePath), FileStatus.MODIFIED));\n        }\n      }\n      return;\n    }\n    if (status == FileStatus.MODIFIED || status == FileStatus.MERGE || status == FileStatus.MERGED_WITH_CONFLICTS) {\n      builder.processChange(new Change(new CvsUpToDateRevision(filePath, number), new CurrentContentRevision(filePath), status));\n    }\n    else if (status == FileStatus.ADDED) {\n      builder.processChange(new Change(null, new CurrentContentRevision(filePath), status));\n    }\n    else if (status == FileStatus.DELETED) {\n      builder.processChange(new Change(new CvsUpToDateRevision(filePath, number), null, status));\n    }\n    else if (status == FileStatus.DELETED_FROM_FS) {\n      builder.processLocallyDeletedFile(filePath);\n    }\n    else if (status == FileStatus.UNKNOWN) {\n      builder.processUnversionedFile(filePath.getVirtualFile());\n    }\n  }","id":73183,"modified_method":"private void processStatus(final FilePath filePath,\n                             final VirtualFile file,\n                             final FileStatus status,\n                             final VcsRevisionNumber number,\n                             final ChangelistBuilder builder) {\n    if (status == FileStatus.NOT_CHANGED) {\n      if (file != null && FileDocumentManager.getInstance().isFileModified(file)) {\n        builder.processChange(new Change(new CvsUpToDateRevision(filePath, number), new CurrentContentRevision(filePath), FileStatus.MODIFIED));\n      }\n      return;\n    }\n    if (status == FileStatus.MODIFIED || status == FileStatus.MERGE || status == FileStatus.MERGED_WITH_CONFLICTS) {\n      builder.processChange(new Change(new CvsUpToDateRevision(filePath, number), new CurrentContentRevision(filePath), status));\n    }\n    else if (status == FileStatus.ADDED) {\n      builder.processChange(new Change(null, new CurrentContentRevision(filePath), status));\n    }\n    else if (status == FileStatus.DELETED) {\n      builder.processChange(new Change(new CvsUpToDateRevision(filePath, number), null, status));\n    }\n    else if (status == FileStatus.DELETED_FROM_FS) {\n      builder.processLocallyDeletedFile(filePath);\n    }\n    else if (status == FileStatus.UNKNOWN) {\n      builder.processUnversionedFile(filePath.getVirtualFile());\n    }\n  }","commit_id":"ea905b310fe5a7d698c8ed1e9629a4ae947a1459","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void undo() {\n    exchangeStrings(myNewString, myOldString);\n    getDocument().setModificationStamp(myTimeStamp);\n    fileFileStatusChanged();\n  }","id":73184,"modified_method":"public void undo() {\n    exchangeStrings(myNewString, myOldString);\n    getDocument().setModificationStamp(myTimeStamp);\n    fireFileStatusChanged();\n  }","commit_id":"ea905b310fe5a7d698c8ed1e9629a4ae947a1459","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void fileFileStatusChanged() {\n    VirtualFile file = myDocumentFile != null ? myDocumentFile : FileDocumentManager.getInstance().getFile(getDocument());\n    if (file == null || file instanceof LightVirtualFile) return;\n\n    final Project[] projects = ProjectManager.getInstance().getOpenProjects();\n    for (Project project : projects) {\n      FileStatusManager.getInstance(project).fileStatusChanged(file);\n    }\n  }","id":73185,"modified_method":"private void fireFileStatusChanged() {\n    VirtualFile file = myDocumentFile != null ? myDocumentFile : FileDocumentManager.getInstance().getFile(getDocument());\n    if (file == null || file instanceof LightVirtualFile) return;\n\n    final Project[] projects = ProjectManager.getInstance().getOpenProjects();\n    for (Project project : projects) {\n      final FileStatusManagerImpl fileStatusManager = (FileStatusManagerImpl)FileStatusManager.getInstance (project);\n      fileStatusManager.refreshFileStatusFromDocument(file, getDocument());\n    }\n  }","commit_id":"ea905b310fe5a7d698c8ed1e9629a4ae947a1459","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void documentChanged(DocumentEvent event) {\n      VirtualFile file = FileDocumentManager.getInstance().getFile(event.getDocument());\n      if (file != null) {\n        FileStatus cachedStatus = getCachedStatus(file);\n        if (cachedStatus == FileStatus.NOT_CHANGED) {\n          fileStatusChanged(file);\n          final AbstractVcs vcs = myVcsManager.getVcsFor(file);\n          if (vcs == null) return;\n          ChangeProvider cp = vcs.getChangeProvider();\n          if (cp == null || !cp.isModifiedDocumentTrackingRequired()) return;\n          VcsDirtyScopeManager.getInstance(myProject).fileDirty(file);\n        }\n      }\n    }","id":73186,"modified_method":"public void documentChanged(DocumentEvent event) {\n      VirtualFile file = FileDocumentManager.getInstance().getFile(event.getDocument());\n      if (file != null) {\n        refreshFileStatusFromDocument(file, event.getDocument());\n      }\n    }","commit_id":"ea905b310fe5a7d698c8ed1e9629a4ae947a1459","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n    public void verifyPingIsSent() throws Exception\n    {\n        // Note that we verify that the ES Runner has been initialized as this allows us to more easily debug the test\n        // by manually starting an XWiki instance and an ES instance prior to running this test (in this case we don't\n        // provision ES).\n        if (ElasticSearchRunner.esSetup != null) {\n            // When XWiki was started by ElasticSearchRunner from AllTests, a page was checked to verify that the XWiki\n            // instance was up. This, in turn, triggered the send of an asynchronous ping to the ES instance\n            // (started prior to the XWiki start in ElasticSearchRunner).\n            //\n            // Since the ping may take some time to be sent to our ES instance, we wait till we have 1 index in ES or\n            // till the timeout expires.\n            long count = 0;\n            long time = System.currentTimeMillis();\n            while (count != 1 && (System.currentTimeMillis() - time) < 5000L) {\n                count = ElasticSearchRunner.esSetup.countAll();\n                Thread.sleep(100L);\n            }\n\n            // In order to verify backward compatibility with the previous Active Install format, we also add an index\n            // in the older format.\n            ElasticSearchRunner.esSetup.execute(index(\"installs\", \"install\", \"156231f3-705b-44c6-afe3-e191bcc4b746\")\n                .withSource(\"{ \\\"formatVersion\\\": \\\"1.0\\\", \\\"distributionVersion\\\": \\\"5.2\\\", \"\n                    + \"\\\"distributionId\\\": \\\"org.xwiki.enterprise:xwiki-enterprise-web\\\", \"\n                    + \"\\\"date\\\": \\\"2013-09-16T20:00:34.277Z\\\", \\\"extensions\\\": [ ] }\"));\n        }\n\n        // Navigate to the Active Installs Counter Value page to verify that the ping has been received\n        getUtil().gotoPage(\"ActiveInstalls\", \"ActiveCounterValue2\", \"view\",\n            \"snapshots=true&distributionId=org.xwiki.platform:xwiki-platform-web\");\n        ViewPage vp  = new ViewPage();\n        assertEquals(\"1\", vp.getContent());\n\n        // The default query doesn't show SNAPSHOT versions and thus we expect 0\n        getUtil().gotoPage(\"ActiveInstalls\", \"ActiveCounterValue2\", \"view\",\n            \"distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp  = new ViewPage();\n        assertEquals(\"0\", vp.getContent());\n\n        // Also verify the Active Installs Counter for the old format\n        getUtil().gotoPage(\"ActiveInstalls\", \"ActiveCounterValue1\");\n        vp  = new ViewPage();\n        assertEquals(\"0\", vp.getContent());\n\n        // Navigate to the Total Installs Counter Value page to verify that the ping has been received\n        getUtil().gotoPage(\"ActiveInstalls\", \"TotalCounterValue2\", \"view\",\n            \"snapshots=true&distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp = new ViewPage();\n        assertEquals(\"1\", vp.getContent());\n\n        // The default query doesn't show SNAPSHOT versions and thus we expect 0\n        getUtil().gotoPage(\"ActiveInstalls\", \"TotalCounterValue2\", \"view\",\n            \"distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp = new ViewPage();\n        assertEquals(\"0\", vp.getContent());\n\n        // Also verify the Total Installs Counter for the old format\n        getUtil().gotoPage(\"ActiveInstalls\", \"TotalCounterValue1\");\n        vp  = new ViewPage();\n        assertEquals(\"1\", vp.getContent());\n    }","id":73187,"modified_method":"@Test\n    public void verifyPingIsSent() throws Exception\n    {\n        // Note that we verify that the ES Runner has been initialized as this allows us to more easily debug the test\n        // by manually starting an XWiki instance and an ES instance prior to running this test (in this case we don't\n        // provision ES).\n        if (ElasticSearchRunner.esSetup != null) {\n            // When XWiki was started by ElasticSearchRunner from AllTests, a page was checked to verify that the XWiki\n            // instance was up. This, in turn, triggered the send of an asynchronous ping to the ES instance\n            // (started prior to the XWiki start in ElasticSearchRunner).\n            //\n            // Since the ping may take some time to be sent to our ES instance, we wait till we have 1 index in ES or\n            // till the timeout expires.\n            long count = 0;\n            long time = System.currentTimeMillis();\n            while (count != 1 && (System.currentTimeMillis() - time) < 5000L) {\n                count = ElasticSearchRunner.esSetup.countAll();\n                Thread.sleep(100L);\n            }\n\n            // In order to verify backward compatibility with the previous Active Install format, we also add an index\n            // in the older format.\n            ElasticSearchRunner.esSetup.execute(index(\"installs\", \"install\", \"156231f3-705b-44c6-afe3-e191bcc4b746\")\n                .withSource(\"{ \\\"formatVersion\\\": \\\"1.0\\\", \\\"distributionVersion\\\": \\\"5.2\\\", \"\n                    + \"\\\"distributionId\\\": \\\"org.xwiki.enterprise:xwiki-enterprise-web\\\", \"\n                    + \"\\\"date\\\": \\\"2013-09-16T20:00:34.277Z\\\", \\\"extensions\\\": [ ] }\"));\n        }\n\n        // Navigate to the Active Installs Counter Value page to verify that the ping has been received\n        getUtil().gotoPage(\"ActiveInstalls\", \"ActiveCounterValue2\", \"view\",\n            \"snapshots=true&distributionId=org.xwiki.platform:xwiki-platform-web\");\n        ViewPage vp  = new ViewPage();\n        assertEquals(\"1\", vp.getContent());\n\n        // The default query doesn't show SNAPSHOT versions and thus we expect 0\n        getUtil().gotoPage(\"ActiveInstalls\", \"ActiveCounterValue2\", \"view\",\n            \"distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp  = new ViewPage();\n        assertEquals(\"0\", vp.getContent());\n\n        // Also verify the Active Installs Counter for the old format\n        getUtil().gotoPage(\"ActiveInstalls\", \"ActiveCounterValue1\");\n        vp  = new ViewPage();\n        assertEquals(\"0\", vp.getContent());\n\n        // Navigate to the Total Installs Counter Value page to verify that the ping has been received\n        getUtil().gotoPage(\"ActiveInstalls\", \"TotalCounterValue2\", \"view\",\n            \"snapshots=true&distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp = new ViewPage();\n        assertEquals(\"1\", vp.getContent());\n\n        // The default query doesn't show SNAPSHOT versions and thus we expect 0\n        getUtil().gotoPage(\"ActiveInstalls\", \"TotalCounterValue2\", \"view\",\n            \"distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp = new ViewPage();\n        assertEquals(\"0\", vp.getContent());\n\n        // Also verify the Total Installs Counter for the old format\n        getUtil().gotoPage(\"ActiveInstalls\", \"TotalCounterValue1\");\n        vp  = new ViewPage();\n        assertEquals(\"1\", vp.getContent());\n\n        // Verify JavaVersion data\n        getUtil().gotoPage(\"ActiveInstalls\", \"JavaVersionsData\", \"view\",\n            \"snapshots=true&distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp  = new ViewPage();\n        assertTrue(\"Got [\" + vp.getContent() + \"]\",\n            vp.getContent().matches(\"Java Version Active Installs Count\\\\r?\\\\n1\\\\.[0-9_\\\\.]* 1\"));\n\n        // Verify Databases data\n        getUtil().gotoPage(\"ActiveInstalls\", \"DatabasesData\", \"view\",\n            \"snapshots=true&distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp  = new ViewPage();\n        assertTrue(\"Got [\" + vp.getContent() + \"]\",\n            vp.getContent().matches(\"Database Active Installs Count\\\\r?\\\\nHSQL Database Engine 1\"));\n\n        // Verify XWikiVersion data\n        getUtil().gotoPage(\"ActiveInstalls\", \"XWikiVersionsData\", \"view\",\n            \"snapshots=true&distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp  = new ViewPage();\n        assertTrue(\"Got [\" + vp.getContent() + \"]\",\n            vp.getContent().matches(\"XWiki Version Active Installs Count\\\\r?\\\\n[0-9]\\\\.[0-9].* 1\"));\n\n        // Verify ServletContainers data\n        getUtil().gotoPage(\"ActiveInstalls\", \"ServletContainersData\", \"view\",\n            \"snapshots=true&distributionId=org.xwiki.platform:xwiki-platform-web\");\n        vp  = new ViewPage();\n        assertTrue(\"Got [\" + vp.getContent() + \"]\",\n            vp.getContent().matches(\"Servlet Container Active Installs Count\\\\r?\\\\njetty 1\"));\n    }","commit_id":"051129f9e3434edacde43969cb37fbdecaaf92cf","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public Map<String, Object> provideData()\n    {\n        Map<String, Object> jsonMap = new HashMap<>();\n        Request request = this.container.getRequest();\n        if (request instanceof ServletRequest) {\n            try {\n                HttpServletRequest httpServletRequest = ((ServletRequest) request).getHttpServletRequest();\n                HttpSession session = httpServletRequest.getSession();\n                ServletContext servletContext = session.getServletContext();\n                // Format of getServerInfo() is \"name/version (text)\" where \" (text)\" is optional.\n                String serverInfo = servletContext.getServerInfo();\n                jsonMap.put(PROPERTY_SERVLET_CONTAINER_NAME,\n                    StringUtils.trim(StringUtils.substringBefore(serverInfo, SERVLET_INFO_VERSION_SEPARATOR)));\n                jsonMap.put(PROPERTY_SERVLET_CONTAINER_VERSION, StringUtils.trim(StringUtils.substringBefore(\n                    StringUtils.substringAfter(serverInfo, SERVLET_INFO_VERSION_SEPARATOR),\n                    SERVLET_INFO_OPTIONALSEPARATOR)));\n            } catch (Throwable e) {\n                // Ignore, we just don't save that information...\n                // However we log a warning since it's a problem that needs to be seen and looked at.\n                this.logger.warn(\"Failed to compute Servlet container information. \"\n                        + \"This information has not been added to the Active Installs ping data. Reason [{}]\",\n                    ExceptionUtils.getRootCauseMessage(e)\n                );\n            }\n        }\n        return jsonMap;\n    }","id":73188,"modified_method":"@Override\n    public Map<String, Object> provideData()\n    {\n        Map<String, Object> jsonMap = new HashMap<>();\n        if (this.environment instanceof ServletEnvironment) {\n            ServletEnvironment servletEnvironment = (ServletEnvironment) this.environment;\n            try {\n                ServletContext servletContext = servletEnvironment.getServletContext();\n                // Format of getServerInfo() is \"name/version (text)\" where \" (text)\" is optional.\n                String serverInfo = servletContext.getServerInfo();\n                jsonMap.put(PROPERTY_SERVLET_CONTAINER_NAME,\n                    StringUtils.trim(StringUtils.substringBefore(serverInfo, SERVLET_INFO_VERSION_SEPARATOR)));\n                jsonMap.put(PROPERTY_SERVLET_CONTAINER_VERSION, StringUtils.trim(StringUtils.substringBefore(\n                    StringUtils.substringAfter(serverInfo, SERVLET_INFO_VERSION_SEPARATOR),\n                    SERVLET_INFO_OPTIONALSEPARATOR)));\n            } catch (Throwable e) {\n                // Ignore, we just don't save that information...\n                // However we log a warning since it's a problem that needs to be seen and looked at.\n                this.logger.warn(\"Failed to compute Servlet container information. \"\n                        + \"This information has not been added to the Active Installs ping data. Reason [{}]\",\n                    ExceptionUtils.getRootCauseMessage(e)\n                );\n            }\n        }\n        return jsonMap;\n    }","commit_id":"051129f9e3434edacde43969cb37fbdecaaf92cf","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void provideData() throws Exception\n    {\n        Container container = this.mocker.getInstance(Container.class);\n        ServletRequest servletRequest = mock(ServletRequest.class);\n        when(container.getRequest()).thenReturn(servletRequest);\n        HttpServletRequest httpServletRequest = mock(HttpServletRequest.class);\n        when(servletRequest.getHttpServletRequest()).thenReturn(httpServletRequest);\n        HttpSession session = mock(HttpSession.class);\n        when(httpServletRequest.getSession()).thenReturn(session);\n        ServletContext servletContext = mock(ServletContext.class);\n        when(session.getServletContext()).thenReturn(servletContext);\n        when(servletContext.getServerInfo()).thenReturn(\"Apache Tomcat/7.0.4 (optional text)\");\n\n        assertEquals(\"{\\\"servletContainerVersion\\\":\\\"7.0.4\\\",\\\"servletContainerName\\\":\\\"Apache Tomcat\\\"}\",\n            JSONObject.fromObject(this.mocker.getComponentUnderTest().provideData()).toString());\n    }","id":73189,"modified_method":"@Test\n    public void provideData() throws Exception\n    {\n        ServletEnvironment servletEnvironment = mock(ServletEnvironment.class);\n        ReflectionUtils.setFieldValue(this.mocker.getComponentUnderTest(), \"environment\", servletEnvironment);\n\n        ServletContext servletContext = mock(ServletContext.class);\n        when(servletEnvironment.getServletContext()).thenReturn(servletContext);\n        when(servletContext.getServerInfo()).thenReturn(\"Apache Tomcat/7.0.4 (optional text)\");\n\n        assertEquals(\"{\\\"servletContainerVersion\\\":\\\"7.0.4\\\",\\\"servletContainerName\\\":\\\"Apache Tomcat\\\"}\",\n            JSONObject.fromObject(this.mocker.getComponentUnderTest().provideData()).toString());\n    }","commit_id":"051129f9e3434edacde43969cb37fbdecaaf92cf","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void set(WikiDescriptor descriptor)\n    {\n        // Update the wiki name cache\n        this.wikiIdCache.set(descriptor.getWikiId(), descriptor);\n\n        // Update the wiki alias cache\n        this.wikiAliasCache.set(descriptor.getWikiAlias(), descriptor);\n        for (WikiDescriptorAlias alias : descriptor.getDescriptorAliases()) {\n            this.wikiAliasCache.set(alias.getWikiAlias(), descriptor);\n        }\n    }","id":73190,"modified_method":"@Override\n    public void set(WikiDescriptor descriptor)\n    {\n        // Update the wiki name cache\n        this.wikiIdCache.put(descriptor.getWikiId(), descriptor);\n\n        // Update the wiki alias cache\n        this.wikiAliasCache.put(descriptor.getWikiAlias(), descriptor);\n        for (WikiDescriptorAlias alias : descriptor.getDescriptorAliases()) {\n            this.wikiAliasCache.put(alias.getWikiAlias(), descriptor);\n        }\n    }","commit_id":"c7102b2ac3c2324293020799863825184b46c4ce","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public WikiDescriptor getByWikiId(String wikiId) throws WikiDescriptorException\n    {\n        WikiDescriptor descriptor = this.wikiIdCache.get(wikiId);\n\n        if (descriptor == null) {\n            // Try to load a page named XWiki.XWikiServer<wikiId>\n            XWikiDocument document = getDocument(new EntityReference(\n                String.format(\"XWikiServer%s\", StringUtils.capitalize(wikiId)), EntityType.DOCUMENT,\n                new EntityReference(\"XWiki\", EntityType.SPACE)));\n            if (!document.isNew()) {\n                descriptor = set(document);\n            }\n        }\n\n        return descriptor;\n    }","id":73191,"modified_method":"@Override\n    public WikiDescriptor getByWikiId(String wikiId) throws WikiDescriptorException\n    {\n        WikiDescriptor descriptor;\n\n        if (this.wikiIdCache.containsKey(wikiId)) {\n            descriptor = this.wikiIdCache.get(wikiId);\n            if (descriptor.equals(EMPTY_DESCRIPTOR)) {\n                descriptor = null;\n            }\n        } else {\n            // Try to load a page named XWiki.XWikiServer<wikiId>\n            XWikiDocument document = getDocument(new EntityReference(\n                String.format(\"XWikiServer%s\", StringUtils.capitalize(wikiId)), EntityType.DOCUMENT,\n                new EntityReference(\"XWiki\", EntityType.SPACE)));\n            if (!document.isNew()) {\n                descriptor = set(document);\n            } else {\n                descriptor = null;\n                this.wikiIdCache.put(wikiId, EMPTY_DESCRIPTOR);\n            }\n        }\n\n        return descriptor;\n    }","commit_id":"c7102b2ac3c2324293020799863825184b46c4ce","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private DocumentReference findXWikiServerClassDocumentReference(String wikiAlias)\n        throws WikiDescriptorException\n    {\n        DocumentReference result = null;\n\n        try {\n            Query query = this.queryManager.createQuery(\n                \"where doc.object(XWiki.XWikiServerClass).server = ':wikiAlias'\", Query.XWQL);\n            query.bindValue(\"wikiAlias\", wikiAlias);\n            List<String> documentNames = query.execute();\n\n            // Resolve the document name into a references\n            if (documentNames != null && !documentNames.isEmpty()) {\n                result = this.documentReferenceResolver.resolve(documentNames.get(0));\n            }\n\n        } catch (QueryException e) {\n            throw new WikiDescriptorException(String.format(\n                \"Failed to locate XWiki.XWikiServerClass document for wiki alias [%s]\", wikiAlias), e);\n        }\n\n        return result;\n    }","id":73192,"modified_method":"private DocumentReference findXWikiServerClassDocumentReference(String wikiAlias)\n        throws WikiDescriptorException\n    {\n        DocumentReference result = null;\n\n        try {\n            Query query = this.queryManager.createQuery(\n                \"where doc.object(XWiki.XWikiServerClass).server = :wikiAlias\", Query.XWQL);\n            query.bindValue(\"wikiAlias\", wikiAlias);\n            List<String> documentNames = query.execute();\n\n            // Resolve the document name into a references\n            if (documentNames != null && !documentNames.isEmpty()) {\n                result = this.documentReferenceResolver.resolve(documentNames.get(0));\n            }\n\n        } catch (QueryException e) {\n            throw new WikiDescriptorException(String.format(\n                \"Failed to locate XWiki.XWikiServerClass document for wiki alias [%s]\", wikiAlias), e);\n        }\n\n        return result;\n    }","commit_id":"c7102b2ac3c2324293020799863825184b46c4ce","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public WikiDescriptor getByWikiAlias(String wikiAlias) throws WikiDescriptorException\n    {\n        WikiDescriptor descriptor = this.wikiAliasCache.get(wikiAlias);\n\n        // If not found in the cache then query the wiki and add to the cache if found.\n        //\n        // Note that an alternative implementation would have been to find all Wiki Descriptors at startup but this\n        // would have meant keeping them all in memory at once. Since we want to be able to scale to any number of\n        // subwikis we only cache the most used one. This allows inactive wikis to not take up any memory for example.\n        // Note that In order for performance to be maximum it also means we need to have a cache size at least as\n        // large as the max # of wikis being used at once.\n        if (descriptor == null) {\n            DocumentReference reference = findXWikiServerClassDocumentReference(wikiAlias);\n            if (reference != null) {\n                descriptor = set(getDocument(reference));\n            }\n        }\n\n        return descriptor;\n    }","id":73193,"modified_method":"@Override\n    public WikiDescriptor getByWikiAlias(String wikiAlias) throws WikiDescriptorException\n    {\n        WikiDescriptor descriptor;\n\n        // If not found in the cache then query the wiki and add to the cache if found.\n        //\n        // Note that an alternative implementation would have been to find all Wiki Descriptors at startup but this\n        // would have meant keeping them all in memory at once. Since we want to be able to scale to any number of\n        // subwikis we only cache the most used one. This allows inactive wikis to not take up any memory for example.\n        // Note that In order for performance to be maximum it also means we need to have a cache size at least as\n        // large as the max # of wikis being used at once.\n        if (this.wikiAliasCache.containsKey(wikiAlias)) {\n            descriptor = this.wikiAliasCache.get(wikiAlias);\n            if (descriptor.equals(EMPTY_DESCRIPTOR)) {\n                descriptor = null;\n            }\n        } else {\n            DocumentReference reference = findXWikiServerClassDocumentReference(wikiAlias);\n            if (reference != null) {\n                descriptor = set(getDocument(reference));\n            } else {\n                descriptor = null;\n                this.wikiAliasCache.put(wikiAlias, EMPTY_DESCRIPTOR);\n            }\n        }\n\n        return descriptor;\n    }","commit_id":"c7102b2ac3c2324293020799863825184b46c4ce","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void remove(WikiDescriptor descriptor)\n    {\n        // Remove from the wiki name cache\n        this.wikiIdCache.remove(descriptor.getWikiId());\n\n        // Remove from the wiki alias cache\n        this.wikiAliasCache.remove(descriptor.getWikiAlias());\n        for (WikiDescriptorAlias alias : descriptor.getDescriptorAliases()) {\n            this.wikiAliasCache.set(alias.getWikiAlias(), descriptor);\n        }\n    }","id":73194,"modified_method":"@Override\n    public void remove(WikiDescriptor descriptor)\n    {\n        // Remove from the wiki name cache\n        this.wikiIdCache.remove(descriptor.getWikiId());\n\n        // Remove from the wiki alias cache\n        this.wikiAliasCache.remove(descriptor.getWikiAlias());\n        for (WikiDescriptorAlias alias : descriptor.getDescriptorAliases()) {\n            this.wikiAliasCache.remove(alias.getWikiAlias());\n        }\n    }","commit_id":"c7102b2ac3c2324293020799863825184b46c4ce","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void getByWikiAliasWhenNotInCacheAndItDoesntExist() throws Exception\n    {\n        // Not in cache...\n        Cache<WikiDescriptor> cache = mock(Cache.class);\n        CacheFactory cacheFactory = this.mocker.getInstance(CacheFactory.class);\n        when(cacheFactory.<WikiDescriptor>newCache(any(CacheConfiguration.class))).thenReturn(cache);\n        when(cache.get(\"wikialias\")).thenReturn(null);\n\n        // No result when querying the DB for a XWiki.XWikiServerClass matching the alias\n        QueryManager queryManager = this.mocker.getInstance(QueryManager.class);\n        QueryExecutor queryExecutor = mock(QueryExecutor.class);\n        when(queryManager.createQuery(\"where doc.object(XWiki.XWikiServerClass).server = ':wikiAlias'\", Query.XWQL))\n            .thenReturn(new DefaultQuery(\"statement\", \"language\", queryExecutor));\n        when(queryExecutor.<String>execute(any(Query.class))).thenReturn(Collections.EMPTY_LIST);\n\n        assertNull(this.mocker.getComponentUnderTest().getByWikiAlias(\"wikialias\"));\n    }","id":73195,"modified_method":"@Test\n    public void getByWikiAliasWhenNotInCacheAndItDoesntExist() throws Exception\n    {\n        // No result when querying the DB for a XWiki.XWikiServerClass matching the alias\n        QueryManager queryManager = this.mocker.getInstance(QueryManager.class);\n        QueryExecutor queryExecutor = mock(QueryExecutor.class);\n        when(queryManager.createQuery(\"where doc.object(XWiki.XWikiServerClass).server = :wikiAlias\", Query.XWQL))\n            .thenReturn(new DefaultQuery(\"statement\", \"language\", queryExecutor));\n        when(queryExecutor.<String>execute(any(Query.class))).thenReturn(Collections.EMPTY_LIST);\n\n        assertNull(this.mocker.getComponentUnderTest().getByWikiAlias(\"wikialias\"));\n    }","commit_id":"c7102b2ac3c2324293020799863825184b46c4ce","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void getByWikiIdWhenInCache() throws Exception\n    {\n        // Descriptor is in cache...\n        Cache<WikiDescriptor> cache = mock(Cache.class);\n        CacheFactory cacheFactory = this.mocker.getInstance(CacheFactory.class);\n        when(cacheFactory.<WikiDescriptor>newCache(any(CacheConfiguration.class))).thenReturn(cache);\n        WikiDescriptor descriptor = new WikiDescriptor(\"wikiid\", \"wikialias\");\n        when(cache.get(\"wikiid\")).thenReturn(descriptor);\n\n        assertEquals(descriptor, this.mocker.getComponentUnderTest().getByWikiId(\"wikiid\"));\n    }","id":73196,"modified_method":"@Test\n    public void getByWikiIdWhenInCache() throws Exception\n    {\n        // Descriptor is in cache...\n        WikiDescriptor descriptor = new WikiDescriptor(\"wikiid\", \"wikialias\");\n        this.mocker.getComponentUnderTest().set(descriptor);\n\n        assertEquals(descriptor, this.mocker.getComponentUnderTest().getByWikiId(\"wikiid\"));\n    }","commit_id":"c7102b2ac3c2324293020799863825184b46c4ce","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void getByWikiAliasWhenNotInCacheButExists() throws Exception\n    {\n        // Not in cache...\n        Cache<WikiDescriptor> wikiAliasCache = mock(Cache.class);\n        Cache<WikiDescriptor> wikiIdCache = mock(Cache.class);\n        CacheFactory cacheFactory = this.mocker.getInstance(CacheFactory.class);\n        when(cacheFactory.<WikiDescriptor>newCache(any(CacheConfiguration.class))).thenReturn(wikiAliasCache,\n            wikiIdCache);\n        when(wikiAliasCache.get(\"wikialias\")).thenReturn(null);\n\n        // Return \"space.page\" document name when querying the DB for a XWiki.XWikiServerClass matching the alias\n        QueryManager queryManager = this.mocker.getInstance(QueryManager.class);\n        QueryExecutor queryExecutor = mock(QueryExecutor.class);\n        when(queryManager.createQuery(\"where doc.object(XWiki.XWikiServerClass).server = ':wikiAlias'\", Query.XWQL))\n            .thenReturn(new DefaultQuery(\"statement\", \"language\", queryExecutor));\n        when(queryExecutor.<String>execute(any(Query.class))).thenReturn(Arrays.asList(\"space.page\"));\n\n        // Convert the returned document name represented as a String into a Document Reference\n        DocumentReferenceResolver<String> resolver =\n            this.mocker.getInstance(DocumentReferenceResolver.TYPE_STRING, \"current\");\n        DocumentReference reference = new DocumentReference(\"wiki\", \"space\", \"page\");\n        when(resolver.resolve(\"space.page\")).thenReturn(reference);\n\n        // Get the XWikiDocument for the Document Reference\n        Execution execution = this.mocker.getInstance(Execution.class);\n        XWikiContext xcontext = mock(XWikiContext.class);\n        com.xpn.xwiki.XWiki xwiki = mock(com.xpn.xwiki.XWiki.class);\n        when(xcontext.getWiki()).thenReturn(xwiki);\n        ExecutionContext ec = new ExecutionContext();\n        ec.setProperty(\"xwikicontext\", xcontext);\n        when(execution.getContext()).thenReturn(ec);\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(xwiki.getDocument(eq((EntityReference) reference), any(XWikiContext.class))).thenReturn(document);\n\n        // Get all XWiki.XWikiServerClass XObjects to pass to the Wiki Descriptor Builder\n        List<BaseObject> baseObjects = Arrays.asList(mock(BaseObject.class));\n        when(document.getXObjects(any(EntityReference.class))).thenReturn(baseObjects);\n\n        // Get a WikiDescriptor from the Wiki Descriptor Builder\n        WikiDescriptorBuilder wikiDescriptorBuilder = this.mocker.getInstance(WikiDescriptorBuilder.class);\n        WikiDescriptor descriptor = new WikiDescriptor(\"wikiid\", \"wikialias\");\n        when(wikiDescriptorBuilder.build(anyListOf(BaseObject.class), any(XWikiDocument.class),\n            any(XWikiContext.class))).thenReturn(descriptor);\n\n        assertEquals(descriptor, this.mocker.getComponentUnderTest().getByWikiAlias(\"wikialias\"));\n\n        // Now verify that calling getByWikiId() doesn't need any database calls since getByWikiAlias() has put the\n        // descriptor in the wikiid cache too.\n        verify(wikiAliasCache).set(\"wikialias\", descriptor);\n        verify(wikiIdCache).set(\"wikiid\", descriptor);\n    }","id":73197,"modified_method":"@Test\n    public void getByWikiAliasWhenNotInCacheButExists() throws Exception\n    {\n        // Return \"space.page\" document name when querying the DB for a XWiki.XWikiServerClass matching the alias\n        QueryManager queryManager = this.mocker.getInstance(QueryManager.class);\n        QueryExecutor queryExecutor = mock(QueryExecutor.class);\n        when(queryManager.createQuery(\"where doc.object(XWiki.XWikiServerClass).server = :wikiAlias\", Query.XWQL))\n            .thenReturn(new DefaultQuery(\"statement\", \"language\", queryExecutor));\n        when(queryExecutor.<String>execute(any(Query.class))).thenReturn(Arrays.asList(\"space.page\"));\n\n        // Convert the returned document name represented as a String into a Document Reference\n        DocumentReferenceResolver<String> resolver =\n            this.mocker.getInstance(DocumentReferenceResolver.TYPE_STRING, \"current\");\n        DocumentReference reference = new DocumentReference(\"wiki\", \"space\", \"page\");\n        when(resolver.resolve(\"space.page\")).thenReturn(reference);\n\n        // Get the XWikiDocument for the Document Reference\n        Execution execution = this.mocker.getInstance(Execution.class);\n        XWikiContext xcontext = mock(XWikiContext.class);\n        com.xpn.xwiki.XWiki xwiki = mock(com.xpn.xwiki.XWiki.class);\n        when(xcontext.getWiki()).thenReturn(xwiki);\n        ExecutionContext ec = new ExecutionContext();\n        ec.setProperty(\"xwikicontext\", xcontext);\n        when(execution.getContext()).thenReturn(ec);\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(xwiki.getDocument(eq((EntityReference) reference), any(XWikiContext.class))).thenReturn(document);\n\n        // Get all XWiki.XWikiServerClass XObjects to pass to the Wiki Descriptor Builder\n        List<BaseObject> baseObjects = Arrays.asList(mock(BaseObject.class));\n        when(document.getXObjects(any(EntityReference.class))).thenReturn(baseObjects);\n\n        // Get a WikiDescriptor from the Wiki Descriptor Builder\n        WikiDescriptorBuilder wikiDescriptorBuilder = this.mocker.getInstance(WikiDescriptorBuilder.class);\n        WikiDescriptor descriptor = new WikiDescriptor(\"wikiid\", \"wikialias\");\n        when(wikiDescriptorBuilder.build(anyListOf(BaseObject.class), any(XWikiDocument.class),\n            any(XWikiContext.class))).thenReturn(descriptor);\n\n        assertEquals(descriptor, this.mocker.getComponentUnderTest().getByWikiAlias(\"wikialias\"));\n\n        // Verify that calling getByWikiId() doesn't call XWiki.getDocument() since getByWikiAlias should have put the\n        // descriptor in the wikiId cache too.\n        assertEquals(descriptor, this.mocker.getComponentUnderTest().getByWikiId(\"wikiid\"));\n\n        EntityReference er = new EntityReference(\"XWikiServerWikiid\", EntityType.DOCUMENT,\n            new EntityReference(\"XWiki\", EntityType.SPACE));\n        verify(xwiki, never()).getDocument(eq(er), any(XWikiContext.class));\n    }","commit_id":"c7102b2ac3c2324293020799863825184b46c4ce","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void getByWikiIdWhenNotInCacheButExists() throws Exception\n    {\n        // Not in cache...\n        Cache<WikiDescriptor> wikiAliasCache = mock(Cache.class);\n        Cache<WikiDescriptor> wikiIdCache = mock(Cache.class);\n        CacheFactory cacheFactory = this.mocker.getInstance(CacheFactory.class);\n        when(cacheFactory.<WikiDescriptor>newCache(any(CacheConfiguration.class))).thenReturn(wikiAliasCache,\n            wikiIdCache);\n        when(wikiAliasCache.get(\"wikiid\")).thenReturn(null);\n\n        // Get the XWikiDocument for the Document Reference\n        Execution execution = this.mocker.getInstance(Execution.class);\n        XWikiContext xcontext = mock(XWikiContext.class);\n        com.xpn.xwiki.XWiki xwiki = mock(com.xpn.xwiki.XWiki.class);\n        when(xcontext.getWiki()).thenReturn(xwiki);\n        ExecutionContext ec = new ExecutionContext();\n        ec.setProperty(\"xwikicontext\", xcontext);\n        when(execution.getContext()).thenReturn(ec);\n        XWikiDocument document = mock(XWikiDocument.class);\n        EntityReference reference = new EntityReference(\"XWikiServerWikiid\", EntityType.DOCUMENT,\n            new EntityReference(\"XWiki\", EntityType.SPACE));\n        when(xwiki.getDocument(eq(reference), any(XWikiContext.class))).thenReturn(document);\n        when(document.isNew()).thenReturn(false);\n\n        // Get all XWiki.XWikiServerClass XObjects to pass to the Wiki Descriptor Builder\n        List<BaseObject> baseObjects = Arrays.asList(mock(BaseObject.class));\n        when(document.getXObjects(any(EntityReference.class))).thenReturn(baseObjects);\n\n        // Get a WikiDescriptor from the Wiki Descriptor Builder\n        WikiDescriptorBuilder wikiDescriptorBuilder = this.mocker.getInstance(WikiDescriptorBuilder.class);\n        WikiDescriptor descriptor = new WikiDescriptor(\"wikiid\", \"wikialias\");\n        when(wikiDescriptorBuilder.build(anyListOf(BaseObject.class), any(XWikiDocument.class),\n            any(XWikiContext.class))).thenReturn(descriptor);\n\n        assertEquals(descriptor, this.mocker.getComponentUnderTest().getByWikiId(\"wikiid\"));\n\n        // Now verify that calling getByWikiId() doesn't need any database calls since getByWikiAlias() has put the\n        // descriptor in the wikiid cache too.\n        verify(wikiAliasCache).set(\"wikialias\", descriptor);\n        verify(wikiIdCache).set(\"wikiid\", descriptor);\n    }","id":73198,"modified_method":"@Test\n    public void getByWikiIdWhenNotInCacheButExists() throws Exception\n    {\n        // Get the XWikiDocument for the Document Reference\n        Execution execution = this.mocker.getInstance(Execution.class);\n        XWikiContext xcontext = mock(XWikiContext.class);\n        com.xpn.xwiki.XWiki xwiki = mock(com.xpn.xwiki.XWiki.class);\n        when(xcontext.getWiki()).thenReturn(xwiki);\n        ExecutionContext ec = new ExecutionContext();\n        ec.setProperty(\"xwikicontext\", xcontext);\n        when(execution.getContext()).thenReturn(ec);\n        XWikiDocument document = mock(XWikiDocument.class);\n        EntityReference reference = new EntityReference(\"XWikiServerWikiid\", EntityType.DOCUMENT,\n            new EntityReference(\"XWiki\", EntityType.SPACE));\n        when(xwiki.getDocument(eq(reference), any(XWikiContext.class))).thenReturn(document);\n        when(document.isNew()).thenReturn(false);\n\n        // Get all XWiki.XWikiServerClass XObjects to pass to the Wiki Descriptor Builder\n        List<BaseObject> baseObjects = Arrays.asList(mock(BaseObject.class));\n        when(document.getXObjects(any(EntityReference.class))).thenReturn(baseObjects);\n\n        // Get a WikiDescriptor from the Wiki Descriptor Builder\n        WikiDescriptorBuilder wikiDescriptorBuilder = this.mocker.getInstance(WikiDescriptorBuilder.class);\n        WikiDescriptor descriptor = new WikiDescriptor(\"wikiid\", \"wikialias\");\n        when(wikiDescriptorBuilder.build(anyListOf(BaseObject.class), any(XWikiDocument.class),\n            any(XWikiContext.class))).thenReturn(descriptor);\n\n        assertEquals(descriptor, this.mocker.getComponentUnderTest().getByWikiId(\"wikiid\"));\n\n        // Verify that calling getByWikiAlias() doesn't need any database calls (since we don't mock the Query Manager\n        // if it were calling it we would get an error) since getByWikiId() has put the descriptor in the wikiAlias\n        // cache too.\n        assertEquals(descriptor, this.mocker.getComponentUnderTest().getByWikiAlias(\"wikialias\"));\n    }","commit_id":"c7102b2ac3c2324293020799863825184b46c4ce","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void getByWikiAliasWhenInCache() throws Exception\n    {\n        // Descriptor is in cache...\n        Cache<WikiDescriptor> cache = mock(Cache.class);\n        CacheFactory cacheFactory = this.mocker.getInstance(CacheFactory.class);\n        when(cacheFactory.<WikiDescriptor>newCache(any(CacheConfiguration.class))).thenReturn(cache);\n        WikiDescriptor descriptor = new WikiDescriptor(\"wikiid\", \"wikialias\");\n        when(cache.get(\"wikialias\")).thenReturn(descriptor);\n\n        assertEquals(descriptor, this.mocker.getComponentUnderTest().getByWikiAlias(\"wikialias\"));\n    }","id":73199,"modified_method":"@Test\n    public void getByWikiAliasWhenInCache() throws Exception\n    {\n        // Descriptor is in cache...\n        WikiDescriptor descriptor = new WikiDescriptor(\"wikiid\", \"wikialias\");\n        this.mocker.getComponentUnderTest().set(descriptor);\n\n        assertEquals(descriptor, this.mocker.getComponentUnderTest().getByWikiAlias(\"wikialias\"));\n    }","commit_id":"c7102b2ac3c2324293020799863825184b46c4ce","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void getByWikiIdWhenNotInCacheAndItDoesntExist() throws Exception\n    {\n        // Not in cache...\n        Cache<WikiDescriptor> cache = mock(Cache.class);\n        CacheFactory cacheFactory = this.mocker.getInstance(CacheFactory.class);\n        when(cacheFactory.<WikiDescriptor>newCache(any(CacheConfiguration.class))).thenReturn(cache);\n        when(cache.get(\"wikiid\")).thenReturn(null);\n\n        // Get the XWikiDocument for the Document Reference but mark it as new (meaning that it doesn't exist)\n        Execution execution = this.mocker.getInstance(Execution.class);\n        XWikiContext xcontext = mock(XWikiContext.class);\n        com.xpn.xwiki.XWiki xwiki = mock(com.xpn.xwiki.XWiki.class);\n        when(xcontext.getWiki()).thenReturn(xwiki);\n        ExecutionContext ec = new ExecutionContext();\n        ec.setProperty(\"xwikicontext\", xcontext);\n        when(execution.getContext()).thenReturn(ec);\n        XWikiDocument document = mock(XWikiDocument.class);\n        EntityReference reference = new EntityReference(\"XWikiServerWikiid\", EntityType.DOCUMENT,\n            new EntityReference(\"XWiki\", EntityType.SPACE));\n        when(xwiki.getDocument(eq(reference), any(XWikiContext.class))).thenReturn(document);\n        when(document.isNew()).thenReturn(true);\n\n        assertNull(this.mocker.getComponentUnderTest().getByWikiId(\"wikiid\"));\n    }","id":73200,"modified_method":"@Test\n    public void getByWikiIdWhenNotInCacheAndItDoesntExist() throws Exception\n    {\n        // Get the XWikiDocument for the Document Reference but mark it as new (meaning that it doesn't exist)\n        Execution execution = this.mocker.getInstance(Execution.class);\n        XWikiContext xcontext = mock(XWikiContext.class);\n        com.xpn.xwiki.XWiki xwiki = mock(com.xpn.xwiki.XWiki.class);\n        when(xcontext.getWiki()).thenReturn(xwiki);\n        ExecutionContext ec = new ExecutionContext();\n        ec.setProperty(\"xwikicontext\", xcontext);\n        when(execution.getContext()).thenReturn(ec);\n        XWikiDocument document = mock(XWikiDocument.class);\n        EntityReference reference = new EntityReference(\"XWikiServerWikiid\", EntityType.DOCUMENT,\n            new EntityReference(\"XWiki\", EntityType.SPACE));\n        when(xwiki.getDocument(eq(reference), any(XWikiContext.class))).thenReturn(document);\n        when(document.isNew()).thenReturn(true);\n\n        assertNull(this.mocker.getComponentUnderTest().getByWikiId(\"wikiid\"));\n    }","commit_id":"c7102b2ac3c2324293020799863825184b46c4ce","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void getAll() throws Exception\n    {\n        // Cache setup\n        Cache<WikiDescriptor> wikiAliasCache = mock(Cache.class);\n        Cache<WikiDescriptor> wikiIdCache = mock(Cache.class);\n        CacheFactory cacheFactory = this.mocker.getInstance(CacheFactory.class);\n        when(cacheFactory.<WikiDescriptor>newCache(any(CacheConfiguration.class))).thenReturn(wikiAliasCache,\n            wikiIdCache);\n\n        QueryManager queryManager = this.mocker.getInstance(QueryManager.class);\n        QueryExecutor queryExecutor = mock(QueryExecutor.class);\n        when(queryManager.createQuery(\"from doc.object(XWiki.XWikiServerClass) as descriptor\", Query.XWQL))\n            .thenReturn(new DefaultQuery(\"statement\", \"language\", queryExecutor));\n        when(queryExecutor.<String>execute(any(Query.class))).thenReturn(Arrays.asList(\"space1.page1\", \"space2.page2\"));\n\n        // Convert the returned document names represented as Strings into Document References\n        DocumentReferenceResolver<String> resolver =\n            this.mocker.getInstance(DocumentReferenceResolver.TYPE_STRING, \"current\");\n        DocumentReference reference1 = new DocumentReference(\"wiki1\", \"space1\", \"page1\");\n        when(resolver.resolve(\"space1.page1\")).thenReturn(reference1);\n        DocumentReference reference2 = new DocumentReference(\"wiki2\", \"space2\", \"page2\");\n        when(resolver.resolve(\"space2.page2\")).thenReturn(reference2);\n\n        // Get the XWikiDocuments for the Document References\n        Execution execution = this.mocker.getInstance(Execution.class);\n        XWikiContext xcontext = mock(XWikiContext.class);\n        com.xpn.xwiki.XWiki xwiki = mock(com.xpn.xwiki.XWiki.class);\n        when(xcontext.getWiki()).thenReturn(xwiki);\n        ExecutionContext ec = new ExecutionContext();\n        ec.setProperty(\"xwikicontext\", xcontext);\n        when(execution.getContext()).thenReturn(ec);\n        XWikiDocument document1 = mock(XWikiDocument.class);\n        when(xwiki.getDocument(eq((EntityReference) reference1), any(XWikiContext.class))).thenReturn(document1);\n        XWikiDocument document2 = mock(XWikiDocument.class);\n        when(xwiki.getDocument(eq((EntityReference) reference2), any(XWikiContext.class))).thenReturn(document2);\n\n        // Get all XWiki.XWikiServerClass XObjects to pass to the Wiki Descriptor Builder\n        List<BaseObject> baseObjects = Arrays.asList(mock(BaseObject.class));\n        when(document1.getXObjects(any(EntityReference.class))).thenReturn(baseObjects);\n        when(document2.getXObjects(any(EntityReference.class))).thenReturn(baseObjects);\n\n        // Get a WikiDescriptor from the Wiki Descriptor Builder\n        WikiDescriptorBuilder wikiDescriptorBuilder = this.mocker.getInstance(WikiDescriptorBuilder.class);\n        WikiDescriptor descriptor1 = new WikiDescriptor(\"wikiid1\", \"wikialias1\");\n        WikiDescriptor descriptor2 = new WikiDescriptor(\"wikiid2\", \"wikialias2\");\n        when(wikiDescriptorBuilder.build(anyListOf(BaseObject.class), any(XWikiDocument.class),\n            any(XWikiContext.class))).thenReturn(descriptor1, descriptor2);\n\n        Collection<WikiDescriptor> descriptors = this.mocker.getComponentUnderTest().getAll();\n        assertEquals(2, descriptors.size());\n\n        // Verify all descriptors were put in cache\n        verify(wikiAliasCache).set(\"wikialias1\", descriptor1);\n        verify(wikiAliasCache).set(\"wikialias2\", descriptor2);\n        verify(wikiIdCache).set(\"wikiid1\", descriptor1);\n        verify(wikiIdCache).set(\"wikiid2\", descriptor2);\n    }","id":73201,"modified_method":"@Test\n    public void getAll() throws Exception\n    {\n        QueryManager queryManager = this.mocker.getInstance(QueryManager.class);\n        QueryExecutor queryExecutor = mock(QueryExecutor.class);\n        when(queryManager.createQuery(\"from doc.object(XWiki.XWikiServerClass) as descriptor\", Query.XWQL))\n            .thenReturn(new DefaultQuery(\"statement\", \"language\", queryExecutor));\n        when(queryExecutor.<String>execute(any(Query.class))).thenReturn(Arrays.asList(\"space1.page1\", \"space2.page2\"));\n\n        // Convert the returned document names represented as Strings into Document References\n        DocumentReferenceResolver<String> resolver =\n            this.mocker.getInstance(DocumentReferenceResolver.TYPE_STRING, \"current\");\n        DocumentReference reference1 = new DocumentReference(\"wiki1\", \"space1\", \"page1\");\n        when(resolver.resolve(\"space1.page1\")).thenReturn(reference1);\n        DocumentReference reference2 = new DocumentReference(\"wiki2\", \"space2\", \"page2\");\n        when(resolver.resolve(\"space2.page2\")).thenReturn(reference2);\n\n        // Get the XWikiDocuments for the Document References\n        Execution execution = this.mocker.getInstance(Execution.class);\n        XWikiContext xcontext = mock(XWikiContext.class);\n        com.xpn.xwiki.XWiki xwiki = mock(com.xpn.xwiki.XWiki.class);\n        when(xcontext.getWiki()).thenReturn(xwiki);\n        ExecutionContext ec = new ExecutionContext();\n        ec.setProperty(\"xwikicontext\", xcontext);\n        when(execution.getContext()).thenReturn(ec);\n        XWikiDocument document1 = mock(XWikiDocument.class);\n        when(xwiki.getDocument(eq((EntityReference) reference1), any(XWikiContext.class))).thenReturn(document1);\n        XWikiDocument document2 = mock(XWikiDocument.class);\n        when(xwiki.getDocument(eq((EntityReference) reference2), any(XWikiContext.class))).thenReturn(document2);\n\n        // Get all XWiki.XWikiServerClass XObjects to pass to the Wiki Descriptor Builder\n        List<BaseObject> baseObjects = Arrays.asList(mock(BaseObject.class));\n        when(document1.getXObjects(any(EntityReference.class))).thenReturn(baseObjects);\n        when(document2.getXObjects(any(EntityReference.class))).thenReturn(baseObjects);\n\n        // Get a WikiDescriptor from the Wiki Descriptor Builder\n        WikiDescriptorBuilder wikiDescriptorBuilder = this.mocker.getInstance(WikiDescriptorBuilder.class);\n        WikiDescriptor descriptor1 = new WikiDescriptor(\"wikiid1\", \"wikialias1\");\n        WikiDescriptor descriptor2 = new WikiDescriptor(\"wikiid2\", \"wikialias2\");\n        when(wikiDescriptorBuilder.build(anyListOf(BaseObject.class), any(XWikiDocument.class),\n            any(XWikiContext.class))).thenReturn(descriptor1, descriptor2);\n\n        Collection<WikiDescriptor> descriptors = this.mocker.getComponentUnderTest().getAll();\n        assertEquals(2, descriptors.size());\n\n        // Verify all descriptors were put in cache\n        assertEquals(descriptor1, this.mocker.getComponentUnderTest().getByWikiAlias(\"wikialias1\"));\n        assertEquals(descriptor2, this.mocker.getComponentUnderTest().getByWikiAlias(\"wikialias2\"));\n        assertEquals(descriptor1, this.mocker.getComponentUnderTest().getByWikiId(\"wikiid1\"));\n        assertEquals(descriptor2, this.mocker.getComponentUnderTest().getByWikiId(\"wikiid2\"));\n    }","commit_id":"c7102b2ac3c2324293020799863825184b46c4ce","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private WikiDescriptor getWikiDescriptorById(String wikiId)\n    {\n        try {\n            return this.wikiDescriptorManager.getByWikiId(wikiId);\n        } catch (WikiDescriptorException e) {\n            throw new RuntimeException(String.format(\"Failed to located wiki descriptor for wiki [{}]\", wikiId), e);\n        }\n    }","id":73202,"modified_method":"private WikiDescriptor getWikiDescriptorById(String wikiId)\n    {\n        try {\n            return this.wikiDescriptorManager.getByWikiId(wikiId);\n        } catch (WikiDescriptorException e) {\n            throw new RuntimeException(String.format(\"Failed to located wiki descriptor for wiki [%s]\", wikiId), e);\n        }\n    }","commit_id":"c7102b2ac3c2324293020799863825184b46c4ce","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private WikiDescriptor getWikiDescriptorByAlias(String alias)\n    {\n        try {\n            return this.wikiDescriptorManager.getByWikiAlias(alias);\n        } catch (WikiDescriptorException e) {\n            throw new RuntimeException(String.format(\"Failed to located wiki descriptor for alias [{}]\", alias), e);\n        }\n    }","id":73203,"modified_method":"private WikiDescriptor getWikiDescriptorByAlias(String alias)\n    {\n        try {\n            return this.wikiDescriptorManager.getByWikiAlias(alias);\n        } catch (WikiDescriptorException e) {\n            throw new RuntimeException(String.format(\"Failed to located wiki descriptor for alias [%s]\", alias), e);\n        }\n    }","commit_id":"c7102b2ac3c2324293020799863825184b46c4ce","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static ServiceContext getInstance(PortletRequest portletRequest)\n\t\tthrows PortalException {\n\n\t\t// Theme display\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextThreadLocal.getServiceContext();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tif (serviceContext != null) {\n\t\t\tserviceContext = (ServiceContext)serviceContext.clone();\n\t\t}\n\t\telse {\n\t\t\tserviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setCompanyId(themeDisplay.getCompanyId());\n\t\t\tserviceContext.setLanguageId(themeDisplay.getLanguageId());\n\t\t\tserviceContext.setLayoutFullURL(\n\t\t\t\tPortalUtil.getLayoutFullURL(themeDisplay));\n\t\t\tserviceContext.setLayoutURL(PortalUtil.getLayoutURL(themeDisplay));\n\t\t\tserviceContext.setPathFriendlyURLPrivateGroup(\n\t\t\t\tPortalUtil.getPathFriendlyURLPrivateGroup());\n\t\t\tserviceContext.setPathFriendlyURLPrivateUser(\n\t\t\t\tPortalUtil.getPathFriendlyURLPrivateUser());\n\t\t\tserviceContext.setPathFriendlyURLPublic(\n\t\t\t\tPortalUtil.getPathFriendlyURLPublic());\n\t\t\tserviceContext.setPathMain(PortalUtil.getPathMain());\n\t\t\tserviceContext.setPlid(themeDisplay.getPlid());\n\t\t\tserviceContext.setPortalURL(\n\t\t\t\tPortalUtil.getPortalURL(portletRequest));\n\t\t\tserviceContext.setSignedIn(themeDisplay.isSignedIn());\n\t\t\tserviceContext.setTimeZone(themeDisplay.getTimeZone());\n\n\t\t\tUser user = themeDisplay.getUser();\n\n\t\t\tserviceContext.setUserDisplayURL(user.getDisplayURL(themeDisplay));\n\t\t\tserviceContext.setUserId(user.getUserId());\n\t\t}\n\n\t\tserviceContext.setScopeGroupId(themeDisplay.getScopeGroupId());\n\n\t\t// Attributes\n\n\t\tMap<String, Serializable> attributes = new HashMap<>();\n\n\t\tEnumeration<String> enu = portletRequest.getParameterNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString param = enu.nextElement();\n\n\t\t\tString[] values = portletRequest.getParameterValues(param);\n\n\t\t\tif (ArrayUtil.isNotEmpty(values)) {\n\t\t\t\tif (values.length == 1) {\n\t\t\t\t\tattributes.put(param, values[0]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tattributes.put(param, values);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tserviceContext.setAttributes(attributes);\n\n\t\t// Command\n\n\t\tString cmd = ParamUtil.getString(portletRequest, Constants.CMD);\n\n\t\tserviceContext.setCommand(cmd);\n\n\t\t// Current URL\n\n\t\tString currentURL = PortalUtil.getCurrentURL(portletRequest);\n\n\t\tserviceContext.setCurrentURL(currentURL);\n\n\t\t// Form date\n\n\t\tlong formDateLong = ParamUtil.getLong(portletRequest, \"formDate\");\n\n\t\tif (formDateLong > 0) {\n\t\t\tDate formDate = new Date(formDateLong);\n\n\t\t\tserviceContext.setFormDate(formDate);\n\t\t}\n\n\t\t// Permissions\n\n\t\tboolean addGroupPermissions = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"addGroupPermissions\");\n\t\tboolean addGuestPermissions = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"addGuestPermissions\");\n\t\tString[] groupPermissions = PortalUtil.getGroupPermissions(\n\t\t\tportletRequest);\n\t\tString[] guestPermissions = PortalUtil.getGuestPermissions(\n\t\t\tportletRequest);\n\n\t\tserviceContext.setAddGroupPermissions(addGroupPermissions);\n\t\tserviceContext.setAddGuestPermissions(addGuestPermissions);\n\t\tserviceContext.setGroupPermissions(groupPermissions);\n\t\tserviceContext.setGuestPermissions(guestPermissions);\n\n\t\t// Portlet preferences ids\n\n\t\tHttpServletRequest request = PortalUtil.getHttpServletRequest(\n\t\t\tportletRequest);\n\n\t\tString portletId = PortalUtil.getPortletId(portletRequest);\n\n\t\tPortletPreferencesIds portletPreferencesIds =\n\t\t\tPortletPreferencesFactoryUtil.getPortletPreferencesIds(\n\t\t\t\trequest, portletId);\n\n\t\tserviceContext.setPortletPreferencesIds(portletPreferencesIds);\n\n\t\t// Request\n\n\t\tMap<String, String> headerMap = new HashMap<>();\n\n\t\tenu = request.getHeaderNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString header = enu.nextElement();\n\n\t\t\tString value = request.getHeader(header);\n\n\t\t\theaderMap.put(header, value);\n\t\t}\n\n\t\tserviceContext.setHeaders(headerMap);\n\n\t\tserviceContext.setRemoteAddr(request.getRemoteAddr());\n\t\tserviceContext.setRemoteHost(request.getRemoteHost());\n\t\tserviceContext.setRequest(request);\n\n\t\t// Asset\n\n\t\tMap<String, String[]> parameterMap = portletRequest.getParameterMap();\n\n\t\tList<Long> assetCategoryIdsList = new ArrayList<>();\n\n\t\tboolean updateAssetCategoryIds = false;\n\n\t\tfor (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {\n\t\t\tString name = entry.getKey();\n\n\t\t\tif (name.startsWith(\"assetCategoryIds\")) {\n\t\t\t\tupdateAssetCategoryIds = true;\n\n\t\t\t\tlong[] assetVocabularyAssetCategoryIds = StringUtil.split(\n\t\t\t\t\tParamUtil.getString(portletRequest, name), 0L);\n\n\t\t\t\tfor (long assetCategoryId : assetVocabularyAssetCategoryIds) {\n\t\t\t\t\tassetCategoryIdsList.add(assetCategoryId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (updateAssetCategoryIds) {\n\t\t\tlong[] assetCategoryIds = ArrayUtil.toArray(\n\t\t\t\tassetCategoryIdsList.toArray(\n\t\t\t\t\tnew Long[assetCategoryIdsList.size()]));\n\n\t\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\t}\n\n\t\tboolean assetEntryVisible = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"assetEntryVisible\", true);\n\n\t\tserviceContext.setAssetEntryVisible(assetEntryVisible);\n\n\t\tString assetLinkEntryIdsString = request.getParameter(\n\t\t\t\"assetLinksSearchContainerPrimaryKeys\");\n\n\t\tif (assetLinkEntryIdsString != null) {\n\t\t\tlong[] assetLinkEntryIds = StringUtil.split(\n\t\t\t\tassetLinkEntryIdsString, 0L);\n\n\t\t\tserviceContext.setAssetLinkEntryIds(assetLinkEntryIds);\n\t\t}\n\n\t\tString assetTagNamesString = request.getParameter(\"assetTagNames\");\n\n\t\tif (assetTagNamesString != null) {\n\t\t\tString[] assetTagNames = StringUtil.split(assetTagNamesString);\n\n\t\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\t}\n\n\t\t// Workflow\n\n\t\tint workflowAction = ParamUtil.getInteger(\n\t\t\tportletRequest, \"workflowAction\", WorkflowConstants.ACTION_PUBLISH);\n\n\t\tserviceContext.setWorkflowAction(workflowAction);\n\n\t\treturn serviceContext;\n\t}","id":73204,"modified_method":"public static ServiceContext getInstance(PortletRequest portletRequest)\n\t\tthrows PortalException {\n\n\t\t// Theme display\n\n\t\tServiceContext serviceContext =\n\t\t\tServiceContextThreadLocal.getServiceContext();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tif (serviceContext != null) {\n\t\t\tserviceContext = (ServiceContext)serviceContext.clone();\n\t\t}\n\t\telse {\n\t\t\tserviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setCompanyId(themeDisplay.getCompanyId());\n\t\t\tserviceContext.setLanguageId(themeDisplay.getLanguageId());\n\t\t\tserviceContext.setLayoutFullURL(\n\t\t\t\tPortalUtil.getLayoutFullURL(themeDisplay));\n\t\t\tserviceContext.setLayoutURL(PortalUtil.getLayoutURL(themeDisplay));\n\t\t\tserviceContext.setPathFriendlyURLPrivateGroup(\n\t\t\t\tPortalUtil.getPathFriendlyURLPrivateGroup());\n\t\t\tserviceContext.setPathFriendlyURLPrivateUser(\n\t\t\t\tPortalUtil.getPathFriendlyURLPrivateUser());\n\t\t\tserviceContext.setPathFriendlyURLPublic(\n\t\t\t\tPortalUtil.getPathFriendlyURLPublic());\n\t\t\tserviceContext.setPathMain(PortalUtil.getPathMain());\n\t\t\tserviceContext.setPlid(themeDisplay.getPlid());\n\t\t\tserviceContext.setPortalURL(\n\t\t\t\tPortalUtil.getPortalURL(portletRequest));\n\t\t\tserviceContext.setSignedIn(themeDisplay.isSignedIn());\n\t\t\tserviceContext.setTimeZone(themeDisplay.getTimeZone());\n\n\t\t\tUser user = themeDisplay.getUser();\n\n\t\t\tserviceContext.setUserDisplayURL(user.getDisplayURL(themeDisplay));\n\t\t\tserviceContext.setUserId(user.getUserId());\n\t\t}\n\n\t\tserviceContext.setScopeGroupId(themeDisplay.getScopeGroupId());\n\n\t\t// Attributes\n\n\t\tMap<String, Serializable> attributes = new HashMap<>();\n\n\t\tEnumeration<String> enu = portletRequest.getParameterNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString param = enu.nextElement();\n\n\t\t\tString[] values = portletRequest.getParameterValues(param);\n\n\t\t\tif (ArrayUtil.isNotEmpty(values)) {\n\t\t\t\tif (values.length == 1) {\n\t\t\t\t\tattributes.put(param, values[0]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tattributes.put(param, values);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tserviceContext.setAttributes(attributes);\n\n\t\t// Command\n\n\t\tString cmd = ParamUtil.getString(portletRequest, Constants.CMD);\n\n\t\tserviceContext.setCommand(cmd);\n\n\t\t// Current URL\n\n\t\tString currentURL = PortalUtil.getCurrentURL(portletRequest);\n\n\t\tserviceContext.setCurrentURL(currentURL);\n\n\t\t// Form date\n\n\t\tlong formDateLong = ParamUtil.getLong(portletRequest, \"formDate\");\n\n\t\tif (formDateLong > 0) {\n\t\t\tDate formDate = new Date(formDateLong);\n\n\t\t\tserviceContext.setFormDate(formDate);\n\t\t}\n\n\t\t// Permissions\n\n\t\tModelPermissions modelPermissions = ModelPermissionsFactory.create(\n\t\t\tportletRequest);\n\n\t\tif (!modelPermissions.isEmpty()) {\n\t\t\tserviceContext.setModelPermissions(modelPermissions);\n\t\t}\n\t\telse {\n\t\t\tboolean addGroupPermissions = ParamUtil.getBoolean(\n\t\t\t\tportletRequest, \"addGroupPermissions\");\n\t\t\tboolean addGuestPermissions = ParamUtil.getBoolean(\n\t\t\t\tportletRequest, \"addGuestPermissions\");\n\t\t\tString[] groupPermissions = PortalUtil.getGroupPermissions(\n\t\t\t\tportletRequest);\n\t\t\tString[] guestPermissions = PortalUtil.getGuestPermissions(\n\t\t\t\tportletRequest);\n\n\t\t\tserviceContext.setAddGroupPermissions(addGroupPermissions);\n\t\t\tserviceContext.setAddGuestPermissions(addGuestPermissions);\n\t\t\tserviceContext.setGroupPermissions(groupPermissions);\n\t\t\tserviceContext.setGuestPermissions(guestPermissions);\n\n\t\t\tif ((groupPermissions != null) || (guestPermissions != null)) {\n\t\t\t\tmodelPermissions = ModelPermissionsFactory.create(\n\t\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getSiteGroupId(),\n\t\t\t\t\tgroupPermissions, guestPermissions);\n\t\t\t}\n\n\t\t\tserviceContext.setModelPermissions(modelPermissions);\n\t\t}\n\n\t\t// Portlet preferences ids\n\n\t\tHttpServletRequest request = PortalUtil.getHttpServletRequest(\n\t\t\tportletRequest);\n\n\t\tString portletId = PortalUtil.getPortletId(portletRequest);\n\n\t\tPortletPreferencesIds portletPreferencesIds =\n\t\t\tPortletPreferencesFactoryUtil.getPortletPreferencesIds(\n\t\t\t\trequest, portletId);\n\n\t\tserviceContext.setPortletPreferencesIds(portletPreferencesIds);\n\n\t\t// Request\n\n\t\tMap<String, String> headerMap = new HashMap<>();\n\n\t\tenu = request.getHeaderNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString header = enu.nextElement();\n\n\t\t\tString value = request.getHeader(header);\n\n\t\t\theaderMap.put(header, value);\n\t\t}\n\n\t\tserviceContext.setHeaders(headerMap);\n\n\t\tserviceContext.setRemoteAddr(request.getRemoteAddr());\n\t\tserviceContext.setRemoteHost(request.getRemoteHost());\n\t\tserviceContext.setRequest(request);\n\n\t\t// Asset\n\n\t\tMap<String, String[]> parameterMap = portletRequest.getParameterMap();\n\n\t\tList<Long> assetCategoryIdsList = new ArrayList<>();\n\n\t\tboolean updateAssetCategoryIds = false;\n\n\t\tfor (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {\n\t\t\tString name = entry.getKey();\n\n\t\t\tif (name.startsWith(\"assetCategoryIds\")) {\n\t\t\t\tupdateAssetCategoryIds = true;\n\n\t\t\t\tlong[] assetVocabularyAssetCategoryIds = StringUtil.split(\n\t\t\t\t\tParamUtil.getString(portletRequest, name), 0L);\n\n\t\t\t\tfor (long assetCategoryId : assetVocabularyAssetCategoryIds) {\n\t\t\t\t\tassetCategoryIdsList.add(assetCategoryId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (updateAssetCategoryIds) {\n\t\t\tlong[] assetCategoryIds = ArrayUtil.toArray(\n\t\t\t\tassetCategoryIdsList.toArray(\n\t\t\t\t\tnew Long[assetCategoryIdsList.size()]));\n\n\t\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\t}\n\n\t\tboolean assetEntryVisible = ParamUtil.getBoolean(\n\t\t\tportletRequest, \"assetEntryVisible\", true);\n\n\t\tserviceContext.setAssetEntryVisible(assetEntryVisible);\n\n\t\tString assetLinkEntryIdsString = request.getParameter(\n\t\t\t\"assetLinksSearchContainerPrimaryKeys\");\n\n\t\tif (assetLinkEntryIdsString != null) {\n\t\t\tlong[] assetLinkEntryIds = StringUtil.split(\n\t\t\t\tassetLinkEntryIdsString, 0L);\n\n\t\t\tserviceContext.setAssetLinkEntryIds(assetLinkEntryIds);\n\t\t}\n\n\t\tString assetTagNamesString = request.getParameter(\"assetTagNames\");\n\n\t\tif (assetTagNamesString != null) {\n\t\t\tString[] assetTagNames = StringUtil.split(assetTagNamesString);\n\n\t\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\t}\n\n\t\t// Workflow\n\n\t\tint workflowAction = ParamUtil.getInteger(\n\t\t\tportletRequest, \"workflowAction\", WorkflowConstants.ACTION_PUBLISH);\n\n\t\tserviceContext.setWorkflowAction(workflowAction);\n\n\t\treturn serviceContext;\n\t}","commit_id":"1ac26a73be9d743405247d5bcdfc5304d9b5a1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ServiceContext getInstance(\n\t\t\tString className, PortletRequest portletRequest)\n\t\tthrows PortalException {\n\n\t\tServiceContext serviceContext = getInstance(portletRequest);\n\n\t\t// Permissions\n\n\t\tString[] groupPermissions = PortalUtil.getGroupPermissions(\n\t\t\tportletRequest, className);\n\t\tString[] guestPermissions = PortalUtil.getGuestPermissions(\n\t\t\tportletRequest, className);\n\n\t\tif (groupPermissions != null) {\n\t\t\tserviceContext.setGroupPermissions(groupPermissions);\n\t\t}\n\n\t\tif (guestPermissions != null) {\n\t\t\tserviceContext.setGuestPermissions(guestPermissions);\n\t\t}\n\n\t\t// Expando\n\n\t\tMap<String, Serializable> expandoBridgeAttributes =\n\t\t\tPortalUtil.getExpandoBridgeAttributes(\n\t\t\t\tExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tserviceContext.getCompanyId(), className),\n\t\t\t\tportletRequest);\n\n\t\tserviceContext.setExpandoBridgeAttributes(expandoBridgeAttributes);\n\n\t\treturn serviceContext;\n\t}","id":73205,"modified_method":"public static ServiceContext getInstance(\n\t\t\tString className, PortletRequest portletRequest)\n\t\tthrows PortalException {\n\n\t\tServiceContext serviceContext = getInstance(portletRequest);\n\n\t\t// Permissions\n\n\t\tString[] groupPermissions = PortalUtil.getGroupPermissions(\n\t\t\tportletRequest, className);\n\t\tString[] guestPermissions = PortalUtil.getGuestPermissions(\n\t\t\tportletRequest, className);\n\n\t\tif ((groupPermissions != null) || (guestPermissions != null)) {\n\t\t\tserviceContext.setGroupPermissions(groupPermissions);\n\t\t\tserviceContext.setGuestPermissions(guestPermissions);\n\n\t\t\tModelPermissions modelPermissions =\n\t\t\t\tModelPermissionsFactory.create(\n\t\t\t\t\tserviceContext.getCompanyId(),\n\t\t\t\t\tserviceContext.getScopeGroupId(),\n\t\t\t\t\tgroupPermissions, guestPermissions);\n\n\t\t\tserviceContext.setModelPermissions(modelPermissions);\n\t\t}\n\n\t\t// Expando\n\n\t\tMap<String, Serializable> expandoBridgeAttributes =\n\t\t\tPortalUtil.getExpandoBridgeAttributes(\n\t\t\t\tExpandoBridgeFactoryUtil.getExpandoBridge(\n\t\t\t\t\tserviceContext.getCompanyId(), className),\n\t\t\t\tportletRequest);\n\n\t\tserviceContext.setExpandoBridgeAttributes(expandoBridgeAttributes);\n\n\t\treturn serviceContext;\n\t}","commit_id":"1ac26a73be9d743405247d5bcdfc5304d9b5a1f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Before\n    public void setUp() throws Exception {\n        mockStatic(RoleLocalServiceUtil.class);\n\n        Role siteMemberRole = Mockito.mock(Role.class);\n\n        Mockito.when(\n            siteMemberRole.getName()\n        ).thenReturn(\n            RoleConstants.SITE_MEMBER\n        );\n\n        when(\n            RoleLocalServiceUtil.getDefaultGroupRole(Mockito.anyLong())\n        ).thenReturn(\n            siteMemberRole\n        );\n\n        Role guestRole = Mockito.mock(Role.class);\n\n        Mockito.when(\n            guestRole.getName()\n        ).thenReturn(\n            RoleConstants.GUEST\n        );\n\n        when(\n            RoleLocalServiceUtil.getRole(\n                Mockito.anyLong(), Mockito.eq(RoleConstants.GUEST))\n        ).thenReturn(\n            guestRole\n        );\n    }","id":73206,"modified_method":"@Before\n    public void setUp() throws Exception {\n        mockStatic(RoleLocalServiceUtil.class);\n\n        Role siteMemberRole = Mockito.mock(Role.class);\n\n        Mockito.when(\n            siteMemberRole.getName()\n        ).thenReturn(\n            RoleConstants.SITE_MEMBER\n        );\n\n        when(\n            RoleLocalServiceUtil.getDefaultGroupRole(Mockito.anyLong())\n        ).thenReturn(\n            siteMemberRole\n        );\n\n        when(\n            RoleLocalServiceUtil.getRole(\n                Mockito.anyLong(), Mockito.eq(RoleConstants.SITE_MEMBER))\n        ).thenReturn(\n            siteMemberRole\n        );\n\n        Role guestRole = Mockito.mock(Role.class);\n\n        Mockito.when(\n            guestRole.getName()\n        ).thenReturn(\n            RoleConstants.GUEST\n        );\n\n        when(\n            RoleLocalServiceUtil.getRole(\n                Mockito.anyLong(), Mockito.eq(RoleConstants.GUEST))\n        ).thenReturn(\n            guestRole\n        );\n    }","commit_id":"95426dc7f8d3ae014561a320143e17e54bb65d7e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ServiceContext getInstance(HttpServletRequest request)\n\t\tthrows PortalException {\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t// Theme display\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tif (themeDisplay != null) {\n\t\t\tserviceContext.setCompanyId(themeDisplay.getCompanyId());\n\t\t\tserviceContext.setLanguageId(themeDisplay.getLanguageId());\n\t\t\tserviceContext.setLayoutFullURL(\n\t\t\t\tPortalUtil.getCanonicalURL(\n\t\t\t\t\tPortalUtil.getLayoutFullURL(themeDisplay), themeDisplay,\n\t\t\t\t\tthemeDisplay.getLayout(), true));\n\t\t\tserviceContext.setLayoutURL(\n\t\t\t\tPortalUtil.getCanonicalURL(\n\t\t\t\t\tPortalUtil.getLayoutURL(themeDisplay), themeDisplay,\n\t\t\t\t\tthemeDisplay.getLayout(), true));\n\t\t\tserviceContext.setPlid(themeDisplay.getPlid());\n\t\t\tserviceContext.setScopeGroupId(themeDisplay.getScopeGroupId());\n\t\t\tserviceContext.setSignedIn(themeDisplay.isSignedIn());\n\t\t\tserviceContext.setTimeZone(themeDisplay.getTimeZone());\n\n\t\t\tUser user = themeDisplay.getUser();\n\n\t\t\tserviceContext.setUserDisplayURL(user.getDisplayURL(themeDisplay));\n\t\t\tserviceContext.setUserId(user.getUserId());\n\t\t}\n\t\telse {\n\t\t\tlong companyId = PortalUtil.getCompanyId(request);\n\n\t\t\tserviceContext.setCompanyId(companyId);\n\n\t\t\tGroup guestGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\tserviceContext.getCompanyId(), GroupConstants.GUEST);\n\n\t\t\tserviceContext.setScopeGroupId(guestGroup.getGroupId());\n\n\t\t\tlong plid = LayoutLocalServiceUtil.getDefaultPlid(\n\t\t\t\tserviceContext.getScopeGroupId(), false);\n\n\t\t\tserviceContext.setPlid(plid);\n\n\t\t\tUser user = null;\n\n\t\t\ttry {\n\t\t\t\tuser = PortalUtil.getUser(request);\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue) {\n\n\t\t\t\t// LPS-24160\n\n\t\t\t}\n\n\t\t\tif (user != null) {\n\t\t\t\tserviceContext.setSignedIn(!user.isDefaultUser());\n\t\t\t\tserviceContext.setUserId(user.getUserId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tserviceContext.setSignedIn(false);\n\t\t\t}\n\t\t}\n\n\t\tserviceContext.setPortalURL(PortalUtil.getPortalURL(request));\n\t\tserviceContext.setPathMain(PortalUtil.getPathMain());\n\t\tserviceContext.setPathFriendlyURLPrivateGroup(\n\t\t\tPortalUtil.getPathFriendlyURLPrivateGroup());\n\t\tserviceContext.setPathFriendlyURLPrivateUser(\n\t\t\tPortalUtil.getPathFriendlyURLPrivateUser());\n\t\tserviceContext.setPathFriendlyURLPublic(\n\t\t\tPortalUtil.getPathFriendlyURLPublic());\n\n\t\t// Attributes\n\n\t\tMap<String, Serializable> attributes = new HashMap<>();\n\n\t\tMap<String, String[]> parameters = request.getParameterMap();\n\n\t\tfor (Map.Entry<String, String[]> entry : parameters.entrySet()) {\n\t\t\tString name = entry.getKey();\n\t\t\tString[] values = entry.getValue();\n\n\t\t\tif (ArrayUtil.isNotEmpty(values)) {\n\t\t\t\tif (values.length == 1) {\n\t\t\t\t\tattributes.put(name, values[0]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tattributes.put(name, values);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tserviceContext.setAttributes(attributes);\n\n\t\t// Command\n\n\t\tString cmd = ParamUtil.getString(request, Constants.CMD);\n\n\t\tserviceContext.setCommand(cmd);\n\n\t\t// Current URL\n\n\t\tString currentURL = PortalUtil.getCurrentURL(request);\n\n\t\tserviceContext.setCurrentURL(currentURL);\n\n\t\t// Form date\n\n\t\tlong formDateLong = ParamUtil.getLong(request, \"formDate\");\n\n\t\tif (formDateLong > 0) {\n\t\t\tDate formDate = new Date(formDateLong);\n\n\t\t\tserviceContext.setFormDate(formDate);\n\t\t}\n\n\t\t// Permissions\n\n\t\tboolean addGroupPermissions = ParamUtil.getBoolean(\n\t\t\trequest, \"addGroupPermissions\");\n\t\tboolean addGuestPermissions = ParamUtil.getBoolean(\n\t\t\trequest, \"addGuestPermissions\");\n\t\tString[] groupPermissions = PortalUtil.getGroupPermissions(request);\n\t\tString[] guestPermissions = PortalUtil.getGuestPermissions(request);\n\n\t\tserviceContext.setAddGroupPermissions(addGroupPermissions);\n\t\tserviceContext.setAddGuestPermissions(addGuestPermissions);\n\t\tserviceContext.setGroupPermissions(groupPermissions);\n\t\tserviceContext.setGuestPermissions(guestPermissions);\n\n\t\t// Portlet preferences ids\n\n\t\tString portletId = PortalUtil.getPortletId(request);\n\n\t\tif (Validator.isNotNull(portletId)) {\n\t\t\tPortletPreferencesIds portletPreferencesIds =\n\t\t\t\tPortletPreferencesFactoryUtil.getPortletPreferencesIds(\n\t\t\t\t\trequest, portletId);\n\n\t\t\tserviceContext.setPortletPreferencesIds(portletPreferencesIds);\n\t\t}\n\n\t\t// Request\n\n\t\tMap<String, String> headerMap = new HashMap<>();\n\n\t\tEnumeration<String> enu = request.getHeaderNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString header = enu.nextElement();\n\n\t\t\tString value = request.getHeader(header);\n\n\t\t\theaderMap.put(header, value);\n\t\t}\n\n\t\tserviceContext.setHeaders(headerMap);\n\n\t\tserviceContext.setRemoteAddr(request.getRemoteAddr());\n\t\tserviceContext.setRemoteHost(request.getRemoteHost());\n\t\tserviceContext.setRequest(request);\n\n\t\t// Asset\n\n\t\tMap<String, String[]> parameterMap = request.getParameterMap();\n\n\t\tList<Long> assetCategoryIdsList = new ArrayList<>();\n\n\t\tboolean updateAssetCategoryIds = false;\n\n\t\tfor (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {\n\t\t\tString name = entry.getKey();\n\n\t\t\tif (name.startsWith(\"assetCategoryIds\")) {\n\t\t\t\tupdateAssetCategoryIds = true;\n\n\t\t\t\tlong[] assetVocabularyAssetCategoryIds = StringUtil.split(\n\t\t\t\t\tParamUtil.getString(request, name), 0L);\n\n\t\t\t\tfor (long assetCategoryId : assetVocabularyAssetCategoryIds) {\n\t\t\t\t\tassetCategoryIdsList.add(assetCategoryId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (updateAssetCategoryIds) {\n\t\t\tlong[] assetCategoryIds = ArrayUtil.toArray(\n\t\t\t\tassetCategoryIdsList.toArray(\n\t\t\t\t\tnew Long[assetCategoryIdsList.size()]));\n\n\t\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\t}\n\n\t\tboolean assetEntryVisible = ParamUtil.getBoolean(\n\t\t\trequest, \"assetEntryVisible\", true);\n\n\t\tserviceContext.setAssetEntryVisible(assetEntryVisible);\n\n\t\tString assetLinkEntryIdsString = request.getParameter(\n\t\t\t\"assetLinksSearchContainerPrimaryKeys\");\n\n\t\tif (assetLinkEntryIdsString != null) {\n\t\t\tlong[] assetLinkEntryIds = StringUtil.split(\n\t\t\t\tassetLinkEntryIdsString, 0L);\n\n\t\t\tserviceContext.setAssetLinkEntryIds(assetLinkEntryIds);\n\t\t}\n\n\t\tString assetTagNamesString = request.getParameter(\"assetTagNames\");\n\n\t\tif (assetTagNamesString != null) {\n\t\t\tString[] assetTagNames = StringUtil.split(assetTagNamesString);\n\n\t\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\t}\n\n\t\t// Workflow\n\n\t\tint workflowAction = ParamUtil.getInteger(\n\t\t\trequest, \"workflowAction\", WorkflowConstants.ACTION_PUBLISH);\n\n\t\tserviceContext.setWorkflowAction(workflowAction);\n\n\t\treturn serviceContext;\n\t}","id":73207,"modified_method":"public static ServiceContext getInstance(HttpServletRequest request)\n\t\tthrows PortalException {\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t// Theme display\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tif (themeDisplay != null) {\n\t\t\tserviceContext.setCompanyId(themeDisplay.getCompanyId());\n\t\t\tserviceContext.setLanguageId(themeDisplay.getLanguageId());\n\t\t\tserviceContext.setLayoutFullURL(\n\t\t\t\tPortalUtil.getCanonicalURL(\n\t\t\t\t\tPortalUtil.getLayoutFullURL(themeDisplay), themeDisplay,\n\t\t\t\t\tthemeDisplay.getLayout(), true));\n\t\t\tserviceContext.setLayoutURL(\n\t\t\t\tPortalUtil.getCanonicalURL(\n\t\t\t\t\tPortalUtil.getLayoutURL(themeDisplay), themeDisplay,\n\t\t\t\t\tthemeDisplay.getLayout(), true));\n\t\t\tserviceContext.setPlid(themeDisplay.getPlid());\n\t\t\tserviceContext.setScopeGroupId(themeDisplay.getScopeGroupId());\n\t\t\tserviceContext.setSignedIn(themeDisplay.isSignedIn());\n\t\t\tserviceContext.setTimeZone(themeDisplay.getTimeZone());\n\n\t\t\tUser user = themeDisplay.getUser();\n\n\t\t\tserviceContext.setUserDisplayURL(user.getDisplayURL(themeDisplay));\n\t\t\tserviceContext.setUserId(user.getUserId());\n\t\t}\n\t\telse {\n\t\t\tlong companyId = PortalUtil.getCompanyId(request);\n\n\t\t\tserviceContext.setCompanyId(companyId);\n\n\t\t\tGroup guestGroup = GroupLocalServiceUtil.getGroup(\n\t\t\t\tserviceContext.getCompanyId(), GroupConstants.GUEST);\n\n\t\t\tserviceContext.setScopeGroupId(guestGroup.getGroupId());\n\n\t\t\tlong plid = LayoutLocalServiceUtil.getDefaultPlid(\n\t\t\t\tserviceContext.getScopeGroupId(), false);\n\n\t\t\tserviceContext.setPlid(plid);\n\n\t\t\tUser user = null;\n\n\t\t\ttry {\n\t\t\t\tuser = PortalUtil.getUser(request);\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue) {\n\n\t\t\t\t// LPS-24160\n\n\t\t\t}\n\n\t\t\tif (user != null) {\n\t\t\t\tserviceContext.setSignedIn(!user.isDefaultUser());\n\t\t\t\tserviceContext.setUserId(user.getUserId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tserviceContext.setSignedIn(false);\n\t\t\t}\n\t\t}\n\n\t\tserviceContext.setPortalURL(PortalUtil.getPortalURL(request));\n\t\tserviceContext.setPathMain(PortalUtil.getPathMain());\n\t\tserviceContext.setPathFriendlyURLPrivateGroup(\n\t\t\tPortalUtil.getPathFriendlyURLPrivateGroup());\n\t\tserviceContext.setPathFriendlyURLPrivateUser(\n\t\t\tPortalUtil.getPathFriendlyURLPrivateUser());\n\t\tserviceContext.setPathFriendlyURLPublic(\n\t\t\tPortalUtil.getPathFriendlyURLPublic());\n\n\t\t// Attributes\n\n\t\tMap<String, Serializable> attributes = new HashMap<>();\n\n\t\tMap<String, String[]> parameters = request.getParameterMap();\n\n\t\tfor (Map.Entry<String, String[]> entry : parameters.entrySet()) {\n\t\t\tString name = entry.getKey();\n\t\t\tString[] values = entry.getValue();\n\n\t\t\tif (ArrayUtil.isNotEmpty(values)) {\n\t\t\t\tif (values.length == 1) {\n\t\t\t\t\tattributes.put(name, values[0]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tattributes.put(name, values);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tserviceContext.setAttributes(attributes);\n\n\t\t// Command\n\n\t\tString cmd = ParamUtil.getString(request, Constants.CMD);\n\n\t\tserviceContext.setCommand(cmd);\n\n\t\t// Current URL\n\n\t\tString currentURL = PortalUtil.getCurrentURL(request);\n\n\t\tserviceContext.setCurrentURL(currentURL);\n\n\t\t// Form date\n\n\t\tlong formDateLong = ParamUtil.getLong(request, \"formDate\");\n\n\t\tif (formDateLong > 0) {\n\t\t\tDate formDate = new Date(formDateLong);\n\n\t\t\tserviceContext.setFormDate(formDate);\n\t\t}\n\n\t\t// Permissions\n\n\t\tModelPermissions modelPermissions = ModelPermissionsFactory.create(\n\t\t\trequest);\n\n\t\tif (!modelPermissions.isEmpty()) {\n\t\t\tserviceContext.setModelPermissions(modelPermissions);\n\t\t}\n\t\telse {\n\t\t\tboolean addGroupPermissions = ParamUtil.getBoolean(\n\t\t\t\trequest, \"addGroupPermissions\");\n\t\t\tboolean addGuestPermissions = ParamUtil.getBoolean(\n\t\t\t\trequest, \"addGuestPermissions\");\n\t\t\tString[] groupPermissions = PortalUtil.getGroupPermissions(request);\n\t\t\tString[] guestPermissions = PortalUtil.getGuestPermissions(request);\n\n\t\t\tserviceContext.setAddGroupPermissions(addGroupPermissions);\n\t\t\tserviceContext.setAddGuestPermissions(addGuestPermissions);\n\t\t\tserviceContext.setGroupPermissions(groupPermissions);\n\t\t\tserviceContext.setGuestPermissions(guestPermissions);\n\t\t}\n\n\t\t// Portlet preferences ids\n\n\t\tString portletId = PortalUtil.getPortletId(request);\n\n\t\tif (Validator.isNotNull(portletId)) {\n\t\t\tPortletPreferencesIds portletPreferencesIds =\n\t\t\t\tPortletPreferencesFactoryUtil.getPortletPreferencesIds(\n\t\t\t\t\trequest, portletId);\n\n\t\t\tserviceContext.setPortletPreferencesIds(portletPreferencesIds);\n\t\t}\n\n\t\t// Request\n\n\t\tMap<String, String> headerMap = new HashMap<>();\n\n\t\tEnumeration<String> enu = request.getHeaderNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString header = enu.nextElement();\n\n\t\t\tString value = request.getHeader(header);\n\n\t\t\theaderMap.put(header, value);\n\t\t}\n\n\t\tserviceContext.setHeaders(headerMap);\n\n\t\tserviceContext.setRemoteAddr(request.getRemoteAddr());\n\t\tserviceContext.setRemoteHost(request.getRemoteHost());\n\t\tserviceContext.setRequest(request);\n\n\t\t// Asset\n\n\t\tMap<String, String[]> parameterMap = request.getParameterMap();\n\n\t\tList<Long> assetCategoryIdsList = new ArrayList<>();\n\n\t\tboolean updateAssetCategoryIds = false;\n\n\t\tfor (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {\n\t\t\tString name = entry.getKey();\n\n\t\t\tif (name.startsWith(\"assetCategoryIds\")) {\n\t\t\t\tupdateAssetCategoryIds = true;\n\n\t\t\t\tlong[] assetVocabularyAssetCategoryIds = StringUtil.split(\n\t\t\t\t\tParamUtil.getString(request, name), 0L);\n\n\t\t\t\tfor (long assetCategoryId : assetVocabularyAssetCategoryIds) {\n\t\t\t\t\tassetCategoryIdsList.add(assetCategoryId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (updateAssetCategoryIds) {\n\t\t\tlong[] assetCategoryIds = ArrayUtil.toArray(\n\t\t\t\tassetCategoryIdsList.toArray(\n\t\t\t\t\tnew Long[assetCategoryIdsList.size()]));\n\n\t\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\t}\n\n\t\tboolean assetEntryVisible = ParamUtil.getBoolean(\n\t\t\trequest, \"assetEntryVisible\", true);\n\n\t\tserviceContext.setAssetEntryVisible(assetEntryVisible);\n\n\t\tString assetLinkEntryIdsString = request.getParameter(\n\t\t\t\"assetLinksSearchContainerPrimaryKeys\");\n\n\t\tif (assetLinkEntryIdsString != null) {\n\t\t\tlong[] assetLinkEntryIds = StringUtil.split(\n\t\t\t\tassetLinkEntryIdsString, 0L);\n\n\t\t\tserviceContext.setAssetLinkEntryIds(assetLinkEntryIds);\n\t\t}\n\n\t\tString assetTagNamesString = request.getParameter(\"assetTagNames\");\n\n\t\tif (assetTagNamesString != null) {\n\t\t\tString[] assetTagNames = StringUtil.split(assetTagNamesString);\n\n\t\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\t}\n\n\t\t// Workflow\n\n\t\tint workflowAction = ParamUtil.getInteger(\n\t\t\trequest, \"workflowAction\", WorkflowConstants.ACTION_PUBLISH);\n\n\t\tserviceContext.setWorkflowAction(workflowAction);\n\n\t\treturn serviceContext;\n\t}","commit_id":"95426dc7f8d3ae014561a320143e17e54bb65d7e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic MBMessage addDiscussionMessage(\n\t\t\tlong userId, String userName, long groupId, String className,\n\t\t\tlong classPK, long threadId, long parentMessageId, String subject,\n\t\t\tString body, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Message\n\n\t\tvalidateDiscussionMaxComments(className, classPK);\n\n\t\tlong categoryId = MBCategoryConstants.DISCUSSION_CATEGORY_ID;\n\n\t\tif (Validator.isNull(subject)) {\n\t\t\tif (Validator.isNotNull(body)) {\n\t\t\t\tint pos = Math.min(body.length(), 50);\n\n\t\t\t\tsubject = body.substring(0, pos) + \"...\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new MessageBodyException();\n\t\t\t}\n\t\t}\n\n\t\tList<ObjectValuePair<String, InputStream>> inputStreamOVPs =\n\t\t\tCollections.emptyList();\n\t\tboolean anonymous = false;\n\t\tDate now = new Date();\n\t\tdouble priority = 0.0;\n\t\tboolean allowPingbacks = false;\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAttribute(\"className\", className);\n\t\tserviceContext.setAttribute(\"classPK\", String.valueOf(classPK));\n\t\tserviceContext.setCreateDate(now);\n\t\tserviceContext.setModifiedDate(now);\n\n\t\tMBMessage message = addMessage(\n\t\t\tuserId, userName, groupId, categoryId, threadId, parentMessageId,\n\t\t\tsubject, body, PropsValues.DISCUSSION_COMMENTS_FORMAT,\n\t\t\tinputStreamOVPs, anonymous, priority, allowPingbacks,\n\t\t\tserviceContext);\n\n\t\t// Discussion\n\n\t\tif (parentMessageId == MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\t\t\tlong classNameId = classNameLocalService.getClassNameId(className);\n\n\t\t\tMBDiscussion discussion = mbDiscussionPersistence.fetchByC_C(\n\t\t\t\tclassNameId, classPK);\n\n\t\t\tif (discussion == null) {\n\t\t\t\tmbDiscussionLocalService.addDiscussion(\n\t\t\t\t\tuserId, groupId, classNameId, classPK,\n\t\t\t\t\tmessage.getThreadId(), serviceContext);\n\t\t\t}\n\t\t}\n\n\t\treturn message;\n\t}","id":73208,"modified_method":"@Override\n\tpublic MBMessage addDiscussionMessage(\n\t\t\tlong userId, String userName, long groupId, String className,\n\t\t\tlong classPK, long threadId, long parentMessageId, String subject,\n\t\t\tString body, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Message\n\n\t\tvalidateDiscussionMaxComments(className, classPK);\n\n\t\tlong categoryId = MBCategoryConstants.DISCUSSION_CATEGORY_ID;\n\n\t\tif (Validator.isNull(subject)) {\n\t\t\tif (Validator.isNotNull(body)) {\n\t\t\t\tint pos = Math.min(body.length(), 50);\n\n\t\t\t\tsubject = body.substring(0, pos) + \"...\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new MessageBodyException();\n\t\t\t}\n\t\t}\n\n\t\tserviceContext.setAddGroupPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAttribute(\"className\", className);\n\t\tserviceContext.setAttribute(\"classPK\", String.valueOf(classPK));\n\n\t\tDate now = new Date();\n\n\t\tif (serviceContext.getCreateDate() == null) {\n\t\t\tserviceContext.setCreateDate(now);\n\t\t}\n\n\t\tif (serviceContext.getModifiedDate() == null) {\n\t\t\tserviceContext.setModifiedDate(now);\n\t\t}\n\n\t\tList<ObjectValuePair<String, InputStream>> inputStreamOVPs =\n\t\t\tCollections.emptyList();\n\t\tboolean anonymous = false;\n\t\tdouble priority = 0.0;\n\t\tboolean allowPingbacks = false;\n\n\t\tMBMessage message = addMessage(\n\t\t\tuserId, userName, groupId, categoryId, threadId, parentMessageId,\n\t\t\tsubject, body, PropsValues.DISCUSSION_COMMENTS_FORMAT,\n\t\t\tinputStreamOVPs, anonymous, priority, allowPingbacks,\n\t\t\tserviceContext);\n\n\t\t// Discussion\n\n\t\tif (parentMessageId == MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\t\t\tlong classNameId = classNameLocalService.getClassNameId(className);\n\n\t\t\tMBDiscussion discussion = mbDiscussionPersistence.fetchByC_C(\n\t\t\t\tclassNameId, classPK);\n\n\t\t\tif (discussion == null) {\n\t\t\t\tmbDiscussionLocalService.addDiscussion(\n\t\t\t\t\tuserId, groupId, classNameId, classPK,\n\t\t\t\t\tmessage.getThreadId(), serviceContext);\n\t\t\t}\n\t\t}\n\n\t\treturn message;\n\t}","commit_id":"e2f4c8698e552be34e32b993ed5081bc96edf9f4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void encodeCall(StringBuilder sb, int id, @Nullable String domain, @Nullable String command, @Nullable Object[] params, @Nullable CharSequence rawData)\n    throws IOException {\n    sb.append('[');\n    boolean hasPrev = false;\n    if (id != -1) {\n      sb.append(id);\n      hasPrev = true;\n    }\n\n    if (domain != null) {\n      if (hasPrev) {\n        sb.append(',');\n      }\n      sb.append('\"').append(domain).append(\"\\\",\\\"\");\n\n      if (command == null) {\n        if (rawData != null) {\n          sb.append(rawData);\n        }\n        sb.append('\"');\n        return;\n      }\n      else {\n        sb.append(command).append('\"');\n      }\n    }\n\n    encodeParameters(sb, params == null ? ArrayUtil.EMPTY_OBJECT_ARRAY : params, rawData);\n    sb.append(']');\n  }","id":73209,"modified_method":"private void doEncodeMessage(@NotNull StringBuilder sb, int id, @Nullable String domain, @Nullable String command, @NotNull Object[] params, @Nullable CharSequence rawData) throws IOException {\n    sb.append('[');\n    boolean hasPrev = false;\n    if (id != -1) {\n      sb.append(id);\n      hasPrev = true;\n    }\n\n    if (domain != null) {\n      if (hasPrev) {\n        sb.append(',');\n      }\n      sb.append('\"').append(domain).append(\"\\\",\\\"\");\n\n      if (command == null) {\n        if (rawData != null) {\n          sb.append(rawData);\n        }\n        sb.append('\"');\n        return;\n      }\n      else {\n        sb.append(command).append('\"');\n      }\n    }\n\n    encodeParameters(sb, params, rawData);\n    sb.append(']');\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean sendWithRawPart(Client client, String domain, String command, @Nullable CharSequence rawMessage, Object... params) {\n    ByteBuf message = encodeMessage(-1, domain, command, rawMessage, params);\n    if (message != null) {\n      webSocketServer.send(client, -1, message);\n    }\n    return message != null;\n  }","id":73210,"modified_method":"public boolean sendWithRawPart(@NotNull Client client, @NotNull String domain, @NotNull String command, @Nullable CharSequence rawMessage, Object... params) {\n    client.send(encodeMessage(-1, domain, command, rawMessage, params));\n    return true;\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void encodeParameters(StringBuilder sb, Object[] params, @Nullable CharSequence rawData) throws IOException {\n    if (params.length == 0 && rawData == null) {\n      return;\n    }\n\n    JsonWriter writer = null;\n    sb.append(',').append('[');\n    boolean hasPrev = false;\n    for (Object param : params) {\n      if (hasPrev) {\n        sb.append(',');\n      }\n      else {\n        hasPrev = true;\n      }\n\n      // gson - SOE if param has type class com.intellij.openapi.editor.impl.DocumentImpl$MyCharArray, so, use hack\n      if (param instanceof CharSequence) {\n        JsonUtil.escape(((CharSequence)param), sb);\n      }\n      else if (param == null) {\n        sb.append(\"null\");\n      }\n      else if (param instanceof Number || param instanceof Boolean) {\n        sb.append(param.toString());\n      }\n      else if (param instanceof Consumer) {\n        //noinspection unchecked\n        ((Consumer<StringBuilder>)param).consume(sb);\n      }\n      else {\n        if (writer == null) {\n          writer = new JsonWriter(Streams.writerForAppendable(sb));\n        }\n        //noinspection unchecked\n        ((TypeAdapter<Object>)gson.getAdapter(param.getClass())).write(writer, param);\n      }\n    }\n\n    if (rawData != null) {\n      if (hasPrev) {\n        sb.append(',');\n      }\n      sb.append(rawData);\n    }\n    sb.append(']');\n  }","id":73211,"modified_method":"private void encodeParameters(@NotNull StringBuilder sb, @NotNull Object[] params, @Nullable CharSequence rawData) throws IOException {\n    JsonWriter writer = null;\n    sb.append(',').append('[');\n    boolean hasPrev = false;\n    for (Object param : params) {\n      if (hasPrev) {\n        sb.append(',');\n      }\n      else {\n        hasPrev = true;\n      }\n\n      // gson - SOE if param has type class com.intellij.openapi.editor.impl.DocumentImpl$MyCharArray, so, use hack\n      if (param instanceof CharSequence) {\n        JsonUtil.escape(((CharSequence)param), sb);\n      }\n      else if (param == null) {\n        sb.append(\"null\");\n      }\n      else if (param instanceof Number || param instanceof Boolean) {\n        sb.append(param.toString());\n      }\n      else if (param instanceof Consumer) {\n        //noinspection unchecked\n        ((Consumer<StringBuilder>)param).consume(sb);\n      }\n      else {\n        if (writer == null) {\n          writer = new JsonWriter(Streams.writerForAppendable(sb));\n        }\n        //noinspection unchecked\n        ((TypeAdapter<Object>)gson.getAdapter(param.getClass())).write(writer, param);\n      }\n    }\n\n    if (rawData != null) {\n      if (hasPrev) {\n        sb.append(',');\n      }\n      sb.append(rawData);\n    }\n    sb.append(']');\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public <T> void send(String domain, String command, @Nullable final List<AsyncResult<Pair<Client, T>>> results, Object... params) {\n    if (webSocketServer.hasClients()) {\n      send(results == null ? -1 : messageIdCounter.getAndIncrement(), domain, command, results, params);\n    }\n  }","id":73212,"modified_method":"public <T> void sendToClients(@NotNull String domain, @NotNull String command, @Nullable List<AsyncPromise<Pair<Client, T>>> results, Object... params) {\n    if (clientManager.hasClients()) {\n      sendToClients(results == null ? -1 : messageIdCounter.getAndIncrement(), domain, command, results, params);\n    }\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private ByteBuf encodeMessage(int messageId,\n                                @Nullable String domain,\n                                @Nullable String command,\n                                @Nullable CharSequence rawMessage,\n                                @Nullable Object[] params) {\n    StringBuilder sb = new StringBuilder();\n    try {\n      encodeCall(sb, messageId, domain, command, params, rawMessage);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"OUT \" + sb.toString());\n      }\n      return Unpooled.copiedBuffer(sb, CharsetUtil.UTF_8);\n    }\n    catch (IOException e) {\n      exceptionHandler.exceptionCaught(e);\n      return null;\n    }\n  }","id":73213,"modified_method":"@NotNull\n  private ByteBuf encodeMessage(int messageId,\n                                @Nullable String domain,\n                                @Nullable String command,\n                                @Nullable CharSequence rawData,\n                                @Nullable Object[] params) {\n    StringBuilder sb = new StringBuilder();\n    try {\n      doEncodeMessage(sb, messageId, domain, command, params == null ? ArrayUtil.EMPTY_OBJECT_ARRAY : params, rawData);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"OUT \" + sb.toString());\n      }\n      return Unpooled.copiedBuffer(sb, CharsetUtil.UTF_8);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void send(String domain, String name) {\n    send(domain, name, null);\n  }","id":73214,"modified_method":"public void sendToClients(@NotNull String domain, @NotNull String name) {\n    sendToClients(domain, name, null);\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public <T> AsyncResult<T> call(Client client, String domain, String command, Object... params) {\n    int messageId = messageIdCounter.getAndIncrement();\n    ByteBuf message = encodeMessage(messageId, domain, command, params);\n    if (message == null) {\n      return new AsyncResult.Rejected<T>();\n    }\n\n    AsyncResult<T> result = webSocketServer.send(client, messageId, message);\n    return result == null ? new AsyncResult.Rejected<T>() : result;\n  }","id":73215,"modified_method":"@NotNull\n  public <T> Promise<T> call(@NotNull Client client, @NotNull String domain, @NotNull String command, Object... params) {\n    int messageId = messageIdCounter.getAndIncrement();\n    ByteBuf message = encodeMessage(messageId, domain, command, null, params);\n    AsyncPromise<T> result = client.send(messageId, message);\n    LOG.assertTrue(result != null);\n    return result;\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void message(@NotNull Client client, String message) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"IN \" + message);\n    }\n\n    JsonReaderEx reader = new JsonReaderEx(message);\n    reader.beginArray();\n    int messageId = reader.peek() == JsonToken.NUMBER ? reader.nextInt() : -1;\n    String domainName = reader.nextString();\n    if (domainName.length() == 1) {\n      AsyncResult asyncResult = webSocketServer.removeAsyncResult(client, messageId);\n      if (domainName.charAt(0) == 'r') {\n        if (asyncResult == null) {\n          LOG.error(\"Response with id \" + messageId + \" was already processed\");\n          return;\n        }\n        //noinspection unchecked\n        asyncResult.setDone(JsonUtil.nextAny(reader));\n      }\n      else {\n        asyncResult.setRejected();\n      }\n      return;\n    }\n\n    NotNullLazyValue domainHolder = domains.get(domainName);\n    if (domainHolder == null) {\n      LOG.error(\"Cannot find domain \" + domainName);\n      return;\n    }\n\n    Object domain = domainHolder.getValue();\n    String command = reader.nextString();\n    if (domain instanceof JsonServiceInvocator) {\n      ((JsonServiceInvocator)domain).invoke(command, client, reader, message, messageId);\n      return;\n    }\n\n    Object[] parameters;\n    if (reader.hasNext()) {\n      List<Object> list = new SmartList<Object>();\n      JsonUtil.readListBody(reader, list);\n      parameters = ArrayUtil.toObjectArray(list);\n    }\n    else {\n      parameters = ArrayUtilRt.EMPTY_OBJECT_ARRAY;\n    }\n\n    reader.endArray();\n    LOG.assertTrue(reader.peek() == JsonToken.END_DOCUMENT);\n\n    try {\n      boolean isStatic = domain instanceof Class;\n      Method[] methods;\n      if (isStatic) {\n        methods = ((Class)domain).getDeclaredMethods();\n      }\n      else {\n        methods = domain.getClass().getMethods();\n      }\n      for (Method method : methods) {\n        if (method.getName().equals(command)) {\n          method.setAccessible(true);\n          Object result = method.invoke(isStatic ? null : domain, parameters);\n          if (messageId != -1) {\n            ByteBuf response = encodeMessage(messageId, null, null, new Object[]{result});\n            if (response != null) {\n              webSocketServer.sendResponse(client, response);\n            }\n          }\n          return;\n        }\n      }\n\n      throw new NoSuchMethodException(command);\n    }\n    catch (Throwable e) {\n      throw new IOException(e);\n    }\n  }","id":73216,"modified_method":"@Override\n  public void message(@NotNull Client client, @NotNull String message) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"IN \" + message);\n    }\n\n    JsonReaderEx reader = new JsonReaderEx(message);\n    reader.beginArray();\n    int messageId = reader.peek() == JsonToken.NUMBER ? reader.nextInt() : -1;\n    String domainName = reader.nextString();\n    if (domainName.length() == 1) {\n      AsyncPromise<Object> promise = client.messageCallbackMap.remove(messageId);\n      if (domainName.charAt(0) == 'r') {\n        if (promise == null) {\n          LOG.error(\"Response with id \" + messageId + \" was already processed\");\n          return;\n        }\n        promise.setResult(JsonUtil.nextAny(reader));\n      }\n      else {\n        promise.setError(Promise.createError(\"error\"));\n      }\n      return;\n    }\n\n    NotNullLazyValue domainHolder = domains.get(domainName);\n    if (domainHolder == null) {\n      LOG.error(\"Cannot find domain \" + domainName);\n      return;\n    }\n\n    Object domain = domainHolder.getValue();\n    String command = reader.nextString();\n    if (domain instanceof JsonServiceInvocator) {\n      ((JsonServiceInvocator)domain).invoke(command, client, reader, message, messageId);\n      return;\n    }\n\n    Object[] parameters;\n    if (reader.hasNext()) {\n      List<Object> list = new SmartList<Object>();\n      JsonUtil.readListBody(reader, list);\n      parameters = ArrayUtil.toObjectArray(list);\n    }\n    else {\n      parameters = ArrayUtilRt.EMPTY_OBJECT_ARRAY;\n    }\n\n    reader.endArray();\n    LOG.assertTrue(reader.peek() == JsonToken.END_DOCUMENT);\n\n    try {\n      boolean isStatic = domain instanceof Class;\n      Method[] methods;\n      if (isStatic) {\n        methods = ((Class)domain).getDeclaredMethods();\n      }\n      else {\n        methods = domain.getClass().getMethods();\n      }\n      for (Method method : methods) {\n        if (method.getName().equals(command)) {\n          method.setAccessible(true);\n          Object result = method.invoke(isStatic ? null : domain, parameters);\n          if (messageId != -1) {\n            client.send(encodeMessage(messageId, null, null, null, new Object[]{result}));\n          }\n          return;\n        }\n      }\n\n      throw new NoSuchMethodException(command);\n    }\n    catch (Throwable e) {\n      throw new IOException(e);\n    }\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void sendErrorResponse(int messageId, @NotNull Client client, @Nullable CharSequence rawMessage) {\n    ByteBuf response = encodeMessage(messageId, \"e\", null, rawMessage, ArrayUtil.EMPTY_OBJECT_ARRAY);\n    assert response != null;\n    webSocketServer.sendResponse(client, response);\n  }","id":73217,"modified_method":"public void sendErrorResponse(int messageId, @NotNull Client client, @Nullable CharSequence rawMessage) {\n    client.send(encodeMessage(messageId, \"e\", null, rawMessage, ArrayUtil.EMPTY_OBJECT_ARRAY));\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private <T> void send(int messageId, @Nullable String domain, @Nullable String command, @Nullable final List<AsyncResult<Pair<Client, T>>> results, Object[] params) {\n    ByteBuf message = encodeMessage(messageId, domain, command, params);\n    if (message != null) {\n      doSend(messageId, results, message);\n    }\n  }","id":73218,"modified_method":"private <T> void sendToClients(int messageId, @Nullable String domain, @Nullable String command, @Nullable List<AsyncPromise<Pair<Client, T>>> results, Object[] params) {\n    clientManager.send(messageId, encodeMessage(messageId, domain, command, null, params), results);\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void sendResponse(int messageId, @NotNull Client client, @Nullable CharSequence rawMessage) {\n    ByteBuf response = encodeMessage(messageId, null, null, rawMessage, ArrayUtil.EMPTY_OBJECT_ARRAY);\n    assert response != null;\n    webSocketServer.sendResponse(client, response);\n  }","id":73219,"modified_method":"public void sendResponse(int messageId, @NotNull Client client, @Nullable CharSequence rawMessage) {\n    client.send(encodeMessage(messageId, null, null, rawMessage, ArrayUtil.EMPTY_OBJECT_ARRAY));\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void channelInactive(ChannelHandlerContext context) throws Exception {\n    Client client = context.attr(WebSocketHandshakeHandler.CLIENT).get();\n    // if null, so, has already been explicitly removed\n    if (client != null) {\n      server.disconnectClient(context, client, false);\n    }\n  }","id":73220,"modified_method":"@Override\n  public void channelInactive(ChannelHandlerContext context) throws Exception {\n    Client client = context.attr(ClientManager.CLIENT).get();\n    // if null, so, has already been explicitly removed\n    if (client != null) {\n      clientManager.disconnectClient(context, client, false);\n    }\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void exceptionCaught(ChannelHandlerContext context, Throwable cause) throws Exception {\n    try {\n      server.exceptionHandler.exceptionCaught(cause);\n    }\n    finally {\n      context.channel().close();\n    }\n  }","id":73221,"modified_method":"@Override\n  public void exceptionCaught(ChannelHandlerContext context, Throwable cause) throws Exception {\n    try {\n      clientManager.exceptionHandler.exceptionCaught(cause);\n    }\n    finally {\n      context.channel().close();\n    }\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void messageReceived(ChannelHandlerContext context, WebSocketFrame message) throws Exception {\n    WebSocketClient client = (WebSocketClient)context.attr(WebSocketHandshakeHandler.CLIENT).get();\n    if (message instanceof CloseWebSocketFrame) {\n      if (client != null) {\n        try {\n          server.disconnectClient(context, client, false);\n        }\n        finally {\n          message.retain();\n          client.disconnect((CloseWebSocketFrame)message);\n        }\n      }\n    }\n    else if (message instanceof PingWebSocketFrame) {\n      context.channel().writeAndFlush(new PongWebSocketFrame(message.content()));\n    }\n    else if (message instanceof TextWebSocketFrame) {\n      String text = ChannelBufferToString.readString(message.content());\n      try {\n        messageServer.message(client, text);\n      }\n      catch (Throwable e) {\n        server.exceptionHandler.exceptionCaught(new IOException(\"Exception while handle message: \" + text, e));\n      }\n    }\n    else if (!(message instanceof PongWebSocketFrame)) {\n      throw new UnsupportedOperationException(message.getClass().getName() + \" frame types not supported\");\n    }\n  }","id":73222,"modified_method":"@Override\n  protected void messageReceived(ChannelHandlerContext context, WebSocketFrame message) throws Exception {\n    WebSocketClient client = (WebSocketClient)context.attr(ClientManager.CLIENT).get();\n    if (message instanceof CloseWebSocketFrame) {\n      if (client != null) {\n        try {\n          clientManager.disconnectClient(context, client, false);\n        }\n        finally {\n          message.retain();\n          client.disconnect((CloseWebSocketFrame)message);\n        }\n      }\n    }\n    else if (message instanceof PingWebSocketFrame) {\n      context.channel().writeAndFlush(new PongWebSocketFrame(message.content()));\n    }\n    else if (message instanceof TextWebSocketFrame) {\n      String text = ChannelBufferToString.readString(message.content());\n      try {\n        messageServer.message(client, text);\n      }\n      catch (Throwable e) {\n        clientManager.exceptionHandler.exceptionCaught(new IOException(\"Exception while handle message: \" + text, e));\n      }\n    }\n    else if (!(message instanceof PongWebSocketFrame)) {\n      throw new UnsupportedOperationException(message.getClass().getName() + \" frame types not supported\");\n    }\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"MessageChannelHandler(@NotNull WebSocketServer server, @NotNull MessageServer messageServer) {\n    this.server = server;\n    this.messageServer = messageServer;\n  }","id":73223,"modified_method":"MessageChannelHandler(@NotNull ClientManager clientManager, @NotNull MessageServer messageServer) {\n    this.clientManager = clientManager;\n    this.messageServer = messageServer;\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  void sendHeartbeat() {\n    channel.writeAndFlush(new PingWebSocketFrame());\n  }","id":73224,"modified_method":"@Override\n  public void sendHeartbeat() {\n    channel.writeAndFlush(new PingWebSocketFrame());\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void handleWebSocketRequest(final ChannelHandlerContext context,\n                                      FullHttpRequest request,\n                                      final QueryStringDecoder uriDecoder) {\n    WebSocketServerHandshakerFactory factory = new WebSocketServerHandshakerFactory(\"ws://\" + HttpHeaders.getHost(request) + uriDecoder.path(), null, false, NettyUtil.MAX_CONTENT_LENGTH);\n    WebSocketServerHandshaker handshaker = factory.newHandshaker(request);\n    if (handshaker == null) {\n      WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(context.channel());\n      return;\n    }\n\n    if (!context.channel().isOpen()) {\n      return;\n    }\n\n    final Client client = new WebSocketClient(context.channel(), handshaker);\n    context.attr(CLIENT).set(client);\n    handshaker.handshake(context.channel(), request).addListener(new ChannelFutureListener() {\n      @Override\n      public void operationComplete(ChannelFuture future) throws Exception {\n        if (future.isSuccess()) {\n          WebSocketServer webSocketServer = server.getValue();\n          webSocketServer.addClient(client);\n          MessageChannelHandler messageChannelHandler = new MessageChannelHandler(webSocketServer, getMessageServer());\n          BuiltInServer.replaceDefaultHandler(context, messageChannelHandler);\n          ChannelHandlerContext messageChannelHandlerContext = context.pipeline().context(messageChannelHandler);\n          context.pipeline().addBefore(messageChannelHandlerContext.name(), \"webSocketFrameAggregator\", new WebSocketFrameAggregator(NettyUtil.MAX_CONTENT_LENGTH));\n          messageChannelHandlerContext.attr(CLIENT).set(client);\n          connected(client, uriDecoder.parameters());\n        }\n      }\n    });\n  }","id":73225,"modified_method":"private void handleWebSocketRequest(final ChannelHandlerContext context,\n                                      FullHttpRequest request,\n                                      final QueryStringDecoder uriDecoder) {\n    WebSocketServerHandshakerFactory factory = new WebSocketServerHandshakerFactory(\"ws://\" + HttpHeaders.getHost(request) + uriDecoder.path(), null, false, NettyUtil.MAX_CONTENT_LENGTH);\n    WebSocketServerHandshaker handshaker = factory.newHandshaker(request);\n    if (handshaker == null) {\n      WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(context.channel());\n      return;\n    }\n\n    if (!context.channel().isOpen()) {\n      return;\n    }\n\n    final Client client = new WebSocketClient(context.channel(), handshaker);\n    context.attr(ClientManager.CLIENT).set(client);\n    handshaker.handshake(context.channel(), request).addListener(new ChannelFutureListener() {\n      @Override\n      public void operationComplete(ChannelFuture future) throws Exception {\n        if (future.isSuccess()) {\n          ClientManager webSocketServer = server.getValue();\n          webSocketServer.addClient(client);\n          MessageChannelHandler messageChannelHandler = new MessageChannelHandler(webSocketServer, getMessageServer());\n          BuiltInServer.replaceDefaultHandler(context, messageChannelHandler);\n          ChannelHandlerContext messageChannelHandlerContext = context.pipeline().context(messageChannelHandler);\n          context.pipeline().addBefore(messageChannelHandlerContext.name(), \"webSocketFrameAggregator\", new WebSocketFrameAggregator(NettyUtil.MAX_CONTENT_LENGTH));\n          messageChannelHandlerContext.attr(ClientManager.CLIENT).set(client);\n          connected(client, uriDecoder.parameters());\n        }\n      }\n    });\n  }","commit_id":"b5c5e8e156c0b22fb5431225319c2941762bbff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void showNotesView()\n    {\n    \tWidget.setExpanded(mSummaryPane, true);\n    \tWidget.setExpanded(mNotePanel, true);\n    \tWidget.setExpanded(mResourceMetaData, false);\n        Widget.setExpanded(mPreview, false);\n    \tWidget.setExpanded(mUserMetaData, false);\n    \t\n    }","id":73226,"modified_method":"public void showNotesView()\n    {\n    \tif (mSummaryPane.isVisible())\n    \t\tWidget.setExpanded(mSummaryPane, true);\n    \tif (mNotePanel.isVisible())\n    \t\tWidget.setExpanded(mNotePanel, true);\n    \tif (mResourceMetaData.isVisible())\n    \t\tWidget.setExpanded(mResourceMetaData, false);\n    \tif (mPreview.isVisible())\n    \t\tWidget.setExpanded(mPreview, false);\n    \tif (mUserMetaData.isVisible())\n    \t\tWidget.setExpanded(mUserMetaData, false);\n    \t\n    }","commit_id":"2bccea5a26a2a834608f739cb2b31a4468a29859","url":"https://github.com/VUE/VUE"},{"original_method":"public void showInfoView()\n    {\n    \tWidget.setExpanded(mSummaryPane, true);\n    \tWidget.setExpanded(mNotePanel, true);\n    \tWidget.setExpanded(mResourceMetaData, true);\n        Widget.setExpanded(mPreview, true);\n    \tWidget.setExpanded(mUserMetaData, false);\n    \t\n    }","id":73227,"modified_method":"public void showInfoView()\n    {\n    \tif (mSummaryPane.isVisible())\n    \t\tWidget.setExpanded(mSummaryPane, true);\n    \tif (mNotePanel.isVisible())\n    \t\tWidget.setExpanded(mNotePanel, true);\n    \tif (mResourceMetaData.isVisible())\n    \t\tWidget.setExpanded(mResourceMetaData, true);\n    \tif (mPreview.isVisible())\n    \t\tWidget.setExpanded(mPreview, true);\n    \tif (mUserMetaData.isVisible())\n    \t\tWidget.setExpanded(mUserMetaData, false);\n    \t\n    }","commit_id":"2bccea5a26a2a834608f739cb2b31a4468a29859","url":"https://github.com/VUE/VUE"},{"original_method":"public void showKeywordView()\n    {\n    \tWidget.setExpanded(mSummaryPane, true);\n    \tWidget.setExpanded(mNotePanel, false);\n    \tWidget.setExpanded(mResourceMetaData, false);\n        Widget.setExpanded(mPreview, false);\n    \tWidget.setExpanded(mUserMetaData, true);\n    \t\n    }","id":73228,"modified_method":"public void showKeywordView()\n    {\n    \tif (mSummaryPane.isVisible())\n    \t\tWidget.setExpanded(mSummaryPane, true);\n    \tif (mNotePanel.isVisible())\n    \t\tWidget.setExpanded(mNotePanel, false);\n    \tif (mResourceMetaData.isVisible())\n    \t\tWidget.setExpanded(mResourceMetaData, false);\n    \tif (mPreview.isVisible())\n    \t\tWidget.setExpanded(mPreview, false);\n    \tif (mUserMetaData.isVisible())\n    \t\tWidget.setExpanded(mUserMetaData, true);\n    \t\n    }","commit_id":"2bccea5a26a2a834608f739cb2b31a4468a29859","url":"https://github.com/VUE/VUE"},{"original_method":"@Override\n\t\tprotected void handleOption(String option, String optionExtraPart)\n\t\t\t\tthrows IOException {\n\t\t\tif (option.equals(\"-overrideRevisionNames\")) {\n\t\t\t\tif (optionExtraPart.length() == 0)\n\t\t\t\t\toverrideRevisionNames = true;\n\t\t\t\telse\n\t\t\t\t\toverrideRevisionNames = TigerSubstitutes.parseBoolean(optionExtraPart);\n\t\t\t}\n\t\t\telse if (option.equals(\"-noPackageMoves\")) {\n\t\t\t\tif (optionExtraPart.length() == 0)\n\t\t\t\t\tnoPackageMoves = true;\n\t\t\t\telse\n\t\t\t\t\tnoPackageMoves = TigerSubstitutes.parseBoolean(optionExtraPart);\n\t\t\t}\n\t\t\telse \tif (option.equals(\"-precisePriorityMatch\")) \n\t\t\t\tversionInsensitiveBugComparator.setComparePriorities(true);\n\t\t\telse if (option.equals(\"-quiet\")) verbose = false;\n\t\t\telse throw new IllegalArgumentException(\"no option \" + option);\n\n\t\t}","id":73229,"modified_method":"@Override\n\t\tprotected void handleOption(String option, String optionExtraPart)\n\t\t\t\tthrows IOException {\n\t\t\tif (option.equals(\"-overrideRevisionNames\")) {\n\t\t\t\tif (optionExtraPart.length() == 0)\n\t\t\t\t\toverrideRevisionNames = true;\n\t\t\t\telse\n\t\t\t\t\toverrideRevisionNames = TigerSubstitutes\n\t\t\t\t\t\t\t.parseBoolean(optionExtraPart);\n\t\t\t} else if (option.equals(\"-noPackageMoves\")) {\n\t\t\t\tif (optionExtraPart.length() == 0)\n\t\t\t\t\tnoPackageMoves = true;\n\t\t\t\telse\n\t\t\t\t\tnoPackageMoves = TigerSubstitutes\n\t\t\t\t\t\t\t.parseBoolean(optionExtraPart);\n\t\t\t} else if (option.equals(\"-preciseMatch\")) {\n\t\t\t\tpreciseMatch = true;\n\t\t\t} else if (option.equals(\"-precisePriorityMatch\")) {\n\t\t\t\tversionInsensitiveBugComparator.setComparePriorities(true);\n\t\t\t\tfuzzyBugPatternMatcher.setComparePriorities(true);\n\t\t\t\tprecisePriorityMatch = true;\n\t\t\t} else if (option.equals(\"-quiet\"))\n\t\t\t\tverbose = false;\n\t\t\telse\n\t\t\t\tthrow new IllegalArgumentException(\"no option \" + option);\n\n\t\t}","commit_id":"6ec242011f030fc2387b13fbcfca2eeaf3e79ca8","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static void matchBugs(\n\t\t\tComparator<BugInstance> bugInstanceComparator,\n\t\t\tBugCollection origCollection, BugCollection newCollection) {\n\t\t\n\t\tTreeMap<BugInstance, LinkedList<BugInstance>> set = new TreeMap<BugInstance, LinkedList<BugInstance>>(\n\t\t\t\tbugInstanceComparator);\n\t\tint oldBugs = 0;\n\t\tint newBugs = 0;\n\t\tint matchedBugs = 0;\n\t\tfor (BugInstance bug : origCollection.getCollection())\n\t\t\tif (bug.getLastVersion() == -1 && !matchedOldBugs.contains(bug)) {\n\t\t\t\toldBugs++;\n\t\t\t\tLinkedList<BugInstance> q = set.get(bug);\n\t\t\t\tif (q == null) {\n\t\t\t\t\tq = new LinkedList<BugInstance>();\n\t\t\t\t\tset.put(bug, q);\n\t\t\t\t}\n\t\t\t\tq.add(bug);\n\t\t\t}\n\t\tfor (BugInstance bug : newCollection.getCollection()) if (!mapFromNewToOldBug.containsKey(bug)) {\n\t\t\tnewBugs++;\n\t\t\tLinkedList<BugInstance> q = set.get(bug);\n\t\t\tif (q != null && !q.isEmpty()) {\n\t\t\t\tmatchedBugs++;\n\t\t\t\tBugInstance matchedBug = q.removeFirst();\n\t\t\t\tmapFromNewToOldBug.put(bug, matchedBug);\n\t\t\t\tmatchedOldBugs.add(matchedBug);\n\t\t\t}\n\t\t}\n\t\tif (false && verbose) System.out.println(\"matched \" + matchedBugs + \" of \" + oldBugs +\"o/\" + newBugs  + \"n bugs using \" + bugInstanceComparator.getClass().getName()); \n\t}","id":73230,"modified_method":"private void matchBugs(Comparator<BugInstance> bugInstanceComparator,\n\t\t\tBugCollection origCollection, BugCollection newCollection) {\n\n\t\tTreeMap<BugInstance, LinkedList<BugInstance>> set = new TreeMap<BugInstance, LinkedList<BugInstance>>(\n\t\t\t\tbugInstanceComparator);\n\t\tint oldBugs = 0;\n\t\tint newBugs = 0;\n\t\tint matchedBugs = 0;\n\t\tfor (BugInstance bug : origCollection.getCollection())\n\t\t\tif (bug.getLastVersion() == -1 && !matchedOldBugs.contains(bug)) {\n\t\t\t\toldBugs++;\n\t\t\t\tLinkedList<BugInstance> q = set.get(bug);\n\t\t\t\tif (q == null) {\n\t\t\t\t\tq = new LinkedList<BugInstance>();\n\t\t\t\t\tset.put(bug, q);\n\t\t\t\t}\n\t\t\t\tq.add(bug);\n\t\t\t}\n\t\tfor (BugInstance bug : newCollection.getCollection())\n\t\t\tif (!mapFromNewToOldBug.containsKey(bug)) {\n\t\t\t\tnewBugs++;\n\t\t\t\tLinkedList<BugInstance> q = set.get(bug);\n\t\t\t\tif (q != null && !q.isEmpty()) {\n\t\t\t\t\tmatchedBugs++;\n\t\t\t\t\tBugInstance matchedBug = q.removeFirst();\n\t\t\t\t\tmapFromNewToOldBug.put(bug, matchedBug);\n\t\t\t\t\tmatchedOldBugs.add(matchedBug);\n\t\t\t\t}\n\t\t\t}\n\t\tif (false && verbose)\n\t\t\tSystem.out.println(\"matched \" + matchedBugs + \" of \" + oldBugs\n\t\t\t\t\t+ \"o/\" + newBugs + \"n bugs using \"\n\t\t\t\t\t+ bugInstanceComparator.getClass().getName());\n\t}","commit_id":"6ec242011f030fc2387b13fbcfca2eeaf3e79ca8","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public static void main(String[] args) throws IOException,\n\t\t\tDocumentException {\n\n\t\tDetectorFactoryCollection.instance();\n\t\tUpdateCommandLine commandLine = new UpdateCommandLine();\n\t\tint argCount = commandLine.parse(args, 2, Integer.MAX_VALUE, USAGE);\n\n\t\tif (commandLine.outputFilename == null) verbose = false;\n\t\tString[] firstPathParts = getFilePathParts(args[argCount]);\n\t\tint commonPrefix = firstPathParts.length;\n\t\tfor(int i = argCount+1; i <= (args.length - 1); i++) {\n\n\t\t\tcommonPrefix = Math.min(commonPrefix, \n\t\t\t\t\tlengthCommonPrefix(\n\t\t\t\t\t\t\tfirstPathParts, \n\t\t\t\t\t\t\tgetFilePathParts(args[i])));\n\t\t}\n\t\t\n\t\t\n\t\tString origFilename = args[argCount++];\n\t\tProject project = new Project();\n\t\tBugCollection origCollection;\n\t\torigCollection = new SortedBugCollection();\n\t\tif (verbose)\n\t\t\tSystem.out.println(\"Starting with \" + origFilename);\n\n\t\torigCollection.readXML(origFilename, project);\n\n\t\tif (commandLine.overrideRevisionNames || origCollection.getReleaseName() == null || origCollection.getReleaseName().length() == 0)\n\t\t\torigCollection.setReleaseName(firstPathParts[commonPrefix]);\n\t\tfor (BugInstance bug : origCollection.getCollection())\n\t\t\tif (bug.getLastVersion() >= 0\n\t\t\t\t\t&& bug.getFirstVersion() > bug.getLastVersion())\n\t\t\t\tthrow new IllegalStateException(\"Illegal Version range: \"\n\t\t\t\t\t\t+ bug.getFirstVersion() + \"..\" + bug.getLastVersion());\n\n\n\t\twhile (argCount <= (args.length - 1)) {\n\n\t\t\tBugCollection newCollection = new SortedBugCollection();\n\n\t\t\tString newFilename = args[argCount++];\n\t\t\tif (verbose)\n\t\t\t\tSystem.out.println(\"Merging \" + newFilename);\n\t\t\tproject = new Project();\n\t\t\ttry {\n\t\t\t\tFile f = new File(newFilename);\n\t\t\t\tif (f.length() == 0) {\n\t\t\t\t\tif (verbose) System.out.println(\"Empty input file: \" + f);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\tnewCollection.readXML(newFilename, project);\n\n\n\t\t\tif (commandLine.overrideRevisionNames || newCollection.getReleaseName() == null || newCollection.getReleaseName().length() == 0) \n\t\t\t\t\tnewCollection.setReleaseName(getFilePathParts(newFilename)[commonPrefix]);\n\n\t\t\torigCollection = mergeCollections(origCollection, newCollection, true);\n\t\t\t} catch (IOException e) {\n\t\t\t\tif (verbose) \n\t\t\t\t\tSystem.out.println(e);\n\t\t\t\telse throw e;\n\t\t\t}\n\t\t}\n\n\t\tif (commandLine.outputFilename != null) \n\t\t\torigCollection.writeXML(commandLine.outputFilename, project);\n\t\telse\n\t\t\torigCollection.writeXML(System.out, project);\n\n\t}","id":73231,"modified_method":"public static void main(String[] args) throws IOException,\n\t\t\tDocumentException {\n\t\tnew Update().doit(args);\n\t}","commit_id":"6ec242011f030fc2387b13fbcfca2eeaf3e79ca8","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public static BugCollection mergeCollections(BugCollection origCollection,\n\t\t\tBugCollection newCollection, boolean copyDeadBugs) {\n\t\t\n\t\tmapFromNewToOldBug.clear();\n\n\t\tmatchedOldBugs.clear();\n\t\tBugCollection resultCollection = newCollection\n\t\t\t\t.createEmptyCollectionWithMetadata();\n\t\t// Previous sequence number\n\t\tlong lastSequence = origCollection.getSequenceNumber();\n\t\t// The AppVersion history is retained from the orig collection,\n\t\t// adding an entry for the sequence/timestamp of the current state\n\t\t// of the orig collection.\n\t\tresultCollection.clearAppVersions();\n\t\tfor (Iterator<AppVersion> i = origCollection.appVersionIterator(); i\n\t\t\t\t.hasNext();) {\n\t\t\tAppVersion appVersion = i.next();\n\t\t\tresultCollection.addAppVersion((AppVersion) appVersion.clone());\n\t\t}\n\t\t//why not do: AppVersion origCollectionVersion = origCollection.getCurrentAppVersion();\n\t\tAppVersion origCollectionVersion = new AppVersion(lastSequence);\n\t\torigCollectionVersion.setTimestamp(origCollection\n\t\t\t\t.getCurrentAppVersion().getTimestamp());\n\t\torigCollectionVersion.setReleaseName(origCollection\n\t\t\t\t.getCurrentAppVersion().getReleaseName());\n\t\torigCollectionVersion.setNumClasses(origCollection.getProjectStats().getNumClasses());\n\t\torigCollectionVersion.setCodeSize(origCollection.getProjectStats().getCodeSize());\n\t\t\n\t\tresultCollection.addAppVersion(origCollectionVersion);\n\n\t\t// We assign a sequence number to the new collection as one greater than\n\t\t// the original collection.\n\t\tlong currentSequence = origCollection.getSequenceNumber() + 1;\n\t\tresultCollection.setSequenceNumber(currentSequence);\n\n\t\tint oldBugs = 0;\n\t\t// move all inactive bugs\n\t\tif (copyDeadBugs) for (BugInstance bug : origCollection.getCollection())\n\t\t\t\tif (bug.getLastVersion() != -1)\n\t\t\t\t{\n\t\t\t\t\toldBugs++;\n\t\t\t\t\tBugInstance newBug = (BugInstance) bug.clone();\n\t\t\t\t\tresultCollection.add(newBug, false);\n\t\t\t\t}\n\n\t\t\n\t\t\n\t\tmatchBugs(SortedBugCollection.BugInstanceComparator.instance,\n\t\t\t\torigCollection, newCollection);\n\t\tmatchBugs(versionInsensitiveBugComparator, origCollection,\n\t\t\t\tnewCollection);\n\t\t{\n\t\tVersionInsensitiveBugComparator fuzzyBugPatternMatcher = new VersionInsensitiveBugComparator();\n\t\tfuzzyBugPatternMatcher.setExactBugPatternMatch(false);\n\t\tmatchBugs(fuzzyBugPatternMatcher, origCollection,\n\t\t\tnewCollection);\n\t\t}\n\t\tif (!noPackageMoves) {\n\t\t\tVersionInsensitiveBugComparator movedBugComparator = new VersionInsensitiveBugComparator();\n\t\t\tmovedBugComparator.setClassNameRewriter(new MovedClassMap(origCollection,newCollection).execute());\n\t\t\tmatchBugs(movedBugComparator, origCollection,\n\t\t\t\t\tnewCollection);\n\t\t\tmovedBugComparator.setExactBugPatternMatch(false);\n\t\t\tmatchBugs(movedBugComparator, origCollection,\n\t\t\t\tnewCollection);\n\t\t}\n\n\t\t// matchBugs(new SloppyBugComparator(), origCollection, newCollection);\n\n\n\t\tint newlyDeadBugs = 0;\n\t\tint persistantBugs = 0;\n\t\tint addedBugs = 0;\n\t\tint addedInNewCode = 0;\n\t\tint deadBugInDeadCode = 0;\n\n\t\t// Copy unmatched bugs\n\t\tif (copyDeadBugs) for (BugInstance bug : origCollection.getCollection())\n\t\t\tif (!matchedOldBugs.contains(bug)) {\n\t\t\t\tif (bug.getLastVersion() == -1)\n\t\t\t\t\tnewlyDeadBugs++;\n\t\t\t\telse\n\t\t\t\t\toldBugs++;\n\t\t\t\tBugInstance newBug = (BugInstance) bug.clone();\n\n\t\t\t\tif (newBug.getLastVersion() == -1) {\n\t\t\t\t\tnewBug.setLastVersion(lastSequence);\n\t\t\t\t\tClassAnnotation classBugFoundIn = bug.getPrimaryClass();\n\t\t\t\t\tString className = classBugFoundIn.getClassName();\n\t\t\t\t\tif (newCollection.getProjectStats()\n\t\t\t\t\t\t\t.getClassStats(className) != null)\n\t\t\t\t\t\tnewBug.setRemovedByChangeOfPersistingClass(true);\n\t\t\t\t\telse\n\t\t\t\t\t\tdeadBugInDeadCode++;\n\t\t\t\t}\n\n\t\t\t\tif (newBug.getFirstVersion() > newBug.getLastVersion())\n\t\t\t\t\tthrow new IllegalStateException(\"Illegal Version range: \"\n\t\t\t\t\t\t\t+ newBug.getFirstVersion() + \"..\"\n\t\t\t\t\t\t\t+ newBug.getLastVersion());\n\t\t\t\tresultCollection.add(newBug, false);\n\t\t\t}\n\t\t// Copy matched bugs\n\t\tfor (BugInstance bug : newCollection.getCollection()) {\n\t\t\tBugInstance newBug = (BugInstance) bug.clone();\n\t\t\tif (mapFromNewToOldBug.containsKey(bug)) {\n\t\t\t\tBugInstance origWarning = mapFromNewToOldBug.get(bug);\n\t\t\t\tassert origWarning.getLastVersion() == -1;\n\n\t\t\t\tnewBug.setUniqueId(origWarning.getUniqueId());\n\t\t\t\tcopyBugHistory(origWarning, newBug);\n\t\t\t\t//handle getAnnotationText()/setAnnotationText() and designation key\n\t\t\t\tBugDesignation designation = newBug.getUserDesignation();\n\t\t\t\tif (designation != null) designation.merge(origWarning.getUserDesignation());\n\t\t\t\t\telse newBug.setUserDesignation(origWarning.getUserDesignation()); //clone??\n\t\t\t\t\t\n\n\t\t\t\tpersistantBugs++;\n\t\t\t} else {\n\t\t\t\tnewBug.setFirstVersion(lastSequence + 1);\n\t\t\t\taddedBugs++;\n\n\t\t\t\tClassAnnotation classBugFoundIn = bug.getPrimaryClass();\n\n\t\t\t\tString className = classBugFoundIn.getClassName();\n\t\t\t\tif (origCollection.getProjectStats().getClassStats(className) != null) {\n\t\t\t\t\tnewBug.setIntroducedByChangeOfExistingClass(true);\n\t\t\t\t\t// System.out.println(\"added bug to existing code \" +\n\t\t\t\t\t// newBug.getUniqueId() + \" : \" + newBug.getAbbrev() + \" in\n\t\t\t\t\t// \" + classBugFoundIn);\n\t\t\t\t} else\n\t\t\t\t\taddedInNewCode++;\n\t\t\t}\n\t\t\tassert newBug.getLastVersion() == -1;\n\t\t\tif (newBug.getLastVersion() != -1)\n\t\t\t\tthrow new IllegalStateException(\"Illegal Version range: \"\n\t\t\t\t\t\t+ newBug.getFirstVersion() + \"..\"\n\t\t\t\t\t\t+ newBug.getLastVersion());\n\t\t\tint oldSize = resultCollection.getCollection().size();\n\t\t\tresultCollection.add(newBug, false);\n\t\t\tint newSize = resultCollection.getCollection().size();\n\t\t\tif (newSize != oldSize + 1) {\n\t\t\t\tSystem.out.println(\"Failed to add bug #\" + newBug.getUniqueId()\n\t\t\t\t\t\t+ \" : \" + newBug.getMessage());\n\t\t\t}\n\t\t}\n\t\tif (false && verbose) {\n\t\t\tSystem.out.println(origCollection.getCollection().size()\n\t\t\t\t\t+ \" orig bugs, \" + newCollection.getCollection().size()\n\t\t\t\t\t+ \" new bugs\");\n\t\t\tSystem.out.println(\"Bugs: \" + oldBugs + \" old, \"\n\t\t\t\t\t+ deadBugInDeadCode + \" in removed code, \"\n\t\t\t\t\t+ (newlyDeadBugs - deadBugInDeadCode) + \" died, \"\n\t\t\t\t\t+ persistantBugs + \" persist, \" + addedInNewCode\n\t\t\t\t\t+ \" in new code, \" + (addedBugs - addedInNewCode)\n\t\t\t\t\t+ \" added\");\n\t\t\tSystem.out.println(resultCollection.getCollection().size()  + \" resulting bugs\");\n\t\t}\n\t\treturn resultCollection;\n\n\t}","id":73232,"modified_method":"public BugCollection mergeCollections(BugCollection origCollection,\n\t\t\tBugCollection newCollection, boolean copyDeadBugs) {\n\n\t\tmapFromNewToOldBug.clear();\n\n\t\tmatchedOldBugs.clear();\n\t\tBugCollection resultCollection = newCollection\n\t\t\t\t.createEmptyCollectionWithMetadata();\n\t\t// Previous sequence number\n\t\tlong lastSequence = origCollection.getSequenceNumber();\n\t\t// The AppVersion history is retained from the orig collection,\n\t\t// adding an entry for the sequence/timestamp of the current state\n\t\t// of the orig collection.\n\t\tresultCollection.clearAppVersions();\n\t\tfor (Iterator<AppVersion> i = origCollection.appVersionIterator(); i\n\t\t\t\t.hasNext();) {\n\t\t\tAppVersion appVersion = i.next();\n\t\t\tresultCollection.addAppVersion((AppVersion) appVersion.clone());\n\t\t}\n\t\t// why not do: AppVersion origCollectionVersion =\n\t\t// origCollection.getCurrentAppVersion();\n\t\tAppVersion origCollectionVersion = new AppVersion(lastSequence);\n\t\torigCollectionVersion.setTimestamp(origCollection\n\t\t\t\t.getCurrentAppVersion().getTimestamp());\n\t\torigCollectionVersion.setReleaseName(origCollection\n\t\t\t\t.getCurrentAppVersion().getReleaseName());\n\t\torigCollectionVersion.setNumClasses(origCollection.getProjectStats()\n\t\t\t\t.getNumClasses());\n\t\torigCollectionVersion.setCodeSize(origCollection.getProjectStats()\n\t\t\t\t.getCodeSize());\n\n\t\tresultCollection.addAppVersion(origCollectionVersion);\n\n\t\t// We assign a sequence number to the new collection as one greater than\n\t\t// the original collection.\n\t\tlong currentSequence = origCollection.getSequenceNumber() + 1;\n\t\tresultCollection.setSequenceNumber(currentSequence);\n\n\t\tint oldBugs = 0;\n\t\t// move all inactive bugs\n\t\tif (copyDeadBugs)\n\t\t\tfor (BugInstance bug : origCollection.getCollection())\n\t\t\t\tif (bug.getLastVersion() != -1) {\n\t\t\t\t\toldBugs++;\n\t\t\t\t\tBugInstance newBug = (BugInstance) bug.clone();\n\t\t\t\t\tresultCollection.add(newBug, false);\n\t\t\t\t}\n\n\t\tmatchBugs(SortedBugCollection.BugInstanceComparator.instance,\n\t\t\t\torigCollection, newCollection);\n\t\tmatchBugs(versionInsensitiveBugComparator, origCollection,\n\t\t\t\tnewCollection);\n\t\tif (!preciseMatch) {\n\t\t\tmatchBugs(fuzzyBugPatternMatcher, origCollection, newCollection);\n\t\t}\n\t\tif (!noPackageMoves) {\n\t\t\tVersionInsensitiveBugComparator movedBugComparator = new VersionInsensitiveBugComparator();\n\t\t\tMovedClassMap movedClassMap = new MovedClassMap(\n\t\t\t\t\t\t\t\torigCollection, newCollection).execute();\n\t\t\tif (!movedClassMap.isEmpty()) {\n\t\t\t\tmovedBugComparator.setClassNameRewriter(movedClassMap);\n\t\t\t\tmovedBugComparator.setComparePriorities(precisePriorityMatch);\n\t\t\t\tmatchBugs(movedBugComparator, origCollection, newCollection);\n\t\t\t\tif (!preciseMatch) {\n\t\t\t\t\tmovedBugComparator.setExactBugPatternMatch(false);\n\t\t\t\t\tmatchBugs(movedBugComparator, origCollection, newCollection);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// matchBugs(new SloppyBugComparator(), origCollection, newCollection);\n\n\t\tint newlyDeadBugs = 0;\n\t\tint persistantBugs = 0;\n\t\tint addedBugs = 0;\n\t\tint addedInNewCode = 0;\n\t\tint deadBugInDeadCode = 0;\n\n\t\t// Copy unmatched bugs\n\t\tif (copyDeadBugs)\n\t\t\tfor (BugInstance bug : origCollection.getCollection())\n\t\t\t\tif (!matchedOldBugs.contains(bug)) {\n\t\t\t\t\tif (bug.getLastVersion() == -1)\n\t\t\t\t\t\tnewlyDeadBugs++;\n\t\t\t\t\telse\n\t\t\t\t\t\toldBugs++;\n\t\t\t\t\tBugInstance newBug = (BugInstance) bug.clone();\n\n\t\t\t\t\tif (newBug.getLastVersion() == -1) {\n\t\t\t\t\t\tnewBug.setLastVersion(lastSequence);\n\t\t\t\t\t\tClassAnnotation classBugFoundIn = bug.getPrimaryClass();\n\t\t\t\t\t\tString className = classBugFoundIn.getClassName();\n\t\t\t\t\t\tif (newCollection.getProjectStats().getClassStats(\n\t\t\t\t\t\t\t\tclassName) != null)\n\t\t\t\t\t\t\tnewBug.setRemovedByChangeOfPersistingClass(true);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdeadBugInDeadCode++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newBug.getFirstVersion() > newBug.getLastVersion())\n\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\"Illegal Version range: \"\n\t\t\t\t\t\t\t\t\t\t+ newBug.getFirstVersion() + \"..\"\n\t\t\t\t\t\t\t\t\t\t+ newBug.getLastVersion());\n\t\t\t\t\tresultCollection.add(newBug, false);\n\t\t\t\t}\n\t\t// Copy matched bugs\n\t\tfor (BugInstance bug : newCollection.getCollection()) {\n\t\t\tBugInstance newBug = (BugInstance) bug.clone();\n\t\t\tif (mapFromNewToOldBug.containsKey(bug)) {\n\t\t\t\tBugInstance origWarning = mapFromNewToOldBug.get(bug);\n\t\t\t\tassert origWarning.getLastVersion() == -1;\n\n\t\t\t\tnewBug.setUniqueId(origWarning.getUniqueId());\n\t\t\t\tcopyBugHistory(origWarning, newBug);\n\t\t\t\t// handle getAnnotationText()/setAnnotationText() and\n\t\t\t\t// designation key\n\t\t\t\tBugDesignation designation = newBug.getUserDesignation();\n\t\t\t\tif (designation != null)\n\t\t\t\t\tdesignation.merge(origWarning.getUserDesignation());\n\t\t\t\telse\n\t\t\t\t\tnewBug.setUserDesignation(origWarning.getUserDesignation()); // clone??\n\n\t\t\t\tpersistantBugs++;\n\t\t\t} else {\n\t\t\t\tnewBug.setFirstVersion(lastSequence + 1);\n\t\t\t\taddedBugs++;\n\n\t\t\t\tClassAnnotation classBugFoundIn = bug.getPrimaryClass();\n\n\t\t\t\tString className = classBugFoundIn.getClassName();\n\t\t\t\tif (origCollection.getProjectStats().getClassStats(className) != null) {\n\t\t\t\t\tnewBug.setIntroducedByChangeOfExistingClass(true);\n\t\t\t\t\t// System.out.println(\"added bug to existing code \" +\n\t\t\t\t\t// newBug.getUniqueId() + \" : \" + newBug.getAbbrev() + \" in\n\t\t\t\t\t// \" + classBugFoundIn);\n\t\t\t\t} else\n\t\t\t\t\taddedInNewCode++;\n\t\t\t}\n\t\t\tassert newBug.getLastVersion() == -1;\n\t\t\tif (newBug.getLastVersion() != -1)\n\t\t\t\tthrow new IllegalStateException(\"Illegal Version range: \"\n\t\t\t\t\t\t+ newBug.getFirstVersion() + \"..\"\n\t\t\t\t\t\t+ newBug.getLastVersion());\n\t\t\tint oldSize = resultCollection.getCollection().size();\n\t\t\tresultCollection.add(newBug, false);\n\t\t\tint newSize = resultCollection.getCollection().size();\n\t\t\tif (newSize != oldSize + 1) {\n\t\t\t\tSystem.out.println(\"Failed to add bug #\" + newBug.getUniqueId()\n\t\t\t\t\t\t+ \" : \" + newBug.getMessage());\n\t\t\t}\n\t\t}\n\t\tif (false && verbose) {\n\t\t\tSystem.out.println(origCollection.getCollection().size()\n\t\t\t\t\t+ \" orig bugs, \" + newCollection.getCollection().size()\n\t\t\t\t\t+ \" new bugs\");\n\t\t\tSystem.out.println(\"Bugs: \" + oldBugs + \" old, \"\n\t\t\t\t\t+ deadBugInDeadCode + \" in removed code, \"\n\t\t\t\t\t+ (newlyDeadBugs - deadBugInDeadCode) + \" died, \"\n\t\t\t\t\t+ persistantBugs + \" persist, \" + addedInNewCode\n\t\t\t\t\t+ \" in new code, \" + (addedBugs - addedInNewCode)\n\t\t\t\t\t+ \" added\");\n\t\t\tSystem.out.println(resultCollection.getCollection().size()\n\t\t\t\t\t+ \" resulting bugs\");\n\t\t}\n\t\treturn resultCollection;\n\n\t}","commit_id":"6ec242011f030fc2387b13fbcfca2eeaf3e79ca8","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"UpdateCommandLine() {\n\t\t\taddSwitch(\"-overrideRevisionNames\", \n\t\t\t\"override revision names for each version with names computed filenames\");\n\t\t\taddSwitch(\"-noPackageMoves\", \n\t\t\t\"if a class seems to have moved from one package to another, treat warnings in that class as two seperate warnings\");\n\t\t\t\n\t\t\taddSwitch(\"-precisePriorityMatch\", \n\t\t\t\"only consider two warnings to be the same if their priorities match exactly\");\n\t\t\taddOption(\"-output\", \"output file\",\n\t\t\t\t\t\"explicit filename for merged results (standard out used if not specified)\");\n\t\t\taddSwitch(\"-quiet\", \n\t\t\t\"don't generate any outout to standard out unless there is an error\");\n\n\t\t}","id":73233,"modified_method":"UpdateCommandLine() {\n\t\t\taddSwitch(\"-overrideRevisionNames\",\n\t\t\t\t\t\"override revision names for each version with names computed filenames\");\n\t\t\taddSwitch(\n\t\t\t\t\t\"-noPackageMoves\",\n\t\t\t\t\t\"if a class seems to have moved from one package to another, treat warnings in that class as two seperate warnings\");\n\t\t\taddSwitch(\"-preciseMatch\",\n\t\t\t\t\t\"require bug patterns to match precisely\");\n\t\t\taddSwitch(\"-precisePriorityMatch\",\n\t\t\t\t\t\"only consider two warnings to be the same if their priorities match exactly\");\n\t\t\taddOption(\"-output\", \"output file\",\n\t\t\t\t\t\"explicit filename for merged results (standard out used if not specified)\");\n\t\t\taddSwitch(\"-quiet\",\n\t\t\t\t\t\"don't generate any outout to standard out unless there is an error\");\n\n\t\t}","commit_id":"6ec242011f030fc2387b13fbcfca2eeaf3e79ca8","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"UpdateCommandLine() {\n\t\t\taddSwitch(\"-overrideRevisionNames\", \n\t\t\t\"override revision names for each version with names computed filenames\");\n\t\t\taddSwitch(\"-precisePriorityMatch\", \n\t\t\t\"only consider two warnings to be the same if their prioritys match exactly\");\n\t\t\taddOption(\"-output\", \"output file\",\n\t\t\t\t\t\"explicit filename for merged results (standard out used if not specified)\");\n\t\n\t\t}","id":73234,"modified_method":"UpdateCommandLine() {\n\t\t\taddSwitch(\"-overrideRevisionNames\", \n\t\t\t\"override revision names for each version with names computed filenames\");\n\t\t\taddSwitch(\"-noPackageMoves\", \n\t\t\t\"if a class seems to have moved from one package to another, treat warnings in that class as two seperate warnings\");\n\t\t\t\n\t\t\taddSwitch(\"-precisePriorityMatch\", \n\t\t\t\"only consider two warnings to be the same if their priorities match exactly\");\n\t\t\taddOption(\"-output\", \"output file\",\n\t\t\t\t\t\"explicit filename for merged results (standard out used if not specified)\");\n\t\n\t\t}","commit_id":"61f6ae47f87e485ee06acfe12128548986b40c36","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public static BugCollection mergeCollections(BugCollection origCollection,\n\t\t\tBugCollection newCollection) {\n\t\t\n\t\tmapFromNewToOldBug.clear();\n\n\t\tmatchedOldBugs.clear();\n\t\tBugCollection resultCollection = newCollection\n\t\t\t\t.createEmptyCollectionWithMetadata();\n\t\t// Previous sequence number\n\t\tlong lastSequence = origCollection.getSequenceNumber();\n\t\t// The AppVersion history is retained from the orig collection,\n\t\t// adding an entry for the sequence/timestamp of the current state\n\t\t// of the orig collection.\n\t\tresultCollection.clearAppVersions();\n\t\tfor (Iterator<AppVersion> i = origCollection.appVersionIterator(); i\n\t\t\t\t.hasNext();) {\n\t\t\tAppVersion appVersion = i.next();\n\t\t\tresultCollection.addAppVersion((AppVersion) appVersion.clone());\n\t\t}\n\t\tAppVersion origCollectionVersion = new AppVersion(lastSequence);\n\t\torigCollectionVersion.setTimestamp(origCollection\n\t\t\t\t.getCurrentAppVersion().getTimestamp());\n\t\torigCollectionVersion.setReleaseName(origCollection\n\t\t\t\t.getCurrentAppVersion().getReleaseName());\n\t\torigCollectionVersion.setNumClasses(origCollection.getProjectStats().getNumClasses());\n\t\torigCollectionVersion.setCodeSize(origCollection.getProjectStats().getCodeSize());\n\t\t\n\t\tresultCollection.addAppVersion(origCollectionVersion);\n\n\t\t// We assign a sequence number to the new collection as one greater than\n\t\t// the\n\t\t// original collection.\n\t\tlong currentSequence = origCollection.getSequenceNumber() + 1;\n\t\tresultCollection.setSequenceNumber(currentSequence);\n\n\t\tmatchBugs(SortedBugCollection.BugInstanceComparator.instance,\n\t\t\t\torigCollection, newCollection);\n\t\tmatchBugs(versionInsensitiveBugComparator, origCollection,\n\t\t\t\tnewCollection);\n\t\tVersionInsensitiveBugComparator movedBugComparator = new VersionInsensitiveBugComparator();\n\t\tmovedBugComparator.setClassNameRewriter(new MovedClassMap(origCollection,newCollection).execute());\n\t\tmatchBugs(movedBugComparator, origCollection,\n\t\t\t\tnewCollection);\n\n\t\t// matchBugs(new SloppyBugComparator(), origCollection, newCollection);\n\n\t\tint oldBugs = 0;\n\t\tint newlyDeadBugs = 0;\n\t\tint persistantBugs = 0;\n\t\tint addedBugs = 0;\n\t\tint addedInNewCode = 0;\n\t\tint deadBugInDeadCode = 0;\n\n\t\t// Copy unmatched bugs\n\t\tfor (BugInstance bug : origCollection.getCollection())\n\t\t\tif (!matchedOldBugs.contains(bug)) {\n\t\t\t\tif (bug.getLastVersion() == -1)\n\t\t\t\t\tnewlyDeadBugs++;\n\t\t\t\telse\n\t\t\t\t\toldBugs++;\n\t\t\t\tBugInstance newBug = (BugInstance) bug.clone();\n\n\t\t\t\tif (newBug.getLastVersion() == -1) {\n\t\t\t\t\tnewBug.setLastVersion(lastSequence);\n\t\t\t\t\tClassAnnotation classBugFoundIn = bug.getPrimaryClass();\n\t\t\t\t\tString className = classBugFoundIn.getClassName();\n\t\t\t\t\tif (newCollection.getProjectStats()\n\t\t\t\t\t\t\t.getClassStats(className) != null)\n\t\t\t\t\t\tnewBug.setRemovedByChangeOfPersistingClass(true);\n\t\t\t\t\telse\n\t\t\t\t\t\tdeadBugInDeadCode++;\n\t\t\t\t}\n\n\t\t\t\tif (newBug.getFirstVersion() > newBug.getLastVersion())\n\t\t\t\t\tthrow new IllegalStateException(\"Illegal Version range: \"\n\t\t\t\t\t\t\t+ newBug.getFirstVersion() + \"..\"\n\t\t\t\t\t\t\t+ newBug.getLastVersion());\n\t\t\t\tresultCollection.add(newBug, false);\n\t\t\t}\n\t\t// Copy matched bugs\n\t\tfor (BugInstance bug : newCollection.getCollection()) {\n\t\t\tBugInstance newBug = (BugInstance) bug.clone();\n\t\t\tif (mapFromNewToOldBug.containsKey(bug)) {\n\t\t\t\tBugInstance origWarning = mapFromNewToOldBug.get(bug);\n\t\t\t\tassert origWarning.getLastVersion() == -1;\n\n\t\t\t\tnewBug.setUniqueId(origWarning.getUniqueId());\n\t\t\t\tcopyBugHistory(origWarning, newBug);\n\t\t\t\tString annotation = newBug.getAnnotationText();\n\t\t\t\tif (annotation.length() == 0)\n\t\t\t\t\tnewBug.setAnnotationText(origWarning.getAnnotationText());\n\n\t\t\t\tpersistantBugs++;\n\t\t\t} else {\n\t\t\t\tnewBug.setFirstVersion(lastSequence + 1);\n\t\t\t\taddedBugs++;\n\n\t\t\t\tClassAnnotation classBugFoundIn = bug.getPrimaryClass();\n\n\t\t\t\tString className = classBugFoundIn.getClassName();\n\t\t\t\tif (origCollection.getProjectStats().getClassStats(className) != null) {\n\t\t\t\t\tnewBug.setIntroducedByChangeOfExistingClass(true);\n\t\t\t\t\t// System.out.println(\"added bug to existing code \" +\n\t\t\t\t\t// newBug.getUniqueId() + \" : \" + newBug.getAbbrev() + \" in\n\t\t\t\t\t// \" + classBugFoundIn);\n\t\t\t\t} else\n\t\t\t\t\taddedInNewCode++;\n\t\t\t}\n\t\t\tassert newBug.getLastVersion() == -1;\n\t\t\tif (newBug.getLastVersion() != -1)\n\t\t\t\tthrow new IllegalStateException(\"Illegal Version range: \"\n\t\t\t\t\t\t+ newBug.getFirstVersion() + \"..\"\n\t\t\t\t\t\t+ newBug.getLastVersion());\n\t\t\tint oldSize = resultCollection.getCollection().size();\n\t\t\tresultCollection.add(newBug, false);\n\t\t\tint newSize = resultCollection.getCollection().size();\n\t\t\tif (newSize != oldSize + 1) {\n\t\t\t\tSystem.out.println(\"Failed to add bug #\" + newBug.getUniqueId()\n\t\t\t\t\t\t+ \" : \" + newBug.getMessage());\n\t\t\t}\n\t\t}\n\t\tif (false && verbose) {\n\t\t\tSystem.out.println(origCollection.getCollection().size()\n\t\t\t\t\t+ \" orig bugs, \" + newCollection.getCollection().size()\n\t\t\t\t\t+ \" new bugs\");\n\t\t\tSystem.out.println(\"Bugs: \" + oldBugs + \" old, \"\n\t\t\t\t\t+ deadBugInDeadCode + \" in removed code, \"\n\t\t\t\t\t+ (newlyDeadBugs - deadBugInDeadCode) + \" died, \"\n\t\t\t\t\t+ persistantBugs + \" persist, \" + addedInNewCode\n\t\t\t\t\t+ \" in new code, \" + (addedBugs - addedInNewCode)\n\t\t\t\t\t+ \" added\");\n\t\t}\n\t\treturn resultCollection;\n\n\t}","id":73235,"modified_method":"public static BugCollection mergeCollections(BugCollection origCollection,\n\t\t\tBugCollection newCollection) {\n\t\t\n\t\tmapFromNewToOldBug.clear();\n\n\t\tmatchedOldBugs.clear();\n\t\tBugCollection resultCollection = newCollection\n\t\t\t\t.createEmptyCollectionWithMetadata();\n\t\t// Previous sequence number\n\t\tlong lastSequence = origCollection.getSequenceNumber();\n\t\t// The AppVersion history is retained from the orig collection,\n\t\t// adding an entry for the sequence/timestamp of the current state\n\t\t// of the orig collection.\n\t\tresultCollection.clearAppVersions();\n\t\tfor (Iterator<AppVersion> i = origCollection.appVersionIterator(); i\n\t\t\t\t.hasNext();) {\n\t\t\tAppVersion appVersion = i.next();\n\t\t\tresultCollection.addAppVersion((AppVersion) appVersion.clone());\n\t\t}\n\t\tAppVersion origCollectionVersion = new AppVersion(lastSequence);\n\t\torigCollectionVersion.setTimestamp(origCollection\n\t\t\t\t.getCurrentAppVersion().getTimestamp());\n\t\torigCollectionVersion.setReleaseName(origCollection\n\t\t\t\t.getCurrentAppVersion().getReleaseName());\n\t\torigCollectionVersion.setNumClasses(origCollection.getProjectStats().getNumClasses());\n\t\torigCollectionVersion.setCodeSize(origCollection.getProjectStats().getCodeSize());\n\t\t\n\t\tresultCollection.addAppVersion(origCollectionVersion);\n\n\t\t// We assign a sequence number to the new collection as one greater than\n\t\t// the\n\t\t// original collection.\n\t\tlong currentSequence = origCollection.getSequenceNumber() + 1;\n\t\tresultCollection.setSequenceNumber(currentSequence);\n\n\t\tmatchBugs(SortedBugCollection.BugInstanceComparator.instance,\n\t\t\t\torigCollection, newCollection);\n\t\tmatchBugs(versionInsensitiveBugComparator, origCollection,\n\t\t\t\tnewCollection);\n\t\tif (!noPackageMoves) {\n\t\t\tVersionInsensitiveBugComparator movedBugComparator = new VersionInsensitiveBugComparator();\n\t\t\tmovedBugComparator.setClassNameRewriter(new MovedClassMap(origCollection,newCollection).execute());\n\t\t\tmatchBugs(movedBugComparator, origCollection,\n\t\t\t\tnewCollection);\n\t\t}\n\n\t\t// matchBugs(new SloppyBugComparator(), origCollection, newCollection);\n\n\t\tint oldBugs = 0;\n\t\tint newlyDeadBugs = 0;\n\t\tint persistantBugs = 0;\n\t\tint addedBugs = 0;\n\t\tint addedInNewCode = 0;\n\t\tint deadBugInDeadCode = 0;\n\n\t\t// Copy unmatched bugs\n\t\tfor (BugInstance bug : origCollection.getCollection())\n\t\t\tif (!matchedOldBugs.contains(bug)) {\n\t\t\t\tif (bug.getLastVersion() == -1)\n\t\t\t\t\tnewlyDeadBugs++;\n\t\t\t\telse\n\t\t\t\t\toldBugs++;\n\t\t\t\tBugInstance newBug = (BugInstance) bug.clone();\n\n\t\t\t\tif (newBug.getLastVersion() == -1) {\n\t\t\t\t\tnewBug.setLastVersion(lastSequence);\n\t\t\t\t\tClassAnnotation classBugFoundIn = bug.getPrimaryClass();\n\t\t\t\t\tString className = classBugFoundIn.getClassName();\n\t\t\t\t\tif (newCollection.getProjectStats()\n\t\t\t\t\t\t\t.getClassStats(className) != null)\n\t\t\t\t\t\tnewBug.setRemovedByChangeOfPersistingClass(true);\n\t\t\t\t\telse\n\t\t\t\t\t\tdeadBugInDeadCode++;\n\t\t\t\t}\n\n\t\t\t\tif (newBug.getFirstVersion() > newBug.getLastVersion())\n\t\t\t\t\tthrow new IllegalStateException(\"Illegal Version range: \"\n\t\t\t\t\t\t\t+ newBug.getFirstVersion() + \"..\"\n\t\t\t\t\t\t\t+ newBug.getLastVersion());\n\t\t\t\tresultCollection.add(newBug, false);\n\t\t\t}\n\t\t// Copy matched bugs\n\t\tfor (BugInstance bug : newCollection.getCollection()) {\n\t\t\tBugInstance newBug = (BugInstance) bug.clone();\n\t\t\tif (mapFromNewToOldBug.containsKey(bug)) {\n\t\t\t\tBugInstance origWarning = mapFromNewToOldBug.get(bug);\n\t\t\t\tassert origWarning.getLastVersion() == -1;\n\n\t\t\t\tnewBug.setUniqueId(origWarning.getUniqueId());\n\t\t\t\tcopyBugHistory(origWarning, newBug);\n\t\t\t\tString annotation = newBug.getAnnotationText();\n\t\t\t\tif (annotation.length() == 0)\n\t\t\t\t\tnewBug.setAnnotationText(origWarning.getAnnotationText());\n\n\t\t\t\tpersistantBugs++;\n\t\t\t} else {\n\t\t\t\tnewBug.setFirstVersion(lastSequence + 1);\n\t\t\t\taddedBugs++;\n\n\t\t\t\tClassAnnotation classBugFoundIn = bug.getPrimaryClass();\n\n\t\t\t\tString className = classBugFoundIn.getClassName();\n\t\t\t\tif (origCollection.getProjectStats().getClassStats(className) != null) {\n\t\t\t\t\tnewBug.setIntroducedByChangeOfExistingClass(true);\n\t\t\t\t\t// System.out.println(\"added bug to existing code \" +\n\t\t\t\t\t// newBug.getUniqueId() + \" : \" + newBug.getAbbrev() + \" in\n\t\t\t\t\t// \" + classBugFoundIn);\n\t\t\t\t} else\n\t\t\t\t\taddedInNewCode++;\n\t\t\t}\n\t\t\tassert newBug.getLastVersion() == -1;\n\t\t\tif (newBug.getLastVersion() != -1)\n\t\t\t\tthrow new IllegalStateException(\"Illegal Version range: \"\n\t\t\t\t\t\t+ newBug.getFirstVersion() + \"..\"\n\t\t\t\t\t\t+ newBug.getLastVersion());\n\t\t\tint oldSize = resultCollection.getCollection().size();\n\t\t\tresultCollection.add(newBug, false);\n\t\t\tint newSize = resultCollection.getCollection().size();\n\t\t\tif (newSize != oldSize + 1) {\n\t\t\t\tSystem.out.println(\"Failed to add bug #\" + newBug.getUniqueId()\n\t\t\t\t\t\t+ \" : \" + newBug.getMessage());\n\t\t\t}\n\t\t}\n\t\tif (false && verbose) {\n\t\t\tSystem.out.println(origCollection.getCollection().size()\n\t\t\t\t\t+ \" orig bugs, \" + newCollection.getCollection().size()\n\t\t\t\t\t+ \" new bugs\");\n\t\t\tSystem.out.println(\"Bugs: \" + oldBugs + \" old, \"\n\t\t\t\t\t+ deadBugInDeadCode + \" in removed code, \"\n\t\t\t\t\t+ (newlyDeadBugs - deadBugInDeadCode) + \" died, \"\n\t\t\t\t\t+ persistantBugs + \" persist, \" + addedInNewCode\n\t\t\t\t\t+ \" in new code, \" + (addedBugs - addedInNewCode)\n\t\t\t\t\t+ \" added\");\n\t\t}\n\t\treturn resultCollection;\n\n\t}","commit_id":"61f6ae47f87e485ee06acfe12128548986b40c36","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n\t\tprotected void handleOption(String option, String optionExtraPart)\n\t\t\t\tthrows IOException {\n\t\t\tif (option.equals(\"-overrideRevisionNames\")) {\n\t\t\t\tif (optionExtraPart.length() == 0)\n\t\t\t\t\toverrideRevisionNames = true;\n\t\t\t\telse\n\t\t\t\t\toverrideRevisionNames = Boolean.parseBoolean(optionExtraPart);\n\t\t\t}\n\t\t\telse \tif (option.equals(\"-precisePriorityMatch\")) \n\t\t\t\tversionInsensitiveBugComparator.setComparePriorities(true);\n\t\t\t\t\n\t\t\telse throw new IllegalArgumentException(\"no option \" + option);\n\n\t\t}","id":73236,"modified_method":"@Override\n\t\tprotected void handleOption(String option, String optionExtraPart)\n\t\t\t\tthrows IOException {\n\t\t\tif (option.equals(\"-overrideRevisionNames\")) {\n\t\t\t\tif (optionExtraPart.length() == 0)\n\t\t\t\t\toverrideRevisionNames = true;\n\t\t\t\telse\n\t\t\t\t\toverrideRevisionNames = Boolean.parseBoolean(optionExtraPart);\n\t\t\t}\n\t\t\telse if (option.equals(\"-noPackageMoves\")) {\n\t\t\t\tif (optionExtraPart.length() == 0)\n\t\t\t\t\tnoPackageMoves = true;\n\t\t\t\telse\n\t\t\t\t\tnoPackageMoves = Boolean.parseBoolean(optionExtraPart);\n\t\t\t}\n\t\t\telse \tif (option.equals(\"-precisePriorityMatch\")) \n\t\t\t\tversionInsensitiveBugComparator.setComparePriorities(true);\n\t\t\t\t\n\t\t\telse throw new IllegalArgumentException(\"no option \" + option);\n\n\t\t}","commit_id":"61f6ae47f87e485ee06acfe12128548986b40c36","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public DistributedStatusHistoryModel createHistoryModel(\n            String locationName, String monitorId, String applicationName,\n            String timeSpan, String previousLocationName) {\n        List<String> errors = new LinkedList<String>();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions = m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        List<RelativeTimePeriod> periods = Arrays.asList(RelativeTimePeriod.getDefaultPeriods());\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        List<OnmsApplication> sortedApplications = new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications);\n\n        OnmsMonitoringLocationDefinition location;\n        if (locationName == null) {\n            location = locationDefinitions.get(0);\n        } else {\n            location = m_locationMonitorDao.findMonitoringLocationDefinition(locationName);\n            if (location == null) {\n                errors.add(\"Could not find location definition '\" + locationName + \"'\");\n                location = locationDefinitions.get(0);\n            }\n        }\n        \n        int monitorIdInt = -1;\n        \n        if (monitorId != null && monitorId.length() > 0) {\n            try {\n                monitorIdInt = WebSecurityUtils.safeParseInt(monitorId);\n            } catch (NumberFormatException e) {\n                errors.add(\"Monitor ID '\" + monitorId + \"' is not an integer\");\n            }\n        }\n\n        OnmsApplication application;\n        if (applicationName == null) {\n            application = sortedApplications.get(0);\n        } else {\n            application = m_applicationDao.findByName(applicationName);\n            if (application == null) {\n                errors.add(\"Could not find application '\" + applicationName + \"'\");\n                application = sortedApplications.get(0);\n            }\n        }\n        \n        Collection<OnmsLocationMonitor> monitors = m_locationMonitorDao.findByLocationDefinition(location);\n        List<OnmsLocationMonitor> sortedMonitors = new LinkedList<OnmsLocationMonitor>(monitors);\n        Collections.sort(sortedMonitors);\n\n        OnmsLocationMonitor monitor = null;\n        if (monitorIdInt != -1 && location.getName().equals(previousLocationName)) {\n            for (OnmsLocationMonitor m : sortedMonitors) {\n                if (m.getId().equals(monitorIdInt)) {\n                    monitor = m;\n                    break;\n                }\n            }\n        }\n        \n        if (monitor == null && sortedMonitors.size() > 0) {\n            monitor = sortedMonitors.get(0);\n        }\n        \n        RelativeTimePeriod period = RelativeTimePeriod.getPeriodByIdOrDefault(timeSpan);\n        \n        /*\n         * Initialize the heirarchy under the service so that we don't get\n         * a LazyInitializationException later when the JSP page is pulling\n         * data out of the model object.\n         */\n        Collection<OnmsMonitoredService> memberServices = m_monitoredServiceDao.findByApplication(application);\n        for (OnmsMonitoredService service : memberServices) {\n            m_locationMonitorDao.initialize(service.getIpInterface());\n            m_locationMonitorDao.initialize(service.getIpInterface().getNode());\n        }\n\n        Collection<OnmsMonitoredService> applicationMemberServices = m_monitoredServiceDao.findByApplication(application);\n        if (applicationMemberServices.size() == 0) {\n            errors.add(\"There are no services in the application '\" + applicationName + \"'\");\n        }\n        \n        DistributedStatusHistoryModel model = new DistributedStatusHistoryModel(locationDefinitions,\n                                                 sortedApplications,\n                                                 sortedMonitors,\n                                                 periods,\n                                                 location,\n                                                 application,\n                                                 applicationMemberServices,\n                                                 monitor,\n                                                 period,\n                                                 errors);\n        initializeGraphUrls(model);\n        return model;\n    }","id":73237,"modified_method":"public DistributedStatusHistoryModel createHistoryModel(\n            String locationName, String monitorId, String applicationName,\n            String timeSpan, String previousLocationName) {\n        List<String> errors = new LinkedList<String>();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions = m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        List<RelativeTimePeriod> periods = Arrays.asList(RelativeTimePeriod.getDefaultPeriods());\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        List<OnmsApplication> sortedApplications = new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications);\n\n        OnmsMonitoringLocationDefinition location = new OnmsMonitoringLocationDefinition();\n        if (locationName == null) {\n            if (!locationDefinitions.isEmpty()) {\n                location = locationDefinitions.get(0);\n            }\n        } else {\n            location = m_locationMonitorDao.findMonitoringLocationDefinition(locationName);\n            if (location == null) {\n                errors.add(\"Could not find location definition '\" + locationName + \"'\");\n                if (!locationDefinitions.isEmpty()) {\n                    location = locationDefinitions.get(0);\n                }\n            }\n        }\n        \n        int monitorIdInt = -1;\n        \n        if (monitorId != null && monitorId.length() > 0) {\n            try {\n                monitorIdInt = WebSecurityUtils.safeParseInt(monitorId);\n            } catch (NumberFormatException e) {\n                errors.add(\"Monitor ID '\" + monitorId + \"' is not an integer\");\n            }\n        }\n\n        OnmsApplication application = new OnmsApplication();\n        if (applicationName == null) {\n            if (!sortedApplications.isEmpty()) {\n                application = sortedApplications.get(0);\n            }\n        } else {\n            application = m_applicationDao.findByName(applicationName);\n            if (application == null) {\n                errors.add(\"Could not find application '\" + applicationName + \"'\");\n                if (!sortedApplications.isEmpty()) {\n                    application = sortedApplications.get(0);\n                }\n            }\n        }\n        \n        Collection<OnmsLocationMonitor> monitors = m_locationMonitorDao.findByLocationDefinition(location);\n        List<OnmsLocationMonitor> sortedMonitors = new LinkedList<OnmsLocationMonitor>(monitors);\n        Collections.sort(sortedMonitors);\n\n        OnmsLocationMonitor monitor = null;\n        if (monitorIdInt != -1 && location.getName().equals(previousLocationName)) {\n            for (OnmsLocationMonitor m : sortedMonitors) {\n                if (m.getId().equals(monitorIdInt)) {\n                    monitor = m;\n                    break;\n                }\n            }\n        }\n        \n        if (monitor == null && !sortedMonitors.isEmpty()) {\n            monitor = sortedMonitors.get(0);\n        }\n        \n        RelativeTimePeriod period = RelativeTimePeriod.getPeriodByIdOrDefault(timeSpan);\n        \n        /*\n         * Initialize the heirarchy under the service so that we don't get\n         * a LazyInitializationException later when the JSP page is pulling\n         * data out of the model object.\n         */\n        Collection<OnmsMonitoredService> memberServices = m_monitoredServiceDao.findByApplication(application);\n        for (OnmsMonitoredService service : memberServices) {\n            m_locationMonitorDao.initialize(service.getIpInterface());\n            m_locationMonitorDao.initialize(service.getIpInterface().getNode());\n        }\n\n        Collection<OnmsMonitoredService> applicationMemberServices = m_monitoredServiceDao.findByApplication(application);\n        if (applicationMemberServices.isEmpty()) {\n            errors.add(\"There are no services in the application '\" + applicationName + \"'\");\n        }\n        \n        DistributedStatusHistoryModel model = new DistributedStatusHistoryModel(locationDefinitions,\n                                                 sortedApplications,\n                                                 sortedMonitors,\n                                                 periods,\n                                                 location,\n                                                 application,\n                                                 applicationMemberServices,\n                                                 monitor,\n                                                 period,\n                                                 errors);\n        initializeGraphUrls(model);\n        return model;\n    }","commit_id":"036533fd5eb87c1bcc85c021951860956893cf0e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void run() {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        // Queue of the lines that are read from the Nessus socket\n        FifoQueue lines = null;\n        // Flag that lets us know if we've found what we're looking for\n        boolean found = false;\n        // DB connection; is connected and disconnected as necessary\n        Connection conn = null;\n\n        /*\n         * Grab the list of all current open vulnerabilities for the IP address.\n         * We'll use this list to resolve vulnerabilities that are not\n         * redetected.\n         */\n        try {\n            conn = DataSourceFactory.getInstance().getConnection();\n        } catch (SQLException ex) {\n            log.error(\"Could not open DB connection\", ex);\n            return;\n        }\n        try {\n            PreparedStatement stmt = conn.prepareStatement(SELECT_ALL_VULNERABILITIES);\n\n            stmt.setString(1, config.targetAddress.getHostAddress());\n            ResultSet openVulnerabilitiesRS = stmt.executeQuery();\n\n            while (openVulnerabilitiesRS.next()) {\n                openVulnerabilities.add(new Integer(openVulnerabilitiesRS.getInt(\"vulnerabilityid\")));\n            }\n        } catch (SQLException ex) {\n            log.error(\"Error when querying database for open vulnerabilities.\");\n            log.error(ex.getLocalizedMessage(), ex);\n            return;\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                log.error(\"Could not close DB connection\", ex);\n            }\n        }\n\n        /*\n         * Perform a Nessus scan of the target IP address.  As each\n         * vulnerability is found, a new entry is put into the database\n\t * or the existing entry is updated.\n         */\n        Socket nessusSocket = null;\n        try {\n            nessusSocket = NessusConnectionFactory.getConnection(config.hostname, config.hostport);\n\n            if (nessusSocket == null) {\n                throw new IOException(\"Factory returned null connection\");\n            }\n\n            InputStream in = nessusSocket.getInputStream();\n            OutputStream out = nessusSocket.getOutputStream();\n\n            log.debug(\"Attached streams to the Nessus socket.\");\n\n            // Login to the server\n            out.write((NTP_VERSION_STRING + \"\\n\").getBytes());\n\n            log.debug(\"Sent NTP version string.\");\n\n            lines = readLines(in);\n\n            // Strip off the protocol/username prompt\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n                    log.debug(\"NTP string response: \" + line);\n                    if (line.indexOf(NTP_USERNAME_PROMPT) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Login to the server\n            out.write((config.username + \"\\n\").getBytes());\n\n            log.debug(\"Sent username string.\");\n\n            // Strip off the password prompt\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n                    log.debug(\"Username response: \" + line);\n                    if (line.indexOf(NTP_PASSWORD_PROMPT) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Login to the server\n            out.write((config.password + \"\\n\").getBytes());\n\n            log.debug(\"Sent password string.\");\n\n            // Strip off the rules list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Password response: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Strip off the preferences list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Preferences: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Strip off the rules list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Rules: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n\t\t}\n            }\n\n            /*\n             * Write the preferences list for the scan\n             * (which includes the list of plugins to execute\n             * against the target).\n             */\n            out.write(buildPreferencesString().getBytes());\n\n            log.debug(\"Sent preferences string.\");\n\n            // Strip off the PREFERENCES_ERRORS\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Preferences response: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found)\n                    lines = readLines(in);\n            }\n\n            /*\n             * I'm using the NEW_ATTACK directive, since I don't\n             * care about command strings getting too long (which\n             * you would use the LONG_ATTACK directive for).\n             */\n            \n            out.write((NTP_CLIENT_ENTITY + NTP_SEP + \"NEW_ATTACK\" + NTP_SEP + config.targetAddress.toString().replaceAll(\"/\", \"\") + NTP_SEP + NTP_CLIENT_ENTITY + \"\\n\").getBytes());\n//            out.write((NTP_CLIENT_ENTITY + NTP_SEP + \"NEW_ATTACK\" + NTP_SEP + config.targetAddress.toString() + NTP_SEP + NTP_CLIENT_ENTITY + \"\\n\").getBytes());\n\n            log.debug(\"Sent NEW_ATTACK directive against target: \" + config.targetAddress.toString());\n\n            // Read the response to the NEW_ATTACK\n            int returnCode = SCAN_SUCCESS;\n\n            while ((returnCode == SCAN_SUCCESS) || (returnCode == SCAN_NON_FATAL_ERROR)) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    log.debug(\"Nessus attack response: \" + line.replace('\\n', ' '));\n\n                    // Grep out any inappropriate messages\n                    if ((line.indexOf(\"the server killed it\") == -1)) {\n                        /*\n                         * This processing will update existing vulnerabilities\n                         * in the database and add new vulnerability entries\n                         * as the vulnerabilities are detected.\n                         */\n                        returnCode = processScanMessage(line);\n                    } else {\n                        log.error(\"Discarded inappropriate Nessus message: \" + line);\n                    }\n                }\n\n                // If the last read was successful, get more lines\n                if ((returnCode == SCAN_SUCCESS) || (returnCode == SCAN_NON_FATAL_ERROR)) {\n                    lines = readLines(in);\n                }\n            }\n\n            out.write(buildStopWholeTestString().getBytes());\n\n            /*\n             * If there were open vulnerabilities that were not reconfirmed\n             * during this scanning cycle, then mark them as resolved.\n             */\n            if (openVulnerabilities.size() > 0) {\n                try {\n                    conn = DataSourceFactory.getInstance().getConnection();\n                } catch (SQLException ex) {\n                    log.error(\"Could not open DB connection\", ex);\n                    return;\n                }\n                try {\n                    PreparedStatement stmt = conn.prepareStatement(RESOLVE_VULNERABILITY);\n\n                    Timestamp currentTime = new Timestamp(new java.util.Date().getTime());\n\n                    Iterator vuln = openVulnerabilities.iterator();\n                    while (vuln.hasNext()) {\n                        stmt.setTimestamp(1, currentTime);\n\n                        /*\n                         * If the scan ended because of a successful completion\n                         * and all plugins were executed (indicating that the\n                         * host WAS accessible), resolve the bug.\n                         */\n                        if ((returnCode == SCAN_COMPLETE) && (lastPlugin == totalPlugins)) {\n                            stmt.setTimestamp(2, currentTime);\n                        }\n                        // Otherwise, just leave the resolved field NULL\n                        else {\n                            stmt.setNull(2, Types.TIMESTAMP);\n                        }\n\n                        stmt.setInt(3, ((Integer) vuln.next()).intValue());\n\n                        stmt.executeUpdate();\n                    }\n                } catch (SQLException ex) {\n                    log.error(\"Error when querying database for open vulnerabilities.\");\n                    log.error(ex.getLocalizedMessage(), ex);\n                    return;\n                } finally {\n                    try {\n                        conn.close();\n                    } catch (SQLException ex) {\n                        log.error(\"Could not close DB connection\", ex);\n                    }\n                }\n            }\n\n            log.debug(\"Sent STOP_WHOLE_TEST directive against target \" + config.targetAddress.toString());\n        } catch (FifoQueueException ex) {\n            log.warn(ex, ex);\n        } catch (InterruptedException ex) {\n            log.warn(ex, ex);\n        } catch (IOException ex) {\n            log.warn(ex, ex);\n        } finally {\n            log.info(\"Releasing Nessus socket connection\");\n            if (nessusSocket != null) {\n                NessusConnectionFactory.releaseConnection(nessusSocket);\n\t    }\n        }\n\n        // Update the scheduler flags for this configuration\n        config.setScheduled(false);\n        config.setLastScanned(new java.util.Date());\n    }","id":73238,"modified_method":"public void run() {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        // Queue of the lines that are read from the Nessus socket\n        FifoQueue lines = null;\n        // Flag that lets us know if we've found what we're looking for\n        boolean found = false;\n        // DB connection; is connected and disconnected as necessary\n        Connection conn = null;\n\n        /*\n         * Grab the list of all current open vulnerabilities for the IP address.\n         * We'll use this list to resolve vulnerabilities that are not\n         * redetected.\n         */\n        try {\n            conn = DataSourceFactory.getInstance().getConnection();\n        } catch (SQLException ex) {\n            log.error(\"Could not open DB connection\", ex);\n            return;\n        }\n        try {\n            PreparedStatement stmt = conn.prepareStatement(SELECT_ALL_VULNERABILITIES);\n\n            stmt.setString(1, config.targetAddress.getHostAddress());\n            ResultSet openVulnerabilitiesRS = stmt.executeQuery();\n\n            while (openVulnerabilitiesRS.next()) {\n                openVulnerabilities.add(new Integer(openVulnerabilitiesRS.getInt(\"vulnerabilityid\")));\n            }\n        } catch (SQLException ex) {\n            log.error(\"Error when querying database for open vulnerabilities.\");\n            log.error(ex.getLocalizedMessage(), ex);\n            return;\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                log.error(\"Could not close DB connection\", ex);\n            }\n        }\n\n        /*\n         * Perform a Nessus scan of the target IP address.  As each\n         * vulnerability is found, a new entry is put into the database\n\t * or the existing entry is updated.\n         */\n        Socket nessusSocket = null;\n        try {\n            nessusSocket = NessusConnectionFactory.getConnection(config.hostname, config.hostport);\n\n            if (nessusSocket == null) {\n                throw new IOException(\"Factory returned null connection\");\n            }\n\n            InputStream in = nessusSocket.getInputStream();\n            OutputStream out = nessusSocket.getOutputStream();\n\n            log.debug(\"Attached streams to the Nessus socket.\");\n\n            // Login to the server\n            out.write((NTP_VERSION_STRING + \"\\n\").getBytes());\n\n            log.debug(\"Sent NTP version string.\");\n\n            lines = readLines(in);\n\n            // Strip off the protocol/username prompt\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n                    log.debug(\"NTP string response: \" + line);\n                    if (line.indexOf(NTP_USERNAME_PROMPT) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Login to the server\n            out.write((config.username + \"\\n\").getBytes());\n\n            log.debug(\"Sent username string.\");\n\n            // Strip off the password prompt\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n                    log.debug(\"Username response: \" + line);\n                    if (line.indexOf(NTP_PASSWORD_PROMPT) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Login to the server\n            out.write((config.password + \"\\n\").getBytes());\n\n            log.debug(\"Sent password string.\");\n\n            // Strip off the rules list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Password response: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Strip off the preferences list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Preferences: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Strip off the rules list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Rules: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n\t\t}\n            }\n\n            /*\n             * Write the preferences list for the scan\n             * (which includes the list of plugins to execute\n             * against the target).\n             */\n            out.write(buildPreferencesString().getBytes());\n\n            log.debug(\"Sent preferences string.\");\n\n            // Strip off the PREFERENCES_ERRORS\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Preferences response: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found)\n                    lines = readLines(in);\n            }\n\n            /*\n             * I'm using the NEW_ATTACK directive, since I don't\n             * care about command strings getting too long (which\n             * you would use the LONG_ATTACK directive for).\n             */\n            \n            //out.write((NTP_CLIENT_ENTITY + NTP_SEP + \"NEW_ATTACK\" + NTP_SEP + config.targetAddress.toString().replaceAll(\"/\", \"\") + NTP_SEP + NTP_CLIENT_ENTITY + \"\\n\").getBytes());\n//            out.write((NTP_CLIENT_ENTITY + NTP_SEP + \"NEW_ATTACK\" + NTP_SEP + config.targetAddress.toString().replaceAll(\"/\", \"\") + NTP_SEP + NTP_CLIENT_ENTITY + \"\\n\").getBytes());\n            out.write((NTP_CLIENT_ENTITY + NTP_SEP + \"NEW_ATTACK\" + NTP_SEP + config.targetAddress.getCanonicalHostName() + NTP_SEP + NTP_CLIENT_ENTITY + \"\\n\").getBytes());\n\n            log.debug(\"Sent NEW_ATTACK directive against target: \" + config.targetAddress.getCanonicalHostName());\n\n            // Read the response to the NEW_ATTACK\n            int returnCode = SCAN_SUCCESS;\n\n            while ((returnCode == SCAN_SUCCESS) || (returnCode == SCAN_NON_FATAL_ERROR)) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    log.debug(\"Nessus attack response: \" + line.replace('\\n', ' '));\n\n                    // Grep out any inappropriate messages\n                    if ((line.indexOf(\"the server killed it\") == -1)) {\n                        /*\n                         * This processing will update existing vulnerabilities\n                         * in the database and add new vulnerability entries\n                         * as the vulnerabilities are detected.\n                         */\n                        returnCode = processScanMessage(line);\n                    } else {\n                        log.error(\"Discarded inappropriate Nessus message: \" + line);\n                    }\n                }\n\n                // If the last read was successful, get more lines\n                if ((returnCode == SCAN_SUCCESS) || (returnCode == SCAN_NON_FATAL_ERROR)) {\n                    lines = readLines(in);\n                }\n            }\n\n            out.write(buildStopWholeTestString().getBytes());\n\n            /*\n             * If there were open vulnerabilities that were not reconfirmed\n             * during this scanning cycle, then mark them as resolved.\n             */\n            if (openVulnerabilities.size() > 0) {\n                try {\n                    conn = DataSourceFactory.getInstance().getConnection();\n                } catch (SQLException ex) {\n                    log.error(\"Could not open DB connection\", ex);\n                    return;\n                }\n                try {\n                    PreparedStatement stmt = conn.prepareStatement(RESOLVE_VULNERABILITY);\n\n                    Timestamp currentTime = new Timestamp(new java.util.Date().getTime());\n\n                    Iterator vuln = openVulnerabilities.iterator();\n                    while (vuln.hasNext()) {\n                        stmt.setTimestamp(1, currentTime);\n\n                        /*\n                         * If the scan ended because of a successful completion\n                         * and all plugins were executed (indicating that the\n                         * host WAS accessible), resolve the bug.\n                         */\n                        if ((returnCode == SCAN_COMPLETE) && (lastPlugin == totalPlugins)) {\n                            stmt.setTimestamp(2, currentTime);\n                        }\n                        // Otherwise, just leave the resolved field NULL\n                        else {\n                            stmt.setNull(2, Types.TIMESTAMP);\n                        }\n\n                        stmt.setInt(3, ((Integer) vuln.next()).intValue());\n\n                        stmt.executeUpdate();\n                    }\n                } catch (SQLException ex) {\n                    log.error(\"Error when querying database for open vulnerabilities.\");\n                    log.error(ex.getLocalizedMessage(), ex);\n                    return;\n                } finally {\n                    try {\n                        conn.close();\n                    } catch (SQLException ex) {\n                        log.error(\"Could not close DB connection\", ex);\n                    }\n                }\n            }\n\n            log.debug(\"Sent STOP_WHOLE_TEST directive against target \" + config.targetAddress.toString());\n        } catch (FifoQueueException ex) {\n            log.warn(ex, ex);\n        } catch (InterruptedException ex) {\n            log.warn(ex, ex);\n        } catch (IOException ex) {\n            log.warn(ex, ex);\n        } finally {\n            log.info(\"Releasing Nessus socket connection\");\n            if (nessusSocket != null) {\n                NessusConnectionFactory.releaseConnection(nessusSocket);\n\t    }\n        }\n\n        // Update the scheduler flags for this configuration\n        config.setScheduled(false);\n        config.setLastScanned(new java.util.Date());\n    }","commit_id":"036533fd5eb87c1bcc85c021951860956893cf0e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Build the preferences string with the appropriate plugins and safe_checks\n     * settings from the config file.\n     */\n    private String buildPreferencesString() {\n        String retval = NTP_CLIENT_ENTITY + NTP_SEP + \"PREFERENCES\" + NTP_SEP + \"\\n\" + \"plugin_set\" + NTP_SEP + pluginLists[config.scanLevel] + \"\\n\" + \"safe_checks\" + NTP_SEP;\n\n        if (safeChecks[config.scanLevel])\n            retval += \"yes\";\n        else\n            retval += \"no\";\n\n        retval += \"\\nmax_hosts\" + NTP_SEP + \"1\\n\" + \"ntp_short_status\" + NTP_SEP + \"yes\\n\" + NTP_SEP + NTP_CLIENT_ENTITY;\n\n        return retval;\n    }","id":73239,"modified_method":"/**\n     * Build the preferences string with the appropriate plugins and safe_checks\n     * settings from the config file.\n     */\n    private String buildPreferencesString() {\n        String retval = NTP_CLIENT_ENTITY + NTP_SEP + \"PREFERENCES\" + NTP_SEP + \"\\n\" + \"plugin_set\" + NTP_SEP + pluginLists[config.scanLevel] + \"\\n\" + \"safe_checks\" + NTP_SEP;\n\n        if (safeChecks[config.scanLevel])\n            retval += \"yes\";\n        else\n            retval += \"no\";\n\n        retval += \"\\nmax_hosts\" + NTP_SEP + \"1\\n\" + \"ntp_short_status\" + NTP_SEP + \"yes\\n\" +  \"reverse_lookup\" + NTP_SEP + \"yes\\n\" + NTP_SEP + NTP_CLIENT_ENTITY;\n\n        return retval;\n    }","commit_id":"036533fd5eb87c1bcc85c021951860956893cf0e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\t\n\t}","id":73240,"modified_method":"@Before\n    public void setUp() {\n        System.setProperty(\"opennms.startup.context\", \"classpath:/startup.xml\");\n    }","commit_id":"036533fd5eb87c1bcc85c021951860956893cf0e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public DistributedStatusHistoryModel createHistoryModel(\n            String locationName, String monitorId, String applicationName,\n            String timeSpan, String previousLocationName) {\n        List<String> errors = new LinkedList<String>();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions = m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        List<RelativeTimePeriod> periods = Arrays.asList(RelativeTimePeriod.getDefaultPeriods());\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        List<OnmsApplication> sortedApplications = new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications);\n\n        OnmsMonitoringLocationDefinition location;\n        if (locationName == null) {\n            location = locationDefinitions.get(0);\n        } else {\n            location = m_locationMonitorDao.findMonitoringLocationDefinition(locationName);\n            if (location == null) {\n                errors.add(\"Could not find location definition '\" + locationName + \"'\");\n                location = locationDefinitions.get(0);\n            }\n        }\n        \n        int monitorIdInt = -1;\n        \n        if (monitorId != null && monitorId.length() > 0) {\n            try {\n                monitorIdInt = WebSecurityUtils.safeParseInt(monitorId);\n            } catch (NumberFormatException e) {\n                errors.add(\"Monitor ID '\" + monitorId + \"' is not an integer\");\n            }\n        }\n\n        OnmsApplication application;\n        if (applicationName == null) {\n            application = sortedApplications.get(0);\n        } else {\n            application = m_applicationDao.findByName(applicationName);\n            if (application == null) {\n                errors.add(\"Could not find application '\" + applicationName + \"'\");\n                application = sortedApplications.get(0);\n            }\n        }\n        \n        Collection<OnmsLocationMonitor> monitors = m_locationMonitorDao.findByLocationDefinition(location);\n        List<OnmsLocationMonitor> sortedMonitors = new LinkedList<OnmsLocationMonitor>(monitors);\n        Collections.sort(sortedMonitors);\n\n        OnmsLocationMonitor monitor = null;\n        if (monitorIdInt != -1 && location.getName().equals(previousLocationName)) {\n            for (OnmsLocationMonitor m : sortedMonitors) {\n                if (m.getId().equals(monitorIdInt)) {\n                    monitor = m;\n                    break;\n                }\n            }\n        }\n        \n        if (monitor == null && sortedMonitors.size() > 0) {\n            monitor = sortedMonitors.get(0);\n        }\n        \n        RelativeTimePeriod period = RelativeTimePeriod.getPeriodByIdOrDefault(timeSpan);\n        \n        /*\n         * Initialize the heirarchy under the service so that we don't get\n         * a LazyInitializationException later when the JSP page is pulling\n         * data out of the model object.\n         */\n        Collection<OnmsMonitoredService> memberServices = m_monitoredServiceDao.findByApplication(application);\n        for (OnmsMonitoredService service : memberServices) {\n            m_locationMonitorDao.initialize(service.getIpInterface());\n            m_locationMonitorDao.initialize(service.getIpInterface().getNode());\n        }\n\n        Collection<OnmsMonitoredService> applicationMemberServices = m_monitoredServiceDao.findByApplication(application);\n        if (applicationMemberServices.size() == 0) {\n            errors.add(\"There are no services in the application '\" + applicationName + \"'\");\n        }\n        \n        DistributedStatusHistoryModel model = new DistributedStatusHistoryModel(locationDefinitions,\n                                                 sortedApplications,\n                                                 sortedMonitors,\n                                                 periods,\n                                                 location,\n                                                 application,\n                                                 applicationMemberServices,\n                                                 monitor,\n                                                 period,\n                                                 errors);\n        initializeGraphUrls(model);\n        return model;\n    }","id":73241,"modified_method":"public DistributedStatusHistoryModel createHistoryModel(\n            String locationName, String monitorId, String applicationName,\n            String timeSpan, String previousLocationName) {\n        List<String> errors = new LinkedList<String>();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions = m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        List<RelativeTimePeriod> periods = Arrays.asList(RelativeTimePeriod.getDefaultPeriods());\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        List<OnmsApplication> sortedApplications = new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications);\n\n        OnmsMonitoringLocationDefinition location = new OnmsMonitoringLocationDefinition();\n        if (locationName == null) {\n            if (!locationDefinitions.isEmpty()) {\n                location = locationDefinitions.get(0);\n            }\n        } else {\n            location = m_locationMonitorDao.findMonitoringLocationDefinition(locationName);\n            if (location == null) {\n                errors.add(\"Could not find location definition '\" + locationName + \"'\");\n                if (!locationDefinitions.isEmpty()) {\n                    location = locationDefinitions.get(0);\n                }\n            }\n        }\n        \n        int monitorIdInt = -1;\n        \n        if (monitorId != null && monitorId.length() > 0) {\n            try {\n                monitorIdInt = WebSecurityUtils.safeParseInt(monitorId);\n            } catch (NumberFormatException e) {\n                errors.add(\"Monitor ID '\" + monitorId + \"' is not an integer\");\n            }\n        }\n\n        OnmsApplication application = new OnmsApplication();\n        if (applicationName == null) {\n            if (!sortedApplications.isEmpty()) {\n                application = sortedApplications.get(0);\n            }\n        } else {\n            application = m_applicationDao.findByName(applicationName);\n            if (application == null) {\n                errors.add(\"Could not find application '\" + applicationName + \"'\");\n                if (!sortedApplications.isEmpty()) {\n                    application = sortedApplications.get(0);\n                }\n            }\n        }\n        \n        Collection<OnmsLocationMonitor> monitors = m_locationMonitorDao.findByLocationDefinition(location);\n        List<OnmsLocationMonitor> sortedMonitors = new LinkedList<OnmsLocationMonitor>(monitors);\n        Collections.sort(sortedMonitors);\n\n        OnmsLocationMonitor monitor = null;\n        if (monitorIdInt != -1 && location.getName().equals(previousLocationName)) {\n            for (OnmsLocationMonitor m : sortedMonitors) {\n                if (m.getId().equals(monitorIdInt)) {\n                    monitor = m;\n                    break;\n                }\n            }\n        }\n        \n        if (monitor == null && !sortedMonitors.isEmpty()) {\n            monitor = sortedMonitors.get(0);\n        }\n        \n        RelativeTimePeriod period = RelativeTimePeriod.getPeriodByIdOrDefault(timeSpan);\n        \n        /*\n         * Initialize the heirarchy under the service so that we don't get\n         * a LazyInitializationException later when the JSP page is pulling\n         * data out of the model object.\n         */\n        Collection<OnmsMonitoredService> memberServices = m_monitoredServiceDao.findByApplication(application);\n        for (OnmsMonitoredService service : memberServices) {\n            m_locationMonitorDao.initialize(service.getIpInterface());\n            m_locationMonitorDao.initialize(service.getIpInterface().getNode());\n        }\n\n        Collection<OnmsMonitoredService> applicationMemberServices = m_monitoredServiceDao.findByApplication(application);\n        if (applicationMemberServices.isEmpty()) {\n            errors.add(\"There are no services in the application '\" + applicationName + \"'\");\n        }\n        \n        DistributedStatusHistoryModel model = new DistributedStatusHistoryModel(locationDefinitions,\n                                                 sortedApplications,\n                                                 sortedMonitors,\n                                                 periods,\n                                                 location,\n                                                 application,\n                                                 applicationMemberServices,\n                                                 monitor,\n                                                 period,\n                                                 errors);\n        initializeGraphUrls(model);\n        return model;\n    }","commit_id":"db4ee9b44393ff3094c26c475ac8a35931008fb9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Build the preferences string with the appropriate plugins and safe_checks\n     * settings from the config file.\n     */\n    private String buildPreferencesString() {\n        String retval = NTP_CLIENT_ENTITY + NTP_SEP + \"PREFERENCES\" + NTP_SEP + \"\\n\" + \"plugin_set\" + NTP_SEP + pluginLists[config.scanLevel] + \"\\n\" + \"safe_checks\" + NTP_SEP;\n\n        if (safeChecks[config.scanLevel])\n            retval += \"yes\";\n        else\n            retval += \"no\";\n\n        retval += \"\\nmax_hosts\" + NTP_SEP + \"1\\n\" + \"ntp_short_status\" + NTP_SEP + \"yes\\n\" + NTP_SEP + NTP_CLIENT_ENTITY;\n\n        return retval;\n    }","id":73242,"modified_method":"/**\n     * Build the preferences string with the appropriate plugins and safe_checks\n     * settings from the config file.\n     */\n    private String buildPreferencesString() {\n        String retval = NTP_CLIENT_ENTITY + NTP_SEP + \"PREFERENCES\" + NTP_SEP + \"\\n\" + \"plugin_set\" + NTP_SEP + pluginLists[config.scanLevel] + \"\\n\" + \"safe_checks\" + NTP_SEP;\n\n        if (safeChecks[config.scanLevel])\n            retval += \"yes\";\n        else\n            retval += \"no\";\n\n        retval += \"\\nmax_hosts\" + NTP_SEP + \"1\\n\" + \"ntp_short_status\" + NTP_SEP + \"yes\\n\" +  \"reverse_lookup\" + NTP_SEP + \"yes\\n\" + NTP_SEP + NTP_CLIENT_ENTITY;\n\n        return retval;\n    }","commit_id":"db4ee9b44393ff3094c26c475ac8a35931008fb9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void run() {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        // Queue of the lines that are read from the Nessus socket\n        FifoQueue lines = null;\n        // Flag that lets us know if we've found what we're looking for\n        boolean found = false;\n        // DB connection; is connected and disconnected as necessary\n        Connection conn = null;\n\n        /*\n         * Grab the list of all current open vulnerabilities for the IP address.\n         * We'll use this list to resolve vulnerabilities that are not\n         * redetected.\n         */\n        try {\n            conn = DataSourceFactory.getInstance().getConnection();\n        } catch (SQLException ex) {\n            log.error(\"Could not open DB connection\", ex);\n            return;\n        }\n        try {\n            PreparedStatement stmt = conn.prepareStatement(SELECT_ALL_VULNERABILITIES);\n\n            stmt.setString(1, config.targetAddress.getHostAddress());\n            ResultSet openVulnerabilitiesRS = stmt.executeQuery();\n\n            while (openVulnerabilitiesRS.next()) {\n                openVulnerabilities.add(new Integer(openVulnerabilitiesRS.getInt(\"vulnerabilityid\")));\n            }\n        } catch (SQLException ex) {\n            log.error(\"Error when querying database for open vulnerabilities.\");\n            log.error(ex.getLocalizedMessage(), ex);\n            return;\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                log.error(\"Could not close DB connection\", ex);\n            }\n        }\n\n        /*\n         * Perform a Nessus scan of the target IP address.  As each\n         * vulnerability is found, a new entry is put into the database\n\t * or the existing entry is updated.\n         */\n        Socket nessusSocket = null;\n        try {\n            nessusSocket = NessusConnectionFactory.getConnection(config.hostname, config.hostport);\n\n            if (nessusSocket == null) {\n                throw new IOException(\"Factory returned null connection\");\n            }\n\n            InputStream in = nessusSocket.getInputStream();\n            OutputStream out = nessusSocket.getOutputStream();\n\n            log.debug(\"Attached streams to the Nessus socket.\");\n\n            // Login to the server\n            out.write((NTP_VERSION_STRING + \"\\n\").getBytes());\n\n            log.debug(\"Sent NTP version string.\");\n\n            lines = readLines(in);\n\n            // Strip off the protocol/username prompt\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n                    log.debug(\"NTP string response: \" + line);\n                    if (line.indexOf(NTP_USERNAME_PROMPT) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Login to the server\n            out.write((config.username + \"\\n\").getBytes());\n\n            log.debug(\"Sent username string.\");\n\n            // Strip off the password prompt\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n                    log.debug(\"Username response: \" + line);\n                    if (line.indexOf(NTP_PASSWORD_PROMPT) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Login to the server\n            out.write((config.password + \"\\n\").getBytes());\n\n            log.debug(\"Sent password string.\");\n\n            // Strip off the rules list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Password response: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Strip off the preferences list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Preferences: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Strip off the rules list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Rules: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n\t\t}\n            }\n\n            /*\n             * Write the preferences list for the scan\n             * (which includes the list of plugins to execute\n             * against the target).\n             */\n            out.write(buildPreferencesString().getBytes());\n\n            log.debug(\"Sent preferences string.\");\n\n            // Strip off the PREFERENCES_ERRORS\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Preferences response: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found)\n                    lines = readLines(in);\n            }\n\n            /*\n             * I'm using the NEW_ATTACK directive, since I don't\n             * care about command strings getting too long (which\n             * you would use the LONG_ATTACK directive for).\n             */\n            \n            out.write((NTP_CLIENT_ENTITY + NTP_SEP + \"NEW_ATTACK\" + NTP_SEP + config.targetAddress.toString().replaceAll(\"/\", \"\") + NTP_SEP + NTP_CLIENT_ENTITY + \"\\n\").getBytes());\n//            out.write((NTP_CLIENT_ENTITY + NTP_SEP + \"NEW_ATTACK\" + NTP_SEP + config.targetAddress.toString() + NTP_SEP + NTP_CLIENT_ENTITY + \"\\n\").getBytes());\n\n            log.debug(\"Sent NEW_ATTACK directive against target: \" + config.targetAddress.toString());\n\n            // Read the response to the NEW_ATTACK\n            int returnCode = SCAN_SUCCESS;\n\n            while ((returnCode == SCAN_SUCCESS) || (returnCode == SCAN_NON_FATAL_ERROR)) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    log.debug(\"Nessus attack response: \" + line.replace('\\n', ' '));\n\n                    // Grep out any inappropriate messages\n                    if ((line.indexOf(\"the server killed it\") == -1)) {\n                        /*\n                         * This processing will update existing vulnerabilities\n                         * in the database and add new vulnerability entries\n                         * as the vulnerabilities are detected.\n                         */\n                        returnCode = processScanMessage(line);\n                    } else {\n                        log.error(\"Discarded inappropriate Nessus message: \" + line);\n                    }\n                }\n\n                // If the last read was successful, get more lines\n                if ((returnCode == SCAN_SUCCESS) || (returnCode == SCAN_NON_FATAL_ERROR)) {\n                    lines = readLines(in);\n                }\n            }\n\n            out.write(buildStopWholeTestString().getBytes());\n\n            /*\n             * If there were open vulnerabilities that were not reconfirmed\n             * during this scanning cycle, then mark them as resolved.\n             */\n            if (openVulnerabilities.size() > 0) {\n                try {\n                    conn = DataSourceFactory.getInstance().getConnection();\n                } catch (SQLException ex) {\n                    log.error(\"Could not open DB connection\", ex);\n                    return;\n                }\n                try {\n                    PreparedStatement stmt = conn.prepareStatement(RESOLVE_VULNERABILITY);\n\n                    Timestamp currentTime = new Timestamp(new java.util.Date().getTime());\n\n                    Iterator vuln = openVulnerabilities.iterator();\n                    while (vuln.hasNext()) {\n                        stmt.setTimestamp(1, currentTime);\n\n                        /*\n                         * If the scan ended because of a successful completion\n                         * and all plugins were executed (indicating that the\n                         * host WAS accessible), resolve the bug.\n                         */\n                        if ((returnCode == SCAN_COMPLETE) && (lastPlugin == totalPlugins)) {\n                            stmt.setTimestamp(2, currentTime);\n                        }\n                        // Otherwise, just leave the resolved field NULL\n                        else {\n                            stmt.setNull(2, Types.TIMESTAMP);\n                        }\n\n                        stmt.setInt(3, ((Integer) vuln.next()).intValue());\n\n                        stmt.executeUpdate();\n                    }\n                } catch (SQLException ex) {\n                    log.error(\"Error when querying database for open vulnerabilities.\");\n                    log.error(ex.getLocalizedMessage(), ex);\n                    return;\n                } finally {\n                    try {\n                        conn.close();\n                    } catch (SQLException ex) {\n                        log.error(\"Could not close DB connection\", ex);\n                    }\n                }\n            }\n\n            log.debug(\"Sent STOP_WHOLE_TEST directive against target \" + config.targetAddress.toString());\n        } catch (FifoQueueException ex) {\n            log.warn(ex, ex);\n        } catch (InterruptedException ex) {\n            log.warn(ex, ex);\n        } catch (IOException ex) {\n            log.warn(ex, ex);\n        } finally {\n            log.info(\"Releasing Nessus socket connection\");\n            if (nessusSocket != null) {\n                NessusConnectionFactory.releaseConnection(nessusSocket);\n\t    }\n        }\n\n        // Update the scheduler flags for this configuration\n        config.setScheduled(false);\n        config.setLastScanned(new java.util.Date());\n    }","id":73243,"modified_method":"public void run() {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        // Queue of the lines that are read from the Nessus socket\n        FifoQueue lines = null;\n        // Flag that lets us know if we've found what we're looking for\n        boolean found = false;\n        // DB connection; is connected and disconnected as necessary\n        Connection conn = null;\n\n        /*\n         * Grab the list of all current open vulnerabilities for the IP address.\n         * We'll use this list to resolve vulnerabilities that are not\n         * redetected.\n         */\n        try {\n            conn = DataSourceFactory.getInstance().getConnection();\n        } catch (SQLException ex) {\n            log.error(\"Could not open DB connection\", ex);\n            return;\n        }\n        try {\n            PreparedStatement stmt = conn.prepareStatement(SELECT_ALL_VULNERABILITIES);\n\n            stmt.setString(1, config.targetAddress.getHostAddress());\n            ResultSet openVulnerabilitiesRS = stmt.executeQuery();\n\n            while (openVulnerabilitiesRS.next()) {\n                openVulnerabilities.add(new Integer(openVulnerabilitiesRS.getInt(\"vulnerabilityid\")));\n            }\n        } catch (SQLException ex) {\n            log.error(\"Error when querying database for open vulnerabilities.\");\n            log.error(ex.getLocalizedMessage(), ex);\n            return;\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                log.error(\"Could not close DB connection\", ex);\n            }\n        }\n\n        /*\n         * Perform a Nessus scan of the target IP address.  As each\n         * vulnerability is found, a new entry is put into the database\n\t * or the existing entry is updated.\n         */\n        Socket nessusSocket = null;\n        try {\n            nessusSocket = NessusConnectionFactory.getConnection(config.hostname, config.hostport);\n\n            if (nessusSocket == null) {\n                throw new IOException(\"Factory returned null connection\");\n            }\n\n            InputStream in = nessusSocket.getInputStream();\n            OutputStream out = nessusSocket.getOutputStream();\n\n            log.debug(\"Attached streams to the Nessus socket.\");\n\n            // Login to the server\n            out.write((NTP_VERSION_STRING + \"\\n\").getBytes());\n\n            log.debug(\"Sent NTP version string.\");\n\n            lines = readLines(in);\n\n            // Strip off the protocol/username prompt\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n                    log.debug(\"NTP string response: \" + line);\n                    if (line.indexOf(NTP_USERNAME_PROMPT) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Login to the server\n            out.write((config.username + \"\\n\").getBytes());\n\n            log.debug(\"Sent username string.\");\n\n            // Strip off the password prompt\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n                    log.debug(\"Username response: \" + line);\n                    if (line.indexOf(NTP_PASSWORD_PROMPT) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Login to the server\n            out.write((config.password + \"\\n\").getBytes());\n\n            log.debug(\"Sent password string.\");\n\n            // Strip off the rules list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Password response: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Strip off the preferences list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Preferences: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Strip off the rules list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Rules: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n\t\t}\n            }\n\n            /*\n             * Write the preferences list for the scan\n             * (which includes the list of plugins to execute\n             * against the target).\n             */\n            out.write(buildPreferencesString().getBytes());\n\n            log.debug(\"Sent preferences string.\");\n\n            // Strip off the PREFERENCES_ERRORS\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Preferences response: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found)\n                    lines = readLines(in);\n            }\n\n            /*\n             * I'm using the NEW_ATTACK directive, since I don't\n             * care about command strings getting too long (which\n             * you would use the LONG_ATTACK directive for).\n             */\n            \n            //out.write((NTP_CLIENT_ENTITY + NTP_SEP + \"NEW_ATTACK\" + NTP_SEP + config.targetAddress.toString().replaceAll(\"/\", \"\") + NTP_SEP + NTP_CLIENT_ENTITY + \"\\n\").getBytes());\n//            out.write((NTP_CLIENT_ENTITY + NTP_SEP + \"NEW_ATTACK\" + NTP_SEP + config.targetAddress.toString().replaceAll(\"/\", \"\") + NTP_SEP + NTP_CLIENT_ENTITY + \"\\n\").getBytes());\n            out.write((NTP_CLIENT_ENTITY + NTP_SEP + \"NEW_ATTACK\" + NTP_SEP + config.targetAddress.getCanonicalHostName() + NTP_SEP + NTP_CLIENT_ENTITY + \"\\n\").getBytes());\n\n            log.debug(\"Sent NEW_ATTACK directive against target: \" + config.targetAddress.getCanonicalHostName());\n\n            // Read the response to the NEW_ATTACK\n            int returnCode = SCAN_SUCCESS;\n\n            while ((returnCode == SCAN_SUCCESS) || (returnCode == SCAN_NON_FATAL_ERROR)) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    log.debug(\"Nessus attack response: \" + line.replace('\\n', ' '));\n\n                    // Grep out any inappropriate messages\n                    if ((line.indexOf(\"the server killed it\") == -1)) {\n                        /*\n                         * This processing will update existing vulnerabilities\n                         * in the database and add new vulnerability entries\n                         * as the vulnerabilities are detected.\n                         */\n                        returnCode = processScanMessage(line);\n                    } else {\n                        log.error(\"Discarded inappropriate Nessus message: \" + line);\n                    }\n                }\n\n                // If the last read was successful, get more lines\n                if ((returnCode == SCAN_SUCCESS) || (returnCode == SCAN_NON_FATAL_ERROR)) {\n                    lines = readLines(in);\n                }\n            }\n\n            out.write(buildStopWholeTestString().getBytes());\n\n            /*\n             * If there were open vulnerabilities that were not reconfirmed\n             * during this scanning cycle, then mark them as resolved.\n             */\n            if (openVulnerabilities.size() > 0) {\n                try {\n                    conn = DataSourceFactory.getInstance().getConnection();\n                } catch (SQLException ex) {\n                    log.error(\"Could not open DB connection\", ex);\n                    return;\n                }\n                try {\n                    PreparedStatement stmt = conn.prepareStatement(RESOLVE_VULNERABILITY);\n\n                    Timestamp currentTime = new Timestamp(new java.util.Date().getTime());\n\n                    Iterator vuln = openVulnerabilities.iterator();\n                    while (vuln.hasNext()) {\n                        stmt.setTimestamp(1, currentTime);\n\n                        /*\n                         * If the scan ended because of a successful completion\n                         * and all plugins were executed (indicating that the\n                         * host WAS accessible), resolve the bug.\n                         */\n                        if ((returnCode == SCAN_COMPLETE) && (lastPlugin == totalPlugins)) {\n                            stmt.setTimestamp(2, currentTime);\n                        }\n                        // Otherwise, just leave the resolved field NULL\n                        else {\n                            stmt.setNull(2, Types.TIMESTAMP);\n                        }\n\n                        stmt.setInt(3, ((Integer) vuln.next()).intValue());\n\n                        stmt.executeUpdate();\n                    }\n                } catch (SQLException ex) {\n                    log.error(\"Error when querying database for open vulnerabilities.\");\n                    log.error(ex.getLocalizedMessage(), ex);\n                    return;\n                } finally {\n                    try {\n                        conn.close();\n                    } catch (SQLException ex) {\n                        log.error(\"Could not close DB connection\", ex);\n                    }\n                }\n            }\n\n            log.debug(\"Sent STOP_WHOLE_TEST directive against target \" + config.targetAddress.toString());\n        } catch (FifoQueueException ex) {\n            log.warn(ex, ex);\n        } catch (InterruptedException ex) {\n            log.warn(ex, ex);\n        } catch (IOException ex) {\n            log.warn(ex, ex);\n        } finally {\n            log.info(\"Releasing Nessus socket connection\");\n            if (nessusSocket != null) {\n                NessusConnectionFactory.releaseConnection(nessusSocket);\n\t    }\n        }\n\n        // Update the scheduler flags for this configuration\n        config.setScheduled(false);\n        config.setLastScanned(new java.util.Date());\n    }","commit_id":"db4ee9b44393ff3094c26c475ac8a35931008fb9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\t\n\t}","id":73244,"modified_method":"@Before\n    public void setUp() {\n        System.setProperty(\"opennms.startup.context\", \"classpath:/startup.xml\");\n    }","commit_id":"db4ee9b44393ff3094c26c475ac8a35931008fb9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public DistributedStatusHistoryModel createHistoryModel(\n            String locationName, String monitorId, String applicationName,\n            String timeSpan, String previousLocationName) {\n        List<String> errors = new LinkedList<String>();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions = m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        List<RelativeTimePeriod> periods = Arrays.asList(RelativeTimePeriod.getDefaultPeriods());\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        List<OnmsApplication> sortedApplications = new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications);\n\n        OnmsMonitoringLocationDefinition location;\n        if (locationName == null) {\n            location = locationDefinitions.get(0);\n        } else {\n            location = m_locationMonitorDao.findMonitoringLocationDefinition(locationName);\n            if (location == null) {\n                errors.add(\"Could not find location definition '\" + locationName + \"'\");\n                location = locationDefinitions.get(0);\n            }\n        }\n        \n        int monitorIdInt = -1;\n        \n        if (monitorId != null && monitorId.length() > 0) {\n            try {\n                monitorIdInt = WebSecurityUtils.safeParseInt(monitorId);\n            } catch (NumberFormatException e) {\n                errors.add(\"Monitor ID '\" + monitorId + \"' is not an integer\");\n            }\n        }\n\n        OnmsApplication application;\n        if (applicationName == null) {\n            application = sortedApplications.get(0);\n        } else {\n            application = m_applicationDao.findByName(applicationName);\n            if (application == null) {\n                errors.add(\"Could not find application '\" + applicationName + \"'\");\n                application = sortedApplications.get(0);\n            }\n        }\n        \n        Collection<OnmsLocationMonitor> monitors = m_locationMonitorDao.findByLocationDefinition(location);\n        List<OnmsLocationMonitor> sortedMonitors = new LinkedList<OnmsLocationMonitor>(monitors);\n        Collections.sort(sortedMonitors);\n\n        OnmsLocationMonitor monitor = null;\n        if (monitorIdInt != -1 && location.getName().equals(previousLocationName)) {\n            for (OnmsLocationMonitor m : sortedMonitors) {\n                if (m.getId().equals(monitorIdInt)) {\n                    monitor = m;\n                    break;\n                }\n            }\n        }\n        \n        if (monitor == null && sortedMonitors.size() > 0) {\n            monitor = sortedMonitors.get(0);\n        }\n        \n        RelativeTimePeriod period = RelativeTimePeriod.getPeriodByIdOrDefault(timeSpan);\n        \n        /*\n         * Initialize the heirarchy under the service so that we don't get\n         * a LazyInitializationException later when the JSP page is pulling\n         * data out of the model object.\n         */\n        Collection<OnmsMonitoredService> memberServices = m_monitoredServiceDao.findByApplication(application);\n        for (OnmsMonitoredService service : memberServices) {\n            m_locationMonitorDao.initialize(service.getIpInterface());\n            m_locationMonitorDao.initialize(service.getIpInterface().getNode());\n        }\n\n        Collection<OnmsMonitoredService> applicationMemberServices = m_monitoredServiceDao.findByApplication(application);\n        if (applicationMemberServices.size() == 0) {\n            errors.add(\"There are no services in the application '\" + applicationName + \"'\");\n        }\n        \n        DistributedStatusHistoryModel model = new DistributedStatusHistoryModel(locationDefinitions,\n                                                 sortedApplications,\n                                                 sortedMonitors,\n                                                 periods,\n                                                 location,\n                                                 application,\n                                                 applicationMemberServices,\n                                                 monitor,\n                                                 period,\n                                                 errors);\n        initializeGraphUrls(model);\n        return model;\n    }","id":73245,"modified_method":"public DistributedStatusHistoryModel createHistoryModel(\n            String locationName, String monitorId, String applicationName,\n            String timeSpan, String previousLocationName) {\n        List<String> errors = new LinkedList<String>();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions = m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        List<RelativeTimePeriod> periods = Arrays.asList(RelativeTimePeriod.getDefaultPeriods());\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        List<OnmsApplication> sortedApplications = new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications);\n\n        OnmsMonitoringLocationDefinition location = new OnmsMonitoringLocationDefinition();\n        if (locationName == null) {\n            if (!locationDefinitions.isEmpty()) {\n                location = locationDefinitions.get(0);\n            }\n        } else {\n            location = m_locationMonitorDao.findMonitoringLocationDefinition(locationName);\n            if (location == null) {\n                errors.add(\"Could not find location definition '\" + locationName + \"'\");\n                if (!locationDefinitions.isEmpty()) {\n                    location = locationDefinitions.get(0);\n                }\n            }\n        }\n        \n        int monitorIdInt = -1;\n        \n        if (monitorId != null && monitorId.length() > 0) {\n            try {\n                monitorIdInt = WebSecurityUtils.safeParseInt(monitorId);\n            } catch (NumberFormatException e) {\n                errors.add(\"Monitor ID '\" + monitorId + \"' is not an integer\");\n            }\n        }\n\n        OnmsApplication application = new OnmsApplication();\n        if (applicationName == null) {\n            if (!sortedApplications.isEmpty()) {\n                application = sortedApplications.get(0);\n            }\n        } else {\n            application = m_applicationDao.findByName(applicationName);\n            if (application == null) {\n                errors.add(\"Could not find application '\" + applicationName + \"'\");\n                if (!sortedApplications.isEmpty()) {\n                    application = sortedApplications.get(0);\n                }\n            }\n        }\n        \n        Collection<OnmsLocationMonitor> monitors = m_locationMonitorDao.findByLocationDefinition(location);\n        List<OnmsLocationMonitor> sortedMonitors = new LinkedList<OnmsLocationMonitor>(monitors);\n        Collections.sort(sortedMonitors);\n\n        OnmsLocationMonitor monitor = null;\n        if (monitorIdInt != -1 && location.getName().equals(previousLocationName)) {\n            for (OnmsLocationMonitor m : sortedMonitors) {\n                if (m.getId().equals(monitorIdInt)) {\n                    monitor = m;\n                    break;\n                }\n            }\n        }\n        \n        if (monitor == null && !sortedMonitors.isEmpty()) {\n            monitor = sortedMonitors.get(0);\n        }\n        \n        RelativeTimePeriod period = RelativeTimePeriod.getPeriodByIdOrDefault(timeSpan);\n        \n        /*\n         * Initialize the heirarchy under the service so that we don't get\n         * a LazyInitializationException later when the JSP page is pulling\n         * data out of the model object.\n         */\n        Collection<OnmsMonitoredService> memberServices = m_monitoredServiceDao.findByApplication(application);\n        for (OnmsMonitoredService service : memberServices) {\n            m_locationMonitorDao.initialize(service.getIpInterface());\n            m_locationMonitorDao.initialize(service.getIpInterface().getNode());\n        }\n\n        Collection<OnmsMonitoredService> applicationMemberServices = m_monitoredServiceDao.findByApplication(application);\n        if (applicationMemberServices.isEmpty()) {\n            errors.add(\"There are no services in the application '\" + applicationName + \"'\");\n        }\n        \n        DistributedStatusHistoryModel model = new DistributedStatusHistoryModel(locationDefinitions,\n                                                 sortedApplications,\n                                                 sortedMonitors,\n                                                 periods,\n                                                 location,\n                                                 application,\n                                                 applicationMemberServices,\n                                                 monitor,\n                                                 period,\n                                                 errors);\n        initializeGraphUrls(model);\n        return model;\n    }","commit_id":"9602fe1433a92867500a3d32607ba9e7ce7722d6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void run() {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        // Queue of the lines that are read from the Nessus socket\n        FifoQueue lines = null;\n        // Flag that lets us know if we've found what we're looking for\n        boolean found = false;\n        // DB connection; is connected and disconnected as necessary\n        Connection conn = null;\n\n        /*\n         * Grab the list of all current open vulnerabilities for the IP address.\n         * We'll use this list to resolve vulnerabilities that are not\n         * redetected.\n         */\n        try {\n            conn = DataSourceFactory.getInstance().getConnection();\n        } catch (SQLException ex) {\n            log.error(\"Could not open DB connection\", ex);\n            return;\n        }\n        try {\n            PreparedStatement stmt = conn.prepareStatement(SELECT_ALL_VULNERABILITIES);\n\n            stmt.setString(1, config.targetAddress.getHostAddress());\n            ResultSet openVulnerabilitiesRS = stmt.executeQuery();\n\n            while (openVulnerabilitiesRS.next()) {\n                openVulnerabilities.add(new Integer(openVulnerabilitiesRS.getInt(\"vulnerabilityid\")));\n            }\n        } catch (SQLException ex) {\n            log.error(\"Error when querying database for open vulnerabilities.\");\n            log.error(ex.getLocalizedMessage(), ex);\n            return;\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                log.error(\"Could not close DB connection\", ex);\n            }\n        }\n\n        /*\n         * Perform a Nessus scan of the target IP address.  As each\n         * vulnerability is found, a new entry is put into the database\n\t * or the existing entry is updated.\n         */\n        Socket nessusSocket = null;\n        try {\n            nessusSocket = NessusConnectionFactory.getConnection(config.hostname, config.hostport);\n\n            if (nessusSocket == null) {\n                throw new IOException(\"Factory returned null connection\");\n            }\n\n            InputStream in = nessusSocket.getInputStream();\n            OutputStream out = nessusSocket.getOutputStream();\n\n            log.debug(\"Attached streams to the Nessus socket.\");\n\n            // Login to the server\n            out.write((NTP_VERSION_STRING + \"\\n\").getBytes());\n\n            log.debug(\"Sent NTP version string.\");\n\n            lines = readLines(in);\n\n            // Strip off the protocol/username prompt\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n                    log.debug(\"NTP string response: \" + line);\n                    if (line.indexOf(NTP_USERNAME_PROMPT) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Login to the server\n            out.write((config.username + \"\\n\").getBytes());\n\n            log.debug(\"Sent username string.\");\n\n            // Strip off the password prompt\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n                    log.debug(\"Username response: \" + line);\n                    if (line.indexOf(NTP_PASSWORD_PROMPT) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Login to the server\n            out.write((config.password + \"\\n\").getBytes());\n\n            log.debug(\"Sent password string.\");\n\n            // Strip off the rules list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Password response: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Strip off the preferences list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Preferences: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Strip off the rules list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Rules: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n\t\t}\n            }\n\n            /*\n             * Write the preferences list for the scan\n             * (which includes the list of plugins to execute\n             * against the target).\n             */\n            out.write(buildPreferencesString().getBytes());\n\n            log.debug(\"Sent preferences string.\");\n\n            // Strip off the PREFERENCES_ERRORS\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Preferences response: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found)\n                    lines = readLines(in);\n            }\n\n            /*\n             * I'm using the NEW_ATTACK directive, since I don't\n             * care about command strings getting too long (which\n             * you would use the LONG_ATTACK directive for).\n             */\n            \n            out.write((NTP_CLIENT_ENTITY + NTP_SEP + \"NEW_ATTACK\" + NTP_SEP + config.targetAddress.toString().replaceAll(\"/\", \"\") + NTP_SEP + NTP_CLIENT_ENTITY + \"\\n\").getBytes());\n//            out.write((NTP_CLIENT_ENTITY + NTP_SEP + \"NEW_ATTACK\" + NTP_SEP + config.targetAddress.toString() + NTP_SEP + NTP_CLIENT_ENTITY + \"\\n\").getBytes());\n\n            log.debug(\"Sent NEW_ATTACK directive against target: \" + config.targetAddress.toString());\n\n            // Read the response to the NEW_ATTACK\n            int returnCode = SCAN_SUCCESS;\n\n            while ((returnCode == SCAN_SUCCESS) || (returnCode == SCAN_NON_FATAL_ERROR)) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    log.debug(\"Nessus attack response: \" + line.replace('\\n', ' '));\n\n                    // Grep out any inappropriate messages\n                    if ((line.indexOf(\"the server killed it\") == -1)) {\n                        /*\n                         * This processing will update existing vulnerabilities\n                         * in the database and add new vulnerability entries\n                         * as the vulnerabilities are detected.\n                         */\n                        returnCode = processScanMessage(line);\n                    } else {\n                        log.error(\"Discarded inappropriate Nessus message: \" + line);\n                    }\n                }\n\n                // If the last read was successful, get more lines\n                if ((returnCode == SCAN_SUCCESS) || (returnCode == SCAN_NON_FATAL_ERROR)) {\n                    lines = readLines(in);\n                }\n            }\n\n            out.write(buildStopWholeTestString().getBytes());\n\n            /*\n             * If there were open vulnerabilities that were not reconfirmed\n             * during this scanning cycle, then mark them as resolved.\n             */\n            if (openVulnerabilities.size() > 0) {\n                try {\n                    conn = DataSourceFactory.getInstance().getConnection();\n                } catch (SQLException ex) {\n                    log.error(\"Could not open DB connection\", ex);\n                    return;\n                }\n                try {\n                    PreparedStatement stmt = conn.prepareStatement(RESOLVE_VULNERABILITY);\n\n                    Timestamp currentTime = new Timestamp(new java.util.Date().getTime());\n\n                    Iterator vuln = openVulnerabilities.iterator();\n                    while (vuln.hasNext()) {\n                        stmt.setTimestamp(1, currentTime);\n\n                        /*\n                         * If the scan ended because of a successful completion\n                         * and all plugins were executed (indicating that the\n                         * host WAS accessible), resolve the bug.\n                         */\n                        if ((returnCode == SCAN_COMPLETE) && (lastPlugin == totalPlugins)) {\n                            stmt.setTimestamp(2, currentTime);\n                        }\n                        // Otherwise, just leave the resolved field NULL\n                        else {\n                            stmt.setNull(2, Types.TIMESTAMP);\n                        }\n\n                        stmt.setInt(3, ((Integer) vuln.next()).intValue());\n\n                        stmt.executeUpdate();\n                    }\n                } catch (SQLException ex) {\n                    log.error(\"Error when querying database for open vulnerabilities.\");\n                    log.error(ex.getLocalizedMessage(), ex);\n                    return;\n                } finally {\n                    try {\n                        conn.close();\n                    } catch (SQLException ex) {\n                        log.error(\"Could not close DB connection\", ex);\n                    }\n                }\n            }\n\n            log.debug(\"Sent STOP_WHOLE_TEST directive against target \" + config.targetAddress.toString());\n        } catch (FifoQueueException ex) {\n            log.warn(ex, ex);\n        } catch (InterruptedException ex) {\n            log.warn(ex, ex);\n        } catch (IOException ex) {\n            log.warn(ex, ex);\n        } finally {\n            log.info(\"Releasing Nessus socket connection\");\n            if (nessusSocket != null) {\n                NessusConnectionFactory.releaseConnection(nessusSocket);\n\t    }\n        }\n\n        // Update the scheduler flags for this configuration\n        config.setScheduled(false);\n        config.setLastScanned(new java.util.Date());\n    }","id":73246,"modified_method":"public void run() {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        // Queue of the lines that are read from the Nessus socket\n        FifoQueue lines = null;\n        // Flag that lets us know if we've found what we're looking for\n        boolean found = false;\n        // DB connection; is connected and disconnected as necessary\n        Connection conn = null;\n\n        /*\n         * Grab the list of all current open vulnerabilities for the IP address.\n         * We'll use this list to resolve vulnerabilities that are not\n         * redetected.\n         */\n        try {\n            conn = DataSourceFactory.getInstance().getConnection();\n        } catch (SQLException ex) {\n            log.error(\"Could not open DB connection\", ex);\n            return;\n        }\n        try {\n            PreparedStatement stmt = conn.prepareStatement(SELECT_ALL_VULNERABILITIES);\n\n            stmt.setString(1, config.targetAddress.getHostAddress());\n            ResultSet openVulnerabilitiesRS = stmt.executeQuery();\n\n            while (openVulnerabilitiesRS.next()) {\n                openVulnerabilities.add(new Integer(openVulnerabilitiesRS.getInt(\"vulnerabilityid\")));\n            }\n        } catch (SQLException ex) {\n            log.error(\"Error when querying database for open vulnerabilities.\");\n            log.error(ex.getLocalizedMessage(), ex);\n            return;\n        } finally {\n            try {\n                conn.close();\n            } catch (SQLException ex) {\n                log.error(\"Could not close DB connection\", ex);\n            }\n        }\n\n        /*\n         * Perform a Nessus scan of the target IP address.  As each\n         * vulnerability is found, a new entry is put into the database\n\t * or the existing entry is updated.\n         */\n        Socket nessusSocket = null;\n        try {\n            nessusSocket = NessusConnectionFactory.getConnection(config.hostname, config.hostport);\n\n            if (nessusSocket == null) {\n                throw new IOException(\"Factory returned null connection\");\n            }\n\n            InputStream in = nessusSocket.getInputStream();\n            OutputStream out = nessusSocket.getOutputStream();\n\n            log.debug(\"Attached streams to the Nessus socket.\");\n\n            // Login to the server\n            out.write((NTP_VERSION_STRING + \"\\n\").getBytes());\n\n            log.debug(\"Sent NTP version string.\");\n\n            lines = readLines(in);\n\n            // Strip off the protocol/username prompt\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n                    log.debug(\"NTP string response: \" + line);\n                    if (line.indexOf(NTP_USERNAME_PROMPT) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Login to the server\n            out.write((config.username + \"\\n\").getBytes());\n\n            log.debug(\"Sent username string.\");\n\n            // Strip off the password prompt\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n                    log.debug(\"Username response: \" + line);\n                    if (line.indexOf(NTP_PASSWORD_PROMPT) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Login to the server\n            out.write((config.password + \"\\n\").getBytes());\n\n            log.debug(\"Sent password string.\");\n\n            // Strip off the rules list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Password response: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Strip off the preferences list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Preferences: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n                }\n            }\n\n            // Strip off the rules list\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Rules: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    lines = readLines(in);\n\t\t}\n            }\n\n            /*\n             * Write the preferences list for the scan\n             * (which includes the list of plugins to execute\n             * against the target).\n             */\n            out.write(buildPreferencesString().getBytes());\n\n            log.debug(\"Sent preferences string.\");\n\n            // Strip off the PREFERENCES_ERRORS\n            found = false;\n            while (!found) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    // Do any necessary parsing\n                    log.debug(\"Preferences response: \" + line);\n\n                    if (line.indexOf((NTP_SEP + NTP_SERVER_ENTITY).trim()) != -1) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found)\n                    lines = readLines(in);\n            }\n\n            /*\n             * I'm using the NEW_ATTACK directive, since I don't\n             * care about command strings getting too long (which\n             * you would use the LONG_ATTACK directive for).\n             */\n            \n            //out.write((NTP_CLIENT_ENTITY + NTP_SEP + \"NEW_ATTACK\" + NTP_SEP + config.targetAddress.toString().replaceAll(\"/\", \"\") + NTP_SEP + NTP_CLIENT_ENTITY + \"\\n\").getBytes());\n//            out.write((NTP_CLIENT_ENTITY + NTP_SEP + \"NEW_ATTACK\" + NTP_SEP + config.targetAddress.toString().replaceAll(\"/\", \"\") + NTP_SEP + NTP_CLIENT_ENTITY + \"\\n\").getBytes());\n            out.write((NTP_CLIENT_ENTITY + NTP_SEP + \"NEW_ATTACK\" + NTP_SEP + config.targetAddress.getCanonicalHostName() + NTP_SEP + NTP_CLIENT_ENTITY + \"\\n\").getBytes());\n\n            log.debug(\"Sent NEW_ATTACK directive against target: \" + config.targetAddress.getCanonicalHostName());\n\n            // Read the response to the NEW_ATTACK\n            int returnCode = SCAN_SUCCESS;\n\n            while ((returnCode == SCAN_SUCCESS) || (returnCode == SCAN_NON_FATAL_ERROR)) {\n                while (lines.size() > 0) {\n                    String line = (String) lines.remove();\n\n                    log.debug(\"Nessus attack response: \" + line.replace('\\n', ' '));\n\n                    // Grep out any inappropriate messages\n                    if ((line.indexOf(\"the server killed it\") == -1)) {\n                        /*\n                         * This processing will update existing vulnerabilities\n                         * in the database and add new vulnerability entries\n                         * as the vulnerabilities are detected.\n                         */\n                        returnCode = processScanMessage(line);\n                    } else {\n                        log.error(\"Discarded inappropriate Nessus message: \" + line);\n                    }\n                }\n\n                // If the last read was successful, get more lines\n                if ((returnCode == SCAN_SUCCESS) || (returnCode == SCAN_NON_FATAL_ERROR)) {\n                    lines = readLines(in);\n                }\n            }\n\n            out.write(buildStopWholeTestString().getBytes());\n\n            /*\n             * If there were open vulnerabilities that were not reconfirmed\n             * during this scanning cycle, then mark them as resolved.\n             */\n            if (openVulnerabilities.size() > 0) {\n                try {\n                    conn = DataSourceFactory.getInstance().getConnection();\n                } catch (SQLException ex) {\n                    log.error(\"Could not open DB connection\", ex);\n                    return;\n                }\n                try {\n                    PreparedStatement stmt = conn.prepareStatement(RESOLVE_VULNERABILITY);\n\n                    Timestamp currentTime = new Timestamp(new java.util.Date().getTime());\n\n                    Iterator vuln = openVulnerabilities.iterator();\n                    while (vuln.hasNext()) {\n                        stmt.setTimestamp(1, currentTime);\n\n                        /*\n                         * If the scan ended because of a successful completion\n                         * and all plugins were executed (indicating that the\n                         * host WAS accessible), resolve the bug.\n                         */\n                        if ((returnCode == SCAN_COMPLETE) && (lastPlugin == totalPlugins)) {\n                            stmt.setTimestamp(2, currentTime);\n                        }\n                        // Otherwise, just leave the resolved field NULL\n                        else {\n                            stmt.setNull(2, Types.TIMESTAMP);\n                        }\n\n                        stmt.setInt(3, ((Integer) vuln.next()).intValue());\n\n                        stmt.executeUpdate();\n                    }\n                } catch (SQLException ex) {\n                    log.error(\"Error when querying database for open vulnerabilities.\");\n                    log.error(ex.getLocalizedMessage(), ex);\n                    return;\n                } finally {\n                    try {\n                        conn.close();\n                    } catch (SQLException ex) {\n                        log.error(\"Could not close DB connection\", ex);\n                    }\n                }\n            }\n\n            log.debug(\"Sent STOP_WHOLE_TEST directive against target \" + config.targetAddress.toString());\n        } catch (FifoQueueException ex) {\n            log.warn(ex, ex);\n        } catch (InterruptedException ex) {\n            log.warn(ex, ex);\n        } catch (IOException ex) {\n            log.warn(ex, ex);\n        } finally {\n            log.info(\"Releasing Nessus socket connection\");\n            if (nessusSocket != null) {\n                NessusConnectionFactory.releaseConnection(nessusSocket);\n\t    }\n        }\n\n        // Update the scheduler flags for this configuration\n        config.setScheduled(false);\n        config.setLastScanned(new java.util.Date());\n    }","commit_id":"9602fe1433a92867500a3d32607ba9e7ce7722d6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Build the preferences string with the appropriate plugins and safe_checks\n     * settings from the config file.\n     */\n    private String buildPreferencesString() {\n        String retval = NTP_CLIENT_ENTITY + NTP_SEP + \"PREFERENCES\" + NTP_SEP + \"\\n\" + \"plugin_set\" + NTP_SEP + pluginLists[config.scanLevel] + \"\\n\" + \"safe_checks\" + NTP_SEP;\n\n        if (safeChecks[config.scanLevel])\n            retval += \"yes\";\n        else\n            retval += \"no\";\n\n        retval += \"\\nmax_hosts\" + NTP_SEP + \"1\\n\" + \"ntp_short_status\" + NTP_SEP + \"yes\\n\" + NTP_SEP + NTP_CLIENT_ENTITY;\n\n        return retval;\n    }","id":73247,"modified_method":"/**\n     * Build the preferences string with the appropriate plugins and safe_checks\n     * settings from the config file.\n     */\n    private String buildPreferencesString() {\n        String retval = NTP_CLIENT_ENTITY + NTP_SEP + \"PREFERENCES\" + NTP_SEP + \"\\n\" + \"plugin_set\" + NTP_SEP + pluginLists[config.scanLevel] + \"\\n\" + \"safe_checks\" + NTP_SEP;\n\n        if (safeChecks[config.scanLevel])\n            retval += \"yes\";\n        else\n            retval += \"no\";\n\n        retval += \"\\nmax_hosts\" + NTP_SEP + \"1\\n\" + \"ntp_short_status\" + NTP_SEP + \"yes\\n\" +  \"reverse_lookup\" + NTP_SEP + \"yes\\n\" + NTP_SEP + NTP_CLIENT_ENTITY;\n\n        return retval;\n    }","commit_id":"9602fe1433a92867500a3d32607ba9e7ce7722d6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\t\n\t}","id":73248,"modified_method":"@Before\n    public void setUp() {\n        System.setProperty(\"opennms.startup.context\", \"classpath:/startup.xml\");\n    }","commit_id":"9602fe1433a92867500a3d32607ba9e7ce7722d6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tprotected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {\n\t\tManagedMap<RuntimeBeanReference, String> cronTaskMap = new ManagedMap<RuntimeBeanReference, String>();\n\t\tManagedMap<RuntimeBeanReference, String> fixedDelayTaskMap = new ManagedMap<RuntimeBeanReference, String>();\n\t\tManagedMap<RuntimeBeanReference, String> fixedRateTaskMap = new ManagedMap<RuntimeBeanReference, String>();\n\t\tNodeList childNodes = element.getChildNodes();\n\t\tfor (int i = 0; i < childNodes.getLength(); i++) {\n\t\t\tNode child = childNodes.item(i);\n\t\t\tif (!isScheduledElement(child, parserContext)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tElement taskElement = (Element) child;\n\t\t\tString ref = taskElement.getAttribute(\"ref\");\n\t\t\tString method = taskElement.getAttribute(\"method\");\n\t\t\t\n\t\t\t// Check that 'ref' and 'method' are specified\n\t\t\tif (!StringUtils.hasText(ref) || !StringUtils.hasText(method)) {\n\t\t\t\tparserContext.getReaderContext().error(\"Both 'ref' and 'method' are required\", taskElement);\n\t\t\t\t// Continue with the possible next task element\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tRuntimeBeanReference runnableBeanRef = new RuntimeBeanReference(\n\t\t\t\t\tcreateRunnableBean(ref, method, taskElement, parserContext));\n\t\t\tString cronAttribute = taskElement.getAttribute(\"cron\");\n\t\t\tif (StringUtils.hasText(cronAttribute)) {\n\t\t\t\tcronTaskMap.put(runnableBeanRef, cronAttribute);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString fixedDelayAttribute = taskElement.getAttribute(\"fixed-delay\");\n\t\t\t\tif (StringUtils.hasText(fixedDelayAttribute)) {\n\t\t\t\t\tfixedDelayTaskMap.put(runnableBeanRef, fixedDelayAttribute);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString fixedRateAttribute = taskElement.getAttribute(\"fixed-rate\");\n\t\t\t\t\tif (!StringUtils.hasText(fixedRateAttribute)) {\n\t\t\t\t\t\tparserContext.getReaderContext().error(\n\t\t\t\t\t\t\t\t\"One of 'cron', 'fixed-delay', or 'fixed-rate' is required\", taskElement);\n\t\t\t\t\t\t// Continue with the possible next task element\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfixedRateTaskMap.put(runnableBeanRef, fixedRateAttribute);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString schedulerRef = element.getAttribute(\"scheduler\");\n\t\tif (StringUtils.hasText(schedulerRef)) {\n\t\t\tbuilder.addPropertyReference(\"taskScheduler\", schedulerRef);\n\t\t}\n\t\tbuilder.addPropertyValue(\"cronTasks\", cronTaskMap);\n\t\tbuilder.addPropertyValue(\"fixedDelayTasks\", fixedDelayTaskMap);\n\t\tbuilder.addPropertyValue(\"fixedRateTasks\", fixedRateTaskMap);\n\t}","id":73249,"modified_method":"@Override\n\tprotected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {\n\t\tManagedMap<RuntimeBeanReference, String> cronTaskMap = new ManagedMap<RuntimeBeanReference, String>();\n\t\tManagedMap<RuntimeBeanReference, String> fixedDelayTaskMap = new ManagedMap<RuntimeBeanReference, String>();\n\t\tManagedMap<RuntimeBeanReference, String> fixedRateTaskMap = new ManagedMap<RuntimeBeanReference, String>();\n\t\tManagedMap<RuntimeBeanReference, RuntimeBeanReference> triggerTaskMap = new ManagedMap<RuntimeBeanReference, RuntimeBeanReference>();\n\t\tNodeList childNodes = element.getChildNodes();\n\t\tfor (int i = 0; i < childNodes.getLength(); i++) {\n\t\t\tNode child = childNodes.item(i);\n\t\t\tif (!isScheduledElement(child, parserContext)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tElement taskElement = (Element) child;\n\t\t\tString ref = taskElement.getAttribute(\"ref\");\n\t\t\tString method = taskElement.getAttribute(\"method\");\n\t\t\t\n\t\t\t// Check that 'ref' and 'method' are specified\n\t\t\tif (!StringUtils.hasText(ref) || !StringUtils.hasText(method)) {\n\t\t\t\tparserContext.getReaderContext().error(\"Both 'ref' and 'method' are required\", taskElement);\n\t\t\t\t// Continue with the possible next task element\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tRuntimeBeanReference runnableBeanRef = new RuntimeBeanReference(\n\t\t\t\t\tcreateRunnableBean(ref, method, taskElement, parserContext));\n\n\t\t\tString cronAttribute = taskElement.getAttribute(\"cron\");\n\t\t\tString fixedDelayAttribute = taskElement.getAttribute(\"fixed-delay\");\n\t\t\tString fixedRateAttribute = taskElement.getAttribute(\"fixed-rate\");\n\t\t\tString triggerAttribute = taskElement.getAttribute(\"trigger\");\n\n\t\t\tboolean hasCronAttribute = StringUtils.hasText(cronAttribute);\n\t\t\tboolean hasFixedDelayAttribute = StringUtils.hasText(fixedDelayAttribute);\n\t\t\tboolean hasFixedRateAttribute = StringUtils.hasText(fixedRateAttribute);\n\t\t\tboolean hasTriggerAttribute = StringUtils.hasText(triggerAttribute);\n\n\t\t\tif (!(hasCronAttribute | hasFixedDelayAttribute | hasFixedRateAttribute | hasTriggerAttribute)) {\n\t\t\t\tparserContext.getReaderContext().error(\n\t\t\t\t\t\t\"exactly one of the 'cron', 'fixed-delay', 'fixed-rate', or 'trigger' attributes is required\", taskElement);\n\t\t\t\t// Continue with the possible next task element\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (hasCronAttribute) {\n\t\t\t\tcronTaskMap.put(runnableBeanRef, cronAttribute);\n\t\t\t}\n\t\t\tif (hasFixedDelayAttribute) {\n\t\t\t\tfixedDelayTaskMap.put(runnableBeanRef, fixedDelayAttribute);\n\t\t\t}\n\t\t\tif (hasFixedRateAttribute) {\n\t\t\t\tfixedRateTaskMap.put(runnableBeanRef, fixedRateAttribute);\n\t\t\t}\n\t\t\tif (hasTriggerAttribute) {\n\t\t\t\ttriggerTaskMap.put(runnableBeanRef, new RuntimeBeanReference(triggerAttribute));\n\t\t\t}\n\t\t}\n\t\tString schedulerRef = element.getAttribute(\"scheduler\");\n\t\tif (StringUtils.hasText(schedulerRef)) {\n\t\t\tbuilder.addPropertyReference(\"taskScheduler\", schedulerRef);\n\t\t}\n\t\tbuilder.addPropertyValue(\"cronTasks\", cronTaskMap);\n\t\tbuilder.addPropertyValue(\"fixedDelayTasks\", fixedDelayTaskMap);\n\t\tbuilder.addPropertyValue(\"fixedRateTasks\", fixedRateTaskMap);\n\t\tbuilder.addPropertyValue(\"triggerTasks\", triggerTaskMap);\n\t}","commit_id":"72420c79cbaf1c0c625a4d38c01980b8db564ad3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public List getDependentAgents()\n    {\n        return Collections.EMPTY_LIST;\n    }","id":73250,"modified_method":"public List<Class<Agent>> getDependentAgents()\n    {\n        return Collections.emptyList();\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Setter for property 'loadJdmkAgent'.\n     *\n     * @param loadJdmkAgent Value to set for property 'loadJdmkAgent'.\n     */\n    public void setLoadJdmkAgent(boolean loadJdmkAgent)\n    {\n        this.loadJdmkAgent = loadJdmkAgent;\n    }","id":73251,"modified_method":"public void setLoadJdmkAgent(boolean loadJdmkAgent)\n    {\n        this.loadJdmkAgent = loadJdmkAgent;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Getter for property 'port'.\n     *\n     * @return Value for property 'port'.\n     */\n    public String getPort()\n    {\n        return port;\n    }","id":73252,"modified_method":"public String getPort()\n    {\n        return port;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Method used to perform any initialisation work. If a fatal error occurs during\n     * initialisation an <code>InitialisationException<\/code> should be thrown,\n     * causing the Mule instance to shutdown. If the error is recoverable, say by\n     * retrying to connect, a <code>RecoverableException<\/code> should be thrown.\n     * There is no guarantee that by throwing a Recoverable exception that the Mule\n     * instance will not shut down.\n     *\n     * @throws org.mule.api.lifecycle.InitialisationException\n     *          if a fatal error occurs\n     *          causing the Mule instance to shutdown\n     */\n    public void initialise() throws InitialisationException\n    {\n        try\n        {\n            Agent agent = createRmiAgent();\n            if (!isAgentRegistered(agent))\n            {\n                muleContext.getRegistry().registerAgent(agent);\n            }\n            agent = createJmxAgent();\n            if (!isAgentRegistered(agent))\n            {\n                muleContext.getRegistry().registerAgent(agent);\n            }\n            agent = createLog4jAgent();\n            if (!isAgentRegistered(agent))\n            {\n                muleContext.getRegistry().registerAgent(agent);\n            }\n            agent = createJmxNotificationAgent();\n            if (!isAgentRegistered(agent))\n            {\n                muleContext.getRegistry().registerAgent(agent);\n            }\n            if (loadJdmkAgent)\n            {\n                agent = createJdmkAgent();\n                if (!isAgentRegistered(agent))\n                {\n                    muleContext.getRegistry().registerAgent(agent);\n                }\n            }\n\n            if (loadMx4jAgent)\n            {\n                agent = createMx4jAgent();\n                if (!isAgentRegistered(agent))\n                {\n                    muleContext.getRegistry().registerAgent(agent);\n                }\n            }\n\n            if (loadProfilerAgent)\n            {\n                agent = createProfilerAgent();\n                if (!isAgentRegistered(agent))\n                {\n                    muleContext.getRegistry().registerAgent(agent);\n                }\n            }\n\n            // remove this agent once it has registered the other agents\n            //TODO RM* this currently does nothing!!!\n            muleContext.getRegistry().unregisterAgent(name);\n        }\n        catch (MuleException e)\n        {\n            throw new InitialisationException(e, this);\n        }\n    }","id":73253,"modified_method":"/**\n     * Method used to perform any initialisation work. If a fatal error occurs during\n     * initialisation an <code>InitialisationException<\/code> should be thrown,\n     * causing the Mule instance to shutdown. If the error is recoverable, say by\n     * retrying to connect, a <code>RecoverableException<\/code> should be thrown.\n     * There is no guarantee that by throwing a Recoverable exception that the Mule\n     * instance will not shut down.\n     *\n     * @throws org.mule.api.lifecycle.InitialisationException\n     *          if a fatal error occurs\n     *          causing the Mule instance to shutdown\n     */\n    public void initialise() throws InitialisationException\n    {\n        try\n        {\n            Agent agent = createRmiAgent();\n            if (!isAgentRegistered(agent))\n            {\n                muleContext.getRegistry().registerAgent(agent);\n            }\n            \n            agent = createJmxAgent();\n            if (!isAgentRegistered(agent))\n            {\n                muleContext.getRegistry().registerAgent(agent);\n            }\n            \n            if (loadLog4jAgent)\n            {\n                agent = createLog4jAgent();\n                if (!isAgentRegistered(agent))\n                {\n                    muleContext.getRegistry().registerAgent(agent);\n                }\n            }\n            \n            agent = createJmxNotificationAgent();\n            if (!isAgentRegistered(agent))\n            {\n                muleContext.getRegistry().registerAgent(agent);\n            }\n            \n            if (loadJdmkAgent)\n            {\n                agent = createJdmkAgent();\n                if (!isAgentRegistered(agent))\n                {\n                    muleContext.getRegistry().registerAgent(agent);\n                }\n            }\n\n            if (loadMx4jAgent)\n            {\n                agent = createMx4jAgent();\n                if (!isAgentRegistered(agent))\n                {\n                    muleContext.getRegistry().registerAgent(agent);\n                }\n            }\n\n            if (loadProfilerAgent)\n            {\n                agent = createProfilerAgent();\n                if (!isAgentRegistered(agent))\n                {\n                    muleContext.getRegistry().registerAgent(agent);\n                }\n            }\n\n            // remove this agent once it has registered the other agents\n            //TODO RM* this currently does nothing!!!\n            muleContext.getRegistry().unregisterAgent(name);\n        }\n        catch (MuleException e)\n        {\n            throw new InitialisationException(e, this);\n        }\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Getter for property 'loadJdmkAgent'.\n     *\n     * @return Value for property 'loadJdmkAgent'.\n     */\n    public boolean isLoadJdmkAgent()\n    {\n        return loadJdmkAgent;\n    }","id":73254,"modified_method":"public boolean isLoadJdmkAgent()\n    {\n        return loadJdmkAgent;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"public JmxAgent createJmxAgent()\n    {\n        JmxAgent agent = new JmxAgent();\n        String remotingUri = null;\n        if (StringUtils.isBlank(host) && StringUtils.isBlank(port))\n        {\n            remotingUri = JmxAgent.DEFAULT_REMOTING_URI;\n        }\n        else if (StringUtils.isNotBlank(host))\n        {\n            // enable support for multi-NIC servers by configuring\n            // a custom RMIClientSocketFactory\n            Map props = agent.getConnectorServerProperties();\n            Map mergedProps = new HashMap(props.size() + 1);\n            mergedProps.putAll(props);\n            RMIClientSocketFactory factory = new FixedHostRmiClientSocketFactory(host);\n            mergedProps.put(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE,\n                    factory);\n            agent.setConnectorServerProperties(mergedProps);\n        }\n\n        // if defaults haven't been used\n        if (StringUtils.isBlank(remotingUri))\n        {\n            remotingUri =\n                    MessageFormat.format(\"service:jmx:rmi:///jndi/rmi://{0}:{1}/server\",\n                                         StringUtils.defaultString(host, DEFAULT_HOST),\n                                         StringUtils.defaultString(port, DEFAULT_PORT));\n        }\n\n        if (credentials != null && !credentials.isEmpty())\n        {\n            agent.setCredentials(credentials);\n        }\n        agent.setConnectorServerUrl(remotingUri);\n        return agent;\n    }","id":73255,"modified_method":"public JmxAgent createJmxAgent()\n    {\n        JmxAgent agent = new JmxAgent();\n        String remotingUri = null;\n        if (StringUtils.isBlank(host) && StringUtils.isBlank(port))\n        {\n            remotingUri = JmxAgent.DEFAULT_REMOTING_URI;\n        }\n        else if (StringUtils.isNotBlank(host))\n        {\n            // enable support for multi-NIC servers by configuring\n            // a custom RMIClientSocketFactory\n            Map<String, Object> props = agent.getConnectorServerProperties();\n            Map<String, Object> mergedProps = new HashMap<String, Object>(props.size() + 1);\n            mergedProps.putAll(props);\n            \n            RMIClientSocketFactory factory = new FixedHostRmiClientSocketFactory(host);\n            mergedProps.put(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE, factory);\n            agent.setConnectorServerProperties(mergedProps);\n        }\n\n        // if defaults haven't been used\n        if (StringUtils.isBlank(remotingUri))\n        {\n            remotingUri = MessageFormat.format(\"service:jmx:rmi:///jndi/rmi://{0}:{1}/server\",\n                StringUtils.defaultString(host, DEFAULT_HOST),\n                StringUtils.defaultString(port, DEFAULT_PORT));\n        }\n\n        if (credentials != null && !credentials.isEmpty())\n        {\n            agent.setCredentials(credentials);\n        }\n        agent.setConnectorServerUrl(remotingUri);\n        return agent;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Getter for property 'host'.\n     *\n     * @return Value for property 'host'.\n     */\n    public String getHost()\n    {\n        return host;\n    }","id":73256,"modified_method":"public String getHost()\n    {\n        return host;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Setter for property 'credentials'.\n     *\n     * @param credentials Value to set for property 'credentials'.\n     */\n    public void setCredentials(final Map credentials)\n    {\n        this.credentials = credentials;\n    }","id":73257,"modified_method":"public void setCredentials(Map<String, Object> credentials)\n    {\n        this.credentials = credentials;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Getter for property 'loadProfilerAgent'.\n     * @return Value for property 'loadProfilerAgent'.\n     */\n    public boolean isLoadProfilerAgent()\n    {\n        return loadProfilerAgent;\n    }","id":73258,"modified_method":"public boolean isLoadProfilerAgent()\n    {\n        return loadProfilerAgent;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Setter for property 'loadProfilerAgent'.\n     * @param loadProfilerAgent Value to set for property 'loadProfilerAgent'.\n     */\n    public void setLoadProfilerAgent(boolean loadProfilerAgent)\n    {\n        this.loadProfilerAgent = loadProfilerAgent;\n    }","id":73259,"modified_method":"public void setLoadProfilerAgent(boolean loadProfilerAgent)\n    {\n        this.loadProfilerAgent = loadProfilerAgent;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Setter for property 'port'.\n     *\n     * @param port Value to set for property 'port'.\n     */\n    public void setPort(final String port)\n    {\n        this.port = port;\n    }","id":73260,"modified_method":"public void setPort(final String port)\n    {\n        this.port = port;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Setter for property 'loadMx4jAgent'.\n     *\n     * @param loadMx4jAgent Value to set for property 'loadMx4jAgent'.\n     */\n    public void setLoadMx4jAgent(boolean loadMx4jAgent)\n    {\n        this.loadMx4jAgent = loadMx4jAgent;\n    }","id":73261,"modified_method":"public void setLoadMx4jAgent(boolean loadMx4jAgent)\n    {\n        this.loadMx4jAgent = loadMx4jAgent;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Getter for property 'loadMx4jAgent'.\n     *\n     * @return Value for property 'loadMx4jAgent'.\n     */\n    public boolean isLoadMx4jAgent()\n    {\n        return loadMx4jAgent;\n    }","id":73262,"modified_method":"public boolean isLoadMx4jAgent()\n    {\n        return loadMx4jAgent;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Setter for property 'host'.\n     *\n     * @param host Value to set for property 'host'.\n     */\n    public void setHost(final String host)\n    {\n        this.host = host;\n    }","id":73263,"modified_method":"public void setHost(final String host)\n    {\n        this.host = host;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Getter for property 'jmxSupportFactory'.\n     *\n     * @return Value for property 'jmxSupportFactory'.\n     */\n    public JmxSupportFactory getJmxSupportFactory()\n    {\n        return jmxSupportFactory;\n    }","id":73264,"modified_method":"public JmxSupportFactory getJmxSupportFactory()\n    {\n        return jmxSupportFactory;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"public JmxAgent()\n    {\n        super(\"jmx-agent\");\n        connectorServerProperties = new HashMap(DEFAULT_CONNECTOR_SERVER_PROPERTIES);\n    }","id":73265,"modified_method":"public JmxAgent()\n    {\n        super(\"jmx-agent\");\n        connectorServerProperties = new HashMap<String, Object>(DEFAULT_CONNECTOR_SERVER_PROPERTIES);\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void start() throws MuleException\n    {\n        try\n        {\n            logger.info(\"Creating and starting JMX agent connector Server\");\n            if (connectorServerUrl != null)\n            {\n                JMXServiceURL url = new JMXServiceURL(connectorServerUrl);\n                if (connectorServerProperties == null)\n                {\n                    connectorServerProperties = new HashMap(DEFAULT_CONNECTOR_SERVER_PROPERTIES);\n                }\n                // TODO custom authenticator may have its own security config,\n                // refactor\n                if (!credentials.isEmpty())\n                {\n                    JMXAuthenticator jmxAuthenticator = (JMXAuthenticator)ClassUtils.instanciateClass(DEFAULT_JMX_AUTHENTICATOR);\n                    // TODO support for custom authenticators\n                    ((SimplePasswordJmxAuthenticator)jmxAuthenticator).setCredentials(credentials);\n                    connectorServerProperties.put(JMXConnectorServer.AUTHENTICATOR, jmxAuthenticator);\n                }\n                connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(url,\n                    connectorServerProperties, mBeanServer);\n                connectorServer.start();\n            }\n        }\n        catch (ExportException e)\n        {\n            throw new JmxManagementException(CoreMessages.failedToStart(\"Jmx Agent\"), e);\n        }\n        catch (Exception e)\n        {\n            throw new JmxManagementException(CoreMessages.failedToStart(\"Jmx Agent\"), e);\n        }\n    }","id":73266,"modified_method":"public void start() throws MuleException\n    {\n        try\n        {\n            logger.info(\"Creating and starting JMX agent connector Server\");\n            if (connectorServerUrl != null)\n            {\n                JMXServiceURL url = new JMXServiceURL(connectorServerUrl);\n                if (connectorServerProperties == null)\n                {\n                    connectorServerProperties = new HashMap<String, Object>(DEFAULT_CONNECTOR_SERVER_PROPERTIES);\n                }\n                // TODO custom authenticator may have its own security config,\n                // refactor\n                if (!credentials.isEmpty())\n                {\n                    JMXAuthenticator jmxAuthenticator = (JMXAuthenticator)ClassUtils.instanciateClass(DEFAULT_JMX_AUTHENTICATOR);\n                    // TODO support for custom authenticators\n                    ((SimplePasswordJmxAuthenticator)jmxAuthenticator).setCredentials(credentials);\n                    connectorServerProperties.put(JMXConnectorServer.AUTHENTICATOR, jmxAuthenticator);\n                }\n                connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(url,\n                    connectorServerProperties, mBeanServer);\n                connectorServer.start();\n            }\n        }\n        catch (ExportException e)\n        {\n            throw new JmxManagementException(CoreMessages.failedToStart(\"Jmx Agent\"), e);\n        }\n        catch (Exception e)\n        {\n            throw new JmxManagementException(CoreMessages.failedToStart(\"Jmx Agent\"), e);\n        }\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Setter for property 'credentials'.\n     *\n     * @param newCredentials Value to set for property 'credentials'.\n     */\n    public void setCredentials(final Map newCredentials)\n    {\n        this.credentials.clear();\n        if (newCredentials != null && !newCredentials.isEmpty())\n        {\n            this.credentials.putAll(newCredentials);\n        }\n    }","id":73267,"modified_method":"public void setCredentials(Map<String, Object> newCredentials)\n    {\n        this.credentials.clear();\n        if (newCredentials != null && !newCredentials.isEmpty())\n        {\n            this.credentials.putAll(newCredentials);\n        }\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Setter for property 'connectorServerProperties'. Set to {@code null} to use defaults ({@link\n     * #DEFAULT_CONNECTOR_SERVER_PROPERTIES}). Pass in an empty map to use no parameters. Passing a non-empty map will\n     * replace defaults.\n     *\n     * @param connectorServerProperties Value to set for property 'connectorServerProperties'.\n     */\n    public void setConnectorServerProperties(Map connectorServerProperties)\n    {\n        this.connectorServerProperties = connectorServerProperties;\n    }","id":73268,"modified_method":"/**\n     * Setter for property 'connectorServerProperties'. Set to {@code null} to use defaults ({@link\n     * #DEFAULT_CONNECTOR_SERVER_PROPERTIES}). Pass in an empty map to use no parameters. \n     * Passing a non-empty map will replace defaults.\n     *\n     * @param connectorServerProperties Value to set for property 'connectorServerProperties'.\n     */\n    public void setConnectorServerProperties(Map<String, Object> connectorServerProperties)\n    {\n        this.connectorServerProperties = connectorServerProperties;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Setter for property 'jmxSupportFactory'.\n     *\n     * @param jmxSupportFactory Value to set for property 'jmxSupportFactory'.\n     */\n    public void setJmxSupportFactory(JmxSupportFactory jmxSupportFactory)\n    {\n        this.jmxSupportFactory = jmxSupportFactory;\n    }","id":73269,"modified_method":"public void setJmxSupportFactory(JmxSupportFactory jmxSupportFactory)\n    {\n        this.jmxSupportFactory = jmxSupportFactory;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Getter for property 'connectorServerProperties'.\n     *\n     * @return Value for property 'connectorServerProperties'.\n     */\n    public Map getConnectorServerProperties()\n    {\n        return connectorServerProperties;\n    }","id":73270,"modified_method":"public Map<String, Object> getConnectorServerProperties()\n    {\n        return connectorServerProperties;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * @see org.mule.api.agent.Agent#getDescription()\n     */\n    public String getDescription()\n    {\n        if (connectorServerUrl != null)\n        {\n            return name + \": \" + connectorServerUrl;\n        }\n        else\n        {\n            return \"JMX Agent\";\n        }\n    }","id":73271,"modified_method":"@Override\n    public String getDescription()\n    {\n        if (connectorServerUrl != null)\n        {\n            return name + \": \" + connectorServerUrl;\n        }\n        else\n        {\n            return \"JMX Agent\";\n        }\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerBeanDefinitionParser(\"jmx-server\", new JmxAgentDefinitionParser());\n        registerBeanDefinitionParser(\"mBeanServer\", new ObjectFactoryWrapper(\"MBeanServerObjectFactory\"));\n        registerBeanDefinitionParser(\"credentials\", new ChildMapDefinitionParser(\"credentials\"));\n        registerBeanDefinitionParser(\"jmx-log4j\", new AgentDefinitionParser(Log4jAgent.class));\n        registerBeanDefinitionParser(\"jmx-mx4j-adaptor\", new AgentDefinitionParser(Mx4jAgent.class));\n        registerBeanDefinitionParser(\"jmx-notifications\", new AgentDefinitionParser(JmxServerNotificationAgent.class));\n        registerMuleBeanDefinitionParser(\"jmx-default-config\", new AgentDefinitionParser(DefaultJmxSupportAgent.class)).addAlias(\"registerMx4jAdapter\", \"loadMx4jAgent\");\n        registerBeanDefinitionParser(\"level-mapping\", new ChildMapEntryDefinitionParser(\"levelMappings\", \"severity\", \"eventId\"));\n\n        // these two are identical?\n        registerBeanDefinitionParser(\"log4j-notifications\", new AgentDefinitionParser(Log4jNotificationLoggerAgent.class));\n        registerBeanDefinitionParser(\"chainsaw-notifications\", new AgentDefinitionParser(Log4jNotificationLoggerAgent.class));\n\n        registerBeanDefinitionParser(\"publish-notifications\", new AgentDefinitionParser(EndpointNotificationLoggerAgent.class));\n        registerBeanDefinitionParser(\"rmi-server\", new AgentDefinitionParser(RmiRegistryAgent.class));\n        registerBeanDefinitionParser(\"yourkit-profiler\", new AgentDefinitionParser(YourKitProfilerAgent.class));\n\n        registerBeanDefinitionParser(\"outbound-endpoint\", new GenericEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n\n\n        //This gets processed by the jmx-server parser\n        registerIgnoredElement(\"connector-server\");\n    }","id":73272,"modified_method":"public void init()\n    {\n        registerBeanDefinitionParser(\"jmx-server\", new JmxAgentDefinitionParser());\n        registerBeanDefinitionParser(\"mBeanServer\", new ObjectFactoryWrapper(\"MBeanServerObjectFactory\"));\n        registerBeanDefinitionParser(\"credentials\", new ChildMapDefinitionParser(\"credentials\"));\n        registerBeanDefinitionParser(\"jmx-log4j\", new AgentDefinitionParser(Log4jAgent.class));\n        registerBeanDefinitionParser(\"jmx-mx4j-adaptor\", new AgentDefinitionParser(Mx4jAgent.class));\n        registerBeanDefinitionParser(\"jmx-notifications\", new AgentDefinitionParser(JmxServerNotificationAgent.class));\n\n        MuleDefinitionParserConfiguration defaultJmxParser = registerMuleBeanDefinitionParser(\"jmx-default-config\", new AgentDefinitionParser(DefaultJmxSupportAgent.class));\n        defaultJmxParser.addAlias(\"registerMx4jAdapter\", \"loadMx4jAgent\");\n        defaultJmxParser.addAlias(\"registerLog4j\", \"loadLog4jAgent\");\n        \n        registerBeanDefinitionParser(\"level-mapping\", new ChildMapEntryDefinitionParser(\"levelMappings\", \"severity\", \"eventId\"));\n\n        // these two are identical?\n        registerBeanDefinitionParser(\"log4j-notifications\", new AgentDefinitionParser(Log4jNotificationLoggerAgent.class));\n        registerBeanDefinitionParser(\"chainsaw-notifications\", new AgentDefinitionParser(Log4jNotificationLoggerAgent.class));\n\n        registerBeanDefinitionParser(\"publish-notifications\", new AgentDefinitionParser(EndpointNotificationLoggerAgent.class));\n        registerBeanDefinitionParser(\"rmi-server\", new AgentDefinitionParser(RmiRegistryAgent.class));\n        registerBeanDefinitionParser(\"yourkit-profiler\", new AgentDefinitionParser(YourKitProfilerAgent.class));\n\n        registerBeanDefinitionParser(\"outbound-endpoint\", new GenericEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n\n        // This gets processed by the jmx-server parser\n        registerIgnoredElement(\"connector-server\");\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Setter for property 'credentials'.\n     *\n     * @param newCredentials Value to set for property 'credentials'.\n     */\n    public void setCredentials (final Map newCredentials)\n    {\n        this.credentials.clear();\n        if (newCredentials == null || newCredentials.isEmpty())\n        {\n            logger.warn(\"Credentials cache has been purged, remote access will no longer be available\");\n        }\n        else\n        {\n            this.credentials.putAll(newCredentials);\n        }\n    }","id":73273,"modified_method":"public void setCredentials (Map<String, Object> newCredentials)\n    {\n        this.credentials.clear();\n        if (newCredentials == null || newCredentials.isEmpty())\n        {\n            logger.warn(\"Credentials cache has been purged, remote access will no longer be available\");\n        }\n        else\n        {\n            this.credentials.putAll(newCredentials);\n        }\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public Subject authenticate (Object authToken)\n    {\n        if (authToken == null)\n        {\n            throw new SecurityException(\"No authentication token available\");\n        }\n        if (!(authToken instanceof String[]) || ((String[]) authToken).length != 2)\n        {\n            throw new SecurityException(\"Unsupported credentials format\");\n        }\n\n        String[] authentication = (String[]) authToken;\n\n        String username = StringUtils.defaultString(authentication[0]);\n        String password = StringUtils.defaultString(authentication[1]);\n\n        if (!credentials.containsKey(username))\n        {\n            throw new SecurityException(\"Unauthenticated user: \" + username);\n        }\n\n        if (!password.equals(ObjectUtils.toString(credentials.get(username))))\n        {\n            throw new SecurityException(\"Invalid password\");\n        }\n\n        Set principals = new HashSet();\n        principals.add(new JMXPrincipal(username));\n        return new Subject(true, principals, Collections.EMPTY_SET, Collections.EMPTY_SET);\n    }","id":73274,"modified_method":"public Subject authenticate (Object authToken)\n    {\n        if (authToken == null)\n        {\n            throw new SecurityException(\"No authentication token available\");\n        }\n        if (!(authToken instanceof String[]) || ((String[]) authToken).length != 2)\n        {\n            throw new SecurityException(\"Unsupported credentials format\");\n        }\n\n        String[] authentication = (String[]) authToken;\n\n        String username = StringUtils.defaultString(authentication[0]);\n        String password = StringUtils.defaultString(authentication[1]);\n\n        if (!credentials.containsKey(username))\n        {\n            throw new SecurityException(\"Unauthenticated user: \" + username);\n        }\n\n        if (!password.equals(ObjectUtils.toString(credentials.get(username))))\n        {\n            throw new SecurityException(\"Invalid password\");\n        }\n\n        Set<Principal> principals = new HashSet<Principal>();\n        principals.add(new JMXPrincipal(username));\n        return new Subject(true, principals, Collections.EMPTY_SET, Collections.EMPTY_SET);\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testNullOrEmptyCredentialsConfigured()\n    {\n        final Map credentials = Collections.EMPTY_MAP;\n\n        // shouldn't fail\n        authenticator.setCredentials(credentials);\n\n        try\n        {\n            authenticator.authenticate(VALID_AUTH_TOKEN);\n            fail(\"Should've thrown an exception\");\n        }\n        catch (SecurityException e)\n        {\n            // expected\n        }\n\n        // shouldn't fail\n        authenticator.setCredentials(null);\n\n        try\n        {\n            authenticator.authenticate(VALID_AUTH_TOKEN);\n            fail(\"Should've thrown an exception\");\n        }\n        catch (SecurityException e)\n        {\n            // expected\n        }\n\n    }","id":73275,"modified_method":"public void testNullOrEmptyCredentialsConfigured()\n    {\n        Map<String, Object> credentials = Collections.emptyMap();\n\n        // shouldn't fail\n        authenticator.setCredentials(credentials);\n\n        try\n        {\n            authenticator.authenticate(VALID_AUTH_TOKEN);\n            fail(\"Should've thrown an exception\");\n        }\n        catch (SecurityException e)\n        {\n            // expected\n        }\n\n        // shouldn't fail\n        authenticator.setCredentials(null);\n\n        try\n        {\n            authenticator.authenticate(VALID_AUTH_TOKEN);\n            fail(\"Should've thrown an exception\");\n        }\n        catch (SecurityException e)\n        {\n            // expected\n        }\n\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testSuccessfulAuthentication()\n    {\n        Map credentials = getValidCredentials();\n\n        authenticator.setCredentials(credentials);\n\n        Subject subject = authenticator.authenticate(VALID_AUTH_TOKEN);\n        assertNotNull(subject);\n        assertTrue(subject.isReadOnly());\n\n        final Set publicCredentials = subject.getPublicCredentials();\n        assertNotNull(publicCredentials);\n        assertEquals(0, publicCredentials.size());\n\n        final Set privateCredentials = subject.getPrivateCredentials();\n        assertNotNull(privateCredentials);\n        assertEquals(0, privateCredentials.size());\n\n        final Set principals = subject.getPrincipals();\n        assertNotNull(principals);\n        assertEquals(1, principals.size());\n\n        final Object ref = principals.iterator().next();\n        assertTrue(ref instanceof JMXPrincipal);\n\n        final JMXPrincipal jmxPrincipal = (JMXPrincipal) ref;\n        final String name = jmxPrincipal.getName();\n        assertNotNull(name);\n        assertEquals(VALID_AUTH_TOKEN[0], name);\n    }","id":73276,"modified_method":"public void testSuccessfulAuthentication()\n    {\n        Map<String, Object> credentials = getValidCredentials();\n\n        authenticator.setCredentials(credentials);\n\n        Subject subject = authenticator.authenticate(VALID_AUTH_TOKEN);\n        assertNotNull(subject);\n        assertTrue(subject.isReadOnly());\n\n        Set<Object> publicCredentials = subject.getPublicCredentials();\n        assertNotNull(publicCredentials);\n        assertEquals(0, publicCredentials.size());\n\n        Set<Object> privateCredentials = subject.getPrivateCredentials();\n        assertNotNull(privateCredentials);\n        assertEquals(0, privateCredentials.size());\n\n        Set<Principal> principals = subject.getPrincipals();\n        assertNotNull(principals);\n        assertEquals(1, principals.size());\n\n        Object ref = principals.iterator().next();\n        assertTrue(ref instanceof JMXPrincipal);\n\n        JMXPrincipal jmxPrincipal = (JMXPrincipal) ref;\n        String name = jmxPrincipal.getName();\n        assertNotNull(name);\n        assertEquals(VALID_AUTH_TOKEN[0], name);\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Map getValidCredentials ()\n    {\n        final Map credentials = new HashMap(1);\n        credentials.put(VALID_AUTH_TOKEN[0], VALID_AUTH_TOKEN[1]);\n\n        return credentials;\n    }","id":73277,"modified_method":"protected Map<String, Object> getValidCredentials ()\n    {\n        Map<String, Object> credentials = new HashMap<String, Object>(1);\n        credentials.put(VALID_AUTH_TOKEN[0], VALID_AUTH_TOKEN[1]);\n\n        return credentials;\n    }","commit_id":"dca4a0aed864499a056cf93c85f98669f5eb0e8f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerIgnoredElement(\"mule\");\n        registerIgnoredElement(\"description\");\n\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"global-property\", new GlobalPropertyDefinitionParser());\n        registerBeanDefinitionParser(\"default-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-receiver-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-service-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_SERVICE_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"threading-profile\", new ThreadingProfileDefinitionParser(\"threadingProfile\", MuleProperties.OBJECT_DEFAULT_SERVICE_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-service-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultServiceExceptionStrategy.class));\n        registerBeanDefinitionParser(\"commit-transaction\", new ExceptionTXFilterDefinitionParser(\"commitTxFilter\"));\n        registerBeanDefinitionParser(\"rollback-transaction\", new ExceptionTXFilterDefinitionParser(\"rollbackTxFilter\"));\n        registerBeanDefinitionParser(\"custom-agent\", new DefaultNameMuleOrphanDefinitionParser());        \n\n        registerBeanDefinitionParser(\"default-connector-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new ChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n        registerMuleBeanDefinitionParser(\"notifications\", new NamedDefinitionParser(MuleProperties.OBJECT_NOTIFICATION_MANAGER)).addAlias(\"dynamic\", \"notificationDynamic\");\n        registerBeanDefinitionParser(\"notification\", new NotificationDefinitionParser());\n        registerBeanDefinitionParser(\"disable-notification\", new NotificationDisableDefinitionParser());\n        registerMuleBeanDefinitionParser(\"notification-listener\", new ChildDefinitionParser(\"allListenerSubscriptionPair\", ListenerSubscriptionPair.class)).addAlias(\"ref\", \"listener\").addReference(\"listener\");\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"dispatcherThreadingProfile\", MuleProperties.OBJECT_DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"receiverThreadingProfile\", MuleProperties.OBJECT_DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new MuleOrphanDefinitionParser(true));\n\n        //Transformer elements\n\n        registerBeanDefinitionParser(\"transformer\", new MessageProcessorRefDefinitionParser());\n\n        registerBeanDefinitionParser(\"custom-transformer\", new MessageProcessorDefinitionParser());\n        registerBeanDefinitionParser(\"auto-transformer\", new MessageProcessorDefinitionParser(AutoTransformer.class));\n        registerBeanDefinitionParser(\"message-properties-transformer\", new MessagePropertiesTransformerDefinitionParser());\n\n        registerBeanDefinitionParser(\"expression-transformer\", new MessageProcessorDefinitionParser(ExpressionTransformer.class));\n        registerBeanDefinitionParser(\"return-argument\", new ChildDefinitionParser(\"argument\", ExpressionArgument.class));\n\n        registerBeanDefinitionParser(\"bean-builder-transformer\", new MessageProcessorDefinitionParser(BeanBuilderTransformer.class));\n        registerBeanDefinitionParser(\"bean-property\", new ChildDefinitionParser(\"argument\", ExpressionArgument.class));\n\n        registerBeanDefinitionParser(\"base64-encoder-transformer\", new MessageProcessorDefinitionParser(Base64Encoder.class));\n        registerBeanDefinitionParser(\"base64-decoder-transformer\", new MessageProcessorDefinitionParser(Base64Decoder.class));\n\n        registerBeanDefinitionParser(\"xml-entity-encoder-transformer\", new MessageProcessorDefinitionParser(XmlEntityEncoder.class));\n        registerBeanDefinitionParser(\"xml-entity-decoder-transformer\", new MessageProcessorDefinitionParser(XmlEntityDecoder.class));\n        registerBeanDefinitionParser(\"gzip-compress-transformer\", new MessageProcessorDefinitionParser(GZipCompressTransformer.class));\n        registerBeanDefinitionParser(\"gzip-uncompress-transformer\", new MessageProcessorDefinitionParser(GZipUncompressTransformer.class));\n        registerBeanDefinitionParser(\"encrypt-transformer\", new MessageProcessorDefinitionParser(EncryptionTransformer.class));\n        registerBeanDefinitionParser(\"decrypt-transformer\", new MessageProcessorDefinitionParser(DecryptionTransformer.class));\n        registerBeanDefinitionParser(\"byte-array-to-hex-string-transformer\", new MessageProcessorDefinitionParser(ByteArrayToHexString.class));\n        registerBeanDefinitionParser(\"hex-string-to-byte-array-transformer\", new MessageProcessorDefinitionParser(HexStringToByteArray.class));\n\n        registerBeanDefinitionParser(\"byte-array-to-object-transformer\", new MessageProcessorDefinitionParser(ByteArrayToObject.class));\n        registerBeanDefinitionParser(\"object-to-byte-array-transformer\", new MessageProcessorDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"object-to-string-transformer\", new MessageProcessorDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"byte-array-to-serializable-transformer\", new MessageProcessorDefinitionParser(ByteArrayToSerializable.class));\n        registerBeanDefinitionParser(\"serializable-to-byte-array-transformer\", new MessageProcessorDefinitionParser(SerializableToByteArray.class));\n        registerBeanDefinitionParser(\"byte-array-to-string-transformer\", new MessageProcessorDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"string-to-byte-array-transformer\", new MessageProcessorDefinitionParser(ObjectToByteArray.class));\n\n        registerBeanDefinitionParser(\"append-string-transformer\", new MessageProcessorDefinitionParser(StringAppendTransformer.class));\n\n        registerBeanDefinitionParser(\"map-to-bean-transformer\", new MessageProcessorDefinitionParser(MapToBean.class));\n        registerBeanDefinitionParser(\"bean-to-map-transformer\", new MessageProcessorDefinitionParser(BeanToMap.class));\n\n        //Transaction Managers\n        registerBeanDefinitionParser(\"custom-transaction-manager\", new TransactionManagerDefinitionParser());\n        registerBeanDefinitionParser(\"jndi-transaction-manager\", new TransactionManagerDefinitionParser(GenericTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"weblogic-transaction-manager\", new TransactionManagerDefinitionParser(WeblogicTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jboss-transaction-manager\", new TransactionManagerDefinitionParser(JBossTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jrun-transaction-manager\", new TransactionManagerDefinitionParser(JRunTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"resin-transaction-manager\", new TransactionManagerDefinitionParser(Resin3TransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"websphere-transaction-manager\", new TransactionManagerDefinitionParser(WebsphereTransactionManagerLookupFactory.class));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"inbound-endpoint\", new ChildEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"outbound-endpoint\", new ChildEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"custom-transaction\", new TransactionDefinitionParser());\n        registerBeanDefinitionParser(\"xa-transaction\", new TransactionDefinitionParser(XaTransactionFactory.class));\n        \n        // Message Processors\n        registerBeanDefinitionParser(\"processor\", new MessageProcessorRefDefinitionParser());\n        registerBeanDefinitionParser(\"custom-processor\", new MessageProcessorDefinitionParser());        \n        registerBeanDefinitionParser(\"composite-processor\", new CompositeMessageProcessorDefinitionParser());        \n        registerBeanDefinitionParser(\"response\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"message-filter\", new MessageProcessorDefinitionParser(MessageFilter.class, true)).addAlias(\"messageProcessor\", \"unacceptedMessageProcessor\");\n        \n        // Message Sources\n        // TODO MULE-4987\n        // registerBeanDefinitionParser(\"custom-source\", new ChildDefinitionParser(\"messageSource\", null, MessageSource.class));        \n        registerBeanDefinitionParser(\"composite-source\", new ChildDefinitionParser(\"messageSource\", CompositeMessageSourceFactoryBean.class));        \n\n        // Models\n        registerBeanDefinitionParser(\"model\", new ModelDefinitionParser());\n        registerBeanDefinitionParser(\"seda-model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n\n        registerBeanDefinitionParser(\"entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", DefaultEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"legacy-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", LegacyEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"custom-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\"));\n\n        registerBeanDefinitionParser(\"custom-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\"));\n        registerBeanDefinitionParser(\"callable-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"property-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", MethodHeaderPropertyEntryPointResolver.class)).addAlias(\"property\", \"methodProperty\");\n        registerBeanDefinitionParser(\"method-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ExplicitMethodEntryPointResolver.class));\n        registerBeanDefinitionParser(\"reflection-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ReflectionEntryPointResolver.class));\n        registerBeanDefinitionParser(\"no-arguments-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", NoArgumentsEntryPointResolver.class));\n        registerBeanDefinitionParser(\"array-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ArrayEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"include-entry-point\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"exclude-entry-point\", new ParentDefinitionParser()).addAlias(\"method\", \"ignoredMethod\");\n        registerMuleBeanDefinitionParser(\"exclude-object-methods\", new IgnoreObjectMethodsDefinitionParser());\n\n        // Services\n        registerBeanDefinitionParser(\"seda-service\", new ServiceDefinitionParser(SedaService.class));\n        registerBeanDefinitionParser(\"service\", new ServiceDefinitionParser(SedaService.class));\n        registerBeanDefinitionParser(\"custom-service\", new ServiceDefinitionParser());\n        \n        // Flow Constructs\n        registerBeanDefinitionParser(\"flow\", new FlowDefinitionParser());\n        registerBeanDefinitionParser(\"simple-service\", new SimpleServiceDefinitionParser());\n\n        // Components\n        registerBeanDefinitionParser(\"component\", new ComponentDelegatingDefinitionParser(DefaultJavaComponent.class));\n        registerBeanDefinitionParser(\"pooled-component\", new ComponentDelegatingDefinitionParser(PooledJavaComponent.class));\n\n        registerMuleBeanDefinitionParser(\"binding\", new BindingDefinitionParser(\"bindingCollection.routers\", DefaultInterfaceBinding.class)).addCollection(\"bindingCollection.routers\");\n\n        // Simple Components\n        registerBeanDefinitionParser(\"pass-through-component\", new ComponentDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"log-component\", new SimpleComponentDefinitionParser(SimpleCallableJavaComponent.class, LogComponent.class));\n        registerBeanDefinitionParser(\"null-component\", new SimpleComponentDefinitionParser(SimpleCallableJavaComponent.class, NullComponent.class));\n        registerBeanDefinitionParser(\"static-component\", new StaticComponentDefinitionParser());        \n        registerIgnoredElement(\"return-data\"); // Handled by StaticComponentDefinitionParser\n\n        // We need to use DefaultJavaComponent for the echo component because some tests invoke EchoComponent with method name and therefore we need an entry point resolver\n        registerBeanDefinitionParser(\"echo-component\", new SimpleComponentDefinitionParser(DefaultJavaComponent.class, EchoComponent.class));\n\n        // Object Factories\n        registerBeanDefinitionParser(\"singleton-object\", new ObjectFactoryDefinitionParser(SingletonObjectFactory.class, \"objectFactory\"));\n        registerBeanDefinitionParser(\"prototype-object\", new ObjectFactoryDefinitionParser(PrototypeObjectFactory.class, \"objectFactory\"));\n        registerBeanDefinitionParser(\"spring-object\", new ObjectFactoryDefinitionParser(SpringBeanLookup.class, \"objectFactory\"));\n\n        // Life-cycle Adapters Factories\n        registerBeanDefinitionParser(\"custom-lifecycle-adapter-factory\", new ChildDefinitionParser(\"lifecycleAdapterFactory\"));\n\n        //Stores\n        registerBeanDefinitionParser(\"in-memory-store\", new ChildDefinitionParser(\"store\", InMemoryObjectStore.class));\n        registerBeanDefinitionParser(\"simple-text-file-store\", new ChildDefinitionParser(\"store\", TextFileObjectStore.class));\n\n        //Routers\n        registerBeanDefinitionParser(\"inbound\", new ChildDefinitionParser(\"messageSource\", ServiceCompositeMessageSource.class, true));\n        registerBeanDefinitionParser(\"outbound\", new ChildDefinitionParser(\"outboundRouter\", DefaultOutboundRouterCollection.class, true));\n        registerBeanDefinitionParser(\"async-reply\", new ChildDefinitionParser(\"asyncReplyMessageSource\", ServiceAsyncReplyCompositeMessageSource.class, true));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"forwarding-router\", new InboundRouterDefinitionParser(ForwardingConsumer.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new InboundRouterDefinitionParser(IdempotentMessageFilter.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new InboundRouterDefinitionParser(IdempotentSecureHashMessageFilter.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new InboundRouterDefinitionParser(MessageFilter.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new InboundRouterDefinitionParser(WireTap.class));\n        registerBeanDefinitionParser(\"custom-correlation-aggregator-router\", new InboundRouterDefinitionParser());\n        registerBeanDefinitionParser(\"collection-aggregator-router\", new InboundRouterDefinitionParser(SimpleCollectionAggregator.class));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new InboundRouterDefinitionParser(MessageChunkAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new InboundRouterDefinitionParser(Resequencer.class));\n        registerBeanDefinitionParser(\"custom-inbound-router\", new InboundRouterDefinitionParser(null));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"pass-through-router\", new RouterDefinitionParser(OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"recipient-list-exception-based-router\", new RouterDefinitionParser(ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(ListMessageSplitter.class));\n        registerBeanDefinitionParser(\"expression-splitter-router\", new RouterDefinitionParser(ExpressionMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(StaticRecipientList.class));\n        registerBeanDefinitionParser(\"expression-recipient-list-router\", new RouterDefinitionParser(ExpressionRecipientList.class));\n        registerBeanDefinitionParser(\"recipients\", new ChildListDefinitionParser(\"recipients\"));\n        registerBeanDefinitionParser(\"custom-outbound-router\", new RouterDefinitionParser(null));\n        registerBeanDefinitionParser(\"reply-to\", new EndpointRefParser(\"replyTo\"));\n\n        //Response Routers\n        registerBeanDefinitionParser(\"custom-async-reply-router\", new InboundRouterDefinitionParser(null));\n        registerBeanDefinitionParser(\"single-async-reply-router\", new InboundRouterDefinitionParser(NullMessageProcessor.class));\n        registerBeanDefinitionParser(\"collection-async-reply-router\", new InboundRouterDefinitionParser(SimpleCollectionAggregator.class));\n\n        //Message Info Mappings\n        registerBeanDefinitionParser(\"expression-message-info-mapping\", new ChildDefinitionParser(\"messageInfoMapping\", ExpressionMessageInfoMapping.class));\n        registerBeanDefinitionParser(\"custom-message-info-mapping\", new ChildDefinitionParser(\"messageInfoMapping\"));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"logging-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", LoggingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerMuleBeanDefinitionParser(\"filter\", new ParentDefinitionParser()).addAlias(\"ref\", \"filter\");\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser(AndFilter.class));\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser(OrFilter.class));\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser(NotFilter.class));\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser(RegExFilter.class));\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser(ExceptionTypeFilter.class));\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser(MessagePropertyFilter.class));\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser(PayloadTypeFilter.class));\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser(WildcardFilter.class));\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser(EqualsFilter.class));\n        registerBeanDefinitionParser(\"expression-filter\", new FilterDefinitionParser(ExpressionFilter.class));\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Utils / Standard Types\n        registerMuleBeanDefinitionParser(\"properties\", new ChildMapDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"property\", new ChildMapEntryDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"add-message-properties\", new ChildMapDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"add-message-property\", new ChildMapEntryDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"rename-message-property\", new ChildMapEntryDefinitionParser(\"renameProperties\")).addCollection(\"renameProperties\");\n        registerBeanDefinitionParser(\"delete-message-property\", new ChildListEntryDefinitionParser(\"deleteProperties\", ChildMapEntryDefinitionParser.KEY));\n        registerMuleBeanDefinitionParser(\"jndi-provider-properties\", new ChildMapDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerMuleBeanDefinitionParser(\"jndi-provider-property\", new ChildMapEntryDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerBeanDefinitionParser(\"environment\", new ChildMapDefinitionParser(\"environment\"));\n        registerBeanDefinitionParser(\"expression\", new ChildDefinitionParser(\"expression\", ExpressionConfig.class));\n\n        //Security\n        registerMuleBeanDefinitionParser(\"security-manager\", new NamedDefinitionParser(MuleProperties.OBJECT_SECURITY_MANAGER)).addIgnored(\"type\").addIgnored(\"name\");\n        registerBeanDefinitionParser(\"custom-security-provider\", new NameTransferDefinitionParser(\"providers\"));\n        registerMuleBeanDefinitionParser(\"custom-encryption-strategy\", new NameTransferDefinitionParser(\"encryptionStrategies\")).addAlias(\"strategy\", \"encryptionStrategy\");\n        registerBeanDefinitionParser(\"password-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", PasswordBasedEncryptionStrategy.class));\n        registerMuleBeanDefinitionParser(\"secret-key-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", SecretKeyEncryptionStrategy.class)).registerPreProcessor(new CheckExclusiveAttributes(new String[][]{new String[]{\"key\"}, new String[]{\"keyFactory-ref\"}}));\n        registerBeanDefinitionParser(\"encryption-security-filter\", new ChildDefinitionParser(\"securityFilter\", MuleEncryptionEndpointSecurityFilter.class));\n        registerBeanDefinitionParser(\"custom-security-filter\", new ChildDefinitionParser(\"securityFilter\"));\n        //Interceptors\n        registerMuleBeanDefinitionParser(\"interceptor-stack\", new InterceptorStackDefinitionParser());\n        registerBeanDefinitionParser(\"custom-interceptor\", new InterceptorDefinitionParser());\n        registerBeanDefinitionParser(\"timer-interceptor\", new InterceptorDefinitionParser(TimerInterceptor.class));\n        registerBeanDefinitionParser(\"logging-interceptor\", new InterceptorDefinitionParser(LoggingInterceptor.class));\n    }","id":73278,"modified_method":"public void init()\n    {\n        registerIgnoredElement(\"mule\");\n        registerIgnoredElement(\"description\");\n\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"global-property\", new GlobalPropertyDefinitionParser());\n        registerBeanDefinitionParser(\"default-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-receiver-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-service-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_SERVICE_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"threading-profile\", new ThreadingProfileDefinitionParser(\"threadingProfile\", MuleProperties.OBJECT_DEFAULT_SERVICE_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-service-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultServiceExceptionStrategy.class));\n        registerBeanDefinitionParser(\"commit-transaction\", new ExceptionTXFilterDefinitionParser(\"commitTxFilter\"));\n        registerBeanDefinitionParser(\"rollback-transaction\", new ExceptionTXFilterDefinitionParser(\"rollbackTxFilter\"));\n        registerBeanDefinitionParser(\"custom-agent\", new DefaultNameMuleOrphanDefinitionParser());        \n\n        registerBeanDefinitionParser(\"default-connector-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new ChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n        registerMuleBeanDefinitionParser(\"notifications\", new NamedDefinitionParser(MuleProperties.OBJECT_NOTIFICATION_MANAGER)).addAlias(\"dynamic\", \"notificationDynamic\");\n        registerBeanDefinitionParser(\"notification\", new NotificationDefinitionParser());\n        registerBeanDefinitionParser(\"disable-notification\", new NotificationDisableDefinitionParser());\n        registerMuleBeanDefinitionParser(\"notification-listener\", new ChildDefinitionParser(\"allListenerSubscriptionPair\", ListenerSubscriptionPair.class)).addAlias(\"ref\", \"listener\").addReference(\"listener\");\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"dispatcherThreadingProfile\", MuleProperties.OBJECT_DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"receiverThreadingProfile\", MuleProperties.OBJECT_DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new MuleOrphanDefinitionParser(true));\n\n        //Transformer elements\n\n        registerBeanDefinitionParser(\"transformer\", new MessageProcessorRefDefinitionParser());\n\n        registerBeanDefinitionParser(\"custom-transformer\", new MessageProcessorDefinitionParser());\n        registerBeanDefinitionParser(\"auto-transformer\", new MessageProcessorDefinitionParser(AutoTransformer.class));\n        registerBeanDefinitionParser(\"message-properties-transformer\", new MessagePropertiesTransformerDefinitionParser());\n\n        registerBeanDefinitionParser(\"expression-transformer\", new MessageProcessorDefinitionParser(ExpressionTransformer.class));\n        registerBeanDefinitionParser(\"return-argument\", new ChildDefinitionParser(\"argument\", ExpressionArgument.class));\n\n        registerBeanDefinitionParser(\"bean-builder-transformer\", new MessageProcessorDefinitionParser(BeanBuilderTransformer.class));\n        registerBeanDefinitionParser(\"bean-property\", new ChildDefinitionParser(\"argument\", ExpressionArgument.class));\n\n        registerBeanDefinitionParser(\"base64-encoder-transformer\", new MessageProcessorDefinitionParser(Base64Encoder.class));\n        registerBeanDefinitionParser(\"base64-decoder-transformer\", new MessageProcessorDefinitionParser(Base64Decoder.class));\n\n        registerBeanDefinitionParser(\"xml-entity-encoder-transformer\", new MessageProcessorDefinitionParser(XmlEntityEncoder.class));\n        registerBeanDefinitionParser(\"xml-entity-decoder-transformer\", new MessageProcessorDefinitionParser(XmlEntityDecoder.class));\n        registerBeanDefinitionParser(\"gzip-compress-transformer\", new MessageProcessorDefinitionParser(GZipCompressTransformer.class));\n        registerBeanDefinitionParser(\"gzip-uncompress-transformer\", new MessageProcessorDefinitionParser(GZipUncompressTransformer.class));\n        registerBeanDefinitionParser(\"encrypt-transformer\", new MessageProcessorDefinitionParser(EncryptionTransformer.class));\n        registerBeanDefinitionParser(\"decrypt-transformer\", new MessageProcessorDefinitionParser(DecryptionTransformer.class));\n        registerBeanDefinitionParser(\"byte-array-to-hex-string-transformer\", new MessageProcessorDefinitionParser(ByteArrayToHexString.class));\n        registerBeanDefinitionParser(\"hex-string-to-byte-array-transformer\", new MessageProcessorDefinitionParser(HexStringToByteArray.class));\n\n        registerBeanDefinitionParser(\"byte-array-to-object-transformer\", new MessageProcessorDefinitionParser(ByteArrayToObject.class));\n        registerBeanDefinitionParser(\"object-to-byte-array-transformer\", new MessageProcessorDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"object-to-string-transformer\", new MessageProcessorDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"byte-array-to-serializable-transformer\", new MessageProcessorDefinitionParser(ByteArrayToSerializable.class));\n        registerBeanDefinitionParser(\"serializable-to-byte-array-transformer\", new MessageProcessorDefinitionParser(SerializableToByteArray.class));\n        registerBeanDefinitionParser(\"byte-array-to-string-transformer\", new MessageProcessorDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"string-to-byte-array-transformer\", new MessageProcessorDefinitionParser(ObjectToByteArray.class));\n\n        registerBeanDefinitionParser(\"append-string-transformer\", new MessageProcessorDefinitionParser(StringAppendTransformer.class));\n\n        registerBeanDefinitionParser(\"map-to-bean-transformer\", new MessageProcessorDefinitionParser(MapToBean.class));\n        registerBeanDefinitionParser(\"bean-to-map-transformer\", new MessageProcessorDefinitionParser(BeanToMap.class));\n\n        //Transaction Managers\n        registerBeanDefinitionParser(\"custom-transaction-manager\", new TransactionManagerDefinitionParser());\n        registerBeanDefinitionParser(\"jndi-transaction-manager\", new TransactionManagerDefinitionParser(GenericTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"weblogic-transaction-manager\", new TransactionManagerDefinitionParser(WeblogicTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jboss-transaction-manager\", new TransactionManagerDefinitionParser(JBossTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jrun-transaction-manager\", new TransactionManagerDefinitionParser(JRunTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"resin-transaction-manager\", new TransactionManagerDefinitionParser(Resin3TransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"websphere-transaction-manager\", new TransactionManagerDefinitionParser(WebsphereTransactionManagerLookupFactory.class));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"inbound-endpoint\", new ChildEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"outbound-endpoint\", new ChildEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"custom-transaction\", new TransactionDefinitionParser());\n        registerBeanDefinitionParser(\"xa-transaction\", new TransactionDefinitionParser(XaTransactionFactory.class));\n        \n        // Message Processors\n        registerBeanDefinitionParser(\"processor\", new MessageProcessorRefDefinitionParser());\n        registerBeanDefinitionParser(\"custom-processor\", new MessageProcessorDefinitionParser());        \n        registerBeanDefinitionParser(\"composite-processor\", new CompositeMessageProcessorDefinitionParser());        \n        registerBeanDefinitionParser(\"response\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"message-filter\", new MessageProcessorDefinitionParser(MessageFilter.class, true)).addAlias(\"messageProcessor\", \"unacceptedMessageProcessor\");\n        \n        // Message Sources\n        // TODO MULE-4987\n        // registerBeanDefinitionParser(\"custom-source\", new ChildDefinitionParser(\"messageSource\", null, MessageSource.class));        \n        registerBeanDefinitionParser(\"composite-source\", new ChildDefinitionParser(\"messageSource\", CompositeMessageSourceFactoryBean.class));        \n\n        // Models\n        registerBeanDefinitionParser(\"model\", new ModelDefinitionParser());\n        registerBeanDefinitionParser(\"seda-model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n\n        registerBeanDefinitionParser(\"entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", DefaultEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"legacy-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", LegacyEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"custom-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\"));\n\n        registerBeanDefinitionParser(\"custom-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\"));\n        registerBeanDefinitionParser(\"callable-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"property-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", MethodHeaderPropertyEntryPointResolver.class)).addAlias(\"property\", \"methodProperty\");\n        registerBeanDefinitionParser(\"method-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ExplicitMethodEntryPointResolver.class));\n        registerBeanDefinitionParser(\"reflection-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ReflectionEntryPointResolver.class));\n        registerBeanDefinitionParser(\"no-arguments-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", NoArgumentsEntryPointResolver.class));\n        registerBeanDefinitionParser(\"array-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ArrayEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"include-entry-point\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"exclude-entry-point\", new ParentDefinitionParser()).addAlias(\"method\", \"ignoredMethod\");\n        registerMuleBeanDefinitionParser(\"exclude-object-methods\", new IgnoreObjectMethodsDefinitionParser());\n\n        // Services\n        registerBeanDefinitionParser(\"seda-service\", new ServiceDefinitionParser(SedaService.class));\n        registerBeanDefinitionParser(\"service\", new ServiceDefinitionParser(SedaService.class));\n        registerBeanDefinitionParser(\"custom-service\", new ServiceDefinitionParser());\n        \n        // Flow Constructs\n        registerBeanDefinitionParser(\"flow\", new FlowDefinitionParser());\n        registerBeanDefinitionParser(\"simple-service\", new SimpleServiceDefinitionParser());\n\n        // Components\n        registerBeanDefinitionParser(\"component\", new ComponentDelegatingDefinitionParser(DefaultJavaComponent.class));\n        registerBeanDefinitionParser(\"pooled-component\", new ComponentDelegatingDefinitionParser(PooledJavaComponent.class));\n\n        registerMuleBeanDefinitionParser(\"binding\", new BindingDefinitionParser(\"bindingCollection.routers\", DefaultInterfaceBinding.class)).addCollection(\"bindingCollection.routers\");\n\n        // Simple Components\n        registerBeanDefinitionParser(\"pass-through-component\", new ComponentDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"log-component\", new SimpleComponentDefinitionParser(SimpleCallableJavaComponent.class, LogComponent.class));\n        registerBeanDefinitionParser(\"null-component\", new SimpleComponentDefinitionParser(SimpleCallableJavaComponent.class, NullComponent.class));\n        registerBeanDefinitionParser(\"static-component\", new StaticComponentDefinitionParser());        \n        registerIgnoredElement(\"return-data\"); // Handled by StaticComponentDefinitionParser\n\n        // We need to use DefaultJavaComponent for the echo component because some tests invoke EchoComponent with method name and therefore we need an entry point resolver\n        registerBeanDefinitionParser(\"echo-component\", new SimpleComponentDefinitionParser(DefaultJavaComponent.class, EchoComponent.class));\n\n        // Object Factories\n        registerBeanDefinitionParser(\"singleton-object\", new ObjectFactoryDefinitionParser(SingletonObjectFactory.class, \"objectFactory\"));\n        registerBeanDefinitionParser(\"prototype-object\", new ObjectFactoryDefinitionParser(PrototypeObjectFactory.class, \"objectFactory\"));\n        registerBeanDefinitionParser(\"spring-object\", new ObjectFactoryDefinitionParser(SpringBeanLookup.class, \"objectFactory\"));\n\n        // Life-cycle Adapters Factories\n        registerBeanDefinitionParser(\"custom-lifecycle-adapter-factory\", new ChildDefinitionParser(\"lifecycleAdapterFactory\"));\n\n        //Stores\n        registerBeanDefinitionParser(\"in-memory-store\", new ChildDefinitionParser(\"store\", InMemoryObjectStore.class));\n        registerBeanDefinitionParser(\"simple-text-file-store\", new ChildDefinitionParser(\"store\", TextFileObjectStore.class));\n\n        //Routers\n        registerBeanDefinitionParser(\"inbound\", new ChildDefinitionParser(\"messageSource\", ServiceCompositeMessageSource.class, true));\n        registerBeanDefinitionParser(\"outbound\", new ChildDefinitionParser(\"outboundRouter\", DefaultOutboundRouterCollection.class, true));\n        registerBeanDefinitionParser(\"async-reply\", new ChildDefinitionParser(\"asyncReplyMessageSource\", ServiceAsyncReplyCompositeMessageSource.class, true));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"forwarding-router\", new InboundRouterDefinitionParser(ForwardingConsumer.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new InboundRouterDefinitionParser(IdempotentMessageFilter.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new InboundRouterDefinitionParser(IdempotentSecureHashMessageFilter.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new InboundRouterDefinitionParser(MessageFilter.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new InboundRouterDefinitionParser(WireTap.class));\n        registerBeanDefinitionParser(\"custom-correlation-aggregator-router\", new InboundRouterDefinitionParser());\n        registerBeanDefinitionParser(\"collection-aggregator-router\", new InboundRouterDefinitionParser(SimpleCollectionAggregator.class));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new InboundRouterDefinitionParser(MessageChunkAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new InboundRouterDefinitionParser(Resequencer.class));\n        registerBeanDefinitionParser(\"custom-inbound-router\", new InboundRouterDefinitionParser(null));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"pass-through-router\", new RouterDefinitionParser(OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"recipient-list-exception-based-router\", new RouterDefinitionParser(ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(ListMessageSplitter.class));\n        registerBeanDefinitionParser(\"expression-splitter-router\", new RouterDefinitionParser(ExpressionMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(StaticRecipientList.class));\n        registerBeanDefinitionParser(\"expression-recipient-list-router\", new RouterDefinitionParser(ExpressionRecipientList.class));\n        registerBeanDefinitionParser(\"recipients\", new ChildListDefinitionParser(\"recipients\"));\n        registerBeanDefinitionParser(\"custom-outbound-router\", new RouterDefinitionParser(null));\n        registerBeanDefinitionParser(\"reply-to\", new EndpointRefParser(\"replyTo\"));\n\n        //Response Routers\n        registerBeanDefinitionParser(\"custom-async-reply-router\", new InboundRouterDefinitionParser(null));\n        registerBeanDefinitionParser(\"single-async-reply-router\", new InboundRouterDefinitionParser(NullMessageProcessor.class));\n        registerBeanDefinitionParser(\"collection-async-reply-router\", new InboundRouterDefinitionParser(SimpleCollectionAggregator.class));\n\n        //Message Info Mappings\n        registerBeanDefinitionParser(\"expression-message-info-mapping\", new ChildDefinitionParser(\"messageInfoMapping\", ExpressionMessageInfoMapping.class));\n        registerBeanDefinitionParser(\"custom-message-info-mapping\", new ChildDefinitionParser(\"messageInfoMapping\"));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"logging-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", LoggingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerMuleBeanDefinitionParser(\"filter\", new FilterRefDefinitionParser());\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser(AndFilter.class));\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser(OrFilter.class));\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser(NotFilter.class));\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser(RegExFilter.class));\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser(ExceptionTypeFilter.class));\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser(MessagePropertyFilter.class));\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser(PayloadTypeFilter.class));\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser(WildcardFilter.class));\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser(EqualsFilter.class));\n        registerBeanDefinitionParser(\"expression-filter\", new FilterDefinitionParser(ExpressionFilter.class));\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Utils / Standard Types\n        registerMuleBeanDefinitionParser(\"properties\", new ChildMapDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"property\", new ChildMapEntryDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"add-message-properties\", new ChildMapDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"add-message-property\", new ChildMapEntryDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"rename-message-property\", new ChildMapEntryDefinitionParser(\"renameProperties\")).addCollection(\"renameProperties\");\n        registerBeanDefinitionParser(\"delete-message-property\", new ChildListEntryDefinitionParser(\"deleteProperties\", ChildMapEntryDefinitionParser.KEY));\n        registerMuleBeanDefinitionParser(\"jndi-provider-properties\", new ChildMapDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerMuleBeanDefinitionParser(\"jndi-provider-property\", new ChildMapEntryDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerBeanDefinitionParser(\"environment\", new ChildMapDefinitionParser(\"environment\"));\n        registerBeanDefinitionParser(\"expression\", new ChildDefinitionParser(\"expression\", ExpressionConfig.class));\n\n        //Security\n        registerMuleBeanDefinitionParser(\"security-manager\", new NamedDefinitionParser(MuleProperties.OBJECT_SECURITY_MANAGER)).addIgnored(\"type\").addIgnored(\"name\");\n        registerBeanDefinitionParser(\"custom-security-provider\", new NameTransferDefinitionParser(\"providers\"));\n        registerMuleBeanDefinitionParser(\"custom-encryption-strategy\", new NameTransferDefinitionParser(\"encryptionStrategies\")).addAlias(\"strategy\", \"encryptionStrategy\");\n        registerBeanDefinitionParser(\"password-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", PasswordBasedEncryptionStrategy.class));\n        registerMuleBeanDefinitionParser(\"secret-key-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", SecretKeyEncryptionStrategy.class)).registerPreProcessor(new CheckExclusiveAttributes(new String[][]{new String[]{\"key\"}, new String[]{\"keyFactory-ref\"}}));\n        registerBeanDefinitionParser(\"encryption-security-filter\", new ChildDefinitionParser(\"securityFilter\", MuleEncryptionEndpointSecurityFilter.class));\n        registerBeanDefinitionParser(\"custom-security-filter\", new ChildDefinitionParser(\"securityFilter\"));\n        //Interceptors\n        registerMuleBeanDefinitionParser(\"interceptor-stack\", new InterceptorStackDefinitionParser());\n        registerBeanDefinitionParser(\"custom-interceptor\", new InterceptorDefinitionParser());\n        registerBeanDefinitionParser(\"timer-interceptor\", new InterceptorDefinitionParser(TimerInterceptor.class));\n        registerBeanDefinitionParser(\"logging-interceptor\", new InterceptorDefinitionParser(LoggingInterceptor.class));\n    }","commit_id":"db981073b8398bb49fbbfe53a080047ea159e95c","url":"https://github.com/mulesoft/mule"},{"original_method":"private boolean registerAsSoap(String endpoint, Object listener) throws MuleException\n    {\n        if (endpoint.startsWith(\"glue\") || endpoint.startsWith(\"soap\") || endpoint.startsWith(\"axis\")\n            || endpoint.startsWith(\"xfire\"))\n        {\n            EndpointURI ep = new MuleEndpointURI(endpoint);\n\n            // get the service name from the URI path\n            String serviceName = null;\n            if (ep.getPath() != null)\n            {\n                String path = ep.getPath();\n                if (path.endsWith(\"/\"))\n                {\n                    path = path.substring(0, path.length() - 1);\n                }\n                int i = path.lastIndexOf(\"/\");\n                if (i > -1)\n                {\n                    serviceName = path.substring(i + 1);\n                }\n            }\n            else\n            {\n                serviceName = service.getName();\n            }\n            // now strip off the service name\n            String newEndpoint = endpoint;\n            int i = newEndpoint.indexOf(serviceName);\n            newEndpoint = newEndpoint.substring(0, i - 1);\n            SedaService s = new SedaService();\n            s.setName(serviceName);\n            s.setQueueProfile(new QueueProfile());\n            s.getInboundRouter().addEndpoint(\n                muleContext.getRegistry().lookupEndpointFactory().getInboundEndpoint(newEndpoint));\n            s.setComponentFactory(new SingletonObjectFactory(listener));\n            muleContext.getRegistry().registerService(s);\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }","id":73279,"modified_method":"private boolean registerAsSoap(String endpoint, Object listener) throws MuleException\n    {\n        if (endpoint.startsWith(\"glue\") || endpoint.startsWith(\"soap\") || endpoint.startsWith(\"axis\")\n            || endpoint.startsWith(\"xfire\"))\n        {\n            EndpointURI ep = new MuleEndpointURI(endpoint);\n\n            // get the service name from the URI path\n            String serviceName = null;\n            if (ep.getPath() != null)\n            {\n                String path = ep.getPath();\n                if (path.endsWith(\"/\"))\n                {\n                    path = path.substring(0, path.length() - 1);\n                }\n                int i = path.lastIndexOf(\"/\");\n                if (i > -1)\n                {\n                    serviceName = path.substring(i + 1);\n                }\n            }\n            else\n            {\n                serviceName = service.getName();\n            }\n            // now strip off the service name\n            String newEndpoint = endpoint;\n            int i = newEndpoint.indexOf(serviceName);\n            newEndpoint = newEndpoint.substring(0, i - 1);\n            SedaService s = new SedaService();\n            s.setName(serviceName);\n            s.setModel(muleContext.getRegistry().lookupSystemModel());\n            s.setQueueProfile(new QueueProfile());\n            s.getInboundRouter().addEndpoint(\n                muleContext.getRegistry().lookupEndpointFactory().getInboundEndpoint(newEndpoint));\n            s.setComponentFactory(new SingletonObjectFactory(listener));\n            muleContext.getRegistry().registerService(s);\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }","commit_id":"0c2f2094205e9163831cc2dcb2473fa9c9f95e29","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerIgnoredElement(\"mule\");\n        registerIgnoredElement(\"description\");\n\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"environment-property\", new EnvironmentPropertyDefinitionParser());\n        registerBeanDefinitionParser(\"default-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-receiver-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-component-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_COMPONENT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"default-receiver-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        //registerBeanDefinitionParser(\"mule-configuration\", new MuleContextDefinitionParser());\n        registerBeanDefinitionParser(\"component-threading-profile\", new ThreadingProfileDefinitionParser(\"threadingProfile\", MuleProperties.OBJECT_DEFAULT_COMPONENT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-service-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultServiceExceptionStrategy.class));\n        registerBeanDefinitionParser(\"default-connector-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new ChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n        registerMuleBeanDefinitionParser(\"notifications\", new NamedDefinitionParser(MuleProperties.OBJECT_NOTIFICATION_MANAGER)).addAlias(\"dynamic\", \"notificationDynamic\");\n        registerBeanDefinitionParser(\"notification\", new NotificationDefinitionParser());\n        registerBeanDefinitionParser(\"disable-notification\", new NotificationDisableDefinitionParser());\n        registerMuleBeanDefinitionParser(\"notification-listener\", new ChildDefinitionParser(\"allListenerSubscriptionPair\", ListenerSubscriptionPair.class)).addAlias(\"ref\", \"listener\").addReference(\"listener\");\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"dispatcherThreadingProfile\", MuleProperties.OBJECT_DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"receiverThreadingProfile\", MuleProperties.OBJECT_DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser(\"dispatcherConnectionStrategy\"));\n        registerBeanDefinitionParser(\"receiver-connection-straqtegy\", new ConnectionStrategyDefinitionParser(\"receiverConnectionStrategy\"));\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new MuleOrphanDefinitionParser(true));\n\n        //Transformer elements\n        registerBeanDefinitionParser(\"transformers\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"responseTransformers\", new ParentDefinitionParser()).addAlias(\"transformer\", \"responseTransformer\");\n\n        registerBeanDefinitionParser(\"transformer\", new TransformerRefDefinitionParser());\n\n        registerBeanDefinitionParser(\"custom-transformer\", new TransformerDefinitionParser());\n        registerBeanDefinitionParser(\"no-action-transformer\", new TransformerDefinitionParser(NoActionTransformer.class));\n        registerBeanDefinitionParser(\"message-properties-transformer\", new TransformerDefinitionParser(MessagePropertiesTransformer.class));\n\n        registerBeanDefinitionParser(\"base64-encoder-transformer\", new TransformerDefinitionParser(Base64Encoder.class));\n        registerBeanDefinitionParser(\"base64-decoder-transformer\", new TransformerDefinitionParser(Base64Decoder.class));\n\n        registerBeanDefinitionParser(\"xml-entity-encoder-transformer\", new TransformerDefinitionParser(XmlEntityEncoder.class));\n        registerBeanDefinitionParser(\"xml-entity-decoder-transformer\", new TransformerDefinitionParser(XmlEntityDecoder.class));\n        registerBeanDefinitionParser(\"gzip-compress-transformer\", new TransformerDefinitionParser(GZipCompressTransformer.class));\n        registerBeanDefinitionParser(\"gzip-uncompress-transformer\", new TransformerDefinitionParser(GZipUncompressTransformer.class));\n        registerBeanDefinitionParser(\"encrypt-transformer\", new TransformerDefinitionParser(EncryptionTransformer.class));\n        registerBeanDefinitionParser(\"decrypt-transformer\", new TransformerDefinitionParser(DecryptionTransformer.class));\n        registerBeanDefinitionParser(\"byte-array-to-hex-string-transformer\", new TransformerDefinitionParser(ByteArrayToHexString.class));\n        registerBeanDefinitionParser(\"hex-string-to-byte-array-transformer\", new TransformerDefinitionParser(HexStringToByteArray.class));\n\n        registerBeanDefinitionParser(\"byte-array-to-object-transformer\", new TransformerDefinitionParser(ByteArrayToObject.class));\n        registerBeanDefinitionParser(\"object-to-byte-array-transformer\", new TransformerDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"object-to-string-transformer\", new TransformerDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"byte-array-to-serializable-transformer\", new TransformerDefinitionParser(ByteArrayToSerializable.class));\n        registerBeanDefinitionParser(\"serializable-to-byte-array-transformer\", new TransformerDefinitionParser(SerializableToByteArray.class));\n        registerBeanDefinitionParser(\"byte-array-to-string-transformer\", new TransformerDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"string-to-byte-array-transformer\", new TransformerDefinitionParser(ObjectToByteArray.class));\n\n        registerBeanDefinitionParser(\"append-string-transformer\", new TransformerDefinitionParser(StringAppendTransformer.class));\n\n        //Transaction Managers\n        registerBeanDefinitionParser(\"custom-transaction-manager\", new TransactionManagerDefinitionParser());\n        registerBeanDefinitionParser(\"jndi-transaction-manager\", new TransactionManagerDefinitionParser(GenericTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"weblogic-transaction-manager\", new TransactionManagerDefinitionParser(WeblogicTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jboss-transaction-manager\", new TransactionManagerDefinitionParser(JBossTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jrun-transaction-manager\", new TransactionManagerDefinitionParser(JRunTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"resin-transaction-manager\", new TransactionManagerDefinitionParser(Resin3TransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"websphere-transaction-manager\", new TransactionManagerDefinitionParser(WebsphereTransactionManagerLookupFactory.class));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"inbound-endpoint\", new GenericEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"outbound-endpoint\", new GenericEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"custom-transaction\", new TransactionDefinitionParser());\n\n        //Container contexts\n        registerBeanDefinitionParser(\"custom-container\", new MuleOrphanDefinitionParser(true));\n        registerBeanDefinitionParser(\"rmi-container\", new MuleOrphanDefinitionParser(RmiContainerContext.class, true));\n        registerBeanDefinitionParser(\"jndi-container\", new MuleOrphanDefinitionParser(JndiContainerContext.class, true));\n        registerBeanDefinitionParser(\"properties-container\", new MuleOrphanDefinitionParser(PropertiesContainerContext.class, true));\n\n        // Models\n        registerBeanDefinitionParser(\"model\", new ModelDefinitionParser());\n        registerBeanDefinitionParser(\"seda-model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n//        registerBeanDefinitionParser(\"model-seda-optimised\", new OrphanDefinitionParser(OptimisedSedaModel.class, true));\n//        registerBeanDefinitionParser(\"model-pipeline\", new OrphanDefinitionParser(PipelineModel.class, true));\n\n        registerBeanDefinitionParser(\"entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", DefaultEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"legacy-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", LegacyEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"custom-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\"));\n\n        registerBeanDefinitionParser(\"custom-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\"));\n        registerBeanDefinitionParser(\"callable-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"property-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", MethodHeaderPropertyEntryPointResolver.class)).addAlias(\"property\", \"methodProperty\");\n        registerBeanDefinitionParser(\"method-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ExplicitMethodEntryPointResolver.class));\n        registerBeanDefinitionParser(\"reflection-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ReflectionEntryPointResolver.class));\n        registerBeanDefinitionParser(\"no-arguments-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", NoArgumentsEntryPointResolver.class));\n        registerBeanDefinitionParser(\"array-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ArrayEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"include-entry-point\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"exclude-entry-point\", new ParentDefinitionParser()).addAlias(\"method\", \"ignoredMethod\");\n        registerMuleBeanDefinitionParser(\"exclude-object-methods\", new IgnoreObjectMethodsDefinitionParser());\n\n        // Services\n        registerBeanDefinitionParser(\"seda-service\", new ServiceDefinitionParser(SedaService.class));\n        registerBeanDefinitionParser(\"service\", new ServiceDefinitionParser(SedaService.class));\n        registerBeanDefinitionParser(\"custom-service\", new ServiceDefinitionParser());\n\n        // Pojo Components\n        registerBeanDefinitionParser(\"component\", new ComponentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"binding\", new BindingDefinitionParser(\"nestedRouter.routers\", DefaultNestedRouter.class)).addCollection(\"nestedRouter.routers\");\n\n        // Other Components\n        registerBeanDefinitionParser(\"bridge-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"pass-through-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"log-component\", new SimplePojoServiceDefinitionParser(LogComponent.class));\n        registerBeanDefinitionParser(\"echo-component\", new SimplePojoServiceDefinitionParser(EchoComponent.class));\n        registerBeanDefinitionParser(\"null-component\", new SimplePojoServiceDefinitionParser(NullComponent.class));\n\n        // Object Factories\n        registerBeanDefinitionParser(\"singleton-object\", new ObjectFactoryDefinitionParser(SingletonObjectFactory.class));\n        registerBeanDefinitionParser(\"prototype-object\", new ObjectFactoryDefinitionParser(PrototypeObjectFactory.class));\n        registerBeanDefinitionParser(\"pooled-object\", new ObjectFactoryDefinitionParser(PooledObjectFactory.class));\n        registerBeanDefinitionParser(\"spring-object\", new ObjectFactoryDefinitionParser(SpringBeanLookup.class));\n\n        //Routers\n        registerBeanDefinitionParser(\"inbound\", new ChildDefinitionParser(\"inboundRouter\", DefaultInboundRouterCollection.class));\n        registerBeanDefinitionParser(\"outbound\", new ChildDefinitionParser(\"outboundRouter\", DefaultOutboundRouterCollection.class));\n        registerBeanDefinitionParser(\"async-reply\", new ChildDefinitionParser(\"responseRouter\", DefaultResponseRouterCollection.class));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"forwarding-router\", new RouterDefinitionParser(ForwardingConsumer.class));\n        registerBeanDefinitionParser(\"inbound-pass-through-router\", new RouterDefinitionParser(InboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new RouterDefinitionParser(IdempotentReceiver.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new RouterDefinitionParser(IdempotentSecureHashReceiver.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new RouterDefinitionParser(SelectiveConsumer.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new RouterDefinitionParser(WireTap.class));\n        registerBeanDefinitionParser(\"correlation-aggregator-router\", new RouterDefinitionParser());\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new RouterDefinitionParser(MessageChunkingAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new RouterDefinitionParser(CorrelationEventResequencer.class));\n        registerBeanDefinitionParser(\"custom-inbound-router\", new RouterDefinitionParser(null));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"outbound-pass-through-router\", new RouterDefinitionParser(OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(FilteringListMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(StaticRecipientList.class));\n        registerBeanDefinitionParser(\"recipients\", new ChildListDefinitionParser(\"recipients\"));\n        registerBeanDefinitionParser(\"template-endpoint-router\", new RouterDefinitionParser(TemplateEndpointRouter.class));\n        registerBeanDefinitionParser(\"custom-outbound-router\", new RouterDefinitionParser(null));\n        registerMuleBeanDefinitionParser(\"reply-to\", new ParentDefinitionParser()).addAlias(\"address\", \"replyTo\");\n\n        //Response Routers\n        registerBeanDefinitionParser(\"custom-async-reply-router\", new RouterDefinitionParser(null));\n        registerBeanDefinitionParser(\"single-async-reply-router\", new RouterDefinitionParser(SingleResponseRouter.class));\n\n        //Property Extractors\n        registerBeanDefinitionParser(\"function-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", FunctionPropertyExtractor.class));\n        registerBeanDefinitionParser(\"correlation-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", CorrelationPropertiesExtractor.class));\n        registerBeanDefinitionParser(\"custom-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\"));\n        registerBeanDefinitionParser(\"map-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MapPayloadPropertyExtractor.class));\n        registerBeanDefinitionParser(\"message-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MessageHeaderPropertyExtractor.class));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"logging-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", LoggingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerMuleBeanDefinitionParser(\"filter\", new ParentDefinitionParser()).addAlias(\"ref\", \"filter\");\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser(AndFilter.class));\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser(OrFilter.class));\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser(NotFilter.class));\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser(RegExFilter.class));\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser(ExceptionTypeFilter.class));\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser(MessagePropertyFilter.class));\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser(PayloadTypeFilter.class));\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser(WildcardFilter.class));\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser(EqualsFilter.class));\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Retry strategies\n        registerBeanDefinitionParser(\"retry-connection-strategy\", new ChildDefinitionParser(\"connectionStrategy\", SimpleRetryConnectionStrategy.class));\n\n        //Utils / Standard Types\n        registerMuleBeanDefinitionParser(\"properties\", new ChildMapDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"property\", new ChildMapEntryDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"add-message-properties\", new ChildMapDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"add-message-property\", new ChildMapEntryDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerBeanDefinitionParser(\"delete-message-property\", new ChildListEntryDefinitionParser(\"deleteProperties\", ChildMapEntryDefinitionParser.KEY));\n        registerMuleBeanDefinitionParser(\"jndi-provider-properties\", new ChildMapDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerMuleBeanDefinitionParser(\"jndi-provider-property\", new ChildMapEntryDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerBeanDefinitionParser(\"environment\", new ChildMapDefinitionParser(\"environment\"));\n\n        //Security\n        registerMuleBeanDefinitionParser(\"security-manager\", new NamedDefinitionParser(MuleProperties.OBJECT_SECURITY_MANAGER)).addIgnored(\"type\").addIgnored(\"name\");\n        registerBeanDefinitionParser(\"custom-security-provider\", new NameTransferDefinitionParser(\"providers\"));\n        registerMuleBeanDefinitionParser(\"custom-encryption-strategy\", new NameTransferDefinitionParser(\"encryptionStrategies\")).addAlias(\"strategy\", \"encryptionStrategy\");\n        registerBeanDefinitionParser(\"password-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", PasswordBasedEncryptionStrategy.class));\n        registerMuleBeanDefinitionParser(\"secret-key-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", SecretKeyEncryptionStrategy.class)).registerPreProcessor(new CheckExclusiveAttributes(new String[][]{new String[]{\"key\"}, new String[]{\"keyFactory-ref\"}}));\n        registerBeanDefinitionParser(\"encryption-security-filter\", new ChildDefinitionParser(\"securityFilter\", MuleEncryptionEndpointSecurityFilter.class));\n    }","id":73280,"modified_method":"public void init()\n    {\n        registerIgnoredElement(\"mule\");\n        registerIgnoredElement(\"description\");\n\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"environment-property\", new EnvironmentPropertyDefinitionParser());\n        registerBeanDefinitionParser(\"default-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-receiver-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-component-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_COMPONENT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"default-receiver-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        //registerBeanDefinitionParser(\"mule-configuration\", new MuleContextDefinitionParser());\n        registerBeanDefinitionParser(\"component-threading-profile\", new ThreadingProfileDefinitionParser(\"threadingProfile\", MuleProperties.OBJECT_DEFAULT_COMPONENT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-service-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultServiceExceptionStrategy.class));\n        registerBeanDefinitionParser(\"default-connector-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new ChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n        registerMuleBeanDefinitionParser(\"notifications\", new NamedDefinitionParser(MuleProperties.OBJECT_NOTIFICATION_MANAGER)).addAlias(\"dynamic\", \"notificationDynamic\");\n        registerBeanDefinitionParser(\"notification\", new NotificationDefinitionParser());\n        registerBeanDefinitionParser(\"disable-notification\", new NotificationDisableDefinitionParser());\n        registerMuleBeanDefinitionParser(\"notification-listener\", new ChildDefinitionParser(\"allListenerSubscriptionPair\", ListenerSubscriptionPair.class)).addAlias(\"ref\", \"listener\").addReference(\"listener\");\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"dispatcherThreadingProfile\", MuleProperties.OBJECT_DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"receiverThreadingProfile\", MuleProperties.OBJECT_DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser(\"dispatcherConnectionStrategy\"));\n        registerBeanDefinitionParser(\"receiver-connection-straqtegy\", new ConnectionStrategyDefinitionParser(\"receiverConnectionStrategy\"));\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new MuleOrphanDefinitionParser(true));\n\n        //Transformer elements\n        registerBeanDefinitionParser(\"transformers\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"response-transformers\", new ParentDefinitionParser());\n\n        registerBeanDefinitionParser(\"transformer\", new TransformerRefDefinitionParser());\n\n        registerBeanDefinitionParser(\"custom-transformer\", new TransformerDefinitionParser());\n        registerBeanDefinitionParser(\"no-action-transformer\", new TransformerDefinitionParser(NoActionTransformer.class));\n        registerBeanDefinitionParser(\"message-properties-transformer\", new TransformerDefinitionParser(MessagePropertiesTransformer.class));\n\n        registerBeanDefinitionParser(\"base64-encoder-transformer\", new TransformerDefinitionParser(Base64Encoder.class));\n        registerBeanDefinitionParser(\"base64-decoder-transformer\", new TransformerDefinitionParser(Base64Decoder.class));\n\n        registerBeanDefinitionParser(\"xml-entity-encoder-transformer\", new TransformerDefinitionParser(XmlEntityEncoder.class));\n        registerBeanDefinitionParser(\"xml-entity-decoder-transformer\", new TransformerDefinitionParser(XmlEntityDecoder.class));\n        registerBeanDefinitionParser(\"gzip-compress-transformer\", new TransformerDefinitionParser(GZipCompressTransformer.class));\n        registerBeanDefinitionParser(\"gzip-uncompress-transformer\", new TransformerDefinitionParser(GZipUncompressTransformer.class));\n        registerBeanDefinitionParser(\"encrypt-transformer\", new TransformerDefinitionParser(EncryptionTransformer.class));\n        registerBeanDefinitionParser(\"decrypt-transformer\", new TransformerDefinitionParser(DecryptionTransformer.class));\n        registerBeanDefinitionParser(\"byte-array-to-hex-string-transformer\", new TransformerDefinitionParser(ByteArrayToHexString.class));\n        registerBeanDefinitionParser(\"hex-string-to-byte-array-transformer\", new TransformerDefinitionParser(HexStringToByteArray.class));\n\n        registerBeanDefinitionParser(\"byte-array-to-object-transformer\", new TransformerDefinitionParser(ByteArrayToObject.class));\n        registerBeanDefinitionParser(\"object-to-byte-array-transformer\", new TransformerDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"object-to-string-transformer\", new TransformerDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"byte-array-to-serializable-transformer\", new TransformerDefinitionParser(ByteArrayToSerializable.class));\n        registerBeanDefinitionParser(\"serializable-to-byte-array-transformer\", new TransformerDefinitionParser(SerializableToByteArray.class));\n        registerBeanDefinitionParser(\"byte-array-to-string-transformer\", new TransformerDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"string-to-byte-array-transformer\", new TransformerDefinitionParser(ObjectToByteArray.class));\n\n        registerBeanDefinitionParser(\"append-string-transformer\", new TransformerDefinitionParser(StringAppendTransformer.class));\n\n        //Transaction Managers\n        registerBeanDefinitionParser(\"custom-transaction-manager\", new TransactionManagerDefinitionParser());\n        registerBeanDefinitionParser(\"jndi-transaction-manager\", new TransactionManagerDefinitionParser(GenericTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"weblogic-transaction-manager\", new TransactionManagerDefinitionParser(WeblogicTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jboss-transaction-manager\", new TransactionManagerDefinitionParser(JBossTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jrun-transaction-manager\", new TransactionManagerDefinitionParser(JRunTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"resin-transaction-manager\", new TransactionManagerDefinitionParser(Resin3TransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"websphere-transaction-manager\", new TransactionManagerDefinitionParser(WebsphereTransactionManagerLookupFactory.class));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"inbound-endpoint\", new GenericEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"outbound-endpoint\", new GenericEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"custom-transaction\", new TransactionDefinitionParser());\n\n        //Container contexts\n        registerBeanDefinitionParser(\"custom-container\", new MuleOrphanDefinitionParser(true));\n        registerBeanDefinitionParser(\"rmi-container\", new MuleOrphanDefinitionParser(RmiContainerContext.class, true));\n        registerBeanDefinitionParser(\"jndi-container\", new MuleOrphanDefinitionParser(JndiContainerContext.class, true));\n        registerBeanDefinitionParser(\"properties-container\", new MuleOrphanDefinitionParser(PropertiesContainerContext.class, true));\n\n        // Models\n        registerBeanDefinitionParser(\"model\", new ModelDefinitionParser());\n        registerBeanDefinitionParser(\"seda-model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n//        registerBeanDefinitionParser(\"model-seda-optimised\", new OrphanDefinitionParser(OptimisedSedaModel.class, true));\n//        registerBeanDefinitionParser(\"model-pipeline\", new OrphanDefinitionParser(PipelineModel.class, true));\n\n        registerBeanDefinitionParser(\"entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", DefaultEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"legacy-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", LegacyEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"custom-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\"));\n\n        registerBeanDefinitionParser(\"custom-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\"));\n        registerBeanDefinitionParser(\"callable-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"property-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", MethodHeaderPropertyEntryPointResolver.class)).addAlias(\"property\", \"methodProperty\");\n        registerBeanDefinitionParser(\"method-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ExplicitMethodEntryPointResolver.class));\n        registerBeanDefinitionParser(\"reflection-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ReflectionEntryPointResolver.class));\n        registerBeanDefinitionParser(\"no-arguments-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", NoArgumentsEntryPointResolver.class));\n        registerBeanDefinitionParser(\"array-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ArrayEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"include-entry-point\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"exclude-entry-point\", new ParentDefinitionParser()).addAlias(\"method\", \"ignoredMethod\");\n        registerMuleBeanDefinitionParser(\"exclude-object-methods\", new IgnoreObjectMethodsDefinitionParser());\n\n        // Services\n        registerBeanDefinitionParser(\"seda-service\", new ServiceDefinitionParser(SedaService.class));\n        registerBeanDefinitionParser(\"service\", new ServiceDefinitionParser(SedaService.class));\n        registerBeanDefinitionParser(\"custom-service\", new ServiceDefinitionParser());\n\n        // Pojo Components\n        registerBeanDefinitionParser(\"component\", new ComponentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"binding\", new BindingDefinitionParser(\"nestedRouter.routers\", DefaultNestedRouter.class)).addCollection(\"nestedRouter.routers\");\n\n        // Other Components\n        registerBeanDefinitionParser(\"bridge-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"pass-through-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"log-component\", new SimplePojoServiceDefinitionParser(LogComponent.class));\n        registerBeanDefinitionParser(\"echo-component\", new SimplePojoServiceDefinitionParser(EchoComponent.class));\n        registerBeanDefinitionParser(\"null-component\", new SimplePojoServiceDefinitionParser(NullComponent.class));\n\n        // Object Factories\n        registerBeanDefinitionParser(\"singleton-object\", new ObjectFactoryDefinitionParser(SingletonObjectFactory.class));\n        registerBeanDefinitionParser(\"prototype-object\", new ObjectFactoryDefinitionParser(PrototypeObjectFactory.class));\n        registerBeanDefinitionParser(\"pooled-object\", new ObjectFactoryDefinitionParser(PooledObjectFactory.class));\n        registerBeanDefinitionParser(\"spring-object\", new ObjectFactoryDefinitionParser(SpringBeanLookup.class));\n\n        //Routers\n        registerBeanDefinitionParser(\"inbound\", new ChildDefinitionParser(\"inboundRouter\", DefaultInboundRouterCollection.class));\n        registerBeanDefinitionParser(\"outbound\", new ChildDefinitionParser(\"outboundRouter\", DefaultOutboundRouterCollection.class));\n        registerBeanDefinitionParser(\"async-reply\", new ChildDefinitionParser(\"responseRouter\", DefaultResponseRouterCollection.class));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"forwarding-router\", new RouterDefinitionParser(ForwardingConsumer.class));\n        registerBeanDefinitionParser(\"inbound-pass-through-router\", new RouterDefinitionParser(InboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new RouterDefinitionParser(IdempotentReceiver.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new RouterDefinitionParser(IdempotentSecureHashReceiver.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new RouterDefinitionParser(SelectiveConsumer.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new RouterDefinitionParser(WireTap.class));\n        registerBeanDefinitionParser(\"correlation-aggregator-router\", new RouterDefinitionParser());\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new RouterDefinitionParser(MessageChunkingAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new RouterDefinitionParser(CorrelationEventResequencer.class));\n        registerBeanDefinitionParser(\"custom-inbound-router\", new RouterDefinitionParser(null));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"outbound-pass-through-router\", new RouterDefinitionParser(OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(FilteringListMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(StaticRecipientList.class));\n        registerBeanDefinitionParser(\"recipients\", new ChildListDefinitionParser(\"recipients\"));\n        registerBeanDefinitionParser(\"template-endpoint-router\", new RouterDefinitionParser(TemplateEndpointRouter.class));\n        registerBeanDefinitionParser(\"custom-outbound-router\", new RouterDefinitionParser(null));\n        registerMuleBeanDefinitionParser(\"reply-to\", new ParentDefinitionParser()).addAlias(\"address\", \"replyTo\");\n\n        //Response Routers\n        registerBeanDefinitionParser(\"custom-async-reply-router\", new RouterDefinitionParser(null));\n        registerBeanDefinitionParser(\"single-async-reply-router\", new RouterDefinitionParser(SingleResponseRouter.class));\n\n        //Property Extractors\n        registerBeanDefinitionParser(\"function-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", FunctionPropertyExtractor.class));\n        registerBeanDefinitionParser(\"correlation-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", CorrelationPropertiesExtractor.class));\n        registerBeanDefinitionParser(\"custom-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\"));\n        registerBeanDefinitionParser(\"map-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MapPayloadPropertyExtractor.class));\n        registerBeanDefinitionParser(\"message-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MessageHeaderPropertyExtractor.class));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"logging-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", LoggingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerMuleBeanDefinitionParser(\"filter\", new ParentDefinitionParser()).addAlias(\"ref\", \"filter\");\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser(AndFilter.class));\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser(OrFilter.class));\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser(NotFilter.class));\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser(RegExFilter.class));\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser(ExceptionTypeFilter.class));\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser(MessagePropertyFilter.class));\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser(PayloadTypeFilter.class));\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser(WildcardFilter.class));\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser(EqualsFilter.class));\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Retry strategies\n        registerBeanDefinitionParser(\"retry-connection-strategy\", new ChildDefinitionParser(\"connectionStrategy\", SimpleRetryConnectionStrategy.class));\n\n        //Utils / Standard Types\n        registerMuleBeanDefinitionParser(\"properties\", new ChildMapDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"property\", new ChildMapEntryDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"add-message-properties\", new ChildMapDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"add-message-property\", new ChildMapEntryDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerBeanDefinitionParser(\"delete-message-property\", new ChildListEntryDefinitionParser(\"deleteProperties\", ChildMapEntryDefinitionParser.KEY));\n        registerMuleBeanDefinitionParser(\"jndi-provider-properties\", new ChildMapDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerMuleBeanDefinitionParser(\"jndi-provider-property\", new ChildMapEntryDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerBeanDefinitionParser(\"environment\", new ChildMapDefinitionParser(\"environment\"));\n\n        //Security\n        registerMuleBeanDefinitionParser(\"security-manager\", new NamedDefinitionParser(MuleProperties.OBJECT_SECURITY_MANAGER)).addIgnored(\"type\").addIgnored(\"name\");\n        registerBeanDefinitionParser(\"custom-security-provider\", new NameTransferDefinitionParser(\"providers\"));\n        registerMuleBeanDefinitionParser(\"custom-encryption-strategy\", new NameTransferDefinitionParser(\"encryptionStrategies\")).addAlias(\"strategy\", \"encryptionStrategy\");\n        registerBeanDefinitionParser(\"password-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", PasswordBasedEncryptionStrategy.class));\n        registerMuleBeanDefinitionParser(\"secret-key-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", SecretKeyEncryptionStrategy.class)).registerPreProcessor(new CheckExclusiveAttributes(new String[][]{new String[]{\"key\"}, new String[]{\"keyFactory-ref\"}}));\n        registerBeanDefinitionParser(\"encryption-security-filter\", new ChildDefinitionParser(\"securityFilter\", MuleEncryptionEndpointSecurityFilter.class));\n    }","commit_id":"0c2f2094205e9163831cc2dcb2473fa9c9f95e29","url":"https://github.com/mulesoft/mule"},{"original_method":"protected List listSchema2() throws IOException\n    {\n        ClassLoader loader = getClass().getClassLoader();\n        List files = new LinkedList();\n        Enumeration resources = loader.getResources(\"META-INF\");\n        FilenameFilter filter =\n                new FilenameFilter() {\n                    public boolean accept(File dir, String name)\n                    {\n                        return name.startsWith(MULE) && name.endsWith(XSD);\n                    }\n                };\n        while (resources.hasMoreElements())\n        {\n            URL url = (URL) resources.nextElement();\n            logger.debug(\"url: \" + url);\n            if (url.toString().startsWith(\"jar:\"))\n            {\n                readFromJar(url, files);\n            }\n            else if (\"file\".equals(url.getProtocol()))\n            {\n                readFromDirectory(new File(url.getFile()), files, filter);\n            }\n        }\n        return files;\n    }","id":73281,"modified_method":"protected List listSchema2() throws IOException\n    {\n        ClassLoader loader = getClass().getClassLoader();\n        List files = new LinkedList();\n        Enumeration resources = loader.getResources(\"META-INF\");\n        FilenameFilter filter =\n                new FilenameFilter() {\n                    public boolean accept(File dir, String name)\n                    {\n                        if (name.startsWith(MULE) && name.endsWith(XSD))\n                        {\n                            for (int i = 0; i < BLOCKED.length; ++i)\n                            {\n                                if (name.indexOf(BLOCKED[i]) > -1)\n                                {\n                                    return false;\n                                }\n                            }\n                            return true;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n                    }\n                };\n        while (resources.hasMoreElements())\n        {\n            URL url = (URL) resources.nextElement();\n            logger.debug(\"url: \" + url);\n            if (url.toString().startsWith(\"jar:\"))\n            {\n                readFromJar(url, files);\n            }\n            else if (\"file\".equals(url.getProtocol()))\n            {\n                readFromDirectory(new File(url.getFile()), files, filter);\n            }\n        }\n        return files;\n    }","commit_id":"0c2f2094205e9163831cc2dcb2473fa9c9f95e29","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doSetUp() throws Exception\n    {\n        if (context == null)\n        {\n            context = new ClassPathXmlApplicationContext(\n                \"org/mule/test/integration/spring/events/async/mule-events-example-async-app-context.xml\");\n        }\n        else\n        {\n            context.refresh();\n        }\n        eventCount = 0;\n    }","id":73282,"modified_method":"protected void doSetUp() throws Exception\n    {\n        super.doSetUp();\n        eventCount.set(0);\n    }","commit_id":"0c2f2094205e9163831cc2dcb2473fa9c9f95e29","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testReceiveAsWebService() throws Exception\n    {\n        MuleClient client = new MuleClient();\n        OrderManagerBean orderManager = (OrderManagerBean)context.getBean(\"orderManager\");\n        assertNotNull(orderManager);\n        EventCallback callback = new EventCallback()\n        {\n            public void eventReceived(MuleEventContext context, Object o) throws Exception\n            {\n                eventCount++;\n            }\n        };\n        orderManager.setEventCallback(callback);\n\n        Order order = new Order(\"Sausage and Mash\");\n        // Make an async call\n        client.dispatch(\"axis:http://localhost:44444/mule/orderManager?method=processOrderAsync\", order, null);\n\n        MuleMessage result = client.request(\"jms://processed.queue\", 10000);\n        assertNotNull(result);\n        assertEquals(\"Order 'Sausage and Mash' Processed Async\", result.getPayload());\n    }","id":73283,"modified_method":"public void testReceiveAsWebService() throws Exception\n    {\n        MuleClient client = new MuleClient();\n        OrderManagerBean orderManager = (OrderManagerBean) muleContext.getRegistry().lookupObject(\"orderManagerBean\");\n        assertNotNull(orderManager);\n        EventCallback callback = new EventCallback()\n        {\n            public void eventReceived(MuleEventContext context, Object o) throws Exception\n            {\n                eventCount.incrementAndGet();\n            }\n        };\n        orderManager.setEventCallback(callback);\n\n        Order order = new Order(\"Sausage and Mash\");\n        // Make an async call\n        client.dispatch(\"axis:http://localhost:44444/mule/orderManager?method=processOrderAsync\", order, null);\n\n        MuleMessage result = client.request(\"jms://processed.queue\", 10000);\n        assertNotNull(result);\n        assertEquals(\"Order 'Sausage and Mash' Processed Async\", result.getPayload());\n    }","commit_id":"0c2f2094205e9163831cc2dcb2473fa9c9f95e29","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testReceivingASubscriptionEvent() throws Exception\n    {\n        OrderManagerBean subscriptionBean = (OrderManagerBean)context.getBean(\"orderManager\");\n        assertNotNull(subscriptionBean);\n        // when an event is received by 'testEventBean1' this callback will be\n        // invoked\n        EventCallback callback = new EventCallback()\n        {\n            public void eventReceived(MuleEventContext context, Object o) throws Exception\n            {\n                eventCount++;\n            }\n        };\n        subscriptionBean.setEventCallback(callback);\n\n        muleContext.getConfiguration().setDefaultSynchronousEndpoints(true);\n        MuleClient client = new MuleClient();\n        Order order = new Order(\"Sausage and Mash\");\n        client.send(\"jms://orders.queue\", order, null);\n        Thread.sleep(1000);\n        assertTrue(eventCount == 1);\n\n        MuleMessage result = client.request(\"jms://processed.queue\", 10000);\n        assertEquals(1, eventCount);\n        assertNotNull(result);\n        assertEquals(\"Order 'Sausage and Mash' Processed\", result.getPayloadAsString());\n    }","id":73284,"modified_method":"public void testReceivingASubscriptionEvent() throws Exception\n    {\n        OrderManagerBean subscriptionBean = (OrderManagerBean) muleContext.getRegistry().lookupObject(\n            \"orderManagerBean\");\n        assertNotNull(subscriptionBean);\n        // when an event is received by 'testEventBean1' this callback will be\n        // invoked\n        EventCallback callback = new EventCallback()\n        {\n            public void eventReceived(MuleEventContext context, Object o) throws Exception\n            {\n                eventCount.incrementAndGet();\n            }\n        };\n        subscriptionBean.setEventCallback(callback);\n\n        muleContext.getConfiguration().setDefaultSynchronousEndpoints(true);\n        MuleClient client = new MuleClient();\n        Order order = new Order(\"Sausage and Mash\");\n        client.send(\"jms://orders.queue\", order, null);\n        Thread.sleep(1000);\n        assertTrue(eventCount.get() == 1);\n\n        MuleMessage result = client.request(\"jms://processed.queue\", 10000);\n        assertEquals(1, eventCount.intValue());\n        assertNotNull(result);\n        assertEquals(\"Order 'Sausage and Mash' Processed\", result.getPayloadAsString());\n    }","commit_id":"0c2f2094205e9163831cc2dcb2473fa9c9f95e29","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testReceivingASubscriptionEvent() throws Exception\n    {\n        OrderManagerBean subscriptionBean = (OrderManagerBean)context.getBean(\"orderManager\");\n        assertNotNull(subscriptionBean);\n        // when an event is received by 'testEventBean1' this callback will be\n        // invoked\n        EventCallback callback = new EventCallback()\n        {\n            public void eventReceived(MuleEventContext context, Object o) throws Exception\n            {\n                eventCount.incrementAndGet();\n            }\n        };\n        subscriptionBean.setEventCallback(callback);\n\n        MuleClient client = new MuleClient();\n        Order order = new Order(\"Sausage and Mash\");\n        client.dispatch(\"jms://orders.queue\", order, null);\n        Thread.sleep(2000);\n        assertTrue(eventCount.get() == 1);\n\n        MuleMessage result = client.request(\"jms://processed.queue\", 10000);\n        assertEquals(1, eventCount.get());\n        assertNotNull(result);\n        assertEquals(\"Order 'Sausage and Mash' Processed\", result.getPayload());\n    }","id":73285,"modified_method":"public void testReceivingASubscriptionEvent() throws Exception\n    {\n        OrderManagerBean subscriptionBean = (OrderManagerBean) muleContext.getRegistry().lookupObject(\n            \"orderManagerBean\");\n        assertNotNull(subscriptionBean);\n        // when an event is received by 'testEventBean1' this callback will be\n        // invoked\n        EventCallback callback = new EventCallback()\n        {\n            public void eventReceived(MuleEventContext context, Object o) throws Exception\n            {\n                eventCount.incrementAndGet();\n            }\n        };\n        subscriptionBean.setEventCallback(callback);\n\n        MuleClient client = new MuleClient();\n        Order order = new Order(\"Sausage and Mash\");\n        client.dispatch(\"jms://orders.queue\", order, null);\n        Thread.sleep(2000);\n        assertTrue(eventCount.get() == 1);\n\n        MuleMessage result = client.request(\"jms://processed.queue\", 10000);\n        assertEquals(1, eventCount.get());\n        assertNotNull(result);\n        assertEquals(\"Order 'Sausage and Mash' Processed\", result.getPayload());\n    }","commit_id":"0c2f2094205e9163831cc2dcb2473fa9c9f95e29","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testReceiveAsWebService() throws Exception\n    {\n        MuleClient client = new MuleClient();\n        OrderManagerBean orderManager = (OrderManagerBean)context.getBean(\"orderManager\");\n        assertNotNull(orderManager);\n        EventCallback callback = new EventCallback()\n        {\n            public void eventReceived(MuleEventContext context, Object o) throws Exception\n            {\n                eventCount.incrementAndGet();\n            }\n        };\n        orderManager.setEventCallback(callback);\n\n        Order order = new Order(\"Sausage and Mash\");\n        MuleMessage result = client.send(\"axis:http://localhost:44444/mule/orderManager?method=processOrder\",\n            order, null);\n\n        assertNotNull(result);\n        assertEquals(\"Order 'Sausage and Mash' Processed\", (result.getPayload()));\n    }","id":73286,"modified_method":"public void testReceiveAsWebService() throws Exception\n    {\n        MuleClient client = new MuleClient();\n        OrderManagerBean orderManager = (OrderManagerBean) muleContext.getRegistry().lookupObject(\"orderManagerBean\");\n        assertNotNull(orderManager);\n        EventCallback callback = new EventCallback()\n        {\n            public void eventReceived(MuleEventContext context, Object o) throws Exception\n            {\n                eventCount.incrementAndGet();\n            }\n        };\n        orderManager.setEventCallback(callback);\n\n        Order order = new Order(\"Sausage and Mash\");\n        MuleMessage result = client.send(\"axis:http://localhost:44444/mule/orderManager?method=processOrder\", order,\n            null);\n\n        assertNotNull(result);\n        assertEquals(\"Order 'Sausage and Mash' Processed\", (result.getPayload()));\n    }","commit_id":"0c2f2094205e9163831cc2dcb2473fa9c9f95e29","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void testExpressionLanguageGlobalFunction()\n    {\n        assertEquals(\"Hello \" + muleContext.getConfiguration().getId() + \"!\", el.evaluate(\"hello()\"));\n        assertEquals(\"Hello \" + muleContext.getConfiguration().getId() + \"!\",\n            em.evaluate(\"hello()\", (MuleMessage) null));\n    }","id":73287,"modified_method":"@Test\n    public void testExpressionLanguageGlobalFunction()\n    {\n        assertEquals(\"hi\", el.evaluate(\"echo('hi')\"));\n        assertEquals(\"hi\", em.evaluate(\"echo('hi')\", (MuleMessage) null));\n    }","commit_id":"124d0249f2b035f5d53a963dcdbedb390ad15cff","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public void init()\n    {\n        registerIgnoredElement(\"mule\");\n        registerIgnoredElement(\"description\");\n\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"global-property\", new GlobalPropertyDefinitionParser());\n        registerBeanDefinitionParser(\"default-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-receiver-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-service-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_SERVICE_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"threading-profile\", new ThreadingProfileDefinitionParser(\"threadingProfile\", MuleProperties.OBJECT_DEFAULT_SERVICE_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"custom-agent\", new DefaultNameMuleOrphanDefinitionParser());\n        registerBeanDefinitionParser(\"expression-language\", new ExpressionLanguageDefinitionParser());\n        registerBeanDefinitionParser(\"global-functions\", new TextDefinitionParser(\"globalFunctionsString\"));\n        registerMuleBeanDefinitionParser(\"alias\", new ChildMapEntryDefinitionParser(\"aliases\")).addAlias(\"name\", \"key\").addAlias(\"expression\", \"value\");\n        registerMuleBeanDefinitionParser(\"import\", new ChildMapEntryDefinitionParser(\"import\")).addAlias(\"name\", \"key\").addAlias(\"class\", \"value\");\n\n        // Exception Strategies\n        registerBeanDefinitionParser(\"default-exception-strategy\", new ExceptionStrategyDefinitionParser(DefaultMessagingExceptionStrategy.class));\n        registerBeanDefinitionParser(\"catch-exception-strategy\", new ExceptionStrategyDefinitionParser(CatchMessagingExceptionStrategy.class));\n        registerBeanDefinitionParser(\"rollback-exception-strategy\", new ExceptionStrategyDefinitionParser(RollbackMessagingExceptionStrategy.class));\n        registerBeanDefinitionParser(\"on-redelivery-attempts-exceeded\", new ChildDefinitionParser(\"redeliveryExceeded\", RedeliveryExceeded.class));\n        registerBeanDefinitionParser(\"choice-exception-strategy\", new ExceptionStrategyDefinitionParser(ChoiceMessagingExceptionStrategy.class));\n        registerMuleBeanDefinitionParser(\"exception-strategy\", new ReferenceExceptionStrategyDefinitionParser());\n        registerDeprecatedBeanDefinitionParser(\"default-service-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultMessagingExceptionStrategy.class), \"Use default-exception-strategy instead.\");\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new ExceptionStrategyDefinitionParser(null));\n        registerBeanDefinitionParser(\"commit-transaction\", new ExceptionTXFilterDefinitionParser(\"commitTxFilter\"));\n        registerBeanDefinitionParser(\"rollback-transaction\", new ExceptionTXFilterDefinitionParser(\"rollbackTxFilter\"));\n\n        // Reconnection Strategies\n        registerBeanDefinitionParser(\"reconnect\", new RetryPolicyDefinitionParser(SimpleRetryPolicyTemplate.class));\n        registerBeanDefinitionParser(\"reconnect-forever\", new RetryPolicyDefinitionParser(RetryForeverPolicyTemplate.class));\n        registerBeanDefinitionParser(\"reconnect-custom-strategy\", new RetryPolicyDefinitionParser());\n        registerBeanDefinitionParser(\"reconnect-notifier\", new RetryNotifierDefinitionParser(ConnectNotifier.class));\n        registerBeanDefinitionParser(\"reconnect-custom-notifier\", new RetryNotifierDefinitionParser());\n\n        // Queue Store\n        registerMuleBeanDefinitionParser(\"queue-store\", new ParentDefinitionParser()).addAlias(AbstractMuleBeanDefinitionParser.ATTRIBUTE_REF, \"queue-store\");\n        registerMuleBeanDefinitionParser(\"custom-queue-store\", new QueueStoreDefinitionParser()).addIgnored(\"name\");\n        registerBeanDefinitionParser(\"default-in-memory-queue-store\", new QueueStoreDefinitionParser(DefaultMemoryQueueStoreFactoryBean.class));\n        registerBeanDefinitionParser(\"default-persistent-queue-store\", new QueueStoreDefinitionParser(DefaultPersistentQueueStoreFactoryBean.class));\n        registerBeanDefinitionParser(\"simple-in-memory-queue-store\", new QueueStoreDefinitionParser(SimpleMemoryQueueStoreFactoryBean.class));\n        registerBeanDefinitionParser(\"file-queue-store\", new QueueStoreDefinitionParser(FileQueueStoreFactoryBean.class));\n        \n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new ChildDefinitionParser(\"queueProfile\", QueueProfileFactoryBean.class));\n        registerMuleBeanDefinitionParser(\"notifications\", new NamedDefinitionParser(MuleProperties.OBJECT_NOTIFICATION_MANAGER)).addAlias(\"dynamic\", \"notificationDynamic\");\n        registerBeanDefinitionParser(\"notification\", new NotificationDefinitionParser());\n        registerBeanDefinitionParser(\"disable-notification\", new NotificationDisableDefinitionParser());\n        registerMuleBeanDefinitionParser(\"notification-listener\", new ChildDefinitionParser(\"allListenerSubscriptionPair\", ListenerSubscriptionPair.class)).addAlias(\"ref\", \"listener\").addReference(\"listener\");\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"dispatcherThreadingProfile\", MuleProperties.OBJECT_DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"receiverThreadingProfile\", MuleProperties.OBJECT_DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new MuleOrphanDefinitionParser(true));\n\n        //Transformer elements\n\n        registerMuleBeanDefinitionParser(\"transformer\", new ParentDefinitionParser()).addAlias(AbstractMuleBeanDefinitionParser.ATTRIBUTE_REF, \"messageProcessor\");\n\n        registerBeanDefinitionParser(\"custom-transformer\", new MessageProcessorDefinitionParser());\n        registerBeanDefinitionParser(\"auto-transformer\", new MessageProcessorDefinitionParser(AutoTransformer.class));\n        registerBeanDefinitionParser(\"message-properties-transformer\", new MessagePropertiesTransformerDefinitionParser());\n        registerBeanDefinitionParser(\"set-property\", new MessageProcessorDefinitionParser(AddPropertyTransformer.class));\n        registerBeanDefinitionParser(\"remove-property\", new MessageProcessorDefinitionParser(RemovePropertyTransformer.class));\n        registerBeanDefinitionParser(\"copy-properties\", new MessageProcessorDefinitionParser(CopyPropertiesTransformer.class));\n        registerBeanDefinitionParser(\"set-variable\", new MessageProcessorDefinitionParser(AddFlowVariableTransformer.class));\n        registerBeanDefinitionParser(\"remove-variable\", new MessageProcessorDefinitionParser(RemoveFlowVariableTransformer.class));\n        registerBeanDefinitionParser(\"set-session-variable\", new MessageProcessorDefinitionParser(AddSessionVariableTransformer.class));\n        registerBeanDefinitionParser(\"remove-session-variable\", new MessageProcessorDefinitionParser(RemoveSessionVariableTransformer.class));\n        registerBeanDefinitionParser(\"set-attachment\", new MessageProcessorDefinitionParser(AddAttachmentTransformer.class));\n        registerBeanDefinitionParser(\"remove-attachment\", new MessageProcessorDefinitionParser(RemoveAttachmentTransformer.class));\n        registerBeanDefinitionParser(\"copy-attachments\", new MessageProcessorDefinitionParser(CopyAttachmentsTransformer.class));\n\n        registerMuleBeanDefinitionParser(\"expression-transformer\", new ExpressionTransformerDefinitionParser(\n                ExpressionTransformer.class));\n\n        registerBeanDefinitionParser(\"return-argument\", new ChildDefinitionParser(\"argument\", ExpressionArgument.class));\n\n        registerBeanDefinitionParser(\"bean-builder-transformer\", new MessageProcessorDefinitionParser(BeanBuilderTransformer.class));\n\n        final ChildDefinitionParser beanPropertyParser = new ChildDefinitionParser(\"argument\", ExpressionArgument.class);\n        beanPropertyParser.addAlias(\"property-name\", \"name\");\n        registerBeanDefinitionParser(\"bean-property\", beanPropertyParser);\n\n        registerBeanDefinitionParser(\"base64-encoder-transformer\", new MessageProcessorDefinitionParser(Base64Encoder.class));\n        registerBeanDefinitionParser(\"base64-decoder-transformer\", new MessageProcessorDefinitionParser(Base64Decoder.class));\n\n        registerBeanDefinitionParser(\"xml-entity-encoder-transformer\", new MessageProcessorDefinitionParser(XmlEntityEncoder.class));\n        registerBeanDefinitionParser(\"xml-entity-decoder-transformer\", new MessageProcessorDefinitionParser(XmlEntityDecoder.class));\n        registerBeanDefinitionParser(\"gzip-compress-transformer\", new MessageProcessorDefinitionParser(GZipCompressTransformer.class));\n        registerBeanDefinitionParser(\"gzip-uncompress-transformer\", new MessageProcessorDefinitionParser(GZipUncompressTransformer.class));\n        registerBeanDefinitionParser(\"encrypt-transformer\", new MessageProcessorDefinitionParser(EncryptionTransformer.class));\n        registerBeanDefinitionParser(\"decrypt-transformer\", new MessageProcessorDefinitionParser(DecryptionTransformer.class));\n        registerBeanDefinitionParser(\"byte-array-to-hex-string-transformer\", new MessageProcessorDefinitionParser(ByteArrayToHexString.class));\n        registerBeanDefinitionParser(\"hex-string-to-byte-array-transformer\", new MessageProcessorDefinitionParser(HexStringToByteArray.class));\n\n        registerBeanDefinitionParser(\"byte-array-to-object-transformer\", new MessageProcessorDefinitionParser(ByteArrayToObject.class));\n        registerBeanDefinitionParser(\"object-to-byte-array-transformer\", new MessageProcessorDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"object-to-string-transformer\", new MessageProcessorDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"byte-array-to-serializable-transformer\", new MessageProcessorDefinitionParser(ByteArrayToSerializable.class));\n        registerBeanDefinitionParser(\"serializable-to-byte-array-transformer\", new MessageProcessorDefinitionParser(SerializableToByteArray.class));\n        registerBeanDefinitionParser(\"byte-array-to-string-transformer\", new MessageProcessorDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"string-to-byte-array-transformer\", new MessageProcessorDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"parse-template\", new MessageProcessorDefinitionParser(ParseTemplateTransformer.class));\n        registerBeanDefinitionParser(\"set-payload\", new MessageProcessorDefinitionParser(SetPayloadTransformer.class));\n\n        registerBeanDefinitionParser(\"append-string-transformer\", new MessageProcessorDefinitionParser(StringAppendTransformer.class));\n\n        registerBeanDefinitionParser(\"map-to-bean-transformer\", new MessageProcessorDefinitionParser(MapToBean.class));\n        registerBeanDefinitionParser(\"bean-to-map-transformer\", new MessageProcessorDefinitionParser(BeanToMap.class));\n\n        registerMuleBeanDefinitionParser(\"combine-collections-transformer\", new MessageProcessorDefinitionParser(CombineCollectionsTransformer.class)).addIgnored(\"name\");\n        \n        //Transaction Managers\n        registerBeanDefinitionParser(\"custom-transaction-manager\", new TransactionManagerDefinitionParser());\n        registerBeanDefinitionParser(\"jndi-transaction-manager\", new TransactionManagerDefinitionParser(GenericTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"weblogic-transaction-manager\", new TransactionManagerDefinitionParser(WeblogicTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jboss-transaction-manager\", new TransactionManagerDefinitionParser(JBossTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jrun-transaction-manager\", new TransactionManagerDefinitionParser(JRunTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"resin-transaction-manager\", new TransactionManagerDefinitionParser(Resin3TransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"websphere-transaction-manager\", new TransactionManagerDefinitionParser(WebsphereTransactionManagerLookupFactory.class));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"inbound-endpoint\", new ChildEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"outbound-endpoint\", new ChildEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"custom-transaction\", new TransactionDefinitionParser());\n        registerBeanDefinitionParser(\"xa-transaction\", new TransactionDefinitionParser(XaTransactionFactory.class));\n        registerBeanDefinitionParser(\"idempotent-redelivery-policy\", new ChildDefinitionParser(\"redeliveryPolicy\", IdempotentRedeliveryPolicy.class));\n\n        // Message Processors\n        registerMuleBeanDefinitionParser(\"processor\", new ParentDefinitionParser()).addAlias(AbstractMuleBeanDefinitionParser.ATTRIBUTE_REF, \"messageProcessor\");\n        registerMuleBeanDefinitionParser(\"custom-processor\", new MessageProcessorDefinitionParser()).addIgnored(\"name\");\n        registerBeanDefinitionParser(\"processor-chain\", new MessageProcessorChainDefinitionParser());\n        registerBeanDefinitionParser(\"sub-flow\", new MuleOrphanDefinitionParser(MessageProcessorChainFactoryBean.class, false));\n        registerBeanDefinitionParser(\"response\", new ResponseDefinitionParser());\n        registerMuleBeanDefinitionParser(\"message-filter\", new MessageFilterDefinitionParser());\n        registerMuleBeanDefinitionParser(\"invoke\",\n            new MessageProcessorDefinitionParser(InvokerMessageProcessor.class)).addAlias(\"method\",\n            \"methodName\").addAlias(\"methodArguments\", \"argumentExpressionsString\").addAlias(\n            \"methodArgumentTypes\", \"ArgumentTypes\");\n        registerMuleBeanDefinitionParser(\"enricher\",\n            new MessageEnricherDefinitionParser(\"messageProcessor\", MessageEnricher.class)).addIgnored(\n            \"source\")\n            .addIgnored(\"target\")\n            .registerPreProcessor(\n                new CheckExclusiveAttributesAndChildren(new String[]{\"source\", \"target\"},\n                    new String[]{\"enrich\"}))\n            .registerPreProcessor(\n                new CheckRequiredAttributesWhenNoChildren(new String[][]{new String[]{\"target\"}}, \"enrich\"))\n            .addCollection(\"enrichExpressionPairs\");\n        registerMuleBeanDefinitionParser(\"enrich\", new ChildDefinitionParser(\"enrichExpressionPair\",\n            EnrichExpressionPair.class));\n\n        registerBeanDefinitionParser(\"async\", new AsyncMessageProcessorsDefinitionParser());\n        registerBeanDefinitionParser(\"transactional\", new ChildDefinitionParser(\"messageProcessor\",\n            TransactionalMessageProcessorsFactoryBean.class));\n        registerMuleBeanDefinitionParser(\"logger\", new ChildDefinitionParser(\"messageProcessor\",\n            LoggerMessageProcessor.class));\n        registerMuleBeanDefinitionParser(\"eval\", new ChildDefinitionParser(\"messageProcessor\",\n            ExpressionLanguageExecutor.class));\n\n        // Message Sources\n        registerBeanDefinitionParser(\"custom-source\", new ChildDefinitionParser(\"messageSource\", null, MessageSource.class));\n        registerBeanDefinitionParser(\"composite-source\", new ChildDefinitionParser(\"messageSource\", CompositeMessageSourceFactoryBean.class));\n        registerBeanDefinitionParser(\"poll\", new ChildEndpointDefinitionParser(PollingMessageSourceFactoryBean.class));\n\n        // Models\n        registerBeanDefinitionParser(\"model\", new ModelDefinitionParser());\n        registerBeanDefinitionParser(\"seda-model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n\n        registerBeanDefinitionParser(\"entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", DefaultEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"legacy-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", LegacyEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"custom-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\"));\n\n        registerBeanDefinitionParser(\"custom-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\"));\n        registerBeanDefinitionParser(\"callable-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"property-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", MethodHeaderPropertyEntryPointResolver.class)).addAlias(\"property\", \"methodProperty\");\n        registerBeanDefinitionParser(\"method-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ExplicitMethodEntryPointResolver.class));\n        registerBeanDefinitionParser(\"reflection-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ReflectionEntryPointResolver.class));\n        registerBeanDefinitionParser(\"no-arguments-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", NoArgumentsEntryPointResolver.class));\n        registerBeanDefinitionParser(\"array-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ArrayEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"include-entry-point\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"exclude-entry-point\", new ParentDefinitionParser()).addAlias(\"method\", \"ignoredMethod\");\n        registerMuleBeanDefinitionParser(\"exclude-object-methods\", new IgnoreObjectMethodsDefinitionParser());\n\n        // Services\n        registerBeanDefinitionParser(\"seda-service\", new ServiceDefinitionParser(SedaService.class));\n        registerBeanDefinitionParser(\"service\", new ServiceDefinitionParser(SedaService.class));\n        registerBeanDefinitionParser(\"custom-service\", new ServiceDefinitionParser());\n\n        // Flow Constructs\n        registerBeanDefinitionParser(\"flow\", new FlowDefinitionParser());\n        registerBeanDefinitionParser(\"simple-service\", new SimpleServiceDefinitionParser());\n        registerBeanDefinitionParser(\"bridge\", new BridgeDefinitionParser());\n        registerBeanDefinitionParser(\"validator\", new ValidatorDefinitionParser());\n\n        registerBeanDefinitionParser(\"flow-ref\", new FlowRefDefinitionParser());\n        \n        // Processing Strategies\n        registerMuleBeanDefinitionParser(\"asynchronous-processing-strategy\",\n            new OrphanDefinitionParser(AsynchronousProcessingStrategy.class, false)).addMapping(\n            \"poolExhaustedAction\", ThreadingProfile.POOL_EXHAUSTED_ACTIONS).addIgnored(\"name\");\n        registerMuleBeanDefinitionParser(\"queued-asynchronous-processing-strategy\",\n            new OrphanDefinitionParser(QueuedAsynchronousProcessingStrategy.class, false)).addMapping(\n            \"poolExhaustedAction\", ThreadingProfile.POOL_EXHAUSTED_ACTIONS).addIgnored(\"name\");\n        registerMuleBeanDefinitionParser(\"thread-per-processor-processing-strategy\",\n            new OrphanDefinitionParser(ThreadPerProcessorProcessingStrategy.class, false)).addMapping(\n            \"poolExhaustedAction\", ThreadingProfile.POOL_EXHAUSTED_ACTIONS).addIgnored(\"name\");\n        registerMuleBeanDefinitionParser(\"queued-thread-per-processor-processing-strategy\",\n            new OrphanDefinitionParser(QueuedThreadPerProcessorProcessingStrategy.class, false)).addMapping(\n            \"poolExhaustedAction\", ThreadingProfile.POOL_EXHAUSTED_ACTIONS).addIgnored(\"name\");\n        registerMuleBeanDefinitionParser(\"custom-processing-strategy\", new OrphanDefinitionParser(false)).addIgnored(\n            \"name\");\n\n        // Components\n        registerBeanDefinitionParser(\"component\", new ComponentDelegatingDefinitionParser(DefaultJavaComponent.class));\n        registerBeanDefinitionParser(\"pooled-component\", new ComponentDelegatingDefinitionParser(PooledJavaComponent.class));\n\n        registerMuleBeanDefinitionParser(\"binding\", new BindingDefinitionParser(\"interfaceBinding\", DefaultInterfaceBinding.class));\n\n        // Simple Components\n        registerBeanDefinitionParser(\"pass-through-component\", new ComponentDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"log-component\", new SimpleComponentDefinitionParser(SimpleCallableJavaComponent.class, LogComponent.class));\n        registerBeanDefinitionParser(\"null-component\", new SimpleComponentDefinitionParser(SimpleCallableJavaComponent.class, NullComponent.class));\n        registerBeanDefinitionParser(\"static-component\", new StaticComponentDefinitionParser());\n        registerIgnoredElement(\"return-data\"); // Handled by StaticComponentDefinitionParser\n\n        // We need to use DefaultJavaComponent for the echo component because some tests invoke EchoComponent with method name and therefore we need an entry point resolver\n        registerBeanDefinitionParser(\"echo-component\", new SimpleComponentDefinitionParser(DefaultJavaComponent.class, EchoComponent.class));\n\n        // Object Factories\n        registerBeanDefinitionParser(\"singleton-object\", new ObjectFactoryDefinitionParser(SingletonObjectFactory.class, \"objectFactory\"));\n        registerBeanDefinitionParser(\"prototype-object\", new ObjectFactoryDefinitionParser(PrototypeObjectFactory.class, \"objectFactory\"));\n        registerBeanDefinitionParser(\"spring-object\", new ObjectFactoryDefinitionParser(SpringBeanLookup.class, \"objectFactory\"));\n\n        // Life-cycle Adapters Factories\n        registerBeanDefinitionParser(\"custom-lifecycle-adapter-factory\", new ChildDefinitionParser(\"lifecycleAdapterFactory\"));\n\n        //Stores\n        registerBeanDefinitionParser(\"in-memory-store\", new ChildDefinitionParser(\"store\", InMemoryObjectStore.class));\n        registerBeanDefinitionParser(\"simple-text-file-store\", new ChildDefinitionParser(\"store\", TextFileObjectStore.class));\n        registerBeanDefinitionParser(\"custom-object-store\",new ChildDefinitionParser(\"store\", null));\n        registerBeanDefinitionParser(\"spring-object-store\",(BeanDefinitionParser)new ParentDefinitionParser().addAlias(\"ref\", \"store\"));\n        registerBeanDefinitionParser(\"managed-store\", new ChildDefinitionParser(\"store\",ManagedObjectStore.class));\n\n        //Routers\n        registerBeanDefinitionParser(\"inbound\", new ChildDefinitionParser(\"messageSource\", ServiceCompositeMessageSource.class, true));\n        registerBeanDefinitionParser(\"outbound\", new ChildDefinitionParser(\"outboundMessageProcessor\", DefaultOutboundRouterCollection.class, true));\n        registerBeanDefinitionParser(\"async-reply\", new ChildDefinitionParser(\"asyncReplyMessageSource\", ServiceAsyncReplyCompositeMessageSource.class, true));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"forwarding-router\", new InboundRouterDefinitionParser(ForwardingConsumer.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new InboundRouterDefinitionParser(IdempotentMessageFilter.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new InboundRouterDefinitionParser(IdempotentSecureHashMessageFilter.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new InboundRouterDefinitionParser(MessageFilter.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new InboundRouterDefinitionParser(WireTap.class));\n        registerBeanDefinitionParser(\"custom-correlation-aggregator-router\", new InboundRouterDefinitionParser());\n        registerBeanDefinitionParser(\"collection-aggregator-router\", new InboundRouterDefinitionParser(SimpleCollectionAggregator.class));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new InboundRouterDefinitionParser(MessageChunkAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new InboundRouterDefinitionParser(Resequencer.class));\n        registerBeanDefinitionParser(\"custom-inbound-router\", new InboundRouterDefinitionParser(null));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"pass-through-router\", new RouterDefinitionParser(OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"recipient-list-exception-based-router\", new RouterDefinitionParser(ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(ListMessageSplitter.class));\n        registerBeanDefinitionParser(\"expression-splitter-router\", new RouterDefinitionParser(ExpressionMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(StaticRecipientList.class));\n        registerBeanDefinitionParser(\"expression-recipient-list-router\", new RouterDefinitionParser(ExpressionRecipientList.class));\n        registerBeanDefinitionParser(\"recipients\", new ChildListDefinitionParser(\"recipients\"));\n        registerBeanDefinitionParser(\"custom-outbound-router\", new RouterDefinitionParser(null));\n        registerBeanDefinitionParser(\"reply-to\", new EndpointRefParser(\"replyTo\"));\n        registerBeanDefinitionParser(\"sequence-router\", new RouterDefinitionParser(SequenceRouter.class));\n\n        //Response Routers\n        registerBeanDefinitionParser(\"custom-async-reply-router\", new InboundRouterDefinitionParser(null));\n        registerBeanDefinitionParser(\"single-async-reply-router\", new InboundRouterDefinitionParser(NullMessageProcessor.class));\n        registerBeanDefinitionParser(\"collection-async-reply-router\", new InboundRouterDefinitionParser(SimpleCollectionAggregator.class));\n\n        // Routing: Intercepting Message Processors\n        registerMuleBeanDefinitionParser(\"idempotent-message-filter\", new MessageProcessorDefinitionParser(IdempotentMessageFilter.class)).addIgnored(\"name\");\n        registerMuleBeanDefinitionParser(\"idempotent-secure-hash-message-filter\", new MessageProcessorDefinitionParser(IdempotentSecureHashMessageFilter.class)).addIgnored(\"name\");\n        registerBeanDefinitionParser(\"wire-tap\", new InboundRouterDefinitionParser(WireTap.class));\n        registerBeanDefinitionParser(\"custom-aggregator\", new AggregatorDefinitionParser());\n        registerBeanDefinitionParser(\"collection-aggregator\", new AggregatorDefinitionParser(SimpleCollectionAggregator.class));\n        registerBeanDefinitionParser(\"message-chunk-aggregator\", new AggregatorDefinitionParser(MessageChunkAggregator.class));\n        registerBeanDefinitionParser(\"resequencer\", new InboundRouterDefinitionParser(Resequencer.class));\n        registerBeanDefinitionParser(\"splitter\", new SplitterDefinitionParser(ExpressionSplitter.class));\n        registerBeanDefinitionParser(\"collection-splitter\", new SplitterDefinitionParser(CollectionSplitter.class));\n        registerBeanDefinitionParser(\"map-splitter\", new SplitterDefinitionParser(MapSplitter.class));\n        registerBeanDefinitionParser(\"message-chunk-splitter\", new SplitterDefinitionParser(MessageChunkSplitter.class));\n        registerBeanDefinitionParser(\"custom-splitter\", new SplitterDefinitionParser());\n        registerMuleBeanDefinitionParser(\"foreach\", new ChildDefinitionParser(\"messageProcessor\", Foreach.class)).addAlias(\"collection\", \"collectionExpression\");\n\n        // Routing: Routing Message Processors\n\n        // Routing: Conditional Routers\n        registerBeanDefinitionParser(\"choice\", new ChildDefinitionParser(\"messageProcessor\", ChoiceRouterFactoryBean.class));\n        registerBeanDefinitionParser(\"when\", (ChildDefinitionParser)new ChildDefinitionParser(\"route\", MessageProcessorFilterPairFactoryBean.class).registerPreProcessor(new CheckExclusiveAttributesAndChildren(new String[]{\n            \"expression\"}, new String[]{\"{http://www.mulesoft.org/schema/mule/core}abstractFilterType\"})));\n        registerBeanDefinitionParser(\"otherwise\", new ChildDefinitionParser(\"defaultRoute\", MessageProcessorFilterPairFactoryBean.class));\n\n        registerBeanDefinitionParser(\"all\", new ChildDefinitionParser(\"messageProcessor\", MulticastingRouter.class));\n        registerBeanDefinitionParser(\"recipient-list\", new ChildDefinitionParser(\"messageProcessor\", ExpressionRecipientList.class));\n\n        registerBeanDefinitionParser(\"request-reply\", new ChildDefinitionParser(\"messageProcessor\", SimpleAsyncRequestReplyRequester.class));\n        registerBeanDefinitionParser(\"first-successful\", new ChildDefinitionParser(\"messageProcessor\", FirstSuccessful.class));\n        registerBeanDefinitionParser(\"until-successful\", new ChildDefinitionParser(\"messageProcessor\", UntilSuccessful.class));\n        registerBeanDefinitionParser(\"round-robin\", new ChildDefinitionParser(\"messageProcessor\", RoundRobin.class));\n        registerBeanDefinitionParser(\"dead-letter-queue\", new ChildDefinitionParser(\"deadLetterQueue\", MessageProcessorFilterPairFactoryBean.class));\n\n        registerBeanDefinitionParser(\"custom-router\", new ChildDefinitionParser(\"messageProcessor\"));\n\n        //Message Info Mappings\n        registerBeanDefinitionParser(\"expression-message-info-mapping\", new ChildDefinitionParser(\"messageInfoMapping\", ExpressionMessageInfoMapping.class));\n        registerBeanDefinitionParser(\"custom-message-info-mapping\", new ChildDefinitionParser(\"messageInfoMapping\"));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"logging-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", LoggingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerMuleBeanDefinitionParser(\"filter\", new FilterRefDefinitionParser());\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser(AndFilter.class));\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser(OrFilter.class));\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser(NotFilter.class));\n        registerBeanDefinitionParser(\"regex-filter\", new RegExFilterDefinitionParser());\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser(ExceptionTypeFilter.class));\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser(MessagePropertyFilter.class));\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser(PayloadTypeFilter.class));\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser(WildcardFilter.class));\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser(EqualsFilter.class));\n        registerBeanDefinitionParser(\"expression-filter\", new FilterDefinitionParser(ExpressionFilter.class));\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Utils / Standard Types\n        registerMuleBeanDefinitionParser(\"properties\", new ChildMapDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"property\", new ChildMapEntryDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"add-message-properties\", new ChildMapDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"add-message-property\", new ChildMapEntryDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"rename-message-property\", new ChildMapEntryDefinitionParser(\"renameProperties\")).addCollection(\"renameProperties\");\n        registerBeanDefinitionParser(\"delete-message-property\", new ChildListEntryDefinitionParser(\"deleteProperties\", ChildMapEntryDefinitionParser.KEY));\n        registerMuleBeanDefinitionParser(\"jndi-provider-properties\", new ChildMapDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerMuleBeanDefinitionParser(\"jndi-provider-property\", new ChildMapEntryDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerBeanDefinitionParser(\"environment\", new ChildMapDefinitionParser(\"environment\"));\n        registerBeanDefinitionParser(\"expression\", new ChildDefinitionParser(\"expression\", ExpressionConfig.class));\n\n        //Security\n        registerMuleBeanDefinitionParser(\"security-manager\", new NamedDefinitionParser(MuleProperties.OBJECT_SECURITY_MANAGER)).addIgnored(\"type\").addIgnored(\"name\");\n        registerBeanDefinitionParser(\"custom-security-provider\", new NameTransferDefinitionParser(\"providers\"));\n        registerMuleBeanDefinitionParser(\"custom-encryption-strategy\", new NameTransferDefinitionParser(\"encryptionStrategies\")).addAlias(\"strategy\", \"encryptionStrategy\");\n        registerBeanDefinitionParser(\"password-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", PasswordBasedEncryptionStrategy.class));\n        registerMuleBeanDefinitionParser(\"secret-key-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", SecretKeyEncryptionStrategy.class)).registerPreProcessor(new CheckExclusiveAttributes(new String[][]{new String[]{\"key\"}, new String[]{\"keyFactory-ref\"}}));\n        registerBeanDefinitionParser(\"encryption-security-filter\", new SecurityFilterDefinitionParser(MuleEncryptionEndpointSecurityFilter.class));\n        registerBeanDefinitionParser(\"custom-security-filter\", new SecurityFilterDefinitionParser());\n        registerBeanDefinitionParser(\"username-password-filter\", new SecurityFilterDefinitionParser(UsernamePasswordAuthenticationFilter.class));\n        \n        //Interceptors\n        registerMuleBeanDefinitionParser(\"interceptor-stack\", new InterceptorStackDefinitionParser());\n        registerBeanDefinitionParser(\"custom-interceptor\", new InterceptorDefinitionParser());\n        registerBeanDefinitionParser(\"timer-interceptor\", new InterceptorDefinitionParser(TimerInterceptor.class));\n        registerBeanDefinitionParser(\"logging-interceptor\", new InterceptorDefinitionParser(LoggingInterceptor.class));\n    }","id":73288,"modified_method":"@Override\n    public void init()\n    {\n        registerIgnoredElement(\"mule\");\n        registerIgnoredElement(\"description\");\n\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"global-property\", new GlobalPropertyDefinitionParser());\n        registerBeanDefinitionParser(\"default-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-receiver-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-service-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_SERVICE_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"threading-profile\", new ThreadingProfileDefinitionParser(\"threadingProfile\", MuleProperties.OBJECT_DEFAULT_SERVICE_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"custom-agent\", new DefaultNameMuleOrphanDefinitionParser());\n        registerBeanDefinitionParser(\"expression-language\", new ExpressionLanguageDefinitionParser());\n        registerBeanDefinitionParser(\"global-functions\", new TextDefinitionParser(\"globalFunctionsString\"));\n        registerMuleBeanDefinitionParser(\"alias\", new ChildMapEntryDefinitionParser(\"aliases\")).addAlias(\"name\", \"key\").addAlias(\"expression\", \"value\");\n        registerMuleBeanDefinitionParser(\"import\", new ImportMapEntryDefinitionParser(\"import\"));\n\n        // Exception Strategies\n        registerBeanDefinitionParser(\"default-exception-strategy\", new ExceptionStrategyDefinitionParser(DefaultMessagingExceptionStrategy.class));\n        registerBeanDefinitionParser(\"catch-exception-strategy\", new ExceptionStrategyDefinitionParser(CatchMessagingExceptionStrategy.class));\n        registerBeanDefinitionParser(\"rollback-exception-strategy\", new ExceptionStrategyDefinitionParser(RollbackMessagingExceptionStrategy.class));\n        registerBeanDefinitionParser(\"on-redelivery-attempts-exceeded\", new ChildDefinitionParser(\"redeliveryExceeded\", RedeliveryExceeded.class));\n        registerBeanDefinitionParser(\"choice-exception-strategy\", new ExceptionStrategyDefinitionParser(ChoiceMessagingExceptionStrategy.class));\n        registerMuleBeanDefinitionParser(\"exception-strategy\", new ReferenceExceptionStrategyDefinitionParser());\n        registerDeprecatedBeanDefinitionParser(\"default-service-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultMessagingExceptionStrategy.class), \"Use default-exception-strategy instead.\");\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new ExceptionStrategyDefinitionParser(null));\n        registerBeanDefinitionParser(\"commit-transaction\", new ExceptionTXFilterDefinitionParser(\"commitTxFilter\"));\n        registerBeanDefinitionParser(\"rollback-transaction\", new ExceptionTXFilterDefinitionParser(\"rollbackTxFilter\"));\n\n        // Reconnection Strategies\n        registerBeanDefinitionParser(\"reconnect\", new RetryPolicyDefinitionParser(SimpleRetryPolicyTemplate.class));\n        registerBeanDefinitionParser(\"reconnect-forever\", new RetryPolicyDefinitionParser(RetryForeverPolicyTemplate.class));\n        registerBeanDefinitionParser(\"reconnect-custom-strategy\", new RetryPolicyDefinitionParser());\n        registerBeanDefinitionParser(\"reconnect-notifier\", new RetryNotifierDefinitionParser(ConnectNotifier.class));\n        registerBeanDefinitionParser(\"reconnect-custom-notifier\", new RetryNotifierDefinitionParser());\n\n        // Queue Store\n        registerMuleBeanDefinitionParser(\"queue-store\", new ParentDefinitionParser()).addAlias(AbstractMuleBeanDefinitionParser.ATTRIBUTE_REF, \"queue-store\");\n        registerMuleBeanDefinitionParser(\"custom-queue-store\", new QueueStoreDefinitionParser()).addIgnored(\"name\");\n        registerBeanDefinitionParser(\"default-in-memory-queue-store\", new QueueStoreDefinitionParser(DefaultMemoryQueueStoreFactoryBean.class));\n        registerBeanDefinitionParser(\"default-persistent-queue-store\", new QueueStoreDefinitionParser(DefaultPersistentQueueStoreFactoryBean.class));\n        registerBeanDefinitionParser(\"simple-in-memory-queue-store\", new QueueStoreDefinitionParser(SimpleMemoryQueueStoreFactoryBean.class));\n        registerBeanDefinitionParser(\"file-queue-store\", new QueueStoreDefinitionParser(FileQueueStoreFactoryBean.class));\n        \n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new ChildDefinitionParser(\"queueProfile\", QueueProfileFactoryBean.class));\n        registerMuleBeanDefinitionParser(\"notifications\", new NamedDefinitionParser(MuleProperties.OBJECT_NOTIFICATION_MANAGER)).addAlias(\"dynamic\", \"notificationDynamic\");\n        registerBeanDefinitionParser(\"notification\", new NotificationDefinitionParser());\n        registerBeanDefinitionParser(\"disable-notification\", new NotificationDisableDefinitionParser());\n        registerMuleBeanDefinitionParser(\"notification-listener\", new ChildDefinitionParser(\"allListenerSubscriptionPair\", ListenerSubscriptionPair.class)).addAlias(\"ref\", \"listener\").addReference(\"listener\");\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"dispatcherThreadingProfile\", MuleProperties.OBJECT_DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"receiverThreadingProfile\", MuleProperties.OBJECT_DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new MuleOrphanDefinitionParser(true));\n\n        //Transformer elements\n\n        registerMuleBeanDefinitionParser(\"transformer\", new ParentDefinitionParser()).addAlias(AbstractMuleBeanDefinitionParser.ATTRIBUTE_REF, \"messageProcessor\");\n\n        registerBeanDefinitionParser(\"custom-transformer\", new MessageProcessorDefinitionParser());\n        registerBeanDefinitionParser(\"auto-transformer\", new MessageProcessorDefinitionParser(AutoTransformer.class));\n        registerBeanDefinitionParser(\"message-properties-transformer\", new MessagePropertiesTransformerDefinitionParser());\n        registerBeanDefinitionParser(\"set-property\", new MessageProcessorDefinitionParser(AddPropertyTransformer.class));\n        registerBeanDefinitionParser(\"remove-property\", new MessageProcessorDefinitionParser(RemovePropertyTransformer.class));\n        registerBeanDefinitionParser(\"copy-properties\", new MessageProcessorDefinitionParser(CopyPropertiesTransformer.class));\n        registerBeanDefinitionParser(\"set-variable\", new MessageProcessorDefinitionParser(AddFlowVariableTransformer.class));\n        registerBeanDefinitionParser(\"remove-variable\", new MessageProcessorDefinitionParser(RemoveFlowVariableTransformer.class));\n        registerBeanDefinitionParser(\"set-session-variable\", new MessageProcessorDefinitionParser(AddSessionVariableTransformer.class));\n        registerBeanDefinitionParser(\"remove-session-variable\", new MessageProcessorDefinitionParser(RemoveSessionVariableTransformer.class));\n        registerBeanDefinitionParser(\"set-attachment\", new MessageProcessorDefinitionParser(AddAttachmentTransformer.class));\n        registerBeanDefinitionParser(\"remove-attachment\", new MessageProcessorDefinitionParser(RemoveAttachmentTransformer.class));\n        registerBeanDefinitionParser(\"copy-attachments\", new MessageProcessorDefinitionParser(CopyAttachmentsTransformer.class));\n\n        registerMuleBeanDefinitionParser(\"expression-transformer\", new ExpressionTransformerDefinitionParser(\n                ExpressionTransformer.class));\n\n        registerBeanDefinitionParser(\"return-argument\", new ChildDefinitionParser(\"argument\", ExpressionArgument.class));\n\n        registerBeanDefinitionParser(\"bean-builder-transformer\", new MessageProcessorDefinitionParser(BeanBuilderTransformer.class));\n\n        final ChildDefinitionParser beanPropertyParser = new ChildDefinitionParser(\"argument\", ExpressionArgument.class);\n        beanPropertyParser.addAlias(\"property-name\", \"name\");\n        registerBeanDefinitionParser(\"bean-property\", beanPropertyParser);\n\n        registerBeanDefinitionParser(\"base64-encoder-transformer\", new MessageProcessorDefinitionParser(Base64Encoder.class));\n        registerBeanDefinitionParser(\"base64-decoder-transformer\", new MessageProcessorDefinitionParser(Base64Decoder.class));\n\n        registerBeanDefinitionParser(\"xml-entity-encoder-transformer\", new MessageProcessorDefinitionParser(XmlEntityEncoder.class));\n        registerBeanDefinitionParser(\"xml-entity-decoder-transformer\", new MessageProcessorDefinitionParser(XmlEntityDecoder.class));\n        registerBeanDefinitionParser(\"gzip-compress-transformer\", new MessageProcessorDefinitionParser(GZipCompressTransformer.class));\n        registerBeanDefinitionParser(\"gzip-uncompress-transformer\", new MessageProcessorDefinitionParser(GZipUncompressTransformer.class));\n        registerBeanDefinitionParser(\"encrypt-transformer\", new MessageProcessorDefinitionParser(EncryptionTransformer.class));\n        registerBeanDefinitionParser(\"decrypt-transformer\", new MessageProcessorDefinitionParser(DecryptionTransformer.class));\n        registerBeanDefinitionParser(\"byte-array-to-hex-string-transformer\", new MessageProcessorDefinitionParser(ByteArrayToHexString.class));\n        registerBeanDefinitionParser(\"hex-string-to-byte-array-transformer\", new MessageProcessorDefinitionParser(HexStringToByteArray.class));\n\n        registerBeanDefinitionParser(\"byte-array-to-object-transformer\", new MessageProcessorDefinitionParser(ByteArrayToObject.class));\n        registerBeanDefinitionParser(\"object-to-byte-array-transformer\", new MessageProcessorDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"object-to-string-transformer\", new MessageProcessorDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"byte-array-to-serializable-transformer\", new MessageProcessorDefinitionParser(ByteArrayToSerializable.class));\n        registerBeanDefinitionParser(\"serializable-to-byte-array-transformer\", new MessageProcessorDefinitionParser(SerializableToByteArray.class));\n        registerBeanDefinitionParser(\"byte-array-to-string-transformer\", new MessageProcessorDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"string-to-byte-array-transformer\", new MessageProcessorDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"parse-template\", new MessageProcessorDefinitionParser(ParseTemplateTransformer.class));\n        registerBeanDefinitionParser(\"set-payload\", new MessageProcessorDefinitionParser(SetPayloadTransformer.class));\n\n        registerBeanDefinitionParser(\"append-string-transformer\", new MessageProcessorDefinitionParser(StringAppendTransformer.class));\n\n        registerBeanDefinitionParser(\"map-to-bean-transformer\", new MessageProcessorDefinitionParser(MapToBean.class));\n        registerBeanDefinitionParser(\"bean-to-map-transformer\", new MessageProcessorDefinitionParser(BeanToMap.class));\n\n        registerMuleBeanDefinitionParser(\"combine-collections-transformer\", new MessageProcessorDefinitionParser(CombineCollectionsTransformer.class)).addIgnored(\"name\");\n        \n        //Transaction Managers\n        registerBeanDefinitionParser(\"custom-transaction-manager\", new TransactionManagerDefinitionParser());\n        registerBeanDefinitionParser(\"jndi-transaction-manager\", new TransactionManagerDefinitionParser(GenericTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"weblogic-transaction-manager\", new TransactionManagerDefinitionParser(WeblogicTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jboss-transaction-manager\", new TransactionManagerDefinitionParser(JBossTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jrun-transaction-manager\", new TransactionManagerDefinitionParser(JRunTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"resin-transaction-manager\", new TransactionManagerDefinitionParser(Resin3TransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"websphere-transaction-manager\", new TransactionManagerDefinitionParser(WebsphereTransactionManagerLookupFactory.class));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"inbound-endpoint\", new ChildEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"outbound-endpoint\", new ChildEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"custom-transaction\", new TransactionDefinitionParser());\n        registerBeanDefinitionParser(\"xa-transaction\", new TransactionDefinitionParser(XaTransactionFactory.class));\n        registerBeanDefinitionParser(\"idempotent-redelivery-policy\", new ChildDefinitionParser(\"redeliveryPolicy\", IdempotentRedeliveryPolicy.class));\n\n        // Message Processors\n        registerMuleBeanDefinitionParser(\"processor\", new ParentDefinitionParser()).addAlias(AbstractMuleBeanDefinitionParser.ATTRIBUTE_REF, \"messageProcessor\");\n        registerMuleBeanDefinitionParser(\"custom-processor\", new MessageProcessorDefinitionParser()).addIgnored(\"name\");\n        registerBeanDefinitionParser(\"processor-chain\", new MessageProcessorChainDefinitionParser());\n        registerBeanDefinitionParser(\"sub-flow\", new MuleOrphanDefinitionParser(MessageProcessorChainFactoryBean.class, false));\n        registerBeanDefinitionParser(\"response\", new ResponseDefinitionParser());\n        registerMuleBeanDefinitionParser(\"message-filter\", new MessageFilterDefinitionParser());\n        registerMuleBeanDefinitionParser(\"invoke\",\n            new MessageProcessorDefinitionParser(InvokerMessageProcessor.class)).addAlias(\"method\",\n            \"methodName\").addAlias(\"methodArguments\", \"argumentExpressionsString\").addAlias(\n            \"methodArgumentTypes\", \"ArgumentTypes\");\n        registerMuleBeanDefinitionParser(\"enricher\",\n            new MessageEnricherDefinitionParser(\"messageProcessor\", MessageEnricher.class)).addIgnored(\n            \"source\")\n            .addIgnored(\"target\")\n            .registerPreProcessor(\n                new CheckExclusiveAttributesAndChildren(new String[]{\"source\", \"target\"},\n                    new String[]{\"enrich\"}))\n            .registerPreProcessor(\n                new CheckRequiredAttributesWhenNoChildren(new String[][]{new String[]{\"target\"}}, \"enrich\"))\n            .addCollection(\"enrichExpressionPairs\");\n        registerMuleBeanDefinitionParser(\"enrich\", new ChildDefinitionParser(\"enrichExpressionPair\",\n            EnrichExpressionPair.class));\n\n        registerBeanDefinitionParser(\"async\", new AsyncMessageProcessorsDefinitionParser());\n        registerBeanDefinitionParser(\"transactional\", new ChildDefinitionParser(\"messageProcessor\",\n            TransactionalMessageProcessorsFactoryBean.class));\n        registerMuleBeanDefinitionParser(\"logger\", new ChildDefinitionParser(\"messageProcessor\",\n            LoggerMessageProcessor.class));\n        registerMuleBeanDefinitionParser(\"eval\", new ChildDefinitionParser(\"messageProcessor\",\n            ExpressionLanguageExecutor.class));\n\n        // Message Sources\n        registerBeanDefinitionParser(\"custom-source\", new ChildDefinitionParser(\"messageSource\", null, MessageSource.class));\n        registerBeanDefinitionParser(\"composite-source\", new ChildDefinitionParser(\"messageSource\", CompositeMessageSourceFactoryBean.class));\n        registerBeanDefinitionParser(\"poll\", new ChildEndpointDefinitionParser(PollingMessageSourceFactoryBean.class));\n\n        // Models\n        registerBeanDefinitionParser(\"model\", new ModelDefinitionParser());\n        registerBeanDefinitionParser(\"seda-model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n\n        registerBeanDefinitionParser(\"entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", DefaultEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"legacy-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", LegacyEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"custom-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\"));\n\n        registerBeanDefinitionParser(\"custom-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\"));\n        registerBeanDefinitionParser(\"callable-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"property-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", MethodHeaderPropertyEntryPointResolver.class)).addAlias(\"property\", \"methodProperty\");\n        registerBeanDefinitionParser(\"method-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ExplicitMethodEntryPointResolver.class));\n        registerBeanDefinitionParser(\"reflection-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ReflectionEntryPointResolver.class));\n        registerBeanDefinitionParser(\"no-arguments-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", NoArgumentsEntryPointResolver.class));\n        registerBeanDefinitionParser(\"array-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ArrayEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"include-entry-point\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"exclude-entry-point\", new ParentDefinitionParser()).addAlias(\"method\", \"ignoredMethod\");\n        registerMuleBeanDefinitionParser(\"exclude-object-methods\", new IgnoreObjectMethodsDefinitionParser());\n\n        // Services\n        registerBeanDefinitionParser(\"seda-service\", new ServiceDefinitionParser(SedaService.class));\n        registerBeanDefinitionParser(\"service\", new ServiceDefinitionParser(SedaService.class));\n        registerBeanDefinitionParser(\"custom-service\", new ServiceDefinitionParser());\n\n        // Flow Constructs\n        registerBeanDefinitionParser(\"flow\", new FlowDefinitionParser());\n        registerBeanDefinitionParser(\"simple-service\", new SimpleServiceDefinitionParser());\n        registerBeanDefinitionParser(\"bridge\", new BridgeDefinitionParser());\n        registerBeanDefinitionParser(\"validator\", new ValidatorDefinitionParser());\n\n        registerBeanDefinitionParser(\"flow-ref\", new FlowRefDefinitionParser());\n        \n        // Processing Strategies\n        registerMuleBeanDefinitionParser(\"asynchronous-processing-strategy\",\n            new OrphanDefinitionParser(AsynchronousProcessingStrategy.class, false)).addMapping(\n            \"poolExhaustedAction\", ThreadingProfile.POOL_EXHAUSTED_ACTIONS).addIgnored(\"name\");\n        registerMuleBeanDefinitionParser(\"queued-asynchronous-processing-strategy\",\n            new OrphanDefinitionParser(QueuedAsynchronousProcessingStrategy.class, false)).addMapping(\n            \"poolExhaustedAction\", ThreadingProfile.POOL_EXHAUSTED_ACTIONS).addIgnored(\"name\");\n        registerMuleBeanDefinitionParser(\"thread-per-processor-processing-strategy\",\n            new OrphanDefinitionParser(ThreadPerProcessorProcessingStrategy.class, false)).addMapping(\n            \"poolExhaustedAction\", ThreadingProfile.POOL_EXHAUSTED_ACTIONS).addIgnored(\"name\");\n        registerMuleBeanDefinitionParser(\"queued-thread-per-processor-processing-strategy\",\n            new OrphanDefinitionParser(QueuedThreadPerProcessorProcessingStrategy.class, false)).addMapping(\n            \"poolExhaustedAction\", ThreadingProfile.POOL_EXHAUSTED_ACTIONS).addIgnored(\"name\");\n        registerMuleBeanDefinitionParser(\"custom-processing-strategy\", new OrphanDefinitionParser(false)).addIgnored(\n            \"name\");\n\n        // Components\n        registerBeanDefinitionParser(\"component\", new ComponentDelegatingDefinitionParser(DefaultJavaComponent.class));\n        registerBeanDefinitionParser(\"pooled-component\", new ComponentDelegatingDefinitionParser(PooledJavaComponent.class));\n\n        registerMuleBeanDefinitionParser(\"binding\", new BindingDefinitionParser(\"interfaceBinding\", DefaultInterfaceBinding.class));\n\n        // Simple Components\n        registerBeanDefinitionParser(\"pass-through-component\", new ComponentDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"log-component\", new SimpleComponentDefinitionParser(SimpleCallableJavaComponent.class, LogComponent.class));\n        registerBeanDefinitionParser(\"null-component\", new SimpleComponentDefinitionParser(SimpleCallableJavaComponent.class, NullComponent.class));\n        registerBeanDefinitionParser(\"static-component\", new StaticComponentDefinitionParser());\n        registerIgnoredElement(\"return-data\"); // Handled by StaticComponentDefinitionParser\n\n        // We need to use DefaultJavaComponent for the echo component because some tests invoke EchoComponent with method name and therefore we need an entry point resolver\n        registerBeanDefinitionParser(\"echo-component\", new SimpleComponentDefinitionParser(DefaultJavaComponent.class, EchoComponent.class));\n\n        // Object Factories\n        registerBeanDefinitionParser(\"singleton-object\", new ObjectFactoryDefinitionParser(SingletonObjectFactory.class, \"objectFactory\"));\n        registerBeanDefinitionParser(\"prototype-object\", new ObjectFactoryDefinitionParser(PrototypeObjectFactory.class, \"objectFactory\"));\n        registerBeanDefinitionParser(\"spring-object\", new ObjectFactoryDefinitionParser(SpringBeanLookup.class, \"objectFactory\"));\n\n        // Life-cycle Adapters Factories\n        registerBeanDefinitionParser(\"custom-lifecycle-adapter-factory\", new ChildDefinitionParser(\"lifecycleAdapterFactory\"));\n\n        //Stores\n        registerBeanDefinitionParser(\"in-memory-store\", new ChildDefinitionParser(\"store\", InMemoryObjectStore.class));\n        registerBeanDefinitionParser(\"simple-text-file-store\", new ChildDefinitionParser(\"store\", TextFileObjectStore.class));\n        registerBeanDefinitionParser(\"custom-object-store\",new ChildDefinitionParser(\"store\", null));\n        registerBeanDefinitionParser(\"spring-object-store\",(BeanDefinitionParser)new ParentDefinitionParser().addAlias(\"ref\", \"store\"));\n        registerBeanDefinitionParser(\"managed-store\", new ChildDefinitionParser(\"store\",ManagedObjectStore.class));\n\n        //Routers\n        registerBeanDefinitionParser(\"inbound\", new ChildDefinitionParser(\"messageSource\", ServiceCompositeMessageSource.class, true));\n        registerBeanDefinitionParser(\"outbound\", new ChildDefinitionParser(\"outboundMessageProcessor\", DefaultOutboundRouterCollection.class, true));\n        registerBeanDefinitionParser(\"async-reply\", new ChildDefinitionParser(\"asyncReplyMessageSource\", ServiceAsyncReplyCompositeMessageSource.class, true));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"forwarding-router\", new InboundRouterDefinitionParser(ForwardingConsumer.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new InboundRouterDefinitionParser(IdempotentMessageFilter.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new InboundRouterDefinitionParser(IdempotentSecureHashMessageFilter.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new InboundRouterDefinitionParser(MessageFilter.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new InboundRouterDefinitionParser(WireTap.class));\n        registerBeanDefinitionParser(\"custom-correlation-aggregator-router\", new InboundRouterDefinitionParser());\n        registerBeanDefinitionParser(\"collection-aggregator-router\", new InboundRouterDefinitionParser(SimpleCollectionAggregator.class));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new InboundRouterDefinitionParser(MessageChunkAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new InboundRouterDefinitionParser(Resequencer.class));\n        registerBeanDefinitionParser(\"custom-inbound-router\", new InboundRouterDefinitionParser(null));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"pass-through-router\", new RouterDefinitionParser(OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"recipient-list-exception-based-router\", new RouterDefinitionParser(ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(ListMessageSplitter.class));\n        registerBeanDefinitionParser(\"expression-splitter-router\", new RouterDefinitionParser(ExpressionMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(StaticRecipientList.class));\n        registerBeanDefinitionParser(\"expression-recipient-list-router\", new RouterDefinitionParser(ExpressionRecipientList.class));\n        registerBeanDefinitionParser(\"recipients\", new ChildListDefinitionParser(\"recipients\"));\n        registerBeanDefinitionParser(\"custom-outbound-router\", new RouterDefinitionParser(null));\n        registerBeanDefinitionParser(\"reply-to\", new EndpointRefParser(\"replyTo\"));\n        registerBeanDefinitionParser(\"sequence-router\", new RouterDefinitionParser(SequenceRouter.class));\n\n        //Response Routers\n        registerBeanDefinitionParser(\"custom-async-reply-router\", new InboundRouterDefinitionParser(null));\n        registerBeanDefinitionParser(\"single-async-reply-router\", new InboundRouterDefinitionParser(NullMessageProcessor.class));\n        registerBeanDefinitionParser(\"collection-async-reply-router\", new InboundRouterDefinitionParser(SimpleCollectionAggregator.class));\n\n        // Routing: Intercepting Message Processors\n        registerMuleBeanDefinitionParser(\"idempotent-message-filter\", new MessageProcessorDefinitionParser(IdempotentMessageFilter.class)).addIgnored(\"name\");\n        registerMuleBeanDefinitionParser(\"idempotent-secure-hash-message-filter\", new MessageProcessorDefinitionParser(IdempotentSecureHashMessageFilter.class)).addIgnored(\"name\");\n        registerBeanDefinitionParser(\"wire-tap\", new InboundRouterDefinitionParser(WireTap.class));\n        registerBeanDefinitionParser(\"custom-aggregator\", new AggregatorDefinitionParser());\n        registerBeanDefinitionParser(\"collection-aggregator\", new AggregatorDefinitionParser(SimpleCollectionAggregator.class));\n        registerBeanDefinitionParser(\"message-chunk-aggregator\", new AggregatorDefinitionParser(MessageChunkAggregator.class));\n        registerBeanDefinitionParser(\"resequencer\", new InboundRouterDefinitionParser(Resequencer.class));\n        registerBeanDefinitionParser(\"splitter\", new SplitterDefinitionParser(ExpressionSplitter.class));\n        registerBeanDefinitionParser(\"collection-splitter\", new SplitterDefinitionParser(CollectionSplitter.class));\n        registerBeanDefinitionParser(\"map-splitter\", new SplitterDefinitionParser(MapSplitter.class));\n        registerBeanDefinitionParser(\"message-chunk-splitter\", new SplitterDefinitionParser(MessageChunkSplitter.class));\n        registerBeanDefinitionParser(\"custom-splitter\", new SplitterDefinitionParser());\n        registerMuleBeanDefinitionParser(\"foreach\", new ChildDefinitionParser(\"messageProcessor\", Foreach.class)).addAlias(\"collection\", \"collectionExpression\");\n\n        // Routing: Routing Message Processors\n\n        // Routing: Conditional Routers\n        registerBeanDefinitionParser(\"choice\", new ChildDefinitionParser(\"messageProcessor\", ChoiceRouterFactoryBean.class));\n        registerBeanDefinitionParser(\"when\", (ChildDefinitionParser)new ChildDefinitionParser(\"route\", MessageProcessorFilterPairFactoryBean.class).registerPreProcessor(new CheckExclusiveAttributesAndChildren(new String[]{\n            \"expression\"}, new String[]{\"{http://www.mulesoft.org/schema/mule/core}abstractFilterType\"})));\n        registerBeanDefinitionParser(\"otherwise\", new ChildDefinitionParser(\"defaultRoute\", MessageProcessorFilterPairFactoryBean.class));\n\n        registerBeanDefinitionParser(\"all\", new ChildDefinitionParser(\"messageProcessor\", MulticastingRouter.class));\n        registerBeanDefinitionParser(\"recipient-list\", new ChildDefinitionParser(\"messageProcessor\", ExpressionRecipientList.class));\n\n        registerBeanDefinitionParser(\"request-reply\", new ChildDefinitionParser(\"messageProcessor\", SimpleAsyncRequestReplyRequester.class));\n        registerBeanDefinitionParser(\"first-successful\", new ChildDefinitionParser(\"messageProcessor\", FirstSuccessful.class));\n        registerBeanDefinitionParser(\"until-successful\", new ChildDefinitionParser(\"messageProcessor\", UntilSuccessful.class));\n        registerBeanDefinitionParser(\"round-robin\", new ChildDefinitionParser(\"messageProcessor\", RoundRobin.class));\n        registerBeanDefinitionParser(\"dead-letter-queue\", new ChildDefinitionParser(\"deadLetterQueue\", MessageProcessorFilterPairFactoryBean.class));\n\n        registerBeanDefinitionParser(\"custom-router\", new ChildDefinitionParser(\"messageProcessor\"));\n\n        //Message Info Mappings\n        registerBeanDefinitionParser(\"expression-message-info-mapping\", new ChildDefinitionParser(\"messageInfoMapping\", ExpressionMessageInfoMapping.class));\n        registerBeanDefinitionParser(\"custom-message-info-mapping\", new ChildDefinitionParser(\"messageInfoMapping\"));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"logging-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", LoggingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerMuleBeanDefinitionParser(\"filter\", new FilterRefDefinitionParser());\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser(AndFilter.class));\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser(OrFilter.class));\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser(NotFilter.class));\n        registerBeanDefinitionParser(\"regex-filter\", new RegExFilterDefinitionParser());\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser(ExceptionTypeFilter.class));\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser(MessagePropertyFilter.class));\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser(PayloadTypeFilter.class));\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser(WildcardFilter.class));\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser(EqualsFilter.class));\n        registerBeanDefinitionParser(\"expression-filter\", new FilterDefinitionParser(ExpressionFilter.class));\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Utils / Standard Types\n        registerMuleBeanDefinitionParser(\"properties\", new ChildMapDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"property\", new ChildMapEntryDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"add-message-properties\", new ChildMapDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"add-message-property\", new ChildMapEntryDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"rename-message-property\", new ChildMapEntryDefinitionParser(\"renameProperties\")).addCollection(\"renameProperties\");\n        registerBeanDefinitionParser(\"delete-message-property\", new ChildListEntryDefinitionParser(\"deleteProperties\", ChildMapEntryDefinitionParser.KEY));\n        registerMuleBeanDefinitionParser(\"jndi-provider-properties\", new ChildMapDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerMuleBeanDefinitionParser(\"jndi-provider-property\", new ChildMapEntryDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerBeanDefinitionParser(\"environment\", new ChildMapDefinitionParser(\"environment\"));\n        registerBeanDefinitionParser(\"expression\", new ChildDefinitionParser(\"expression\", ExpressionConfig.class));\n\n        //Security\n        registerMuleBeanDefinitionParser(\"security-manager\", new NamedDefinitionParser(MuleProperties.OBJECT_SECURITY_MANAGER)).addIgnored(\"type\").addIgnored(\"name\");\n        registerBeanDefinitionParser(\"custom-security-provider\", new NameTransferDefinitionParser(\"providers\"));\n        registerMuleBeanDefinitionParser(\"custom-encryption-strategy\", new NameTransferDefinitionParser(\"encryptionStrategies\")).addAlias(\"strategy\", \"encryptionStrategy\");\n        registerBeanDefinitionParser(\"password-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", PasswordBasedEncryptionStrategy.class));\n        registerMuleBeanDefinitionParser(\"secret-key-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", SecretKeyEncryptionStrategy.class)).registerPreProcessor(new CheckExclusiveAttributes(new String[][]{new String[]{\"key\"}, new String[]{\"keyFactory-ref\"}}));\n        registerBeanDefinitionParser(\"encryption-security-filter\", new SecurityFilterDefinitionParser(MuleEncryptionEndpointSecurityFilter.class));\n        registerBeanDefinitionParser(\"custom-security-filter\", new SecurityFilterDefinitionParser());\n        registerBeanDefinitionParser(\"username-password-filter\", new SecurityFilterDefinitionParser(UsernamePasswordAuthenticationFilter.class));\n        \n        //Interceptors\n        registerMuleBeanDefinitionParser(\"interceptor-stack\", new InterceptorStackDefinitionParser());\n        registerBeanDefinitionParser(\"custom-interceptor\", new InterceptorDefinitionParser());\n        registerBeanDefinitionParser(\"timer-interceptor\", new InterceptorDefinitionParser(TimerInterceptor.class));\n        registerBeanDefinitionParser(\"logging-interceptor\", new InterceptorDefinitionParser(LoggingInterceptor.class));\n    }","commit_id":"124d0249f2b035f5d53a963dcdbedb390ad15cff","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void logWithLevel(Object object, Level level)\n    {\n        switch (level.toInt())\n        {\n            case Level.ERROR_INT :\n                logger.error(object);\n            case Level.WARN_INT :\n                logger.warn(object);\n            case Level.INFO_INT :\n                logger.info(object);\n            case Level.DEBUG_INT :\n                logger.debug(object);\n            case Level.TRACE_INT :\n                logger.trace(object);\n        }\n\n    }","id":73289,"modified_method":"protected void logWithLevel(Object object, String level)\n    {\n        if (\"ERROR\".equals(level))\n        {\n            logger.error(object);\n        }\n        else if (\"WARN\".equals(level))\n        {\n            logger.warn(object);\n        }\n        else if (\"INFO\".equals(level))\n        {\n            if (logger.isInfoEnabled())\n            {\n                logger.info(object);\n            }\n        }\n        else if (\"DEBUG\".equals(level))\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(object);\n            }\n        }\n        else if (\"TRACE\".equals(level))\n        {\n            if (logger.isTraceEnabled())\n            {\n                logger.trace(object);\n            }\n        }\n    }","commit_id":"ddd5d224e7c91a49241af56277b8c247dabcabf7","url":"https://github.com/mulesoft/mule"},{"original_method":"public void initialise() throws InitialisationException\n    {\n        if (category != null)\n        {\n            logger = LogFactory.getLog(category);\n        }\n        else\n        {\n            logger = LogFactory.getLog(LoggerMessageProcessor.class);\n        }\n        level = Level.toLevel(levelString);\n\n        expressionManager = muleContext.getExpressionManager();\n\n    }","id":73290,"modified_method":"public void initialise() throws InitialisationException\n    {\n        if (category != null)\n        {\n            logger = LogFactory.getLog(category);\n        }\n        else\n        {\n            logger = LogFactory.getLog(LoggerMessageProcessor.class);\n        }\n\n        expressionManager = muleContext.getExpressionManager();\n\n    }","commit_id":"ddd5d224e7c91a49241af56277b8c247dabcabf7","url":"https://github.com/mulesoft/mule"},{"original_method":"public void setLevelString(String levelString)\n    {\n        this.levelString = levelString;\n    }","id":73291,"modified_method":"public void setLevel(String level)\n    {\n        this.level = level.toUpperCase();\n    }","commit_id":"ddd5d224e7c91a49241af56277b8c247dabcabf7","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerIgnoredElement(\"mule\");\n        registerIgnoredElement(\"description\");\n\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"global-property\", new GlobalPropertyDefinitionParser());\n        registerBeanDefinitionParser(\"default-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-receiver-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-service-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_SERVICE_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"threading-profile\", new ThreadingProfileDefinitionParser(\"threadingProfile\", MuleProperties.OBJECT_DEFAULT_SERVICE_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-service-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultServiceExceptionStrategy.class));\n        registerBeanDefinitionParser(\"commit-transaction\", new ExceptionTXFilterDefinitionParser(\"commitTxFilter\"));\n        registerBeanDefinitionParser(\"rollback-transaction\", new ExceptionTXFilterDefinitionParser(\"rollbackTxFilter\"));\n        registerBeanDefinitionParser(\"custom-agent\", new DefaultNameMuleOrphanDefinitionParser());\n\n        registerBeanDefinitionParser(\"routeable-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", RouteableExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new ChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n        registerMuleBeanDefinitionParser(\"notifications\", new NamedDefinitionParser(MuleProperties.OBJECT_NOTIFICATION_MANAGER)).addAlias(\"dynamic\", \"notificationDynamic\");\n        registerBeanDefinitionParser(\"notification\", new NotificationDefinitionParser());\n        registerBeanDefinitionParser(\"disable-notification\", new NotificationDisableDefinitionParser());\n        registerMuleBeanDefinitionParser(\"notification-listener\", new ChildDefinitionParser(\"allListenerSubscriptionPair\", ListenerSubscriptionPair.class)).addAlias(\"ref\", \"listener\").addReference(\"listener\");\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"dispatcherThreadingProfile\", MuleProperties.OBJECT_DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"receiverThreadingProfile\", MuleProperties.OBJECT_DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new MuleOrphanDefinitionParser(true));\n\n        //Transformer elements\n\n        registerBeanDefinitionParser(\"transformer\", new MessageProcessorRefDefinitionParser());\n\n        registerBeanDefinitionParser(\"custom-transformer\", new MessageProcessorDefinitionParser());\n        registerBeanDefinitionParser(\"auto-transformer\", new MessageProcessorDefinitionParser(AutoTransformer.class));\n        registerBeanDefinitionParser(\"message-properties-transformer\", new MessagePropertiesTransformerDefinitionParser());\n\n        registerBeanDefinitionParser(\"expression-transformer\", new MessageProcessorDefinitionParser(ExpressionTransformer.class));\n        registerBeanDefinitionParser(\"return-argument\", new ChildDefinitionParser(\"argument\", ExpressionArgument.class));\n\n        registerBeanDefinitionParser(\"bean-builder-transformer\", new MessageProcessorDefinitionParser(BeanBuilderTransformer.class));\n\n        final ChildDefinitionParser beanPropertyParser = new ChildDefinitionParser(\"argument\", ExpressionArgument.class);\n        beanPropertyParser.addAlias(\"property-name\", \"name\");\n        registerBeanDefinitionParser(\"bean-property\", beanPropertyParser);\n\n        registerBeanDefinitionParser(\"base64-encoder-transformer\", new MessageProcessorDefinitionParser(Base64Encoder.class));\n        registerBeanDefinitionParser(\"base64-decoder-transformer\", new MessageProcessorDefinitionParser(Base64Decoder.class));\n\n        registerBeanDefinitionParser(\"xml-entity-encoder-transformer\", new MessageProcessorDefinitionParser(XmlEntityEncoder.class));\n        registerBeanDefinitionParser(\"xml-entity-decoder-transformer\", new MessageProcessorDefinitionParser(XmlEntityDecoder.class));\n        registerBeanDefinitionParser(\"gzip-compress-transformer\", new MessageProcessorDefinitionParser(GZipCompressTransformer.class));\n        registerBeanDefinitionParser(\"gzip-uncompress-transformer\", new MessageProcessorDefinitionParser(GZipUncompressTransformer.class));\n        registerBeanDefinitionParser(\"encrypt-transformer\", new MessageProcessorDefinitionParser(EncryptionTransformer.class));\n        registerBeanDefinitionParser(\"decrypt-transformer\", new MessageProcessorDefinitionParser(DecryptionTransformer.class));\n        registerBeanDefinitionParser(\"byte-array-to-hex-string-transformer\", new MessageProcessorDefinitionParser(ByteArrayToHexString.class));\n        registerBeanDefinitionParser(\"hex-string-to-byte-array-transformer\", new MessageProcessorDefinitionParser(HexStringToByteArray.class));\n\n        registerBeanDefinitionParser(\"byte-array-to-object-transformer\", new MessageProcessorDefinitionParser(ByteArrayToObject.class));\n        registerBeanDefinitionParser(\"object-to-byte-array-transformer\", new MessageProcessorDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"object-to-string-transformer\", new MessageProcessorDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"byte-array-to-serializable-transformer\", new MessageProcessorDefinitionParser(ByteArrayToSerializable.class));\n        registerBeanDefinitionParser(\"serializable-to-byte-array-transformer\", new MessageProcessorDefinitionParser(SerializableToByteArray.class));\n        registerBeanDefinitionParser(\"byte-array-to-string-transformer\", new MessageProcessorDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"string-to-byte-array-transformer\", new MessageProcessorDefinitionParser(ObjectToByteArray.class));\n\n        registerBeanDefinitionParser(\"append-string-transformer\", new MessageProcessorDefinitionParser(StringAppendTransformer.class));\n\n        registerBeanDefinitionParser(\"map-to-bean-transformer\", new MessageProcessorDefinitionParser(MapToBean.class));\n        registerBeanDefinitionParser(\"bean-to-map-transformer\", new MessageProcessorDefinitionParser(BeanToMap.class));\n\n        //Transaction Managers\n        registerBeanDefinitionParser(\"custom-transaction-manager\", new TransactionManagerDefinitionParser());\n        registerBeanDefinitionParser(\"jndi-transaction-manager\", new TransactionManagerDefinitionParser(GenericTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"weblogic-transaction-manager\", new TransactionManagerDefinitionParser(WeblogicTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jboss-transaction-manager\", new TransactionManagerDefinitionParser(JBossTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jrun-transaction-manager\", new TransactionManagerDefinitionParser(JRunTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"resin-transaction-manager\", new TransactionManagerDefinitionParser(Resin3TransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"websphere-transaction-manager\", new TransactionManagerDefinitionParser(WebsphereTransactionManagerLookupFactory.class));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"inbound-endpoint\", new ChildEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"outbound-endpoint\", new ChildEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"custom-transaction\", new TransactionDefinitionParser());\n        registerBeanDefinitionParser(\"xa-transaction\", new TransactionDefinitionParser(XaTransactionFactory.class));\n\n        // Message Processors\n        registerBeanDefinitionParser(\"processor\", new MessageProcessorRefDefinitionParser());\n        registerMuleBeanDefinitionParser(\"custom-processor\", new MessageProcessorDefinitionParser()).addIgnored(\"name\");\n        registerBeanDefinitionParser(\"processor-chain\", new MessageProcessorChainDefinitionParser());\n        registerBeanDefinitionParser(\"response\", new ResponseDefinitionParser());\n        registerMuleBeanDefinitionParser(\"message-filter\", new MessageFilterDefinitionParser());\n        registerMuleBeanDefinitionParser(\"invoke\",\n            new MessageProcessorDefinitionParser(InvokerMessageProcessor.class)).addAlias(\"method\",\n            \"methodName\").addAlias(\"methodArguments\", \"argumentExpressionsString\").addAlias(\n            \"methodArgumentTypes\", \"ArgumentTypes\");\n        registerMuleBeanDefinitionParser(\"enricher\",\n            new MessageEnricherDefinitionParser(\"messageProcessor\", MessageEnricher.class)).addIgnored(\n            \"source\")\n            .addIgnored(\"target\")\n            .registerPreProcessor(\n                new CheckExclusiveAttributesAndChildren(new String[]{\"source\", \"target\"},\n                    new String[]{\"enrich\"}))\n            .registerPreProcessor(\n                new CheckRequiredAttributesWhenNoChildren(new String[][]{new String[]{\"target\"}}, \"enrich\"))\n            .addCollection(\"enrichExpressionPairs\");\n        registerMuleBeanDefinitionParser(\"enrich\", new ChildDefinitionParser(\"enrichExpressionPair\",\n            EnrichExpressionPair.class));\n        \n        registerBeanDefinitionParser(\"async\", new ChildDefinitionParser(\"messageProcessor\",\n            AsyncMessageProcessorsFactoryBean.class));\n        registerBeanDefinitionParser(\"transactional\", new ChildDefinitionParser(\"messageProcessor\",\n            TransactionalMessageProcessorsFactoryBean.class));\n        registerMuleBeanDefinitionParser(\"logger\", new ChildDefinitionParser(\"messageProcessor\",\n            LoggerMessageProcessor.class)).addAlias(\"level\", \"levelString\");\n        \n        // Message Sources\n        // TODO MULE-4987\n        // registerBeanDefinitionParser(\"custom-source\", new ChildDefinitionParser(\"messageSource\", null, MessageSource.class));\n        registerBeanDefinitionParser(\"composite-source\", new ChildDefinitionParser(\"messageSource\", CompositeMessageSourceFactoryBean.class));\n\n        // Models\n        registerBeanDefinitionParser(\"model\", new ModelDefinitionParser());\n        registerBeanDefinitionParser(\"seda-model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n\n        registerBeanDefinitionParser(\"entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", DefaultEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"legacy-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", LegacyEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"custom-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\"));\n\n        registerBeanDefinitionParser(\"custom-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\"));\n        registerBeanDefinitionParser(\"callable-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"property-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", MethodHeaderPropertyEntryPointResolver.class)).addAlias(\"property\", \"methodProperty\");\n        registerBeanDefinitionParser(\"method-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ExplicitMethodEntryPointResolver.class));\n        registerBeanDefinitionParser(\"reflection-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ReflectionEntryPointResolver.class));\n        registerBeanDefinitionParser(\"no-arguments-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", NoArgumentsEntryPointResolver.class));\n        registerBeanDefinitionParser(\"array-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ArrayEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"include-entry-point\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"exclude-entry-point\", new ParentDefinitionParser()).addAlias(\"method\", \"ignoredMethod\");\n        registerMuleBeanDefinitionParser(\"exclude-object-methods\", new IgnoreObjectMethodsDefinitionParser());\n\n        // Services\n        registerBeanDefinitionParser(\"seda-service\", new ServiceDefinitionParser(SedaService.class));\n        registerBeanDefinitionParser(\"service\", new ServiceDefinitionParser(SedaService.class));\n        registerBeanDefinitionParser(\"custom-service\", new ServiceDefinitionParser());\n\n        // Flow Constructs\n        registerBeanDefinitionParser(\"flow\", new FlowDefinitionParser());\n        registerBeanDefinitionParser(\"simple-service\", new SimpleServiceDefinitionParser());\n        registerBeanDefinitionParser(\"bridge\", new BridgeDefinitionParser());\n        registerBeanDefinitionParser(\"validator\", new ValidatorDefinitionParser());\n\n        registerBeanDefinitionParser(\"flow-ref\", new FlowRefDefinitionParser());\n\n        // Components\n        registerBeanDefinitionParser(\"component\", new ComponentDelegatingDefinitionParser(DefaultJavaComponent.class));\n        registerBeanDefinitionParser(\"pooled-component\", new ComponentDelegatingDefinitionParser(PooledJavaComponent.class));\n\n        registerMuleBeanDefinitionParser(\"binding\", new BindingDefinitionParser(\"interfaceBinding\", DefaultInterfaceBinding.class));\n\n        // Simple Components\n        registerBeanDefinitionParser(\"pass-through-component\", new ComponentDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"log-component\", new SimpleComponentDefinitionParser(SimpleCallableJavaComponent.class, LogComponent.class));\n        registerBeanDefinitionParser(\"null-component\", new SimpleComponentDefinitionParser(SimpleCallableJavaComponent.class, NullComponent.class));\n        registerBeanDefinitionParser(\"static-component\", new StaticComponentDefinitionParser());\n        registerIgnoredElement(\"return-data\"); // Handled by StaticComponentDefinitionParser\n\n        // We need to use DefaultJavaComponent for the echo component because some tests invoke EchoComponent with method name and therefore we need an entry point resolver\n        registerBeanDefinitionParser(\"echo-component\", new SimpleComponentDefinitionParser(DefaultJavaComponent.class, EchoComponent.class));\n\n        // Object Factories\n        registerBeanDefinitionParser(\"singleton-object\", new ObjectFactoryDefinitionParser(SingletonObjectFactory.class, \"objectFactory\"));\n        registerBeanDefinitionParser(\"prototype-object\", new ObjectFactoryDefinitionParser(PrototypeObjectFactory.class, \"objectFactory\"));\n        registerBeanDefinitionParser(\"spring-object\", new ObjectFactoryDefinitionParser(SpringBeanLookup.class, \"objectFactory\"));\n\n        // Life-cycle Adapters Factories\n        registerBeanDefinitionParser(\"custom-lifecycle-adapter-factory\", new ChildDefinitionParser(\"lifecycleAdapterFactory\"));\n\n        //Stores\n        registerBeanDefinitionParser(\"in-memory-store\", new ChildDefinitionParser(\"store\", InMemoryObjectStore.class));\n        registerBeanDefinitionParser(\"simple-text-file-store\", new ChildDefinitionParser(\"store\", TextFileObjectStore.class));\n\n        //Routers\n        registerBeanDefinitionParser(\"inbound\", new ChildDefinitionParser(\"messageSource\", ServiceCompositeMessageSource.class, true));\n        registerBeanDefinitionParser(\"outbound\", new ChildDefinitionParser(\"outboundMessageProcessor\", DefaultOutboundRouterCollection.class, true));\n        registerBeanDefinitionParser(\"async-reply\", new ChildDefinitionParser(\"asyncReplyMessageSource\", ServiceAsyncReplyCompositeMessageSource.class, true));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"forwarding-router\", new InboundRouterDefinitionParser(ForwardingConsumer.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new InboundRouterDefinitionParser(IdempotentMessageFilter.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new InboundRouterDefinitionParser(IdempotentSecureHashMessageFilter.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new InboundRouterDefinitionParser(MessageFilter.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new InboundRouterDefinitionParser(WireTap.class));\n        registerBeanDefinitionParser(\"custom-correlation-aggregator-router\", new InboundRouterDefinitionParser());\n        registerBeanDefinitionParser(\"collection-aggregator-router\", new InboundRouterDefinitionParser(SimpleCollectionAggregator.class));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new InboundRouterDefinitionParser(MessageChunkAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new InboundRouterDefinitionParser(Resequencer.class));\n        registerBeanDefinitionParser(\"custom-inbound-router\", new InboundRouterDefinitionParser(null));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"pass-through-router\", new RouterDefinitionParser(OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"recipient-list-exception-based-router\", new RouterDefinitionParser(ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(ListMessageSplitter.class));\n        registerBeanDefinitionParser(\"expression-splitter-router\", new RouterDefinitionParser(ExpressionMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(StaticRecipientList.class));\n        registerBeanDefinitionParser(\"expression-recipient-list-router\", new RouterDefinitionParser(ExpressionRecipientList.class));\n        registerBeanDefinitionParser(\"recipients\", new ChildListDefinitionParser(\"recipients\"));\n        registerBeanDefinitionParser(\"custom-outbound-router\", new RouterDefinitionParser(null));\n        registerBeanDefinitionParser(\"reply-to\", new EndpointRefParser(\"replyTo\"));\n\n        //Response Routers\n        registerBeanDefinitionParser(\"custom-async-reply-router\", new InboundRouterDefinitionParser(null));\n        registerBeanDefinitionParser(\"single-async-reply-router\", new InboundRouterDefinitionParser(NullMessageProcessor.class));\n        registerBeanDefinitionParser(\"collection-async-reply-router\", new InboundRouterDefinitionParser(SimpleCollectionAggregator.class));\n\n        // Routing: Intercepting Message Processors\n        registerBeanDefinitionParser(\"idempotent-message-filter\", new InboundRouterDefinitionParser(IdempotentMessageFilter.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-message-filter\", new InboundRouterDefinitionParser(IdempotentSecureHashMessageFilter.class));\n        registerBeanDefinitionParser(\"wire-tap\", new InboundRouterDefinitionParser(WireTap.class));\n        registerBeanDefinitionParser(\"custom-aggregator\", new AggregatorDefinitionParser());\n        registerBeanDefinitionParser(\"collection-aggregator\", new AggregatorDefinitionParser(SimpleCollectionAggregator.class));\n        registerBeanDefinitionParser(\"message-chunk-aggregator\", new AggregatorDefinitionParser(MessageChunkAggregator.class));\n        registerBeanDefinitionParser(\"resequencer\", new InboundRouterDefinitionParser(Resequencer.class));\n        registerBeanDefinitionParser(\"splitter\", new SplitterDefinitionParser(ExpressionSplitter.class));\n        registerBeanDefinitionParser(\"collection-splitter\", new SplitterDefinitionParser(CollectionSplitter.class));\n        registerBeanDefinitionParser(\"message-chunk-splitter\", new SplitterDefinitionParser(MessageChunkSplitter.class));\n        registerBeanDefinitionParser(\"custom-splitter\", new SplitterDefinitionParser());\n\n        // Routing: Routing Message Processors\n\n        // Routing: Conditional Routers\n        registerBeanDefinitionParser(\"choice\", new ChildDefinitionParser(\"messageProcessor\", ChoiceRouterFactoryBean.class));\n        registerBeanDefinitionParser(\"when\", (ChildDefinitionParser)new ChildDefinitionParser(\"route\", MessageProcessorFilterPairFactoryBean.class).registerPreProcessor(new CheckExclusiveAttributesAndChildren(new String[]{\n            \"expression\"}, new String[]{\"{http://www.mulesoft.org/schema/mule/core}abstractFilterType\"})));\n        registerBeanDefinitionParser(\"otherwise\", new ChildDefinitionParser(\"defaultRoute\", MessageProcessorFilterPairFactoryBean.class));\n\n        registerBeanDefinitionParser(\"all\", new ChildDefinitionParser(\"messageProcessor\", MulticastingRouter.class));\n        registerBeanDefinitionParser(\"recipient-list\", new ChildDefinitionParser(\"messageProcessor\", ExpressionRecipientList.class));\n\n        registerBeanDefinitionParser(\"request-reply\", new ChildDefinitionParser(\"messageProcessor\", SimpleAsyncRequestReplyRequester.class));\n        registerBeanDefinitionParser(\"first-successful\", new ChildDefinitionParser(\"messageProcessor\", FirstSuccessful.class));\n        registerBeanDefinitionParser(\"round-robin\", new ChildDefinitionParser(\"messageProcessor\", RoundRobin.class));\n\n        //Message Info Mappings\n        registerBeanDefinitionParser(\"expression-message-info-mapping\", new ChildDefinitionParser(\"messageInfoMapping\", ExpressionMessageInfoMapping.class));\n        registerBeanDefinitionParser(\"custom-message-info-mapping\", new ChildDefinitionParser(\"messageInfoMapping\"));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"logging-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", LoggingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerMuleBeanDefinitionParser(\"filter\", new FilterRefDefinitionParser());\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser(AndFilter.class));\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser(OrFilter.class));\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser(NotFilter.class));\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser(RegExFilter.class));\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser(ExceptionTypeFilter.class));\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser(MessagePropertyFilter.class));\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser(PayloadTypeFilter.class));\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser(WildcardFilter.class));\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser(EqualsFilter.class));\n        registerBeanDefinitionParser(\"expression-filter\", new FilterDefinitionParser(ExpressionFilter.class));\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Utils / Standard Types\n        registerMuleBeanDefinitionParser(\"properties\", new ChildMapDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"property\", new ChildMapEntryDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"add-message-properties\", new ChildMapDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"add-message-property\", new ChildMapEntryDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"rename-message-property\", new ChildMapEntryDefinitionParser(\"renameProperties\")).addCollection(\"renameProperties\");\n        registerBeanDefinitionParser(\"delete-message-property\", new ChildListEntryDefinitionParser(\"deleteProperties\", ChildMapEntryDefinitionParser.KEY));\n        registerMuleBeanDefinitionParser(\"jndi-provider-properties\", new ChildMapDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerMuleBeanDefinitionParser(\"jndi-provider-property\", new ChildMapEntryDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerBeanDefinitionParser(\"environment\", new ChildMapDefinitionParser(\"environment\"));\n        registerBeanDefinitionParser(\"expression\", new ChildDefinitionParser(\"expression\", ExpressionConfig.class));\n\n        //Security\n        registerMuleBeanDefinitionParser(\"security-manager\", new NamedDefinitionParser(MuleProperties.OBJECT_SECURITY_MANAGER)).addIgnored(\"type\").addIgnored(\"name\");\n        registerBeanDefinitionParser(\"custom-security-provider\", new NameTransferDefinitionParser(\"providers\"));\n        registerMuleBeanDefinitionParser(\"custom-encryption-strategy\", new NameTransferDefinitionParser(\"encryptionStrategies\")).addAlias(\"strategy\", \"encryptionStrategy\");\n        registerBeanDefinitionParser(\"password-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", PasswordBasedEncryptionStrategy.class));\n        registerMuleBeanDefinitionParser(\"secret-key-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", SecretKeyEncryptionStrategy.class)).registerPreProcessor(new CheckExclusiveAttributes(new String[][]{new String[]{\"key\"}, new String[]{\"keyFactory-ref\"}}));\n        registerBeanDefinitionParser(\"encryption-security-filter\", new SecurityFilterDefinitionParser(MuleEncryptionEndpointSecurityFilter.class));\n        registerBeanDefinitionParser(\"custom-security-filter\", new SecurityFilterDefinitionParser());\n        //Interceptors\n        registerMuleBeanDefinitionParser(\"interceptor-stack\", new InterceptorStackDefinitionParser());\n        registerBeanDefinitionParser(\"custom-interceptor\", new InterceptorDefinitionParser());\n        registerBeanDefinitionParser(\"timer-interceptor\", new InterceptorDefinitionParser(TimerInterceptor.class));\n        registerBeanDefinitionParser(\"logging-interceptor\", new InterceptorDefinitionParser(LoggingInterceptor.class));\n    }","id":73292,"modified_method":"public void init()\n    {\n        registerIgnoredElement(\"mule\");\n        registerIgnoredElement(\"description\");\n\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"global-property\", new GlobalPropertyDefinitionParser());\n        registerBeanDefinitionParser(\"default-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-receiver-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-service-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleProperties.OBJECT_DEFAULT_SERVICE_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"threading-profile\", new ThreadingProfileDefinitionParser(\"threadingProfile\", MuleProperties.OBJECT_DEFAULT_SERVICE_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-service-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultServiceExceptionStrategy.class));\n        registerBeanDefinitionParser(\"commit-transaction\", new ExceptionTXFilterDefinitionParser(\"commitTxFilter\"));\n        registerBeanDefinitionParser(\"rollback-transaction\", new ExceptionTXFilterDefinitionParser(\"rollbackTxFilter\"));\n        registerBeanDefinitionParser(\"custom-agent\", new DefaultNameMuleOrphanDefinitionParser());\n\n        registerBeanDefinitionParser(\"routeable-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", RouteableExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new ChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n        registerMuleBeanDefinitionParser(\"notifications\", new NamedDefinitionParser(MuleProperties.OBJECT_NOTIFICATION_MANAGER)).addAlias(\"dynamic\", \"notificationDynamic\");\n        registerBeanDefinitionParser(\"notification\", new NotificationDefinitionParser());\n        registerBeanDefinitionParser(\"disable-notification\", new NotificationDisableDefinitionParser());\n        registerMuleBeanDefinitionParser(\"notification-listener\", new ChildDefinitionParser(\"allListenerSubscriptionPair\", ListenerSubscriptionPair.class)).addAlias(\"ref\", \"listener\").addReference(\"listener\");\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"dispatcherThreadingProfile\", MuleProperties.OBJECT_DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"receiverThreadingProfile\", MuleProperties.OBJECT_DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new MuleOrphanDefinitionParser(true));\n\n        //Transformer elements\n\n        registerBeanDefinitionParser(\"transformer\", new MessageProcessorRefDefinitionParser());\n\n        registerBeanDefinitionParser(\"custom-transformer\", new MessageProcessorDefinitionParser());\n        registerBeanDefinitionParser(\"auto-transformer\", new MessageProcessorDefinitionParser(AutoTransformer.class));\n        registerBeanDefinitionParser(\"message-properties-transformer\", new MessagePropertiesTransformerDefinitionParser());\n\n        registerBeanDefinitionParser(\"expression-transformer\", new MessageProcessorDefinitionParser(ExpressionTransformer.class));\n        registerBeanDefinitionParser(\"return-argument\", new ChildDefinitionParser(\"argument\", ExpressionArgument.class));\n\n        registerBeanDefinitionParser(\"bean-builder-transformer\", new MessageProcessorDefinitionParser(BeanBuilderTransformer.class));\n\n        final ChildDefinitionParser beanPropertyParser = new ChildDefinitionParser(\"argument\", ExpressionArgument.class);\n        beanPropertyParser.addAlias(\"property-name\", \"name\");\n        registerBeanDefinitionParser(\"bean-property\", beanPropertyParser);\n\n        registerBeanDefinitionParser(\"base64-encoder-transformer\", new MessageProcessorDefinitionParser(Base64Encoder.class));\n        registerBeanDefinitionParser(\"base64-decoder-transformer\", new MessageProcessorDefinitionParser(Base64Decoder.class));\n\n        registerBeanDefinitionParser(\"xml-entity-encoder-transformer\", new MessageProcessorDefinitionParser(XmlEntityEncoder.class));\n        registerBeanDefinitionParser(\"xml-entity-decoder-transformer\", new MessageProcessorDefinitionParser(XmlEntityDecoder.class));\n        registerBeanDefinitionParser(\"gzip-compress-transformer\", new MessageProcessorDefinitionParser(GZipCompressTransformer.class));\n        registerBeanDefinitionParser(\"gzip-uncompress-transformer\", new MessageProcessorDefinitionParser(GZipUncompressTransformer.class));\n        registerBeanDefinitionParser(\"encrypt-transformer\", new MessageProcessorDefinitionParser(EncryptionTransformer.class));\n        registerBeanDefinitionParser(\"decrypt-transformer\", new MessageProcessorDefinitionParser(DecryptionTransformer.class));\n        registerBeanDefinitionParser(\"byte-array-to-hex-string-transformer\", new MessageProcessorDefinitionParser(ByteArrayToHexString.class));\n        registerBeanDefinitionParser(\"hex-string-to-byte-array-transformer\", new MessageProcessorDefinitionParser(HexStringToByteArray.class));\n\n        registerBeanDefinitionParser(\"byte-array-to-object-transformer\", new MessageProcessorDefinitionParser(ByteArrayToObject.class));\n        registerBeanDefinitionParser(\"object-to-byte-array-transformer\", new MessageProcessorDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"object-to-string-transformer\", new MessageProcessorDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"byte-array-to-serializable-transformer\", new MessageProcessorDefinitionParser(ByteArrayToSerializable.class));\n        registerBeanDefinitionParser(\"serializable-to-byte-array-transformer\", new MessageProcessorDefinitionParser(SerializableToByteArray.class));\n        registerBeanDefinitionParser(\"byte-array-to-string-transformer\", new MessageProcessorDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"string-to-byte-array-transformer\", new MessageProcessorDefinitionParser(ObjectToByteArray.class));\n\n        registerBeanDefinitionParser(\"append-string-transformer\", new MessageProcessorDefinitionParser(StringAppendTransformer.class));\n\n        registerBeanDefinitionParser(\"map-to-bean-transformer\", new MessageProcessorDefinitionParser(MapToBean.class));\n        registerBeanDefinitionParser(\"bean-to-map-transformer\", new MessageProcessorDefinitionParser(BeanToMap.class));\n\n        //Transaction Managers\n        registerBeanDefinitionParser(\"custom-transaction-manager\", new TransactionManagerDefinitionParser());\n        registerBeanDefinitionParser(\"jndi-transaction-manager\", new TransactionManagerDefinitionParser(GenericTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"weblogic-transaction-manager\", new TransactionManagerDefinitionParser(WeblogicTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jboss-transaction-manager\", new TransactionManagerDefinitionParser(JBossTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"jrun-transaction-manager\", new TransactionManagerDefinitionParser(JRunTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"resin-transaction-manager\", new TransactionManagerDefinitionParser(Resin3TransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"websphere-transaction-manager\", new TransactionManagerDefinitionParser(WebsphereTransactionManagerLookupFactory.class));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"inbound-endpoint\", new ChildEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"outbound-endpoint\", new ChildEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"custom-transaction\", new TransactionDefinitionParser());\n        registerBeanDefinitionParser(\"xa-transaction\", new TransactionDefinitionParser(XaTransactionFactory.class));\n\n        // Message Processors\n        registerBeanDefinitionParser(\"processor\", new MessageProcessorRefDefinitionParser());\n        registerMuleBeanDefinitionParser(\"custom-processor\", new MessageProcessorDefinitionParser()).addIgnored(\"name\");\n        registerBeanDefinitionParser(\"processor-chain\", new MessageProcessorChainDefinitionParser());\n        registerBeanDefinitionParser(\"response\", new ResponseDefinitionParser());\n        registerMuleBeanDefinitionParser(\"message-filter\", new MessageFilterDefinitionParser());\n        registerMuleBeanDefinitionParser(\"invoke\",\n            new MessageProcessorDefinitionParser(InvokerMessageProcessor.class)).addAlias(\"method\",\n            \"methodName\").addAlias(\"methodArguments\", \"argumentExpressionsString\").addAlias(\n            \"methodArgumentTypes\", \"ArgumentTypes\");\n        registerMuleBeanDefinitionParser(\"enricher\",\n            new MessageEnricherDefinitionParser(\"messageProcessor\", MessageEnricher.class)).addIgnored(\n            \"source\")\n            .addIgnored(\"target\")\n            .registerPreProcessor(\n                new CheckExclusiveAttributesAndChildren(new String[]{\"source\", \"target\"},\n                    new String[]{\"enrich\"}))\n            .registerPreProcessor(\n                new CheckRequiredAttributesWhenNoChildren(new String[][]{new String[]{\"target\"}}, \"enrich\"))\n            .addCollection(\"enrichExpressionPairs\");\n        registerMuleBeanDefinitionParser(\"enrich\", new ChildDefinitionParser(\"enrichExpressionPair\",\n            EnrichExpressionPair.class));\n        \n        registerBeanDefinitionParser(\"async\", new ChildDefinitionParser(\"messageProcessor\",\n            AsyncMessageProcessorsFactoryBean.class));\n        registerBeanDefinitionParser(\"transactional\", new ChildDefinitionParser(\"messageProcessor\",\n            TransactionalMessageProcessorsFactoryBean.class));\n        registerMuleBeanDefinitionParser(\"logger\", new ChildDefinitionParser(\"messageProcessor\",\n            LoggerMessageProcessor.class));\n        \n        // Message Sources\n        // TODO MULE-4987\n        // registerBeanDefinitionParser(\"custom-source\", new ChildDefinitionParser(\"messageSource\", null, MessageSource.class));\n        registerBeanDefinitionParser(\"composite-source\", new ChildDefinitionParser(\"messageSource\", CompositeMessageSourceFactoryBean.class));\n\n        // Models\n        registerBeanDefinitionParser(\"model\", new ModelDefinitionParser());\n        registerBeanDefinitionParser(\"seda-model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n\n        registerBeanDefinitionParser(\"entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", DefaultEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"legacy-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\", LegacyEntryPointResolverSet.class));\n        registerBeanDefinitionParser(\"custom-entry-point-resolver-set\", new ChildDefinitionParser(\"entryPointResolverSet\"));\n\n        registerBeanDefinitionParser(\"custom-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\"));\n        registerBeanDefinitionParser(\"callable-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"property-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", MethodHeaderPropertyEntryPointResolver.class)).addAlias(\"property\", \"methodProperty\");\n        registerBeanDefinitionParser(\"method-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ExplicitMethodEntryPointResolver.class));\n        registerBeanDefinitionParser(\"reflection-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ReflectionEntryPointResolver.class));\n        registerBeanDefinitionParser(\"no-arguments-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", NoArgumentsEntryPointResolver.class));\n        registerBeanDefinitionParser(\"array-entry-point-resolver\", new ChildDefinitionParser(\"entryPointResolver\", ArrayEntryPointResolver.class));\n        registerMuleBeanDefinitionParser(\"include-entry-point\", new ParentDefinitionParser());\n        registerMuleBeanDefinitionParser(\"exclude-entry-point\", new ParentDefinitionParser()).addAlias(\"method\", \"ignoredMethod\");\n        registerMuleBeanDefinitionParser(\"exclude-object-methods\", new IgnoreObjectMethodsDefinitionParser());\n\n        // Services\n        registerBeanDefinitionParser(\"seda-service\", new ServiceDefinitionParser(SedaService.class));\n        registerBeanDefinitionParser(\"service\", new ServiceDefinitionParser(SedaService.class));\n        registerBeanDefinitionParser(\"custom-service\", new ServiceDefinitionParser());\n\n        // Flow Constructs\n        registerBeanDefinitionParser(\"flow\", new FlowDefinitionParser());\n        registerBeanDefinitionParser(\"simple-service\", new SimpleServiceDefinitionParser());\n        registerBeanDefinitionParser(\"bridge\", new BridgeDefinitionParser());\n        registerBeanDefinitionParser(\"validator\", new ValidatorDefinitionParser());\n\n        registerBeanDefinitionParser(\"flow-ref\", new FlowRefDefinitionParser());\n\n        // Components\n        registerBeanDefinitionParser(\"component\", new ComponentDelegatingDefinitionParser(DefaultJavaComponent.class));\n        registerBeanDefinitionParser(\"pooled-component\", new ComponentDelegatingDefinitionParser(PooledJavaComponent.class));\n\n        registerMuleBeanDefinitionParser(\"binding\", new BindingDefinitionParser(\"interfaceBinding\", DefaultInterfaceBinding.class));\n\n        // Simple Components\n        registerBeanDefinitionParser(\"pass-through-component\", new ComponentDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"log-component\", new SimpleComponentDefinitionParser(SimpleCallableJavaComponent.class, LogComponent.class));\n        registerBeanDefinitionParser(\"null-component\", new SimpleComponentDefinitionParser(SimpleCallableJavaComponent.class, NullComponent.class));\n        registerBeanDefinitionParser(\"static-component\", new StaticComponentDefinitionParser());\n        registerIgnoredElement(\"return-data\"); // Handled by StaticComponentDefinitionParser\n\n        // We need to use DefaultJavaComponent for the echo component because some tests invoke EchoComponent with method name and therefore we need an entry point resolver\n        registerBeanDefinitionParser(\"echo-component\", new SimpleComponentDefinitionParser(DefaultJavaComponent.class, EchoComponent.class));\n\n        // Object Factories\n        registerBeanDefinitionParser(\"singleton-object\", new ObjectFactoryDefinitionParser(SingletonObjectFactory.class, \"objectFactory\"));\n        registerBeanDefinitionParser(\"prototype-object\", new ObjectFactoryDefinitionParser(PrototypeObjectFactory.class, \"objectFactory\"));\n        registerBeanDefinitionParser(\"spring-object\", new ObjectFactoryDefinitionParser(SpringBeanLookup.class, \"objectFactory\"));\n\n        // Life-cycle Adapters Factories\n        registerBeanDefinitionParser(\"custom-lifecycle-adapter-factory\", new ChildDefinitionParser(\"lifecycleAdapterFactory\"));\n\n        //Stores\n        registerBeanDefinitionParser(\"in-memory-store\", new ChildDefinitionParser(\"store\", InMemoryObjectStore.class));\n        registerBeanDefinitionParser(\"simple-text-file-store\", new ChildDefinitionParser(\"store\", TextFileObjectStore.class));\n\n        //Routers\n        registerBeanDefinitionParser(\"inbound\", new ChildDefinitionParser(\"messageSource\", ServiceCompositeMessageSource.class, true));\n        registerBeanDefinitionParser(\"outbound\", new ChildDefinitionParser(\"outboundMessageProcessor\", DefaultOutboundRouterCollection.class, true));\n        registerBeanDefinitionParser(\"async-reply\", new ChildDefinitionParser(\"asyncReplyMessageSource\", ServiceAsyncReplyCompositeMessageSource.class, true));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"forwarding-router\", new InboundRouterDefinitionParser(ForwardingConsumer.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new InboundRouterDefinitionParser(IdempotentMessageFilter.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new InboundRouterDefinitionParser(IdempotentSecureHashMessageFilter.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new InboundRouterDefinitionParser(MessageFilter.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new InboundRouterDefinitionParser(WireTap.class));\n        registerBeanDefinitionParser(\"custom-correlation-aggregator-router\", new InboundRouterDefinitionParser());\n        registerBeanDefinitionParser(\"collection-aggregator-router\", new InboundRouterDefinitionParser(SimpleCollectionAggregator.class));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new InboundRouterDefinitionParser(MessageChunkAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new InboundRouterDefinitionParser(Resequencer.class));\n        registerBeanDefinitionParser(\"custom-inbound-router\", new InboundRouterDefinitionParser(null));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"pass-through-router\", new RouterDefinitionParser(OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"recipient-list-exception-based-router\", new RouterDefinitionParser(ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(ListMessageSplitter.class));\n        registerBeanDefinitionParser(\"expression-splitter-router\", new RouterDefinitionParser(ExpressionMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(StaticRecipientList.class));\n        registerBeanDefinitionParser(\"expression-recipient-list-router\", new RouterDefinitionParser(ExpressionRecipientList.class));\n        registerBeanDefinitionParser(\"recipients\", new ChildListDefinitionParser(\"recipients\"));\n        registerBeanDefinitionParser(\"custom-outbound-router\", new RouterDefinitionParser(null));\n        registerBeanDefinitionParser(\"reply-to\", new EndpointRefParser(\"replyTo\"));\n\n        //Response Routers\n        registerBeanDefinitionParser(\"custom-async-reply-router\", new InboundRouterDefinitionParser(null));\n        registerBeanDefinitionParser(\"single-async-reply-router\", new InboundRouterDefinitionParser(NullMessageProcessor.class));\n        registerBeanDefinitionParser(\"collection-async-reply-router\", new InboundRouterDefinitionParser(SimpleCollectionAggregator.class));\n\n        // Routing: Intercepting Message Processors\n        registerBeanDefinitionParser(\"idempotent-message-filter\", new InboundRouterDefinitionParser(IdempotentMessageFilter.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-message-filter\", new InboundRouterDefinitionParser(IdempotentSecureHashMessageFilter.class));\n        registerBeanDefinitionParser(\"wire-tap\", new InboundRouterDefinitionParser(WireTap.class));\n        registerBeanDefinitionParser(\"custom-aggregator\", new AggregatorDefinitionParser());\n        registerBeanDefinitionParser(\"collection-aggregator\", new AggregatorDefinitionParser(SimpleCollectionAggregator.class));\n        registerBeanDefinitionParser(\"message-chunk-aggregator\", new AggregatorDefinitionParser(MessageChunkAggregator.class));\n        registerBeanDefinitionParser(\"resequencer\", new InboundRouterDefinitionParser(Resequencer.class));\n        registerBeanDefinitionParser(\"splitter\", new SplitterDefinitionParser(ExpressionSplitter.class));\n        registerBeanDefinitionParser(\"collection-splitter\", new SplitterDefinitionParser(CollectionSplitter.class));\n        registerBeanDefinitionParser(\"message-chunk-splitter\", new SplitterDefinitionParser(MessageChunkSplitter.class));\n        registerBeanDefinitionParser(\"custom-splitter\", new SplitterDefinitionParser());\n\n        // Routing: Routing Message Processors\n\n        // Routing: Conditional Routers\n        registerBeanDefinitionParser(\"choice\", new ChildDefinitionParser(\"messageProcessor\", ChoiceRouterFactoryBean.class));\n        registerBeanDefinitionParser(\"when\", (ChildDefinitionParser)new ChildDefinitionParser(\"route\", MessageProcessorFilterPairFactoryBean.class).registerPreProcessor(new CheckExclusiveAttributesAndChildren(new String[]{\n            \"expression\"}, new String[]{\"{http://www.mulesoft.org/schema/mule/core}abstractFilterType\"})));\n        registerBeanDefinitionParser(\"otherwise\", new ChildDefinitionParser(\"defaultRoute\", MessageProcessorFilterPairFactoryBean.class));\n\n        registerBeanDefinitionParser(\"all\", new ChildDefinitionParser(\"messageProcessor\", MulticastingRouter.class));\n        registerBeanDefinitionParser(\"recipient-list\", new ChildDefinitionParser(\"messageProcessor\", ExpressionRecipientList.class));\n\n        registerBeanDefinitionParser(\"request-reply\", new ChildDefinitionParser(\"messageProcessor\", SimpleAsyncRequestReplyRequester.class));\n        registerBeanDefinitionParser(\"first-successful\", new ChildDefinitionParser(\"messageProcessor\", FirstSuccessful.class));\n        registerBeanDefinitionParser(\"round-robin\", new ChildDefinitionParser(\"messageProcessor\", RoundRobin.class));\n\n        //Message Info Mappings\n        registerBeanDefinitionParser(\"expression-message-info-mapping\", new ChildDefinitionParser(\"messageInfoMapping\", ExpressionMessageInfoMapping.class));\n        registerBeanDefinitionParser(\"custom-message-info-mapping\", new ChildDefinitionParser(\"messageInfoMapping\"));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"logging-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", LoggingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerMuleBeanDefinitionParser(\"filter\", new FilterRefDefinitionParser());\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser(AndFilter.class));\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser(OrFilter.class));\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser(NotFilter.class));\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser(RegExFilter.class));\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser(ExceptionTypeFilter.class));\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser(MessagePropertyFilter.class));\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser(PayloadTypeFilter.class));\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser(WildcardFilter.class));\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser(EqualsFilter.class));\n        registerBeanDefinitionParser(\"expression-filter\", new FilterDefinitionParser(ExpressionFilter.class));\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Utils / Standard Types\n        registerMuleBeanDefinitionParser(\"properties\", new ChildMapDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"property\", new ChildMapEntryDefinitionParser(\"properties\")).addCollection(\"properties\");\n        registerMuleBeanDefinitionParser(\"add-message-properties\", new ChildMapDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"add-message-property\", new ChildMapEntryDefinitionParser(\"addProperties\")).addCollection(\"addProperties\");\n        registerMuleBeanDefinitionParser(\"rename-message-property\", new ChildMapEntryDefinitionParser(\"renameProperties\")).addCollection(\"renameProperties\");\n        registerBeanDefinitionParser(\"delete-message-property\", new ChildListEntryDefinitionParser(\"deleteProperties\", ChildMapEntryDefinitionParser.KEY));\n        registerMuleBeanDefinitionParser(\"jndi-provider-properties\", new ChildMapDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerMuleBeanDefinitionParser(\"jndi-provider-property\", new ChildMapEntryDefinitionParser(\"jndiProviderProperties\")).addCollection(\"jndiProviderProperties\");\n        registerBeanDefinitionParser(\"environment\", new ChildMapDefinitionParser(\"environment\"));\n        registerBeanDefinitionParser(\"expression\", new ChildDefinitionParser(\"expression\", ExpressionConfig.class));\n\n        //Security\n        registerMuleBeanDefinitionParser(\"security-manager\", new NamedDefinitionParser(MuleProperties.OBJECT_SECURITY_MANAGER)).addIgnored(\"type\").addIgnored(\"name\");\n        registerBeanDefinitionParser(\"custom-security-provider\", new NameTransferDefinitionParser(\"providers\"));\n        registerMuleBeanDefinitionParser(\"custom-encryption-strategy\", new NameTransferDefinitionParser(\"encryptionStrategies\")).addAlias(\"strategy\", \"encryptionStrategy\");\n        registerBeanDefinitionParser(\"password-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", PasswordBasedEncryptionStrategy.class));\n        registerMuleBeanDefinitionParser(\"secret-key-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", SecretKeyEncryptionStrategy.class)).registerPreProcessor(new CheckExclusiveAttributes(new String[][]{new String[]{\"key\"}, new String[]{\"keyFactory-ref\"}}));\n        registerBeanDefinitionParser(\"encryption-security-filter\", new SecurityFilterDefinitionParser(MuleEncryptionEndpointSecurityFilter.class));\n        registerBeanDefinitionParser(\"custom-security-filter\", new SecurityFilterDefinitionParser());\n        //Interceptors\n        registerMuleBeanDefinitionParser(\"interceptor-stack\", new InterceptorStackDefinitionParser());\n        registerBeanDefinitionParser(\"custom-interceptor\", new InterceptorDefinitionParser());\n        registerBeanDefinitionParser(\"timer-interceptor\", new InterceptorDefinitionParser(TimerInterceptor.class));\n        registerBeanDefinitionParser(\"logging-interceptor\", new InterceptorDefinitionParser(LoggingInterceptor.class));\n    }","commit_id":"ddd5d224e7c91a49241af56277b8c247dabcabf7","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n   * Get queue at namespace level if it is empty returns the default queue.\n   *\n   * @param namespaceId NamespaceId\n   * @return schedule queue at namespace level or default queue.\n   */\n  @Nullable\n  public String getQueue(Id.Namespace namespaceId) {\n    NamespaceMeta meta = store.getNamespace(namespaceId);\n    if (meta != null) {\n      NamespaceConfig config = meta.getConfig();\n      return config.getSchedulerQueueName() != null ? config.getSchedulerQueueName() : getDefaultQueue();\n    } else {\n      return getDefaultQueue();\n    }\n  }","id":73293,"modified_method":"/**\n   * Get queue at namespace level if it is empty returns the default queue.\n   *\n   * @param namespaceId NamespaceId\n   * @return schedule queue at namespace level or default queue.\n   */\n  @Nullable\n  public String getQueue(Id.Namespace namespaceId) {\n    NamespaceMeta meta = store.getNamespace(namespaceId);\n    if (meta != null) {\n      NamespaceConfig config = meta.getConfig();\n      String namespaceQueue = config.getSchedulerQueueName();\n      return Strings.isNullOrEmpty(namespaceQueue) ? getDefaultQueue() : namespaceQueue;\n    } else {\n      return getDefaultQueue();\n    }\n  }","commit_id":"ce18322e70c2621d420cafd868f401d2629b95d0","url":"https://github.com/caskdata/cdap"},{"original_method":"public synchronized void updateProperties(Id.Namespace namespaceId, NamespaceMeta namespaceMeta)\n    throws NamespaceNotFoundException {\n\n    if (store.getNamespace(namespaceId) == null) {\n      throw new NamespaceNotFoundException(namespaceId);\n    }\n    NamespaceMeta metadata = store.getNamespace(namespaceId);\n    NamespaceMeta.Builder builder = new NamespaceMeta.Builder(metadata);\n\n    if (namespaceMeta.getDescription() != null) {\n      builder.setDescription(namespaceMeta.getDescription());\n    }\n\n    if (namespaceMeta.getName() != null) {\n      builder.setName(namespaceMeta.getName());\n    }\n\n    NamespaceConfig config = namespaceMeta.getConfig();\n\n    if (config != null && config.getSchedulerQueueName() != null && !config.getSchedulerQueueName().isEmpty()) {\n      builder.setSchedulerQueueName(config.getSchedulerQueueName());\n    }\n\n    store.updateNamespace(builder.build());\n  }","id":73294,"modified_method":"public synchronized void updateProperties(Id.Namespace namespaceId, NamespaceMeta namespaceMeta)\n    throws NamespaceNotFoundException {\n\n    if (store.getNamespace(namespaceId) == null) {\n      throw new NamespaceNotFoundException(namespaceId);\n    }\n    NamespaceMeta metadata = store.getNamespace(namespaceId);\n    NamespaceMeta.Builder builder = new NamespaceMeta.Builder(metadata);\n\n    if (namespaceMeta.getDescription() != null) {\n      builder.setDescription(namespaceMeta.getDescription());\n    }\n\n    NamespaceConfig config = namespaceMeta.getConfig();\n    if (config != null && !Strings.isNullOrEmpty(config.getSchedulerQueueName())) {\n      builder.setSchedulerQueueName(config.getSchedulerQueueName());\n    }\n\n    store.updateNamespace(builder.build());\n  }","commit_id":"476b6264b8b682fe643741b07bad8a9cda8fb4f7","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testProperties() throws Exception {\n    // create with no metadata\n    HttpResponse response = createNamespace(NAME);\n    assertResponseCode(200, response);\n    // verify\n    response = getNamespace(NAME);\n    JsonObject namespace = readGetResponse(response);\n    Assert.assertNotNull(namespace);\n    Assert.assertEquals(NAME, namespace.get(NAME_FIELD).getAsString());\n    Assert.assertEquals(EMPTY, namespace.get(DESCRIPTION_FIELD).getAsString());\n\n    NamespaceMeta meta = new NamespaceMeta.Builder().setName(NAME).setSchedulerQueueName(\"prod\").build();\n    setProperties(NAME, meta);\n    response = getNamespace(NAME);\n    namespace = readGetResponse(response);\n    Assert.assertNotNull(namespace);\n\n    // Update scheduler queue name.\n    NamespaceConfig config = GSON.fromJson(namespace.get(CONFIG_FIELD).getAsJsonObject(),\n                                                           NamespaceConfig.class);\n    Assert.assertEquals(\"prod\", config.getSchedulerQueueName());\n    Assert.assertEquals(NAME, namespace.get(NAME_FIELD).getAsString());\n    Assert.assertEquals(EMPTY, namespace.get(DESCRIPTION_FIELD).getAsString());\n\n    // Update description\n    meta = new NamespaceMeta.Builder().setName(NAME).setDescription(\"new fancy description\").build();\n    setProperties(NAME, meta);\n    response = getNamespace(NAME);\n    namespace = readGetResponse(response);\n    Assert.assertNotNull(namespace);\n\n    //verify that the description has changed\n    Assert.assertEquals(\"new fancy description\", namespace.get(DESCRIPTION_FIELD).getAsString());\n    Assert.assertEquals(NAME, namespace.get(NAME_FIELD).getAsString());\n\n    // verify other properties set earlier has not changed.\n    config = GSON.fromJson(namespace.get(CONFIG_FIELD).getAsJsonObject(),\n                           NamespaceConfig.class);\n    Assert.assertEquals(\"prod\", config.getSchedulerQueueName());\n\n    // cleanup\n    response = deleteNamespace(NAME);\n    Assert.assertEquals(200, response.getStatusLine().getStatusCode());\n  }","id":73295,"modified_method":"@Test\n  public void testProperties() throws Exception {\n    // create with no metadata\n    HttpResponse response = createNamespace(NAME);\n    assertResponseCode(200, response);\n    // verify\n    response = getNamespace(NAME);\n    JsonObject namespace = readGetResponse(response);\n    Assert.assertNotNull(namespace);\n    Assert.assertEquals(NAME, namespace.get(NAME_FIELD).getAsString());\n    Assert.assertEquals(EMPTY, namespace.get(DESCRIPTION_FIELD).getAsString());\n\n    // Update scheduler queue name.\n    String nonexistentName = NAME + \"nonexistent\";\n    NamespaceMeta meta = new NamespaceMeta.Builder().setName(nonexistentName).setSchedulerQueueName(\"prod\").build();\n    setProperties(NAME, meta);\n    // assert that the name in the metadata is ignored (the name from the url should be used, instead\n    HttpResponse nonexistentGet = getNamespace(nonexistentName);\n    Assert.assertEquals(404, nonexistentGet.getStatusLine().getStatusCode());\n\n    response = getNamespace(NAME);\n    namespace = readGetResponse(response);\n    Assert.assertNotNull(namespace);\n\n    NamespaceConfig config = GSON.fromJson(namespace.get(CONFIG_FIELD).getAsJsonObject(),\n                                                           NamespaceConfig.class);\n    Assert.assertEquals(\"prod\", config.getSchedulerQueueName());\n    Assert.assertEquals(NAME, namespace.get(NAME_FIELD).getAsString());\n    Assert.assertEquals(EMPTY, namespace.get(DESCRIPTION_FIELD).getAsString());\n\n    // Update description\n    meta = new NamespaceMeta.Builder().setName(NAME).setDescription(\"new fancy description\").build();\n    setProperties(NAME, meta);\n    response = getNamespace(NAME);\n    namespace = readGetResponse(response);\n    Assert.assertNotNull(namespace);\n\n    //verify that the description has changed\n    Assert.assertEquals(\"new fancy description\", namespace.get(DESCRIPTION_FIELD).getAsString());\n    Assert.assertEquals(NAME, namespace.get(NAME_FIELD).getAsString());\n\n    // verify other properties set earlier has not changed.\n    config = GSON.fromJson(namespace.get(CONFIG_FIELD).getAsJsonObject(), NamespaceConfig.class);\n    Assert.assertEquals(\"prod\", config.getSchedulerQueueName());\n\n    // cleanup\n    response = deleteNamespace(NAME);\n    Assert.assertEquals(200, response.getStatusLine().getStatusCode());\n  }","commit_id":"476b6264b8b682fe643741b07bad8a9cda8fb4f7","url":"https://github.com/caskdata/cdap"},{"original_method":"public synchronized void updateProperties(Id.Namespace namespaceId, NamespaceMeta namespaceMeta)\n    throws NamespaceNotFoundException {\n\n    if (store.getNamespace(namespaceId) == null) {\n      throw new NamespaceNotFoundException(namespaceId);\n    }\n    NamespaceMeta metadata = store.getNamespace(namespaceId);\n    NamespaceMeta.Builder builder = new NamespaceMeta.Builder(metadata);\n\n    if (namespaceMeta.getDescription() != null) {\n      builder.setDescription(namespaceMeta.getDescription());\n    }\n\n    if (namespaceMeta.getName() != null) {\n      builder.setName(namespaceMeta.getName());\n    }\n\n    NamespaceConfig config = namespaceMeta.getConfig();\n\n    if (config != null && config.getSchedulerQueueName() != null && !config.getSchedulerQueueName().isEmpty()) {\n      builder.setSchedulerQueueName(config.getSchedulerQueueName());\n    }\n\n    store.updateNamespace(builder.build());\n  }","id":73296,"modified_method":"public synchronized void updateProperties(Id.Namespace namespaceId, NamespaceMeta namespaceMeta)\n    throws NamespaceNotFoundException {\n\n    if (store.getNamespace(namespaceId) == null) {\n      throw new NamespaceNotFoundException(namespaceId);\n    }\n    NamespaceMeta metadata = store.getNamespace(namespaceId);\n    NamespaceMeta.Builder builder = new NamespaceMeta.Builder(metadata);\n\n    if (namespaceMeta.getDescription() != null) {\n      builder.setDescription(namespaceMeta.getDescription());\n    }\n\n    NamespaceConfig config = namespaceMeta.getConfig();\n    if (config != null && !Strings.isNullOrEmpty(config.getSchedulerQueueName())) {\n      builder.setSchedulerQueueName(config.getSchedulerQueueName());\n    }\n\n    store.updateNamespace(builder.build());\n  }","commit_id":"8e4437ac39593d353f5937ff4e4e89934dde8eb0","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testProperties() throws Exception {\n    // create with no metadata\n    HttpResponse response = createNamespace(NAME);\n    assertResponseCode(200, response);\n    // verify\n    response = getNamespace(NAME);\n    JsonObject namespace = readGetResponse(response);\n    Assert.assertNotNull(namespace);\n    Assert.assertEquals(NAME, namespace.get(NAME_FIELD).getAsString());\n    Assert.assertEquals(EMPTY, namespace.get(DESCRIPTION_FIELD).getAsString());\n\n    NamespaceMeta meta = new NamespaceMeta.Builder().setName(NAME).setSchedulerQueueName(\"prod\").build();\n    setProperties(NAME, meta);\n    response = getNamespace(NAME);\n    namespace = readGetResponse(response);\n    Assert.assertNotNull(namespace);\n\n    // Update scheduler queue name.\n    NamespaceConfig config = GSON.fromJson(namespace.get(CONFIG_FIELD).getAsJsonObject(),\n                                                           NamespaceConfig.class);\n    Assert.assertEquals(\"prod\", config.getSchedulerQueueName());\n    Assert.assertEquals(NAME, namespace.get(NAME_FIELD).getAsString());\n    Assert.assertEquals(EMPTY, namespace.get(DESCRIPTION_FIELD).getAsString());\n\n    // Update description\n    meta = new NamespaceMeta.Builder().setName(NAME).setDescription(\"new fancy description\").build();\n    setProperties(NAME, meta);\n    response = getNamespace(NAME);\n    namespace = readGetResponse(response);\n    Assert.assertNotNull(namespace);\n\n    //verify that the description has changed\n    Assert.assertEquals(\"new fancy description\", namespace.get(DESCRIPTION_FIELD).getAsString());\n    Assert.assertEquals(NAME, namespace.get(NAME_FIELD).getAsString());\n\n    // verify other properties set earlier has not changed.\n    config = GSON.fromJson(namespace.get(CONFIG_FIELD).getAsJsonObject(),\n                           NamespaceConfig.class);\n    Assert.assertEquals(\"prod\", config.getSchedulerQueueName());\n\n    // cleanup\n    response = deleteNamespace(NAME);\n    Assert.assertEquals(200, response.getStatusLine().getStatusCode());\n  }","id":73297,"modified_method":"@Test\n  public void testProperties() throws Exception {\n    // create with no metadata\n    HttpResponse response = createNamespace(NAME);\n    assertResponseCode(200, response);\n    // verify\n    response = getNamespace(NAME);\n    JsonObject namespace = readGetResponse(response);\n    Assert.assertNotNull(namespace);\n    Assert.assertEquals(NAME, namespace.get(NAME_FIELD).getAsString());\n    Assert.assertEquals(EMPTY, namespace.get(DESCRIPTION_FIELD).getAsString());\n\n    // Update scheduler queue name.\n    String nonexistentName = NAME + \"nonexistent\";\n    NamespaceMeta meta = new NamespaceMeta.Builder().setName(nonexistentName).setSchedulerQueueName(\"prod\").build();\n    setProperties(NAME, meta);\n    // assert that the name in the metadata is ignored (the name from the url should be used, instead\n    HttpResponse nonexistentGet = getNamespace(nonexistentName);\n    Assert.assertEquals(404, nonexistentGet.getStatusLine().getStatusCode());\n\n    response = getNamespace(NAME);\n    namespace = readGetResponse(response);\n    Assert.assertNotNull(namespace);\n\n    NamespaceConfig config = GSON.fromJson(namespace.get(CONFIG_FIELD).getAsJsonObject(),\n                                                           NamespaceConfig.class);\n    Assert.assertEquals(\"prod\", config.getSchedulerQueueName());\n    Assert.assertEquals(NAME, namespace.get(NAME_FIELD).getAsString());\n    Assert.assertEquals(EMPTY, namespace.get(DESCRIPTION_FIELD).getAsString());\n\n    // Update description\n    meta = new NamespaceMeta.Builder().setName(NAME).setDescription(\"new fancy description\").build();\n    setProperties(NAME, meta);\n    response = getNamespace(NAME);\n    namespace = readGetResponse(response);\n    Assert.assertNotNull(namespace);\n\n    //verify that the description has changed\n    Assert.assertEquals(\"new fancy description\", namespace.get(DESCRIPTION_FIELD).getAsString());\n    Assert.assertEquals(NAME, namespace.get(NAME_FIELD).getAsString());\n\n    // verify other properties set earlier has not changed.\n    config = GSON.fromJson(namespace.get(CONFIG_FIELD).getAsJsonObject(), NamespaceConfig.class);\n    Assert.assertEquals(\"prod\", config.getSchedulerQueueName());\n\n    // cleanup\n    response = deleteNamespace(NAME);\n    Assert.assertEquals(200, response.getStatusLine().getStatusCode());\n  }","commit_id":"8e4437ac39593d353f5937ff4e4e89934dde8eb0","url":"https://github.com/caskdata/cdap"},{"original_method":"private Properties createOverridingProperties()\r\n    {\r\n        Properties props = new Properties();\r\n        props.setProperty( \"checkstyle.header.file\", \"LICENSE.txt\" );\r\n        // TODO: explicit output directory when it is back\r\n        props.setProperty( \"checkstyle.cache.file\", getProject().getModel().getBuild().getDirectory() + \"/checkstyle-cachefile\" );\r\n        return props;\r\n    }","id":73298,"modified_method":"private Properties getOverridingProperties() throws MavenReportException\n    {\n        Properties p = new Properties();\n        \n        try\n        {\n            if (  propertiesFile != null )\n            {\n                p.load( new FileInputStream( propertiesFile ) );\n            }\n            else if ( propertiesURL != null )\n            {\n                p.load( propertiesURL.openStream() );\n            }\n\n            if ( headerFile != null )\n                p.setProperty( \"checkstyle.header.file\", headerFile );\n\n            if ( cacheFile != null )\n                p.setProperty( \"checkstyle.cache.file\", cacheFile );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Failed to get overriding properties\", e );\n        }\n        \n        return p;\n    }","commit_id":"efa3609d70636348b001b72ca7ae3cc578df3f35","url":"https://github.com/apache/maven"},{"original_method":"/**\r\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\r\n     */\r\n    public void executeReport( Locale locale )\r\n        throws MavenReportException\r\n    {\r\n        // ----------------------------------------------------------------------\r\n        //\r\n        // ----------------------------------------------------------------------\r\n\r\n        AuditListener listener = null;\r\n\r\n        if ( StringUtils.isNotEmpty( extraFormatter ) )\r\n        {\r\n            FileOutputStream out;\r\n            // TODO: I removed outputDirectory, and shouldn't have. Put it back here.\r\n            File resultFile = new File( getProject().getModel().getBuild().getDirectory() + \"/site\", resultFileName );\r\n            try\r\n            {\r\n                File parentFile = resultFile.getParentFile();\r\n                parentFile.mkdirs();\r\n                out = new FileOutputStream( resultFile );\r\n            }\r\n            catch( IOException e )\r\n            {\r\n                throw new MavenReportException( \"Can't access to \" + resultFile.getAbsolutePath(), e );\r\n            }\r\n\r\n            if ( \"xml\".equals( extraFormatter ) )\r\n            {\r\n                listener = new XMLLogger( out, true );\r\n            }\r\n            else if ( \"plain\".equals( extraFormatter ) )\r\n            {\r\n                listener = new DefaultLogger( out, true );\r\n            }\r\n            else\r\n            {\r\n                throw new MavenReportException( \"Invalid format: (\" + extraFormatter + \"). Must be 'plain' or 'xml'.\" );\r\n            }\r\n        }\r\n\r\n        File[] files;\r\n        String sourceDirectory = getProject().getBuild().getSourceDirectory();\r\n        try\r\n        {\r\n            List filesList = getFilesToProcess( \"**/*.java\", null );\r\n            files = new File[filesList.size()];\r\n            int i = 0;\r\n            for ( Iterator iter = filesList.iterator(); iter.hasNext(); )\r\n            {\r\n                files[i++] = (File) iter.next();\r\n            }\r\n        }\r\n        catch( IOException e )\r\n        {\r\n            throw new MavenReportException( \"Can't parse \" + sourceDirectory, e );\r\n        }\r\n\r\n        Configuration config;\r\n\r\n        try\r\n        {\r\n            Properties overridingProperties = createOverridingProperties();\r\n            config = ConfigurationLoader.loadConfiguration( configFile.toString(),\r\n                                                            new PropertiesExpander( overridingProperties ) );\r\n        }\r\n        catch ( CheckstyleException e )\r\n        {\r\n            throw new MavenReportException( \"Error loading config file : \" + configFile.toString(), e );\r\n        }\r\n\r\n        ModuleFactory moduleFactory = null;\r\n\r\n        if ( StringUtils.isNotEmpty( packageNamesFile ) )\r\n        {\r\n            try\r\n            {\r\n                moduleFactory = PackageNamesLoader.loadModuleFactory( packageNamesFile );\r\n            }\r\n            catch ( CheckstyleException e )\r\n            {\r\n                throw new MavenReportException( \"Error loading package names file : \" + packageNamesFile, e );\r\n            }\r\n        }\r\n\r\n        Checker checker = null;\r\n\r\n        try\r\n        {\r\n            checker = new Checker();\r\n\r\n            checker.setModuleFactory( moduleFactory );\r\n\r\n            checker.configure( config );\r\n\r\n            // TODO: use source roots\r\n            AuditListener sinkListener = new CheckstyleReportListener( getSink(), sourceDirectory, getBundle( locale ) );\r\n\r\n            if ( listener != null )\r\n            {\r\n                checker.addListener( listener );\r\n            }\r\n\r\n            checker.addListener( sinkListener );\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MavenReportException( \"Unable to create Checker: \" + e.getMessage(), e );\r\n        }\r\n\r\n        int nbErrors = checker.process( files );\r\n\r\n        if ( checker != null )\r\n        {\r\n            checker.destroy();\r\n        }\r\n        \r\n        if ( failedOnError && nbErrors > 0 )\r\n        {\r\n            throw new MavenReportException( \"There are \" + nbErrors + \" formatting errors.\" );\r\n        }\r\n    }","id":73299,"modified_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    public void executeReport( Locale locale ) throws MavenReportException\n    {\n        File[] files = getFilesToProcess( includes, excludes );\n\n        String configFile = getConfigFile();\n\n        Properties overridingProperties = getOverridingProperties();\n\n        ModuleFactory moduleFactory = getModuleFactory();\n        \n        FilterSet filterSet = getSuppressions();\n        \n        Checker checker = null;\n        \n        try\n        {\n            Configuration config = ConfigurationLoader.loadConfiguration( configFile,\n                                       new PropertiesExpander( overridingProperties ) );\n\n            checker = new Checker();\n\n            if ( moduleFactory != null ) checker.setModuleFactory( moduleFactory );\n            \n            if ( filterSet != null ) checker.addFilter( filterSet );\n\n            checker.configure( config );\n        }\n        catch( CheckstyleException ce )\n        {\n            throw new MavenReportException( \"Failed during checkstyle configuration\", ce );\n        }\n\n        AuditListener listener = getListener();\n\n        if ( listener != null )\n        {\n            checker.addListener( listener );\n        }\n        \n        if ( StringUtils.isNotEmpty( useFile ) )\n        {\n            File outputFile = new File( useFile );\n            \n            OutputStream out = getOutputStream( outputFile );\n            \n            checker.addListener( new DefaultLogger( out, true ) );\n        }\n\n        AuditListener sinkListener = new CheckstyleReportListener( getSink(), sourceDirectory, getBundle( locale ) );\n\n        checker.addListener( sinkListener );\n\n        int nbErrors = checker.process( files );\n\n        checker.destroy();\n\n        if ( failsOnError && nbErrors > 0 )\n        {\n            throw new MavenReportException( \"There are \" + nbErrors + \" formatting errors.\" );\n        }\n    }","commit_id":"efa3609d70636348b001b72ca7ae3cc578df3f35","url":"https://github.com/apache/maven"},{"original_method":"private List getFilesToProcess( String includes, String excludes )\r\n        throws IOException\r\n    {\r\n        StringBuffer excludesStr = new StringBuffer();\r\n        if ( StringUtils.isNotEmpty( excludes ) )\r\n        {\r\n            excludesStr.append(excludes);\r\n        }\r\n        for ( int i = 0; i < DEFAULT_EXCLUDES.length; i++ )\r\n        {\r\n            if ( excludesStr.length() > 0 )\r\n            {\r\n                excludesStr.append( \",\" );\r\n            }\r\n            excludesStr.append( DEFAULT_EXCLUDES[i] );\r\n        }\r\n\r\n        return FileUtils.getFiles( new File( getProject().getBuild().getSourceDirectory() ), includes, excludesStr.toString() );\r\n    }","id":73300,"modified_method":"private File[] getFilesToProcess( String includes, String excludes ) throws MavenReportException\n    {\n        StringBuffer excludesStr = new StringBuffer();\n        \n        if ( StringUtils.isNotEmpty( excludes ) )\n        {\n            excludesStr.append(excludes);\n        }\n        \n        for ( int i = 0; i < DEFAULT_EXCLUDES.length; i++ )\n        {\n            if ( excludesStr.length() > 0 )\n            {\n                excludesStr.append( \",\" );\n            }\n            \n            excludesStr.append( DEFAULT_EXCLUDES[i] );\n        }\n\n        List files;\n        \n        try\n        {\n            files = FileUtils.getFiles( new File( sourceDirectory ), includes, excludesStr.toString() );\n        }\n        catch ( IOException ioe )\n        {\n            throw new MavenReportException( \"Failed to get source files\", ioe );\n        }\n        \n        return (File[]) ( files.toArray( new File[ 0 ] ) );\n    }","commit_id":"efa3609d70636348b001b72ca7ae3cc578df3f35","url":"https://github.com/apache/maven"},{"original_method":"private List getFilesToProcess( String includes, String excludes )\r\n        throws IOException\r\n    {\r\n        StringBuffer excludesStr = new StringBuffer();\r\n        if ( StringUtils.isNotEmpty( excludes ) )\r\n        {\r\n            excludesStr.append(excludes);\r\n        }\r\n        for ( int i = 0; i < DEFAULT_EXCLUDES.length; i++ )\r\n        {\r\n            if ( excludesStr.length() > 0 )\r\n            {\r\n                excludesStr.append( \",\" );\r\n            }\r\n            excludesStr.append( DEFAULT_EXCLUDES[i] );\r\n        }\r\n\r\n        return FileUtils.getFiles( new File( getProject().getBuild().getSourceDirectory() ), includes, excludesStr.toString() );\r\n    }","id":73301,"modified_method":"private File[] getFilesToProcess( String includes, String excludes ) throws MavenReportException\n    {\n        StringBuffer excludesStr = new StringBuffer();\n        \n        if ( StringUtils.isNotEmpty( excludes ) )\n        {\n            excludesStr.append(excludes);\n        }\n        \n        for ( int i = 0; i < DEFAULT_EXCLUDES.length; i++ )\n        {\n            if ( excludesStr.length() > 0 )\n            {\n                excludesStr.append( \",\" );\n            }\n            \n            excludesStr.append( DEFAULT_EXCLUDES[i] );\n        }\n\n        List files;\n        \n        try\n        {\n            files = FileUtils.getFiles( new File( sourceDirectory ), includes, excludesStr.toString() );\n        }\n        catch ( IOException ioe )\n        {\n            throw new MavenReportException( \"Failed to get source files\", ioe );\n        }\n        \n        return (File[]) ( files.toArray( new File[ 0 ] ) );\n    }","commit_id":"b245d03078aab80e63cc68fee8c4a1503a73b9d5","url":"https://github.com/apache/maven-plugins"},{"original_method":"private Properties createOverridingProperties()\r\n    {\r\n        Properties props = new Properties();\r\n        props.setProperty( \"checkstyle.header.file\", \"LICENSE.txt\" );\r\n        // TODO: explicit output directory when it is back\r\n        props.setProperty( \"checkstyle.cache.file\", getProject().getModel().getBuild().getDirectory() + \"/checkstyle-cachefile\" );\r\n        return props;\r\n    }","id":73302,"modified_method":"private Properties getOverridingProperties() throws MavenReportException\n    {\n        Properties p = new Properties();\n        \n        try\n        {\n            if (  propertiesFile != null )\n            {\n                p.load( new FileInputStream( propertiesFile ) );\n            }\n            else if ( propertiesURL != null )\n            {\n                p.load( propertiesURL.openStream() );\n            }\n\n            if ( headerFile != null )\n                p.setProperty( \"checkstyle.header.file\", headerFile );\n\n            if ( cacheFile != null )\n                p.setProperty( \"checkstyle.cache.file\", cacheFile );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Failed to get overriding properties\", e );\n        }\n        \n        return p;\n    }","commit_id":"b245d03078aab80e63cc68fee8c4a1503a73b9d5","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\r\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\r\n     */\r\n    public void executeReport( Locale locale )\r\n        throws MavenReportException\r\n    {\r\n        // ----------------------------------------------------------------------\r\n        //\r\n        // ----------------------------------------------------------------------\r\n\r\n        AuditListener listener = null;\r\n\r\n        if ( StringUtils.isNotEmpty( extraFormatter ) )\r\n        {\r\n            FileOutputStream out;\r\n            // TODO: I removed outputDirectory, and shouldn't have. Put it back here.\r\n            File resultFile = new File( getProject().getModel().getBuild().getDirectory() + \"/site\", resultFileName );\r\n            try\r\n            {\r\n                File parentFile = resultFile.getParentFile();\r\n                parentFile.mkdirs();\r\n                out = new FileOutputStream( resultFile );\r\n            }\r\n            catch( IOException e )\r\n            {\r\n                throw new MavenReportException( \"Can't access to \" + resultFile.getAbsolutePath(), e );\r\n            }\r\n\r\n            if ( \"xml\".equals( extraFormatter ) )\r\n            {\r\n                listener = new XMLLogger( out, true );\r\n            }\r\n            else if ( \"plain\".equals( extraFormatter ) )\r\n            {\r\n                listener = new DefaultLogger( out, true );\r\n            }\r\n            else\r\n            {\r\n                throw new MavenReportException( \"Invalid format: (\" + extraFormatter + \"). Must be 'plain' or 'xml'.\" );\r\n            }\r\n        }\r\n\r\n        File[] files;\r\n        String sourceDirectory = getProject().getBuild().getSourceDirectory();\r\n        try\r\n        {\r\n            List filesList = getFilesToProcess( \"**/*.java\", null );\r\n            files = new File[filesList.size()];\r\n            int i = 0;\r\n            for ( Iterator iter = filesList.iterator(); iter.hasNext(); )\r\n            {\r\n                files[i++] = (File) iter.next();\r\n            }\r\n        }\r\n        catch( IOException e )\r\n        {\r\n            throw new MavenReportException( \"Can't parse \" + sourceDirectory, e );\r\n        }\r\n\r\n        Configuration config;\r\n\r\n        try\r\n        {\r\n            Properties overridingProperties = createOverridingProperties();\r\n            config = ConfigurationLoader.loadConfiguration( configFile.toString(),\r\n                                                            new PropertiesExpander( overridingProperties ) );\r\n        }\r\n        catch ( CheckstyleException e )\r\n        {\r\n            throw new MavenReportException( \"Error loading config file : \" + configFile.toString(), e );\r\n        }\r\n\r\n        ModuleFactory moduleFactory = null;\r\n\r\n        if ( StringUtils.isNotEmpty( packageNamesFile ) )\r\n        {\r\n            try\r\n            {\r\n                moduleFactory = PackageNamesLoader.loadModuleFactory( packageNamesFile );\r\n            }\r\n            catch ( CheckstyleException e )\r\n            {\r\n                throw new MavenReportException( \"Error loading package names file : \" + packageNamesFile, e );\r\n            }\r\n        }\r\n\r\n        Checker checker = null;\r\n\r\n        try\r\n        {\r\n            checker = new Checker();\r\n\r\n            checker.setModuleFactory( moduleFactory );\r\n\r\n            checker.configure( config );\r\n\r\n            // TODO: use source roots\r\n            AuditListener sinkListener = new CheckstyleReportListener( getSink(), sourceDirectory, getBundle( locale ) );\r\n\r\n            if ( listener != null )\r\n            {\r\n                checker.addListener( listener );\r\n            }\r\n\r\n            checker.addListener( sinkListener );\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MavenReportException( \"Unable to create Checker: \" + e.getMessage(), e );\r\n        }\r\n\r\n        int nbErrors = checker.process( files );\r\n\r\n        if ( checker != null )\r\n        {\r\n            checker.destroy();\r\n        }\r\n        \r\n        if ( failedOnError && nbErrors > 0 )\r\n        {\r\n            throw new MavenReportException( \"There are \" + nbErrors + \" formatting errors.\" );\r\n        }\r\n    }","id":73303,"modified_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    public void executeReport( Locale locale ) throws MavenReportException\n    {\n        File[] files = getFilesToProcess( includes, excludes );\n\n        String configFile = getConfigFile();\n\n        Properties overridingProperties = getOverridingProperties();\n\n        ModuleFactory moduleFactory = getModuleFactory();\n        \n        FilterSet filterSet = getSuppressions();\n        \n        Checker checker = null;\n        \n        try\n        {\n            Configuration config = ConfigurationLoader.loadConfiguration( configFile,\n                                       new PropertiesExpander( overridingProperties ) );\n\n            checker = new Checker();\n\n            if ( moduleFactory != null ) checker.setModuleFactory( moduleFactory );\n            \n            if ( filterSet != null ) checker.addFilter( filterSet );\n\n            checker.configure( config );\n        }\n        catch( CheckstyleException ce )\n        {\n            throw new MavenReportException( \"Failed during checkstyle configuration\", ce );\n        }\n\n        AuditListener listener = getListener();\n\n        if ( listener != null )\n        {\n            checker.addListener( listener );\n        }\n        \n        if ( StringUtils.isNotEmpty( useFile ) )\n        {\n            File outputFile = new File( useFile );\n            \n            OutputStream out = getOutputStream( outputFile );\n            \n            checker.addListener( new DefaultLogger( out, true ) );\n        }\n\n        AuditListener sinkListener = new CheckstyleReportListener( getSink(), sourceDirectory, getBundle( locale ) );\n\n        checker.addListener( sinkListener );\n\n        int nbErrors = checker.process( files );\n\n        checker.destroy();\n\n        if ( failsOnError && nbErrors > 0 )\n        {\n            throw new MavenReportException( \"There are \" + nbErrors + \" formatting errors.\" );\n        }\n    }","commit_id":"b245d03078aab80e63cc68fee8c4a1503a73b9d5","url":"https://github.com/apache/maven-plugins"},{"original_method":"@NotNull\n  public static Set<FilePath> getFilteredFilesForRoot(@NotNull VirtualFile root, VcsLogFilterCollection filterCollection) {\n    if (filterCollection.getStructureFilter() == null) return Collections.emptySet();\n\n    Pair<Set<VirtualFile>, MultiMap<VirtualFile, FilePath>> rootsAndFiles =\n      collectRoots(filterCollection.getStructureFilter().getFiles(), Collections.singleton(root));\n\n    return new HashSet<FilePath>(rootsAndFiles.second.get(root));\n  }","id":73304,"modified_method":"@NotNull\n  public static Set<FilePath> getFilteredFilesForRoot(@NotNull final VirtualFile root, @NotNull VcsLogFilterCollection filterCollection) {\n    if (filterCollection.getStructureFilter() == null) return Collections.emptySet();\n    Collection<FilePath> files = filterCollection.getStructureFilter().getFiles();\n\n    return new HashSet<FilePath>(ContainerUtil.filter(files, new Condition<FilePath>() {\n      @Override\n      public boolean value(FilePath filePath) {\n        VirtualFile virtualFileParent = ChangesUtil.findValidParentAccurately(filePath);\n        if (virtualFileParent != null) {\n          return root.equals(virtualFileParent) || VfsUtilCore.isAncestor(root, virtualFileParent, false);\n        }\n        return false;\n      }\n    }));\n  }","commit_id":"dbce2f16ca323c592e73d4ed5c177a8791a9cd42","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FileCollection getFiles() {\n            List<File> files = new ArrayList<File>();\n            for (Map.Entry<String, IncrementalFileSnapshot> entry : snapshots.entrySet()) {\n                if (entry.getValue() instanceof FileHashSnapshot) {\n                    files.add(new File(entry.getKey()));\n                }\n            }\n            return new SimpleFileCollection(files);\n        }","id":73305,"modified_method":"public List<File> getFiles() {\n            List<File> files = new ArrayList<File>();\n            for (Map.Entry<String, IncrementalFileSnapshot> entry : snapshots.entrySet()) {\n                if (entry.getValue() instanceof FileHashSnapshot) {\n                    files.add(new File(entry.getKey()));\n                }\n            }\n            return files;\n        }","commit_id":"460b7944980e72f4c4f13b0c04c71e97e4feafb7","url":"https://github.com/gradle/gradle"},{"original_method":"public FileCollection getAllFiles() {\n            List<File> files = Lists.newArrayList();\n            for (Map.Entry<String, IncrementalFileSnapshot> entry : snapshots.entrySet()) {\n                if (!(entry.getValue() instanceof DirSnapshot)) {\n                    files.add(new File(entry.getKey()));\n                }\n            }\n            return new SimpleFileCollection(files);\n        }","id":73306,"modified_method":"public List<File> getAllFiles() {\n            List<File> files = Lists.newArrayList();\n            for (Map.Entry<String, IncrementalFileSnapshot> entry : snapshots.entrySet()) {\n                if (!(entry.getValue() instanceof DirSnapshot)) {\n                    files.add(new File(entry.getKey()));\n                }\n            }\n            return files;\n        }","commit_id":"460b7944980e72f4c4f13b0c04c71e97e4feafb7","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultTaskArtifactStateRepository(TaskHistoryRepository taskHistoryRepository, Instantiator instantiator,\n                                              FileCollectionSnapshotter outputFilesSnapshotter, FileCollectionSnapshotter inputFilesSnapshotter,\n                                              FileCollectionSnapshotter discoveredFileCollectionSnapshotter) {\n        this.taskHistoryRepository = taskHistoryRepository;\n        this.instantiator = instantiator;\n        this.outputFilesSnapshotter = outputFilesSnapshotter;\n        this.inputFilesSnapshotter = inputFilesSnapshotter;\n        this.discoveredFilesSnapshotter = discoveredFileCollectionSnapshotter;\n    }","id":73307,"modified_method":"public DefaultTaskArtifactStateRepository(TaskHistoryRepository taskHistoryRepository, Instantiator instantiator,\n                                              FileCollectionSnapshotter outputFilesSnapshotter, FileCollectionSnapshotter inputFilesSnapshotter,\n                                              FileCollectionSnapshotter discoveredFileCollectionSnapshotter, FileCollectionFactory fileCollectionFactory) {\n        this.taskHistoryRepository = taskHistoryRepository;\n        this.instantiator = instantiator;\n        this.outputFilesSnapshotter = outputFilesSnapshotter;\n        this.inputFilesSnapshotter = inputFilesSnapshotter;\n        this.fileCollectionFactory = fileCollectionFactory;\n        discoveredInputFilesStateChangeRule = new DiscoveredInputFilesStateChangeRule(discoveredFileCollectionSnapshotter, this.fileCollectionFactory);\n    }","commit_id":"460b7944980e72f4c4f13b0c04c71e97e4feafb7","url":"https://github.com/gradle/gradle"},{"original_method":"private TaskUpToDateState getStates() {\n            if (states == null) {\n                // Calculate initial state - note this is potentially expensive\n                states = new TaskUpToDateState(task, history, outputFilesSnapshotter, inputFilesSnapshotter, discoveredFilesSnapshotter);\n            }\n            return states;\n        }","id":73308,"modified_method":"private TaskUpToDateState getStates() {\n            if (states == null) {\n                // Calculate initial state - note this is potentially expensive\n                states = new TaskUpToDateState(task, history, outputFilesSnapshotter, inputFilesSnapshotter, discoveredInputFilesStateChangeRule);\n            }\n            return states;\n        }","commit_id":"460b7944980e72f4c4f13b0c04c71e97e4feafb7","url":"https://github.com/gradle/gradle"},{"original_method":"public FileCollection getOutputFiles() {\n            TaskExecution lastExecution = history.getPreviousExecution();\n            return lastExecution != null && lastExecution.getOutputFilesSnapshot() != null ? lastExecution.getOutputFilesSnapshot().getFiles() : new SimpleFileCollection();\n        }","id":73309,"modified_method":"public FileCollection getOutputFiles() {\n            TaskExecution lastExecution = history.getPreviousExecution();\n            if (lastExecution != null && lastExecution.getOutputFilesSnapshot() != null) {\n                return fileCollectionFactory.fixed(\"Task \" + task.getPath() + \" outputs\", lastExecution.getOutputFilesSnapshot().getFiles());\n            } else {\n                return fileCollectionFactory.empty(\"Task \" + task.getPath() + \" outputs\");\n            }\n        }","commit_id":"460b7944980e72f4c4f13b0c04c71e97e4feafb7","url":"https://github.com/gradle/gradle"},{"original_method":"public static DiscoveredTaskStateChanges create(final TaskExecution previousExecution, final TaskExecution currentExecution, final FileCollectionSnapshotter inputFilesSnapshotter) {\n        return new DiscoveredTaskStateChanges() {\n            private final Collection<File> discoveredFiles = Sets.newHashSet();\n\n            public Iterator<TaskStateChange> iterator() {\n                if (previousExecution.getDiscoveredInputFilesSnapshot() == null) {\n                    return Collections.<TaskStateChange>singleton(new DescriptiveChange(\"Discovered input file history is not available.\")).iterator();\n                }\n\n                Iterables.addAll(discoveredFiles, previousExecution.getDiscoveredInputFilesSnapshot().getAllFiles());\n                final FileCollectionSnapshot discoveredFileSnapshot = inputFilesSnapshotter.snapshot(new SimpleFileCollection(discoveredFiles));\n\n                return new AbstractIterator<TaskStateChange>() {\n                    final FileCollectionSnapshot.ChangeIterator<String> changeIterator = discoveredFileSnapshot.iterateChangesSince(previousExecution.getDiscoveredInputFilesSnapshot());\n                    final ChangeListenerAdapter listenerAdapter = new ChangeListenerAdapter();\n\n                    @Override\n                    protected TaskStateChange computeNext() {\n                        if (changeIterator.next(listenerAdapter)) {\n                            return listenerAdapter.lastChange;\n                        }\n                        return endOfData();\n                    }\n                };\n            }\n\n            @Override\n            public void newInputs(Set<File> files) {\n                discoveredFiles.clear();\n                discoveredFiles.addAll(files);\n            }\n\n            public void snapshotAfterTask() {\n\n                currentExecution.setDiscoveredInputFilesSnapshot(inputFilesSnapshotter.snapshot(new SimpleFileCollection(discoveredFiles)));\n            }\n        };\n    }","id":73310,"modified_method":"public DiscoveredInputFilesStateChangeRule(FileCollectionSnapshotter inputFilesSnapshotter, FileCollectionFactory fileCollectionFactory) {\n        this.inputFilesSnapshotter = inputFilesSnapshotter;\n        this.fileCollectionFactory = fileCollectionFactory;\n    }","commit_id":"460b7944980e72f4c4f13b0c04c71e97e4feafb7","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected void visitFiles(FileCollection input, final List<FileVisitDetails> allFileVisitDetails, final List<File> missingFiles) {\n        visitFiles(new ListBackedFileSet(input.getFiles()), allFileVisitDetails, missingFiles);\n    }","id":73311,"modified_method":"@Override\n    protected void visitFiles(FileCollection input, final List<FileVisitDetails> allFileVisitDetails, final List<File> missingFiles) {\n        for (File file : input.getFiles()) {\n            if (file.exists()) {\n                allFileVisitDetails.add(new DefaultFileVisitDetails(file, fileSystem, fileSystem));\n            } else {\n                missingFiles.add(file);\n            }\n        }\n    }","commit_id":"460b7944980e72f4c4f13b0c04c71e97e4feafb7","url":"https://github.com/gradle/gradle"},{"original_method":"TaskArtifactStateRepository createTaskArtifactStateRepository(Instantiator instantiator, TaskArtifactStateCacheAccess cacheAccess, StartParameter startParameter, FileSnapshotter fileSnapshotter,\n                                                                  StringInterner stringInterner, FileResolver fileResolver, FileSystem fileSystem) {\n        FileCollectionSnapshotter fileCollectionSnapshotter = new DefaultFileCollectionSnapshotter(fileSnapshotter, cacheAccess, stringInterner, fileResolver);\n        FileCollectionSnapshotter discoveredFileCollectionSnapshotter = new MinimalFileSetSnapshotter(fileSnapshotter, cacheAccess, stringInterner, fileResolver, fileSystem);\n\n        FileCollectionSnapshotter outputFilesSnapshotter = new OutputFilesCollectionSnapshotter(fileCollectionSnapshotter, new RandomLongIdGenerator(), cacheAccess, stringInterner);\n\n        SerializerRegistry<FileCollectionSnapshot> serializerRegistry = new DefaultSerializerRegistry<FileCollectionSnapshot>();\n        fileCollectionSnapshotter.registerSerializers(serializerRegistry);\n        outputFilesSnapshotter.registerSerializers(serializerRegistry);\n        fileCollectionSnapshotter.registerSerializers(serializerRegistry);\n\n        TaskHistoryRepository taskHistoryRepository = new CacheBackedTaskHistoryRepository(cacheAccess,\n            new CacheBackedFileSnapshotRepository(cacheAccess,\n                serializerRegistry.build(),\n                new RandomLongIdGenerator()),\n            stringInterner);\n\n        return new ShortCircuitTaskArtifactStateRepository(\n            startParameter,\n            instantiator,\n            new DefaultTaskArtifactStateRepository(\n                taskHistoryRepository,\n                instantiator,\n                outputFilesSnapshotter,\n                fileCollectionSnapshotter,\n                discoveredFileCollectionSnapshotter\n            )\n        );\n    }","id":73312,"modified_method":"TaskArtifactStateRepository createTaskArtifactStateRepository(Instantiator instantiator, TaskArtifactStateCacheAccess cacheAccess, StartParameter startParameter, FileSnapshotter fileSnapshotter,\n                                                                  StringInterner stringInterner, FileResolver fileResolver, FileSystem fileSystem, FileCollectionFactory fileCollectionFactory) {\n        FileCollectionSnapshotter fileCollectionSnapshotter = new DefaultFileCollectionSnapshotter(fileSnapshotter, cacheAccess, stringInterner, fileResolver);\n        FileCollectionSnapshotter discoveredFileCollectionSnapshotter = new MinimalFileSetSnapshotter(fileSnapshotter, cacheAccess, stringInterner, fileResolver, fileSystem);\n\n        FileCollectionSnapshotter outputFilesSnapshotter = new OutputFilesCollectionSnapshotter(fileCollectionSnapshotter, new RandomLongIdGenerator(), cacheAccess, stringInterner);\n\n        SerializerRegistry<FileCollectionSnapshot> serializerRegistry = new DefaultSerializerRegistry<FileCollectionSnapshot>();\n        fileCollectionSnapshotter.registerSerializers(serializerRegistry);\n        outputFilesSnapshotter.registerSerializers(serializerRegistry);\n        fileCollectionSnapshotter.registerSerializers(serializerRegistry);\n\n        TaskHistoryRepository taskHistoryRepository = new CacheBackedTaskHistoryRepository(cacheAccess,\n            new CacheBackedFileSnapshotRepository(cacheAccess,\n                serializerRegistry.build(),\n                new RandomLongIdGenerator()),\n            stringInterner);\n\n        return new ShortCircuitTaskArtifactStateRepository(\n            startParameter,\n            instantiator,\n            new DefaultTaskArtifactStateRepository(\n                taskHistoryRepository,\n                instantiator,\n                outputFilesSnapshotter,\n                fileCollectionSnapshotter,\n                discoveredFileCollectionSnapshotter,\n                fileCollectionFactory\n            )\n        );\n    }","commit_id":"460b7944980e72f4c4f13b0c04c71e97e4feafb7","url":"https://github.com/gradle/gradle"},{"original_method":"public TaskUpToDateState(TaskInternal task, TaskHistoryRepository.History history, FileCollectionSnapshotter outputFilesSnapshotter, FileCollectionSnapshotter inputFilesSnapshotter, FileCollectionSnapshotter discoveredFilesSnapshotter) {\n        TaskExecution thisExecution = history.getCurrentExecution();\n        TaskExecution lastExecution = history.getPreviousExecution();\n\n        noHistoryState = NoHistoryStateChangeRule.create(task, lastExecution);\n        taskTypeState = TaskTypeStateChangeRule.create(task, lastExecution, thisExecution);\n        inputPropertiesState = InputPropertiesStateChangeRule.create(task, lastExecution, thisExecution);\n\n        // Capture outputs state\n        try {\n            outputFilesState = caching(OutputFilesStateChangeRule.create(task, lastExecution, thisExecution, outputFilesSnapshotter));\n        } catch (UncheckedIOException e) {\n            throw new UncheckedIOException(String.format(\"Failed to capture snapshot of output files for task '%s' during up-to-date check.\", task.getName()), e);\n        }\n\n        // Capture inputs state\n        try {\n            FileCollectionSnapshot inputFilesSnapshot = inputFilesSnapshotter.snapshot(task.getInputs().getFiles());\n            this.inputFilesSnapshot = inputFilesSnapshot.getSnapshot();\n            inputFilesState = caching(InputFilesStateChangeRule.create(lastExecution, thisExecution, inputFilesSnapshot));\n        } catch (UncheckedIOException e) {\n            throw new UncheckedIOException(String.format(\"Failed to capture snapshot of input files for task '%s' during up-to-date check.\", task.getName()), e);\n        }\n\n        // Capture discovered inputs state from previous execution\n        try {\n            discoveredInputFilesState = DiscoveredInputFilesStateChangeRule.create(lastExecution, thisExecution, discoveredFilesSnapshotter);\n        } catch (UncheckedIOException e) {\n            throw new UncheckedIOException(String.format(\"Failed to capture snapshot of input files for task '%s' during up-to-date check.\", task.getName()), e);\n        }\n\n        allTaskChanges = new SummaryTaskStateChanges(MAX_OUT_OF_DATE_MESSAGES, noHistoryState, taskTypeState, inputPropertiesState, outputFilesState, inputFilesState, caching(discoveredInputFilesState));\n        rebuildChanges = new SummaryTaskStateChanges(1, noHistoryState, taskTypeState, inputPropertiesState, outputFilesState);\n    }","id":73313,"modified_method":"public TaskUpToDateState(TaskInternal task, TaskHistoryRepository.History history, FileCollectionSnapshotter outputFilesSnapshotter, FileCollectionSnapshotter inputFilesSnapshotter, DiscoveredInputFilesStateChangeRule discoveredInputFilesStateChangeRule) {\n        TaskExecution thisExecution = history.getCurrentExecution();\n        TaskExecution lastExecution = history.getPreviousExecution();\n\n        TaskStateChanges noHistoryState = NoHistoryStateChangeRule.create(task, lastExecution);\n        TaskStateChanges taskTypeState = TaskTypeStateChangeRule.create(task, lastExecution, thisExecution);\n        TaskStateChanges inputPropertiesState = InputPropertiesStateChangeRule.create(task, lastExecution, thisExecution);\n\n        // Capture outputs state\n        TaskStateChanges outputFilesState;\n        try {\n            outputFilesState = caching(OutputFilesStateChangeRule.create(task, lastExecution, thisExecution, outputFilesSnapshotter));\n        } catch (UncheckedIOException e) {\n            throw new UncheckedIOException(String.format(\"Failed to capture snapshot of output files for task '%s' during up-to-date check.\", task.getName()), e);\n        }\n\n        // Capture inputs state\n        try {\n            FileCollectionSnapshot inputFilesSnapshot = inputFilesSnapshotter.snapshot(task.getInputs().getFiles());\n            this.inputFilesSnapshot = inputFilesSnapshot.getSnapshot();\n            inputFilesState = caching(InputFilesStateChangeRule.create(lastExecution, thisExecution, inputFilesSnapshot));\n        } catch (UncheckedIOException e) {\n            throw new UncheckedIOException(String.format(\"Failed to capture snapshot of input files for task '%s' during up-to-date check.\", task.getName()), e);\n        }\n\n        // Capture discovered inputs state from previous execution\n        try {\n            discoveredInputFilesState = discoveredInputFilesStateChangeRule.create(lastExecution, thisExecution);\n        } catch (UncheckedIOException e) {\n            throw new UncheckedIOException(String.format(\"Failed to capture snapshot of input files for task '%s' during up-to-date check.\", task.getName()), e);\n        }\n\n        allTaskChanges = new SummaryTaskStateChanges(MAX_OUT_OF_DATE_MESSAGES, noHistoryState, taskTypeState, inputPropertiesState, outputFilesState, inputFilesState, caching(discoveredInputFilesState));\n        rebuildChanges = new SummaryTaskStateChanges(1, noHistoryState, taskTypeState, inputPropertiesState, outputFilesState);\n    }","commit_id":"460b7944980e72f4c4f13b0c04c71e97e4feafb7","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n\tprotected BaseModel<?> addBaseModelWithWorkflow(\n\t\t\tBaseModel<?> parentBaseModel, boolean approved, String keywords,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tDLFolder dlFolder = (DLFolder)parentBaseModel;\n\n\t\tString content = \"Content: Enterprise. Open Source.\";\n\n\t\tFile file = FileUtil.createTempFile(content.getBytes());\n\n\t\tserviceContext = (ServiceContext)serviceContext.clone();\n\n\t\tserviceContext.setWorkflowAction(WorkflowConstants.ACTION_SAVE_DRAFT);\n\n\t\tif (approved) {\n\t\t\tserviceContext.setWorkflowAction(WorkflowConstants.ACTION_PUBLISH);\n\t\t}\n\n\t\tFileEntry fileEntry = DLAppServiceUtil.addFileEntry(\n\t\t\tdlFolder.getRepositoryId(), dlFolder.getFolderId(),\n\t\t\tServiceTestUtil.randomString() + \".txt\", ContentTypes.TEXT_PLAIN,\n\t\t\tkeywords, keywords, StringPool.BLANK, file, serviceContext);\n\n\t\tLiferayFileEntry liferayFileEntry = (LiferayFileEntry)fileEntry;\n\n\t\treturn liferayFileEntry.getDLFileEntry();\n\t}","id":73314,"modified_method":"@Override\n\tprotected BaseModel<?> addBaseModelWithWorkflow(\n\t\t\tBaseModel<?> parentBaseModel, boolean approved, String keywords,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tDLFolder dlFolder = (DLFolder)parentBaseModel;\n\n\t\tFileEntry fileEntry = DLAppTestUtil.addFileEntry(\n\t\t\tdlFolder.getGroupId(), dlFolder.getFolderId(), keywords + \".txt\",\n\t\t\tkeywords, approved);\n\n\t\treturn (DLFileEntry)fileEntry.getModel();\n\t}","commit_id":"be7555067bfa79e12a7e974d54f9d7d6e8bdf47d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected BaseModel<?> getParentBaseModel(\n\t\t\tGroup group, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\treturn DLFolderLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), group.getGroupId(), group.getGroupId(),\n\t\t\tfalse, DLFolderConstants.DEFAULT_PARENT_FOLDER_ID,\n\t\t\tServiceTestUtil.randomString(_FOLDER_NAME_MAX_LENGTH),\n\t\t\tStringPool.BLANK, false, serviceContext);\n\t}","id":73315,"modified_method":"@Override\n\tprotected BaseModel<?> getParentBaseModel(\n\t\t\tGroup group, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tFolder folder = DLAppTestUtil.addFolder(\n\t\t\tgroup.getGroupId(), DLFolderConstants.DEFAULT_PARENT_FOLDER_ID,\n\t\t\tServiceTestUtil.randomString(_FOLDER_NAME_MAX_LENGTH));\n\n\t\treturn (DLFolder)folder.getModel();\n\t}","commit_id":"be7555067bfa79e12a7e974d54f9d7d6e8bdf47d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected BaseModel<?> addBaseModelWithWorkflow(\n\t\t\tBaseModel<?> parentBaseModel, boolean approved,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tDLFolder dlFolder = (DLFolder)parentBaseModel;\n\n\t\tString title = getSearchKeywords();\n\n\t\ttitle += ServiceTestUtil.randomString(\n\t\t\t_FILE_ENTRY_TITLE_MAX_LENGTH - title.length());\n\n\t\tString content = \"Content: Enterprise. Open Source.\";\n\n\t\tFile file = FileUtil.createTempFile(content.getBytes());\n\n\t\tserviceContext = (ServiceContext)serviceContext.clone();\n\n\t\tserviceContext.setWorkflowAction(WorkflowConstants.ACTION_SAVE_DRAFT);\n\n\t\tif (approved) {\n\t\t\tserviceContext.setWorkflowAction(WorkflowConstants.ACTION_PUBLISH);\n\t\t}\n\n\t\tFileEntry fileEntry = DLAppServiceUtil.addFileEntry(\n\t\t\tdlFolder.getRepositoryId(), dlFolder.getFolderId(),\n\t\t\tServiceTestUtil.randomString() + \".txt\", ContentTypes.TEXT_PLAIN,\n\t\t\ttitle, StringPool.BLANK, StringPool.BLANK, file, serviceContext);\n\n\t\tLiferayFileEntry liferayFileEntry = (LiferayFileEntry)fileEntry;\n\n\t\treturn liferayFileEntry.getDLFileEntry();\n\t}","id":73316,"modified_method":"@Override\n\tprotected BaseModel<?> addBaseModelWithWorkflow(\n\t\t\tBaseModel<?> parentBaseModel, boolean approved,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tDLFolder dlFolder = (DLFolder)parentBaseModel;\n\n\t\tString title = getSearchKeywords();\n\n\t\ttitle += ServiceTestUtil.randomString(\n\t\t\t_FILE_ENTRY_TITLE_MAX_LENGTH - title.length());\n\n\t\tFileEntry fileEntry = DLAppTestUtil.addFileEntry(\n\t\t\tdlFolder.getGroupId(), dlFolder.getFolderId(),\n\t\t\tServiceTestUtil.randomString() + \".txt\", title, approved);\n\n\t\treturn (DLFileEntry)fileEntry.getModel();\n\t}","commit_id":"be7555067bfa79e12a7e974d54f9d7d6e8bdf47d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected BaseModel<?> getParentBaseModel(\n\t\t\tGroup group, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\treturn DLFolderLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), group.getGroupId(), group.getGroupId(),\n\t\t\tfalse, DLFolderConstants.DEFAULT_PARENT_FOLDER_ID,\n\t\t\tServiceTestUtil.randomString(_FOLDER_NAME_MAX_LENGTH),\n\t\t\tStringPool.BLANK, false, serviceContext);\n\t}","id":73317,"modified_method":"@Override\n\tprotected BaseModel<?> getParentBaseModel(\n\t\t\tGroup group, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tFolder folder = DLAppTestUtil.addFolder(\n\t\t\tgroup.getGroupId(), DLFolderConstants.DEFAULT_PARENT_FOLDER_ID,\n\t\t\tServiceTestUtil.randomString(_FOLDER_NAME_MAX_LENGTH));\n\n\t\treturn (DLFolder)folder.getModel();\n\t}","commit_id":"be7555067bfa79e12a7e974d54f9d7d6e8bdf47d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected BaseModel<?> addBaseModelWithWorkflow(\n\t\t\tBaseModel<?> parentBaseModel, boolean approved, String keywords,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tDLFolder parentDLFolder = (DLFolder)parentBaseModel;\n\n\t\tDLFolder dlFolder = DLFolderLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), parentDLFolder.getGroupId(),\n\t\t\tparentDLFolder.getGroupId(), false, parentDLFolder.getFolderId(),\n\t\t\tkeywords, keywords, false, serviceContext);\n\n\t\treturn dlFolder;\n\t}","id":73318,"modified_method":"@Override\n\tprotected BaseModel<?> addBaseModelWithWorkflow(\n\t\t\tBaseModel<?> parentBaseModel, boolean approved, String keywords,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tDLFolder parentDLFolder = (DLFolder)parentBaseModel;\n\n\t\tFolder folder = DLAppTestUtil.addFolder(\n\t\t\tparentDLFolder.getGroupId(), parentDLFolder.getFolderId(),\n\t\t\tkeywords);\n\n\t\treturn (DLFolder)folder.getModel();\n\t}","commit_id":"be7555067bfa79e12a7e974d54f9d7d6e8bdf47d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected BaseModel<?> getParentBaseModel(\n\t\t\tGroup group, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\treturn DLFolderLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), group.getGroupId(), group.getGroupId(),\n\t\t\tfalse, DLFolderConstants.DEFAULT_PARENT_FOLDER_ID,\n\t\t\tServiceTestUtil.randomString(_FOLDER_NAME_MAX_LENGTH),\n\t\t\tStringPool.BLANK, false, serviceContext);\n\t}","id":73319,"modified_method":"@Override\n\tprotected BaseModel<?> getParentBaseModel(\n\t\t\tGroup group, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tFolder folder = DLAppTestUtil.addFolder(\n\t\t\tgroup.getGroupId(), DLFolderConstants.DEFAULT_PARENT_FOLDER_ID,\n\t\t\tServiceTestUtil.randomString(_FOLDER_NAME_MAX_LENGTH));\n\n\t\treturn (DLFolder)folder.getModel();\n\t}","commit_id":"be7555067bfa79e12a7e974d54f9d7d6e8bdf47d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected BaseModel<?> addBaseModelWithWorkflow(\n\t\t\tBaseModel<?> parentBaseModel, boolean approved,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tDLFolder parentDLFolder = (DLFolder)parentBaseModel;\n\n\t\tString name = getSearchKeywords();\n\n\t\tname += ServiceTestUtil.randomString(\n\t\t\t_FOLDER_NAME_MAX_LENGTH - name.length());\n\n\t\tDLFolder dlFolder = DLFolderLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), parentDLFolder.getGroupId(),\n\t\t\tparentDLFolder.getGroupId(), false, parentDLFolder.getFolderId(),\n\t\t\tname, StringPool.BLANK, false, serviceContext);\n\n\t\treturn dlFolder;\n\t}","id":73320,"modified_method":"@Override\n\tprotected BaseModel<?> addBaseModelWithWorkflow(\n\t\t\tBaseModel<?> parentBaseModel, boolean approved,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tDLFolder parentDLFolder = (DLFolder)parentBaseModel;\n\n\t\tString name = getSearchKeywords();\n\n\t\tname += ServiceTestUtil.randomString(\n\t\t\t_FOLDER_NAME_MAX_LENGTH - name.length());\n\n\t\tFolder folder = DLAppTestUtil.addFolder(\n\t\t\tparentDLFolder.getGroupId(), parentDLFolder.getFolderId(), name);\n\n\t\treturn (DLFolder)folder.getModel();\n\t}","commit_id":"be7555067bfa79e12a7e974d54f9d7d6e8bdf47d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected BaseModel<?> getParentBaseModel(\n\t\t\tGroup group, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\treturn DLFolderLocalServiceUtil.addFolder(\n\t\t\tTestPropsValues.getUserId(), group.getGroupId(), group.getGroupId(),\n\t\t\tfalse, DLFolderConstants.DEFAULT_PARENT_FOLDER_ID,\n\t\t\tServiceTestUtil.randomString(), StringPool.BLANK, false,\n\t\t\tserviceContext);\n\t}","id":73321,"modified_method":"@Override\n\tprotected BaseModel<?> getParentBaseModel(\n\t\t\tGroup group, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tFolder folder = DLAppTestUtil.addFolder(\n\t\t\tgroup.getGroupId(), DLFolderConstants.DEFAULT_PARENT_FOLDER_ID,\n\t\t\tServiceTestUtil.randomString(_FOLDER_NAME_MAX_LENGTH));\n\n\t\treturn (DLFolder)folder.getModel();\n\t}","commit_id":"be7555067bfa79e12a7e974d54f9d7d6e8bdf47d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tDLFileEntryType fileEntryType)\n\t\tthrows Exception {\n\n\t\tString path = fileEntryTypeElement.attributeValue(\"path\");\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tDLFileEntryType dlFileEntryType =\n\t\t\t(DLFileEntryType)portletDataContext.getZipEntryAsObject(path);\n\n\t\tlong userId = portletDataContext.getUserId(\n\t\t\tdlFileEntryType.getUserUuid());\n\n\t\tString name = getFileEntryTypeName(\n\t\t\tdlFileEntryType.getUuid(), portletDataContext.getScopeGroupId(),\n\t\t\tdlFileEntryType.getName(), 2);\n\n\t\tList<Element> structureElements = fileEntryTypeElement.elements(\n\t\t\t\"structure\");\n\n\t\tfor (Element structureElement : structureElements) {\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, structureElement);\n\t\t}\n\n\t\tMap<Long, Long> ddmStructureIdsMap =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMStructure.class);\n\n\t\tCollection<Long> ddmStructureIdsCollection =\n\t\t\tddmStructureIdsMap.values();\n\n\t\tlong[] ddmStructureIds = ArrayUtil.toArray(\n\t\t\tddmStructureIdsCollection.toArray(\n\t\t\t\tnew Long[ddmStructureIdsMap.size()]));\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tpath, dlFileEntryType, NAMESPACE);\n\n\t\tDLFileEntryType importedDLFileEntryType = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tDLFileEntryType existingDLFileEntryType =\n\t\t\t\tDLFileEntryTypeUtil.fetchByUUID_G(\n\t\t\t\t\tdlFileEntryType.getUuid(),\n\t\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\t\tif (existingDLFileEntryType == null) {\n\t\t\t\tGroup companyGroup = GroupLocalServiceUtil.getCompanyGroup(\n\t\t\t\t\tportletDataContext.getCompanyId());\n\n\t\t\t\texistingDLFileEntryType = DLFileEntryTypeUtil.fetchByUUID_G(\n\t\t\t\t\tdlFileEntryType.getUuid(), companyGroup.getGroupId());\n\t\t\t}\n\n\t\t\tif (existingDLFileEntryType == null) {\n\t\t\t\tserviceContext.setUuid(dlFileEntryType.getUuid());\n\n\t\t\t\timportedDLFileEntryType =\n\t\t\t\t\tDLFileEntryTypeLocalServiceUtil.addFileEntryType(\n\t\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), name,\n\t\t\t\t\t\tdlFileEntryType.getDescription(), ddmStructureIds,\n\t\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!isFileEntryTypeGlobal(\n\t\t\t\t\t\tportletDataContext.getCompanyId(),\n\t\t\t\t\t\texistingDLFileEntryType)) {\n\n\t\t\t\t\tDLFileEntryTypeLocalServiceUtil.updateFileEntryType(\n\t\t\t\t\t\tuserId, existingDLFileEntryType.getFileEntryTypeId(),\n\t\t\t\t\t\tname, dlFileEntryType.getDescription(), ddmStructureIds,\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\n\t\t\t\timportedDLFileEntryType = existingDLFileEntryType;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedDLFileEntryType =\n\t\t\t\tDLFileEntryTypeLocalServiceUtil.addFileEntryType(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), name,\n\t\t\t\t\tdlFileEntryType.getDescription(), ddmStructureIds,\n\t\t\t\t\tserviceContext);\n\t\t}\n\n\t\tif (!isFileEntryTypeGlobal(\n\t\t\t\tportletDataContext.getCompanyId(), importedDLFileEntryType)) {\n\n\t\t\tportletDataContext.importClassedModel(\n\t\t\t\tdlFileEntryType, importedDLFileEntryType, NAMESPACE);\n\n\t\t\tString importedDLFileEntryDDMStructureKey =\n\t\t\t\tDLUtil.getDDMStructureKey(importedDLFileEntryType);\n\n\t\t\tList<DDMStructure> ddmStructures =\n\t\t\t\timportedDLFileEntryType.getDDMStructures();\n\n\t\t\tfor (DDMStructure ddmStructure : ddmStructures) {\n\t\t\t\tString ddmStructureKey = ddmStructure.getStructureKey();\n\n\t\t\t\tif (!DLUtil.isAutoGeneratedDLFileEntryTypeDDMStructureKey(\n\t\t\t\t\t\tddmStructureKey)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (ddmStructureKey.equals(\n\t\t\t\t\t\timportedDLFileEntryDDMStructureKey)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tddmStructure.setStructureKey(\n\t\t\t\t\timportedDLFileEntryDDMStructureKey);\n\n\t\t\t\tDDMStructureLocalServiceUtil.updateDDMStructure(ddmStructure);\n\t\t\t}\n\t\t}\n\t}","id":73322,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tDLFileEntryType fileEntryType)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(fileEntryType.getUserUuid());\n\n\t\tString name = getFileEntryTypeName(\n\t\t\tfileEntryType.getUuid(), portletDataContext.getScopeGroupId(),\n\t\t\tfileEntryType.getName(), 2);\n\n\t\tList<Element> referencedElements =\n\t\t\tportletDataContext.getReferencedDataElements(\n\t\t\t\tfileEntryType, DDMStructure.class);\n\n\t\tfor (Element referencedElement : referencedElements) {\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, referencedElement);\n\t\t}\n\n\t\tMap<Long, Long> ddmStructureIdsMap =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMStructure.class);\n\n\t\tCollection<Long> ddmStructureIdsCollection =\n\t\t\tddmStructureIdsMap.values();\n\n\t\tlong[] ddmStructureIds = ArrayUtil.toArray(\n\t\t\tddmStructureIdsCollection.toArray(\n\t\t\t\tnew Long[ddmStructureIdsMap.size()]));\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tfileEntryType, DLPortletDataHandler.NAMESPACE);\n\n\t\tDLFileEntryType importedDLFileEntryType = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tDLFileEntryType existingDLFileEntryType =\n\t\t\t\tDLFileEntryTypeUtil.fetchByUUID_G(\n\t\t\t\t\tfileEntryType.getUuid(),\n\t\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\t\tif (existingDLFileEntryType == null) {\n\t\t\t\tGroup companyGroup = GroupLocalServiceUtil.getCompanyGroup(\n\t\t\t\t\tportletDataContext.getCompanyId());\n\n\t\t\t\texistingDLFileEntryType = DLFileEntryTypeUtil.fetchByUUID_G(\n\t\t\t\t\tfileEntryType.getUuid(), companyGroup.getGroupId());\n\t\t\t}\n\n\t\t\tif (existingDLFileEntryType == null) {\n\t\t\t\tserviceContext.setUuid(fileEntryType.getUuid());\n\n\t\t\t\timportedDLFileEntryType =\n\t\t\t\t\tDLFileEntryTypeLocalServiceUtil.addFileEntryType(\n\t\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), name,\n\t\t\t\t\t\tfileEntryType.getDescription(), ddmStructureIds,\n\t\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!isFileEntryTypeGlobal(\n\t\t\t\t\t\tportletDataContext.getCompanyId(),\n\t\t\t\t\t\texistingDLFileEntryType)) {\n\n\t\t\t\t\tDLFileEntryTypeLocalServiceUtil.updateFileEntryType(\n\t\t\t\t\t\tuserId, existingDLFileEntryType.getFileEntryTypeId(),\n\t\t\t\t\t\tname, fileEntryType.getDescription(), ddmStructureIds,\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\n\t\t\t\timportedDLFileEntryType = existingDLFileEntryType;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedDLFileEntryType =\n\t\t\t\tDLFileEntryTypeLocalServiceUtil.addFileEntryType(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), name,\n\t\t\t\t\tfileEntryType.getDescription(), ddmStructureIds,\n\t\t\t\t\tserviceContext);\n\t\t}\n\n\t\tif (!isFileEntryTypeGlobal(\n\t\t\t\tportletDataContext.getCompanyId(), importedDLFileEntryType)) {\n\n\t\t\tportletDataContext.importClassedModel(\n\t\t\t\tfileEntryType, importedDLFileEntryType,\n\t\t\t\tDLPortletDataHandler.NAMESPACE);\n\n\t\t\tString importedDLFileEntryDDMStructureKey =\n\t\t\t\tDLUtil.getDDMStructureKey(importedDLFileEntryType);\n\n\t\t\tList<DDMStructure> ddmStructures =\n\t\t\t\timportedDLFileEntryType.getDDMStructures();\n\n\t\t\tfor (DDMStructure ddmStructure : ddmStructures) {\n\t\t\t\tString ddmStructureKey = ddmStructure.getStructureKey();\n\n\t\t\t\tif (!DLUtil.isAutoGeneratedDLFileEntryTypeDDMStructureKey(\n\t\t\t\t\t\tddmStructureKey)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (ddmStructureKey.equals(\n\t\t\t\t\t\timportedDLFileEntryDDMStructureKey)) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tddmStructure.setStructureKey(\n\t\t\t\t\timportedDLFileEntryDDMStructureKey);\n\n\t\t\t\tDDMStructureLocalServiceUtil.updateDDMStructure(ddmStructure);\n\t\t\t}\n\t\t}\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * @see com.liferay.portal.lar.PortletImporter#getAssetCategoryName(String,\n\t *      long, long, String, int)\n\t * @see com.liferay.portal.lar.PortletImporter#getAssetVocabularyName(\n\t *      String, long, String, int)\n\t */\n\tprotected static String getFileEntryTypeName(\n\t\t\tString uuid, long groupId, String name, int count)\n\t\tthrows Exception {\n\n\t\tDLFileEntryType dlFileEntryType = DLFileEntryTypeUtil.fetchByG_N(\n\t\t\tgroupId, name);\n\n\t\tif (dlFileEntryType == null) {\n\t\t\treturn name;\n\t\t}\n\n\t\tif (Validator.isNotNull(uuid) &&\n\t\t\tuuid.equals(dlFileEntryType.getUuid())) {\n\n\t\t\treturn name;\n\t\t}\n\n\t\tname = StringUtil.appendParentheticalSuffix(name, count);\n\n\t\treturn getFileEntryTypeName(uuid, groupId, name, ++count);\n\t}","id":73323,"modified_method":"/**\n\t * @see com.liferay.portal.lar.PortletImporter#getAssetCategoryName(String,\n\t *      long, long, String, int)\n\t * @see com.liferay.portal.lar.PortletImporter#getAssetVocabularyName(\n\t *      String, long, String, int)\n\t */\n\tprotected String getFileEntryTypeName(\n\t\t\tString uuid, long groupId, String name, int count)\n\t\tthrows Exception {\n\n\t\tDLFileEntryType dlFileEntryType = DLFileEntryTypeUtil.fetchByG_N(\n\t\t\tgroupId, name);\n\n\t\tif (dlFileEntryType == null) {\n\t\t\treturn name;\n\t\t}\n\n\t\tif (Validator.isNotNull(uuid) &&\n\t\t\tuuid.equals(dlFileEntryType.getUuid())) {\n\n\t\t\treturn name;\n\t\t}\n\n\t\tname = StringUtil.appendParentheticalSuffix(name, count);\n\n\t\treturn getFileEntryTypeName(uuid, groupId, name, ++count);\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tDLFileEntryType fileEntryType)\n\t\tthrows Exception {\n\n\t\tString path = getFileEntryTypePath(portletDataContext, dlFileEntryType);\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tElement fileEntryTypeElement = fileEntryTypesElement.addElement(\n\t\t\t\"file-entry-type\");\n\n\t\tList<DDMStructure> ddmStructures = dlFileEntryType.getDDMStructures();\n\n\t\tString[] ddmStructureUuids = new String[ddmStructures.size()];\n\n\t\tfor (int i = 0; i < ddmStructures.size(); i++) {\n\t\t\tDDMStructure ddmStructure = ddmStructures.get(i);\n\n\t\t\tddmStructureUuids[i] = ddmStructure.getUuid();\n\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, ddmStructure);\n\t\t}\n\n\t\tfileEntryTypeElement.addAttribute(\n\t\t\t\"structureUuids\", StringUtil.merge(ddmStructureUuids));\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tfileEntryTypeElement, path, dlFileEntryType, NAMESPACE);\n\t}","id":73324,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tDLFileEntryType fileEntryType)\n\t\tthrows Exception {\n\n\t\tElement fileEntryTypeElement =\n\t\t\tportletDataContext.getExportDataStagedModelElement(fileEntryType);\n\n\t\tList<DDMStructure> ddmStructures = fileEntryType.getDDMStructures();\n\n\t\tfor (DDMStructure ddmStructure : ddmStructures) {\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, ddmStructure);\n\n\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\tfileEntryTypeElement, ddmStructure);\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tfileEntryTypeElement,\n\t\t\tExportImportPathUtil.getModelPath(fileEntryType), fileEntryType,\n\t\t\tDLPortletDataHandler.NAMESPACE);\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DLFileRank fileRank)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(fileRank.getUserUuid());\n\n\t\tlong groupId = portletDataContext.getScopeGroupId();\n\n\t\tFileEntry fileEntry = FileEntryUtil.fetchByUUID_R(\n\t\t\tfileEntryUuid, groupId);\n\n\t\tif (fileEntry == null) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Unable to retrieve file \" + fileEntryUuid +\n\t\t\t\t\t\t\" to import file rank\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tlong fileEntryId = fileEntry.getFileEntryId();\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setCreateDate(fileRank.getCreateDate());\n\n\t\tDLAppLocalServiceUtil.updateFileRank(\n\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\tportletDataContext.getCompanyId(), userId, fileEntryId,\n\t\t\tserviceContext);\n\t}","id":73325,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DLFileRank fileRank)\n\t\tthrows Exception {\n\n\t\tString fileEntryPath = ExportImportPathUtil.getModelPath(\n\t\t\tportletDataContext, DLFileEntry.class.getName(),\n\t\t\tfileRank.getFileEntryId());\n\n\t\tDLFileEntry fileEntry =\n\t\t\t(DLFileEntry)portletDataContext.getZipEntryAsObject(fileEntryPath);\n\n\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\tportletDataContext, fileEntry);\n\n\t\tlong userId = portletDataContext.getUserId(fileRank.getUserUuid());\n\n\t\tMap<Long, Long> fileEntryIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDLFileEntry.class);\n\n\t\tlong fileEntryId = MapUtil.getLong(\n\t\t\tfileEntryIds, fileRank.getFileEntryId(), fileRank.getFileEntryId());\n\n\t\tif (DLFileEntryLocalServiceUtil.fetchDLFileEntry(fileEntryId) == null) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"Unable to retrieve file to import file rank\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setCreateDate(fileRank.getCreateDate());\n\n\t\tDLAppLocalServiceUtil.updateFileRank(\n\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\tportletDataContext.getCompanyId(), userId, fileEntryId,\n\t\t\tserviceContext);\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DLFileRank fileRank)\n\t\tthrows Exception {\n\n\t\tString path = getFileRankPath(portletDataContext, fileRank);\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tElement fileRankElement = fileRanksElement.addElement(\"file-rank\");\n\n\t\tFileEntry fileEntry = FileEntryUtil.fetchByPrimaryKey(\n\t\t\tfileRank.getFileEntryId());\n\n\t\tString fileEntryUuid = fileEntry.getUuid();\n\n\t\tfileRankElement.addAttribute(\"file-entry-uuid\", fileEntryUuid);\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tfileRankElement, path, fileRank, NAMESPACE);\n\t}","id":73326,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DLFileRank fileRank)\n\t\tthrows Exception {\n\n\t\tDLFileEntry fileEntry = DLFileEntryUtil.fetchByPrimaryKey(\n\t\t\tfileRank.getFileEntryId());\n\n\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\tportletDataContext, fileEntry);\n\n\t\tElement fileRankElement =\n\t\t\tportletDataContext.getExportDataStagedModelElement(fileRank);\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tfileRankElement, ExportImportPathUtil.getModelPath(fileRank),\n\t\t\tfileRank, DLPortletDataHandler.NAMESPACE);\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DLFileShortcut fileShortcut)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(fileShortcut.getUserUuid());\n\n\t\tMap<Long, Long> folderIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDLFolder.class);\n\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderIds, fileShortcut.getFolderId(), fileShortcut.getFolderId());\n\n\t\tlong groupId = portletDataContext.getScopeGroupId();\n\n\t\tif (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\tFolder folder = FolderUtil.findByPrimaryKey(folderId);\n\n\t\t\tgroupId = folder.getRepositoryId();\n\t\t}\n\n\t\tString fileEntryUuid = fileShortcutElement.attributeValue(\n\t\t\t\"file-entry-uuid\");\n\n\t\tFileEntry fileEntry = FileEntryUtil.fetchByUUID_R(\n\t\t\tfileEntryUuid, groupId);\n\n\t\tif (fileEntry == null) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Unable to fetch file entry {uuid=\" + fileEntryUuid +\n\t\t\t\t\t\t\", groupId=\" + groupId + \"}\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tlong fileEntryId = fileEntry.getFileEntryId();\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tfileShortcutElement, fileShortcut, NAMESPACE);\n\n\t\tDLFileShortcut importedFileShortcut = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tDLFileShortcut existingFileShortcut =\n\t\t\t\tDLFileShortcutUtil.fetchByUUID_G(\n\t\t\t\t\tfileShortcut.getUuid(),\n\t\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\t\tif (existingFileShortcut == null) {\n\t\t\t\tserviceContext.setUuid(fileShortcut.getUuid());\n\n\t\t\t\timportedFileShortcut = DLAppLocalServiceUtil.addFileShortcut(\n\t\t\t\t\tuserId, groupId, folderId, fileEntryId, serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedFileShortcut = DLAppLocalServiceUtil.updateFileShortcut(\n\t\t\t\t\tuserId, existingFileShortcut.getFileShortcutId(), folderId,\n\t\t\t\t\tfileEntryId, serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedFileShortcut = DLAppLocalServiceUtil.addFileShortcut(\n\t\t\t\tuserId, groupId, folderId, fileEntryId, serviceContext);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tfileShortcut, importedFileShortcut, NAMESPACE);\n\t}","id":73327,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DLFileShortcut fileShortcut)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(fileShortcut.getUserUuid());\n\n\t\tif (fileShortcut.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tString folderPath = ExportImportPathUtil.getModelPath(\n\t\t\t\tportletDataContext, Folder.class.getName(),\n\t\t\t\tfileShortcut.getFolderId());\n\n\t\t\tDLFolder dlFolder =\n\t\t\t\t(DLFolder)portletDataContext.getZipEntryAsObject(folderPath);\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, dlFolder);\n\t\t}\n\n\t\tMap<Long, Long> folderIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFolder.class);\n\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderIds, fileShortcut.getFolderId(), fileShortcut.getFolderId());\n\n\t\tString fileEntryPath = ExportImportPathUtil.getModelPath(\n\t\t\tportletDataContext, DLFileEntry.class.getName(),\n\t\t\tfileShortcut.getToFileEntryId());\n\n\t\tDLFileEntry dlFileEntry =\n\t\t\t(DLFileEntry)portletDataContext.getZipEntryAsObject(fileEntryPath);\n\n\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\tportletDataContext, dlFileEntry);\n\n\t\tlong groupId = portletDataContext.getScopeGroupId();\n\n\t\tif (folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\tFolder folder = FolderUtil.findByPrimaryKey(folderId);\n\n\t\t\tgroupId = folder.getRepositoryId();\n\t\t}\n\n\t\tElement fileShortcutElement =\n\t\t\tportletDataContext.getImportDataStagedModelElement(fileShortcut);\n\n\t\tString fileEntryUuid = fileShortcutElement.attributeValue(\n\t\t\t\"file-entry-uuid\");\n\n\t\tFileEntry fileEntry = FileEntryUtil.fetchByUUID_R(\n\t\t\tfileEntryUuid, groupId);\n\n\t\tif (fileEntry == null) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Unable to fetch file entry {uuid=\" + fileEntryUuid +\n\t\t\t\t\t\t\", groupId=\" + groupId + \"}\");\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tlong fileEntryId = fileEntry.getFileEntryId();\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tfileShortcut, DLPortletDataHandler.NAMESPACE);\n\n\t\tDLFileShortcut importedFileShortcut = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tDLFileShortcut existingFileShortcut =\n\t\t\t\tDLFileShortcutUtil.fetchByUUID_G(\n\t\t\t\t\tfileShortcut.getUuid(),\n\t\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\t\tif (existingFileShortcut == null) {\n\t\t\t\tserviceContext.setUuid(fileShortcut.getUuid());\n\n\t\t\t\timportedFileShortcut = DLAppLocalServiceUtil.addFileShortcut(\n\t\t\t\t\tuserId, groupId, folderId, fileEntryId, serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedFileShortcut = DLAppLocalServiceUtil.updateFileShortcut(\n\t\t\t\t\tuserId, existingFileShortcut.getFileShortcutId(), folderId,\n\t\t\t\t\tfileEntryId, serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedFileShortcut = DLAppLocalServiceUtil.addFileShortcut(\n\t\t\t\tuserId, groupId, folderId, fileEntryId, serviceContext);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tfileShortcut, importedFileShortcut, DLPortletDataHandler.NAMESPACE);\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DLFileShortcut fileShortcut)\n\t\tthrows Exception {\n\n\t\tif (!portletDataContext.isWithinDateRange(\n\t\t\t\tfileShortcut.getModifiedDate())) {\n\n\t\t\treturn;\n\t\t}\n\n\t\texportParentFolder(\n\t\t\tportletDataContext, fileEntryTypesElement, foldersElement,\n\t\t\trepositoriesElement, repositoryEntriesElement,\n\t\t\tfileShortcut.getFolderId());\n\n\t\tString path = getFileShortcutPath(portletDataContext, fileShortcut);\n\n\t\tif (portletDataContext.isPathNotProcessed(path)) {\n\t\t\tElement fileShortcutElement = fileShortcutsElement.addElement(\n\t\t\t\t\"file-shortcut\");\n\n\t\t\tFileEntry fileEntry = DLAppLocalServiceUtil.getFileEntry(\n\t\t\t\tfileShortcut.getToFileEntryId());\n\n\t\t\tString fileEntryUuid = fileEntry.getUuid();\n\n\t\t\tfileShortcutElement.addAttribute(\"file-entry-uuid\", fileEntryUuid);\n\n\t\t\tportletDataContext.addClassedModel(\n\t\t\t\tfileShortcutElement, path, fileShortcut, NAMESPACE);\n\t\t}\n\t}","id":73328,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DLFileShortcut fileShortcut)\n\t\tthrows Exception {\n\n\t\tif (fileShortcut.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, fileShortcut);\n\t\t}\n\n\t\tDLFileEntry fileEntry = DLFileEntryLocalServiceUtil.getDLFileEntry(\n\t\t\tfileShortcut.getToFileEntryId());\n\n\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\tportletDataContext, fileEntry);\n\n\t\tString fileEntryUuid = fileEntry.getUuid();\n\n\t\tElement fileShortcutElement =\n\t\t\tportletDataContext.getExportDataStagedModelElement(fileShortcut);\n\n\t\tfileShortcutElement.addAttribute(\"file-entry-uuid\", fileEntryUuid);\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tfileShortcutElement,\n\t\t\tExportImportPathUtil.getModelPath(fileShortcut), fileShortcut,\n\t\t\tDLPortletDataHandler.NAMESPACE);\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, FileEntry fileEntry)\n\t\tthrows Exception {\n\n\t\tif (checkDateRange &&\n\t\t\t!portletDataContext.isWithinDateRange(\n\t\t\t\tfileEntry.getModifiedDate())) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!fileEntry.isDefaultRepository()) {\n\t\t\tRepository repository = RepositoryUtil.findByPrimaryKey(\n\t\t\t\tfileEntry.getRepositoryId());\n\n\t\t\texportRepository(\n\t\t\t\tportletDataContext, repositoriesElement,\n\t\t\t\trepositoryEntriesElement, repository);\n\n\t\t\treturn;\n\t\t}\n\n\t\tFileVersion fileVersion = fileEntry.getFileVersion();\n\n\t\tif (!fileVersion.isApproved() && !fileVersion.isInTrash()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString path = getFileEntryPath(portletDataContext, fileEntry);\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tLiferayFileEntry liferayFileEntry = (LiferayFileEntry)fileEntry;\n\n\t\tliferayFileEntry.setCachedFileVersion(fileVersion);\n\n\t\tElement fileEntryElement = fileEntriesElement.addElement(\"file-entry\");\n\n\t\tif (foldersElement != null) {\n\t\t\texportParentFolder(\n\t\t\t\tportletDataContext, fileEntryTypesElement, foldersElement,\n\t\t\t\trepositoriesElement, repositoryEntriesElement,\n\t\t\t\tfileEntry.getFolderId());\n\t\t}\n\n\t\tif (!portletDataContext.isPerformDirectBinaryImport()) {\n\t\t\tInputStream is = null;\n\n\t\t\ttry {\n\t\t\t\tis = FileEntryUtil.getContentStream(fileEntry);\n\t\t\t}\n\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t}\n\n\t\t\tif (is == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"No file found for file entry \" +\n\t\t\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t\t}\n\n\t\t\t\tfileEntryElement.detach();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tString binPath = getFileEntryBinPath(\n\t\t\t\t\tportletDataContext, fileEntry);\n\n\t\t\t\tportletDataContext.addZipEntry(binPath, is);\n\n\t\t\t\tfileEntryElement.addAttribute(\"bin-path\", binPath);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tis.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t_log.error(ioe, ioe);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(NAMESPACE, \"ranks\")) {\n\t\t\tList<DLFileRank> fileRanks = DLFileRankUtil.findByFileEntryId(\n\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\tfor (DLFileRank fileRank : fileRanks) {\n\t\t\t\texportFileRank(portletDataContext, fileRanksElement, fileRank);\n\t\t\t}\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\tNAMESPACE, \"previews-and-thumbnails\")) {\n\n\t\t\tDLProcessorRegistryUtil.exportGeneratedFiles(\n\t\t\t\tportletDataContext, fileEntry, fileEntryElement);\n\t\t}\n\n\t\texportMetaData(\n\t\t\tportletDataContext, fileEntryTypesElement, fileEntryElement,\n\t\t\tfileEntry);\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tfileEntryElement, path, fileEntry, NAMESPACE);\n\t}","id":73329,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, FileEntry fileEntry)\n\t\tthrows Exception {\n\n\t\tElement fileEntryGroupElement =\n\t\t\tportletDataContext.getExportDataGroupElement(FileEntry.class);\n\n\t\tElement fileEntryElement = fileEntryGroupElement.addElement(\n\t\t\t\"staged-model\");\n\n\t\tString fileEntryPath = ExportImportPathUtil.getModelPath(\n\t\t\tfileEntry.getGroupId(), FileEntry.class.getName(),\n\t\t\tfileEntry.getFileEntryId());\n\n\t\tif (!fileEntry.isDefaultRepository()) {\n\t\t\tRepository repository = RepositoryUtil.findByPrimaryKey(\n\t\t\t\tfileEntry.getRepositoryId());\n\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, repository);\n\n\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\tfileEntryElement, repository);\n\t\t}\n\n\t\tFileVersion fileVersion = fileEntry.getFileVersion();\n\n\t\tif (!fileVersion.isApproved() && !fileVersion.isInTrash()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (fileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, fileEntry.getFolder());\n\t\t}\n\n\t\tLiferayFileEntry liferayFileEntry = (LiferayFileEntry)fileEntry;\n\n\t\tliferayFileEntry.setCachedFileVersion(fileVersion);\n\n\t\tif (!portletDataContext.isPerformDirectBinaryImport()) {\n\t\t\tInputStream is = null;\n\n\t\t\ttry {\n\t\t\t\tis = FileEntryUtil.getContentStream(fileEntry);\n\t\t\t}\n\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t}\n\n\t\t\tif (is == null) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"No file found for file entry \" +\n\t\t\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t\t}\n\n\t\t\t\tfileEntryElement.detach();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tString binPath = ExportImportPathUtil.getModelPath(\n\t\t\t\t\tfileEntry, fileEntry.getVersion());\n\n\t\t\t\tportletDataContext.addZipEntry(binPath, is);\n\n\t\t\t\tfileEntryElement.addAttribute(\"bin-path\", binPath);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tis.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t_log.error(ioe, ioe);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\tDLPortletDataHandler.NAMESPACE, \"ranks\")) {\n\n\t\t\tList<DLFileRank> fileRanks = DLFileRankUtil.findByFileEntryId(\n\t\t\t\tfileEntry.getFileEntryId());\n\n\t\t\tfor (DLFileRank fileRank : fileRanks) {\n\t\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\t\tportletDataContext, fileRank);\n\n\t\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\t\tfileEntryElement, fileRank);\n\t\t\t}\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\tDLPortletDataHandler.NAMESPACE, \"previews-and-thumbnails\")) {\n\n\t\t\tDLProcessorRegistryUtil.exportGeneratedFiles(\n\t\t\t\tportletDataContext, fileEntry, fileEntryElement);\n\t\t}\n\n\t\texportMetaData(portletDataContext, fileEntryElement, fileEntry);\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tfileEntryElement, fileEntryPath, fileEntry,\n\t\t\tDLPortletDataHandler.NAMESPACE);\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void exportMetaData(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tElement fileEntryTypesElement, Element fileEntryElement,\n\t\t\tFileEntry fileEntry)\n\t\tthrows Exception {\n\n\t\tif (!(fileEntry instanceof LiferayFileEntry)) {\n\t\t\treturn;\n\t\t}\n\n\t\tLiferayFileEntry liferayFileEntry = (LiferayFileEntry)fileEntry;\n\n\t\tDLFileEntry dlFileEntry = liferayFileEntry.getDLFileEntry();\n\n\t\tlong fileEntryTypeId = dlFileEntry.getFileEntryTypeId();\n\n\t\tDLFileEntryType dlFileEntryType =\n\t\t\tDLFileEntryTypeLocalServiceUtil.fetchFileEntryType(fileEntryTypeId);\n\n\t\tif (dlFileEntryType == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfileEntryElement.addAttribute(\n\t\t\t\"fileEntryTypeUuid\", dlFileEntryType.getUuid());\n\n\t\tif (!dlFileEntryType.isExportable()) {\n\t\t\treturn;\n\t\t}\n\n\t\texportFileEntryType(\n\t\t\tportletDataContext, fileEntryTypesElement, dlFileEntryType);\n\n\t\tList<DDMStructure> ddmStructures = dlFileEntryType.getDDMStructures();\n\n\t\tfor (DDMStructure ddmStructure : ddmStructures) {\n\t\t\tElement structureFields = fileEntryElement.addElement(\n\t\t\t\t\"structure-fields\");\n\n\t\t\tString path = getFileEntryFileEntryTypeStructureFieldsPath(\n\t\t\t\tportletDataContext, fileEntry, dlFileEntryType.getUuid(),\n\t\t\t\tddmStructure.getStructureId());\n\n\t\t\tstructureFields.addAttribute(\"path\", path);\n\n\t\t\tstructureFields.addAttribute(\n\t\t\t\t\"structureUuid\", ddmStructure.getUuid());\n\n\t\t\tFileVersion fileVersion = fileEntry.getFileVersion();\n\n\t\t\tDLFileEntryMetadata dlFileEntryMetadata =\n\t\t\t\tDLFileEntryMetadataLocalServiceUtil.getFileEntryMetadata(\n\t\t\t\t\tddmStructure.getStructureId(),\n\t\t\t\t\tfileVersion.getFileVersionId());\n\n\t\t\tFields fields = StorageEngineUtil.getFields(\n\t\t\t\tdlFileEntryMetadata.getDDMStorageId());\n\n\t\t\tportletDataContext.addZipEntry(path, fields);\n\t\t}\n\t}","id":73330,"modified_method":"protected void exportMetaData(\n\t\t\tPortletDataContext portletDataContext, Element fileEntryElement,\n\t\t\tFileEntry fileEntry)\n\t\tthrows Exception {\n\n\t\tLiferayFileEntry liferayFileEntry = (LiferayFileEntry)fileEntry;\n\n\t\tDLFileEntry dlFileEntry = liferayFileEntry.getDLFileEntry();\n\n\t\tlong fileEntryTypeId = dlFileEntry.getFileEntryTypeId();\n\n\t\tDLFileEntryType dlFileEntryType =\n\t\t\tDLFileEntryTypeLocalServiceUtil.fetchFileEntryType(fileEntryTypeId);\n\n\t\tif ((dlFileEntryType == null) || !dlFileEntryType.isExportable()) {\n\t\t\treturn;\n\t\t}\n\n\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\tportletDataContext, dlFileEntryType);\n\n\t\tList<DDMStructure> ddmStructures = dlFileEntryType.getDDMStructures();\n\n\t\tfor (DDMStructure ddmStructure : ddmStructures) {\n\t\t\tElement structureFields = fileEntryElement.addElement(\n\t\t\t\t\"structure-fields\");\n\n\t\t\tString path = ExportImportPathUtil.getModelPath(\n\t\t\t\tddmStructure, String.valueOf(ddmStructure.getStructureId()));\n\n\t\t\tstructureFields.addAttribute(\"path\", path);\n\n\t\t\tstructureFields.addAttribute(\n\t\t\t\t\"structureUuid\", ddmStructure.getUuid());\n\n\t\t\tFileVersion fileVersion = fileEntry.getFileVersion();\n\n\t\t\tDLFileEntryMetadata dlFileEntryMetadata =\n\t\t\t\tDLFileEntryMetadataLocalServiceUtil.getFileEntryMetadata(\n\t\t\t\t\tddmStructure.getStructureId(),\n\t\t\t\t\tfileVersion.getFileVersionId());\n\n\t\t\tFields fields = StorageEngineUtil.getFields(\n\t\t\t\tdlFileEntryMetadata.getDDMStorageId());\n\n\t\t\tportletDataContext.addZipEntry(path, fields);\n\t\t}\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, FileEntry fileEntry)\n\t\tthrows Exception {\n\n\t\tFileEntry fileEntry = (FileEntry)portletDataContext.getZipEntryAsObject(\n\t\t\tpath);\n\n\t\tlong userId = portletDataContext.getUserId(fileEntry.getUserUuid());\n\n\t\tMap<Long, Long> folderIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDLFolder.class);\n\n\t\tlong folderId = MapUtil.getLong(\n\t\t\t\tfolderIds, fileEntry.getFolderId(), fileEntry.getFolderId());\n\n\t\tlong[] assetCategoryIds = null;\n\t\tString[] assetTagNames = null;\n\n\t\tif (portletDataContext.getBooleanParameter(NAMESPACE, \"categories\")) {\n\t\t\tassetCategoryIds = portletDataContext.getAssetCategoryIds(\n\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = portletDataContext.getAssetTagNames(\n\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t}\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tfileEntryElement, fileEntry, NAMESPACE);\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"sourceFileName\", \"A.\" + fileEntry.getExtension());\n\t\tserviceContext.setUserId(userId);\n\n\t\tString binPath = fileEntryElement.attributeValue(\"bin-path\");\n\n\t\tInputStream is = null;\n\n\t\tif (Validator.isNull(binPath) &&\n\t\t\tportletDataContext.isPerformDirectBinaryImport()) {\n\n\t\t\ttry {\n\t\t\t\tis = FileEntryUtil.getContentStream(fileEntry);\n\t\t\t}\n\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tis = portletDataContext.getZipEntryAsInputStream(binPath);\n\t\t}\n\n\t\tif (is == null) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No file found for file entry \" +\n\t\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif ((folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == fileEntry.getFolderId())) {\n\n\t\t\tString folderPath = getImportFolderPath(\n\t\t\t\tportletDataContext, folderId);\n\n\t\t\tFolder folder = (Folder)portletDataContext.getZipEntryAsObject(\n\t\t\t\tfolderPath);\n\n\t\t\tDocument document = fileEntryElement.getDocument();\n\n\t\t\tElement rootElement = document.getRootElement();\n\n\t\t\tElement folderElement = (Element)rootElement.selectSingleNode(\n\t\t\t\t\"//folder[@path='\".concat(folderPath).concat(\"']\"));\n\n\t\t\timportFolder(portletDataContext, folderPath, folderElement, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderIds, fileEntry.getFolderId(), fileEntry.getFolderId());\n\t\t}\n\n\t\timportMetaData(portletDataContext, fileEntryElement, serviceContext);\n\n\t\tFileEntry importedFileEntry = null;\n\n\t\tString titleWithExtension = DLUtil.getTitleWithExtension(fileEntry);\n\t\tString extension = fileEntry.getExtension();\n\n\t\tString dotExtension = StringPool.PERIOD + extension;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tFileEntry existingFileEntry = FileEntryUtil.fetchByUUID_R(\n\t\t\t\tfileEntry.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tFileVersion fileVersion = fileEntry.getFileVersion();\n\n\t\t\tif (existingFileEntry == null) {\n\t\t\t\tString fileEntryTitle = fileEntry.getTitle();\n\n\t\t\t\tFileEntry existingTitleFileEntry = FileEntryUtil.fetchByR_F_T(\n\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\tfileEntryTitle);\n\n\t\t\t\tif (existingTitleFileEntry != null) {\n\t\t\t\t\tif ((fileEntry.getGroupId() ==\n\t\t\t\t\t\t\tportletDataContext.getSourceGroupId()) &&\n\t\t\t\t\t\tportletDataContext.\n\t\t\t\t\t\t\tisDataStrategyMirrorWithOverwriting()) {\n\n\t\t\t\t\t\tDLAppLocalServiceUtil.deleteFileEntry(\n\t\t\t\t\t\t\texistingTitleFileEntry.getFileEntryId());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tboolean titleHasExtension = false;\n\n\t\t\t\t\t\tif (fileEntryTitle.endsWith(dotExtension)) {\n\t\t\t\t\t\t\tfileEntryTitle = FileUtil.stripExtension(\n\t\t\t\t\t\t\t\tfileEntryTitle);\n\n\t\t\t\t\t\t\ttitleHasExtension = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int i = 1;; i++) {\n\t\t\t\t\t\t\tfileEntryTitle += StringPool.SPACE + i;\n\n\t\t\t\t\t\t\ttitleWithExtension = fileEntryTitle + dotExtension;\n\n\t\t\t\t\t\t\texistingTitleFileEntry = FileEntryUtil.fetchByR_F_T(\n\t\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\t\t\t\ttitleWithExtension);\n\n\t\t\t\t\t\t\tif (existingTitleFileEntry == null) {\n\t\t\t\t\t\t\t\tif (titleHasExtension) {\n\t\t\t\t\t\t\t\t\tfileEntryTitle += dotExtension;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tserviceContext.setAttribute(\n\t\t\t\t\t\"fileVersionUuid\", fileVersion.getUuid());\n\t\t\t\tserviceContext.setUuid(fileEntry.getUuid());\n\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitleWithExtension, fileEntry.getMimeType(), fileEntryTitle,\n\t\t\t\t\tfileEntry.getDescription(), null, is, fileEntry.getSize(),\n\t\t\t\t\tserviceContext);\n\n\t\t\t\tif (fileVersion.isInTrash()) {\n\t\t\t\t\timportedFileEntry = DLAppServiceUtil.moveFileEntryToTrash(\n\t\t\t\t\t\timportedFileEntry.getFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileVersion latestExistingFileVersion =\n\t\t\t\t\texistingFileEntry.getLatestFileVersion();\n\n\t\t\t\tboolean indexEnabled = serviceContext.isIndexingEnabled();\n\n\t\t\t\ttry {\n\t\t\t\t\tserviceContext.setIndexingEnabled(false);\n\n\t\t\t\t\tif (!fileVersion.getUuid().equals(\n\t\t\t\t\t\t\tlatestExistingFileVersion.getUuid())) {\n\n\t\t\t\t\t\tDLFileVersion alreadyExistingFileVersion =\n\t\t\t\t\t\t\tDLFileVersionLocalServiceUtil.\n\t\t\t\t\t\t\t\tgetFileVersionByUuidAndGroupId(\n\t\t\t\t\t\t\t\t\tfileVersion.getUuid(),\n\t\t\t\t\t\t\t\t\texistingFileEntry.getGroupId());\n\n\t\t\t\t\t\tif (alreadyExistingFileVersion != null) {\n\t\t\t\t\t\t\tserviceContext.setAttribute(\n\t\t\t\t\t\t\t\t\"existingDLFileVersionId\",\n\t\t\t\t\t\t\t\talreadyExistingFileVersion.getFileVersionId());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tserviceContext.setUuid(fileVersion.getUuid());\n\n\t\t\t\t\t\timportedFileEntry =\n\t\t\t\t\t\t\tDLAppLocalServiceUtil.updateFileEntry(\n\t\t\t\t\t\t\t\tuserId, existingFileEntry.getFileEntryId(),\n\t\t\t\t\t\t\t\tfileEntry.getTitle(), fileEntry.getMimeType(),\n\t\t\t\t\t\t\t\tfileEntry.getTitle(),\n\t\t\t\t\t\t\t\tfileEntry.getDescription(), null, false, is,\n\t\t\t\t\t\t\t\tfileEntry.getSize(), serviceContext);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tDLAppLocalServiceUtil.updateAsset(\n\t\t\t\t\t\t\tuserId, existingFileEntry,\n\t\t\t\t\t\t\tlatestExistingFileVersion, assetCategoryIds,\n\t\t\t\t\t\t\tassetTagNames, null);\n\n\t\t\t\t\t\timportedFileEntry = existingFileEntry;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (importedFileEntry.getFolderId() != folderId) {\n\t\t\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.moveFileEntry(\n\t\t\t\t\t\t\tuserId, importedFileEntry.getFileEntryId(),\n\t\t\t\t\t\t\tfolderId, serviceContext);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (importedFileEntry instanceof LiferayFileEntry) {\n\t\t\t\t\t\tLiferayFileEntry liferayFileEntry =\n\t\t\t\t\t\t\t(LiferayFileEntry)importedFileEntry;\n\n\t\t\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\t\t\tDLFileEntry.class);\n\n\t\t\t\t\t\tindexer.reindex(liferayFileEntry.getModel());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tserviceContext.setIndexingEnabled(indexEnabled);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitleWithExtension, fileEntry.getMimeType(),\n\t\t\t\t\tfileEntry.getTitle(), fileEntry.getDescription(), null, is,\n\t\t\t\t\tfileEntry.getSize(), serviceContext);\n\t\t\t}\n\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\tString title = fileEntry.getTitle();\n\n\t\t\t\tString[] titleParts = title.split(\"\\\\.\", 2);\n\n\t\t\t\ttitle = titleParts[0] + PwdGenerator.getPassword();\n\n\t\t\t\tif (titleParts.length > 1) {\n\t\t\t\t\ttitle += StringPool.PERIOD + titleParts[1];\n\t\t\t\t}\n\n\t\t\t\tif (!title.endsWith(dotExtension)) {\n\t\t\t\t\ttitle += dotExtension;\n\t\t\t\t}\n\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitle, fileEntry.getMimeType(), title,\n\t\t\t\t\tfileEntry.getDescription(), null, is, fileEntry.getSize(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\tNAMESPACE, \"previews-and-thumbnails\")) {\n\n\t\t\tDLProcessorRegistryUtil.importGeneratedFiles(\n\t\t\t\tportletDataContext, fileEntry, importedFileEntry,\n\t\t\t\tfileEntryElement);\n\t\t}\n\n\t\tMap<String, String> fileEntryTitles =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDLFileEntry.class.getName() + \".title\");\n\n\t\tfileEntryTitles.put(fileEntry.getTitle(), importedFileEntry.getTitle());\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tfileEntry, importedFileEntry, NAMESPACE);\n\t}","id":73331,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, FileEntry fileEntry)\n\t\tthrows Exception {\n\n\t\tString path = ExportImportPathUtil.getModelPath(\n\t\t\tportletDataContext, FileEntry.class.getName(),\n\t\t\tfileEntry.getFileEntryId());\n\n\t\tElement fileEntryElement =\n\t\t\tportletDataContext.getImportDataStagedModelElement(\n\t\t\t\tFileEntry.class.getSimpleName(), \"path\", path);\n\n\t\tElement referencesElement = fileEntryElement.element(\"references\");\n\n\t\tif (referencesElement != null) {\n\t\t\tList<Element> refElements = referencesElement.elements();\n\n\t\t\tfor (Element refElement : refElements) {\n\t\t\t\tString className = refElement.attributeValue(\"class-name\");\n\t\t\t\tString classPk = refElement.attributeValue(\"class-pk\");\n\n\t\t\t\tString refPath = ExportImportPathUtil.getModelPath(\n\t\t\t\t\tportletDataContext, className, Long.valueOf(classPk));\n\n\t\t\t\tStagedModel referencedStagedModel =\n\t\t\t\t\t(StagedModel)portletDataContext.getZipEntryAsObject(\n\t\t\t\t\t\trefPath);\n\n\t\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\t\tportletDataContext, referencedStagedModel);\n\t\t\t}\n\t\t}\n\n\t\tlong userId = portletDataContext.getUserId(fileEntry.getUserUuid());\n\n\t\tif ((fileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(fileEntry.getFolderId() == fileEntry.getFolderId())) {\n\n\t\t\tString folderPath = ExportImportPathUtil.getModelPath(\n\t\t\t\tportletDataContext, Folder.class.getName(),\n\t\t\t\tfileEntry.getFolderId());\n\n\t\t\tFolder folder = (Folder)portletDataContext.getZipEntryAsObject(\n\t\t\t\tfolderPath);\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, folder);\n\t\t}\n\n\t\tMap<Long, Long> folderIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFolder.class);\n\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderIds, fileEntry.getFolderId(), fileEntry.getFolderId());\n\n\t\tlong[] assetCategoryIds = null;\n\t\tString[] assetTagNames = null;\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\tDLPortletDataHandler.NAMESPACE, \"categories\")) {\n\n\t\t\tassetCategoryIds = portletDataContext.getAssetCategoryIds(\n\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\tDLPortletDataHandler.NAMESPACE, \"tags\")) {\n\n\t\t\tassetTagNames = portletDataContext.getAssetTagNames(\n\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t}\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tfileEntry, DLPortletDataHandler.NAMESPACE);\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"sourceFileName\", \"A.\" + fileEntry.getExtension());\n\t\tserviceContext.setUserId(userId);\n\n\t\tString binPath = fileEntryElement.attributeValue(\"bin-path\");\n\n\t\tInputStream is = null;\n\n\t\tif (Validator.isNull(binPath) &&\n\t\t\tportletDataContext.isPerformDirectBinaryImport()) {\n\n\t\t\ttry {\n\t\t\t\tis = FileEntryUtil.getContentStream(fileEntry);\n\t\t\t}\n\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tis = portletDataContext.getZipEntryAsInputStream(binPath);\n\t\t}\n\n\t\tif (is == null) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No file found for file entry \" +\n\t\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\timportMetaData(portletDataContext, fileEntryElement, serviceContext);\n\n\t\tFileEntry importedFileEntry = null;\n\n\t\tString titleWithExtension = DLUtil.getTitleWithExtension(fileEntry);\n\t\tString extension = fileEntry.getExtension();\n\n\t\tString dotExtension = StringPool.PERIOD + extension;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tFileEntry existingFileEntry = FileEntryUtil.fetchByUUID_R(\n\t\t\t\tfileEntry.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tFileVersion fileVersion = fileEntry.getFileVersion();\n\n\t\t\tif (existingFileEntry == null) {\n\t\t\t\tString fileEntryTitle = fileEntry.getTitle();\n\n\t\t\t\tFileEntry existingTitleFileEntry = FileEntryUtil.fetchByR_F_T(\n\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\tfileEntryTitle);\n\n\t\t\t\tif (existingTitleFileEntry != null) {\n\t\t\t\t\tif ((fileEntry.getGroupId() ==\n\t\t\t\t\t\t\tportletDataContext.getSourceGroupId()) &&\n\t\t\t\t\t\tportletDataContext.\n\t\t\t\t\t\t\tisDataStrategyMirrorWithOverwriting()) {\n\n\t\t\t\t\t\tDLAppLocalServiceUtil.deleteFileEntry(\n\t\t\t\t\t\t\texistingTitleFileEntry.getFileEntryId());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tboolean titleHasExtension = false;\n\n\t\t\t\t\t\tif (fileEntryTitle.endsWith(dotExtension)) {\n\t\t\t\t\t\t\tfileEntryTitle = FileUtil.stripExtension(\n\t\t\t\t\t\t\t\tfileEntryTitle);\n\n\t\t\t\t\t\t\ttitleHasExtension = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int i = 1;; i++) {\n\t\t\t\t\t\t\tfileEntryTitle += StringPool.SPACE + i;\n\n\t\t\t\t\t\t\ttitleWithExtension = fileEntryTitle + dotExtension;\n\n\t\t\t\t\t\t\texistingTitleFileEntry = FileEntryUtil.fetchByR_F_T(\n\t\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\t\t\t\ttitleWithExtension);\n\n\t\t\t\t\t\t\tif (existingTitleFileEntry == null) {\n\t\t\t\t\t\t\t\tif (titleHasExtension) {\n\t\t\t\t\t\t\t\t\tfileEntryTitle += dotExtension;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tserviceContext.setAttribute(\n\t\t\t\t\t\"fileVersionUuid\", fileVersion.getUuid());\n\t\t\t\tserviceContext.setUuid(fileEntry.getUuid());\n\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitleWithExtension, fileEntry.getMimeType(), fileEntryTitle,\n\t\t\t\t\tfileEntry.getDescription(), null, is, fileEntry.getSize(),\n\t\t\t\t\tserviceContext);\n\n\t\t\t\tif (fileVersion.isInTrash()) {\n\t\t\t\t\timportedFileEntry = DLAppServiceUtil.moveFileEntryToTrash(\n\t\t\t\t\t\timportedFileEntry.getFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileVersion latestExistingFileVersion =\n\t\t\t\t\texistingFileEntry.getLatestFileVersion();\n\n\t\t\t\tboolean indexEnabled = serviceContext.isIndexingEnabled();\n\n\t\t\t\ttry {\n\t\t\t\t\tserviceContext.setIndexingEnabled(false);\n\n\t\t\t\t\tif (!fileVersion.getUuid().equals(\n\t\t\t\t\t\t\tlatestExistingFileVersion.getUuid())) {\n\n\t\t\t\t\t\tDLFileVersion alreadyExistingFileVersion =\n\t\t\t\t\t\t\tDLFileVersionLocalServiceUtil.\n\t\t\t\t\t\t\t\tgetFileVersionByUuidAndGroupId(\n\t\t\t\t\t\t\t\t\tfileVersion.getUuid(),\n\t\t\t\t\t\t\t\t\texistingFileEntry.getGroupId());\n\n\t\t\t\t\t\tif (alreadyExistingFileVersion != null) {\n\t\t\t\t\t\t\tserviceContext.setAttribute(\n\t\t\t\t\t\t\t\t\"existingDLFileVersionId\",\n\t\t\t\t\t\t\t\talreadyExistingFileVersion.getFileVersionId());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tserviceContext.setUuid(fileVersion.getUuid());\n\n\t\t\t\t\t\timportedFileEntry =\n\t\t\t\t\t\t\tDLAppLocalServiceUtil.updateFileEntry(\n\t\t\t\t\t\t\t\tuserId, existingFileEntry.getFileEntryId(),\n\t\t\t\t\t\t\t\tfileEntry.getTitle(), fileEntry.getMimeType(),\n\t\t\t\t\t\t\t\tfileEntry.getTitle(),\n\t\t\t\t\t\t\t\tfileEntry.getDescription(), null, false, is,\n\t\t\t\t\t\t\t\tfileEntry.getSize(), serviceContext);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tDLAppLocalServiceUtil.updateAsset(\n\t\t\t\t\t\t\tuserId, existingFileEntry,\n\t\t\t\t\t\t\tlatestExistingFileVersion, assetCategoryIds,\n\t\t\t\t\t\t\tassetTagNames, null);\n\n\t\t\t\t\t\timportedFileEntry = existingFileEntry;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (importedFileEntry.getFolderId() != folderId) {\n\t\t\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.moveFileEntry(\n\t\t\t\t\t\t\tuserId, importedFileEntry.getFileEntryId(),\n\t\t\t\t\t\t\tfolderId, serviceContext);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (importedFileEntry instanceof LiferayFileEntry) {\n\t\t\t\t\t\tLiferayFileEntry liferayFileEntry =\n\t\t\t\t\t\t\t(LiferayFileEntry)importedFileEntry;\n\n\t\t\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\t\t\tDLFileEntry.class);\n\n\t\t\t\t\t\tindexer.reindex(liferayFileEntry.getModel());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tserviceContext.setIndexingEnabled(indexEnabled);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitleWithExtension, fileEntry.getMimeType(),\n\t\t\t\t\tfileEntry.getTitle(), fileEntry.getDescription(), null, is,\n\t\t\t\t\tfileEntry.getSize(), serviceContext);\n\t\t\t}\n\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\tString title = fileEntry.getTitle();\n\n\t\t\t\tString[] titleParts = title.split(\"\\\\.\", 2);\n\n\t\t\t\ttitle = titleParts[0] + PwdGenerator.getPassword();\n\n\t\t\t\tif (titleParts.length > 1) {\n\t\t\t\t\ttitle += StringPool.PERIOD + titleParts[1];\n\t\t\t\t}\n\n\t\t\t\tif (!title.endsWith(dotExtension)) {\n\t\t\t\t\ttitle += dotExtension;\n\t\t\t\t}\n\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitle, fileEntry.getMimeType(), title,\n\t\t\t\t\tfileEntry.getDescription(), null, is, fileEntry.getSize(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\tDLPortletDataHandler.NAMESPACE, \"previews-and-thumbnails\")) {\n\n\t\t\tDLProcessorRegistryUtil.importGeneratedFiles(\n\t\t\t\tportletDataContext, fileEntry, importedFileEntry,\n\t\t\t\tfileEntryElement);\n\t\t}\n\n\t\tMap<String, String> fileEntryTitles =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDLFileEntry.class.getName() + \".title\");\n\n\t\tfileEntryTitles.put(fileEntry.getTitle(), importedFileEntry.getTitle());\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tfileEntry, importedFileEntry, DLPortletDataHandler.NAMESPACE);\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void importMetaData(\n\t\t\tPortletDataContext portletDataContext, Element fileEntryElement,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tString fileEntryTypeUuid = fileEntryElement.attributeValue(\n\t\t\t\"fileEntryTypeUuid\");\n\n\t\tif (Validator.isNull(fileEntryTypeUuid)) {\n\t\t\treturn;\n\t\t}\n\n\t\tDLFileEntryType dlFileEntryType = DLFileEntryTypeUtil.fetchByUUID_G(\n\t\t\tfileEntryTypeUuid, portletDataContext.getScopeGroupId());\n\n\t\tif (dlFileEntryType == null) {\n\t\t\tGroup group = GroupLocalServiceUtil.getCompanyGroup(\n\t\t\t\tportletDataContext.getCompanyId());\n\n\t\t\tdlFileEntryType = DLFileEntryTypeUtil.fetchByUUID_G(\n\t\t\t\tfileEntryTypeUuid, group.getGroupId());\n\n\t\t\tif (dlFileEntryType == null) {\n\t\t\t\tserviceContext.setAttribute(\"fileEntryTypeId\", -1);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"fileEntryTypeId\", dlFileEntryType.getFileEntryTypeId());\n\n\t\tList<DDMStructure> ddmStructures = dlFileEntryType.getDDMStructures();\n\n\t\tfor (DDMStructure ddmStructure : ddmStructures) {\n\t\t\tElement structureFieldsElement =\n\t\t\t\t(Element)fileEntryElement.selectSingleNode(\n\t\t\t\t\t\"structure-fields[@structureUuid='\".concat(\n\t\t\t\t\t\tddmStructure.getUuid()).concat(\"']\"));\n\n\t\t\tif (structureFieldsElement == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString path = structureFieldsElement.attributeValue(\"path\");\n\n\t\t\tFields fields = (Fields)portletDataContext.getZipEntryAsObject(\n\t\t\t\tpath);\n\n\t\t\tserviceContext.setAttribute(\n\t\t\t\tFields.class.getName() + ddmStructure.getStructureId(), fields);\n\t\t}\n\t}","id":73332,"modified_method":"protected void importMetaData(\n\t\t\tPortletDataContext portletDataContext, Element fileEntryElement,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tString fileEntryTypeUuid = fileEntryElement.attributeValue(\n\t\t\t\"fileEntryTypeUuid\");\n\n\t\tif (Validator.isNull(fileEntryTypeUuid)) {\n\t\t\treturn;\n\t\t}\n\n\t\tDLFileEntryType dlFileEntryType = DLFileEntryTypeUtil.fetchByUUID_G(\n\t\t\tfileEntryTypeUuid, portletDataContext.getScopeGroupId());\n\n\t\tif (dlFileEntryType == null) {\n\t\t\tGroup group = GroupLocalServiceUtil.getCompanyGroup(\n\t\t\t\tportletDataContext.getCompanyId());\n\n\t\t\tdlFileEntryType = DLFileEntryTypeUtil.fetchByUUID_G(\n\t\t\t\tfileEntryTypeUuid, group.getGroupId());\n\n\t\t\tif (dlFileEntryType == null) {\n\t\t\t\tserviceContext.setAttribute(\"fileEntryTypeId\", -1);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"fileEntryTypeId\", dlFileEntryType.getFileEntryTypeId());\n\n\t\tList<DDMStructure> ddmStructures = dlFileEntryType.getDDMStructures();\n\n\t\tfor (DDMStructure ddmStructure : ddmStructures) {\n\t\t\tElement structureFieldsElement =\n\t\t\t\t(Element)fileEntryElement.selectSingleNode(\n\t\t\t\t\t\"structure-fields[@structureUuid='\".concat(\n\t\t\t\t\t\tddmStructure.getUuid()).concat(\"']\"));\n\n\t\t\tif (structureFieldsElement == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString path = structureFieldsElement.attributeValue(\"path\");\n\n\t\t\tFields fields = (Fields)portletDataContext.getZipEntryAsObject(\n\t\t\t\tpath);\n\n\t\t\tserviceContext.setAttribute(\n\t\t\t\tFields.class.getName() + ddmStructure.getStructureId(), fields);\n\t\t}\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * @see com.liferay.portal.lar.PortletImporter#getAssetCategoryName(String,\n\t *      long, long, String, int)\n\t * @see com.liferay.portal.lar.PortletImporter#getAssetVocabularyName(\n\t *      String, long, String, int)\n\t */\n\tprotected static String getFolderName(\n\t\t\tString uuid, long groupId, long parentFolderId, String name,\n\t\t\tint count)\n\t\tthrows Exception {\n\n\t\tFolder folder = FolderUtil.fetchByR_P_N(groupId, parentFolderId, name);\n\n\t\tif (folder == null) {\n\t\t\treturn name;\n\t\t}\n\n\t\tif (Validator.isNotNull(uuid) && uuid.equals(folder.getUuid())) {\n\t\t\treturn name;\n\t\t}\n\n\t\tname = StringUtil.appendParentheticalSuffix(name, count);\n\n\t\treturn getFolderName(uuid, groupId, parentFolderId, name, ++count);\n\t}","id":73333,"modified_method":"/**\n\t * @see com.liferay.portal.lar.PortletImporter#getAssetCategoryName(String,\n\t *      long, long, String, int)\n\t * @see com.liferay.portal.lar.PortletImporter#getAssetVocabularyName(\n\t *      String, long, String, int)\n\t */\n\tprotected String getFolderName(\n\t\t\tString uuid, long groupId, long parentFolderId, String name,\n\t\t\tint count)\n\t\tthrows Exception {\n\n\t\tFolder folder = FolderUtil.fetchByR_P_N(groupId, parentFolderId, name);\n\n\t\tif (folder == null) {\n\t\t\treturn name;\n\t\t}\n\n\t\tif (Validator.isNotNull(uuid) && uuid.equals(folder.getUuid())) {\n\t\t\treturn name;\n\t\t}\n\n\t\tname = StringUtil.appendParentheticalSuffix(name, count);\n\n\t\treturn getFolderName(uuid, groupId, parentFolderId, name, ++count);\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void exportFolderFileEntryTypes(\n\t\t\tPortletDataContext portletDataContext, Folder folder,\n\t\t\tElement fileEntryTypesElement, Element folderElement)\n\t\tthrows Exception {\n\n\t\tList<DLFileEntryType> dlFileEntryTypes =\n\t\t\tDLFileEntryTypeLocalServiceUtil.getFolderFileEntryTypes(\n\t\t\t\tnew long[] {portletDataContext.getScopeGroupId()},\n\t\t\t\tfolder.getFolderId(), false);\n\n\t\tString[] fileEntryTypeUuids = new String[dlFileEntryTypes.size()];\n\n\t\tlong defaultFileEntryTypeId =\n\t\t\tDLFileEntryTypeLocalServiceUtil.getDefaultFileEntryTypeId(\n\t\t\t\tfolder.getFolderId());\n\n\t\tString defaultFileEntryTypeUuid = StringPool.BLANK;\n\n\t\tfor (int i = 0; i < dlFileEntryTypes.size(); i++) {\n\t\t\tDLFileEntryType dlFileEntryType = dlFileEntryTypes.get(i);\n\n\t\t\tif (dlFileEntryType.getFileEntryTypeId() ==\n\t\t\t\t\tDLFileEntryTypeConstants.\n\t\t\t\t\t\tFILE_ENTRY_TYPE_ID_BASIC_DOCUMENT) {\n\n\t\t\t\tfileEntryTypeUuids[i] = \"@basic_document@\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfileEntryTypeUuids[i] = dlFileEntryType.getUuid();\n\t\t\t}\n\n\t\t\tif (defaultFileEntryTypeId ==\n\t\t\t\t\tdlFileEntryType.getFileEntryTypeId()) {\n\n\t\t\t\tdefaultFileEntryTypeUuid = dlFileEntryType.getUuid();\n\t\t\t}\n\n\t\t\tif (dlFileEntryType.isExportable()) {\n\t\t\t\texportFileEntryType(\n\t\t\t\t\tportletDataContext, fileEntryTypesElement, dlFileEntryType);\n\t\t\t}\n\t\t}\n\n\t\tfolderElement.addAttribute(\n\t\t\t\"fileEntryTypeUuids\", StringUtil.merge(fileEntryTypeUuids));\n\t\tfolderElement.addAttribute(\n\t\t\t\"defaultFileEntryTypeUuid\", defaultFileEntryTypeUuid);\n\t}","id":73334,"modified_method":"protected void exportFolderFileEntryTypes(\n\t\t\tPortletDataContext portletDataContext, Folder folder,\n\t\t\tElement folderElement)\n\t\tthrows Exception {\n\n\t\tList<DLFileEntryType> dlFileEntryTypes =\n\t\t\tDLFileEntryTypeLocalServiceUtil.getFolderFileEntryTypes(\n\t\t\t\tnew long[]{portletDataContext.getScopeGroupId()},\n\t\t\t\tfolder.getFolderId(), false);\n\n\t\tlong defaultFileEntryTypeId =\n\t\t\tDLFileEntryTypeLocalServiceUtil.getDefaultFileEntryTypeId(\n\t\t\t\tfolder.getFolderId());\n\n\t\tString defaultFileEntryTypeUuid = StringPool.BLANK;\n\n\t\tfor (DLFileEntryType dlFileEntryType : dlFileEntryTypes) {\n\n\t\t\tif (dlFileEntryType.getFileEntryTypeId() ==\n\t\t\t\t\tDLFileEntryTypeConstants.\n\t\t\t\t\t\tFILE_ENTRY_TYPE_ID_BASIC_DOCUMENT) {\n\n\t\t\t\tfolderElement.addAttribute(\"basic-document\", \"true\");\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (defaultFileEntryTypeId ==\n\t\t\t\t\tdlFileEntryType.getFileEntryTypeId()) {\n\n\t\t\t\tdefaultFileEntryTypeUuid = dlFileEntryType.getUuid();\n\t\t\t}\n\n\t\t\tif (dlFileEntryType.isExportable()) {\n\t\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\t\tportletDataContext, dlFileEntryType);\n\n\t\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\t\tfolderElement, dlFileEntryType);\n\t\t\t}\n\t\t}\n\n\t\tfolderElement.addAttribute(\n\t\t\t\"defaultFileEntryTypeUuid\", defaultFileEntryTypeUuid);\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Folder folder)\n\t\tthrows Exception {\n\n\t\tif (!portletDataContext.isWithinDateRange(folder.getLastPostDate())) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (folder.isMountPoint()) {\n\t\t\tRepository repository = RepositoryUtil.findByPrimaryKey(\n\t\t\t\tfolder.getRepositoryId());\n\n\t\t\texportRepository(\n\t\t\t\tportletDataContext, repositoriesElement,\n\t\t\t\trepositoryEntriesElement, repository);\n\n\t\t\treturn;\n\t\t}\n\t\telse if (!folder.isDefaultRepository()) {\n\n\t\t\t// No need to export non-Liferay repository items since they would\n\t\t\t// be exported as part of repository export\n\n\t\t\treturn;\n\t\t}\n\n\t\texportParentFolder(\n\t\t\tportletDataContext, fileEntryTypesElement, foldersElement,\n\t\t\trepositoriesElement, repositoryEntriesElement,\n\t\t\tfolder.getParentFolderId());\n\n\t\tString path = getFolderPath(portletDataContext, folder);\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tElement folderElement = foldersElement.addElement(\"folder\");\n\n\t\texportFolderFileEntryTypes(\n\t\t\tportletDataContext, folder, fileEntryTypesElement, folderElement);\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tfolderElement, path, folder, NAMESPACE);\n\n\t\tif (recurse) {\n\t\t\tList<Folder> folders = FolderUtil.findByR_P(\n\t\t\t\tfolder.getRepositoryId(), folder.getFolderId());\n\n\t\t\tfor (Folder curFolder : folders) {\n\t\t\t\texportFolder(\n\t\t\t\t\tportletDataContext, fileEntryTypesElement, foldersElement,\n\t\t\t\t\tfileEntriesElement, fileShortcutsElement, fileRanksElement,\n\t\t\t\t\trepositoriesElement, repositoryEntriesElement, curFolder,\n\t\t\t\t\trecurse);\n\t\t\t}\n\t\t}\n\n\t\tList<FileEntry> fileEntries = FileEntryUtil.findByR_F(\n\t\t\tfolder.getRepositoryId(), folder.getFolderId());\n\n\t\tfor (FileEntry fileEntry : fileEntries) {\n\t\t\texportFileEntry(\n\t\t\t\tportletDataContext, fileEntryTypesElement, foldersElement,\n\t\t\t\tfileEntriesElement, fileRanksElement, repositoriesElement,\n\t\t\t\trepositoryEntriesElement, fileEntry, true);\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(NAMESPACE, \"shortcuts\")) {\n\t\t\tList<DLFileShortcut> fileShortcuts = DLFileShortcutUtil.findByG_F_A(\n\t\t\t\tfolder.getRepositoryId(), folder.getFolderId(), true);\n\n\t\t\tfor (DLFileShortcut fileShortcut : fileShortcuts) {\n\t\t\t\texportFileShortcut(\n\t\t\t\t\tportletDataContext, fileEntryTypesElement, foldersElement,\n\t\t\t\t\tfileShortcutsElement, repositoriesElement,\n\t\t\t\t\trepositoryEntriesElement, fileShortcut);\n\t\t\t}\n\t\t}\n\t}","id":73335,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Folder folder)\n\t\tthrows Exception {\n\n\t\tElement folderGroupElement =\n\t\t\tportletDataContext.getExportDataGroupElement(Folder.class);\n\n\t\tElement folderElement = folderGroupElement.addElement(\"staged-model\");\n\n\t\tString folderPath = ExportImportPathUtil.getModelPath(\n\t\t\tfolder.getGroupId(), Folder.class.getName(), folder.getFolderId());\n\n\t\tif (folder.isMountPoint()) {\n\t\t\tRepository repository = RepositoryUtil.findByPrimaryKey(\n\t\t\t\tfolder.getRepositoryId());\n\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, repository);\n\n\t\t\tportletDataContext.addReferenceElement(folderElement, repository);\n\t\t}\n\t\telse if (!folder.isDefaultRepository()) {\n\n\t\t\t// No need to export non-Liferay repository items since they would\n\t\t\t// be exported as part of repository export\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (folder.getParentFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, folder.getParentFolder());\n\t\t}\n\n\t\texportFolderFileEntryTypes(portletDataContext, folder, folderElement);\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tfolderElement, folderPath, folder, DLPortletDataHandler.NAMESPACE);\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void importFolderFileEntryTypes(\n\t\t\tPortletDataContext portletDataContext, Element folderElement,\n\t\t\tFolder folder, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tString[] fileEntryTypeUuids = StringUtil.split(\n\t\t\tfolderElement.attributeValue(\"fileEntryTypeUuids\"));\n\n\t\tList<Long> fileEntryTypeIds = new ArrayList<Long>();\n\n\t\tString defaultFileEntryTypeUuid = GetterUtil.getString(\n\t\t\tfolderElement.attributeValue(\"defaultFileEntryTypeUuid\"));\n\n\t\tlong defaultFileEntryTypeId = 0;\n\n\t\tfor (String fileEntryTypeUuid : fileEntryTypeUuids) {\n\t\t\tDLFileEntryType dlFileEntryType = DLFileEntryTypeUtil.fetchByUUID_G(\n\t\t\t\tfileEntryTypeUuid, portletDataContext.getScopeGroupId());\n\n\t\t\tif (dlFileEntryType == null) {\n\t\t\t\tGroup companyGroup = GroupLocalServiceUtil.getCompanyGroup(\n\t\t\t\t\tportletDataContext.getCompanyId());\n\n\t\t\t\tdlFileEntryType = DLFileEntryTypeUtil.fetchByUUID_G(\n\t\t\t\t\tfileEntryTypeUuid, companyGroup.getGroupId());\n\t\t\t}\n\n\t\t\tif ((dlFileEntryType == null) &&\n\t\t\t\tfileEntryTypeUuid.equals(\"@basic_document@\")) {\n\n\t\t\t\tdlFileEntryType =\n\t\t\t\t\tDLFileEntryTypeLocalServiceUtil.fetchDLFileEntryType(0);\n\t\t\t}\n\n\t\t\tif (dlFileEntryType == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfileEntryTypeIds.add(dlFileEntryType.getFileEntryTypeId());\n\n\t\t\tif (defaultFileEntryTypeUuid.equals(dlFileEntryType.getUuid())) {\n\t\t\t\tdefaultFileEntryTypeId = dlFileEntryType.getFileEntryTypeId();\n\t\t\t}\n\t\t}\n\n\t\tif (!fileEntryTypeIds.isEmpty()) {\n\t\t\tDLFolder dlFolder = (DLFolder)folder.getModel();\n\n\t\t\tdlFolder.setDefaultFileEntryTypeId(defaultFileEntryTypeId);\n\t\t\tdlFolder.setOverrideFileEntryTypes(true);\n\n\t\t\tDLFolderLocalServiceUtil.updateDLFolder(dlFolder);\n\n\t\t\tDLFileEntryTypeLocalServiceUtil.updateFolderFileEntryTypes(\n\t\t\t\tdlFolder, fileEntryTypeIds, defaultFileEntryTypeId,\n\t\t\t\tserviceContext);\n\t\t}\n\t}","id":73336,"modified_method":"protected void importFolderFileEntryTypes(\n\t\t\tPortletDataContext portletDataContext, Element folderElement,\n\t\t\tFolder folder, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tList<Long> fileEntryTypeIds = new ArrayList<Long>();\n\n\t\tString defaultFileEntryTypeUuid = GetterUtil.getString(\n\t\t\tfolderElement.attributeValue(\"defaultFileEntryTypeUuid\"));\n\n\t\tlong defaultFileEntryTypeId = 0;\n\n\t\tElement referencesElement = folderElement.element(\"references\");\n\n\t\tif (referencesElement == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tList<Element> referencedElements = referencesElement.elements();\n\n\t\tfor (Element referencedElement : referencedElements) {\n\t\t\tString className = referencedElement.attributeValue(\"class-name\");\n\n\t\t\tif (!className.equals(DLFileEntryType.class.getSimpleName())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString referencedPath = referencedElement.attributeValue(\"path\");\n\n\t\t\tDLFileEntryType referencedFileEntryType =\n\t\t\t\t(DLFileEntryType)portletDataContext.getZipEntryAsObject(\n\t\t\t\t\treferencedPath);\n\n\t\t\tString fileEntryTypeUuid = referencedFileEntryType.getUuid();\n\n\t\t\tDLFileEntryType dlFileEntryType = DLFileEntryTypeUtil.fetchByUUID_G(\n\t\t\t\tfileEntryTypeUuid, portletDataContext.getScopeGroupId());\n\n\t\t\tif (dlFileEntryType == null) {\n\t\t\t\tGroup companyGroup = GroupLocalServiceUtil.getCompanyGroup(\n\t\t\t\t\tportletDataContext.getCompanyId());\n\n\t\t\t\tdlFileEntryType = DLFileEntryTypeUtil.fetchByUUID_G(\n\t\t\t\t\tfileEntryTypeUuid, companyGroup.getGroupId());\n\t\t\t}\n\n\t\t\tif (dlFileEntryType == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfileEntryTypeIds.add(dlFileEntryType.getFileEntryTypeId());\n\n\t\t\tif (defaultFileEntryTypeUuid.equals(dlFileEntryType.getUuid())) {\n\t\t\t\tdefaultFileEntryTypeId = dlFileEntryType.getFileEntryTypeId();\n\t\t\t}\n\t\t}\n\n\t\tif (GetterUtil.getBoolean(\n\t\t\t\tfolderElement.attributeValue(\"basic-document\"))) {\n\n\t\t\tDLFileEntryType dlFileEntryType =\n\t\t\t\tDLFileEntryTypeLocalServiceUtil.fetchDLFileEntryType(0);\n\n\t\t\tfileEntryTypeIds.add(dlFileEntryType.getFileEntryTypeId());\n\t\t}\n\n\t\tif (!fileEntryTypeIds.isEmpty()) {\n\t\t\tDLFolder dlFolder = (DLFolder)folder.getModel();\n\n\t\t\tdlFolder.setDefaultFileEntryTypeId(defaultFileEntryTypeId);\n\t\t\tdlFolder.setOverrideFileEntryTypes(true);\n\n\t\t\tDLFolderLocalServiceUtil.updateDLFolder(dlFolder);\n\n\t\t\tDLFileEntryTypeLocalServiceUtil.updateFolderFileEntryTypes(\n\t\t\t\tdlFolder, fileEntryTypeIds, defaultFileEntryTypeId,\n\t\t\t\tserviceContext);\n\t\t}\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Folder folder)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(folder.getUserUuid());\n\n\t\tMap<Long, Long> folderIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDLFolder.class);\n\n\t\tlong parentFolderId = MapUtil.getLong(\n\t\t\tfolderIds, folder.getParentFolderId(), folder.getParentFolderId());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tfolderPath, folder, NAMESPACE);\n\n\t\tif ((parentFolderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(parentFolderId == folder.getParentFolderId())) {\n\n\t\t\tString path = getImportFolderPath(\n\t\t\t\tportletDataContext, parentFolderId);\n\n\t\t\tFolder parentFolder =\n\t\t\t\t(Folder)portletDataContext.getZipEntryAsObject(path);\n\n\t\t\timportFolder(portletDataContext, path, folderElement, parentFolder);\n\n\t\t\tparentFolderId = MapUtil.getLong(\n\t\t\t\tfolderIds, folder.getParentFolderId(),\n\t\t\t\tfolder.getParentFolderId());\n\t\t}\n\n\t\tFolder importedFolder = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tFolder existingFolder = FolderUtil.fetchByUUID_R(\n\t\t\t\tfolder.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tif (existingFolder == null) {\n\t\t\t\tString name = getFolderName(\n\t\t\t\t\tnull, portletDataContext.getScopeGroupId(), parentFolderId,\n\t\t\t\t\tfolder.getName(), 2);\n\n\t\t\t\tserviceContext.setUuid(folder.getUuid());\n\n\t\t\t\timportedFolder = DLAppLocalServiceUtil.addFolder(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tparentFolderId, name, folder.getDescription(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString name = getFolderName(\n\t\t\t\t\tfolder.getUuid(), portletDataContext.getScopeGroupId(),\n\t\t\t\t\tparentFolderId, folder.getName(), 2);\n\n\t\t\t\timportedFolder = DLAppLocalServiceUtil.updateFolder(\n\t\t\t\t\texistingFolder.getFolderId(), parentFolderId, name,\n\t\t\t\t\tfolder.getDescription(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString name = getFolderName(\n\t\t\t\tnull, portletDataContext.getScopeGroupId(), parentFolderId,\n\t\t\t\tfolder.getName(), 2);\n\n\t\t\timportedFolder = DLAppLocalServiceUtil.addFolder(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), parentFolderId,\n\t\t\t\tname, folder.getDescription(), serviceContext);\n\t\t}\n\n\t\tfolderIds.put(folder.getFolderId(), importedFolder.getFolderId());\n\n\t\timportFolderFileEntryTypes(\n\t\t\tportletDataContext, folderElement, importedFolder, serviceContext);\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tfolder, importedFolder, NAMESPACE);\n\t}","id":73337,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Folder folder)\n\t\tthrows Exception {\n\n\t\tString path = ExportImportPathUtil.getModelPath(\n\t\t\tportletDataContext, Folder.class.getName(), folder.getFolderId());\n\n\t\tElement folderElement =\n\t\t\tportletDataContext.getImportDataStagedModelElement(\n\t\t\t\tFolder.class.getSimpleName(), \"path\", path);\n\n\t\tElement folderReferencesElement = folderElement.element(\"references\");\n\n\t\tif (folderReferencesElement != null) {\n\t\t\tList<Element> refElements = folderReferencesElement.elements();\n\n\t\t\tfor (Element refElement : refElements) {\n\t\t\t\tString className = refElement.attributeValue(\"class-name\");\n\n\t\t\t\tif (!className.equals(Repository.class.getSimpleName())) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString classPk = refElement.attributeValue(\"class-pk\");\n\n\t\t\t\tString refPath = ExportImportPathUtil.getModelPath(\n\t\t\t\t\tportletDataContext, className, Long.valueOf(classPk));\n\n\t\t\t\tStagedModel referencedStagedModel =\n\t\t\t\t\t(StagedModel)portletDataContext.getZipEntryAsObject(\n\t\t\t\t\t\trefPath);\n\n\t\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\t\tportletDataContext, referencedStagedModel);\n\t\t\t}\n\t\t}\n\n\t\tlong userId = portletDataContext.getUserId(folder.getUserUuid());\n\n\t\tif (folder.getParentFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tString parentFolderPath = ExportImportPathUtil.getModelPath(\n\t\t\t\tportletDataContext, Folder.class.getName(),\n\t\t\t\tfolder.getParentFolderId());\n\n\t\t\tFolder parentFolder =\n\t\t\t\t(Folder)portletDataContext.getZipEntryAsObject(\n\t\t\t\t\tparentFolderPath);\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, parentFolder);\n\t\t}\n\n\t\tMap<Long, Long> folderIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFolder.class);\n\n\t\tlong parentFolderId = MapUtil.getLong(\n\t\t\tfolderIds, folder.getParentFolderId(), folder.getParentFolderId());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tfolder, DLPortletDataHandler.NAMESPACE);\n\n\t\tserviceContext.setUserId(userId);\n\n\t\tFolder importedFolder = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tFolder existingFolder = FolderUtil.fetchByUUID_R(\n\t\t\t\tfolder.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tif (existingFolder == null) {\n\t\t\t\tString name = getFolderName(\n\t\t\t\t\tnull, portletDataContext.getScopeGroupId(), parentFolderId,\n\t\t\t\t\tfolder.getName(), 2);\n\n\t\t\t\tserviceContext.setUuid(folder.getUuid());\n\n\t\t\t\timportedFolder = DLAppLocalServiceUtil.addFolder(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tparentFolderId, name, folder.getDescription(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString name = getFolderName(\n\t\t\t\t\tfolder.getUuid(), portletDataContext.getScopeGroupId(),\n\t\t\t\t\tparentFolderId, folder.getName(), 2);\n\n\t\t\t\timportedFolder = DLAppLocalServiceUtil.updateFolder(\n\t\t\t\t\texistingFolder.getFolderId(), parentFolderId, name,\n\t\t\t\t\tfolder.getDescription(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString name = getFolderName(\n\t\t\t\tnull, portletDataContext.getScopeGroupId(), parentFolderId,\n\t\t\t\tfolder.getName(), 2);\n\n\t\t\timportedFolder = DLAppLocalServiceUtil.addFolder(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), parentFolderId,\n\t\t\t\tname, folder.getDescription(), serviceContext);\n\t\t}\n\n\t\tfolderIds.put(folder.getFolderId(), importedFolder.getFolderId());\n\n\t\timportFolderFileEntryTypes(\n\t\t\tportletDataContext, folderElement, folder, serviceContext);\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tfolder, importedFolder, DLPortletDataHandler.NAMESPACE);\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tRepositoryEntry repositoryEntry)\n\t\tthrows Exception {\n\n\t\tString path = getRepositoryEntryPath(\n\t\t\tportletDataContext, repositoryEntry);\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tElement repositoryEntryElement = repositoryEntriesElement.addElement(\n\t\t\t\"repository-entry\");\n\n\t\tportletDataContext.addClassedModel(\n\t\t\trepositoryEntryElement, path, repositoryEntry, NAMESPACE);\n\t}","id":73338,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tRepositoryEntry repositoryEntry)\n\t\tthrows Exception {\n\n\t\tElement repositoryEntryElement =\n\t\t\tportletDataContext.getExportDataStagedModelElement(repositoryEntry);\n\n\t\tportletDataContext.addClassedModel(\n\t\t\trepositoryEntryElement,\n\t\t\tExportImportPathUtil.getModelPath(repositoryEntry), repositoryEntry,\n\t\t\tDLPortletDataHandler.NAMESPACE);\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tRepositoryEntry repositoryEntry)\n\t\tthrows Exception {\n\n\t\tString path = repositoryEntryElement.attributeValue(\"path\");\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tRepositoryEntry repositoryEntry =\n\t\t\t(RepositoryEntry)portletDataContext.getZipEntryAsObject(path);\n\n\t\tlong userId = portletDataContext.getUserId(\n\t\t\trepositoryEntry.getUserUuid());\n\n\t\tMap<Long, Long> repositoryIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tRepository.class);\n\n\t\tlong repositoryId = MapUtil.getLong(\n\t\t\trepositoryIds, repositoryEntry.getRepositoryId(),\n\t\t\trepositoryEntry.getRepositoryId());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\trepositoryEntryElement, repositoryEntry, NAMESPACE);\n\n\t\tRepositoryEntry importedRepositoryEntry = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tRepositoryEntry existingRepositoryEntry =\n\t\t\t\tRepositoryEntryUtil.fetchByUUID_G(\n\t\t\t\t\trepositoryEntry.getUuid(),\n\t\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\t\tif (existingRepositoryEntry == null) {\n\t\t\t\tserviceContext.setUuid(repositoryEntry.getUuid());\n\n\t\t\t\timportedRepositoryEntry =\n\t\t\t\t\tRepositoryEntryLocalServiceUtil.addRepositoryEntry(\n\t\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\t\trepositoryId, repositoryEntry.getMappedId(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedRepositoryEntry =\n\t\t\t\t\tRepositoryEntryLocalServiceUtil.updateRepositoryEntry(\n\t\t\t\t\t\texistingRepositoryEntry.getRepositoryEntryId(),\n\t\t\t\t\t\trepositoryEntry.getMappedId());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedRepositoryEntry =\n\t\t\t\tRepositoryEntryLocalServiceUtil.addRepositoryEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), repositoryId,\n\t\t\t\t\trepositoryEntry.getMappedId(), serviceContext);\n\t\t}\n\n\t\tMap<Long, Long> repositoryEntryIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tRepositoryEntry.class);\n\n\t\trepositoryEntryIds.put(\n\t\t\trepositoryEntry.getRepositoryEntryId(),\n\t\t\timportedRepositoryEntry.getRepositoryEntryId());\n\n\t\tportletDataContext.importClassedModel(\n\t\t\trepositoryEntry, importedRepositoryEntry, NAMESPACE);\n\t}","id":73339,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext,\n\t\t\tRepositoryEntry repositoryEntry)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(\n\t\t\trepositoryEntry.getUserUuid());\n\n\t\tMap<Long, Long> repositoryIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tRepository.class);\n\n\t\tlong repositoryId = MapUtil.getLong(\n\t\t\trepositoryIds, repositoryEntry.getRepositoryId(),\n\t\t\trepositoryEntry.getRepositoryId());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\trepositoryEntry, DLPortletDataHandler.NAMESPACE);\n\n\t\tRepositoryEntry importedRepositoryEntry = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tRepositoryEntry existingRepositoryEntry =\n\t\t\t\tRepositoryEntryUtil.fetchByUUID_G(\n\t\t\t\t\trepositoryEntry.getUuid(),\n\t\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\t\tif (existingRepositoryEntry == null) {\n\t\t\t\tserviceContext.setUuid(repositoryEntry.getUuid());\n\n\t\t\t\timportedRepositoryEntry =\n\t\t\t\t\tRepositoryEntryLocalServiceUtil.addRepositoryEntry(\n\t\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\t\trepositoryId, repositoryEntry.getMappedId(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedRepositoryEntry =\n\t\t\t\t\tRepositoryEntryLocalServiceUtil.updateRepositoryEntry(\n\t\t\t\t\t\texistingRepositoryEntry.getRepositoryEntryId(),\n\t\t\t\t\t\trepositoryEntry.getMappedId());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedRepositoryEntry =\n\t\t\t\tRepositoryEntryLocalServiceUtil.addRepositoryEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), repositoryId,\n\t\t\t\t\trepositoryEntry.getMappedId(), serviceContext);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\trepositoryEntry, importedRepositoryEntry,\n\t\t\tDLPortletDataHandler.NAMESPACE);\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Repository repository)\n\t\tthrows Exception {\n\n\t\tString path = repositoryElement.attributeValue(\"path\");\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tRepository repository =\n\t\t\t(Repository)portletDataContext.getZipEntryAsObject(\n\t\t\t\trepositoryElement, path);\n\n\t\tlong userId = portletDataContext.getUserId(repository.getUserUuid());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\trepositoryElement, repository, NAMESPACE);\n\n\t\tRepository importedRepository = null;\n\n\t\ttry {\n\t\t\tboolean hidden = GetterUtil.getBoolean(\n\t\t\t\trepositoryElement.attributeValue(\"hidden\"));\n\n\t\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\t\tRepository existingRepository = RepositoryUtil.fetchByUUID_G(\n\t\t\t\t\trepository.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\t\tif (existingRepository == null) {\n\t\t\t\t\texistingRepository =\n\t\t\t\t\t\tRepositoryLocalServiceUtil.fetchRepository(\n\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\t\t\trepository.getName());\n\t\t\t\t}\n\n\t\t\t\tlong classNameId = 0;\n\n\t\t\t\tif (existingRepository != null) {\n\t\t\t\t\tclassNameId = existingRepository.getClassNameId();\n\t\t\t\t}\n\n\t\t\t\tif ((existingRepository == null) ||\n\t\t\t\t\t(classNameId !=\n\t\t\t\t\t\tPortalUtil.getClassNameId(LiferayRepository.class))) {\n\n\t\t\t\t\tserviceContext.setUuid(repository.getUuid());\n\n\t\t\t\t\timportedRepository =\n\t\t\t\t\t\tRepositoryLocalServiceUtil.addRepository(\n\t\t\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\t\t\trepository.getClassNameId(),\n\t\t\t\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID,\n\t\t\t\t\t\t\trepository.getName(), repository.getDescription(),\n\t\t\t\t\t\t\trepository.getPortletId(),\n\t\t\t\t\t\t\trepository.getTypeSettingsProperties(), hidden,\n\t\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tRepositoryLocalServiceUtil.updateRepository(\n\t\t\t\t\t\texistingRepository.getRepositoryId(),\n\t\t\t\t\t\trepository.getName(), repository.getDescription());\n\n\t\t\t\t\timportedRepository = existingRepository;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedRepository = RepositoryLocalServiceUtil.addRepository(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\trepository.getClassNameId(),\n\t\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID,\n\t\t\t\t\trepository.getName(), repository.getDescription(),\n\t\t\t\t\trepository.getPortletId(),\n\t\t\t\t\trepository.getTypeSettingsProperties(), hidden,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Unable to connect to repository {name=\" +\n\t\t\t\t\t\trepository.getName() + \", typeSettings=\" +\n\t\t\t\t\t\trepository.getTypeSettingsProperties() + \"}\",\n\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\trepository, importedRepository, NAMESPACE);\n\t}","id":73340,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Repository repository)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(repository.getUserUuid());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\trepository, DLPortletDataHandler.NAMESPACE);\n\n\t\tRepository importedRepository = null;\n\n\t\tElement repositoryElement =\n\t\t\tportletDataContext.getImportDataStagedModelElement(repository);\n\n\t\ttry {\n\t\t\tboolean hidden = GetterUtil.getBoolean(\n\t\t\t\trepositoryElement.attributeValue(\"hidden\"));\n\n\t\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\t\tRepository existingRepository = RepositoryUtil.fetchByUUID_G(\n\t\t\t\t\trepository.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\t\tif (existingRepository == null) {\n\t\t\t\t\texistingRepository =\n\t\t\t\t\t\tRepositoryLocalServiceUtil.fetchRepository(\n\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\t\t\trepository.getName());\n\t\t\t\t}\n\n\t\t\t\tlong classNameId = 0;\n\n\t\t\t\tif (existingRepository != null) {\n\t\t\t\t\tclassNameId = existingRepository.getClassNameId();\n\t\t\t\t}\n\n\t\t\t\tif ((existingRepository == null) ||\n\t\t\t\t\t(classNameId !=\n\t\t\t\t\t\tPortalUtil.getClassNameId(LiferayRepository.class))) {\n\n\t\t\t\t\tserviceContext.setUuid(repository.getUuid());\n\n\t\t\t\t\timportedRepository =\n\t\t\t\t\t\tRepositoryLocalServiceUtil.addRepository(\n\t\t\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\t\t\trepository.getClassNameId(),\n\t\t\t\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID,\n\t\t\t\t\t\t\trepository.getName(), repository.getDescription(),\n\t\t\t\t\t\t\trepository.getPortletId(),\n\t\t\t\t\t\t\trepository.getTypeSettingsProperties(), hidden,\n\t\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tRepositoryLocalServiceUtil.updateRepository(\n\t\t\t\t\t\texistingRepository.getRepositoryId(),\n\t\t\t\t\t\trepository.getName(), repository.getDescription());\n\n\t\t\t\t\timportedRepository = existingRepository;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedRepository = RepositoryLocalServiceUtil.addRepository(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\trepository.getClassNameId(),\n\t\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID,\n\t\t\t\t\trepository.getName(), repository.getDescription(),\n\t\t\t\t\trepository.getPortletId(),\n\t\t\t\t\trepository.getTypeSettingsProperties(), hidden,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Unable to connect to repository {name=\" +\n\t\t\t\t\t\trepository.getName() + \", typeSettings=\" +\n\t\t\t\t\t\t\trepository.getTypeSettingsProperties() + \"}\",\n\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\trepository, importedRepository, DLPortletDataHandler.NAMESPACE);\n\n\t\t// Repository Entries\n\n\t\tList<Element> referencedElements =\n\t\t\tportletDataContext.getReferencedDataElements(\n\t\t\t\trepository, RepositoryEntry.class);\n\n\t\tfor (Element referencedElement : referencedElements) {\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, referencedElement);\n\t\t}\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Repository repository)\n\t\tthrows Exception {\n\n\t\tif (!portletDataContext.isWithinDateRange(\n\t\t\t\trepository.getModifiedDate())) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tString path = getRepositoryPath(portletDataContext, repository);\n\n\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tElement repositoryElement = repositoriesElement.addElement(\n\t\t\t\"repository\");\n\n\t\tFolder folder = DLAppLocalServiceUtil.getFolder(\n\t\t\trepository.getDlFolderId());\n\n\t\tif (folder.getModel() instanceof DLFolder) {\n\t\t\tDLFolder dlFolder = (DLFolder)folder.getModel();\n\n\t\t\trepositoryElement.addAttribute(\n\t\t\t\t\"hidden\", String.valueOf(dlFolder.isHidden()));\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\trepositoryElement, path, repository, NAMESPACE);\n\n\t\tList<RepositoryEntry> repositoryEntries =\n\t\t\tRepositoryEntryUtil.findByRepositoryId(\n\t\t\t\trepository.getRepositoryId());\n\n\t\tfor (RepositoryEntry repositoryEntry : repositoryEntries) {\n\t\t\texportRepositoryEntry(\n\t\t\t\tportletDataContext, repositoryEntriesElement, repositoryEntry);\n\t\t}\n\t}","id":73341,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Repository repository)\n\t\tthrows Exception {\n\n\t\tElement repositoryElement =\n\t\t\tportletDataContext.getExportDataStagedModelElement(repository);\n\n\t\tFolder folder = DLAppLocalServiceUtil.getFolder(\n\t\t\trepository.getDlFolderId());\n\n\t\tif (folder.getModel() instanceof DLFolder) {\n\t\t\tDLFolder dlFolder = (DLFolder)folder.getModel();\n\n\t\t\trepositoryElement.addAttribute(\n\t\t\t\t\"hidden\", String.valueOf(dlFolder.isHidden()));\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\trepositoryElement, ExportImportPathUtil.getModelPath(repository),\n\t\t\trepository, DLPortletDataHandler.NAMESPACE);\n\n\t\tList<RepositoryEntry> repositoryEntries =\n\t\t\tRepositoryEntryUtil.findByRepositoryId(\n\t\t\t\trepository.getRepositoryId());\n\n\t\tfor (RepositoryEntry repositoryEntry : repositoryEntries) {\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, repositoryEntry);\n\n\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\trepositoryElement, repositoryEntry);\n\t\t}\n\t}","commit_id":"fdb2c6fca1db9628a4af7b3a40523a6d52f37712","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSearchAndVerifyDocs() throws Exception {\n\t\tBookmarksFolder folder = BookmarksTestUtil.addFolder(\n\t\t\t_group.getGroupId());\n\n\t\tBookmarksEntry entry = BookmarksTestUtil.addEntry(\n\t\t\t_group.getGroupId(), folder.getFolderId(), true);\n\n\t\tlong companyId = entry.getCompanyId();\n\t\tlong groupId = entry.getFolder().getGroupId();\n\t\tlong folderId = entry.getFolderId();\n\t\tString keywords = \"test\";\n\n\t\tSearchContext searchContext = BookmarksTestUtil.getSearchContext(\n\t\t\tcompanyId, groupId, folderId, keywords);\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(BookmarksEntry.class);\n\n\t\tHits hits = indexer.search(searchContext);\n\n\t\tAssert.assertEquals(1, hits.getLength());\n\n\t\tList<Document> results = hits.toList();\n\n\t\tfor (Document doc : results) {\n\t\t\tAssert.assertEquals(\n\t\t\t\tcompanyId, GetterUtil.getLong(doc.get(Field.COMPANY_ID)));\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tgroupId, GetterUtil.getLong(doc.get(Field.GROUP_ID)));\n\n\t\t\tAssertUtils.assertEqualsIgnoreCase(\n\t\t\t\tentry.getName(), doc.get(Field.TITLE));\n\t\t\tAssert.assertEquals(entry.getUrl(), doc.get(Field.URL));\n\t\t\tAssertUtils.assertEqualsIgnoreCase(\n\t\t\t\tentry.getDescription(), doc.get(Field.DESCRIPTION));\n\n\t\t\tAssert.assertEquals(\n\t\t\t\tfolderId, GetterUtil.getLong(doc.get(\"folderId\")));\n\t\t\tAssert.assertEquals(\n\t\t\t\tentry.getEntryId(),\n\t\t\t\tGetterUtil.getLong(doc.get(Field.ENTRY_CLASS_PK)));\n\t\t}\n\t}","id":73342,"modified_method":"@Test\n\tpublic void testSearchAndVerifyDocs() throws Exception {\n\t\tBookmarksFolder folder = BookmarksTestUtil.addFolder(\n\t\t\t_group.getGroupId());\n\n\t\tBookmarksEntry entry = BookmarksTestUtil.addEntry(\n\t\t\t_group.getGroupId(), folder.getFolderId(), true);\n\n\t\tSearchContext searchContext = BookmarksTestUtil.getSearchContext(\n\t\t\tentry.getCompanyId(), entry.getGroupId(), entry.getFolderId(),\n\t\t\t\"test\");\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(BookmarksEntry.class);\n\n\t\tHits hits = indexer.search(searchContext);\n\n\t\tAssert.assertEquals(1, hits.getLength());\n\n\t\tList<Document> results = hits.toList();\n\n\t\tfor (Document doc : results) {\n\t\t\tAssert.assertEquals(\n\t\t\t\tentry.getCompanyId(),\n\t\t\t\tGetterUtil.getLong(doc.get(Field.COMPANY_ID)));\n\t\t\tAssertUtils.assertEqualsIgnoreCase(\n\t\t\t\tentry.getDescription(), doc.get(Field.DESCRIPTION));\n\t\t\tAssert.assertEquals(\n\t\t\t\tentry.getEntryId(),\n\t\t\t\tGetterUtil.getLong(doc.get(Field.ENTRY_CLASS_PK)));\n\t\t\tAssert.assertEquals(\n\t\t\t\tentry.getGroupId(),\n\t\t\t\tGetterUtil.getLong(doc.get(Field.GROUP_ID)));\n\t\t\tAssertUtils.assertEqualsIgnoreCase(\n\t\t\t\tentry.getName(), doc.get(Field.TITLE));\n\t\t\tAssert.assertEquals(entry.getUrl(), doc.get(Field.URL));\n\t\t\tAssert.assertEquals(\n\t\t\t\tentry.getFolderId(), GetterUtil.getLong(doc.get(\"folderId\")));\n\t\t}\n\t}","commit_id":"21053430f11c05f1d09bd450dd35f1b30729b4f0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testCountRangeSearch() throws Exception {\n\t\tBookmarksEntry entry = BookmarksTestUtil.addEntry(\n\t\t\t_group.getGroupId(), true);\n\n\t\tBookmarksTestUtil.addEntry(_group.getGroupId(), true);\n\t\tBookmarksTestUtil.addEntry(_group.getGroupId(), true);\n\t\tBookmarksTestUtil.addEntry(_group.getGroupId(), true);\n\n\t\tlong companyId = _group.getCompanyId();\n\t\tlong groupId = _group.getGroupId();\n\t\tlong folderId = entry.getFolderId();\n\t\tString keywords = \"test\";\n\n\t\tSearchContext searchContext = BookmarksTestUtil.getSearchContext(\n\t\t\tcompanyId, groupId, folderId, keywords);\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(BookmarksEntry.class);\n\n\t\tsearchContext.setEnd(3);\n\t\tsearchContext.setFolderIds((long[]) null);\n\t\tsearchContext.setStart(1);\n\n\t\tHits hits = indexer.search(searchContext);\n\n\t\tAssert.assertEquals(4, hits.getLength());\n\t\tAssert.assertEquals(2, hits.getDocs().length);\n\t}","id":73343,"modified_method":"@Test\n\tpublic void testSearchRange() throws Exception {\n\t\tBookmarksEntry entry = BookmarksTestUtil.addEntry(\n\t\t\t_group.getGroupId(), true);\n\n\t\tBookmarksTestUtil.addEntry(_group.getGroupId(), true);\n\t\tBookmarksTestUtil.addEntry(_group.getGroupId(), true);\n\t\tBookmarksTestUtil.addEntry(_group.getGroupId(), true);\n\n\t\tSearchContext searchContext = BookmarksTestUtil.getSearchContext(\n\t\t\t_group.getCompanyId(), _group.getGroupId(), entry.getFolderId(),\n\t\t\t\"test\");\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(BookmarksEntry.class);\n\n\t\tsearchContext.setEnd(3);\n\t\tsearchContext.setFolderIds((long[])null);\n\t\tsearchContext.setStart(1);\n\n\t\tHits hits = indexer.search(searchContext);\n\n\t\tAssert.assertEquals(4, hits.getLength());\n\t\t\n\t\tDocument[] documents = hits.getDocs();\n\n\t\tAssert.assertEquals(2, documents.length);\n\t}","commit_id":"21053430f11c05f1d09bd450dd35f1b30729b4f0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testSearch() throws Exception {\n\t\tBookmarksFolder folder = BookmarksTestUtil.addFolder(\n\t\t\t_group.getGroupId());\n\n\t\tBookmarksEntry entry = BookmarksTestUtil.addEntry(\n\t\t\t_group.getGroupId(), folder.getFolderId(), true);\n\n\t\tlong companyId = entry.getCompanyId();\n\t\tlong groupId = entry.getFolder().getGroupId();\n\t\tlong folderId = entry.getFolderId();\n\t\tString keywords = \"test\";\n\n\t\tSearchContext searchContext = BookmarksTestUtil.getSearchContext(\n\t\t\tcompanyId, groupId, folderId, keywords);\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(BookmarksEntry.class);\n\n\t\tHits hits = indexer.search(searchContext);\n\n\t\tAssert.assertEquals(1, hits.getLength());\n\t}","id":73344,"modified_method":"@Test\n\tpublic void testSearch() throws Exception {\n\t\tBookmarksFolder folder = BookmarksTestUtil.addFolder(\n\t\t\t_group.getGroupId());\n\n\t\tBookmarksEntry entry = BookmarksTestUtil.addEntry(\n\t\t\t_group.getGroupId(), folder.getFolderId(), true);\n\n\t\tSearchContext searchContext = BookmarksTestUtil.getSearchContext(\n\t\t\tentry.getCompanyId(), entry.getGroupId(), entry.getFolderId(),\n\t\t\t\"test\");\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(BookmarksEntry.class);\n\n\t\tHits hits = indexer.search(searchContext);\n\n\t\tAssert.assertEquals(1, hits.getLength());\n\t}","commit_id":"1c534ad0063f383bd590027ddea69c31e8e18def","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean parse(PsiBuilder builder, boolean isInClass, boolean isInAnnotation) {\n    PsiBuilder.Marker declMarker = builder.mark();\n    //allows error messages\n    boolean modifiersParsed = Modifiers.parse(builder);\n\n    if (modifiersParsed && mLT == builder.getTokenType()) {\n      TypeParameters.parse(builder);\n      PsiBuilder.Marker checkMarker = builder.mark(); //point to begin of type or variable\n\n      if (!TypeSpec.parse(builder, true)) { //if type wasn't recognized trying parse VaribleDeclaration\n        checkMarker.rollbackTo();\n      } else {\n        checkMarker.drop();\n      }\n      IElementType decl = VariableDefinitions.parseDefinitions(builder, isInClass, false, false, true, modifiersParsed);\n\n      if (WRONGWAY.equals(decl)) {\n        declMarker.error(GroovyBundle.message(\"method.definitions.expected\"));\n      } else {\n        declMarker.done(METHOD_DEFINITION);\n      }\n      return true;\n\n    } else if (modifiersParsed) {\n\n      PsiBuilder.Marker checkMarker = builder.mark(); //point to begin of type or variable\n\n      if (!TypeSpec.parse(builder, false)) { //if type wasn't recognized trying parse VaribleDeclaration\n        checkMarker.rollbackTo();\n\n        if (isInAnnotation) {\n          builder.error(GroovyBundle.message(\"type.expected\"));\n        }\n\n        IElementType varDecl = VariableDefinitions.parse(builder, isInClass, modifiersParsed);\n\n        if (WRONGWAY.equals(varDecl)) {\n          builder.error(GroovyBundle.message(\"variable.definitions.expected\"));\n          declMarker.rollbackTo();\n          return false;\n        } else {\n          declMarker.done(varDecl);\n          return true;\n        }\n\n      } else {  //type was recognized\n        IElementType varDeclarationTop = VariableDefinitions.parse(builder, isInClass, modifiersParsed);\n\n        if (WRONGWAY.equals(varDeclarationTop)) {\n          checkMarker.rollbackTo();\n\n          if (isInAnnotation) {\n            builder.error(GroovyBundle.message(\"type.expected\"));\n          }\n\n          IElementType varDecl = VariableDefinitions.parse(builder, isInClass, modifiersParsed);\n\n          if (WRONGWAY.equals(varDecl)) {\n            builder.error(GroovyBundle.message(\"variable.definitions.expected\"));\n            declMarker.rollbackTo();\n            return false;\n          } else {\n            declMarker.done(varDecl);\n            return true;\n          }\n        } else {\n          checkMarker.drop();\n          declMarker.done(varDeclarationTop);\n          return true;\n        }\n      }\n    } else {\n\n      //if definition starts with lower case letter than it can be just call expression\n\n      String text = builder.getTokenText();\n      if (!builder.eof()\n          && !TokenSets.BUILT_IN_TYPE.contains(builder.getTokenType())\n          && text != null\n          && (Character.isLowerCase((text.charAt(0))) || !Character.isLetter(text.charAt(0))) &&\n          (ParserUtils.lookAhead(builder, mIDENT, mIDENT) || ParserUtils.lookAhead(builder, mIDENT, mLPAREN))) {\n        //call expression\n        declMarker.rollbackTo();\n        return false;\n      }\n\n      boolean typeParsed = false;\n      if (!ParserUtils.lookAhead(builder, mIDENT, mLPAREN)) {\n        typeParsed = TypeSpec.parse(builder, true);\n        //type specification starts with upper case letter\n        if (!typeParsed) {\n          builder.error(GroovyBundle.message(\"type.specification.expected\"));\n          declMarker.rollbackTo();\n          return false;\n        }\n      }\n\n      IElementType varDef = VariableDefinitions.parse(builder, isInClass, modifiersParsed || typeParsed);\n      if (varDef != WRONGWAY) {\n        declMarker.done(varDef);\n        return true;\n      } else if (isInClass && typeParsed) {\n        declMarker.drop();\n        return typeParsed;\n      }\n\n      declMarker.rollbackTo();\n      return false;\n    }\n  }","id":73345,"modified_method":"public static boolean parse(PsiBuilder builder, boolean isInClass, boolean isInAnnotation) {\n    PsiBuilder.Marker declMarker = builder.mark();\n    //allows error messages\n    boolean modifiersParsed = Modifiers.parse(builder);\n\n    if (modifiersParsed && mLT == builder.getTokenType()) {\n      TypeParameters.parse(builder);\n      PsiBuilder.Marker checkMarker = builder.mark(); //point to begin of type or variable\n\n      if (!TypeSpec.parse(builder, true)) { //if type wasn't recognized trying parse VaribleDeclaration\n        checkMarker.rollbackTo();\n      } else {\n        checkMarker.drop();\n      }\n      IElementType decl = VariableDefinitions.parseDefinitions(builder, isInClass, false, false, true, modifiersParsed, false);\n\n      if (WRONGWAY.equals(decl)) {\n        declMarker.error(GroovyBundle.message(\"method.definitions.expected\"));\n      } else {\n        declMarker.done(METHOD_DEFINITION);\n      }\n      return true;\n\n    } else if (modifiersParsed) {\n\n      PsiBuilder.Marker checkMarker = builder.mark(); //point to begin of type or variable\n\n      if (!TypeSpec.parse(builder, false)) { //if type wasn't recognized trying parse VaribleDeclaration\n        checkMarker.rollbackTo();\n\n        if (isInAnnotation) {\n          builder.error(GroovyBundle.message(\"type.expected\"));\n        }\n\n        //current token isn't identifier\n        IElementType varDecl = VariableDefinitions.parse(builder, isInClass, modifiersParsed);\n\n        if (WRONGWAY.equals(varDecl)) {\n          builder.error(GroovyBundle.message(\"variable.definitions.expected\"));\n          declMarker.rollbackTo();\n          return false;\n        } else {\n          declMarker.done(varDecl);\n          return true;\n        }\n\n      } else {  //type was recognized, identifier here\n        //starts after type\n        IElementType varDeclarationTop = VariableDefinitions.parse(builder, isInClass, modifiersParsed, false);\n\n        if (WRONGWAY.equals(varDeclarationTop)) {\n          checkMarker.rollbackTo();\n\n          if (isInAnnotation) {\n            builder.error(GroovyBundle.message(\"type.expected\"));\n          }\n\n          //starts before \"type\" identifier, here can't be tuple, because next token is identifier (we are in \"type recognized\" branch)\n          IElementType varDecl = VariableDefinitions.parse(builder, isInClass, modifiersParsed, false);\n\n          if (WRONGWAY.equals(varDecl)) {\n            builder.error(GroovyBundle.message(\"variable.definitions.expected\"));\n            declMarker.rollbackTo();\n            return false;\n          } else {\n            declMarker.done(varDecl);\n            return true;\n          }\n        } else {\n          checkMarker.drop();\n          declMarker.done(varDeclarationTop);\n          return true;\n        }\n      }\n    } else {\n\n      //if definition starts with lower case letter than it can be just call expression\n\n      String text = builder.getTokenText();\n      if (!builder.eof()\n          && !TokenSets.BUILT_IN_TYPE.contains(builder.getTokenType())\n          && text != null\n          && (Character.isLowerCase((text.charAt(0))) || !Character.isLetter(text.charAt(0))) &&\n          (ParserUtils.lookAhead(builder, mIDENT, mIDENT) || ParserUtils.lookAhead(builder, mIDENT, mLPAREN))) {\n        //call expression\n        declMarker.rollbackTo();\n        return false;\n      }\n\n      if (builder.getTokenType() == mLPAREN) {\n        IElementType tupleDef = VariableDefinitions.parse(builder, isInClass, modifiersParsed, true);\n        if (tupleDef == WRONGWAY) {\n          declMarker.rollbackTo();\n          return false;\n        } else {\n          declMarker.done(tupleDef);\n          return true;\n        }\n      }\n\n      boolean typeParsed = false;\n      if (!ParserUtils.lookAhead(builder, mIDENT, mLPAREN)) {\n        typeParsed = TypeSpec.parse(builder, true);\n        //type specification starts with upper case letter\n        if (!typeParsed) {\n          builder.error(GroovyBundle.message(\"type.specification.expected\"));\n          declMarker.rollbackTo();\n          return false;\n        }\n      }\n\n      IElementType varDef = VariableDefinitions.parse(builder, isInClass, typeParsed);\n      if (varDef != WRONGWAY) {\n        declMarker.done(varDef);\n        return true;\n      } else if (isInClass && typeParsed) {\n        declMarker.drop();\n        return typeParsed;\n      }\n\n      declMarker.rollbackTo();\n      return false;\n    }\n  }","commit_id":"0db72ff82b59bdb84dd5ffff3391e01b02150abf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public GrModifierList getModifierList() {\n    PsiElement parent = getParent();\n    if (parent instanceof GrVariableDeclaration) {\n      return ((GrVariableDeclaration)parent).getModifierList();\n    }\n    return null;\n  }","id":73346,"modified_method":"@Nullable\n  public GrModifierList getModifierList() {\n    PsiElement parent = getParent();\n    if (parent instanceof GrVariableDeclaration) {\n      return ((GrVariableDeclaration)parent).getModifierList();\n    } else if (parent instanceof GrTuple) {\n      return ((GrVariableDeclaration)parent.getParent()).getModifierList();\n    }\n    return null;\n  }","commit_id":"0db72ff82b59bdb84dd5ffff3391e01b02150abf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public GrTypeElement getTypeElementGroovy() {\n    return ((GrVariableDeclaration)getParent()).getTypeElementGroovy();\n  }","id":73347,"modified_method":"@Nullable\n  public GrTypeElement getTypeElementGroovy() {\n    PsiElement parent = getParent();\n    return parent instanceof GrTuple ? null : ((GrVariableDeclaration)parent).getTypeElementGroovy();\n  }","commit_id":"0db72ff82b59bdb84dd5ffff3391e01b02150abf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public GrExpression getInitializerGroovy() {\n    return findChildByClass(GrExpression.class);\n  }","id":73348,"modified_method":"@Nullable\n  public GrExpression getInitializerGroovy() {\n    final PsiElement parent = getParent();\n    if (parent instanceof GrTuple){\n      final GrTuple tuple = (GrTuple)parent;\n      final GrExpression initializer = tuple.getInitializerGroovy();\n\n      if (initializer instanceof GrListOrMap){\n        final GrListOrMap listOrMap = (GrListOrMap)initializer;\n        final GrExpression[] initializers = listOrMap.getInitializers();\n\n        final int varNumber = tuple.getVariableNumber(this);\n        if (initializers.length < varNumber + 1) return null;\n\n        return initializers[varNumber];\n      }\n    }\n    return findChildByClass(GrExpression.class);\n  }","commit_id":"0db72ff82b59bdb84dd5ffff3391e01b02150abf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public PsiType getTypeGroovy() {\n    GrTypeElement typeElement = getTypeElementGroovy();\n    PsiType declaredType = null;\n    if (typeElement != null) {\n      declaredType = typeElement.getType();\n      if (!(declaredType instanceof PsiClassType)) {\n        return declaredType;\n      }\n    }\n\n    GrExpression initializer = getInitializerGroovy();\n    if (initializer != null) {\n      PsiType initializerType = initializer.getType(); // WARNING may give rise to SOE\n      if (initializerType != null) {\n        if (declaredType != null && initializerType instanceof PsiClassType) {\n          final PsiClass declaredClass = ((PsiClassType)declaredType).resolve();\n          if (declaredClass != null) {\n            final PsiClassType.ClassResolveResult initializerResult = ((PsiClassType)initializerType).resolveGenerics();\n            final PsiClass initializerClass = initializerResult.getElement();\n            if (initializerClass != null &&\n                !com.intellij.psi.util.PsiUtil.isRawSubstitutor(initializerClass, initializerResult.getSubstitutor())) {\n              if (declaredClass == initializerClass) return initializerType;\n              final PsiSubstitutor superSubstitutor =\n                TypeConversionUtil.getClassSubstitutor(declaredClass, initializerClass, initializerResult.getSubstitutor());\n              if (superSubstitutor != null) {\n                return JavaPsiFacade.getInstance(getProject()).getElementFactory().createType(declaredClass, superSubstitutor);\n              }\n            }\n          }\n        }\n      }\n\n      if (declaredType == null) declaredType = initializerType;\n    }\n\n\n    return declaredType;\n  }","id":73349,"modified_method":"@Nullable\n  public PsiType getTypeGroovy() {\n    GrExpression initializer = getInitializerGroovy();\n    final PsiElement parent = getParent();\n\n    if (parent instanceof GrTuple && initializer != null){\n      return initializer.getType();\n    }\n\n    GrTypeElement typeElement = getTypeElementGroovy();\n    PsiType declaredType = null;\n    if (typeElement != null) {\n      declaredType = typeElement.getType();\n      if (!(declaredType instanceof PsiClassType)) {\n        return declaredType;\n      }\n    }\n\n    if (initializer != null) {\n      PsiType initializerType = initializer.getType(); // WARNING may give rise to SOE\n      if (initializerType != null) {\n        if (declaredType != null && initializerType instanceof PsiClassType) {\n          final PsiClass declaredClass = ((PsiClassType)declaredType).resolve();\n          if (declaredClass != null) {\n            final PsiClassType.ClassResolveResult initializerResult = ((PsiClassType)initializerType).resolveGenerics();\n            final PsiClass initializerClass = initializerResult.getElement();\n            if (initializerClass != null &&\n                !com.intellij.psi.util.PsiUtil.isRawSubstitutor(initializerClass, initializerResult.getSubstitutor())) {\n              if (declaredClass == initializerClass) return initializerType;\n              final PsiSubstitutor superSubstitutor =\n                TypeConversionUtil.getClassSubstitutor(declaredClass, initializerClass, initializerResult.getSubstitutor());\n              if (superSubstitutor != null) {\n                return JavaPsiFacade.getInstance(getProject()).getElementFactory().createType(declaredClass, superSubstitutor);\n              }\n            }\n          }\n        }\n      }\n\n      if (declaredType == null) declaredType = initializerType;\n    }\n\n\n    return declaredType;\n  }","commit_id":"0db72ff82b59bdb84dd5ffff3391e01b02150abf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Creates Groovy PSI element by given AST node\n   *\n   * @param node Given node\n   * @return Respective PSI element\n   */\n  public static PsiElement createElement(ASTNode node) {\n    IElementType elem = node.getElementType();\n\n    if (elem instanceof IGroovyDocElementType) {\n      return GroovyDocPsiCreator.createElement(node);\n    }\n\n    // Groovydoc comment\n    if (elem.equals(GROOVY_DOC_COMMENT)) return new GrDocCommentImpl();\n\n    //Identifiers & literal\n    if (elem.equals(LITERAL)) return new GrLiteralImpl(node);\n    if (elem.equals(LABEL)) return new GrLabelImpl(node);\n\n    //Lists, maps etc...\n    if (elem.equals(LIST_OR_MAP)) return new GrListOrMapImpl(node);\n\n    if (elem.equals(MODIFIERS)) return new GrModifierListImpl(node);\n    if (elem.equals(ANNOTATION)) return new GrAnnotationImpl(node);\n    if (elem.equals(ANNOTATION_ARGUMENTS)) return new GrAnnotationArgumentListImpl(node);\n    if (elem.equals(ANNOTATION_ARRAY_INITIALIZER)) return new GrAnnotationArrrayInitializerImpl(node);\n    if (elem.equals(ANNOTATION_MEMBER_VALUE_PAIR)) return new GrAnnotationNameValuePairImpl(node);\n    if (elem.equals(ANNOTATION_MEMBER_VALUE_PAIRS)) return new GrAnnotationNameValuePairsImpl(node);\n\n    if (elem.equals(DEFAULT_ANNOTATION_VALUE)) return new GrDefaultAnnotationValueImpl(node);\n\n    //throws\n    if (elem.equals(THROW_CLAUSE)) return new GrThrowsClauseImpl(node);\n\n    // Imports\n    if (elem.equals(IMPORT_STATEMENT)) return new GrImportStatementImpl(node);\n\n    // Packaging\n    if (elem.equals(PACKAGE_DEFINITION)) return new GrPackageDefinitionImpl(node);\n\n    //statements\n    if (elem.equals(LABELED_STATEMENT)) return new GrLabeledStatementImpl(node);\n    if (elem.equals(IF_STATEMENT)) return new GrIfStatementImpl(node);\n    if (elem.equals(FOR_STATEMENT)) return new GrForStatementImpl(node);\n    if (elem.equals(FOR_IN_CLAUSE)) return new GrForInClauseImpl(node);\n    if (elem.equals(FOR_TRADITIONAL_CLAUSE)) return new GrTraditionalForClauseImpl(node);\n    if (elem.equals(WHILE_STATEMENT)) return new GrWhileStatementImpl(node);\n    if (elem.equals(TRY_BLOCK_STATEMENT)) return new GrTryCatchStatementImpl(node);\n    if (elem.equals(CATCH_CLAUSE)) return new GrCatchClauseImpl(node);\n    if (elem.equals(FINALLY_CLAUSE)) return new GrFinallyClauseImpl(node);\n    if (elem.equals(SYNCHRONIZED_STATEMENT)) return new GrSynchronizedStatementImpl(node);\n    if (elem.equals(SWITCH_STATEMENT)) return new GrSwitchStatementImpl(node);\n    if (elem.equals(CASE_LABEL)) return new GrCaseLabelImpl(node);\n    if (elem.equals(CASE_SECTION)) return new GrCaseSectionImpl(node);\n    if (elem.equals(VARIABLE_DEFINITION) || elem.equals(VARIABLE_DEFINITION_ERROR))\n      return new GrVariableDeclarationImpl(node);\n    if (elem.equals(VARIABLE)) return new GrVariableImpl(node);\n\n    if (elem.equals(FIELD)) return new GrFieldImpl(node);\n    if (elem.equals(CLASS_INITIALIZER)) return new GrClassInitializerImpl(node);\n\n    //type definitions\n    if (elem.equals(CLASS_DEFINITION)) return new GrClassDefinitionImpl(node);\n    if (elem.equals(INTERFACE_DEFINITION))\n      return new GrInterfaceDefinitionImpl(node);\n    if (elem.equals(ENUM_DEFINITION)) return new GrEnumTypeDefinitionImpl(node);\n    if (elem.equals(ANNOTATION_DEFINITION))\n      return new GrAnnotationTypeDefinitionImpl(node);\n    if (elem.equals(ANNOTATION_METHOD)) return new GrAnnotationMethodImpl(node);\n\n    if (elem.equals(REFERENCE_ELEMENT)) return new GrCodeReferenceElementImpl(node);\n    if (elem.equals(CLASS_TYPE_ELEMENT)) return new GrClassTypeElementImpl(node);\n\n    //clauses\n    if (elem.equals(IMPLEMENTS_CLAUSE)) return new GrImplementsClauseImpl(node);\n    if (elem.equals(EXTENDS_CLAUSE)) return new GrExtendsClauseImpl(node);\n\n    //bodies\n    if (elem.equals(CLASS_BODY)) return new GrTypeDefinitionBodyImpl(node);\n    if (elem.equals(ENUM_BODY)) return new GrEnumDefinitionBodyImpl(node);\n    if (elem.equals(CLOSABLE_BLOCK)) return new GrClosableBlockImpl(node);\n    if (elem.equals(OPEN_BLOCK)) return new GrOpenBlockImpl(node);\n    if (elem.equals(BLOCK_STATEMENT)) return new GrBlockStatementImpl(node);\n    if (elem.equals(EXPLICIT_CONSTRUCTOR)) return new GrConstructorInvocationImpl(node);\n\n    //enum\n    if (elem.equals(ENUM_CONSTANTS)) return new GrEnumConstantListImpl(node);\n    if (elem.equals(ENUM_CONSTANT)) return new GrEnumConstantImpl(node);\n\n    //members\n    if (elem.equals(CONSTRUCTOR_DEFINITION)) return new GrConstructorImpl(node);\n    if (elem.equals(METHOD_DEFINITION)) return new GrMethodImpl(node);\n\n    //parameters\n    if (elem.equals(PARAMETERS_LIST)) return new GrParameterListImpl(node);\n    if (elem.equals(PARAMETER)) return new GrParameterImpl(node);\n\n    //type parameters\n    if (elem.equals(TYPE_ARGUMENT)) return new GrWildcardTypeArgumentImpl(node);\n    if (elem.equals(TYPE_ARGUMENTS)) return new GrTypeArgumentListImpl(node);\n\n\n    if (elem.equals(TYPE_PARAMETER_LIST)) return new GrTypeParameterListImpl(node);\n    if (elem.equals(TYPE_PARAMETER)) return new GrTypeParameterImpl(node);\n    if (elem.equals(TYPE_PARAMETER_EXTENDS_BOUND_LIST)) return new GrTypeParameterParameterExtendsListImpl(node);\n\n    //Branch statements\n    if (elem.equals(RETURN_STATEMENT)) return new GrReturnStatementImpl(node);\n    if (elem.equals(THROW_STATEMENT)) return new GrThrowStatementImpl(node);\n    if (elem.equals(ASSERT_STATEMENT)) return new GrAssertStatementImpl(node);\n    if (elem.equals(BREAK_STATEMENT)) return new GrBreakStatementImpl(node);\n    if (elem.equals(CONTINUE_STATEMENT)) return new GrContinueStatementImpl(node);\n\n    //expressions\n    if (elem.equals(CALL_EXPRESSION)) return new GrApplicationStatementImpl(node);\n    if (elem.equals(COMMAND_ARGUMENTS)) return new GrCommandArgumentListImpl(node);\n    if (elem.equals(CONDITIONAL_EXPRESSION)) return new GrConditionalExprImpl(node);\n    if (elem.equals(ELVIS_EXPRESSION)) return new GrElvisExprImpl(node);\n    if (elem.equals(ASSIGNMENT_EXPRESSION)) return new GrAssignmentExpressionImpl(node);\n    if (elem.equals(LOGICAL_OR_EXPRESSION)) return new GrLogicalOrExpressionImpl(node);\n    if (elem.equals(LOGICAL_AND_EXPRESSION)) return new GrLogicalAndExpressionImpl(node);\n    if (elem.equals(EXCLUSIVE_OR_EXPRESSION)) return new GrExclusiveOrExpressionImpl(node);\n    if (elem.equals(INCLUSIVE_OR_EXPRESSION)) return new GrInclusiveOrExpressionImpl(node);\n    if (elem.equals(AND_EXPRESSION)) return new GrAndExpressionImpl(node);\n    if (elem.equals(REGEX_MATCH_EXPRESSION)) return new GrRegexMatchExpressionImpl(node);\n    if (elem.equals(REGEX_FIND_EXPRESSION)) return new GrRegexFindExpressionImpl(node);\n    if (elem.equals(EQUALITY_EXPRESSION)) return new GrEqualityExpressionImpl(node);\n    if (elem.equals(RELATIONAL_EXPRESSION)) return new GrRelationalExpressionImpl(node);\n    if (elem.equals(SHIFT_EXPRESSION)) return new GrShiftExpressionImpl(node);\n    if (elem.equals(RANGE_EXPRESSION)) return new GrRangeExpressionImpl(node);\n    if (elem.equals(COMPOSITE_SHIFT_SIGN)) return new GrOperationSignImpl(node);\n    if (elem.equals(ADDITIVE_EXPRESSION)) return new GrAdditiveExpressionImpl(node);\n    if (elem.equals(MULTIPLICATIVE_EXPRESSION)) return new GrMultiplicativeExpressionImpl(node);\n    if (elem.equals(POWER_EXPRESSION)) return new GrPowerExpressionImpl(node);\n    if (elem.equals(POWER_EXPRESSION_SIMPLE)) return new GrPowerExpressionImpl(node);\n    if (elem.equals(UNARY_EXPRESSION)) return new GrUnaryExpressionImpl(node);\n    if (elem.equals(POSTFIX_EXPRESSION)) return new GrPostfixExprImpl(node);\n    if (elem.equals(CAST_EXPRESSION)) return new GrTypeCastExpressionImpl(node);\n    if (elem.equals(SAFE_CAST_EXPRESSION)) return new GrSafeCastExpressionImpl(node);\n    if (elem.equals(INSTANCEOF_EXPRESSION)) return new GrInstanceofExpressionImpl(node);\n    if (elem.equals(BUILT_IN_TYPE_EXPRESSION)) return new GrBuiltinTypeClassExpressionImpl(node);\n    if (elem.equals(ARRAY_TYPE)) return new GrArrayTypeElementImpl(node);\n    if (elem.equals(BUILT_IN_TYPE)) return new GrBuiltInTypeElementImpl(node);\n    if (elem.equals(GSTRING)) return new GrStringImpl(node);\n    if (elem.equals(REGEX)) return new GrRegexImpl(node);\n    if (elem.equals(REFERENCE_EXPRESSION)) return new GrReferenceExpressionImpl(node);\n    if (elem.equals(THIS_REFERENCE_EXPRESSION)) return new GrThisReferenceExpressionImpl(node);\n    if (elem.equals(SUPER_REFERENCE_EXPRESSION)) return new GrSuperReferenceExpressionImpl(node);\n    if (elem.equals(PARENTHESIZED_EXPRESSION)) return new GrParenthesizedExpressionImpl(node);\n    if (elem.equals(NEW_EXPRESSION)) return new GrNewExpressionImpl(node);\n    if (elem.equals(ARRAY_DECLARATOR)) return new GrArrayDeclarationImpl(node);\n\n    //Paths\n    if (elem.equals(PATH_PROPERTY)) return new GrPropertySelectorImpl(node);\n    if (elem.equals(PATH_PROPERTY_REFERENCE)) return new GrPropertySelectionImpl(node);\n    if (elem.equals(PATH_METHOD_CALL)) return new GrMethodCallExpressionImpl(node);\n    if (elem.equals(PATH_INDEX_PROPERTY)) return new GrIndexPropertyImpl(node);\n\n    // Arguments\n    if (elem.equals(ARGUMENTS)) return new GrArgumentListImpl(node);\n    if (elem.equals(ARGUMENT)) return new GrNamedArgumentImpl(node);\n    if (elem.equals(ARGUMENT_LABEL)) return new GrArgumentLabelImpl(node);\n\n    if (elem.equals(BALANCED_BRACKETS)) return new GrBalancedBracketsImpl(node);\n\n    // GSP-specific Element types\n    if (GROOVY_EXPR_CODE.equals(elem)) return new GrGspExprInjectionImpl();\n    if (GROOVY_DECLARATION.equals(elem)) return new GrGspDeclarationHolderImpl();\n\n    if (GSP_CLASS.equals(elem)) return new GrGspClassImpl(node);\n    if (GSP_RUN_METHOD.equals(elem)) return new GrGspRunMethodImpl(node);\n    if (GSP_RUN_BLOCK.equals(elem)) return new GrGspRunBlockImpl(node);\n\n    return new ASTWrapperPsiElement(node);\n  }","id":73350,"modified_method":"/**\n   * Creates Groovy PSI element by given AST node\n   *\n   * @param node Given node\n   * @return Respective PSI element\n   */\n  public static PsiElement createElement(ASTNode node) {\n    IElementType elem = node.getElementType();\n\n    if (elem instanceof IGroovyDocElementType) {\n      return GroovyDocPsiCreator.createElement(node);\n    }\n\n    // Groovydoc comment\n    if (elem.equals(GROOVY_DOC_COMMENT)) return new GrDocCommentImpl();\n\n    //Identifiers & literal\n    if (elem.equals(LITERAL)) return new GrLiteralImpl(node);\n    if (elem.equals(LABEL)) return new GrLabelImpl(node);\n\n    //Lists, maps etc...\n    if (elem.equals(LIST_OR_MAP)) return new GrListOrMapImpl(node);\n\n    if (elem.equals(MODIFIERS)) return new GrModifierListImpl(node);\n    if (elem.equals(ANNOTATION)) return new GrAnnotationImpl(node);\n    if (elem.equals(ANNOTATION_ARGUMENTS)) return new GrAnnotationArgumentListImpl(node);\n    if (elem.equals(ANNOTATION_ARRAY_INITIALIZER)) return new GrAnnotationArrrayInitializerImpl(node);\n    if (elem.equals(ANNOTATION_MEMBER_VALUE_PAIR)) return new GrAnnotationNameValuePairImpl(node);\n    if (elem.equals(ANNOTATION_MEMBER_VALUE_PAIRS)) return new GrAnnotationNameValuePairsImpl(node);\n\n    if (elem.equals(DEFAULT_ANNOTATION_VALUE)) return new GrDefaultAnnotationValueImpl(node);\n\n    //throws\n    if (elem.equals(THROW_CLAUSE)) return new GrThrowsClauseImpl(node);\n\n    // Imports\n    if (elem.equals(IMPORT_STATEMENT)) return new GrImportStatementImpl(node);\n\n    // Packaging\n    if (elem.equals(PACKAGE_DEFINITION)) return new GrPackageDefinitionImpl(node);\n\n    //statements\n    if (elem.equals(LABELED_STATEMENT)) return new GrLabeledStatementImpl(node);\n    if (elem.equals(IF_STATEMENT)) return new GrIfStatementImpl(node);\n    if (elem.equals(FOR_STATEMENT)) return new GrForStatementImpl(node);\n    if (elem.equals(FOR_IN_CLAUSE)) return new GrForInClauseImpl(node);\n    if (elem.equals(FOR_TRADITIONAL_CLAUSE)) return new GrTraditionalForClauseImpl(node);\n    if (elem.equals(WHILE_STATEMENT)) return new GrWhileStatementImpl(node);\n    if (elem.equals(TRY_BLOCK_STATEMENT)) return new GrTryCatchStatementImpl(node);\n    if (elem.equals(CATCH_CLAUSE)) return new GrCatchClauseImpl(node);\n    if (elem.equals(FINALLY_CLAUSE)) return new GrFinallyClauseImpl(node);\n    if (elem.equals(SYNCHRONIZED_STATEMENT)) return new GrSynchronizedStatementImpl(node);\n    if (elem.equals(SWITCH_STATEMENT)) return new GrSwitchStatementImpl(node);\n    if (elem.equals(CASE_LABEL)) return new GrCaseLabelImpl(node);\n    if (elem.equals(CASE_SECTION)) return new GrCaseSectionImpl(node);\n    if (elem.equals(VARIABLE_DEFINITION) || elem.equals(VARIABLE_DEFINITION_ERROR))\n      return new GrVariableDeclarationImpl(node);\n    if (elem.equals(MULTIPLE_VARIABLE_DEFINITION))\n      return new GrMultipleVariableDeclarationImpl(node);\n    if (elem.equals(TUPLE) || elem.equals(TUPLE_ERROR)) return new GrTupleImpl(node);\n    if (elem.equals(VARIABLE)) return new GrVariableImpl(node);\n\n    if (elem.equals(FIELD)) return new GrFieldImpl(node);\n    if (elem.equals(CLASS_INITIALIZER)) return new GrClassInitializerImpl(node);\n\n    //type definitions\n    if (elem.equals(CLASS_DEFINITION)) return new GrClassDefinitionImpl(node);\n    if (elem.equals(INTERFACE_DEFINITION))\n      return new GrInterfaceDefinitionImpl(node);\n    if (elem.equals(ENUM_DEFINITION)) return new GrEnumTypeDefinitionImpl(node);\n    if (elem.equals(ANNOTATION_DEFINITION))\n      return new GrAnnotationTypeDefinitionImpl(node);\n    if (elem.equals(ANNOTATION_METHOD)) return new GrAnnotationMethodImpl(node);\n\n    if (elem.equals(REFERENCE_ELEMENT)) return new GrCodeReferenceElementImpl(node);\n    if (elem.equals(CLASS_TYPE_ELEMENT)) return new GrClassTypeElementImpl(node);\n\n    //clauses\n    if (elem.equals(IMPLEMENTS_CLAUSE)) return new GrImplementsClauseImpl(node);\n    if (elem.equals(EXTENDS_CLAUSE)) return new GrExtendsClauseImpl(node);\n\n    //bodies\n    if (elem.equals(CLASS_BODY)) return new GrTypeDefinitionBodyImpl(node);\n    if (elem.equals(ENUM_BODY)) return new GrEnumDefinitionBodyImpl(node);\n    if (elem.equals(CLOSABLE_BLOCK)) return new GrClosableBlockImpl(node);\n    if (elem.equals(OPEN_BLOCK)) return new GrOpenBlockImpl(node);\n    if (elem.equals(BLOCK_STATEMENT)) return new GrBlockStatementImpl(node);\n    if (elem.equals(EXPLICIT_CONSTRUCTOR)) return new GrConstructorInvocationImpl(node);\n\n    //enum\n    if (elem.equals(ENUM_CONSTANTS)) return new GrEnumConstantListImpl(node);\n    if (elem.equals(ENUM_CONSTANT)) return new GrEnumConstantImpl(node);\n\n    //members\n    if (elem.equals(CONSTRUCTOR_DEFINITION)) return new GrConstructorImpl(node);\n    if (elem.equals(METHOD_DEFINITION)) return new GrMethodImpl(node);\n\n    //parameters\n    if (elem.equals(PARAMETERS_LIST)) return new GrParameterListImpl(node);\n    if (elem.equals(PARAMETER)) return new GrParameterImpl(node);\n\n    //type parameters\n    if (elem.equals(TYPE_ARGUMENT)) return new GrWildcardTypeArgumentImpl(node);\n    if (elem.equals(TYPE_ARGUMENTS)) return new GrTypeArgumentListImpl(node);\n\n\n    if (elem.equals(TYPE_PARAMETER_LIST)) return new GrTypeParameterListImpl(node);\n    if (elem.equals(TYPE_PARAMETER)) return new GrTypeParameterImpl(node);\n    if (elem.equals(TYPE_PARAMETER_EXTENDS_BOUND_LIST)) return new GrTypeParameterParameterExtendsListImpl(node);\n\n    //Branch statements\n    if (elem.equals(RETURN_STATEMENT)) return new GrReturnStatementImpl(node);\n    if (elem.equals(THROW_STATEMENT)) return new GrThrowStatementImpl(node);\n    if (elem.equals(ASSERT_STATEMENT)) return new GrAssertStatementImpl(node);\n    if (elem.equals(BREAK_STATEMENT)) return new GrBreakStatementImpl(node);\n    if (elem.equals(CONTINUE_STATEMENT)) return new GrContinueStatementImpl(node);\n\n    //expressions\n    if (elem.equals(CALL_EXPRESSION)) return new GrApplicationStatementImpl(node);\n    if (elem.equals(COMMAND_ARGUMENTS)) return new GrCommandArgumentListImpl(node);\n    if (elem.equals(CONDITIONAL_EXPRESSION)) return new GrConditionalExprImpl(node);\n    if (elem.equals(ELVIS_EXPRESSION)) return new GrElvisExprImpl(node);\n    if (elem.equals(ASSIGNMENT_EXPRESSION)) return new GrAssignmentExpressionImpl(node);\n    if (elem.equals(LOGICAL_OR_EXPRESSION)) return new GrLogicalOrExpressionImpl(node);\n    if (elem.equals(LOGICAL_AND_EXPRESSION)) return new GrLogicalAndExpressionImpl(node);\n    if (elem.equals(EXCLUSIVE_OR_EXPRESSION)) return new GrExclusiveOrExpressionImpl(node);\n    if (elem.equals(INCLUSIVE_OR_EXPRESSION)) return new GrInclusiveOrExpressionImpl(node);\n    if (elem.equals(AND_EXPRESSION)) return new GrAndExpressionImpl(node);\n    if (elem.equals(REGEX_MATCH_EXPRESSION)) return new GrRegexMatchExpressionImpl(node);\n    if (elem.equals(REGEX_FIND_EXPRESSION)) return new GrRegexFindExpressionImpl(node);\n    if (elem.equals(EQUALITY_EXPRESSION)) return new GrEqualityExpressionImpl(node);\n    if (elem.equals(RELATIONAL_EXPRESSION)) return new GrRelationalExpressionImpl(node);\n    if (elem.equals(SHIFT_EXPRESSION)) return new GrShiftExpressionImpl(node);\n    if (elem.equals(RANGE_EXPRESSION)) return new GrRangeExpressionImpl(node);\n    if (elem.equals(COMPOSITE_SHIFT_SIGN)) return new GrOperationSignImpl(node);\n    if (elem.equals(ADDITIVE_EXPRESSION)) return new GrAdditiveExpressionImpl(node);\n    if (elem.equals(MULTIPLICATIVE_EXPRESSION)) return new GrMultiplicativeExpressionImpl(node);\n    if (elem.equals(POWER_EXPRESSION)) return new GrPowerExpressionImpl(node);\n    if (elem.equals(POWER_EXPRESSION_SIMPLE)) return new GrPowerExpressionImpl(node);\n    if (elem.equals(UNARY_EXPRESSION)) return new GrUnaryExpressionImpl(node);\n    if (elem.equals(POSTFIX_EXPRESSION)) return new GrPostfixExprImpl(node);\n    if (elem.equals(CAST_EXPRESSION)) return new GrTypeCastExpressionImpl(node);\n    if (elem.equals(SAFE_CAST_EXPRESSION)) return new GrSafeCastExpressionImpl(node);\n    if (elem.equals(INSTANCEOF_EXPRESSION)) return new GrInstanceofExpressionImpl(node);\n    if (elem.equals(BUILT_IN_TYPE_EXPRESSION)) return new GrBuiltinTypeClassExpressionImpl(node);\n    if (elem.equals(ARRAY_TYPE)) return new GrArrayTypeElementImpl(node);\n    if (elem.equals(BUILT_IN_TYPE)) return new GrBuiltInTypeElementImpl(node);\n    if (elem.equals(GSTRING)) return new GrStringImpl(node);\n    if (elem.equals(REGEX)) return new GrRegexImpl(node);\n    if (elem.equals(REFERENCE_EXPRESSION)) return new GrReferenceExpressionImpl(node);\n    if (elem.equals(THIS_REFERENCE_EXPRESSION)) return new GrThisReferenceExpressionImpl(node);\n    if (elem.equals(SUPER_REFERENCE_EXPRESSION)) return new GrSuperReferenceExpressionImpl(node);\n    if (elem.equals(PARENTHESIZED_EXPRESSION)) return new GrParenthesizedExpressionImpl(node);\n    if (elem.equals(NEW_EXPRESSION)) return new GrNewExpressionImpl(node);\n    if (elem.equals(ARRAY_DECLARATOR)) return new GrArrayDeclarationImpl(node);\n\n    //Paths\n    if (elem.equals(PATH_PROPERTY)) return new GrPropertySelectorImpl(node);\n    if (elem.equals(PATH_PROPERTY_REFERENCE)) return new GrPropertySelectionImpl(node);\n    if (elem.equals(PATH_METHOD_CALL)) return new GrMethodCallExpressionImpl(node);\n    if (elem.equals(PATH_INDEX_PROPERTY)) return new GrIndexPropertyImpl(node);\n\n    // Arguments\n    if (elem.equals(ARGUMENTS)) return new GrArgumentListImpl(node);\n    if (elem.equals(ARGUMENT)) return new GrNamedArgumentImpl(node);\n    if (elem.equals(ARGUMENT_LABEL)) return new GrArgumentLabelImpl(node);\n\n    if (elem.equals(BALANCED_BRACKETS)) return new GrBalancedBracketsImpl(node);\n\n    // GSP-specific Element types\n    if (GROOVY_EXPR_CODE.equals(elem)) return new GrGspExprInjectionImpl();\n    if (GROOVY_DECLARATION.equals(elem)) return new GrGspDeclarationHolderImpl();\n\n    if (GSP_CLASS.equals(elem)) return new GrGspClassImpl(node);\n    if (GSP_RUN_METHOD.equals(elem)) return new GrGspRunMethodImpl(node);\n    if (GSP_RUN_BLOCK.equals(elem)) return new GrGspRunBlockImpl(node);\n\n    return new ASTWrapperPsiElement(node);\n  }","commit_id":"0db72ff82b59bdb84dd5ffff3391e01b02150abf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static IElementType parse(PsiBuilder builder, boolean isInClass, boolean hasModifiers) {\n    return parseDefinitions(builder, isInClass, false, false, false, hasModifiers);\n  }","id":73351,"modified_method":"public static IElementType parse(PsiBuilder builder, boolean isInClass, boolean hasModifiers) {\n    return parseDefinitions(builder, isInClass, false, false, false, hasModifiers, true);\n  }","commit_id":"0db72ff82b59bdb84dd5ffff3391e01b02150abf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static IElementType parseVariableDeclarator(PsiBuilder builder, boolean isInClass) {\n    PsiBuilder.Marker varAssMarker = builder.mark();\n    if (ParserUtils.getToken(builder, mIDENT)) {\n      parseAssignment(builder);\n      if (isInClass) {\n        varAssMarker.done(FIELD);\n        return FIELD;\n      } else {\n        varAssMarker.done(VARIABLE);\n        return VARIABLE;\n      }\n    } else {\n      varAssMarker.drop();\n      return WRONGWAY;\n    }\n  }","id":73352,"modified_method":"private static IElementType parseDeclarator(PsiBuilder builder, boolean inClass, boolean isTuple, boolean hasModifiers) {\n    if (!isTuple) {\n      if (builder.getTokenType() == mIDENT) {\n        ParserUtils.getToken(builder, mIDENT);\n        return mIDENT;\n      } else {\n        return WRONGWAY;\n      }\n    } else if (ParserUtils.getToken(builder, mLPAREN)) {\n      PsiBuilder.Marker tupleMarker = builder.mark();\n\n      final PsiBuilder.Marker firstVarMarker = builder.mark();\n      if (!ParserUtils.getToken(builder, mIDENT)) {\n        tupleMarker.drop();\n        firstVarMarker.drop();\n        return WRONGWAY;\n      } else {\n        firstVarMarker.done(VARIABLE);\n      }\n\n      while (!builder.eof() && builder.getTokenType() != mRPAREN && builder.getTokenType() != mASSIGN) {\n        if (!ParserUtils.getToken(builder, mCOMMA)) {\n          builder.error(GroovyBundle.message(\"comma.expected\"));\n\n          if (!hasModifiers) {\n            tupleMarker.drop();\n            return WRONGWAY;\n          }\n\n        } else {\n          PsiBuilder.Marker varMarker = builder.mark();\n          if (!ParserUtils.getToken(builder, mIDENT)) {\n            builder.error(GroovyBundle.message(\"identifier.expected\"));\n            varMarker.drop();\n          } else {\n            varMarker.done(VARIABLE);\n          }                             \n        }\n      }\n\n      if (ParserUtils.getToken(builder, mRPAREN)) {\n        if (builder.getTokenType() != mASSIGN) {\n          if (!hasModifiers) {\n            tupleMarker.drop();\n            return WRONGWAY;\n          }\n        }\n        tupleMarker.done(TUPLE);\n        return TUPLE;\n      }\n\n      if (builder.getTokenType() == mASSIGN) {\n        builder.error(\"rparen.expected\");\n        tupleMarker.done(TUPLE_ERROR);\n        return TUPLE_ERROR;\n      }\n\n      tupleMarker.drop();\n      return WRONGWAY;\n    } else {\n      return WRONGWAY;\n    }\n  }","commit_id":"0db72ff82b59bdb84dd5ffff3391e01b02150abf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static IElementType parseDefinitions(PsiBuilder builder,\n                                                   boolean isInClass,\n                                                   boolean isEnumConstantMember,\n                                                   boolean isAnnotationMember,\n                                                   boolean mustBeMethod,\n                                                   boolean hasModifiers) {\n    if (!(builder.getTokenType() == mIDENT || builder.getTokenType() == mSTRING_LITERAL || builder.getTokenType() == mGSTRING_LITERAL)) {\n      builder.error(GroovyBundle.message(\"indentifier.or.string.literal.expected\"));\n      return WRONGWAY;\n    }\n\n    PsiBuilder.Marker varMarker = builder.mark();\n    boolean isStringName = builder.getTokenType() == mSTRING_LITERAL || builder.getTokenType() == mGSTRING_LITERAL;\n\n    if (isAnnotationMember && isStringName) {\n      builder.error(GroovyBundle.message(\"string.name.unexpected\"));\n    }\n\n    //eaten one of these tokens\n    boolean eaten = ParserUtils.getToken(builder, mIDENT) || ParserUtils.getToken(builder, mSTRING_LITERAL) || ParserUtils.getToken(builder, mGSTRING_LITERAL);\n\n    if (!eaten) return WRONGWAY;\n\n    if (mustBeMethod && mLPAREN != builder.getTokenType()) {\n      varMarker.drop();\n      return WRONGWAY;\n    }\n\n    if (!hasModifiers && mLPAREN == builder.getTokenType()) {\n      builder.error(GroovyBundle.message(\"method.definition.without.modifier\"));\n      varMarker.drop();\n      return WRONGWAY;\n    }\n\n    if (ParserUtils.getToken(builder, mLPAREN)) {\n      ParameterList.parse(builder, mRPAREN);\n\n      if (isEnumConstantMember && !isStringName) {\n        builder.error(GroovyBundle.message(\"string.name.unexpected\"));\n      }\n\n      ParserUtils.getToken(builder, mNLS);\n      if (!ParserUtils.getToken(builder, mRPAREN)) {\n        builder.error(GroovyBundle.message(\"rparen.expected\"));\n        varMarker.drop();\n        ThrowClause.parse(builder);\n        return METHOD_DEFINITION;\n      }\n\n      varMarker.drop();\n      if (builder.getTokenType() == kDEFAULT) {\n        PsiBuilder.Marker defaultValueMarker = builder.mark();\n        ParserUtils.getToken(builder, GroovyTokenTypes.kDEFAULT);\n        ParserUtils.getToken(builder, GroovyTokenTypes.mNLS);\n\n        if (!AnnotationArguments.parseAnnotationMemberValueInitializer(builder)) {\n          builder.error(GroovyBundle.message(\"annotation.initializer.expected\"));\n        }\n\n        defaultValueMarker.done(DEFAULT_ANNOTATION_VALUE);\n        return ANNOTATION_METHOD;\n      }\n      if (ParserUtils.lookAhead(builder, mNLS, kTHROWS) || ParserUtils.lookAhead(builder, mNLS, mLCURLY)) {\n        ParserUtils.getToken(builder, mNLS);\n      }\n\n      ThrowClause.parse(builder);\n\n      if (builder.getTokenType() == mLCURLY || ParserUtils.lookAhead(builder, mNLS, mLCURLY)) {\n        ParserUtils.getToken(builder, mNLS);\n        OpenOrClosableBlock.parseOpenBlock(builder);\n      }\n\n//      if (isAnnotationMember && !NONE.equals(paramDeclList) && OPEN_BLOCK.equals(openBlock)) {\n//        builder.error(GroovyBundle.message(\"empty.parameter.list.expected\"));\n//      }\n\n      return METHOD_DEFINITION;\n    } else {\n      varMarker.rollbackTo();\n\n      // a = b, c = d\n      PsiBuilder.Marker varAssMarker = builder.mark();\n      if (ParserUtils.getToken(builder, mIDENT)) {\n\n        if (parseAssignment(builder)) { // a = b, c = d\n          if (isInClass) {\n            varAssMarker.done(FIELD);\n          } else {\n            varAssMarker.done(VARIABLE);\n          }\n\n          while (ParserUtils.getToken(builder, mCOMMA)) {\n            ParserUtils.getToken(builder, mNLS);\n\n            if (WRONGWAY.equals(parseVariableDeclarator(builder, isInClass)))\n              return VARIABLE_DEFINITION_ERROR; //parse b = d\n          }\n          return VARIABLE_DEFINITION;\n        } else {\n          if (isInClass) {\n            varAssMarker.done(FIELD);\n          } else {\n            varAssMarker.done(VARIABLE);\n          }\n//          varAssMarker.drop();\n          while (ParserUtils.getToken(builder, mCOMMA)) {// a, b = d, c = d\n            ParserUtils.getToken(builder, mNLS);\n            if (WRONGWAY.equals(parseVariableDeclarator(builder, isInClass))) return VARIABLE_DEFINITION_ERROR;\n          }\n\n          return VARIABLE_DEFINITION;\n        }\n      } else {\n        varAssMarker.drop();\n        builder.error(GroovyBundle.message(\"identifier.expected\"));\n        return VARIABLE_DEFINITION_ERROR;\n      }\n\n    }\n  }","id":73353,"modified_method":"public static IElementType parseDefinitions(PsiBuilder builder,\n                                              boolean isInClass,\n                                              boolean isEnumConstantMember,\n                                              boolean isAnnotationMember,\n                                              boolean mustBeMethod,\n                                              boolean hasModifiers,\n                                              boolean canBeTuple) {\n    if (builder.getTokenType() == mLPAREN && !canBeTuple) {\n      builder.error(GroovyBundle.message(\"indentifier.or.string.or.left.parenth.literal.expected\"));\n      return WRONGWAY;\n    }\n\n    if (!(builder.getTokenType() == mIDENT ||\n          builder.getTokenType() == mSTRING_LITERAL ||\n          builder.getTokenType() == mGSTRING_LITERAL ||\n          builder.getTokenType() == mLPAREN)) {\n      builder.error(GroovyBundle.message(\"indentifier.or.string.or.left.parenth.literal.expected\"));\n      return WRONGWAY;\n    }\n\n    PsiBuilder.Marker varMarker = builder.mark();\n    boolean isStringName = builder.getTokenType() == mSTRING_LITERAL || builder.getTokenType() == mGSTRING_LITERAL;\n\n    if (isAnnotationMember && isStringName) {\n      builder.error(GroovyBundle.message(\"string.name.unexpected\"));\n    }\n\n    //eaten one of these tokens\n    boolean isTuple = builder.getTokenType() == mLPAREN;\n    boolean eaten = ParserUtils.getToken(builder, mIDENT) ||\n                    ParserUtils.getToken(builder, mSTRING_LITERAL) ||\n                    ParserUtils.getToken(builder, mGSTRING_LITERAL) ||\n                    ParserUtils.getToken(builder, mLPAREN);\n\n    if (!eaten && !isTuple) return WRONGWAY;\n\n    if (mustBeMethod && mLPAREN != builder.getTokenType()) {\n      varMarker.drop();\n      return WRONGWAY;\n    }\n\n    if (!hasModifiers && mLPAREN == builder.getTokenType()) {\n      builder.error(GroovyBundle.message(\"method.definition.without.modifier\"));\n      varMarker.drop();\n      return WRONGWAY;\n    }\n\n    if (ParserUtils.getToken(builder, mLPAREN)) {\n      ParameterList.parse(builder, mRPAREN);\n\n      if (isEnumConstantMember && !isStringName) {\n        builder.error(GroovyBundle.message(\"string.name.unexpected\"));\n      }\n\n      ParserUtils.getToken(builder, mNLS);\n      if (!ParserUtils.getToken(builder, mRPAREN)) {\n        builder.error(GroovyBundle.message(\"rparen.expected\"));\n        varMarker.drop();\n        ThrowClause.parse(builder);\n        return METHOD_DEFINITION;\n      }\n\n      varMarker.drop();\n      if (builder.getTokenType() == kDEFAULT) {\n        PsiBuilder.Marker defaultValueMarker = builder.mark();\n        ParserUtils.getToken(builder, GroovyTokenTypes.kDEFAULT);\n        ParserUtils.getToken(builder, GroovyTokenTypes.mNLS);\n\n        if (!AnnotationArguments.parseAnnotationMemberValueInitializer(builder)) {\n          builder.error(GroovyBundle.message(\"annotation.initializer.expected\"));\n        }\n\n        defaultValueMarker.done(DEFAULT_ANNOTATION_VALUE);\n        return ANNOTATION_METHOD;\n      }\n      if (ParserUtils.lookAhead(builder, mNLS, kTHROWS) || ParserUtils.lookAhead(builder, mNLS, mLCURLY)) {\n        ParserUtils.getToken(builder, mNLS);\n      }\n\n      ThrowClause.parse(builder);\n\n      if (builder.getTokenType() == mLCURLY || ParserUtils.lookAhead(builder, mNLS, mLCURLY)) {\n        ParserUtils.getToken(builder, mNLS);\n        OpenOrClosableBlock.parseOpenBlock(builder);\n      }\n\n//      if (isAnnotationMember && !NONE.equals(paramDeclList) && OPEN_BLOCK.equals(openBlock)) {\n//        builder.error(GroovyBundle.message(\"empty.parameter.list.expected\"));\n//      }\n\n      return METHOD_DEFINITION;\n    } else {\n      varMarker.rollbackTo();\n\n      // a = b, c = d\n      PsiBuilder.Marker varAssMarker = builder.mark();\n\n      final IElementType declarator = parseDeclarator(builder, isInClass, isTuple, hasModifiers);\n\n      if (declarator != WRONGWAY) {\n        final boolean wasAssingment = parseAssignment(builder);\n\n        if (declarator == TUPLE) {\n          varAssMarker.drop();\n          if (!wasAssingment && !hasModifiers) {\n            builder.error(GroovyBundle.message(\"assignment.expected\"));\n          }\n        } else if (declarator == mIDENT) { //if (isAssignment) { // a = b, c = d\n          if (isInClass) {\n            varAssMarker.done(FIELD);\n          } else {\n            varAssMarker.done(VARIABLE);\n          }\n        }\n\n        while (ParserUtils.getToken(builder, mCOMMA)) {\n          ParserUtils.getToken(builder, mNLS);\n\n          if (WRONGWAY.equals(parseVariableOrField(builder, isInClass)) && declarator == mIDENT) {\n            return VARIABLE_DEFINITION_ERROR; //parse b = d\n          }\n        }\n\n        if (isInClass && declarator == TUPLE) {\n          builder.error(GroovyBundle.message(\"tuple.cant.be.placed.in.class\"));\n        }\n        return declarator == TUPLE ? MULTIPLE_VARIABLE_DEFINITION : VARIABLE_DEFINITION;\n      } else {\n        varAssMarker.drop();\n        builder.error(GroovyBundle.message(\"identifier.expected\"));\n        return WRONGWAY;\n      }\n    }\n  }","commit_id":"0db72ff82b59bdb84dd5ffff3391e01b02150abf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiType getType() {\n    GrTypeElement typeElement = ((GrVariableDeclarations) getParent()).getTypeElementGroovy();\n    return typeElement == null ?\n        getManager().getElementFactory().createTypeByFQClassName(\"java.lang.Object\", getResolveScope()) :\n        typeElement.getType();\n  }","id":73354,"modified_method":"@NotNull\n  public PsiType getType() {\n    PsiElement parent = getParent();\n    GrTypeElement typeElement = parent instanceof GrParameter ? ((GrParameter) parent).getTypeElementGroovy() : ((GrVariableDeclarations) parent).getTypeElementGroovy();\n    return typeElement == null ?\n        getManager().getElementFactory().createTypeByFQClassName(\"java.lang.Object\", getResolveScope()) :\n        typeElement.getType();\n  }","commit_id":"9d4476aaa15a92b8263f40ebadae17b0b2c7c2e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public GrTypeElement getTypeElementGroovy() {\n    PsiElement parent = getParent();\n    return parent instanceof GrTupleDeclaration ? null : ((GrVariableDeclaration)parent).getTypeElementGroovy();\n  }","id":73355,"modified_method":"@Nullable\n  public GrTypeElement getTypeElementGroovy() {\n    PsiElement parent = getParent();\n    if (parent instanceof GrTupleDeclaration || !(parent instanceof GrVariableDeclaration)) {\n      return null;\n    }\n    else {\n      return ((GrVariableDeclaration)parent).getTypeElementGroovy();\n    }\n  }","commit_id":"bc4320a4928b5915c78e9ea9bb53aadcd3443fb6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void delete() throws IncorrectOperationException {\n    PsiElement parent = getParent();\n    PsiElement prev = PsiUtil.getPrevNonSpace(this);\n    PsiElement next = PsiUtil.getNextNonSpace(this);\n    ASTNode parentNode = parent.getNode();\n    assert parentNode != null;\n    if (parentNode != null) {\n      parentNode.removeChild(getNode());\n    }\n    if (prev != null && prev.getNode() != null && prev.getNode().getElementType() == GroovyTokenTypes.mCOMMA) {\n      parentNode.removeChild(prev.getNode());\n    } else if (next instanceof LeafPsiElement && next.getNode() != null && next.getNode().getElementType() == GroovyTokenTypes.mCOMMA) {\n      next.delete();\n    }\n    if (parent instanceof GrVariableDeclaration && ((GrVariableDeclaration)parent).getVariables().length == 0) {\n      parent.delete();\n    }\n  }","id":73356,"modified_method":"@Override\n  public void delete() throws IncorrectOperationException {\n    PsiElement parent = getParent();\n    PsiElement prev = PsiUtil.getPrevNonSpace(this);\n    PsiElement next = PsiUtil.getNextNonSpace(this);\n    ASTNode parentNode = parent.getNode();\n    assert parentNode != null;\n    parentNode.removeChild(getNode());\n    if (prev != null && prev.getNode() != null && prev.getNode().getElementType() == GroovyTokenTypes.mCOMMA) {\n      parentNode.removeChild(prev.getNode());\n    } else if (next instanceof LeafPsiElement && next.getNode() != null && next.getNode().getElementType() == GroovyTokenTypes.mCOMMA) {\n      next.delete();\n    }\n    if (parent instanceof GrVariableDeclaration && ((GrVariableDeclaration)parent).getVariables().length == 0) {\n      parent.delete();\n    }\n  }","commit_id":"bc4320a4928b5915c78e9ea9bb53aadcd3443fb6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public <T> T run(Class<T> type, ConsumerOperationParameters operationParameters) throws UnsupportedOperationException, IllegalStateException {\n        if (type.equals(Void.class)) {\n            doRunBuild(operationParameters);\n            return null;\n        } else {\n            Class<?> protocolType = getVersionDetails().mapModelTypeToProtocolType(type);\n            Object model = doGetModel(protocolType, operationParameters);\n            return adapter.adapt(type, model, new ConsumerPropertyHandler(getVersionDetails()));\n        }\n    }","id":73357,"modified_method":"public <T> T run(Class<T> type, ConsumerOperationParameters operationParameters) throws UnsupportedOperationException, IllegalStateException {\n        if (type.equals(Void.class)) {\n            doRunBuild(operationParameters);\n            return null;\n        } else {\n            Class<?> protocolType = getVersionDetails().mapModelTypeToProtocolType(type);\n            Object model = doGetModel(protocolType, operationParameters);\n            return adapter.adapt(type, model, new PropertyHandlerFactory().forVersion(getVersionDetails()));\n        }\n    }","commit_id":"deec0fb0da85bbc28bc32efd6c1bba231eb113b7","url":"https://github.com/gradle/gradle"},{"original_method":"public <T> T run(Class<T> type, ConsumerOperationParameters operationParameters) throws UnsupportedOperationException, IllegalStateException {\n        Class<?> protocolType = getVersionDetails().mapModelTypeToProtocolType(type);\n        Object model = buildActionRunner.run(protocolType, operationParameters).getModel();\n        return adapter.adapt(type, model, new ConsumerPropertyHandler(getVersionDetails()));\n    }","id":73358,"modified_method":"public <T> T run(Class<T> type, ConsumerOperationParameters operationParameters) throws UnsupportedOperationException, IllegalStateException {\n        Class<?> protocolType = getVersionDetails().mapModelTypeToProtocolType(type);\n        Object model = buildActionRunner.run(protocolType, operationParameters).getModel();\n        return adapter.adapt(type, model, new PropertyHandlerFactory().forVersion(getVersionDetails()));\n    }","commit_id":"deec0fb0da85bbc28bc32efd6c1bba231eb113b7","url":"https://github.com/gradle/gradle"},{"original_method":"public <T> T run(Class<T> type, ConsumerOperationParameters operationParameters) throws UnsupportedOperationException, IllegalStateException {\n        ModelIdentifier modelIdentifier = getVersionDetails().mapModelTypeToModelIdentifier(type);\n        Object model = builder.getModel(modelIdentifier, operationParameters).getModel();\n        return adapter.adapt(type, model, new ConsumerPropertyHandler(getVersionDetails()));\n    }","id":73359,"modified_method":"public <T> T run(Class<T> type, ConsumerOperationParameters operationParameters) throws UnsupportedOperationException, IllegalStateException {\n        ModelIdentifier modelIdentifier = getVersionDetails().mapModelTypeToModelIdentifier(type);\n        Object model = builder.getModel(modelIdentifier, operationParameters).getModel();\n        return adapter.adapt(type, model, new PropertyHandlerFactory().forVersion(getVersionDetails()));\n    }","commit_id":"deec0fb0da85bbc28bc32efd6c1bba231eb113b7","url":"https://github.com/gradle/gradle"},{"original_method":"public InvocationHandlerImpl(Object delegate, MethodInvoker overrideMethodInvoker) {\n            this.delegate = delegate;\n            invoker = new SupportedPropertyInvoker(\n                    new SafeMethodInvoker(\n                            new PropertyCachingMethodInvoker(\n                                    new ChainedMethodInvoker(\n                                            overrideMethodInvoker,\n                                            new ReflectionMethodInvoker(overrideMethodInvoker)))));\n            try {\n                equalsMethod = Object.class.getMethod(\"equals\", Object.class);\n                hashCodeMethod = Object.class.getMethod(\"hashCode\");\n            } catch (NoSuchMethodException e) {\n                throw UncheckedException.throwAsUncheckedException(e);\n            }\n        }","id":73360,"modified_method":"public InvocationHandlerImpl(Object delegate, MethodInvoker overrideMethodInvoker) {\n            this.delegate = delegate;\n            this.overrideMethodInvoker = overrideMethodInvoker;\n            setup();\n        }","commit_id":"deec0fb0da85bbc28bc32efd6c1bba231eb113b7","url":"https://github.com/gradle/gradle"},{"original_method":"public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n\t\tif (_dynamicDataSourceTargetSource == null) {\n\t\t\treturn super.invoke(methodInvocation);\n\t\t}\n\n\t\tClass<?> targetClass = null;\n\n\t\tif (methodInvocation.getThis() != null) {\n\t\t\ttargetClass = methodInvocation.getThis().getClass();\n\t\t}\n\n\t\tMethod targetMethod = methodInvocation.getMethod();\n\n\t\tTransactionAttributeSource transactionAttributeSource =\n\t\t\tgetTransactionAttributeSource();\n\n\t\tTransactionAttribute transactionAttribute =\n\t\t\ttransactionAttributeSource.getTransactionAttribute(\n\t\t\t\ttargetMethod, targetClass);\n\n\t\tif ((transactionAttribute != null) &&\n\t\t\t(transactionAttribute.isReadOnly())) {\n\n\t\t\t_dynamicDataSourceTargetSource.setOperation(Operation.READ);\n\t\t}\n\t\telse {\n\t\t\t_dynamicDataSourceTargetSource.setOperation(Operation.WRITE);\n\t\t}\n\n\t\t_dynamicDataSourceTargetSource.pushMethod(\n\t\t\ttargetClass.getName().concat(StringPool.PERIOD).concat(\n\t\t\t\ttargetMethod.getName()));\n\n\t\tObject returnValue = null;\n\n\t\ttry {\n\t\t\treturnValue = super.invoke(methodInvocation);\n\t\t}\n\t\tfinally {\n\t\t\t_dynamicDataSourceTargetSource.popMethod();\n\t\t}\n\n\t\treturn returnValue;\n\t}","id":73361,"modified_method":"public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n\t\tif (_dynamicDataSourceTargetSource == null) {\n\t\t\treturn super.invoke(methodInvocation);\n\t\t}\n\n\t\tClass<?> targetClass = null;\n\n\t\tif (methodInvocation.getThis() != null) {\n\t\t\tObject targetBean = methodInvocation.getThis();\n\n\t\t\ttargetClass = targetBean.getClass();\n\t\t}\n\n\t\tMethod targetMethod = methodInvocation.getMethod();\n\n\t\tTransactionAttributeSource transactionAttributeSource =\n\t\t\tgetTransactionAttributeSource();\n\n\t\tTransactionAttribute transactionAttribute =\n\t\t\ttransactionAttributeSource.getTransactionAttribute(\n\t\t\t\ttargetMethod, targetClass);\n\n\t\tif ((transactionAttribute != null) &&\n\t\t\t(transactionAttribute.isReadOnly())) {\n\n\t\t\t_dynamicDataSourceTargetSource.setOperation(Operation.READ);\n\t\t}\n\t\telse {\n\t\t\t_dynamicDataSourceTargetSource.setOperation(Operation.WRITE);\n\t\t}\n\n\t\t_dynamicDataSourceTargetSource.pushMethod(\n\t\t\ttargetClass.getName().concat(StringPool.PERIOD).concat(\n\t\t\t\ttargetMethod.getName()));\n\n\t\tObject returnValue = null;\n\n\t\ttry {\n\t\t\treturnValue = super.invoke(methodInvocation);\n\t\t}\n\t\tfinally {\n\t\t\t_dynamicDataSourceTargetSource.popMethod();\n\t\t}\n\n\t\treturn returnValue;\n\t}","commit_id":"b51a731b5210dc9858db4a1b31bb2d9e8acfb3a9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Indexer getIndexer(Class<?> classObj) {\n\t\treturn getIndexerRegistry().getIndexer(classObj.getName());\n\t}","id":73362,"modified_method":"public static Indexer getIndexer(Class<?> clazz) {\n\t\treturn getIndexerRegistry().getIndexer(clazz.getName());\n\t}","commit_id":"b51a731b5210dc9858db4a1b31bb2d9e8acfb3a9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static <T> LinkedHashMap<String, T> toLinkedHashMap(\n\t\tString[] params, String delimiter) {\n\n\t\tLinkedHashMap<String, Object> map = new LinkedHashMap<String, Object>();\n\n\t\tfor (int i = 0; i < params.length; i++) {\n\t\t\tString[] kvp = StringUtil.split(params[i], delimiter);\n\n\t\t\tif (kvp.length == 2) {\n\t\t\t\tmap.put(kvp[0], kvp[1]);\n\t\t\t}\n\t\t\telse if (kvp.length == 3) {\n\t\t\t\tString type = kvp[2];\n\n\t\t\t\tif (type.equalsIgnoreCase(\"boolean\") ||\n\t\t\t\t\ttype.equals(Boolean.class.getName())) {\n\n\t\t\t\t\tmap.put(kvp[0], new Boolean(kvp[1]));\n\t\t\t\t}\n\t\t\t\telse if (type.equalsIgnoreCase(\"double\") ||\n\t\t\t\t\ttype.equals(Double.class.getName())) {\n\n\t\t\t\t\tmap.put(kvp[0], new Double(kvp[1]));\n\t\t\t\t}\n\t\t\t\telse if (type.equalsIgnoreCase(\"int\") ||\n\t\t\t\t\ttype.equals(Integer.class.getName())) {\n\n\t\t\t\t\tmap.put(kvp[0], new Integer(kvp[1]));\n\t\t\t\t}\n\t\t\t\telse if (type.equalsIgnoreCase(\"long\") ||\n\t\t\t\t\ttype.equals(Long.class.getName())) {\n\n\t\t\t\t\tmap.put(kvp[0], new Long(kvp[1]));\n\t\t\t\t}\n\t\t\t\telse if (type.equalsIgnoreCase(\"short\") ||\n\t\t\t\t\ttype.equals(Short.class.getName())) {\n\n\t\t\t\t\tmap.put(kvp[0], new Short(kvp[1]));\n\t\t\t\t}\n\t\t\t\telse if (type.equals(String.class.getName())) {\n\t\t\t\t\tmap.put(kvp[0], kvp[1]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClass<?> classObj = Class.forName(type);\n\n\t\t\t\t\t\tConstructor<?> constructor = classObj.getConstructor(\n\t\t\t\t\t\t\tnew Class<?>[] {String.class});\n\n\t\t\t\t\t\tmap.put(kvp[0], constructor.newInstance(kvp[1]));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t_log.error(e, e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (LinkedHashMap<String, T>) map;\n\t}","id":73363,"modified_method":"public static <T> LinkedHashMap<String, T> toLinkedHashMap(\n\t\tString[] params, String delimiter) {\n\n\t\tLinkedHashMap<String, Object> map = new LinkedHashMap<String, Object>();\n\n\t\tfor (int i = 0; i < params.length; i++) {\n\t\t\tString[] kvp = StringUtil.split(params[i], delimiter);\n\n\t\t\tif (kvp.length == 2) {\n\t\t\t\tmap.put(kvp[0], kvp[1]);\n\t\t\t}\n\t\t\telse if (kvp.length == 3) {\n\t\t\t\tString type = kvp[2];\n\n\t\t\t\tif (type.equalsIgnoreCase(\"boolean\") ||\n\t\t\t\t\ttype.equals(Boolean.class.getName())) {\n\n\t\t\t\t\tmap.put(kvp[0], new Boolean(kvp[1]));\n\t\t\t\t}\n\t\t\t\telse if (type.equalsIgnoreCase(\"double\") ||\n\t\t\t\t\ttype.equals(Double.class.getName())) {\n\n\t\t\t\t\tmap.put(kvp[0], new Double(kvp[1]));\n\t\t\t\t}\n\t\t\t\telse if (type.equalsIgnoreCase(\"int\") ||\n\t\t\t\t\ttype.equals(Integer.class.getName())) {\n\n\t\t\t\t\tmap.put(kvp[0], new Integer(kvp[1]));\n\t\t\t\t}\n\t\t\t\telse if (type.equalsIgnoreCase(\"long\") ||\n\t\t\t\t\ttype.equals(Long.class.getName())) {\n\n\t\t\t\t\tmap.put(kvp[0], new Long(kvp[1]));\n\t\t\t\t}\n\t\t\t\telse if (type.equalsIgnoreCase(\"short\") ||\n\t\t\t\t\ttype.equals(Short.class.getName())) {\n\n\t\t\t\t\tmap.put(kvp[0], new Short(kvp[1]));\n\t\t\t\t}\n\t\t\t\telse if (type.equals(String.class.getName())) {\n\t\t\t\t\tmap.put(kvp[0], kvp[1]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClass<?> clazz = Class.forName(type);\n\n\t\t\t\t\t\tConstructor<?> constructor = clazz.getConstructor(\n\t\t\t\t\t\t\tnew Class<?>[] {String.class});\n\n\t\t\t\t\t\tmap.put(kvp[0], constructor.newInstance(kvp[1]));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t_log.error(e, e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (LinkedHashMap<String, T>) map;\n\t}","commit_id":"b51a731b5210dc9858db4a1b31bb2d9e8acfb3a9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void remove(Class<?> classObj) {\n\t\t_instance._remove(classObj);\n\t}","id":73364,"modified_method":"public static void remove(Class<?> clazz) {\n\t\t_instance._remove(clazz);\n\t}","commit_id":"b51a731b5210dc9858db4a1b31bb2d9e8acfb3a9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Method _get(\n\t\t\tMap<String, Class<?>> classesMap, Map<MethodKey, Method> methodsMap,\n\t\t\tMethodKey methodKey)\n\t\tthrows ClassNotFoundException, NoSuchMethodException {\n\n\t\tif (classesMap == null) {\n\t\t\tclassesMap = _classesMap;\n\t\t}\n\n\t\tif (methodsMap == null) {\n\t\t\tmethodsMap = _methodsMap;\n\t\t}\n\n\t\tMethod method = methodsMap.get(methodKey);\n\n\t\tif (method == null) {\n\t\t\tString className = methodKey.getClassName();\n\t\t\tString methodName = methodKey.getMethodName();\n\t\t\tClass<?>[] parameterTypes = methodKey.getParameterTypes();\n\n\t\t\tClass<?> classObj = classesMap.get(className);\n\n\t\t\tif (classObj == null) {\n\t\t\t\tThread currentThread = Thread.currentThread();\n\n\t\t\t\tClassLoader contextClassLoader =\n\t\t\t\t\tcurrentThread.getContextClassLoader();\n\n\t\t\t\tclassObj = contextClassLoader.loadClass(className);\n\n\t\t\t\tclassesMap.put(className, classObj);\n\t\t\t}\n\n\t\t\tmethod = classObj.getMethod(methodName, parameterTypes);\n\n\t\t\tmethodsMap.put(methodKey, method);\n\t\t}\n\n\t\treturn method;\n\t}","id":73365,"modified_method":"private Method _get(\n\t\t\tMap<String, Class<?>> classesMap, Map<MethodKey, Method> methodsMap,\n\t\t\tMethodKey methodKey)\n\t\tthrows ClassNotFoundException, NoSuchMethodException {\n\n\t\tif (classesMap == null) {\n\t\t\tclassesMap = _classesMap;\n\t\t}\n\n\t\tif (methodsMap == null) {\n\t\t\tmethodsMap = _methodsMap;\n\t\t}\n\n\t\tMethod method = methodsMap.get(methodKey);\n\n\t\tif (method == null) {\n\t\t\tString className = methodKey.getClassName();\n\t\t\tString methodName = methodKey.getMethodName();\n\t\t\tClass<?>[] parameterTypes = methodKey.getParameterTypes();\n\n\t\t\tClass<?> clazz = classesMap.get(className);\n\n\t\t\tif (clazz == null) {\n\t\t\t\tThread currentThread = Thread.currentThread();\n\n\t\t\t\tClassLoader contextClassLoader =\n\t\t\t\t\tcurrentThread.getContextClassLoader();\n\n\t\t\t\tclazz = contextClassLoader.loadClass(className);\n\n\t\t\t\tclassesMap.put(className, clazz);\n\t\t\t}\n\n\t\t\tmethod = clazz.getMethod(methodName, parameterTypes);\n\n\t\t\tmethodsMap.put(methodKey, method);\n\t\t}\n\n\t\treturn method;\n\t}","commit_id":"b51a731b5210dc9858db4a1b31bb2d9e8acfb3a9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _remove(Class<?> classObj) {\n\t\t_classesMap.remove(classObj.getName());\n\n\t\tfor (Method method : classObj.getMethods()) {\n\t\t\t_methodsMap.remove(new MethodKey(method));\n\t\t}\n\t}","id":73366,"modified_method":"private void _remove(Class<?> clazz) {\n\t\t_classesMap.remove(clazz.getName());\n\n\t\tfor (Method method : clazz.getMethods()) {\n\t\t\t_methodsMap.remove(new MethodKey(method));\n\t\t}\n\t}","commit_id":"b51a731b5210dc9858db4a1b31bb2d9e8acfb3a9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Method getDeclaredMethod(\n\t\t\tClass<?> classObj, String name, Class<?> ... parameterTypes)\n\t\tthrows Exception {\n\n\t\tMethod method = classObj.getDeclaredMethod(name, parameterTypes);\n\n\t\tmethod.setAccessible(true);\n\n\t\treturn method;\n\t}","id":73367,"modified_method":"public static Method getDeclaredMethod(\n\t\t\tClass<?> clazz, String name, Class<?> ... parameterTypes)\n\t\tthrows Exception {\n\n\t\tMethod method = clazz.getDeclaredMethod(name, parameterTypes);\n\n\t\tmethod.setAccessible(true);\n\n\t\treturn method;\n\t}","commit_id":"b51a731b5210dc9858db4a1b31bb2d9e8acfb3a9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Field getDeclaredField(Class<?> classObj, String name)\n\t\tthrows Exception {\n\n\t\tField field = classObj.getDeclaredField(name);\n\n\t\tfield.setAccessible(true);\n\n\t\treturn field;\n\t}","id":73368,"modified_method":"public static Field getDeclaredField(Class<?> clazz, String name)\n\t\tthrows Exception {\n\n\t\tField field = clazz.getDeclaredField(name);\n\n\t\tfield.setAccessible(true);\n\n\t\treturn field;\n\t}","commit_id":"b51a731b5210dc9858db4a1b31bb2d9e8acfb3a9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private boolean _detect(String className) {\n\t\ttry {\n\t\t\tClassLoader systemClassLoader =\n\t\t\t\tClassLoader.getSystemClassLoader();\n\n\t\t\tsystemClassLoader.loadClass(className);\n\n\t\t\treturn true;\n\t\t}\n\t\tcatch (ClassNotFoundException cnfe) {\n\t\t\tClass<?> classObj = getClass();\n\n\t\t\tif (classObj.getResource(className) != null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}","id":73369,"modified_method":"private boolean _detect(String className) {\n\t\ttry {\n\t\t\tClassLoader systemClassLoader =\n\t\t\t\tClassLoader.getSystemClassLoader();\n\n\t\t\tsystemClassLoader.loadClass(className);\n\n\t\t\treturn true;\n\t\t}\n\t\tcatch (ClassNotFoundException cnfe) {\n\t\t\tClass<?> clazz = getClass();\n\n\t\t\tif (clazz.getResource(className) != null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}","commit_id":"b51a731b5210dc9858db4a1b31bb2d9e8acfb3a9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object before(MethodInvocation methodInvocation) throws Throwable {\n\t\tif (!_active) {\n\t\t\treturn null;\n\t\t}\n\n\t\tClass<?> classObj = methodInvocation.getThis().getClass();\n\n\t\tClass<?>[] interfaces = classObj.getInterfaces();\n\n\t\tfor (int i = 0; i < interfaces.length; i++) {\n\t\t\tif (interfaces[i].isAssignableFrom(MonitoringProcessor.class)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (!_permissiveMode && !isMonitored(methodInvocation)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tServiceRequestDataSample serviceRequestDataSample =\n\t\t\tnew ServiceRequestDataSample(methodInvocation);\n\n\t\tserviceRequestDataSample.prepare();\n\n\t\t_serviceRequestDataSampleThreadLocal.set(serviceRequestDataSample);\n\n\t\treturn null;\n\t}","id":73370,"modified_method":"public Object before(MethodInvocation methodInvocation) throws Throwable {\n\t\tif (!_active) {\n\t\t\treturn null;\n\t\t}\n\n\t\tObject object = methodInvocation.getThis();\n\n\t\tClass<?> clazz = object.getClass();\n\n\t\tClass<?>[] interfaces = clazz.getInterfaces();\n\n\t\tfor (int i = 0; i < interfaces.length; i++) {\n\t\t\tif (interfaces[i].isAssignableFrom(MonitoringProcessor.class)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (!_permissiveMode && !isMonitored(methodInvocation)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tServiceRequestDataSample serviceRequestDataSample =\n\t\t\tnew ServiceRequestDataSample(methodInvocation);\n\n\t\tserviceRequestDataSample.prepare();\n\n\t\t_serviceRequestDataSampleThreadLocal.set(serviceRequestDataSample);\n\n\t\treturn null;\n\t}","commit_id":"b51a731b5210dc9858db4a1b31bb2d9e8acfb3a9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void registerAnnotationType(\n\t\tClass<? extends Annotation> annotationType) {\n\t\t_annotationTypeSet.add(annotationType);\n\t}","id":73371,"modified_method":"public static void registerAnnotationType(\n\t\tClass<? extends Annotation> annotationType) {\n\n\t\t_annotationTypes.add(annotationType);\n\t}","commit_id":"2003fb3de0afaf479783cbf4d6b8224cb30e72f2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public AnnotationChainableMethodAdvice() {\n\t\t_nullAnnotation = getNullAnnotation();\n\t\t_annotationType = _nullAnnotation.annotationType();\n\t\t_annotationTypeSet.add(_annotationType);\n\t}","id":73372,"modified_method":"public AnnotationChainableMethodAdvice() {\n\t\t_nullAnnotation = getNullAnnotation();\n\n\t\t_annotationType = _nullAnnotation.annotationType();\n\n\t\t_annotationTypes.add(_annotationType);\n\t}","commit_id":"2003fb3de0afaf479783cbf4d6b8224cb30e72f2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected T findAnnotation(MethodInvocation methodInvocation) {\n\t\tAnnotation annotation = ServiceMethodAnnotationCache.get(\n\t\t\tmethodInvocation, _annotationType, _nullAnnotation);\n\n\t\tif (annotation != null) {\n\t\t\treturn (T)annotation;\n\t\t}\n\n\t\tClass<?> targetClass = methodInvocation.getThis().getClass();\n\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tMethod targetMethod = null;\n\n\t\ttry {\n\t\t\ttargetMethod = targetClass.getDeclaredMethod(\n\t\t\t\tmethod.getName(), method.getParameterTypes());\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t}\n\n\t\tAnnotation[] annotations = null;\n\n\t\tif (targetMethod != null) {\n\t\t\tannotations = targetMethod.getAnnotations();\n\t\t}\n\n\t\tif ((annotations == null) || (annotations.length == 0)) {\n\t\t\tannotations = method.getAnnotations();\n\t\t}\n\n\t\tif ((annotations != null) && annotations.length > 0) {\n\t\t\tList<Annotation> filteredAnnotations =\n\t\t\t\tnew ArrayList<Annotation>(annotations.length);\n\n\t\t\tfor (Annotation tempAnnotation : annotations) {\n\t\t\t\tif (_annotationTypeSet.contains(\n\t\t\t\t\ttempAnnotation.annotationType())) {\n\t\t\t\t\tfilteredAnnotations.add(tempAnnotation);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tannotations = filteredAnnotations.toArray(\n\t\t\t\tnew Annotation[filteredAnnotations.size()]);\n\t\t}\n\n\t\tServiceMethodAnnotationCache.put(methodInvocation, annotations);\n\n\t\tfor (Annotation tempAnnotation : annotations) {\n\t\t\tif (tempAnnotation.annotationType() == _annotationType) {\n\t\t\t\treturn (T)tempAnnotation;\n\t\t\t}\n\t\t}\n\n\t\treturn _nullAnnotation;\n\t}","id":73373,"modified_method":"protected T findAnnotation(MethodInvocation methodInvocation) {\n\t\tAnnotation annotation = ServiceMethodAnnotationCache.get(\n\t\t\tmethodInvocation, _annotationType, _nullAnnotation);\n\n\t\tif (annotation != null) {\n\t\t\treturn (T)annotation;\n\t\t}\n\n\t\tObject thisObject = methodInvocation.getThis();\n\n\t\tClass<?> targetClass = thisObject.getClass();\n\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tMethod targetMethod = null;\n\n\t\ttry {\n\t\t\ttargetMethod = targetClass.getDeclaredMethod(\n\t\t\t\tmethod.getName(), method.getParameterTypes());\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t}\n\n\t\tAnnotation[] annotations = null;\n\n\t\tif (targetMethod != null) {\n\t\t\tannotations = targetMethod.getAnnotations();\n\t\t}\n\n\t\tif ((annotations == null) || (annotations.length == 0)) {\n\t\t\tannotations = method.getAnnotations();\n\t\t}\n\n\t\tif ((annotations != null) && (annotations.length > 0)) {\n\t\t\tList<Annotation> filteredAnnotations = new ArrayList<Annotation>(\n\t\t\t\t\t\t\tannotations.length);\n\n\t\t\tfor (Annotation curAnnotation : annotations) {\n\t\t\t\tif (_annotationTypes.contains(\n\t\t\t\t\t\tcurAnnotation.annotationType())) {\n\n\t\t\t\t\tfilteredAnnotations.add(curAnnotation);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tannotations = filteredAnnotations.toArray(\n\t\t\t\tnew Annotation[filteredAnnotations.size()]);\n\t\t}\n\n\t\tServiceMethodAnnotationCache.put(methodInvocation, annotations);\n\n\t\tfor (Annotation curAnnotation : annotations) {\n\t\t\tif (curAnnotation.annotationType() == _annotationType) {\n\t\t\t\treturn (T)curAnnotation;\n\t\t\t}\n\t\t}\n\n\t\treturn _nullAnnotation;\n\t}","commit_id":"2003fb3de0afaf479783cbf4d6b8224cb30e72f2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic Object before(final MethodInvocation methodInvocation)\n\t\tthrows Throwable {\n\n\t\tAsync async = findAnnotation(methodInvocation);\n\n\t\tif (async == _nullAsync) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tif (method.getReturnType() != void.class) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Async annotation on method \" + method.getName() +\n\t\t\t\t\t\t\" does not return void\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString destinationName = null;\n\n\t\tif ((_destinationNames != null) && !_destinationNames.isEmpty()) {\n\t\t\tdestinationName = _destinationNames.get(\n\t\t\t\tmethodInvocation.getThis().getClass());\n\t\t}\n\n\t\tif (destinationName == null) {\n\t\t\tdestinationName = _defaultDestinationName;\n\t\t}\n\n\t\tMessageBusUtil.sendMessage(\n\t\t\tdestinationName,\n\t\t\tnew Runnable() {\n\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tnextMethodInterceptor.invoke(methodInvocation);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable t) {\n\t\t\t\t\t\tthrow new RuntimeException(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn methodInvocation.toString();\n\t\t\t\t}\n\n\t\t\t});\n\n\t\treturn nullResult;\n\t}","id":73374,"modified_method":"@Override\n\tpublic Object before(final MethodInvocation methodInvocation)\n\t\tthrows Throwable {\n\n\t\tAsync async = findAnnotation(methodInvocation);\n\n\t\tif (async == _nullAsync) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tif (method.getReturnType() != void.class) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Async annotation on method \" + method.getName() +\n\t\t\t\t\t\t\" does not return void\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString destinationName = null;\n\n\t\tif ((_destinationNames != null) && !_destinationNames.isEmpty()) {\n\t\t\tObject thisObject = methodInvocation.getThis();\n\n\t\t\tdestinationName = _destinationNames.get(thisObject.getClass());\n\t\t}\n\n\t\tif (destinationName == null) {\n\t\t\tdestinationName = _defaultDestinationName;\n\t\t}\n\n\t\tMessageBusUtil.sendMessage(\n\t\t\tdestinationName,\n\t\t\tnew Runnable() {\n\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tnextMethodInterceptor.invoke(methodInvocation);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable t) {\n\t\t\t\t\t\tthrow new RuntimeException(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn methodInvocation.toString();\n\t\t\t\t}\n\n\t\t\t});\n\n\t\treturn nullResult;\n\t}","commit_id":"2003fb3de0afaf479783cbf4d6b8224cb30e72f2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void afterReturning(MethodInvocation methodInvocation, Object result)\n\t\tthrows Throwable {\n\n\t\tif (!ClusterInvokeThreadLocal.isEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tClusterable clusterable = findAnnotation(methodInvocation);\n\n\t\tif (clusterable == _nullClusterable) {\n\t\t\treturn;\n\t\t}\n\n\t\tObject targetBean = methodInvocation.getThis();\n\n\t\tif (!(targetBean instanceof IdentifiableBean)) {\n\t\t\t_log.error(\n\t\t\t\t\"Not clustering calls for \" + targetBean.getClass().getName() +\n\t\t\t\t\t\" because it does not implement \" +\n\t\t\t\t\t\tIdentifiableBean.class.getName());\n\n\t\t\treturn;\n\t\t}\n\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\tmethod, methodInvocation.getArguments());\n\n\t\tClusterRequest clusterRequest = ClusterRequest.createMulticastRequest(\n\t\t\tmethodHandler, true);\n\n\t\tIdentifiableBean identifiableBean = (IdentifiableBean)targetBean;\n\n\t\tclusterRequest.setBeanIdentifier(identifiableBean.getBeanIdentifier());\n\n\t\tclusterRequest.setServletContextName(_servletContextName);\n\n\t\tClusterExecutorUtil.execute(clusterRequest);\n\t}","id":73375,"modified_method":"@Override\n\tpublic void afterReturning(MethodInvocation methodInvocation, Object result)\n\t\tthrows Throwable {\n\n\t\tif (!ClusterInvokeThreadLocal.isEnabled()) {\n\t\t\treturn;\n\t\t}\n\n\t\tClusterable clusterable = findAnnotation(methodInvocation);\n\n\t\tif (clusterable == _nullClusterable) {\n\t\t\treturn;\n\t\t}\n\n\t\tObject thisObject = methodInvocation.getThis();\n\n\t\tif (!(thisObject instanceof IdentifiableBean)) {\n\t\t\t_log.error(\n\t\t\t\t\"Not clustering calls for \" + thisObject.getClass().getName() +\n\t\t\t\t\t\" because it does not implement \" +\n\t\t\t\t\t\tIdentifiableBean.class.getName());\n\n\t\t\treturn;\n\t\t}\n\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tMethodHandler methodHandler = new MethodHandler(\n\t\t\tmethod, methodInvocation.getArguments());\n\n\t\tClusterRequest clusterRequest = ClusterRequest.createMulticastRequest(\n\t\t\tmethodHandler, true);\n\n\t\tIdentifiableBean identifiableBean = (IdentifiableBean)thisObject;\n\n\t\tclusterRequest.setBeanIdentifier(identifiableBean.getBeanIdentifier());\n\n\t\tclusterRequest.setServletContextName(_servletContextName);\n\n\t\tClusterExecutorUtil.execute(clusterRequest);\n\t}","commit_id":"2003fb3de0afaf479783cbf4d6b8224cb30e72f2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic Object invoke(MethodInvocation methodInvocation) throws Throwable {\n\t\tif (_dynamicDataSourceTargetSource == null) {\n\t\t\treturn super.invoke(methodInvocation);\n\t\t}\n\n\t\tClass<?> targetClass = null;\n\n\t\tif (methodInvocation.getThis() != null) {\n\t\t\tObject targetBean = methodInvocation.getThis();\n\n\t\t\ttargetClass = targetBean.getClass();\n\t\t}\n\n\t\tMethod targetMethod = methodInvocation.getMethod();\n\n\t\tTransactionAttributeSource transactionAttributeSource =\n\t\t\tgetTransactionAttributeSource();\n\n\t\tTransactionAttribute transactionAttribute =\n\t\t\ttransactionAttributeSource.getTransactionAttribute(\n\t\t\t\ttargetMethod, targetClass);\n\n\t\tif ((transactionAttribute != null) &&\n\t\t\t(transactionAttribute.isReadOnly())) {\n\n\t\t\t_dynamicDataSourceTargetSource.setOperation(Operation.READ);\n\t\t}\n\t\telse {\n\t\t\t_dynamicDataSourceTargetSource.setOperation(Operation.WRITE);\n\t\t}\n\n\t\t_dynamicDataSourceTargetSource.pushMethod(\n\t\t\ttargetClass.getName().concat(StringPool.PERIOD).concat(\n\t\t\t\ttargetMethod.getName()));\n\n\t\tObject returnValue = null;\n\n\t\ttry {\n\t\t\treturnValue = super.invoke(methodInvocation);\n\t\t}\n\t\tfinally {\n\t\t\t_dynamicDataSourceTargetSource.popMethod();\n\t\t}\n\n\t\treturn returnValue;\n\t}","id":73376,"modified_method":"@Override\n\tpublic Object invoke(MethodInvocation methodInvocation) throws Throwable {\n\t\tif (_dynamicDataSourceTargetSource == null) {\n\t\t\treturn super.invoke(methodInvocation);\n\t\t}\n\n\t\tClass<?> targetClass = null;\n\n\t\tif (methodInvocation.getThis() != null) {\n\t\t\tObject thisObject = methodInvocation.getThis();\n\n\t\t\ttargetClass = thisObject.getClass();\n\t\t}\n\n\t\tMethod targetMethod = methodInvocation.getMethod();\n\n\t\tTransactionAttributeSource transactionAttributeSource =\n\t\t\tgetTransactionAttributeSource();\n\n\t\tTransactionAttribute transactionAttribute =\n\t\t\ttransactionAttributeSource.getTransactionAttribute(\n\t\t\t\ttargetMethod, targetClass);\n\n\t\tif ((transactionAttribute != null) &&\n\t\t\t(transactionAttribute.isReadOnly())) {\n\n\t\t\t_dynamicDataSourceTargetSource.setOperation(Operation.READ);\n\t\t}\n\t\telse {\n\t\t\t_dynamicDataSourceTargetSource.setOperation(Operation.WRITE);\n\t\t}\n\n\t\t_dynamicDataSourceTargetSource.pushMethod(\n\t\t\ttargetClass.getName().concat(StringPool.PERIOD).concat(\n\t\t\t\ttargetMethod.getName()));\n\n\t\tObject returnValue = null;\n\n\t\ttry {\n\t\t\treturnValue = super.invoke(methodInvocation);\n\t\t}\n\t\tfinally {\n\t\t\t_dynamicDataSourceTargetSource.popMethod();\n\t\t}\n\n\t\treturn returnValue;\n\t}","commit_id":"2003fb3de0afaf479783cbf4d6b8224cb30e72f2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object getProxy(ClassLoader classLoader) {\n\t\tClass[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(\n\t\t\t_advisedSupport);\n\t\treturn Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);\n\t}","id":73377,"modified_method":"public Object getProxy(ClassLoader classLoader) {\n\t\tClass<?>[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(\n\t\t\t_advisedSupport);\n\n\t\treturn Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);\n\t}","commit_id":"2003fb3de0afaf479783cbf4d6b8224cb30e72f2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object invoke(Object proxy, Method method, Object[] args)\n\t\tthrows Throwable {\n\t\tTargetSource targetSource = _advisedSupport.getTargetSource();\n\t\tObject target = null;\n\n\t\ttry {\n\t\t\tClass targetClass = null;\n\n\t\t\ttarget = targetSource.getTarget();\n\t\t\tif (target != null) {\n\t\t\t\ttargetClass = target.getClass();\n\t\t\t}\n\n\t\t\tServiceBeanMethodInvocation serviceBeanMethodInvocation =\n\t\t\t\tnew ServiceBeanMethodInvocation(target, method, args,\n\t\t\t\t\ttargetClass);\n\n\t\t\tSkip skip = ServiceMethodAnnotationCache.get(\n\t\t\t\tserviceBeanMethodInvocation, Skip.class, null);\n\n\t\t\tif (skip == null) {\n\t\t\t\treturn _methodInterceptor.invoke(serviceBeanMethodInvocation);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn serviceBeanMethodInvocation.proceed();\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (target != null && !targetSource.isStatic()) {\n\t\t\t\ttargetSource.releaseTarget(target);\n\t\t\t}\n\t\t}\n\t}","id":73378,"modified_method":"public Object invoke(Object proxy, Method method, Object[] arguments)\n\t\tthrows Throwable {\n\n\t\tTargetSource targetSource = _advisedSupport.getTargetSource();\n\n\t\tObject target = null;\n\n\t\ttry {\n\t\t\tClass<?> targetClass = null;\n\n\t\t\ttarget = targetSource.getTarget();\n\n\t\t\tif (target != null) {\n\t\t\t\ttargetClass = target.getClass();\n\t\t\t}\n\n\t\t\tServiceBeanMethodInvocation serviceBeanMethodInvocation =\n\t\t\t\tnew ServiceBeanMethodInvocation(\n\t\t\t\t\ttarget, targetClass, method, arguments);\n\n\t\t\tSkip skip = ServiceMethodAnnotationCache.get(\n\t\t\t\tserviceBeanMethodInvocation, Skip.class, null);\n\n\t\t\tif (skip == null) {\n\t\t\t\treturn _methodInterceptor.invoke(serviceBeanMethodInvocation);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn serviceBeanMethodInvocation.proceed();\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif ((target != null) && !targetSource.isStatic()) {\n\t\t\t\ttargetSource.releaseTarget(target);\n\t\t\t}\n\t\t}\n\t}","commit_id":"2003fb3de0afaf479783cbf4d6b8224cb30e72f2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Object[] getAdvicesAndAdvisorsForBean(\n\t\t\tClass<?> beanClass, String beanName, TargetSource targetSource)\n\t\tthrows BeansException {\n\t\tif (beanName.endsWith(\"Service\")) {\n\t\t\treturn PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS;\n\t\t}\n\t\telse {\n\t\t\treturn DO_NOT_PROXY;\n\t\t}\n\t}","id":73379,"modified_method":"protected Object[] getAdvicesAndAdvisorsForBean(\n\t\t\tClass<?> beanClass, String beanName, TargetSource targetSource)\n\t\tthrows BeansException {\n\n\t\tif (beanName.endsWith(_SERVICE_SUFFIX)) {\n\t\t\treturn PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS;\n\t\t}\n\t\telse {\n\t\t\treturn DO_NOT_PROXY;\n\t\t}\n\t}","commit_id":"2003fb3de0afaf479783cbf4d6b8224cb30e72f2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String toString() {\n\t\tif (_toString == null) {\n\t\t\tClass<?>[] parameterTypes = _method.getParameterTypes();\n\n\t\t\tStringBundler sb = new StringBundler(parameterTypes.length * 2 + 6);\n\n\t\t\tsb.append(_method.getDeclaringClass().getName());\n\t\t\tsb.append(StringPool.PERIOD);\n\t\t\tsb.append(_method.getName());\n\t\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\n\t\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\t\tsb.append(parameterTypes[i].getName());\n\n\t\t\t\tif ((i + 1) < parameterTypes.length) {\n\t\t\t\t\tsb.append(StringPool.COMMA);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\t\tif (_targetClass != null) {\n\t\t\t\tsb.append(StringPool.AT);\n\t\t\t\tsb.append(_targetClass.getName());\n\t\t\t}\n\n\t\t\t_toString = sb.toString();\n\t\t}\n\n\t\treturn _toString;\n\t}","id":73380,"modified_method":"public String toString() {\n\t\tif (_toString != null) {\n\t\t\treturn _toString;\n\t\t}\n\n\t\tClass<?>[] parameterTypes = _method.getParameterTypes();\n\n\t\tStringBundler sb = new StringBundler(parameterTypes.length * 2 + 6);\n\n\t\tClass<?> declaringClass = _method.getDeclaringClass();\n\n\t\tsb.append(declaringClass.getName());\n\n\t\tsb.append(StringPool.PERIOD);\n\t\tsb.append(_method.getName());\n\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\n\t\tfor (int i = 0; i < parameterTypes.length; i++) {\n\t\t\tClass<?> parameterType = parameterTypes[i];\n\n\t\t\tsb.append(parameterType.getName());\n\n\t\t\tif ((i + 1) < parameterTypes.length) {\n\t\t\t\tsb.append(StringPool.COMMA);\n\t\t\t}\n\t\t}\n\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\tif (_targetClass != null) {\n\t\t\tsb.append(StringPool.AT);\n\t\t\tsb.append(_targetClass.getName());\n\t\t}\n\n\t\t_toString = sb.toString();\n\n\t\treturn _toString;\n\t}","commit_id":"2003fb3de0afaf479783cbf4d6b8224cb30e72f2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ServiceBeanMethodInvocation(\n\t\tObject target, Method method, Object[] arguments,\n\t\tClass<?> targetClass) {\n\t\t_arguments = arguments;\n\t\t_method = method;\n\t\t_target = target;\n\t\t_targetClass = targetClass;\n\n\t\t_method.setAccessible(true);\n\t}","id":73381,"modified_method":"public ServiceBeanMethodInvocation(\n\t\tObject target, Class<?> targetClass, Method method,\n\t\tObject[] arguments) {\n\n\t\t_target = target;\n\t\t_targetClass = targetClass;\n\t\t_method = method;\n\t\t_arguments = arguments;\n\n\t\t_method.setAccessible(true);\n\t}","commit_id":"2003fb3de0afaf479783cbf4d6b8224cb30e72f2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static <T> T get(\n\t\tMethodInvocation methodInvocation,\n\t\tClass<? extends Annotation> annotationType, T defaultValue) {\n\t\tAnnotation[] annotations = _annotationCache.get(methodInvocation);\n\n\t\tif (annotations == _emptyAnnotations) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tif (annotations == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfor (Annotation annotation : annotations) {\n\t\t\tif (annotation.annotationType() == annotationType) {\n\t\t\t\treturn (T)annotation;\n\t\t\t}\n\t\t}\n\n\t\treturn defaultValue;\n\t}","id":73382,"modified_method":"public static <T> T get(\n\t\tMethodInvocation methodInvocation,\n\t\tClass<? extends Annotation> annotationType, T defaultValue) {\n\n\t\tAnnotation[] annotations = _annotations.get(methodInvocation);\n\n\t\tif (annotations == _nullAnnotations) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tif (annotations == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfor (Annotation annotation : annotations) {\n\t\t\tif (annotation.annotationType() == annotationType) {\n\t\t\t\treturn (T)annotation;\n\t\t\t}\n\t\t}\n\n\t\treturn defaultValue;\n\t}","commit_id":"2003fb3de0afaf479783cbf4d6b8224cb30e72f2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void put(\n\t\tMethodInvocation methodInvocation, Annotation[] annotations) {\n\t\tif ((annotations == null) || (annotations.length == 0)) {\n\t\t\tannotations = _emptyAnnotations;\n\t\t}\n\n\t\t_annotationCache.put(methodInvocation, annotations);\n\t}","id":73383,"modified_method":"public static void put(\n\t\tMethodInvocation methodInvocation, Annotation[] annotations) {\n\n\t\tif ((annotations == null) || (annotations.length == 0)) {\n\t\t\tannotations = _nullAnnotations;\n\t\t}\n\n\t\t_annotations.put(methodInvocation, annotations);\n\t}","commit_id":"2003fb3de0afaf479783cbf4d6b8224cb30e72f2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic Object before(MethodInvocation methodInvocation) throws Throwable {\n\t\tif (!_active) {\n\t\t\treturn null;\n\t\t}\n\n\t\tObject object = methodInvocation.getThis();\n\n\t\tClass<?> clazz = object.getClass();\n\n\t\tClass<?>[] interfaces = clazz.getInterfaces();\n\n\t\tfor (int i = 0; i < interfaces.length; i++) {\n\t\t\tif (interfaces[i].isAssignableFrom(MonitoringProcessor.class)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (!_permissiveMode && !isMonitored(methodInvocation)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tServiceRequestDataSample serviceRequestDataSample =\n\t\t\tnew ServiceRequestDataSample(methodInvocation);\n\n\t\tserviceRequestDataSample.prepare();\n\n\t\t_serviceRequestDataSampleThreadLocal.set(serviceRequestDataSample);\n\n\t\treturn null;\n\t}","id":73384,"modified_method":"@Override\n\tpublic Object before(MethodInvocation methodInvocation) throws Throwable {\n\t\tif (!_active) {\n\t\t\treturn null;\n\t\t}\n\n\t\tObject thisObject = methodInvocation.getThis();\n\n\t\tClass<?> clazz = thisObject.getClass();\n\n\t\tClass<?>[] interfaces = clazz.getInterfaces();\n\n\t\tfor (int i = 0; i < interfaces.length; i++) {\n\t\t\tif (interfaces[i].isAssignableFrom(MonitoringProcessor.class)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (!_permissiveMode && !isMonitored(methodInvocation)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tServiceRequestDataSample serviceRequestDataSample =\n\t\t\tnew ServiceRequestDataSample(methodInvocation);\n\n\t\tserviceRequestDataSample.prepare();\n\n\t\t_serviceRequestDataSampleThreadLocal.set(serviceRequestDataSample);\n\n\t\treturn null;\n\t}","commit_id":"2003fb3de0afaf479783cbf4d6b8224cb30e72f2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tClass<?> targetClass = null;\n\n\t\tObject thisObject = methodInvocation.getThis();\n\n\t\tif (thisObject != null) {\n\t\t\ttargetClass = thisObject.getClass();\n\t\t}\n\n\t\tTransactionAttributeSource transactionAttributeSource =\n\t\t\tgetTransactionAttributeSource();\n\n\t\tTransactionAttribute transactionAttribute =\n\t\t\ttransactionAttributeSource.getTransactionAttribute(\n\t\t\t\tmethod, targetClass);\n\n\t\tif (transactionAttribute == null) {\n\t\t\treturn methodInvocation.proceed();\n\t\t}\n\n\t\tClass<?> declaringClass = method.getDeclaringClass();\n\n\t\tString joinPointIdentification = StringPool.BLANK;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tjoinPointIdentification =\n\t\t\t\tdeclaringClass.getName().concat(StringPool.PERIOD).concat(\n\t\t\t\t\tmethod.getName());\n\t\t}\n\n\t\tTransactionInfo transactionInfo = createTransactionIfNecessary(\n\t\t\tgetTransactionManager(), transactionAttribute,\n\t\t\tjoinPointIdentification);\n\n\t\tTransactionStatus transactionStatus =\n\t\t\ttransactionInfo.getTransactionStatus();\n\n\t\tboolean newTransaction = transactionStatus.isNewTransaction();\n\n\t\tif (newTransaction) {\n\t\t\tTransactionalPortalCacheHelper.begin();\n\t\t}\n\n\t\tObject returnValue = null;\n\n\t\ttry {\n\t\t\treturnValue = methodInvocation.proceed();\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\tif (newTransaction) {\n\t\t\t\tTransactionalPortalCacheHelper.rollback();\n\t\t\t}\n\n\t\t\tcompleteTransactionAfterThrowing(transactionInfo, throwable);\n\n\t\t\tthrow throwable;\n\t\t}\n\t\tfinally {\n\t\t\tcleanupTransactionInfo(transactionInfo);\n\t\t}\n\n\t\tcommitTransactionAfterReturning(transactionInfo);\n\n\t\tif (newTransaction) {\n\t\t\tTransactionalPortalCacheHelper.commit();\n\t\t}\n\n\t\treturn returnValue;\n\t}","id":73385,"modified_method":"public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tClass<?> targetClass = null;\n\n\t\tObject targetBean = methodInvocation.getThis();\n\n\t\tif (targetBean != null) {\n\t\t\ttargetClass = targetBean.getClass();\n\t\t}\n\n\t\tTransactionAttributeSource transactionAttributeSource =\n\t\t\tgetTransactionAttributeSource();\n\n\t\tTransactionAttribute transactionAttribute =\n\t\t\ttransactionAttributeSource.getTransactionAttribute(\n\t\t\t\tmethod, targetClass);\n\n\t\tif (transactionAttribute == null) {\n\t\t\treturn methodInvocation.proceed();\n\t\t}\n\n\t\tClass<?> declaringClass = method.getDeclaringClass();\n\n\t\tString joinPointIdentification = StringPool.BLANK;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tjoinPointIdentification =\n\t\t\t\tdeclaringClass.getName().concat(StringPool.PERIOD).concat(\n\t\t\t\t\tmethod.getName());\n\t\t}\n\n\t\tTransactionInfo transactionInfo = createTransactionIfNecessary(\n\t\t\tgetTransactionManager(), transactionAttribute,\n\t\t\tjoinPointIdentification);\n\n\t\tTransactionStatus transactionStatus =\n\t\t\ttransactionInfo.getTransactionStatus();\n\n\t\tboolean newTransaction = transactionStatus.isNewTransaction();\n\n\t\tif (newTransaction) {\n\t\t\tTransactionalPortalCacheHelper.begin();\n\t\t}\n\n\t\tObject returnValue = null;\n\n\t\ttry {\n\t\t\treturnValue = methodInvocation.proceed();\n\t\t}\n\t\tcatch (Throwable throwable) {\n\t\t\tif (newTransaction) {\n\t\t\t\tTransactionalPortalCacheHelper.rollback();\n\t\t\t}\n\n\t\t\tcompleteTransactionAfterThrowing(transactionInfo, throwable);\n\n\t\t\tthrow throwable;\n\t\t}\n\t\tfinally {\n\t\t\tcleanupTransactionInfo(transactionInfo);\n\t\t}\n\n\t\tcommitTransactionAfterReturning(transactionInfo);\n\n\t\tif (newTransaction) {\n\t\t\tTransactionalPortalCacheHelper.commit();\n\t\t}\n\n\t\treturn returnValue;\n\t}","commit_id":"2003fb3de0afaf479783cbf4d6b8224cb30e72f2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private List<PsiClass> getClassesToImport() {\n    PsiManager manager = PsiManager.getInstance(myRef.getProject());\n    PsiShortNamesCache cache = JavaPsiFacade.getInstance(manager.getProject()).getShortNamesCache();\n    String name = myRef.getReferenceName();\n    GlobalSearchScope scope = myRef.getResolveScope();\n    if (name == null) {\n      return Collections.emptyList();\n    }\n    final PsiReferenceParameterList refParameters = myRef.getParameterList();\n    boolean referenceHasTypeParameters = refParameters != null && refParameters.getTypeParameterElements().length > 0;\n    PsiClass[] classes = cache.getClassesByName(name, scope);\n    ArrayList<PsiClass> classList = new ArrayList<PsiClass>();\n    boolean isAnnotationReference = myRef.getParent() instanceof PsiAnnotation;\n    for (PsiClass aClass : classes) {\n      if (isAnnotationReference && !aClass.isAnnotationType()) continue;\n      if (JavaCompletionUtil.isInExcludedPackage(aClass)) continue;\n      if (referenceHasTypeParameters && !aClass.hasTypeParameters()) continue;\n      PsiFile file = aClass.getContainingFile();\n      if (file instanceof PsiJavaFile && ((PsiJavaFile)file).getPackageName().length() == 0) { //do not show classes from default package\n        continue;\n      }\n      String qName = aClass.getQualifiedName();\n      if (qName != null) { //filter local classes\n        if (qName.endsWith(name)) {\n          if (aClass.hasModifierProperty(PsiModifier.PUBLIC)) {\n            classList.add(aClass);\n          }\n        }\n      }\n    }\n    return classList;\n  }","id":73386,"modified_method":"private List<PsiClass> getClassesToImport() {\n    PsiManager manager = PsiManager.getInstance(myRef.getProject());\n    PsiShortNamesCache cache = JavaPsiFacade.getInstance(manager.getProject()).getShortNamesCache();\n    String name = myRef.getReferenceName();\n    GlobalSearchScope scope = myRef.getResolveScope();\n    if (name == null) {\n      return Collections.emptyList();\n    }\n    final PsiReferenceParameterList refParameters = myRef.getParameterList();\n    boolean referenceHasTypeParameters = refParameters != null && refParameters.getTypeParameterElements().length > 0;\n    PsiClass[] classes = cache.getClassesByName(name, scope);\n    if (classes.length == 0) return Collections.emptyList();\n    ArrayList<PsiClass> classList = new ArrayList<PsiClass>(classes.length);\n    boolean isAnnotationReference = myRef.getParent() instanceof PsiAnnotation;\n    for (PsiClass aClass : classes) {\n      if (isAnnotationReference && !aClass.isAnnotationType()) continue;\n      if (JavaCompletionUtil.isInExcludedPackage(aClass)) continue;\n      if (referenceHasTypeParameters && !aClass.hasTypeParameters()) continue;\n      PsiFile file = aClass.getContainingFile();\n      if (file instanceof PsiJavaFile && ((PsiJavaFile)file).getPackageName().length() == 0) { //do not show classes from default package\n        continue;\n      }\n      String qName = aClass.getQualifiedName();\n      if (qName != null) { //filter local classes\n        if (qName.endsWith(name)) {\n          if (aClass.hasModifierProperty(PsiModifier.PUBLIC)) {\n            classList.add(aClass);\n          }\n        }\n      }\n    }\n    return classList;\n  }","commit_id":"68b58595ac31254f481fc7663a673caba8bdf4f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public JavaResolveResult[] multiResolve(boolean incompleteCode) {\n    final PsiManagerEx manager = getManager();\n    if (manager == null) {\n      LOG.assertTrue(false, \"getManager() == null!\");\n      return null;\n    }\n    return (JavaResolveResult[])manager.getResolveCache().resolveWithCaching(this, OurGenericsResolver.INSTANCE, true, incompleteCode);\n  }","id":73387,"modified_method":"@NotNull\n  public JavaResolveResult[] multiResolve(boolean incompleteCode) {\n    final PsiManagerEx manager = getManager();\n    if (manager == null) {\n      LOG.assertTrue(false, \"getManager() == null!\");\n      return null;\n    }\n    ResolveResult[] results = manager.getResolveCache().resolveWithCaching(this, OurGenericsResolver.INSTANCE, true, incompleteCode);\n    return (JavaResolveResult[])results;\n  }","commit_id":"68b58595ac31254f481fc7663a673caba8bdf4f3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public JavaResolveResult[] multiResolve(final boolean incompleteCode) {\n    final PsiManagerEx manager = getManager();\n    if (manager == null) {\n      LOG.assertTrue(false, \"getManager() == null!\");\n      return JavaResolveResult.EMPTY_ARRAY;\n    }\n\n    final ResolveCache resolveCache = manager.getResolveCache();\n    return (JavaResolveResult[])resolveCache.resolveWithCaching(this, OurGenericsResolver.INSTANCE, true, incompleteCode);\n  }","id":73388,"modified_method":"@NotNull\n  public JavaResolveResult[] multiResolve(final boolean incompleteCode) {\n    final PsiManagerEx manager = getManager();\n    if (manager == null) {\n      LOG.assertTrue(false, \"getManager() == null!\");\n      return JavaResolveResult.EMPTY_ARRAY;\n    }\n\n    final ResolveCache resolveCache = manager.getResolveCache();\n    final ResolveResult[] results = resolveCache.resolveWithCaching(this, OurGenericsResolver.INSTANCE, true, incompleteCode);\n    final JavaResolveResult[] javaResults = new JavaResolveResult[results.length];\n    for (int i = 0; i < results.length; i++) {\n      javaResults[i] = (JavaResolveResult)results[i];\n    }\n    return javaResults;\n  }","commit_id":"88ee4442d3ac5f92f80d353bed21d3fc2d9445ec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static AnnotationNode createAnnotationNode(AnnotationStub annotation, AsmReferenceResolver resolver) {\n        AnnotationNode node = new DecompiledAnnotationNode(resolver.resolveType(Type.getType(annotation.className)));\n        for (Map.Entry<String, Object> entry : annotation.members.entrySet()) {\n            node.addMember(entry.getKey(), annotationValueToExpression(entry.getValue(), resolver));\n        }\n        return node;\n    }","id":73389,"modified_method":"static AnnotationNode createAnnotationNode(AnnotationStub annotation, AsmReferenceResolver resolver) {\n        ClassNode classNode = resolver.resolveClassNullable(Type.getType(annotation.className).getClassName());\n        if (classNode == null) {\n            // there might be annotations not present in the classpath\n            // e.g. java.lang.Synthetic (http://forge.ow2.org/tracker/?aid=307392&group_id=23&atid=100023&func=detail)\n            // so skip them\n            return null;\n        }\n\n        AnnotationNode node = new DecompiledAnnotationNode(classNode);\n        for (Map.Entry<String, Object> entry : annotation.members.entrySet()) {\n            node.addMember(entry.getKey(), annotationValueToExpression(entry.getValue(), resolver));\n        }\n        return node;\n    }","commit_id":"283a636a856267d4964f49575fc755c128d029d3","url":"https://github.com/apache/groovy"},{"original_method":"private static Expression annotationValueToExpression(Object value, AsmReferenceResolver resolver) {\n        if (value instanceof TypeWrapper) {\n            return new ClassExpression(resolver.resolveType(Type.getType(((TypeWrapper) value).desc)));\n        }\n\n        if (value instanceof EnumConstantWrapper) {\n            EnumConstantWrapper wrapper = (EnumConstantWrapper) value;\n            return new PropertyExpression(new ClassExpression(resolver.resolveType(Type.getType(wrapper.enumDesc))), wrapper.constant);\n        }\n\n        if (value instanceof AnnotationStub) {\n            return new AnnotationConstantExpression(createAnnotationNode((AnnotationStub) value, resolver));\n        }\n\n        if (value != null && value.getClass().isArray()) {\n            ListExpression elementExprs = new ListExpression();\n            int len = Array.getLength(value);\n            for (int i = 0; i != len; ++i) {\n                elementExprs.addExpression(annotationValueToExpression(Array.get(value, i), resolver));\n            }\n            return elementExprs;\n        }\n\n        if (value instanceof List) {\n            ListExpression elementExprs = new ListExpression();\n            for (Object o : (List) value) {\n                elementExprs.addExpression(annotationValueToExpression(o, resolver));\n            }\n            return elementExprs;\n        }\n\n        return new ConstantExpression(value);\n    }","id":73390,"modified_method":"private static Expression annotationValueToExpression(Object value, AsmReferenceResolver resolver) {\n        if (value instanceof TypeWrapper) {\n            return new ClassExpression(resolver.resolveType(Type.getType(((TypeWrapper) value).desc)));\n        }\n\n        if (value instanceof EnumConstantWrapper) {\n            EnumConstantWrapper wrapper = (EnumConstantWrapper) value;\n            return new PropertyExpression(new ClassExpression(resolver.resolveType(Type.getType(wrapper.enumDesc))), wrapper.constant);\n        }\n\n        if (value instanceof AnnotationStub) {\n            AnnotationNode annotationNode = createAnnotationNode((AnnotationStub) value, resolver);\n            return annotationNode != null ? new AnnotationConstantExpression(annotationNode) : ConstantExpression.NULL;\n        }\n\n        if (value != null && value.getClass().isArray()) {\n            ListExpression elementExprs = new ListExpression();\n            int len = Array.getLength(value);\n            for (int i = 0; i != len; ++i) {\n                elementExprs.addExpression(annotationValueToExpression(Array.get(value, i), resolver));\n            }\n            return elementExprs;\n        }\n\n        if (value instanceof List) {\n            ListExpression elementExprs = new ListExpression();\n            for (Object o : (List) value) {\n                elementExprs.addExpression(annotationValueToExpression(o, resolver));\n            }\n            return elementExprs;\n        }\n\n        return new ConstantExpression(value);\n    }","commit_id":"283a636a856267d4964f49575fc755c128d029d3","url":"https://github.com/apache/groovy"},{"original_method":"private <T extends AnnotatedNode> T addAnnotations(MemberStub stub, T node) {\n        for (AnnotationStub annotation : stub.annotations) {\n            node.addAnnotation(Annotations.createAnnotationNode(annotation, resolver));\n        }\n        return node;\n    }","id":73391,"modified_method":"private <T extends AnnotatedNode> T addAnnotations(MemberStub stub, T node) {\n        for (AnnotationStub annotation : stub.annotations) {\n            AnnotationNode annotationNode = Annotations.createAnnotationNode(annotation, resolver);\n            if (annotationNode != null) {\n                node.addAnnotation(annotationNode);\n            }\n        }\n        return node;\n    }","commit_id":"283a636a856267d4964f49575fc755c128d029d3","url":"https://github.com/apache/groovy"},{"original_method":"static MethodNode createMethodNode(final AsmReferenceResolver resolver, MethodStub method) {\n        GenericsType[] typeParameters = null;\n\n        Type[] argumentTypes = Type.getArgumentTypes(method.desc);\n        final ClassNode[] parameterTypes = new ClassNode[argumentTypes.length];\n        for (int i = 0; i < argumentTypes.length; i++) {\n            parameterTypes[i] = resolver.resolveType(argumentTypes[i]);\n        }\n\n        final ClassNode[] exceptions = new ClassNode[method.exceptions.length];\n        for (int i = 0; i < method.exceptions.length; i++) {\n            exceptions[i] = resolver.resolveClass(AsmDecompiler.fromInternalName(method.exceptions[i]));\n        }\n\n        final ClassNode[] returnType = {resolver.resolveType(Type.getReturnType(method.desc))};\n\n        if (method.signature != null) {\n            FormalParameterParser v = new FormalParameterParser(resolver) {\n                int paramIndex = 0;\n\n                @Override\n                public SignatureVisitor visitParameterType() {\n                    return new TypeSignatureParser(resolver) {\n                        @Override\n                        void finished(ClassNode result) {\n                            parameterTypes[paramIndex++] = result;\n                        }\n                    };\n                }\n\n                @Override\n                public SignatureVisitor visitReturnType() {\n                    return new TypeSignatureParser(resolver) {\n                        @Override\n                        void finished(ClassNode result) {\n                            returnType[0] = result;\n                        }\n                    };\n                }\n\n                int exceptionIndex = 0;\n\n                @Override\n                public SignatureVisitor visitExceptionType() {\n                    return new TypeSignatureParser(resolver) {\n                        @Override\n                        void finished(ClassNode result) {\n                            exceptions[exceptionIndex++] = result;\n                        }\n                    };\n                }\n            };\n            new SignatureReader(method.signature).accept(v);\n            typeParameters = v.getTypeParameters();\n        }\n\n        Parameter[] parameters = new Parameter[parameterTypes.length];\n        for (int i = 0; i < parameterTypes.length; i++) {\n            parameters[i] = new Parameter(parameterTypes[i], \"param\" + i);\n        }\n\n        for (Map.Entry<Integer, List<AnnotationStub>> entry : method.parameterAnnotations.entrySet()) {\n            for (AnnotationStub stub : entry.getValue()) {\n                parameters[entry.getKey()].addAnnotation(Annotations.createAnnotationNode(stub, resolver));\n            }\n        }\n\n        MethodNode result;\n        if (\"<init>\".equals(method.methodName)) {\n            result = new ConstructorNode(method.accessModifiers, parameters, exceptions, null);\n        } else {\n            result = new MethodNode(method.methodName, method.accessModifiers, returnType[0], parameters, exceptions, null);\n            if (method.annotationDefault != null) {\n                result.setCode(new ReturnStatement(new ConstantExpression(method.annotationDefault)));\n                result.setAnnotationDefault(true);\n            } else {\n                // Seems wrong but otherwise some tests fail (e.g. TestingASTTransformsTest)\n                result.setCode(new ReturnStatement(ConstantExpression.NULL));\n            }\n\n        }\n        if (typeParameters != null && typeParameters.length > 0) {\n            result.setGenericsTypes(typeParameters);\n        }\n        return result;\n    }","id":73392,"modified_method":"static MethodNode createMethodNode(final AsmReferenceResolver resolver, MethodStub method) {\n        GenericsType[] typeParameters = null;\n\n        Type[] argumentTypes = Type.getArgumentTypes(method.desc);\n        final ClassNode[] parameterTypes = new ClassNode[argumentTypes.length];\n        for (int i = 0; i < argumentTypes.length; i++) {\n            parameterTypes[i] = resolver.resolveType(argumentTypes[i]);\n        }\n\n        final ClassNode[] exceptions = new ClassNode[method.exceptions.length];\n        for (int i = 0; i < method.exceptions.length; i++) {\n            exceptions[i] = resolver.resolveClass(AsmDecompiler.fromInternalName(method.exceptions[i]));\n        }\n\n        final ClassNode[] returnType = {resolver.resolveType(Type.getReturnType(method.desc))};\n\n        if (method.signature != null) {\n            FormalParameterParser v = new FormalParameterParser(resolver) {\n                int paramIndex = 0;\n\n                @Override\n                public SignatureVisitor visitParameterType() {\n                    return new TypeSignatureParser(resolver) {\n                        @Override\n                        void finished(ClassNode result) {\n                            parameterTypes[paramIndex++] = result;\n                        }\n                    };\n                }\n\n                @Override\n                public SignatureVisitor visitReturnType() {\n                    return new TypeSignatureParser(resolver) {\n                        @Override\n                        void finished(ClassNode result) {\n                            returnType[0] = result;\n                        }\n                    };\n                }\n\n                int exceptionIndex = 0;\n\n                @Override\n                public SignatureVisitor visitExceptionType() {\n                    return new TypeSignatureParser(resolver) {\n                        @Override\n                        void finished(ClassNode result) {\n                            exceptions[exceptionIndex++] = result;\n                        }\n                    };\n                }\n            };\n            new SignatureReader(method.signature).accept(v);\n            typeParameters = v.getTypeParameters();\n        }\n\n        Parameter[] parameters = new Parameter[parameterTypes.length];\n        for (int i = 0; i < parameterTypes.length; i++) {\n            parameters[i] = new Parameter(parameterTypes[i], \"param\" + i);\n        }\n\n        for (Map.Entry<Integer, List<AnnotationStub>> entry : method.parameterAnnotations.entrySet()) {\n            for (AnnotationStub stub : entry.getValue()) {\n                AnnotationNode annotationNode = Annotations.createAnnotationNode(stub, resolver);\n                if (annotationNode != null) {\n                    parameters[entry.getKey()].addAnnotation(annotationNode);\n                }\n            }\n        }\n\n        MethodNode result;\n        if (\"<init>\".equals(method.methodName)) {\n            result = new ConstructorNode(method.accessModifiers, parameters, exceptions, null);\n        } else {\n            result = new MethodNode(method.methodName, method.accessModifiers, returnType[0], parameters, exceptions, null);\n            if (method.annotationDefault != null) {\n                result.setCode(new ReturnStatement(new ConstantExpression(method.annotationDefault)));\n                result.setAnnotationDefault(true);\n            } else {\n                // Seems wrong but otherwise some tests fail (e.g. TestingASTTransformsTest)\n                result.setCode(new ReturnStatement(ConstantExpression.NULL));\n            }\n\n        }\n        if (typeParameters != null && typeParameters.length > 0) {\n            result.setGenericsTypes(typeParameters);\n        }\n        return result;\n    }","commit_id":"283a636a856267d4964f49575fc755c128d029d3","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tJournalArticle article = null;\n\t\tString oldUrlTitle = StringPool.BLANK;\n\n\t\ttry {\n\t\t\tif (Validator.isNull(cmd)) {\n\t\t\t\tUploadException uploadException =\n\t\t\t\t\t(UploadException)actionRequest.getAttribute(\n\t\t\t\t\t\tWebKeys.UPLOAD_EXCEPTION);\n\n\t\t\t\tif (uploadException != null) {\n\t\t\t\t\tif (uploadException.isExceededSizeLimit()) {\n\t\t\t\t\t\tthrow new ArticleContentSizeException();\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new PortalException(uploadException.getCause());\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.ADD) ||\n\t\t\t\t\t cmd.equals(Constants.TRANSLATE) ||\n\t\t\t\t\t cmd.equals(Constants.UPDATE)) {\n\n\t\t\t\tObject[] returnValue = updateArticle(actionRequest);\n\n\t\t\t\tarticle = (JournalArticle)returnValue[0];\n\t\t\t\toldUrlTitle = ((String)returnValue[1]);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteArticles(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE_TRANSLATION)) {\n\t\t\t\tremoveArticlesLocale(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.EXPIRE)) {\n\t\t\t\texpireArticles(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.MOVE)) {\n\t\t\t\tmoveArticles(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.SUBSCRIBE)) {\n\t\t\t\tsubscribeArticles(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UNSUBSCRIBE)) {\n\t\t\t\tunsubscribeArticles(actionRequest);\n\t\t\t}\n\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\t\tint workflowAction = ParamUtil.getInteger(\n\t\t\t\tactionRequest, \"workflowAction\",\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH);\n\n\t\t\tif ((article != null) &&\n\t\t\t\t(workflowAction == WorkflowConstants.ACTION_SAVE_DRAFT)) {\n\n\t\t\t\tredirect = getSaveAndContinueRedirect(\n\t\t\t\t\tportletConfig, actionRequest, article, redirect);\n\t\t\t}\n\n\t\t\tif (redirect.contains(\"/content/\" + oldUrlTitle + \"?\")) {\n\t\t\t\tint pos = redirect.indexOf(\"?\");\n\n\t\t\t\tif (pos == -1) {\n\t\t\t\t\tpos = redirect.length();\n\t\t\t\t}\n\n\t\t\t\tString newRedirect = redirect.substring(\n\t\t\t\t\t0, pos - oldUrlTitle.length());\n\n\t\t\t\tnewRedirect += article.getUrlTitle();\n\n\t\t\t\tif (oldUrlTitle.contains(\"/maximized\")) {\n\t\t\t\t\tnewRedirect += \"/maximized\";\n\t\t\t\t}\n\n\t\t\t\tif (pos < redirect.length()) {\n\t\t\t\t\tnewRedirect += \"?\" + redirect.substring(pos + 1);\n\t\t\t\t}\n\n\t\t\t\tredirect = newRedirect;\n\t\t\t}\n\n\t\t\tWindowState windowState = actionRequest.getWindowState();\n\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)actionRequest.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tLayout layout = themeDisplay.getLayout();\n\n\t\t\tif (cmd.equals(Constants.DELETE_TRANSLATION) ||\n\t\t\t\tcmd.equals(Constants.TRANSLATE)) {\n\n\t\t\t\tsetForward(\n\t\t\t\t\tactionRequest,\n\t\t\t\t\t\"portlet.journal.update_translation_redirect\");\n\t\t\t}\n\t\t\telse if (!windowState.equals(LiferayWindowState.POP_UP) &&\n\t\t\t\t\t layout.isTypeControlPanel()) {\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tredirect = PortalUtil.escapeRedirect(redirect);\n\n\t\t\t\tif (Validator.isNotNull(redirect)) {\n\t\t\t\t\tactionResponse.sendRedirect(redirect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchArticleException ||\n\t\t\t\te instanceof NoSuchStructureException ||\n\t\t\t\te instanceof NoSuchTemplateException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.journal.error\");\n\t\t\t}\n\t\t\telse if (e instanceof ArticleContentException ||\n\t\t\t\t\t e instanceof ArticleContentSizeException ||\n\t\t\t\t\t e instanceof ArticleDisplayDateException ||\n\t\t\t\t\t e instanceof ArticleExpirationDateException ||\n\t\t\t\t\t e instanceof ArticleIdException ||\n\t\t\t\t\t e instanceof ArticleSmallImageNameException ||\n\t\t\t\t\t e instanceof ArticleSmallImageSizeException ||\n\t\t\t\t\t e instanceof ArticleTitleException ||\n\t\t\t\t\t e instanceof ArticleTypeException ||\n\t\t\t\t\t e instanceof ArticleVersionException ||\n\t\t\t\t\t e instanceof DuplicateArticleIdException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse if (e instanceof AssetCategoryException ||\n\t\t\t\t\t e instanceof AssetTagException ||\n\t\t\t\t\t e instanceof LocaleException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass(), e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":73393,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tJournalArticle article = null;\n\t\tString oldUrlTitle = StringPool.BLANK;\n\n\t\ttry {\n\t\t\tif (Validator.isNull(cmd)) {\n\t\t\t\tUploadException uploadException =\n\t\t\t\t\t(UploadException)actionRequest.getAttribute(\n\t\t\t\t\t\tWebKeys.UPLOAD_EXCEPTION);\n\n\t\t\t\tif (uploadException != null) {\n\t\t\t\t\tif (uploadException.isExceededSizeLimit()) {\n\t\t\t\t\t\tthrow new ArticleContentSizeException();\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new PortalException(uploadException.getCause());\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.ADD) ||\n\t\t\t\t\t cmd.equals(Constants.TRANSLATE) ||\n\t\t\t\t\t cmd.equals(Constants.UPDATE)) {\n\n\t\t\t\tObject[] returnValue = updateArticle(actionRequest);\n\n\t\t\t\tarticle = (JournalArticle)returnValue[0];\n\t\t\t\toldUrlTitle = ((String)returnValue[1]);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteArticles(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE_TRANSLATION)) {\n\t\t\t\tremoveArticlesLocale(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.EXPIRE)) {\n\t\t\t\texpireArticles(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.MOVE)) {\n\t\t\t\tmoveArticles(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.SUBSCRIBE)) {\n\t\t\t\tsubscribeArticles(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UNSUBSCRIBE)) {\n\t\t\t\tunsubscribeArticles(actionRequest);\n\t\t\t}\n\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\t\tint workflowAction = ParamUtil.getInteger(\n\t\t\t\tactionRequest, \"workflowAction\",\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH);\n\n\t\t\tif ((article != null) &&\n\t\t\t\t(workflowAction == WorkflowConstants.ACTION_SAVE_DRAFT)) {\n\n\t\t\t\tredirect = getSaveAndContinueRedirect(\n\t\t\t\t\tportletConfig, actionRequest, article, redirect);\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(oldUrlTitle)) {\n\t\t\t\tString portletId = HttpUtil.getParameter(\n\t\t\t\t\tredirect, \"p_p_id\", false);\n\n\t\t\t\tString oldRedirectParamName =\n\t\t\t\t\tPortalUtil.getPortletNamespace(portletId) + \"redirect\";\n\n\t\t\t\tString oldRedirect = HttpUtil.getParameter(\n\t\t\t\t\tredirect, oldRedirectParamName, false);\n\n\t\t\t\tString newRedirect = null;\n\n\t\t\t\tif (Validator.isNotNull(oldRedirect)) {\n\t\t\t\t\tnewRedirect = HttpUtil.decodeURL(oldRedirect);\n\n\t\t\t\t\tnewRedirect = StringUtil.replace(\n\t\t\t\t\t\tnewRedirect, oldUrlTitle, article.getUrlTitle());\n\n\t\t\t\t\tnewRedirect = newRedirect.replace(\n\t\t\t\t\t\toldRedirectParamName, \"redirect\");\n\n\t\t\t\t\tredirect = redirect.replace(oldRedirect, newRedirect);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWindowState windowState = actionRequest.getWindowState();\n\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)actionRequest.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tLayout layout = themeDisplay.getLayout();\n\n\t\t\tif (cmd.equals(Constants.DELETE_TRANSLATION) ||\n\t\t\t\tcmd.equals(Constants.TRANSLATE)) {\n\n\t\t\t\tsetForward(\n\t\t\t\t\tactionRequest,\n\t\t\t\t\t\"portlet.journal.update_translation_redirect\");\n\t\t\t}\n\t\t\telse if (!windowState.equals(LiferayWindowState.POP_UP) &&\n\t\t\t\t\t layout.isTypeControlPanel()) {\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tredirect = PortalUtil.escapeRedirect(redirect);\n\n\t\t\t\tif (Validator.isNotNull(redirect)) {\n\t\t\t\t\tactionResponse.sendRedirect(redirect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchArticleException ||\n\t\t\t\te instanceof NoSuchStructureException ||\n\t\t\t\te instanceof NoSuchTemplateException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.journal.error\");\n\t\t\t}\n\t\t\telse if (e instanceof ArticleContentException ||\n\t\t\t\t\t e instanceof ArticleContentSizeException ||\n\t\t\t\t\t e instanceof ArticleDisplayDateException ||\n\t\t\t\t\t e instanceof ArticleExpirationDateException ||\n\t\t\t\t\t e instanceof ArticleIdException ||\n\t\t\t\t\t e instanceof ArticleSmallImageNameException ||\n\t\t\t\t\t e instanceof ArticleSmallImageSizeException ||\n\t\t\t\t\t e instanceof ArticleTitleException ||\n\t\t\t\t\t e instanceof ArticleTypeException ||\n\t\t\t\t\t e instanceof ArticleVersionException ||\n\t\t\t\t\t e instanceof DuplicateArticleIdException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse if (e instanceof AssetCategoryException ||\n\t\t\t\t\t e instanceof AssetTagException ||\n\t\t\t\t\t e instanceof LocaleException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass(), e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"b73daf38fffda85b4d3f7ed0b4689450e9a6de93","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tBlogsEntry entry = null;\n\t\t\tString oldUrlTitle = StringPool.BLANK;\n\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tObject[] returnValue = updateEntry(actionRequest);\n\n\t\t\t\tentry = (BlogsEntry)returnValue[0];\n\t\t\t\toldUrlTitle = ((String)returnValue[1]);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteEntries(\n\t\t\t\t\t(LiferayPortletConfig)portletConfig, actionRequest, false);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.MOVE_TO_TRASH)) {\n\t\t\t\tdeleteEntries(\n\t\t\t\t\t(LiferayPortletConfig)portletConfig, actionRequest, true);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.SUBSCRIBE)) {\n\t\t\t\tsubscribe(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.RESTORE)) {\n\t\t\t\trestoreEntries(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UNSUBSCRIBE)) {\n\t\t\t\tunsubscribe(actionRequest);\n\t\t\t}\n\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\t\t\tboolean updateRedirect = false;\n\n\t\t\tif (redirect.contains(\"/blogs/\" + oldUrlTitle + \"/maximized\")) {\n\t\t\t\toldUrlTitle += \"/maximized\";\n\t\t\t}\n\n\t\t\tif ((entry != null) && Validator.isNotNull(oldUrlTitle) &&\n\t\t\t\t(redirect.endsWith(\"/blogs/\" + oldUrlTitle) ||\n\t\t\t\t redirect.contains(\"/blogs/\" + oldUrlTitle + \"?\") ||\n\t\t\t\t redirect.contains(\"/blog/\" + oldUrlTitle + \"?\"))) {\n\n\t\t\t\tint pos = redirect.indexOf(\"?\");\n\n\t\t\t\tif (pos == -1) {\n\t\t\t\t\tpos = redirect.length();\n\t\t\t\t}\n\n\t\t\t\tString newRedirect = redirect.substring(\n\t\t\t\t\t0, pos - oldUrlTitle.length());\n\n\t\t\t\tnewRedirect += entry.getUrlTitle();\n\n\t\t\t\tif (oldUrlTitle.indexOf(\"/maximized\") != -1) {\n\t\t\t\t\tnewRedirect += \"/maximized\";\n\t\t\t\t}\n\n\t\t\t\tif (pos < redirect.length()) {\n\t\t\t\t\tnewRedirect += \"?\" + redirect.substring(pos + 1);\n\t\t\t\t}\n\n\t\t\t\tredirect = newRedirect;\n\t\t\t\tupdateRedirect = true;\n\t\t\t}\n\n\t\t\tint workflowAction = ParamUtil.getInteger(\n\t\t\t\tactionRequest, \"workflowAction\",\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\n\t\t\tboolean ajax = ParamUtil.getBoolean(actionRequest, \"ajax\");\n\n\t\t\tif (ajax) {\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.put(\"entryId\", entry.getEntryId());\n\t\t\t\tjsonObject.put(\"redirect\", redirect);\n\t\t\t\tjsonObject.put(\"updateRedirect\", updateRedirect);\n\n\t\t\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ((entry != null) &&\n\t\t\t\t(workflowAction == WorkflowConstants.ACTION_SAVE_DRAFT)) {\n\n\t\t\t\tredirect = getSaveAndContinueRedirect(\n\t\t\t\t\tportletConfig, actionRequest, entry, redirect);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tWindowState windowState = actionRequest.getWindowState();\n\n\t\t\t\tif (!windowState.equals(LiferayWindowState.POP_UP)) {\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tredirect = PortalUtil.escapeRedirect(redirect);\n\n\t\t\t\t\tif (Validator.isNotNull(redirect)) {\n\t\t\t\t\t\tactionResponse.sendRedirect(redirect);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchEntryException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.blogs.error\");\n\t\t\t}\n\t\t\telse if (e instanceof EntryContentException ||\n\t\t\t\t\t e instanceof EntryDisplayDateException ||\n\t\t\t\t\t e instanceof EntrySmallImageNameException ||\n\t\t\t\t\t e instanceof EntrySmallImageSizeException ||\n\t\t\t\t\t e instanceof EntryTitleException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse if (e instanceof AssetCategoryException ||\n\t\t\t\t\t e instanceof AssetTagException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass(), e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":73394,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tBlogsEntry entry = null;\n\t\t\tString oldUrlTitle = StringPool.BLANK;\n\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tObject[] returnValue = updateEntry(actionRequest);\n\n\t\t\t\tentry = (BlogsEntry)returnValue[0];\n\t\t\t\toldUrlTitle = ((String)returnValue[1]);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteEntries(\n\t\t\t\t\t(LiferayPortletConfig)portletConfig, actionRequest, false);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.MOVE_TO_TRASH)) {\n\t\t\t\tdeleteEntries(\n\t\t\t\t\t(LiferayPortletConfig)portletConfig, actionRequest, true);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.SUBSCRIBE)) {\n\t\t\t\tsubscribe(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.RESTORE)) {\n\t\t\t\trestoreEntries(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UNSUBSCRIBE)) {\n\t\t\t\tunsubscribe(actionRequest);\n\t\t\t}\n\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\t\t\tboolean updateRedirect = false;\n\n\t\t\tif (Validator.isNotNull(oldUrlTitle)) {\n\t\t\t\tString portletId = HttpUtil.getParameter(\n\t\t\t\t\tredirect, \"p_p_id\", false);\n\n\t\t\t\tString oldRedirectParamName =\n\t\t\t\t\tPortalUtil.getPortletNamespace(portletId) + \"redirect\";\n\n\t\t\t\tString oldRedirect = HttpUtil.getParameter(\n\t\t\t\t\tredirect, oldRedirectParamName, false);\n\n\t\t\t\tString newRedirect = null;\n\n\t\t\t\tif (Validator.isNotNull(oldRedirect)) {\n\t\t\t\t\tnewRedirect = HttpUtil.decodeURL(oldRedirect);\n\n\t\t\t\t\tnewRedirect = StringUtil.replace(\n\t\t\t\t\t\tnewRedirect, oldUrlTitle, entry.getUrlTitle());\n\n\t\t\t\t\tnewRedirect = newRedirect.replace(\n\t\t\t\t\t\toldRedirectParamName, \"redirect\");\n\n\t\t\t\t\tredirect = redirect.replace(oldRedirect, newRedirect);\n\t\t\t\t}\n\t\t\t\telse if (redirect.endsWith(\"/blogs/\" + oldUrlTitle) ||\n\t\t\t\t\t\tredirect.contains(\"/blogs/\" + oldUrlTitle + \"?\") ||\n\t\t\t\t\t\tredirect.contains(\"/blog/\" + oldUrlTitle + \"?\")) {\n\n\t\t\t\t\tredirect = StringUtil.replace(\n\t\t\t\t\t\tredirect, oldUrlTitle, entry.getUrlTitle());\n\t\t\t\t}\n\n\t\t\t\tupdateRedirect = true;\n\t\t\t}\n\n\t\t\tint workflowAction = ParamUtil.getInteger(\n\t\t\t\tactionRequest, \"workflowAction\",\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\n\t\t\tboolean ajax = ParamUtil.getBoolean(actionRequest, \"ajax\");\n\n\t\t\tif (ajax) {\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tjsonObject.put(\"entryId\", entry.getEntryId());\n\t\t\t\tjsonObject.put(\"redirect\", redirect);\n\t\t\t\tjsonObject.put(\"updateRedirect\", updateRedirect);\n\n\t\t\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ((entry != null) &&\n\t\t\t\t(workflowAction == WorkflowConstants.ACTION_SAVE_DRAFT)) {\n\n\t\t\t\tredirect = getSaveAndContinueRedirect(\n\t\t\t\t\tportletConfig, actionRequest, entry, redirect);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tWindowState windowState = actionRequest.getWindowState();\n\n\t\t\t\tif (!windowState.equals(LiferayWindowState.POP_UP)) {\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tredirect = PortalUtil.escapeRedirect(redirect);\n\n\t\t\t\t\tif (Validator.isNotNull(redirect)) {\n\t\t\t\t\t\tactionResponse.sendRedirect(redirect);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchEntryException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.blogs.error\");\n\t\t\t}\n\t\t\telse if (e instanceof EntryContentException ||\n\t\t\t\t\t e instanceof EntryDisplayDateException ||\n\t\t\t\t\t e instanceof EntrySmallImageNameException ||\n\t\t\t\t\t e instanceof EntrySmallImageSizeException ||\n\t\t\t\t\t e instanceof EntryTitleException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse if (e instanceof AssetCategoryException ||\n\t\t\t\t\t e instanceof AssetTagException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass(), e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"b73daf38fffda85b4d3f7ed0b4689450e9a6de93","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getURLViewInContext(\n\t\t\tLiferayPortletRequest liferayPortletRequest,\n\t\t\tLiferayPortletResponse liferayPortletResponse,\n\t\t\tString noSuchEntryRedirect)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)liferayPortletRequest.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString languageId = LanguageUtil.getLanguageId(liferayPortletRequest);\n\n\t\tJournalArticleDisplay articleDisplay = JournalContentUtil.getDisplay(\n\t\t\t_article.getGroupId(), _article.getArticleId(), null, null,\n\t\t\tlanguageId, themeDisplay);\n\n\t\tif (articleDisplay == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tPortletURL portletURL = liferayPortletResponse.createRenderURL();\n\n\t\tportletURL.setParameter(\n\t\t\t\"struts_action\", \"/asset_publisher/view_content\");\n\t\tportletURL.setParameter(\"urlTitle\", _article.getUrlTitle());\n\t\tportletURL.setParameter(\n\t\t\t\"type\", JournalArticleAssetRendererFactory.TYPE);\n\n\t\treturn portletURL.toString();\n\t}","id":73395,"modified_method":"public String getURLViewInContext(\n\t\t\tLiferayPortletRequest liferayPortletRequest,\n\t\t\tLiferayPortletResponse liferayPortletResponse,\n\t\t\tString noSuchEntryRedirect)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)liferayPortletRequest.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong groupId = _article.getGroupId();\n\t\tGroup group;\n\n\t\tif (themeDisplay.getScopeGroup().getGroupId() == groupId) {\n\t\t\tgroup = themeDisplay.getScopeGroup();\n\t\t}\n\t\telse {\n\t\t\tgroup = GroupLocalServiceUtil.getGroup(groupId);\n\t\t}\n\n\t\treturn PortalUtil.getGroupFriendlyURL(group, false, themeDisplay) +\n\t\t\tJournalArticleConstants.CANONICAL_URL_SEPARATOR +\n\t\t\t_article.getUrlTitle();\n\t}","commit_id":"9d83c5828950a36931ae8846a02df385492b5099","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getURLViewInContext(\n\t\t\tLiferayPortletRequest liferayPortletRequest,\n\t\t\tLiferayPortletResponse liferayPortletResponse,\n\t\t\tString noSuchEntryRedirect)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)liferayPortletRequest.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString languageId = LanguageUtil.getLanguageId(liferayPortletRequest);\n\n\t\tJournalArticleDisplay articleDisplay = JournalContentUtil.getDisplay(\n\t\t\t_article.getGroupId(), _article.getArticleId(), null, null,\n\t\t\tlanguageId, themeDisplay);\n\n\t\tif (articleDisplay == null) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tPortletURL portletURL = liferayPortletResponse.createRenderURL();\n\n\t\tportletURL.setParameter(\n\t\t\t\"struts_action\", \"/asset_publisher/view_content\");\n\t\tportletURL.setParameter(\"urlTitle\", _article.getUrlTitle());\n\t\tportletURL.setParameter(\n\t\t\t\"type\", JournalArticleAssetRendererFactory.TYPE);\n\n\t\treturn portletURL.toString();\n\t}","id":73396,"modified_method":"public String getURLViewInContext(\n\t\t\tLiferayPortletRequest liferayPortletRequest,\n\t\t\tLiferayPortletResponse liferayPortletResponse,\n\t\t\tString noSuchEntryRedirect)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)liferayPortletRequest.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong groupId = _article.getGroupId();\n\t\tGroup group;\n\n\t\tif (themeDisplay.getScopeGroup().getGroupId() == groupId) {\n\t\t\tgroup = themeDisplay.getScopeGroup();\n\t\t}\n\t\telse {\n\t\t\tgroup = GroupLocalServiceUtil.getGroup(groupId);\n\t\t}\n\n\t\treturn PortalUtil.getGroupFriendlyURL(group, false, themeDisplay) +\n\t\t\tJournalArticleConstants.CANONICAL_URL_SEPARATOR +\n\t\t\t_article.getUrlTitle();\n\t}","commit_id":"1cae6e1103d36fccd0c6e446d0ed3240c05346f8","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Creates a new native client wrapper from the given parameters (internal use only).\n     *\n     * @param clientConnectionKeyBase\n     *            the base hash/key for this connection, as defined by the pool.\n     * @param clientConnectionKey\n     *            the actual hash/key for this connection, as defined by the pool (may contain a\n     *            trailing index when the pool decides a new client needs to be created based on the\n     *            number of clients).\n     * @param servers\n     *            the list of VoltDB servers to connect to in hostname[:port] format.\n     * @param user\n     *            the user name to use when connecting to the server(s).\n     * @param password\n     *            the password to use when connecting to the server(s).\n     * @param isHeavyWeight\n     *            the flag indicating callback processes on this connection will be heavy (long\n     *            running callbacks). By default the connection only allocates one background\n     *            processing thread to process callbacks. If those callbacks run for a long time,\n     *            the network stack can get clogged with pending responses that have yet to be\n     *            processed, at which point the server will disconnect the application, thinking it\n     *            died and is not reading responses as fast as it is pushing requests. When the flag\n     *            is set to 'true', an additional 2 processing thread will deal with processing\n     *            callbacks, thus mitigating the issue.\n     * @param maxOutstandingTxns\n     *            the number of transactions the client application may push against a specific\n     *            connection before getting blocked on back-pressure. By default the connection\n     *            allows 3,000 open transactions before preventing the client from posting more\n     *            work, thus preventing server fire-hosing. In some cases however, with very fast,\n     *            small transactions, this limit can be raised.\n     * @throws IOException\n     * @throws UnknownHostException\n     */\n    protected JDBC4ClientConnection(\n            String clientConnectionKeyBase, String clientConnectionKey,\n            String[] servers, String user, String password, boolean isHeavyWeight,\n            int maxOutstandingTxns)\n                    throws UnknownHostException, IOException\n    {\n        // Save the list of trimmed non-empty server names.\n        this.servers = new ArrayList<String>(servers.length);\n        for (String server : servers) {\n            server = server.trim();\n            if (!server.isEmpty()) {\n                this.servers.add(server);\n            }\n        }\n        if (this.servers.isEmpty()) {\n            throw new UnknownHostException(\"JDBC4ClientConnection: no servers provided\");\n        }\n\n        this.keyBase = clientConnectionKeyBase;\n        this.key = clientConnectionKey;\n        this.statistics = JDBC4ClientConnectionPool.getStatistics(clientConnectionKeyBase);\n\n        // Create configuration\n        this.config = new ClientConfig(user, password);\n        config.setHeavyweight(isHeavyWeight);\n        if (maxOutstandingTxns > 0)\n            config.setMaxOutstandingTxns(maxOutstandingTxns);\n\n        // Create client and connect.\n        createClientAndConnect();\n    }","id":73397,"modified_method":"/**\n     * Creates a new native client wrapper from the given parameters (internal use only).\n     *\n     * @param clientConnectionKeyBase\n     *            the base hash/key for this connection, as defined by the pool.\n     * @param clientConnectionKey\n     *            the actual hash/key for this connection, as defined by the pool (may contain a\n     *            trailing index when the pool decides a new client needs to be created based on the\n     *            number of clients).\n     * @param servers\n     *            the list of VoltDB servers to connect to in hostname[:port] format.\n     * @param user\n     *            the user name to use when connecting to the server(s).\n     * @param password\n     *            the password to use when connecting to the server(s).\n     * @param isHeavyWeight\n     *            the flag indicating callback processes on this connection will be heavy (long\n     *            running callbacks). By default the connection only allocates one background\n     *            processing thread to process callbacks. If those callbacks run for a long time,\n     *            the network stack can get clogged with pending responses that have yet to be\n     *            processed, at which point the server will disconnect the application, thinking it\n     *            died and is not reading responses as fast as it is pushing requests. When the flag\n     *            is set to 'true', an additional 2 processing thread will deal with processing\n     *            callbacks, thus mitigating the issue.\n     * @param maxOutstandingTxns\n     *            the number of transactions the client application may push against a specific\n     *            connection before getting blocked on back-pressure. By default the connection\n     *            allows 3,000 open transactions before preventing the client from posting more\n     *            work, thus preventing server fire-hosing. In some cases however, with very fast,\n     *            small transactions, this limit can be raised.\n     * @throws IOException\n     * @throws UnknownHostException\n     */\n    protected JDBC4ClientConnection(\n            String clientConnectionKeyBase, String clientConnectionKey,\n            String[] servers, String user, String password, boolean isHeavyWeight,\n            int maxOutstandingTxns)\n                    throws UnknownHostException, IOException\n    {\n        // Save the list of trimmed non-empty server names.\n        this.servers = new ArrayList<String>(servers.length);\n        for (String server : servers) {\n            server = server.trim();\n            if (!server.isEmpty()) {\n                this.servers.add(server);\n            }\n        }\n        if (this.servers.isEmpty()) {\n            throw new UnknownHostException(\"JDBC4ClientConnection: no servers provided\");\n        }\n\n        this.keyBase = clientConnectionKeyBase;\n        this.key = clientConnectionKey;\n\n        // Create configuration\n        this.config = new ClientConfig(user, password);\n        config.setHeavyweight(isHeavyWeight);\n        if (maxOutstandingTxns > 0)\n            config.setMaxOutstandingTxns(maxOutstandingTxns);\n\n        // Create client and connect.\n        createClientAndConnect();\n    }","commit_id":"9059614ec0b6ac348395beb519cd733fcd5d9c54","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Executes a procedure synchronously and returns the result to the caller. The method\n     * internally tracks execution performance.\n     *\n     * @param procedure\n     *            the name of the procedure to call.\n     * @param parameters\n     *            the list of parameters to pass to the procedure.\n     * @return the response sent back by the VoltDB cluster for the procedure execution.\n     * @throws IOException\n     * @throws NoConnectionsException\n     * @throws ProcCallException\n     */\n    public ClientResponse execute(String procedure, long timeout, Object... parameters)\n            throws NoConnectionsException, IOException, ProcCallException {\n        long start = System.currentTimeMillis();\n        ClientImpl currentClient = this.getClient();\n        try {\n            // If connections are lost try reconnecting.\n            ClientResponse response = currentClient.callProcedureWithTimeout(procedure, timeout, TimeUnit.SECONDS, parameters);\n            this.statistics.update(procedure, response);\n            return response;\n        }\n        catch (ProcCallException pce) {\n            this.statistics.update(procedure, System.currentTimeMillis() - start, false);\n            throw pce;\n        }\n        catch (NoConnectionsException e) {\n            this.statistics.update(procedure, System.currentTimeMillis() - start, false);\n            this.dropClient(currentClient);\n            throw e;\n        }\n    }","id":73398,"modified_method":"/**\n     * Executes a procedure synchronously and returns the result to the caller. The method\n     * internally tracks execution performance.\n     *\n     * @param procedure\n     *            the name of the procedure to call.\n     * @param parameters\n     *            the list of parameters to pass to the procedure.\n     * @return the response sent back by the VoltDB cluster for the procedure execution.\n     * @throws IOException\n     * @throws NoConnectionsException\n     * @throws ProcCallException\n     */\n    public ClientResponse execute(String procedure, long timeout, Object... parameters)\n            throws NoConnectionsException, IOException, ProcCallException {\n        long start = System.currentTimeMillis();\n        ClientImpl currentClient = this.getClient();\n        try {\n            // If connections are lost try reconnecting.\n            ClientResponse response = currentClient.callProcedureWithTimeout(procedure, timeout, TimeUnit.SECONDS, parameters);\n            return response;\n        }\n        catch (ProcCallException pce) {\n            throw pce;\n        }\n        catch (NoConnectionsException e) {\n            this.dropClient(currentClient);\n            throw e;\n        }\n    }","commit_id":"9059614ec0b6ac348395beb519cd733fcd5d9c54","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Save statistics to a CSV file.\n     *\n     * @param file\n     *            File path\n     * @throws IOException\n     */\n    public void saveStatistics(String file) throws IOException {\n        if (file != null && !file.trim().isEmpty()) {\n            FileWriter fw = new FileWriter(file);\n            fw.write(getStatistics().toRawString(','));\n            fw.flush();\n            fw.close();\n        }\n    }","id":73399,"modified_method":"/**\n     * Save statistics to a CSV file.\n     *\n     * @param file\n     *            File path\n     * @throws IOException\n     */\n    public void saveStatistics(ClientStats stats, String file) throws IOException {\n        this.client.get().writeSummaryCSV(stats, file);\n    }","commit_id":"9059614ec0b6ac348395beb519cd733fcd5d9c54","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n         * Processes the server response, tracking performance statistics internally, then calling\n         * the user-specified callback (if any).\n         */\n        @Override\n        public void clientCallback(ClientResponse response) throws Exception {\n\n            this.Owner.getStatistics().update(this.Procedure, response);\n            if (this.UserCallback != null)\n                this.UserCallback.clientCallback(response);\n        }","id":73400,"modified_method":"/**\n         * Processes the server response, tracking performance statistics internally, then calling\n         * the user-specified callback (if any).\n         */\n        @Override\n        public void clientCallback(ClientResponse response) throws Exception {\n            if (this.UserCallback != null)\n                this.UserCallback.clientCallback(response);\n        }","commit_id":"9059614ec0b6ac348395beb519cd733fcd5d9c54","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Deprecated\n    @Override\n    public void saveStatistics(String file) throws IOException\n    {\n        this.NativeConnection.saveStatistics(file);\n    }","id":73401,"modified_method":"@Override\n    public void saveStatistics(ClientStats stats, String file) throws IOException\n    {\n        this.NativeConnection.saveStatistics(stats, file);\n    }","commit_id":"9059614ec0b6ac348395beb519cd733fcd5d9c54","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static void main(String[] args)\n    {\n        try\n        {\n            KVConfig config = new KVConfig();\n            config.parse(JDBCBenchmark.class.getName(), args);\n\n            System.out.println(config.getConfigDumpString());\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // We need only do this once, to \"hot cache\" the JDBC driver reference so the JVM may realize it's there.\n            Class.forName(\"org.voltdb.jdbc.Driver\");\n\n            // Prepare the JDBC URL for the VoltDB driver\n            String url = \"jdbc:voltdb://\" + config.servers;\n\n            // Get a client connection - we retry for a while in case the server hasn't started yet\n            System.out.printf(\"Connecting to: %s\\n\", url);\n            int sleep = 1000;\n            while(true)\n            {\n                try\n                {\n                    Con = DriverManager.getConnection(url, \"\", \"\");\n                    break;\n                }\n                catch (Exception e)\n                {\n                    System.err.printf(\"Connection failed - retrying in %d second(s).\\n\", sleep/1000);\n                    try {Thread.sleep(sleep);} catch(Exception tie){}\n                    if (sleep < 8000)\n                        sleep += sleep;\n                }\n            }\n\n            // Statistics manager objects from the connection, used to generate latency histogram\n            ClientStatsContext fullStatsContext = ((IVoltDBConnection) Con).createStatsContext();\n\n            System.out.println(\"Connected.  Starting benchmark.\");\n\n            // Get a payload generator to create random Key-Value pairs to store in the database and process (uncompress) pairs retrieved from the database.\n            final PayloadProcessor processor = new PayloadProcessor(\n                    config.keysize, config.minvaluesize, config.maxvaluesize,\n                    config.entropy, config.poolsize, config.usecompression);\n\n            // Initialize the store\n            if (config.preload) {\n                System.out.print(\"Initializing data store... \");\n\n                final PreparedStatement removeCS = Con.prepareStatement(\"DELETE FROM store;\");\n                final CallableStatement putCS = Con.prepareCall(\"{call STORE.upsert(?,?)}\");\n                for(int i=0;i<config.poolsize ;i++) {\n                    if (i == 0) {\n                        removeCS.execute();\n                    }\n                    putCS.setString(1, String.format(processor.KeyFormat, i));\n                    putCS.setBytes(2,processor.generateForStore().getStoreValue());\n                    putCS.execute();\n                }\n                System.out.println(\" Done.\");\n            }\n            // start the stats\n            fullStatsContext.fetchAndResetBaseline();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create a Timer task to display performance data on the operating procedures\n            Timer timer = new Timer();\n            timer.scheduleAtFixedRate(new TimerTask()\n            {\n                @Override\n                public void run()\n                {\n                    try { System.out.print(Con.unwrap(IVoltDBConnection.class).getStatistics(\"STORE.select\", \"STORE.upsert\")); } catch(Exception x) {}\n                }\n            }\n            , config.displayinterval*1000l\n            , config.displayinterval*1000l\n            );\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create multiple processing threads\n            ArrayList<Thread> threads = new ArrayList<Thread>();\n            for (int i = 0; i < config.threads; i++)\n                threads.add(new Thread(new ClientThread(url, processor, config.duration, config.getputratio)));\n\n            // Start threads\n            for (Thread thread : threads)\n                thread.start();\n\n            // Wait for threads to complete\n            for (Thread thread : threads)\n                thread.join();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // We're done - stop the performance statistics display task\n            timer.cancel();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Now print application results:\n\n            // stop and fetch the stats\n            ClientStats stats = fullStatsContext.fetch().getStats();\n\n            // 1. Store statistics as tracked by the application (ops counts, payload traffic)\n            System.out.printf(\n              \"\\n-------------------------------------------------------------------------------------\\n\"\n            + \" Store Results\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\"\n            + \"A total of %,d operations was posted...\\n\"\n            + \" - GETs: %,9d Operations (%,9d Misses/Failures)\\n\"\n            + \"         %,9d MB in compressed store data\\n\"\n            + \"         %,9d MB in uncompressed application data\\n\"\n            + \"         Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \" - PUTs: %,9d Operations (%,9d Failures)\\n\"\n            + \"         %,9d MB in compressed store data\\n\"\n            + \"         %,9d MB in uncompressed application data\\n\"\n            + \"         Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \" - Total Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \"* Figure includes key & value traffic but not database protocol overhead.\\n\"\n            + \"\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\"\n            , GetStoreResults.get(0)+GetStoreResults.get(1)+PutStoreResults.get(0)+PutStoreResults.get(1)\n            , GetStoreResults.get(0)\n            , GetStoreResults.get(1)\n            , GetCompressionResults.get(0)/1048576l\n            , GetCompressionResults.get(1)/1048576l\n            , ((double)GetCompressionResults.get(0) + (GetStoreResults.get(0)+GetStoreResults.get(1))*config.keysize)/(134217728d*config.duration)\n            , PutStoreResults.get(0)\n            , PutStoreResults.get(1)\n            , PutCompressionResults.get(0)/1048576l\n            , PutCompressionResults.get(1)/1048576l\n            , ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0)+PutStoreResults.get(1))*config.keysize)/(134217728d*config.duration)\n            , ((double)GetCompressionResults.get(0) + (GetStoreResults.get(0)+GetStoreResults.get(1))*config.keysize)/(134217728d*config.duration)\n            + ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0)+PutStoreResults.get(1))*config.keysize)/(134217728d*config.duration)\n            );\n\n            // 2. Overall performance statistics for GET/PUT operations\n            System.out.println(\n              \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n            + \" System Statistics\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.print(Con.unwrap(IVoltDBConnection.class).getStatistics(\"STORE.select\", \"STORE.upsert\").toString(false));\n\n            // 3. Per-procedure detailed performance statistics\n            System.out.println(\n              \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n            + \" Detailed Statistics\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.print(Con.unwrap(IVoltDBConnection.class).getStatistics().toString(false));\n\n            System.out.println(\n                    \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n                  + \" Client Latency Statistics\\n\"\n                  + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.printf(\"Average latency:               %,9.2f ms\\n\",\n                    stats.getAverageLatency());\n            System.out.printf(\"10th percentile latency:       %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.1));\n            System.out.printf(\"25th percentile latency:       %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.25));\n            System.out.printf(\"50th percentile latency:       %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.5));\n            System.out.printf(\"75th percentile latency:       %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.75));\n            System.out.printf(\"90th percentile latency:       %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.9));\n            System.out.printf(\"95th percentile latency:       %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.95));\n            System.out.printf(\"99th percentile latency:       %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.99));\n            System.out.printf(\"99.5th percentile latency:     %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.995));\n            System.out.printf(\"99.9th percentile latency:     %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.999));\n            System.out.println(\"\\n\\n\" + stats.latencyHistoReport());\n\n            // Dump statistics to a CSV file\n            Con.unwrap(IVoltDBConnection.class).saveStatistics(config.statsfile);\n\n            Con.close();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n        }\n        catch(Exception x)\n        {\n            System.out.println(\"Exception: \" + x);\n            x.printStackTrace();\n        }\n    }","id":73402,"modified_method":"public static void main(String[] args)\n    {\n        try\n        {\n            KVConfig config = new KVConfig();\n            config.parse(JDBCBenchmark.class.getName(), args);\n\n            System.out.println(config.getConfigDumpString());\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // We need only do this once, to \"hot cache\" the JDBC driver reference so the JVM may realize it's there.\n            Class.forName(\"org.voltdb.jdbc.Driver\");\n\n            // Prepare the JDBC URL for the VoltDB driver\n            String url = \"jdbc:voltdb://\" + config.servers;\n\n            // Get a client connection - we retry for a while in case the server hasn't started yet\n            System.out.printf(\"Connecting to: %s\\n\", url);\n            int sleep = 1000;\n            while(true)\n            {\n                try\n                {\n                    Con = DriverManager.getConnection(url, \"\", \"\");\n                    break;\n                }\n                catch (Exception e)\n                {\n                    System.err.printf(\"Connection failed - retrying in %d second(s).\\n\", sleep/1000);\n                    try {Thread.sleep(sleep);} catch(Exception tie){}\n                    if (sleep < 8000)\n                        sleep += sleep;\n                }\n            }\n\n            // Statistics manager objects from the connection, used to generate latency histogram\n            ClientStatsContext fullStatsContext = ((IVoltDBConnection) Con).createStatsContext();\n            periodicStatsContext = ((IVoltDBConnection) Con).createStatsContext();\n\n            System.out.println(\"Connected.  Starting benchmark.\");\n\n            // Get a payload generator to create random Key-Value pairs to store in the database and process (uncompress) pairs retrieved from the database.\n            final PayloadProcessor processor = new PayloadProcessor(\n                    config.keysize, config.minvaluesize, config.maxvaluesize,\n                    config.entropy, config.poolsize, config.usecompression);\n\n            // Initialize the store\n            if (config.preload) {\n                System.out.print(\"Initializing data store... \");\n\n                final PreparedStatement removeCS = Con.prepareStatement(\"DELETE FROM store;\");\n                final CallableStatement putCS = Con.prepareCall(\"{call STORE.upsert(?,?)}\");\n                for(int i=0;i<config.poolsize ;i++) {\n                    if (i == 0) {\n                        removeCS.execute();\n                    }\n                    putCS.setString(1, String.format(processor.KeyFormat, i));\n                    putCS.setBytes(2,processor.generateForStore().getStoreValue());\n                    putCS.execute();\n                }\n                System.out.println(\" Done.\");\n            }\n            // start the stats\n            fullStatsContext.fetchAndResetBaseline();\n            periodicStatsContext.fetchAndResetBaseline();\n            benchmarkStartTS = System.currentTimeMillis();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create a Timer task to display performance data on the operating procedures\n            Timer timer = new Timer();\n            TimerTask statsPrinting = new TimerTask() {\n                @Override\n                public void run() { printStatistics(); }\n            };\n            timer.scheduleAtFixedRate(statsPrinting\n            , config.displayinterval*1000l\n            , config.displayinterval*1000l\n            );\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create multiple processing threads\n            ArrayList<Thread> threads = new ArrayList<Thread>();\n            for (int i = 0; i < config.threads; i++)\n                threads.add(new Thread(new ClientThread(url, processor, config.duration, config.getputratio)));\n\n            // Start threads\n            for (Thread thread : threads)\n                thread.start();\n\n            // Wait for threads to complete\n            for (Thread thread : threads)\n                thread.join();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // We're done - stop the performance statistics display task\n            timer.cancel();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Now print application results:\n\n            // stop and fetch the stats\n            ClientStats stats = fullStatsContext.fetch().getStats();\n\n            // 1. Store statistics as tracked by the application (ops counts, payload traffic)\n            System.out.printf(\n              \"\\n-------------------------------------------------------------------------------------\\n\"\n            + \" Store Results\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\"\n            + \"A total of %,d operations was posted...\\n\"\n            + \" - GETs: %,9d Operations (%,9d Misses/Failures)\\n\"\n            + \"         %,9d MB in compressed store data\\n\"\n            + \"         %,9d MB in uncompressed application data\\n\"\n            + \"         Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \" - PUTs: %,9d Operations (%,9d Failures)\\n\"\n            + \"         %,9d MB in compressed store data\\n\"\n            + \"         %,9d MB in uncompressed application data\\n\"\n            + \"         Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \" - Total Network Throughput: %6.3f Gbps*\\n\\n\"\n            + \"* Figure includes key & value traffic but not database protocol overhead.\\n\"\n            + \"\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\"\n            , GetStoreResults.get(0)+GetStoreResults.get(1)+PutStoreResults.get(0)+PutStoreResults.get(1)\n            , GetStoreResults.get(0)\n            , GetStoreResults.get(1)\n            , GetCompressionResults.get(0)/1048576l\n            , GetCompressionResults.get(1)/1048576l\n            , ((double)GetCompressionResults.get(0) + (GetStoreResults.get(0)+GetStoreResults.get(1))*config.keysize)/(134217728d*config.duration)\n            , PutStoreResults.get(0)\n            , PutStoreResults.get(1)\n            , PutCompressionResults.get(0)/1048576l\n            , PutCompressionResults.get(1)/1048576l\n            , ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0)+PutStoreResults.get(1))*config.keysize)/(134217728d*config.duration)\n            , ((double)GetCompressionResults.get(0) + (GetStoreResults.get(0)+GetStoreResults.get(1))*config.keysize)/(134217728d*config.duration)\n            + ((double)PutCompressionResults.get(0) + (PutStoreResults.get(0)+PutStoreResults.get(1))*config.keysize)/(134217728d*config.duration)\n            );\n\n            System.out.println(\n                    \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n                  + \" Client Latency Statistics\\n\"\n                  + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.printf(\"Average latency:               %,9.2f ms\\n\",\n                    stats.getAverageLatency());\n            System.out.printf(\"10th percentile latency:       %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.1));\n            System.out.printf(\"25th percentile latency:       %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.25));\n            System.out.printf(\"50th percentile latency:       %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.5));\n            System.out.printf(\"75th percentile latency:       %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.75));\n            System.out.printf(\"90th percentile latency:       %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.9));\n            System.out.printf(\"95th percentile latency:       %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.95));\n            System.out.printf(\"99th percentile latency:       %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.99));\n            System.out.printf(\"99.5th percentile latency:     %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.995));\n            System.out.printf(\"99.9th percentile latency:     %,9.2f ms\\n\",\n                    stats.kPercentileLatencyAsDouble(.999));\n            System.out.println(\"\\n\\n\" + stats.latencyHistoReport());\n\n            // Dump statistics to a CSV file\n            Con.unwrap(IVoltDBConnection.class).saveStatistics(stats, config.statsfile);\n\n            Con.close();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n        }\n        catch(Exception x)\n        {\n            System.out.println(\"Exception: \" + x);\n            x.printStackTrace();\n        }\n    }","commit_id":"9059614ec0b6ac348395beb519cd733fcd5d9c54","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static void main(String[] args)\n    {\n        try\n        {\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Use the AppHelper utility class to retrieve command line application parameters\n\n            // Define parameters and pull from command line\n            AppHelper apph = new AppHelper(JDBCBenchmark.class.getCanonicalName())\n                .add(\"threads\", \"thread_count\", \"Number of concurrent threads attacking the database.\", 1)\n                .add(\"displayinterval\", \"display_interval_in_seconds\", \"Interval for performance feedback, in seconds.\", 10)\n                .add(\"duration\", \"run_duration_in_seconds\", \"Benchmark duration, in seconds.\", 120)\n                .add(\"servers\", \"comma_separated_server_list\", \"List of VoltDB servers to connect to.\", \"localhost\")\n                .add(\"port\", \"port_number\", \"Client port to connect to on cluster nodes.\", 21212)\n                .add(\"poolsize\", \"pool_size\", \"Size of the record pool to operate on - larger sizes will cause a higher insert/update-delete rate.\", 100000)\n                .add(\"procedure\", \"procedure_name\", \"Procedure to call.\", \"JiggleSinglePartition\")\n                .add(\"wait\", \"wait_duration\", \"Wait duration (only when calling one of the Wait procedures), in milliseconds.\", 0)\n                .setArguments(args)\n            ;\n\n            // Retrieve parameters\n            final int threadCount      = apph.intValue(\"threads\");\n            final long displayInterval = apph.longValue(\"displayinterval\");\n            final long duration        = apph.longValue(\"duration\");\n            final String servers       = apph.stringValue(\"servers\");\n            final int port             = apph.intValue(\"port\");\n            final int poolSize         = apph.intValue(\"poolsize\");\n            final String procedure     = apph.stringValue(\"procedure\");\n            final long wait            = apph.intValue(\"wait\");\n            final String csv           = apph.stringValue(\"statsfile\");\n\n            // Validate parameters\n            apph.validate(\"duration\", (duration > 0))\n                .validate(\"threads\", (threadCount > 0))\n                .validate(\"poolsize\", (poolSize > 0))\n                .validate(\"wait\", (wait >= 0))\n            ;\n\n            // Display actual parameters, for reference\n            apph.printActualUsage();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // We need only do this once, to \"hot cache\" the JDBC driver reference so the JVM may realize it's there.\n            Class.forName(\"org.voltdb.jdbc.Driver\");\n\n            // Prepare the JDBC URL for the VoltDB driver\n            String url = \"jdbc:voltdb://\" + servers + \":\" + port;\n\n            // Get a client connection - we retry for a while in case the server hasn't started yet\n            System.out.printf(\"Connecting to: %s\\n\", url);\n            int sleep = 1000;\n            while(true)\n            {\n                try\n                {\n                    Con = DriverManager.getConnection(url, \"\", \"\");\n                    break;\n                }\n                catch (Exception e)\n                {\n                    System.err.printf(\"Connection failed - retrying in %d second(s).\\n\", sleep/1000);\n                    try {Thread.sleep(sleep);} catch(Exception tie){}\n                    if (sleep < 8000)\n                        sleep += sleep;\n                }\n            }\n            System.out.println(\"Connected.  Starting benchmark.\");\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create a Timer task to display performance data on the procedure\n            Timer timer = new Timer();\n            timer.scheduleAtFixedRate(new TimerTask()\n            {\n                @Override\n                public void run()\n                {\n                    try { System.out.print(Con.unwrap(IVoltDBConnection.class).getStatistics(procedure)); } catch(Exception x) {}\n                }\n            }\n            , displayInterval*1000l\n            , displayInterval*1000l\n            );\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create multiple processing threads\n            ArrayList<Thread> threads = new ArrayList<Thread>();\n            for (int i = 0; i < threadCount; i++)\n                threads.add(new Thread(new ClientThread(url, procedure, poolSize, wait, duration)));\n\n            // Start threads\n            for (Thread thread : threads)\n                thread.start();\n\n            // Wait for threads to complete\n            for (Thread thread : threads)\n                thread.join();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // We're done - stop the performance statistics display task\n            timer.cancel();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Now print application results:\n\n            // 1. Tracking statistics\n            System.out.printf(\n              \"-------------------------------------------------------------------------------------\\n\"\n            + \" Benchmark Results\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\"\n            + \"A total of %d calls was received...\\n\"\n            + \" - %,9d Succeeded\\n\"\n            + \" - %,9d Failed (Transaction Error)\\n\"\n            + \"\\n\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\"\n            , TrackingResults.get(0)+TrackingResults.get(1)\n            , TrackingResults.get(0)\n            , TrackingResults.get(1)\n            );\n\n            // 3. Performance statistics (we only care about the procedure that we're benchmarking)\n            System.out.println(\n              \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n            + \" System Statistics\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.print(Con.unwrap(IVoltDBConnection.class).getStatistics(procedure).toString(false));\n\n            // Dump statistics to a CSV file\n            Con.unwrap(IVoltDBConnection.class).saveStatistics(csv);\n\n            Con.close();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n        }\n        catch(Exception x)\n        {\n            System.out.println(\"Exception: \" + x);\n            x.printStackTrace();\n        }\n    }","id":73403,"modified_method":"public static void main(String[] args)\n    {\n        try\n        {\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Use the AppHelper utility class to retrieve command line application parameters\n\n            // Define parameters and pull from command line\n            AppHelper apph = new AppHelper(JDBCBenchmark.class.getCanonicalName())\n                .add(\"threads\", \"thread_count\", \"Number of concurrent threads attacking the database.\", 1)\n                .add(\"displayinterval\", \"display_interval_in_seconds\", \"Interval for performance feedback, in seconds.\", 10)\n                .add(\"duration\", \"run_duration_in_seconds\", \"Benchmark duration, in seconds.\", 120)\n                .add(\"servers\", \"comma_separated_server_list\", \"List of VoltDB servers to connect to.\", \"localhost\")\n                .add(\"port\", \"port_number\", \"Client port to connect to on cluster nodes.\", 21212)\n                .add(\"poolsize\", \"pool_size\", \"Size of the record pool to operate on - larger sizes will cause a higher insert/update-delete rate.\", 100000)\n                .add(\"procedure\", \"procedure_name\", \"Procedure to call.\", \"JiggleSinglePartition\")\n                .add(\"wait\", \"wait_duration\", \"Wait duration (only when calling one of the Wait procedures), in milliseconds.\", 0)\n                .setArguments(args)\n            ;\n\n            // Retrieve parameters\n            final int threadCount      = apph.intValue(\"threads\");\n            final long displayInterval = apph.longValue(\"displayinterval\");\n            final long duration        = apph.longValue(\"duration\");\n            final String servers       = apph.stringValue(\"servers\");\n            final int port             = apph.intValue(\"port\");\n            final int poolSize         = apph.intValue(\"poolsize\");\n            final String procedure     = apph.stringValue(\"procedure\");\n            final long wait            = apph.intValue(\"wait\");\n            final String csv           = apph.stringValue(\"statsfile\");\n\n            // Validate parameters\n            apph.validate(\"duration\", (duration > 0))\n                .validate(\"threads\", (threadCount > 0))\n                .validate(\"poolsize\", (poolSize > 0))\n                .validate(\"wait\", (wait >= 0))\n            ;\n\n            // Display actual parameters, for reference\n            apph.printActualUsage();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // We need only do this once, to \"hot cache\" the JDBC driver reference so the JVM may realize it's there.\n            Class.forName(\"org.voltdb.jdbc.Driver\");\n\n            // Prepare the JDBC URL for the VoltDB driver\n            String url = \"jdbc:voltdb://\" + servers + \":\" + port;\n\n            // Get a client connection - we retry for a while in case the server hasn't started yet\n            System.out.printf(\"Connecting to: %s\\n\", url);\n            int sleep = 1000;\n            while(true)\n            {\n                try\n                {\n                    Con = DriverManager.getConnection(url, \"\", \"\");\n                    break;\n                }\n                catch (Exception e)\n                {\n                    System.err.printf(\"Connection failed - retrying in %d second(s).\\n\", sleep/1000);\n                    try {Thread.sleep(sleep);} catch(Exception tie){}\n                    if (sleep < 8000)\n                        sleep += sleep;\n                }\n            }\n            System.out.println(\"Connected.  Starting benchmark.\");\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            final ClientStatsContext fullStatsContext = ((IVoltDBConnection) Con).createStatsContext();\n            periodicStatsContext = ((IVoltDBConnection) Con).createStatsContext();\n            benchmarkStartTS = System.currentTimeMillis();\n\n            // Create a Timer task to display performance data on the procedure\n            Timer timer = new Timer();\n            TimerTask statsPrinting = new TimerTask() {\n                @Override\n                public void run() { printStatistics(); }\n            };\n            timer.scheduleAtFixedRate(statsPrinting\n            , displayInterval*1000l\n            , displayInterval*1000l\n            );\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Create multiple processing threads\n            ArrayList<Thread> threads = new ArrayList<Thread>();\n            for (int i = 0; i < threadCount; i++)\n                threads.add(new Thread(new ClientThread(url, procedure, poolSize, wait, duration)));\n\n            // Start threads\n            for (Thread thread : threads)\n                thread.start();\n\n            // Wait for threads to complete\n            for (Thread thread : threads)\n                thread.join();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // We're done - stop the performance statistics display task\n            timer.cancel();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n            // Now print application results:\n\n            // 1. Tracking statistics\n            System.out.printf(\n              \"-------------------------------------------------------------------------------------\\n\"\n            + \" Benchmark Results\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\"\n            + \"A total of %d calls was received...\\n\"\n            + \" - %,9d Succeeded\\n\"\n            + \" - %,9d Failed (Transaction Error)\\n\"\n            + \"\\n\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\"\n            , TrackingResults.get(0)+TrackingResults.get(1)\n            , TrackingResults.get(0)\n            , TrackingResults.get(1)\n            );\n\n            // 3. Performance statistics (we only care about the procedure that we're benchmarking)\n            System.out.println(\n              \"\\n\\n-------------------------------------------------------------------------------------\\n\"\n            + \" System Statistics\\n\"\n            + \"-------------------------------------------------------------------------------------\\n\\n\");\n            System.out.print(fullStatsContext.getStatsForProcedure(procedure).toString());\n\n            // Dump statistics to a CSV file\n            Con.unwrap(IVoltDBConnection.class).saveStatistics(fullStatsContext.getStats(), csv);\n\n            Con.close();\n\n// ---------------------------------------------------------------------------------------------------------------------------------------------------\n\n        }\n        catch(Exception x)\n        {\n            System.out.println(\"Exception: \" + x);\n            x.printStackTrace();\n        }\n    }","commit_id":"9059614ec0b6ac348395beb519cd733fcd5d9c54","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n\tpublic int create(TT model) throws SQLException {\n\t\tsuper.create(model);\n\n\t\tnotifyModelListenersOnCreate(model);\n\n\t\treturn 1;\n\t}","id":73404,"modified_method":"@Override\n\tpublic int create(TT model) throws SQLException {\n\t\tint rowCount = super.create(model);\n\n\t\tnotifyModelListenersOnCreate(model);\n\n\t\treturn rowCount;\n\t}","commit_id":"6780137eb9597e097e2a1f881c43df9c834c258d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static void cancelSyncAccountTasks(long syncAccountId)\n\t\tthrows Exception {\n\n\t\tObject[] syncAccountTasks = _syncAccountTasksMap.get(syncAccountId);\n\n\t\tScheduledFuture<?> scheduledFuture =\n\t\t\t(ScheduledFuture<?>)syncAccountTasks[0];\n\n\t\tscheduledFuture.cancel(false);\n\n\t\tWatcher watcher = (Watcher)syncAccountTasks[1];\n\n\t\twatcher.close();\n\t}","id":73405,"modified_method":"public static void cancelSyncAccountTasks(long syncAccountId)\n\t\tthrows Exception {\n\n\t\tObject[] syncAccountTasks = _syncAccountTasks.get(syncAccountId);\n\n\t\tScheduledFuture<?> scheduledFuture =\n\t\t\t(ScheduledFuture<?>)syncAccountTasks[0];\n\n\t\tscheduledFuture.cancel(false);\n\n\t\tWatcher watcher = (Watcher)syncAccountTasks[1];\n\n\t\twatcher.close();\n\t}","commit_id":"6780137eb9597e097e2a1f881c43df9c834c258d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static void scheduleSyncAccountTasks(long syncAccountId)\n\t\tthrows Exception {\n\n\t\tfinal SyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\tsyncAccountId);\n\n\t\tScheduledFuture<?> scheduledFuture =\n\t\t\t_eventScheduledExecutorService.scheduleAtFixedRate(\n\t\t\t\tnew Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tList<Long> syncSiteIds =\n\t\t\t\t\t\t\tSyncSiteService.getActiveSyncSiteIds(\n\t\t\t\t\t\t\t\tsyncAccount.getSyncAccountId());\n\n\t\t\t\t\t\tfor (long syncSiteId : syncSiteIds) {\n\t\t\t\t\t\t\tSyncSite syncSite = SyncSiteService.fetchSyncSite(\n\t\t\t\t\t\t\t\tsyncSiteId);\n\n\t\t\t\t\t\t\tMap<String, Object> parameters =\n\t\t\t\t\t\t\t\tnew HashMap<String, Object>();\n\n\t\t\t\t\t\t\tparameters.put(\n\t\t\t\t\t\t\t\t\"companyId\", syncSite.getCompanyId());\n\t\t\t\t\t\t\tparameters.put(\n\t\t\t\t\t\t\t\t\"repositoryId\", syncSite.getGroupId());\n\t\t\t\t\t\t\tparameters.put(\"syncSite\", syncSite);\n\n\t\t\t\t\t\t\tGetSyncDLObjectUpdateEvent\n\t\t\t\t\t\t\t\tgetSyncDLObjectUpdateEvent =\n\t\t\t\t\t\t\t\t\tnew GetSyncDLObjectUpdateEvent(\n\t\t\t\t\t\t\t\t\t\tsyncAccount.getSyncAccountId(),\n\t\t\t\t\t\t\t\t\t\tparameters);\n\n\t\t\t\t\t\t\tgetSyncDLObjectUpdateEvent.run();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t},\n\t\t\t\t0, syncAccount.getInterval(), TimeUnit.SECONDS);\n\n\t\tPath filePath = Paths.get(syncAccount.getFilePathName());\n\n\t\tWatchEventListener watchEventListener = new SyncSiteWatchEventListener(\n\t\t\tsyncAccount.getSyncAccountId());\n\n\t\tWatcher watcher = new Watcher(filePath, true, watchEventListener);\n\n\t\t_watcherExecutorService.execute(watcher);\n\n\t\t_syncAccountTasksMap.put(\n\t\t\tsyncAccountId, new Object[] {scheduledFuture, watcher});\n\t}","id":73406,"modified_method":"public static void scheduleSyncAccountTasks(long syncAccountId)\n\t\tthrows Exception {\n\n\t\tfinal SyncAccount syncAccount = SyncAccountService.fetchSyncAccount(\n\t\t\tsyncAccountId);\n\n\t\tRunnable runnable = new Runnable() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tList<Long> syncSiteIds =\n\t\t\t\t\tSyncSiteService.getActiveSyncSiteIds(\n\t\t\t\t\t\tsyncAccount.getSyncAccountId());\n\n\t\t\t\tfor (long syncSiteId : syncSiteIds) {\n\t\t\t\t\tSyncSite syncSite = SyncSiteService.fetchSyncSite(\n\t\t\t\t\t\tsyncSiteId);\n\n\t\t\t\t\tMap<String, Object> parameters =\n\t\t\t\t\t\tnew HashMap<String, Object>();\n\n\t\t\t\t\tparameters.put(\"companyId\", syncSite.getCompanyId());\n\t\t\t\t\tparameters.put(\"repositoryId\", syncSite.getGroupId());\n\t\t\t\t\tparameters.put(\"syncSite\", syncSite);\n\n\t\t\t\t\tGetSyncDLObjectUpdateEvent\n\t\t\t\t\t\tgetSyncDLObjectUpdateEvent =\n\t\t\t\t\t\t\tnew GetSyncDLObjectUpdateEvent(\n\t\t\t\t\t\t\t\tsyncAccount.getSyncAccountId(), parameters);\n\n\t\t\t\t\tgetSyncDLObjectUpdateEvent.run();\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t\tScheduledFuture<?> scheduledFuture =\n\t\t\t_eventScheduledExecutorService.scheduleAtFixedRate(\n\t\t\t\trunnable, 0, syncAccount.getInterval(), TimeUnit.SECONDS);\n\n\t\tPath filePath = Paths.get(syncAccount.getFilePathName());\n\n\t\tWatchEventListener watchEventListener = new SyncSiteWatchEventListener(\n\t\t\tsyncAccount.getSyncAccountId());\n\n\t\tWatcher watcher = new Watcher(filePath, true, watchEventListener);\n\n\t\t_watcherExecutorService.execute(watcher);\n\n\t\t_syncAccountTasks.put(\n\t\t\tsyncAccountId, new Object[] {scheduledFuture, watcher});\n\t}","commit_id":"6780137eb9597e097e2a1f881c43df9c834c258d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static List<Long> getActiveSyncSiteIds(long syncAccountId) {\n\t\ttry {\n\t\t\tList<Long> activeSyncSiteIds = _activeSyncSiteIdsMap.get(\n\t\t\t\tsyncAccountId);\n\n\t\t\tif ((activeSyncSiteIds != null) && !activeSyncSiteIds.isEmpty()) {\n\t\t\t\treturn activeSyncSiteIds;\n\t\t\t}\n\n\t\t\tactiveSyncSiteIds = _syncSitePersistence.findByA_S(\n\t\t\t\ttrue, syncAccountId);\n\n\t\t\t_activeSyncSiteIdsMap.put(syncAccountId, activeSyncSiteIds);\n\n\t\t\treturn activeSyncSiteIds;\n\t\t}\n\t\tcatch (SQLException sqle) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(sqle.getMessage(), sqle);\n\t\t\t}\n\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}","id":73407,"modified_method":"public static List<Long> getActiveSyncSiteIds(long syncAccountId) {\n\t\ttry {\n\t\t\tList<Long> activeSyncSiteIds = _activeSyncSiteIds.get(\n\t\t\t\tsyncAccountId);\n\n\t\t\tif ((activeSyncSiteIds != null) && !activeSyncSiteIds.isEmpty()) {\n\t\t\t\treturn activeSyncSiteIds;\n\t\t\t}\n\n\t\t\tactiveSyncSiteIds = _syncSitePersistence.findByA_S(\n\t\t\t\ttrue, syncAccountId);\n\n\t\t\t_activeSyncSiteIds.put(syncAccountId, activeSyncSiteIds);\n\n\t\t\treturn activeSyncSiteIds;\n\t\t}\n\t\tcatch (SQLException sqle) {\n\t\t\tif (_logger.isDebugEnabled()) {\n\t\t\t\t_logger.debug(sqle.getMessage(), sqle);\n\t\t\t}\n\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}","commit_id":"6780137eb9597e097e2a1f881c43df9c834c258d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static void setActiveSyncSiteIds(\n\t\tlong syncAccountId, List<Long> activeSyncSiteIds) {\n\n\t\t_activeSyncSiteIdsMap.put(syncAccountId, activeSyncSiteIds);\n\t}","id":73408,"modified_method":"public static void setActiveSyncSiteIds(\n\t\tlong syncAccountId, List<Long> activeSyncSiteIds) {\n\n\t\t_activeSyncSiteIds.put(syncAccountId, activeSyncSiteIds);\n\t}","commit_id":"6780137eb9597e097e2a1f881c43df9c834c258d","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@NotNull\n  private static Color getDefaultBackgroundColor() {\n    EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n    Color color = scheme.getColor(ConsoleViewContentType.CONSOLE_BACKGROUND_KEY);\n    return ObjectUtils.notNull(color, scheme.getDefaultBackground());\n  }","id":73409,"modified_method":"@NotNull\n  private static Color getDefaultBackgroundColor() {\n    EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n    Color color = scheme.getColor(ConsoleViewContentType.CONSOLE_BACKGROUND_KEY);\n    if (color == null) {\n      color = scheme.getDefaultBackground();\n    }\n    return color;\n  }","commit_id":"23a0809b46ed2ca678f445372aa706645a5c7ee5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Key getOutputKey(@NonNls String attribute) {\n    final String completeAttribute = attribute;\n    if (attribute.startsWith(\"\\u001B[\")) {\n      attribute = attribute.substring(2);\n    }\n    else {\n      attribute = StringUtil.trimStart(attribute, \"[\");\n    }\n    attribute = StringUtil.trimEnd(attribute, \"m\");\n    if (attribute.equals(\"0\")) {\n      return ProcessOutputTypes.STDOUT;\n    }\n    TextAttributes attrs = new TextAttributes();\n    final String[] strings = attribute.split(\";\");\n    for (String string : strings) {\n      int value;\n      try {\n        value = Integer.parseInt(string);\n      }\n      catch (NumberFormatException e) {\n        continue;\n      }\n      if (value == 1) {\n        attrs.setFontType(Font.BOLD);\n      }\n      else if (value == 4) {\n        attrs.setEffectType(EffectType.LINE_UNDERSCORE);\n      }\n      else if (value == 22) {\n        attrs.setFontType(Font.PLAIN);\n      }\n      else if (value == 24) {  //not underlined\n        attrs.setEffectType(null);\n      }\n      else if (value >= 30 && value <= 37) {\n        attrs.setForegroundColor(getAnsiColor(value - 30));\n      }\n      else if (value == 38) {\n        //TODO: 256 colors foreground\n      }\n      else if (value == 39) {\n        attrs.setForegroundColor(getColorByKey(ConsoleViewContentType.NORMAL_OUTPUT_KEY));\n      }\n      else if (value >= 40 && value <= 47) {\n        attrs.setBackgroundColor(getAnsiColor(value - 40));\n      }\n      else if (value == 48) {\n        //TODO: 256 colors background\n      }\n      else if (value == 49) {\n        attrs.setBackgroundColor(getDefaultBackgroundColor());\n      }\n      else if (value >= 90 && value <= 97) {\n        attrs.setForegroundColor(\n          getAnsiColor(value - 82));\n      }\n      else if (value >= 100 && value <= 107) {\n        attrs.setBackgroundColor(\n          getAnsiColor(value - 92));\n      }\n    }\n    if (attrs.getEffectType() == EffectType.LINE_UNDERSCORE) {\n      attrs.setEffectColor(attrs.getForegroundColor());\n    }\n    Key newKey = new Key(completeAttribute);\n    ConsoleViewContentType contentType = new ConsoleViewContentType(completeAttribute, attrs);\n    ConsoleViewContentType.registerNewConsoleViewType(newKey, contentType);\n    return newKey;\n  }","id":73410,"modified_method":"@NotNull\n  public Key getOutputKey(@NonNls String attribute) {\n    final String completeAttribute = attribute;\n    if (attribute.startsWith(\"\\u001B[\")) {\n      attribute = attribute.substring(2);\n    }\n    else {\n      attribute = StringUtil.trimStart(attribute, \"[\");\n    }\n    attribute = StringUtil.trimEnd(attribute, \"m\");\n    if (attribute.equals(\"0\")) {\n      return ProcessOutputTypes.STDOUT;\n    }\n    TextAttributes attrs = new TextAttributes();\n    final String[] strings = attribute.split(\";\");\n    for (String string : strings) {\n      int value;\n      try {\n        value = Integer.parseInt(string);\n      }\n      catch (NumberFormatException e) {\n        continue;\n      }\n      if (value == 1) {\n        attrs.setFontType(Font.BOLD);\n      }\n      else if (value == 4) {\n        attrs.setEffectType(EffectType.LINE_UNDERSCORE);\n      }\n      else if (value == 22) {\n        attrs.setFontType(Font.PLAIN);\n      }\n      else if (value == 24) {  //not underlined\n        attrs.setEffectType(null);\n      }\n      else if (value >= 30 && value <= 37) {\n        attrs.setForegroundColor(getAnsiColor(value - 30));\n      }\n      else if (value == 38) {\n        //TODO: 256 colors foreground\n      }\n      else if (value == 39) {\n        attrs.setForegroundColor(getDefaultForegroundColor());\n      }\n      else if (value >= 40 && value <= 47) {\n        attrs.setBackgroundColor(getAnsiColor(value - 40));\n      }\n      else if (value == 48) {\n        //TODO: 256 colors background\n      }\n      else if (value == 49) {\n        attrs.setBackgroundColor(getDefaultBackgroundColor());\n      }\n      else if (value >= 90 && value <= 97) {\n        attrs.setForegroundColor(\n          getAnsiColor(value - 82));\n      }\n      else if (value >= 100 && value <= 107) {\n        attrs.setBackgroundColor(\n          getAnsiColor(value - 92));\n      }\n    }\n    if (attrs.getEffectType() == EffectType.LINE_UNDERSCORE) {\n      Color foregroundColor = attrs.getForegroundColor();\n      if (foregroundColor == null) {\n        foregroundColor = getDefaultForegroundColor();\n      }\n      attrs.setEffectColor(foregroundColor);\n    }\n    Key newKey = new Key(completeAttribute);\n    ConsoleViewContentType contentType = new ConsoleViewContentType(completeAttribute, attrs);\n    ConsoleViewContentType.registerNewConsoleViewType(newKey, contentType);\n    return newKey;\n  }","commit_id":"23a0809b46ed2ca678f445372aa706645a5c7ee5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    @Override\n    public Color getDefaultForeground() {\n      return getGlobal().getAttributes(ConsoleViewContentType.NORMAL_OUTPUT_KEY).getForegroundColor();\n    }","id":73411,"modified_method":"@NotNull\n    @Override\n    public Color getDefaultForeground() {\n      Color foregroundColor = getGlobal().getAttributes(ConsoleViewContentType.NORMAL_OUTPUT_KEY).getForegroundColor();\n      return foregroundColor != null ? foregroundColor: getGlobal().getDefaultForeground();\n    }","commit_id":"66b9593d6fdd0033f9467902572b2db2e4a7c263","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean isValidRequestor(String remoteUser, Configuration conf)\n      throws IOException {\n    if(remoteUser == null) { // This really shouldn't happen...\n      LOG.warn(\"Received null remoteUser while authorizing access to getImage servlet\");\n      return false;\n    }\n\n    String[] validRequestors = {\n        SecurityUtil.getServerPrincipal(conf\n            .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), NameNode\n            .getAddress(conf).getHostName()),\n        SecurityUtil.getServerPrincipal(conf\n            .get(DFSConfigKeys.DFS_NAMENODE_USER_NAME_KEY), NameNode\n            .getAddress(conf).getHostName()),\n        SecurityUtil.getServerPrincipal(conf\n            .get(DFSConfigKeys.DFS_SECONDARY_NAMENODE_KRB_HTTPS_USER_NAME_KEY),\n            SecondaryNameNode.getHttpAddress(conf).getHostName()),\n        SecurityUtil.getServerPrincipal(conf\n            .get(DFSConfigKeys.DFS_SECONDARY_NAMENODE_USER_NAME_KEY),\n            SecondaryNameNode.getHttpAddress(conf).getHostName()) };\n\n    for(String v : validRequestors) {\n      if(v != null && v.equals(remoteUser)) {\n        if(LOG.isDebugEnabled()) LOG.debug(\"isValidRequestor is allowing: \" + remoteUser);\n        return true;\n      }\n    }\n    if(LOG.isDebugEnabled()) LOG.debug(\"isValidRequestor is rejecting: \" + remoteUser);\n    return false;\n  }","id":73412,"modified_method":"@VisibleForTesting\n  static boolean isValidRequestor(String remoteUser, Configuration conf)\n      throws IOException {\n    if(remoteUser == null) { // This really shouldn't happen...\n      LOG.warn(\"Received null remoteUser while authorizing access to getImage servlet\");\n      return false;\n    }\n    \n    Set<String> validRequestors = new HashSet<String>();\n\n    validRequestors.add(\n        SecurityUtil.getServerPrincipal(conf\n            .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), NameNode\n            .getAddress(conf).getHostName()));\n    validRequestors.add(\n        SecurityUtil.getServerPrincipal(conf\n            .get(DFSConfigKeys.DFS_NAMENODE_USER_NAME_KEY), NameNode\n            .getAddress(conf).getHostName()));\n    validRequestors.add(\n        SecurityUtil.getServerPrincipal(conf\n            .get(DFSConfigKeys.DFS_SECONDARY_NAMENODE_KRB_HTTPS_USER_NAME_KEY),\n            SecondaryNameNode.getHttpAddress(conf).getHostName()));\n    validRequestors.add(\n        SecurityUtil.getServerPrincipal(conf\n            .get(DFSConfigKeys.DFS_SECONDARY_NAMENODE_USER_NAME_KEY),\n            SecondaryNameNode.getHttpAddress(conf).getHostName()));\n\n    if (HAUtil.isHAEnabled(conf, DFSUtil.getNamenodeNameServiceId(conf))) {\n      Configuration otherNnConf = HAUtil.getConfForOtherNode(conf);\n      validRequestors.add(\n          SecurityUtil.getServerPrincipal(otherNnConf\n              .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY),\n              NameNode.getAddress(otherNnConf).getHostName()));\n      validRequestors.add(\n          SecurityUtil.getServerPrincipal(otherNnConf\n              .get(DFSConfigKeys.DFS_NAMENODE_USER_NAME_KEY),\n              NameNode.getAddress(otherNnConf).getHostName()));\n    }\n\n    for(String v : validRequestors) {\n      if(v != null && v.equals(remoteUser)) {\n        if(LOG.isDebugEnabled()) LOG.debug(\"isValidRequestor is allowing: \" + remoteUser);\n        return true;\n      }\n    }\n    if(LOG.isDebugEnabled()) LOG.debug(\"isValidRequestor is rejecting: \" + remoteUser);\n    return false;\n  }","commit_id":"49ed783a3a68726264c68cdc6c958ba9ad26c2c9","url":"https://github.com/apache/hadoop"},{"original_method":"@Parameters\n    public static Collection<Object[]> data() throws Exception {\n        return Arrays.asList(new Object[][] {\n                {\n                    getSampleAlarm(),\n                    \"<northbound-alarm xmlns=\\\"http://xmlns.opennms.org/xsd/alarms\\\" id=\\\"1\\\">\\n\" +\n                     \"<uei>some-uei<\/uei>\\n\" +\n                     \"<node-id>99<\/node-id>\\n\" +\n                     \"<node-label>some-node-label<\/node-label>\\n\" +\n                     \"<node-sysobjectid>.1.3.6<\/node-sysobjectid>\\n\" +\n                     \"<node-foreignsource>fs<\/node-foreignsource>\\n\" +\n                     \"<node-foreignid>fid<\/node-foreignid>\\n\" +\n                     \"<ack-time>\" + fixDate(new Date(1)) + \"<\/ack-time>\\n\" +\n                     \"<ack-user>admin<\/ack-user>\\n\" +\n                     \"<alarm-type>PROBLEM<\/alarm-type>\\n\" +\n                     \"<app-dn>some-app-dn<\/app-dn>\\n\" +\n                     \"<clear-key>some-clear-key<\/clear-key>\\n\" +\n                     \"<count>1<\/count>\\n\" +\n                     \"<description>some description<\/description>\\n\" +\n                     \"<first-occurrence>\" + fixDate(new Date(2)) + \"<\/first-occurrence>\\n\" +\n                     \"<ip-address>127.0.0.127<\/ip-address>\\n\" +\n                     \"<last-occurrence>\" + fixDate(new Date(4)) + \"<\/last-occurrence>\\n\" +\n                     \"<log-messsage>logmsg<\/log-messsage>\\n\" +\n                     \"<object-instance>instance<\/object-instance>\\n\" +\n                     \"<object-type>type<\/object-type>\\n\" +\n                     \"<operator-instructions>instructions here<\/operator-instructions>\\n\" +\n                     \"<oss-key>key<\/oss-key>\\n\" +\n                     \"<oss-state>state<\/oss-state>\\n\" +\n                     \"<alarm-key>key<\/alarm-key>\\n\" +\n                     \"<service>service<\/service>\\n\" +\n                     \"<severity>CRITICAL<\/severity>\\n\" +\n                     \"<suppressed>\" + fixDate(new Date(5)) + \"<\/suppressed>\\n\" +\n                     \"<suppressed-until>\" + fixDate(new Date(6)) + \"<\/suppressed-until>\\n\" +\n                     \"<suppressed-by>me<\/suppressed-by>\\n\" +\n                     \"<ticket-id>NMS-8068<\/ticket-id>\\n\" +\n                     \"<ticket-state>OPEN<\/ticket-state>\\n\" +\n                     \"<x733-type>type<\/x733-type>\\n\" +\n                     \"<x733-cause>1<\/x733-cause>\\n\" +\n                     \"<parameters/>\\n\" +\n                     \"<preserved>true<\/preserved>\\n\" +\n                    \"<\/northbound-alarm>\"\n                }\n        });\n    }","id":73413,"modified_method":"@Parameters\n    public static Collection<Object[]> data() throws Exception {\n        return Arrays.asList(new Object[][] {\n                {\n                    getSampleAlarm(),\n                    \"<northbound-alarm xmlns=\\\"http://xmlns.opennms.org/xsd/alarms\\\" id=\\\"1\\\">\\n\" +\n                     \"<uei>some-uei<\/uei>\\n\" +\n                     \"<node-id>99<\/node-id>\\n\" +\n                     \"<node-label>some-node-label<\/node-label>\\n\" +\n                     \"<node-sysobjectid>.1.3.6<\/node-sysobjectid>\\n\" +\n                     \"<node-foreignsource>fs<\/node-foreignsource>\\n\" +\n                     \"<node-foreignid>fid<\/node-foreignid>\\n\" +\n                     \"<ack-time>\" + fixDate(new Date(1)).replaceAll(\"\\\\+00:00\", \"Z\") + \"<\/ack-time>\\n\" +\n                     \"<ack-user>admin<\/ack-user>\\n\" +\n                     \"<alarm-type>PROBLEM<\/alarm-type>\\n\" +\n                     \"<app-dn>some-app-dn<\/app-dn>\\n\" +\n                     \"<clear-key>some-clear-key<\/clear-key>\\n\" +\n                     \"<count>1<\/count>\\n\" +\n                     \"<description>some description<\/description>\\n\" +\n                     \"<first-occurrence>\" + fixDate(new Date(2)).replaceAll(\"\\\\+00:00\", \"Z\") + \"<\/first-occurrence>\\n\" +\n                     \"<ip-address>127.0.0.127<\/ip-address>\\n\" +\n                     \"<last-occurrence>\" + fixDate(new Date(4)).replaceAll(\"\\\\+00:00\", \"Z\") + \"<\/last-occurrence>\\n\" +\n                     \"<log-messsage>logmsg<\/log-messsage>\\n\" +\n                     \"<object-instance>instance<\/object-instance>\\n\" +\n                     \"<object-type>type<\/object-type>\\n\" +\n                     \"<operator-instructions>instructions here<\/operator-instructions>\\n\" +\n                     \"<oss-key>key<\/oss-key>\\n\" +\n                     \"<oss-state>state<\/oss-state>\\n\" +\n                     \"<alarm-key>key<\/alarm-key>\\n\" +\n                     \"<service>service<\/service>\\n\" +\n                     \"<severity>CRITICAL<\/severity>\\n\" +\n                     \"<suppressed>\" + fixDate(new Date(5)).replaceAll(\"\\\\+00:00\", \"Z\") + \"<\/suppressed>\\n\" +\n                     \"<suppressed-until>\" + fixDate(new Date(6)).replaceAll(\"\\\\+00:00\", \"Z\") + \"<\/suppressed-until>\\n\" +\n                     \"<suppressed-by>me<\/suppressed-by>\\n\" +\n                     \"<ticket-id>NMS-8068<\/ticket-id>\\n\" +\n                     \"<ticket-state>OPEN<\/ticket-state>\\n\" +\n                     \"<x733-type>type<\/x733-type>\\n\" +\n                     \"<x733-cause>1<\/x733-cause>\\n\" +\n                     \"<parameters/>\\n\" +\n                     \"<preserved>true<\/preserved>\\n\" +\n                    \"<\/northbound-alarm>\"\n                }\n        });\n    }","commit_id":"9dfa101190a0483f9edc0c83b4f4efceed99399e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected AbstractService(final Object mBeanInstance, final ClassReflectionIndex<?> mBeanClassIndex) {\n        this.mBeanInstance = mBeanInstance;\n        this.mBeanClassIndex = mBeanClassIndex;\n    }","id":73414,"modified_method":"protected void invokeLifecycleMethod(final Method method) throws InvocationTargetException, IllegalAccessException {\n        if (method != null) {\n            final ClassLoader old = SecurityActions.setThreadContextClassLoader(mBeanInstance.getClass().getClassLoader());\n            try {\n                method.invoke(mBeanInstance);\n            } finally {\n                SecurityActions.resetThreadContextClassLoader(old);\n            }\n        }\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public void start(final StartContext context) throws StartException {\n        log.debugf(\"Creating Service: %s\", context.getController().getName());\n        try {\n            invokeLifecycleMethod(CREATE_METHOD_NAME);\n        } catch (final Exception e) {\n            throw new StartException(\"Failed to execute legacy service create() method\", e);\n        }\n    }","id":73415,"modified_method":"/** {@inheritDoc} */\n    public void start(final StartContext context) throws StartException {\n        if (log.isTraceEnabled()) {\n            log.tracef(\"Creating Service: %s\", context.getController().getName());\n        }\n        try {\n            invokeLifecycleMethod(createMethod);\n        } catch (final Exception e) {\n            throw new StartException(\"Failed to execute legacy service create() method\", e);\n        }\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public void stop(final StopContext context) {\n        log.debugf(\"Destroying Service: %s\", context.getController().getName());\n        try {\n            invokeLifecycleMethod(DESTROY_METHOD_NAME);\n        } catch (final Exception e) {\n            log.error(\"Failed to execute legacy service destroy() method\", e);\n        }\n    }","id":73416,"modified_method":"/** {@inheritDoc} */\n    public void stop(final StopContext context) {\n        if (log.isTraceEnabled()) {\n            log.tracef(\"Destroying Service: %s\", context.getController().getName());\n        }\n        try {\n            invokeLifecycleMethod(destroyMethod);\n        } catch (final Exception e) {\n            log.error(\"Failed to execute legacy service destroy() method\", e);\n        }\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"CreateDestroyService(final Object mBeanInstance, final ClassReflectionIndex<?> mBeanClassIndex) {\n        super(mBeanInstance, mBeanClassIndex);\n    }","id":73417,"modified_method":"CreateDestroyService(final Object mBeanInstance, final Method createMethod, final Method destroyMethod) {\n        super(mBeanInstance);\n        this.createMethod = createMethod;\n        this.destroyMethod = destroyMethod;\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"MBeanServices(final String mBeanName, final Object mBeanInstance, final ClassReflectionIndex<?> mBeanClassIndex, final ServiceTarget target) {\n        if ((mBeanName == null) || (mBeanInstance == null) || (target == null)) {\n            throw new IllegalArgumentException(\"Parameters must not be null\");\n        }\n\n        createDestroyService = new CreateDestroyService(mBeanInstance, mBeanClassIndex);\n        createDestroyServiceName = ServiceNameFactory.newCreateDestroy(mBeanName);\n        createDestroyServiceBuilder = target.addService(createDestroyServiceName, createDestroyService);\n\n        startStopService = new StartStopService(mBeanInstance, mBeanClassIndex);\n        startStopServiceName = ServiceNameFactory.newStartStop(mBeanName);\n        startStopServiceBuilder = target.addService(startStopServiceName, startStopService);\n        startStopServiceBuilder.addDependency(createDestroyServiceName);\n\n        this.mBeanName = mBeanName;\n        this.target = target;\n    }","id":73418,"modified_method":"MBeanServices(final String mBeanName, final Object mBeanInstance, final List<ClassReflectionIndex<?>> mBeanClassHierarchy, final ServiceTarget target) {\n        if ((mBeanName == null) || (mBeanInstance == null) || (target == null)) {\n            throw new IllegalArgumentException(\"Parameters must not be null\");\n        }\n\n        final Method createMethod = ReflectionUtils.getMethod(mBeanClassHierarchy, CREATE_METHOD_NAME, NO_ARGS, false);\n        final Method destroyMethod = ReflectionUtils.getMethod(mBeanClassHierarchy, DESTROY_METHOD_NAME, NO_ARGS, false);\n        createDestroyService = new CreateDestroyService(mBeanInstance, createMethod, destroyMethod);\n        createDestroyServiceName = ServiceNameFactory.newCreateDestroy(mBeanName);\n        createDestroyServiceBuilder = target.addService(createDestroyServiceName, createDestroyService);\n\n        final Method startMethod = ReflectionUtils.getMethod(mBeanClassHierarchy, START_METHOD_NAME, NO_ARGS, false);\n        final Method stopMethod = ReflectionUtils.getMethod(mBeanClassHierarchy, STOP_METHOD_NAME, NO_ARGS, false);\n        startStopService = new StartStopService(mBeanInstance, startMethod, stopMethod);\n        startStopServiceName = ServiceNameFactory.newStartStop(mBeanName);\n        startStopServiceBuilder = target.addService(startStopServiceName, startStopService);\n        startStopServiceBuilder.addDependency(createDestroyServiceName);\n\n        this.mBeanName = mBeanName;\n        this.target = target;\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static Injector<Object> getPropertyInjector(final String propertyName, final ClassReflectionIndex<?> mBeanClassIndex, final Service<?> service, final Value<?> value) {\n        final Method setterMethod = ReflectionUtils.getSetter(mBeanClassIndex, propertyName);\n        return new MethodInjector<Object>(setterMethod, service, Values.nullValue(), Collections.singletonList(value));\n    }","id":73419,"modified_method":"private static Injector<Object> getPropertyInjector(final String propertyName, final List<ClassReflectionIndex<?>> mBeanClassHierarchy, final Service<?> service, final Value<?> value) {\n        final Method setterMethod = ReflectionUtils.getSetter(mBeanClassHierarchy, propertyName);\n        return new MethodInjector<Object>(setterMethod, service, Values.nullValue(), Collections.singletonList(value));\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static Injector<Object> getInjector(final JBossServiceDependencyConfig dependencyConfig, final ClassReflectionIndex<?> mBeanClassIndex, final Service<Object> service) {\n        final String attrName = dependencyConfig.getOptionalAttributeName();\n        return attrName != null ? getPropertyInjector(attrName, mBeanClassIndex, service, Values.injectedValue()) : NullInjector.getInstance();\n    }","id":73420,"modified_method":"private static Injector<Object> getInjector(final JBossServiceDependencyConfig dependencyConfig, final List<ClassReflectionIndex<?>> mBeanClassHierarchy, final Service<Object> service) {\n        final String attrName = dependencyConfig.getOptionalAttributeName();\n        return attrName != null ? getPropertyInjector(attrName, mBeanClassHierarchy, service, Values.injectedValue()) : NullInjector.getInstance();\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static Value<?> getValue(final Inject injectConfig, final ClassReflectionIndex<?> mBeanClassIndex) {\n        final String propertyName = injectConfig.getPropertyName();\n        Value<?> valueToInject = Values.injectedValue();\n        if (propertyName != null) {\n            final Method getter = ReflectionUtils.getGetter(mBeanClassIndex, propertyName);\n            final Value<Method> getterValue = new ImmediateValue<Method>(getter);\n            valueToInject = cached(new MethodValue<Object>(getterValue, valueToInject, Values.<Object>emptyList()));\n        }\n        return valueToInject;\n    }","id":73421,"modified_method":"private static Value<?> getValue(final Inject injectConfig, final List<ClassReflectionIndex<?>> mBeanClassHierarchy) {\n        final String propertyName = injectConfig.getPropertyName();\n        Value<?> valueToInject = Values.injectedValue();\n        if (propertyName != null) {\n            final Method getter = ReflectionUtils.getGetter(mBeanClassHierarchy, propertyName);\n            final Value<Method> getterValue = new ImmediateValue<Method>(getter);\n            valueToInject = cached(new MethodValue<Object>(getterValue, valueToInject, Values.<Object>emptyList()));\n        }\n        return valueToInject;\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static Value<?> getValue(final JBossServiceAttributeConfig attributeConfig, final ClassReflectionIndex<?> mBeanClassIndex) {\n        final String attributeName = attributeConfig.getName();\n        final Method setterMethod = ReflectionUtils.getSetter(mBeanClassIndex, attributeName);\n        final Class<?> setterType = setterMethod.getParameterTypes()[0];\n\n        return new ImmediateValue<Object>(newValue(setterType, attributeConfig.getValue()));\n    }","id":73422,"modified_method":"private static Value<?> getValue(final JBossServiceAttributeConfig attributeConfig, final List<ClassReflectionIndex<?>> mBeanClassHierarchy) {\n        final String attributeName = attributeConfig.getName();\n        final Method setterMethod = ReflectionUtils.getSetter(mBeanClassHierarchy, attributeName);\n        final Class<?> setterType = setterMethod.getParameterTypes()[0];\n\n        return new ImmediateValue<Object>(newValue(setterType, attributeConfig.getValue()));\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static Value<?> getValue(final ValueFactory valueFactory, final ClassReflectionIndex<?> mBeanClassIndex, final ClassLoader classLoader) throws DeploymentUnitProcessingException {\n        final String methodName = valueFactory.getMethodName();\n        final ValueFactoryParameter[] parameters = valueFactory.getParameters();\n        final List<Class<?>> paramTypes = new ArrayList<Class<?>>(parameters.length);\n        final List<Value<?>> paramValues = new ArrayList<Value<?>>(parameters.length);\n        for (ValueFactoryParameter parameter : parameters) {\n            final Class<?> attributeTypeValue = ReflectionUtils.getClass(parameter.getType(), classLoader);\n            paramTypes.add(attributeTypeValue);\n            paramValues.add(new ImmediateValue<Object>(newValue(attributeTypeValue, parameter.getValue())));\n        }\n        final Value<Method> methodValue = new ImmediateValue<Method>(ReflectionUtils.getMethod(mBeanClassIndex, methodName, paramTypes.toArray(new Class<?>[0]), true));\n        return cached(new MethodValue<Object>(methodValue, Values.injectedValue(), paramValues));\n    }","id":73423,"modified_method":"private static Value<?> getValue(final ValueFactory valueFactory, final List<ClassReflectionIndex<?>> mBeanClassHierarchy, final ClassLoader classLoader) throws DeploymentUnitProcessingException {\n        final String methodName = valueFactory.getMethodName();\n        final ValueFactoryParameter[] parameters = valueFactory.getParameters();\n        final List<Class<?>> paramTypes = new ArrayList<Class<?>>(parameters.length);\n        final List<Value<?>> paramValues = new ArrayList<Value<?>>(parameters.length);\n        for (ValueFactoryParameter parameter : parameters) {\n            final Class<?> attributeTypeValue = ReflectionUtils.getClass(parameter.getType(), classLoader);\n            paramTypes.add(attributeTypeValue);\n            paramValues.add(new ImmediateValue<Object>(newValue(attributeTypeValue, parameter.getValue())));\n        }\n        final Value<Method> methodValue = new ImmediateValue<Method>(ReflectionUtils.getMethod(mBeanClassHierarchy, methodName, paramTypes.toArray(new Class<?>[0]), true));\n        return cached(new MethodValue<Object>(methodValue, Values.injectedValue(), paramValues));\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void addServices(final ServiceTarget target, final JBossServiceConfig mBeanConfig, final ClassLoader classLoader, final DeploymentReflectionIndex index) throws DeploymentUnitProcessingException {\n        final String mBeanClassName = mBeanConfig.getCode();\n        final Class<?> mBeanClass = ReflectionUtils.getClass(mBeanClassName, classLoader);\n        final ClassReflectionIndex<?> mBeanClassIndex = index.getClassIndex(mBeanClass);\n        final Object mBeanInstance = newInstance(mBeanConfig, mBeanClassIndex, classLoader);\n        final String mBeanName = mBeanConfig.getName();\n        final MBeanServices mBeanServices = new MBeanServices(mBeanName, mBeanInstance, mBeanClassIndex, target);\n\n        final JBossServiceDependencyConfig[] dependencyConfigs = mBeanConfig.getDependencyConfigs();\n        if (dependencyConfigs != null) {\n            final Service<Object> createDestroyService = mBeanServices.getCreateDestroyService();\n            for (final JBossServiceDependencyConfig dependencyConfig : dependencyConfigs) {\n                final Injector<Object> injector = getInjector(dependencyConfig, mBeanClassIndex, createDestroyService);\n                mBeanServices.addDependency(dependencyConfig.getDependencyName(), injector);\n            }\n        }\n\n        final JBossServiceAttributeConfig[] attributeConfigs = mBeanConfig.getAttributeConfigs();\n        if (attributeConfigs != null) {\n            final Service<Object> createDestroyService = mBeanServices.getCreateDestroyService();\n            for (final JBossServiceAttributeConfig attributeConfig : attributeConfigs) {\n                final String propertyName = attributeConfig.getName();\n                final Inject injectConfig = attributeConfig.getInject();\n                final ValueFactory valueFactoryConfig = attributeConfig.getValueFactory();\n\n                if (injectConfig != null) {\n                    final Value<?> value = getValue(injectConfig, mBeanClassIndex);\n                    final Injector<Object> injector = getPropertyInjector(propertyName, mBeanClassIndex, createDestroyService, value);\n                    mBeanServices.addDependency(injectConfig.getBeanName(), injector);\n                } else if (valueFactoryConfig != null) {\n                    final Value<?> value = getValue(valueFactoryConfig, mBeanClassIndex, classLoader);\n                    final Injector<Object> injector = getPropertyInjector(propertyName, mBeanClassIndex, createDestroyService, value);\n                    mBeanServices.addDependency(valueFactoryConfig.getBeanName(), injector);\n                } else {\n                    final Value<?> value = getValue(attributeConfig, mBeanClassIndex);\n                    final Injector<Object> injector = getPropertyInjector(propertyName, mBeanClassIndex, createDestroyService, Values.injectedValue());\n                    mBeanServices.addInjectionValue(injector, value);\n                }\n            }\n        }\n\n        // register all mBean related services\n        mBeanServices.install();\n    }","id":73424,"modified_method":"private void addServices(final ServiceTarget target, final JBossServiceConfig mBeanConfig, final ClassLoader classLoader, final DeploymentReflectionIndex index) throws DeploymentUnitProcessingException {\n        final String mBeanClassName = mBeanConfig.getCode();\n        final List<ClassReflectionIndex<?>> mBeanClassHierarchy = ReflectionUtils.getClassHierarchy(mBeanClassName, index, classLoader);\n        final Object mBeanInstance = newInstance(mBeanConfig, mBeanClassHierarchy, classLoader);\n        final String mBeanName = mBeanConfig.getName();\n        final MBeanServices mBeanServices = new MBeanServices(mBeanName, mBeanInstance, mBeanClassHierarchy, target);\n\n        final JBossServiceDependencyConfig[] dependencyConfigs = mBeanConfig.getDependencyConfigs();\n        if (dependencyConfigs != null) {\n            final Service<Object> createDestroyService = mBeanServices.getCreateDestroyService();\n            for (final JBossServiceDependencyConfig dependencyConfig : dependencyConfigs) {\n                final Injector<Object> injector = getInjector(dependencyConfig, mBeanClassHierarchy, createDestroyService);\n                mBeanServices.addDependency(dependencyConfig.getDependencyName(), injector);\n            }\n        }\n\n        final JBossServiceAttributeConfig[] attributeConfigs = mBeanConfig.getAttributeConfigs();\n        if (attributeConfigs != null) {\n            final Service<Object> createDestroyService = mBeanServices.getCreateDestroyService();\n            for (final JBossServiceAttributeConfig attributeConfig : attributeConfigs) {\n                final String propertyName = attributeConfig.getName();\n                final Inject injectConfig = attributeConfig.getInject();\n                final ValueFactory valueFactoryConfig = attributeConfig.getValueFactory();\n\n                if (injectConfig != null) {\n                    final Value<?> value = getValue(injectConfig, mBeanClassHierarchy);\n                    final Injector<Object> injector = getPropertyInjector(propertyName, mBeanClassHierarchy, createDestroyService, value);\n                    mBeanServices.addDependency(injectConfig.getBeanName(), injector);\n                } else if (valueFactoryConfig != null) {\n                    final Value<?> value = getValue(valueFactoryConfig, mBeanClassHierarchy, classLoader);\n                    final Injector<Object> injector = getPropertyInjector(propertyName, mBeanClassHierarchy, createDestroyService, value);\n                    mBeanServices.addDependency(valueFactoryConfig.getBeanName(), injector);\n                } else {\n                    final Value<?> value = getValue(attributeConfig, mBeanClassHierarchy);\n                    final Injector<Object> injector = getPropertyInjector(propertyName, mBeanClassHierarchy, createDestroyService, Values.injectedValue());\n                    mBeanServices.addInjectionValue(injector, value);\n                }\n            }\n        }\n\n        // register all mBean related services\n        mBeanServices.install();\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static Object newInstance(final JBossServiceConfig serviceConfig, final ClassReflectionIndex<?> classIndex, final ClassLoader classLoader) throws DeploymentUnitProcessingException {\n        final JBossServiceConstructorConfig constructorConfig = serviceConfig.getConstructorConfig();\n        final int paramCount = constructorConfig != null ? constructorConfig.getArguments().length : 0;\n        final Class<?>[] types = new Class<?>[paramCount];\n        final Object[] params = new Object[paramCount];\n\n        if (constructorConfig != null) {\n            final Argument[] arguments = constructorConfig.getArguments();\n            for (int i = 0; i < paramCount; i++) {\n                final Argument argument = arguments[i];\n                types[i] = ReflectionUtils.getClass(argument.getType(), classLoader);\n                params[i] = newValue(ReflectionUtils.getClass(argument.getType(), classLoader), argument.getValue());\n            }\n        }\n\n        final Constructor<?> constructor = classIndex.getConstructor(types);\n        final Object mBeanInstance = ReflectionUtils.newInstance(constructor, params);\n\n        return mBeanInstance;\n    }","id":73425,"modified_method":"private static Object newInstance(final JBossServiceConfig serviceConfig, final List<ClassReflectionIndex<?>> mBeanClassHierarchy, final ClassLoader classLoader) throws DeploymentUnitProcessingException {\n        final JBossServiceConstructorConfig constructorConfig = serviceConfig.getConstructorConfig();\n        final int paramCount = constructorConfig != null ? constructorConfig.getArguments().length : 0;\n        final Class<?>[] types = new Class<?>[paramCount];\n        final Object[] params = new Object[paramCount];\n\n        if (constructorConfig != null) {\n            final Argument[] arguments = constructorConfig.getArguments();\n            for (int i = 0; i < paramCount; i++) {\n                final Argument argument = arguments[i];\n                types[i] = ReflectionUtils.getClass(argument.getType(), classLoader);\n                params[i] = newValue(ReflectionUtils.getClass(argument.getType(), classLoader), argument.getValue());\n            }\n        }\n\n        final Constructor<?> constructor = mBeanClassHierarchy.get(0).getConstructor(types);\n        final Object mBeanInstance = ReflectionUtils.newInstance(constructor, params);\n\n        return mBeanInstance;\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"static Method getGetter(final ClassReflectionIndex<?> classIndex, final String propertyName) {\n        final String getterName = \"get\" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);\n        final String iserName = \"is\" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);\n        final Iterator<Method> methods = classIndex.getMethods().iterator();\n        Method method = null;\n        String methodName = null;\n        while (methods.hasNext()) {\n            method = methods.next();\n            methodName = method.getName();\n            if ((getterName.equals(methodName) || iserName.equals(methodName)) && method.getParameterTypes().length == 0) {\n                return method;\n            }\n        }\n\n        throw new IllegalStateException(\"No such get method for property '\" + propertyName + \"' found on \" + classIndex.getIndexedClass());\n    }","id":73426,"modified_method":"static Method getGetter(final List<ClassReflectionIndex<?>> classHierarchy, final String propertyName) {\n        final String getterName = \"get\" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);\n        final String iserName = \"is\" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);\n\n        for (final ClassReflectionIndex<?> classIndex : classHierarchy) {\n            final Iterator<Method> methods = classIndex.getMethods().iterator();\n            Method method = null;\n            String methodName = null;\n            while (methods.hasNext()) {\n                method = methods.next();\n                methodName = method.getName();\n                if ((getterName.equals(methodName) || iserName.equals(methodName)) && method.getParameterTypes().length == 0) {\n                    return method;\n                }\n            }\n        }\n\n        final String className = classHierarchy.get(0).getIndexedClass().getName();\n        throw new IllegalStateException(\"Get method for property '\" + propertyName + \"' not found for: \" + className);\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"static Class<?> getClass(final String className, final ClassLoader classLoader) throws DeploymentUnitProcessingException {\n        try {\n            return Class.forName(className, false, classLoader);\n        } catch (ClassNotFoundException e) {\n            throw new DeploymentUnitProcessingException(\"Component class not found\", e);\n        }\n    }","id":73427,"modified_method":"static Class<?> getClass(final String className, final ClassLoader classLoader) {\n        try {\n            return Class.forName(className, false, classLoader);\n        } catch (final ClassNotFoundException e) {\n            throw new IllegalArgumentException(\"Class not found\", e);\n        }\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"static Method getMethod(final ClassReflectionIndex<?> classIndex, final String methodName, final Class<?>[] types, final boolean fail) {\n        final Collection<Method> methods = classIndex.getMethods(methodName, types);\n        if (methods.size() == 1) {\n            return methods.iterator().next();\n        }\n        if (fail) {\n            throw new IllegalStateException(noSuchMethod(classIndex, methodName, types));\n        } else {\n            return null;\n        }\n    }","id":73428,"modified_method":"static Method getMethod(final List<ClassReflectionIndex<?>> classHierarchy, final String methodName, final Class<?>[] types, final boolean fail) {\n        for (final ClassReflectionIndex<?> classIndex : classHierarchy) {\n            final Collection<Method> methods = classIndex.getMethods(methodName, types);\n            if (methods.size() == 1) {\n                return methods.iterator().next();\n            }\n        }\n        if (fail) {\n            final String className = classHierarchy.get(0).getIndexedClass().getName();\n            throw new IllegalStateException(noSuchMethod(className, methodName, types));\n        } else {\n            return null;\n        }\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"static Method getSetter(final ClassReflectionIndex<?> classIndex, final String propertyName) {\n        final String setterName = \"set\" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);\n\n        final Iterator<Method> methods = classIndex.getMethods().iterator();\n        Method method = null;\n        String methodName = null;\n        while (methods.hasNext()) {\n            method = methods.next();\n            methodName = method.getName();\n            if (setterName.equals(methodName) && method.getParameterTypes().length == 1) {\n                return method;\n            }\n        }\n\n        throw new IllegalStateException(\"No such set method for property '\" + propertyName + \"' found on \" + classIndex.getIndexedClass());\n    }","id":73429,"modified_method":"static Method getSetter(final List<ClassReflectionIndex<?>> classHierarchy, final String propertyName) {\n        final String setterName = \"set\" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);\n\n        for (final ClassReflectionIndex<?> classIndex : classHierarchy) {\n            final Iterator<Method> methods = classIndex.getMethods().iterator();\n            Method method = null;\n            String methodName = null;\n            while (methods.hasNext()) {\n                method = methods.next();\n                methodName = method.getName();\n                if (setterName.equals(methodName) && method.getParameterTypes().length == 1) {\n                    return method;\n                }\n            }\n        }\n\n        final String className = classHierarchy.get(0).getIndexedClass().getName();\n        throw new IllegalStateException(\"Set method for property '\" + propertyName + \"' not found for: \" + className);\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static String noSuchMethod(final ClassReflectionIndex<?> classIndex, final String methodName, final Class<?>[] parameterTypes) {\n        StringBuffer message = new StringBuffer();\n        message.append(\"No such method '\");\n        message.append(methodName);\n        appendParameterList(message, parameterTypes);\n        message.append(\"' found on \").append(classIndex.getIndexedClass());\n        return message.toString();\n    }","id":73430,"modified_method":"private static String noSuchMethod(final String className, final String methodName, final Class<?>[] parameterTypes) {\n        StringBuffer message = new StringBuffer();\n        message.append(\"Method '\");\n        message.append(methodName);\n        appendParameterList(message, parameterTypes);\n        message.append(\"' not found for: \").append(className);\n        return message.toString();\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"static Object newInstance(final Constructor<?> constructor, final Object[] args) throws DeploymentUnitProcessingException {\n        try {\n            return constructor.newInstance(args);\n        } catch (Exception e) {\n            throw new DeploymentUnitProcessingException(\"Component class not instantiated\", e);\n        }\n    }","id":73431,"modified_method":"static Object newInstance(final Constructor<?> constructor, final Object[] args) {\n        try {\n            return constructor.newInstance(args);\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Class not instantiated\", e);\n        }\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public void start(final StartContext context) throws StartException {\n        log.debugf(\"Starting Service: %s\", context.getController().getName());\n        try {\n            invokeLifecycleMethod(START_METHOD_NAME);\n        } catch (final Exception e) {\n            throw new StartException(\"Failed to execute legacy service start() method\", e);\n        }\n    }","id":73432,"modified_method":"/** {@inheritDoc} */\n    public void start(final StartContext context) throws StartException {\n        if (log.isTraceEnabled()) {\n            log.tracef(\"Starting Service: %s\", context.getController().getName());\n        }\n        try {\n            invokeLifecycleMethod(startMethod);\n        } catch (final Exception e) {\n            throw new StartException(\"Failed to execute legacy service start() method\", e);\n        }\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public void stop(final StopContext context) {\n        log.debugf(\"Stopping Service: %s\", context.getController().getName());\n        try {\n            invokeLifecycleMethod(STOP_METHOD_NAME);\n        } catch (final Exception e) {\n            log.error(\"Failed to execute legacy service stop() method\", e);\n        }\n    }","id":73433,"modified_method":"/** {@inheritDoc} */\n    public void stop(final StopContext context) {\n        if (log.isTraceEnabled()) {\n            log.tracef(\"Stopping Service: %s\", context.getController().getName());\n        }\n        try {\n            invokeLifecycleMethod(stopMethod);\n        } catch (final Exception e) {\n            log.error(\"Failed to execute legacy service stop() method\", e);\n        }\n    }","commit_id":"e37687b86189e5f323eac1409591f08eadd9acc4","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n\tprotected ProcessCallable<Serializable> processProcessCallable(\n\t\tProcessCallable<Serializable> processCallable, MethodKey methodKey) {\n\n\t\tString dumpDirName = System.getProperty(\"junit.aspectj.dump\");\n\n\t\tString className = methodKey.getDeclaringClass().getName();\n\n\t\tFile dumpDir = new File(\n\t\t\tdumpDirName,\n\t\t\tclassName.concat(StringPool.PERIOD).concat(\n\t\t\t\tmethodKey.getMethodName()));\n\n\t\treturn new SwitchClassLoaderProcessCallable(processCallable, dumpDir);\n\t}","id":73434,"modified_method":"@Override\n\tprotected ProcessCallable<Serializable> processProcessCallable(\n\t\tProcessCallable<Serializable> processCallable, MethodKey methodKey) {\n\n\t\tString dumpDirName = System.getProperty(\"junit.aspectj.dump\");\n\n\t\tClass<?> clazz = methodKey.getDeclaringClass();\n\n\t\tString className = clazz.getName();\n\n\t\tFile dumpDir = new File(\n\t\t\tdumpDirName,\n\t\t\tclassName.concat(StringPool.PERIOD).concat(\n\t\t\t\tmethodKey.getMethodName()));\n\n\t\treturn new SwitchClassLoaderProcessCallable(processCallable, dumpDir);\n\t}","commit_id":"5b2bc55bdf815bf9eea6a6fc5fa7eb5fb1e410f4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String getTypeSettingsValue(\n\t\tUnicodeProperties typeSettingsProperties, String typeSettingsKey) {\n\n\t\tString value = null;\n\n\t\ttry {\n\t\t\tObject returnObj = PortalClassInvoker.invoke(\n\t\t\t\tfalse, _getTypeSettingsValue, typeSettingsProperties,\n\t\t\t\ttypeSettingsKey);\n\n\t\t\tif (returnObj != null) {\n\t\t\t\tvalue = (String)returnObj;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn value;\n\t}","id":73435,"modified_method":"public static String getTypeSettingsValue(\n\t\tUnicodeProperties typeSettingsProperties, String typeSettingsKey) {\n\n\t\tString value = null;\n\n\t\ttry {\n\t\t\tObject returnObj = PortalClassInvoker.invoke(\n\t\t\t\tfalse, _getTypeSettingsValueMethodKey, typeSettingsProperties,\n\t\t\t\ttypeSettingsKey);\n\n\t\t\tif (returnObj != null) {\n\t\t\t\tvalue = (String)returnObj;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn value;\n\t}","commit_id":"5b2bc55bdf815bf9eea6a6fc5fa7eb5fb1e410f4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void checkRepository(\n\t\tlong repositoryId, Map<String, String> parameters,\n\t\tUnicodeProperties typeSettingsProperties, String typeSettingsKey) {\n\n\t\ttry {\n\t\t\tPortalClassInvoker.invoke(\n\t\t\t\tfalse, _checkRepository, repositoryId, parameters,\n\t\t\t\ttypeSettingsProperties, typeSettingsKey);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","id":73436,"modified_method":"public static void checkRepository(\n\t\tlong repositoryId, Map<String, String> parameters,\n\t\tUnicodeProperties typeSettingsProperties, String typeSettingsKey) {\n\n\t\ttry {\n\t\t\tPortalClassInvoker.invoke(\n\t\t\t\tfalse, _checkRepositoryMethodKey, repositoryId, parameters,\n\t\t\t\ttypeSettingsProperties, typeSettingsKey);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","commit_id":"5b2bc55bdf815bf9eea6a6fc5fa7eb5fb1e410f4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Session createSession(Map<String, String> parameters)\n\t\tthrows RepositoryException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tObject returnObj = PortalClassInvoker.invoke(\n\t\t\t\tfalse, _createSession, parameters);\n\n\t\t\tif (returnObj != null) {\n\t\t\t\tsession = (Session)returnObj;\n\t\t\t}\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow re;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn session;\n\t}","id":73437,"modified_method":"public static Session createSession(Map<String, String> parameters)\n\t\tthrows RepositoryException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tObject returnObj = PortalClassInvoker.invoke(\n\t\t\t\tfalse, _createSessionMethodKey, parameters);\n\n\t\t\tif (returnObj != null) {\n\t\t\t\tsession = (Session)returnObj;\n\t\t\t}\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow re;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn session;\n\t}","commit_id":"5b2bc55bdf815bf9eea6a6fc5fa7eb5fb1e410f4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean isValidRequest(String className) {\n\t\tif (className.contains(\".service.\") &&\n\t\t\tclassName.endsWith(\"ServiceUtil\") &&\n\t\t\t!className.endsWith(\"LocalServiceUtil\")) {\n\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","id":73438,"modified_method":"protected boolean isValidRequest(Class<?> clazz) {\n\t\tString className = clazz.getName();\n\n\t\tif (className.contains(\".service.\") &&\n\t\t\tclassName.endsWith(\"ServiceUtil\") &&\n\t\t\t!className.endsWith(\"LocalServiceUtil\")) {\n\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"5b2bc55bdf815bf9eea6a6fc5fa7eb5fb1e410f4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows IOException {\n\n\t\tObjectInputStream ois;\n\n\t\ttry {\n\t\t\tois = new ObjectInputStream(request.getInputStream());\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(ioe, ioe);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tObject returnObj = null;\n\n\t\tboolean remoteAccess = AccessControlThreadLocal.isRemoteAccess();\n\n\t\ttry {\n\t\t\tAccessControlThreadLocal.setRemoteAccess(true);\n\n\t\t\tObjectValuePair<HttpPrincipal, MethodHandler> ovp =\n\t\t\t\t(ObjectValuePair<HttpPrincipal, MethodHandler>)ois.readObject();\n\n\t\t\tMethodHandler methodHandler = ovp.getValue();\n\n\t\t\tif (methodHandler != null) {\n\t\t\t\tMethodKey methodKey = methodHandler.getMethodKey();\n\n\t\t\t\tif (!isValidRequest(methodKey.getDeclaringClass().getName())) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treturnObj = methodHandler.invoke(true);\n\t\t\t}\n\t\t}\n\t\tcatch (InvocationTargetException ite) {\n\t\t\treturnObj = ite.getCause();\n\n\t\t\tif (!(returnObj instanceof PortalException)) {\n\t\t\t\tite.printStackTrace();\n\n\t\t\t\treturnObj = new SystemException();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t\tfinally {\n\t\t\tAccessControlThreadLocal.setRemoteAccess(remoteAccess);\n\t\t}\n\n\t\tif (returnObj != null) {\n\t\t\ttry {\n\t\t\t\tObjectOutputStream oos = new ObjectOutputStream(\n\t\t\t\t\tresponse.getOutputStream());\n\n\t\t\t\toos.writeObject(returnObj);\n\n\t\t\t\toos.flush();\n\t\t\t\toos.close();\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\t_log.error(ioe, ioe);\n\n\t\t\t\tthrow ioe;\n\t\t\t}\n\t\t}\n\t}","id":73439,"modified_method":"@Override\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows IOException {\n\n\t\tObjectInputStream ois;\n\n\t\ttry {\n\t\t\tois = new ObjectInputStream(request.getInputStream());\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(ioe, ioe);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tObject returnObj = null;\n\n\t\tboolean remoteAccess = AccessControlThreadLocal.isRemoteAccess();\n\n\t\ttry {\n\t\t\tAccessControlThreadLocal.setRemoteAccess(true);\n\n\t\t\tObjectValuePair<HttpPrincipal, MethodHandler> ovp =\n\t\t\t\t(ObjectValuePair<HttpPrincipal, MethodHandler>)ois.readObject();\n\n\t\t\tMethodHandler methodHandler = ovp.getValue();\n\n\t\t\tif (methodHandler != null) {\n\t\t\t\tMethodKey methodKey = methodHandler.getMethodKey();\n\n\t\t\t\tif (!isValidRequest(methodKey.getDeclaringClass())) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treturnObj = methodHandler.invoke(true);\n\t\t\t}\n\t\t}\n\t\tcatch (InvocationTargetException ite) {\n\t\t\treturnObj = ite.getCause();\n\n\t\t\tif (!(returnObj instanceof PortalException)) {\n\t\t\t\tite.printStackTrace();\n\n\t\t\t\treturnObj = new SystemException();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t\tfinally {\n\t\t\tAccessControlThreadLocal.setRemoteAccess(remoteAccess);\n\t\t}\n\n\t\tif (returnObj != null) {\n\t\t\ttry {\n\t\t\t\tObjectOutputStream oos = new ObjectOutputStream(\n\t\t\t\t\tresponse.getOutputStream());\n\n\t\t\t\toos.writeObject(returnObj);\n\n\t\t\t\toos.flush();\n\t\t\t\toos.close();\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\t_log.error(ioe, ioe);\n\n\t\t\t\tthrow ioe;\n\t\t\t}\n\t\t}\n\t}","commit_id":"5b2bc55bdf815bf9eea6a6fc5fa7eb5fb1e410f4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Method _get(MethodKey methodKey)\n\t\tthrows ClassNotFoundException, NoSuchMethodException {\n\n\t\tMap<String, Class<?>> classesMap = methodKey.getClassesMap();\n\n\t\tif (classesMap == null) {\n\t\t\tclassesMap = _classesMap;\n\t\t}\n\n\t\tMap<MethodKey, Method> methodsMap = methodKey.getMethodsMap();\n\n\t\tif (methodsMap == null) {\n\t\t\tmethodsMap = _methodsMap;\n\t\t}\n\n\t\tMethod method = methodsMap.get(methodKey);\n\n\t\tif (method == null) {\n\t\t\tString className = methodKey.getClassName();\n\t\t\tString methodName = methodKey.getMethodName();\n\t\t\tClass<?>[] types = methodKey.getTypes();\n\n\t\t\tClass<?> classObj = classesMap.get(className);\n\n\t\t\tif (classObj == null) {\n\t\t\t\tThread currentThread = Thread.currentThread();\n\n\t\t\t\tClassLoader contextClassLoader =\n\t\t\t\t\tcurrentThread.getContextClassLoader();\n\n\t\t\t\tclassObj = contextClassLoader.loadClass(className);\n\n\t\t\t\tclassesMap.put(className, classObj);\n\t\t\t}\n\n\t\t\tmethod = classObj.getMethod(methodName, types);\n\n\t\t\tmethodsMap.put(methodKey, method);\n\t\t}\n\n\t\treturn method;\n\t}","id":73440,"modified_method":"private Method _get(MethodKey methodKey)\n\t\tthrows ClassNotFoundException, NoSuchMethodException {\n\n\t\tMap<String, Class<?>> classesMap = methodKey.getClassesMap();\n\n\t\tif (classesMap == null) {\n\t\t\tclassesMap = _classesMap;\n\t\t}\n\n\t\tMap<MethodKey, Method> methodsMap = methodKey.getMethodsMap();\n\n\t\tif (methodsMap == null) {\n\t\t\tmethodsMap = _methodsMap;\n\t\t}\n\n\t\tMethod method = methodsMap.get(methodKey);\n\n\t\tif (method == null) {\n\t\t\tString className = methodKey.getClassName();\n\t\t\tString methodName = methodKey.getMethodName();\n\t\t\tClass<?>[] parameterTypes = methodKey.getParameterTypes();\n\n\t\t\tClass<?> classObj = classesMap.get(className);\n\n\t\t\tif (classObj == null) {\n\t\t\t\tThread currentThread = Thread.currentThread();\n\n\t\t\t\tClassLoader contextClassLoader =\n\t\t\t\t\tcurrentThread.getContextClassLoader();\n\n\t\t\t\tclassObj = contextClassLoader.loadClass(className);\n\n\t\t\t\tclassesMap.put(className, classObj);\n\t\t\t}\n\n\t\t\tmethod = classObj.getMethod(methodName, parameterTypes);\n\n\t\t\tmethodsMap.put(methodKey, method);\n\t\t}\n\n\t\treturn method;\n\t}","commit_id":"1a1d0f1907a4122376e914ec89d114a5e9f90b1a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MethodKey(String className, String methodName, Class<?>[] types) {\n\t\tthis(null, null, className, methodName, types);\n\t}","id":73441,"modified_method":"public MethodKey(\n\t\tString className, String methodName, Class<?>[] parameterTypes) {\n\n\t\tthis(null, null, className, methodName, parameterTypes);\n\t}","commit_id":"1a1d0f1907a4122376e914ec89d114a5e9f90b1a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private String _toString() {\n\t\tif (_toString == null) {\n\t\t\tStringBundler sb = new StringBundler();\n\n\t\t\tsb.append(_className);\n\t\t\tsb.append(_methodName);\n\n\t\t\tif ((_types != null) && (_types.length > 0)) {\n\t\t\t\tsb.append(StringPool.DASH);\n\n\t\t\t\tfor (Class<?> type : _types) {\n\t\t\t\t\tsb.append(type.getName());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_toString = sb.toString();\n\t\t}\n\n\t\treturn _toString;\n\t}","id":73442,"modified_method":"private String _toString() {\n\t\tif (_toString == null) {\n\t\t\tStringBundler sb = new StringBundler();\n\n\t\t\tsb.append(_className);\n\t\t\tsb.append(_methodName);\n\n\t\t\tif ((_parameterTypes != null) && (_parameterTypes.length > 0)) {\n\t\t\t\tsb.append(StringPool.DASH);\n\n\t\t\t\tfor (Class<?> parameterType : _parameterTypes) {\n\t\t\t\t\tsb.append(parameterType.getName());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_toString = sb.toString();\n\t\t}\n\n\t\treturn _toString;\n\t}","commit_id":"1a1d0f1907a4122376e914ec89d114a5e9f90b1a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MethodKey(\n\t\tMap<String, Class<?>> classesMap, Map<MethodKey, Method> methodsMap,\n\t\tString className, String methodName, Class<?>[] types) {\n\n\t\t_classesMap = classesMap;\n\t\t_methodsMap = methodsMap;\n\t\t_className = className;\n\t\t_methodName = methodName;\n\t\t_types = types;\n\t}","id":73443,"modified_method":"public MethodKey(\n\t\tMap<String, Class<?>> classesMap, Map<MethodKey, Method> methodsMap,\n\t\tString className, String methodName, Class<?>[] parameterTypes) {\n\n\t\t_classesMap = classesMap;\n\t\t_methodsMap = methodsMap;\n\t\t_className = className;\n\t\t_methodName = methodName;\n\t\t_parameterTypes = parameterTypes;\n\t}","commit_id":"1a1d0f1907a4122376e914ec89d114a5e9f90b1a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Class<?>[] getTypes() {\n\t\treturn _types;\n\t}","id":73444,"modified_method":"public Class<?>[] getParameterTypes() {\n\t\treturn _parameterTypes;\n\t}","commit_id":"1a1d0f1907a4122376e914ec89d114a5e9f90b1a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static MethodKey create(\n\t\t\tString className, String methodName, String[] types)\n\t\tthrows ClassNotFoundException {\n\n\t\tClass[] parameterTypes = new Class[types.length];\n\n\t\tint counter = 0;\n\t\tfor (String type : types) {\n\t\t\tparameterTypes[counter] = Class.forName(type);\n\n\t\t\tcounter++;\n\t\t}\n\n\t\treturn new MethodKey(className, methodName, parameterTypes);\n\t}","id":73445,"modified_method":"public static MethodKey create(\n\t\t\tString className, String methodName, String[] parameterTypeNames)\n\t\tthrows ClassNotFoundException {\n\n\t\tClass<?>[] parameterTypes = new Class[parameterTypeNames.length];\n\n\t\tfor (int i = 0; i < parameterTypeNames.length; i++) {\n\t\t\tString parameterTypeName = parameterTypeNames[i];\n\n\t\t\tparameterTypes[i] = Class.forName(parameterTypeName);\n\t\t}\n\n\t\treturn new MethodKey(className, methodName, parameterTypes);\n\t}","commit_id":"1a1d0f1907a4122376e914ec89d114a5e9f90b1a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processDataSample(ServiceRequestDataSample dataSample)\n\t\tthrows MonitoringException {\n\n\t\tString className = dataSample.getMethodKey().getClassName();\n\n\t\tServiceStatistics serviceStatistics = _serviceStatistics.get(className);\n\t\tif (serviceStatistics == null) {\n\t\t\tserviceStatistics = new ServiceStatistics(className);\n\n\t\t\t_serviceStatistics.put(className, serviceStatistics);\n\t\t}\n\n\t\tserviceStatistics.processDataSample(dataSample);\n\t}","id":73446,"modified_method":"public void processDataSample(\n\t\tServiceRequestDataSample serviceRequestDataSample) {\n\n\t\tMethodKey methodKey = serviceRequestDataSample.getMethodKey();\n\n\t\tString className = methodKey.getClassName();\n\n\t\tServiceStatistics serviceStatistics = _serviceStatistics.get(className);\n\n\t\tif (serviceStatistics == null) {\n\t\t\tserviceStatistics = new ServiceStatistics(className);\n\n\t\t\t_serviceStatistics.put(className, serviceStatistics);\n\t\t}\n\n\t\tserviceStatistics.processDataSample(serviceRequestDataSample);\n\t}","commit_id":"1a1d0f1907a4122376e914ec89d114a5e9f90b1a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addMonitoredClass(String monitoredClass) {\n\t\t_serviceMonitorAdvice.addMonitoredClass(monitoredClass);\n\t}","id":73447,"modified_method":"public void addMonitoredClass(String className) {\n\t\t_serviceMonitorAdvice.addMonitoredClass(className);\n\t}","commit_id":"1a1d0f1907a4122376e914ec89d114a5e9f90b1a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addMonitoredMethod(\n\t\t\tString className, String methodName, String[] parameterTypes)\n\t\tthrows SystemException {\n\n\t\ttry {\n\t\t\tMethodKey methodKey = MethodKey.create(\n\t\t\t\tclassName, methodName, parameterTypes);\n\n\t\t\t_monitoredMethods.add(methodKey);\n\t\t}\n\t\tcatch (ClassNotFoundException e) {\n\t\t\tthrow new SystemException(\"Unable to add method\", e);\n\t\t}\n\t}","id":73448,"modified_method":"public void addMonitoredMethod(\n\t\t\tString className, String methodName, String[] parameterTypes)\n\t\tthrows SystemException {\n\n\t\ttry {\n\t\t\tMethodKey methodKey = MethodKey.create(\n\t\t\t\tclassName, methodName, parameterTypes);\n\n\t\t\t_monitoredMethods.add(methodKey);\n\t\t}\n\t\tcatch (ClassNotFoundException cnfe) {\n\t\t\tthrow new SystemException(\"Unable to add method\", cnfe);\n\t\t}\n\t}","commit_id":"1a1d0f1907a4122376e914ec89d114a5e9f90b1a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addMonitoredClass(String monitoredClass) {\n\t\t_monitoredClasses.add(monitoredClass);\n\t}","id":73449,"modified_method":"public void addMonitoredClass(String className) {\n\t\t_monitoredClasses.add(className);\n\t}","commit_id":"1a1d0f1907a4122376e914ec89d114a5e9f90b1a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean isMonitored(MethodInvocation methodInvocation) {\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tString className = method.getDeclaringClass().getName();\n\n\t\tif (_monitoredClasses.contains(className)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tString methodName = method.getName();\n\t\tClass[] types = method.getParameterTypes();\n\n\t\tMethodKey methodKey = new MethodKey(className, methodName, types);\n\n\t\tif (_monitoredMethods.contains(methodKey)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":73450,"modified_method":"protected boolean isMonitored(MethodInvocation methodInvocation) {\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tClass<?> declaringClass = method.getDeclaringClass();\n\n\t\tString className = declaringClass.getName();\n\n\t\tif (_monitoredClasses.contains(className)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tString methodName = method.getName();\n\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\n\t\tMethodKey methodKey = new MethodKey(\n\t\t\tclassName, methodName, parameterTypes);\n\n\t\tif (_monitoredMethods.contains(methodKey)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"1a1d0f1907a4122376e914ec89d114a5e9f90b1a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ServiceRequestDataSample(MethodInvocation methodInvocation) {\n\n\t\tsetNamespace(MonitorNames.SERVICE);\n\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tString className = method.getDeclaringClass().getName();\n\t\tString methodName = method.getName();\n\t\tClass[] parameterTypes = method.getParameterTypes();\n\n\t\t_methodKey = new MethodKey(className, methodName, parameterTypes);\n\n\t\tsetDescription(_methodKey.toString());\n\t}","id":73451,"modified_method":"public ServiceRequestDataSample(MethodInvocation methodInvocation) {\n\t\tsetNamespace(MonitorNames.SERVICE);\n\n\t\tMethod method = methodInvocation.getMethod();\n\n\t\tString className = method.getDeclaringClass().getName();\n\t\tString methodName = method.getName();\n\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\n\t\t_methodKey = new MethodKey(className, methodName, parameterTypes);\n\n\t\tsetDescription(_methodKey.toString());\n\t}","commit_id":"1a1d0f1907a4122376e914ec89d114a5e9f90b1a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processDataSample(ServiceRequestDataSample dataSample)\n\t\tthrows MonitoringException {\n\n\t\tMethodKey methodKey = dataSample.getMethodKey();\n\n\t\tRequestStatistics requestStatistics = _methodRequestStatistics.get(\n\t\t\tmethodKey);\n\n\t\tif (requestStatistics == null) {\n\t\t\trequestStatistics = new RequestStatistics(methodKey.toString());\n\n\t\t\t_methodRequestStatistics.put(methodKey, requestStatistics);\n\t\t}\n\n\t\tif (dataSample.getRequestStatus() == RequestStatus.ERROR) {\n\t\t\trequestStatistics.incrementError();\n\t\t}\n\t\telse if (dataSample.getRequestStatus() == RequestStatus.TIMEOUT) {\n\t\t\trequestStatistics.incrementTimeout();\n\t\t}\n\t\telse if (dataSample.getRequestStatus() == RequestStatus.SUCCESS) {\n\t\t\trequestStatistics.incrementSuccessDuration(\n\t\t\t\tdataSample.getDuration());\n\t\t}\n\t}","id":73452,"modified_method":"public void processDataSample(\n\t\tServiceRequestDataSample serviceRequestDataSample) {\n\n\t\tMethodKey methodKey = serviceRequestDataSample.getMethodKey();\n\n\t\tRequestStatistics requestStatistics = _methodRequestStatistics.get(\n\t\t\tmethodKey);\n\n\t\tif (requestStatistics == null) {\n\t\t\trequestStatistics = new RequestStatistics(methodKey.toString());\n\n\t\t\t_methodRequestStatistics.put(methodKey, requestStatistics);\n\t\t}\n\n\t\tRequestStatus requestStatus =\n\t\t\tserviceRequestDataSample.getRequestStatus();\n\n\t\tif (requestStatus == RequestStatus.ERROR) {\n\t\t\trequestStatistics.incrementError();\n\t\t}\n\t\telse if (requestStatus == RequestStatus.TIMEOUT) {\n\t\t\trequestStatistics.incrementTimeout();\n\t\t}\n\t\telse if (requestStatus == RequestStatus.SUCCESS) {\n\t\t\trequestStatistics.incrementSuccessDuration(\n\t\t\t\tserviceRequestDataSample.getDuration());\n\t\t}\n\t}","commit_id":"1a1d0f1907a4122376e914ec89d114a5e9f90b1a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void renderMetadata(Map parameters, Writer out) throws IOException {\n        String blogStr = getString(parameters, PARAM_BLOG);\n        if (blogStr != null) { \n            Hash blog = new Hash(Base64.decode(blogStr));\n            Archive archive = BlogManager.instance().getArchive();\n            BlogInfo info = archive.getBlogInfo(blog);\n            if (info == null) {\n                out.write(\"Blog \" + blog.toBase64() + \" does not exist\");\n                return;\n            }\n            String props[] = info.getProperties();\n            out.write(\"<table class=\\\"b_meta\\\" border=\\\"0\\\">\");\n            for (int i = 0; i < props.length; i++) {\n                if (props[i].equals(BlogInfo.OWNER_KEY)) {\n                    out.write(\"<tr class=\\\"b_metaBlog\\\"><td class=\\\"b_metaBlog\\\"><span class=\\\"b_metaBlog\\\">Blog:<\/span><\/td>\");\n                    String blogURL = HTMLRenderer.getPageURL(blog, null, -1, -1, -1, false, false);\n                    out.write(\"<td class=\\\"b_metaBlog\\\"><a class=\\\"b_metaBlog\\\" href=\\\"\" + blogURL + \"\\\">\" + Base64.encode(blog.getData()) + \"<\/td><\/tr>\\n\");\n                } else if (props[i].equals(BlogInfo.SIGNATURE)) {\n                    continue;\n                } else if (props[i].equals(BlogInfo.POSTERS)) {\n                    SigningPublicKey keys[] = info.getPosters();\n                    if ( (keys != null) && (keys.length > 0) ) {\n                        out.write(\"<tr class=\\\"b_metaAuthor\\\"><td class=\\\"b_metaAuthor\\\"><span class=\\\"b_metaAuthor\\\">Allowed authors:<\/span><\/td>\");\n                        out.write(\"<td class=\\\"b_metaAuthor\\\">\");\n                        for (int j = 0; j < keys.length; j++) {\n                            out.write(\"<span class=\\\"b_metaAuthor\\\">\" + keys[j].calculateHash().toBase64() + \"<\/span>\");\n                            if (j + 1 < keys.length)\n                                out.write(\"<br />\\n\");\n                        }\n                        out.write(\"<\/td><\/tr>\\n\");\n                    }\n                } else {\n                    out.write(\"<tr class=\\\"b_metaField\\\"><td class=\\\"b_metaField\\\"><span class=\\\"b_metaField\\\">\" + HTMLRenderer.sanitizeString(props[i]) \n                              + \":<\/span><\/td><td class=\\\"b_metaValue\\\"><span class=\\\"b_metaValue\\\">\" + HTMLRenderer.sanitizeString(info.getProperty(props[i])) + \"<\/span><\/td><\/tr>\\n\");\n                }\n            }\n            List tags = BlogManager.instance().getArchive().getIndex().getBlogTags(blog);\n            if ( (tags != null) && (tags.size() > 0) ) {\n                out.write(\"<tr class=\\\"b_metaTags\\\"><td class=\\\"b_metaTags\\\"><span class=\\\"b_metaTags\\\">Known tags:<\/span><\/td><td class=\\\"b_metaTags\\\">\");\n                for (int i = 0; i < tags.size(); i++) {\n                    String tag = (String)tags.get(i);\n                    out.write(\"<a class=\\\"b_metaTag\\\" href=\\\"\" + HTMLRenderer.getPageURL(blog, tag, -1, -1, -1, false, false) + \"\\\">\" +\n                              HTMLRenderer.sanitizeString(tag) + \"<\/a> \");\n                }\n                out.write(\"<\/td><\/tr>\");\n            }\n            out.write(\"<\/table>\");\n        } else {\n            out.write(\"<span class=\\\"b_metaMsgErr\\\">Blog not specified<\/span>\");\n        }\n    }","id":73453,"modified_method":"/**\n     * @param currentURI URI of the with current page without any parameters tacked on\n     */\n    public static void renderMetadata(User viewer, String currentURI, Map parameters, Writer out) throws IOException {\n        if (parameters.get(\"action\") != null) {\n            updateMetadata(viewer, parameters, out);\n        }\n        String blogStr = getString(parameters, PARAM_BLOG);\n        if (blogStr != null) { \n            Hash blog = new Hash(Base64.decode(blogStr));\n            Archive archive = BlogManager.instance().getArchive();\n            BlogInfo info = archive.getBlogInfo(blog);\n            if (info == null) {\n                out.write(\"Blog \" + blog.toBase64() + \" does not exist\");\n                return;\n            }\n            boolean isUser = ( (viewer != null) && (viewer.getAuthenticated()) && (viewer.getBlog().equals(info.getKey().calculateHash())) );\n            String props[] = info.getProperties();\n            if (isUser) {\n                out.write(\"<form action=\\\"\" + getURL(currentURI, parameters) + \"\\\" method=\\\"GET\\\">\\n\");\n                out.write(\"<input type=\\\"hidden\\\" name=\\\"submit_blog\\\" value=\\\"\" + blog.toBase64() + \"\\\" />\\n\");\n            }\n            out.write(\"<table class=\\\"b_meta\\\" border=\\\"0\\\">\");\n            for (int i = 0; i < props.length; i++) {\n                if (props[i].equals(BlogInfo.OWNER_KEY)) {\n                    out.write(\"<tr class=\\\"b_metaBlog\\\"><td class=\\\"b_metaBlog\\\"><span class=\\\"b_metaBlog\\\">Blog:<\/span><\/td>\");\n                    String blogURL = HTMLRenderer.getPageURL(blog, null, -1, -1, -1, false, false);\n                    out.write(\"<td class=\\\"b_metaBlog\\\"><a class=\\\"b_metaBlog\\\" href=\\\"\" + blogURL + \"\\\">\" + Base64.encode(blog.getData()) + \"<\/td><\/tr>\\n\");\n                } else if (props[i].equals(BlogInfo.SIGNATURE)) {\n                    continue;\n                } else if (props[i].equals(BlogInfo.POSTERS)) {\n                    SigningPublicKey keys[] = info.getPosters();\n                    if ( (keys != null) && (keys.length > 0) ) {\n                        out.write(\"<tr class=\\\"b_metaAuthor\\\"><td class=\\\"b_metaAuthor\\\"><span class=\\\"b_metaAuthor\\\">Allowed authors:<\/span><\/td>\");\n                        out.write(\"<td class=\\\"b_metaAuthor\\\">\");\n                        for (int j = 0; j < keys.length; j++) {\n                            out.write(\"<span class=\\\"b_metaAuthor\\\">\" + keys[j].calculateHash().toBase64() + \"<\/span>\");\n                            if (j + 1 < keys.length)\n                                out.write(\"<br />\\n\");\n                        }\n                        out.write(\"<\/td><\/tr>\\n\");\n                    }\n                } else {\n                    String field = HTMLRenderer.sanitizeString(props[i]);\n                    String val = HTMLRenderer.sanitizeString(info.getProperty(props[i]));\n                    out.write(\"<tr class=\\\"b_metaField\\\"><td class=\\\"b_metaField\\\"><span class=\\\"b_metaField\\\">\" + field\n                              + \":<\/span><\/td><td class=\\\"b_metaValue\\\"><span class=\\\"b_metaValue\\\">\" + val + \"<\/span><\/td><\/tr>\\n\");\n                    \n                    if (isUser && (!field.equals(\"Edition\")))\n                        out.write(\"<tr class=\\\"b_metaField\\\"><td>&nbsp;<\/td><td class=\\\"b_metaValue\\\"><input type=\\\"text\\\" name=\\\"\" \n                                  + HTMLRenderer.sanitizeTagParam(props[i]) + \"\\\" value=\\\"\" \n                                  + HTMLRenderer.sanitizeTagParam(info.getProperty(props[i])) + \"\\\" size=\\\"40\\\" ><\/td><\/tr>\");\n                }\n            }\n            List tags = BlogManager.instance().getArchive().getIndex().getBlogTags(blog);\n            if ( (tags != null) && (tags.size() > 0) ) {\n                out.write(\"<tr class=\\\"b_metaTags\\\"><td class=\\\"b_metaTags\\\"><span class=\\\"b_metaTags\\\">Known tags:<\/span><\/td><td class=\\\"b_metaTags\\\">\");\n                for (int i = 0; i < tags.size(); i++) {\n                    String tag = (String)tags.get(i);\n                    out.write(\"<a class=\\\"b_metaTag\\\" href=\\\"\" + HTMLRenderer.getPageURL(blog, tag, -1, -1, -1, false, false) + \"\\\">\" +\n                              HTMLRenderer.sanitizeString(tag) + \"<\/a> \");\n                }\n                out.write(\"<\/td><\/tr>\");\n            }\n            if (isUser)\n                out.write(\"<tr class=\\\"b_metaField\\\"><td colspan=\\\"2\\\" class=\\\"b_metaField\\\"><input type=\\\"submit\\\" name=\\\"action\\\" value=\\\"Save changes\\\" class=\\\"b_metaSave\\\" /><\/td><\/tr>\\n\");\n            out.write(\"<\/table>\");\n        } else {\n            out.write(\"<span class=\\\"b_metaMsgErr\\\">Blog not specified<\/span>\");\n        }\n    }","commit_id":"848ead76835277a4e439fcb44df5b6ccd78d426e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run() {\n            _isRunning = true;\n            reseed();\n            System.setProperty(\"net.i2p.router.web.ReseedHandler.reseedInProgress\", \"false\");\n            _isRunning = false;\n        }","id":73454,"modified_method":"public void run() {\n            _isRunning = true;\n            reseed(false);\n            System.out.println(\"Reseeding complete\");\n            System.setProperty(\"net.i2p.router.web.ReseedHandler.reseedInProgress\", \"false\");\n            _isRunning = false;\n        }","commit_id":"848ead76835277a4e439fcb44df5b6ccd78d426e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Reseed has been requested, so lets go ahead and do it.  Fetch all of\n     * the routerInfo-*.dat files from the specified URL (or the default) and\n     * save them into this router's netDb dir.\n     *\n     */\n    private static void reseed() {\n        String seedURL = System.getProperty(\"i2p.reseedURL\", DEFAULT_SEED_URL);\n        if ( (seedURL == null) || (seedURL.trim().length() <= 0) ) \n            seedURL = DEFAULT_SEED_URL;\n        try {\n            URL dir = new URL(seedURL);\n            String content = new String(readURL(dir));\n            Set urls = new HashSet();\n            int cur = 0;\n            while (true) {\n                int start = content.indexOf(\"href=\\\"routerInfo-\", cur);\n                if (start < 0)\n                    break;\n\n                int end = content.indexOf(\".dat\\\">\", start);\n                String name = content.substring(start+\"href=\\\"routerInfo-\".length(), end);\n                urls.add(name);\n                cur = end + 1;\n            }\n\n            int fetched = 0;\n            int errors = 0;\n            for (Iterator iter = urls.iterator(); iter.hasNext(); ) {\n                try {\n                    fetchSeed(seedURL, (String)iter.next());\n                    fetched++;\n                } catch (Exception e) {\n                    errors++;\n                }\n            }\n        } catch (Throwable t) {\n            I2PAppContext.getGlobalContext().logManager().getLog(ReseedHandler.class).error(\"Error reseeding\", t);\n        }\n    }","id":73455,"modified_method":"public static void requestReseed() {\n        synchronized (_reseedRunner) {\n            if (_reseedRunner.isRunning()) {\n                return;\n            } else {\n                System.setProperty(\"net.i2p.router.web.ReseedHandler.reseedInProgress\", \"true\");\n                System.out.println(\"Reseeding\");\n                I2PThread reseed = new I2PThread(_reseedRunner, \"Reseed\");\n                reseed.start();\n            }\n        }\n    }","commit_id":"848ead76835277a4e439fcb44df5b6ccd78d426e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public static void main(String args[]) {\n        reseed();\n        //System.out.println(\"Done reseeding\");\n    }","id":73456,"modified_method":"public static void main(String args[]) {\n        if ( (args != null) && (args.length == 1) && (!Boolean.valueOf(args[0]).booleanValue()) ) {\n            System.out.println(\"Not reseeding, as requested\");\n            return; // not reseeding on request\n        }\n        System.out.println(\"Reseeding\");\n        reseed(true);\n    }","commit_id":"848ead76835277a4e439fcb44df5b6ccd78d426e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void setReseedNonce(String nonce) { \n        if (nonce == null) return;\n        if (nonce.equals(System.getProperty(\"net.i2p.router.web.ReseedHandler.nonce\")) ||\n            nonce.equals(System.getProperty(\"net.i2p.router.web.ReseedHandler.noncePrev\"))) {\n            synchronized (_reseedRunner) {\n                if (_reseedRunner.isRunning()) {\n                    return;\n                } else {\n                    System.setProperty(\"net.i2p.router.web.ReseedHandler.reseedInProgress\", \"true\");\n                    I2PThread reseed = new I2PThread(_reseedRunner, \"Reseed\");\n                    reseed.start();\n                }\n            }\n        }\n    }","id":73457,"modified_method":"public void setReseedNonce(String nonce) { \n        if (nonce == null) return;\n        if (nonce.equals(System.getProperty(\"net.i2p.router.web.ReseedHandler.nonce\")) ||\n            nonce.equals(System.getProperty(\"net.i2p.router.web.ReseedHandler.noncePrev\"))) {\n            requestReseed();\n        }\n    }","commit_id":"848ead76835277a4e439fcb44df5b6ccd78d426e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void startConsole() {\n        File workDir = new File(\"work\");\n        boolean workDirRemoved = FileUtil.rmdir(workDir, false);\n        if (!workDirRemoved)\n            System.err.println(\"ERROR: Unable to remove Jetty temporary work directory\");\n        boolean workDirCreated = workDir.mkdirs();\n        if (!workDirCreated)\n            System.err.println(\"ERROR: Unable to create Jetty temporary work directory\");\n        \n        _server = new Server();\n        WebApplicationContext contexts[] = null;\n        try {\n            _server.addListener(_listenHost + ':' + _listenPort);\n            _server.setRootWebApp(\"routerconsole\");\n            contexts = _server.addWebApplications(_webAppsDir);\n            if (contexts != null) {\n                for (int i = 0; i < contexts.length; i++) \n                    initialize(contexts[i]);\n            }\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n        try {\n            _server.start();\n        } catch (Exception me) {\n            me.printStackTrace();\n        }\n        try {\n            SysTray tray = SysTray.getInstance();\n        } catch (Throwable t) {\n            t.printStackTrace();\n        }\n        \n        NewsFetcher fetcher = NewsFetcher.getInstance(I2PAppContext.getGlobalContext());\n        I2PThread t = new I2PThread(fetcher, \"NewsFetcher\");\n        t.setDaemon(true);\n        t.start();\n    }","id":73458,"modified_method":"public void startConsole() {\n        File workDir = new File(\"work\");\n        boolean workDirRemoved = FileUtil.rmdir(workDir, false);\n        if (!workDirRemoved)\n            System.err.println(\"ERROR: Unable to remove Jetty temporary work directory\");\n        boolean workDirCreated = workDir.mkdirs();\n        if (!workDirCreated)\n            System.err.println(\"ERROR: Unable to create Jetty temporary work directory\");\n        \n        _server = new Server();\n        WebApplicationContext contexts[] = null;\n        try {\n            _server.addListener(_listenHost + ':' + _listenPort);\n            _server.setRootWebApp(\"routerconsole\");\n            contexts = _server.addWebApplications(_webAppsDir);\n            if (contexts != null) {\n                for (int i = 0; i < contexts.length; i++) \n                    initialize(contexts[i]);\n            }\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n        try {\n            _server.start();\n        } catch (Exception me) {\n            me.printStackTrace();\n        }\n        try {\n            SysTray tray = SysTray.getInstance();\n        } catch (Throwable t) {\n            t.printStackTrace();\n        }\n\n        File noReseedFile = new File(new File(System.getProperty(\"user.home\")), \".i2pnoreseed\");\n        if (!noReseedFile.exists()) {\n            RouterContext ctx = (RouterContext)RouterContext.listContexts().get(0);\n            if (ctx.netDb().getKnownRouters() < 15) {\n                ReseedHandler.requestReseed();\n            }\n        }\n        \n        NewsFetcher fetcher = NewsFetcher.getInstance(I2PAppContext.getGlobalContext());\n        I2PThread t = new I2PThread(fetcher, \"NewsFetcher\");\n        t.setDaemon(true);\n        t.start();\n    }","commit_id":"848ead76835277a4e439fcb44df5b6ccd78d426e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run() {\n            _isRunning = true;\n            update();\n            System.setProperty(\"net.i2p.router.web.ReseedHandler.updateInProgress\", \"false\");\n            _isRunning = false;\n        }","id":73459,"modified_method":"public void run() {\n            _isRunning = true;\n            update();\n            System.setProperty(\"net.i2p.router.web.UpdateHandler.updateInProgress\", \"false\");\n            _isRunning = false;\n        }","commit_id":"848ead76835277a4e439fcb44df5b6ccd78d426e","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n  public EditorCell createEditorCell(EditorContext context, SNode node) {\n    myView.text().set(node.getName());\n    return GenericViewCell.createViewCell(context, node, myView);\n  }","id":73460,"modified_method":"@Override\n  public EditorCell createEditorCell(EditorContext context, SNode node) {\n    GenericViewCell viewCell = GenericViewCell.createViewCell(context, node, myView);\n    GenericViewCell rectCell = createRectCell(context, node);\n    viewCell.addEditorCell(rectCell);\n    myView.setRectView(((RectView) rectCell.getView()));\n\n    GenericViewCell textCell = createTextCell(context, node);\n    viewCell.addEditorCell(textCell);\n    myView.setTextView(((TextView) textCell.getView()));\n\n    return viewCell;\n  }","commit_id":"918dda0bdc9183048754d928ced2fa587d35bae2","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public EditorCell createEditorCell(EditorContext context, SNode node) {\n    GenericViewCell cell = GenericViewCell.createViewCell(context, node, myView);\n    EditorCell_Collection collection = createBlockCollection(context, node);\n    cell.addEditorCell(collection);\n    int i = 0;\n    for (EditorCell child : Sequence.fromIterable(collection)) {\n      if (child instanceof GenericViewCell) {\n        View view = ((GenericViewCell) child).getView();\n        myView.itemsView.children().add(view);\n        view.moveTo(new Vector(i, i));\n        i += 10;\n      }\n    }\n    return cell;\n  }","id":73461,"modified_method":"@Override\n  public EditorCell createEditorCell(EditorContext context, SNode node) {\n    GenericViewCell cell = GenericViewCell.createViewCell(context, node, myView);\n    EditorCell_Collection collection = createBlockCollection(context, node);\n    cell.addEditorCell(collection);\n    int i = 40;\n    for (EditorCell child : Sequence.fromIterable(collection)) {\n      if (child instanceof GenericViewCell) {\n        View view = ((GenericViewCell) child).getView();\n        myView.itemsView.children().add(view);\n        view.moveTo(new Vector(i, i));\n        i += 40;\n      }\n    }\n    return cell;\n  }","commit_id":"918dda0bdc9183048754d928ced2fa587d35bae2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Collection<ConceptEditor> getEditors(ConceptDescriptor descriptor) {\n    if (\"jetbrains.mps.testHybridEditor.structure.Diagram\".equals(descriptor.getConceptFqName())) {\n      return Collections.<ConceptEditor>singletonList(new DiagramEditor());\n    } else if (\"jetbrains.mps.testHybridEditor.structure.Block\".equals(descriptor.getConceptFqName())) {\n      return Collections.<ConceptEditor>singletonList(new BlockEditor());\n    }\n    return Collections.<ConceptEditor>emptyList();\n  }","id":73462,"modified_method":"public Collection<ConceptEditor> getEditors(ConceptDescriptor descriptor) {\n    if (\"jetbrains.mps.testHybridEditor.structure.Diagram\".equals(descriptor.getConceptFqName())) {\n      return Collections.<ConceptEditor>singletonList(new DiagramEditor());\n    } else if (\"jetbrains.mps.testHybridEditor.structure.Block\".equals(descriptor.getConceptFqName())) {\n      return Collections.<ConceptEditor>singletonList(new BlockEditor());\n    } else if (\"jetbrains.mps.testHybridEditor.structure.Connector\".equals(descriptor.getConceptFqName())) {\n      return Collections.<ConceptEditor>singletonList(new ConnectorEditor());\n    }\n    return Collections.<ConceptEditor>emptyList();\n  }","commit_id":"918dda0bdc9183048754d928ced2fa587d35bae2","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void paintContent(Graphics g, ParentSettings parentSettings) {\n    Color background = myView.background().get();\n    Rectangle bounds = myView.bounds().get();\n\n    if (background != null) {\n      g.setColor(JetpadUtils.toAwtColor(background));\n      g.fillRect(bounds.origin.x, bounds.origin.y, bounds.dimension.x, bounds.dimension.y);\n    }\n\n    Color border = myView.border().get();\n    if (border != null) {\n      g.setColor(JetpadUtils.toAwtColor(border));\n      g.drawRect(bounds.origin.x, bounds.origin.y, bounds.dimension.x - 1, bounds.dimension.y - 1);\n    }\n\n    if (myView instanceof RectView) {\n      RectView rectView = (RectView) myView;\n      g.setColor(JetpadUtils.toAwtColor(rectView.background().get()));\n\n      g.fillRect(bounds.origin.x, bounds.origin.y, bounds.dimension.x, bounds.dimension.y);\n    }\n\n    if (myView instanceof LineView) {\n      LineView lineView = (LineView) myView;\n      g.setColor(JetpadUtils.toAwtColor(lineView.color().get()));\n      Vector start = lineView.start().get();\n      Vector end = lineView.end().get();\n      g.drawLine(start.x, start.y, end.x, end.y);\n    }\n\n    if (myView instanceof TextView) {\n      TextView textView = (TextView) myView;\n      String text = textView.text().get();\n      Vector origin = bounds.origin;\n      Font font = myFont;\n\n      if (textView.bold().get()) {\n        font = font.deriveFont(Font.BOLD, font.getSize());\n      }\n\n      g.setFont(font);\n      g.setColor(JetpadUtils.toAwtColor(textView.textColor().get()));\n      g.drawString(text, origin.x, origin.y + textView.baseLine());\n\n//      if (textView.caretVisible().get() && myCaretVisible && myFocused) {\n//        int xOffset = Math.max(0, getFontMetrics().stringWidth(text.substring(0, textView.caretPosition().get())));\n//        g.drawLine(origin.x + xOffset, origin.y, origin.x + xOffset, origin.y + bounds.dimension.y - 1);\n//      }\n    }\n  }","id":73463,"modified_method":"@Override\n  public void paintContent(Graphics g, ParentSettings parentSettings) {\n    paintContent(g, parentSettings, myView);\n  }","commit_id":"918dda0bdc9183048754d928ced2fa587d35bae2","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public EditorCell createEditorCell(EditorContext context, SNode node) {\n    GenericViewCell viewCell = GenericViewCell.createViewCell(context, node, myView);\n    GenericViewCell rectCell = createRectCell(context, node);\n    viewCell.addEditorCell(rectCell);\n    myView.setRectView(((RectView) rectCell.getView()));\n\n    GenericViewCell textCell = createTextCell(context, node);\n    viewCell.addEditorCell(textCell);\n    myView.setTextView(((TextView) textCell.getView()));\n\n    return viewCell;\n  }","id":73464,"modified_method":"@Override\n  public EditorCell createEditorCell(EditorContext context, SNode node) {\n\n    GenericViewCell blockCell = GenericViewCell.createViewCell(context, node, myView);\n\n    createRectCell(context, node, blockCell);\n    createTextCell(context, node, blockCell);\n    return blockCell;\n  }","commit_id":"b885e9fd2700914838087cfff2c1849881042d3d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private GenericViewCell createRectCell(EditorContext context, SNode node) {\n    RectView view = new RectView();\n    view.background().set(Color.LIGHT_GRAY);\n    view.visible().set(true);\n    return GenericViewCell.createViewCell(context, node, view);\n  }","id":73465,"modified_method":"private void createRectCell(EditorContext context, SNode node, GenericViewCell blockCell) {\n    RectView rectView = new RectView();\n    rectView.background().set(Color.LIGHT_GRAY);\n    rectView.visible().set(true);\n    rectView.dimension().set(new Vector(75, 75));\n    myView.setRectView(rectView);\n    GenericViewCell rectCell = GenericViewCell.createViewCell(context, node, rectView);\n    blockCell.addEditorCell(rectCell);\n  }","commit_id":"b885e9fd2700914838087cfff2c1849881042d3d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private GenericViewCell createTextCell(EditorContext context, SNode node) {\n    MPSTextView view = new MPSTextView(EditorSettings.getInstance().getDefaultEditorFont());\n    view.text().set(node.getName());\n    return GenericViewCell.createViewCell(context, node, view);\n  }","id":73466,"modified_method":"private void createTextCell(EditorContext context, SNode node, GenericViewCell blockCell) {\n    MPSTextView textView = new MPSTextView(EditorSettings.getInstance().getDefaultEditorFont());\n    textView.text().set(node.getName());\n    myView.setTextView(textView);\n    GenericViewCell textCell = GenericViewCell.createViewCell(context, node, textView);\n    blockCell.addEditorCell(textCell);\n  }","commit_id":"b885e9fd2700914838087cfff2c1849881042d3d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void createConnectorCollection(EditorContext editorContext, SNode diagramNode, GenericViewCell diagramCell) {\n    for (SNode connectorNode : ListSequence.fromList(SLinkOperations.getTargets(diagramNode, \"connectors\", true))) {\n      ConnectorViewCell connectorCell = (ConnectorViewCell) editorContext.createNodeCell(connectorNode);\n      View connectorView = connectorCell.getView();\n      View fromView = MapSequence.fromMap(nodeToViewMap).get(SNodeOperations.getParent(SLinkOperations.getTarget(connectorNode, \"inputPort\", false)));\n      View toView = MapSequence.fromMap(nodeToViewMap).get(SNodeOperations.getParent(SLinkOperations.getTarget(connectorNode, \"outputPort\", false)));\n      if (fromView != null && toView != null) {\n        diagramCell.addEditorCell(connectorCell);\n        myView.itemsView.children().add(connectorView);\n        PolylineConnection connection = connectorCell.getConnection();\n        connection.toView().set(fromView);\n        connection.fromView().set(toView);\n        connection.update(fromView.bounds().get().center(), toView.bounds().get().center());\n        for (LineView line : ListSequence.fromList(connection.getLines())) {\n          connectorCell.addEditorCell(GenericViewCell.createViewCell(editorContext, diagramNode, line));\n        }\n      }\n    }\n  }","id":73467,"modified_method":"private void createConnectorCollection(EditorContext editorContext, SNode diagramNode, GenericViewCell diagramCell) {\n    for (SNode connectorNode : ListSequence.fromList(SLinkOperations.getTargets(diagramNode, \"connectors\", true))) {\n      ConnectorViewCell connectorCell = (ConnectorViewCell) editorContext.createNodeCell(connectorNode);\n      View connectorView = connectorCell.getView();\n      View fromView = MapSequence.fromMap(nodeToViewMap).get(SNodeOperations.getParent(SLinkOperations.getTarget(connectorNode, \"inputPort\", false)));\n      View toView = MapSequence.fromMap(nodeToViewMap).get(SNodeOperations.getParent(SLinkOperations.getTarget(connectorNode, \"outputPort\", false)));\n      EditorCell_Collection lineCollection = jetbrains.mps.nodeEditor.cells.EditorCell_Collection.createIndent2(editorContext, diagramNode);\n      if (fromView != null && toView != null) {\n        createConnection(lineCollection, connectorCell, connectorView, fromView, toView, editorContext, diagramNode);\n      }\n      diagramCell.addEditorCell(lineCollection);\n    }\n  }","commit_id":"b885e9fd2700914838087cfff2c1849881042d3d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void createBlockCells(EditorContext editorContext, SNode diagramNode, GenericViewCell diagramCell) {\n    for (SNode blockNode : ListSequence.fromList(SLinkOperations.getTargets(diagramNode, \"blocks\", true))) {\n      GenericViewCell blockCell = (GenericViewCell) editorContext.createNodeCell(blockNode);\n      View blockView = blockCell.getView();\n      diagramCell.addEditorCell(blockCell);\n      myView.itemsView.children().add(blockView);\n      blockView.moveTo(new Vector(SPropertyOperations.getInteger(blockNode, \"x\"), SPropertyOperations.getInteger(blockNode, \"y\")));\n      MapSequence.fromMap(nodeToViewMap).put(blockNode, blockView);\n    }\n  }","id":73468,"modified_method":"private void createBlockCells(EditorContext editorContext, SNode diagramNode, GenericViewCell diagramCell) {\n    EditorCell_Collection blockCollection = jetbrains.mps.nodeEditor.cells.EditorCell_Collection.createIndent2(editorContext, diagramNode);\n    for (SNode blockNode : ListSequence.fromList(SLinkOperations.getTargets(diagramNode, \"blocks\", true))) {\n      GenericViewCell blockCell = (GenericViewCell) editorContext.createNodeCell(blockNode);\n      View blockView = blockCell.getView();\n      blockCollection.addEditorCell(blockCell);\n      myView.itemsView.children().add(blockView);\n      blockView.moveTo(new Vector(SPropertyOperations.getInteger(blockNode, \"x\"), SPropertyOperations.getInteger(blockNode, \"y\")));\n      MapSequence.fromMap(nodeToViewMap).put(blockNode, blockView);\n    }\n    diagramCell.addEditorCell(blockCollection);\n  }","commit_id":"b885e9fd2700914838087cfff2c1849881042d3d","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected void relayoutImpl() {\n    super.relayoutImpl();\n    myView.validate();\n    Rectangle bounds = myView.bounds().get();\n    myX = bounds.origin.x;\n    myY = bounds.dimension.y;\n    myWidth = bounds.dimension.x;\n    myHeight = bounds.dimension.y;\n  }","id":73469,"modified_method":"@Override\n  protected void relayoutImpl() {\n    super.relayoutImpl();\n    if(myView instanceof DiagramView) {\n      myView.validate();\n    }\n    Rectangle bounds = myView.bounds().get();\n    myX = bounds.origin.x;\n    myY = bounds.dimension.y;\n    myWidth = bounds.dimension.x;\n    myHeight = bounds.dimension.y;\n  }","commit_id":"b885e9fd2700914838087cfff2c1849881042d3d","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected void doValidate(View.ValidationContext context) {\n    super.doValidate(context);\n    Rectangle labelRect = myTextView.bounds().get();\n    myRectView.moveTo(labelRect.origin);\n    myRectView.dimension().set(labelRect.dimension);\n    super.doValidate(context);\n\n  }","id":73470,"modified_method":"@Override\n  protected void doValidate(View.ValidationContext context) {\n    super.doValidate(context);\n    Rectangle labelRect = myTextView.bounds().get();\n    myRectView.moveTo(labelRect.origin);\n    myRectView.dimension().set(myRectView.dimension().get().max(myTextView.bounds().get().dimension));\n\n    super.doValidate(context);\n\n  }","commit_id":"b885e9fd2700914838087cfff2c1849881042d3d","url":"https://github.com/JetBrains/MPS"},{"original_method":"@DB\n    public void scheduleRulesetUpdateToHosts(Set<Long> affectedVms, boolean updateSeqno, Long delayMs) {\n        if (affectedVms.size() == 0) {\n            return;\n        }\n\n        if (delayMs == null) {\n            delayMs = new Long(100l);\n        }\n\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"Security Group Mgr: scheduling ruleset updates for \" + affectedVms.size() + \" vms\");\n        }\n        Transaction txn = Transaction.currentTxn();\n        txn.start();\n        try {\n            PreparedStatement pstmt = txn.prepareAutoCloseStatement(\"LOCK TABLES op_vm_ruleset_log WRITE, op_nwgrp_work WRITE\");\n            int tablesLocked = pstmt.executeUpdate();\n            if (tablesLocked != 2) {\n                s_logger.warn(\"Unable to get locks on both tables: \" + tablesLocked);\n                return;\n            }\n            for (Long vmId : affectedVms) {\n                if (s_logger.isTraceEnabled()) {\n                    s_logger.trace(\"Security Group Mgr: scheduling ruleset updates for \" + vmId);\n                }\n                VmRulesetLogVO log = null;\n                SecurityGroupWorkVO work = null;\n                log = _rulesetLogDao.findByVmId(vmId);\n                if (log == null) {\n                    log = new VmRulesetLogVO(vmId);\n                    log = _rulesetLogDao.persist(log);\n                }\n\n                if (log != null && updateSeqno) {\n                    log.incrLogsequence();\n                    _rulesetLogDao.update(log.getId(), log);\n                }\n                work = _workDao.findByVmIdStep(vmId, Step.Scheduled);\n                if (work == null) {\n                    work = new SecurityGroupWorkVO(vmId, null, null, SecurityGroupWorkVO.Step.Scheduled, null);\n                    work = _workDao.persist(work);\n                    if (s_logger.isTraceEnabled()) {\n                        s_logger.trace(\"Security Group Mgr: created new work item for \" + vmId);\n                    }\n                }\n\n                work.setLogsequenceNumber(log.getLogsequence());\n                _workDao.update(work.getId(), work);\n\n                _executorPool.schedule(new WorkerThread(), delayMs, TimeUnit.MILLISECONDS);\n            }\n\n            txn.commit();\n        } catch (SQLException e) {\n            s_logger.error(\"Unable to execute lock tables routines\", e);\n        } finally {\n            try {\n                PreparedStatement pstmt = txn.prepareAutoCloseStatement(\"UNLOCK TABLES\");\n                int tablesUnlocked = pstmt.executeUpdate();\n                assert (tablesUnlocked == 2) : \"Less than two tables unlocked: \" + tablesUnlocked;\n            } catch (SQLException e) {\n                s_logger.warn(\"Unable to unlock tables\");\n            }\n        }\n    }","id":73471,"modified_method":"@DB\n    public void scheduleRulesetUpdateToHosts(Set<Long> affectedVms, boolean updateSeqno, Long delayMs) {\n        if (delayMs == null) {\n            delayMs = new Long(100l);\n        }\n        \n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"Security Group Mgr: scheduling ruleset updates for \" + affectedVms.size() + \" vms\");\n        }\n        boolean locked = _workLock.lock(_globalWorkLockTimeout); \n        if (locked) {\n            if (s_logger.isTraceEnabled()) {\n                s_logger.trace(\"Security Group Mgr: acquired global work lock\");\n            }\n            try {\n                for (Long vmId : affectedVms) {\n                    if (s_logger.isTraceEnabled()) {\n                        s_logger.trace(\"Security Group Mgr: scheduling ruleset updates for \" + vmId);\n                    }\n                    VmRulesetLogVO log = null;\n                    SecurityGroupWorkVO work = null;\n                    //UserVm vm = null;\n                    Transaction txn = null;\n                    try {\n                        txn = Transaction.currentTxn();\n                        txn.start();\n\n                        //vm = _userVMDao.acquireInLockTable(vmId);\n                        //if (vm == null) {\n                        //s_logger.warn(\"Failed to acquire lock on vm id \" + vmId);\n                        //continue;\n                        //}\n                        log = _rulesetLogDao.findByVmId(vmId);\n                        if (log == null) {\n                            log = new VmRulesetLogVO(vmId);\n                            log = _rulesetLogDao.persist(log);\n                        }\n\n                        if (log != null && updateSeqno) {\n                            log.incrLogsequence();\n                            _rulesetLogDao.update(log.getId(), log);\n                        }\n                        work = _workDao.findByVmIdStep(vmId, Step.Scheduled);\n                        if (work == null) {\n                            work = new SecurityGroupWorkVO(vmId, null, null, SecurityGroupWorkVO.Step.Scheduled, null);\n                            work = _workDao.persist(work);\n                            if (s_logger.isTraceEnabled()) {\n                                s_logger.trace(\"Security Group Mgr: created new work item for \" + vmId);\n                            }\n                        }\n\n                        work.setLogsequenceNumber(log.getLogsequence());\n                        _workDao.update(work.getId(), work);\n\n                    } finally {\n                        //                if (vm != null) {\n                        //                    _userVMDao.releaseFromLockTable(vmId);\n                        //                }\n                        if (txn != null)\n                            txn.commit();\n                    }\n\n                    _executorPool.schedule(new WorkerThread(), delayMs, TimeUnit.MILLISECONDS);\n                }\n            } finally {\n                _workLock.unlock();\n                if (s_logger.isTraceEnabled()) {\n                    s_logger.trace(\"Security Group Mgr: released global work lock\");\n                }\n            }\n        } else {\n            s_logger.warn(\"Security Group Mgr: failed to acquire global work lock\");\n        }\n    }","commit_id":"92b8b29fe4726b9affac5fc0318edcc11c129d43","url":"https://github.com/apache/cloudstack"},{"original_method":"protected void handleVmStarted(VMInstanceVO vm) {\n        if (vm.getType() != VirtualMachine.Type.User || !isVmSecurityGroupEnabled(vm.getId()))\n            return;\n        Set<Long> affectedVms = getAffectedVmsForVmStart(vm);\n        scheduleRulesetUpdateToHosts(affectedVms, true, null);\n    }","id":73472,"modified_method":"protected void handleVmStarted(VMInstanceVO vm) {\n        if (vm.getType() != VirtualMachine.Type.User || !isVmSecurityGroupEnabled(vm.getId()))\n            return;\n        List<Long> affectedVms = getAffectedVmsForVmStart(vm);\n        scheduleRulesetUpdateToHosts(affectedVms, true, null);\n    }","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    @DB\n    @SuppressWarnings(\"rawtypes\")\n    public List<IngressRuleVO> authorizeSecurityGroupIngress(AuthorizeSecurityGroupIngressCmd cmd) {\n        Long securityGroupId = cmd.getSecurityGroupId();\n        String protocol = cmd.getProtocol();\n        Integer startPort = cmd.getStartPort();\n        Integer endPort = cmd.getEndPort();\n        Integer icmpType = cmd.getIcmpType();\n        Integer icmpCode = cmd.getIcmpCode();\n        List<String> cidrList = cmd.getCidrList();\n        Map groupList = cmd.getUserSecurityGroupList();\n        Integer startPortOrType = null;\n        Integer endPortOrCode = null;\n\n        // Validate parameters\n        SecurityGroup securityGroup = _securityGroupDao.findById(securityGroupId);\n        if (securityGroup == null) {\n            throw new InvalidParameterValueException(\"Unable to find security group by id \" + securityGroupId);\n        }\n\n        if (cidrList == null && groupList == null) {\n            throw new InvalidParameterValueException(\"At least one cidr or at least one security group needs to be specified\");\n        }\n\n        Account caller = UserContext.current().getCaller();\n        Account owner = _accountMgr.getAccount(securityGroup.getAccountId());\n\n        if (owner == null) {\n            throw new InvalidParameterValueException(\"Unable to find security group owner by id=\" + securityGroup.getAccountId());\n        }\n\n        // Verify permissions\n        _accountMgr.checkAccess(caller, null, securityGroup);\n        Long domainId = owner.getDomainId();\n\n        if (protocol == null) {\n            protocol = NetUtils.ALL_PROTO;\n        }\n\n        if (!NetUtils.isValidSecurityGroupProto(protocol)) {\n            throw new InvalidParameterValueException(\"Invalid protocol \" + protocol);\n        }\n        if (\"icmp\".equalsIgnoreCase(protocol)) {\n            if ((icmpType == null) || (icmpCode == null)) {\n                throw new InvalidParameterValueException(\"Invalid ICMP type/code specified, icmpType = \" + icmpType + \", icmpCode = \" + icmpCode);\n            }\n            if (icmpType == -1 && icmpCode != -1) {\n                throw new InvalidParameterValueException(\"Invalid icmp type range\");\n            }\n            if (icmpCode > 255) {\n                throw new InvalidParameterValueException(\"Invalid icmp code \");\n            }\n            startPortOrType = icmpType;\n            endPortOrCode = icmpCode;\n        } else if (protocol.equals(NetUtils.ALL_PROTO)) {\n            if ((startPort != null) || (endPort != null)) {\n                throw new InvalidParameterValueException(\"Cannot specify startPort or endPort without specifying protocol\");\n            }\n            startPortOrType = 0;\n            endPortOrCode = 0;\n        } else {\n            if ((startPort == null) || (endPort == null)) {\n                throw new InvalidParameterValueException(\"Invalid port range specified, startPort = \" + startPort + \", endPort = \" + endPort);\n            }\n            if (startPort == 0 && endPort == 0) {\n                endPort = 65535;\n            }\n            if (startPort > endPort) {\n                throw new InvalidParameterValueException(\"Invalid port range \" + startPort + \":\" + endPort);\n            }\n            if (startPort > 65535 || endPort > 65535 || startPort < -1 || endPort < -1) {\n                throw new InvalidParameterValueException(\"Invalid port numbers \" + startPort + \":\" + endPort);\n            }\n\n            if (startPort < 0 || endPort < 0) {\n                throw new InvalidParameterValueException(\"Invalid port range \" + startPort + \":\" + endPort);\n            }\n            startPortOrType = startPort;\n            endPortOrCode = endPort;\n        }\n\n        protocol = protocol.toLowerCase();\n\n        List<SecurityGroupVO> authorizedGroups = new ArrayList<SecurityGroupVO>();\n        if (groupList != null) {\n            Collection userGroupCollection = groupList.values();\n            Iterator iter = userGroupCollection.iterator();\n            while (iter.hasNext()) {\n                HashMap userGroup = (HashMap) iter.next();\n                String group = (String) userGroup.get(\"group\");\n                String authorizedAccountName = (String) userGroup.get(\"account\");\n\n                if ((group == null) || (authorizedAccountName == null)) {\n                    throw new InvalidParameterValueException(\n                            \"Invalid user group specified, fields 'group' and 'account' cannot be null, please specify groups in the form:  userGroupList[0].group=XXX&userGroupList[0].account=YYY\");\n                }\n\n                Account authorizedAccount = _accountDao.findActiveAccount(authorizedAccountName, domainId);\n                if (authorizedAccount == null) {\n                    throw new InvalidParameterValueException(\"Nonexistent account: \" + authorizedAccountName + \" when trying to authorize ingress for \" + securityGroupId + \":\" + protocol + \":\"\n                            + startPortOrType + \":\" + endPortOrCode);\n                }\n\n                SecurityGroupVO groupVO = _securityGroupDao.findByAccountAndName(authorizedAccount.getId(), group);\n                if (groupVO == null) {\n                    throw new InvalidParameterValueException(\"Nonexistent group \" + group + \" for account \" + authorizedAccountName + \"/\" + domainId + \" is given, unable to authorize ingress.\");\n                }\n\n                // Check permissions\n                _accountMgr.checkAccess(caller, null, groupVO);\n\n                authorizedGroups.add(groupVO);\n            }\n        }\n\n        final Transaction txn = Transaction.currentTxn();\n        final Set<SecurityGroupVO> authorizedGroups2 = new TreeSet<SecurityGroupVO>(new SecurityGroupVOComparator());\n\n        authorizedGroups2.addAll(authorizedGroups); // Ensure we don't re-lock the same row\n        txn.start();\n\n        // Prevents other threads/management servers from creating duplicate ingress rules\n        securityGroup = _securityGroupDao.acquireInLockTable(securityGroupId);\n        if (securityGroup == null) {\n            s_logger.warn(\"Could not acquire lock on network security group: id= \" + securityGroupId);\n            return null;\n        }\n        List<IngressRuleVO> newRules = new ArrayList<IngressRuleVO>();\n        try {\n            for (final SecurityGroupVO ngVO : authorizedGroups2) {\n                final Long ngId = ngVO.getId();\n                // Don't delete the referenced group from under us\n                if (ngVO.getId() != securityGroup.getId()) {\n                    final SecurityGroupVO tmpGrp = _securityGroupDao.lockRow(ngId, false);\n                    if (tmpGrp == null) {\n                        s_logger.warn(\"Failed to acquire lock on security group: \" + ngId);\n                        txn.rollback();\n                        return null;\n                    }\n                }\n                IngressRuleVO ingressRule = _ingressRuleDao.findByProtoPortsAndAllowedGroupId(securityGroup.getId(), protocol, startPortOrType, endPortOrCode, ngVO.getId());\n                if (ingressRule != null) {\n                    continue; // rule already exists.\n                }\n                ingressRule = new IngressRuleVO(securityGroup.getId(), startPortOrType, endPortOrCode, protocol, ngVO.getId());\n                ingressRule = _ingressRuleDao.persist(ingressRule);\n                newRules.add(ingressRule);\n            }\n            if (cidrList != null) {\n                for (String cidr : cidrList) {\n                    IngressRuleVO ingressRule = _ingressRuleDao.findByProtoPortsAndCidr(securityGroup.getId(), protocol, startPortOrType, endPortOrCode, cidr);\n                    if (ingressRule != null) {\n                        continue;\n                    }\n                    ingressRule = new IngressRuleVO(securityGroup.getId(), startPortOrType, endPortOrCode, protocol, cidr);\n                    ingressRule = _ingressRuleDao.persist(ingressRule);\n                    newRules.add(ingressRule);\n                }\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Added \" + newRules.size() + \" rules to security group \" + securityGroup.getName());\n            }\n            txn.commit();\n            final Set<Long> affectedVms = new HashSet<Long>();\n            affectedVms.addAll(_securityGroupVMMapDao.listVmIdsBySecurityGroup(securityGroup.getId()));\n            scheduleRulesetUpdateToHosts(affectedVms, true, null);\n            return newRules;\n        } catch (Exception e) {\n            s_logger.warn(\"Exception caught when adding ingress rules \", e);\n            throw new CloudRuntimeException(\"Exception caught when adding ingress rules\", e);\n        } finally {\n            if (securityGroup != null) {\n                _securityGroupDao.releaseFromLockTable(securityGroup.getId());\n            }\n        }\n    }","id":73473,"modified_method":"@Override\n    @DB\n    @SuppressWarnings(\"rawtypes\")\n    public List<IngressRuleVO> authorizeSecurityGroupIngress(AuthorizeSecurityGroupIngressCmd cmd) {\n        Long securityGroupId = cmd.getSecurityGroupId();\n        String protocol = cmd.getProtocol();\n        Integer startPort = cmd.getStartPort();\n        Integer endPort = cmd.getEndPort();\n        Integer icmpType = cmd.getIcmpType();\n        Integer icmpCode = cmd.getIcmpCode();\n        List<String> cidrList = cmd.getCidrList();\n        Map groupList = cmd.getUserSecurityGroupList();\n        Integer startPortOrType = null;\n        Integer endPortOrCode = null;\n\n        // Validate parameters\n        SecurityGroup securityGroup = _securityGroupDao.findById(securityGroupId);\n        if (securityGroup == null) {\n            throw new InvalidParameterValueException(\"Unable to find security group by id \" + securityGroupId);\n        }\n\n        if (cidrList == null && groupList == null) {\n            throw new InvalidParameterValueException(\"At least one cidr or at least one security group needs to be specified\");\n        }\n\n        Account caller = UserContext.current().getCaller();\n        Account owner = _accountMgr.getAccount(securityGroup.getAccountId());\n\n        if (owner == null) {\n            throw new InvalidParameterValueException(\"Unable to find security group owner by id=\" + securityGroup.getAccountId());\n        }\n\n        // Verify permissions\n        _accountMgr.checkAccess(caller, null, securityGroup);\n        Long domainId = owner.getDomainId();\n\n        if (protocol == null) {\n            protocol = NetUtils.ALL_PROTO;\n        }\n\n        if (!NetUtils.isValidSecurityGroupProto(protocol)) {\n            throw new InvalidParameterValueException(\"Invalid protocol \" + protocol);\n        }\n        if (\"icmp\".equalsIgnoreCase(protocol)) {\n            if ((icmpType == null) || (icmpCode == null)) {\n                throw new InvalidParameterValueException(\"Invalid ICMP type/code specified, icmpType = \" + icmpType + \", icmpCode = \" + icmpCode);\n            }\n            if (icmpType == -1 && icmpCode != -1) {\n                throw new InvalidParameterValueException(\"Invalid icmp type range\");\n            }\n            if (icmpCode > 255) {\n                throw new InvalidParameterValueException(\"Invalid icmp code \");\n            }\n            startPortOrType = icmpType;\n            endPortOrCode = icmpCode;\n        } else if (protocol.equals(NetUtils.ALL_PROTO)) {\n            if ((startPort != null) || (endPort != null)) {\n                throw new InvalidParameterValueException(\"Cannot specify startPort or endPort without specifying protocol\");\n            }\n            startPortOrType = 0;\n            endPortOrCode = 0;\n        } else {\n            if ((startPort == null) || (endPort == null)) {\n                throw new InvalidParameterValueException(\"Invalid port range specified, startPort = \" + startPort + \", endPort = \" + endPort);\n            }\n            if (startPort == 0 && endPort == 0) {\n                endPort = 65535;\n            }\n            if (startPort > endPort) {\n                throw new InvalidParameterValueException(\"Invalid port range \" + startPort + \":\" + endPort);\n            }\n            if (startPort > 65535 || endPort > 65535 || startPort < -1 || endPort < -1) {\n                throw new InvalidParameterValueException(\"Invalid port numbers \" + startPort + \":\" + endPort);\n            }\n\n            if (startPort < 0 || endPort < 0) {\n                throw new InvalidParameterValueException(\"Invalid port range \" + startPort + \":\" + endPort);\n            }\n            startPortOrType = startPort;\n            endPortOrCode = endPort;\n        }\n\n        protocol = protocol.toLowerCase();\n\n        List<SecurityGroupVO> authorizedGroups = new ArrayList<SecurityGroupVO>();\n        if (groupList != null) {\n            Collection userGroupCollection = groupList.values();\n            Iterator iter = userGroupCollection.iterator();\n            while (iter.hasNext()) {\n                HashMap userGroup = (HashMap) iter.next();\n                String group = (String) userGroup.get(\"group\");\n                String authorizedAccountName = (String) userGroup.get(\"account\");\n\n                if ((group == null) || (authorizedAccountName == null)) {\n                    throw new InvalidParameterValueException(\n                            \"Invalid user group specified, fields 'group' and 'account' cannot be null, please specify groups in the form:  userGroupList[0].group=XXX&userGroupList[0].account=YYY\");\n                }\n\n                Account authorizedAccount = _accountDao.findActiveAccount(authorizedAccountName, domainId);\n                if (authorizedAccount == null) {\n                    throw new InvalidParameterValueException(\"Nonexistent account: \" + authorizedAccountName + \" when trying to authorize ingress for \" + securityGroupId + \":\" + protocol + \":\"\n                            + startPortOrType + \":\" + endPortOrCode);\n                }\n\n                SecurityGroupVO groupVO = _securityGroupDao.findByAccountAndName(authorizedAccount.getId(), group);\n                if (groupVO == null) {\n                    throw new InvalidParameterValueException(\"Nonexistent group \" + group + \" for account \" + authorizedAccountName + \"/\" + domainId + \" is given, unable to authorize ingress.\");\n                }\n\n                // Check permissions\n                _accountMgr.checkAccess(caller, null, groupVO);\n\n                authorizedGroups.add(groupVO);\n            }\n        }\n\n        final Transaction txn = Transaction.currentTxn();\n        final Set<SecurityGroupVO> authorizedGroups2 = new TreeSet<SecurityGroupVO>(new SecurityGroupVOComparator());\n\n        authorizedGroups2.addAll(authorizedGroups); // Ensure we don't re-lock the same row\n        txn.start();\n\n        // Prevents other threads/management servers from creating duplicate ingress rules\n        securityGroup = _securityGroupDao.acquireInLockTable(securityGroupId);\n        if (securityGroup == null) {\n            s_logger.warn(\"Could not acquire lock on network security group: id= \" + securityGroupId);\n            return null;\n        }\n        List<IngressRuleVO> newRules = new ArrayList<IngressRuleVO>();\n        try {\n            for (final SecurityGroupVO ngVO : authorizedGroups2) {\n                final Long ngId = ngVO.getId();\n                // Don't delete the referenced group from under us\n                if (ngVO.getId() != securityGroup.getId()) {\n                    final SecurityGroupVO tmpGrp = _securityGroupDao.lockRow(ngId, false);\n                    if (tmpGrp == null) {\n                        s_logger.warn(\"Failed to acquire lock on security group: \" + ngId);\n                        txn.rollback();\n                        return null;\n                    }\n                }\n                IngressRuleVO ingressRule = _ingressRuleDao.findByProtoPortsAndAllowedGroupId(securityGroup.getId(), protocol, startPortOrType, endPortOrCode, ngVO.getId());\n                if (ingressRule != null) {\n                    continue; // rule already exists.\n                }\n                ingressRule = new IngressRuleVO(securityGroup.getId(), startPortOrType, endPortOrCode, protocol, ngVO.getId());\n                ingressRule = _ingressRuleDao.persist(ingressRule);\n                newRules.add(ingressRule);\n            }\n            if (cidrList != null) {\n                for (String cidr : cidrList) {\n                    IngressRuleVO ingressRule = _ingressRuleDao.findByProtoPortsAndCidr(securityGroup.getId(), protocol, startPortOrType, endPortOrCode, cidr);\n                    if (ingressRule != null) {\n                        continue;\n                    }\n                    ingressRule = new IngressRuleVO(securityGroup.getId(), startPortOrType, endPortOrCode, protocol, cidr);\n                    ingressRule = _ingressRuleDao.persist(ingressRule);\n                    newRules.add(ingressRule);\n                }\n            }\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Added \" + newRules.size() + \" rules to security group \" + securityGroup.getName());\n            }\n            txn.commit();\n            final ArrayList<Long> affectedVms = new ArrayList<Long>();\n            affectedVms.addAll(_securityGroupVMMapDao.listVmIdsBySecurityGroup(securityGroup.getId()));\n            scheduleRulesetUpdateToHosts(affectedVms, true, null);\n            return newRules;\n        } catch (Exception e) {\n            s_logger.warn(\"Exception caught when adding ingress rules \", e);\n            throw new CloudRuntimeException(\"Exception caught when adding ingress rules\", e);\n        } finally {\n            if (securityGroup != null) {\n                _securityGroupDao.releaseFromLockTable(securityGroup.getId());\n            }\n        }\n    }","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"private void cleanupUnfinishedWork() {\n        Date before = new Date(System.currentTimeMillis() - 2*_timeBetweenCleanups*1000l);\n        List<SecurityGroupWorkVO> unfinished = _workDao.findUnfinishedWork(before);\n        if (unfinished.size() > 0) {\n            s_logger.info(\"Network Group Work cleanup found \" + unfinished.size() + \" unfinished work items older than \" + before.toString());\n            Set<Long> affectedVms = new HashSet<Long>();\n            for (SecurityGroupWorkVO work : unfinished) {\n                affectedVms.add(work.getInstanceId());\n                work.setStep(Step.Error);\n                _workDao.update(work.getId(), work);\n            }\n            scheduleRulesetUpdateToHosts(affectedVms, false, null);\n        } else {\n            s_logger.debug(\"Network Group Work cleanup found no unfinished work items older than \" + before.toString());\n        }\n    }","id":73474,"modified_method":"private void cleanupUnfinishedWork() {\n        Date before = new Date(System.currentTimeMillis() - 2*_timeBetweenCleanups*1000l);\n        List<SecurityGroupWorkVO> unfinished = _workDao.findUnfinishedWork(before);\n        if (unfinished.size() > 0) {\n            s_logger.info(\"Network Group Work cleanup found \" + unfinished.size() + \" unfinished work items older than \" + before.toString());\n            ArrayList<Long> affectedVms = new ArrayList<Long>();\n            for (SecurityGroupWorkVO work : unfinished) {\n                affectedVms.add(work.getInstanceId());\n                work.setStep(Step.Error);\n                _workDao.update(work.getId(), work);\n            }\n            scheduleRulesetUpdateToHosts(affectedVms, false, null);\n        } else {\n            s_logger.debug(\"Network Group Work cleanup found no unfinished work items older than \" + before.toString());\n        }\n    }","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Map<PortAndProto, Set<String>> generateEgressRulesForVM(Long userVmId) {\n\n        Map<PortAndProto, Set<String>> allowed = new TreeMap<PortAndProto, Set<String>>();\n\n        List<SecurityGroupVMMapVO> groupsForVm = _securityGroupVMMapDao.listByInstanceId(userVmId);\n        for (SecurityGroupVMMapVO mapVO : groupsForVm) {\n            List<EgressRuleVO> rules = _egressRuleDao.listBySecurityGroupId(mapVO.getSecurityGroupId());\n            for (EgressRuleVO rule : rules) {\n                PortAndProto portAndProto = new PortAndProto(rule.getProtocol(), rule.getStartPort(), rule.getEndPort());\n                Set<String> cidrs = allowed.get(portAndProto);\n                if (cidrs == null) {\n                    cidrs = new TreeSet<String>(new CidrComparator());\n                }\n                if (rule.getAllowedNetworkId() != null) {\n                    List<SecurityGroupVMMapVO> allowedInstances = _securityGroupVMMapDao.listBySecurityGroup(rule.getAllowedNetworkId(), State.Running);\n                    for (SecurityGroupVMMapVO ngmapVO : allowedInstances) {\n                        Nic defaultNic = _networkMgr.getDefaultNic(ngmapVO.getInstanceId());\n                        if (defaultNic != null) {\n                            String cidr = defaultNic.getIp4Address();\n                            cidr = cidr + \"/32\";\n                            cidrs.add(cidr);\n                        }\n                    }\n                } else if (rule.getAllowedDestinationIpCidr() != null) {\n                    cidrs.add(rule.getAllowedDestinationIpCidr());\n                }\n                if (cidrs.size() > 0) {\n                    allowed.put(portAndProto, cidrs);\n                }\n            }\n        }\n\n        return allowed;\n    }","id":73475,"modified_method":"protected Map<PortAndProto, Set<String>> generateRulesForVM(Long userVmId) {\n\n        Map<PortAndProto, Set<String>> allowed = new TreeMap<PortAndProto, Set<String>>();\n\n        List<SecurityGroupVMMapVO> groupsForVm = _securityGroupVMMapDao.listByInstanceId(userVmId);\n        for (SecurityGroupVMMapVO mapVO : groupsForVm) {\n            List<IngressRuleVO> rules = _ingressRuleDao.listBySecurityGroupId(mapVO.getSecurityGroupId());\n            for (IngressRuleVO rule : rules) {\n                PortAndProto portAndProto = new PortAndProto(rule.getProtocol(), rule.getStartPort(), rule.getEndPort());\n                Set<String> cidrs = allowed.get(portAndProto);\n                if (cidrs == null) {\n                    cidrs = new TreeSet<String>(new CidrComparator());\n                }\n                if (rule.getAllowedNetworkId() != null) {\n                    List<SecurityGroupVMMapVO> allowedInstances = _securityGroupVMMapDao.listBySecurityGroup(rule.getAllowedNetworkId(), State.Running);\n                    for (SecurityGroupVMMapVO ngmapVO : allowedInstances) {\n                        Nic defaultNic = _networkMgr.getDefaultNic(ngmapVO.getInstanceId());\n                        if (defaultNic != null) {\n                            String cidr = defaultNic.getIp4Address();\n                            cidr = cidr + \"/32\";\n                            cidrs.add(cidr);\n                        }\n                    }\n                } else if (rule.getAllowedSourceIpCidr() != null) {\n                    cidrs.add(rule.getAllowedSourceIpCidr());\n                }\n                if (cidrs.size() > 0) {\n                    allowed.put(portAndProto, cidrs);\n                }\n            }\n        }\n\n        return allowed;\n    }","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"@DB\n    public void scheduleRulesetUpdateToHosts(Set<Long> affectedVms, boolean updateSeqno, Long delayMs) {\n        if (delayMs == null) {\n            delayMs = new Long(100l);\n        }\n\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"Security Group Mgr: scheduling ruleset updates for \" + affectedVms.size() + \" vms\");\n        }\n        if (affectedVms.size() == 0) {\n            return;\n        }\n        boolean locked = _workLock.lock(_globalWorkLockTimeout); \n        if (locked) {\n            if (s_logger.isTraceEnabled()) {\n                s_logger.trace(\"Security Group Mgr: acquired global work lock\");\n            }\n            try {\n                for (Long vmId : affectedVms) {\n                    if (s_logger.isTraceEnabled()) {\n                        s_logger.trace(\"Security Group Mgr: scheduling ruleset update for \" + vmId);\n                    }\n                    VmRulesetLogVO log = null;\n                    SecurityGroupWorkVO work = null;\n                    //UserVm vm = null;\n                    Transaction txn = null;\n                    try {\n                        txn = Transaction.currentTxn();\n                        txn.start();\n\n                        //vm = _userVMDao.acquireInLockTable(vmId);\n                        //if (vm == null) {\n                        //s_logger.warn(\"Failed to acquire lock on vm id \" + vmId);\n                        //continue;\n                        //}\n                        log = _rulesetLogDao.findByVmId(vmId);\n                        if (log == null) {\n                            log = new VmRulesetLogVO(vmId);\n                            log = _rulesetLogDao.persist(log);\n                        }\n\n                        if (log != null && updateSeqno) {\n                            log.incrLogsequence();\n                            _rulesetLogDao.update(log.getId(), log);\n                        }\n                        work = _workDao.findByVmIdStep(vmId, Step.Scheduled);\n                        if (work == null) {\n                            work = new SecurityGroupWorkVO(vmId, null, null, SecurityGroupWorkVO.Step.Scheduled, null);\n                            work = _workDao.persist(work);\n                            if (s_logger.isTraceEnabled()) {\n                                s_logger.trace(\"Security Group Mgr: created new work item for \" + vmId);\n                            }\n                        }\n\n                        work.setLogsequenceNumber(log.getLogsequence());\n                        _workDao.update(work.getId(), work);\n\n                    } finally {\n                        //                if (vm != null) {\n                        //                    _userVMDao.releaseFromLockTable(vmId);\n                        //                }\n                        if (txn != null)\n                            txn.commit();\n                    }\n\n                    _executorPool.schedule(new WorkerThread(), delayMs, TimeUnit.MILLISECONDS);\n                }\n            } finally {\n                _workLock.unlock();\n                if (s_logger.isTraceEnabled()) {\n                    s_logger.trace(\"Security Group Mgr: released global work lock\");\n                }\n            }\n        } else {\n            s_logger.warn(\"Security Group Mgr: failed to acquire global work lock\");\n        }\n    }","id":73476,"modified_method":"@DB\n    public void scheduleRulesetUpdateToHosts(List<Long> affectedVms, boolean updateSeqno, Long delayMs) {\n        if (affectedVms.size() == 0) {\n            return;\n        }\n\n        if (delayMs == null) {\n            delayMs = new Long(100l);\n        }\n\n        Collections.sort(affectedVms);\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"Security Group Mgr: scheduling ruleset updates for \" + affectedVms.size() + \" vms\");\n        }\n        boolean locked = _workLock.lock(_globalWorkLockTimeout); \n        if (!locked) {\n            s_logger.warn(\"Security Group Mgr: failed to acquire global work lock\");\n            return;\n        }\n\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"Security Group Mgr: acquired global work lock\");\n        }\n        Transaction txn = Transaction.currentTxn();\n        try {\n            txn.start();\n            for (Long vmId : affectedVms) {\n                if (s_logger.isTraceEnabled()) {\n                    s_logger.trace(\"Security Group Mgr: scheduling ruleset update for \" + vmId);\n                }\n                VmRulesetLogVO log = null;\n                SecurityGroupWorkVO work = null;\n\n                log = _rulesetLogDao.findByVmId(vmId);\n                if (log == null) {\n                    log = new VmRulesetLogVO(vmId);\n                    log = _rulesetLogDao.persist(log);\n                }\n\n                if (log != null && updateSeqno) {\n                    log.incrLogsequence();\n                    _rulesetLogDao.update(log.getId(), log);\n                }\n                work = _workDao.findByVmIdStep(vmId, Step.Scheduled);\n                if (work == null) {\n                    work = new SecurityGroupWorkVO(vmId, null, null, SecurityGroupWork.Step.Scheduled, null);\n                    work = _workDao.persist(work);\n                    if (s_logger.isTraceEnabled()) {\n                        s_logger.trace(\"Security Group Mgr: created new work item for \" + vmId + \"; id = \" + work.getId());\n                    }\n                }\n\n                work.setLogsequenceNumber(log.getLogsequence());\n                _workDao.update(work.getId(), work);\n            }\n            txn.commit();\n            for (Long vmId : affectedVms) {\n                _executorPool.schedule(new WorkerThread(), delayMs, TimeUnit.MILLISECONDS);\n            }\n        } finally {\n            _workLock.unlock();\n            if (s_logger.isTraceEnabled()) {\n                s_logger.trace(\"Security Group Mgr: released global work lock\");\n            }\n        }\n    }","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Set<Long> getAffectedVmsForVmStop(VMInstanceVO vm) {\n        Set<Long> affectedVms = new HashSet<Long>();\n        List<SecurityGroupVMMapVO> groupsForVm = _securityGroupVMMapDao.listByInstanceId(vm.getId());\n        // For each group, find the ingress rules that allow the group\n        for (SecurityGroupVMMapVO mapVO : groupsForVm) {// FIXME: use custom sql in the dao\n            List<IngressRuleVO> allowingRules = _ingressRuleDao.listByAllowedSecurityGroupId(mapVO.getSecurityGroupId());\n            // For each ingress rule that allows a group that the vm belongs to, find the group it belongs to\n            affectedVms.addAll(getAffectedVmsForIngressRules(allowingRules));\n        }\n        return affectedVms;\n    }","id":73477,"modified_method":"protected List<Long> getAffectedVmsForVmStop(VMInstanceVO vm) {\n        List<Long> affectedVms = new ArrayList<Long>();\n        List<SecurityGroupVMMapVO> groupsForVm = _securityGroupVMMapDao.listByInstanceId(vm.getId());\n        // For each group, find the ingress rules that allow the group\n        for (SecurityGroupVMMapVO mapVO : groupsForVm) {// FIXME: use custom sql in the dao\n            List<IngressRuleVO> allowingRules = _ingressRuleDao.listByAllowedSecurityGroupId(mapVO.getSecurityGroupId());\n            // For each ingress rule that allows a group that the vm belongs to, find the group it belongs to\n            affectedVms.addAll(getAffectedVmsForIngressRules(allowingRules));\n        }\n        return affectedVms;\n    }","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"protected void handleVmMigrated(VMInstanceVO vm) {\n        if (!isVmSecurityGroupEnabled(vm.getId()))\n            return;\n        if (vm.getType() != VirtualMachine.Type.User) {\n            Commands cmds = null;\n            NetworkRulesSystemVmCommand nrc = new NetworkRulesSystemVmCommand(vm.getInstanceName(), vm.getType());\n            cmds = new Commands(nrc);\n            try {\n                _agentMgr.send(vm.getHostId(), cmds);\n            } catch (AgentUnavailableException e) {\n                s_logger.debug(e.toString());\n            } catch (OperationTimedoutException e) {\n                s_logger.debug(e.toString());\n            }\n\n        } else {\n            Set<Long> affectedVms = new HashSet<Long>();\n            affectedVms.add(vm.getId());\n            scheduleRulesetUpdateToHosts(affectedVms, true, null);\n        }\n    }","id":73478,"modified_method":"protected void handleVmMigrated(VMInstanceVO vm) {\n        if (!isVmSecurityGroupEnabled(vm.getId()))\n            return;\n        if (vm.getType() != VirtualMachine.Type.User) {\n            Commands cmds = null;\n            NetworkRulesSystemVmCommand nrc = new NetworkRulesSystemVmCommand(vm.getInstanceName(), vm.getType());\n            cmds = new Commands(nrc);\n            try {\n                _agentMgr.send(vm.getHostId(), cmds);\n            } catch (AgentUnavailableException e) {\n                s_logger.debug(e.toString());\n            } catch (OperationTimedoutException e) {\n                s_logger.debug(e.toString());\n            }\n\n        } else {\n            List<Long> affectedVms = new ArrayList<Long>();\n            affectedVms.add(vm.getId());\n            scheduleRulesetUpdateToHosts(affectedVms, true, null);\n        }\n    }","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"protected void handleVmStopped(VMInstanceVO vm) {\n        if (vm.getType() != VirtualMachine.Type.User || !isVmSecurityGroupEnabled(vm.getId()))\n            return;\n        Set<Long> affectedVms = getAffectedVmsForVmStop(vm);\n        scheduleRulesetUpdateToHosts(affectedVms, true, null);\n    }","id":73479,"modified_method":"protected void handleVmStopped(VMInstanceVO vm) {\n        if (vm.getType() != VirtualMachine.Type.User || !isVmSecurityGroupEnabled(vm.getId()))\n            return;\n        List<Long> affectedVms = getAffectedVmsForVmStop(vm);\n        scheduleRulesetUpdateToHosts(affectedVms, true, null);\n    }","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"private String generateRulesetSignature(Map<PortAndProto, Set<String>> allowed) {\n        String ruleset = allowed.toString();\n        return DigestUtils.md5Hex(ruleset);\n    }","id":73480,"modified_method":"protected String generateRulesetSignature(Map<PortAndProto, Set<String>> allowed) {\n        String ruleset = allowed.toString();\n        return DigestUtils.md5Hex(ruleset);\n    }","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    @DB\n    public boolean revokeSecurityGroupIngress(RevokeSecurityGroupIngressCmd cmd) {\n        // input validation\n        Account caller = UserContext.current().getCaller();\n        Long id = cmd.getId();\n\n        IngressRuleVO rule = _ingressRuleDao.findById(id);\n        if (rule == null) {\n            s_logger.debug(\"Unable to find ingress rule with id \" + id);\n            throw new InvalidParameterValueException(\"Unable to find ingress rule with id \" + id);\n        }\n\n        // Check permissions\n        SecurityGroup securityGroup = _securityGroupDao.findById(rule.getSecurityGroupId());\n        _accountMgr.checkAccess(caller, null, securityGroup);\n\n        SecurityGroupVO groupHandle = null;\n        final Transaction txn = Transaction.currentTxn();\n\n        try {\n            txn.start();\n            // acquire lock on parent group (preserving this logic)\n            groupHandle = _securityGroupDao.acquireInLockTable(rule.getSecurityGroupId());\n            if (groupHandle == null) {\n                s_logger.warn(\"Could not acquire lock on security group id: \" + rule.getSecurityGroupId());\n                return false;\n            }\n\n            _ingressRuleDao.remove(id);\n            s_logger.debug(\"revokeSecurityGroupIngress succeeded for ingress rule id: \" + id);\n\n            final Set<Long> affectedVms = new HashSet<Long>();\n            affectedVms.addAll(_securityGroupVMMapDao.listVmIdsBySecurityGroup(groupHandle.getId()));\n            scheduleRulesetUpdateToHosts(affectedVms, true, null);\n\n            return true;\n        } catch (Exception e) {\n            s_logger.warn(\"Exception caught when deleting ingress rules \", e);\n            throw new CloudRuntimeException(\"Exception caught when deleting ingress rules\", e);\n        } finally {\n            if (groupHandle != null) {\n                _securityGroupDao.releaseFromLockTable(groupHandle.getId());\n            }\n            txn.commit();\n        }\n\n    }","id":73481,"modified_method":"@Override\n    @DB\n    public boolean revokeSecurityGroupIngress(RevokeSecurityGroupIngressCmd cmd) {\n        // input validation\n        Account caller = UserContext.current().getCaller();\n        Long id = cmd.getId();\n\n        IngressRuleVO rule = _ingressRuleDao.findById(id);\n        if (rule == null) {\n            s_logger.debug(\"Unable to find ingress rule with id \" + id);\n            throw new InvalidParameterValueException(\"Unable to find ingress rule with id \" + id);\n        }\n\n        // Check permissions\n        SecurityGroup securityGroup = _securityGroupDao.findById(rule.getSecurityGroupId());\n        _accountMgr.checkAccess(caller, null, securityGroup);\n\n        SecurityGroupVO groupHandle = null;\n        final Transaction txn = Transaction.currentTxn();\n\n        try {\n            txn.start();\n            // acquire lock on parent group (preserving this logic)\n            groupHandle = _securityGroupDao.acquireInLockTable(rule.getSecurityGroupId());\n            if (groupHandle == null) {\n                s_logger.warn(\"Could not acquire lock on security group id: \" + rule.getSecurityGroupId());\n                return false;\n            }\n\n            _ingressRuleDao.remove(id);\n            s_logger.debug(\"revokeSecurityGroupIngress succeeded for ingress rule id: \" + id);\n\n            final ArrayList<Long> affectedVms = new ArrayList<Long>();\n            affectedVms.addAll(_securityGroupVMMapDao.listVmIdsBySecurityGroup(groupHandle.getId()));\n            scheduleRulesetUpdateToHosts(affectedVms, true, null);\n\n            return true;\n        } catch (Exception e) {\n            s_logger.warn(\"Exception caught when deleting ingress rules \", e);\n            throw new CloudRuntimeException(\"Exception caught when deleting ingress rules\", e);\n        } finally {\n            if (groupHandle != null) {\n                _securityGroupDao.releaseFromLockTable(groupHandle.getId());\n            }\n            txn.commit();\n        }\n\n    }","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"@DB\n    public void work() {\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"Checking the database\");\n        }\n        final SecurityGroupWorkVO work = _workDao.take(_serverId);\n        if (work == null) {\n            if (s_logger.isTraceEnabled()) {\n                s_logger.trace(\"Security Group work: no work found\");\n            }\n            return;\n        }\n        Long userVmId = work.getInstanceId();\n        if (work.getStep() == Step.Done) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Security Group work: found a job in done state, rescheduling for vm: \" + userVmId);\n            }\n            Set<Long> affectedVms = new HashSet<Long>();\n            affectedVms.add(userVmId);\n            scheduleRulesetUpdateToHosts(affectedVms, true, _timeBetweenCleanups*1000l);\n        }\n        UserVm vm = null;\n        Long seqnum = null;\n        s_logger.debug(\"Working on \" + work);\n        final Transaction txn = Transaction.currentTxn();\n        txn.start();\n        boolean locked = false;\n        try {\n            vm = _userVMDao.acquireInLockTable(work.getInstanceId());\n            if (vm == null) {\n                vm = _userVMDao.findById(work.getInstanceId());\n                if (vm == null) {\n                    s_logger.info(\"VM \" + work.getInstanceId() + \" is removed\");\n                    locked = true;\n                    return;\n                }\n                s_logger.warn(\"Unable to acquire lock on vm id=\" + userVmId);\n                return;\n            }\n            locked = true;\n            Long agentId = null;\n            VmRulesetLogVO log = _rulesetLogDao.findByVmId(userVmId);\n            if (log == null) {\n                s_logger.warn(\"Cannot find log record for vm id=\" + userVmId);\n                return;\n            }\n            seqnum = log.getLogsequence();\n\n            if (vm != null && vm.getState() == State.Running) {\n                Map<PortAndProto, Set<String>> ingressRules = generateIngressRulesForVM(userVmId);\n                Map<PortAndProto, Set<String>> egressRules = generateEgressRulesForVM(userVmId);\n                agentId = vm.getHostId();\n                if (agentId != null) {\n                    _rulesetLogDao.findByVmId(work.getInstanceId());\n                    SecurityIngressRulesCmd ingressCmd = generateIngressRulesetCmd(vm.getInstanceName(), vm.getPrivateIpAddress(), vm.getPrivateMacAddress(), vm.getId(), generateRulesetSignature(ingressRules), seqnum,\n                    \t\tingressRules);\n                    Commands ingressCmds = new Commands(ingressCmd);\n                    try {\n                        _agentMgr.send(agentId, ingressCmds, _answerListener);\n                    } catch (AgentUnavailableException e) {\n                        s_logger.debug(\"Unable to send updates for vm: \" + userVmId + \"(agentid=\" + agentId + \")\");\n                        _workDao.updateStep(work.getInstanceId(), seqnum, Step.Done);\n                    }\n                    \n                    SecurityEgressRulesCmd cmd = generateEgressRulesetCmd(vm.getInstanceName(), vm.getPrivateIpAddress(), vm.getPrivateMacAddress(), vm.getId(), generateRulesetSignature(egressRules), seqnum,\n                    \t\tegressRules);\n                    Commands cmds = new Commands(cmd);\n                    try {\n                        _agentMgr.send(agentId, cmds, _answerListener);\n                    } catch (AgentUnavailableException e) {\n                        s_logger.debug(\"Unable to send updates for vm: \" + userVmId + \"(agentid=\" + agentId + \")\");\n                        _workDao.updateStep(work.getInstanceId(), seqnum, Step.Done);\n                    }\n                }\n            }\n        } finally {\n            if (locked) {\n                _userVMDao.releaseFromLockTable(userVmId);\n                _workDao.updateStep(work.getId(), Step.Done);\n            }\n            txn.commit();\n        }\n    }","id":73482,"modified_method":"@DB\n    public void work() {\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"Checking the database\");\n        }\n        final SecurityGroupWorkVO work = _workDao.take(_serverId);\n        if (work == null) {\n            if (s_logger.isTraceEnabled()) {\n                s_logger.trace(\"Security Group work: no work found\");\n            }\n            return;\n        }\n        Long userVmId = work.getInstanceId();\n        if (work.getStep() == Step.Done) {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Security Group work: found a job in done state, rescheduling for vm: \" + userVmId);\n            }\n            ArrayList<Long> affectedVms = new ArrayList<Long>();\n            affectedVms.add(userVmId);\n            scheduleRulesetUpdateToHosts(affectedVms, true, _timeBetweenCleanups*1000l);\n            return;\n        }\n        UserVm vm = null;\n        Long seqnum = null;\n        s_logger.debug(\"Working on \" + work);\n        final Transaction txn = Transaction.currentTxn();\n        txn.start();\n        boolean locked = false;\n        try {\n            vm = _userVMDao.acquireInLockTable(work.getInstanceId());\n            if (vm == null) {\n                vm = _userVMDao.findById(work.getInstanceId());\n                if (vm == null) {\n                    s_logger.info(\"VM \" + work.getInstanceId() + \" is removed\");\n                    locked = true;\n                    return;\n                }\n                s_logger.warn(\"Unable to acquire lock on vm id=\" + userVmId);\n                return;\n            }\n            locked = true;\n            Long agentId = null;\n            VmRulesetLogVO log = _rulesetLogDao.findByVmId(userVmId);\n            if (log == null) {\n                s_logger.warn(\"Cannot find log record for vm id=\" + userVmId);\n                return;\n            }\n            seqnum = log.getLogsequence();\n\n            if (vm != null && vm.getState() == State.Running) {\n                Map<PortAndProto, Set<String>> rules = generateRulesForVM(userVmId);\n                agentId = vm.getHostId();\n                if (agentId != null) {\n                    SecurityIngressRulesCmd cmd = generateRulesetCmd(vm.getInstanceName(), vm.getPrivateIpAddress(), vm.getPrivateMacAddress(), vm.getId(), generateRulesetSignature(rules), seqnum,\n                            rules);\n                    Commands cmds = new Commands(cmd);\n                    try {\n                        _agentMgr.send(agentId, cmds, _answerListener);\n                    } catch (AgentUnavailableException e) {\n                        s_logger.debug(\"Unable to send updates for vm: \" + userVmId + \"(agentid=\" + agentId + \")\");\n                        _workDao.updateStep(work.getInstanceId(), seqnum, Step.Done);\n                    }\n                }\n            }\n        } finally {\n            if (locked) {\n                _userVMDao.releaseFromLockTable(userVmId);\n                _workDao.updateStep(work.getId(), Step.Done);\n            }\n            txn.commit();\n        }\n    }","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"protected SecurityIngressRulesCmd generateIngressRulesetCmd(String vmName, String guestIp, String guestMac, Long vmId, String signature, long seqnum, Map<PortAndProto, Set<String>> rules) {\n        List<IpPortAndProto> result = new ArrayList<IpPortAndProto>();\n        for (PortAndProto pAp : rules.keySet()) {\n            Set<String> cidrs = rules.get(pAp);\n            if (cidrs.size() > 0) {\n                IpPortAndProto ipPortAndProto = new SecurityIngressRulesCmd.IpPortAndProto(pAp.getProto(), pAp.getStartPort(), pAp.getEndPort(), cidrs.toArray(new String[cidrs.size()]));\n                result.add(ipPortAndProto);\n            }\n        }\n        return new SecurityIngressRulesCmd(guestIp, guestMac, vmName, vmId, signature, seqnum, result.toArray(new IpPortAndProto[result.size()]));\n    }","id":73483,"modified_method":"protected SecurityIngressRulesCmd generateRulesetCmd(String vmName, String guestIp, String guestMac, Long vmId, String signature, long seqnum, Map<PortAndProto, Set<String>> rules) {\n        List<IpPortAndProto> result = new ArrayList<IpPortAndProto>();\n        for (PortAndProto pAp : rules.keySet()) {\n            Set<String> cidrs = rules.get(pAp);\n            if (cidrs.size() > 0) {\n                IpPortAndProto ipPortAndProto = new SecurityIngressRulesCmd.IpPortAndProto(pAp.getProto(), pAp.getStartPort(), pAp.getEndPort(), cidrs.toArray(new String[cidrs.size()]));\n                result.add(ipPortAndProto);\n            }\n        }\n        return new SecurityIngressRulesCmd(guestIp, guestMac, vmName, vmId, signature, seqnum, result.toArray(new IpPortAndProto[result.size()]));\n    }","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Set<Long> getAffectedVmsForVmStart(VMInstanceVO vm) {\n        Set<Long> affectedVms = new HashSet<Long>();\n        affectedVms.add(vm.getId());\n        List<SecurityGroupVMMapVO> groupsForVm = _securityGroupVMMapDao.listByInstanceId(vm.getId());\n        // For each group, find the ingress rules that allow the group\n        for (SecurityGroupVMMapVO mapVO : groupsForVm) {// FIXME: use custom sql in the dao\n            List<IngressRuleVO> allowingRules = _ingressRuleDao.listByAllowedSecurityGroupId(mapVO.getSecurityGroupId());\n            // For each ingress rule that allows a group that the vm belongs to, find the group it belongs to\n            affectedVms.addAll(getAffectedVmsForIngressRules(allowingRules));\n        }\n        return affectedVms;\n    }","id":73484,"modified_method":"protected List<Long> getAffectedVmsForVmStart(VMInstanceVO vm) {\n        List<Long> affectedVms = new ArrayList<Long>();\n        affectedVms.add(vm.getId());\n        List<SecurityGroupVMMapVO> groupsForVm = _securityGroupVMMapDao.listByInstanceId(vm.getId());\n        // For each group, find the ingress rules that allow the group\n        for (SecurityGroupVMMapVO mapVO : groupsForVm) {// FIXME: use custom sql in the dao\n            List<IngressRuleVO> allowingRules = _ingressRuleDao.listByAllowedSecurityGroupId(mapVO.getSecurityGroupId());\n            // For each ingress rule that allows a group that the vm belongs to, find the group it belongs to\n            affectedVms.addAll(getAffectedVmsForIngressRules(allowingRules));\n        }\n        return affectedVms;\n    }","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Set<Long> getAffectedVmsForIngressRules(List<IngressRuleVO> allowingRules) {\n        Set<Long> distinctGroups = new HashSet<Long>();\n        Set<Long> affectedVms = new HashSet<Long>();\n\n        for (IngressRuleVO allowingRule : allowingRules) {\n            distinctGroups.add(allowingRule.getSecurityGroupId());\n        }\n        for (Long groupId : distinctGroups) {\n            // allVmUpdates.putAll(generateRulesetForGroupMembers(groupId));\n            affectedVms.addAll(_securityGroupVMMapDao.listVmIdsBySecurityGroup(groupId));\n        }\n        return affectedVms;\n    }","id":73485,"modified_method":"protected List<Long> getAffectedVmsForIngressRules(List<IngressRuleVO> allowingRules) {\n        Set<Long> distinctGroups = new HashSet<Long>();\n        List<Long> affectedVms = new ArrayList<Long>();\n\n        for (IngressRuleVO allowingRule : allowingRules) {\n            distinctGroups.add(allowingRule.getSecurityGroupId());\n        }\n        for (Long groupId : distinctGroups) {\n            // allVmUpdates.putAll(generateRulesetForGroupMembers(groupId));\n            affectedVms.addAll(_securityGroupVMMapDao.listVmIdsBySecurityGroup(groupId));\n        }\n        return affectedVms;\n    }","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void fullSync(long agentId, HashMap<String, Pair<Long, Long>> newGroupStates) {\n        Set<Long> affectedVms = new HashSet<Long>();\n        for (String vmName : newGroupStates.keySet()) {\n            Long vmId = newGroupStates.get(vmName).first();\n            Long seqno = newGroupStates.get(vmName).second();\n\n            VmRulesetLogVO log = _rulesetLogDao.findByVmId(vmId);\n            if (log != null && log.getLogsequence() != seqno) {\n                affectedVms.add(vmId);\n            }\n        }\n        if (affectedVms.size() > 0) {\n            s_logger.info(\"Network Group full sync for agent \" + agentId + \" found \" + affectedVms.size() + \" vms out of sync\");\n            scheduleRulesetUpdateToHosts(affectedVms, false, null);\n        }\n\n    }","id":73486,"modified_method":"@Override\n    public void fullSync(long agentId, HashMap<String, Pair<Long, Long>> newGroupStates) {\n        ArrayList<Long> affectedVms = new ArrayList<Long>();\n        for (String vmName : newGroupStates.keySet()) {\n            Long vmId = newGroupStates.get(vmName).first();\n            Long seqno = newGroupStates.get(vmName).second();\n\n            VmRulesetLogVO log = _rulesetLogDao.findByVmId(vmId);\n            if (log != null && log.getLogsequence() != seqno) {\n                affectedVms.add(vmId);\n            }\n        }\n        if (affectedVms.size() > 0) {\n            s_logger.info(\"Network Group full sync for agent \" + agentId + \" found \" + affectedVms.size() + \" vms out of sync\");\n            scheduleRulesetUpdateToHosts(affectedVms, false, null);\n        }\n\n    }","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\r\n    public SecurityGroupWorkVO findByVmId(long vmId, boolean taken) {\r\n        SearchCriteria<SecurityGroupWorkVO> sc = taken?VmIdTakenSearch.create():VmIdUnTakenSearch.create();\r\n        sc.setParameters(\"vmId\", vmId);\r\n        return findOneIncludingRemovedBy(sc);\r\n    }","id":73487,"modified_method":"@Override\r\n    public SecurityGroupWork findByVmId(long vmId, boolean taken) {\r\n        SearchCriteria<SecurityGroupWorkVO> sc = taken?VmIdTakenSearch.create():VmIdUnTakenSearch.create();\r\n        sc.setParameters(\"vmId\", vmId);\r\n        return findOneIncludingRemovedBy(sc);\r\n    }","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n\t@DB\n\tpublic SecurityGroupWorkVO take(long serverId) {\n\t\tfinal Transaction txn = Transaction.currentTxn();\n        try {\n            final SearchCriteria<SecurityGroupWorkVO> sc = UntakenWorkSearch.create();\n            sc.setParameters(\"step\", Step.Scheduled);\n\n            final Filter filter = new Filter(SecurityGroupWorkVO.class, null, true, 0l, 1l);//FIXME: order desc by update time?\n\n            txn.start();\n            final List<SecurityGroupWorkVO> vos = lockRows(sc, filter, true);\n            if (vos.size() == 0) {\n                txn.commit();\n                if (s_logger.isTraceEnabled()) {\n                    s_logger.trace(\"Security Group take: no work found\");\n                }\n                return null;\n            }\n            SecurityGroupWorkVO work = vos.get(0);\n            boolean processing = false;\n            if ( findByVmIdStep(work.getInstanceId(), Step.Processing) != null) {\n                //ensure that there is no job in Processing state for the same VM\n                processing = true;\n                if (s_logger.isTraceEnabled()) {\n                    s_logger.trace(\"Security Group work take: found a job in Scheduled and Processing  vmid=\" + work.getInstanceId());\n                }\n            }\n            work.setServerId(serverId);\n            work.setDateTaken(new Date());\n            if (processing) {\n                //the caller to take() should check the step and schedule another work item to come back\n                //and take a look.\n                work.setStep(SecurityGroupWorkVO.Step.Done);\n            } else {\n                work.setStep(SecurityGroupWorkVO.Step.Processing);\n            }\n\n            update(work.getId(), work);\n\n            txn.commit();\n\n            return work;\n\n        } catch (final Throwable e) {\n            throw new CloudRuntimeException(\"Unable to execute take\", e);\n        }\n\t}","id":73488,"modified_method":"@Override\n\t@DB\n\tpublic SecurityGroupWorkVO take(long serverId) {\n\t\tfinal Transaction txn = Transaction.currentTxn();\n        try {\n            final SearchCriteria<SecurityGroupWorkVO> sc = UntakenWorkSearch.create();\n            sc.setParameters(\"step\", Step.Scheduled);\n\n            final Filter filter = new Filter(SecurityGroupWorkVO.class, null, true, 0l, 1l);//FIXME: order desc by update time?\n\n            txn.start();\n            final List<SecurityGroupWorkVO> vos = lockRows(sc, filter, true);\n            if (vos.size() == 0) {\n                txn.commit();\n                if (s_logger.isTraceEnabled()) {\n                    s_logger.trace(\"Security Group take: no work found\");\n                }\n                return null;\n            }\n            SecurityGroupWorkVO work = vos.get(0);\n            boolean processing = false;\n            if ( findByVmIdStep(work.getInstanceId(), Step.Processing) != null) {\n                //ensure that there is no job in Processing state for the same VM\n                processing = true;\n                if (s_logger.isTraceEnabled()) {\n                    s_logger.trace(\"Security Group work take: found a job in Scheduled and Processing  vmid=\" + work.getInstanceId());\n                }\n            }\n            work.setServerId(serverId);\n            work.setDateTaken(new Date());\n            if (processing) {\n                //the caller to take() should check the step and schedule another work item to come back\n                //and take a look.\n                work.setStep(SecurityGroupWork.Step.Done);\n            } else {\n                work.setStep(SecurityGroupWork.Step.Processing);\n            }\n\n            update(work.getId(), work);\n\n            txn.commit();\n\n            return work;\n\n        } catch (final Throwable e) {\n            throw new CloudRuntimeException(\"Unable to execute take\", e);\n        }\n\t}","commit_id":"abf47545032132d50ac17fdb524ee0da16c73304","url":"https://github.com/apache/cloudstack"},{"original_method":"@DB\n    public void scheduleRulesetUpdateToHosts(Set<Long> affectedVms, boolean updateSeqno, Long delayMs) {\n        if (delayMs == null) {\n            delayMs = new Long(100l);\n        }\n        \n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"Security Group Mgr: scheduling ruleset updates for \" + affectedVms.size() + \" vms\");\n        }\n        boolean locked = _workLock.lock(_globalWorkLockTimeout); \n        if (locked) {\n            if (s_logger.isTraceEnabled()) {\n                s_logger.trace(\"Security Group Mgr: acquired global work lock\");\n            }\n            try {\n                for (Long vmId : affectedVms) {\n                    if (s_logger.isTraceEnabled()) {\n                        s_logger.trace(\"Security Group Mgr: scheduling ruleset updates for \" + vmId);\n                    }\n                    VmRulesetLogVO log = null;\n                    SecurityGroupWorkVO work = null;\n                    //UserVm vm = null;\n                    Transaction txn = null;\n                    try {\n                        txn = Transaction.currentTxn();\n                        txn.start();\n\n                        //vm = _userVMDao.acquireInLockTable(vmId);\n                        //if (vm == null) {\n                        //s_logger.warn(\"Failed to acquire lock on vm id \" + vmId);\n                        //continue;\n                        //}\n                        log = _rulesetLogDao.findByVmId(vmId);\n                        if (log == null) {\n                            log = new VmRulesetLogVO(vmId);\n                            log = _rulesetLogDao.persist(log);\n                        }\n\n                        if (log != null && updateSeqno) {\n                            log.incrLogsequence();\n                            _rulesetLogDao.update(log.getId(), log);\n                        }\n                        work = _workDao.findByVmIdStep(vmId, Step.Scheduled);\n                        if (work == null) {\n                            work = new SecurityGroupWorkVO(vmId, null, null, SecurityGroupWorkVO.Step.Scheduled, null);\n                            work = _workDao.persist(work);\n                            if (s_logger.isTraceEnabled()) {\n                                s_logger.trace(\"Security Group Mgr: created new work item for \" + vmId);\n                            }\n                        }\n\n                        work.setLogsequenceNumber(log.getLogsequence());\n                        _workDao.update(work.getId(), work);\n\n                    } finally {\n                        //                if (vm != null) {\n                        //                    _userVMDao.releaseFromLockTable(vmId);\n                        //                }\n                        if (txn != null)\n                            txn.commit();\n                    }\n\n                    _executorPool.schedule(new WorkerThread(), delayMs, TimeUnit.MILLISECONDS);\n                }\n            } finally {\n                _workLock.unlock();\n                if (s_logger.isTraceEnabled()) {\n                    s_logger.trace(\"Security Group Mgr: released global work lock\");\n                }\n            }\n        } else {\n            s_logger.warn(\"Security Group Mgr: failed to acquire global work lock\");\n        }\n    }","id":73489,"modified_method":"@DB\n    public void scheduleRulesetUpdateToHosts(Set<Long> affectedVms, boolean updateSeqno, Long delayMs) {\n        if (affectedVms.size() == 0) {\n            return;\n        }\n\n        if (delayMs == null) {\n            delayMs = new Long(100l);\n        }\n\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"Security Group Mgr: scheduling ruleset updates for \" + affectedVms.size() + \" vms\");\n        }\n        Transaction txn = Transaction.currentTxn();\n        txn.start();\n        try {\n            PreparedStatement pstmt = txn.prepareAutoCloseStatement(\"LOCK TABLES op_vm_ruleset_log WRITE, op_nwgrp_work WRITE\");\n            int tablesLocked = pstmt.executeUpdate();\n            if (tablesLocked != 2) {\n                s_logger.warn(\"Unable to get locks on both tables: \" + tablesLocked);\n                return;\n            }\n            for (Long vmId : affectedVms) {\n                if (s_logger.isTraceEnabled()) {\n                    s_logger.trace(\"Security Group Mgr: scheduling ruleset updates for \" + vmId);\n                }\n                VmRulesetLogVO log = null;\n                SecurityGroupWorkVO work = null;\n                log = _rulesetLogDao.findByVmId(vmId);\n                if (log == null) {\n                    log = new VmRulesetLogVO(vmId);\n                    log = _rulesetLogDao.persist(log);\n                }\n\n                if (log != null && updateSeqno) {\n                    log.incrLogsequence();\n                    _rulesetLogDao.update(log.getId(), log);\n                }\n                work = _workDao.findByVmIdStep(vmId, Step.Scheduled);\n                if (work == null) {\n                    work = new SecurityGroupWorkVO(vmId, null, null, SecurityGroupWorkVO.Step.Scheduled, null);\n                    work = _workDao.persist(work);\n                    if (s_logger.isTraceEnabled()) {\n                        s_logger.trace(\"Security Group Mgr: created new work item for \" + vmId);\n                    }\n                }\n\n                work.setLogsequenceNumber(log.getLogsequence());\n                _workDao.update(work.getId(), work);\n\n                _executorPool.schedule(new WorkerThread(), delayMs, TimeUnit.MILLISECONDS);\n            }\n\n            txn.commit();\n        } catch (SQLException e) {\n            s_logger.error(\"Unable to execute lock tables routines\", e);\n        } finally {\n            try {\n                PreparedStatement pstmt = txn.prepareAutoCloseStatement(\"UNLOCK TABLES\");\n                int tablesUnlocked = pstmt.executeUpdate();\n                assert (tablesUnlocked == 2) : \"Less than two tables unlocked: \" + tablesUnlocked;\n            } catch (SQLException e) {\n                s_logger.warn(\"Unable to unlock tables\");\n            }\n        }\n    }","commit_id":"6905a1db1dfa2cc5ad8fabcba725332ba2de6088","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    @DB\n    public ExternalLoadBalancerDeviceVO addExternalLoadBalancer(long physicalNetworkId, String url, String username, String password, String deviceName, ServerResource resource) {\n\n        String guid;\n        PhysicalNetworkVO pNetwork = null;\n        NetworkDevice ntwkDevice = NetworkDevice.getNetworkDevice(deviceName);\n        Transaction txn = null;\n        long zoneId;\n\n        if ((ntwkDevice == null) || (url == null) || (username == null) || (resource == null) || (password == null)) {\n            throw new InvalidParameterValueException(\"Atleast one of the required parameters (url, username, password,\" +\n                    \" server resource, zone id/physical network id) is not specified or a valid parameter.\");\n        }\n\n        pNetwork = _physicalNetworkDao.findById(physicalNetworkId);\n        if (pNetwork == null) {\n            throw new InvalidParameterValueException(\"Could not find phyical network with ID: \" + physicalNetworkId);\n        }\n        zoneId = pNetwork.getDataCenterId();\n\n        PhysicalNetworkServiceProviderVO ntwkSvcProvider = _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), ntwkDevice.getNetworkServiceProvder());\n        if (ntwkSvcProvider == null) {\n            throw new CloudRuntimeException(\"Network Service Provider: \" + ntwkDevice.getNetworkServiceProvder() +\n                    \" is not enabled in the physical network: \" + physicalNetworkId + \"to add this device\");\n        } else if (ntwkSvcProvider.getState() == PhysicalNetworkServiceProvider.State.Shutdown) {\n            throw new CloudRuntimeException(\"Network Service Provider: \" + ntwkSvcProvider.getProviderName() +\n                    \" is in shutdown state in the physical network: \" + physicalNetworkId + \"to add this device\");\n        }\n\n        URI uri;\n        try {\n            uri = new URI(url);\n        } catch (Exception e) {\n            s_logger.debug(e);\n            throw new InvalidParameterValueException(e.getMessage());\n        }\n\n        String ipAddress = uri.getHost();\n        Map hostDetails = new HashMap<String, String>();\n        guid = getExternalLoadBalancerResourceGuid(pNetwork.getId(), deviceName, ipAddress);\n        hostDetails.put(\"name\", guid);\n        hostDetails.put(\"guid\", guid);\n        hostDetails.put(\"zoneId\", String.valueOf(pNetwork.getDataCenterId()));\n        hostDetails.put(\"ip\", ipAddress);\n        hostDetails.put(\"physicalNetworkId\", String.valueOf(pNetwork.getId()));\n        hostDetails.put(\"username\", username);\n        hostDetails.put(\"password\", password);\n        hostDetails.put(\"deviceName\", deviceName);\n\n        // leave parameter validation to be part server resource configure\n        Map<String, String> configParams = new HashMap<String, String>();\n        UrlUtil.parseQueryParameters(uri.getQuery(), false, configParams);\n        hostDetails.putAll(configParams);\n\n        try {\n            resource.configure(guid, hostDetails);\n\n            Host host = _resourceMgr.addHost(zoneId, resource, Host.Type.ExternalLoadBalancer, hostDetails);\n            if (host != null) {\n                txn = Transaction.currentTxn();\n                txn.start();\n\n                boolean dedicatedUse = (configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_DEDICATED) != null) ? Boolean.parseBoolean(configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_DEDICATED)) : false;\n                boolean inline = (configParams.get(ApiConstants.INLINE) != null) ? Boolean.parseBoolean(configParams.get(ApiConstants.INLINE)) : false;\n                long capacity = NumbersUtil.parseLong((String) configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_CAPACITY), 0);\n\n                ExternalLoadBalancerDeviceVO lbDeviceVO = new ExternalLoadBalancerDeviceVO(host.getId(), pNetwork.getId(), ntwkSvcProvider.getProviderName(),\n                        deviceName, capacity, dedicatedUse, inline);\n\n                _externalLoadBalancerDeviceDao.persist(lbDeviceVO);\n\n                DetailVO hostDetail = new DetailVO(host.getId(), ApiConstants.LOAD_BALANCER_DEVICE_ID, String.valueOf(lbDeviceVO.getId()));\n                _hostDetailDao.persist(hostDetail);\n\n                txn.commit();\n                return lbDeviceVO;\n            } else {\n                throw new CloudRuntimeException(\"Failed to add load balancer device due to internal error.\");\n            }\n        } catch (ConfigurationException e) {\n            throw new CloudRuntimeException(e.getMessage());\n        }\n    }","id":73490,"modified_method":"@Override\n    @DB\n    public ExternalLoadBalancerDeviceVO addExternalLoadBalancer(long physicalNetworkId, String url, String username, String password, String deviceName, ServerResource resource) {\n\n        PhysicalNetworkVO pNetwork = null;\n        NetworkDevice ntwkDevice = NetworkDevice.getNetworkDevice(deviceName);\n        long zoneId;\n\n        if ((ntwkDevice == null) || (url == null) || (username == null) || (resource == null) || (password == null)) {\n            throw new InvalidParameterValueException(\"Atleast one of the required parameters (url, username, password,\" +\n                    \" server resource, zone id/physical network id) is not specified or a valid parameter.\");\n        }\n\n        pNetwork = _physicalNetworkDao.findById(physicalNetworkId);\n        if (pNetwork == null) {\n            throw new InvalidParameterValueException(\"Could not find phyical network with ID: \" + physicalNetworkId);\n        }\n        zoneId = pNetwork.getDataCenterId();\n\n        PhysicalNetworkServiceProviderVO ntwkSvcProvider = _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), ntwkDevice.getNetworkServiceProvder());\n        if (ntwkSvcProvider == null) {\n            throw new CloudRuntimeException(\"Network Service Provider: \" + ntwkDevice.getNetworkServiceProvder() +\n                    \" is not enabled in the physical network: \" + physicalNetworkId + \"to add this device\");\n        } else if (ntwkSvcProvider.getState() == PhysicalNetworkServiceProvider.State.Shutdown) {\n            throw new CloudRuntimeException(\"Network Service Provider: \" + ntwkSvcProvider.getProviderName() +\n                    \" is in shutdown state in the physical network: \" + physicalNetworkId + \"to add this device\");\n        }\n\n        URI uri;\n        try {\n            uri = new URI(url);\n        } catch (Exception e) {\n            s_logger.debug(e);\n            throw new InvalidParameterValueException(e.getMessage());\n        }\n\n        String ipAddress = uri.getHost();\n        Map hostDetails = new HashMap<String, String>();\n        String hostName = getExternalLoadBalancerResourceGuid(pNetwork.getId(), deviceName, ipAddress);\n        hostDetails.put(\"name\", hostName);\n        hostDetails.put(\"guid\", UUID.randomUUID().toString());\n        hostDetails.put(\"zoneId\", String.valueOf(pNetwork.getDataCenterId()));\n        hostDetails.put(\"ip\", ipAddress);\n        hostDetails.put(\"physicalNetworkId\", String.valueOf(pNetwork.getId()));\n        hostDetails.put(\"username\", username);\n        hostDetails.put(\"password\", password);\n        hostDetails.put(\"deviceName\", deviceName);\n\n        // leave parameter validation to be part server resource configure\n        Map<String, String> configParams = new HashMap<String, String>();\n        UrlUtil.parseQueryParameters(uri.getQuery(), false, configParams);\n        hostDetails.putAll(configParams);\n\n        Transaction txn = Transaction.currentTxn();\n        try {\n            resource.configure(hostName, hostDetails);\n\n            Host host = _resourceMgr.addHost(zoneId, resource, Host.Type.ExternalLoadBalancer, hostDetails);\n            if (host != null) {\n\n                boolean dedicatedUse = (configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_DEDICATED) != null) ? Boolean.parseBoolean(configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_DEDICATED)) : false;\n                boolean inline = (configParams.get(ApiConstants.INLINE) != null) ? Boolean.parseBoolean(configParams.get(ApiConstants.INLINE)) : false;\n                long capacity = NumbersUtil.parseLong((String) configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_CAPACITY), 0);\n\n                txn.start();\n                ExternalLoadBalancerDeviceVO lbDeviceVO = new ExternalLoadBalancerDeviceVO(host.getId(), pNetwork.getId(), ntwkSvcProvider.getProviderName(),\n                        deviceName, capacity, dedicatedUse, inline);\n                _externalLoadBalancerDeviceDao.persist(lbDeviceVO);\n\n                DetailVO hostDetail = new DetailVO(host.getId(), ApiConstants.LOAD_BALANCER_DEVICE_ID, String.valueOf(lbDeviceVO.getId()));\n                _hostDetailDao.persist(hostDetail);\n\n                txn.commit();\n                return lbDeviceVO;\n            } else {\n                throw new CloudRuntimeException(\"Failed to add load balancer device due to internal error.\");\n            }\n        } catch (ConfigurationException e) {\n            txn.rollback();\n            throw new CloudRuntimeException(e.getMessage());\n        }\n    }","commit_id":"35ea4b7df18273677bdc4b619e45843c4b82e2de","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\r\n  public void mousePressed(final MouseEvent e) {\r\n    if(gui.updating || opened == null) return;\r\n    super.mousePressed(e);\r\n\r\n    if(!focus(e.getX(), e.getY())) return;\r\n\r\n    // add or remove marked node\r\n    final Nodes marked = gui.context.marked;\r\n    if(e.getClickCount() == 2) {\r\n      gui.notify.context(marked, false, null);\r\n    } else if(e.isShiftDown()) {\r\n      gui.notify.mark(1, null);\r\n    } else if(sc(e)) {\r\n      gui.notify.mark(2, null);\r\n    } else if(getCursor() != CURSORHAND) {\r\n      if(!marked.contains(gui.context.focused)) gui.notify.mark(0, null);\r\n    } else {\r\n      // open/close entry\r\n      opened[gui.context.focused] ^= true;\r\n      refreshHeight();\r\n      repaint();\r\n    }\r\n  }","id":73491,"modified_method":"@Override\r\n  public void mousePressed(final MouseEvent e) {\r\n    if(gui.updating || opened == null) return;\r\n    super.mousePressed(e);\r\n\r\n    if(!focus(e.getX(), e.getY())) return;\r\n\r\n    // add or remove marked node\r\n    final Nodes marked = gui.context.marked;\r\n    if(e.getClickCount() == 2) {\r\n      gui.notify.context(marked, false, null);\r\n    } else if(e.isShiftDown()) {\r\n      gui.notify.mark(1, null);\r\n    } else if(sc(e) && SwingUtilities.isLeftMouseButton(e)) {\r\n      gui.notify.mark(2, null);\r\n    } else if(getCursor() != CURSORHAND) {\r\n      if(!marked.contains(gui.context.focused)) gui.notify.mark(0, null);\r\n    } else {\r\n      // open/close entry\r\n      opened[gui.context.focused] ^= true;\r\n      refreshHeight();\r\n      repaint();\r\n    }\r\n  }","commit_id":"b0cac28d133d6c574a19baa8f253c825a6b67ff5","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void mousePressed(final MouseEvent e) {\r\n    if(gui.updating) return;\r\n    super.mousePressed(e);\r\n\r\n    mouseX = e.getX();\r\n    mouseY = e.getY();\r\n    dragTol = 0;\r\n    if(!focus() && gui.context.focused == -1) return;\r\n\r\n    // add or remove marked node\r\n    final Nodes marked = gui.context.marked;\r\n    if(e.getClickCount() == 2) {\r\n      if(mainRects.size != 1) gui.notify.context(marked, false, null);\r\n    } else if(e.isShiftDown()) {\r\n      gui.notify.mark(1, null);\r\n    } else if(sc(e)) {\r\n      gui.notify.mark(2, null);\r\n    } else {\r\n      if(!marked.contains(gui.context.focused)) gui.notify.mark(0, null);\r\n    }\r\n  }","id":73492,"modified_method":"@Override\r\n  public void mousePressed(final MouseEvent e) {\r\n    if(gui.updating) return;\r\n    super.mousePressed(e);\r\n\r\n    mouseX = e.getX();\r\n    mouseY = e.getY();\r\n    dragTol = 0;\r\n    if(!focus() && gui.context.focused == -1) return;\r\n\r\n    // add or remove marked node\r\n    final Nodes marked = gui.context.marked;\r\n    if(e.getClickCount() == 2) {\r\n      if(mainRects.size != 1) gui.notify.context(marked, false, null);\r\n    } else if(e.isShiftDown()) {\r\n      gui.notify.mark(1, null);\r\n    } else if(sc(e) && SwingUtilities.isLeftMouseButton(e)) {\r\n      gui.notify.mark(2, null);\r\n    } else {\r\n      if(!marked.contains(gui.context.focused)) gui.notify.mark(0, null);\r\n    }\r\n  }","commit_id":"b0cac28d133d6c574a19baa8f253c825a6b67ff5","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Constructor.\r\n   * @param comp component reference\r\n   * @param pop popup reference\r\n   */\r\n  public BaseXPopup(final BaseXPanel comp, final GUICommand[] pop) {\r\n    popup = pop;\r\n    gui = comp.gui;\r\n\r\n    comp.addMouseListener(new MouseAdapter() {\r\n      @Override\r\n      public void mouseReleased(final MouseEvent e) {\r\n        if(!gui.updating && !SwingUtilities.isLeftMouseButton(e))\r\n          show(e.getComponent(), e.getX() - 10, e.getY() - 15);\r\n      }\r\n    });\r\n    comp.addKeyListener(new KeyAdapter() {\r\n      @Override\r\n      public void keyPressed(final KeyEvent e) {\r\n        if(!gui.updating && pressed(CONTEXT, e)) show(e.getComponent(), 10, 10);\r\n      }\r\n    });\r\n\r\n    for(final GUICommand c : pop) {\r\n      if(c == null) {\r\n        addSeparator();\r\n      } else {\r\n        final JMenuItem item = add(c.desc());\r\n        item.addActionListener(new ActionListener() {\r\n          public void actionPerformed(final ActionEvent e) {\r\n            if(!gui.updating) c.execute(comp.gui);\r\n          }\r\n        });\r\n        item.setMnemonic(c.desc().charAt(0));\r\n        item.setToolTipText(c.help());\r\n      }\r\n    }\r\n  }","id":73493,"modified_method":"/**\r\n   * Constructor.\r\n   * @param comp component reference\r\n   * @param pop popup reference\r\n   */\r\n  public BaseXPopup(final BaseXPanel comp, final GUICommand[] pop) {\r\n    popup = pop;\r\n    gui = comp.gui;\r\n\r\n    comp.addMouseListener(new MouseAdapter() {\r\n      @Override\r\n      public void mousePressed(final MouseEvent e) {\r\n        if(!gui.updating && e.isPopupTrigger())\r\n          show(e.getComponent(), e.getX() - 10, e.getY() - 15);\r\n      }\r\n    });\r\n    comp.addKeyListener(new KeyAdapter() {\r\n      @Override\r\n      public void keyPressed(final KeyEvent e) {\r\n        if(!gui.updating && pressed(CONTEXT, e)) show(e.getComponent(), 10, 10);\r\n      }\r\n    });\r\n\r\n    for(final GUICommand c : pop) {\r\n      if(c == null) {\r\n        addSeparator();\r\n      } else {\r\n        final JMenuItem item = add(c.desc());\r\n        item.addActionListener(new ActionListener() {\r\n          public void actionPerformed(final ActionEvent e) {\r\n            if(!gui.updating) c.execute(comp.gui);\r\n          }\r\n        });\r\n        item.setMnemonic(c.desc().charAt(0));\r\n        item.setToolTipText(c.help());\r\n      }\r\n    }\r\n  }","commit_id":"e5bcfbcb81dcebeace51d5ac8cf987305c750b1a","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void mousePressed(final MouseEvent e) {\r\n    if(gui.updating) return;\r\n    super.mousePressed(e);\r\n\r\n    mouseX = e.getX();\r\n    mouseY = e.getY();\r\n    dragTol = 0;\r\n    if(!focus() && gui.context.focused == -1) return;\r\n\r\n    // add or remove marked node\r\n    final Nodes marked = gui.context.marked;\r\n    if(e.getClickCount() == 2) {\r\n      if(mainRects.size != 1) gui.notify.context(marked, false, null);\r\n    } else if(e.isShiftDown()) {\r\n      gui.notify.mark(1, null);\r\n    } else if(sc(e)) {\r\n      gui.notify.mark(2, null);\r\n    } else {\r\n      if(!marked.contains(gui.context.focused)) gui.notify.mark(0, null);\r\n    }\r\n  }","id":73494,"modified_method":"@Override\r\n  public void mousePressed(final MouseEvent e) {\r\n    if(gui.updating) return;\r\n    super.mousePressed(e);\r\n\r\n    mouseX = e.getX();\r\n    mouseY = e.getY();\r\n    dragTol = 0;\r\n    if(!focus() && gui.context.focused == -1) return;\r\n    \r\n    // add or remove marked node\r\n    final Nodes marked = gui.context.marked;\r\n    if(e.getClickCount() == 2) {\r\n      if(mainRects.size != 1) gui.notify.context(marked, false, null);\r\n    } else if(e.isShiftDown()) {\r\n      gui.notify.mark(1, null);\r\n    } else if(sc(e) && SwingUtilities.isLeftMouseButton(e)) {\r\n      gui.notify.mark(2, null);\r\n    } else {\r\n      if(!marked.contains(gui.context.focused)) gui.notify.mark(0, null);\r\n    }\r\n  }","commit_id":"e5bcfbcb81dcebeace51d5ac8cf987305c750b1a","url":"https://github.com/BaseXdb/basex"},{"original_method":"@GET\n  @Produces({MIMETYPE_TEXT, MIMETYPE_XML, MIMETYPE_JSON, MIMETYPE_JAVASCRIPT,\n    MIMETYPE_PROTOBUF})\n  public Response get(@Context UriInfo uriInfo) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"GET \" + uriInfo.getAbsolutePath());\n    }\n    try {\n      RESTServlet server = RESTServlet.getInstance();\n      HBaseAdmin admin = new HBaseAdmin(server.getConfiguration());\n      StorageClusterVersionModel model = new StorageClusterVersionModel();\n      model.setVersion(admin.getClusterStatus().getHBaseVersion());\n      ResponseBuilder response = Response.ok(model);\n      response.cacheControl(cacheControl);\n      return response.build();\n    } catch (IOException e) {\n      throw new WebApplicationException(e, \n                  Response.Status.SERVICE_UNAVAILABLE);\n    }\n  }","id":73495,"modified_method":"@GET\n  @Produces({MIMETYPE_TEXT, MIMETYPE_XML, MIMETYPE_JSON, MIMETYPE_JAVASCRIPT})\n  public Response get(@Context UriInfo uriInfo) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"GET \" + uriInfo.getAbsolutePath());\n    }\n    try {\n      RESTServlet server = RESTServlet.getInstance();\n      HBaseConfiguration hconf = server.getConfiguration();\n      HBaseAdmin admin = new HBaseAdmin(hconf);\n      StorageClusterVersionModel model = new StorageClusterVersionModel();\n      model.setVersion(admin.getClusterStatus().getHBaseVersion());\n      ResponseBuilder response = Response.ok(model);\n      response.cacheControl(cacheControl);\n      return response.build();\n    } catch (IOException e) {\n      throw new WebApplicationException(e, \n                  Response.Status.SERVICE_UNAVAILABLE);\n    }\n  }","commit_id":"0159889bba4b1ecd7c7b08c087cbc7b2cb5f27ba","url":"https://github.com/apache/hbase"},{"original_method":"public static void setupBlockStoragePersistenceContext() {\n    Map<String,String> props = Maps.newHashMap( );\n    props.put(\"hibernate.archive.autodetection\", \"jar, class, hbm\");\n    props.put(\"hibernate.ejb.interceptor.session_scoped\", \"com.eucalyptus.entities.DelegatingInterceptor\");\n    props.put(\"hibernate.show_sql\", \"false\");\n    props.put(\"hibernate.format_sql\", \"false\");\n    props.put(\"hibernate.generate_statistics\", \"false\");\n    props.put(\"hibernate.bytecode.use_reflection_optimizer\", \"true\");\n    props.put(\"javax.persistence.jdbc.driver\", \"org.apache.derby.jdbc.EmbeddedDriver\");\n    props.put(\"javax.persistence.jdbc.user\", \"root\");\n    props.put(\"javax.persistence.jdbc.password\", \"root\");\n    props.put(\"hibernate.hbm2ddl.auto\", \"create\");\n    props.put(\"hibernate.cache.use_second_level_cache\", \"false\");\n    props.put(\"hibernate.dialect\", \"org.hibernate.dialect.DerbyDialect\");\n    props.put(\"hibernate.connection.url\", \"jdbc:derby:memory:test;create=true\");\n\n    PersistenceContextConfiguration config = new PersistenceContextConfiguration(\n        \"eucalyptus_storage\",\n        ImmutableList.<Class<?>>builder( ).add( BlockStorageGlobalConfiguration.class ).add( CHAPUserInfo.class )\n            .add( DASInfo.class ).add( DirectStorageInfo.class ).add( ISCSIMetaInfo.class )\n            .add( ISCSIVolumeInfo.class ).add( SnapshotInfo.class ).add( SnapshotPart.class )\n            .add( SnapshotTransferConfiguration.class ).add( SnapshotUploadInfo.class ).add( StorageInfo.class )\n            .add( VolumeExportRecord.class ).add( VolumeInfo.class ).add( VolumeToken.class )\n            .add( SANVolumeInfo.class ).add( SANInfo.class ).build( ),\n        props\n    );\n\n    PersistenceContexts.registerPersistenceContext( config );\n  }","id":73496,"modified_method":"public static void setupBlockStoragePersistenceContext() {\n    Map<String,String> props = Maps.newHashMap( );\n    props.put(\"hibernate.ejb.interceptor.session_scoped\", \"com.eucalyptus.entities.DelegatingInterceptor\");\n    props.put(\"hibernate.show_sql\", \"false\");\n    props.put(\"hibernate.format_sql\", \"false\");\n    props.put(\"hibernate.generate_statistics\", \"false\");\n    props.put(\"hibernate.bytecode.use_reflection_optimizer\", \"true\");\n    props.put(\"javax.persistence.jdbc.driver\", \"org.apache.derby.jdbc.EmbeddedDriver\");\n    props.put(\"javax.persistence.jdbc.user\", \"root\");\n    props.put(\"javax.persistence.jdbc.password\", \"root\");\n    props.put(\"hibernate.hbm2ddl.auto\", \"create\");\n    props.put(\"hibernate.cache.use_second_level_cache\", \"false\");\n    props.put(\"hibernate.dialect\", \"org.hibernate.dialect.DerbyDialect\");\n    props.put(\"hibernate.connection.url\", \"jdbc:derby:memory:test;create=true\");\n\n    PersistenceContextConfiguration config = new PersistenceContextConfiguration(\n        \"eucalyptus_storage\",\n        ImmutableList.<Class<?>>builder( ).add( BlockStorageGlobalConfiguration.class ).add( CHAPUserInfo.class )\n            .add( DASInfo.class ).add( DirectStorageInfo.class ).add( ISCSIMetaInfo.class )\n            .add( ISCSIVolumeInfo.class ).add( SnapshotInfo.class ).add( SnapshotPart.class )\n            .add( SnapshotTransferConfiguration.class ).add( SnapshotUploadInfo.class ).add( StorageInfo.class )\n            .add( VolumeExportRecord.class ).add( VolumeInfo.class ).add( VolumeToken.class )\n            .add( SANVolumeInfo.class ).add( SANInfo.class ).build( ),\n        props\n    );\n\n    PersistenceContexts.registerPersistenceContext( config );\n  }","commit_id":"f7ccf15d8dd8ace93d2adcf5a49ba10877be68a5","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void setupOsgPersistenceContext() {\n    Map<String,String> props = Maps.newHashMap( );\n    props.put(\"hibernate.archive.autodetection\", \"jar, class, hbm\");\n    props.put(\"hibernate.ejb.interceptor.session_scoped\", \"com.eucalyptus.entities.DelegatingInterceptor\");\n    props.put(\"hibernate.show_sql\", \"false\");\n    props.put(\"hibernate.format_sql\", \"false\");\n    props.put(\"hibernate.generate_statistics\", \"false\");\n    props.put(\"hibernate.bytecode.use_reflection_optimizer\", \"true\");\n    props.put(\"javax.persistence.jdbc.driver\", \"org.apache.derby.jdbc.EmbeddedDriver\");\n    props.put(\"javax.persistence.jdbc.user\", \"root\");\n    props.put(\"javax.persistence.jdbc.password\", \"root\");\n    props.put(\"hibernate.hbm2ddl.auto\", \"create\");\n    props.put(\"hibernate.cache.use_second_level_cache\", \"false\");\n    props.put(\"hibernate.dialect\", \"org.hibernate.dialect.DerbyDialect\");\n    props.put(\"hibernate.connection.url\", \"jdbc:derby:memory:test;create=true\");\n\n    PersistenceContextConfiguration config = new PersistenceContextConfiguration(\n        \"eucalyptus_osg\",\n        ImmutableList.<Class<?>>builder( ).add(Bucket.class).add(ObjectEntity.class)\n            .add(PartEntity.class).add(TorrentInfo.class).add(BucketTags.class)\n            .add(LifecycleRule.class).add(ScheduledJob.class).add(ObjectStorageGlobalConfiguration.class)\n            .add( S3AccessControlledEntity.class ).add( S3ProviderConfiguration.class ).build( ),\n        props\n    );\n\n    PersistenceContexts.registerPersistenceContext( config );\n  }","id":73497,"modified_method":"public static void setupOsgPersistenceContext() {\n    Map<String,String> props = Maps.newHashMap( );\n    props.put(\"hibernate.ejb.interceptor.session_scoped\", \"com.eucalyptus.entities.DelegatingInterceptor\");\n    props.put(\"hibernate.show_sql\", \"false\");\n    props.put(\"hibernate.format_sql\", \"false\");\n    props.put(\"hibernate.generate_statistics\", \"false\");\n    props.put(\"hibernate.bytecode.use_reflection_optimizer\", \"true\");\n    props.put(\"javax.persistence.jdbc.driver\", \"org.apache.derby.jdbc.EmbeddedDriver\");\n    props.put(\"javax.persistence.jdbc.user\", \"root\");\n    props.put(\"javax.persistence.jdbc.password\", \"root\");\n    props.put(\"hibernate.hbm2ddl.auto\", \"create\");\n    props.put(\"hibernate.cache.use_second_level_cache\", \"false\");\n    props.put(\"hibernate.dialect\", \"org.hibernate.dialect.DerbyDialect\");\n    props.put(\"hibernate.connection.url\", \"jdbc:derby:memory:test;create=true\");\n\n    PersistenceContextConfiguration config = new PersistenceContextConfiguration(\n        \"eucalyptus_osg\",\n        ImmutableList.<Class<?>>builder( ).add(Bucket.class).add(ObjectEntity.class)\n            .add(PartEntity.class).add(TorrentInfo.class).add(BucketTags.class)\n            .add(LifecycleRule.class).add(ScheduledJob.class).add(ObjectStorageGlobalConfiguration.class)\n            .add( S3AccessControlledEntity.class ).add( S3ProviderConfiguration.class ).build( ),\n        props\n    );\n\n    PersistenceContexts.registerPersistenceContext( config );\n  }","commit_id":"f7ccf15d8dd8ace93d2adcf5a49ba10877be68a5","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static void runSchemaUpdate( DatabaseFilters dbName ) throws RuntimeException {\n    try {\n      final Map<String, String> props = Maps.newHashMap( UpgradeState.getDatabaseProperties( ) );\n      for ( final String ctx : PersistenceContexts.list( ) ) {\n        final String databaseName = PersistenceContexts.toDatabaseName( ).apply( ctx );\n        final String schemaName = PersistenceContexts.toSchemaName( ).apply( ctx );\n        UpgradeState.putContextProperties( props, schemaName, dbName.getVersionedName( databaseName ) );\n        final PersistenceContextConfiguration config = new PersistenceContextConfiguration(\n            ctx,\n            PersistenceContexts.listEntities( ctx ),\n            props\n        );\n        new SchemaUpdate(PersistenceContexts.getConfiguration( config )).execute(true, true);\n      }\n    } catch ( final Exception e ) {\n      LOG.fatal( e, e );\n      LOG.fatal( \"Failed to initialize the persistence layer.\" );\n      throw Exceptions.toUndeclared( e );\n    }\n  }","id":73498,"modified_method":"private static void runSchemaUpdate( DatabaseFilters dbName ) throws RuntimeException {\n    try {\n      final Map<String, String> props = Maps.newHashMap( UpgradeState.getDatabaseProperties( ) );\n      for ( final String ctx : PersistenceContexts.list( ) ) {\n        final String databaseName = PersistenceContexts.toDatabaseName( ).apply( ctx );\n        final String schemaName = PersistenceContexts.toSchemaName( ).apply( ctx );\n        UpgradeState.putContextProperties( props, schemaName, dbName.getVersionedName( databaseName ) );\n        final PersistenceContextConfiguration config = new PersistenceContextConfiguration(\n            ctx,\n            PersistenceContexts.listEntities( ctx ),\n            props\n        );\n        final Configuration configuration = PersistenceContexts.getConfiguration( config );\n        final File configDigestFile = SubDirectory.RUNDB.getChildFile( ctx + \".cfg.sha256\" );\n        final ByteArrayOutputStream output = new ByteArrayOutputStream( 4096 );\n        final ObjectOutputStream outputObject = new ObjectOutputStream( output );\n        outputObject.writeObject( configuration ); // when using Java 7 the EntityTuplizerFactory/ConcurrentHashMap can\n        outputObject.flush( );                     // cause spurious hash differences. This occurs much less with Java 8.\n        final String digest = BaseEncoding.base16().lowerCase( )\n            .encode( Digest.SHA256.digestBinary( output.toByteArray( ) ) );\n        final boolean upgrade = BootstrapArgs.isUpgradeSystem( ) || isForceUpgrade( );\n        if ( upgrade ||\n            !configDigestFile.canRead( ) ||\n            !digest.equals( Files.toString( configDigestFile, StandardCharsets.UTF_8 ) ) ) {\n          LOG.info( \"Running schema update for \" + ctx );\n          new SchemaUpdate( configuration ).execute( false, true );\n          if ( upgrade ) {\n            if ( configDigestFile.exists( ) && !configDigestFile.delete( ) ) {\n              LOG.warn( \"Unable to delete configuration digest file: \" + configDigestFile.getAbsolutePath( ) );\n            }\n          } else {\n            Files.write( digest.getBytes( StandardCharsets.UTF_8 ), configDigestFile );\n          }\n        } else {\n          LOG.debug( \"Schema update skipped (no changes) for \" + ctx );\n        }\n      }\n    } catch ( final Exception e ) {\n      LOG.fatal( e, e );\n      LOG.fatal( \"Failed to initialize the persistence layer.\" );\n      throw Exceptions.toUndeclared( e );\n    }\n  }","commit_id":"f7ccf15d8dd8ace93d2adcf5a49ba10877be68a5","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n   * Test export scanner batching\n   */\n   @Test\n   public void testExportScannerBatching() throws Exception {\n    String BATCH_TABLE = \"exportWithBatch\";\n    HTableDescriptor desc = new HTableDescriptor(BATCH_TABLE);\n    desc.addFamily(new HColumnDescriptor(FAMILYA)\n        .setMaxVersions(1)\n    );\n    UTIL.getHBaseAdmin().createTable(desc);\n    HTable t = new HTable(UTIL.getConfiguration(), BATCH_TABLE);\n\n    Put p = new Put(ROW1);\n    p.add(FAMILYA, QUAL, now, QUAL);\n    p.add(FAMILYA, QUAL, now+1, QUAL);\n    p.add(FAMILYA, QUAL, now+2, QUAL);\n    p.add(FAMILYA, QUAL, now+3, QUAL);\n    p.add(FAMILYA, QUAL, now+4, QUAL);\n    t.put(p);\n\n    String[] args = new String[] {\n        \"-D\" + Export.EXPORT_BATCHING + \"=\" + EXPORT_BATCH_SIZE,  // added scanner batching arg.\n        BATCH_TABLE,\n        FQ_OUTPUT_DIR\n    };\n    assertTrue(runExport(args));\n\n    FileSystem fs = FileSystem.get(UTIL.getConfiguration());\n    fs.delete(new Path(FQ_OUTPUT_DIR), true);\n  }","id":73499,"modified_method":"/**\n   * Test export scanner batching\n   */\n   @Test\n   public void testExportScannerBatching() throws Exception {\n    String BATCH_TABLE = \"exportWithBatch\";\n    HTableDescriptor desc = new HTableDescriptor(BATCH_TABLE);\n    desc.addFamily(new HColumnDescriptor(FAMILYA)\n        .setMaxVersions(1)\n    );\n    UTIL.getHBaseAdmin().createTable(desc);\n    HTable t = new HTable(UTIL.getConfiguration(), BATCH_TABLE);\n\n    Put p = new Put(ROW1);\n    p.add(FAMILYA, QUAL, now, QUAL);\n    p.add(FAMILYA, QUAL, now+1, QUAL);\n    p.add(FAMILYA, QUAL, now+2, QUAL);\n    p.add(FAMILYA, QUAL, now+3, QUAL);\n    p.add(FAMILYA, QUAL, now+4, QUAL);\n    t.put(p);\n\n    String[] args = new String[] {\n        \"-D\" + Export.EXPORT_BATCHING + \"=\" + EXPORT_BATCH_SIZE,  // added scanner batching arg.\n        BATCH_TABLE,\n        FQ_OUTPUT_DIR\n    };\n    assertTrue(runExport(args));\n\n    FileSystem fs = FileSystem.get(UTIL.getConfiguration());\n    fs.delete(new Path(FQ_OUTPUT_DIR), true);\n    t.close();\n  }","commit_id":"191ba57a27dd195187fa4dd248d1ce02345e5b1a","url":"https://github.com/apache/hbase"},{"original_method":"private void addStartEndKeysForTest(TreeMap<byte[], Integer> map, byte[] first, byte[] last) {\n    Integer value = map.containsKey(first)?(Integer)map.get(first):0;\n    map.put(first, value+1);\n\n    value = map.containsKey(last)?(Integer)map.get(last):0;\n    map.put(last, value-1);\n  }","id":73500,"modified_method":"private void addStartEndKeysForTest(TreeMap<byte[], Integer> map, byte[] first, byte[] last) {\n    Integer value = map.containsKey(first)?map.get(first):0;\n    map.put(first, value+1);\n\n    value = map.containsKey(last)?map.get(last):0;\n    map.put(last, value-1);\n  }","commit_id":"191ba57a27dd195187fa4dd248d1ce02345e5b1a","url":"https://github.com/apache/hbase"},{"original_method":"private void runTest(String testName, BloomType bloomType, \n          byte[][][] hfileRanges) throws Exception {\n    Path dir = util.getDataTestDirOnTestFS(testName);\n    FileSystem fs = util.getTestFileSystem();\n    dir = dir.makeQualified(fs);\n    Path familyDir = new Path(dir, Bytes.toString(FAMILY));\n\n    int hfileIdx = 0;\n    for (byte[][] range : hfileRanges) {\n      byte[] from = range[0];\n      byte[] to = range[1];\n      createHFile(util.getConfiguration(), fs, new Path(familyDir, \"hfile_\"\n          + hfileIdx++), FAMILY, QUALIFIER, from, to, 1000);\n    }\n    int expectedRows = hfileIdx * 1000;\n\n    final byte[] TABLE = Bytes.toBytes(\"mytable_\"+testName);\n\n    HBaseAdmin admin = new HBaseAdmin(util.getConfiguration());\n    HTableDescriptor htd = new HTableDescriptor(TABLE);\n    HColumnDescriptor familyDesc = new HColumnDescriptor(FAMILY);\n    familyDesc.setBloomFilterType(bloomType);\n    htd.addFamily(familyDesc);\n    admin.createTable(htd, SPLIT_KEYS);\n\n    HTable table = new HTable(util.getConfiguration(), TABLE);\n    util.waitTableEnabled(TABLE);\n    LoadIncrementalHFiles loader = new LoadIncrementalHFiles(util.getConfiguration(), useSecure);\n    loader.doBulkLoad(dir, table);\n\n    assertEquals(expectedRows, util.countRows(table));\n  }","id":73501,"modified_method":"private void runTest(String testName, BloomType bloomType, \n          byte[][][] hfileRanges) throws Exception {\n    Path dir = util.getDataTestDirOnTestFS(testName);\n    FileSystem fs = util.getTestFileSystem();\n    dir = dir.makeQualified(fs);\n    Path familyDir = new Path(dir, Bytes.toString(FAMILY));\n\n    int hfileIdx = 0;\n    for (byte[][] range : hfileRanges) {\n      byte[] from = range[0];\n      byte[] to = range[1];\n      createHFile(util.getConfiguration(), fs, new Path(familyDir, \"hfile_\"\n          + hfileIdx++), FAMILY, QUALIFIER, from, to, 1000);\n    }\n    int expectedRows = hfileIdx * 1000;\n\n    final byte[] TABLE = Bytes.toBytes(\"mytable_\"+testName);\n\n    HTableDescriptor htd = new HTableDescriptor(TABLE);\n    HColumnDescriptor familyDesc = new HColumnDescriptor(FAMILY);\n    familyDesc.setBloomFilterType(bloomType);\n    htd.addFamily(familyDesc);\n\n    LoadIncrementalHFiles loader = new LoadIncrementalHFiles(util.getConfiguration(), useSecure);\n    String [] args= {dir.toString(),\"mytable_\"+testName};\n    loader.run(args);\n    HTable table = new HTable(util.getConfiguration(), TABLE);\n    \n    assertEquals(expectedRows, util.countRows(table));\n  }","commit_id":"191ba57a27dd195187fa4dd248d1ce02345e5b1a","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Test loading into a column family that does not exist.\n   */\n  @Test\n  public void testNonexistentColumnFamilyLoad() throws Exception {\n    String testName = \"testNonexistentColumnFamilyLoad\";\n    byte[][][] hfileRanges = new byte[][][] {\n      new byte[][]{ Bytes.toBytes(\"aaa\"), Bytes.toBytes(\"ccc\") },\n      new byte[][]{ Bytes.toBytes(\"ddd\"), Bytes.toBytes(\"ooo\") },\n    }; \n\n    Path dir = util.getDataTestDirOnTestFS(testName);\n    FileSystem fs = util.getTestFileSystem();\n    dir = dir.makeQualified(fs);\n    Path familyDir = new Path(dir, Bytes.toString(FAMILY));\n\n    int hfileIdx = 0;\n    for (byte[][] range : hfileRanges) {\n      byte[] from = range[0];\n      byte[] to = range[1];\n      createHFile(util.getConfiguration(), fs, new Path(familyDir, \"hfile_\"\n          + hfileIdx++), FAMILY, QUALIFIER, from, to, 1000);\n    }\n\n    final byte[] TABLE = Bytes.toBytes(\"mytable_\"+testName);\n\n    HBaseAdmin admin = new HBaseAdmin(util.getConfiguration());\n    HTableDescriptor htd = new HTableDescriptor(TABLE);\n    // set real family name to upper case in purpose to simulate the case that\n    // family name in HFiles is invalid\n    HColumnDescriptor family =\n        new HColumnDescriptor(Bytes.toBytes(new String(FAMILY).toUpperCase()));\n    htd.addFamily(family);\n    admin.createTable(htd, SPLIT_KEYS);\n\n    HTable table = new HTable(util.getConfiguration(), TABLE);\n    util.waitTableEnabled(TABLE);\n    LoadIncrementalHFiles loader = new LoadIncrementalHFiles(util.getConfiguration(), false);\n    try {\n      loader.doBulkLoad(dir, table);\n      assertTrue(\"Loading into table with non-existent family should have failed\", false);\n    } catch (Exception e) {\n      assertTrue(\"IOException expected\", e instanceof IOException);\n      // further check whether the exception message is correct\n      String errMsg = e.getMessage();\n      assertTrue(\"Incorrect exception message, expected message: [\"\n          + EXPECTED_MSG_FOR_NON_EXISTING_FAMILY + \"], current message: [\" + errMsg + \"]\",\n          errMsg.contains(EXPECTED_MSG_FOR_NON_EXISTING_FAMILY));\n    }\n    table.close();\n    admin.close();\n  }","id":73502,"modified_method":"/**\n   * Test loading into a column family that does not exist.\n   */\n  @Test\n  public void testNonexistentColumnFamilyLoad() throws Exception {\n    String testName = \"testNonexistentColumnFamilyLoad\";\n    byte[][][] hFileRanges = new byte[][][] {\n      new byte[][]{ Bytes.toBytes(\"aaa\"), Bytes.toBytes(\"ccc\") },\n      new byte[][]{ Bytes.toBytes(\"ddd\"), Bytes.toBytes(\"ooo\") },\n    }; \n\n    Path dir = util.getDataTestDirOnTestFS(testName);\n    FileSystem fs = util.getTestFileSystem();\n    dir = dir.makeQualified(fs);\n    Path familyDir = new Path(dir, Bytes.toString(FAMILY));\n\n    int hFileIdx = 0;\n    for (byte[][] range : hFileRanges) {\n      byte[] from = range[0];\n      byte[] to = range[1];\n      createHFile(util.getConfiguration(), fs, new Path(familyDir, \"hfile_\"\n          + hFileIdx++), FAMILY, QUALIFIER, from, to, 1000);\n    }\n\n    final byte[] TABLE = Bytes.toBytes(\"mytable_\"+testName);\n\n    HBaseAdmin admin = new HBaseAdmin(util.getConfiguration());\n    HTableDescriptor htd = new HTableDescriptor(TABLE);\n    // set real family name to upper case in purpose to simulate the case that\n    // family name in HFiles is invalid\n    HColumnDescriptor family =\n        new HColumnDescriptor(Bytes.toBytes(new String(FAMILY).toUpperCase()));\n    htd.addFamily(family);\n    admin.createTable(htd, SPLIT_KEYS);\n\n    HTable table = new HTable(util.getConfiguration(), TABLE);\n    util.waitTableEnabled(TABLE);\n    LoadIncrementalHFiles loader = new LoadIncrementalHFiles(util.getConfiguration(), false);\n    try {\n      loader.doBulkLoad(dir, table);\n      assertTrue(\"Loading into table with non-existent family should have failed\", false);\n    } catch (Exception e) {\n      assertTrue(\"IOException expected\", e instanceof IOException);\n      // further check whether the exception message is correct\n      String errMsg = e.getMessage();\n      assertTrue(\"Incorrect exception message, expected message: [\"\n          + EXPECTED_MSG_FOR_NON_EXISTING_FAMILY + \"], current message: [\" + errMsg + \"]\",\n          errMsg.contains(EXPECTED_MSG_FOR_NON_EXISTING_FAMILY));\n    }\n    table.close();\n    admin.close();\n  }","commit_id":"191ba57a27dd195187fa4dd248d1ce02345e5b1a","url":"https://github.com/apache/hbase"},{"original_method":"private int verifyHFile(Path p) throws IOException {\n    Configuration conf = util.getConfiguration();\n    HFile.Reader reader = HFile.createReader(\n        p.getFileSystem(conf), p, new CacheConfig(conf));\n    reader.loadFileInfo();\n    HFileScanner scanner = reader.getScanner(false, false);\n    scanner.seekTo();\n    int count = 0;\n    do {\n      count++;\n    } while (scanner.next());\n    assertTrue(count > 0);\n    reader.close();\n    return count;\n  }","id":73503,"modified_method":"private int verifyHFile(Path p) throws IOException {\n    Configuration configuration = util.getConfiguration();\n    HFile.Reader reader = HFile.createReader(\n        p.getFileSystem(configuration), p, new CacheConfig(configuration));\n    reader.loadFileInfo();\n    HFileScanner scanner = reader.getScanner(false, false);\n    scanner.seekTo();\n    int count = 0;\n    do {\n      count++;\n    } while (scanner.next());\n    assertTrue(count > 0);\n    reader.close();\n    return count;\n  }","commit_id":"191ba57a27dd195187fa4dd248d1ce02345e5b1a","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Create an HFile with the given number of rows between a given\n   * start key and end key.\n   * TODO put me in an HFileTestUtil or something?\n   */\n  static void createHFile(\n      Configuration conf,\n      FileSystem fs, Path path,\n      byte[] family, byte[] qualifier,\n      byte[] startKey, byte[] endKey, int numRows) throws IOException\n  {\n    HFile.Writer writer = HFile.getWriterFactory(conf, new CacheConfig(conf))\n        .withPath(fs, path)\n        .withBlockSize(BLOCKSIZE)\n        .withCompression(COMPRESSION)\n        .withComparator(KeyValue.KEY_COMPARATOR)\n        .create();\n    long now = System.currentTimeMillis();\n    try {\n      // subtract 2 since iterateOnSplits doesn't include boundary keys\n      for (byte[] key : Bytes.iterateOnSplits(startKey, endKey, numRows-2)) {\n        KeyValue kv = new KeyValue(key, family, qualifier, now, key);\n        writer.append(kv);\n      }\n    } finally {\n      writer.appendFileInfo(StoreFile.BULKLOAD_TIME_KEY,\n          Bytes.toBytes(System.currentTimeMillis()));\n      writer.close();\n    }\n  }","id":73504,"modified_method":"/**\n   * Create an HFile with the given number of rows between a given\n   * start key and end key.\n   * TODO put me in an HFileTestUtil or something?\n   */\n  static void createHFile(\n      Configuration configuration,\n      FileSystem fs, Path path,\n      byte[] family, byte[] qualifier,\n      byte[] startKey, byte[] endKey, int numRows) throws IOException\n  {\n    HFile.Writer writer = HFile.getWriterFactory(configuration, new CacheConfig(configuration))\n        .withPath(fs, path)\n        .withBlockSize(BLOCKSIZE)\n        .withCompression(COMPRESSION)\n        .withComparator(KeyValue.KEY_COMPARATOR)\n        .create();\n    long now = System.currentTimeMillis();\n    try {\n      // subtract 2 since iterateOnSplits doesn't include boundary keys\n      for (byte[] key : Bytes.iterateOnSplits(startKey, endKey, numRows-2)) {\n        KeyValue kv = new KeyValue(key, family, qualifier, now, key);\n        writer.append(kv);\n      }\n    } finally {\n      writer.appendFileInfo(StoreFile.BULKLOAD_TIME_KEY,\n          Bytes.toBytes(System.currentTimeMillis()));\n      writer.close();\n    }\n  }","commit_id":"191ba57a27dd195187fa4dd248d1ce02345e5b1a","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Simple end-to-end test\n   * @throws Exception\n   */\n  @Test\n  public void testWALPlayer() throws Exception {\n    final byte[] TABLENAME1 = Bytes.toBytes(\"testWALPlayer1\");\n    final byte[] TABLENAME2 = Bytes.toBytes(\"testWALPlayer2\");\n    final byte[] FAMILY = Bytes.toBytes(\"family\");\n    final byte[] COLUMN1 = Bytes.toBytes(\"c1\");\n    final byte[] COLUMN2 = Bytes.toBytes(\"c2\");\n    final byte[] ROW = Bytes.toBytes(\"row\");\n    HTable t1 = TEST_UTIL.createTable(TABLENAME1, FAMILY);\n    HTable t2 = TEST_UTIL.createTable(TABLENAME2, FAMILY);\n\n    // put a row into the first table\n    Put p = new Put(ROW);\n    p.add(FAMILY, COLUMN1, COLUMN1);\n    p.add(FAMILY, COLUMN2, COLUMN2);\n    t1.put(p);\n    // delete one column\n    Delete d = new Delete(ROW);\n    d.deleteColumns(FAMILY, COLUMN1);\n    t1.delete(d);\n\n    // replay the WAL, map table 1 to table 2\n    HLog log = cluster.getRegionServer(0).getWAL();\n    log.rollWriter();\n    String walInputDir = new Path(cluster.getMaster().getMasterFileSystem()\n        .getRootDir(), HConstants.HREGION_LOGDIR_NAME).toString();\n\n    WALPlayer player = new WALPlayer(TEST_UTIL.getConfiguration());\n    assertEquals(0, player.run(new String[] { walInputDir, Bytes.toString(TABLENAME1),\n        Bytes.toString(TABLENAME2) }));\n\n    // verify the WAL was player into table 2\n    Get g = new Get(ROW);\n    Result r = t2.get(g);\n    assertEquals(1, r.size());\n    assertTrue(Bytes.equals(COLUMN2, r.raw()[0].getQualifier()));\n  }","id":73505,"modified_method":"/**\n   * Simple end-to-end test\n   * @throws Exception\n   */\n  @Test\n  public void testWALPlayer() throws Exception {\n    final byte[] TABLENAME1 = Bytes.toBytes(\"testWALPlayer1\");\n    final byte[] TABLENAME2 = Bytes.toBytes(\"testWALPlayer2\");\n    final byte[] FAMILY = Bytes.toBytes(\"family\");\n    final byte[] COLUMN1 = Bytes.toBytes(\"c1\");\n    final byte[] COLUMN2 = Bytes.toBytes(\"c2\");\n    final byte[] ROW = Bytes.toBytes(\"row\");\n    HTable t1 = TEST_UTIL.createTable(TABLENAME1, FAMILY);\n    HTable t2 = TEST_UTIL.createTable(TABLENAME2, FAMILY);\n\n    // put a row into the first table\n    Put p = new Put(ROW);\n    p.add(FAMILY, COLUMN1, COLUMN1);\n    p.add(FAMILY, COLUMN2, COLUMN2);\n    t1.put(p);\n    // delete one column\n    Delete d = new Delete(ROW);\n    d.deleteColumns(FAMILY, COLUMN1);\n    t1.delete(d);\n\n    // replay the WAL, map table 1 to table 2\n    HLog log = cluster.getRegionServer(0).getWAL();\n    log.rollWriter();\n    String walInputDir = new Path(cluster.getMaster().getMasterFileSystem()\n        .getRootDir(), HConstants.HREGION_LOGDIR_NAME).toString();\n\n    Configuration configuration= TEST_UTIL.getConfiguration();\n    WALPlayer player = new WALPlayer(configuration);\n    String optionName=\"_test_.name\";\n    configuration.set(optionName, \"1000\");\n    player.setupTime(configuration, optionName);\n    assertEquals(1000,configuration.getLong(optionName,0));\n    assertEquals(0, player.run(new String[] { walInputDir, Bytes.toString(TABLENAME1),\n        Bytes.toString(TABLENAME2) }));\n\n    \n    // verify the WAL was player into table 2\n    Get g = new Get(ROW);\n    Result r = t2.get(g);\n    assertEquals(1, r.size());\n    assertTrue(Bytes.equals(COLUMN2, r.raw()[0].getQualifier()));\n  }","commit_id":"191ba57a27dd195187fa4dd248d1ce02345e5b1a","url":"https://github.com/apache/hbase"},{"original_method":"@NotNull\n    private JsConfig getConfig() {\n        CompilerConfiguration configuration = getEnvironment().getConfiguration().copy();\n        configuration.put(CommonConfigurationKeys.DISABLE_INLINE, true);\n        return new LibrarySourcesConfig.Builder(getProject(), configuration, \"testModule\", LibrarySourcesConfig.JS_STDLIB)\n                .isUnitTestConfig(true)\n                .build();\n    }","id":73506,"modified_method":"@NotNull\n    private JsConfig getConfig() {\n        CompilerConfiguration configuration = getEnvironment().getConfiguration().copy();\n        configuration.put(JSConfigurationKeys.MODULE_ID, \"testModule\");\n        configuration.put(JSConfigurationKeys.LIBRARY_FILES, LibrarySourcesConfig.JS_STDLIB);\n        configuration.put(CommonConfigurationKeys.DISABLE_INLINE, true);\n        configuration.put(JSConfigurationKeys.UNIT_TEST_CONFIG, true);\n        return new LibrarySourcesConfig(getProject(), configuration);\n    }","commit_id":"cad4b6973cca289ac44408b3737394088731142f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        config = new LibrarySourcesConfig.Builder(\n                getProject(), getEnvironment().getConfiguration(), \"module\", LibrarySourcesConfig.JS_STDLIB\n        ).build();\n    }","id":73507,"modified_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        CompilerConfiguration configuration = getEnvironment().getConfiguration().copy();\n        configuration.put(JSConfigurationKeys.MODULE_ID, \"module\");\n        configuration.put(JSConfigurationKeys.LIBRARY_FILES, LibrarySourcesConfig.JS_STDLIB);\n        config = new LibrarySourcesConfig(getProject(), configuration);\n    }","commit_id":"cad4b6973cca289ac44408b3737394088731142f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private JsConfig createConfig(\n            @NotNull Project project,\n            @NotNull String moduleId,\n            @NotNull EcmaVersion ecmaVersion,\n            @Nullable List<String> libraries,\n            @NotNull List<KtFile> files\n    ) {\n        CompilerConfiguration configuration = getEnvironment().getConfiguration().copy();\n\n        for (KtFile file : files) {\n            String text = file.getText();\n\n            if (isDirectiveDefined(text, NO_INLINE_DIRECTIVE)) {\n                configuration.put(CommonConfigurationKeys.DISABLE_INLINE, true);\n                break;\n            }\n        }\n\n        List<String> librariesWithStdlib = new ArrayList<String>(LibrarySourcesConfig.JS_STDLIB);\n        if (libraries != null) {\n            librariesWithStdlib.addAll(libraries);\n        }\n\n        return new LibrarySourcesConfig.Builder(project, configuration, moduleId, librariesWithStdlib)\n                .ecmaVersion(ecmaVersion)\n                .sourceMap(shouldGenerateSourceMap())\n                .isUnitTestConfig(shouldBeTranslateAsUnitTestClass())\n                .metaInfo(shouldGenerateMetaInfo())\n                .build();\n    }","id":73508,"modified_method":"@NotNull\n    private JsConfig createConfig(\n            @NotNull Project project,\n            @NotNull String moduleId,\n            @NotNull EcmaVersion ecmaVersion,\n            @Nullable List<String> libraries,\n            @NotNull List<KtFile> files\n    ) {\n        CompilerConfiguration configuration = getEnvironment().getConfiguration().copy();\n\n        configuration.put(CommonConfigurationKeys.DISABLE_INLINE, hasNoInline(files));\n\n        List<String> librariesWithStdlib = new ArrayList<String>(LibrarySourcesConfig.JS_STDLIB);\n        if (libraries != null) {\n            librariesWithStdlib.addAll(libraries);\n        }\n        configuration.put(JSConfigurationKeys.LIBRARY_FILES, librariesWithStdlib);\n\n        configuration.put(JSConfigurationKeys.MODULE_ID, moduleId);\n        configuration.put(JSConfigurationKeys.TARGET, ecmaVersion);\n\n        configuration.put(JSConfigurationKeys.SOURCE_MAP, shouldGenerateSourceMap());\n        configuration.put(JSConfigurationKeys.META_INFO, shouldGenerateMetaInfo());\n\n        configuration.put(JSConfigurationKeys.UNIT_TEST_CONFIG, shouldBeTranslateAsUnitTestClass());\n\n        return new LibrarySourcesConfig(project, configuration);\n    }","commit_id":"cad4b6973cca289ac44408b3737394088731142f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public List<KtFile> getSourceFilesFromLibraries() {\n        init();\n        return sourceFilesFromLibraries;\n    }","id":73509,"modified_method":"@NotNull\n    private List<KtFile> getSourceFilesFromLibraries() {\n        init();\n        return sourceFilesFromLibraries;\n    }","commit_id":"cad4b6973cca289ac44408b3737394088731142f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected JsConfig(\n            @NotNull Project project,\n            @NotNull CompilerConfiguration configuration,\n            @NotNull String moduleId,\n            @NotNull EcmaVersion ecmaVersion,\n            boolean sourcemap,\n            boolean metaInfo,\n            boolean kjsm\n    ) {\n        this.project = project;\n        this.configuration = configuration;\n        this.target = ecmaVersion;\n        this.moduleId = moduleId;\n        this.sourcemap = sourcemap;\n        this.metaInfo = metaInfo;\n        this.kjsm = kjsm;\n    }","id":73510,"modified_method":"protected JsConfig(@NotNull Project project, @NotNull CompilerConfiguration configuration) {\n        this.project = project;\n        this.configuration = configuration;\n    }","commit_id":"cad4b6973cca289ac44408b3737394088731142f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public String getModuleId() {\n        return moduleId;\n    }","id":73511,"modified_method":"@NotNull\n    public String getModuleId() {\n        return configuration.getNotNull(JSConfigurationKeys.MODULE_ID);\n    }","commit_id":"cad4b6973cca289ac44408b3737394088731142f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    protected ExitCode doExecute(\n            @NotNull K2JSCompilerArguments arguments, @NotNull CompilerConfiguration configuration, @NotNull Disposable rootDisposable\n    ) {\n        final MessageCollector messageCollector = configuration.getNotNull(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY);\n\n        if (arguments.freeArgs.isEmpty()) {\n            if (arguments.version) {\n                return OK;\n            }\n            messageCollector.report(CompilerMessageSeverity.ERROR, \"Specify at least one source file or directory\", NO_LOCATION);\n            return COMPILATION_ERROR;\n        }\n\n        ContentRootsKt.addKotlinSourceRoots(configuration, arguments.freeArgs);\n        KotlinCoreEnvironment environmentForJS =\n                KotlinCoreEnvironment.createForProduction(rootDisposable, configuration, EnvironmentConfigFiles.JS_CONFIG_FILES);\n\n        Project project = environmentForJS.getProject();\n        List<KtFile> sourcesFiles = environmentForJS.getSourceFiles();\n\n        if (arguments.outputFile == null) {\n            messageCollector.report(CompilerMessageSeverity.ERROR, \"Specify output file via -output\", CompilerMessageLocation.NO_LOCATION);\n            return ExitCode.COMPILATION_ERROR;\n        }\n\n        if (messageCollector.hasErrors()) {\n            return ExitCode.COMPILATION_ERROR;\n        }\n\n        if (sourcesFiles.isEmpty()) {\n            messageCollector.report(CompilerMessageSeverity.ERROR, \"No source files\", CompilerMessageLocation.NO_LOCATION);\n            return COMPILATION_ERROR;\n        }\n\n        if (arguments.verbose) {\n            reportCompiledSourcesList(messageCollector, sourcesFiles);\n        }\n\n        File outputFile = new File(arguments.outputFile);\n\n        JsConfig config = getConfig(project, configuration, arguments);\n        if (config.checkLibFilesAndReportErrors(new Function1<String, Unit>() {\n            @Override\n            public Unit invoke(String message) {\n                messageCollector.report(CompilerMessageSeverity.ERROR, message, CompilerMessageLocation.NO_LOCATION);\n                return Unit.INSTANCE;\n            }\n        })) {\n            return COMPILATION_ERROR;\n        }\n\n        AnalyzerWithCompilerReport analyzerWithCompilerReport = analyzeAndReportErrors(messageCollector, sourcesFiles, config);\n        if (analyzerWithCompilerReport.hasErrors()) {\n            return COMPILATION_ERROR;\n        }\n\n        ProgressIndicatorAndCompilationCanceledStatus.checkCanceled();\n\n        AnalysisResult analysisResult = analyzerWithCompilerReport.getAnalysisResult();\n        assert analysisResult instanceof JsAnalysisResult : \"analysisResult should be instance of JsAnalysisResult, but \" + analysisResult;\n        JsAnalysisResult jsAnalysisResult = (JsAnalysisResult) analysisResult;\n\n        File outputPrefixFile = null;\n        if (arguments.outputPrefix != null) {\n            outputPrefixFile = new File(arguments.outputPrefix);\n            if (!outputPrefixFile.exists()) {\n                messageCollector.report(CompilerMessageSeverity.ERROR,\n                                        \"Output prefix file '\" + arguments.outputPrefix + \"' not found\",\n                                        CompilerMessageLocation.NO_LOCATION);\n                return ExitCode.COMPILATION_ERROR;\n            }\n        }\n\n        File outputPostfixFile = null;\n        if (arguments.outputPostfix != null) {\n            outputPostfixFile = new File(arguments.outputPostfix);\n            if (!outputPostfixFile.exists()) {\n                messageCollector.report(CompilerMessageSeverity.ERROR,\n                                        \"Output postfix file '\" + arguments.outputPostfix + \"' not found\",\n                                        CompilerMessageLocation.NO_LOCATION);\n                return ExitCode.COMPILATION_ERROR;\n            }\n        }\n\n        MainCallParameters mainCallParameters = createMainCallParameters(arguments.main);\n        TranslationResult translationResult;\n\n        K2JSTranslator translator = new K2JSTranslator(config);\n        try {\n            //noinspection unchecked\n            translationResult = translator.translate(sourcesFiles, mainCallParameters, jsAnalysisResult);\n        }\n        catch (Exception e) {\n            throw ExceptionUtilsKt.rethrow(e);\n        }\n\n        ProgressIndicatorAndCompilationCanceledStatus.checkCanceled();\n\n        AnalyzerWithCompilerReport.Companion.reportDiagnostics(translationResult.getDiagnostics(), messageCollector);\n\n        if (!(translationResult instanceof TranslationResult.Success)) return ExitCode.COMPILATION_ERROR;\n\n        TranslationResult.Success successResult = (TranslationResult.Success) translationResult;\n        OutputFileCollection outputFiles = successResult.getOutputFiles(outputFile, outputPrefixFile, outputPostfixFile);\n\n        if (outputFile.isDirectory()) {\n            messageCollector.report(CompilerMessageSeverity.ERROR,\n                                    \"Cannot open output file '\" + outputFile.getPath() + \"': is a directory\",\n                                    CompilerMessageLocation.NO_LOCATION);\n            return ExitCode.COMPILATION_ERROR;\n        }\n\n        File outputDir = outputFile.getParentFile();\n        if (outputDir == null) {\n            outputDir = outputFile.getAbsoluteFile().getParentFile();\n        }\n\n        ProgressIndicatorAndCompilationCanceledStatus.checkCanceled();\n\n        OutputUtilsKt.writeAll(outputFiles, outputDir, messageCollector);\n\n        return OK;\n    }","id":73512,"modified_method":"@NotNull\n    @Override\n    protected ExitCode doExecute(\n            @NotNull K2JSCompilerArguments arguments, @NotNull CompilerConfiguration configuration, @NotNull Disposable rootDisposable\n    ) {\n        final MessageCollector messageCollector = configuration.getNotNull(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY);\n\n        if (arguments.freeArgs.isEmpty()) {\n            if (arguments.version) {\n                return OK;\n            }\n            messageCollector.report(CompilerMessageSeverity.ERROR, \"Specify at least one source file or directory\", NO_LOCATION);\n            return COMPILATION_ERROR;\n        }\n\n        ContentRootsKt.addKotlinSourceRoots(configuration, arguments.freeArgs);\n        KotlinCoreEnvironment environmentForJS =\n                KotlinCoreEnvironment.createForProduction(rootDisposable, configuration, EnvironmentConfigFiles.JS_CONFIG_FILES);\n\n        Project project = environmentForJS.getProject();\n        List<KtFile> sourcesFiles = environmentForJS.getSourceFiles();\n\n        if (arguments.outputFile == null) {\n            messageCollector.report(CompilerMessageSeverity.ERROR, \"Specify output file via -output\", CompilerMessageLocation.NO_LOCATION);\n            return ExitCode.COMPILATION_ERROR;\n        }\n\n        if (messageCollector.hasErrors()) {\n            return ExitCode.COMPILATION_ERROR;\n        }\n\n        if (sourcesFiles.isEmpty()) {\n            messageCollector.report(CompilerMessageSeverity.ERROR, \"No source files\", CompilerMessageLocation.NO_LOCATION);\n            return COMPILATION_ERROR;\n        }\n\n        if (arguments.verbose) {\n            reportCompiledSourcesList(messageCollector, sourcesFiles);\n        }\n\n        File outputFile = new File(arguments.outputFile);\n\n        JsConfig config = new LibrarySourcesConfig(project, configuration);\n        if (config.checkLibFilesAndReportErrors(new Function1<String, Unit>() {\n            @Override\n            public Unit invoke(String message) {\n                messageCollector.report(CompilerMessageSeverity.ERROR, message, CompilerMessageLocation.NO_LOCATION);\n                return Unit.INSTANCE;\n            }\n        })) {\n            return COMPILATION_ERROR;\n        }\n\n        AnalyzerWithCompilerReport analyzerWithCompilerReport = analyzeAndReportErrors(messageCollector, sourcesFiles, config);\n        if (analyzerWithCompilerReport.hasErrors()) {\n            return COMPILATION_ERROR;\n        }\n\n        ProgressIndicatorAndCompilationCanceledStatus.checkCanceled();\n\n        AnalysisResult analysisResult = analyzerWithCompilerReport.getAnalysisResult();\n        assert analysisResult instanceof JsAnalysisResult : \"analysisResult should be instance of JsAnalysisResult, but \" + analysisResult;\n        JsAnalysisResult jsAnalysisResult = (JsAnalysisResult) analysisResult;\n\n        File outputPrefixFile = null;\n        if (arguments.outputPrefix != null) {\n            outputPrefixFile = new File(arguments.outputPrefix);\n            if (!outputPrefixFile.exists()) {\n                messageCollector.report(CompilerMessageSeverity.ERROR,\n                                        \"Output prefix file '\" + arguments.outputPrefix + \"' not found\",\n                                        CompilerMessageLocation.NO_LOCATION);\n                return ExitCode.COMPILATION_ERROR;\n            }\n        }\n\n        File outputPostfixFile = null;\n        if (arguments.outputPostfix != null) {\n            outputPostfixFile = new File(arguments.outputPostfix);\n            if (!outputPostfixFile.exists()) {\n                messageCollector.report(CompilerMessageSeverity.ERROR,\n                                        \"Output postfix file '\" + arguments.outputPostfix + \"' not found\",\n                                        CompilerMessageLocation.NO_LOCATION);\n                return ExitCode.COMPILATION_ERROR;\n            }\n        }\n\n        MainCallParameters mainCallParameters = createMainCallParameters(arguments.main);\n        TranslationResult translationResult;\n\n        K2JSTranslator translator = new K2JSTranslator(config);\n        try {\n            //noinspection unchecked\n            translationResult = translator.translate(sourcesFiles, mainCallParameters, jsAnalysisResult);\n        }\n        catch (Exception e) {\n            throw ExceptionUtilsKt.rethrow(e);\n        }\n\n        ProgressIndicatorAndCompilationCanceledStatus.checkCanceled();\n\n        AnalyzerWithCompilerReport.Companion.reportDiagnostics(translationResult.getDiagnostics(), messageCollector);\n\n        if (!(translationResult instanceof TranslationResult.Success)) return ExitCode.COMPILATION_ERROR;\n\n        TranslationResult.Success successResult = (TranslationResult.Success) translationResult;\n        OutputFileCollection outputFiles = successResult.getOutputFiles(outputFile, outputPrefixFile, outputPostfixFile);\n\n        if (outputFile.isDirectory()) {\n            messageCollector.report(CompilerMessageSeverity.ERROR,\n                                    \"Cannot open output file '\" + outputFile.getPath() + \"': is a directory\",\n                                    CompilerMessageLocation.NO_LOCATION);\n            return ExitCode.COMPILATION_ERROR;\n        }\n\n        File outputDir = outputFile.getParentFile();\n        if (outputDir == null) {\n            outputDir = outputFile.getAbsoluteFile().getParentFile();\n        }\n\n        ProgressIndicatorAndCompilationCanceledStatus.checkCanceled();\n\n        OutputUtilsKt.writeAll(outputFiles, outputDir, messageCollector);\n\n        return OK;\n    }","commit_id":"cad4b6973cca289ac44408b3737394088731142f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static MainCallParameters createMainCallParameters(String main) {\n        if (K2JsArgumentConstants.NO_CALL.equals(main)) {\n            return MainCallParameters.noCall();\n        }\n        else {\n            return MainCallParameters.mainWithoutArguments();\n        }\n    }","id":73513,"modified_method":"private static MainCallParameters createMainCallParameters(String main) {\n        if (K2JsArgumentConstants.NO_CALL.equals(main)) {\n            return MainCallParameters.noCall();\n        }\n        else {\n            return MainCallParameters.mainWithoutArguments();\n        }\n    }","commit_id":"cad4b6973cca289ac44408b3737394088731142f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    protected void setupPlatformSpecificArgumentsAndServices(\n            @NotNull CompilerConfiguration configuration, @NotNull K2JSCompilerArguments arguments, @NotNull Services services\n    ) {\n        // No platform-specific arguments yet\n    }","id":73514,"modified_method":"@Override\n    protected void setupPlatformSpecificArgumentsAndServices(\n            @NotNull CompilerConfiguration configuration, @NotNull K2JSCompilerArguments arguments, @NotNull Services services\n    ) {\n        if (arguments.target != null) {\n            assert arguments.target == \"v5\" : \"Unsupported ECMA version: \" + arguments.target;\n        }\n        configuration.put(JSConfigurationKeys.TARGET, EcmaVersion.defaultVersion());\n\n        String moduleId = FileUtil.getNameWithoutExtension(new File(arguments.outputFile));\n        configuration.put(JSConfigurationKeys.MODULE_ID, moduleId);\n\n        if (arguments.sourceMap) {\n            configuration.put(JSConfigurationKeys.SOURCE_MAP, true);\n        }\n        if (arguments.metaInfo) {\n            configuration.put(JSConfigurationKeys.META_INFO, true);\n        }\n        if (arguments.kjsm) {\n            configuration.put(JSConfigurationKeys.KJSM, true);\n        }\n\n        List<String> libraryFiles = new SmartList<String>();\n        if (!arguments.noStdlib) {\n            libraryFiles.add(0, PathUtil.getKotlinPathsForCompiler().getJsStdLibJarPath().getAbsolutePath());\n        }\n\n        if (arguments.libraryFiles != null) {\n            ContainerUtil.addAllNotNull(libraryFiles, arguments.libraryFiles);\n        }\n\n        configuration.put(JSConfigurationKeys.LIBRARY_FILES, libraryFiles);\n    }","commit_id":"cad4b6973cca289ac44408b3737394088731142f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public List<String> getLibraries() {\n        return files;\n    }","id":73515,"modified_method":"@NotNull\n    public List<String> getLibraries() {\n        return getConfiguration().getList(JSConfigurationKeys.LIBRARY_FILES);\n    }","commit_id":"cad4b6973cca289ac44408b3737394088731142f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected static void setupPsiFile(PsiFile psiFile, String moduleName) {\n        psiFile.putUserData(EXTERNAL_MODULE_NAME, moduleName);\n    }","id":73516,"modified_method":"private static void setupPsiFile(PsiFile psiFile, String moduleName) {\n        psiFile.putUserData(EXTERNAL_MODULE_NAME, moduleName);\n    }","commit_id":"cad4b6973cca289ac44408b3737394088731142f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private boolean checkLibFilesAndReportErrors(@NotNull Function1<String, Unit> report, @Nullable Function2<String, VirtualFile, Unit> action) {\n        if (files.isEmpty()) {\n            return false;\n        }\n\n        VirtualFileSystem fileSystem = VirtualFileManager.getInstance().getFileSystem(StandardFileSystems.FILE_PROTOCOL);\n        VirtualFileSystem jarFileSystem = VirtualFileManager.getInstance().getFileSystem(StandardFileSystems.JAR_PROTOCOL);\n\n        for (String path : files) {\n            VirtualFile file;\n\n            File filePath = new File(path);\n            if (!filePath.exists()) {\n                report.invoke(\"Path '\" + path + \"' does not exist\");\n                return true;\n            }\n\n            if (path.endsWith(\".jar\") || path.endsWith(\".zip\")) {\n                file = jarFileSystem.findFileByPath(path + URLUtil.JAR_SEPARATOR);\n            }\n            else {\n                file = fileSystem.findFileByPath(path);\n            }\n\n            if (file == null) {\n                report.invoke(\"File '\" + path + \"' does not exist or could not be read\");\n                return true;\n            }\n\n            String moduleName;\n\n            if (isOldKotlinJavascriptLibrary(filePath)) {\n                moduleName = LibraryUtils.getKotlinJsModuleName(filePath);\n            }\n            else {\n                List<KotlinJavascriptMetadata> metadataList = KotlinJavascriptMetadataUtils.loadMetadata(filePath);\n                if (metadataList.isEmpty()) {\n                    report.invoke(\"'\" + path + \"' is not a valid Kotlin Javascript library\");\n                    return true;\n                }\n\n                for (KotlinJavascriptMetadata metadata : metadataList) {\n                    if (!metadata.isAbiVersionCompatible()) {\n                        report.invoke(\"File '\" + path + \"' was compiled with an incompatible version of Kotlin. \" +\n                                      \"Its ABI version is \" + metadata.getAbiVersion() +\n                                      \", expected ABI version is \" + KotlinJavascriptMetadataUtils.ABI_VERSION);\n                        return true;\n                    }\n                }\n\n                moduleName = null;\n            }\n\n            if (action != null) {\n                action.invoke(moduleName, file);\n            }\n        }\n\n        return false;\n    }","id":73517,"modified_method":"private boolean checkLibFilesAndReportErrors(@NotNull Function1<String, Unit> report, @Nullable Function2<String, VirtualFile, Unit> action) {\n        List<String> libraries = getLibraries();\n        if (libraries.isEmpty()) {\n            return false;\n        }\n\n        VirtualFileSystem fileSystem = VirtualFileManager.getInstance().getFileSystem(StandardFileSystems.FILE_PROTOCOL);\n        VirtualFileSystem jarFileSystem = VirtualFileManager.getInstance().getFileSystem(StandardFileSystems.JAR_PROTOCOL);\n\n        for (String path : libraries) {\n            VirtualFile file;\n\n            File filePath = new File(path);\n            if (!filePath.exists()) {\n                report.invoke(\"Path '\" + path + \"' does not exist\");\n                return true;\n            }\n\n            if (path.endsWith(\".jar\") || path.endsWith(\".zip\")) {\n                file = jarFileSystem.findFileByPath(path + URLUtil.JAR_SEPARATOR);\n            }\n            else {\n                file = fileSystem.findFileByPath(path);\n            }\n\n            if (file == null) {\n                report.invoke(\"File '\" + path + \"' does not exist or could not be read\");\n                return true;\n            }\n\n            String moduleName;\n\n            if (isOldKotlinJavascriptLibrary(filePath)) {\n                moduleName = LibraryUtils.getKotlinJsModuleName(filePath);\n            }\n            else {\n                List<KotlinJavascriptMetadata> metadataList = KotlinJavascriptMetadataUtils.loadMetadata(filePath);\n                if (metadataList.isEmpty()) {\n                    report.invoke(\"'\" + path + \"' is not a valid Kotlin Javascript library\");\n                    return true;\n                }\n\n                for (KotlinJavascriptMetadata metadata : metadataList) {\n                    if (!metadata.isAbiVersionCompatible()) {\n                        report.invoke(\"File '\" + path + \"' was compiled with an incompatible version of Kotlin. \" +\n                                      \"Its ABI version is \" + metadata.getAbiVersion() +\n                                      \", expected ABI version is \" + KotlinJavascriptMetadataUtils.ABI_VERSION);\n                        return true;\n                    }\n                }\n\n                moduleName = null;\n            }\n\n            if (action != null) {\n                action.invoke(moduleName, file);\n            }\n        }\n\n        return false;\n    }","commit_id":"cad4b6973cca289ac44408b3737394088731142f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    protected void init(@NotNull final List<KtFile> sourceFilesInLibraries, @NotNull final List<KotlinJavascriptMetadata> metadata) {\n        if (files.isEmpty()) return;\n\n        final PsiManager psiManager = PsiManager.getInstance(getProject());\n\n        Function1<String, Unit> report = new Function1<String, Unit>() {\n            @Override\n            public Unit invoke(String message) {\n                throw new IllegalStateException(message);\n            }\n        };\n\n        Function2<String, VirtualFile, Unit> action = new Function2<String, VirtualFile, Unit>() {\n            @Override\n            public Unit invoke(String moduleName, VirtualFile file) {\n                if (moduleName != null) {\n                    JetFileCollector jetFileCollector = new JetFileCollector(sourceFilesInLibraries, moduleName, psiManager);\n                    VfsUtilCore.visitChildrenRecursively(file, jetFileCollector);\n                }\n                else {\n                    String libraryPath = PathUtil.getLocalPath(file);\n                    assert libraryPath != null : \"libraryPath for \" + file + \" should not be null\";\n                    metadata.addAll(KotlinJavascriptMetadataUtils.loadMetadata(libraryPath));\n                }\n\n                return Unit.INSTANCE;\n            }\n        };\n\n        boolean hasErrors = checkLibFilesAndReportErrors(report, action);\n        assert !hasErrors : \"hasErrors should be false\";\n    }","id":73518,"modified_method":"@Override\n    protected void init(@NotNull final List<KtFile> sourceFilesInLibraries, @NotNull final List<KotlinJavascriptMetadata> metadata) {\n        if (getLibraries().isEmpty()) return;\n\n        final PsiManager psiManager = PsiManager.getInstance(getProject());\n\n        Function1<String, Unit> report = new Function1<String, Unit>() {\n            @Override\n            public Unit invoke(String message) {\n                throw new IllegalStateException(message);\n            }\n        };\n\n        Function2<String, VirtualFile, Unit> action = new Function2<String, VirtualFile, Unit>() {\n            @Override\n            public Unit invoke(String moduleName, VirtualFile file) {\n                if (moduleName != null) {\n                    JetFileCollector jetFileCollector = new JetFileCollector(sourceFilesInLibraries, moduleName, psiManager);\n                    VfsUtilCore.visitChildrenRecursively(file, jetFileCollector);\n                }\n                else {\n                    String libraryPath = PathUtil.getLocalPath(file);\n                    assert libraryPath != null : \"libraryPath for \" + file + \" should not be null\";\n                    metadata.addAll(KotlinJavascriptMetadataUtils.loadMetadata(libraryPath));\n                }\n\n                return Unit.INSTANCE;\n            }\n        };\n\n        boolean hasErrors = checkLibFilesAndReportErrors(report, action);\n        assert !hasErrors : \"hasErrors should be false\";\n    }","commit_id":"cad4b6973cca289ac44408b3737394088731142f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private LibrarySourcesConfig(\n            @NotNull Project project,\n            @NotNull CompilerConfiguration configuration,\n            @NotNull String moduleId,\n            @NotNull List<String> files,\n            @NotNull EcmaVersion ecmaVersion,\n            boolean sourceMap,\n            boolean isUnitTestConfig,\n            boolean metaInfo,\n            boolean kjsm\n    ) {\n        super(project, configuration, moduleId, ecmaVersion, sourceMap, metaInfo, kjsm);\n        this.files = files;\n        this.isUnitTestConfig = isUnitTestConfig;\n    }","id":73519,"modified_method":"public LibrarySourcesConfig(@NotNull Project project, @NotNull CompilerConfiguration configuration) {\n        super(project, configuration);\n    }","commit_id":"cad4b6973cca289ac44408b3737394088731142f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected static KtFile getJetFileByVirtualFile(VirtualFile file, String moduleName, PsiManager psiManager) {\n        PsiFile psiFile = psiManager.findFile(file);\n        assert psiFile != null;\n\n        setupPsiFile(psiFile, moduleName);\n        return (KtFile) psiFile;\n    }","id":73520,"modified_method":"private static KtFile getJetFileByVirtualFile(VirtualFile file, String moduleName, PsiManager psiManager) {\n        PsiFile psiFile = psiManager.findFile(file);\n        assert psiFile != null;\n\n        setupPsiFile(psiFile, moduleName);\n        return (KtFile) psiFile;\n    }","commit_id":"cad4b6973cca289ac44408b3737394088731142f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void mayBeGenerateTests(\n            @NotNull Collection<KtFile> files, @NotNull JsConfig config, @NotNull JsBlock rootBlock, @NotNull TranslationContext context\n    ) {\n        JSTester tester = config.isTestConfig() ? new JSRhinoUnitTester() : new QUnitTester();\n        tester.initialize(context, rootBlock);\n        JSTestGenerator.generateTestCalls(context, files, tester);\n        tester.deinitialize();\n    }","id":73521,"modified_method":"private static void mayBeGenerateTests(\n            @NotNull Collection<KtFile> files, @NotNull JsConfig config, @NotNull JsBlock rootBlock, @NotNull TranslationContext context\n    ) {\n        JSTester tester =\n                config.getConfiguration().getBoolean(JSConfigurationKeys.UNIT_TEST_CONFIG) ? new JSRhinoUnitTester() : new QUnitTester();\n        tester.initialize(context, rootBlock);\n        JSTestGenerator.generateTestCalls(context, files, tester);\n        tester.deinitialize();\n    }","commit_id":"cad4b6973cca289ac44408b3737394088731142f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@BeforeClass\n  public static void init() throws Exception {\n    HBaseTestBase.startHBase();\n    CConfiguration cConf = CConfiguration.create();\n    Injector injector = Guice.createInjector(new ConfigModule(cConf, HBaseTestBase.getConfiguration()),\n                                             new DataFabricDistributedModule(HBaseTestBase.getConfiguration()),\n                                             new LocationRuntimeModule().getDistributedModules(),\n                                             new HbaseTableTestModule());\n\n    tableFactory = injector.getInstance(MetricsTableFactory.class);\n  }","id":73522,"modified_method":"@BeforeClass\n  public static void init() throws Exception {\n    HBaseTestBase.startHBase();\n    CConfiguration cConf = CConfiguration.create();\n    cConf.unset(Constants.CFG_HDFS_USER);\n    Injector injector = Guice.createInjector(new ConfigModule(cConf, HBaseTestBase.getConfiguration()),\n                                             new DataFabricDistributedModule(cConf, HBaseTestBase.getConfiguration()),\n                                             new LocationRuntimeModule().getDistributedModules(),\n                                             new HbaseTableTestModule());\n\n    tableFactory = injector.getInstance(MetricsTableFactory.class);\n  }","commit_id":"d21d71d8000219eee1175c75ad52f8405df01836","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected DataSetManager getMetricsTableManager() throws Exception {\n    return new HBaseMetricsTableManager(hConf);\n  }","id":73523,"modified_method":"@Override\n  protected DataSetManager getMetricsTableManager() throws Exception {\n    return new HBaseMetricsTableManager(cConf, hConf, locationFactory);\n  }","commit_id":"d21d71d8000219eee1175c75ad52f8405df01836","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected DataSetManager getOcTableManager() throws Exception {\n    return new HBaseOcTableManager(hConf);\n  }","id":73524,"modified_method":"@Override\n  protected DataSetManager getOcTableManager() throws Exception {\n    return new HBaseOcTableManager(cConf, hConf, locationFactory);\n  }","commit_id":"d21d71d8000219eee1175c75ad52f8405df01836","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void beforeClass() throws Exception {\n    NamespacingDataSetAccessorTest.beforeClass();\n    HBaseTestBase.startHBase();\n    dsAccessor = new DistributedDataSetAccessor(conf, HBaseTestBase.getConfiguration());\n  }","id":73525,"modified_method":"@BeforeClass\n  public static void beforeClass() throws Exception {\n    NamespacingDataSetAccessorTest.beforeClass();\n    HBaseTestBase.startHBase();\n    Configuration hConf = HBaseTestBase.getConfiguration();\n    dsAccessor = new DistributedDataSetAccessor(conf, hConf, new HDFSLocationFactory(hConf));\n  }","commit_id":"d21d71d8000219eee1175c75ad52f8405df01836","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void init() throws Exception {\n    HBaseTestBase.startHBase();\n    Injector injector = Guice.createInjector(new ConfigModule(CConfiguration.create(),\n                                                              HBaseTestBase.getConfiguration()),\n                                             new DataFabricDistributedModule(HBaseTestBase.getConfiguration()),\n                                             new LocationRuntimeModule().getDistributedModules());\n\n    accessor = injector.getInstance(DataSetAccessor.class);\n  }","id":73526,"modified_method":"@BeforeClass\n  public static void init() throws Exception {\n    HBaseTestBase.startHBase();\n    CConfiguration cConf = CConfiguration.create();\n    cConf.unset(Constants.CFG_HDFS_USER);\n\n    Injector injector = Guice.createInjector(new ConfigModule(cConf, HBaseTestBase.getConfiguration()),\n                                             new DataFabricDistributedModule(cConf, HBaseTestBase.getConfiguration()),\n                                             new LocationRuntimeModule().getDistributedModules());\n\n    accessor = injector.getInstance(DataSetAccessor.class);\n  }","commit_id":"d21d71d8000219eee1175c75ad52f8405df01836","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void setupDataFabric() throws Exception {\n    HBaseTestBase.startHBase();\n    DataFabricDistributedModule dfModule = new DataFabricDistributedModule(HBaseTestBase.getConfiguration());\n    Module module = Modules.override(dfModule).with(\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          // prevent going through network for transactions\n          bind(TransactionSystemClient.class).to(InMemoryTxSystemClient.class);\n        }\n      });\n    dfModule.getConfiguration().set(Constants.Zookeeper.QUORUM, HBaseTestBase.getZkConnectionString());\n    // tests should interact with HDFS as the current user\n    dfModule.getConfiguration().unset(Constants.CFG_HDFS_USER);\n    injector = Guice.createInjector(module,\n                                    new ConfigModule(dfModule.getConfiguration(),\n                                                     HBaseTestBase.getConfiguration()),\n                                    new LocationRuntimeModule().getInMemoryModules());\n  }","id":73527,"modified_method":"@BeforeClass\n  public static void setupDataFabric() throws Exception {\n    HBaseTestBase.startHBase();\n    CConfiguration conf = CConfiguration.create();\n    conf.set(Constants.Zookeeper.QUORUM, HBaseTestBase.getZkConnectionString());\n    // tests should interact with HDFS as the current user\n    conf.unset(Constants.CFG_HDFS_USER);\n    DataFabricDistributedModule dfModule = new DataFabricDistributedModule(conf, HBaseTestBase.getConfiguration());\n    Module module = Modules.override(dfModule).with(\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          // prevent going through network for transactions\n          bind(TransactionSystemClient.class).to(InMemoryTxSystemClient.class);\n        }\n      });\n    injector = Guice.createInjector(module,\n                                    new ConfigModule(conf, HBaseTestBase.getConfiguration()),\n                                    new LocationRuntimeModule().getDistributedModules());\n  }","commit_id":"d21d71d8000219eee1175c75ad52f8405df01836","url":"https://github.com/caskdata/cdap"},{"original_method":"public HBaseMetricsTableManager(Configuration hConf) throws IOException {\n    super(hConf);\n  }","id":73528,"modified_method":"public HBaseMetricsTableManager(CConfiguration conf, Configuration hConf, LocationFactory locationFactory)\n      throws IOException {\n    super(conf, hConf, locationFactory);\n  }","commit_id":"d21d71d8000219eee1175c75ad52f8405df01836","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void setup() throws Exception {\n    HBaseTestBase.startHBase();\n    Injector injector = Guice.createInjector(new DataFabricDistributedModule(HBaseTestBase.getConfiguration()),\n                                             new LocationRuntimeModule().getDistributedModules());\n    dsAccessor = injector.getInstance(DataSetAccessor.class);\n  }","id":73529,"modified_method":"@BeforeClass\n  public static void setup() throws Exception {\n    HBaseTestBase.startHBase();\n    CConfiguration conf = CConfiguration.create();\n    conf.unset(Constants.CFG_HDFS_USER);\n    Injector injector = Guice.createInjector(new DataFabricDistributedModule(conf, HBaseTestBase.getConfiguration()),\n                                             new ConfigModule(conf, HBaseTestBase.getConfiguration()),\n                                             new LocationRuntimeModule().getDistributedModules());\n    dsAccessor = injector.getInstance(DataSetAccessor.class);\n  }","commit_id":"d21d71d8000219eee1175c75ad52f8405df01836","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected DataSetManager getTableManager() throws Exception {\n    return new HBaseOcTableManager(HBaseTestBase.getConfiguration());\n  }","id":73530,"modified_method":"@Override\n  protected DataSetManager getTableManager() throws Exception {\n    Configuration hConf = HBaseTestBase.getConfiguration();\n    return new HBaseOcTableManager(CConfiguration.create(), hConf, new HDFSLocationFactory(hConf));\n  }","commit_id":"d21d71d8000219eee1175c75ad52f8405df01836","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void create(String name, Properties props) throws Exception {\n    final String tableName = HBaseTableUtil.getHBaseTableName(name);\n\n    final HColumnDescriptor columnDescriptor = new HColumnDescriptor(DATA_COLUMN_FAMILY);\n    // todo: make stuff configurable\n    // todo: using snappy compression for some reason breaks mini-hbase cluster (i.e. unit-test doesn't work)\n    //    columnDescriptor.setCompressionType(Compression.Algorithm.SNAPPY);\n    columnDescriptor.setMaxVersions(100);\n    columnDescriptor.setBloomFilterType(StoreFile.BloomType.ROW);\n\n    // todo: find a better way to make this configurable\n    if (props != null) {\n      String ttlProp = props.getProperty(HBaseTableUtil.PROPERTY_TTL);\n      if (ttlProp != null) {\n        int ttl = Integer.parseInt(ttlProp);\n        if (ttl > 0) {\n          columnDescriptor.setTimeToLive(ttl);\n        }\n      }\n    }\n\n    final HTableDescriptor tableDescriptor = new HTableDescriptor(tableName);\n    tableDescriptor.addFamily(columnDescriptor);\n\n    HBaseTableUtil.createTableIfNotExists(admin, tableName, tableDescriptor);\n  }","id":73531,"modified_method":"@Override\n  public void create(String name, Properties props) throws Exception {\n    final String tableName = HBaseTableUtil.getHBaseTableName(name);\n\n    final HColumnDescriptor columnDescriptor = new HColumnDescriptor(DATA_COLUMN_FAMILY);\n    // todo: make stuff configurable\n    // todo: using snappy compression for some reason breaks mini-hbase cluster (i.e. unit-test doesn't work)\n    //    columnDescriptor.setCompressionType(Compression.Algorithm.SNAPPY);\n    columnDescriptor.setMaxVersions(100);\n    columnDescriptor.setBloomFilterType(StoreFile.BloomType.ROW);\n\n    // todo: find a better way to make this configurable\n    if (props != null) {\n      String ttlProp = props.getProperty(HBaseTableUtil.PROPERTY_TTL);\n      if (ttlProp != null) {\n        int ttl = Integer.parseInt(ttlProp);\n        if (ttl > 0) {\n          columnDescriptor.setTimeToLive(ttl);\n        }\n      }\n    }\n\n    final HTableDescriptor tableDescriptor = new HTableDescriptor(tableName);\n    tableDescriptor.addFamily(columnDescriptor);\n    // package and add the transaction cleanup coprocessor\n    Location jarDir = locationFactory.create(conf.get(Constants.CFG_HDFS_LIB_DIR));\n    Location jarFile = HBaseTableUtil.createCoProcessorJar(\"table\", jarDir, TransactionDataJanitor.class);\n    tableDescriptor.addCoprocessor(TransactionDataJanitor.class.getName(),\n                                   new Path(jarFile.toURI()), Coprocessor.PRIORITY_USER, null);\n\n    HBaseTableUtil.createTableIfNotExists(admin, tableName, tableDescriptor);\n  }","commit_id":"d21d71d8000219eee1175c75ad52f8405df01836","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public HBaseOcTableManager(Configuration hConf)\n    throws IOException {\n    admin = new HBaseAdmin(hConf);\n  }","id":73532,"modified_method":"@Inject\n  public HBaseOcTableManager(CConfiguration conf, Configuration hConf, LocationFactory locationFactory)\n    throws IOException {\n    this.conf = conf;\n    this.admin = new HBaseAdmin(hConf);\n    this.locationFactory = locationFactory;\n  }","commit_id":"d21d71d8000219eee1175c75ad52f8405df01836","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void create(String name) throws Exception {\n    // NOTE: as of now, all queues stored in same table\n    byte[] tableNameBytes = Bytes.toBytes(tableName);\n    Location jarDir = locationFactory.create(cConf.get(QueueConstants.ConfigKeys.QUEUE_TABLE_COPROCESSOR_DIR,\n                                                       QueueConstants.DEFAULT_QUEUE_TABLE_COPROCESSOR_DIR));\n    int splits = cConf.getInt(QueueConstants.ConfigKeys.QUEUE_TABLE_PRESPLITS,\n                              QueueConstants.DEFAULT_QUEUE_TABLE_PRESPLITS);\n    HBaseTableUtil.createTableIfNotExists(admin, tableNameBytes, QueueConstants.COLUMN_FAMILY,\n                                           QueueConstants.MAX_CREATE_TABLE_WAIT,\n                                           splits, HBaseTableUtil.createCoProcessorJar(jarDir, HBaseQueueRegionObserver.class),\n                                           HBaseQueueRegionObserver.class.getName());\n  }","id":73533,"modified_method":"@Override\n  public void create(String name) throws Exception {\n    // NOTE: as of now, all queues stored in same table\n    byte[] tableNameBytes = Bytes.toBytes(tableName);\n    Location jarDir = locationFactory.create(cConf.get(QueueConstants.ConfigKeys.QUEUE_TABLE_COPROCESSOR_DIR,\n                                                       QueueConstants.DEFAULT_QUEUE_TABLE_COPROCESSOR_DIR));\n    int splits = cConf.getInt(QueueConstants.ConfigKeys.QUEUE_TABLE_PRESPLITS,\n                              QueueConstants.DEFAULT_QUEUE_TABLE_PRESPLITS);\n    HBaseTableUtil.createTableIfNotExists(admin, tableNameBytes, QueueConstants.COLUMN_FAMILY,\n        QueueConstants.MAX_CREATE_TABLE_WAIT, splits,\n        HBaseTableUtil.createCoProcessorJar(\"queue\", jarDir, HBaseQueueRegionObserver.class,\n                                            TransactionDataJanitor.class),\n        HBaseQueueRegionObserver.class.getName(), TransactionDataJanitor.class.getName());\n  }","commit_id":"d21d71d8000219eee1175c75ad52f8405df01836","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void init() throws Exception {\n    // Start hbase\n    HBaseTestBase.startHBase();\n\n    // Customize test configuration\n    cConf = new CConfiguration();\n    cConf.set(Constants.Zookeeper.QUORUM, HBaseTestBase.getZkConnectionString());\n    cConf.set(Constants.Transaction.Service.CFG_DATA_TX_BIND_PORT,\n              Integer.toString(Networks.getRandomPort()));\n    cConf.set(DataSetAccessor.CFG_TABLE_PREFIX, \"test\");\n    cConf.setBoolean(Constants.Transaction.Manager.CFG_DO_PERSIST, false);\n\n    final DataFabricDistributedModule dfModule =\n      new DataFabricDistributedModule(cConf, HBaseTestBase.getConfiguration());\n    // turn off persistence in tx manager to get rid of ugly zookeeper warnings\n    final Module dataFabricModule = Modules.override(dfModule).with(\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          bind(TransactionStateStorage.class).to(NoOpTransactionStateStorage.class);\n        }\n      });\n\n    ZKClientService zkClientService = getZkClientService();\n    zkClientService.start();\n\n    final Injector injector = Guice.createInjector(dataFabricModule,\n                                                   new DiscoveryRuntimeModule(zkClientService).getDistributedModules(),\n                                                   new AbstractModule() {\n\n      @Override\n      protected void configure() {\n        try {\n          bind(LocationFactory.class).toInstance(new LocalLocationFactory(tmpFolder.newFolder()));\n        } catch (IOException e) {\n          throw Throwables.propagate(e);\n        }\n      }\n    });\n\n    txService = injector.getInstance(TransactionService.class);\n    Thread t = new Thread() {\n      @Override\n      public void run() {\n        txService.start();\n      }\n    };\n    t.start();\n\n    txSystemClient = injector.getInstance(TransactionSystemClient.class);\n    queueClientFactory = injector.getInstance(QueueClientFactory.class);\n    queueAdmin = injector.getInstance(QueueAdmin.class);\n    executorFactory = injector.getInstance(TransactionExecutorFactory.class);\n  }","id":73534,"modified_method":"@BeforeClass\n  public static void init() throws Exception {\n    // Start hbase\n    HBaseTestBase.startHBase();\n\n    // Customize test configuration\n    cConf = CConfiguration.create();\n    cConf.set(Constants.Zookeeper.QUORUM, HBaseTestBase.getZkConnectionString());\n    cConf.set(Constants.Transaction.Service.CFG_DATA_TX_BIND_PORT,\n              Integer.toString(Networks.getRandomPort()));\n    cConf.set(DataSetAccessor.CFG_TABLE_PREFIX, \"test\");\n    cConf.setBoolean(Constants.Transaction.Manager.CFG_DO_PERSIST, false);\n    cConf.unset(Constants.CFG_HDFS_USER);\n\n    final DataFabricDistributedModule dfModule =\n      new DataFabricDistributedModule(cConf, HBaseTestBase.getConfiguration());\n    // turn off persistence in tx manager to get rid of ugly zookeeper warnings\n    final Module dataFabricModule = Modules.override(dfModule).with(\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          bind(TransactionStateStorage.class).to(NoOpTransactionStateStorage.class);\n        }\n      });\n\n    ZKClientService zkClientService = getZkClientService();\n    zkClientService.start();\n\n    final Injector injector = Guice.createInjector(dataFabricModule,\n                                                   new DiscoveryRuntimeModule(zkClientService).getDistributedModules(),\n                                                   new AbstractModule() {\n\n      @Override\n      protected void configure() {\n        try {\n          bind(LocationFactory.class).toInstance(new LocalLocationFactory(tmpFolder.newFolder()));\n        } catch (IOException e) {\n          throw Throwables.propagate(e);\n        }\n      }\n    });\n\n    txService = injector.getInstance(TransactionService.class);\n    Thread t = new Thread() {\n      @Override\n      public void run() {\n        txService.start();\n      }\n    };\n    t.start();\n\n    txSystemClient = injector.getInstance(TransactionSystemClient.class);\n    queueClientFactory = injector.getInstance(QueueClientFactory.class);\n    queueAdmin = injector.getInstance(QueueAdmin.class);\n    executorFactory = injector.getInstance(TransactionExecutorFactory.class);\n  }","commit_id":"d21d71d8000219eee1175c75ad52f8405df01836","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Creates a jar files container coprocessors that are using by queue.\n   * @param jarDir\n   * @return The Path of the jar file on the file system.\n   * @throws java.io.IOException\n   */\n  public static Location createCoProcessorJar(Location jarDir, Class<? extends Coprocessor> clz) throws IOException {\n    final Hasher hasher = Hashing.md5().newHasher();\n    final byte[] buffer = new byte[COPY_BUFFER_SIZE];\n    File jarFile = File.createTempFile(\"queue\", \".jar\");\n    try {\n      final JarOutputStream jarOutput = new JarOutputStream(new FileOutputStream(jarFile));\n      try {\n        Dependencies.findClassDependencies(clz.getClassLoader(), new Dependencies.ClassAcceptor() {\n          @Override\n          public boolean accept(String className, final URL classUrl, URL classPathUrl) {\n            // Assuming the endpoint and protocol class doesn't have dependencies\n            // other than those comes with HBase and Java.\n            if (className.startsWith(\"com.continuuity\")) {\n              try {\n                jarOutput.putNextEntry(new JarEntry(className.replace('.', File.separatorChar) + \".class\"));\n                InputStream inputStream = classUrl.openStream();\n\n                try {\n                  int len = inputStream.read(buffer);\n                  while (len >= 0) {\n                    hasher.putBytes(buffer, 0, len);\n                    jarOutput.write(buffer, 0, len);\n                    len = inputStream.read(buffer);\n                  }\n                } finally {\n                  inputStream.close();\n                }\n                return true;\n              } catch (IOException e) {\n                throw Throwables.propagate(e);\n              }\n            }\n            return false;\n          }\n        }, clz.getName());\n      } finally {\n        jarOutput.close();\n      }\n      // Copy jar file into HDFS\n      // Target path is the jarDir + jarMD5.jar\n      final Location targetPath = jarDir.append(\"coprocessor\" + hasher.hash().toString() + \".jar\");\n\n      // If the file exists and having same since, assume the file doesn't changed\n      if (targetPath.exists() && targetPath.length() == jarFile.length()) {\n        return targetPath;\n      }\n\n      // Copy jar file into filesystem\n      if (!jarDir.mkdirs()) {\n        throw new IOException(\"Fails to create directory: \" + jarDir.toURI());\n      }\n      Files.copy(jarFile, new OutputSupplier<OutputStream>() {\n        @Override\n        public OutputStream getOutput() throws IOException {\n          return targetPath.getOutputStream();\n        }\n      });\n      return targetPath;\n\n    } finally {\n      jarFile.delete();\n    }\n  }","id":73535,"modified_method":"/**\n   * Creates a jar files container coprocessors that are using by queue.\n   * @param jarDir\n   * @return The Path of the jar file on the file system.\n   * @throws java.io.IOException\n   */\n  public static Location createCoProcessorJar(String filePrefix, Location jarDir,\n                                              Class<? extends Coprocessor>... classes) throws IOException {\n    final Hasher hasher = Hashing.md5().newHasher();\n    final byte[] buffer = new byte[COPY_BUFFER_SIZE];\n    File jarFile = File.createTempFile(filePrefix, \".jar\");\n    try {\n      final JarOutputStream jarOutput = new JarOutputStream(new FileOutputStream(jarFile));\n      try {\n        final Map<String, URL> dependentClasses = new HashMap<String, URL>();\n        for (Class<? extends Coprocessor> clz : classes) {\n          Dependencies.findClassDependencies(clz.getClassLoader(), new Dependencies.ClassAcceptor() {\n            @Override\n            public boolean accept(String className, final URL classUrl, URL classPathUrl) {\n              // Assuming the endpoint and protocol class doesn't have dependencies\n              // other than those comes with HBase and Java.\n              if (className.startsWith(\"com.continuuity\")) {\n                if (!dependentClasses.containsKey(className)) {\n                  dependentClasses.put(className, classUrl);\n                }\n                return true;\n              }\n              return false;\n            }\n          }, clz.getName());\n        }\n        for (Map.Entry<String, URL> entry : dependentClasses.entrySet()) {\n          try {\n            jarOutput.putNextEntry(new JarEntry(entry.getKey().replace('.', File.separatorChar) + \".class\"));\n            InputStream inputStream = entry.getValue().openStream();\n\n            try {\n              int len = inputStream.read(buffer);\n              while (len >= 0) {\n                hasher.putBytes(buffer, 0, len);\n                jarOutput.write(buffer, 0, len);\n                len = inputStream.read(buffer);\n              }\n            } finally {\n              inputStream.close();\n            }\n          } catch (IOException e) {\n            throw Throwables.propagate(e);\n          }\n        }\n      } finally {\n        jarOutput.close();\n      }\n      // Copy jar file into HDFS\n      // Target path is the jarDir + jarMD5.jar\n      final Location targetPath = jarDir.append(\"coprocessor\" + hasher.hash().toString() + \".jar\");\n\n      // If the file exists and having same since, assume the file doesn't changed\n      if (targetPath.exists() && targetPath.length() == jarFile.length()) {\n        return targetPath;\n      }\n\n      // Copy jar file into filesystem\n      if (!jarDir.mkdirs()) {\n        throw new IOException(\"Fails to create directory: \" + jarDir.toURI());\n      }\n      Files.copy(jarFile, new OutputSupplier<OutputStream>() {\n        @Override\n        public OutputStream getOutput() throws IOException {\n          return targetPath.getOutputStream();\n        }\n      });\n      return targetPath;\n\n    } finally {\n      jarFile.delete();\n    }\n  }","commit_id":"d21d71d8000219eee1175c75ad52f8405df01836","url":"https://github.com/caskdata/cdap"},{"original_method":"@Provides\n    @Singleton\n    private HDFSLocationFactory providesHDFSLocationFactory(CConfiguration cConf, Configuration hConf) {\n      String hdfsUser = cConf.get(Constants.CFG_HDFS_USER);\n      String namespace = cConf.get(Constants.CFG_HDFS_NAMESPACE);\n      FileSystem fileSystem;\n\n      try {\n        if (hdfsUser == null) {\n          fileSystem = FileSystem.get(FileSystem.getDefaultUri(hConf), hConf);\n        } else {\n          fileSystem = FileSystem.get(FileSystem.getDefaultUri(hConf), hConf, hdfsUser);\n        }\n        return new HDFSLocationFactory(fileSystem, namespace);\n      } catch (Exception e) {\n        throw Throwables.propagate(e);\n      }\n    }","id":73536,"modified_method":"@Provides\n    @Singleton\n    private HDFSLocationFactory providesHDFSLocationFactory(CConfiguration cConf, Configuration hConf) {\n      String hdfsUser = cConf.get(Constants.CFG_HDFS_USER);\n      String namespace = cConf.get(Constants.CFG_HDFS_NAMESPACE);\n      LOG.info(\"HDFS namespace is \" + namespace);\n      FileSystem fileSystem;\n\n      try {\n        if (hdfsUser == null) {\n          fileSystem = FileSystem.get(FileSystem.getDefaultUri(hConf), hConf);\n        } else {\n          fileSystem = FileSystem.get(FileSystem.getDefaultUri(hConf), hConf, hdfsUser);\n        }\n        return new HDFSLocationFactory(fileSystem, namespace);\n      } catch (Exception e) {\n        throw Throwables.propagate(e);\n      }\n    }","commit_id":"d21d71d8000219eee1175c75ad52f8405df01836","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void initialize(WeaveContext context) {\n    super.initialize(context);\n\n    runLatch = new CountDownLatch(1);\n    name = context.getSpecification().getName();\n    Map<String, String> configs = context.getSpecification().getConfigs();\n\n    LOG.info(\"Initialize runnable: \" + name);\n    try {\n      // Load configuration\n      Configuration hConf = new Configuration();\n      hConf.clear();\n      hConf.addResource(new File(configs.get(\"hConf\")).toURI().toURL());\n\n      CConfiguration cConf = CConfiguration.create();\n      cConf.clear();\n      cConf.addResource(new File(configs.get(\"cConf\")).toURI().toURL());\n      String baseDir = cConf.get(LoggingConfiguration.LOG_BASE_DIR);\n      if (baseDir != null) {\n        if (baseDir.startsWith(\"/\")) {\n          baseDir = baseDir.substring(1);\n        }\n        cConf.set(LoggingConfiguration.LOG_BASE_DIR, cConf.get(Constants.CFG_HDFS_NAMESPACE) + \"/\" + baseDir);\n      }\n\n      DataSetAccessor dataSetAccessor = new DistributedDataSetAccessor(cConf, hConf);\n      TransactionSystemClient txClient = new TransactionServiceClient(cConf);\n\n      // Initialize ZK client\n      String zookeeper = cConf.get(Constants.CFG_ZOOKEEPER_ENSEMBLE);\n      if (zookeeper == null) {\n        LOG.error(\"No zookeeper quorum provided.\");\n        throw new IllegalStateException(\"No zookeeper quorum provided.\");\n      }\n\n      zkClientService =\n        ZKClientServices.delegate(\n          ZKClients.reWatchOnExpire(\n            ZKClients.retryOnFailure(\n              ZKClientService.Builder.of(zookeeper).build(),\n              RetryStrategies.exponentialDelay(500, 2000, TimeUnit.MILLISECONDS)\n            )\n          ));\n\n      // Initialize Kafka client\n      String kafkaZKNamespace = cConf.get(KafkaConstants.ConfigKeys.ZOOKEEPER_NAMESPACE_CONFIG);\n      kafkaClientService = new ZKKafkaClientService(\n        kafkaZKNamespace == null\n          ? zkClientService\n          : ZKClients.namespace(zkClientService, \"/\" + kafkaZKNamespace)\n      );\n\n\n      logSaver = new LogSaver(dataSetAccessor, txClient, kafkaClientService, hConf, cConf);\n\n      int numPartitions = Integer.parseInt(cConf.get(LoggingConfiguration.NUM_PARTITIONS,\n                                                     LoggingConfiguration.DEFAULT_NUM_PARTITIONS));\n      LOG.info(\"Num partitions = {}\", numPartitions);\n      multiElection = new MultiLeaderElection(zkClientService, \"log-saver\", numPartitions, logSaver);\n\n      LOG.info(\"Runnable initialized: \" + name);\n    } catch (Throwable t) {\n      LOG.error(t.getMessage(), t);\n      throw Throwables.propagate(t);\n    }\n  }","id":73537,"modified_method":"@Override\n  public void initialize(WeaveContext context) {\n    super.initialize(context);\n\n    runLatch = new CountDownLatch(1);\n    name = context.getSpecification().getName();\n    Map<String, String> configs = context.getSpecification().getConfigs();\n\n    LOG.info(\"Initialize runnable: \" + name);\n    try {\n      // Load configuration\n      Configuration hConf = new Configuration();\n      hConf.clear();\n      hConf.addResource(new File(configs.get(\"hConf\")).toURI().toURL());\n\n      CConfiguration cConf = CConfiguration.create();\n      cConf.clear();\n      cConf.addResource(new File(configs.get(\"cConf\")).toURI().toURL());\n      String baseDir = cConf.get(LoggingConfiguration.LOG_BASE_DIR);\n      if (baseDir != null) {\n        if (baseDir.startsWith(\"/\")) {\n          baseDir = baseDir.substring(1);\n        }\n        cConf.set(LoggingConfiguration.LOG_BASE_DIR, cConf.get(Constants.CFG_HDFS_NAMESPACE) + \"/\" + baseDir);\n      }\n\n      LocationFactory locationFactory = new HDFSLocationFactory(hConf);\n      DataSetAccessor dataSetAccessor = new DistributedDataSetAccessor(cConf, hConf, locationFactory);\n      TransactionSystemClient txClient = new TransactionServiceClient(cConf);\n\n      // Initialize ZK client\n      String zookeeper = cConf.get(Constants.CFG_ZOOKEEPER_ENSEMBLE);\n      if (zookeeper == null) {\n        LOG.error(\"No zookeeper quorum provided.\");\n        throw new IllegalStateException(\"No zookeeper quorum provided.\");\n      }\n\n      zkClientService =\n        ZKClientServices.delegate(\n          ZKClients.reWatchOnExpire(\n            ZKClients.retryOnFailure(\n              ZKClientService.Builder.of(zookeeper).build(),\n              RetryStrategies.exponentialDelay(500, 2000, TimeUnit.MILLISECONDS)\n            )\n          ));\n\n      // Initialize Kafka client\n      String kafkaZKNamespace = cConf.get(KafkaConstants.ConfigKeys.ZOOKEEPER_NAMESPACE_CONFIG);\n      kafkaClientService = new ZKKafkaClientService(\n        kafkaZKNamespace == null\n          ? zkClientService\n          : ZKClients.namespace(zkClientService, \"/\" + kafkaZKNamespace)\n      );\n\n\n      logSaver = new LogSaver(dataSetAccessor, txClient, kafkaClientService, hConf, cConf);\n\n      int numPartitions = Integer.parseInt(cConf.get(LoggingConfiguration.NUM_PARTITIONS,\n                                                     LoggingConfiguration.DEFAULT_NUM_PARTITIONS));\n      LOG.info(\"Num partitions = {}\", numPartitions);\n      multiElection = new MultiLeaderElection(zkClientService, \"log-saver\", numPartitions, logSaver);\n\n      LOG.info(\"Runnable initialized: \" + name);\n    } catch (Throwable t) {\n      LOG.error(t.getMessage(), t);\n      throw Throwables.propagate(t);\n    }\n  }","commit_id":"d21d71d8000219eee1175c75ad52f8405df01836","url":"https://github.com/caskdata/cdap"},{"original_method":"public void layout () {\r\n\t\tDrawable bg = style.background;\r\n\t\tBitmapFont font = style.font;\r\n\r\n\t\tprefHeight = Math.max(bg.getTopHeight() + bg.getBottomHeight() + font.getCapHeight() - font.getDescent() * 2,\r\n\t\t\tbg.getMinHeight());\r\n\r\n\t\tfloat maxItemWidth = 0;\r\n\t\tfor (int i = 0; i < items.size; i++)\r\n\t\t\tmaxItemWidth = Math.max(font.getBounds(items.get(i).toString()).width, maxItemWidth);\r\n\r\n\t\tprefWidth = bg.getLeftWidth() + bg.getRightWidth() + maxItemWidth;\r\n\r\n\t\tListStyle listStyle = style.listStyle;\r\n\t\tScrollPaneStyle scrollStyle = style.scrollStyle;\r\n\t\tprefWidth = Math.max(\r\n\t\t\tprefWidth,\r\n\t\t\tmaxItemWidth\r\n\t\t\t\t+ scrollStyle.background.getLeftWidth()\r\n\t\t\t\t+ scrollStyle.background.getRightWidth()\r\n\t\t\t\t+ listStyle.selection.getLeftWidth()\r\n\t\t\t\t+ listStyle.selection.getRightWidth()\r\n\t\t\t\t+ Math.max(style.scrollStyle.vScroll != null ? style.scrollStyle.vScroll.getMinWidth() : 0,\r\n\t\t\t\t\tstyle.scrollStyle.vScrollKnob != null ? style.scrollStyle.vScrollKnob.getMinWidth() : 0));\r\n\t}","id":73538,"modified_method":"public void layout () {\r\n\t\tDrawable bg = style.background;\r\n\t\tBitmapFont font = style.font;\r\n\r\n\t\tprefHeight = Math.max(bg.getTopHeight() + bg.getBottomHeight() + font.getCapHeight() - font.getDescent() * 2,\r\n\t\t\tbg.getMinHeight());\r\n\r\n\t\tfloat maxItemWidth = 0;\r\n\t\tfor (int i = 0; i < items.size; i++)\r\n\t\t\tmaxItemWidth = Math.max(font.getBounds(items.get(i).toString()).width, maxItemWidth);\r\n\r\n\t\tprefWidth = bg.getLeftWidth() + bg.getRightWidth() + maxItemWidth;\r\n\r\n\t\tListStyle listStyle = style.listStyle;\r\n\t\tScrollPaneStyle scrollStyle = style.scrollStyle;\r\n\t\tprefWidth = Math.max(\r\n\t\t\tprefWidth,\r\n\t\t\tmaxItemWidth\r\n\t\t\t\t+ (scrollStyle.background == null ? 0 : scrollStyle.background.getLeftWidth()\r\n\t\t\t\t\t+ scrollStyle.background.getRightWidth())\r\n\t\t\t\t+ listStyle.selection.getLeftWidth()\r\n\t\t\t\t+ listStyle.selection.getRightWidth()\r\n\t\t\t\t+ Math.max(style.scrollStyle.vScroll != null ? style.scrollStyle.vScroll.getMinWidth() : 0,\r\n\t\t\t\t\tstyle.scrollStyle.vScrollKnob != null ? style.scrollStyle.vScrollKnob.getMinWidth() : 0));\r\n\t}","commit_id":"9f21308877b0ee09109d40ccceb4896d87e29180","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void layout () {\r\n\t\tDrawable bg = style.background;\r\n\t\tBitmapFont font = style.font;\r\n\r\n\t\tprefHeight = Math.max(bg.getTopHeight() + bg.getBottomHeight() + font.getCapHeight() - font.getDescent() * 2,\r\n\t\t\tbg.getMinHeight());\r\n\r\n\t\tfloat maxItemWidth = 0;\r\n\t\tfor (int i = 0; i < items.size; i++)\r\n\t\t\tmaxItemWidth = Math.max(font.getBounds(items.get(i).toString()).width, maxItemWidth);\r\n\r\n\t\tprefWidth = bg.getLeftWidth() + bg.getRightWidth() + maxItemWidth;\r\n\r\n\t\tListStyle listStyle = style.listStyle;\r\n\t\tScrollPaneStyle scrollStyle = style.scrollStyle;\r\n\t\tprefWidth = Math.max(\r\n\t\t\tprefWidth,\r\n\t\t\tmaxItemWidth\r\n\t\t\t\t+ (scrollStyle.background == null ? 0 : scrollStyle.background.getLeftWidth()\r\n\t\t\t\t\t+ scrollStyle.background.getRightWidth())\r\n\t\t\t\t+ listStyle.selection.getLeftWidth()\r\n\t\t\t\t+ listStyle.selection.getRightWidth()\r\n\t\t\t\t+ Math.max(style.scrollStyle.vScroll != null ? style.scrollStyle.vScroll.getMinWidth() : 0,\r\n\t\t\t\t\tstyle.scrollStyle.vScrollKnob != null ? style.scrollStyle.vScrollKnob.getMinWidth() : 0));\r\n\t}","id":73539,"modified_method":"@Override\r\n\tpublic void layout () {\r\n\t\tDrawable bg = style.background;\r\n\t\tBitmapFont font = style.font;\r\n\r\n\t\tif(bg != null)\r\n\t\t\tprefHeight = Math.max(bg.getTopHeight() + bg.getBottomHeight() + font.getCapHeight() - font.getDescent() * 2,\r\n\t\t\t\tbg.getMinHeight());\r\n\t\telse\r\n\t\t\tprefHeight = font.getCapHeight() - font.getDescent() * 2;\r\n\r\n\t\tfloat maxItemWidth = 0;\r\n\t\tfor (int i = 0; i < items.size; i++)\r\n\t\t\tmaxItemWidth = Math.max(font.getBounds(items.get(i).toString()).width, maxItemWidth);\r\n\r\n\t\tprefWidth = maxItemWidth;\r\n\t\tif (bg != null)\r\n\t\t\tprefWidth += bg.getLeftWidth() + bg.getRightWidth();\r\n\r\n\t\tListStyle listStyle = style.listStyle;\r\n\t\tScrollPaneStyle scrollStyle = style.scrollStyle;\r\n\t\tprefWidth = Math.max(\r\n\t\t\tprefWidth,\r\n\t\t\tmaxItemWidth\r\n\t\t\t\t+ (scrollStyle.background == null ? 0 : scrollStyle.background.getLeftWidth()\r\n\t\t\t\t\t+ scrollStyle.background.getRightWidth())\r\n\t\t\t\t+ listStyle.selection.getLeftWidth()\r\n\t\t\t\t+ listStyle.selection.getRightWidth()\r\n\t\t\t\t+ Math.max(style.scrollStyle.vScroll != null ? style.scrollStyle.vScroll.getMinWidth() : 0,\r\n\t\t\t\t\tstyle.scrollStyle.vScrollKnob != null ? style.scrollStyle.vScrollKnob.getMinWidth() : 0));\r\n\t}","commit_id":"d9ffbf27c787cd48f18dfe474910a238d1bc32f1","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void draw (Batch batch, float parentAlpha) {\r\n\t\tvalidate();\r\n\r\n\t\tDrawable background;\r\n\t\tif (disabled && style.backgroundDisabled != null)\r\n\t\t\tbackground = style.backgroundDisabled;\r\n\t\telse if (scroll.hasParent() && style.backgroundOpen != null)\r\n\t\t\tbackground = style.backgroundOpen;\r\n\t\telse if (clickListener.isOver() && style.backgroundOver != null)\r\n\t\t\tbackground = style.backgroundOver;\r\n\t\telse\r\n\t\t\tbackground = style.background;\r\n\t\tfinal BitmapFont font = style.font;\r\n\t\tfinal Color fontColor = (disabled && style.disabledFontColor != null) ? style.disabledFontColor : style.fontColor;\r\n\r\n\t\tColor color = getColor();\r\n\t\tfloat x = getX();\r\n\t\tfloat y = getY();\r\n\t\tfloat width = getWidth();\r\n\t\tfloat height = getHeight();\r\n\r\n\t\tbatch.setColor(color.r, color.g, color.b, color.a * parentAlpha);\r\n\t\tbackground.draw(batch, x, y, width, height);\r\n\t\tT selected = this.selected != null ? this.selected : selection.first();\r\n\t\tif (selected != null) {\r\n\t\t\tfloat availableWidth = width - background.getLeftWidth() - background.getRightWidth();\r\n\t\t\tString string = selected.toString();\r\n\t\t\tint numGlyphs = font.computeVisibleGlyphs(string, 0, string.length(), availableWidth);\r\n\t\t\tbounds.set(font.getBounds(string));\r\n\t\t\theight -= background.getBottomHeight() + background.getTopHeight();\r\n\t\t\tfloat textY = (int)(height / 2 + background.getBottomHeight() + bounds.height / 2);\r\n\t\t\tfont.setColor(fontColor.r, fontColor.g, fontColor.b, fontColor.a * parentAlpha);\r\n\t\t\tfont.draw(batch, string, x + background.getLeftWidth(), y + textY, 0, numGlyphs);\r\n\t\t}\r\n\t}","id":73540,"modified_method":"@Override\r\n\tpublic void draw (Batch batch, float parentAlpha) {\r\n\t\tvalidate();\r\n\r\n\t\tDrawable background;\r\n\t\tif (disabled && style.backgroundDisabled != null)\r\n\t\t\tbackground = style.backgroundDisabled;\r\n\t\telse if (scroll.hasParent() && style.backgroundOpen != null)\r\n\t\t\tbackground = style.backgroundOpen;\r\n\t\telse if (clickListener.isOver() && style.backgroundOver != null)\r\n\t\t\tbackground = style.backgroundOver;\r\n\t\telse if (style.background != null)\r\n\t\t\tbackground = style.background;\r\n\t\telse\r\n\t\t\tbackground = null;\r\n\t\tfinal BitmapFont font = style.font;\r\n\t\tfinal Color fontColor = (disabled && style.disabledFontColor != null) ? style.disabledFontColor : style.fontColor;\r\n\r\n\t\tColor color = getColor();\r\n\t\tfloat x = getX();\r\n\t\tfloat y = getY();\r\n\t\tfloat width = getWidth();\r\n\t\tfloat height = getHeight();\r\n\r\n\t\tbatch.setColor(color.r, color.g, color.b, color.a * parentAlpha);\r\n\t\tif (background != null)\r\n\t\t\tbackground.draw(batch, x, y, width, height);\r\n\r\n\t\tT selected = this.selected != null ? this.selected : selection.first();\r\n\t\tif (selected != null) {\r\n\t\t\tString string = selected.toString();\r\n\t\t\tbounds.set(font.getBounds(string));\r\n\t\t\tif (background != null) {\r\n\t\t\t\twidth -= background.getLeftWidth() + background.getRightWidth();\r\n\t\t\t\theight -= background.getBottomHeight() + background.getTopHeight();\r\n\t\t\t\tx += background.getLeftWidth();\r\n\t\t\t\ty += (int)(height / 2 + background.getBottomHeight() + bounds.height / 2);\r\n\t\t\t} else {\r\n\t\t\t\ty += (int)(height / 2 + bounds.height / 2);\r\n\t\t\t}\r\n\t\t\tint numGlyphs = font.computeVisibleGlyphs(string, 0, string.length(), width);\r\n\t\t\tfont.setColor(fontColor.r, fontColor.g, fontColor.b, fontColor.a * parentAlpha);\r\n\t\t\tfont.draw(batch, string, x, y, 0, numGlyphs);\r\n\t\t}\r\n\t}","commit_id":"d9ffbf27c787cd48f18dfe474910a238d1bc32f1","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void draw (SpriteBatch batch, float parentAlpha) {\r\n\t\tif (widget == null) return;\r\n\r\n\t\tvalidate();\r\n\r\n\t\t// Setup transform for this group.\r\n\t\tapplyTransform(batch);\r\n\r\n\t\t// Calculate the bounds for the scrollbars, the widget area and the scissor area.\r\n\t\tcalculateBoundsAndPositions(batch.getTransformMatrix());\r\n\r\n\t\t// Draw the background ninepatch.\r\n\t\tbatch.setColor(color.r, color.g, color.b, color.a * parentAlpha);\r\n\t\tstyle.background.draw(batch, 0, 0, width, height);\r\n\t\tbatch.flush();\r\n\r\n\t\t// Enable scissors for widget area and draw the widget.\r\n\t\tif (ScissorStack.pushScissors(scissorBounds)) {\r\n\t\t\tdrawChildren(batch, parentAlpha);\r\n\t\t\tScissorStack.popScissors();\r\n\t\t}\r\n\r\n\t\t// Render scrollbars and knobs on top.\r\n\t\tbatch.setColor(color.r, color.g, color.b, color.a * parentAlpha);\r\n\t\tif (scrollX) {\r\n\t\t\tstyle.hScroll.draw(batch, hScrollBounds.x, hScrollBounds.y, hScrollBounds.width, hScrollBounds.height);\r\n\t\t\tstyle.hScrollKnob.draw(batch, hKnobBounds.x, hKnobBounds.y, hKnobBounds.width, hKnobBounds.height);\r\n\t\t}\r\n\t\tif (scrollY) {\r\n\t\t\tstyle.vScroll.draw(batch, vScrollBounds.x, vScrollBounds.y, vScrollBounds.width, vScrollBounds.height);\r\n\t\t\tstyle.vScrollKnob.draw(batch, vKnobBounds.x, vKnobBounds.y, vKnobBounds.width, vKnobBounds.height);\r\n\t\t}\r\n\r\n\t\tresetTransform(batch);\r\n\t}","id":73541,"modified_method":"@Override\r\n\tpublic void draw (SpriteBatch batch, float parentAlpha) {\r\n\t\tif (widget == null) return;\r\n\r\n\t\tvalidate();\r\n\r\n\t\t// Setup transform for this group.\r\n\t\tapplyTransform(batch);\r\n\r\n\t\t// Calculate the bounds for the scrollbars, the widget area and the scissor area.\r\n\t\tcalculateBoundsAndPositions(batch.getTransformMatrix());\r\n\r\n\t\t// Draw the background ninepatch.\r\n\t\tbatch.setColor(color.r, color.g, color.b, color.a * parentAlpha);\r\n\t\tif (style.background != null) {\r\n\t\t\tstyle.background.draw(batch, 0, 0, width, height);\r\n\t\t}\r\n\t\tbatch.flush();\r\n\r\n\t\t// Enable scissors for widget area and draw the widget.\r\n\t\tif (ScissorStack.pushScissors(scissorBounds)) {\r\n\t\t\tdrawChildren(batch, parentAlpha);\r\n\t\t\tScissorStack.popScissors();\r\n\t\t}\r\n\r\n\t\t// Render scrollbars and knobs on top.\r\n\t\tbatch.setColor(color.r, color.g, color.b, color.a * parentAlpha);\r\n\t\tif (scrollX) {\r\n\t\t\tstyle.hScroll.draw(batch, hScrollBounds.x, hScrollBounds.y, hScrollBounds.width, hScrollBounds.height);\r\n\t\t\tstyle.hScrollKnob.draw(batch, hKnobBounds.x, hKnobBounds.y, hKnobBounds.width, hKnobBounds.height);\r\n\t\t}\r\n\t\tif (scrollY) {\r\n\t\t\tstyle.vScroll.draw(batch, vScrollBounds.x, vScrollBounds.y, vScrollBounds.width, vScrollBounds.height);\r\n\t\t\tstyle.vScrollKnob.draw(batch, vKnobBounds.x, vKnobBounds.y, vKnobBounds.width, vKnobBounds.height);\r\n\t\t}\r\n\r\n\t\tresetTransform(batch);\r\n\t}","commit_id":"8bc8e1039836628c520e4a12e8d1d8c55dd9b0a2","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param widget May be null. */\r\n\tpublic ScrollPane (Actor widget, ScrollPaneStyle style, String name) {\r\n\t\tsuper(name);\r\n\t\tif (style == null) throw new IllegalArgumentException(\"style cannot be null.\");\r\n\t\tthis.widget = widget;\r\n\t\tthis.style = style;\r\n\t\tsetWidget(widget);\r\n\t\twidth = 150;\r\n\t\theight = 150;\r\n\t}","id":73542,"modified_method":"/** @param widget May be null. */\r\n\tpublic ScrollPane (Actor widget, ScrollPaneStyle style, String name) {\r\n\t\tsuper(name);\r\n\t\tif (style == null) throw new IllegalArgumentException(\"style cannot be null.\");\r\n\t\tthis.widget = widget;\r\n\t\tthis.style = style;\r\n\t\tif (widget != null) {\r\n\t\t\tsetWidget(widget);\r\n\t\t}\r\n\t\twidth = 150;\r\n\t\theight = 150;\r\n\t}","commit_id":"8bc8e1039836628c520e4a12e8d1d8c55dd9b0a2","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void calculateBoundsAndPositions (Matrix4 batchTransform) {\r\n\t\tfinal NinePatch bg = style.background;\r\n\t\tfinal NinePatch hScrollKnob = style.hScrollKnob;\r\n\t\tfinal NinePatch vScrollKnob = style.vScrollKnob;\r\n\r\n\t\t// Get available space size by subtracting background's padded area.\r\n\t\tfloat areaWidth = width - bg.getLeftWidth() - bg.getRightWidth();\r\n\t\tfloat areaHeight = height - bg.getTopHeight() - bg.getBottomHeight();\r\n\r\n\t\t// Get widget's desired width.\r\n\t\tfloat widgetWidth, widgetHeight;\r\n\t\tif (widget instanceof Layout) {\r\n\t\t\tLayout layout = (Layout)widget;\r\n\t\t\twidgetWidth = layout.getPrefWidth();\r\n\t\t\twidgetHeight = layout.getPrefHeight();\r\n\t\t} else {\r\n\t\t\twidgetWidth = widget.width;\r\n\t\t\twidgetHeight = widget.height;\r\n\t\t}\r\n\r\n\t\t// Figure out if we need horizontal/vertical scrollbars.\r\n\t\tscrollX = false;\r\n\t\tscrollY = false;\r\n\t\tif (!disableX && widgetWidth > areaWidth) scrollX = true;\r\n\t\tif (!disableY && widgetHeight > areaHeight) scrollY = true;\r\n\r\n\t\t// Check again, now taking into account the area that's taken up by any enabled scrollbars.\r\n\t\tif (!disableX && scrollY && widgetWidth > areaWidth - vScrollKnob.getTotalWidth()) {\r\n\t\t\tscrollX = true;\r\n\t\t\tareaWidth -= vScrollKnob.getTotalWidth();\r\n\t\t}\r\n\t\tif (!disableY && scrollX && widgetHeight > areaHeight - hScrollKnob.getTotalHeight()) {\r\n\t\t\tscrollY = true;\r\n\t\t\tareaHeight -= hScrollKnob.getTotalHeight();\r\n\t\t}\r\n\r\n\t\t// Set the widget area bounds.\r\n\t\twidgetAreaBounds.set(bg.getLeftWidth(), bg.getBottomHeight() + (scrollX ? hScrollKnob.getTotalHeight() : 0), areaWidth,\r\n\t\t\tareaHeight);\r\n\t\tamountX = MathUtils.clamp(amountX, 0, widgetAreaBounds.x);\r\n\t\tamountY = MathUtils.clamp(amountY, 0, widgetAreaBounds.y);\r\n\r\n\t\t// If the widget is smaller than the available space, make it take up the available space.\r\n\t\twidgetWidth = disableX ? width : Math.max(areaWidth, widgetWidth);\r\n\t\twidgetHeight = disableY ? height : Math.max(areaHeight, widgetHeight);\r\n\t\tif (widget.width != widgetWidth || widget.height != widgetHeight) {\r\n\t\t\twidget.width = widgetWidth;\r\n\t\t\twidget.height = widgetHeight;\r\n\t\t\tif (widget instanceof Layout) ((Layout)widget).invalidate();\r\n\t\t}\r\n\r\n\t\t// Set the bounds and scroll knob sizes if scrollbars are needed.\r\n\t\tif (scrollX) {\r\n\t\t\thScrollBounds.set(bg.getLeftWidth(), bg.getBottomHeight(), areaWidth, hScrollKnob.getTotalHeight());\r\n\t\t\thKnobBounds.width = Math.max(hScrollKnob.getTotalWidth(), (int)(hScrollBounds.width * areaWidth / widget.width));\r\n\t\t\thKnobBounds.height = hScrollKnob.getTotalHeight();\r\n\t\t\thKnobBounds.x = hScrollBounds.x + (int)((hScrollBounds.width - hKnobBounds.width) * getScrollPercentX());\r\n\t\t\thKnobBounds.y = hScrollBounds.y;\r\n\t\t}\r\n\t\tif (scrollY) {\r\n\t\t\tvScrollBounds.set(width - bg.getRightWidth() - vScrollKnob.getTotalWidth(), height - bg.getTopHeight() - areaHeight,\r\n\t\t\t\tvScrollKnob.getTotalWidth(), areaHeight);\r\n\t\t\tvKnobBounds.width = vScrollKnob.getTotalWidth();\r\n\t\t\tvKnobBounds.height = Math.max(vScrollKnob.getTotalHeight(), (int)(vScrollBounds.height * areaHeight / widget.height));\r\n\t\t\tvKnobBounds.x = vScrollBounds.x;\r\n\t\t\tvKnobBounds.y = vScrollBounds.y + (int)((vScrollBounds.height - vKnobBounds.height) * (1 - getScrollPercentY()));\r\n\t\t}\r\n\r\n\t\t// Calculate the widgets offset depending on the scroll state and available widget area.\r\n\t\twidget.y = widgetAreaBounds.y - (!scrollY ? (int)(widget.height - areaHeight) : 0)\r\n\t\t\t- (scrollY ? (int)((widget.height - areaHeight) * (1 - getScrollPercentY())) : 0);\r\n\t\twidget.x = widgetAreaBounds.x - (scrollX ? (int)((widget.width - areaWidth) * getScrollPercentX()) : 0);\r\n\r\n\t\t// Caculate the scissor bounds based on the batch transform, the available widget area and the camera transform. We need to\r\n\t\t// project those to screen coordinates for OpenGL ES to consume.\r\n\t\tScissorStack.calculateScissors(stage.getCamera(), batchTransform, widgetAreaBounds, scissorBounds);\r\n\r\n\t\tif (widget instanceof Cullable) {\r\n\t\t\twidgetCullingArea.x = -widget.x + widgetAreaBounds.x;\r\n\t\t\twidgetCullingArea.y = -widget.y + widgetAreaBounds.y;\r\n\t\t\twidgetCullingArea.width = areaWidth;\r\n\t\t\twidgetCullingArea.height = areaHeight;\r\n\t\t\t((Cullable)widget).setCullingArea(widgetCullingArea);\r\n\t\t}\r\n\t}","id":73543,"modified_method":"private void calculateBoundsAndPositions (Matrix4 batchTransform) {\r\n\t\tfinal NinePatch bg = style.background;\r\n\t\tfinal NinePatch hScrollKnob = style.hScrollKnob;\r\n\t\tfinal NinePatch vScrollKnob = style.vScrollKnob;\r\n\r\n\t\t// For no background, ex. background is drawn a parent who has two scroll area\r\n\t\tfloat bgLeftWidth = bg == null ? 0 : bg.getLeftWidth();\r\n\t\tfloat bgRightWidth = bg == null ? 0 : bg.getRightWidth();\r\n\t\tfloat bgTopHeight = bg == null ? 0 : bg.getTopHeight();\r\n\t\tfloat bgBottomHeight = bg == null ? 0 : bg.getTopHeight();\r\n\r\n\t\t// Get available space size by subtracting background's padded area.\r\n\t\tfloat areaWidth = width - bgLeftWidth - bgRightWidth;\r\n\t\tfloat areaHeight = height - bgTopHeight - bgBottomHeight;\r\n\r\n\t\t// Get widget's desired width.\r\n\t\tfloat widgetWidth, widgetHeight;\r\n\t\tif (widget instanceof Layout) {\r\n\t\t\tLayout layout = (Layout)widget;\r\n\t\t\twidgetWidth = layout.getPrefWidth();\r\n\t\t\twidgetHeight = layout.getPrefHeight();\r\n\t\t} else {\r\n\t\t\twidgetWidth = widget.width;\r\n\t\t\twidgetHeight = widget.height;\r\n\t\t}\r\n\r\n\t\t// Figure out if we need horizontal/vertical scrollbars.\r\n\t\tscrollX = false;\r\n\t\tscrollY = false;\r\n\t\tif (!disableX && widgetWidth > areaWidth) scrollX = true;\r\n\t\tif (!disableY && widgetHeight > areaHeight) scrollY = true;\r\n\r\n\t\t// Check again, now taking into account the area that's taken up by any enabled scrollbars.\r\n\t\tif (!disableX && scrollY && widgetWidth > areaWidth - vScrollKnob.getTotalWidth()) {\r\n\t\t\tscrollX = true;\r\n\t\t\tareaWidth -= vScrollKnob.getTotalWidth();\r\n\t\t}\r\n\t\tif (!disableY && scrollX && widgetHeight > areaHeight - hScrollKnob.getTotalHeight()) {\r\n\t\t\tscrollY = true;\r\n\t\t\tareaHeight -= hScrollKnob.getTotalHeight();\r\n\t\t}\r\n\r\n\t\t// Set the widget area bounds.\r\n\t\twidgetAreaBounds.set(bgLeftWidth, bgBottomHeight + (scrollX ? hScrollKnob.getTotalHeight() : 0), areaWidth, areaHeight);\r\n\t\tamountX = MathUtils.clamp(amountX, 0, widgetAreaBounds.x);\r\n\t\tamountY = MathUtils.clamp(amountY, 0, widgetAreaBounds.y);\r\n\r\n\t\t// If the widget is smaller than the available space, make it take up the available space.\r\n\t\twidgetWidth = disableX ? width : Math.max(areaWidth, widgetWidth);\r\n\t\twidgetHeight = disableY ? height : Math.max(areaHeight, widgetHeight);\r\n\t\tif (widget.width != widgetWidth || widget.height != widgetHeight) {\r\n\t\t\twidget.width = widgetWidth;\r\n\t\t\twidget.height = widgetHeight;\r\n\t\t\tif (widget instanceof Layout) ((Layout)widget).invalidate();\r\n\t\t}\r\n\r\n\t\t// Set the bounds and scroll knob sizes if scrollbars are needed.\r\n\t\tif (scrollX) {\r\n\t\t\thScrollBounds.set(bgLeftWidth, bgBottomHeight, areaWidth, hScrollKnob.getTotalHeight());\r\n\t\t\thKnobBounds.width = Math.max(hScrollKnob.getTotalWidth(), (int)(hScrollBounds.width * areaWidth / widget.width));\r\n\t\t\thKnobBounds.height = hScrollKnob.getTotalHeight();\r\n\t\t\thKnobBounds.x = hScrollBounds.x + (int)((hScrollBounds.width - hKnobBounds.width) * getScrollPercentX());\r\n\t\t\thKnobBounds.y = hScrollBounds.y;\r\n\t\t}\r\n\t\tif (scrollY) {\r\n\t\t\tvScrollBounds.set(width - bgRightWidth - vScrollKnob.getTotalWidth(), height - bgTopHeight - areaHeight,\r\n\t\t\t\tvScrollKnob.getTotalWidth(), areaHeight);\r\n\t\t\tvKnobBounds.width = vScrollKnob.getTotalWidth();\r\n\t\t\tvKnobBounds.height = Math.max(vScrollKnob.getTotalHeight(), (int)(vScrollBounds.height * areaHeight / widget.height));\r\n\t\t\tvKnobBounds.x = vScrollBounds.x;\r\n\t\t\tvKnobBounds.y = vScrollBounds.y + (int)((vScrollBounds.height - vKnobBounds.height) * (1 - getScrollPercentY()));\r\n\t\t}\r\n\r\n\t\t// Calculate the widgets offset depending on the scroll state and available widget area.\r\n\t\twidget.y = widgetAreaBounds.y - (!scrollY ? (int)(widget.height - areaHeight) : 0)\r\n\t\t\t- (scrollY ? (int)((widget.height - areaHeight) * (1 - getScrollPercentY())) : 0);\r\n\t\twidget.x = widgetAreaBounds.x - (scrollX ? (int)((widget.width - areaWidth) * getScrollPercentX()) : 0);\r\n\r\n\t\t// Caculate the scissor bounds based on the batch transform, the available widget area and the camera transform. We need to\r\n\t\t// project those to screen coordinates for OpenGL ES to consume.\r\n\t\tScissorStack.calculateScissors(stage.getCamera(), batchTransform, widgetAreaBounds, scissorBounds);\r\n\r\n\t\tif (widget instanceof Cullable) {\r\n\t\t\twidgetCullingArea.x = -widget.x + widgetAreaBounds.x;\r\n\t\t\twidgetCullingArea.y = -widget.y + widgetAreaBounds.y;\r\n\t\t\twidgetCullingArea.width = areaWidth;\r\n\t\t\twidgetCullingArea.height = areaHeight;\r\n\t\t\t((Cullable)widget).setCullingArea(widgetCullingArea);\r\n\t\t}\r\n\t}","commit_id":"8bc8e1039836628c520e4a12e8d1d8c55dd9b0a2","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Disposes the {@link Texture} and all {@link Disposable} resources of this Skin. */\r\n\t@Override\r\n\tpublic void dispose () {\r\n\t\ttexture.dispose();\r\n\t\tfor (Object object : resources.values())\r\n\t\t\tif (object instanceof Disposable) ((Disposable)object).dispose();\r\n\t}","id":73544,"modified_method":"/** Disposes the {@link Texture} and all {@link Disposable} resources of this Skin. */\r\n\t@Override\r\n\tpublic void dispose () {\r\n\t\ttexture.dispose();\r\n\t\tfor (Entry<Class, ObjectMap<String, Object>> entry : resources.entries()) {\r\n\t\t\tif (!Disposable.class.isAssignableFrom(entry.key)) continue;\r\n\t\t\tfor (Object resource : entry.value.values())\r\n\t\t\t\t((Disposable)resource).dispose();\r\n\t\t}\r\n\t}","commit_id":"8bc8e1039836628c520e4a12e8d1d8c55dd9b0a2","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters.\n     *\n     * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName,\n            Hashtable parameters, String templateSelector) throws CmsException {\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n        CmsXmlWpTemplateFile xmlTemplateDocument = (CmsXmlWpTemplateFile)getOwnTemplateFile(cms,\n                templateFile, elementName, parameters, templateSelector);\n\n        // clear session values on first load\n        String initial = (String)parameters.get(C_PARA_INITIAL);\n        if(initial != null) {\n\n            // remove all session values\n            session.removeValue(C_PARA_FOLDER);\n        }\n\n        // getting the URL to which we need to return when we're done\n        String lasturl = getLastUrl(cms, parameters);\n\n        // read the parameters\n        String foldername = (String)parameters.get(C_PARA_FOLDER);\n        if(foldername != null) {\n\n            // need the foldername in the session in case of an exception in the dialog\n            session.putValue(C_PARA_FOLDER, foldername);\n        }\n        else {\n            foldername = (String)session.getValue(C_PARA_FOLDER);\n        }\n        String action = (String)parameters.get(\"action\");\n        String newname = (String)parameters.get(C_PARA_NAME);\n        String title = (String)parameters.get(\"TITLE\"); // both for gallery and upload file\n        String step = (String)parameters.get(\"step\");\n        if(foldername == null) {\n            foldername = \"\";\n        }\n        if(\"new\".equals(action)) {\n            String galleryname = (String)parameters.get(\"NAME\");\n            String group = (String)parameters.get(\"GROUP\");\n            boolean read = parameters.get(\"READ\") != null;\n            boolean write = parameters.get(\"WRITE\") != null;\n            try {\n\n                // create the folder\n\n                // get the path from the workplace.ini\n                String superfolder = getConfigFile(cms).getDownGalleryPath();\n                CmsFolder folder = cms.createFolder(superfolder, galleryname);\n                cms.lockResource(folder.getAbsolutePath());\n                cms.writeProperty(folder.getAbsolutePath(), C_PROPERTY_TITLE, title);\n                cms.chgrp(folder.getAbsolutePath(), group);\n                int flag = folder.getAccessFlags();\n\n                // set the access rights for 'other' users\n                if(read != ((flag & C_ACCESS_PUBLIC_READ) != 0)) {\n                    flag ^= C_ACCESS_PUBLIC_READ;\n                }\n                if(write != ((flag & C_ACCESS_PUBLIC_WRITE) != 0)) {\n                    flag ^= C_ACCESS_PUBLIC_WRITE;\n                }\n                if((flag & C_ACCESS_GROUP_READ) == 0){\n                    flag ^= C_ACCESS_GROUP_READ;\n                }\n                if((flag & C_ACCESS_GROUP_WRITE) == 0){\n                    flag ^= C_ACCESS_GROUP_WRITE;\n                }\n                if((flag & C_ACCESS_GROUP_VISIBLE) == 0){\n                    flag ^= C_ACCESS_GROUP_VISIBLE;\n                }\n                if((flag & C_ACCESS_OWNER_READ ) == 0){\n                    flag ^= C_ACCESS_OWNER_READ;\n                }\n                if((flag & C_ACCESS_OWNER_WRITE) == 0){\n                    flag ^= C_ACCESS_OWNER_WRITE;\n                }\n                if((flag & C_ACCESS_OWNER_VISIBLE) == 0){\n                    flag ^= C_ACCESS_OWNER_VISIBLE;\n                }\n                if((flag & C_ACCESS_PUBLIC_VISIBLE) == 0){\n                    flag ^= C_ACCESS_PUBLIC_VISIBLE;\n                }\n               cms.chmod(folder.getAbsolutePath(), flag);\n               cms.unlockResource(folder.getAbsolutePath());\n            }\n            catch(CmsException ex) {\n                xmlTemplateDocument.setData(\"ERRORDETAILS\", Utils.getStackTrace(ex));\n                templateSelector = \"error\";\n            }\n        }\n        else {\n            if(\"upload\".equals(action)) {\n\n                // get filename and file content if available\n                String filename = null;\n                byte[] filecontent = new byte[0];\n\n                // get the filename\n                Enumeration files = cms.getRequestContext().getRequest().getFileNames();\n                while(files.hasMoreElements()) {\n                    filename = (String)files.nextElement();\n                }\n                if(filename != null) {\n                    session.putValue(C_PARA_FILE, filename);\n                }\n                filename = (String)session.getValue(C_PARA_FILE);\n\n                // get the filecontent\n                if(filename != null) {\n                    filecontent = cms.getRequestContext().getRequest().getFile(filename);\n                }\n                if(filecontent != null) {\n                    session.putValue(C_PARA_FILECONTENT, filecontent);\n                }\n                filecontent = (byte[])session.getValue(C_PARA_FILECONTENT);\n                if(\"0\".equals(step)) {\n                    templateSelector = \"\";\n                }\n                else {\n                    if(\"1\".equals(step)) {\n\n                        // display the select filetype screen\n                        if(filename != null) {\n\n                            // check if the file size is 0\n                            if(filecontent.length == 0) {\n                                templateSelector = \"error\";\n                                xmlTemplateDocument.setData(\"details\", filename);\n                            }\n                            else {\n                                xmlTemplateDocument.setData(\"MIME\", filename);\n                                xmlTemplateDocument.setData(\"SIZE\", \"Not yet available\");\n                                xmlTemplateDocument.setData(\"FILESIZE\", new Integer(filecontent.length).toString() + \" Bytes\");\n                                xmlTemplateDocument.setData(\"FILENAME\", filename);\n                                templateSelector = \"step1\";\n                            }\n                        }\n                    }\n                    else {\n                        if(\"2\".equals(step)) {\n\n                            // check if a new filename is given\n                            if(newname != null) {\n                                filename = newname;\n                            }\n                            CmsFile file = cms.createFile(foldername, filename, filecontent, C_TYPE_PLAIN_NAME);\n                            if(title != null) {\n                                String filepath = file.getAbsolutePath();\n                                cms.lockResource(filepath);\n                                cms.writeProperty(filepath, C_PROPERTY_TITLE, title);\n                            }\n                            try {\n                                cms.getRequestContext().getResponse().sendCmsRedirect(getConfigFile(cms).getWorkplaceActionPath() + lasturl);\n                            }\n                            catch(Exception ex) {\n                                throw new CmsException(\"Redirect fails :\" + getConfigFile(cms).getWorkplaceActionPath()\n                                        + lasturl, CmsException.C_UNKNOWN_EXCEPTION, ex);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        xmlTemplateDocument.setData(\"link_value\", foldername);\n        xmlTemplateDocument.setData(\"lasturl\", lasturl);\n\n        // Finally start the processing\n        return startProcessing(cms, xmlTemplateDocument, elementName, parameters, templateSelector);\n    }","id":73545,"modified_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters.\n     *\n     * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName,\n            Hashtable parameters, String templateSelector) throws CmsException {\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n        CmsXmlWpTemplateFile xmlTemplateDocument = (CmsXmlWpTemplateFile)getOwnTemplateFile(cms,\n                templateFile, elementName, parameters, templateSelector);\n\n        // clear session values on first load\n        String initial = (String)parameters.get(C_PARA_INITIAL);\n        if(initial != null) {\n\n            // remove all session values\n            session.removeValue(C_PARA_FOLDER);\n        }\n\n        // getting the URL to which we need to return when we're done\n        String lasturl = getLastUrl(cms, parameters);\n\n        // read the parameters\n        String foldername = (String)parameters.get(C_PARA_FOLDER);\n        if(foldername != null) {\n            int index = foldername.indexOf(\"/\", 10);\n            if(index != foldername.lastIndexOf(\"/\") ){\n                foldername = foldername.substring(0,index);\n                parameters.put(C_PARA_FOLDER, foldername);\n            }\n\n            // need the foldername in the session in case of an exception in the dialog\n            session.putValue(C_PARA_FOLDER, foldername);\n        }\n        else {\n            foldername = (String)session.getValue(C_PARA_FOLDER);\n        }\n        String action = (String)parameters.get(\"action\");\n        String newname = (String)parameters.get(C_PARA_NAME);\n        String title = (String)parameters.get(\"TITLE\"); // both for gallery and upload file\n        String step = (String)parameters.get(\"step\");\n        if(foldername == null) {\n            foldername = \"\";\n        }\n        if(\"new\".equals(action)) {\n            String galleryname = (String)parameters.get(\"NAME\");\n            String group = (String)parameters.get(\"GROUP\");\n            boolean read = parameters.get(\"READ\") != null;\n            boolean write = parameters.get(\"WRITE\") != null;\n            try {\n\n                // create the folder\n\n                // get the path from the workplace.ini\n                String superfolder = getConfigFile(cms).getDownGalleryPath();\n                CmsFolder folder = cms.createFolder(superfolder, galleryname);\n                cms.writeProperty(folder.getAbsolutePath(), C_PROPERTY_TITLE, title);\n                cms.chgrp(folder.getAbsolutePath(), group);\n                int flag = folder.getAccessFlags();\n\n                // set the access rights for 'other' users\n                if(read != ((flag & C_ACCESS_PUBLIC_READ) != 0)) {\n                    flag ^= C_ACCESS_PUBLIC_READ;\n                }\n                if(write != ((flag & C_ACCESS_PUBLIC_WRITE) != 0)) {\n                    flag ^= C_ACCESS_PUBLIC_WRITE;\n                }\n                if((flag & C_ACCESS_GROUP_READ) == 0){\n                    flag ^= C_ACCESS_GROUP_READ;\n                }\n                if((flag & C_ACCESS_GROUP_WRITE) == 0){\n                    flag ^= C_ACCESS_GROUP_WRITE;\n                }\n                if((flag & C_ACCESS_GROUP_VISIBLE) == 0){\n                    flag ^= C_ACCESS_GROUP_VISIBLE;\n                }\n                if((flag & C_ACCESS_OWNER_READ ) == 0){\n                    flag ^= C_ACCESS_OWNER_READ;\n                }\n                if((flag & C_ACCESS_OWNER_WRITE) == 0){\n                    flag ^= C_ACCESS_OWNER_WRITE;\n                }\n                if((flag & C_ACCESS_OWNER_VISIBLE) == 0){\n                    flag ^= C_ACCESS_OWNER_VISIBLE;\n                }\n                if((flag & C_ACCESS_PUBLIC_VISIBLE) == 0){\n                    flag ^= C_ACCESS_PUBLIC_VISIBLE;\n                }\n               cms.chmod(folder.getAbsolutePath(), flag);\n               cms.unlockResource(folder.getAbsolutePath());\n            }\n            catch(CmsException ex) {\n                xmlTemplateDocument.setData(\"ERRORDETAILS\", Utils.getStackTrace(ex));\n                templateSelector = \"error\";\n            }\n        }\n        else {\n            if(\"upload\".equals(action)) {\n\n                // get filename and file content if available\n                String filename = null;\n                byte[] filecontent = new byte[0];\n\n                // get the filename\n                Enumeration files = cms.getRequestContext().getRequest().getFileNames();\n                while(files.hasMoreElements()) {\n                    filename = (String)files.nextElement();\n                }\n                if(filename != null) {\n                    session.putValue(C_PARA_FILE, filename);\n                }\n                filename = (String)session.getValue(C_PARA_FILE);\n\n                // get the filecontent\n                if(filename != null) {\n                    filecontent = cms.getRequestContext().getRequest().getFile(filename);\n                }\n                if(filecontent != null) {\n                    session.putValue(C_PARA_FILECONTENT, filecontent);\n                }\n                filecontent = (byte[])session.getValue(C_PARA_FILECONTENT);\n                if(\"0\".equals(step)) {\n                    templateSelector = \"\";\n                }\n                else {\n                    if(\"1\".equals(step)) {\n\n                        // display the select filetype screen\n                        if(filename != null) {\n\n                            // check if the file size is 0\n                            if(filecontent.length == 0) {\n                                templateSelector = \"error\";\n                                xmlTemplateDocument.setData(\"details\", filename);\n                            }\n                            else {\n                                xmlTemplateDocument.setData(\"MIME\", filename);\n                                xmlTemplateDocument.setData(\"SIZE\", \"Not yet available\");\n                                xmlTemplateDocument.setData(\"FILESIZE\", new Integer(filecontent.length).toString() + \" Bytes\");\n                                xmlTemplateDocument.setData(\"FILENAME\", filename);\n                                templateSelector = \"step1\";\n                            }\n                        }\n                    }\n                    else {\n                        if(\"2\".equals(step)) {\n\n                            // check if a new filename is given\n                            if(newname != null) {\n                                filename = newname;\n                            }\n                            CmsFile file = cms.createFile(foldername, filename, filecontent, C_TYPE_PLAIN_NAME);\n                            if(title != null) {\n                                String filepath = file.getAbsolutePath();\n                                cms.writeProperty(filepath, C_PROPERTY_TITLE, title);\n                            }\n                            try {\n                                cms.getRequestContext().getResponse().sendCmsRedirect(getConfigFile(cms).getWorkplaceActionPath() + lasturl);\n                            }\n                            catch(Exception ex) {\n                                throw new CmsException(\"Redirect fails :\" + getConfigFile(cms).getWorkplaceActionPath()\n                                        + lasturl, CmsException.C_UNKNOWN_EXCEPTION, ex);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        xmlTemplateDocument.setData(\"link_value\", foldername);\n        xmlTemplateDocument.setData(\"lasturl\", lasturl);\n\n        // Finally start the processing\n        return startProcessing(cms, xmlTemplateDocument, elementName, parameters, templateSelector);\n    }","commit_id":"1432e4b4841461c6403158db7860bd1122859451","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters.\n     *\n     * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName,\n            Hashtable parameters, String templateSelector) throws CmsException {\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n        CmsXmlWpTemplateFile xmlTemplateDocument = (CmsXmlWpTemplateFile)getOwnTemplateFile(cms,\n                templateFile, elementName, parameters, templateSelector);\n\n         String unzip = (String) parameters.get(\"unzip\");\n\n        // clear session values on first load\n        String initial = (String)parameters.get(C_PARA_INITIAL);\n        if(initial != null) {\n\n            // remove all session values\n            session.removeValue(C_PARA_FOLDER);\n            session.removeValue(\"lasturl\");\n        }\n\n        // getting the URL to which we need to return when we're done\n        String lasturl = getLastUrl(cms, parameters);\n\n        // read the parameters\n        String foldername = (String)parameters.get(C_PARA_FOLDER);\n        if(foldername != null) {\n            int index = foldername.indexOf(\"/\", 8);\n            if(index != foldername.lastIndexOf(\"/\") ){\n                foldername = foldername.substring(0,index);\n                parameters.put(C_PARA_FOLDER, foldername);\n            }\n\n            // need the foldername in the session in case of an exception in the dialog\n            session.putValue(C_PARA_FOLDER, foldername);\n        }\n        else {\n            foldername = (String)session.getValue(C_PARA_FOLDER);\n        }\n        String action = (String)parameters.get(\"action\");\n        String newname = (String)parameters.get(C_PARA_NAME);\n        String title = (String)parameters.get(\"TITLE\"); // both for gallery and upload file\n        String step = (String)parameters.get(\"step\");\n        if(foldername == null) {\n            foldername = \"\";\n        }\n        if(\"new\".equals(action)) {\n            String galleryname = (String)parameters.get(\"NAME\");\n            String group = (String)parameters.get(\"GROUP\");\n            if(galleryname != null && group != null && galleryname != \"\" && group != \"\") {\n                boolean read = parameters.get(\"READ\") != null;\n                boolean write = parameters.get(\"WRITE\") != null;\n                try {\n\n                    // create the folder\n\n                    // get the path from the workplace.ini\n                    String superfolder = getConfigFile(cms).getPicGalleryPath();\n                    CmsFolder folder = cms.createFolder(superfolder, galleryname);\n                    if(title != null) {\n                        cms.writeProperty(folder.getAbsolutePath(), C_PROPERTY_TITLE, title);\n                    }\n                    cms.chgrp(folder.getAbsolutePath(), group);\n                    int flag = folder.getAccessFlags();\n\n                    // set the access rights for 'other' users\n                    if(read != ((flag & C_ACCESS_PUBLIC_READ) != 0)) {\n                        flag ^= C_ACCESS_PUBLIC_READ;\n                    }\n                    if(write != ((flag & C_ACCESS_PUBLIC_WRITE) != 0)) {\n                        flag ^= C_ACCESS_PUBLIC_WRITE;\n                    }\n                    if((flag & C_ACCESS_GROUP_READ) == 0){\n                        flag ^= C_ACCESS_GROUP_READ;\n                    }\n                    if((flag & C_ACCESS_GROUP_WRITE) == 0){\n                        flag ^= C_ACCESS_GROUP_WRITE;\n                    }\n                    if((flag & C_ACCESS_GROUP_VISIBLE) == 0){\n                        flag ^= C_ACCESS_GROUP_VISIBLE;\n                    }\n                    if((flag & C_ACCESS_OWNER_READ ) == 0){\n                        flag ^= C_ACCESS_OWNER_READ;\n                    }\n                    if((flag & C_ACCESS_OWNER_WRITE) == 0){\n                        flag ^= C_ACCESS_OWNER_WRITE;\n                    }\n                    if((flag & C_ACCESS_OWNER_VISIBLE) == 0){\n                        flag ^= C_ACCESS_OWNER_VISIBLE;\n                    }\n                    if((flag & C_ACCESS_PUBLIC_VISIBLE) == 0){\n                        flag ^= C_ACCESS_PUBLIC_VISIBLE;\n                    }\n                    cms.chmod(folder.getAbsolutePath(), flag);\n                    cms.unlockResource(folder.getAbsolutePath());\n                }\n                catch(CmsException ex) {\n                    xmlTemplateDocument.setData(\"ERRORDETAILS\", Utils.getStackTrace(ex));\n                    templateSelector = \"error\";\n                }\n            }\n            else {\n                templateSelector = \"datamissing\";\n            }\n        }\n        else {\n            if(\"upload\".equals(action)) {\n\n                // get filename and file content if available\n                String filename = null;\n                byte[] filecontent = new byte[0];\n\n                // get the filename\n                Enumeration files = cms.getRequestContext().getRequest().getFileNames();\n                while(files.hasMoreElements()) {\n                    filename = (String)files.nextElement();\n                }\n                if(filename != null) {\n                    session.putValue(C_PARA_FILE, filename);\n                }\n                filename = (String)session.getValue(C_PARA_FILE);\n\n                // get the filecontent\n                if(filename != null) {\n                    filecontent = cms.getRequestContext().getRequest().getFile(filename);\n                }\n                if(filecontent != null) {\n                    session.putValue(C_PARA_FILECONTENT, filecontent);\n                }\n                filecontent = (byte[])session.getValue(C_PARA_FILECONTENT);\n                if(\"0\".equals(step)) {\n                    templateSelector = \"\";\n                }\n                else {\n                    if(\"1\".equals(step)) {\n\n                        // display the select filetype screen\n                        if(filename != null) {\n\n                            // check if the file size is 0\n                            if(filecontent.length == 0) {\n                                templateSelector = \"error\";\n                                xmlTemplateDocument.setData(\"details\", filename);\n                            }\n                            else {\n                                if(unzip != null) {\n                                    // try to unzip the file here ...\n                                    CmsImportFolder zip = new CmsImportFolder(\n                                        filecontent, foldername, cms, true);\n                                    if( zip.isValidZipFile() ) {\n\n                                    // remove the values form the session\n                                    session.removeValue(C_PARA_FILE);\n                                    session.removeValue(C_PARA_FILECONTENT);\n                                    session.removeValue(C_PARA_NEWTYPE);\n                                    session.removeValue(\"unzip\");\n                                    // return to the filelist\n                                    try {\n                                        if((lasturl != null) && (lasturl != \"\")) {\n                                            cms.getRequestContext().getResponse().sendRedirect(lasturl);\n                                        }\n                                        else {\n                                            cms.getRequestContext().getResponse().sendCmsRedirect(\n                                                getConfigFile(cms).getWorkplaceActionPath() + C_WP_EXPLORER_FILELIST);\n                                        }\n                                    } catch(Exception ex) {\n                                        throw new CmsException(\n                                            \"Redirect fails :\" + getConfigFile(cms).getWorkplaceActionPath()\n                                            + C_WP_EXPLORER_FILELIST, CmsException.C_UNKNOWN_EXCEPTION, ex);\n                                    }\n                                    return null;\n                                    }\n                                } // else, zip was not valid, so continue ...\n                                xmlTemplateDocument.setData(\"MIME\", filename);\n                                xmlTemplateDocument.setData(\"SIZE\", \"Not yet available\");\n                                xmlTemplateDocument.setData(\"FILESIZE\",\n                                        new Integer(filecontent.length).toString() + \" Bytes\");\n                                xmlTemplateDocument.setData(\"FILENAME\", filename);\n                                templateSelector = \"step1\";\n                            }\n                        }\n                    }\n                    else {\n                        if(\"2\".equals(step)) {\n\n                            // check if a new filename is given\n                            if(newname != null) {\n                                filename = newname;\n                            }\n                            try {\n                                CmsFile file = cms.createFile(foldername, filename,\n                                       filecontent, C_TYPE_IMAGE_NAME);\n                                if(title != null) {\n                                    String filepath = file.getAbsolutePath();\n                                    cms.writeProperty(filepath, C_PROPERTY_TITLE, title);\n                                }\n                            }\n                            catch(CmsException ex) {\n                                xmlTemplateDocument.setData(\"details\", Utils.getStackTrace(ex));\n                                templateSelector = \"error\";\n                                xmlTemplateDocument.setData(\"link_value\", foldername);\n                                xmlTemplateDocument.setData(\"lasturl\", lasturl);\n                                return startProcessing(cms, xmlTemplateDocument, elementName,\n                                        parameters, templateSelector);\n                            }\n                            try {\n                                cms.getRequestContext().getResponse().sendCmsRedirect(getConfigFile(cms).getWorkplaceActionPath() + lasturl);\n                            }\n                            catch(Exception ex) {\n                                throw new CmsException(\"Redirect fails :\" + getConfigFile(cms).getWorkplaceActionPath() +\n                                        lasturl, CmsException.C_UNKNOWN_EXCEPTION, ex);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        xmlTemplateDocument.setData(\"link_value\", foldername);\n        xmlTemplateDocument.setData(\"lasturl\", lasturl);\n\n        // Finally start the processing\n        return startProcessing(cms, xmlTemplateDocument, elementName, parameters,\n                templateSelector);\n    }","id":73546,"modified_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters.\n     *\n     * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName,\n            Hashtable parameters, String templateSelector) throws CmsException {\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n        CmsXmlWpTemplateFile xmlTemplateDocument = (CmsXmlWpTemplateFile)getOwnTemplateFile(cms,\n                templateFile, elementName, parameters, templateSelector);\n\n         String unzip = (String) parameters.get(\"unzip\");\n\n        // clear session values on first load\n        String initial = (String)parameters.get(C_PARA_INITIAL);\n        if(initial != null) {\n\n            // remove all session values\n            session.removeValue(C_PARA_FOLDER);\n            session.removeValue(\"lasturl\");\n        }\n\n        // getting the URL to which we need to return when we're done\n        String lasturl = getLastUrl(cms, parameters);\n\n        // read the parameters\n        String foldername = (String)parameters.get(C_PARA_FOLDER);\n        if(foldername != null) {\n            int index = foldername.indexOf(\"/\", 6);\n            if(index != foldername.lastIndexOf(\"/\") ){\n                foldername = foldername.substring(0,index);\n                parameters.put(C_PARA_FOLDER, foldername);\n            }\n\n            // need the foldername in the session in case of an exception in the dialog\n            session.putValue(C_PARA_FOLDER, foldername);\n        }\n        else {\n            foldername = (String)session.getValue(C_PARA_FOLDER);\n        }\n        String action = (String)parameters.get(\"action\");\n        String newname = (String)parameters.get(C_PARA_NAME);\n        String title = (String)parameters.get(\"TITLE\"); // both for gallery and upload file\n        String step = (String)parameters.get(\"step\");\n        if(foldername == null) {\n            foldername = \"\";\n        }\n        if(\"new\".equals(action)) {\n            String galleryname = (String)parameters.get(\"NAME\");\n            String group = (String)parameters.get(\"GROUP\");\n            if(galleryname != null && group != null && galleryname != \"\" && group != \"\") {\n                boolean read = parameters.get(\"READ\") != null;\n                boolean write = parameters.get(\"WRITE\") != null;\n                try {\n\n                    // create the folder\n\n                    // get the path from the workplace.ini\n                    String superfolder = getConfigFile(cms).getPicGalleryPath();\n                    CmsFolder folder = cms.createFolder(superfolder, galleryname);\n                    if(title != null) {\n                        cms.writeProperty(folder.getAbsolutePath(), C_PROPERTY_TITLE, title);\n                    }\n                    cms.chgrp(folder.getAbsolutePath(), group);\n                    int flag = folder.getAccessFlags();\n\n                    // set the access rights for 'other' users\n                    if(read != ((flag & C_ACCESS_PUBLIC_READ) != 0)) {\n                        flag ^= C_ACCESS_PUBLIC_READ;\n                    }\n                    if(write != ((flag & C_ACCESS_PUBLIC_WRITE) != 0)) {\n                        flag ^= C_ACCESS_PUBLIC_WRITE;\n                    }\n                    if((flag & C_ACCESS_GROUP_READ) == 0){\n                        flag ^= C_ACCESS_GROUP_READ;\n                    }\n                    if((flag & C_ACCESS_GROUP_WRITE) == 0){\n                        flag ^= C_ACCESS_GROUP_WRITE;\n                    }\n                    if((flag & C_ACCESS_GROUP_VISIBLE) == 0){\n                        flag ^= C_ACCESS_GROUP_VISIBLE;\n                    }\n                    if((flag & C_ACCESS_OWNER_READ ) == 0){\n                        flag ^= C_ACCESS_OWNER_READ;\n                    }\n                    if((flag & C_ACCESS_OWNER_WRITE) == 0){\n                        flag ^= C_ACCESS_OWNER_WRITE;\n                    }\n                    if((flag & C_ACCESS_OWNER_VISIBLE) == 0){\n                        flag ^= C_ACCESS_OWNER_VISIBLE;\n                    }\n                    if((flag & C_ACCESS_PUBLIC_VISIBLE) == 0){\n                        flag ^= C_ACCESS_PUBLIC_VISIBLE;\n                    }\n                    cms.chmod(folder.getAbsolutePath(), flag);\n                    cms.unlockResource(folder.getAbsolutePath());\n                }\n                catch(CmsException ex) {\n                    xmlTemplateDocument.setData(\"ERRORDETAILS\", Utils.getStackTrace(ex));\n                    templateSelector = \"error\";\n                }\n            }\n            else {\n                templateSelector = \"datamissing\";\n            }\n        }\n        else {\n            if(\"upload\".equals(action)) {\n\n                // get filename and file content if available\n                String filename = null;\n                byte[] filecontent = new byte[0];\n\n                // get the filename\n                Enumeration files = cms.getRequestContext().getRequest().getFileNames();\n                while(files.hasMoreElements()) {\n                    filename = (String)files.nextElement();\n                }\n                if(filename != null) {\n                    session.putValue(C_PARA_FILE, filename);\n                }\n                filename = (String)session.getValue(C_PARA_FILE);\n\n                // get the filecontent\n                if(filename != null) {\n                    filecontent = cms.getRequestContext().getRequest().getFile(filename);\n                }\n                if(filecontent != null) {\n                    session.putValue(C_PARA_FILECONTENT, filecontent);\n                }\n                filecontent = (byte[])session.getValue(C_PARA_FILECONTENT);\n                if(\"0\".equals(step)) {\n                    templateSelector = \"\";\n                }\n                else {\n                    if(\"1\".equals(step)) {\n\n                        // display the select filetype screen\n                        if(filename != null) {\n\n                            // check if the file size is 0\n                            if(filecontent.length == 0) {\n                                templateSelector = \"error\";\n                                xmlTemplateDocument.setData(\"details\", filename);\n                            }\n                            else {\n                                if(unzip != null) {\n                                    // try to unzip the file here ...\n                                    CmsImportFolder zip = new CmsImportFolder(\n                                        filecontent, foldername, cms, true);\n                                    if( zip.isValidZipFile() ) {\n\n                                    // remove the values form the session\n                                    session.removeValue(C_PARA_FILE);\n                                    session.removeValue(C_PARA_FILECONTENT);\n                                    session.removeValue(C_PARA_NEWTYPE);\n                                    session.removeValue(\"unzip\");\n                                    // return to the filelist\n                                    try {\n                                        if((lasturl != null) && (lasturl != \"\")) {\n                                            cms.getRequestContext().getResponse().sendRedirect(lasturl);\n                                        }\n                                        else {\n                                            cms.getRequestContext().getResponse().sendCmsRedirect(\n                                                getConfigFile(cms).getWorkplaceActionPath() + C_WP_EXPLORER_FILELIST);\n                                        }\n                                    } catch(Exception ex) {\n                                        throw new CmsException(\n                                            \"Redirect fails :\" + getConfigFile(cms).getWorkplaceActionPath()\n                                            + C_WP_EXPLORER_FILELIST, CmsException.C_UNKNOWN_EXCEPTION, ex);\n                                    }\n                                    return null;\n                                    }\n                                } // else, zip was not valid, so continue ...\n                                xmlTemplateDocument.setData(\"MIME\", filename);\n                                xmlTemplateDocument.setData(\"SIZE\", \"Not yet available\");\n                                xmlTemplateDocument.setData(\"FILESIZE\",\n                                        new Integer(filecontent.length).toString() + \" Bytes\");\n                                xmlTemplateDocument.setData(\"FILENAME\", filename);\n                                templateSelector = \"step1\";\n                            }\n                        }\n                    }\n                    else {\n                        if(\"2\".equals(step)) {\n\n                            // check if a new filename is given\n                            if(newname != null) {\n                                filename = newname;\n                            }\n                            try {\n                                CmsFile file = cms.createFile(foldername, filename,\n                                       filecontent, C_TYPE_IMAGE_NAME);\n                                if(title != null) {\n                                    String filepath = file.getAbsolutePath();\n                                    cms.writeProperty(filepath, C_PROPERTY_TITLE, title);\n                                }\n                            }\n                            catch(CmsException ex) {\n                                xmlTemplateDocument.setData(\"details\", Utils.getStackTrace(ex));\n                                templateSelector = \"error\";\n                                xmlTemplateDocument.setData(\"link_value\", foldername);\n                                xmlTemplateDocument.setData(\"lasturl\", lasturl);\n                                return startProcessing(cms, xmlTemplateDocument, elementName,\n                                        parameters, templateSelector);\n                            }\n                            try {\n                                cms.getRequestContext().getResponse().sendCmsRedirect(getConfigFile(cms).getWorkplaceActionPath() + lasturl);\n                            }\n                            catch(Exception ex) {\n                                throw new CmsException(\"Redirect fails :\" + getConfigFile(cms).getWorkplaceActionPath() +\n                                        lasturl, CmsException.C_UNKNOWN_EXCEPTION, ex);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        xmlTemplateDocument.setData(\"link_value\", foldername);\n        xmlTemplateDocument.setData(\"lasturl\", lasturl);\n\n        // Finally start the processing\n        return startProcessing(cms, xmlTemplateDocument, elementName, parameters,\n                templateSelector);\n    }","commit_id":"1432e4b4841461c6403158db7860bd1122859451","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters.\n     *\n     * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName,\n            Hashtable parameters, String templateSelector) throws CmsException {\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n        CmsXmlWpTemplateFile xmlTemplateDocument = (CmsXmlWpTemplateFile)getOwnTemplateFile(cms,\n                templateFile, elementName, parameters, templateSelector);\n\n         String unzip = (String) parameters.get(\"unzip\");\n\n        // clear session values on first load\n        String initial = (String)parameters.get(C_PARA_INITIAL);\n        if(initial != null) {\n\n            // remove all session values\n            session.removeValue(C_PARA_FOLDER);\n            session.removeValue(\"lasturl\");\n        }\n\n        // getting the URL to which we need to return when we're done\n        String lasturl = getLastUrl(cms, parameters);\n\n        // read the parameters\n        String foldername = (String)parameters.get(C_PARA_FOLDER);\n        if(foldername != null) {\n\n            // need the foldername in the session in case of an exception in the dialog\n            session.putValue(C_PARA_FOLDER, foldername);\n        }\n        else {\n            foldername = (String)session.getValue(C_PARA_FOLDER);\n        }\n        String action = (String)parameters.get(\"action\");\n        String newname = (String)parameters.get(C_PARA_NAME);\n        String title = (String)parameters.get(\"TITLE\"); // both for gallery and upload file\n        String step = (String)parameters.get(\"step\");\n        if(foldername == null) {\n            foldername = \"\";\n        }\n        if(\"new\".equals(action)) {\n            String galleryname = (String)parameters.get(\"NAME\");\n            String group = (String)parameters.get(\"GROUP\");\n            if(galleryname != null && group != null && galleryname != \"\" && group != \"\") {\n                boolean read = parameters.get(\"READ\") != null;\n                boolean write = parameters.get(\"WRITE\") != null;\n                try {\n\n                    // create the folder\n\n                    // get the path from the workplace.ini\n                    String superfolder = getConfigFile(cms).getPicGalleryPath();\n                    CmsFolder folder = cms.createFolder(superfolder, galleryname);\n                    if(title != null) {\n                        cms.writeProperty(folder.getAbsolutePath(), C_PROPERTY_TITLE, title);\n                    }\n                    cms.chgrp(folder.getAbsolutePath(), group);\n                    int flag = folder.getAccessFlags();\n\n                    // set the access rights for 'other' users\n                    if(read != ((flag & C_ACCESS_PUBLIC_READ) != 0)) {\n                        flag ^= C_ACCESS_PUBLIC_READ;\n                    }\n                    if(write != ((flag & C_ACCESS_PUBLIC_WRITE) != 0)) {\n                        flag ^= C_ACCESS_PUBLIC_WRITE;\n                    }\n                    if((flag & C_ACCESS_GROUP_READ) == 0){\n                        flag ^= C_ACCESS_GROUP_READ;\n                    }\n                    if((flag & C_ACCESS_GROUP_WRITE) == 0){\n                        flag ^= C_ACCESS_GROUP_WRITE;\n                    }\n                    if((flag & C_ACCESS_GROUP_VISIBLE) == 0){\n                        flag ^= C_ACCESS_GROUP_VISIBLE;\n                    }\n                    if((flag & C_ACCESS_OWNER_READ ) == 0){\n                        flag ^= C_ACCESS_OWNER_READ;\n                    }\n                    if((flag & C_ACCESS_OWNER_WRITE) == 0){\n                        flag ^= C_ACCESS_OWNER_WRITE;\n                    }\n                    if((flag & C_ACCESS_OWNER_VISIBLE) == 0){\n                        flag ^= C_ACCESS_OWNER_VISIBLE;\n                    }\n                    if((flag & C_ACCESS_PUBLIC_VISIBLE) == 0){\n                        flag ^= C_ACCESS_PUBLIC_VISIBLE;\n                    }\n                    cms.chmod(folder.getAbsolutePath(), flag);\n                    cms.unlockResource(folder.getAbsolutePath());\n                }\n                catch(CmsException ex) {\n                    xmlTemplateDocument.setData(\"ERRORDETAILS\", Utils.getStackTrace(ex));\n                    templateSelector = \"error\";\n                }\n            }\n            else {\n                templateSelector = \"datamissing\";\n            }\n        }\n        else {\n            if(\"upload\".equals(action)) {\n\n                // get filename and file content if available\n                String filename = null;\n                byte[] filecontent = new byte[0];\n\n                // get the filename\n                Enumeration files = cms.getRequestContext().getRequest().getFileNames();\n                while(files.hasMoreElements()) {\n                    filename = (String)files.nextElement();\n                }\n                if(filename != null) {\n                    session.putValue(C_PARA_FILE, filename);\n                }\n                filename = (String)session.getValue(C_PARA_FILE);\n\n                // get the filecontent\n                if(filename != null) {\n                    filecontent = cms.getRequestContext().getRequest().getFile(filename);\n                }\n                if(filecontent != null) {\n                    session.putValue(C_PARA_FILECONTENT, filecontent);\n                }\n                filecontent = (byte[])session.getValue(C_PARA_FILECONTENT);\n                if(\"0\".equals(step)) {\n                    templateSelector = \"\";\n                }\n                else {\n                    if(\"1\".equals(step)) {\n\n                        // display the select filetype screen\n                        if(filename != null) {\n\n                            // check if the file size is 0\n                            if(filecontent.length == 0) {\n                                templateSelector = \"error\";\n                                xmlTemplateDocument.setData(\"details\", filename);\n                            }\n                            else {\n                                if(unzip != null) {\n                                    // try to unzip the file here ...\n                                    CmsImportFolder zip = new CmsImportFolder(\n                                        filecontent, foldername, cms, true);\n                                    if( zip.isValidZipFile() ) {\n\n                                    // remove the values form the session\n                                    session.removeValue(C_PARA_FILE);\n                                    session.removeValue(C_PARA_FILECONTENT);\n                                    session.removeValue(C_PARA_NEWTYPE);\n                                    session.removeValue(\"unzip\");\n                                    // return to the filelist\n                                    try {\n                                        if((lasturl != null) && (lasturl != \"\")) {\n                                            cms.getRequestContext().getResponse().sendRedirect(lasturl);\n                                        }\n                                        else {\n                                            cms.getRequestContext().getResponse().sendCmsRedirect(\n                                                getConfigFile(cms).getWorkplaceActionPath() + C_WP_EXPLORER_FILELIST);\n                                        }\n                                    } catch(Exception ex) {\n                                        throw new CmsException(\n                                            \"Redirect fails :\" + getConfigFile(cms).getWorkplaceActionPath()\n                                            + C_WP_EXPLORER_FILELIST, CmsException.C_UNKNOWN_EXCEPTION, ex);\n                                    }\n                                    return null;\n                                    }\n                                } // else, zip was not valid, so continue ...\n                                xmlTemplateDocument.setData(\"MIME\", filename);\n                                xmlTemplateDocument.setData(\"SIZE\", \"Not yet available\");\n                                xmlTemplateDocument.setData(\"FILESIZE\",\n                                        new Integer(filecontent.length).toString() + \" Bytes\");\n                                xmlTemplateDocument.setData(\"FILENAME\", filename);\n                                templateSelector = \"step1\";\n                            }\n                        }\n                    }\n                    else {\n                        if(\"2\".equals(step)) {\n\n                            // check if a new filename is given\n                            if(newname != null) {\n                                filename = newname;\n                            }\n                            try {\n                                CmsFile file = cms.createFile(foldername, filename,\n                                       filecontent, C_TYPE_IMAGE_NAME);\n                                if(title != null) {\n                                    String filepath = file.getAbsolutePath();\n                                    cms.lockResource(filepath);\n                                    cms.writeProperty(filepath, C_PROPERTY_TITLE, title);\n                                }\n                            }\n                            catch(CmsException ex) {\n                                xmlTemplateDocument.setData(\"details\", Utils.getStackTrace(ex));\n                                templateSelector = \"error\";\n                                xmlTemplateDocument.setData(\"link_value\", foldername);\n                                xmlTemplateDocument.setData(\"lasturl\", lasturl);\n                                return startProcessing(cms, xmlTemplateDocument, elementName,\n                                        parameters, templateSelector);\n                            }\n                            try {\n                                cms.getRequestContext().getResponse().sendCmsRedirect(getConfigFile(cms).getWorkplaceActionPath() + lasturl);\n                            }\n                            catch(Exception ex) {\n                                throw new CmsException(\"Redirect fails :\" + getConfigFile(cms).getWorkplaceActionPath() +\n                                        lasturl, CmsException.C_UNKNOWN_EXCEPTION, ex);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        xmlTemplateDocument.setData(\"link_value\", foldername);\n        xmlTemplateDocument.setData(\"lasturl\", lasturl);\n\n        // Finally start the processing\n        return startProcessing(cms, xmlTemplateDocument, elementName, parameters,\n                templateSelector);\n    }","id":73547,"modified_method":"/**\n     * Gets the content of a defined section in a given template file and its subtemplates\n     * with the given parameters.\n     *\n     * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n     * @param cms CmsObject Object for accessing system resources.\n     * @param templateFile Filename of the template file.\n     * @param elementName Element name of this template in our parent template.\n     * @param parameters Hashtable with all template class parameters.\n     * @param templateSelector template section that should be processed.\n     */\n\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName,\n            Hashtable parameters, String templateSelector) throws CmsException {\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n        CmsXmlWpTemplateFile xmlTemplateDocument = (CmsXmlWpTemplateFile)getOwnTemplateFile(cms,\n                templateFile, elementName, parameters, templateSelector);\n\n         String unzip = (String) parameters.get(\"unzip\");\n\n        // clear session values on first load\n        String initial = (String)parameters.get(C_PARA_INITIAL);\n        if(initial != null) {\n\n            // remove all session values\n            session.removeValue(C_PARA_FOLDER);\n            session.removeValue(\"lasturl\");\n        }\n\n        // getting the URL to which we need to return when we're done\n        String lasturl = getLastUrl(cms, parameters);\n\n        // read the parameters\n        String foldername = (String)parameters.get(C_PARA_FOLDER);\n        if(foldername != null) {\n            int index = foldername.indexOf(\"/\", 8);\n            if(index != foldername.lastIndexOf(\"/\") ){\n                foldername = foldername.substring(0,index);\n                parameters.put(C_PARA_FOLDER, foldername);\n            }\n\n            // need the foldername in the session in case of an exception in the dialog\n            session.putValue(C_PARA_FOLDER, foldername);\n        }\n        else {\n            foldername = (String)session.getValue(C_PARA_FOLDER);\n        }\n        String action = (String)parameters.get(\"action\");\n        String newname = (String)parameters.get(C_PARA_NAME);\n        String title = (String)parameters.get(\"TITLE\"); // both for gallery and upload file\n        String step = (String)parameters.get(\"step\");\n        if(foldername == null) {\n            foldername = \"\";\n        }\n        if(\"new\".equals(action)) {\n            String galleryname = (String)parameters.get(\"NAME\");\n            String group = (String)parameters.get(\"GROUP\");\n            if(galleryname != null && group != null && galleryname != \"\" && group != \"\") {\n                boolean read = parameters.get(\"READ\") != null;\n                boolean write = parameters.get(\"WRITE\") != null;\n                try {\n\n                    // create the folder\n\n                    // get the path from the workplace.ini\n                    String superfolder = getConfigFile(cms).getPicGalleryPath();\n                    CmsFolder folder = cms.createFolder(superfolder, galleryname);\n                    if(title != null) {\n                        cms.writeProperty(folder.getAbsolutePath(), C_PROPERTY_TITLE, title);\n                    }\n                    cms.chgrp(folder.getAbsolutePath(), group);\n                    int flag = folder.getAccessFlags();\n\n                    // set the access rights for 'other' users\n                    if(read != ((flag & C_ACCESS_PUBLIC_READ) != 0)) {\n                        flag ^= C_ACCESS_PUBLIC_READ;\n                    }\n                    if(write != ((flag & C_ACCESS_PUBLIC_WRITE) != 0)) {\n                        flag ^= C_ACCESS_PUBLIC_WRITE;\n                    }\n                    if((flag & C_ACCESS_GROUP_READ) == 0){\n                        flag ^= C_ACCESS_GROUP_READ;\n                    }\n                    if((flag & C_ACCESS_GROUP_WRITE) == 0){\n                        flag ^= C_ACCESS_GROUP_WRITE;\n                    }\n                    if((flag & C_ACCESS_GROUP_VISIBLE) == 0){\n                        flag ^= C_ACCESS_GROUP_VISIBLE;\n                    }\n                    if((flag & C_ACCESS_OWNER_READ ) == 0){\n                        flag ^= C_ACCESS_OWNER_READ;\n                    }\n                    if((flag & C_ACCESS_OWNER_WRITE) == 0){\n                        flag ^= C_ACCESS_OWNER_WRITE;\n                    }\n                    if((flag & C_ACCESS_OWNER_VISIBLE) == 0){\n                        flag ^= C_ACCESS_OWNER_VISIBLE;\n                    }\n                    if((flag & C_ACCESS_PUBLIC_VISIBLE) == 0){\n                        flag ^= C_ACCESS_PUBLIC_VISIBLE;\n                    }\n                    cms.chmod(folder.getAbsolutePath(), flag);\n                    cms.unlockResource(folder.getAbsolutePath());\n                }\n                catch(CmsException ex) {\n                    xmlTemplateDocument.setData(\"ERRORDETAILS\", Utils.getStackTrace(ex));\n                    templateSelector = \"error\";\n                }\n            }\n            else {\n                templateSelector = \"datamissing\";\n            }\n        }\n        else {\n            if(\"upload\".equals(action)) {\n\n                // get filename and file content if available\n                String filename = null;\n                byte[] filecontent = new byte[0];\n\n                // get the filename\n                Enumeration files = cms.getRequestContext().getRequest().getFileNames();\n                while(files.hasMoreElements()) {\n                    filename = (String)files.nextElement();\n                }\n                if(filename != null) {\n                    session.putValue(C_PARA_FILE, filename);\n                }\n                filename = (String)session.getValue(C_PARA_FILE);\n\n                // get the filecontent\n                if(filename != null) {\n                    filecontent = cms.getRequestContext().getRequest().getFile(filename);\n                }\n                if(filecontent != null) {\n                    session.putValue(C_PARA_FILECONTENT, filecontent);\n                }\n                filecontent = (byte[])session.getValue(C_PARA_FILECONTENT);\n                if(\"0\".equals(step)) {\n                    templateSelector = \"\";\n                }\n                else {\n                    if(\"1\".equals(step)) {\n\n                        // display the select filetype screen\n                        if(filename != null) {\n\n                            // check if the file size is 0\n                            if(filecontent.length == 0) {\n                                templateSelector = \"error\";\n                                xmlTemplateDocument.setData(\"details\", filename);\n                            }\n                            else {\n                                if(unzip != null) {\n                                    // try to unzip the file here ...\n                                    CmsImportFolder zip = new CmsImportFolder(\n                                        filecontent, foldername, cms, true);\n                                    if( zip.isValidZipFile() ) {\n\n                                    // remove the values form the session\n                                    session.removeValue(C_PARA_FILE);\n                                    session.removeValue(C_PARA_FILECONTENT);\n                                    session.removeValue(C_PARA_NEWTYPE);\n                                    session.removeValue(\"unzip\");\n                                    // return to the filelist\n                                    try {\n                                        if((lasturl != null) && (lasturl != \"\")) {\n                                            cms.getRequestContext().getResponse().sendRedirect(lasturl);\n                                        }\n                                        else {\n                                            cms.getRequestContext().getResponse().sendCmsRedirect(\n                                                getConfigFile(cms).getWorkplaceActionPath() + C_WP_EXPLORER_FILELIST);\n                                        }\n                                    } catch(Exception ex) {\n                                        throw new CmsException(\n                                            \"Redirect fails :\" + getConfigFile(cms).getWorkplaceActionPath()\n                                            + C_WP_EXPLORER_FILELIST, CmsException.C_UNKNOWN_EXCEPTION, ex);\n                                    }\n                                    return null;\n                                    }\n                                } // else, zip was not valid, so continue ...\n                                xmlTemplateDocument.setData(\"MIME\", filename);\n                                xmlTemplateDocument.setData(\"SIZE\", \"Not yet available\");\n                                xmlTemplateDocument.setData(\"FILESIZE\",\n                                        new Integer(filecontent.length).toString() + \" Bytes\");\n                                xmlTemplateDocument.setData(\"FILENAME\", filename);\n                                templateSelector = \"step1\";\n                            }\n                        }\n                    }\n                    else {\n                        if(\"2\".equals(step)) {\n\n                            // check if a new filename is given\n                            if(newname != null) {\n                                filename = newname;\n                            }\n                            try {\n                                CmsFile file = cms.createFile(foldername, filename,\n                                       filecontent, C_TYPE_IMAGE_NAME);\n                                if(title != null) {\n                                    String filepath = file.getAbsolutePath();\n                                    cms.writeProperty(filepath, C_PROPERTY_TITLE, title);\n                                }\n                            }\n                            catch(CmsException ex) {\n                                xmlTemplateDocument.setData(\"details\", Utils.getStackTrace(ex));\n                                templateSelector = \"error\";\n                                xmlTemplateDocument.setData(\"link_value\", foldername);\n                                xmlTemplateDocument.setData(\"lasturl\", lasturl);\n                                return startProcessing(cms, xmlTemplateDocument, elementName,\n                                        parameters, templateSelector);\n                            }\n                            try {\n                                cms.getRequestContext().getResponse().sendCmsRedirect(getConfigFile(cms).getWorkplaceActionPath() + lasturl);\n                            }\n                            catch(Exception ex) {\n                                throw new CmsException(\"Redirect fails :\" + getConfigFile(cms).getWorkplaceActionPath() +\n                                        lasturl, CmsException.C_UNKNOWN_EXCEPTION, ex);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        xmlTemplateDocument.setData(\"link_value\", foldername);\n        xmlTemplateDocument.setData(\"lasturl\", lasturl);\n\n        // Finally start the processing\n        return startProcessing(cms, xmlTemplateDocument, elementName, parameters,\n                templateSelector);\n    }","commit_id":"6adf85b8c3cce457ea243a4ee36d0ad36471d7ba","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets the content of a given template file.\n     *\n     * @param cms CmsObject Object for accessing system resources\n     * @param templateFile Filename of the template file\n     * @param elementName <em>not used here<\/em>.\n     * @param parameters <em>not used here<\/em>.\n     * @return Unprocessed content of the given template file.\n     * @exception CmsException\n     */\n\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName,\n            Hashtable parameters) throws CmsException {\n        if(A_OpenCms.isLogging() && I_CmsLogChannels.C_PREPROCESSOR_IS_LOGGING && C_DEBUG) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, \"[CmsDumpTemplate] Now dumping contents of file \"\n                    + templateFile);\n        }\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n        CmsXmlWpTemplateFile templateDocument = new CmsXmlWpTemplateFile(cms, templateFile);\n        CmsXmlLanguageFile lang = templateDocument.getLanguageFile();\n\n        // get the right folder\n        String currentFolder = (String)parameters.get(\"folder\");\n        if((currentFolder != null) && (!\"\".equals(currentFolder)) && folderExists(cms,\n                currentFolder)) {\n            session.putValue(C_PARA_FILELIST, currentFolder);\n        }else {\n            currentFolder = (String)session.getValue(C_PARA_FILELIST);\n            if((currentFolder == null) || (!folderExists(cms, currentFolder))) {\n                currentFolder = cms.rootFolder().getAbsolutePath();\n                session.putValue(C_PARA_FILELIST, currentFolder);\n            }\n        }\n\n        // if the parameter mode=listonly is set, only the list will be shown\n        boolean listonly = \"listonly\".equals(parameters.get(\"mode\"));\n\n        // get the checksum\n        String checksum = (String)parameters.get(\"check\");\n        boolean newTreePlease = true;\n        long check = -1;\n        try {\n            check = Long.parseLong(checksum);\n            if(check == cms.getFileSystemFolderChanges()) {\n                newTreePlease = false;\n            }\n        }catch(Exception e) {\n        }\n        check = cms.getFileSystemFolderChanges();\n        // get the currentFolder Id\n        int currentFolderId = (cms.readFolder(currentFolder)).getResourceId();\n        // start creating content\n        StringBuffer content = new StringBuffer();\n        content.append(\"<html> \\n<head> \\n<script language=JavaScript>\\n\");\n        content.append(\"function initialize() {\\n\");\n\n        if(listonly) {\n            content.append(\" top.openfolderMethod='openthisfolderflat';\\n\");\n        } else {\n            content.append(\" top.openfolderMethod='openthisfolder';\\n\");\n        }\n\n        // the help_url\n        content.append(\" top.help_url='ExplorerAnsicht/index.html';\\n\");\n        // the project\n        content.append(\" top.setProject(\" + cms.getRequestContext().currentProject().getId() + \");\\n\");\n        // the onlineProject\n        content.append(\" top.setOnlineProject(\" + cms.onlineProject().getId() + \");\\n\");\n        // set the checksum for the tree\n        content.append(\" top.setChecksum(\" + check + \");\\n\");\n        // set the writeAccess for the current Folder\n        CmsFolder test = cms.readFolder(currentFolder);\n        boolean writeAccess = test.getProjectId() == cms.getRequestContext().currentProject().getId();\n        content.append(\" top.enableNewButton(\" + writeAccess + \");\\n\");\n        // the folder\n        content.append(\" top.setDirectory(\" + currentFolderId + \",\\\"\" + currentFolder + \"\\\");\\n\");\n        content.append(\" top.rD();\\n\\n\");\n        // now the entries for the filelist\n        Vector resources = cms.getResourcesInFolder(currentFolder);\n        for(int i = 0;i < resources.size();i++) {\n            CmsResource res = (CmsResource)resources.elementAt(i);\n            content.append(\" top.aF(\");\n            // the name\n            content.append(\"\\\"\" + res.getName() + \"\\\", \");\n            // the path\n            content.append(\"\\\"\" + res.getPath() + \"\\\", \");\n            // the title\n            String title = \"\";\n            try {\n                title = cms.readProperty(res.getAbsolutePath(), C_PROPERTY_TITLE);\n            }catch(CmsException e) {\n            }\n            if(title == null) {\n                title = \"\";\n            }\n            content.append(\"\\\"\" + getChars(title) + \"\\\", \");\n            // the type\n            content.append(\"\\\"\" + res.getType() + \"\\\", \");\n            // date of last change\n            content.append(\"\\\"\" + Utils.getNiceDate(res.getDateLastModified()) + \"\\\", \");\n            // TODO:user who changed it\n            content.append(\"\\\"\" + \"TODO\" + \"\\\", \");\n            // date\n            content.append(\"\\\"\" + Utils.getNiceDate(res.getDateCreated()) + \"\\\", \");\n            // size\n            if(res.isFolder()) {\n                content.append(\"\\\"\" + \"\" + \"\\\", \");\n            }else {\n                content.append(\"\\\"\" + res.getLength() + \"\\\", \");\n            }\n            // state\n            content.append(\"\" + res.getState() + \", \");\n            // project\n            content.append(\"\\\"\" + res.getProjectId() + \"\\\", \");\n            // owner\n            content.append(\"\\\"\" + cms.readUser(res.getOwnerId()).getName() + \"\\\", \");\n            // group\n            content.append(\"\\\"\" + cms.readGroup(res).getName() + \"\\\", \");\n            // accessFlags\n            content.append(\"\\\"\" + res.getAccessFlags() + \"\\\", \");\n            // locked by\n            if(res.isLockedBy() == C_UNKNOWN_ID) {\n                content.append(\"\\\"\" + \"\" + \"\\\", \");\n            }else {\n                content.append(\"\\\"\" + cms.lockedBy(res).getName() + \"\\\", \");\n            }\n            // locked in project\n            int lockedInProject = res.getLockedInProject();\n            String lockedInProjectName = \"\";\n            try {\n                lockedInProjectName = cms.readProject(lockedInProject).getName();\n            } catch(CmsException exc) {\n                // ignore the exception - this is an old project so ignore it\n            }\n            content.append(\"\\\"\" + lockedInProjectName + \"\\\", \" + lockedInProject + \");\\n\");\n        }\n\n        //  now the tree, only if changed\n        if(newTreePlease && (!listonly)) {\n            content.append(\"\\n top.rT();\\n\");\n            Vector tree = cms.getFolderTree();\n            int startAt = 1;\n            int parentId;\n            boolean grey = false;\n            int onlineProjectId = cms.onlineProject().getId();\n            if(onlineProjectId == cms.getRequestContext().currentProject().getId()) {\n\n                // all easy: we are in the onlineProject\n                CmsFolder rootFolder = (CmsFolder)tree.elementAt(0);\n                content.append(\"top.aC(\");\n                content.append(rootFolder.getResourceId() + \", \");\n                content.append(\"\\\"\" + lang.getDataValue(\"title.rootfolder\") + \"\\\", \");\n                content.append(rootFolder.getParentId() + \", false);\\n\");\n                for(int i = startAt;i < tree.size();i++) {\n                    CmsFolder folder = (CmsFolder)tree.elementAt(i);\n                    content.append(\"top.aC(\");\n                    // id\n                    content.append(folder.getResourceId() + \", \");\n                    // name\n                    content.append(\"\\\"\" + folder.getName() + \"\\\", \");\n                    // parentId\n                    content.append(folder.getParentId() + \", false);\\n\");\n                }\n            }else {\n                // offline Project\n                Hashtable idMixer = new Hashtable();\n                CmsFolder rootFolder = (CmsFolder)tree.elementAt(0);\n                String folderToIgnore = null;\n                if(rootFolder.getProjectId() != onlineProjectId) {\n                    startAt = 2;\n                    grey = false;\n                    idMixer.put(new Integer(((CmsFolder)tree.elementAt(1)).getResourceId()),\n                            new Integer(rootFolder.getResourceId()));\n                }else {\n                    grey = true;\n                }\n                content.append(\"top.aC(\");\n                content.append(rootFolder.getResourceId() + \", \");\n                content.append(\"\\\"\" + lang.getDataValue(\"title.rootfolder\") + \"\\\", \");\n                content.append(rootFolder.getParentId() + \", \" + grey + \");\\n\");\n                for(int i = startAt;i < tree.size();i++) {\n                    CmsFolder folder = (CmsFolder)tree.elementAt(i);\n                    if((folder.getState() == C_STATE_DELETED) || (folder.getAbsolutePath().equals(folderToIgnore))) {\n\n                        // if the folder is deleted - ignore it and the following online res\n                        folderToIgnore = folder.getAbsolutePath();\n                    }else {\n                        if(folder.getProjectId() != onlineProjectId) {\n                            grey = false;\n                            parentId = folder.getParentId();\n                            try {\n                                // the next res is the same res in the online-project: ignore it!\n                                if(folder.getAbsolutePath().equals(((CmsFolder)tree.elementAt(i + 1)).getAbsolutePath())) {\n                                    i++;\n                                    idMixer.put(new Integer(((CmsFolder)tree.elementAt(i)).getResourceId()),\n                                            new Integer(folder.getResourceId()));\n                                }\n                            }catch(IndexOutOfBoundsException exc) {\n                            // ignore the exception, this was the last resource\n                            }\n                        }else {\n                            grey = true;\n                            parentId = folder.getParentId();\n                            if(idMixer.containsKey(new Integer(parentId))) {\n                                parentId = ((Integer)idMixer.get(new Integer(parentId))).intValue();\n                            }\n                        }\n                        content.append(\"top.aC(\");\n                        // id\n                        content.append(folder.getResourceId() + \", \");\n                        // name\n                        content.append(\"\\\"\" + folder.getName() + \"\\\", \");\n                        // parentId\n                        content.append(parentId + \", \" + grey + \");\\n\");\n                    }\n                }\n            }\n        }\n        if(listonly) {\n            // only show the filelist\n            content.append(\" top.dUL(document); \\n\");\n        } else {\n            // update all frames\n            content.append(\" top.dU(document); \\n\");\n        }\n        content.append(\"}\\n\");\n        content.append(\"<\/script>\\n<\/head> \\n<BODY onLoad=\\\"initialize()\\\"><\/BODY> \\n<\/html>\\n\");\n\n        return (content.toString()).getBytes();\n    }","id":73548,"modified_method":"/**\n     * Gets the content of a given template file.\n     *\n     * @param cms CmsObject Object for accessing system resources\n     * @param templateFile Filename of the template file\n     * @param elementName <em>not used here<\/em>.\n     * @param parameters <em>not used here<\/em>.\n     * @return Unprocessed content of the given template file.\n     * @exception CmsException\n     */\n\n    public byte[] getContent(CmsObject cms, String templateFile, String elementName,\n            Hashtable parameters) throws CmsException {\n        if(A_OpenCms.isLogging() && I_CmsLogChannels.C_PREPROCESSOR_IS_LOGGING && C_DEBUG) {\n            A_OpenCms.log(C_OPENCMS_DEBUG, \"[CmsDumpTemplate] Now dumping contents of file \"\n                    + templateFile);\n        }\n        I_CmsSession session = cms.getRequestContext().getSession(true);\n        CmsXmlWpTemplateFile templateDocument = new CmsXmlWpTemplateFile(cms, templateFile);\n        CmsXmlLanguageFile lang = templateDocument.getLanguageFile();\n\n        // get the right folder\n        String currentFolder = (String)parameters.get(\"folder\");\n        if((currentFolder != null) && (!\"\".equals(currentFolder)) && folderExists(cms,\n                currentFolder)) {\n            session.putValue(C_PARA_FILELIST, currentFolder);\n        }else {\n            currentFolder = (String)session.getValue(C_PARA_FILELIST);\n            if((currentFolder == null) || (!folderExists(cms, currentFolder))) {\n                currentFolder = cms.rootFolder().getAbsolutePath();\n                session.putValue(C_PARA_FILELIST, currentFolder);\n            }\n        }\n\n        // if the parameter mode=listonly is set, only the list will be shown\n        boolean listonly = \"listonly\".equals(parameters.get(\"mode\"));\n\n        // the flaturl to use for changing folders\n        String flaturl = (String) parameters.get(\"flaturl\");\n\n        // get the checksum\n        String checksum = (String)parameters.get(\"check\");\n        boolean newTreePlease = true;\n        long check = -1;\n        try {\n            check = Long.parseLong(checksum);\n            if(check == cms.getFileSystemFolderChanges()) {\n                newTreePlease = false;\n            }\n        }catch(Exception e) {\n        }\n        check = cms.getFileSystemFolderChanges();\n        // get the currentFolder Id\n        int currentFolderId = (cms.readFolder(currentFolder)).getResourceId();\n        // start creating content\n        StringBuffer content = new StringBuffer();\n        content.append(\"<html> \\n<head> \\n<script language=JavaScript>\\n\");\n        content.append(\"function initialize() {\\n\");\n\n        if(listonly) {\n            content.append(\" top.openfolderMethod='openthisfolderflat';\\n\");\n        } else {\n            content.append(\" top.openfolderMethod='openthisfolder';\\n\");\n        }\n\n        // the flaturl\n        if(flaturl != null) {\n            content.append(\" top.flaturl='\" + flaturl + \"';\\n\");\n        }\n\n        // the help_url\n        content.append(\" top.help_url='ExplorerAnsicht/index.html';\\n\");\n        // the project\n        content.append(\" top.setProject(\" + cms.getRequestContext().currentProject().getId() + \");\\n\");\n        // the onlineProject\n        content.append(\" top.setOnlineProject(\" + cms.onlineProject().getId() + \");\\n\");\n        // set the checksum for the tree\n        content.append(\" top.setChecksum(\" + check + \");\\n\");\n        // set the writeAccess for the current Folder\n        CmsFolder test = cms.readFolder(currentFolder);\n        boolean writeAccess = test.getProjectId() == cms.getRequestContext().currentProject().getId();\n        content.append(\" top.enableNewButton(\" + writeAccess + \");\\n\");\n        // the folder\n        content.append(\" top.setDirectory(\" + currentFolderId + \",\\\"\" + currentFolder + \"\\\");\\n\");\n        content.append(\" top.rD();\\n\\n\");\n        // now the entries for the filelist\n        Vector resources = cms.getResourcesInFolder(currentFolder);\n        for(int i = 0;i < resources.size();i++) {\n            CmsResource res = (CmsResource)resources.elementAt(i);\n            content.append(\" top.aF(\");\n            // the name\n            content.append(\"\\\"\" + res.getName() + \"\\\", \");\n            // the path\n            content.append(\"\\\"\" + res.getPath() + \"\\\", \");\n            // the title\n            String title = \"\";\n            try {\n                title = cms.readProperty(res.getAbsolutePath(), C_PROPERTY_TITLE);\n            }catch(CmsException e) {\n            }\n            if(title == null) {\n                title = \"\";\n            }\n            content.append(\"\\\"\" + getChars(title) + \"\\\", \");\n            // the type\n            content.append(\"\\\"\" + res.getType() + \"\\\", \");\n            // date of last change\n            content.append(\"\\\"\" + Utils.getNiceDate(res.getDateLastModified()) + \"\\\", \");\n            // TODO:user who changed it\n            content.append(\"\\\"\" + \"TODO\" + \"\\\", \");\n            // date\n            content.append(\"\\\"\" + Utils.getNiceDate(res.getDateCreated()) + \"\\\", \");\n            // size\n            if(res.isFolder()) {\n                content.append(\"\\\"\" + \"\" + \"\\\", \");\n            }else {\n                content.append(\"\\\"\" + res.getLength() + \"\\\", \");\n            }\n            // state\n            content.append(\"\" + res.getState() + \", \");\n            // project\n            content.append(\"\\\"\" + res.getProjectId() + \"\\\", \");\n            // owner\n            content.append(\"\\\"\" + cms.readUser(res.getOwnerId()).getName() + \"\\\", \");\n            // group\n            content.append(\"\\\"\" + cms.readGroup(res).getName() + \"\\\", \");\n            // accessFlags\n            content.append(\"\\\"\" + res.getAccessFlags() + \"\\\", \");\n            // locked by\n            if(res.isLockedBy() == C_UNKNOWN_ID) {\n                content.append(\"\\\"\" + \"\" + \"\\\", \");\n            }else {\n                content.append(\"\\\"\" + cms.lockedBy(res).getName() + \"\\\", \");\n            }\n            // locked in project\n            int lockedInProject = res.getLockedInProject();\n            String lockedInProjectName = \"\";\n            try {\n                lockedInProjectName = cms.readProject(lockedInProject).getName();\n            } catch(CmsException exc) {\n                // ignore the exception - this is an old project so ignore it\n            }\n            content.append(\"\\\"\" + lockedInProjectName + \"\\\", \" + lockedInProject + \");\\n\");\n        }\n\n        //  now the tree, only if changed\n        if(newTreePlease && (!listonly)) {\n            content.append(\"\\n top.rT();\\n\");\n            Vector tree = cms.getFolderTree();\n            int startAt = 1;\n            int parentId;\n            boolean grey = false;\n            int onlineProjectId = cms.onlineProject().getId();\n            if(onlineProjectId == cms.getRequestContext().currentProject().getId()) {\n\n                // all easy: we are in the onlineProject\n                CmsFolder rootFolder = (CmsFolder)tree.elementAt(0);\n                content.append(\"top.aC(\");\n                content.append(rootFolder.getResourceId() + \", \");\n                content.append(\"\\\"\" + lang.getDataValue(\"title.rootfolder\") + \"\\\", \");\n                content.append(rootFolder.getParentId() + \", false);\\n\");\n                for(int i = startAt;i < tree.size();i++) {\n                    CmsFolder folder = (CmsFolder)tree.elementAt(i);\n                    content.append(\"top.aC(\");\n                    // id\n                    content.append(folder.getResourceId() + \", \");\n                    // name\n                    content.append(\"\\\"\" + folder.getName() + \"\\\", \");\n                    // parentId\n                    content.append(folder.getParentId() + \", false);\\n\");\n                }\n            }else {\n                // offline Project\n                Hashtable idMixer = new Hashtable();\n                CmsFolder rootFolder = (CmsFolder)tree.elementAt(0);\n                String folderToIgnore = null;\n                if(rootFolder.getProjectId() != onlineProjectId) {\n                    startAt = 2;\n                    grey = false;\n                    idMixer.put(new Integer(((CmsFolder)tree.elementAt(1)).getResourceId()),\n                            new Integer(rootFolder.getResourceId()));\n                }else {\n                    grey = true;\n                }\n                content.append(\"top.aC(\");\n                content.append(rootFolder.getResourceId() + \", \");\n                content.append(\"\\\"\" + lang.getDataValue(\"title.rootfolder\") + \"\\\", \");\n                content.append(rootFolder.getParentId() + \", \" + grey + \");\\n\");\n                for(int i = startAt;i < tree.size();i++) {\n                    CmsFolder folder = (CmsFolder)tree.elementAt(i);\n                    if((folder.getState() == C_STATE_DELETED) || (folder.getAbsolutePath().equals(folderToIgnore))) {\n\n                        // if the folder is deleted - ignore it and the following online res\n                        folderToIgnore = folder.getAbsolutePath();\n                    }else {\n                        if(folder.getProjectId() != onlineProjectId) {\n                            grey = false;\n                            parentId = folder.getParentId();\n                            try {\n                                // the next res is the same res in the online-project: ignore it!\n                                if(folder.getAbsolutePath().equals(((CmsFolder)tree.elementAt(i + 1)).getAbsolutePath())) {\n                                    i++;\n                                    idMixer.put(new Integer(((CmsFolder)tree.elementAt(i)).getResourceId()),\n                                            new Integer(folder.getResourceId()));\n                                }\n                            }catch(IndexOutOfBoundsException exc) {\n                            // ignore the exception, this was the last resource\n                            }\n                        }else {\n                            grey = true;\n                            parentId = folder.getParentId();\n                            if(idMixer.containsKey(new Integer(parentId))) {\n                                parentId = ((Integer)idMixer.get(new Integer(parentId))).intValue();\n                            }\n                        }\n                        content.append(\"top.aC(\");\n                        // id\n                        content.append(folder.getResourceId() + \", \");\n                        // name\n                        content.append(\"\\\"\" + folder.getName() + \"\\\", \");\n                        // parentId\n                        content.append(parentId + \", \" + grey + \");\\n\");\n                    }\n                }\n            }\n        }\n        if(listonly) {\n            // only show the filelist\n            content.append(\" top.dUL(document); \\n\");\n        } else {\n            // update all frames\n            content.append(\" top.dU(document); \\n\");\n        }\n        content.append(\"}\\n\");\n        content.append(\"<\/script>\\n<\/head> \\n<BODY onLoad=\\\"initialize()\\\"><\/BODY> \\n<\/html>\\n\");\n\n        return (content.toString()).getBytes();\n    }","commit_id":"6adf85b8c3cce457ea243a4ee36d0ad36471d7ba","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n\t * Gets the content of a defined section in a given template file and its subtemplates\n\t * with the given parameters. \n\t * \n\t * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n\t * @param cms CmsObject Object for accessing system resources.\n\t * @param templateFile Filename of the template file.\n\t * @param elementName Element name of this template in our parent template.\n\t * @param parameters Hashtable with all template class parameters.\n\t * @param templateSelector template section that should be processed.\n\t */\n\tpublic byte[] getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters, String templateSelector) throws CmsException {\n\t\t\n\t\tCmsRequestContext reqCont = cms.getRequestContext();\n\t\tHttpServletRequest orgReq = (HttpServletRequest)reqCont.getRequest().getOriginalRequest();\n\t\tI_CmsSession session = cms.getRequestContext().getSession(true);\n\t\t// TODO: check, if this is neede: CmsFile editFile = null;\n\n\t\t// Get the user's browser\n\t\tString browser = orgReq.getHeader(\"user-agent\");                \n\t\tString hostName = orgReq.getScheme() + \"://\" + orgReq.getHeader(\"HOST\");\n\t\t\t\t\n\t\tEncoder encoder = new Encoder();\n\t\t\n\t\t// Get all URL parameters\n\t\tString content = (String)parameters.get(C_PARA_CONTENT);            \n\t\tString body = (String)parameters.get(\"body\");\n\t\tString file = (String)parameters.get(C_PARA_FILE);\n\t\tString editor = (String)parameters.get(\"editor\");\n\t\tString title = (String)parameters.get(C_PARA_TITLE);\n\t\tString bodytitle = (String)parameters.get(\"bodytitle\");\n\t\tString layoutTemplateFilename = (String)parameters.get(\"template\");\n\t\tString bodyElementClassName = (String)parameters.get(\"bodyclass\");\n\t\tString bodyElementFilename = (String)parameters.get(\"bodyfile\");\n\t\tString action = (String)parameters.get(C_PARA_ACTION);\n\t\t\n\t\t// Get all session parameters\n\t\tString oldEdit = (String)session.getValue(\"te_oldedit\");\n\t\t// TODO: check, if this is neede: String bodytag = (String)session.getValue(\"bodytag\");\n\t\tString oldLayoutFilename = (String)session.getValue(\"te_oldlayout\");\n\t\tString oldTitle = (String)session.getValue(\"te_title\");\n\t\tString oldBody = (String)session.getValue(\"te_oldbody\");\n\t\tString oldBodytitle = (String)session.getValue(\"te_oldbodytitle\");\n\t\tString layoutTemplateClassName = (String)session.getValue(\"te_templateclass\");\n\t\tString tempPageFilename = (String)session.getValue(\"te_temppagefile\");\n\t\tString tempBodyFilename = (String)session.getValue(\"te_tempbodyfile\");\n\t\tString style = (String)session.getValue(\"te_stylesheet\");\n\t\t\t\t\n\t\t//boolean existsContentParam = (content!=null && (!\"\".equals(content)));\n\t\tboolean existsContentParam = content!=null;\n\n\t\tboolean existsFileParam = (file!=null && (!\"\".equals(file)));\n\t\tboolean saveRequested = ((action != null) && (C_EDIT_ACTION_SAVE.equals(action) || C_EDIT_ACTION_SAVEEXIT.equals(action)));\n\t\tboolean exitRequested = ((action != null) && (C_EDIT_ACTION_EXIT.equals(action) || C_EDIT_ACTION_SAVEEXIT.equals(action)));\n\t\tboolean bodychangeRequested = ((oldBody != null) && (body != null) && (!(oldBody.equals(body))));\n\t\tboolean templatechangeRequested = (oldLayoutFilename != null && layoutTemplateFilename != null\n\t\t\t\t\t\t\t\t\t\t   && (!(oldLayoutFilename.equals(layoutTemplateFilename))));\n\t\tboolean titlechangeRequested = (oldTitle != null && title != null && (!(oldTitle.equals(title))));\n\t\tboolean newbodyRequested = ((action != null) && \"newbody\".equals(action));        \n\t\tboolean previewRequested = ((action != null) && \"preview\".equals(action));        \n\t\tboolean bodytitlechangeRequested = (oldBodytitle != null && bodytitle != null\n\t\t\t\t\t\t\t\t\t\t   && (!(oldBodytitle.equals(bodytitle))));\n\t\t\n\t\t// Check if there is a file parameter in the request\n\t\tif(! existsFileParam) {\n\t\t\tthrowException(\"No \\\"file\\\" parameter given. Don't know which file should be edited.\");\n\t\t}\n\t\t\t\t\n\t\t// If there is no content parameter this seems to be\n\t\t// a new request of the page editor.\n\t\t// So we have to read all files and set some initial values.\n\t\tif(!existsContentParam) {\n\t\t\tCmsXmlControlFile originalControlFile = new CmsXmlControlFile(cms, file);\n\t\t\t\t\t\t\n\t\t\tif(originalControlFile.isElementClassDefined(C_BODY_ELEMENT)) {\n\t\t\t\tbodyElementClassName = originalControlFile.getElementClass(C_BODY_ELEMENT);\n\t\t\t} \n\t\t\t\t\n\t\t\tif(originalControlFile.isElementTemplateDefined(C_BODY_ELEMENT)) {\n\t\t\t\tbodyElementFilename = originalControlFile.getElementTemplate(C_BODY_ELEMENT);\n\t\t\t}\n\t\t\t\n\t\t\tif((bodyElementClassName == null) || (bodyElementFilename == null)) {\n\t\t\t\t// Either the template class or the template file \n\t\t\t\t// for the body element could not be determined.\n\t\t\t\t// BUG: Send error here\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t// Check, if the selected page file is locked\n\t\t\tCmsResource pageFileResource = cms.readFileHeader(file);\n\t\t\tif(!pageFileResource.isLocked()) {\n\t\t\t\t// BUG: Check only, dont't lock here!\n\t\t\t\tcms.lockResource(file);\n\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t// The content file must be locked before editing            \n\t\t\tCmsResource contentFileResource = cms.readFileHeader(bodyElementFilename);\n\t\t\tif(!contentFileResource.isLocked()) {\n\t\t\t\tcms.lockResource(bodyElementFilename);\n\t\t\t}\n\t\t\t\n\t\t\t// Now get the currently selected master template file\n\t\t\tlayoutTemplateFilename = originalControlFile.getMasterTemplate();\n\t\t\tlayoutTemplateClassName = originalControlFile.getTemplateClass();\n\t\t\t\n\t\t\tint browserId;\n\t\t\t\n\t\t\tif(browser.indexOf(\"MSIE\") >-1) {\n\t\t    \tbrowserId = 0;\n\t\t    } else {\n\t\t    \tbrowserId = 1;\n\t    \t}\n\n\t\t\tif(editor == null || \"\".equals(editor)) {\n\t\t\t\teditor = this.C_SELECTBOX_EDITORVIEWS[C_SELECTBOX_EDITORVIEWS_DEFAULT[browserId]];    \n\t\t\t\tsession.putValue(\"te_pageeditor\", editor);\n\t\t\t\tparameters.put(\"editor\", editor);\n\t\t\t}\n\t\t\t\n\t\t\t// And finally the document title\n\t\t\ttitle = cms.readProperty(file, C_PROPERTY_TITLE);\n\t\t\tif(title == null) {\n\t\t\t\ttitle = \"\";\n\t\t\t}\n\n\t\t\t// Okay. All values are initialized. Now we can create\n\t\t\t// the temporary files.\n\t\t\ttempPageFilename = createTemporaryFile(cms, pageFileResource);\n\t\t\ttempBodyFilename = createTemporaryFile(cms, contentFileResource);             \n\t\t\tsession.putValue(\"te_temppagefile\", tempPageFilename);\n\t\t\tsession.putValue(\"te_tempbodyfile\", tempBodyFilename);                        \n\t\t} \n\t\t\t\t\n\t\t\t   \n\t\t// Get the XML parsed content of the layout file.\n\t\t// This can be done by calling the getOwnTemplateFile() method of the\n\t\t// layout's template class.\n\t\t// The content is needed to determine the HTML style of the body element.\n\t\tObject tempObj = CmsTemplateClassManager.getClassInstance(cms, layoutTemplateClassName);\n\t\tCmsXmlTemplate layoutTemplateClassObject = (CmsXmlTemplate)tempObj;\n\t\tCmsXmlTemplateFile layoutTemplateFile = layoutTemplateClassObject.getOwnTemplateFile(cms, layoutTemplateFilename, null, parameters, null);                   \n\t\t\n\t\t// Get the XML parsed content of the body file.        \n\t\t// This can be done by calling the getOwnTemplateFile() method of the\n\t\t// body's template class.\n\t\ttempObj = CmsTemplateClassManager.getClassInstance(cms, bodyElementClassName);\n\t\tCmsXmlTemplate bodyElementClassObject = (CmsXmlTemplate)tempObj;\n\t\tCmsXmlTemplateFile bodyTemplateFile = bodyElementClassObject.getOwnTemplateFile(cms, tempBodyFilename, C_BODY_ELEMENT, parameters, null);\n\n\t\t// Get the temporary page file object\n\t\tCmsXmlControlFile temporaryControlFile = new CmsXmlControlFile(cms, tempPageFilename);\n\t\t\n\t\tif(!existsContentParam) {\n\t\t\tVector allBodys = bodyTemplateFile.getAllSections();\n\t\t\tif(allBodys == null || allBodys.size() == 0) {\n\t\t\t\tbody = \"\";\n\t\t\t} else {\n\t\t\t\tbody = (String)allBodys.elementAt(0);\n\t\t\t}\n\n\t\t\t// bodytitle = bodyTemplateFile.getSectionTitle(body);\n\t\t\tbodytitle = body.equals(\"(default)\")?\"\":body;\n\t\t\t\n\t\t\ttemporaryControlFile.setElementTemplSelector(C_BODY_ELEMENT, body);\n\t\t\ttemporaryControlFile.setElementTemplate(C_BODY_ELEMENT, tempBodyFilename);\n\t\t\ttemporaryControlFile.write();\n\n\t\t\ttry {\n\t\t\t\tstyle = getStylesheet(cms, null, layoutTemplateFile, null);\n\t\t\t\tif(style != null && !\"\".equals(style)) {\n\t\t\t\t\tstyle = hostName + style;\n\t\t\t\t}                \n\t\t\t} catch(Exception e) {\n\t\t\t\tstyle = \"\";\n\t\t\t}\n\t\t\tsession.putValue(\"te_stylesheet\", style);\n\t\t} else {\n\t\t\t// There exists a content parameter.\n\t\t\t// We have to check all possible changes requested by the user.\n\t\t\tif(titlechangeRequested) {\n\t\t\t\t// The user entered a new document title\n\t\t\t\ttry {\n\t\t\t\t\tcms.writeProperty(tempPageFilename, C_PROPERTY_TITLE, title);\n\t\t\t\t} catch(CmsException e) {\n\t\t\t\t\tif(A_OpenCms.isLogging()) {\n\t\t\t\t\t\tA_OpenCms.log(C_OPENCMS_INFO, getClassName() + \"Could not write property \" + C_PROPERTY_TITLE + \" for file \" + file + \".\");                    \n\t\t\t\t\t\tA_OpenCms.log(C_OPENCMS_INFO, getClassName() + e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(templatechangeRequested) {\n\t\t\t\t// The user requested a change of the layout template\n\t\t\t\ttemporaryControlFile.setMasterTemplate(layoutTemplateFilename);\n\t\t\t\t//temporaryControlFile.write();\n\t\t\t\ttry {\n\t\t\t\t\tstyle = getStylesheet(cms, null, layoutTemplateFile, null);\n\t\t\t\t\tif(style != null && !\"\".equals(style)) {\n\t\t\t\t\t\tstyle = hostName + style;\n\t\t\t\t\t}                \n\t\t\t\t} catch(Exception e) {\n\t\t\t\t\tstyle = \"\";\n\t\t\t\t}\n\t\t\t\tsession.putValue(\"te_stylesheet\", style);\n\t\t\t}\n\t\n\t\t\tif(bodytitlechangeRequested) {\n\t\t\t\t// The user entered a new title for the current body\n\t\t\t\t//bodyTemplateFile.setSectionTitle(oldBody, bodytitle);\n\t\t\t\tif((!oldBody.equals(\"(default)\")) && (!oldBody.equals(\"script\"))) {\n\t\t\t\t\tif(bodytitle.toLowerCase().equals(\"script\")) {\n\t\t\t\t\t\tbodytitle = \"script\";\n\t\t\t\t\t}\n\t\t\t\t\ttry { \n\t\t\t\t\t\tbodyTemplateFile.renameSection(oldBody, bodytitle);\n\t\t\t\t\t\toldBody = bodytitle;\n\t\t\t\t\t\tif(!bodychangeRequested) {\n\t\t\t\t\t\t\tbody = bodytitle;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\tbodytitle = oldBodytitle;                       \n\t\t\t\t\t}\n\t\t\t\t\tif(bodytitle.equals(\"script\")) {\n\t\t\t\t\t\tsession.putValue(\"te_pageeditor\", editor);\n\t\t\t\t\t\teditor = C_SELECTBOX_EDITORVIEWS[1];\n\t\t\t\t\t\tparameters.put(\"editor\", editor);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbodytitle = oldBodytitle;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif(bodychangeRequested) {\n\t\t\t\ttemporaryControlFile.setElementTemplSelector(C_BODY_ELEMENT, body);\n\t\t\t\t//temporaryControlFile.write();\n\t\t\t\t////bodytitle = bodyTemplateFile.getSectionTitle(body);\n\t\t\t\tbodytitle = body.equals(\"(default)\")?\"\":body;\n\t\t\t\tif(body.equals(\"script\")) {\n\t\t\t\t\t// User wants to edit javascript code\n\t\t\t\t\t// Select text editor\n\t\t\t\t\tsession.putValue(\"te_pageeditor\", editor);\n\t\t\t\t\teditor = C_SELECTBOX_EDITORVIEWS[1];\n\t\t\t\t\tparameters.put(\"editor\", editor);\n\t\t\t\t} else if(oldBody.equals(\"script\")) {\n\t\t\t\t\t// User wants to switch back from javascript mode\n\t\t\t\t\t// Select old editor\n\t\t\t\t\teditor = (String)session.getValue(\"te_pageeditor\");\n\t\t\t\t\tparameters.put(\"editor\", editor);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t \n\t\t\tif(newbodyRequested) {\n\t\t\t\tbody = C_BODY_ELEMENT + bodyTemplateFile.createNewSection(C_BODY_ELEMENT);\n\t\t\t\tbodytitle = body;\n\t\t\t\ttemporaryControlFile.setElementTemplSelector(C_BODY_ELEMENT, body);\n\t\t\t\ttemporaryControlFile.setElementTemplate(C_BODY_ELEMENT, tempBodyFilename);\n\t\t\t\t//temporaryControlFile.write();\n\t\t\t\t\n\t\t\t\t//bodyTemplateFile.write();\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t// save file contents to our temporary file.\n\t\t\tcontent = encoder.unescape(content);\n\t\t\t\t\n\t\t\t// TODO: Set correct error page here\n\t\t\t//try {\n\t\t\tif((! exitRequested) || saveRequested) {\n\t\t\t\tbodyTemplateFile.setEditedTemplateContent(content, oldBody, oldEdit.equals(C_SELECTBOX_EDITORVIEWS[0]));\n\t\t\t}             \n\t\t\t/*} catch(CmsException e) {\n\t\t\tif(e.getType() == e.C_XML_PARSING_ERROR) {\n\t\t\tCmsXmlWpTemplateFile errorTemplate = (CmsXmlWpTemplateFile)getOwnTemplateFile(cms, templateFile, elementName, parameters, \"parseerror\");\n\t\t\t\terrorTemplate.setData(\"details\", Utils.getStackTrace(e));\n\t\t\t\treturn startProcessing(cms, errorTemplate, elementName, parameters, \"parseerror\");\n\t\t\t}\n\t\t\telse throw e;\n\t\t\t}*/\n\t\t\t\n\t\t\tbodyTemplateFile.write(); \n\t\t\ttemporaryControlFile.write();\n\t\t} \n\n\t\t// If the user requested a preview then send a redirect\n\t\t// to the temporary page file.\n\t\tif(previewRequested) {\n\t\t\tpreview(tempPageFilename, reqCont);\n\t\t\treturn \"\".getBytes();\n\t\t}\n\t\t\t\n\t\t// If the user requested a \"save\" expilitly by pressing one of\n\t\t// the \"save\" buttons, copy all informations of the temporary\n\t\t// files to the original files.\n\t\tif(saveRequested) {\n\t\t\tcommitTemporaryFile(cms, bodyElementFilename, tempBodyFilename);\n\t\t\ttitle = cms.readProperty(tempPageFilename, C_PROPERTY_TITLE);\n\t\t\tif(title != null && !\"\".equals(title)) {\n\t\t\t\tcms.writeProperty(file, C_PROPERTY_TITLE, title);\n\t\t\t}\n\t\t\tCmsXmlControlFile originalControlFile = new CmsXmlControlFile(cms, file);\n\n\t\t\toriginalControlFile.setMasterTemplate(temporaryControlFile.getMasterTemplate());\n\t\t\toriginalControlFile.write();\n\t\t}\n\t\t\n\t\t// Check if we should leave th editor instead of start processing\n\t\tif(exitRequested) {\n\t\t\t// First delete temporary files\n\t\t\ttemporaryControlFile.removeFromFileCache();\n\t\t\tbodyTemplateFile.removeFromFileCache();\n\t\t\tcms.deleteFile(tempBodyFilename);\n\t\t\tcms.deleteFile(tempPageFilename);\n\t\t\ttry {\n\t\t\t\tcms.getRequestContext().getResponse().sendCmsRedirect(getConfigFile(cms).getWorkplaceMainPath());\n\t\t\t} catch(IOException e) {\n\t\t\t\tthrowException(\"Could not send redirect to workplace main screen.\", e);\n\t\t\t}\n\t\t\t//return \"\".getBytes();\n\t\t\treturn null;\n\t\t}\n\n\t\t// Include the datablocks of the layout file into the body file.\n\t\t// So the \"bodytag\" and \"style\" data can be accessed by the body file.\n\t\tElement bodyTag = layoutTemplateFile.getBodyTag();\n\t\tbodyTemplateFile.setBodyTag(bodyTag);\n\n\t\t// Load the body!                                        \n\t\tcontent = bodyTemplateFile.getEditableTemplateContent(this, parameters, body, editor.equals(C_SELECTBOX_EDITORVIEWS[0]), style);        \n\t\tcontent = encoder.escapeWBlanks(content);\n\t\tparameters.put(C_PARA_CONTENT, content);\n\t\t\n\t\t// put the body parameter so that the selectbox can set the correct current value\n\t\tparameters.put(\"body\", body);\n\t\t\n\t\tparameters.put(\"bodyfile\", bodyElementFilename);\n\t\tparameters.put(\"bodyclass\", bodyElementClassName);\n\t\tparameters.put(\"template\", layoutTemplateFilename);\n\t\t\t\t\n\t\t// remove all parameters that could be relevant for the\n\t\t// included editor.\n\t\tparameters.remove(C_PARA_FILE);\n\t\tparameters.remove(C_PARA_ACTION);\n\t\t\t\t\t\t\t\t\n\t\tint numEditors = C_SELECTBOX_EDITORVIEWS.length;\n\t\tfor(int i=0; i<numEditors; i++) {\n\t\t\tif(editor.equals(C_SELECTBOX_EDITORVIEWS[i])) {\n\t\t\t\tparameters.put(\"editor._CLASS_\", C_SELECTBOX_EDITORVIEWS_CLASSES[i]);\n\t\t\t\tparameters.put(\"editor._TEMPLATE_\", getConfigFile(cms).getWorkplaceTemplatePath() + C_SELECTBOX_EDITORVIEWS_TEMPLATES[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsession.putValue(\"te_oldedit\", editor);\n\t\tsession.putValue(\"te_oldbody\", body);\n\t\tsession.putValue(\"te_oldbodytitle\", bodytitle);\n\t\tsession.putValue(\"te_oldlayout\", layoutTemplateFilename);       \n\t\tsession.putValue(\"te_title\", title);       \n\t\tsession.putValue(\"te_templateclass\", layoutTemplateClassName);       \n\t\t\n\t\tCmsXmlWpTemplateFile xmlTemplateDocument = (CmsXmlWpTemplateFile)getOwnTemplateFile(cms, templateFile, elementName, parameters, templateSelector);\n\t\txmlTemplateDocument.setData(\"editor\", editor);\n\t\txmlTemplateDocument.setData(\"bodyfile\", bodyElementFilename);\n\t\txmlTemplateDocument.setData(\"bodyclass\", bodyElementClassName);\n\t\txmlTemplateDocument.setData(\"editorframe\", (String)parameters.get(\"root.editorframe\"));                \n\t   \n\t\t// Put the \"file\" datablock for processing in the template file.\n\t\t// It will be inserted in a hidden input field and given back when submitting.\n\t\txmlTemplateDocument.setData(C_PARA_FILE, file);\n\t\treturn startProcessing(cms, xmlTemplateDocument, elementName, parameters, templateSelector);\n\n\t}","id":73549,"modified_method":"/**\n\t * Gets the content of a defined section in a given template file and its subtemplates\n\t * with the given parameters. \n\t * \n\t * @see getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters)\n\t * @param cms CmsObject Object for accessing system resources.\n\t * @param templateFile Filename of the template file.\n\t * @param elementName Element name of this template in our parent template.\n\t * @param parameters Hashtable with all template class parameters.\n\t * @param templateSelector template section that should be processed.\n\t */\n\tpublic byte[] getContent(CmsObject cms, String templateFile, String elementName, Hashtable parameters, String templateSelector) throws CmsException {\n\t\t\n\t\tCmsRequestContext reqCont = cms.getRequestContext();\n\t\tHttpServletRequest orgReq = (HttpServletRequest)reqCont.getRequest().getOriginalRequest();\n\t\tI_CmsSession session = cms.getRequestContext().getSession(true);\n\t\t// TODO: check, if this is neede: CmsFile editFile = null;\n\n\t\t// Get the user's browser\n\t\tString browser = orgReq.getHeader(\"user-agent\");                \n\t\tString hostName = orgReq.getScheme() + \"://\" + orgReq.getHeader(\"HOST\");\n\t\t\t\t\n\t\tEncoder encoder = new Encoder();\n\t\t\n\t\t// Get all URL parameters\n\t\tString content = (String)parameters.get(C_PARA_CONTENT);            \n\t\tString body = (String)parameters.get(\"body\");\n\t\tString file = (String)parameters.get(C_PARA_FILE);\n\t\tString editor = (String)parameters.get(\"editor\");\n\t\tString title = (String)parameters.get(C_PARA_TITLE);\n\t\tString bodytitle = (String)parameters.get(\"bodytitle\");\n\t\tString layoutTemplateFilename = (String)parameters.get(\"template\");\n\t\tString bodyElementClassName = (String)parameters.get(\"bodyclass\");\n\t\tString bodyElementFilename = (String)parameters.get(\"bodyfile\");\n\t\tString action = (String)parameters.get(C_PARA_ACTION);\n\t\t\n\t\t// Get all session parameters\n\t\tString oldEdit = (String)session.getValue(\"te_oldedit\");\n\t\t// TODO: check, if this is neede: String bodytag = (String)session.getValue(\"bodytag\");\n\t\tString oldLayoutFilename = (String)session.getValue(\"te_oldlayout\");\n\t\tString oldTitle = (String)session.getValue(\"te_title\");\n\t\tString oldBody = (String)session.getValue(\"te_oldbody\");\n\t\tString oldBodytitle = (String)session.getValue(\"te_oldbodytitle\");\n\t\tString layoutTemplateClassName = (String)session.getValue(\"te_templateclass\");\n\t\tString tempPageFilename = (String)session.getValue(\"te_temppagefile\");\n\t\tString tempBodyFilename = (String)session.getValue(\"te_tempbodyfile\");\n\t\tString style = (String)session.getValue(\"te_stylesheet\");\n\t\t\t\t\n\t\t//boolean existsContentParam = (content!=null && (!\"\".equals(content)));\n\t\tboolean existsContentParam = content!=null;\n\n\t\tboolean existsFileParam = (file!=null && (!\"\".equals(file)));\n\t\tboolean saveRequested = ((action != null) && (C_EDIT_ACTION_SAVE.equals(action) || C_EDIT_ACTION_SAVEEXIT.equals(action)));\n\t\tboolean exitRequested = ((action != null) && (C_EDIT_ACTION_EXIT.equals(action) || C_EDIT_ACTION_SAVEEXIT.equals(action)));\n\t\tboolean bodychangeRequested = ((oldBody != null) && (body != null) && (!(oldBody.equals(body))));\n\t\tboolean templatechangeRequested = (oldLayoutFilename != null && layoutTemplateFilename != null\n\t\t\t\t\t\t\t\t\t\t   && (!(oldLayoutFilename.equals(layoutTemplateFilename))));\n\t\tboolean titlechangeRequested = (oldTitle != null && title != null && (!(oldTitle.equals(title))));\n\t\tboolean newbodyRequested = ((action != null) && \"newbody\".equals(action));        \n\t\tboolean previewRequested = ((action != null) && \"preview\".equals(action));        \n\t\tboolean bodytitlechangeRequested = (oldBodytitle != null && bodytitle != null\n\t\t\t\t\t\t\t\t\t\t   && (!(oldBodytitle.equals(bodytitle))));\n\t\t\n\t\t// Check if there is a file parameter in the request\n\t\tif(! existsFileParam) {\n\t\t\tthrowException(\"No \\\"file\\\" parameter given. Don't know which file should be edited.\");\n\t\t}\n\t\t\t\t\n\t\t// If there is no content parameter this seems to be\n\t\t// a new request of the page editor.\n\t\t// So we have to read all files and set some initial values.\n\t\tif(!existsContentParam) {\n\t\t\tCmsXmlControlFile originalControlFile = new CmsXmlControlFile(cms, file);\n\t\t\t\t\t\t\n\t\t\tif(originalControlFile.isElementClassDefined(C_BODY_ELEMENT)) {\n\t\t\t\tbodyElementClassName = originalControlFile.getElementClass(C_BODY_ELEMENT);\n\t\t\t} \n\t\t\t\t\n\t\t\tif(originalControlFile.isElementTemplateDefined(C_BODY_ELEMENT)) {\n\t\t\t\tbodyElementFilename = originalControlFile.getElementTemplate(C_BODY_ELEMENT);\n\t\t\t}\n\t\t\t\n\t\t\tif((bodyElementClassName == null) || (bodyElementFilename == null)) {\n\t\t\t\t// Either the template class or the template file \n\t\t\t\t// for the body element could not be determined.\n\t\t\t\t// BUG: Send error here\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t// Check, if the selected page file is locked\n\t\t\tCmsResource pageFileResource = cms.readFileHeader(file);\n\t\t\tif(!pageFileResource.isLocked()) {\n\t\t\t\t// BUG: Check only, dont't lock here!\n\t\t\t\tcms.lockResource(file);\n\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t// The content file must be locked before editing            \n\t\t\tCmsResource contentFileResource = cms.readFileHeader(bodyElementFilename);\n\t\t\tif(!contentFileResource.isLocked()) {\n\t\t\t\tcms.lockResource(bodyElementFilename);\n\t\t\t}\n\t\t\t\n\t\t\t// Now get the currently selected master template file\n\t\t\tlayoutTemplateFilename = originalControlFile.getMasterTemplate();\n\t\t\tlayoutTemplateClassName = originalControlFile.getTemplateClass();\n\t\t\t\n\t\t\tint browserId;\n\t\t\t\n\t\t\tif(browser.indexOf(\"MSIE\") >-1) {\n\t\t    \tbrowserId = 0;\n\t\t    } else {\n\t\t    \tbrowserId = 1;\n\t    \t}\n\n\t\t\tif(editor == null || \"\".equals(editor)) {\n\t\t\t\teditor = this.C_SELECTBOX_EDITORVIEWS[C_SELECTBOX_EDITORVIEWS_DEFAULT[browserId]];    \n\t\t\t\tsession.putValue(\"te_pageeditor\", editor);\n\t\t\t\tparameters.put(\"editor\", editor);\n\t\t\t}\n\t\t\t\n\t\t\t// And finally the document title\n\t\t\ttitle = cms.readProperty(file, C_PROPERTY_TITLE);\n\t\t\tif(title == null) {\n\t\t\t\ttitle = \"\";\n\t\t\t}\n\n\t\t\t// Okay. All values are initialized. Now we can create\n\t\t\t// the temporary files.\n\t\t\ttempPageFilename = createTemporaryFile(cms, pageFileResource);\n\t\t\ttempBodyFilename = createTemporaryFile(cms, contentFileResource);             \n\t\t\tsession.putValue(\"te_temppagefile\", tempPageFilename);\n\t\t\tsession.putValue(\"te_tempbodyfile\", tempBodyFilename);                        \n\t\t} \n\t\t\t\t\n\t\t\t   \n\t\t// Get the XML parsed content of the layout file.\n\t\t// This can be done by calling the getOwnTemplateFile() method of the\n\t\t// layout's template class.\n\t\t// The content is needed to determine the HTML style of the body element.\n\t\tObject tempObj = CmsTemplateClassManager.getClassInstance(cms, layoutTemplateClassName);\n\t\tCmsXmlTemplate layoutTemplateClassObject = (CmsXmlTemplate)tempObj;\n\t\tCmsXmlTemplateFile layoutTemplateFile = layoutTemplateClassObject.getOwnTemplateFile(cms, layoutTemplateFilename, null, parameters, null);                   \n\t\t\n\t\t// Get the XML parsed content of the body file.        \n\t\t// This can be done by calling the getOwnTemplateFile() method of the\n\t\t// body's template class.\n\t\ttempObj = CmsTemplateClassManager.getClassInstance(cms, bodyElementClassName);\n\t\tCmsXmlTemplate bodyElementClassObject = (CmsXmlTemplate)tempObj;\n\t\tCmsXmlTemplateFile bodyTemplateFile = bodyElementClassObject.getOwnTemplateFile(cms, tempBodyFilename, C_BODY_ELEMENT, parameters, null);\n\n\t\t// Get the temporary page file object\n\t\tCmsXmlControlFile temporaryControlFile = new CmsXmlControlFile(cms, tempPageFilename);\n\t\t\n\t\tif(!existsContentParam) {\n\t\t\tVector allBodys = bodyTemplateFile.getAllSections();\n\t\t\tif(allBodys == null || allBodys.size() == 0) {\n\t\t\t\tbody = \"\";\n\t\t\t} else {\n\t\t\t\tbody = (String)allBodys.elementAt(0);\n\t\t\t}\n\n\t\t\t// bodytitle = bodyTemplateFile.getSectionTitle(body);\n\t\t\tbodytitle = body.equals(\"(default)\")?\"\":body;\n\t\t\t\n\t\t\ttemporaryControlFile.setElementTemplSelector(C_BODY_ELEMENT, body);\n\t\t\ttemporaryControlFile.setElementTemplate(C_BODY_ELEMENT, tempBodyFilename);\n\t\t\ttemporaryControlFile.write();\n\n\t\t\ttry {\n\t\t\t\tstyle = getStylesheet(cms, null, layoutTemplateFile, null);\n\t\t\t\tif(style != null && !\"\".equals(style)) {\n\t\t\t\t\tstyle = hostName + style;\n\t\t\t\t}                \n\t\t\t} catch(Exception e) {\n\t\t\t\tstyle = \"\";\n\t\t\t}\n\t\t\tsession.putValue(\"te_stylesheet\", style);\n\t\t} else {\n\t\t\t// There exists a content parameter.\n\t\t\t// We have to check all possible changes requested by the user.\n\t\t\tif(titlechangeRequested) {\n\t\t\t\t// The user entered a new document title\n\t\t\t\ttry {\n\t\t\t\t\tcms.writeProperty(tempPageFilename, C_PROPERTY_TITLE, title);\n\t\t\t\t} catch(CmsException e) {\n\t\t\t\t\tif(A_OpenCms.isLogging()) {\n\t\t\t\t\t\tA_OpenCms.log(C_OPENCMS_INFO, getClassName() + \"Could not write property \" + C_PROPERTY_TITLE + \" for file \" + file + \".\");                    \n\t\t\t\t\t\tA_OpenCms.log(C_OPENCMS_INFO, getClassName() + e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(templatechangeRequested) {\n\t\t\t\t// The user requested a change of the layout template\n\t\t\t\ttemporaryControlFile.setMasterTemplate(layoutTemplateFilename);\n\t\t\t\t//temporaryControlFile.write();\n\t\t\t\ttry {\n\t\t\t\t\tstyle = getStylesheet(cms, null, layoutTemplateFile, null);\n\t\t\t\t\tif(style != null && !\"\".equals(style)) {\n\t\t\t\t\t\tstyle = hostName + style;\n\t\t\t\t\t}                \n\t\t\t\t} catch(Exception e) {\n\t\t\t\t\tstyle = \"\";\n\t\t\t\t}\n\t\t\t\tsession.putValue(\"te_stylesheet\", style);\n\t\t\t}\n\t\n\t\t\tif(bodytitlechangeRequested) {\n\t\t\t\t// The user entered a new title for the current body\n\t\t\t\t//bodyTemplateFile.setSectionTitle(oldBody, bodytitle);\n\t\t\t\tif((!oldBody.equals(\"(default)\")) && (!oldBody.equals(\"script\"))) {\n\t\t\t\t\tif(bodytitle.toLowerCase().equals(\"script\")) {\n\t\t\t\t\t\tbodytitle = \"script\";\n\t\t\t\t\t}\n\t\t\t\t\ttry { \n\t\t\t\t\t\tbodyTemplateFile.renameSection(oldBody, bodytitle);\n\t\t\t\t\t\toldBody = bodytitle;\n\t\t\t\t\t\tif(!bodychangeRequested) {\n\t\t\t\t\t\t\tbody = bodytitle;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\tbodytitle = oldBodytitle;                       \n\t\t\t\t\t}\n\t\t\t\t\tif(bodytitle.equals(\"script\")) {\n\t\t\t\t\t\tsession.putValue(\"te_pageeditor\", editor);\n\t\t\t\t\t\teditor = C_SELECTBOX_EDITORVIEWS[1];\n\t\t\t\t\t\tparameters.put(\"editor\", editor);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbodytitle = oldBodytitle;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif(bodychangeRequested) {\n\t\t\t\ttemporaryControlFile.setElementTemplSelector(C_BODY_ELEMENT, body);\n\t\t\t\t//temporaryControlFile.write();\n\t\t\t\t////bodytitle = bodyTemplateFile.getSectionTitle(body);\n\t\t\t\tbodytitle = body.equals(\"(default)\")?\"\":body;\n\t\t\t\tif(body.equals(\"script\")) {\n\t\t\t\t\t// User wants to edit javascript code\n\t\t\t\t\t// Select text editor\n\t\t\t\t\tsession.putValue(\"te_pageeditor\", editor);\n\t\t\t\t\teditor = C_SELECTBOX_EDITORVIEWS[1];\n\t\t\t\t\tparameters.put(\"editor\", editor);\n\t\t\t\t} else if(oldBody.equals(\"script\")) {\n\t\t\t\t\t// User wants to switch back from javascript mode\n\t\t\t\t\t// Select old editor\n\t\t\t\t\teditor = (String)session.getValue(\"te_pageeditor\");\n\t\t\t\t\tparameters.put(\"editor\", editor);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t \n\t\t\tif(newbodyRequested) {\n\t\t\t\tbody = C_BODY_ELEMENT + bodyTemplateFile.createNewSection(C_BODY_ELEMENT);\n\t\t\t\tbodytitle = body;\n\t\t\t\ttemporaryControlFile.setElementTemplSelector(C_BODY_ELEMENT, body);\n\t\t\t\ttemporaryControlFile.setElementTemplate(C_BODY_ELEMENT, tempBodyFilename);\n\t\t\t\t//temporaryControlFile.write();\n\t\t\t\t\n\t\t\t\t//bodyTemplateFile.write();\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t// save file contents to our temporary file.\n\t\t\tcontent = encoder.unescape(content);\n\t\t\t\t\n\t\t\t// TODO: Set correct error page here\n\t\t\t//try {\n\t\t\tif((! exitRequested) || saveRequested) {\n\t\t\t\tbodyTemplateFile.setEditedTemplateContent(content, oldBody, oldEdit.equals(C_SELECTBOX_EDITORVIEWS[0]));\n\t\t\t}             \n\t\t\t/*} catch(CmsException e) {\n\t\t\tif(e.getType() == e.C_XML_PARSING_ERROR) {\n\t\t\tCmsXmlWpTemplateFile errorTemplate = (CmsXmlWpTemplateFile)getOwnTemplateFile(cms, templateFile, elementName, parameters, \"parseerror\");\n\t\t\t\terrorTemplate.setData(\"details\", Utils.getStackTrace(e));\n\t\t\t\treturn startProcessing(cms, errorTemplate, elementName, parameters, \"parseerror\");\n\t\t\t}\n\t\t\telse throw e;\n\t\t\t}*/\n\t\t\t\n\t\t\tbodyTemplateFile.write(); \n\t\t\ttemporaryControlFile.write();\n\t\t} \n\n\t\t// If the user requested a preview then send a redirect\n\t\t// to the temporary page file.\n\t\tif(previewRequested) {\n\t\t\tpreview(tempPageFilename, reqCont);\n\t\t\treturn \"\".getBytes();\n\t\t}\n\t\t\t\n\t\t// If the user requested a \"save\" expilitly by pressing one of\n\t\t// the \"save\" buttons, copy all informations of the temporary\n\t\t// files to the original files.\n\t\tif(saveRequested) {\n\t\t\tcommitTemporaryFile(cms, bodyElementFilename, tempBodyFilename);\n\t\t\ttitle = cms.readProperty(tempPageFilename, C_PROPERTY_TITLE);\n\t\t\tif(title != null && !\"\".equals(title)) {\n\t\t\t\tcms.writeProperty(file, C_PROPERTY_TITLE, title);\n\t\t\t}\n\t\t\tCmsXmlControlFile originalControlFile = new CmsXmlControlFile(cms, file);\n\n\t\t\toriginalControlFile.setMasterTemplate(temporaryControlFile.getMasterTemplate());\n\t\t\toriginalControlFile.write();\n\t\t}\n\t\t\n\t\t// Check if we should leave th editor instead of start processing\n\t\tif(exitRequested) {\n\t\t\t// First delete temporary files\n\t\t\ttemporaryControlFile.removeFromFileCache();\n\t\t\tbodyTemplateFile.removeFromFileCache();\n\t\t\tcms.deleteFile(tempBodyFilename);\n\t\t\tcms.deleteFile(tempPageFilename);\n\t\t\ttry {\n\t\t\t\tcms.getRequestContext().getResponse().sendCmsRedirect(getConfigFile(cms).getWorkplaceMainPath());\n\t\t\t} catch(IOException e) {\n\t\t\t\tthrowException(\"Could not send redirect to workplace main screen.\", e);\n\t\t\t}\n\t\t\t//return \"\".getBytes();\n\t\t\treturn null;\n\t\t}\n\n\t\t// Include the datablocks of the layout file into the body file.\n\t\t// So the \"bodytag\" and \"style\" data can be accessed by the body file.\n\t\tElement bodyTag = layoutTemplateFile.getBodyTag();\n\t\tbodyTemplateFile.setBodyTag(bodyTag);\n\n\t\t// Load the body!                                        \n\t\tcontent = bodyTemplateFile.getEditableTemplateContent(this, parameters, body, editor.equals(C_SELECTBOX_EDITORVIEWS[0]), style);        \n\t\tcontent = encoder.escapeWBlanks(content);\n\t\tparameters.put(C_PARA_CONTENT, content);\n\t\t\n\t\t// put the body parameter so that the selectbox can set the correct current value\n\t\tparameters.put(\"body\", body);\n\t\t\n\t\tparameters.put(\"bodyfile\", bodyElementFilename);\n\t\tparameters.put(\"bodyclass\", bodyElementClassName);\n\t\tparameters.put(\"template\", layoutTemplateFilename);\n\t\t\t\t\n\t\t// remove all parameters that could be relevant for the\n\t\t// included editor.\n\t\tparameters.remove(C_PARA_FILE);\n\t\tparameters.remove(C_PARA_ACTION);\n\t\t\t\t\t\t\t\t\n\t\tint numEditors = C_SELECTBOX_EDITORVIEWS.length;\n\t\tfor(int i=0; i<numEditors; i++) {\n\t\t\tif(editor.equals(C_SELECTBOX_EDITORVIEWS[i])) {\n\t\t\t\tparameters.put(\"editor._CLASS_\", C_SELECTBOX_EDITORVIEWS_CLASSES[i]);\n\t\t\t\tparameters.put(\"editor._TEMPLATE_\", getConfigFile(cms).getWorkplaceTemplatePath() + C_SELECTBOX_EDITORVIEWS_TEMPLATES[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsession.putValue(\"te_oldedit\", editor);\n\t\tsession.putValue(\"te_oldbody\", body);\n\t\tsession.putValue(\"te_oldbodytitle\", bodytitle);\n\t\tsession.putValue(\"te_oldlayout\", layoutTemplateFilename);       \n\t\tif(title != null) {\n\t\t\tsession.putValue(\"te_title\", title);       \n\t\t} else {\n\t\t\tsession.putValue(\"te_title\", \"\");       \n\t\t}\n\t\tsession.putValue(\"te_templateclass\", layoutTemplateClassName);       \n\t\t\n\t\tCmsXmlWpTemplateFile xmlTemplateDocument = (CmsXmlWpTemplateFile)getOwnTemplateFile(cms, templateFile, elementName, parameters, templateSelector);\n\t\txmlTemplateDocument.setData(\"editor\", editor);\n\t\txmlTemplateDocument.setData(\"bodyfile\", bodyElementFilename);\n\t\txmlTemplateDocument.setData(\"bodyclass\", bodyElementClassName);\n\t\txmlTemplateDocument.setData(\"editorframe\", (String)parameters.get(\"root.editorframe\"));                \n\t   \n\t\t// Put the \"file\" datablock for processing in the template file.\n\t\t// It will be inserted in a hidden input field and given back when submitting.\n\t\txmlTemplateDocument.setData(C_PARA_FILE, file);\n\t\treturn startProcessing(cms, xmlTemplateDocument, elementName, parameters, templateSelector);\n\n\t}","commit_id":"413117ec94f031bd665d22287862eaef3fe7c98c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Override public void visitAssignmentExpression(\n                @NotNull PsiAssignmentExpression expression) {\n            super.visitAssignmentExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            final IElementType tokenType = sign.getTokenType();\n            if (!JavaTokenType.EQ.equals(tokenType)) {\n                return;\n            }\n            final PsiExpression lhs = expression.getLExpression();\n            if (!(lhs instanceof PsiReferenceExpression)) {\n                return;\n            }\n            if (!TypeUtils.expressionHasTypeOrSubtype(lhs,\n                    \"java.util.Date\", \"java.util.Calendar\")) {\n                return;\n            }\n            final PsiExpression rhs = expression.getRExpression();\n            if (!(rhs instanceof PsiReferenceExpression)) {\n                return;\n            }\n            final PsiElement lhsReferent = ((PsiReference) lhs).resolve();\n            if (!(lhsReferent instanceof PsiField)) {\n                return;\n            }\n            final PsiElement rhsReferent = ((PsiReference) rhs).resolve();\n            if (!(rhsReferent instanceof PsiParameter)) {\n                return;\n            }\n            if (!(rhsReferent.getParent() instanceof PsiParameterList)) {\n                return;\n            }\n            if (ignorePrivateMethods) {\n                final PsiMethod containingMethod =\n                        PsiTreeUtil.getParentOfType(expression,\n                                PsiMethod.class);\n                if (containingMethod == null ||\n                        containingMethod.hasModifierProperty(\n                                PsiModifier.PRIVATE)) {\n                    return;\n                }\n            }\n            registerError(lhs, lhsReferent, rhs);\n        }","id":73550,"modified_method":"@Override public void visitAssignmentExpression(\n                @NotNull PsiAssignmentExpression expression) {\n            super.visitAssignmentExpression(expression);\n            final PsiJavaToken sign = expression.getOperationSign();\n            final IElementType tokenType = sign.getTokenType();\n            if (!JavaTokenType.EQ.equals(tokenType)) {\n                return;\n            }\n            final PsiExpression lhs = expression.getLExpression();\n            if (!(lhs instanceof PsiReferenceExpression)) {\n                return;\n            }\n            final String type = TypeUtils.expressionHasTypeOrSubtype(lhs,\n                    \"java.util.Date\", \"java.util.Calendar\");\n            if (type == null) {\n                return;\n            }\n            final PsiExpression rhs = expression.getRExpression();\n            if (!(rhs instanceof PsiReferenceExpression)) {\n                return;\n            }\n            final PsiElement lhsReferent = ((PsiReference) lhs).resolve();\n            if (!(lhsReferent instanceof PsiField)) {\n                return;\n            }\n            final PsiElement rhsReferent = ((PsiReference) rhs).resolve();\n            if (!(rhsReferent instanceof PsiParameter)) {\n                return;\n            }\n            if (!(rhsReferent.getParent() instanceof PsiParameterList)) {\n                return;\n            }\n            if (ignorePrivateMethods) {\n                final PsiMethod containingMethod =\n                        PsiTreeUtil.getParentOfType(expression,\n                                PsiMethod.class);\n                if (containingMethod == null ||\n                        containingMethod.hasModifierProperty(\n                                PsiModifier.PRIVATE)) {\n                    return;\n                }\n            }\n            registerError(lhs, type, rhs);\n        }","commit_id":"1a36ba3231da308a0b5b3f0613caeda60a4f1096","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public String buildErrorString(Object... infos) {\n        final PsiField field = (PsiField) infos[0];\n        final PsiExpression rhs = (PsiExpression)infos[1];\n        final PsiType type = field.getType();\n        return InspectionGadgetsBundle.message(\n                \"assignment.to.date.calendar.field.from.parameter.problem.descriptor\",\n                type.getPresentableText(), rhs.getText());\n    }","id":73551,"modified_method":"@Override\n    @NotNull\n    public String buildErrorString(Object... infos) {\n        final String type = (String) infos[0];\n        final PsiExpression rhs = (PsiExpression)infos[1];\n        return InspectionGadgetsBundle.message(\n                \"assignment.to.date.calendar.field.from.parameter.problem.descriptor\",\n                type, rhs.getText());\n    }","commit_id":"1a36ba3231da308a0b5b3f0613caeda60a4f1096","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isAddedToCollection(PsiExpression expression) {\n            final PsiElement parent = expression.getParent();\n            if (!(parent instanceof PsiExpressionList)) {\n                return false;\n            }\n            final PsiExpressionList expressionList = (PsiExpressionList)parent;\n            final PsiElement grandParent = expressionList.getParent();\n            if (!(grandParent instanceof PsiMethodCallExpression)) {\n                return false;\n            }\n            final PsiMethodCallExpression methodCallExpression =\n                    (PsiMethodCallExpression)grandParent;\n            final PsiReferenceExpression methodExpression =\n                    methodCallExpression.getMethodExpression();\n            final String methodName = methodExpression.getReferenceName();\n            if (!\"put\".equals(methodName) && !\"set\".equals(methodName) &&\n                    !\"add\".equals(methodName)) {\n                return false;\n            }\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            return TypeUtils.expressionHasTypeOrSubtype(qualifier,\n                    \"java.util.Collection\", \"java.util.Map\");\n        }","id":73552,"modified_method":"private boolean isAddedToCollection(PsiExpression expression) {\n            final PsiElement parent = expression.getParent();\n            if (!(parent instanceof PsiExpressionList)) {\n                return false;\n            }\n            final PsiExpressionList expressionList = (PsiExpressionList)parent;\n            final PsiElement grandParent = expressionList.getParent();\n            if (!(grandParent instanceof PsiMethodCallExpression)) {\n                return false;\n            }\n            final PsiMethodCallExpression methodCallExpression =\n                    (PsiMethodCallExpression)grandParent;\n            final PsiReferenceExpression methodExpression =\n                    methodCallExpression.getMethodExpression();\n            final String methodName = methodExpression.getReferenceName();\n            if (!\"put\".equals(methodName) && !\"set\".equals(methodName) &&\n                    !\"add\".equals(methodName)) {\n                return false;\n            }\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            return TypeUtils.expressionHasTypeOrSubtype(qualifier,\n                    \"java.util.Collection\", \"java.util.Map\") != null;\n        }","commit_id":"1a36ba3231da308a0b5b3f0613caeda60a4f1096","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isChannelFactoryClosedInFinally(\n                PsiMethodCallExpression expression) {\n            final PsiReferenceExpression methodExpression =\n                    expression.getMethodExpression();\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if (!(qualifier instanceof PsiReferenceExpression)) {\n                return false;\n            }\n            PsiReferenceExpression referenceExpression =\n                    (PsiReferenceExpression) qualifier;\n            final PsiElement target = referenceExpression.resolve();\n            if (!(target instanceof PsiVariable)) {\n                return false;\n            }\n            final PsiVariable variable = (PsiVariable) target;\n            PsiTryStatement tryStatement =\n                    PsiTreeUtil.getParentOfType(expression,\n                            PsiTryStatement.class, true, PsiMember.class);\n            if(tryStatement == null){\n                return false;\n            }\n            while (!resourceIsClosedInFinally(tryStatement, variable)) {\n                tryStatement =\n                        PsiTreeUtil.getParentOfType(tryStatement,\n                            PsiTryStatement.class, true, PsiMember.class);\n                if(tryStatement == null){\n                    return false;\n                }\n            }\n            return true;\n        }","id":73553,"modified_method":"private static boolean isChannelFactoryClosedInFinally(\n                PsiMethodCallExpression expression) {\n            final PsiReferenceExpression methodExpression =\n                    expression.getMethodExpression();\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if (!(qualifier instanceof PsiReferenceExpression)) {\n                return false;\n            }\n            final PsiReferenceExpression referenceExpression =\n                    (PsiReferenceExpression) qualifier;\n            final PsiElement target = referenceExpression.resolve();\n            if (!(target instanceof PsiVariable)) {\n                return false;\n            }\n            final PsiVariable variable = (PsiVariable) target;\n            PsiTryStatement tryStatement =\n                    PsiTreeUtil.getParentOfType(expression,\n                            PsiTryStatement.class, true, PsiMember.class);\n            if(tryStatement == null){\n                return false;\n            }\n            while (!resourceIsClosedInFinally(tryStatement, variable)) {\n                tryStatement =\n                        PsiTreeUtil.getParentOfType(tryStatement,\n                            PsiTryStatement.class, true, PsiMember.class);\n                if(tryStatement == null){\n                    return false;\n                }\n            }\n            return true;\n        }","commit_id":"1a36ba3231da308a0b5b3f0613caeda60a4f1096","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isChannelFactoryMethod(\n                PsiMethodCallExpression expression){\n            final PsiReferenceExpression methodExpression =\n                    expression.getMethodExpression();\n            final String methodName = methodExpression.getReferenceName();\n            if(!HardcodedMethodConstants.GET_CHANNEL.equals(methodName)) {\n                return false;\n            }\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if(qualifier == null) {\n                return false;\n            }\n            return TypeUtils.expressionHasTypeOrSubtype(qualifier,\n\t\t            \"java.net.Socket\",\n\t\t            \"java.net.DatagramSocket\",\n\t\t            \"java.net.ServerSocket\",\n\t\t            \"java.io.FileInputStream\",\n\t\t            \"java.io.FileOutputStream\",\n\t\t            \"java.io.RandomAccessFile\",\n                    \"com.sun.corba.se.pept.transport.EventHandler\",\n                    \"sun.nio.ch.InheritedChannel\");\n        }","id":73554,"modified_method":"private static boolean isChannelFactoryMethod(\n                PsiMethodCallExpression expression){\n            final PsiReferenceExpression methodExpression =\n                    expression.getMethodExpression();\n            final String methodName = methodExpression.getReferenceName();\n            if(!HardcodedMethodConstants.GET_CHANNEL.equals(methodName)) {\n                return false;\n            }\n            final PsiExpression qualifier =\n                    methodExpression.getQualifierExpression();\n            if(qualifier == null) {\n                return false;\n            }\n            return TypeUtils.expressionHasTypeOrSubtype(qualifier,\n                    \"java.net.Socket\",\n                    \"java.net.DatagramSocket\",\n                    \"java.net.ServerSocket\",\n                    \"java.io.FileInputStream\",\n                    \"java.io.FileOutputStream\",\n                    \"java.io.RandomAccessFile\",\n                    \"com.sun.corba.se.pept.transport.EventHandler\",\n                    \"sun.nio.ch.InheritedChannel\") != null;\n        }","commit_id":"1a36ba3231da308a0b5b3f0613caeda60a4f1096","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isNonTrivialReader(PsiExpression expression){\n        return TypeUtils.expressionHasTypeOrSubtype(expression,\n\t\t        \"java.io.Reader\") &&\n                !TypeUtils.expressionHasTypeOrSubtype(expression,\n\t\t                \"java.io.CharArrayReader\", \"java.io.StringReader\");\n    }","id":73555,"modified_method":"private static boolean isNonTrivialReader(PsiExpression expression){\n        return TypeUtils.expressionHasTypeOrSubtype(expression,\n                \"java.io.Reader\") &&\n                TypeUtils.expressionHasTypeOrSubtype(expression,\n                        \"java.io.CharArrayReader\", \"java.io.StringReader\") == null;\n    }","commit_id":"1a36ba3231da308a0b5b3f0613caeda60a4f1096","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isNonTrivialInputStream(PsiExpression expression){\n        return TypeUtils.expressionHasTypeOrSubtype(expression,\n\t\t        \"java.io.InputStream\") &&\n                !TypeUtils.expressionHasTypeOrSubtype(expression,\n\t\t                \"java.io.ByteArrayInputStream\",\n\t\t                \"java.io.StringBufferInputStream\");\n    }","id":73556,"modified_method":"private static boolean isNonTrivialInputStream(PsiExpression expression){\n        return TypeUtils.expressionHasTypeOrSubtype(expression,\n                \"java.io.InputStream\") &&\n                TypeUtils.expressionHasTypeOrSubtype(expression,\n                        \"java.io.ByteArrayInputStream\",\n                        \"java.io.StringBufferInputStream\") == null;\n    }","commit_id":"1a36ba3231da308a0b5b3f0613caeda60a4f1096","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isNonTrivialWriter(PsiExpression expression){\n        return TypeUtils.expressionHasTypeOrSubtype(expression,\n\t\t        \"java.io.Writer\") &&\n                !TypeUtils.expressionHasTypeOrSubtype(expression,\n\t\t                \"java.io.CharArrayWriter\", \"java.io.StringWriter\");\n    }","id":73557,"modified_method":"private static boolean isNonTrivialWriter(PsiExpression expression){\n        return TypeUtils.expressionHasTypeOrSubtype(expression,\n                \"java.io.Writer\") &&\n                TypeUtils.expressionHasTypeOrSubtype(expression,\n                        \"java.io.CharArrayWriter\", \"java.io.StringWriter\") == null;\n    }","commit_id":"1a36ba3231da308a0b5b3f0613caeda60a4f1096","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    public String buildErrorString(Object... infos){\n        final PsiExpression expression = (PsiExpression)infos[0];\n\t    final boolean date = TypeUtils.expressionHasTypeOrSubtype(\n\t\t\t    expression, \"java.util.Date\");\n        if (date) {\n            return InspectionGadgetsBundle.message(\n                    \"return.date.calendar.field.problem.descriptor\",\n                    \"Date\");\n        } else {\n            return InspectionGadgetsBundle.message(\n                    \"return.date.calendar.field.problem.descriptor\",\n                    \"Calendar\");\n        }\n    }","id":73558,"modified_method":"@Override\n    @NotNull\n    public String buildErrorString(Object... infos){\n        final String type = (String)infos[0];\n        return InspectionGadgetsBundle.message(\n                \"return.date.calendar.field.problem.descriptor\", type);\n    }","commit_id":"1a36ba3231da308a0b5b3f0613caeda60a4f1096","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override public void visitReturnStatement(@NotNull PsiReturnStatement statement){\n            super.visitReturnStatement(statement);\n            final PsiExpression returnValue = statement.getReturnValue();\n            if(!(returnValue instanceof PsiReferenceExpression)){\n                return;\n            }\n            final PsiReferenceExpression fieldReference =\n                    (PsiReferenceExpression) returnValue;\n            final PsiElement element = fieldReference.resolve();\n            if(!(element instanceof PsiField)){\n                return;\n            }\n            if (!TypeUtils.expressionHasTypeOrSubtype(\n                    returnValue, \"java.util.Date\", \"java.util.Calendar\")) {\n\t            return;\n            }\n\t        registerError(returnValue, returnValue);\n        }","id":73559,"modified_method":"@Override public void visitReturnStatement(\n                @NotNull PsiReturnStatement statement){\n            super.visitReturnStatement(statement);\n            final PsiExpression returnValue = statement.getReturnValue();\n            if(!(returnValue instanceof PsiReferenceExpression)){\n                return;\n            }\n            final PsiReferenceExpression fieldReference =\n                    (PsiReferenceExpression) returnValue;\n            final PsiElement element = fieldReference.resolve();\n            if(!(element instanceof PsiField)){\n                return;\n            }\n            final String type = TypeUtils.expressionHasTypeOrSubtype(\n                    returnValue, \"java.util.Date\", \"java.util.Calendar\");\n            if (type == null) {\n                return;\n            }\n            registerError(returnValue, type);\n        }","commit_id":"1a36ba3231da308a0b5b3f0613caeda60a4f1096","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isSocketResource(PsiNewExpression expression){\n            return TypeUtils.expressionHasTypeOrSubtype(expression,\n                    \"java.net.Socket\",\n                    \"java.net.DatagramSocket\",\n                    \"java.net.ServerSocket\");\n        }","id":73560,"modified_method":"private static boolean isSocketResource(PsiNewExpression expression){\n            return TypeUtils.expressionHasTypeOrSubtype(expression,\n                    \"java.net.Socket\",\n                    \"java.net.DatagramSocket\",\n                    \"java.net.ServerSocket\") != null;\n        }","commit_id":"1a36ba3231da308a0b5b3f0613caeda60a4f1096","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override public void visitSynchronizedStatement(\n                @NotNull PsiSynchronizedStatement statement) {\n            super.visitSynchronizedStatement(statement);\n            final PsiExpression lockExpression = statement.getLockExpression();\n            if (lockExpression == null) {\n                return;\n            }\n            if (TypeUtils.expressionHasTypeOrSubtype(lockExpression,\n                    \"java.util.concurrent.locks.Lock\")) {\n                registerError(lockExpression,\n                        \"java.util.concurrent.locks.Lock\");\n            } else if (TypeUtils.expressionHasTypeOrSubtype(lockExpression,\n                    \"java.util.concurrent.locks.ReadWriteLock\")) {\n                registerError(lockExpression,\n                        \"java.util.concurrent.locks.ReadWriteLock\");\n            }\n        }","id":73561,"modified_method":"@Override public void visitSynchronizedStatement(\n                @NotNull PsiSynchronizedStatement statement) {\n            super.visitSynchronizedStatement(statement);\n            final PsiExpression lockExpression = statement.getLockExpression();\n            if (lockExpression == null) {\n                return;\n            }\n            final String type = TypeUtils.expressionHasTypeOrSubtype(\n                    lockExpression,\n                    \"java.util.concurrent.locks.Lock\",\n                    \"java.util.concurrent.locks.ReadWriteLock\");\n            if (type == null) {\n                return;\n            }\n            registerError(lockExpression, type);\n        }","commit_id":"1a36ba3231da308a0b5b3f0613caeda60a4f1096","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    protected String buildErrorString(Object... infos) {\n        final PsiExpression expression = (PsiExpression)infos[0];\n        if (TypeUtils.expressionHasTypeOrSubtype(expression, \"java.lang.RuntimeException\")) {\n            return InspectionGadgetsBundle.message(\n                    \"throwable.instance.never.thrown.runtime.exception.problem.descriptor\");\n        } else if (TypeUtils.expressionHasTypeOrSubtype(expression, \"java.lang.Exception\")) {\n            return InspectionGadgetsBundle.message(\n                    \"throwable.instance.never.thrown.checked.exception.problem.descriptor\");\n        } else if (TypeUtils.expressionHasTypeOrSubtype(expression, \"java.lang.Error\")) {\n            return InspectionGadgetsBundle.message(\n                    \"throwable.instance.never.thrown.error.problem.descriptor\");\n        } else {\n            return InspectionGadgetsBundle.message(\n                    \"throwable.instance.never.thrown.problem.descriptor\");\n        }\n    }","id":73562,"modified_method":"@Override\n    @NotNull\n    protected String buildErrorString(Object... infos) {\n        final PsiExpression expression = (PsiExpression)infos[0];\n        final String type =\n                TypeUtils.expressionHasTypeOrSubtype(expression,\n                        \"java.lang.RuntimeException\", \"java.lang.Exception\",\n                        \"java.lang.Error\");\n        if (\"java.lang.RuntimeException\".equals(type)) {\n            return InspectionGadgetsBundle.message(\n                    \"throwable.instance.never.thrown.runtime.exception.problem.descriptor\");\n        } else if (\"java.lang.Exception\".equals(type)) {\n            return InspectionGadgetsBundle.message(\n                    \"throwable.instance.never.thrown.checked.exception.problem.descriptor\");\n        } else if (\"java.lang.Error\".equals(type)) {\n            return InspectionGadgetsBundle.message(\n                    \"throwable.instance.never.thrown.error.problem.descriptor\");\n        } else {\n            return InspectionGadgetsBundle.message(\n                    \"throwable.instance.never.thrown.problem.descriptor\");\n        }\n    }","commit_id":"1a36ba3231da308a0b5b3f0613caeda60a4f1096","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean typeEquals(@NonNls @NotNull String typeName,\n                                     @Nullable PsiType targetType) {\n        if (targetType == null) {\n            return false;\n        }\n        return targetType.equalsToText(typeName);\n    }","id":73563,"modified_method":"public static boolean typeEquals(@NonNls @NotNull String typeName,\n                                     @Nullable PsiType targetType) {\n        return targetType != null && targetType.equalsToText(typeName);\n    }","commit_id":"1a36ba3231da308a0b5b3f0613caeda60a4f1096","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean expressionHasTypeOrSubtype(\n            @Nullable PsiExpression expression,\n            @NonNls @NotNull String typeName,\n            @NonNls @NotNull String... typeNames) {\n        if (expression == null) {\n            return false;\n        }\n        final PsiType type = expression.getType();\n        if (type == null) {\n            return false;\n        }\n        if (!(type instanceof PsiClassType)) {\n            return false;\n        }\n        final PsiClassType classType = (PsiClassType) type;\n        final PsiClass aClass = classType.resolve();\n        if (aClass == null) {\n            return false;\n        }\n        if (ClassUtils.isSubclass(aClass, typeName)) {\n            return true;\n        }\n        for (String typeName1 : typeNames) {\n            if (ClassUtils.isSubclass(aClass, typeName1)) {\n                return true;\n            }\n        }\n        return false;\n    }","id":73564,"modified_method":"public static String expressionHasTypeOrSubtype(\n            @Nullable PsiExpression expression,\n            @NonNls @NotNull String... typeNames) {\n        if (expression == null) {\n            return null;\n        }\n        final PsiType type = expression.getType();\n        if (type == null) {\n            return null;\n        }\n        if (!(type instanceof PsiClassType)) {\n            return null;\n        }\n        final PsiClassType classType = (PsiClassType) type;\n        final PsiClass aClass = classType.resolve();\n        if (aClass == null) {\n            return null;\n        }\n        for (String typeName : typeNames) {\n            if (ClassUtils.isSubclass(aClass, typeName)) {\n                return typeName;\n            }\n        }\n        return null;\n    }","commit_id":"1a36ba3231da308a0b5b3f0613caeda60a4f1096","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public OperationResult<ImmutablePair<byte[], Long>> getWithVersion(byte[] row, byte[] column,\n                                                                     ReadPointer readPointer) {\n    PreparedStatement ps = null;\n    try {\n      ps = this.connection.prepareStatement(\n          \"SELECT version, kvtype, id, value \" +\n              \"FROM \" + this.tableName + \" \" +\n              \"WHERE row = ? AND column = ? \" +\n          \"ORDER BY version DESC, kvtype ASC, id DESC\");\n      ps.setBytes(1, row);\n      ps.setBytes(2, column);\n      ResultSet result = ps.executeQuery();\n      ImmutablePair<Long,byte[]> latest = filteredLatest(result, readPointer);\n      if (latest == null) return null;\n      return new ImmutablePair<byte[],Long>(latest.getSecond(),\n          latest.getFirst());\n    } catch (SQLException e) {\n      throw new RuntimeException(\"SQL Exception\", e);\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }","id":73565,"modified_method":"@Override\n  public OperationResult<ImmutablePair<byte[], Long>>\n  getWithVersion(byte[] row, byte[] column, ReadPointer readPointer)\n      throws OperationException {\n\n    PreparedStatement ps = null;\n    try {\n      ps = this.connection.prepareStatement(\n          \"SELECT version, kvtype, id, value \" +\n              \"FROM \" + this.tableName + \" \" +\n              \"WHERE row = ? AND column = ? \" +\n          \"ORDER BY version DESC, kvtype ASC, id DESC\");\n      ps.setBytes(1, row);\n      ps.setBytes(2, column);\n      ResultSet result = ps.executeQuery();\n      ImmutablePair<Long,byte[]> latest = filteredLatest(result, readPointer);\n\n      if (latest == null)\n        return new OperationResult<ImmutablePair<byte[], Long>>(\n            StatusCode.KEY_NOT_FOUND);\n\n      return new OperationResult<ImmutablePair<byte[], Long>>(\n          new ImmutablePair<byte[],Long>(\n              latest.getSecond(), latest.getFirst()));\n\n    } catch (SQLException e) {\n      handleSQLException(e, \"select\");\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          handleSQLException(e, \"close\");\n        }\n      }\n    }\n    throw new InternalError(\"this point should never be reached.\");\n  }","commit_id":"dd50d98572f5eb7e6d8a14284c9781ca2e08b36f","url":"https://github.com/caskdata/cdap"},{"original_method":"private void handleSQLException(SQLException e) {\n    throw new RuntimeException(\"Received a SQLException\", e);\n  }","id":73566,"modified_method":"private void handleSQLException(SQLException e, String where)\n      throws OperationException {\n    String msg = \"HyperSQL exception on \" + where + \"(error code = \" +\n        e.getErrorCode() + \")\";\n    Log.error(msg, e);\n    throw new OperationException(StatusCode.SQL_ERROR, msg, e);\n  }","commit_id":"dd50d98572f5eb7e6d8a14284c9781ca2e08b36f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, byte[][] columns,\n      ReadPointer readPointer) {\n    PreparedStatement ps = null;\n    try {\n      String [] columnChecks = new String[columns.length];\n      String columnCheck = \"column = ?\";\n      for (int i=0; i<columnChecks.length; i++) {\n        columnChecks[i] = columnCheck;\n      }\n      columnCheck = StringUtils.join(columnChecks, \" OR \");\n\n      ps = this.connection.prepareStatement(\n          \"SELECT column, version, kvtype, id, value \" +\n              \"FROM \" + this.tableName + \" \" +\n              \"WHERE row = ? AND (\" + columnCheck + \") \" +\n          \"ORDER BY column ASC, version DESC, kvtype ASC, id DESC\");\n      ps.setBytes(1, row);\n      int idx = 2;\n      for (byte [] column : columns) {\n        ps.setBytes(idx++, column);\n      }\n      ResultSet result = ps.executeQuery();\n      return filteredLatestColumns(result, readPointer);\n    } catch (SQLException e) {\n      throw new RuntimeException(\"SQL Exception\", e);\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }","id":73567,"modified_method":"@Override\n  public OperationResult<Map<byte[], byte[]>>\n  get(byte[] row, byte[][] columns, ReadPointer readPointer) throws OperationException {\n    PreparedStatement ps = null;\n    try {\n      String [] columnChecks = new String[columns.length];\n      String columnCheck = \"column = ?\";\n      for (int i=0; i<columnChecks.length; i++) {\n        columnChecks[i] = columnCheck;\n      }\n      columnCheck = StringUtils.join(columnChecks, \" OR \");\n\n      ps = this.connection.prepareStatement(\n          \"SELECT column, version, kvtype, id, value \" +\n              \"FROM \" + this.tableName + \" \" +\n              \"WHERE row = ? AND (\" + columnCheck + \") \" +\n          \"ORDER BY column ASC, version DESC, kvtype ASC, id DESC\");\n      ps.setBytes(1, row);\n      int idx = 2;\n      for (byte [] column : columns) {\n        ps.setBytes(idx++, column);\n      }\n      ResultSet result = ps.executeQuery();\n      return new OperationResult<Map<byte[], byte[]>>(\n          filteredLatestColumns(result, readPointer));\n\n    } catch (SQLException e) {\n      handleSQLException(e, \"select\");\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          handleSQLException(e, \"close\");\n        }\n      }\n    }\n    throw new InternalError(\"this point should never be reached.\");\n  }","commit_id":"dd50d98572f5eb7e6d8a14284c9781ca2e08b36f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public long increment(byte[] row, byte[] column, long amount,\n      ReadPointer readPointer, long writeVersion) {\n    PreparedStatement ps = null;\n    try {\n      ps = this.connection.prepareStatement(\n          \"SELECT version, kvtype, id, value \" +\n          \"FROM \" + this.tableName + \" \" +\n          \"WHERE row = ? AND column = ? \" +\n          \"ORDER BY version DESC, kvtype ASC, id DESC\");\n      ps.setBytes(1, row);\n      ps.setBytes(2, column);\n      ResultSet result = ps.executeQuery();\n      long newAmount = amount;\n      ImmutablePair<Long, byte[]> latest = filteredLatest(result, readPointer);\n      if (latest != null) {\n        newAmount += Bytes.toLong(latest.getSecond());\n      }\n      ps.close();\n      ps = this.connection.prepareStatement(\n          \"INSERT INTO \" + this.tableName +\n          \" (row, column, version, kvtype, value) VALUES ( ? , ? , ? , ? , ?)\");\n      ps.setBytes(1, row);\n      ps.setBytes(2, column);\n      ps.setLong(3, writeVersion);\n      ps.setInt(4, Type.VALUE.i);\n      ps.setBytes(5, Bytes.toBytes(newAmount));\n      ps.executeUpdate();\n      return newAmount;\n\n    } catch (SQLException e) {\n      throw new RuntimeException(\"SQL Exception\", e);\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }","id":73568,"modified_method":"@Override\n  public long increment(byte[] row, byte[] column, long amount,\n      ReadPointer readPointer, long writeVersion) throws OperationException {\n    PreparedStatement ps = null;\n    long newAmount = amount;\n    try {\n      try {\n        ps = this.connection.prepareStatement(\n            \"SELECT version, kvtype, id, value \" +\n                \"FROM \" + this.tableName + \" \" +\n                \"WHERE row = ? AND column = ? \" +\n                \"ORDER BY version DESC, kvtype ASC, id DESC\");\n        ps.setBytes(1, row);\n        ps.setBytes(2, column);\n        ResultSet result = ps.executeQuery();\n        ImmutablePair<Long, byte[]> latest =\n            filteredLatest(result, readPointer);\n        if (latest != null) {\n          newAmount += Bytes.toLong(latest.getSecond());\n        }\n        ps.close();\n      } catch (SQLException e) {\n        handleSQLException(e, \"select\");\n      }\n      try {\n        ps = this.connection.prepareStatement(\n            \"INSERT INTO \" + this.tableName +\n                \" (row, column, version, kvtype, value) \" +\n                \"VALUES ( ? , ? , ? , ? , ?)\");\n        ps.setBytes(1, row);\n        ps.setBytes(2, column);\n        ps.setLong(3, writeVersion);\n        ps.setInt(4, Type.VALUE.i);\n        ps.setBytes(5, Bytes.toBytes(newAmount));\n        ps.executeUpdate();\n      } catch (SQLException e) {\n        handleSQLException(e, \"insert\");\n      }\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          handleSQLException(e, \"close\");\n        }\n      }\n    }\n    return newAmount;\n  }","commit_id":"dd50d98572f5eb7e6d8a14284c9781ca2e08b36f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<byte[]> getKeys(int limit, int offset, ReadPointer readPointer) {\n    PreparedStatement ps = null;\n    try {\n      ps = this.connection.prepareStatement(\n          \"SELECT row, column, version, kvtype, id \" +\n              \"FROM \" + this.tableName + \" \" +\n          \"ORDER BY row ASC, column ASC, version DESC, kvtype ASC, id DESC\");\n      ResultSet result = ps.executeQuery();\n      List<byte[]> keys = new ArrayList<byte[]>(limit > 1024 ? 1024 : limit);\n      int returned = 0;\n      int skipped = 0;\n      long lastDelete = -1;\n      long undeleted = -1;\n      byte [] lastRow = new byte[0];\n      byte [] curRow = new byte[0];\n      byte [] curCol = new byte [0];\n      byte [] lastCol = new byte [0];\n      while (result.next() && returned < limit) {\n        // See if we already included this row\n        byte [] row = result.getBytes(1);\n        if (Bytes.equals(lastRow, row)) continue;\n\n        // See if this is a new row (clear col/del tracking if so)\n        if (!Bytes.equals(curRow, row)) {\n          lastCol = new byte[0];\n          curCol = new byte[0];\n          lastDelete = -1;\n          undeleted = -1;\n        }\n        curRow = row;\n\n        // Check visibility of this entry\n        long curVersion = result.getLong(3);\n        // Check if this entry is visible, skip if not\n        if (!readPointer.isVisible(curVersion)) continue;\n\n        byte [] column = result.getBytes(2);\n        // Check if this column has been completely deleted\n        if (Bytes.equals(lastCol, column)) {\n          continue;\n        }\n        // Check if this is a new column, reset delete pointers if so\n        if (!Bytes.equals(curCol, column)) {\n          curCol = column;\n          lastDelete = -1;\n          undeleted = -1;\n        }\n        // Check if type is a delete and execute accordingly\n        Type type = Type.from(result.getInt(4));\n        if (type.isUndeleteAll()) {\n          undeleted = curVersion;\n          continue;\n        }\n        if (type.isDeleteAll()) {\n          if (undeleted == curVersion) continue;\n          else {\n            // The rest of this column has been deleted, act like we returned it\n            lastCol = column;\n            continue;\n          }\n        }\n        if (type.isDelete()) {\n          lastDelete = curVersion;\n          continue;\n        }\n        if (curVersion == lastDelete) continue;\n        // Column is valid, therefore row is valid, add row\n        lastRow = row;\n        if (skipped < offset) {\n          skipped++;\n        } else {\n          keys.add(row);\n          returned++;\n        }\n      }\n      return keys;\n    } catch (SQLException e) {\n      throw new RuntimeException(\"SQL Exception\", e);\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }","id":73569,"modified_method":"@Override\n  public List<byte[]> getKeys(int limit, int offset, ReadPointer readPointer)\n      throws OperationException {\n    PreparedStatement ps = null;\n    try {\n      ps = this.connection.prepareStatement(\n          \"SELECT row, column, version, kvtype, id \" +\n              \"FROM \" + this.tableName + \" \" +\n          \"ORDER BY row ASC, column ASC, version DESC, kvtype ASC, id DESC\");\n      ResultSet result = ps.executeQuery();\n      List<byte[]> keys = new ArrayList<byte[]>(limit > 1024 ? 1024 : limit);\n      int returned = 0;\n      int skipped = 0;\n      long lastDelete = -1;\n      long undeleted = -1;\n      byte [] lastRow = new byte[0];\n      byte [] curRow = new byte[0];\n      byte [] curCol = new byte [0];\n      byte [] lastCol = new byte [0];\n      while (result.next() && returned < limit) {\n        // See if we already included this row\n        byte [] row = result.getBytes(1);\n        if (Bytes.equals(lastRow, row)) continue;\n\n        // See if this is a new row (clear col/del tracking if so)\n        if (!Bytes.equals(curRow, row)) {\n          lastCol = new byte[0];\n          curCol = new byte[0];\n          lastDelete = -1;\n          undeleted = -1;\n        }\n        curRow = row;\n\n        // Check visibility of this entry\n        long curVersion = result.getLong(3);\n        // Check if this entry is visible, skip if not\n        if (!readPointer.isVisible(curVersion)) continue;\n\n        byte [] column = result.getBytes(2);\n        // Check if this column has been completely deleted\n        if (Bytes.equals(lastCol, column)) {\n          continue;\n        }\n        // Check if this is a new column, reset delete pointers if so\n        if (!Bytes.equals(curCol, column)) {\n          curCol = column;\n          lastDelete = -1;\n          undeleted = -1;\n        }\n        // Check if type is a delete and execute accordingly\n        Type type = Type.from(result.getInt(4));\n        if (type.isUndeleteAll()) {\n          undeleted = curVersion;\n          continue;\n        }\n        if (type.isDeleteAll()) {\n          if (undeleted == curVersion) continue;\n          else {\n            // The rest of this column has been deleted, act like we returned it\n            lastCol = column;\n            continue;\n          }\n        }\n        if (type.isDelete()) {\n          lastDelete = curVersion;\n          continue;\n        }\n        if (curVersion == lastDelete) continue;\n        // Column is valid, therefore row is valid, add row\n        lastRow = row;\n        if (skipped < offset) {\n          skipped++;\n        } else {\n          keys.add(row);\n          returned++;\n        }\n      }\n      return keys;\n    } catch (SQLException e) {\n      handleSQLException(e, \"select\");\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          handleSQLException(e, \"close\");\n        }\n      }\n    }\n    throw new InternalError(\"this point should never be reached.\");\n  }","commit_id":"dd50d98572f5eb7e6d8a14284c9781ca2e08b36f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void clear() {\n    PreparedStatement ps = null;\n    try {\n      ps = this.connection.prepareStatement(\"DELETE FROM \" + this.tableName);\n      ps.executeUpdate();\n    } catch (SQLException e) {\n      throw new RuntimeException(\"SQL Exception\", e);\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }","id":73570,"modified_method":"@Override\n  public void clear() throws OperationException {\n    PreparedStatement ps = null;\n    try {\n      ps = this.connection.prepareStatement(\"DELETE FROM \" + this.tableName);\n      ps.executeUpdate();\n    } catch (SQLException e) {\n      handleSQLException(e, \"delete\");\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          handleSQLException(e, \"close\");\n        }\n      }\n    }\n  }","commit_id":"dd50d98572f5eb7e6d8a14284c9781ca2e08b36f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, ReadPointer readPointer) {\n    PreparedStatement ps = null;\n    try {\n      ps = this.connection.prepareStatement(\n          \"SELECT column, version, kvtype, id, value \" +\n              \"FROM \" + this.tableName + \" \" +\n              \"WHERE row = ? \" +\n          \"ORDER BY column ASC, version DESC, kvtype ASC, id DESC\");\n      ps.setBytes(1, row);\n      ResultSet result = ps.executeQuery();\n      return filteredLatestColumns(result, readPointer);\n    } catch (SQLException e) {\n      throw new RuntimeException(\"SQL Exception\", e);\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }","id":73571,"modified_method":"@Override\n  public OperationResult<Map<byte[], byte[]>>\n  get(byte[] row, ReadPointer readPointer) throws OperationException {\n    PreparedStatement ps = null;\n    try {\n      ps = this.connection.prepareStatement(\n          \"SELECT column, version, kvtype, id, value \" +\n              \"FROM \" + this.tableName + \" \" +\n              \"WHERE row = ? \" +\n          \"ORDER BY column ASC, version DESC, kvtype ASC, id DESC\");\n      ps.setBytes(1, row);\n      ResultSet result = ps.executeQuery();\n      return new OperationResult<Map<byte[], byte[]>>(\n          filteredLatestColumns(result, readPointer));\n\n    } catch (SQLException e) {\n      handleSQLException(e, \"select\");\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          handleSQLException(e, \"close\");\n        }\n      }\n    }\n    throw new InternalError(\"this point should never be reached.\");\n  }","commit_id":"dd50d98572f5eb7e6d8a14284c9781ca2e08b36f","url":"https://github.com/caskdata/cdap"},{"original_method":"private void performInsert(byte [] row, byte [] column, long version,\n      Type type, byte [] value) {\n    PreparedStatement ps = null;\n    try {\n      ps = this.connection.prepareStatement(\n          \"INSERT INTO \" + this.tableName +\n          \" (row, column, version, kvtype, value) VALUES ( ?, ?, ?, ?, ? )\");\n      ps.setBytes(1, row);\n      ps.setBytes(2, column);\n      ps.setLong(3, version);\n      ps.setInt(4, type.i);\n      ps.setBytes(5, value);\n      ps.executeUpdate();\n    } catch (SQLException e) {\n      handleSQLException(e);\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          handleSQLException(e);\n        }\n      }\n    }\n  }","id":73572,"modified_method":"private void performInsert(byte [] row, byte [] column, long version,\n      Type type, byte [] value) throws OperationException {\n    PreparedStatement ps = null;\n    try {\n      ps = this.connection.prepareStatement(\n          \"INSERT INTO \" + this.tableName +\n          \" (row, column, version, kvtype, value) VALUES ( ?, ?, ?, ?, ? )\");\n      ps.setBytes(1, row);\n      ps.setBytes(2, column);\n      ps.setLong(3, version);\n      ps.setInt(4, type.i);\n      ps.setBytes(5, value);\n      ps.executeUpdate();\n    } catch (SQLException e) {\n      handleSQLException(e, \"insert\");\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          handleSQLException(e, \"close\");\n        }\n      }\n    }\n  }","commit_id":"dd50d98572f5eb7e6d8a14284c9781ca2e08b36f","url":"https://github.com/caskdata/cdap"},{"original_method":"void initializeTable() {\n    String createStatement = \"CREATE CACHED TABLE \" + this.tableName + \" (\" +\n        \"row \" + ROW_TYPE + \" NOT NULL, \" +\n        \"column \" + COLUMN_TYPE + \" NOT NULL, \" +\n        \"version \" + VERSION_TYPE + \" NOT NULL, \" +\n        \"kvtype \" + TYPE_TYPE + \" NOT NULL, \" +\n        \"id BIGINT IDENTITY, \" +\n        \"value \" + VALUE_TYPE + \" NOT NULL, \" +\n        \"PRIMARY KEY (id))\";\n    String indexStatement = \"CREATE INDEX theBigIndex ON \" +\n        this.tableName + \" (row, column, version DESC, kvtype, id DESC)\";\n\n    Statement stmt = null;\n    try {\n      stmt = this.connection.createStatement();\n      stmt.executeUpdate(createStatement);\n      stmt.executeUpdate(indexStatement);\n    } catch (SQLException e) {\n      // fail silent if table/index already exists (code -21 or -23)\n      if (e.getErrorCode() != -21 && e.getErrorCode() != -23) {\n        System.out.println(\"HyperSQL exception on create (id = \" +\n            e.getErrorCode() + \")\");\n        e.printStackTrace();\n        throw new RuntimeException(e);\n      }\n    } finally {\n      if (stmt != null) { try {\n        stmt.close();\n      } catch (SQLException e) {\n        throw new RuntimeException(e);\n      } }\n    }\n  }","id":73573,"modified_method":"void initializeTable() throws OperationException {\n    String createStatement = \"CREATE CACHED TABLE \" + this.tableName + \" (\" +\n        \"row \" + ROW_TYPE + \" NOT NULL, \" +\n        \"column \" + COLUMN_TYPE + \" NOT NULL, \" +\n        \"version \" + VERSION_TYPE + \" NOT NULL, \" +\n        \"kvtype \" + TYPE_TYPE + \" NOT NULL, \" +\n        \"id BIGINT IDENTITY, \" +\n        \"value \" + VALUE_TYPE + \" NOT NULL, \" +\n        \"PRIMARY KEY (id))\";\n    String indexStatement = \"CREATE INDEX theBigIndex ON \" +\n        this.tableName + \" (row, column, version DESC, kvtype, id DESC)\";\n\n    Statement stmt = null;\n    try {\n      stmt = this.connection.createStatement();\n      stmt.executeUpdate(createStatement);\n      stmt.executeUpdate(indexStatement);\n    } catch (SQLException e) {\n      // fail silent if table/index already exists (code -21 or -23)\n      if (e.getErrorCode() != -21 && e.getErrorCode() != -23) {\n        handleSQLException(e, \"create\");\n      }\n    } finally {\n      if (stmt != null) {\n        try {\n          stmt.close();\n        } catch (SQLException e) {\n          handleSQLException(e, \"close\");\n        }\n      }\n    }\n  }","commit_id":"dd50d98572f5eb7e6d8a14284c9781ca2e08b36f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Map<byte[], byte[]> get(byte[] row, byte[] startColumn,\n      byte[] stopColumn, ReadPointer readPointer) {\n    PreparedStatement ps = null;\n    try {\n      String columnChecks = \"\";\n      if (startColumn != null) columnChecks += \" AND column >= ?\";\n      if (stopColumn != null) columnChecks += \" AND column < ?\";\n      ps = this.connection.prepareStatement(\n          \"SELECT column, version, kvtype, id, value \" +\n              \"FROM \" + this.tableName + \" \" +\n              \"WHERE row = ?\" + columnChecks + \" \" +\n          \"ORDER BY column ASC, version DESC, kvtype ASC, id DESC\");\n      ps.setBytes(1, row);\n      int idx = 2;\n      if (startColumn != null) {\n        ps.setBytes(idx, startColumn);\n        idx++;\n      }\n      if (stopColumn != null) {\n        ps.setBytes(idx, stopColumn);\n      }\n      ResultSet result = ps.executeQuery();\n      return filteredLatestColumns(result, readPointer);\n    } catch (SQLException e) {\n      throw new RuntimeException(\"SQL Exception\", e);\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }","id":73574,"modified_method":"@Override\n  public OperationResult<Map<byte[], byte[]>>\n  get(byte[] row, byte[] startColumn, byte[] stopColumn,\n      ReadPointer readPointer) throws OperationException {\n\n    PreparedStatement ps = null;\n    try {\n      String columnChecks = \"\";\n      if (startColumn != null) columnChecks += \" AND column >= ?\";\n      if (stopColumn != null) columnChecks += \" AND column < ?\";\n      ps = this.connection.prepareStatement(\n          \"SELECT column, version, kvtype, id, value \" +\n              \"FROM \" + this.tableName + \" \" +\n              \"WHERE row = ?\" + columnChecks + \" \" +\n          \"ORDER BY column ASC, version DESC, kvtype ASC, id DESC\");\n      ps.setBytes(1, row);\n      int idx = 2;\n      if (startColumn != null) {\n        ps.setBytes(idx, startColumn);\n        idx++;\n      }\n      if (stopColumn != null) {\n        ps.setBytes(idx, stopColumn);\n      }\n      ResultSet result = ps.executeQuery();\n      return new OperationResult<Map<byte[], byte[]>>(\n          filteredLatestColumns(result, readPointer));\n    } catch (SQLException e) {\n      handleSQLException(e, \"select\");\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          handleSQLException(e, \"close\");\n        }\n      }\n    }\n    throw new InternalError(\"this point should never be reached.\");\n  }","commit_id":"dd50d98572f5eb7e6d8a14284c9781ca2e08b36f","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Result has (column, version, kvtype, id, value)\n   * @param result\n   * @param readPointer\n   * @return\n   * @throws SQLException\n   */\n  private Map<byte[], byte[]> filteredLatestColumns(ResultSet result,\n      ReadPointer readPointer) throws SQLException {\n    Map<byte[],byte[]> map = new TreeMap<byte[],byte[]>(Bytes.BYTES_COMPARATOR);\n    if (result == null) return map;\n    byte [] curCol = new byte [0];\n    byte [] lastCol = new byte [0];\n    long lastDelete = -1;\n    long undeleted = -1;\n    while (result.next()) {\n      long curVersion = result.getLong(2);\n      // Check if this entry is visible, skip if not\n      if (!readPointer.isVisible(curVersion)) continue;\n      byte [] column = result.getBytes(1);\n      // Check if this column has already been included in result, skip if so\n      if (Bytes.equals(lastCol, column)) {\n        continue;\n      }\n      // Check if this is a new column, reset delete pointers if so\n      if (!Bytes.equals(curCol, column)) {\n        curCol = column;\n        lastDelete = -1;\n        undeleted = -1;\n      }\n      // Check if type is a delete and execute accordingly\n      Type type = Type.from(result.getInt(3));\n      if (type.isUndeleteAll()) {\n        undeleted = curVersion;\n        continue;\n      }\n      if (type.isDeleteAll()) {\n        if (undeleted == curVersion) continue;\n        else {\n          // The rest of this column has been deleted, act like we returned it\n          lastCol = column;\n          continue;\n        }\n      }\n      if (type.isDelete()) {\n        lastDelete = curVersion;\n        continue;\n      }\n      if (curVersion == lastDelete) continue;\n      lastCol = column;\n      map.put(column, result.getBytes(5));\n    }\n    return map;\n  }","id":73575,"modified_method":"/**\n   * Result has (column, version, kvtype, id, value)\n   * @throws SQLException\n   */\n  private Map<byte[], byte[]> filteredLatestColumns(ResultSet result,\n      ReadPointer readPointer) throws SQLException {\n    Map<byte[],byte[]> map = new TreeMap<byte[],byte[]>(Bytes.BYTES_COMPARATOR);\n    if (result == null) return map;\n    byte [] curCol = new byte [0];\n    byte [] lastCol = new byte [0];\n    long lastDelete = -1;\n    long undeleted = -1;\n    while (result.next()) {\n      long curVersion = result.getLong(2);\n      // Check if this entry is visible, skip if not\n      if (!readPointer.isVisible(curVersion)) continue;\n      byte [] column = result.getBytes(1);\n      // Check if this column has already been included in result, skip if so\n      if (Bytes.equals(lastCol, column)) {\n        continue;\n      }\n      // Check if this is a new column, reset delete pointers if so\n      if (!Bytes.equals(curCol, column)) {\n        curCol = column;\n        lastDelete = -1;\n        undeleted = -1;\n      }\n      // Check if type is a delete and execute accordingly\n      Type type = Type.from(result.getInt(3));\n      if (type.isUndeleteAll()) {\n        undeleted = curVersion;\n        continue;\n      }\n      if (type.isDeleteAll()) {\n        if (undeleted == curVersion) continue;\n        else {\n          // The rest of this column has been deleted, act like we returned it\n          lastCol = column;\n          continue;\n        }\n      }\n      if (type.isDelete()) {\n        lastDelete = curVersion;\n        continue;\n      }\n      if (curVersion == lastDelete) continue;\n      lastCol = column;\n      map.put(column, result.getBytes(5));\n    }\n    return map;\n  }","commit_id":"dd50d98572f5eb7e6d8a14284c9781ca2e08b36f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void compareAndSwap(byte[] row, byte[] column,\n                             byte[] expectedValue, byte[] newValue, ReadPointer readPointer,\n                             long writeVersion) throws OperationException {\n    PreparedStatement ps = null;\n    try {\n      ps = this.connection.prepareStatement(\n          \"SELECT version, kvtype, id, value \" +\n          \"FROM \" + this.tableName + \" \" +\n          \"WHERE row = ? AND column = ? \" +\n          \"ORDER BY version DESC, kvtype ASC, id DESC\");\n      ps.setBytes(1, row);\n      ps.setBytes(2, column);\n      ResultSet result = ps.executeQuery();\n      ImmutablePair<Long, byte[]> latest = filteredLatest(result, readPointer);\n      byte [] existingValue = latest == null ? null : latest.getSecond();\n      ps.close(); ps = null;\n\n      // handle invalid cases regarding non-existent values\n      if (existingValue == null && expectedValue != null) return false;\n      if (existingValue != null && expectedValue == null) return false;\n\n      // if nothing existed, just write\n      // TODO: this is not atomic and thus is broken?  how to make it atomic?\n      if (expectedValue == null) {\n        put(row, column, writeVersion, newValue);\n        return true;\n      }\n\n      // check if expected == existing, fail if not\n      if (!Bytes.equals(expectedValue, existingValue)) {\n        return false;\n      }\n\n      // if newValue is null, just delete.\n      // TODO: this can't be rolled back!\n      if (newValue == null) {\n        deleteAll(row, column, latest.getFirst());\n        return true;\n      }\n\n      // Perform update!\n      ps = this.connection.prepareStatement(\n          \"INSERT INTO \" + this.tableName +\n          \" (row, column, version, kvtype, value) VALUES ( ?, ? , ? , ? , ? )\");\n      ps.setBytes(1, row);\n      ps.setBytes(2, column);\n      ps.setLong(3, writeVersion);\n      ps.setInt(4, Type.VALUE.i);\n      ps.setBytes(5, newValue);\n      ps.executeUpdate();\n      return true;\n\n    } catch (SQLException e) {\n      throw new RuntimeException(\"SQL Exception\", e);\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n  }","id":73576,"modified_method":"@Override\n  public void compareAndSwap(byte[] row, byte[] column,\n                             byte[] expectedValue, byte[] newValue, ReadPointer readPointer,\n                             long writeVersion) throws OperationException {\n    PreparedStatement ps = null;\n    try {\n      ps = this.connection.prepareStatement(\n          \"SELECT version, kvtype, id, value \" +\n          \"FROM \" + this.tableName + \" \" +\n          \"WHERE row = ? AND column = ? \" +\n          \"ORDER BY version DESC, kvtype ASC, id DESC\");\n      ps.setBytes(1, row);\n      ps.setBytes(2, column);\n      ResultSet result = ps.executeQuery();\n      ImmutablePair<Long, byte[]> latest = filteredLatest(result, readPointer);\n      byte [] existingValue = latest == null ? null : latest.getSecond();\n      ps.close(); ps = null;\n\n      // handle invalid cases regarding non-existent values\n      if (existingValue == null && expectedValue != null)\n        throw new OperationException(StatusCode.WRITE_CONFLICT,\n            \"CompareAndSwap expected value mismatch\");\n      if (existingValue != null && expectedValue == null)\n        throw new OperationException(StatusCode.WRITE_CONFLICT,\n            \"CompareAndSwap expected value mismatch\");\n\n      // if nothing existed, just write\n      // TODO: this is not atomic and thus is broken?  how to make it atomic?\n      if (expectedValue == null) {\n        put(row, column, writeVersion, newValue);\n        return;\n      }\n\n      // check if expected == existing, fail if not\n      if (!Bytes.equals(expectedValue, existingValue))\n        throw new OperationException(StatusCode.WRITE_CONFLICT,\n            \"CompareAndSwap expected value mismatch\");\n\n      // if newValue is null, just delete.\n      // TODO: this can't be rolled back!\n      if (newValue == null) {\n        deleteAll(row, column, latest.getFirst());\n        return;\n      }\n\n      // Perform update!\n      ps = this.connection.prepareStatement(\n          \"INSERT INTO \" + this.tableName +\n          \" (row, column, version, kvtype, value) VALUES ( ?, ? , ? , ? , ? )\");\n      ps.setBytes(1, row);\n      ps.setBytes(2, column);\n      ps.setLong(3, writeVersion);\n      ps.setInt(4, Type.VALUE.i);\n      ps.setBytes(5, newValue);\n      ps.executeUpdate();\n\n    } catch (SQLException e) {\n        handleSQLException(e, \"compareAndSwap\");\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          handleSQLException(e, \"close\");\n        }\n      }\n    }\n  }","commit_id":"dd50d98572f5eb7e6d8a14284c9781ca2e08b36f","url":"https://github.com/caskdata/cdap"},{"original_method":"private void performInsert(byte [] row, byte [][] columns, long version,\n      Type type, byte [][] values) {\n    PreparedStatement ps = null;\n    try {\n      ps = this.connection.prepareStatement(\n          \"INSERT INTO \" + this.tableName +\n          \" (row, column, version, kvtype, value) VALUES ( ?, ?, ?, ?, ? )\");\n      for (int i=0; i<columns.length; i++) {\n        ps.setBytes(1, row);\n        ps.setBytes(2, columns[i]);\n        ps.setLong(3, version);\n        ps.setInt(4, type.i);\n        ps.setBytes(5, values[i]);\n        ps.executeUpdate();\n      }\n    } catch (SQLException e) {\n      handleSQLException(e);\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          handleSQLException(e);\n        }\n      }\n    }\n  }","id":73577,"modified_method":"private void performInsert(byte [] row, byte [][] columns, long version,\n      Type type, byte [][] values) throws OperationException {\n    PreparedStatement ps = null;\n    try {\n      ps = this.connection.prepareStatement(\n          \"INSERT INTO \" + this.tableName +\n          \" (row, column, version, kvtype, value) VALUES ( ?, ?, ?, ?, ? )\");\n      for (int i=0; i<columns.length; i++) {\n        ps.setBytes(1, row);\n        ps.setBytes(2, columns[i]);\n        ps.setLong(3, version);\n        ps.setInt(4, type.i);\n        ps.setBytes(5, values[i]);\n        ps.executeUpdate();\n      }\n    } catch (SQLException e) {\n      handleSQLException(e, \"insert\");\n    } finally {\n      if (ps != null) {\n        try {\n          ps.close();\n        } catch (SQLException e) {\n          handleSQLException(e, \"close\");\n        }\n      }\n    }\n  }","commit_id":"dd50d98572f5eb7e6d8a14284c9781ca2e08b36f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public byte[] get(byte[] row, byte[] column, ReadPointer readPointer) {\n    ImmutablePair<byte[], Long> res = getWithVersion(row, column, readPointer);\n    if (res == null) return null;\n    return res.getFirst();\n  }","id":73578,"modified_method":"@Override\n  public OperationResult<byte[]>\n  get(byte[] row, byte[] column, ReadPointer readPointer)\n      throws OperationException {\n\n    OperationResult<ImmutablePair<byte[], Long>> res =\n        getWithVersion(row, column, readPointer);\n    if (res.isEmpty())\n      return new OperationResult<byte[]>(res.getStatus(), res.getMessage());\n    else\n      return new OperationResult<byte[]>(res.getValue().getFirst());\n  }","commit_id":"dd50d98572f5eb7e6d8a14284c9781ca2e08b36f","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Result has (version, kvtype, id, value)\n   * @param result\n   * @param readPointer\n   * @return\n   * @throws SQLException\n   */\n  private ImmutablePair<Long, byte[]> filteredLatest(\n      ResultSet result, ReadPointer readPointer) throws SQLException {\n    if (result == null) return null;\n    long lastDelete = -1;\n    long undeleted = -1;\n    while (result.next()) {\n      long curVersion = result.getLong(1);\n      if (!readPointer.isVisible(curVersion)) continue;\n      Type type = Type.from(result.getInt(2));\n      if (type.isUndeleteAll()) {\n        undeleted = curVersion;\n        continue;\n      }\n      if (type.isDeleteAll()) {\n        if (undeleted == curVersion) continue;\n        else break;\n      }\n      if (type.isDelete()) {\n        lastDelete = curVersion;\n        continue;\n      }\n      if (curVersion == lastDelete) continue;\n      return new ImmutablePair<Long, byte[]>(curVersion,\n          result.getBytes(4));\n    }\n    return null;\n  }","id":73579,"modified_method":"/**\n   * Result has (version, kvtype, id, value)\n   * @throws SQLException\n   */\n  private ImmutablePair<Long, byte[]> filteredLatest(\n      ResultSet result, ReadPointer readPointer) throws SQLException {\n    if (result == null) return null;\n    long lastDelete = -1;\n    long undeleted = -1;\n    while (result.next()) {\n      long curVersion = result.getLong(1);\n      if (!readPointer.isVisible(curVersion)) continue;\n      Type type = Type.from(result.getInt(2));\n      if (type.isUndeleteAll()) {\n        undeleted = curVersion;\n        continue;\n      }\n      if (type.isDeleteAll()) {\n        if (undeleted == curVersion) continue;\n        else break;\n      }\n      if (type.isDelete()) {\n        lastDelete = curVersion;\n        continue;\n      }\n      if (curVersion == lastDelete) continue;\n      return new ImmutablePair<Long, byte[]>(curVersion,\n          result.getBytes(4));\n    }\n    return null;\n  }","commit_id":"dd50d98572f5eb7e6d8a14284c9781ca2e08b36f","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Cleans dead entries from the tuples that {@link GroupBy} and {@link OrderBy} handle.\n   * @param ctx query context\n   * @return change flag\n   */\n  private boolean cleanDeadVars(final QueryContext ctx) {\n    final BitArray used = new BitArray();\n    final ASTVisitor marker = new ASTVisitor() {\n      @Override\n      public boolean used(final VarRef ref) {\n        used.set(ref.var.id);\n        return true;\n      }\n    };\n\n    ret.accept(marker);\n    boolean change = false;\n    for(int i = clauses.size(); --i >= 0;) {\n      final Clause curr = clauses.get(i);\n      change |= curr.clean(ctx, used);\n      curr.accept(marker);\n    }\n    return change;\n  }","id":73580,"modified_method":"/**\n   * Cleans dead entries from the tuples that {@link GroupBy} and {@link OrderBy} handle.\n   * @param ctx query context\n   * @return change flag\n   */\n  private boolean cleanDeadVars(final QueryContext ctx) {\n    final BitArray decl = new BitArray(), used = new BitArray();\n\n    for(final Clause cl : clauses) for(final Var v : cl.vars()) decl.set(v.id);\n    final ASTVisitor marker = new ASTVisitor() {\n      @Override\n      public boolean used(final VarRef ref) {\n        final int id = ref.var.id;\n        if(decl.get(id)) used.set(id);\n        return true;\n      }\n    };\n\n    ret.accept(marker);\n    boolean change = false;\n    for(int i = clauses.size(); --i >= 0;) {\n      final Clause curr = clauses.get(i);\n      change |= curr.clean(ctx, used);\n      curr.accept(marker);\n    }\n    return change;\n  }","commit_id":"482ae3fef48c9034f72e7902549ea1fa06e05af2","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public boolean accept(final ASTVisitor visitor) {\n    return visitAll(visitor, texpr) && visitAll(visitor, keys);\n  }","id":73581,"modified_method":"@Override\n  public boolean accept(final ASTVisitor visitor) {\n    return visitAll(visitor, refs) && visitAll(visitor, keys);\n  }","commit_id":"482ae3fef48c9034f72e7902549ea1fa06e05af2","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  Eval eval(final Eval sub) {\n    return new Eval() {\n      /** Sorted output tuples. */\n      private Value[][] tpls;\n      /** Permutation of the values. */\n      private int[] perm;\n      /** Current position. */\n      int pos;\n      @Override\n      public boolean next(final QueryContext ctx) throws QueryException {\n        if(tpls == null) init(ctx);\n        if(pos == tpls.length) return false;\n        final int p = perm[pos++];\n        final Value[] tuple = tpls[p];\n        // free the space occupied by the tuple\n        tpls[p] = null;\n        for(int i = 0; i < tvars.length; i++) ctx.set(tvars[i], tuple[i], info);\n        return true;\n      }\n\n      /**\n       * Caches and sorts all incoming tuples.\n       * @param ctx query context\n       * @throws QueryException evaluation exception\n       */\n      private void init(final QueryContext ctx) throws QueryException {\n        // keys are stored at off positions, values ad even ones\n        List<Value[]> tuples = new ArrayList<Value[]>();\n        while(sub.next(ctx)) {\n          final Item[] key = new Item[keys.length];\n          for(int i = 0; i < keys.length; i++)\n            key[i] = keys[i].expr.item(ctx, keys[i].info);\n          tuples.add(key);\n\n          final Value[] vals = new Value[tvars.length];\n          for(int i = 0; i < tvars.length; i++) vals[i] = texpr[i].value(ctx);\n          tuples.add(vals);\n        }\n\n        final int len = tuples.size() >>> 1;\n        final Item[][] ks = new Item[len][];\n        perm = new int[len];\n        tpls = new Value[len][];\n        for(int i = 0; i < len; i++) {\n          perm[i] = i;\n          tpls[i] = tuples.get((i << 1) | 1);\n          ks[i] = (Item[]) tuples.get(i << 1);\n        }\n        // be nice to the garbage collector\n        tuples = null;\n        sort(ks, 0, len);\n      }\n\n      /**\n       * Recursively sorts the specified items.\n       * The algorithm is derived from {@link Arrays#sort(int[])}.\n       * @param start start position\n       * @param len end position\n       * @throws QueryException query exception\n       */\n      private void sort(final Item[][] ks, final int start, final int len)\n          throws QueryException {\n        if(len < 7) {\n          // use insertion sort of small arrays\n          for(int i = start; i < len + start; i++)\n            for(int j = i; j > start && cmp(ks, perm[j - 1], perm[j]) > 0; j--)\n              swap(perm, j, j - 1);\n          return;\n        }\n\n        // find a good pivot element\n        int mid = start + (len >> 1);\n        if(len > 7) {\n          int left = start, right = start + len - 1;\n          if(len > 40) {\n            final int k = len >>> 3;\n            left = median(ks, left, left + k, left + (k << 1));\n            mid = median(ks, mid - k, mid, mid + k);\n            right = median(ks, right - (k << 1), right - k, right);\n          }\n          mid = median(ks, left, mid, right);\n        }\n\n        final int pivot = perm[mid];\n\n        // partition the values\n        int a = start, b = a, c = start + len - 1, d = c;\n        while(true) {\n          while(b <= c) {\n            final int h = cmp(ks, perm[b], pivot);\n            if(h > 0) break;\n            if(h == 0) swap(perm, a++, b);\n            ++b;\n          }\n          while(c >= b) {\n            final int h = cmp(ks, perm[c], pivot);\n            if(h < 0) break;\n            if(h == 0) swap(perm, c, d--);\n            --c;\n          }\n          if(b > c) break;\n          swap(perm, b++, c--);\n        }\n\n        // Swap pivot elements back to middle\n        int k;\n        final int n = start + len;\n        k = Math.min(a - start, b - a);\n        swap(perm, start, b - k, k);\n        k = Math.min(d - c, n - d - 1);\n        swap(perm, b, n - k, k);\n\n        // recursively sort non-pivot elements\n        if((k = b - a) > 1) sort(ks, start, k);\n        if((k = d - c) > 1) sort(ks, n - k, k);\n      }\n\n      /**\n       * Returns the difference of two entries (part of QuickSort).\n       * @return result\n       * @throws QueryException query exception\n       */\n      private int cmp(final Item[][] ks, final int x, final int y) throws QueryException {\n        final Item[] a = ks[x], b = ks[y];\n        for(int k = 0; k < keys.length; k++) {\n          final Key or = keys[k];\n          final Item m = a[k] == Dbl.NAN || a[k] == Flt.NAN ? null : a[k],\n              n = b[k] == Dbl.NAN || b[k] == Flt.NAN ? null : b[k];\n          final int c = m == null ? n == null ? 0 : or.least ? -1 : 1 :\n            n == null ? or.least ? 1 : -1 : m.diff(or.info, n);\n          if(c != 0) return or.desc ? -c : c;\n        }\n\n        // optional stable sorting\n        return stable ? x - y : 0;\n      }\n\n      /**\n       * Returns the index of the median of the three indexed integers.\n       * @param ks key array\n       * @param a first offset\n       * @param b second offset\n       * @param c thirst offset\n       * @return median\n       * @throws QueryException query exception\n       */\n      private int median(final Item[][] ks, final int a, final int b, final int c)\n          throws QueryException {\n        final int ka = perm[a], kb = perm[b], kc = perm[c];\n        return cmp(ks, ka, kb) < 0\n            ? cmp(ks, kb, kc) < 0 ? b : cmp(ks, ka, kc) < 0 ? c : a\n            : cmp(ks, kb, kc) > 0 ? b : cmp(ks, ka, kc) > 0 ? c : a;\n      }\n    };\n  }","id":73582,"modified_method":"@Override\n  Eval eval(final Eval sub) {\n    return new Eval() {\n      /** Sorted output tuples. */\n      private Value[][] tpls;\n      /** Permutation of the values. */\n      private int[] perm;\n      /** Current position. */\n      int pos;\n      @Override\n      public boolean next(final QueryContext ctx) throws QueryException {\n        if(tpls == null) init(ctx);\n        if(pos == tpls.length) return false;\n        final int p = perm[pos++];\n        final Value[] tuple = tpls[p];\n        // free the space occupied by the tuple\n        tpls[p] = null;\n        for(int i = 0; i < refs.length; i++) ctx.set(refs[i].var, tuple[i], info);\n        return true;\n      }\n\n      /**\n       * Caches and sorts all incoming tuples.\n       * @param ctx query context\n       * @throws QueryException evaluation exception\n       */\n      private void init(final QueryContext ctx) throws QueryException {\n        // keys are stored at odd positions, values at even ones\n        List<Value[]> tuples = new ArrayList<Value[]>();\n        while(sub.next(ctx)) {\n          final Item[] key = new Item[keys.length];\n          for(int i = 0; i < keys.length; i++)\n            key[i] = keys[i].expr.item(ctx, keys[i].info);\n          tuples.add(key);\n\n          final Value[] vals = new Value[refs.length];\n          for(int i = 0; i < refs.length; i++) vals[i] = refs[i].value(ctx);\n          tuples.add(vals);\n        }\n\n        final int len = tuples.size() >>> 1;\n        final Item[][] ks = new Item[len][];\n        perm = new int[len];\n        tpls = new Value[len][];\n        for(int i = 0; i < len; i++) {\n          perm[i] = i;\n          tpls[i] = tuples.get((i << 1) | 1);\n          ks[i] = (Item[]) tuples.get(i << 1);\n        }\n        // be nice to the garbage collector\n        tuples = null;\n        sort(ks, 0, len);\n      }\n\n      /**\n       * Recursively sorts the specified items.\n       * The algorithm is derived from {@link Arrays#sort(int[])}.\n       * @param start start position\n       * @param len end position\n       * @throws QueryException query exception\n       */\n      private void sort(final Item[][] ks, final int start, final int len)\n          throws QueryException {\n        if(len < 7) {\n          // use insertion sort of small arrays\n          for(int i = start; i < len + start; i++)\n            for(int j = i; j > start && cmp(ks, perm[j - 1], perm[j]) > 0; j--)\n              swap(perm, j, j - 1);\n          return;\n        }\n\n        // find a good pivot element\n        int mid = start + (len >> 1);\n        if(len > 7) {\n          int left = start, right = start + len - 1;\n          if(len > 40) {\n            final int k = len >>> 3;\n            left = median(ks, left, left + k, left + (k << 1));\n            mid = median(ks, mid - k, mid, mid + k);\n            right = median(ks, right - (k << 1), right - k, right);\n          }\n          mid = median(ks, left, mid, right);\n        }\n\n        final int pivot = perm[mid];\n\n        // partition the values\n        int a = start, b = a, c = start + len - 1, d = c;\n        while(true) {\n          while(b <= c) {\n            final int h = cmp(ks, perm[b], pivot);\n            if(h > 0) break;\n            if(h == 0) swap(perm, a++, b);\n            ++b;\n          }\n          while(c >= b) {\n            final int h = cmp(ks, perm[c], pivot);\n            if(h < 0) break;\n            if(h == 0) swap(perm, c, d--);\n            --c;\n          }\n          if(b > c) break;\n          swap(perm, b++, c--);\n        }\n\n        // Swap pivot elements back to middle\n        int k;\n        final int n = start + len;\n        k = Math.min(a - start, b - a);\n        swap(perm, start, b - k, k);\n        k = Math.min(d - c, n - d - 1);\n        swap(perm, b, n - k, k);\n\n        // recursively sort non-pivot elements\n        if((k = b - a) > 1) sort(ks, start, k);\n        if((k = d - c) > 1) sort(ks, n - k, k);\n      }\n\n      /**\n       * Returns the difference of two entries (part of QuickSort).\n       * @return result\n       * @throws QueryException query exception\n       */\n      private int cmp(final Item[][] ks, final int x, final int y) throws QueryException {\n        final Item[] a = ks[x], b = ks[y];\n        for(int k = 0; k < keys.length; k++) {\n          final Key or = keys[k];\n          final Item m = a[k] == Dbl.NAN || a[k] == Flt.NAN ? null : a[k],\n              n = b[k] == Dbl.NAN || b[k] == Flt.NAN ? null : b[k];\n          final int c = m == null ? n == null ? 0 : or.least ? -1 : 1 :\n            n == null ? or.least ? 1 : -1 : m.diff(or.info, n);\n          if(c != 0) return or.desc ? -c : c;\n        }\n\n        // optional stable sorting\n        return stable ? x - y : 0;\n      }\n\n      /**\n       * Returns the index of the median of the three indexed integers.\n       * @param ks key array\n       * @param a first offset\n       * @param b second offset\n       * @param c thirst offset\n       * @return median\n       * @throws QueryException query exception\n       */\n      private int median(final Item[][] ks, final int a, final int b, final int c)\n          throws QueryException {\n        final int ka = perm[a], kb = perm[b], kc = perm[c];\n        return cmp(ks, ka, kb) < 0\n            ? cmp(ks, kb, kc) < 0 ? b : cmp(ks, ka, kc) < 0 ? c : a\n            : cmp(ks, kb, kc) > 0 ? b : cmp(ks, ka, kc) > 0 ? c : a;\n      }\n    };\n  }","commit_id":"482ae3fef48c9034f72e7902549ea1fa06e05af2","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param vs variables to sort\n   * @param ks sort keys\n   * @param stbl stable sort\n   * @param ii input info\n   */\n  public OrderBy(final VarRef[] vs, final Key[] ks, final boolean stbl,\n      final InputInfo ii) {\n    super(ii);\n    tvars = new Var[vs.length];\n    texpr = new Expr[vs.length];\n    for(int i = 0; i < vs.length; i++) {\n      tvars[i] = vs[i].var;\n      texpr[i] = vs[i];\n    }\n    keys = ks;\n    stable = stbl;\n  }","id":73583,"modified_method":"/**\n   * Constructor.\n   * @param vs variables to sort\n   * @param ks sort keys\n   * @param stbl stable sort\n   * @param ii input info\n   */\n  public OrderBy(final VarRef[] vs, final Key[] ks, final boolean stbl,\n      final InputInfo ii) {\n    super(ii);\n    refs = vs;\n    keys = ks;\n    stable = stbl;\n  }","commit_id":"482ae3fef48c9034f72e7902549ea1fa06e05af2","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public VarUsage count(final Var v) {\n    return VarUsage.maximum(v, texpr) != VarUsage.NEVER\n        ? VarUsage.MORE_THAN_ONCE : VarUsage.sum(v, keys);\n  }","id":73584,"modified_method":"@Override\n  public VarUsage count(final Var v) {\n    return VarUsage.sum(v, refs) != VarUsage.NEVER\n        ? VarUsage.MORE_THAN_ONCE : VarUsage.sum(v, keys);\n  }","commit_id":"482ae3fef48c9034f72e7902549ea1fa06e05af2","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public int exprSize() {\n    int sz = 0;\n    for(final Expr e : texpr) sz += e.exprSize();\n    for(final Expr e : keys) sz += e.exprSize();\n    return sz;\n  }","id":73585,"modified_method":"@Override\n  public int exprSize() {\n    int sz = 0;\n    for(final Expr e : refs) sz += e.exprSize();\n    for(final Expr e : keys) sz += e.exprSize();\n    return sz;\n  }","commit_id":"482ae3fef48c9034f72e7902549ea1fa06e05af2","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public GFLWOR.Clause inline(final QueryContext ctx, final VarScope scp,\n      final Var v, final Expr e) throws QueryException {\n    return inlineAll(ctx, scp, keys, v, e) | inlineAll(ctx, scp, texpr, v, e)\n        ? optimize(ctx, scp) : null;\n  }","id":73586,"modified_method":"@Override\n  public GFLWOR.Clause inline(final QueryContext ctx, final VarScope scp,\n      final Var v, final Expr e) throws QueryException {\n    for(int i = refs.length; --i >= 0;)\n      if(v.is(refs[i].var)) refs = Array.delete(refs, i);\n    return inlineAll(ctx, scp, keys, v, e) ? optimize(ctx, scp) : null;\n  }","commit_id":"482ae3fef48c9034f72e7902549ea1fa06e05af2","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public OrderBy copy(final QueryContext ctx, final VarScope scp, final IntMap<Var> vs) {\n    final Var[] tv = tvars.clone();\n    for(int i = 0; i < tv.length; i++) {\n      final Var v = tv[i], cpy = vs.get(v.id);\n      if(cpy != null) tv[i] = cpy;\n    }\n    return new OrderBy(tv, Arr.copyAll(ctx, scp, vs, texpr),\n        Arr.copyAll(ctx, scp, vs, keys), stable, info);\n  }","id":73587,"modified_method":"@Override\n  public OrderBy copy(final QueryContext ctx, final VarScope scp, final IntMap<Var> vs) {\n    return new OrderBy(Arr.copyAll(ctx, scp, vs, refs),\n        Arr.copyAll(ctx, scp, vs, keys), stable, info);\n  }","commit_id":"482ae3fef48c9034f72e7902549ea1fa06e05af2","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  boolean clean(final QueryContext ctx, final BitArray used) {\n    final int len = tvars.length;\n    for(int i = 0; i < tvars.length; i++)\n      if(!used.get(tvars[i].id)) {\n        texpr = Array.delete(texpr, i);\n        tvars = Array.delete(tvars, i--);\n      }\n    return tvars.length < len;\n  }","id":73588,"modified_method":"@Override\n  boolean clean(final QueryContext ctx, final BitArray used) {\n    final int len = refs.length;\n    for(int i = refs.length; --i >= 0;)\n      if(!used.get(refs[i].var.id)) refs = Array.delete(refs, i);\n    return refs.length < len;\n  }","commit_id":"482ae3fef48c9034f72e7902549ea1fa06e05af2","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public FTExpr inline(final QueryContext ctx, final VarScope scp, final Var v, final Expr e)\n      throws QueryException {\n    return inlineAll(ctx, scp, expr, v, e) || inlineAll(ctx, scp, new Expr[] { min, max }, v, e)\n        ? optimize(ctx, scp) : null;\n  }","id":73589,"modified_method":"@Override\n  public FTExpr inline(final QueryContext ctx, final VarScope scp, final Var v, final Expr e)\n      throws QueryException {\n    final Expr mn = min.inline(ctx, scp, v, e), mx = max.inline(ctx, scp, v, e);\n    if(mn != null) min = mn;\n    if(mx != null) max = mx;\n\n    return inlineAll(ctx, scp, expr, v, e) || mn != null || mx != null\n        ? optimize(ctx, scp) : null;\n  }","commit_id":"d8627859014e37c8bc39d9a9db0a57ce48bc6baf","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void compile(final QueryContext ctx) throws QueryException {\n    if(compiled) return;\n    compiled = true;\n\n    if(check) {\n      final StaticFunc sf = ctx.funcs.get(name, args.length, info, true);\n      if(sf == null) throw FUNCUNKNOWN.get(info, name.string());\n      ann = sf.ann;\n      type = sf.funcType().seqType();\n    }\n\n    // Reject updating function items. Happens at compile because the function may not be known\n    // at parse time. This check could possibly be moved to StaticFuncs#check.\n    if(ann.contains(Ann.Q_UPDATING)) throw UPFUNCITEM.get(info);\n\n    try {\n      expr = expr.compile(ctx, scope);\n      expr.markTailCalls(null);\n    } finally {\n      scope.cleanUp(this);\n    }\n  }","id":73590,"modified_method":"@Override\n  public void compile(final QueryContext ctx) throws QueryException {\n    if(compiled) return;\n    compiled = true;\n\n    if(check) {\n      final StaticFunc sf = ctx.funcs.get(name, args.length, info, true);\n      if(sf == null) throw FUNCUNKNOWN.get(info, name.string());\n      ann = sf.ann;\n      type = sf.funcType().seqType();\n    }\n\n    // Reject updating function items. Happens at compile because the function may not be known\n    // at parse time. This check could possibly be moved to StaticFuncs#check.\n    if(ann.contains(Ann.Q_UPDATING)) throw UPFUNCITEM.get(info);\n\n    try {\n      expr = expr.compile(ctx, scope);\n      expr.markTailCalls(null);\n    } catch(final QueryException e) {\n      expr = FNInfo.error(e, type);\n    } finally {\n      scope.cleanUp(this);\n    }\n  }","commit_id":"d8627859014e37c8bc39d9a9db0a57ce48bc6baf","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public FTExpr inline(final QueryContext ctx, final VarScope scp, final Var v, final Expr e)\n      throws QueryException {\n    return inlineAll(ctx, scp, expr, v, e) || inlineAll(ctx, scp, new Expr[] { min, max }, v, e)\n        ? optimize(ctx, scp) : null;\n  }","id":73591,"modified_method":"@Override\n  public FTExpr inline(final QueryContext ctx, final VarScope scp, final Var v, final Expr e)\n      throws QueryException {\n    final Expr mn = min.inline(ctx, scp, v, e), mx = max.inline(ctx, scp, v, e);\n    if(mn != null) min = mn;\n    if(mx != null) max = mx;\n\n    return inlineAll(ctx, scp, expr, v, e) || mn != null || mx != null\n        ? optimize(ctx, scp) : null;\n  }","commit_id":"9be3add8a8a0b81a8c4d1a5ad125b4a5660dcd92","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void compile(final QueryContext ctx) throws QueryException {\n    if(compiled) return;\n    compiled = true;\n\n    if(check) {\n      final StaticFunc sf = ctx.funcs.get(name, args.length, info, true);\n      if(sf == null) throw FUNCUNKNOWN.get(info, name.string());\n      ann = sf.ann;\n      type = sf.funcType().seqType();\n    }\n\n    // Reject updating function items. Happens at compile because the function may not be known\n    // at parse time. This check could possibly be moved to StaticFuncs#check.\n    if(!sc.mixUpdates && ann.contains(Ann.Q_UPDATING)) throw UPFUNCITEM.get(info);\n\n    try {\n      expr = expr.compile(ctx, scope);\n      expr.markTailCalls(null);\n    } finally {\n      scope.cleanUp(this);\n    }\n  }","id":73592,"modified_method":"@Override\n  public void compile(final QueryContext ctx) throws QueryException {\n    if(compiled) return;\n    compiled = true;\n\n    if(check) {\n      final StaticFunc sf = ctx.funcs.get(name, args.length, info, true);\n      if(sf == null) throw FUNCUNKNOWN.get(info, name.string());\n      ann = sf.ann;\n      type = sf.funcType().seqType();\n    }\n\n    // Reject updating function items. Happens at compile because the function may not be known\n    // at parse time. This check could possibly be moved to StaticFuncs#check.\n    if(!sc.mixUpdates && ann.contains(Ann.Q_UPDATING)) throw UPFUNCITEM.get(info);\n\n    try {\n      expr = expr.compile(ctx, scope);\n      expr.markTailCalls(null);\n    } catch(final QueryException e) {\n      expr = FNInfo.error(e, type);\n    } finally {\n      scope.cleanUp(this);\n    }\n  }","commit_id":"9be3add8a8a0b81a8c4d1a5ad125b4a5660dcd92","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n     * Resolve passed user or group into users references list.\n     *\n     * @param userOrGroup the user or group\n     * @param context the XWikiContext the XWiki context\n     * @return the list of users references\n     * @throws XWikiException error when getting documents\n     */\n    public Collection<DocumentReference> resolveUsers(DocumentReference userOrGroup, XWikiContext context)\n        throws XWikiException\n    {\n        Collection<DocumentReference> userReferences = new LinkedHashSet<>();\n        Iterator<DocumentReference> iterator =\n            new UserIterator(userOrGroup, this.explicitDocumentReferenceResolver, context);\n        while (iterator.hasNext()) {\n            userReferences.add(iterator.next());\n        }\n        return userReferences;\n    }","id":73593,"modified_method":"/**\n     * Resolve passed user or group into users references list.\n     *\n     * @param userOrGroup the user or group\n     * @param context the XWikiContext the XWiki context\n     * @return the list of users references\n     * @throws XWikiException error when getting documents\n     */\n    public Collection<DocumentReference> resolveUsers(DocumentReference userOrGroup, XWikiContext context)\n        throws XWikiException\n    {\n        Collection<DocumentReference> userReferences = new LinkedHashSet<>();\n        Iterator<DocumentReference> iterator =\n            new ReferenceUserIterator(userOrGroup, this.explicitDocumentReferenceResolver, context);\n        while (iterator.hasNext()) {\n            userReferences.add(iterator.next());\n        }\n        return userReferences;\n    }","commit_id":"23a34536f7840feabb04578fc267c88ad6369e7b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private Pair<DocumentReference, Iterator<DocumentReference>> handleUserOrGroupReference(\n        DocumentReference currentReference, Iterator<DocumentReference> currentIterator, XWikiDocument document)\n    {\n        DocumentReference reference = currentReference;\n        Iterator<DocumentReference> iterator = currentIterator;\n\n        // Is the reference pointing to a user?\n        DocumentReference userClassReference = new DocumentReference(\n            document.getDocumentReference().getWikiReference().getName(),\n            RightsManager.DEFAULT_USERORGROUP_SPACE, \"XWikiUsers\");\n        boolean isUserReference = document.getXObject(userClassReference) != null;\n\n        // Is the reference pointing to a group?\n        // Note that a reference can point to a user reference and to a group reference at the same time!\n        DocumentReference groupClassReference = new DocumentReference(\n            document.getDocumentReference().getWikiReference().getName(),\n            RightsManager.DEFAULT_USERORGROUP_SPACE, \"XWikiGroups\");\n        List<BaseObject> members = document.getXObjects(groupClassReference);\n        boolean isGroupReference = members != null && !members.isEmpty();\n\n        // If we have a group reference and a user reference then stack the group members but return the user reference\n        // If we have only a group reference then stack the group members and compute the next reference\n        // If we have only a user reference then we'll just return it\n        // If we have neither a group reference nor a user reference, skip it and get the next reference\n        if (isGroupReference) {\n            // Extract the references and push them on the stack as an iterator\n            this.userAndGroupIteratorStack.push(convertToDocumentReferences(members, reference).iterator());\n            if (!isUserReference) {\n                reference = getNext();\n            }\n        } else if (!isUserReference) {\n            cleanStackIfNeeded(iterator);\n            reference = getNext();\n        }\n\n        return new ImmutablePair<>(reference, iterator);\n    }","id":73594,"modified_method":"private Pair<T, Iterator<DocumentReference>> handleUserOrGroupReference(\n        DocumentReference currentReference, Iterator<DocumentReference> currentIterator, XWikiDocument document)\n    {\n        T value;\n\n        // Is the reference pointing to a user?\n        DocumentReference userClassReference = new DocumentReference(\n            document.getDocumentReference().getWikiReference().getName(),\n            RightsManager.DEFAULT_USERORGROUP_SPACE, \"XWikiUsers\");\n        BaseObject userObject = document.getXObject(userClassReference);\n        boolean isUserReference = userObject != null;\n\n        // Is the reference pointing to a group?\n        // Note that a reference can point to a user reference and to a group reference at the same time!\n        DocumentReference groupClassReference = new DocumentReference(\n            document.getDocumentReference().getWikiReference().getName(),\n            RightsManager.DEFAULT_USERORGROUP_SPACE, \"XWikiGroups\");\n        List<BaseObject> members = document.getXObjects(groupClassReference);\n        boolean isGroupReference = members != null && !members.isEmpty();\n\n        // If we have a group reference and a user reference then stack the group members but return the user reference\n        // If we have only a group reference then stack the group members and compute the next reference\n        // If we have only a user reference then we'll just return it\n        // If we have neither a group reference nor a user reference, skip it and get the next reference\n        if (isGroupReference) {\n            // Extract the references and push them on the stack as an iterator\n            this.userAndGroupIteratorStack.push(convertToDocumentReferences(members, currentReference).iterator());\n            if (!isUserReference) {\n                value = getNext();\n            } else {\n                value = getValue(currentIterator, currentReference, document, userObject);\n            }\n        } else if (!isUserReference) {\n            cleanStackIfNeeded(currentIterator);\n            value = getNext();\n        } else {\n            value = getValue(currentIterator, currentReference, document, userObject);\n        }\n\n        return new ImmutablePair<>(value, currentIterator);\n    }","commit_id":"23a34536f7840feabb04578fc267c88ad6369e7b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param userOrGroupReference the reference (user or group) to iterate over\n     * @param explicitDocumentReferenceResolver the resolver to use for transforming group member strings into\n     *        {@link DocumentReference}\n     * @param execution the component used to access the {@link XWikiContext} we use to call oldcore APIs\n     */\n    public UserIterator(DocumentReference userOrGroupReference,\n        DocumentReferenceResolver<String> explicitDocumentReferenceResolver, Execution execution)\n    {\n        initialize(userOrGroupReference, explicitDocumentReferenceResolver);\n        this.xwikiContext = getXWikiContext(execution);\n    }","id":73595,"modified_method":"/**\n     * Recommended if this iterator is called from code using components.\n     *\n     * @param userOrGroupReference the reference (user or group) to iterate over\n     * @param userDataExtractor the extractor to use the return the value extracted from the user profile\n     * @param explicitDocumentReferenceResolver the resolver to use for transforming group member strings into\n     *        {@link DocumentReference}\n     * @param execution the component used to access the {@link XWikiContext} we use to call oldcore APIs\n     */\n    public UserIterator(DocumentReference userOrGroupReference, UserDataExtractor<T> userDataExtractor,\n        DocumentReferenceResolver<String> explicitDocumentReferenceResolver, Execution execution)\n    {\n        initialize(userOrGroupReference, userDataExtractor, explicitDocumentReferenceResolver);\n        this.xwikiContext = getXWikiContext(execution);\n    }","commit_id":"23a34536f7840feabb04578fc267c88ad6369e7b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public DocumentReference next()\n    {\n        DocumentReference currentReference = this.lookaheadReference;\n        if (currentReference != null) {\n            this.lookaheadReference = null;\n        } else {\n            currentReference = getNext();\n            if (currentReference == null) {\n                throw new NoSuchElementException(String.format(\n                    \"No more users to extract from the passed references [%s]\", serializeUserAndGroupReferences()));\n            }\n        }\n        return currentReference;\n    }","id":73596,"modified_method":"@Override\n    public T next()\n    {\n        T currentValue = this.lookaheadValue;\n        if (currentValue != null) {\n            this.lookaheadValue = null;\n        } else {\n            currentValue = getNext();\n            if (currentValue == null) {\n                throw new NoSuchElementException(String.format(\n                    \"No more users to extract from the passed references [%s]\", serializeUserAndGroupReferences()));\n            }\n        }\n        return currentValue;\n    }","commit_id":"23a34536f7840feabb04578fc267c88ad6369e7b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param userAndGroupReferences the list of references (users or groups) to iterate over\n     * @param explicitDocumentReferenceResolver the resolver to use for transforming group member strings into\n     *        {@link DocumentReference}\n     * @param execution the component used to access the {@link XWikiContext} we use to call oldcore APIs\n     */\n    public UserIterator(List<DocumentReference> userAndGroupReferences,\n        DocumentReferenceResolver<String> explicitDocumentReferenceResolver, Execution execution)\n    {\n        initialize(userAndGroupReferences, explicitDocumentReferenceResolver);\n        this.xwikiContext = getXWikiContext(execution);\n    }","id":73597,"modified_method":"/**\n     * Recommended if this iterator is called from code using components.\n     *\n     * @param userAndGroupReferences the list of references (users or groups) to iterate over\n     * @param excludedUserAndGroupReferences the list of references (users or groups) to exclude. Can be null.\n     * @param userDataExtractor the extractor to use the return the value extracted from the user profile\n     * @param explicitDocumentReferenceResolver the resolver to use for transforming group member strings into\n     *        {@link DocumentReference}\n     * @param execution the component used to access the {@link XWikiContext} we use to call oldcore APIs\n     */\n    public UserIterator(List<DocumentReference> userAndGroupReferences,\n        List<DocumentReference> excludedUserAndGroupReferences, UserDataExtractor<T> userDataExtractor,\n        DocumentReferenceResolver<String> explicitDocumentReferenceResolver, Execution execution)\n    {\n        initialize(userAndGroupReferences, excludedUserAndGroupReferences, userDataExtractor,\n            explicitDocumentReferenceResolver);\n        this.xwikiContext = getXWikiContext(execution);\n    }","commit_id":"23a34536f7840feabb04578fc267c88ad6369e7b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private DocumentReference getNext()\n    {\n        DocumentReference currentReference;\n\n        // If there are no more references in the stack then we've already returned everything!\n        if (this.userAndGroupIteratorStack.isEmpty()) {\n            return null;\n        }\n        Iterator<DocumentReference> currentIterator = this.userAndGroupIteratorStack.peek();\n\n        currentReference = currentIterator.next();\n\n        // If it's not a virtual user (guest or superadmin user), then load the document\n        if (!currentReference.getLastSpaceReference().getName().equals(RightsManager.DEFAULT_USERORGROUP_SPACE)\n            || (!currentReference.getName().equalsIgnoreCase(XWikiRightService.SUPERADMIN_USER)\n            && !currentReference.getName().equals(XWikiRightService.GUEST_USER)))\n        {\n            XWikiDocument document = getFailsafeDocument(currentReference);\n            if (!document.isNew()) {\n                Pair<DocumentReference, Iterator<DocumentReference>> result = handleUserOrGroupReference(\n                    currentReference, currentIterator, document);\n                currentReference = result.getLeft();\n                currentIterator = result.getRight();\n            } else {\n                // The document doesn't exist and thus it cannot point to a real user or group, skip it!\n                cleanStackIfNeeded(currentIterator);\n                currentReference = getNext();\n            }\n        }\n\n        cleanStackIfNeeded(currentIterator);\n\n        return currentReference;\n    }","id":73598,"modified_method":"private T getNext()\n    {\n        T currentValue;\n        DocumentReference currentReference;\n\n        // If there are no more references in the stack then we've already returned everything!\n        if (this.userAndGroupIteratorStack.isEmpty()) {\n            return null;\n        }\n\n        Iterator<DocumentReference> currentIterator = this.userAndGroupIteratorStack.peek();\n\n        currentReference = currentIterator.next();\n\n        // If the reference is in the excluded list, skip it!\n        if (this.excludedUserAndGroupReferences.contains(currentReference)) {\n            cleanStackIfNeeded(currentIterator);\n            return getNext();\n        }\n\n        // If it's not a virtual user (guest or superadmin user), then load the document\n        if (isSuperAdmin(currentReference)) {\n            currentValue = this.userDataExtractor.extractFromSuperadmin(currentReference);\n        } else if (isGuest(currentReference)) {\n            currentValue = this.userDataExtractor.extractFromGuest(currentReference);\n        } else {\n            XWikiDocument document = getFailsafeDocument(currentReference);\n            if (!document.isNew()) {\n                Pair<T, Iterator<DocumentReference>> result = handleUserOrGroupReference(\n                    currentReference, currentIterator, document);\n                currentValue = result.getLeft();\n                currentIterator = result.getRight();\n            } else {\n                // The document doesn't exist and thus it cannot point to a real user or group, skip it!\n                cleanStackIfNeeded(currentIterator);\n                currentValue = getNext();\n            }\n        }\n\n        cleanStackIfNeeded(currentIterator);\n\n        return currentValue;\n    }","commit_id":"23a34536f7840feabb04578fc267c88ad6369e7b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private String serializeUserAndGroupReferences()\n    {\n        StringBuffer buffer = new StringBuffer();\n        Iterator<DocumentReference> iterator = this.userAndGroupReferences.iterator();\n        while (iterator.hasNext()) {\n            DocumentReference reference = iterator.next();\n            buffer.append('[').append(reference).append(']');\n            if (iterator.hasNext()) {\n                buffer.append(',').append(' ');\n            }\n        }\n        return buffer.toString();\n    }","id":73599,"modified_method":"private String serializeUserAndGroupReferences()\n    {\n        StringBuilder buffer = new StringBuilder();\n        Iterator<DocumentReference> iterator = this.userAndGroupReferences.iterator();\n        while (iterator.hasNext()) {\n            DocumentReference reference = iterator.next();\n            buffer.append('[').append(reference).append(']');\n            if (iterator.hasNext()) {\n                buffer.append(',').append(' ');\n            }\n        }\n        return buffer.toString();\n    }","commit_id":"23a34536f7840feabb04578fc267c88ad6369e7b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void initialize(List<DocumentReference> userAndGroupReferences,\n        DocumentReferenceResolver<String> explicitDocumentReferenceResolver)\n    {\n        this.userAndGroupReferences = userAndGroupReferences;\n        this.explicitDocumentReferenceResolver = explicitDocumentReferenceResolver;\n        if (userAndGroupReferences != null && !userAndGroupReferences.isEmpty()) {\n            this.userAndGroupIteratorStack.push(userAndGroupReferences.iterator());\n        }\n    }","id":73600,"modified_method":"private void initialize(List<DocumentReference> userAndGroupReferences,\n        List<DocumentReference> excludedUserAndGroupReferences, UserDataExtractor<T> userDataExtractor,\n        DocumentReferenceResolver<String> explicitDocumentReferenceResolver)\n    {\n        this.userAndGroupReferences = userAndGroupReferences;\n        this.excludedUserAndGroupReferences = excludedUserAndGroupReferences;\n        if (excludedUserAndGroupReferences == null) {\n            this.excludedUserAndGroupReferences = Collections.emptyList();\n        }\n        this.explicitDocumentReferenceResolver = explicitDocumentReferenceResolver;\n        this.userDataExtractor = userDataExtractor;\n        if (userAndGroupReferences != null && !userAndGroupReferences.isEmpty()) {\n            this.userAndGroupIteratorStack.push(userAndGroupReferences.iterator());\n        }\n    }","commit_id":"23a34536f7840feabb04578fc267c88ad6369e7b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private XWikiDocument getFailsafeDocument(DocumentReference reference)\n    {\n        try {\n            return this.xwikiContext.getWiki().getDocument(reference, this.xwikiContext);\n        } catch (XWikiException e) {\n            throw new RuntimeException(String.format(\"Failed to get document for User or Group [%s] when extracting \"\n                + \"all users for the references [%s]\", reference, serializeUserAndGroupReferences()));\n        }\n    }","id":73601,"modified_method":"private XWikiDocument getFailsafeDocument(DocumentReference reference)\n    {\n        try {\n            return getXwikiContext().getWiki().getDocument(reference, getXwikiContext());\n        } catch (XWikiException e) {\n            throw new RuntimeException(String.format(\"Failed to get document for User or Group [%s] when extracting \"\n                + \"all users for the references [%s]\", reference, serializeUserAndGroupReferences()));\n        }\n    }","commit_id":"23a34536f7840feabb04578fc267c88ad6369e7b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public boolean hasNext()\n    {\n        boolean hasNext = false;\n        if (!this.userAndGroupIteratorStack.isEmpty()) {\n            if (this.lookaheadReference == null) {\n                DocumentReference currentReference = getNext();\n                if (currentReference != null) {\n                    this.lookaheadReference = currentReference;\n                    hasNext = true;\n                }\n            }\n        }\n        return hasNext;\n    }","id":73602,"modified_method":"@Override\n    public boolean hasNext()\n    {\n        boolean hasNext = false;\n        if (!this.userAndGroupIteratorStack.isEmpty()) {\n            if (this.lookaheadValue == null) {\n                T currentValue = getNext();\n                if (currentValue != null) {\n                    this.lookaheadValue = currentValue;\n                    hasNext = true;\n                }\n            }\n        }\n        return hasNext;\n    }","commit_id":"23a34536f7840feabb04578fc267c88ad6369e7b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param userOrGroupReference the reference (user or group) to iterate over\n     * @param explicitDocumentReferenceResolver the resolver to use for transforming group member strings into\n     *        {@link DocumentReference}\n     * @param xwikiContext the {@link XWikiContext} we use to call oldcore APIs\n     */\n    public UserIterator(DocumentReference userOrGroupReference,\n        DocumentReferenceResolver<String> explicitDocumentReferenceResolver, XWikiContext xwikiContext)\n    {\n        initialize(userOrGroupReference, explicitDocumentReferenceResolver);\n        this.xwikiContext = xwikiContext;\n    }","id":73603,"modified_method":"/**\n     * Recommended if this iterator is called from old code not using components.\n     *\n     * @param userOrGroupReference the reference (user or group) to iterate over\n     * @param userDataExtractor the extractor to use the return the value extracted from the user profile\n     * @param explicitDocumentReferenceResolver the resolver to use for transforming group member strings into\n     *        {@link DocumentReference}\n     * @param xwikiContext the {@link XWikiContext} we use to call oldcore APIs\n     */\n    public UserIterator(DocumentReference userOrGroupReference, UserDataExtractor<T> userDataExtractor,\n        DocumentReferenceResolver<String> explicitDocumentReferenceResolver, XWikiContext xwikiContext)\n    {\n        initialize(userOrGroupReference, userDataExtractor, explicitDocumentReferenceResolver);\n        this.xwikiContext = xwikiContext;\n    }","commit_id":"23a34536f7840feabb04578fc267c88ad6369e7b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param userAndGroupReferences the list of references (users or groups) to iterate over\n     * @param explicitDocumentReferenceResolver the resolver to use for transforming group member strings into\n     *        {@link DocumentReference}\n     * @param xwikiContext the {@link XWikiContext} we use to call oldcore APIs\n     */\n    public UserIterator(List<DocumentReference> userAndGroupReferences,\n        DocumentReferenceResolver<String> explicitDocumentReferenceResolver, XWikiContext xwikiContext)\n    {\n        initialize(userAndGroupReferences, explicitDocumentReferenceResolver);\n        this.xwikiContext = xwikiContext;\n    }","id":73604,"modified_method":"/**\n     * Recommended if this iterator is called from old code not using components.\n     *\n     * @param userAndGroupReferences the list of references (users or groups) to iterate over\n     * @param excludedUserAndGroupReferences the list of references (users or groups) to exclude. Can be null.\n     * @param userDataExtractor the extractor to use the return the value extracted from the user profile\n     * @param explicitDocumentReferenceResolver the resolver to use for transforming group member strings into\n     *        {@link DocumentReference}\n     * @param xwikiContext the {@link XWikiContext} we use to call oldcore APIs\n     */\n    public UserIterator(List<DocumentReference> userAndGroupReferences,\n        List<DocumentReference> excludedUserAndGroupReferences, UserDataExtractor<T> userDataExtractor,\n        DocumentReferenceResolver<String> explicitDocumentReferenceResolver, XWikiContext xwikiContext)\n    {\n        initialize(userAndGroupReferences, excludedUserAndGroupReferences, userDataExtractor,\n            explicitDocumentReferenceResolver);\n        this.xwikiContext = xwikiContext;\n    }","commit_id":"23a34536f7840feabb04578fc267c88ad6369e7b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void initialize(DocumentReference userOrGroupReference,\n        DocumentReferenceResolver<String> explicitDocumentReferenceResolver)\n    {\n        List<DocumentReference> references = userOrGroupReference == null\n            ? Collections.<DocumentReference>emptyList() : Collections.singletonList(userOrGroupReference);\n        initialize(references, explicitDocumentReferenceResolver);\n    }","id":73605,"modified_method":"private void initialize(DocumentReference userOrGroupReference, UserDataExtractor<T> userDataExtractor,\n        DocumentReferenceResolver<String> explicitDocumentReferenceResolver)\n    {\n        List<DocumentReference> references = userOrGroupReference == null\n            ? Collections.<DocumentReference>emptyList() : Collections.singletonList(userOrGroupReference);\n        initialize(references, null, userDataExtractor, explicitDocumentReferenceResolver);\n    }","commit_id":"23a34536f7840feabb04578fc267c88ad6369e7b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param document the translation document\n     */\n    private void unregisterTranslationBundle(XWikiDocument document)\n    {\n        Scope scope = getScope(document.getXObject(TranslationDocumentModel.TRANSLATIONCLASS_REFERENCE));\n\n        // Unregister component\n        if (scope != null && scope != Scope.ON_DEMAND) {\n            ComponentDescriptor<TranslationBundle> descriptor =\n                createComponentDescriptor(document.getDocumentReference());\n\n            getComponentManager(document, scope, true).unregisterComponent(descriptor);\n        }\n\n        // Remove from cache\n        this.bundlesCache.remove(this.uidSerializer.serialize(document.getDocumentReference()));\n    }","id":73606,"modified_method":"/**\n     * @param document the translation document\n     */\n    private void unregisterTranslationBundle(XWikiDocument document)\n    {\n        BaseObject obj = document.getXObject(TranslationDocumentModel.TRANSLATIONCLASS_REFERENCE);\n\n        if (obj != null) {\n            Scope scope = getScope(obj);\n\n            // Unregister component\n            if (scope != null && scope != Scope.ON_DEMAND) {\n                ComponentDescriptor<TranslationBundle> descriptor =\n                    createComponentDescriptor(document.getDocumentReference());\n\n                getComponentManager(document, scope, true).unregisterComponent(descriptor);\n            }\n\n            // Remove from cache\n            this.bundlesCache.remove(this.uidSerializer.serialize(document.getDocumentReference()));\n        }\n    }","commit_id":"6d1996091cff35b17e8591dab894a28d1f92f5e3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param document the translation document\n     */\n    private void translationObjectUpdated(XWikiDocument document)\n    {\n        unregisterTranslationBundle(document.getOriginalDocument());\n        try {\n            registerTranslationBundle(document);\n        } catch (Exception e) {\n            this.logger.error(\"Failed to register translation bundle from document [{}]\",\n                document.getDocumentReference(), e);\n        }\n    }","id":73607,"modified_method":"/**\n     * @param document the translation document\n     */\n    private void translationDocumentUpdated(XWikiDocument document)\n    {\n        if (!document.getOriginalDocument().isNew()) {\n            unregisterTranslationBundle(document.getOriginalDocument());\n        }\n\n        if (!document.isNew()) {\n            try {\n                registerTranslationBundle(document);\n            } catch (Exception e) {\n                this.logger.error(\"Failed to register translation bundle from document [{}]\",\n                    document.getDocumentReference(), e);\n            }\n        }\n    }","commit_id":"6d1996091cff35b17e8591dab894a28d1f92f5e3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param document the translation document\n     * @throws TranslationBundleDoesNotExistsException when no translation bundle could be created from the provided\n     *             document\n     * @throws ComponentRepositoryException when the actual registration of the document bundle failed\n     * @throws AccessDeniedException when the document author does not have enough right to register the translation\n     *             bundle\n     */\n    private void registerTranslationBundle(XWikiDocument document) throws TranslationBundleDoesNotExistsException,\n        ComponentRepositoryException, AccessDeniedException\n    {\n        Scope scope = getScope(document.getXObject(TranslationDocumentModel.TRANSLATIONCLASS_REFERENCE));\n\n        if (scope != null && scope != Scope.ON_DEMAND) {\n            checkRegistrationAuthorization(document, scope);\n\n            DefaultDocumentTranslationBundle bundle = createDocumentBundle(document);\n\n            ComponentDescriptor<TranslationBundle> descriptor =\n                createComponentDescriptor(document.getDocumentReference());\n\n            getComponentManager(document, scope, true).registerComponent(descriptor, bundle);\n\n            this.bundleContext.addBundle(bundle);\n        }\n    }","id":73608,"modified_method":"/**\n     * @param document the translation document\n     * @throws TranslationBundleDoesNotExistsException when no translation bundle could be created from the provided\n     *             document\n     * @throws ComponentRepositoryException when the actual registration of the document bundle failed\n     * @throws AccessDeniedException when the document author does not have enough right to register the translation\n     *             bundle\n     */\n    private void registerTranslationBundle(XWikiDocument document) throws TranslationBundleDoesNotExistsException,\n        ComponentRepositoryException, AccessDeniedException\n    {\n        BaseObject obj = document.getXObject(TranslationDocumentModel.TRANSLATIONCLASS_REFERENCE);\n\n        if (obj != null) {\n            Scope scope = getScope(obj);\n\n            if (scope != null && scope != Scope.ON_DEMAND) {\n                checkRegistrationAuthorization(document, scope);\n\n                DefaultDocumentTranslationBundle bundle = createDocumentBundle(document);\n\n                ComponentDescriptor<TranslationBundle> descriptor =\n                    createComponentDescriptor(document.getDocumentReference());\n\n                getComponentManager(document, scope, true).registerComponent(descriptor, bundle);\n\n                this.bundleContext.addBundle(bundle);\n            }\n        }\n    }","commit_id":"6d1996091cff35b17e8591dab894a28d1f92f5e3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int store(byte[] content) throws BrokenStorageException {\n    try {\n      ByteArrayOutputStream output = new ByteArrayOutputStream();\n\n      OutputStream s = createDeflaterOutputStream(output);\n      s.write(content);\n      s.close();\n      myDeflater.reset();\n\n      return mySubject.store(output.toByteArray());\n    }\n    catch (IOException e) {\n      throw new BrokenStorageException(e);\n    }\n  }","id":73609,"modified_method":"public int store(byte[] content) throws BrokenStorageException {\n    try {\n      ByteArrayOutputStream output = new ByteArrayOutputStream();\n\n      myDeflater.reset();\n      OutputStream s = createDeflaterOutputStream(output);\n      try {\n        s.write(content);\n      }\n      finally {\n        s.close();\n        myDeflater.reset();\n      }\n\n      return mySubject.store(output.toByteArray());\n    }\n    catch (IOException e) {\n      throw new BrokenStorageException(e);\n    }\n  }","commit_id":"78d5b5a674c58ca05626fd5732f75fd1ab0682e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public byte[] load(int id) throws BrokenStorageException {\n    try {\n      ByteArrayOutputStream output = new ByteArrayOutputStream();\n\n      byte[] content = mySubject.load(id);\n      InputStream s = createInflaterOutputStream(content);\n      try {\n        FileUtil.copy(s, output);\n      }\n      catch (IOException e) {\n        // todo hook for IDEADEV-25408.\n        String m = \"Failed to copy content. id = \" + id + \" length=\" + content.length;\n        IOException newEx = new IOException(m);\n        newEx.initCause(e);\n        throw newEx;\n      }\n      s.close();\n      myInflater.reset();\n\n      return output.toByteArray();\n    }\n    catch (IOException e) {\n      throw new BrokenStorageException(e);\n    }\n  }","id":73610,"modified_method":"public byte[] load(int id) throws BrokenStorageException {\n    try {\n      ByteArrayOutputStream output = new ByteArrayOutputStream();\n\n      byte[] content = mySubject.load(id);\n\n      myInflater.reset();\n      InputStream s = createInflaterOutputStream(content);\n      try {\n        FileUtil.copy(s, output);\n      }\n      catch (IOException e) {\n        // todo hook for IDEADEV-25408.\n        String m = \"Failed to copy content. id = \" + id + \" length=\" + content.length;\n        IOException newEx = new IOException(m);\n        newEx.initCause(e);\n        throw newEx;\n      } finally {\n        s.close();\n        myInflater.reset();\n      }\n\n      return output.toByteArray();\n    }\n    catch (IOException e) {\n      throw new BrokenStorageException(e);\n    }\n  }","commit_id":"78d5b5a674c58ca05626fd5732f75fd1ab0682e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean hasUnavailableContent(VirtualFile f) {\n    if (!isInitialized) return false;\n    if (!isUnderControl(f)) return false;\n\n    // TODO IDEADEV-21269 bug hook\n    if (!f.isValid()) {\n      LocalHistoryLog.LOG.warn(\"File is invalid: \" + f);\n      return false;\n    }\n\n    return myVcs.getEntry(f.getPath()).hasUnavailableContent();\n  }","id":73611,"modified_method":"@Override\n  protected boolean hasUnavailableContent(VirtualFile f) {\n    if (!isInitialized) return false;\n    if (!isUnderControl(f)) return false;\n\n    // TODO IDEADEV-21269 bug hook\n    if (!f.isValid()) {\n      LocalHistoryLog.LOG.warn(\"File is invalid: \" + f);\n      return false;\n    }\n\n    Entry entry = myVcs.findEntry(f.getPath());\n    // TODO hook for IDEADEV-26645\n    if (entry == null) {\n      LocalHistoryLog.LOG.warn(\"Entry does not exist for \" + f);\n      return false;\n    }\n    return entry.hasUnavailableContent();\n  }","commit_id":"78d5b5a674c58ca05626fd5732f75fd1ab0682e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visit(DeleteChange c) {\n      if (skippedDueToNonexistence(c)) {\n        if (c.isDeletionOf(myIdPath)) myExists = true;\n        myDoNotAddAnythingElseFromCurrentChangeSet = true;\n        if (myExists) myEntry = myRoot.getEntry(myIdPath);\n        return;\n      }\n\n      addIfAffectsAndRevert(c);\n      myIdPath = myEntry.getIdPath();\n    }","id":73612,"modified_method":"@Override\n    public void visit(DeleteChange c) {\n      if (skippedDueToNonexistence(c)) {\n        if (c.isDeletionOf(myIdPath)) {\n          Entry e = myRoot.findEntry(myIdPath);\n          if (e != null) {\n            myEntry = e;\n            myExists = true;\n            myDoNotAddAnythingElseFromCurrentChangeSet = true;\n          }\n        }\n        return;\n      }\n\n      addIfAffectsAndRevert(c);\n      myIdPath = myEntry.getIdPath();\n    }","commit_id":"ca62467312e008ceb95b118a1d98dfc8cadf3056","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ProvidedContent getProvidedContentFor(VirtualFile f) {\n    if (!getFileFilter().isAllowedAndUnderContentRoot(f)) return null;\n\n    Content c = myVcs.getEntry(f.getPath()).getContent();\n    return c.isAvailable() ? new EntryProvidedContent(c) : null;\n  }","id":73613,"modified_method":"private ProvidedContent getProvidedContentFor(VirtualFile f) {\n    if (!getFileFilter().isAllowedAndUnderContentRoot(f)) return null;\n\n    Entry e = myVcs.findEntry(f.getPath());\n    if (e == null) return null;\n\n    Content c = e.getContent();\n    return c.isAvailable() ? new EntryProvidedContent(c) : null;\n  }","commit_id":"00550b4ee87bf53712c55b1f961341408bd2bfd3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Removes the user's stored activities from the database.\n\t *\n\t * <p>\n\t * This method removes all activities where the user is either the actor or\n\t * the receiver.\n\t * <\/p>\n\t *\n\t * @param  userId the primary key of the user\n\t * @throws PortalException if the user's activity counters could not be\n\t *         deleted\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic void deleteUserActivities(long userId)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<SocialActivity> activities =\n\t\t\tsocialActivityPersistence.findByUserId(\n\t\t\t\tuserId, QueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (SocialActivity activity : activities) {\n\t\t\tsocialActivitySetLocalService.decrementActivityCount(\n\t\t\t\tactivity.getActivitySetId());\n\n\t\t\tsocialActivityPersistence.remove(activity);\n\t\t}\n\n\t\tactivities = socialActivityPersistence.findByReceiverUserId(\n\t\t\tuserId, QueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (SocialActivity activity : activities) {\n\t\t\tsocialActivitySetLocalService.decrementActivityCount(\n\t\t\t\tactivity.getActivitySetId());\n\n\t\t\tsocialActivityPersistence.remove(activity);\n\t\t}\n\n\t\tsocialActivityCounterLocalService.deleteActivityCounters(\n\t\t\tUser.class.getName(), userId);\n\t}","id":73614,"modified_method":"/**\n\t * Removes the user's stored activities from the database.\n\t *\n\t * <p>\n\t * This method removes all activities where the user is either the actor or\n\t * the receiver.\n\t * <\/p>\n\t *\n\t * @param  userId the primary key of the user\n\t * @throws PortalException if the user's activity counters could not be\n\t *         deleted\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic void deleteUserActivities(long userId)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<SocialActivity> activities =\n\t\t\tsocialActivityPersistence.findByUserId(\n\t\t\t\tuserId, QueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (SocialActivity activity : activities) {\n\t\t\tif (PropsValues.SOCIAL_ACTIVITY_SETS_ENABLED) {\n\t\t\t\tsocialActivitySetLocalService.decrementActivityCount(\n\t\t\t\t\tactivity.getActivitySetId());\n\t\t\t}\n\n\t\t\tsocialActivityPersistence.remove(activity);\n\t\t}\n\n\t\tactivities = socialActivityPersistence.findByReceiverUserId(\n\t\t\tuserId, QueryUtil.ALL_POS, QueryUtil.ALL_POS);\n\n\t\tfor (SocialActivity activity : activities) {\n\t\t\tif (PropsValues.SOCIAL_ACTIVITY_SETS_ENABLED) {\n\t\t\t\tsocialActivitySetLocalService.decrementActivityCount(\n\t\t\t\t\tactivity.getActivitySetId());\n\t\t\t}\n\n\t\t\tsocialActivityPersistence.remove(activity);\n\t\t}\n\n\t\tsocialActivityCounterLocalService.deleteActivityCounters(\n\t\t\tUser.class.getName(), userId);\n\t}","commit_id":"24f62ecfbfec7458b33c60b78ccb0f653a33e7f1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Removes stored activities for the asset identified by the class name and\n\t * class primary key.\n\t *\n\t * @param  className the target asset's class name\n\t * @param  classPK the primary key of the target asset\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic void deleteActivities(String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\n\t\tsocialActivitySetLocalService.decrementActivityCount(\n\t\t\tclassNameId, classPK);\n\n\t\tsocialActivityPersistence.removeByC_C(classNameId, classPK);\n\t}","id":73615,"modified_method":"/**\n\t * Removes stored activities for the asset identified by the class name and\n\t * class primary key.\n\t *\n\t * @param  className the target asset's class name\n\t * @param  classPK the primary key of the target asset\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic void deleteActivities(String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\n\t\tif (PropsValues.SOCIAL_ACTIVITY_SETS_ENABLED) {\n\t\t\tsocialActivitySetLocalService.decrementActivityCount(\n\t\t\t\tclassNameId, classPK);\n\t\t}\n\n\t\tsocialActivityPersistence.removeByC_C(classNameId, classPK);\n\t}","commit_id":"24f62ecfbfec7458b33c60b78ccb0f653a33e7f1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Removes stored activities for the asset.\n\t *\n\t * @param  assetEntry the asset from which to remove stored activities\n\t * @throws PortalException if a portal exception occurred\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic void deleteActivities(AssetEntry assetEntry)\n\t\tthrows PortalException, SystemException {\n\n\t\tsocialActivitySetLocalService.decrementActivityCount(\n\t\t\tassetEntry.getClassNameId(), assetEntry.getClassPK());\n\n\t\tsocialActivityPersistence.removeByC_C(\n\t\t\tassetEntry.getClassNameId(), assetEntry.getClassPK());\n\n\t\tsocialActivityCounterLocalService.deleteActivityCounters(assetEntry);\n\t}","id":73616,"modified_method":"/**\n\t * Removes stored activities for the asset.\n\t *\n\t * @param  assetEntry the asset from which to remove stored activities\n\t * @throws PortalException if a portal exception occurred\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic void deleteActivities(AssetEntry assetEntry)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (PropsValues.SOCIAL_ACTIVITY_SETS_ENABLED) {\n\t\t\tsocialActivitySetLocalService.decrementActivityCount(\n\t\t\t\tassetEntry.getClassNameId(), assetEntry.getClassPK());\n\t\t}\n\n\t\tsocialActivityPersistence.removeByC_C(\n\t\t\tassetEntry.getClassNameId(), assetEntry.getClassPK());\n\n\t\tsocialActivityCounterLocalService.deleteActivityCounters(assetEntry);\n\t}","commit_id":"24f62ecfbfec7458b33c60b78ccb0f653a33e7f1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Async\n\tpublic void addActivity(\n\t\t\tSocialActivity activity, SocialActivity mirrorActivity)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (ExportImportThreadLocal.isImportInProcess()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ((activity.getActivityId() > 0) ||\n\t\t\t((mirrorActivity != null) &&\n\t\t\t (mirrorActivity.getActivityId() > 0))) {\n\n\t\t\tthrow new PortalException(\n\t\t\t\t\"Activity and mirror activity must not have primary keys set\");\n\t\t}\n\n\t\tSocialActivityDefinition activityDefinition =\n\t\t\tsocialActivitySettingLocalService.getActivityDefinition(\n\t\t\t\tactivity.getGroupId(), activity.getClassName(),\n\t\t\t\tactivity.getType());\n\n\t\tif (((activityDefinition == null) && (activity.getType() < 10000)) ||\n\t\t\t((activityDefinition != null) &&\n\t\t\t\tactivityDefinition.isLogActivity())) {\n\n\t\t\tlong activityId = counterLocalService.increment(\n\t\t\t\tSocialActivity.class.getName());\n\n\t\t\tactivity.setActivityId(activityId);\n\n\t\t\tsocialActivityPersistence.update(activity);\n\n\t\t\tlong activitySetId =\n\t\t\t\tsocialActivityInterpreterLocalService.getActivitySetId(\n\t\t\t\t\tactivity.getActivityId());\n\n\t\t\tsocialActivitySetLocalService.incrementActivityCount(\n\t\t\t\tactivitySetId, activityId);\n\n\t\t\tif (mirrorActivity != null) {\n\t\t\t\tlong mirrorActivityId = counterLocalService.increment(\n\t\t\t\t\tSocialActivity.class.getName());\n\n\t\t\t\tmirrorActivity.setActivityId(mirrorActivityId);\n\t\t\t\tmirrorActivity.setMirrorActivityId(activity.getPrimaryKey());\n\n\t\t\t\tsocialActivityPersistence.update(mirrorActivity);\n\t\t\t}\n\t\t}\n\n\t\tsocialActivityCounterLocalService.addActivityCounters(activity);\n\t}","id":73617,"modified_method":"@Async\n\tpublic void addActivity(\n\t\t\tSocialActivity activity, SocialActivity mirrorActivity)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (ExportImportThreadLocal.isImportInProcess()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ((activity.getActivityId() > 0) ||\n\t\t\t((mirrorActivity != null) &&\n\t\t\t (mirrorActivity.getActivityId() > 0))) {\n\n\t\t\tthrow new PortalException(\n\t\t\t\t\"Activity and mirror activity must not have primary keys set\");\n\t\t}\n\n\t\tSocialActivityDefinition activityDefinition =\n\t\t\tsocialActivitySettingLocalService.getActivityDefinition(\n\t\t\t\tactivity.getGroupId(), activity.getClassName(),\n\t\t\t\tactivity.getType());\n\n\t\tif (((activityDefinition == null) && (activity.getType() < 10000)) ||\n\t\t\t((activityDefinition != null) &&\n\t\t\t\tactivityDefinition.isLogActivity())) {\n\n\t\t\tlong activityId = counterLocalService.increment(\n\t\t\t\tSocialActivity.class.getName());\n\n\t\t\tactivity.setActivityId(activityId);\n\n\t\t\tsocialActivityPersistence.update(activity);\n\n\t\t\tif (PropsValues.SOCIAL_ACTIVITY_SETS_ENABLED) {\n\t\t\t\tlong activitySetId =\n\t\t\t\t\tsocialActivityInterpreterLocalService.getActivitySetId(\n\t\t\t\t\t\tactivity.getActivityId());\n\n\t\t\t\tsocialActivitySetLocalService.incrementActivityCount(\n\t\t\t\t\tactivitySetId, activityId);\n\t\t\t}\n\n\t\t\tif (mirrorActivity != null) {\n\t\t\t\tlong mirrorActivityId = counterLocalService.increment(\n\t\t\t\t\tSocialActivity.class.getName());\n\n\t\t\t\tmirrorActivity.setActivityId(mirrorActivityId);\n\t\t\t\tmirrorActivity.setMirrorActivityId(activity.getPrimaryKey());\n\n\t\t\t\tsocialActivityPersistence.update(mirrorActivity);\n\t\t\t}\n\t\t}\n\n\t\tsocialActivityCounterLocalService.addActivityCounters(activity);\n\t}","commit_id":"24f62ecfbfec7458b33c60b78ccb0f653a33e7f1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Removes the stored activity and its mirror activity from the database.\n\t *\n\t * @param  activity the activity to be removed\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic void deleteActivity(SocialActivity activity)\n\t\tthrows PortalException, SystemException {\n\n\t\tsocialActivityPersistence.remove(activity);\n\n\t\ttry {\n\t\t\tsocialActivitySetLocalService.decrementActivityCount(\n\t\t\t\tactivity.getActivitySetId());\n\n\t\t\tsocialActivityPersistence.removeByMirrorActivityId(\n\t\t\t\tactivity.getActivityId());\n\t\t}\n\t\tcatch (NoSuchActivityException nsae) {\n\t\t}\n\t}","id":73618,"modified_method":"/**\n\t * Removes the stored activity and its mirror activity from the database.\n\t *\n\t * @param  activity the activity to be removed\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic void deleteActivity(SocialActivity activity)\n\t\tthrows PortalException, SystemException {\n\n\t\tsocialActivityPersistence.remove(activity);\n\n\t\ttry {\n\t\t\tif (PropsValues.SOCIAL_ACTIVITY_SETS_ENABLED) {\n\t\t\t\tsocialActivitySetLocalService.decrementActivityCount(\n\t\t\t\t\tactivity.getActivitySetId());\n\t\t\t}\n\n\t\t\tsocialActivityPersistence.removeByMirrorActivityId(\n\t\t\t\tactivity.getActivityId());\n\t\t}\n\t\tcatch (NoSuchActivityException nsae) {\n\t\t}\n\t}","commit_id":"24f62ecfbfec7458b33c60b78ccb0f653a33e7f1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Map<String, IndexStats> getAllDeflectorIndices(Indexer indexer) {\n        Map<String, IndexStats> result = Maps.newHashMap();\n        for(Map.Entry<String, IndexStats> e : indexer.indices().getAll().entrySet()) {\n            String name = e.getKey();\n            \n            if (ourIndex(name)) {\n                result.put(name, e.getValue());\n            }\n        }\n        \n        return result;\n    }","id":73619,"modified_method":"public Map<String, IndexStats> getAllDeflectorIndices(Indexer indexer) {\n        Map<String, IndexStats> result = Maps.newHashMap();\n        Indices indices = indexer.indices();\n        if (indices != null) {\n            for (Map.Entry<String, IndexStats> e : indices.getAll().entrySet()) {\n                String name = e.getKey();\n\n                if (ourIndex(name)) {\n                    result.put(name, e.getValue());\n                }\n            }\n        }\n        return result;\n    }","commit_id":"de0be934b2a7c8aac724eb9e5da7ee9126921b45","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private boolean ourIndex(String indexName) {\n        return indexName != getName() && indexName.startsWith(configuration.getElasticSearchIndexPrefix() + \"_\");\n    }","id":73620,"modified_method":"private boolean ourIndex(String indexName) {\n        return !indexName.equals(getName()) && indexName.startsWith(configuration.getElasticSearchIndexPrefix() + \"_\");\n    }","commit_id":"de0be934b2a7c8aac724eb9e5da7ee9126921b45","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public String[] getAllDeflectorIndexNames(Indexer indexer) {\n        List<String> indices = Lists.newArrayList();\n        \n        for(Map.Entry<String, IndexStats> e : indexer.indices().getAll().entrySet()) {\n            String name = e.getKey();\n            \n            if (ourIndex(name)) {\n                indices.add(name);\n            }\n        }\n        \n        return indices.toArray(new String[0]);\n    }","id":73621,"modified_method":"public String[] getAllDeflectorIndexNames(Indexer indexer) {\n        List<String> result = Lists.newArrayList();\n\n        final Indices indices = indexer.indices();\n        if (indices != null) {\n            for (Map.Entry<String, IndexStats> e : indices.getAll().entrySet()) {\n                String name = e.getKey();\n\n                if (ourIndex(name)) {\n                    result.add(name);\n                }\n            }\n        }\n\n        return result.toArray(new String[result.size()]);\n    }","commit_id":"de0be934b2a7c8aac724eb9e5da7ee9126921b45","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"MetaData(long version, Settings transientSettings, Settings persistentSettings, ImmutableMap<String, IndexMetaData> indices, ImmutableMap<String, IndexTemplateMetaData> templates, ImmutableMap<String, Custom> customs) {\n        this.version = version;\n        this.transientSettings = transientSettings;\n        this.persistentSettings = persistentSettings;\n        this.settings = ImmutableSettings.settingsBuilder().put(persistentSettings).put(transientSettings).build();\n        this.indices = ImmutableMap.copyOf(indices);\n        this.customs = customs;\n        this.templates = templates;\n        int totalNumberOfShards = 0;\n        for (IndexMetaData indexMetaData : indices.values()) {\n            totalNumberOfShards += indexMetaData.totalNumberOfShards();\n        }\n        this.totalNumberOfShards = totalNumberOfShards;\n\n        // build all indices map\n        List<String> allIndicesLst = Lists.newArrayList();\n        for (IndexMetaData indexMetaData : indices.values()) {\n            allIndicesLst.add(indexMetaData.index());\n        }\n        allIndices = allIndicesLst.toArray(new String[allIndicesLst.size()]);\n\n        List<String> allOpenIndices = Lists.newArrayList();\n        for (IndexMetaData indexMetaData : indices.values()) {\n            if (indexMetaData.state() == IndexMetaData.State.OPEN) {\n                allOpenIndices.add(indexMetaData.index());\n            }\n        }\n        this.allOpenIndices = allOpenIndices.toArray(new String[allOpenIndices.size()]);\n\n        // build aliases map\n        MapBuilder<String, MapBuilder<String, AliasMetaData>> tmpAliasesMap = newMapBuilder();\n        for (IndexMetaData indexMetaData : indices.values()) {\n            String index = indexMetaData.index();\n            for (AliasMetaData aliasMd : indexMetaData.aliases().values()) {\n                MapBuilder<String, AliasMetaData> indexAliasMap = tmpAliasesMap.get(aliasMd.alias());\n                if (indexAliasMap == null) {\n                    indexAliasMap = newMapBuilder();\n                    tmpAliasesMap.put(aliasMd.alias(), indexAliasMap);\n                }\n                indexAliasMap.put(index, aliasMd);\n            }\n        }\n        MapBuilder<String, ImmutableMap<String, AliasMetaData>> aliases = newMapBuilder();\n        for (Map.Entry<String, MapBuilder<String, AliasMetaData>> alias : tmpAliasesMap.map().entrySet()) {\n            aliases.put(alias.getKey(), alias.getValue().immutableMap());\n        }\n        this.aliases = aliases.immutableMap();\n\n        // build routing aliases set\n        MapBuilder<String, MapBuilder<String, ImmutableSet<String>>> tmpAliasToIndexToSearchRoutingMap = newMapBuilder();\n        for (IndexMetaData indexMetaData : indices.values()) {\n            for (AliasMetaData aliasMd : indexMetaData.aliases().values()) {\n                MapBuilder<String, ImmutableSet<String>> indexToSearchRoutingMap = tmpAliasToIndexToSearchRoutingMap.get(aliasMd.alias());\n                if (indexToSearchRoutingMap == null) {\n                    indexToSearchRoutingMap = newMapBuilder();\n                    tmpAliasToIndexToSearchRoutingMap.put(aliasMd.alias(), indexToSearchRoutingMap);\n                }\n                if (aliasMd.searchRouting() != null) {\n                    indexToSearchRoutingMap.put(indexMetaData.index(), ImmutableSet.copyOf(Strings.splitStringByCommaToSet(aliasMd.searchRouting())));\n                } else {\n                    indexToSearchRoutingMap.put(indexMetaData.index(), ImmutableSet.<String>of());\n                }\n            }\n        }\n        MapBuilder<String, ImmutableMap<String, ImmutableSet<String>>> aliasToIndexToSearchRoutingMap = newMapBuilder();\n        for (Map.Entry<String, MapBuilder<String, ImmutableSet<String>>> alias : tmpAliasToIndexToSearchRoutingMap.map().entrySet()) {\n            aliasToIndexToSearchRoutingMap.put(alias.getKey(), alias.getValue().immutableMap());\n        }\n        this.aliasToIndexToSearchRoutingMap = aliasToIndexToSearchRoutingMap.immutableMap();\n\n        // build filtering required map\n        MapBuilder<String, ImmutableMap<String, Boolean>> filteringRequiredMap = newMapBuilder();\n        for (IndexMetaData indexMetaData : indices.values()) {\n            MapBuilder<String, Boolean> indexFilteringRequiredMap = newMapBuilder();\n            // Filtering is not required for the index itself\n            indexFilteringRequiredMap.put(indexMetaData.index(), false);\n            for (AliasMetaData aliasMetaData : indexMetaData.aliases().values()) {\n                if (aliasMetaData.filter() != null) {\n                    indexFilteringRequiredMap.put(aliasMetaData.alias(), true);\n                } else {\n                    indexFilteringRequiredMap.put(aliasMetaData.alias(), false);\n                }\n            }\n            filteringRequiredMap.put(indexMetaData.index(), indexFilteringRequiredMap.immutableMap());\n        }\n        indexToAliasFilteringRequiredMap = filteringRequiredMap.immutableMap();\n\n        // build aliasAndIndex to Index map\n        MapBuilder<String, Set<String>> tmpAliasAndIndexToIndexBuilder = newMapBuilder();\n        for (IndexMetaData indexMetaData : indices.values()) {\n            Set<String> lst = tmpAliasAndIndexToIndexBuilder.get(indexMetaData.index());\n            if (lst == null) {\n                lst = newHashSet();\n                tmpAliasAndIndexToIndexBuilder.put(indexMetaData.index(), lst);\n            }\n            lst.add(indexMetaData.index());\n\n            for (String alias : indexMetaData.aliases().keySet()) {\n                lst = tmpAliasAndIndexToIndexBuilder.get(alias);\n                if (lst == null) {\n                    lst = newHashSet();\n                    tmpAliasAndIndexToIndexBuilder.put(alias, lst);\n                }\n                lst.add(indexMetaData.index());\n            }\n        }\n\n        MapBuilder<String, String[]> aliasAndIndexToIndexBuilder = newMapBuilder();\n        for (Map.Entry<String, Set<String>> entry : tmpAliasAndIndexToIndexBuilder.map().entrySet()) {\n            aliasAndIndexToIndexBuilder.put(entry.getKey(), entry.getValue().toArray(new String[entry.getValue().size()]));\n        }\n        this.aliasAndIndexToIndexMap = aliasAndIndexToIndexBuilder.immutableMap();\n    }","id":73622,"modified_method":"MetaData(long version, Settings transientSettings, Settings persistentSettings, ImmutableMap<String, IndexMetaData> indices, ImmutableMap<String, IndexTemplateMetaData> templates, ImmutableMap<String, Custom> customs) {\n        this.version = version;\n        this.transientSettings = transientSettings;\n        this.persistentSettings = persistentSettings;\n        this.settings = ImmutableSettings.settingsBuilder().put(persistentSettings).put(transientSettings).build();\n        this.indices = ImmutableMap.copyOf(indices);\n        this.customs = customs;\n        this.templates = templates;\n        int totalNumberOfShards = 0;\n        for (IndexMetaData indexMetaData : indices.values()) {\n            totalNumberOfShards += indexMetaData.totalNumberOfShards();\n        }\n        this.totalNumberOfShards = totalNumberOfShards;\n\n        // build all indices map\n        List<String> allIndicesLst = Lists.newArrayList();\n        for (IndexMetaData indexMetaData : indices.values()) {\n            allIndicesLst.add(indexMetaData.index());\n        }\n        allIndices = allIndicesLst.toArray(new String[allIndicesLst.size()]);\n        allIndicesSet = ImmutableSet.copyOf(allIndices);\n\n        List<String> allOpenIndices = Lists.newArrayList();\n        for (IndexMetaData indexMetaData : indices.values()) {\n            if (indexMetaData.state() == IndexMetaData.State.OPEN) {\n                allOpenIndices.add(indexMetaData.index());\n            }\n        }\n        this.allOpenIndices = allOpenIndices.toArray(new String[allOpenIndices.size()]);\n\n        // build aliases map\n        MapBuilder<String, MapBuilder<String, AliasMetaData>> tmpAliasesMap = newMapBuilder();\n        for (IndexMetaData indexMetaData : indices.values()) {\n            String index = indexMetaData.index();\n            for (AliasMetaData aliasMd : indexMetaData.aliases().values()) {\n                MapBuilder<String, AliasMetaData> indexAliasMap = tmpAliasesMap.get(aliasMd.alias());\n                if (indexAliasMap == null) {\n                    indexAliasMap = newMapBuilder();\n                    tmpAliasesMap.put(aliasMd.alias(), indexAliasMap);\n                }\n                indexAliasMap.put(index, aliasMd);\n            }\n        }\n        MapBuilder<String, ImmutableMap<String, AliasMetaData>> aliases = newMapBuilder();\n        for (Map.Entry<String, MapBuilder<String, AliasMetaData>> alias : tmpAliasesMap.map().entrySet()) {\n            aliases.put(alias.getKey(), alias.getValue().immutableMap());\n        }\n        this.aliases = aliases.immutableMap();\n\n        // build routing aliases set\n        MapBuilder<String, MapBuilder<String, ImmutableSet<String>>> tmpAliasToIndexToSearchRoutingMap = newMapBuilder();\n        for (IndexMetaData indexMetaData : indices.values()) {\n            for (AliasMetaData aliasMd : indexMetaData.aliases().values()) {\n                MapBuilder<String, ImmutableSet<String>> indexToSearchRoutingMap = tmpAliasToIndexToSearchRoutingMap.get(aliasMd.alias());\n                if (indexToSearchRoutingMap == null) {\n                    indexToSearchRoutingMap = newMapBuilder();\n                    tmpAliasToIndexToSearchRoutingMap.put(aliasMd.alias(), indexToSearchRoutingMap);\n                }\n                if (aliasMd.searchRouting() != null) {\n                    indexToSearchRoutingMap.put(indexMetaData.index(), ImmutableSet.copyOf(Strings.splitStringByCommaToSet(aliasMd.searchRouting())));\n                } else {\n                    indexToSearchRoutingMap.put(indexMetaData.index(), ImmutableSet.<String>of());\n                }\n            }\n        }\n        MapBuilder<String, ImmutableMap<String, ImmutableSet<String>>> aliasToIndexToSearchRoutingMap = newMapBuilder();\n        for (Map.Entry<String, MapBuilder<String, ImmutableSet<String>>> alias : tmpAliasToIndexToSearchRoutingMap.map().entrySet()) {\n            aliasToIndexToSearchRoutingMap.put(alias.getKey(), alias.getValue().immutableMap());\n        }\n        this.aliasToIndexToSearchRoutingMap = aliasToIndexToSearchRoutingMap.immutableMap();\n\n        // build filtering required map\n        MapBuilder<String, ImmutableMap<String, Boolean>> filteringRequiredMap = newMapBuilder();\n        for (IndexMetaData indexMetaData : indices.values()) {\n            MapBuilder<String, Boolean> indexFilteringRequiredMap = newMapBuilder();\n            // Filtering is not required for the index itself\n            indexFilteringRequiredMap.put(indexMetaData.index(), false);\n            for (AliasMetaData aliasMetaData : indexMetaData.aliases().values()) {\n                if (aliasMetaData.filter() != null) {\n                    indexFilteringRequiredMap.put(aliasMetaData.alias(), true);\n                } else {\n                    indexFilteringRequiredMap.put(aliasMetaData.alias(), false);\n                }\n            }\n            filteringRequiredMap.put(indexMetaData.index(), indexFilteringRequiredMap.immutableMap());\n        }\n        indexToAliasFilteringRequiredMap = filteringRequiredMap.immutableMap();\n\n        // build aliasAndIndex to Index map\n        MapBuilder<String, Set<String>> tmpAliasAndIndexToIndexBuilder = newMapBuilder();\n        for (IndexMetaData indexMetaData : indices.values()) {\n            Set<String> lst = tmpAliasAndIndexToIndexBuilder.get(indexMetaData.index());\n            if (lst == null) {\n                lst = newHashSet();\n                tmpAliasAndIndexToIndexBuilder.put(indexMetaData.index(), lst);\n            }\n            lst.add(indexMetaData.index());\n\n            for (String alias : indexMetaData.aliases().keySet()) {\n                lst = tmpAliasAndIndexToIndexBuilder.get(alias);\n                if (lst == null) {\n                    lst = newHashSet();\n                    tmpAliasAndIndexToIndexBuilder.put(alias, lst);\n                }\n                lst.add(indexMetaData.index());\n            }\n        }\n\n        MapBuilder<String, String[]> aliasAndIndexToIndexBuilder = newMapBuilder();\n        for (Map.Entry<String, Set<String>> entry : tmpAliasAndIndexToIndexBuilder.map().entrySet()) {\n            aliasAndIndexToIndexBuilder.put(entry.getKey(), entry.getValue().toArray(new String[entry.getValue().size()]));\n        }\n        this.aliasAndIndexToIndexMap = aliasAndIndexToIndexBuilder.immutableMap();\n    }","commit_id":"2dd82675fb003bbceb2c8531245716e3ed26ac8f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Translates the provided indices (possibly aliased) into actual indices.\n     */\n    public String[] concreteIndices(String[] aliasesOrIndices, boolean ignoreMissing, boolean allOnlyOpen) throws IndexMissingException {\n        if (aliasesOrIndices == null || aliasesOrIndices.length == 0) {\n            return allOnlyOpen ? concreteAllOpenIndices() : concreteAllIndices();\n        }\n        aliasesOrIndices = convertFromWildcards(aliasesOrIndices, allOnlyOpen, false);\n        // optimize for single element index (common case)\n        if (aliasesOrIndices.length == 1) {\n            String aliasOrIndex = aliasesOrIndices[0];\n            if (aliasOrIndex.length() == 0) {\n                return allOnlyOpen ? concreteAllOpenIndices() : concreteAllIndices();\n            }\n            if (aliasOrIndex.equals(\"_all\")) {\n                return allOnlyOpen ? concreteAllOpenIndices() : concreteAllIndices();\n            }\n            // if a direct index name, just return the array provided\n            if (this.indices.containsKey(aliasOrIndex)) {\n                return aliasesOrIndices;\n            }\n            String[] actualLst = aliasAndIndexToIndexMap.get(aliasOrIndex);\n            if (actualLst == null) {\n                if (!ignoreMissing) {\n                    throw new IndexMissingException(new Index(aliasOrIndex));\n                } else {\n                    return Strings.EMPTY_ARRAY;\n                }\n            } else {\n                return actualLst;\n            }\n        }\n\n        // check if its a possible aliased index, if not, just return the\n        // passed array\n        boolean possiblyAliased = false;\n        for (String index : aliasesOrIndices) {\n            if (!this.indices.containsKey(index)) {\n                possiblyAliased = true;\n                break;\n            }\n        }\n        if (!possiblyAliased) {\n            return aliasesOrIndices;\n        }\n\n        Set<String> actualIndices = new THashSet<String>();\n        for (String index : aliasesOrIndices) {\n            String[] actualLst = aliasAndIndexToIndexMap.get(index);\n            if (actualLst == null) {\n                if (!ignoreMissing) {\n                    throw new IndexMissingException(new Index(index));\n                }\n            } else {\n                for (String x : actualLst) {\n                    actualIndices.add(x);\n                }\n            }\n        }\n        return actualIndices.toArray(new String[actualIndices.size()]);\n    }","id":73623,"modified_method":"/**\n     * Translates the provided indices (possibly aliased) into actual indices.\n     */\n    public String[] concreteIndices(String[] aliasesOrIndices, boolean ignoreMissing, boolean allOnlyOpen) throws IndexMissingException {\n        if (aliasesOrIndices == null || aliasesOrIndices.length == 0) {\n            return allOnlyOpen ? concreteAllOpenIndices() : concreteAllIndices();\n        }\n        aliasesOrIndices = convertFromWildcards(aliasesOrIndices, allOnlyOpen, ignoreMissing);\n        // optimize for single element index (common case)\n        if (aliasesOrIndices.length == 1) {\n            String aliasOrIndex = aliasesOrIndices[0];\n            if (aliasOrIndex.length() == 0) {\n                return allOnlyOpen ? concreteAllOpenIndices() : concreteAllIndices();\n            }\n            if (aliasOrIndex.equals(\"_all\")) {\n                return allOnlyOpen ? concreteAllOpenIndices() : concreteAllIndices();\n            }\n            // if a direct index name, just return the array provided\n            if (this.indices.containsKey(aliasOrIndex)) {\n                return aliasesOrIndices;\n            }\n            String[] actualLst = aliasAndIndexToIndexMap.get(aliasOrIndex);\n            if (actualLst == null) {\n                if (!ignoreMissing) {\n                    throw new IndexMissingException(new Index(aliasOrIndex));\n                } else {\n                    return Strings.EMPTY_ARRAY;\n                }\n            } else {\n                return actualLst;\n            }\n        }\n\n        // check if its a possible aliased index, if not, just return the\n        // passed array\n        boolean possiblyAliased = false;\n        for (String index : aliasesOrIndices) {\n            if (!this.indices.containsKey(index)) {\n                possiblyAliased = true;\n                break;\n            }\n        }\n        if (!possiblyAliased) {\n            return aliasesOrIndices;\n        }\n\n        Set<String> actualIndices = new THashSet<String>();\n        for (String index : aliasesOrIndices) {\n            String[] actualLst = aliasAndIndexToIndexMap.get(index);\n            if (actualLst == null) {\n                if (!ignoreMissing) {\n                    throw new IndexMissingException(new Index(index));\n                }\n            } else {\n                for (String x : actualLst) {\n                    actualIndices.add(x);\n                }\n            }\n        }\n        return actualIndices.toArray(new String[actualIndices.size()]);\n    }","commit_id":"2dd82675fb003bbceb2c8531245716e3ed26ac8f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public String[] convertFromWildcards(String[] aliasesOrIndices, boolean wildcardOnlyOpen, boolean ignoreMissing) {\n        Set<String> result = null;\n        for (int i = 0; i < aliasesOrIndices.length; i++) {\n            String aliasOrIndex = aliasesOrIndices[i];\n            if (aliasAndIndexToIndexMap.containsKey(aliasOrIndex)) {\n                if (result != null) {\n                    result.add(aliasOrIndex);\n                }\n                continue;\n            }\n            boolean add = true;\n            if (aliasOrIndex.charAt(0) == '+') {\n                add = true;\n                aliasOrIndex = aliasOrIndex.substring(1);\n            } else if (aliasOrIndex.charAt(0) == '-') {\n                // if its the first, fill it with all the indices...\n                if (i == 0) {\n                    result = new THashSet<String>(Arrays.asList(wildcardOnlyOpen ? concreteAllOpenIndices() : concreteAllIndices()));\n                }\n                add = false;\n                aliasOrIndex = aliasOrIndex.substring(1);\n            }\n            if (!Regex.isSimpleMatchPattern(aliasOrIndex)) {\n                if (result != null) {\n                    if (add) {\n                        result.add(aliasOrIndex);\n                    } else {\n                        result.remove(aliasOrIndex);\n                    }\n                }\n                continue;\n            }\n            if (result == null) {\n                // add all the previous ones...\n                result = new THashSet<String>();\n                result.addAll(Arrays.asList(aliasesOrIndices).subList(0, i));\n            }\n            String[] indices = wildcardOnlyOpen ? concreteAllOpenIndices() : concreteAllIndices();\n            boolean found = false;\n            for (String index : indices) {\n                if (Regex.simpleMatch(aliasOrIndex, index)) {\n                    found = true;\n                    if (add) {\n                        result.add(index);\n                    } else {\n                        result.remove(index);\n                    }\n                }\n            }\n            for (String alias : aliases.keySet()) {\n                if (Regex.simpleMatch(aliasOrIndex, alias)) {\n                    found = true;\n                    if (add) {\n                        result.add(alias);\n                    } else {\n                        result.remove(alias);\n                    }\n                }\n            }\n            if (!found && !ignoreMissing) {\n                throw new IndexMissingException(new Index(aliasOrIndex));\n            }\n        }\n        if (result == null) {\n            return aliasesOrIndices;\n        }\n        return result.toArray(new String[result.size()]);\n    }","id":73624,"modified_method":"public String[] convertFromWildcards(String[] aliasesOrIndices, boolean wildcardOnlyOpen, boolean ignoreMissing) {\n        Set<String> result = null;\n        for (int i = 0; i < aliasesOrIndices.length; i++) {\n            String aliasOrIndex = aliasesOrIndices[i];\n            if (aliasAndIndexToIndexMap.containsKey(aliasOrIndex)) {\n                if (result != null) {\n                    result.add(aliasOrIndex);\n                }\n                continue;\n            }\n            boolean add = true;\n            if (aliasOrIndex.charAt(0) == '+') {\n                add = true;\n                aliasOrIndex = aliasOrIndex.substring(1);\n            } else if (aliasOrIndex.charAt(0) == '-') {\n                // if its the first, fill it with all the indices...\n                if (i == 0) {\n                    result = new THashSet<String>(Arrays.asList(wildcardOnlyOpen ? concreteAllOpenIndices() : concreteAllIndices()));\n                }\n                add = false;\n                aliasOrIndex = aliasOrIndex.substring(1);\n            }\n            if (!Regex.isSimpleMatchPattern(aliasOrIndex)) {\n                if (!ignoreMissing && !aliasAndIndexToIndexMap.containsKey(aliasOrIndex)) {\n                    throw new IndexMissingException(new Index(aliasOrIndex));\n                }\n                if (result != null) {\n                    if (add) {\n                        result.add(aliasOrIndex);\n                    } else {\n                        result.remove(aliasOrIndex);\n                    }\n                }\n                continue;\n            }\n            if (result == null) {\n                // add all the previous ones...\n                result = new THashSet<String>();\n                result.addAll(Arrays.asList(aliasesOrIndices).subList(0, i));\n            }\n            String[] indices = wildcardOnlyOpen ? concreteAllOpenIndices() : concreteAllIndices();\n            boolean found = false;\n            for (String index : indices) {\n                if (Regex.simpleMatch(aliasOrIndex, index)) {\n                    found = true;\n                    if (add) {\n                        result.add(index);\n                    } else {\n                        result.remove(index);\n                    }\n                }\n            }\n            for (String alias : aliases.keySet()) {\n                if (Regex.simpleMatch(aliasOrIndex, alias)) {\n                    found = true;\n                    if (add) {\n                        result.add(alias);\n                    } else {\n                        result.remove(alias);\n                    }\n                }\n            }\n            if (!found && !ignoreMissing) {\n                throw new IndexMissingException(new Index(aliasOrIndex));\n            }\n        }\n        if (result == null) {\n            return aliasesOrIndices;\n        }\n        return result.toArray(new String[result.size()]);\n    }","commit_id":"2dd82675fb003bbceb2c8531245716e3ed26ac8f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void doExecute(DeleteIndexRequest request, ActionListener<DeleteIndexResponse> listener) {\n        if (disableDeleteAllIndices && (request.indices() == null || request.indices().length == 0 || (request.indices().length == 1 && request.indices()[0].equals(\"_all\")))) {\n            throw new ElasticSearchIllegalArgumentException(\"deleting all indices is disabled\");\n        }\n        request.indices(clusterService.state().metaData().concreteIndices(request.indices()));\n        super.doExecute(request, listener);\n    }","id":73625,"modified_method":"@Override\n    protected void doExecute(DeleteIndexRequest request, ActionListener<DeleteIndexResponse> listener) {\n        ClusterState state = clusterService.state();\n        String[] indicesOrAliases = request.indices();\n        request.indices(state.metaData().concreteIndices(request.indices()));\n        if (disableDeleteAllIndices) {\n            // simple check on the original indices with \"all\" default parameter\n            if (indicesOrAliases == null || indicesOrAliases.length == 0 || (indicesOrAliases.length == 1 && indicesOrAliases[0].equals(\"_all\"))) {\n                throw new ElasticSearchIllegalArgumentException(\"deleting all indices is disabled\");\n            }\n            // if we end up matching on all indices, check, if its a wildcard parameter, or a \"-something\" structure\n            if (request.indices().length == state.metaData().concreteAllIndices().length && indicesOrAliases.length > 0) {\n                boolean hasRegex = false;\n                for (String indexOrAlias : indicesOrAliases) {\n                    if (Regex.isSimpleMatchPattern(indexOrAlias)) {\n                        hasRegex = true;\n                    }\n                }\n                if (indicesOrAliases.length > 0 && (hasRegex || indicesOrAliases[0].charAt(0) == '-')) {\n                    throw new ElasticSearchIllegalArgumentException(\"deleting all indices is disabled\");\n                }\n            }\n        }\n        super.doExecute(request, listener);\n    }","commit_id":"2dd82675fb003bbceb2c8531245716e3ed26ac8f","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void shouldBeAbleToMoveTransactionToAnotherThread() throws Exception\n    {\n        // Given\n        GraphDatabaseAPI db = dbRule.getGraphDatabaseAPI();\n        final TransactionManager tm = db.getDependencyResolver().resolveDependency( TransactionManager.class );\n\n        final Node node = createNode();\n\n        // And that I have added a label to a node in a transaction\n        db.beginTx();\n        node.addLabel( Labels.MY_LABEL );\n\n        // And that I suspend the transaction in this thread\n        final Transaction jtaTx = tm.suspend();\n\n        // When\n        OtherThreadExecutor<Boolean> otherThread = new OtherThreadExecutor<>( \"Thread to resume tx in\", null );\n        boolean result = otherThread.execute( new OtherThreadExecutor.WorkerCommand<Boolean, Boolean>()\n        {\n            @Override\n            public Boolean doWork( Boolean ignore )\n            {\n                try\n                {\n                    tm.resume( jtaTx );\n                    // Then\n                    return node.hasLabel( Labels.MY_LABEL );\n                }\n                catch ( Throwable e )\n                {\n                    throw new RuntimeException( e );\n                }\n            }\n        } );\n\n        // Then\n        assertTrue(\"The label should be visible when I've resumed the transaction.\", result);\n    }","id":73626,"modified_method":"@Test\n    public void shouldBeAbleToMoveTransactionToAnotherThread() throws Exception\n    {\n        // Given\n        //noinspection deprecation\n        GraphDatabaseAPI db = dbRule.getGraphDatabaseAPI();\n        final TransactionManager tm = db.getDependencyResolver().resolveDependency( TransactionManager.class );\n\n        final Node node = createNode();\n\n        // And that I have added a label to a node in a transaction\n        try ( org.neo4j.graphdb.Transaction ignored = db.beginTx() )\n        {\n            node.addLabel( Labels.MY_LABEL );\n\n            // And that I suspend the transaction in this thread\n            final Transaction jtaTx = tm.suspend();\n\n            boolean result;\n            try\n            {\n                // When\n                OtherThreadExecutor<Boolean> otherThread = new OtherThreadExecutor<>( \"Thread to resume tx in\", null );\n                result = otherThread.execute( new OtherThreadExecutor.WorkerCommand<Boolean, Boolean>()\n                {\n                    @Override\n                    public Boolean doWork( Boolean ignore )\n                    {\n                        try\n                        {\n                            tm.resume( jtaTx );\n                            // Then\n                            return node.hasLabel( Labels.MY_LABEL );\n                        }\n                        catch ( Exception e )\n                        {\n                            throw new RuntimeException( e );\n                        }\n                        finally\n                        {\n                            try\n                            {\n                                tm.suspend();\n                            }\n                            catch ( SystemException e )\n                            {\n                                throw new RuntimeException( e );\n                            }\n                        }\n                    }\n                } );\n            }\n            finally\n            {\n                // Need to resume this transaction so that we can close it cleanly.\n                tm.resume( jtaTx );\n            }\n\n            // Then\n            assertTrue(\"The label should be visible when I've resumed the transaction.\", result);\n        }\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldAllowSuspendingAndResumingTransactions() throws Exception\n    {\n        // Given\n        GraphDatabaseAPI db = dbRule.getGraphDatabaseAPI();\n        TransactionManager tm = db.getDependencyResolver().resolveDependency( TransactionManager.class );\n\n        Node node = createNode();\n\n        // And that I have added a label to a node in a transaction\n        db.beginTx();\n        node.addLabel( Labels.MY_LABEL );\n\n        // When\n        Transaction jtaTx = tm.suspend();\n\n        // Then\n        assertThat(node, inTx(db, not( hasLabel( Labels.MY_LABEL ) )));\n\n        // And when\n        tm.resume( jtaTx );\n        // Then\n        assertTrue(\"The label should be visible when I've resumed the transaction.\", node.hasLabel( Labels.MY_LABEL ));\n    }","id":73627,"modified_method":"@Test\n    public void shouldAllowSuspendingAndResumingTransactions() throws Exception\n    {\n        // Given\n        //noinspection deprecation\n        GraphDatabaseAPI db = dbRule.getGraphDatabaseAPI();\n        TransactionManager tm = db.getDependencyResolver().resolveDependency( TransactionManager.class );\n\n        Node node = createNode();\n\n        // And that I have added a label to a node in a transaction\n        try ( org.neo4j.graphdb.Transaction ignored = db.beginTx() )\n        {\n            node.addLabel( Labels.MY_LABEL );\n\n            // When\n            Transaction jtaTx = tm.suspend();\n\n            // Then\n            assertThat(node, inTx(db, not( hasLabel( Labels.MY_LABEL ) )));\n\n            // And when\n            tm.resume( jtaTx );\n            // Then\n            assertTrue(\"The label should be visible when I've resumed the transaction.\", node.hasLabel( Labels.MY_LABEL ));\n        }\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void stopDb()\n    {\n        db.shutdown();\n    }","id":73628,"modified_method":"protected void stopDb()\n    {\n        if ( beansTx != null )\n        {\n            beansTx.finish();\n        }\n        db.shutdown();\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotAllowCreationOfConstraintsWhenInHA() throws Exception\n    {\n        GraphDatabaseAPI db = new FakeHaDatabase();\n        ThreadToStatementContextBridge stmtBridge =\n                db.getDependencyResolver().resolveDependency( ThreadToStatementContextBridge.class );\n        db.beginTx();\n        Statement statement = stmtBridge.instance();\n\n        try\n        {\n            statement.schemaWriteOperations().uniquenessConstraintCreate( 1, 1 );\n            fail( \"expected exception here\" );\n        }\n        catch ( InvalidTransactionTypeKernelException e )\n        {\n            assertThat( e.getMessage(), containsString( \"HA\" ) );\n        }\n        db.shutdown();\n    }","id":73629,"modified_method":"@Test\n    public void shouldNotAllowCreationOfConstraintsWhenInHA() throws Exception\n    {\n        //noinspection deprecation\n        GraphDatabaseAPI db = new FakeHaDatabase();\n        ThreadToStatementContextBridge stmtBridge =\n                db.getDependencyResolver().resolveDependency( ThreadToStatementContextBridge.class );\n\n        try ( Transaction ignored = db.beginTx() )\n        {\n            Statement statement = stmtBridge.instance();\n\n            try\n            {\n                statement.schemaWriteOperations().uniquenessConstraintCreate( 1, 1 );\n                fail( \"expected exception here\" );\n            }\n            catch ( InvalidTransactionTypeKernelException e )\n            {\n                assertThat( e.getMessage(), containsString( \"HA\" ) );\n            }\n        }\n\n        db.shutdown();\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static Object getIndexState( GraphDatabaseService beansAPI, IndexDefinition indexDef )\n    {\n        Transaction tx;\n        tx = beansAPI.beginTx();\n        try\n        {\n            return beansAPI.schema().getIndexState( indexDef );\n        }\n        finally\n        {\n            tx.finish();\n        }\n    }","id":73630,"modified_method":"public static Object getIndexState( GraphDatabaseService beansAPI, IndexDefinition indexDef )\n    {\n        try ( Transaction ignored = beansAPI.beginTx() )\n        {\n            return beansAPI.schema().getIndexState( indexDef );\n        }\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Collection<T> collection()\n        {\n            Transaction tx = db.beginTx();\n            try\n            {\n                return asCollection( manifest() );\n            }\n            finally\n            {\n                tx.finish();\n            }\n        }","id":73631,"modified_method":"public Collection<T> collection()\n        {\n            try ( Transaction ignored = db.beginTx() )\n            {\n                return asCollection( manifest() );\n            }\n        }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void waitForIndex( GraphDatabaseService beansAPI, IndexDefinition indexDef )\n    {\n        Transaction tx;\n        tx = beansAPI.beginTx();\n        try\n        {\n            beansAPI.schema().awaitIndexOnline( indexDef, 10, SECONDS );\n        }\n        finally\n        {\n            tx.finish();\n        }\n    }","id":73632,"modified_method":"public static void waitForIndex( GraphDatabaseService beansAPI, IndexDefinition indexDef )\n    {\n        try ( Transaction ignored = beansAPI.beginTx() )\n        {\n            beansAPI.schema().awaitIndexOnline( indexDef, 10, SECONDS );\n        }\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static <T> Matcher<? super T> inTx( final GraphDatabaseService db, final Matcher<T> inner )\n    {\n        return new DiagnosingMatcher<T>()\n        {\n            @Override\n            protected boolean matches( Object item, Description mismatchDescription )\n            {\n                Transaction tx = db.beginTx();\n                try\n                {\n                    if ( inner.matches( item ) )\n                    {\n                        return true;\n                    }\n\n                    inner.describeMismatch( item, mismatchDescription );\n\n                    return false;\n\n                }\n                finally\n                {\n                    tx.finish();\n                }\n            }\n\n            @Override\n            public void describeTo( Description description )\n            {\n                inner.describeTo( description );\n            }\n        };\n    }","id":73633,"modified_method":"public static <T> Matcher<? super T> inTx( final GraphDatabaseService db, final Matcher<T> inner )\n    {\n        return new DiagnosingMatcher<T>()\n        {\n            @Override\n            protected boolean matches( Object item, Description mismatchDescription )\n            {\n                try ( Transaction ignored = db.beginTx() )\n                {\n                    if ( inner.matches( item ) )\n                    {\n                        return true;\n                    }\n\n                    inner.describeMismatch( item, mismatchDescription );\n\n                    return false;\n                }\n            }\n\n            @Override\n            public void describeTo( Description description )\n            {\n                inner.describeTo( description );\n            }\n        };\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static IndexDefinition createIndex( GraphDatabaseService beansAPI, Label label, String property )\n    {\n        Transaction tx = beansAPI.beginTx();\n        IndexDefinition indexDef;\n        try\n        {\n            indexDef = beansAPI.schema().indexFor( label ).on( property ).create();\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n\n        waitForIndex( beansAPI, indexDef );\n        return indexDef;\n    }","id":73634,"modified_method":"public static IndexDefinition createIndex( GraphDatabaseService beansAPI, Label label, String property )\n    {\n        IndexDefinition indexDef;\n        try ( Transaction tx = beansAPI.beginTx() )\n        {\n            indexDef = beansAPI.schema().indexFor( label ).on( property ).create();\n            tx.success();\n        }\n\n        waitForIndex( beansAPI, indexDef );\n        return indexDef;\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void nestedTransactionCanAcquireLocksFromTransactionObject() throws Exception\n    {\n        // given\n        Node resource = createNode();\n\n        Transaction outerTx = db.beginTx();\n        Transaction nestedTx = db.beginTx();\n        assertNotSame( outerTx, nestedTx );\n\n        try ( OtherThreadExecutor<Void> otherThread = new OtherThreadExecutor<>( \"other thread\", null ) )\n        {\n            // when\n            Lock lock = nestedTx.acquireWriteLock( resource );\n            Future<Lock> future = tryToAcquireSameLockOnAnotherThread( resource, otherThread );\n\n            // then\n            acquireOnOtherThreadTimesOut( future );\n\n            // and when\n            lock.release();\n\n            //then\n            assertNotNull( future.get() );\n        }\n    }","id":73635,"modified_method":"@Test\n    public void nestedTransactionCanAcquireLocksFromTransactionObject() throws Exception\n    {\n        // given\n        Node resource = createNode();\n\n        try ( Transaction outerTx = db.beginTx(); Transaction nestedTx = db.beginTx() )\n        {\n            assertNotSame( outerTx, nestedTx );\n\n            try ( OtherThreadExecutor<Void> otherThread = new OtherThreadExecutor<>( \"other thread\", null ) )\n            {\n                // when\n                Lock lock = nestedTx.acquireWriteLock( resource );\n                Future<Lock> future = tryToAcquireSameLockOnAnotherThread( resource, otherThread );\n\n                // then\n                acquireOnOtherThreadTimesOut( future );\n\n                // and when\n                lock.release();\n\n                //then\n                assertNotNull( future.get() );\n            }\n        }\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"private WorkerCommand<Void, Lock> acquireWriteLock( final Node resource )\n    {\n        return new WorkerCommand<Void, Lock>()\n        {\n            @Override\n            public Lock doWork( Void state )\n            {\n                Transaction tx = db.beginTx();\n                return tx.acquireWriteLock( resource );\n            }\n        };\n    }","id":73636,"modified_method":"private WorkerCommand<Void, Lock> acquireWriteLock( final Node resource )\n    {\n        return new WorkerCommand<Void, Lock>()\n        {\n            @Override\n            public Lock doWork( Void state )\n            {\n                try ( Transaction tx = db.beginTx() )\n                {\n                    return tx.acquireWriteLock( resource );\n                }\n            }\n        };\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void testOpsCountGuardFail()\n    {\n        GraphDatabaseAPI db = (GraphDatabaseAPI) new TestGraphDatabaseFactory().\n            newImpermanentDatabaseBuilder().\n            setConfig( GraphDatabaseSettings.execution_guard_enabled, Settings.TRUE ).\n            newGraphDatabase();\n        db.beginTx();\n        Guard guard = db.getGuard();\n\n        guard.startOperationsCount( 2 );\n        Node n0 = db.createNode();\n        Node n1 = db.createNode();\n        try\n        {\n            Node n2 = db.createNode();\n            fail();\n        } catch ( GuardOperationsCountException e )\n        {\n            // expected\n        }\n        db.shutdown();\n    }","id":73637,"modified_method":"@Test\n    public void testOpsCountGuardFail()\n    {\n        GraphDatabaseAPI db = (GraphDatabaseAPI) new TestGraphDatabaseFactory().\n            newImpermanentDatabaseBuilder().\n            setConfig( GraphDatabaseSettings.execution_guard_enabled, Settings.TRUE ).\n            newGraphDatabase();\n\n        Guard guard = db.getGuard();\n        guard.startOperationsCount( 2 );\n\n        try ( Transaction ignored = db.beginTx() )\n        {\n            db.createNode();\n            db.createNode();\n            try\n            {\n                db.createNode();\n                fail();\n            } catch ( GuardOperationsCountException e )\n            {\n                // expected\n            }\n        }\n\n        db.shutdown();\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void testTimeoutGuardFail() throws InterruptedException\n    {\n        GraphDatabaseAPI db = (GraphDatabaseAPI) new TestGraphDatabaseFactory().\n                newImpermanentDatabaseBuilder().\n                setConfig( GraphDatabaseSettings.execution_guard_enabled, Settings.TRUE ).\n                newGraphDatabase();\n        db.beginTx();\n\n        db.getDependencyResolver().resolveDependency( Guard.class ).startTimeout( 50 );\n        sleep( 100 );\n\n        try\n        {\n            db.createNode();\n            fail( \"Expected guard to stop this\" );\n        }\n        catch ( GuardTimeoutException e )\n        {\n            // expected\n        }\n        db.shutdown();\n    }","id":73638,"modified_method":"@Test\n    public void testTimeoutGuardFail() throws InterruptedException\n    {\n        GraphDatabaseAPI db = (GraphDatabaseAPI) new TestGraphDatabaseFactory().\n                newImpermanentDatabaseBuilder().\n                setConfig( GraphDatabaseSettings.execution_guard_enabled, Settings.TRUE ).\n                newGraphDatabase();\n\n        db.getDependencyResolver().resolveDependency( Guard.class ).startTimeout( 50 );\n\n        try ( Transaction ignore = db.beginTx() )\n        {\n            sleep( 100 );\n\n            try\n            {\n                db.createNode();\n                fail( \"Expected guard to stop this\" );\n            }\n            catch ( GuardTimeoutException e )\n            {\n                // expected\n            }\n        }\n\n        db.shutdown();\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void testGuardOnDifferentGraphOps()\n    {\n        GraphDatabaseAPI db = (GraphDatabaseAPI) new TestGraphDatabaseFactory().\n            newImpermanentDatabaseBuilder().\n            setConfig( GraphDatabaseSettings.execution_guard_enabled, Settings.TRUE ).\n            newGraphDatabase();\n        db.beginTx();\n\n        db.getGuard().startOperationsCount( MAX_VALUE );\n        db.createNode();\n        db.createNode();\n        db.createNode();\n        Guard.OperationsCount ops1 = db.getGuard().stop();\n        assertEquals( 3, ops1.getOpsCount() );\n\n        db.getGuard().startOperationsCount( MAX_VALUE );\n        Node n0 = db.getNodeById( 0 );\n        Node n1 = db.getNodeById( 1 );\n        Node n2 = db.getNodeById( 2 );\n        Guard.OperationsCount ops2 = db.getGuard().stop();\n        assertEquals( 3, ops2.getOpsCount() );\n\n        db.getGuard().startOperationsCount( MAX_VALUE );\n        n0.createRelationshipTo( n1, withName( \"REL\" ));\n        Guard.OperationsCount ops3 = db.getGuard().stop();\n        assertEquals( 2, ops3.getOpsCount() );\n\n\n        db.getGuard().startOperationsCount( MAX_VALUE );\n        for ( Path position : Traversal.description().breadthFirst().relationships( withName( \"REL\" ) ).traverse( n0 ) )\n        {\n            ignore( position );\n        }\n        Guard.OperationsCount ops4 = db.getGuard().stop();\n        assertEquals( 3, ops4.getOpsCount() );\n        db.shutdown();\n    }","id":73639,"modified_method":"@Test\n    public void testGuardOnDifferentGraphOps()\n    {\n        GraphDatabaseAPI db = (GraphDatabaseAPI) new TestGraphDatabaseFactory().\n            newImpermanentDatabaseBuilder().\n            setConfig( GraphDatabaseSettings.execution_guard_enabled, Settings.TRUE ).\n            newGraphDatabase();\n\n        try ( Transaction ignored = db.beginTx() )\n        {\n            db.getGuard().startOperationsCount( MAX_VALUE );\n            db.createNode();\n            db.createNode();\n            db.createNode();\n            Guard.OperationsCount ops1 = db.getGuard().stop();\n            assertEquals( 3, ops1.getOpsCount() );\n\n            db.getGuard().startOperationsCount( MAX_VALUE );\n            Node n0 = db.getNodeById( 0 );\n            Node n1 = db.getNodeById( 1 );\n            db.getNodeById( 2 );\n            Guard.OperationsCount ops2 = db.getGuard().stop();\n            assertEquals( 3, ops2.getOpsCount() );\n\n            db.getGuard().startOperationsCount( MAX_VALUE );\n            n0.createRelationshipTo( n1, withName( \"REL\" ));\n            Guard.OperationsCount ops3 = db.getGuard().stop();\n            assertEquals( 2, ops3.getOpsCount() );\n\n            db.getGuard().startOperationsCount( MAX_VALUE );\n            for ( Path position : Traversal.description().breadthFirst().relationships( withName( \"REL\" ) ).traverse( n0 ) )\n            {\n                ignore( position );\n            }\n            Guard.OperationsCount ops4 = db.getGuard().stop();\n            assertEquals( 3, ops4.getOpsCount() );\n        }\n\n        db.shutdown();\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void testTimeoutGuardPass()\n    {\n        GraphDatabaseAPI db = (GraphDatabaseAPI) new TestGraphDatabaseFactory().\n                newImpermanentDatabaseBuilder().\n                setConfig( GraphDatabaseSettings.execution_guard_enabled, Settings.TRUE ).\n                newGraphDatabase();\n        db.beginTx();\n\n        int timeout = 1000;\n        db.getGuard().startTimeout( timeout );\n\n        db.createNode(); // This should not throw\n        db.shutdown();\n    }","id":73640,"modified_method":"@Test\n    public void testTimeoutGuardPass()\n    {\n        GraphDatabaseAPI db = (GraphDatabaseAPI) new TestGraphDatabaseFactory().\n                newImpermanentDatabaseBuilder().\n                setConfig( GraphDatabaseSettings.execution_guard_enabled, Settings.TRUE ).\n                newGraphDatabase();\n\n        int timeout = 1000;\n        db.getGuard().startTimeout( timeout );\n\n        try ( Transaction ignored = db.beginTx() )\n        {\n            db.createNode(); // This should not throw\n        }\n\n        db.shutdown();\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void testNodeChangePropertyArray() throws Exception\n    {\n        Transaction tx = getTransaction();\n        tx.finish();\n        tx = getGraphDb().beginTx();\n        Node node;\n        try\n        {\n            node = getGraphDb().createNode();\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        tx = getGraphDb().beginTx();\n        try\n        {\n            node.setProperty( \"test\", new String[] { \"value1\" } );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        tx = getGraphDb().beginTx();\n        try\n        {\n            node.setProperty( \"test\", new String[] { \"value1\", \"value2\" } );\n            // no success, we wanna test rollback on this operation\n        }\n        finally\n        {\n            tx.finish();\n        }\n        tx = getGraphDb().beginTx();\n        try\n        {\n            String[] value = (String[]) node.getProperty( \"test\" );\n            assertEquals( 1, value.length );\n            assertEquals( \"value1\", value[0] );\n            tx.success();\n        }\n        finally\n        {\n            tx.finish();\n        }\n        setTransaction( getGraphDb().beginTx() );\n    }","id":73641,"modified_method":"@Test\n    public void testNodeChangePropertyArray() throws Exception\n    {\n        getTransaction().finish();\n\n        Node node;\n        try ( Transaction tx = getGraphDb().beginTx() )\n        {\n            node = getGraphDb().createNode();\n            tx.success();\n        }\n\n        try ( Transaction tx = getGraphDb().beginTx() )\n        {\n            node.setProperty( \"test\", new String[] { \"value1\" } );\n            tx.success();\n        }\n\n        try (Transaction ignored = getGraphDb().beginTx() )\n        {\n            node.setProperty( \"test\", new String[] { \"value1\", \"value2\" } );\n            // no success, we wanna test rollback on this operation\n        }\n\n        try (Transaction tx = getGraphDb().beginTx() )\n        {\n            String[] value = (String[]) node.getProperty( \"test\" );\n            assertEquals( 1, value.length );\n            assertEquals( \"value1\", value[0] );\n            tx.success();\n        }\n\n        setTransaction( getGraphDb().beginTx() );\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void testMultipleShutdown()\n    {\n        getGraphDb().shutdown();\n        getGraphDb().shutdown();\n    }","id":73642,"modified_method":"@Test\n    public void testMultipleShutdown()\n    {\n        getTransaction().close();\n        getGraphDb().shutdown();\n        getGraphDb().shutdown();\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void testBasicNodeRelationships()\n    {\n        Node firstNode = null;\n        Node secondNode = null;\n        Relationship rel = null;\n        // Create nodes and a relationship between them\n        firstNode = getGraphDb().createNode();\n        assertNotNull( \"Failure creating first node\", firstNode );\n        secondNode = getGraphDb().createNode();\n        assertNotNull( \"Failure creating second node\", secondNode );\n        rel = firstNode.createRelationshipTo( secondNode, MyRelTypes.TEST );\n        assertNotNull( \"Relationship is null\", rel );\n        RelationshipType relType = rel.getType();\n        assertNotNull( \"Relationship's type is is null\", relType );\n\n        // Verify that the node reports that it has a relationship of\n        // the type we created above\n        assertTrue( firstNode.getRelationships( relType ).iterator().hasNext() );\n        assertTrue( secondNode.getRelationships( relType ).iterator().hasNext() );\n\n        Iterable<Relationship> allRels = null;\n\n        // Verify that both nodes return the relationship we created above\n        allRels = firstNode.getRelationships();\n        assertTrue( this.objectExistsInIterable( rel, allRels ) );\n        allRels = firstNode.getRelationships( relType );\n        assertTrue( this.objectExistsInIterable( rel, allRels ) );\n\n        allRels = secondNode.getRelationships();\n        assertTrue( this.objectExistsInIterable( rel, allRels ) );\n        allRels = secondNode.getRelationships( relType );\n        assertTrue( this.objectExistsInIterable( rel, allRels ) );\n\n        // Verify that the relationship reports that it is associated with\n        // firstNode and secondNode\n        Node[] relNodes = rel.getNodes();\n        assertEquals( \"A relationship should always be connected to exactly \"\n            + \"two nodes\", relNodes.length, 2 );\n        assertTrue( \"Relationship says that it isn't connected to firstNode\",\n            this.objectExistsInArray( firstNode, relNodes ) );\n        assertTrue( \"Relationship says that it isn't connected to secondNode\",\n            this.objectExistsInArray( secondNode, relNodes ) );\n        assertTrue( \"The other node should be secondNode but it isn't\", rel\n            .getOtherNode( firstNode ).equals( secondNode ) );\n        assertTrue( \"The other node should be firstNode but it isn't\", rel\n            .getOtherNode( secondNode ).equals( firstNode ) );\n        rel.delete();\n        secondNode.delete();\n        firstNode.delete();\n    }","id":73643,"modified_method":"@Test\n    public void testBasicNodeRelationships()\n    {\n        Node firstNode;\n        Node secondNode;\n        Relationship rel;\n        // Create nodes and a relationship between them\n        firstNode = getGraphDb().createNode();\n        assertNotNull( \"Failure creating first node\", firstNode );\n        secondNode = getGraphDb().createNode();\n        assertNotNull( \"Failure creating second node\", secondNode );\n        rel = firstNode.createRelationshipTo( secondNode, MyRelTypes.TEST );\n        assertNotNull( \"Relationship is null\", rel );\n        RelationshipType relType = rel.getType();\n        assertNotNull( \"Relationship's type is is null\", relType );\n\n        // Verify that the node reports that it has a relationship of\n        // the type we created above\n        assertTrue( firstNode.getRelationships( relType ).iterator().hasNext() );\n        assertTrue( secondNode.getRelationships( relType ).iterator().hasNext() );\n\n        Iterable<Relationship> allRels;\n\n        // Verify that both nodes return the relationship we created above\n        allRels = firstNode.getRelationships();\n        assertTrue( this.objectExistsInIterable( rel, allRels ) );\n        allRels = firstNode.getRelationships( relType );\n        assertTrue( this.objectExistsInIterable( rel, allRels ) );\n\n        allRels = secondNode.getRelationships();\n        assertTrue( this.objectExistsInIterable( rel, allRels ) );\n        allRels = secondNode.getRelationships( relType );\n        assertTrue( this.objectExistsInIterable( rel, allRels ) );\n\n        // Verify that the relationship reports that it is associated with\n        // firstNode and secondNode\n        Node[] relNodes = rel.getNodes();\n        assertEquals( \"A relationship should always be connected to exactly \"\n            + \"two nodes\", relNodes.length, 2 );\n        assertTrue( \"Relationship says that it isn't connected to firstNode\",\n            this.objectExistsInArray( firstNode, relNodes ) );\n        assertTrue( \"Relationship says that it isn't connected to secondNode\",\n            this.objectExistsInArray( secondNode, relNodes ) );\n        assertTrue( \"The other node should be secondNode but it isn't\", rel\n            .getOtherNode( firstNode ).equals( secondNode ) );\n        assertTrue( \"The other node should be firstNode but it isn't\", rel\n            .getOtherNode( secondNode ).equals( firstNode ) );\n        rel.delete();\n        secondNode.delete();\n        firstNode.delete();\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldGiveNiceErrorWhenShutdownKernelApi()\n    {\n        GraphDatabaseService graphDb = graph;\n        Node node = graphDb.createNode();\n        graphDb.shutdown();\n\n        try\n        {\n            asList( node.getLabels().iterator() );\n            fail( \"Did not get a nice exception\" );\n        }\n        catch ( DatabaseShutdownException e )\n        { // good\n        }\n    }","id":73644,"modified_method":"@Test\n    public void shouldGiveNiceErrorWhenShutdownKernelApi()\n    {\n        GraphDatabaseService graphDb = graph;\n        Node node = graphDb.createNode();\n        commit();\n        graphDb.shutdown();\n\n        try\n        {\n            asList( node.getLabels().iterator() );\n            fail( \"Did not get a nice exception\" );\n        }\n        catch ( DatabaseShutdownException e )\n        { // good\n        }\n    }","commit_id":"dffc17bfcebb2a96c3e31507bc740cc6cd641ed7","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void injectedTransactionCountShouldBeMonitored() throws Throwable\n    {\n        // GIVEN\n        ClusterManager clusterManager = new ClusterManager( fromXml( getClass().getResource( \"/threeinstances.xml\" ).toURI() ),\n                TargetDirectory.forTest( getClass() ).cleanDirectory( \"testCluster\" ),\n                MapUtil.stringMap( HaSettings.ha_server.name(), \":6001-6005\",\n                        HaSettings.tx_push_factor.name(), \"2\" ) );\n\n        EideticRequestMonitor masterMonitor = new EideticRequestMonitor();\n        EideticRequestMonitor firstSlaveMonitor = new EideticRequestMonitor();\n        EideticRequestMonitor secondSlaveMonitor = new EideticRequestMonitor();\n\n        try\n        {\n            clusterManager.start();\n\n            clusterManager.getDefaultCluster().await( allSeesAllAsAvailable() );\n\n            GraphDatabaseAPI master = clusterManager.getDefaultCluster().getMaster();\n            master.getDependencyResolver().resolveDependency( Monitors.class ).addMonitorListener(\n                    masterMonitor );\n\n            HighlyAvailableGraphDatabase firstSlave = clusterManager.getDefaultCluster().getAnySlave();\n            firstSlave.getDependencyResolver().resolveDependency( Monitors.class ).addMonitorListener(\n                    firstSlaveMonitor );\n\n            HighlyAvailableGraphDatabase secondSlave = clusterManager.getDefaultCluster().getAnySlave( firstSlave );\n            secondSlave.getDependencyResolver().resolveDependency( Monitors.class ).addMonitorListener(\n                    secondSlaveMonitor );\n\n            // WHEN\n            Transaction tx = master.beginTx();\n            master.createNode();\n            tx.success();\n            tx.finish();\n\n            tx = firstSlave.beginTx();\n            firstSlave.createNode();\n            tx.success();\n            tx.finish();\n\n            tx = secondSlave.beginTx();\n            secondSlave.createNode();\n            tx.success();\n            tx.finish();\n        }\n        finally\n        {\n            clusterManager.stop();\n        }\n\n        // THEN\n        assertEquals( masterMonitor.getRequests().size(), masterMonitor.getRequestsEnded() );\n        assertEquals( firstSlaveMonitor.getRequests().size(), firstSlaveMonitor.getRequestsEnded() );\n        assertEquals( secondSlaveMonitor.getRequests().size(), secondSlaveMonitor.getRequestsEnded() );\n    }","id":73645,"modified_method":"@Test\n    public void injectedTransactionCountShouldBeMonitored() throws Throwable\n    {\n        // GIVEN\n        ClusterManager clusterManager = new ClusterManager( fromXml( getClass().getResource( \"/threeinstances.xml\" ).toURI() ),\n                TargetDirectory.forTest( getClass() ).cleanDirectory( \"testCluster\" ),\n                MapUtil.stringMap( HaSettings.ha_server.name(), \":6001-6005\",\n                        HaSettings.tx_push_factor.name(), \"2\" ) );\n\n        EideticRequestMonitor masterMonitor = new EideticRequestMonitor();\n        EideticRequestMonitor firstSlaveMonitor = new EideticRequestMonitor();\n        EideticRequestMonitor secondSlaveMonitor = new EideticRequestMonitor();\n\n        try\n        {\n            clusterManager.start();\n\n            clusterManager.getDefaultCluster().await( allSeesAllAsAvailable() );\n\n            GraphDatabaseAPI master = clusterManager.getDefaultCluster().getMaster();\n            master.getDependencyResolver().\n                    resolveDependency( Monitors.class ).addMonitorListener( masterMonitor );\n\n            HighlyAvailableGraphDatabase firstSlave = clusterManager.getDefaultCluster().getAnySlave();\n            firstSlave.getDependencyResolver().\n                    resolveDependency( Monitors.class ).addMonitorListener( firstSlaveMonitor );\n\n            HighlyAvailableGraphDatabase secondSlave = clusterManager.getDefaultCluster().getAnySlave( firstSlave );\n            secondSlave.getDependencyResolver().\n                    resolveDependency( Monitors.class ).addMonitorListener( secondSlaveMonitor );\n\n            // WHEN\n            try ( Transaction tx = master.beginTx() )\n            {\n                master.createNode();\n                tx.success();\n            }\n\n            try ( Transaction tx = firstSlave.beginTx() )\n            {\n                firstSlave.createNode();\n                tx.success();\n            }\n\n            try ( Transaction tx = secondSlave.beginTx() )\n            {\n                secondSlave.createNode();\n                tx.success();\n            }\n        }\n        finally\n        {\n            clusterManager.shutdown();\n        }\n\n        // THEN\n        assertEquals( masterMonitor.getRequests().size(), masterMonitor.getRequestsEnded() );\n        assertEquals( firstSlaveMonitor.getRequests().size(), firstSlaveMonitor.getRequestsEnded() );\n        assertEquals( secondSlaveMonitor.getRequests().size(), secondSlaveMonitor.getRequestsEnded() );\n    }","commit_id":"5e3cd8584af3726e097016ca8af206fa56a8086e","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void pullUpdatesShouldUpdateCounters() throws Throwable\n    {\n        // GIVEN\n        ClusterManager clusterManager = new ClusterManager( fromXml( getClass().getResource( \"/threeinstances.xml\" ).toURI() ),\n                TargetDirectory.forTest( getClass() ).cleanDirectory( \"testCluster\" ),\n                MapUtil.stringMap( HaSettings.ha_server.name(), \":6001-6005\",\n                        HaSettings.tx_push_factor.name(), \"0\" ) );\n\n        EideticTransactionMonitor masterMonitor = new EideticTransactionMonitor();\n        EideticTransactionMonitor firstSlaveMonitor = new EideticTransactionMonitor();\n\n        try\n        {\n            clusterManager.start();\n\n            clusterManager.getDefaultCluster().await( allSeesAllAsAvailable() );\n\n            GraphDatabaseAPI master = clusterManager.getDefaultCluster().getMaster();\n            master.getDependencyResolver().resolveDependency( Monitors.class ).addMonitorListener(\n                    masterMonitor, XaResourceManager.class.getName(), NeoStoreXaDataSource.DEFAULT_DATA_SOURCE_NAME );\n\n            HighlyAvailableGraphDatabase firstSlave = clusterManager.getDefaultCluster().getAnySlave();\n            firstSlave.getDependencyResolver().resolveDependency( Monitors.class ).addMonitorListener(\n                    firstSlaveMonitor, XaResourceManager.class.getName(), NeoStoreXaDataSource.DEFAULT_DATA_SOURCE_NAME );\n\n            // WHEN\n            for ( int i = 0; i < 10; i++ )\n            {\n\n                Transaction tx = master.beginTx();\n                master.createNode();\n                tx.success();\n                tx.finish();\n            }\n\n            firstSlave.getDependencyResolver().resolveDependency( UpdatePuller.class ).pullUpdates();\n        }\n        finally\n        {\n            clusterManager.stop();\n        }\n\n        // THEN\n        assertEquals( 0, firstSlaveMonitor.getCommitCount() );\n        assertEquals( 10, firstSlaveMonitor.getInjectOnePhaseCommitCount() );\n        assertEquals( 0, firstSlaveMonitor.getInjectTwoPhaseCommitCount() );\n    }","id":73646,"modified_method":"@Test\n    public void pullUpdatesShouldUpdateCounters() throws Throwable\n    {\n        // GIVEN\n        ClusterManager clusterManager = new ClusterManager( fromXml( getClass().getResource( \"/threeinstances.xml\" ).toURI() ),\n                TargetDirectory.forTest( getClass() ).cleanDirectory( \"testCluster\" ),\n                MapUtil.stringMap( HaSettings.ha_server.name(), \":6001-6005\",\n                        HaSettings.tx_push_factor.name(), \"0\" ) );\n\n        EideticTransactionMonitor masterMonitor = new EideticTransactionMonitor();\n        EideticTransactionMonitor firstSlaveMonitor = new EideticTransactionMonitor();\n\n        try\n        {\n            clusterManager.start();\n\n            clusterManager.getDefaultCluster().await( allSeesAllAsAvailable() );\n\n            GraphDatabaseAPI master = clusterManager.getDefaultCluster().getMaster();\n            master.getDependencyResolver().resolveDependency( Monitors.class ).addMonitorListener(\n                    masterMonitor, XaResourceManager.class.getName(), NeoStoreXaDataSource.DEFAULT_DATA_SOURCE_NAME );\n\n            HighlyAvailableGraphDatabase firstSlave = clusterManager.getDefaultCluster().getAnySlave();\n            firstSlave.getDependencyResolver().resolveDependency( Monitors.class ).addMonitorListener(\n                    firstSlaveMonitor, XaResourceManager.class.getName(), NeoStoreXaDataSource.DEFAULT_DATA_SOURCE_NAME );\n\n            // WHEN\n            for ( int i = 0; i < 10; i++ )\n            {\n\n                try ( Transaction tx = master.beginTx() )\n                {\n                    master.createNode();\n                    tx.success();\n                }\n            }\n\n            firstSlave.getDependencyResolver().resolveDependency( UpdatePuller.class ).pullUpdates();\n        }\n        finally\n        {\n            clusterManager.shutdown();\n        }\n\n        // THEN\n        assertEquals( 0, firstSlaveMonitor.getCommitCount() );\n        assertEquals( 10, firstSlaveMonitor.getInjectOnePhaseCommitCount() );\n        assertEquals( 0, firstSlaveMonitor.getInjectTwoPhaseCommitCount() );\n    }","commit_id":"5e3cd8584af3726e097016ca8af206fa56a8086e","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\r\n\tpublic String getFromAddress() {\r\n\t\treturn organizer.getEmail();\r\n\t}","id":73647,"modified_method":"@Override\r\n\tpublic String getFromAddress() {\r\n\t\treturn StringUtils.defaultIfEmpty(organizer.getEmail(), getServerFromAddress());\r\n\t}","commit_id":"fa775dd09ac2c256c128360b2fe959547b5881af","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\r\n\tpublic String getFromAddress() {\r\n\t\treturn initiator.getEmail();\r\n\t}","id":73648,"modified_method":"@Override\r\n\tpublic String getFromAddress() {\r\n\t\treturn StringUtils.defaultIfEmpty(initiator.getEmail(), getServerFromAddress());\r\n\t}","commit_id":"fa775dd09ac2c256c128360b2fe959547b5881af","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\r\n\tpublic String getFromAddress() {\r\n\t\treturn currentUser.getEmail();\r\n\t}","id":73649,"modified_method":"@Override\r\n\tpublic String getFromAddress() {\r\n\t\treturn StringUtils.defaultIfEmpty(currentUser.getEmail(), getServerFromAddress());\r\n\t}","commit_id":"fa775dd09ac2c256c128360b2fe959547b5881af","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n\tpublic String getFromAddress() {\n\t\treturn organizer.getEmail();\n\t}","id":73650,"modified_method":"@Override\n\tpublic String getFromAddress() {\n\t\treturn StringUtils.defaultIfEmpty(organizer.getEmail(), getServerFromAddress());\n\t}","commit_id":"fa775dd09ac2c256c128360b2fe959547b5881af","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\r\n\tpublic String getFromAddress() {\r\n\t\treturn organizer.getEmail();\r\n\t}","id":73651,"modified_method":"@Override\r\n\tpublic String getFromAddress() {\r\n\t\treturn StringUtils.defaultIfEmpty(organizer.getEmail(), getServerFromAddress());\r\n\t}","commit_id":"fa775dd09ac2c256c128360b2fe959547b5881af","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\r\n\tpublic String getFromAddress() {\r\n\t\treturn organizer.getEmail();\r\n\t}","id":73652,"modified_method":"@Override\r\n\tpublic String getFromAddress() {\r\n\t\treturn StringUtils.defaultIfEmpty(organizer.getEmail(), getServerFromAddress());\r\n\t}","commit_id":"fa775dd09ac2c256c128360b2fe959547b5881af","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\r\n\tpublic String getFromAddress() {\r\n\t\treturn creator.getEmail();\r\n\t}","id":73653,"modified_method":"@Override\r\n\tpublic String getFromAddress() {\r\n\t\treturn StringUtils.defaultIfEmpty(creator.getEmail(), getServerFromAddress());\r\n\t}","commit_id":"fa775dd09ac2c256c128360b2fe959547b5881af","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\r\n\tpublic String getFromAddress() {\r\n\t\treturn organizer.getEmail();\r\n\t}","id":73654,"modified_method":"@Override\r\n\tpublic String getFromAddress() {\r\n\t\treturn StringUtils.defaultIfEmpty(organizer.getEmail(), getServerFromAddress());\r\n\t}","commit_id":"fa775dd09ac2c256c128360b2fe959547b5881af","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\r\n\t * Helper to convert a signup email notification into a Sakai EmailMessage, which can encapsulate attachments.\r\n\t * \r\n\t * <p>Due to the way the email objects are created, ie one per email that needs to be sent, not one per user, we cannot store any\r\n\t * user specific attachments within the email objects themselves. So this method assembles an EmailMessage per user\r\n\t * \r\n\t * @param email\t- the signup email obj we will extract info from\r\n\t * @param recipients - list of users to receive email\r\n\t * @return\r\n\t */\r\n\tprivate EmailMessage convertSignupEmail(SignupEmailNotification email, User recipient) {\r\n\t\t\r\n\t\tEmailMessage message = new EmailMessage();\r\n\t\t\t\r\n\t\t//setup message\r\n\t\tmessage.setHeaders(email.getHeader());\r\n\t\tmessage.setBody(email.getMessage());\r\n\t\t\r\n\t\t//note that the headers are largely ignored so we need to repeat some things here that are actually in the headers\r\n\t\t//if these are eventaully converted to proper email templates, this should be alleviated\r\n\t\tmessage.setSubject(email.getSubject());\r\n\t\tmessage.setFrom(email.getFromAddress());\r\n\t\tmessage.setContentType(\"text/html; charset=UTF-8\");\r\n\t\t\r\n\t\tfor(Attachment a: collectAttachments(email, recipient)){\r\n\t\t\tmessage.addAttachment(a);\r\n\t\t}\r\n\t\t\r\n\t\t//add recipient, only if valid email\r\n\t\tString emailAddress = recipient.getEmail();\r\n\t\tif(StringUtils.isNotBlank(emailAddress) && EmailValidator.getInstance().isValid(emailAddress)) {\r\n\t\t\tmessage.addRecipient(EmailAddress.RecipientType.TO, recipient.getDisplayName(), emailAddress);\r\n\t\t} else {\r\n\t\t\tlogger.error(\"Invalid email: \" + emailAddress + \" for user:\" + recipient.getDisplayId());\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\t\t\t\r\n\t\treturn message;\r\n\t}","id":73655,"modified_method":"/**\r\n\t * Helper to convert a signup email notification into a Sakai EmailMessage, which can encapsulate attachments.\r\n\t * \r\n\t * <p>Due to the way the email objects are created, ie one per email that needs to be sent, not one per user, we cannot store any\r\n\t * user specific attachments within the email objects themselves. So this method assembles an EmailMessage per user\r\n\t * \r\n\t * @param email\t- the signup email obj we will extract info from\r\n\t * @param recipients - list of users to receive email\r\n\t * @return\r\n\t */\r\n\tprivate EmailMessage convertSignupEmail(SignupEmailNotification email, User recipient) {\r\n\t\t\r\n\t\tEmailMessage message = new EmailMessage();\r\n\t\t\t\r\n\t\t//setup message\r\n\t\tmessage.setHeaders(email.getHeader());\r\n\t\tmessage.setBody(email.getMessage());\r\n\t\t\r\n\t\t//note that the headers are largely ignored so we need to repeat some things here that are actually in the headers\r\n\t\t//if these are eventaully converted to proper email templates, this should be alleviated\r\n\t\tmessage.setSubject(email.getSubject());\r\n\t\t\r\n\t\tlogger.debug(\"email.getFromAddress(): \" + email.getFromAddress());\r\n\t\t\r\n\t\tmessage.setFrom(email.getFromAddress());\r\n\t\tmessage.setContentType(\"text/html; charset=UTF-8\");\r\n\t\t\r\n\t\tfor(Attachment a: collectAttachments(email, recipient)){\r\n\t\t\tmessage.addAttachment(a);\r\n\t\t}\r\n\t\t\r\n\t\t//add recipient, only if valid email\r\n\t\tString emailAddress = recipient.getEmail();\r\n\t\tif(StringUtils.isNotBlank(emailAddress) && EmailValidator.getInstance().isValid(emailAddress)) {\r\n\t\t\tmessage.addRecipient(EmailAddress.RecipientType.TO, recipient.getDisplayName(), emailAddress);\r\n\t\t} else {\r\n\t\t\tlogger.error(\"Invalid email for user:\" + recipient.getDisplayId() + \". No email will be sent to this user\");\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\t\t\t\r\n\t\treturn message;\r\n\t}","commit_id":"fa775dd09ac2c256c128360b2fe959547b5881af","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void sendEmail(User user, SignupEmailNotification email) {\r\n\t\t\r\n\t\tlogger.debug(\"sendMail called for user:\" + user.getEid());\r\n\t\t\r\n\t\ttry {\r\n\t\t\tEmailMessage message = convertSignupEmail(email, user);\r\n\t\t\t\r\n\t\t\tif(message != null) {\r\n\t\t\t\temailService.send(message);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} catch (NoRecipientsException e) {\r\n\t\t\tlogger.error(\"Cannot send mail. No recipient.\" + e.getMessage());\r\n\t\t} catch (AddressValidationException e) {\r\n\t\t\t//this should be caught when adding the email address, since it is validated then.\r\n\t\t\tlogger.warn(\"Cannot send mail. Invalid email address.\" + EmailAddress.toString(e.getInvalidEmailAddresses()));\r\n\t\t}\r\n\t\t\r\n\t}","id":73656,"modified_method":"private void sendEmail(User user, SignupEmailNotification email) {\r\n\t\t\r\n\t\tlogger.debug(\"sendMail called for user:\" + user.getEid());\r\n\t\t\r\n\t\ttry {\r\n\t\t\tEmailMessage message = convertSignupEmail(email, user);\r\n\t\t\t\r\n\t\t\tif(message != null) {\r\n\t\t\t\temailService.send(message);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} catch (NoRecipientsException e) {\r\n\t\t\tlogger.error(\"Cannot send mail. No recipient.\" + e.getMessage());\r\n\t\t} catch (AddressValidationException e) {\r\n\t\t\t//this should be caught when adding the email address, since it is validated then.\r\n\t\t\tlogger.warn(\"Cannot send mail to user: \" +  user.getEid() + \". Invalid email address.\" + EmailAddress.toString(e.getInvalidEmailAddresses()));\r\n\t\t}\r\n\t\t\r\n\t}","commit_id":"fa775dd09ac2c256c128360b2fe959547b5881af","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\r\n\tpublic String getFromAddress() {\r\n\t\treturn organizer.getEmail();\r\n\t}","id":73657,"modified_method":"@Override\r\n\tpublic String getFromAddress() {\r\n\t\treturn StringUtils.defaultIfEmpty(organizer.getEmail(), getServerFromAddress());\r\n\t}","commit_id":"fa775dd09ac2c256c128360b2fe959547b5881af","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void constructTaskReport() {\n    loadAllTaskAttempts();\n    this.report = Records.newRecord(TaskReport.class);\n    report.setTaskId(taskId);\n    report.setStartTime(taskInfo.getStartTime());\n    report.setFinishTime(taskInfo.getFinishTime());\n    report.setTaskState(getState());\n    report.setProgress(getProgress());\n    report.setCounters(TypeConverter.toYarn(getCounters()));\n    if (successfulAttempt != null) {\n      report.setSuccessfulAttempt(successfulAttempt);\n    }\n    report.addAllDiagnostics(reportDiagnostics);\n    report\n        .addAllRunningAttempts(new ArrayList<TaskAttemptId>(attempts.keySet()));\n  }","id":73658,"modified_method":"private void constructTaskReport() {\n    loadAllTaskAttempts();\n    this.report = Records.newRecord(TaskReport.class);\n    report.setTaskId(taskId);\n    report.setStartTime(taskInfo.getStartTime());\n    report.setFinishTime(taskInfo.getFinishTime());\n    report.setTaskState(getState());\n    report.setProgress(getProgress());\n    Counters counters = getCounters();\n    if (counters == null) {\n      counters = EMPTY_COUNTERS;\n    }\n    report.setCounters(TypeConverter.toYarn(counters));\n    if (successfulAttempt != null) {\n      report.setSuccessfulAttempt(successfulAttempt);\n    }\n    report.addAllDiagnostics(reportDiagnostics);\n    report\n        .addAllRunningAttempts(new ArrayList<TaskAttemptId>(attempts.keySet()));\n  }","commit_id":"b897d6c35a0036ab8b6a73f8dc76064f351b612d","url":"https://github.com/apache/hadoop"},{"original_method":"@Override protected void render(Block html) {\n    if (job == null) {\n      html.\n        p()._(\"Sorry, no counters for nonexistent\", $(JOB_ID, \"job\"))._();\n      return;\n    }\n    if (!$(TASK_ID).isEmpty() && task == null) {\n      html.\n        p()._(\"Sorry, no counters for nonexistent\", $(TASK_ID, \"task\"))._();\n      return;\n    }\n    \n    if(total == null || total.getAllCounterGroups() == null || \n        total.getAllCounterGroups().size() <= 0) {\n      String type = $(TASK_ID);\n      if(type == null || type.isEmpty()) {\n        type = $(JOB_ID, \"the job\");\n      }\n      html.\n        p()._(\"Sorry it looks like \",type,\" has no counters.\")._();\n      return;\n    }\n    \n    String urlBase;\n    String urlId;\n    if(task != null) {\n      urlBase = \"singletaskcounter\";\n      urlId = MRApps.toString(task.getID());\n    } else {\n      urlBase = \"singlejobcounter\";\n      urlId = MRApps.toString(job.getID());\n    }\n    \n    \n    int numGroups = 0;\n    TBODY<TABLE<DIV<Hamlet>>> tbody = html.\n      div(_INFO_WRAP).\n      table(\"#counters\").\n        thead().\n          tr().\n            th(\".group.ui-state-default\", \"Counter Group\").\n            th(\".ui-state-default\", \"Counters\")._()._().\n        tbody();\n    for (CounterGroup g : total.getAllCounterGroups().values()) {\n      CounterGroup mg = map == null ? null : map.getCounterGroup(g.getName());\n      CounterGroup rg = reduce == null ? null : reduce.getCounterGroup(g.getName());\n      ++numGroups;\n      // This is mostly for demonstration :) Typically we'd introduced\n      // a CounterGroup block to reduce the verbosity. OTOH, this\n      // serves as an indicator of where we're in the tag hierarchy.\n      TR<THEAD<TABLE<TD<TR<TBODY<TABLE<DIV<Hamlet>>>>>>>> groupHeadRow = tbody.\n        tr().\n          th().$title(g.getName()).$class(\"ui-state-default\").\n            _(fixGroupDisplayName(g.getDisplayName()))._().\n          td().$class(C_TABLE).\n            table(\".dt-counters\").\n              thead().\n                tr().th(\".name\", \"Name\");\n\n      if (map != null) {\n        groupHeadRow.th(\"Map\").th(\"Reduce\");\n      }\n      // Ditto\n      TBODY<TABLE<TD<TR<TBODY<TABLE<DIV<Hamlet>>>>>>> group = groupHeadRow.\n            th(map == null ? \"Value\" : \"Total\")._()._().\n        tbody();\n      for (Counter counter : g.getAllCounters().values()) {\n        // Ditto\n        TR<TBODY<TABLE<TD<TR<TBODY<TABLE<DIV<Hamlet>>>>>>>> groupRow = group.\n          tr();\n          if (mg == null && rg == null) {\n            groupRow.td().$title(counter.getName())._(counter.getDisplayName()).\n            _();\n          } else {\n            groupRow.td().$title(counter.getName()).\n              a(url(urlBase,urlId,g.getName(), \n                  counter.getName()), counter.getDisplayName()).\n            _();\n          }\n        if (map != null) {\n          Counter mc = mg == null ? null : mg.getCounter(counter.getName());\n          Counter rc = rg == null ? null : rg.getCounter(counter.getName());\n          groupRow.\n            td(mc == null ? \"0\" : String.valueOf(mc.getValue())).\n            td(rc == null ? \"0\" : String.valueOf(rc.getValue()));\n        }\n        groupRow.td(String.valueOf(counter.getValue()))._();\n      }\n      group._()._()._()._();\n    }\n    tbody._()._()._();\n  }","id":73659,"modified_method":"@Override protected void render(Block html) {\n    if (job == null) {\n      html.\n        p()._(\"Sorry, no counters for nonexistent\", $(JOB_ID, \"job\"))._();\n      return;\n    }\n    if (!$(TASK_ID).isEmpty() && task == null) {\n      html.\n        p()._(\"Sorry, no counters for nonexistent\", $(TASK_ID, \"task\"))._();\n      return;\n    }\n    \n    if(total == null || total.getAllCounterGroups() == null || \n        total.getAllCounterGroups().size() <= 0) {\n      String type = $(TASK_ID);\n      if(type == null || type.isEmpty()) {\n        type = $(JOB_ID, \"the job\");\n      }\n      html.\n        p()._(\"Sorry it looks like \",type,\" has no counters.\")._();\n      return;\n    }\n    \n    String urlBase;\n    String urlId;\n    if(task != null) {\n      urlBase = \"singletaskcounter\";\n      urlId = MRApps.toString(task.getID());\n    } else {\n      urlBase = \"singlejobcounter\";\n      urlId = MRApps.toString(job.getID());\n    }\n    \n    \n    int numGroups = 0;\n    TBODY<TABLE<DIV<Hamlet>>> tbody = html.\n      div(_INFO_WRAP).\n      table(\"#counters\").\n        thead().\n          tr().\n            th(\".group.ui-state-default\", \"Counter Group\").\n            th(\".ui-state-default\", \"Counters\")._()._().\n        tbody();\n    for (CounterGroup g : total.getAllCounterGroups().values()) {\n      CounterGroup mg = map == null ? null : map.getCounterGroup(g.getName());\n      CounterGroup rg = reduce == null ? null : reduce.getCounterGroup(g.getName());\n      ++numGroups;\n      // This is mostly for demonstration :) Typically we'd introduced\n      // a CounterGroup block to reduce the verbosity. OTOH, this\n      // serves as an indicator of where we're in the tag hierarchy.\n      TR<THEAD<TABLE<TD<TR<TBODY<TABLE<DIV<Hamlet>>>>>>>> groupHeadRow = tbody.\n        tr().\n          th().$title(g.getName()).$class(\"ui-state-default\").\n            _(fixGroupDisplayName(g.getDisplayName()))._().\n          td().$class(C_TABLE).\n            table(\".dt-counters\").\n              thead().\n                tr().th(\".name\", \"Name\");\n\n      if (map != null) {\n        groupHeadRow.th(\"Map\").th(\"Reduce\");\n      }\n      // Ditto\n      TBODY<TABLE<TD<TR<TBODY<TABLE<DIV<Hamlet>>>>>>> group = groupHeadRow.\n            th(map == null ? \"Value\" : \"Total\")._()._().\n        tbody();\n      for (Counter counter : g.getAllCounters().values()) {\n        // Ditto\n        TR<TBODY<TABLE<TD<TR<TBODY<TABLE<DIV<Hamlet>>>>>>>> groupRow = group.\n          tr();\n          if (task == null && mg == null && rg == null) {\n            groupRow.td().$title(counter.getName())._(counter.getDisplayName()).\n            _();\n          } else {\n            groupRow.td().$title(counter.getName()).\n              a(url(urlBase,urlId,g.getName(), \n                  counter.getName()), counter.getDisplayName()).\n            _();\n          }\n        if (map != null) {\n          Counter mc = mg == null ? null : mg.getCounter(counter.getName());\n          Counter rc = rg == null ? null : rg.getCounter(counter.getName());\n          groupRow.\n            td(mc == null ? \"0\" : String.valueOf(mc.getValue())).\n            td(rc == null ? \"0\" : String.valueOf(rc.getValue()));\n        }\n        groupRow.td(String.valueOf(counter.getValue()))._();\n      }\n      group._()._()._()._();\n    }\n    tbody._()._()._();\n  }","commit_id":"c2fe4a7e83775589481210383f62faa2dcb00ecc","url":"https://github.com/apache/hadoop"},{"original_method":"private void populateMembers(AppContext ctx) {\n    JobId jobID = null;\n    TaskId taskID = null;\n    String tid = $(TASK_ID);\n    if (!tid.isEmpty()) {\n      taskID = MRApps.toTaskID(tid);\n      jobID = taskID.getJobId();\n    } else {\n      String jid = $(JOB_ID);\n      if (!jid.isEmpty()) {\n        jobID = MRApps.toJobID(jid);\n      }\n    }\n    if (jobID == null) {\n      return;\n    }\n    job = ctx.getJob(jobID);\n    if (job == null) {\n      return;\n    }\n    if (taskID != null) {\n      task = job.getTask(taskID);\n      if (task == null) {\n        return;\n      }\n      for(Map.Entry<TaskAttemptId, TaskAttempt> entry : \n        task.getAttempts().entrySet()) {\n        long value = 0;\n        CounterGroup group = entry.getValue().getCounters()\n        .getCounterGroup($(COUNTER_GROUP));\n        if(group != null)  {\n          Counter c = group.getCounter($(COUNTER_NAME));\n          if(c != null) {\n            value = c.getValue();\n          }\n        }\n        values.put(MRApps.toString(entry.getKey()), value);\n      }\n      \n      return;\n    }\n    // Get all types of counters\n    Map<TaskId, Task> tasks = job.getTasks();\n    for(Map.Entry<TaskId, Task> entry : tasks.entrySet()) {\n      long value = 0;\n      CounterGroup group = entry.getValue().getCounters()\n      .getCounterGroup($(COUNTER_GROUP));\n      if(group != null)  {\n        Counter c = group.getCounter($(COUNTER_NAME));\n        if(c != null) {\n          value = c.getValue();\n        }\n      }\n      values.put(MRApps.toString(entry.getKey()), value);\n    }\n  }","id":73660,"modified_method":"private void populateMembers(AppContext ctx) {\n    JobId jobID = null;\n    TaskId taskID = null;\n    String tid = $(TASK_ID);\n    if (!tid.isEmpty()) {\n      taskID = MRApps.toTaskID(tid);\n      jobID = taskID.getJobId();\n    } else {\n      String jid = $(JOB_ID);\n      if (!jid.isEmpty()) {\n        jobID = MRApps.toJobID(jid);\n      }\n    }\n    if (jobID == null) {\n      return;\n    }\n    job = ctx.getJob(jobID);\n    if (job == null) {\n      return;\n    }\n    if (taskID != null) {\n      task = job.getTask(taskID);\n      if (task == null) {\n        return;\n      }\n      for(Map.Entry<TaskAttemptId, TaskAttempt> entry : \n        task.getAttempts().entrySet()) {\n        long value = 0;\n        Counters counters = entry.getValue().getCounters();\n        CounterGroup group = (counters != null)\n        \t\t? counters.getCounterGroup($(COUNTER_GROUP)) : null;\n        if(group != null)  {\n          Counter c = group.getCounter($(COUNTER_NAME));\n          if(c != null) {\n            value = c.getValue();\n          }\n        }\n        values.put(MRApps.toString(entry.getKey()), value);\n      }\n      \n      return;\n    }\n    // Get all types of counters\n    Map<TaskId, Task> tasks = job.getTasks();\n    for(Map.Entry<TaskId, Task> entry : tasks.entrySet()) {\n      long value = 0;\n      CounterGroup group = entry.getValue().getCounters()\n      .getCounterGroup($(COUNTER_GROUP));\n      if(group != null)  {\n        Counter c = group.getCounter($(COUNTER_NAME));\n        if(c != null) {\n          value = c.getValue();\n        }\n      }\n      values.put(MRApps.toString(entry.getKey()), value);\n    }\n  }","commit_id":"c2fe4a7e83775589481210383f62faa2dcb00ecc","url":"https://github.com/apache/hadoop"},{"original_method":"public static Map<String, String> getTaskParams(AppContext appContext) {\n    JobId jobId = appContext.getAllJobs().entrySet().iterator().next().getKey();\n    Entry<TaskId, Task> e = appContext.getJob(jobId).getTasks().entrySet().iterator().next();\n    e.getValue().getType();\n    Map<String, String> params = new HashMap<String, String>();\n    params.put(AMParams.JOB_ID, MRApps.toString(jobId));\n    params.put(AMParams.TASK_ID, e.getKey().toString());\n    params.put(AMParams.TASK_TYPE, MRApps.taskSymbol(e.getValue().getType()));\n    return params;\n  }","id":73661,"modified_method":"public static Map<String, String> getTaskParams(AppContext appContext) {\n    JobId jobId = appContext.getAllJobs().entrySet().iterator().next().getKey();\n    Entry<TaskId, Task> e = appContext.getJob(jobId).getTasks().entrySet().iterator().next();\n    e.getValue().getType();\n    Map<String, String> params = new HashMap<String, String>();\n    params.put(AMParams.JOB_ID, MRApps.toString(jobId));\n    params.put(AMParams.TASK_ID, MRApps.toString(e.getKey()));\n    params.put(AMParams.TASK_TYPE, MRApps.taskSymbol(e.getValue().getType()));\n    return params;\n  }","commit_id":"c2fe4a7e83775589481210383f62faa2dcb00ecc","url":"https://github.com/apache/hadoop"},{"original_method":"private void populateMembers(AppContext ctx) {\n    JobId jobID = null;\n    TaskId taskID = null;\n    String tid = $(TASK_ID);\n    if (!tid.isEmpty()) {\n      taskID = MRApps.toTaskID(tid);\n      jobID = taskID.getJobId();\n    } else {\n      String jid = $(JOB_ID);\n      if (!jid.isEmpty()) {\n        jobID = MRApps.toJobID(jid);\n      }\n    }\n    if (jobID == null) {\n      return;\n    }\n    job = ctx.getJob(jobID);\n    if (job == null) {\n      return;\n    }\n    if (taskID != null) {\n      task = job.getTask(taskID);\n      if (task == null) {\n        return;\n      }\n      for(Map.Entry<TaskAttemptId, TaskAttempt> entry : \n        task.getAttempts().entrySet()) {\n        long value = 0;\n        Counters counters = entry.getValue().getCounters();\n        CounterGroup group = (counters != null) ? counters\n          .getGroup($(COUNTER_GROUP)) : null;\n        if(group != null)  {\n          Counter c = group.findCounter($(COUNTER_NAME));\n          if(c != null) {\n            value = c.getValue();\n          }\n        }\n        values.put(MRApps.toString(entry.getKey()), value);\n      }\n      \n      return;\n    }\n    // Get all types of counters\n    Map<TaskId, Task> tasks = job.getTasks();\n    for(Map.Entry<TaskId, Task> entry : tasks.entrySet()) {\n      long value = 0;\n      CounterGroup group = entry.getValue().getCounters()\n        .getGroup($(COUNTER_GROUP));\n      if(group != null)  {\n        Counter c = group.findCounter($(COUNTER_NAME));\n        if(c != null) {\n          value = c.getValue();\n        }\n      }\n      values.put(MRApps.toString(entry.getKey()), value);\n    }\n  }","id":73662,"modified_method":"private void populateMembers(AppContext ctx) {\n    JobId jobID = null;\n    TaskId taskID = null;\n    String tid = $(TASK_ID);\n    if (!tid.isEmpty()) {\n      taskID = MRApps.toTaskID(tid);\n      jobID = taskID.getJobId();\n    } else {\n      String jid = $(JOB_ID);\n      if (!jid.isEmpty()) {\n        jobID = MRApps.toJobID(jid);\n      }\n    }\n    if (jobID == null) {\n      return;\n    }\n    job = ctx.getJob(jobID);\n    if (job == null) {\n      return;\n    }\n    if (taskID != null) {\n      task = job.getTask(taskID);\n      if (task == null) {\n        return;\n      }\n      for(Map.Entry<TaskAttemptId, TaskAttempt> entry : \n        task.getAttempts().entrySet()) {\n        long value = 0;\n        Counters counters = entry.getValue().getCounters();\n        CounterGroup group = (counters != null) ? counters\n          .getGroup($(COUNTER_GROUP)) : null;\n        if(group != null)  {\n          Counter c = group.findCounter($(COUNTER_NAME));\n          if(c != null) {\n            value = c.getValue();\n          }\n        }\n        values.put(MRApps.toString(entry.getKey()), value);\n      }\n      \n      return;\n    }\n    // Get all types of counters\n    Map<TaskId, Task> tasks = job.getTasks();\n    for(Map.Entry<TaskId, Task> entry : tasks.entrySet()) {\n      long value = 0;\n      Counters counters = entry.getValue().getCounters();\n      CounterGroup group = (counters != null) ? counters\n        .getGroup($(COUNTER_GROUP)) : null;\n      if(group != null)  {\n        Counter c = group.findCounter($(COUNTER_NAME));\n        if(c != null) {\n          value = c.getValue();\n        }\n      }\n      values.put(MRApps.toString(entry.getKey()), value);\n    }\n  }","commit_id":"ca2265b581a0eccbd366a9a1b504a61eb67d23df","url":"https://github.com/apache/hadoop"},{"original_method":"@Test public void testSingleCounterView() {\n    AppContext appContext = new TestAppContext();\n    Map<String, String> params = getJobParams(appContext);\n    params.put(AMParams.COUNTER_GROUP, \n        \"org.apache.hadoop.mapreduce.FileSystemCounter\");\n    params.put(AMParams.COUNTER_NAME, \"HDFS_WRITE_OPS\");\n    WebAppTests.testPage(SingleCounterPage.class, AppContext.class,\n                         appContext, params);\n  }","id":73663,"modified_method":"@Test public void testSingleCounterView() {\n    AppContext appContext = new TestAppContext();\n    Job job = appContext.getAllJobs().values().iterator().next();\n    // add a failed task to the job without any counters\n    Task failedTask = MockJobs.newTask(job.getID(), 2, 1, true);\n    Map<TaskId,Task> tasks = job.getTasks();\n    tasks.put(failedTask.getID(), failedTask);\n    Map<String, String> params = getJobParams(appContext);\n    params.put(AMParams.COUNTER_GROUP, \n        \"org.apache.hadoop.mapreduce.FileSystemCounter\");\n    params.put(AMParams.COUNTER_NAME, \"HDFS_WRITE_OPS\");\n    WebAppTests.testPage(SingleCounterPage.class, AppContext.class,\n                         appContext, params);\n  }","commit_id":"ca2265b581a0eccbd366a9a1b504a61eb67d23df","url":"https://github.com/apache/hadoop"},{"original_method":"private Pair<PsiType, ConstraintType> inferMethodTypeParameterFromParent(PsiElement parent,\n                                                     PsiMethodCallExpression methodCall,\n                                                     final PsiTypeParameter typeParameter,\n                                                     PsiSubstitutor substitutor,\n                                                     final boolean forCompletion) {\n    Pair<PsiType, ConstraintType> constraint = null;\n    PsiType expectedType = null;\n\n    if (parent instanceof PsiVariable && methodCall.equals(((PsiVariable)parent).getInitializer())) {\n      expectedType = ((PsiVariable)parent).getType();\n    }\n    else if (parent instanceof PsiAssignmentExpression && methodCall.equals(((PsiAssignmentExpression)parent).getRExpression())) {\n      expectedType = ((PsiAssignmentExpression)parent).getLExpression().getType();\n    }\n    else if (parent instanceof PsiReturnStatement) {\n      PsiMethod method = PsiTreeUtil.getParentOfType(parent, PsiMethod.class);\n      if (method != null) {\n        expectedType = method.getReturnType();\n      }\n    }\n    else if (parent instanceof PsiExpressionList && forCompletion) {\n      final PsiElement pParent = parent.getParent();\n      if (pParent instanceof PsiCallExpression && parent.equals(((PsiCallExpression)pParent).getArgumentList())) {\n        constraint = inferTypeForCompletionFromCallContext(methodCall, (PsiExpressionList)parent, (PsiCallExpression)pParent, typeParameter);\n      }\n    }\n\n    final PsiManager manager = typeParameter.getManager();\n    final GlobalSearchScope scope = parent.getResolveScope();\n    PsiType returnType = null;\n    if (constraint == null) {\n      if (expectedType == null) {\n        expectedType = forCompletion ?\n               PsiType.NULL :\n               PsiType.getJavaLangObject(manager, scope);\n      }\n\n      returnType = ((PsiMethod)typeParameter.getOwner()).getReturnType();\n\n      constraint = getSubstitutionForTypeParameterConstraint(typeParameter, returnType, expectedType, false, PsiUtil.getLanguageLevel(parent));\n    }\n\n    final Pair<PsiType, ConstraintType> result;\n    if (constraint == null) {\n      final PsiSubstitutor finalSubstitutor = substitutor.put(typeParameter, null);\n      PsiType superType = finalSubstitutor.substitute(typeParameter.getSuperTypes()[0]);\n      if (superType == null) superType = PsiType.getJavaLangObject(manager, scope);\n      if (superType == null) return null;\n      if (forCompletion && !(superType instanceof PsiWildcardType)) {\n        result = new Pair<PsiType, ConstraintType>(PsiWildcardType.createExtends(manager, superType), ConstraintType.EQUALS);\n      }\n      else {\n        result = new Pair<PsiType, ConstraintType>(superType, ConstraintType.SUBTYPE);\n      }\n    }\n    else {\n      PsiType guess = constraint.getFirst();\n      if (forCompletion && guess != null && !(guess instanceof PsiWildcardType)) {\n        if (constraint.getSecond() == ConstraintType.SUPERTYPE) guess = PsiWildcardType.createExtends(manager, guess);\n        else if (constraint.getSecond() == ConstraintType.SUBTYPE) guess = PsiWildcardType.createSuper(manager, guess);\n      }\n\n      //The following code is the result of deep thought, do not shit it out before discussing with [ven]\n      if (returnType instanceof PsiClassType && typeParameter.equals(((PsiClassType)returnType).resolve())) {\n        PsiClassType[] extendsTypes = typeParameter.getExtendsListTypes();\n        PsiSubstitutor newSubstitutor = substitutor.put(typeParameter, guess);\n        for (PsiClassType extendsType1 : extendsTypes) {\n          PsiType extendsType = newSubstitutor.substitute(extendsType1);\n          if (guess != null && !extendsType.isAssignableFrom(guess)) {\n            if (guess.isAssignableFrom(extendsType)) {\n              guess = extendsType;\n              newSubstitutor = substitutor.put(typeParameter, guess);\n            }\n            else {\n              break;\n            }\n          }\n        }\n      }\n\n      result = new Pair<PsiType, ConstraintType>(guess, constraint.getSecond());\n    }\n    return result;\n  }","id":73664,"modified_method":"private Pair<PsiType, ConstraintType> inferMethodTypeParameterFromParent(PsiElement parent,\n                                                     PsiMethodCallExpression methodCall,\n                                                     final PsiTypeParameter typeParameter,\n                                                     PsiSubstitutor substitutor,\n                                                     final boolean forCompletion) {\n    Pair<PsiType, ConstraintType> constraint = null;\n    PsiType expectedType = null;\n\n    if (parent instanceof PsiVariable && methodCall.equals(((PsiVariable)parent).getInitializer())) {\n      expectedType = ((PsiVariable)parent).getType();\n    }\n    else if (parent instanceof PsiAssignmentExpression && methodCall.equals(((PsiAssignmentExpression)parent).getRExpression())) {\n      expectedType = ((PsiAssignmentExpression)parent).getLExpression().getType();\n    }\n    else if (parent instanceof PsiReturnStatement) {\n      PsiMethod method = PsiTreeUtil.getParentOfType(parent, PsiMethod.class);\n      if (method != null) {\n        expectedType = method.getReturnType();\n      }\n    }\n    else if (parent instanceof PsiExpressionList && forCompletion) {\n      final PsiElement pParent = parent.getParent();\n      if (pParent instanceof PsiCallExpression && parent.equals(((PsiCallExpression)pParent).getArgumentList())) {\n        constraint = inferTypeForCompletionFromCallContext(methodCall, (PsiExpressionList)parent, (PsiCallExpression)pParent, typeParameter);\n      }\n    }\n\n    final PsiManager manager = typeParameter.getManager();\n    final GlobalSearchScope scope = parent.getResolveScope();\n    PsiType returnType = null;\n    if (constraint == null) {\n      if (expectedType == null) {\n        expectedType = forCompletion ?\n               PsiType.NULL :\n               PsiType.getJavaLangObject(manager, scope);\n      }\n\n      returnType = ((PsiMethod)typeParameter.getOwner()).getReturnType();\n\n      constraint = getSubstitutionForTypeParameterConstraint(typeParameter, returnType, expectedType, false, PsiUtil.getLanguageLevel(parent));\n    }\n\n    final Pair<PsiType, ConstraintType> result;\n    if (constraint == null) {\n      final PsiSubstitutor finalSubstitutor = substitutor.put(typeParameter, null);\n      PsiClassType[] superTypes = typeParameter.getSuperTypes();\n      if (superTypes.length == 0) return null;\n      PsiType superType = finalSubstitutor.substitute(superTypes[0]);\n      if (superType == null) superType = PsiType.getJavaLangObject(manager, scope);\n      if (superType == null) return null;\n      if (forCompletion && !(superType instanceof PsiWildcardType)) {\n        result = new Pair<PsiType, ConstraintType>(PsiWildcardType.createExtends(manager, superType), ConstraintType.EQUALS);\n      }\n      else {\n        result = new Pair<PsiType, ConstraintType>(superType, ConstraintType.SUBTYPE);\n      }\n    }\n    else {\n      PsiType guess = constraint.getFirst();\n      if (forCompletion && guess != null && !(guess instanceof PsiWildcardType)) {\n        if (constraint.getSecond() == ConstraintType.SUPERTYPE) guess = PsiWildcardType.createExtends(manager, guess);\n        else if (constraint.getSecond() == ConstraintType.SUBTYPE) guess = PsiWildcardType.createSuper(manager, guess);\n      }\n\n      //The following code is the result of deep thought, do not shit it out before discussing with [ven]\n      if (returnType instanceof PsiClassType && typeParameter.equals(((PsiClassType)returnType).resolve())) {\n        PsiClassType[] extendsTypes = typeParameter.getExtendsListTypes();\n        PsiSubstitutor newSubstitutor = substitutor.put(typeParameter, guess);\n        for (PsiClassType extendsType1 : extendsTypes) {\n          PsiType extendsType = newSubstitutor.substitute(extendsType1);\n          if (guess != null && !extendsType.isAssignableFrom(guess)) {\n            if (guess.isAssignableFrom(extendsType)) {\n              guess = extendsType;\n              newSubstitutor = substitutor.put(typeParameter, guess);\n            }\n            else {\n              break;\n            }\n          }\n        }\n      }\n\n      result = new Pair<PsiType, ConstraintType>(guess, constraint.getSecond());\n    }\n    return result;\n  }","commit_id":"3135844bbd5fe901cdcb29b0e9171610667d6984","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @param methodSignature\n   * @param superMethodSignature\n   * @return null if signatures do not match\n   */\n  public static PsiSubstitutor getSuperMethodSignatureSubstitutor(MethodSignature methodSignature, MethodSignature superMethodSignature) {\n    PsiSubstitutor result = getSuperMethodSignatureSubstitutorImpl(methodSignature, superMethodSignature);\n    if (result == null) return null;\n\n    PsiTypeParameter[] methoTypeParameters = methodSignature.getTypeParameters();\n    PsiTypeParameter[] superTypeParameters = superMethodSignature.getTypeParameters();\n    PsiSubstitutor methodSubstitutor = methodSignature.getSubstitutor();\n\n    //check bounds\n    for (int i = 0; i < methoTypeParameters.length; i++) {\n      PsiTypeParameter methoTypeParameter = methoTypeParameters[i];\n      PsiTypeParameter superTypeParameter = superTypeParameters[i];\n      final PsiClassType[] methoSupers = methoTypeParameter.getSuperTypes();\n      final PsiClassType[] superSupers = superTypeParameter.getSuperTypes();\n      if (methoSupers.length != superSupers.length) return null;\n      for (int j = 0; j < methoSupers.length; j++) {\n        PsiType type1 = methodSubstitutor.substitute(methoSupers[j]);\n        PsiType type2 = methodSubstitutor.substitute(PsiUtil.captureToplevelWildcards(result.substitute(superSupers[j]), methoTypeParameter));\n        if (!type1.equals(type2)) return null;\n      }\n    }\n    return result;\n  }","id":73665,"modified_method":"/**\n   * @param methodSignature\n   * @param superMethodSignature\n   * @return null if signatures do not match\n   */\n  public static PsiSubstitutor getSuperMethodSignatureSubstitutor(MethodSignature methodSignature, MethodSignature superMethodSignature) {\n    PsiSubstitutor result = getSuperMethodSignatureSubstitutorImpl(methodSignature, superMethodSignature);\n    if (result == null) return null;\n\n    PsiTypeParameter[] methoTypeParameters = methodSignature.getTypeParameters();\n    PsiTypeParameter[] superTypeParameters = superMethodSignature.getTypeParameters();\n    PsiSubstitutor methodSubstitutor = methodSignature.getSubstitutor();\n\n    //check bounds\n    for (int i = 0; i < methoTypeParameters.length; i++) {\n      PsiTypeParameter methoTypeParameter = methoTypeParameters[i];\n      PsiTypeParameter superTypeParameter = superTypeParameters[i];\n      final Set<PsiType> methoSupers = new HashSet<PsiType>();\n      for (PsiClassType methoSuper : methoTypeParameter.getSuperTypes()) {\n        methoSupers.add(methodSubstitutor.substitute(methoSuper));\n      }\n\n      final Set<PsiType> superSupers = new HashSet<PsiType>();\n      for (PsiClassType superSuper : superTypeParameter.getSuperTypes()) {\n        superSupers.add(methodSubstitutor.substitute(PsiUtil.captureToplevelWildcards(result.substitute(superSuper), methoTypeParameter)));\n      }\n      if (!methoSupers.equals(superSupers)) return null;\n    }\n    return result;\n  }","commit_id":"ab7796431af29301e9a6612c2f6d1595bf1133cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String getJreHome(final String sdkHome) {\n    @NonNls String jreHome;\n    if (SystemInfo.isLinux || SystemInfo.isWindows) {\n      jreHome = sdkHome + File.separator + JRE_DIR_NAME;\n      if (new File(jreHome).exists()){\n        return jreHome;\n      }\n    }\n    return System.getProperty(JAVA_HOME_PROPERTY);\n  }","id":73666,"modified_method":"private static String getJreHome(final String sdkHome) {\n    @NonNls String jreHome;\n    if (SystemInfo.isLinux || SystemInfo.isWindows) {\n      jreHome = sdkHome + File.separator + JRE_DIR_NAME;\n      if (new File(jreHome).exists()){\n        return jreHome;\n      }\n    }\n    final String jrePath = System.getProperty(JAVA_HOME_PROPERTY);\n    final File parent = new File(jrePath).getParentFile();\n    if (JavaSdk.checkForJdk(parent)) {\n      return parent.getPath();\n    }\n    return jrePath;\n  }","commit_id":"601cff4174a0fa6c575778c7ab639073893b422f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private String getInternalRtPath(final String homePath) {\n    @NonNls String rtPath;\n    @NonNls final String rtJar = \"rt.jar\";\n    if (SystemInfo.isLinux || SystemInfo.isWindows) {\n      rtPath = homePath + File.separator + JRE_DIR_NAME + File.separator + LIB_DIR_NAME + File.separator + rtJar;\n      if (new File(rtPath).exists()) {\n        return rtPath;\n      }\n    }\n    final String javaHome = System.getProperty(JAVA_HOME_PROPERTY);\n    File rt = new File(new File(javaHome, LIB_DIR_NAME), rtJar);\n    if (rt.exists()){ // java home points to jre\n      return rt.getPath();\n    } else {\n      rt = new File(new File (new File(javaHome, JRE_DIR_NAME), LIB_DIR_NAME), rtJar);\n      if (rt.exists()){\n        return rt.getPath();\n      }\n    }\n    return null;\n  }","id":73667,"modified_method":"@Nullable\n  private String getInternalRtPath(final String homePath) {\n    @NonNls String rtPath;\n    @NonNls final String rtJar = \"rt.jar\";\n    if (SystemInfo.isLinux || SystemInfo.isWindows) {\n      rtPath = homePath + File.separator + JRE_DIR_NAME + File.separator + LIB_DIR_NAME + File.separator + rtJar;\n      if (new File(rtPath).exists()) {\n        return rtPath;\n      }\n    }\n    final ProjectJdk jdk = getInternalJavaSdk(homePath);\n    if (jdk.getVersionString() != null){\n      return jdk.getToolsPath();\n    }\n    return null;\n  }","commit_id":"601cff4174a0fa6c575778c7ab639073893b422f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private String getInternalToolsPath(final String sdkHome){\n    @NonNls final String toolsJar = \"tools.jar\";\n    if (SystemInfo.isLinux || SystemInfo.isWindows) {\n      final File tools = new File(new File(new File(sdkHome, JRE_DIR_NAME), LIB_DIR_NAME), toolsJar);\n      if (tools.exists()){\n        return tools.getPath();\n      }\n    }\n\n    final String javaHome = System.getProperty(JAVA_HOME_PROPERTY);\n    File tools = new File(new File(javaHome, LIB_DIR_NAME), toolsJar);\n    if (tools.exists()){ // java home points to jdk\n      return tools.getPath();\n    } else {\n      tools = new File(new File (new File(javaHome).getParentFile(), LIB_DIR_NAME), toolsJar);\n      if (tools.exists()){\n        return tools.getPath();\n      }\n    }\n    ProjectJdk jdk = JavaSdk.getInstance().createJdk(\"\", javaHome);\n    if (jdk.getVersionString() != null){\n      return jdk.getToolsPath();\n    }\n    return null;\n  }","id":73668,"modified_method":"@Nullable\n  private String getInternalToolsPath(final String sdkHome){\n    @NonNls final String toolsJar = \"tools.jar\";\n    if (SystemInfo.isLinux || SystemInfo.isWindows) {\n      final File tools = new File(new File(new File(sdkHome, JRE_DIR_NAME), LIB_DIR_NAME), toolsJar);\n      if (tools.exists()){\n        return tools.getPath();\n      }\n    }\n\n    final ProjectJdk jdk = getInternalJavaSdk(sdkHome);\n    if (jdk.getVersionString() != null){\n      return jdk.getToolsPath();\n    }\n    return null;\n  }","commit_id":"601cff4174a0fa6c575778c7ab639073893b422f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private Sdk getInternalJavaSdk(final String sdkHome) {\n    String jreHome = getJreHome(sdkHome);\n    ProjectJdk internalJdk = JavaSdk.getInstance().createJdk(\"\", jreHome);\n    if (internalJdk.getVersionString() != null){ //internal jdk is valid\n      final String internalToolsPath = getInternalToolsPath(sdkHome);\n      if (internalToolsPath != null) {\n        final VirtualFile tools = LocalFileSystem.getInstance().findFileByPath(FileUtil.toSystemIndependentName(internalToolsPath));\n        if (tools != null) {\n          final SdkModificator sdkModificator = internalJdk.getSdkModificator();\n          sdkModificator.addRoot(tools, ProjectRootType.CLASS);\n          sdkModificator.commitChanges();\n        }\n      }\n    } else {\n      return null;\n    }\n    return internalJdk;\n  }","id":73669,"modified_method":"@Nullable\n  private ProjectJdk getInternalJavaSdk(final String sdkHome) {\n    final String jreHome = getJreHome(sdkHome);\n    return JavaSdk.getInstance().createJdk(\"\", jreHome);\n  }","commit_id":"601cff4174a0fa6c575778c7ab639073893b422f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Sdk getInternalJavaSdk(final String sdkHome) {\n    if (myInternalJavaSdk != null){\n      return myInternalJavaSdk;\n    }\n    String jreHome;\n    if (SystemInfo.isLinux || SystemInfo.isWindows) {\n      jreHome = sdkHome + File.separator + \"jre\";\n      if (!new File(jreHome).exists()) {\n        jreHome = System.getProperty(\"java.home\");\n      }\n    }\n    else {\n      jreHome = System.getProperty(\"java.home\");\n    }\n\n    myInternalJavaSdk = JavaSdk.getInstance().createJdk(\"\", jreHome);\n    return myInternalJavaSdk;\n  }","id":73670,"modified_method":"private Sdk getInternalJavaSdk(final String sdkHome) {\n    String jreHome;\n    if (SystemInfo.isLinux || SystemInfo.isWindows) {\n      jreHome = sdkHome + File.separator + \"jre\";\n      if (!new File(jreHome).exists()) {\n        jreHome = System.getProperty(\"java.home\");\n        if (!new File(new File(jreHome, \"lib\"), \"tools.jar\").exists()){\n          jreHome = new File(jreHome).getParent();\n        }\n      }\n    }\n    else {\n      jreHome = System.getProperty(\"java.home\");\n    }\n\n    return JavaSdk.getInstance().createJdk(\"\", jreHome);\n  }","commit_id":"8fbeab52d7a3f4f3541da487359fbbe7becbaa59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void patchJavaParameters(JavaParameters javaParameters) {\n    final ProjectJdk jdk = javaParameters.getJdk();\n    if (jdk == null || !(jdk.getSdkType() instanceof IdeaJdk)) {\n      return;\n    }\n    String libPath = jdk.getHomePath() + File.separator + \"lib\";\n    javaParameters.getVMParametersList().add(\"-Xbootclasspath/p:\" + libPath + File.separator + \"boot.jar\");\n    javaParameters.getClassPath().addFirst(libPath + File.separator + \"idea.jar\");\n    javaParameters.getClassPath().addFirst(libPath + File.separator + \"resources.jar\");\n  }","id":73671,"modified_method":"public void patchJavaParameters(JavaParameters javaParameters) {\n    final ProjectJdk jdk = javaParameters.getJdk();\n    if (jdk == null || !(jdk.getSdkType() instanceof IdeaJdk)) {\n      return;\n    }\n    String libPath = jdk.getHomePath() + File.separator + \"lib\";\n    javaParameters.getVMParametersList().add(\"-Xbootclasspath/p:\" + libPath + File.separator + \"boot.jar\");\n    javaParameters.getClassPath().addFirst(libPath + File.separator + \"idea.jar\");\n    javaParameters.getClassPath().addFirst(libPath + File.separator + \"resources.jar\");\n    javaParameters.getClassPath().addFirst(jdk.getToolsPath());\n  }","commit_id":"8fbeab52d7a3f4f3541da487359fbbe7becbaa59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void apply() throws ConfigurationException {\n    if (!mySetDependencyOnPluginModule.isEmpty()) {\n      throw new ConfigurationException(\"Unable to set dependency on plugin module.\");\n    }\n    final String toDelete = !myJar.isSelected() ? myBuildProperties.getJarPath() != null ? myBuildProperties.getJarPath().replace('/', File.separatorChar) : null :\n                                                  myBuildProperties.getExplodedPath() != null ? myBuildProperties.getExplodedPath().replace('/', File.separatorChar) : null;\n    if (toDelete != null && new File(toDelete).exists()) {\n      if (Messages.showYesNoDialog(myModule.getProject(),\n                                                                      (!myJar.isSelected() ? \"Delete \" : \"Clear \") + toDelete + \"?\",\n                                                                      \"Clean up plugin directory\", null) == DialogWrapper.OK_EXIT_CODE) {\n\n        CommandProcessor.getInstance().executeCommand(myModule.getProject(),\n                                                      new Runnable() {\n                                                        public void run() {\n                                                          FileUtil.delete(new File(toDelete));\n                                                        }\n                                                      },\n                                                      \"Synchronize plugins directory\",\n                                                      null);\n      }\n    }\n    myBuildProperties.setJarPlugin(myJar.isSelected());\n    final File plugin = new File(myBuildProperties.getPluginXMLPath());\n    if (plugin.exists() &&\n        !plugin.getPath().equals(myPluginXML.getText()) &&\n        Messages.showYesNoDialog(myModule.getProject(),\n                                 \"Delete \" + plugin.getPath() + File.separator + \"META-INF\" + \" ?\",\n                                 \"Clean up META-INF directory\", null) == DialogWrapper.OK_EXIT_CODE) {\n\n      CommandProcessor.getInstance().executeCommand(myModule.getProject(),\n                                                    new Runnable() {\n                                                      public void run() {\n                                                        FileUtil.delete(new File(plugin, \"META-INF\"));\n                                                      }\n                                                    },\n                                                    \"Remove old plugin.xml directory\",\n                                                    null);\n    }\n    myBuildProperties.setPluginXMLPath(myPluginXML.getText());\n    myModified = false;\n  }","id":73672,"modified_method":"public void apply() throws ConfigurationException {\n    if (!mySetDependencyOnPluginModule.isEmpty()) {\n      throw new ConfigurationException(\"Unable to set dependency on plugin module.\");\n    }\n    final File plugin = myBuildProperties.getPluginXmlPath() != null ? new File(myBuildProperties.getPluginXmlPath()) : null;\n    if (plugin != null &&\n        plugin.exists() &&\n        !plugin.getPath().equals(myPluginXML.getText()) &&\n        Messages.showYesNoDialog(myModule.getProject(),\n                                 \"Delete \" + plugin.getPath() + \" ?\",\n                                 \"Clean up META-INF directory\", null) == DialogWrapper.OK_EXIT_CODE) {\n\n      CommandProcessor.getInstance().executeCommand(myModule.getProject(),\n                                                    new Runnable() {\n                                                      public void run() {\n                                                        FileUtil.delete(plugin.getParentFile());\n                                                      }\n                                                    },\n                                                    \"Remove old plugin.xml directory\",\n                                                    null);\n    }\n    myBuildProperties.setPluginXMLUrl(myPluginXML.getText());\n    myModified = false;\n  }","commit_id":"8fbeab52d7a3f4f3541da487359fbbe7becbaa59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JComponent createComponent() {\n    ButtonGroup deployButtonGroup = new ButtonGroup();\n    deployButtonGroup.add(myJar);\n    deployButtonGroup.add(myClasses);\n    myClasses.setSelected(true);\n\n    myJar.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        deploymentMethodChanged();\n      }\n    });\n    myClasses.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        deploymentMethodChanged();\n      }\n    });\n    myPluginXML.addActionListener(new BrowseFilesListener(myPluginXML.getTextField(), \"Select META-INF Directory Location\", \"The META-INF\"+ File.separator + \"plugin.xml will be saved in selected directory\", BrowseFilesListener.SINGLE_DIRECTORY_DESCRIPTOR));\n    myPluginXML.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        myModified = !myPluginXML.getText().equals(myBuildProperties.getPluginXMLPath());\n      }\n    });\n    JPanel pluginXmlPanel = new JPanel(new BorderLayout());\n    pluginXmlPanel.add(myPluginXMLLabel,  BorderLayout.NORTH);\n    pluginXmlPanel.add(myPluginXML, BorderLayout.CENTER);\n    myWholePanel.add(pluginXmlPanel, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST,\n                                               GridBagConstraints.HORIZONTAL, new Insets(10, 5, 15, 5), 0, 0));\n    myWholePanel.add(new JLabel(\"Choose plugin deployment method:\"),  new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST,\n                                               GridBagConstraints.HORIZONTAL, new Insets(15, 5, 0, 5), 0, 0));\n    myWholePanel.add(myClasses, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST,\n                                                      GridBagConstraints.NONE, new Insets(0, 5, 0, 5), 0, 0));\n    myWholePanel.add(myJar, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST,\n                                               GridBagConstraints.NONE, new Insets(0, 5, 0, 5), 0, 0));\n    myWholePanel.add(myDesctination,  new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 1.0, GridBagConstraints.SOUTHWEST,\n                                               GridBagConstraints.HORIZONTAL, new Insets(5, 5, 5, 5), 0, 0));\n\n    return myWholePanel;\n  }","id":73673,"modified_method":"public JComponent createComponent() {\n    myPluginXML.addActionListener(new BrowseFilesListener(myPluginXML.getTextField(), \"Select META-INF Directory Location\", \"The META-INF\"+ File.separator + \"plugin.xml will be saved in selected directory\", BrowseFilesListener.SINGLE_DIRECTORY_DESCRIPTOR));\n    myPluginXML.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        myModified = !myPluginXML.getText().equals(myBuildProperties.getVirtualFilePointer());\n      }\n    });\n    JPanel pluginXmlPanel = new JPanel(new BorderLayout());\n    pluginXmlPanel.add(myPluginXMLLabel,  BorderLayout.NORTH);\n    pluginXmlPanel.add(myPluginXML, BorderLayout.CENTER);\n    myWholePanel.add(pluginXmlPanel, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST,\n                                               GridBagConstraints.HORIZONTAL, new Insets(10, 5, 15, 5), 0, 0));\n    myWholePanel.add(myDesctination,  new GridBagConstraints(0, GridBagConstraints.RELATIVE, 1, 1, 1.0, 1.0, GridBagConstraints.SOUTHWEST,\n                                               GridBagConstraints.HORIZONTAL, new Insets(5, 5, 5, 5), 0, 0));\n\n    return myWholePanel;\n  }","commit_id":"8fbeab52d7a3f4f3541da487359fbbe7becbaa59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void reset() {\n    myJar.setSelected(myBuildProperties.isJarPlugin());\n    myClasses.setSelected(!myBuildProperties.isJarPlugin());\n    myPluginXML.setText(myBuildProperties.getPluginXMLPath());\n    deploymentMethodChanged();\n    myModified = false;\n  }","id":73674,"modified_method":"public void reset() {\n    myPluginXML.setText(myBuildProperties.getPluginXmlPath());\n    myModified = false;\n  }","commit_id":"8fbeab52d7a3f4f3541da487359fbbe7becbaa59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getPluginXMLPath() {\n    return FileUtil.toSystemDependentName(myPluginXMLPath);\n  }","id":73675,"modified_method":"public String getPluginXmlPath() {\n    return FileUtil.toSystemDependentName(getVirtualFilePointer().getFile().getPath());\n  }","commit_id":"8fbeab52d7a3f4f3541da487359fbbe7becbaa59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isJarEnabled() {\n    return myJarPlugin;\n  }","id":73676,"modified_method":"public boolean isJarEnabled() {\n    return false;\n  }","commit_id":"8fbeab52d7a3f4f3541da487359fbbe7becbaa59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public J2EEDeploymentItem getPluginXML() {\n    return myPluginXML;\n  }","id":73677,"modified_method":"public J2EEDeploymentItem getPluginXML() {\n    if (myPluginXML == null) {\n      myPluginXML = DeploymentDescriptorFactory.getInstance().createDeploymentItem(myModule, new PluginDescriptorMetaData());\n      myPluginXML.setUrl(getVirtualFilePointer().getUrl());\n      myPluginXML.createIfNotExists();\n    }\n    return myPluginXML;\n  }","commit_id":"8fbeab52d7a3f4f3541da487359fbbe7becbaa59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getJarPath() {\n    return PluginBuildUtil.getPluginExPath(myModule) != null ? PluginBuildUtil.getPluginExPath(myModule) + \"/lib/\" + myModule.getName() + \".jar\" : null;\n  }","id":73678,"modified_method":"public String getJarPath() {\n    return null;\n  }","commit_id":"8fbeab52d7a3f4f3541da487359fbbe7becbaa59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void readExternal(Element element) throws InvalidDataException {\n    DefaultJDOMExternalizer.readExternal(this, element);\n  }","id":73679,"modified_method":"public void readExternal(Element element) throws InvalidDataException {\n    String url = element.getAttributeValue(\"url\");\n    if (url != null) {\n      setPluginXMLUrl(VfsUtil.urlToPath(url));\n    }\n  }","commit_id":"8fbeab52d7a3f4f3541da487359fbbe7becbaa59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setPluginXMLPath(String pluginXMLPath) {\n    myPluginXMLPath = FileUtil.toSystemIndependentName(pluginXMLPath);\n    myPluginXML = DeploymentDescriptorFactory.getInstance().createDeploymentItem(myModule, new PluginDescriptorMetaData());\n    myPluginXML.setUrl(createPluginXMLURL(myPluginXMLPath));\n    myPluginXML.createIfNotExists();\n  }","id":73680,"modified_method":"public void setPluginXMLUrl(final String pluginXMLUrl) {\n    myPluginXML = DeploymentDescriptorFactory.getInstance().createDeploymentItem(myModule, new PluginDescriptorMetaData());\n    myPluginXML.setUrl(VfsUtil.pathToUrl(pluginXMLUrl.replace(File.separatorChar, '/')));\n    myPluginXML.createIfNotExists();\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      public void run() {\n        myVirtualFilePointer = VirtualFilePointerManager.getInstance().create(LocalFileSystem.getInstance().refreshAndFindFileByPath(pluginXMLUrl.replace(File.separatorChar, '/')),\n                                                                              null);\n      }\n    });\n  }","commit_id":"8fbeab52d7a3f4f3541da487359fbbe7becbaa59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeExternal(Element element) throws WriteExternalException {\n    DefaultJDOMExternalizer.writeExternal(this, element);\n  }","id":73681,"modified_method":"public void writeExternal(Element element) throws WriteExternalException {\n    element.setAttribute(\"url\", getVirtualFilePointer().getUrl());\n  }","commit_id":"8fbeab52d7a3f4f3541da487359fbbe7becbaa59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isExplodedEnabled() {\n    return !myJarPlugin;\n  }","id":73682,"modified_method":"public boolean isExplodedEnabled() {\n    return true;\n  }","commit_id":"8fbeab52d7a3f4f3541da487359fbbe7becbaa59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PluginModuleBuildProperties(Module module) {\n    myModule = module;\n    myPluginXMLPath = FileUtil.toSystemIndependentName(new File(myModule.getModuleFilePath()).getParent());\n    myPluginXML = DeploymentDescriptorFactory.getInstance().createDeploymentItem(myModule, new PluginDescriptorMetaData());\n    myPluginXML.setUrl(createPluginXMLURL(myPluginXMLPath));\n    myPluginXML.createIfNotExists();\n  }","id":73683,"modified_method":"public PluginModuleBuildProperties(Module module) {\n    myModule = module;\n  }","commit_id":"8fbeab52d7a3f4f3541da487359fbbe7becbaa59","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void configureSpecificCompilerArguments(@NotNull K2JVMCompilerArguments arguments) throws MojoExecutionException {\n        arguments.destination = output;\n\n        // don't include runtime, it should be in maven dependencies\n        arguments.noStdlib = true;\n\n        if (module != null) {\n            getLog().info(\"Compiling Kotlin module \" + module);\n            arguments.module = module;\n        }\n\n        List<String> classpathList = filterClassPath(classpath);\n\n        if (!classpathList.isEmpty()) {\n            String classPathString = join(classpathList, File.pathSeparator);\n            getLog().info(\"Classpath: \" + classPathString);\n            arguments.classpath = classPathString;\n        }\n\n        getLog().info(\"Classes directory is \" + output);\n        arguments.destination = output;\n\n        try {\n            Args.parse(arguments, ArrayUtil.toStringArray(args));\n        }\n        catch (IllegalArgumentException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n\n        if (arguments.noOptimize) {\n            getLog().info(\"Optimization is turned off\");\n        }\n    }","id":73684,"modified_method":"@Override\n    protected void configureSpecificCompilerArguments(@NotNull K2JVMCompilerArguments arguments) throws MojoExecutionException {\n        arguments.destination = output;\n\n        // don't include runtime, it should be in maven dependencies\n        arguments.noStdlib = true;\n\n        if (module != null) {\n            getLog().info(\"Compiling Kotlin module \" + module);\n            arguments.module = module;\n        }\n\n        List<String> classpathList = filterClassPath(classpath);\n\n        if (!classpathList.isEmpty()) {\n            String classPathString = join(classpathList, File.pathSeparator);\n            getLog().info(\"Classpath: \" + classPathString);\n            arguments.classpath = classPathString;\n        }\n\n        getLog().info(\"Classes directory is \" + output);\n        arguments.destination = output;\n\n        arguments.moduleName = moduleName;\n        getLog().info(\"Module name is \" + moduleName);\n\n        try {\n            Args.parse(arguments, ArrayUtil.toStringArray(args));\n        }\n        catch (IllegalArgumentException e) {\n            throw new MojoExecutionException(e.getMessage());\n        }\n\n        if (arguments.noOptimize) {\n            getLog().info(\"Optimization is turned off\");\n        }\n    }","commit_id":"7e2c2ef6784940adfe376b1cdaebc09afa8b9f0d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private static Sdk getSdk(String sdkHome) {\n        Sdk sdk = JavaSdk.getInstance().createJdk(\"JDK\", sdkHome, true);\n        SdkModificator modificator = sdk.getSdkModificator();\n        VirtualFile file = LocalFileSystem.getInstance().findFileByIoFile(getJdkAnnotationsJar());\n        assert file != null;\n        modificator.addRoot(JarFileSystem.getInstance().getJarRootForLocalFile(file), AnnotationOrderRootType.getInstance());\n        modificator.commitChanges();\n        return sdk;\n    }","id":73685,"modified_method":"@NotNull\n    private static Sdk getSdk(String sdkHome) {\n        return JavaSdk.getInstance().createJdk(\"JDK\", sdkHome, true);\n    }","commit_id":"7e2c2ef6784940adfe376b1cdaebc09afa8b9f0d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n\t * store the record in content_resource_delete table along with\n\t * resource_uuid and date\n\t */\n\tpublic Edit putDeleteResource(String id, String uuid, String userId, Object[] others)\n\t{\n\t\tEntity entry = m_user.newResource(null, id, others);\n\n\t\t// form the XML and SQL for the insert\n\t\tObject blob = getBlob(entry);\n\t\tString statement = null;\n\t\tif (blob instanceof byte[])\n\t\t{\n\t\t\tstatement = \"insert into \"\n\t\t\t\t\t+ m_resourceTableName\n\t\t\t\t\t+ insertDeleteFields(m_resourceTableIdField,\n\t\t\t\t\t\t\tm_resourceTableOtherFields, \"RESOURCE_UUID\", \"DELETE_DATE\",\n\t\t\t\t\t\t\t\"DELETE_USERID\", \"BINARY_ENTITY\") + \" values ( ?, \"\n\t\t\t\t\t+ valuesParams(m_resourceTableOtherFields) + \" ? ,? ,? ,?)\";\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatement = \"insert into \"\n\t\t\t\t\t+ m_resourceTableName\n\t\t\t\t\t+ insertDeleteFields(m_resourceTableIdField,\n\t\t\t\t\t\t\tm_resourceTableOtherFields, \"RESOURCE_UUID\", \"DELETE_DATE\",\n\t\t\t\t\t\t\t\"DELETE_USERID\", \"XML\") + \" values ( ?, \"\n\t\t\t\t\t+ valuesParams(m_resourceTableOtherFields) + \" ? ,? ,? ,?)\";\n\t\t}\n\n\t\tObject[] flds = m_user.storageFields(entry);\n\t\tif (flds == null) flds = new Object[0];\n\t\tObject[] fields = new Object[flds.length + 5];\n\t\tSystem.arraycopy(flds, 0, fields, 1, flds.length);\n\t\tfields[0] = caseId(entry.getId());\n\t\t// uuid added here\n\t\tfields[fields.length - 4] = uuid;\n\t\t// date added here\n\t\tfields[fields.length - 3] = TimeService.newTime();// .toStringLocalDate();\n\n\t\t// userId added here\n\t\tfields[fields.length - 2] = userId;\n\t\tfields[fields.length - 1] = blob;\n\n\t\t// process the insert\n\t\tboolean ok = m_sql.dbWrite(statement, fields);\n\n\t\t// if this failed, assume a key conflict (i.e. id in use)\n\t\tif (!ok) return null;\n\n\t\t// now get a lock on the record for edit\n\t\tEdit edit = editResource(id);\n\t\tif (edit == null)\n\t\t{\n\t\t\tM_log.warn(\"putResourceDelete(): didn't get a lock!\");\n\t\t\treturn null;\n\t\t}\n\n\t\treturn edit;\n\t}","id":73686,"modified_method":"/**\n\t * store the record in content_resource_delete table along with\n\t * resource_uuid and date\n\t */\n\tpublic Edit putDeleteResource(String id, String uuid, String userId, Object[] others)\n\t{\n        // support for SAK-12874\n        Entity entry = null;\n        if (m_storage != null) {\n            // use the object being deleted\n            entry = m_storage.getResource(id);\n        }\n        if (entry == null) {\n            // failsafe to the old method\n            entry = m_user.newResource(null, id, others);\n        }\n\t\t//Entity entry = m_user.newResource(null, id, others);\n\n\t\t// form the XML and SQL for the insert\n\t\tObject blob = getBlob(entry);\n\t\tString statement = null;\n\t\tif (blob instanceof byte[])\n\t\t{\n\t\t\tstatement = \"insert into \"\n\t\t\t\t\t+ m_resourceTableName\n\t\t\t\t\t+ insertDeleteFields(m_resourceTableIdField,\n\t\t\t\t\t\t\tm_resourceTableOtherFields, \"RESOURCE_UUID\", \"DELETE_DATE\",\n\t\t\t\t\t\t\t\"DELETE_USERID\", \"BINARY_ENTITY\") + \" values ( ?, \"\n\t\t\t\t\t+ valuesParams(m_resourceTableOtherFields) + \" ? ,? ,? ,?)\";\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatement = \"insert into \"\n\t\t\t\t\t+ m_resourceTableName\n\t\t\t\t\t+ insertDeleteFields(m_resourceTableIdField,\n\t\t\t\t\t\t\tm_resourceTableOtherFields, \"RESOURCE_UUID\", \"DELETE_DATE\",\n\t\t\t\t\t\t\t\"DELETE_USERID\", \"XML\") + \" values ( ?, \"\n\t\t\t\t\t+ valuesParams(m_resourceTableOtherFields) + \" ? ,? ,? ,?)\";\n\t\t}\n\n\t\tObject[] flds = m_user.storageFields(entry);\n\t\tif (flds == null) flds = new Object[0];\n\t\tObject[] fields = new Object[flds.length + 5];\n\t\tSystem.arraycopy(flds, 0, fields, 1, flds.length);\n\t\tfields[0] = caseId(entry.getId());\n\t\t// uuid added here\n\t\tfields[fields.length - 4] = uuid;\n\t\t// date added here\n\t\tfields[fields.length - 3] = TimeService.newTime();// .toStringLocalDate();\n\n\t\t// userId added here\n\t\tfields[fields.length - 2] = userId;\n\t\tfields[fields.length - 1] = blob;\n\n\t\t// process the insert\n\t\tboolean ok = m_sql.dbWrite(statement, fields);\n\n\t\t// if this failed, assume a key conflict (i.e. id in use)\n\t\tif (!ok) return null;\n\n\t\t// now get a lock on the record for edit\n\t\tEdit edit = editResource(id);\n\t\tif (edit == null)\n\t\t{\n\t\t\tM_log.warn(\"putResourceDelete(): didn't get a lock!\");\n\t\t\treturn null;\n\t\t}\n\n\t\treturn edit;\n\t}","commit_id":"d23867ca8cdd1810b5b0c50d2a57505e9935c00c","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public Edit putDeleteResource(String id, String uuid, String userId, Object[] others)\n\t{\n\t\tEntity entry = m_user.newResource(null, id, others);\n\n\t\t// form the XML and SQL for the insert\n\t\tDocument doc = Xml.createDocument();\n\t\tentry.toXml(doc, new Stack());\n\t\tString xml = Xml.writeDocumentToString(doc);\n\t\tString statement = \"insert into \" + m_resourceTableName\n\t\t\t\t+ insertDeleteFields(m_resourceTableIdField, m_resourceTableOtherFields, \"RESOURCE_UUID\", \"DELETE_DATE\", \"DELETE_USERID\", \"XML\")\n\t\t\t\t+ \" values ( ?, \" + valuesParams(m_resourceTableOtherFields) + \" ? ,? ,? ,?)\";\n\n\t\tObject[] flds = m_user.storageFields(entry);\n\t\tif (flds == null) flds = new Object[0];\n\t\tObject[] fields = new Object[flds.length + 5];\n\t\tSystem.arraycopy(flds, 0, fields, 1, flds.length);\n\t\tfields[0] = caseId(entry.getId());\n\t\t// uuid added here\n\t\tfields[fields.length - 4] = uuid;\n\t\t// date added here\n\t\tfields[fields.length - 3] = TimeService.newTime();// .toStringLocalDate();\n\n\t\t// userId added here\n\t\tfields[fields.length - 2] = userId;\n\t\tfields[fields.length - 1] = xml;\n\n\t\t// process the insert\n\t\tboolean ok = m_sql.dbWrite(statement, fields);\n\n\t\t// if this failed, assume a key conflict (i.e. id in use)\n\t\tif (!ok) return null;\n\n\t\t// now get a lock on the record for edit\n\t\tEdit edit = editResource(id);\n\t\tif (edit == null)\n\t\t{\n\t\t\tM_log.warn(\"putResourceDelete(): didn't get a lock!\");\n\t\t\treturn null;\n\t\t}\n\n\t\treturn edit;\n\t}","id":73687,"modified_method":"public Edit putDeleteResource(String id, String uuid, String userId, Object[] others)\n\t{\n        // support for SAK-12874\n        Entity entry = null;\n        if (m_storage != null) {\n            // use the object being deleted\n            entry = m_storage.getResource(id);\n        }\n        if (entry == null) {\n            // failsafe to the old method\n            entry = m_user.newResource(null, id, others);\n        }\n\t\t//Entity entry = m_user.newResource(null, id, others);\n\n\t\t// form the XML and SQL for the insert\n\t\tDocument doc = Xml.createDocument();\n\t\tentry.toXml(doc, new Stack());\n\t\tString xml = Xml.writeDocumentToString(doc);\n\t\tString statement = \"insert into \" + m_resourceTableName\n\t\t\t\t+ insertDeleteFields(m_resourceTableIdField, m_resourceTableOtherFields, \"RESOURCE_UUID\", \"DELETE_DATE\", \"DELETE_USERID\", \"XML\")\n\t\t\t\t+ \" values ( ?, \" + valuesParams(m_resourceTableOtherFields) + \" ? ,? ,? ,?)\";\n\n\t\tObject[] flds = m_user.storageFields(entry);\n\t\tif (flds == null) flds = new Object[0];\n\t\tObject[] fields = new Object[flds.length + 5];\n\t\tSystem.arraycopy(flds, 0, fields, 1, flds.length);\n\t\tfields[0] = caseId(entry.getId());\n\t\t// uuid added here\n\t\tfields[fields.length - 4] = uuid;\n\t\t// date added here\n\t\tfields[fields.length - 3] = TimeService.newTime();// .toStringLocalDate();\n\n\t\t// userId added here\n\t\tfields[fields.length - 2] = userId;\n\t\tfields[fields.length - 1] = xml;\n\n\t\t// process the insert\n\t\tboolean ok = m_sql.dbWrite(statement, fields);\n\n\t\t// if this failed, assume a key conflict (i.e. id in use)\n\t\tif (!ok) return null;\n\n\t\t// now get a lock on the record for edit\n\t\tEdit edit = editResource(id);\n\t\tif (edit == null)\n\t\t{\n\t\t\tM_log.warn(\"putResourceDelete(): didn't get a lock!\");\n\t\t\treturn null;\n\t\t}\n\n\t\treturn edit;\n\t}","commit_id":"d23867ca8cdd1810b5b0c50d2a57505e9935c00c","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Here is the order in which jars and osgi artifacts are scanned for discoverable annotations.\n     * <ol>\n     * <li>The container jars are scanned.<\/li>\n     * <li>The WEB-INF/classes are scanned<\/li>\n     * <li>The osgi fragment to the web bundle are parsed.<\/li>\n     * <li>The WEB-INF/lib are scanned<\/li>\n     * <li>The required bundles are parsed<\/li>\n     * <\/ol>\n     */\n    @Override\n    public void parseWebInfLib (WebAppContext context, org.eclipse.jetty.annotations.AnnotationParser parser)\n    throws Exception\n    {\n        AnnotationParser oparser = (AnnotationParser)parser;\n        \n        Bundle webbundle = (Bundle) context.getAttribute(OSGiWebappConstants.JETTY_OSGI_BUNDLE);\n        Bundle[] fragAndRequiredBundles = PackageAdminServiceTracker.INSTANCE.getFragmentsAndRequiredBundles(webbundle);\n        if (fragAndRequiredBundles != null)\n        {\n            //index and scan fragments\n            for (Bundle bundle : fragAndRequiredBundles)\n            {\n                Resource bundleRes = oparser.indexBundle(bundle);\n                if (!context.getMetaData().getWebInfJars().contains(bundleRes))\n                {\n                    context.getMetaData().addWebInfJar(bundleRes);\n                }\n                \n                if (bundle.getHeaders().get(Constants.FRAGMENT_HOST) != null)\n                {\n                    //a fragment indeed:\n                    parseFragmentBundle(context,oparser,webbundle,bundle);\n                }\n            }\n        }\n        //scan ourselves\n        oparser.indexBundle(webbundle);\n        parseWebBundle(context,oparser,webbundle);\n        \n        //scan the WEB-INF/lib\n        super.parseWebInfLib(context,parser);\n        if (fragAndRequiredBundles != null)\n        {\n            //scan the required bundles\n            for (Bundle requiredBundle : fragAndRequiredBundles)\n            {\n                if (requiredBundle.getHeaders().get(Constants.FRAGMENT_HOST) == null)\n                {\n                    //a bundle indeed:\n                    parseRequiredBundle(context,oparser,webbundle,requiredBundle);\n                }\n            }\n        }\n    }","id":73688,"modified_method":"/**\n     * Here is the order in which jars and osgi artifacts are scanned for discoverable annotations.\n     * <ol>\n     * <li>The container jars are scanned.<\/li>\n     * <li>The WEB-INF/classes are scanned<\/li>\n     * <li>The osgi fragment to the web bundle are parsed.<\/li>\n     * <li>The WEB-INF/lib are scanned<\/li>\n     * <li>The required bundles are parsed<\/li>\n     * <\/ol>\n     */\n    @Override\n    public void parseWebInfLib (WebAppContext context, org.eclipse.jetty.annotations.AnnotationParser parser)\n    throws Exception\n    {\n        AnnotationParser oparser = (AnnotationParser)parser;\n        \n        Bundle webbundle = (Bundle) context.getAttribute(OSGiWebappConstants.JETTY_OSGI_BUNDLE);\n        Set<Bundle> fragAndRequiredBundles = (Set<Bundle>)context.getAttribute(OSGiWebInfConfiguration.FRAGMENT_AND_REQUIRED_BUNDLES);\n        if (fragAndRequiredBundles != null)\n        {\n            //index and scan fragments\n            for (Bundle bundle : fragAndRequiredBundles)\n            {\n                Resource bundleRes = oparser.indexBundle(bundle);\n                if (!context.getMetaData().getWebInfJars().contains(bundleRes))\n                {\n                    context.getMetaData().addWebInfJar(bundleRes);\n                }\n                \n                if (bundle.getHeaders().get(Constants.FRAGMENT_HOST) != null)\n                {\n                    //a fragment indeed:\n                    parseFragmentBundle(context,oparser,webbundle,bundle);\n                }\n            }\n        }\n        //scan ourselves\n        oparser.indexBundle(webbundle);\n        parseWebBundle(context,oparser,webbundle);\n        \n        //scan the WEB-INF/lib\n        super.parseWebInfLib(context,parser);\n        if (fragAndRequiredBundles != null)\n        {\n            //scan the required bundles\n            for (Bundle requiredBundle : fragAndRequiredBundles)\n            {\n                if (requiredBundle.getHeaders().get(Constants.FRAGMENT_HOST) == null)\n                {\n                    //a bundle indeed:\n                    parseRequiredBundle(context,oparser,webbundle,requiredBundle);\n                }\n            }\n        }\n    }","commit_id":"839485797b74e8dac0180348e14a7464a7816525","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Scan for META-INF/web-fragment.xml file in the given jar.\n     * \n     * @param context\n     * @param jar\n     * @param cache\n     * @throws Exception\n     */\n    public void scanForFragment (WebAppContext context, Resource jar, ConcurrentHashMap<Resource,Resource> cache)\n    throws Exception\n    {\n        Resource webFrag = null;\n        if (cache != null && cache.containsKey(jar))\n        {\n            webFrag = cache.get(jar);  \n            if (webFrag == EmptyResource.INSTANCE)\n            {\n                if (LOG.isDebugEnabled()) LOG.debug(jar+\" cached as containing no META-INF/web-fragment.xml\");\n                return;     \n            }\n            else\n                if (LOG.isDebugEnabled()) LOG.debug(jar+\" META-INF/web-fragment.xml found in cache \");\n        }\n        else\n        {\n            //not using caches or not in the cache so check for the web-fragment.xml\n            if (LOG.isDebugEnabled()) LOG.debug(jar+\" META-INF/web-fragment.xml checked\");\n            URI uri = jar.getURI();\n            webFrag = Resource.newResource(\"jar:\"+uri+\"!/META-INF/web-fragment.xml\");\n            if (!webFrag.exists() || webFrag.isDirectory())\n                webFrag = EmptyResource.INSTANCE;\n            \n            if (cache != null)\n            {\n                //web-fragment.xml doesn't exist: put token in cache to signal we've seen the jar               \n                Resource old = cache.putIfAbsent(jar, webFrag);\n                if (old != null)\n                    webFrag = old;\n                else\n                    if (LOG.isDebugEnabled()) LOG.debug(jar+\" META-INF/web-fragment.xml cache updated\");\n            }\n            \n            if (webFrag == EmptyResource.INSTANCE)\n                return;\n        }\n\n        Map<Resource, Resource> fragments = (Map<Resource,Resource>)context.getAttribute(METAINF_FRAGMENTS);\n        if (fragments == null)\n        {\n            fragments = new HashMap<Resource, Resource>();\n            context.setAttribute(METAINF_FRAGMENTS, fragments);\n        }\n        fragments.put(jar, webFrag);   \n        if (LOG.isDebugEnabled()) LOG.debug(webFrag+\" added to context\");\n    }","id":73689,"modified_method":"/**\n     * Scan for META-INF/web-fragment.xml file in the given jar.\n     * \n     * @param context\n     * @param jar\n     * @param cache\n     * @throws Exception\n     */\n    public void scanForFragment (WebAppContext context, Resource jar, ConcurrentHashMap<Resource,Resource> cache)\n    throws Exception\n    {\n        Resource webFrag = null;\n        if (cache != null && cache.containsKey(jar))\n        {\n            webFrag = cache.get(jar);  \n            if (webFrag == EmptyResource.INSTANCE)\n            {\n                if (LOG.isDebugEnabled()) LOG.debug(jar+\" cached as containing no META-INF/web-fragment.xml\");\n                return;     \n            }\n            else\n                if (LOG.isDebugEnabled()) LOG.debug(jar+\" META-INF/web-fragment.xml found in cache \");\n        }\n        else\n        {\n            //not using caches or not in the cache so check for the web-fragment.xml\n            if (LOG.isDebugEnabled()) LOG.debug(jar+\" META-INF/web-fragment.xml checked\");\n            if (jar.isDirectory())\n            {\n                //TODO   ????\n                webFrag = jar.addPath(\"/META-INF/web-fragment.xml\");\n            }\n            else\n            {\n                URI uri = jar.getURI();\n                webFrag = Resource.newResource(\"jar:\"+uri+\"!/META-INF/web-fragment.xml\");\n            }\n            if (!webFrag.exists() || webFrag.isDirectory())\n                webFrag = EmptyResource.INSTANCE;\n            \n            if (cache != null)\n            {\n                //web-fragment.xml doesn't exist: put token in cache to signal we've seen the jar               \n                Resource old = cache.putIfAbsent(jar, webFrag);\n                if (old != null)\n                    webFrag = old;\n                else\n                    if (LOG.isDebugEnabled()) LOG.debug(jar+\" META-INF/web-fragment.xml cache updated\");\n            }\n            \n            if (webFrag == EmptyResource.INSTANCE)\n                return;\n        }\n\n        Map<Resource, Resource> fragments = (Map<Resource,Resource>)context.getAttribute(METAINF_FRAGMENTS);\n        if (fragments == null)\n        {\n            fragments = new HashMap<Resource, Resource>();\n            context.setAttribute(METAINF_FRAGMENTS, fragments);\n        }\n        fragments.put(jar, webFrag);   \n        if (LOG.isDebugEnabled()) LOG.debug(webFrag+\" added to context\");\n    }","commit_id":"839485797b74e8dac0180348e14a7464a7816525","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Discover META-INF/*.tld files in the given jar\n     * \n     * @param context\n     * @param jar\n     * @param cache\n     * @throws Exception\n     */\n    public void scanForTlds (WebAppContext context, Resource jar, ConcurrentHashMap<Resource, Collection<URL>> cache)\n    throws Exception\n    {\n        Collection<URL> tlds = null;\n        \n        if (cache != null && cache.containsKey(jar))\n        {\n            Collection<URL> tmp = cache.get(jar);\n            if (tmp.isEmpty())\n            {\n                if (LOG.isDebugEnabled()) LOG.debug(jar+\" cached as containing no tlds\");\n                return;\n            }\n            else\n            {\n                tlds = tmp;\n                if (LOG.isDebugEnabled()) LOG.debug(jar+\" tlds found in cache \");\n            }\n        }\n        else\n        {\n            //not using caches or not in the cache so find all tlds\n            URI uri = jar.getURI();\n            Resource metaInfDir = Resource.newResource(\"jar:\"+uri+\"!/META-INF/\");\n\n            //find any *.tld files inside META-INF or subdirs\n            tlds = new HashSet<URL>();      \n            Collection<Resource> resources = metaInfDir.getAllResources();\n            for (Resource t:resources)\n            {\n                String name = t.toString();\n                if (name.endsWith(\".tld\"))\n                {\n                    if (LOG.isDebugEnabled()) LOG.debug(t+\" tld discovered\");\n                    tlds.add(t.getURL());\n                }\n            }\n            if (cache != null)\n            {  \n                if (LOG.isDebugEnabled()) LOG.debug(jar+\" tld cache updated\");\n                Collection<URL> old = (Collection<URL>)cache.putIfAbsent(jar, tlds);\n                if (old != null)\n                    tlds = old;\n            }\n            \n            if (tlds.isEmpty())\n                return;\n        }\n\n        Collection<URL> tld_resources=(Collection<URL>)context.getAttribute(METAINF_TLDS);\n        if (tld_resources == null)\n        {\n            tld_resources = new HashSet<URL>();\n            context.setAttribute(METAINF_TLDS, tld_resources);\n        }\n        tld_resources.addAll(tlds);  \n        if (LOG.isDebugEnabled()) LOG.debug(\"tlds added to context\");\n    }","id":73690,"modified_method":"/**\n     * Discover META-INF/*.tld files in the given jar\n     * \n     * @param context\n     * @param jar\n     * @param cache\n     * @throws Exception\n     */\n    public void scanForTlds (WebAppContext context, Resource jar, ConcurrentHashMap<Resource, Collection<URL>> cache)\n    throws Exception\n    {\n        Collection<URL> tlds = null;\n        \n        if (cache != null && cache.containsKey(jar))\n        {\n            Collection<URL> tmp = cache.get(jar);\n            if (tmp.isEmpty())\n            {\n                if (LOG.isDebugEnabled()) LOG.debug(jar+\" cached as containing no tlds\");\n                return;\n            }\n            else\n            {\n                tlds = tmp;\n                if (LOG.isDebugEnabled()) LOG.debug(jar+\" tlds found in cache \");\n            }\n        }\n        else\n        {\n            //not using caches or not in the cache so find all tlds\n            Resource metaInfDir = null;\n            if (jar.isDirectory())\n            {\n                //TODO ??????\n                metaInfDir = jar.addPath(\"/META-INF/\");\n            }\n            else\n            {\n                URI uri = jar.getURI();\n                metaInfDir = Resource.newResource(\"jar:\"+uri+\"!/META-INF/\");\n            }\n\n            //find any *.tld files inside META-INF or subdirs\n            tlds = new HashSet<URL>();      \n            Collection<Resource> resources = metaInfDir.getAllResources();\n            for (Resource t:resources)\n            {\n                String name = t.toString();\n                if (name.endsWith(\".tld\"))\n                {\n                    if (LOG.isDebugEnabled()) LOG.debug(t+\" tld discovered\");\n                    tlds.add(t.getURL());\n                }\n            }\n            if (cache != null)\n            {  \n                if (LOG.isDebugEnabled()) LOG.debug(jar+\" tld cache updated\");\n                Collection<URL> old = (Collection<URL>)cache.putIfAbsent(jar, tlds);\n                if (old != null)\n                    tlds = old;\n            }\n            \n            if (tlds.isEmpty())\n                return;\n        }\n\n        Collection<URL> tld_resources=(Collection<URL>)context.getAttribute(METAINF_TLDS);\n        if (tld_resources == null)\n        {\n            tld_resources = new HashSet<URL>();\n            context.setAttribute(METAINF_TLDS, tld_resources);\n        }\n        tld_resources.addAll(tlds);  \n        if (LOG.isDebugEnabled()) LOG.debug(\"tlds added to context\");\n    }","commit_id":"839485797b74e8dac0180348e14a7464a7816525","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Scan for META-INF/resources dir in the given jar.\n     * \n     * @param context\n     * @param jar\n     * @param cache\n     * @throws Exception\n     */\n    public void scanForResources (WebAppContext context, Resource jar, ConcurrentHashMap<Resource,Resource> cache)\n    throws Exception\n    {\n        Resource resourcesDir = null;\n        if (cache != null && cache.containsKey(jar))\n        {\n            resourcesDir = cache.get(jar);  \n            if (resourcesDir == EmptyResource.INSTANCE)\n            {\n                if (LOG.isDebugEnabled()) LOG.debug(jar+\" cached as containing no META-INF/resources\");\n                return;    \n            }\n            else\n                if (LOG.isDebugEnabled()) LOG.debug(jar+\" META-INF/resources found in cache \");\n        }\n        else\n        {\n            //not using caches or not in the cache so check for the resources dir\n            if (LOG.isDebugEnabled()) LOG.debug(jar+\" META-INF/resources checked\");\n            URI uri = jar.getURI();\n            resourcesDir = Resource.newResource(\"jar:\"+uri+\"!/META-INF/resources\");\n            if (!resourcesDir.exists() || !resourcesDir.isDirectory())\n                resourcesDir = EmptyResource.INSTANCE;\n\n            if (cache != null)\n            {               \n                Resource old  = cache.putIfAbsent(jar, resourcesDir);\n                if (old != null)\n                    resourcesDir = old;\n                else\n                    if (LOG.isDebugEnabled()) LOG.debug(jar+\" META-INF/resources cache updated\");\n            }\n\n            if (resourcesDir == EmptyResource.INSTANCE)\n                return;\n        }\n\n        //add it to the meta inf resources for this context\n        Set<Resource> dirs = (Set<Resource>)context.getAttribute(METAINF_RESOURCES);\n        if (dirs == null)\n        {\n            dirs = new HashSet<Resource>();\n            context.setAttribute(METAINF_RESOURCES, dirs);\n        }\n        if (LOG.isDebugEnabled()) LOG.debug(resourcesDir+\" added to context\");\n        dirs.add(resourcesDir);\n    }","id":73691,"modified_method":"/**\n     * Scan for META-INF/resources dir in the given jar.\n     * \n     * @param context\n     * @param target\n     * @param cache\n     * @throws Exception\n     */\n    public void scanForResources (WebAppContext context, Resource target, ConcurrentHashMap<Resource,Resource> cache)\n    throws Exception\n    {\n        Resource resourcesDir = null;\n        if (cache != null && cache.containsKey(target))\n        {\n            resourcesDir = cache.get(target);  \n            if (resourcesDir == EmptyResource.INSTANCE)\n            {\n                if (LOG.isDebugEnabled()) LOG.debug(target+\" cached as containing no META-INF/resources\");\n                return;    \n            }\n            else\n                if (LOG.isDebugEnabled()) LOG.debug(target+\" META-INF/resources found in cache \");\n        }\n        else\n        {\n            //not using caches or not in the cache so check for the resources dir\n            if (LOG.isDebugEnabled()) LOG.debug(target+\" META-INF/resources checked\");\n            if (target.isDirectory())\n            {\n                //TODO think  how to handle an unpacked jar file (eg for osgi)\n                resourcesDir = target.addPath(\"/META-INF/resources\");\n            }\n            else\n            {\n                //Resource represents a packed jar\n                URI uri = target.getURI();\n                resourcesDir = Resource.newResource(\"jar:\"+uri+\"!/META-INF/resources\");\n            }\n            if (!resourcesDir.exists() || !resourcesDir.isDirectory())\n                resourcesDir = EmptyResource.INSTANCE;\n\n            if (cache != null)\n            {               \n                Resource old  = cache.putIfAbsent(target, resourcesDir);\n                if (old != null)\n                    resourcesDir = old;\n                else\n                    if (LOG.isDebugEnabled()) LOG.debug(target+\" META-INF/resources cache updated\");\n            }\n\n            if (resourcesDir == EmptyResource.INSTANCE)\n                return;\n        }\n\n        //add it to the meta inf resources for this context\n        Set<Resource> dirs = (Set<Resource>)context.getAttribute(METAINF_RESOURCES);\n        if (dirs == null)\n        {\n            dirs = new HashSet<Resource>();\n            context.setAttribute(METAINF_RESOURCES, dirs);\n        }\n        if (LOG.isDebugEnabled()) LOG.debug(resourcesDir+\" added to context\");\n        dirs.add(resourcesDir);\n    }","commit_id":"839485797b74e8dac0180348e14a7464a7816525","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/** \n     * Consider the fragment bundles associated with the bundle of the webapp being deployed.\n     * \n     * \n     * @see org.eclipse.jetty.webapp.WebInfConfiguration#findJars(org.eclipse.jetty.webapp.WebAppContext)\n     */\n    @Override\n    protected List<Resource> findJars (WebAppContext context) \n    throws Exception\n    {\n        List<Resource> mergedResources = new ArrayList<Resource>();\n        //get jars from WEB-INF/lib if there are any\n        List<Resource> webInfJars = super.findJars(context);\n        if (webInfJars != null)\n            mergedResources.addAll(webInfJars);\n        \n        //add fragment jars as if in WEB-INF/lib of the associated webapp\n        Bundle[] fragments = PackageAdminServiceTracker.INSTANCE.getFragmentsAndRequiredBundles((Bundle)context.getAttribute(OSGiWebappConstants.JETTY_OSGI_BUNDLE));\n        for (Bundle frag : fragments)\n        {\n            File fragFile = BundleFileLocatorHelperFactory.getFactory().getHelper().getBundleInstallLocation(frag);\n            mergedResources.add(Resource.newResource(fragFile.toURI()));  \n        }\n        \n        return mergedResources;\n    }","id":73692,"modified_method":"/** \n     * Consider the fragment bundles associated with the bundle of the webapp being deployed.\n     * \n     * \n     * @see org.eclipse.jetty.webapp.WebInfConfiguration#findJars(org.eclipse.jetty.webapp.WebAppContext)\n     */\n    @Override\n    protected List<Resource> findJars (WebAppContext context) \n    throws Exception\n    {\n        List<Resource> mergedResources = new ArrayList<Resource>();\n        //get jars from WEB-INF/lib if there are any\n        List<Resource> webInfJars = super.findJars(context);\n        if (webInfJars != null)\n            mergedResources.addAll(webInfJars);\n        \n        //add fragment jars and any Required-Bundles as if in WEB-INF/lib of the associated webapp\n        Bundle[] bundles = PackageAdminServiceTracker.INSTANCE.getFragmentsAndRequiredBundles((Bundle)context.getAttribute(OSGiWebappConstants.JETTY_OSGI_BUNDLE));\n        if (bundles != null && bundles.length > 0)\n        {\n            Set<Bundle> fragsAndReqsBundles = (Set<Bundle>)context.getAttribute(FRAGMENT_AND_REQUIRED_BUNDLES);\n            if (fragsAndReqsBundles == null)\n            {\n                fragsAndReqsBundles = new HashSet<Bundle>();\n                context.setAttribute(FRAGMENT_AND_REQUIRED_BUNDLES, fragsAndReqsBundles);\n            }\n            \n            Set<Resource> fragsAndReqsResources = (Set<Resource>)context.getAttribute(FRAGMENT_AND_REQUIRED_RESOURCES);\n            if (fragsAndReqsResources == null)\n            {\n                fragsAndReqsResources = new HashSet<Resource>();\n                context.setAttribute(FRAGMENT_AND_REQUIRED_RESOURCES, fragsAndReqsResources);\n            }\n            \n            for (Bundle b : bundles)\n            {\n                //add to context attribute storing associated fragments and required bundles\n                fragsAndReqsBundles.add(b);\n                File f = BundleFileLocatorHelperFactory.getFactory().getHelper().getBundleInstallLocation(b);\n                Resource r = Resource.newResource(f.toURI());\n                //add to convenience context attribute storing fragments and required bundles as Resources\n                fragsAndReqsResources.add(r);\n                mergedResources.add(r);\n            }\n        }\n        \n        return mergedResources;\n    }","commit_id":"839485797b74e8dac0180348e14a7464a7816525","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/** \n     * Allow fragments to supply some resources that are added to the baseResource of the webapp.\n     * \n     * The resources can be either prepended or appended to the baseResource.\n     * \n     * @see org.eclipse.jetty.webapp.WebInfConfiguration#configure(org.eclipse.jetty.webapp.WebAppContext)\n     */\n    @Override\n    public void configure(WebAppContext context) throws Exception\n    {\n        TreeMap<String, Resource> patchResourcesPath = new TreeMap<String, Resource>();\n        TreeMap<String, Resource> appendedResourcesPath = new TreeMap<String, Resource>();\n             \n        Bundle bundle = (Bundle)context.getAttribute(OSGiWebappConstants.JETTY_OSGI_BUNDLE);\n        if (bundle != null)\n        {\n            //TODO anything we need to do to improve PackageAdminServiceTracker?\n            Bundle[] fragments = PackageAdminServiceTracker.INSTANCE.getFragmentsAndRequiredBundles(bundle);\n            if (fragments != null && fragments.length != 0)\n            {\n                // sorted extra resource base found in the fragments.\n                // the resources are either overriding the resourcebase found in the\n                // web-bundle\n                // or appended.\n                // amongst each resource we sort them according to the alphabetical\n                // order\n                // of the name of the internal folder and the symbolic name of the\n                // fragment.\n                // this is useful to make sure that the lookup path of those\n                // resource base defined by fragments is always the same.\n                // This natural order could be abused to define the order in which\n                // the base resources are\n                // looked up.\n                for (Bundle frag : fragments)\n                {\n                    String fragFolder = (String) frag.getHeaders().get(OSGiWebappConstants.JETTY_WAR_FRAGMENT_FOLDER_PATH);\n                    String patchFragFolder = (String) frag.getHeaders().get(OSGiWebappConstants.JETTY_WAR_PATCH_FRAGMENT_FOLDER_PATH);\n                    if (fragFolder != null)\n                    {\n                        URL fragUrl = frag.getEntry(fragFolder);\n                        if (fragUrl == null) { throw new IllegalArgumentException(\"Unable to locate \" + fragFolder\n                                                                                  + \" inside \"\n                                                                                  + \" the fragment '\"\n                                                                                  + frag.getSymbolicName()\n                                                                                  + \"'\"); }\n                        fragUrl = BundleFileLocatorHelperFactory.getFactory().getHelper().getLocalURL(fragUrl);\n                        String key = fragFolder.startsWith(\"/\") ? fragFolder.substring(1) : fragFolder;\n                        appendedResourcesPath.put(key + \";\" + frag.getSymbolicName(), Resource.newResource(fragUrl));\n                    }\n                    if (patchFragFolder != null)\n                    {\n                        URL patchFragUrl = frag.getEntry(patchFragFolder);\n                        if (patchFragUrl == null)\n                        { \n                            throw new IllegalArgumentException(\"Unable to locate \" + patchFragUrl\n                                                               + \" inside fragment '\"+frag.getSymbolicName()+ \"'\"); \n                        }\n                        patchFragUrl = BundleFileLocatorHelperFactory.getFactory().getHelper().getLocalURL(patchFragUrl);\n                        String key = patchFragFolder.startsWith(\"/\") ? patchFragFolder.substring(1) : patchFragFolder;\n                        patchResourcesPath.put(key + \";\" + frag.getSymbolicName(), Resource.newResource(patchFragUrl));\n                    }\n                }\n                if (!appendedResourcesPath.isEmpty())\n                    context.setAttribute(WebInfConfiguration.RESOURCE_DIRS, new HashSet<Resource>(appendedResourcesPath.values()));\n            }\n        }\n        \n        super.configure(context);\n\n        // place the patch resources at the beginning of the contexts's resource base\n        if (!patchResourcesPath.isEmpty())\n        {\n            Resource[] resources = new Resource[1+patchResourcesPath.size()];\n            ResourceCollection mergedResources = new ResourceCollection (patchResourcesPath.values().toArray(new Resource[patchResourcesPath.size()]));\n            System.arraycopy(patchResourcesPath.values().toArray(new Resource[patchResourcesPath.size()]), 0, resources, 0, patchResourcesPath.size());\n            resources[resources.length-1] = context.getBaseResource();\n            context.setBaseResource(new ResourceCollection(resources));\n        }\n    }","id":73693,"modified_method":"/** \n     * Allow fragments to supply some resources that are added to the baseResource of the webapp.\n     * \n     * The resources can be either prepended or appended to the baseResource.\n     * \n     * @see org.eclipse.jetty.webapp.WebInfConfiguration#configure(org.eclipse.jetty.webapp.WebAppContext)\n     */\n    @Override\n    public void configure(WebAppContext context) throws Exception\n    {\n        TreeMap<String, Resource> patchResourcesPath = new TreeMap<String, Resource>();\n        TreeMap<String, Resource> appendedResourcesPath = new TreeMap<String, Resource>();\n             \n        Bundle bundle = (Bundle)context.getAttribute(OSGiWebappConstants.JETTY_OSGI_BUNDLE);\n        if (bundle != null)\n        {\n            Set<Bundle> fragments = (Set<Bundle>)context.getAttribute(FRAGMENT_AND_REQUIRED_BUNDLES);\n            if (fragments != null && !fragments.isEmpty())\n            {\n                // sorted extra resource base found in the fragments.\n                // the resources are either overriding the resourcebase found in the\n                // web-bundle\n                // or appended.\n                // amongst each resource we sort them according to the alphabetical\n                // order\n                // of the name of the internal folder and the symbolic name of the\n                // fragment.\n                // this is useful to make sure that the lookup path of those\n                // resource base defined by fragments is always the same.\n                // This natural order could be abused to define the order in which\n                // the base resources are\n                // looked up.\n                for (Bundle frag : fragments)\n                {\n                    String fragFolder = (String) frag.getHeaders().get(OSGiWebappConstants.JETTY_WAR_FRAGMENT_FOLDER_PATH);\n                    String patchFragFolder = (String) frag.getHeaders().get(OSGiWebappConstants.JETTY_WAR_PATCH_FRAGMENT_FOLDER_PATH);\n                    if (fragFolder != null)\n                    {\n                        URL fragUrl = frag.getEntry(fragFolder);\n                        if (fragUrl == null) { throw new IllegalArgumentException(\"Unable to locate \" + fragFolder\n                                                                                  + \" inside \"\n                                                                                  + \" the fragment '\"\n                                                                                  + frag.getSymbolicName()\n                                                                                  + \"'\"); }\n                        fragUrl = BundleFileLocatorHelperFactory.getFactory().getHelper().getLocalURL(fragUrl);\n                        String key = fragFolder.startsWith(\"/\") ? fragFolder.substring(1) : fragFolder;\n                        appendedResourcesPath.put(key + \";\" + frag.getSymbolicName(), Resource.newResource(fragUrl));\n                    }\n                    if (patchFragFolder != null)\n                    {\n                        URL patchFragUrl = frag.getEntry(patchFragFolder);\n                        if (patchFragUrl == null)\n                        { \n                            throw new IllegalArgumentException(\"Unable to locate \" + patchFragUrl\n                                                               + \" inside fragment '\"+frag.getSymbolicName()+ \"'\"); \n                        }\n                        patchFragUrl = BundleFileLocatorHelperFactory.getFactory().getHelper().getLocalURL(patchFragUrl);\n                        String key = patchFragFolder.startsWith(\"/\") ? patchFragFolder.substring(1) : patchFragFolder;\n                        patchResourcesPath.put(key + \";\" + frag.getSymbolicName(), Resource.newResource(patchFragUrl));\n                    }\n                }\n                if (!appendedResourcesPath.isEmpty())\n                    context.setAttribute(WebInfConfiguration.RESOURCE_DIRS, new HashSet<Resource>(appendedResourcesPath.values()));\n            }\n        }\n        \n        super.configure(context);\n\n        // place the patch resources at the beginning of the contexts's resource base\n        if (!patchResourcesPath.isEmpty())\n        {\n            Resource[] resources = new Resource[1+patchResourcesPath.size()];\n            ResourceCollection mergedResources = new ResourceCollection (patchResourcesPath.values().toArray(new Resource[patchResourcesPath.size()]));\n            System.arraycopy(patchResourcesPath.values().toArray(new Resource[patchResourcesPath.size()]), 0, resources, 0, patchResourcesPath.size());\n            resources[resources.length-1] = context.getBaseResource();\n            context.setBaseResource(new ResourceCollection(resources));\n        }\n    }","commit_id":"839485797b74e8dac0180348e14a7464a7816525","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public int compareContigs( GenomeLoc that ) {\n        return compareContigs( this.contig, that.contig );\n    }","id":73694,"modified_method":"public final int compareContigs( GenomeLoc that ) {\n        return (this.contigIndex == that.contigIndex)?0:((this.contigIndex < that.contigIndex)?-1:1);\n    }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"public final boolean discontinuousP(GenomeLoc that) {\n        if ( compareContigs(this.contig, that.contig) != 0 ) return true;   // different chromosomes\n        if ( (this.start - 1) > that.stop ) return true;                          // this guy is past that\n        if ( (that.start - 1) > this.stop ) return true;                          // that guy is past our start\n        return false;\n    }","id":73695,"modified_method":"public final boolean discontinuousP(GenomeLoc that) {\n        if ( this.contigIndex != that.contigIndex ) return true;    // different chromosomes\n        if ( (this.start - 1) > that.stop ) return true;            // this guy is past that\n        if ( (that.start - 1) > this.stop ) return true;            // that guy is past our start\n        return false;\n    }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int compareTo( GenomeLoc that ) {\n        if ( this == that ) return 0;\n\n        final int cmpContig = compareContigs( this.getContig(), that.getContig() );\n        if ( cmpContig != 0 ) return cmpContig;\n        if ( this.getStart() < that.getStart() ) return -1;\n        if ( this.getStart() > that.getStart() ) return 1;\n\n        // TODO: and error is being thrown because we are treating reads with the same start positions\n        // but different stop as out of order\n        //if ( this.getStop() < that.getStop() ) return -1;\n        //if ( this.getStop() > that.getStop() ) return 1;\n        return 0;\n    }","id":73696,"modified_method":"public int compareTo( GenomeLoc that ) {\n        if ( this == that ) return 0;\n\n        final int cmpContig = compareContigs(that);\n\n        if ( cmpContig != 0 ) return cmpContig;\n        if ( this.getStart() < that.getStart() ) return -1;\n        if ( this.getStart() > that.getStart() ) return 1;\n\n        // TODO: and error is being thrown because we are treating reads with the same start positions\n        // but different stop as out of order\n        //if ( this.getStop() < that.getStop() ) return -1;\n        //if ( this.getStop() > that.getStop() ) return 1;\n        return 0;\n    }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"public GenomeLoc( final GenomeLoc toCopy ) {\n        this( new String(toCopy.getContig()), toCopy.getStart(), toCopy.getStop() );\n    }","id":73697,"modified_method":"public GenomeLoc( final GenomeLoc toCopy ) {\n        this( toCopy.contigIndex, toCopy.getStart(), toCopy.getStop() );\n    }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static boolean overlapswithSortedLocsP(GenomeLoc curr, List<GenomeLoc> locs, boolean returnTrueIfEmpty) {\n        if ( locs.isEmpty() )\n            return returnTrueIfEmpty;\n\n        // skip loci before intervals begin\n        if ( hasKnownContigOrdering() && getContigIndex(curr.contig) < getContigIndex(locs.get(0).contig) )\n            return false;\n\n        for ( GenomeLoc loc : locs ) {\n            //System.out.printf(\"  Overlap %s vs. %s => %b%n\", loc, curr, loc.overlapsP(curr));\n            if ( loc.overlapsP(curr) )\n                return true;\n            if ( curr.compareTo(loc) < 0 )\n                return false;\n        }\n        return false;\n    }","id":73698,"modified_method":"public static boolean overlapswithSortedLocsP(GenomeLoc curr, List<GenomeLoc> locs, boolean returnTrueIfEmpty) {\n        if ( locs.isEmpty() )\n            return returnTrueIfEmpty;\n\n        // skip loci before intervals begin\n        if ( hasKnownContigOrdering() && curr.contigIndex < locs.get(0).contigIndex )\n            return false;\n\n        for ( GenomeLoc loc : locs ) {\n            //System.out.printf(\"  Overlap %s vs. %s => %b%n\", loc, curr, loc.overlapsP(curr));\n            if ( loc.overlapsP(curr) )\n                return true;\n            if ( curr.compareTo(loc) < 0 )\n                return false;\n        }\n        return false;\n    }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void setContig(String contig) {\n        this.contig = contig;\n    }","id":73699,"modified_method":"public void setContig(String contig) {\n        this.contigIndex = contigInfo.getSequenceIndex(contig);\n    }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"public final String getContig() { return this.contig; }","id":73700,"modified_method":"public final String getContig() { return contigInfo.getSequence(this.contigIndex).getSequenceName(); }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"public final int minus( final GenomeLoc that ) {\n        if ( this.getContig().equals(that.getContig()) )\n            return (int) (this.getStart() - that.getStart());\n        else\n            return Integer.MAX_VALUE;\n    }","id":73701,"modified_method":"public final int minus( final GenomeLoc that ) {\n        if ( this.contigIndex == that.contigIndex )\n            return (int) (this.getStart() - that.getStart());\n        else\n            return Integer.MAX_VALUE;\n    }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"public final boolean isUnmapped() { return this.contig == null; }","id":73702,"modified_method":"public final boolean isUnmapped() { return this.contigIndex == SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX; }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static GenomeLoc parseGenomeLoc( final String str ) {\n        // 'chr2', 'chr2:1000000' or 'chr2:1,000,000-2,000,000'\n        //System.out.printf(\"Parsing location '%s'%n\", str);\n\n        final Pattern regex1 = Pattern.compile(\"([\\\\w&&[^:]]+)$\");             // matches case 1\n        final Pattern regex2 = Pattern.compile(\"([\\\\w&&[^:]]+):([\\\\d,]+)$\");      // matches case 2\n        final Pattern regex3 = Pattern.compile(\"([\\\\w&&[^:]]+):([\\\\d,]+)-([\\\\d,]+)$\");// matches case 3\n\n        String contig = null;\n        long start = 1;\n        long stop = Integer.MAX_VALUE;\n        boolean bad = false;\n\n        Matcher match1 = regex1.matcher(str);\n        Matcher match2 = regex2.matcher(str);\n        Matcher match3 = regex3.matcher(str);\n\n        try {\n            if ( match1.matches() ) {\n                contig = match1.group(1);\n            }\n            else if ( match2.matches() ) {\n                contig = match2.group(1);\n                start = parsePosition(match2.group(2));\n            }\n            else if ( match3.matches() ) {\n                contig = match3.group(1);\n                start = parsePosition(match3.group(2));\n                stop = parsePosition(match3.group(3));\n\n                if ( start > stop )\n                    bad = true;\n            }\n            else {\n                bad = true;\n            }\n        } catch ( Exception e ) {\n            bad = true;\n        }\n\n        if ( bad ) {\n            throw new RuntimeException(\"Invalid Genome Location string: \" + str);\n        }\n\n        if ( stop == Integer.MAX_VALUE && hasKnownContigOrdering() ) {\n            // lookup the actually stop position!\n            stop = getContigInfo(contig).getSequenceLength();\n        }\n\n        GenomeLoc loc = new GenomeLoc(contig, start, stop);\n //       System.out.printf(\"  => Parsed location '%s' into %s%n\", str, loc);\n\n        return loc;\n    }","id":73703,"modified_method":"public static GenomeLoc parseGenomeLoc( final String str ) {\n        // 'chr2', 'chr2:1000000' or 'chr2:1,000,000-2,000,000'\n        //System.out.printf(\"Parsing location '%s'%n\", str);\n\n        final Pattern regex1 = Pattern.compile(\"([\\\\w&&[^:]]+)$\");             // matches case 1\n        final Pattern regex2 = Pattern.compile(\"([\\\\w&&[^:]]+):([\\\\d,]+)$\");      // matches case 2\n        final Pattern regex3 = Pattern.compile(\"([\\\\w&&[^:]]+):([\\\\d,]+)-([\\\\d,]+)$\");// matches case 3\n\n        String contig = null;\n        long start = 1;\n        long stop = Integer.MAX_VALUE;\n        boolean bad = false;\n\n        Matcher match1 = regex1.matcher(str);\n        Matcher match2 = regex2.matcher(str);\n        Matcher match3 = regex3.matcher(str);\n\n        try {\n            if ( match1.matches() ) {\n                contig = match1.group(1);\n            }\n            else if ( match2.matches() ) {\n                contig = match2.group(1);\n                start = parsePosition(match2.group(2));\n                stop = start;                \n            }\n            else if ( match3.matches() ) {\n                contig = match3.group(1);\n                start = parsePosition(match3.group(2));\n                stop = parsePosition(match3.group(3));\n\n                if ( start > stop )\n                    bad = true;\n            }\n            else {\n                bad = true;\n            }\n        } catch ( Exception e ) {\n            bad = true;\n        }\n\n        if ( bad ) {\n            throw new RuntimeException(\"Invalid Genome Location string: \" + str);\n        }\n\n        if ( stop == Integer.MAX_VALUE && hasKnownContigOrdering() ) {\n            // lookup the actually stop position!\n            stop = getContigInfo(contig).getSequenceLength();\n        }\n\n        GenomeLoc loc = new GenomeLoc(contig, start, stop);\n //       System.out.printf(\"  => Parsed location '%s' into %s%n\", str, loc);\n\n        return loc;\n    }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"public final boolean onSameContig(GenomeLoc that) {\n        return this.contig.equals(that.contig);\n    }","id":73704,"modified_method":"public final boolean onSameContig(GenomeLoc that) {\n        return (this.contigIndex == that.contigIndex);\n    }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static GenomeLoc genomicLocationOf(final SAMRecord read) {\n        String contig = read.getReferenceName();\n        if (read.getReadUnmappedFlag())\n            contig = null;\n        return new GenomeLoc(contig, read.getAlignmentStart(), read.getAlignmentEnd());\n    }","id":73705,"modified_method":"public static GenomeLoc genomicLocationOf(final SAMRecord read) {\n        return new GenomeLoc(read.getReferenceIndex(), read.getAlignmentStart(), read.getAlignmentEnd());\n    }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"public GenomeLoc( String contig, final long start, final long stop ) {\n        if ( interns != null )\n            contig = interns.get(contig);\n\n        this.contig = contig;\n        this.start = start;\n        this.stop = stop;\n    }","id":73706,"modified_method":"public GenomeLoc( String contig, final long start, final long stop ) {\n        this(contigInfo.getSequenceIndex(contig), start, stop);\n    }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"public final boolean disjointP(GenomeLoc that) {\n        if ( compareContigs(this.contig, that.contig) != 0 ) return true;   // different chromosomes\n        if ( this.start > that.stop ) return true;                          // this guy is past that\n        if ( that.start > this.stop ) return true;                          // that guy is past our start\n        return false;\n    }","id":73707,"modified_method":"public final boolean disjointP(GenomeLoc that) {\n        if ( this.contigIndex != that.contigIndex ) return true;    // different chromosomes\n        if ( this.start > that.stop ) return true;                  // this guy is past that\n        if ( that.start > this.stop ) return true;                  // that guy is past our start\n        return false;\n    }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected void hangRead(final SAMRecord read) {\n        GenomeLoc readLoc = new GenomeLoc(read.getReferenceName(), read.getAlignmentStart());\n        //System.out.printf(\"Adding read %s at %d%n\", read.getReadName(), read.getAlignmentStart());\n        \n        /*\n        for ( int i = 0; i < read.getReadLength(); i++ ) {\n            GenomeLoc offset = new GenomeLoc(readLoc.getContig(), readLoc.getStart() + i);\n            readHanger.expandingPut(offset, read);\n            offsetHanger.expandingPut(offset, i);\n        }\n        */\n\n        for ( AlignmentBlock block : read.getAlignmentBlocks() ) {\n            if ( DEBUG )\n                logger.debug(String.format(\"Processing block %s len=%d%n\", block, block.getLength()));\n            for ( int i = 0; i < block.getLength(); i++ ) {\n                GenomeLoc offset = new GenomeLoc(readLoc.getContig(), block.getReferenceStart() + i);\n                readHanger.expandingPut(offset, read);\n                offsetHanger.expandingPut(offset, block.getReadStart() + i - 1);\n                if ( DEBUG )\n                    logger.debug(String.format(\"  # Added %s%n\", offset));\n            }\n        }\n    }","id":73708,"modified_method":"protected void hangRead(final SAMRecord read) {\n        GenomeLoc readLoc = new GenomeLoc(read.getReferenceIndex(), read.getAlignmentStart());\n        //System.out.printf(\"Adding read %s at %d%n\", read.getReadName(), read.getAlignmentStart());\n        \n        /*\n        for ( int i = 0; i < read.getReadLength(); i++ ) {\n            GenomeLoc offset = new GenomeLoc(readLoc.getContig(), readLoc.getStart() + i);\n            readHanger.expandingPut(offset, read);\n            offsetHanger.expandingPut(offset, i);\n        }\n        */\n\n        for ( AlignmentBlock block : read.getAlignmentBlocks() ) {\n            if ( DEBUG )\n                logger.debug(String.format(\"Processing block %s len=%d%n\", block, block.getLength()));\n            for ( int i = 0; i < block.getLength(); i++ ) {\n                GenomeLoc offset = new GenomeLoc(readLoc.getContigIndex(), block.getReferenceStart() + i);\n                readHanger.expandingPut(offset, read);\n                offsetHanger.expandingPut(offset, block.getReadStart() + i - 1);\n                if ( DEBUG )\n                    logger.debug(String.format(\"  # Added %s%n\", offset));\n            }\n        }\n    }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public void onTraversalDone(Integer result) {\n        out.println(String.format(\"FINAL - %d %d %d %d\", totalSites, tumorCovered, normalCovered, somaticCovered));\n    }","id":73709,"modified_method":"@Override\n    public void onTraversalDone(Integer result) {\n//        out.println(String.format(\"FINAL - %d %d %d %d\", totalSites, tumorCovered, normalCovered, somaticCovered));\n    }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Integer map(RefMetaDataTracker tracker, char ref, LocusContext context) {\n\n        List<SAMRecord> reads = context.getReads();\n        int tumorDepth = 0;\n        int normalDepth = 0;\n        for ( int i = 0; i < reads.size(); i++ )\n        {\n            SAMRecord read = reads.get(i);\n\n            // TODO: could this be done better elsewhere?\n            // only process primary, non duplicate alignments\n            // that come from fully mapped pairs with a mappign quality threshold >= x\n            if (read.getNotPrimaryAlignmentFlag() ||\n                read.getDuplicateReadFlag() ||\n                read.getReadUnmappedFlag()\n        ||\n                read.getMateUnmappedFlag() ||\n                read.getMappingQuality() < MAPPING_QUALITY_THRESHOLD\n                    ) {\n                continue;\n            }\n\n            String rg = (String) read.getAttribute(\"RG\");\n            String sample = read.getHeader().getReadGroup(rg).getSample();\n\n\n\n            if (normalSampleName.equals(sample)) {\n                normalDepth++;\n            } else if (tumorSampleName.equals(sample)) {\n                tumorDepth++;\n            } else {\n                throw new RuntimeException(\"Unknown Sample Name: \" + sample);\n            }\n\n        }\n\n\n        boolean isTumorCovered = tumorDepth >= 14;\n        boolean isNormalCovered = normalDepth >= 8;\n\n        if (isTumorCovered) { tumorCovered++; }\n        if (isNormalCovered) { normalCovered++; }\n        if (isTumorCovered && isNormalCovered) {somaticCovered++; }\n        totalSites++;\n\n        if (totalSites % 20000 == 0) {\n            out.println(String.format(\"%s:%d %d %d %d %d\", context.getContig(), context.getPosition(), totalSites, tumorCovered, normalCovered, somaticCovered));\n        }\n\n        return 1;\n    }","id":73710,"modified_method":"public Integer map(RefMetaDataTracker tracker, char ref, LocusContext context) {\n        if (start ==0) { start = System.currentTimeMillis(); }\n\n        List<SAMRecord> reads = context.getReads();\n        int tumorDepth = 0;\n        int normalDepth = 0;\n        for ( int i = 0; i < reads.size(); i++ )\n        {\n            SAMRecord read = reads.get(i);\n\n            // TODO: could this be done better elsewhere?\n            // only process primary, non duplicate alignments\n            // that come from fully mapped pairs with a mappign quality threshold >= x\n            if (read.getNotPrimaryAlignmentFlag() ||\n                read.getDuplicateReadFlag() ||\n                read.getReadUnmappedFlag() ||\n                read.getMappingQuality() < MAPPING_QUALITY_THRESHOLD\n//        ||\n//                read.getMateUnmappedFlag() ||\n                    ) {\n                continue;\n            }\n\n            String rg = (String) read.getAttribute(\"RG\");\n            String sample = read.getHeader().getReadGroup(rg).getSample();\n\n\n\n            if (normalSampleName.equals(sample)) {\n                normalDepth++;\n            } else if (tumorSampleName.equals(sample)) {\n                tumorDepth++;\n            } else {\n                throw new RuntimeException(\"Unknown Sample Name: \" + sample);\n            }\n\n        }\n\n\n        boolean isTumorCovered = tumorDepth >= 14;\n        boolean isNormalCovered = normalDepth >= 8;\n\n        if (isTumorCovered) { tumorCovered++; }\n        if (isNormalCovered) { normalCovered++; }\n        if (isTumorCovered && isNormalCovered) {somaticCovered++; }\n        totalSites++;\n\n//        if (totalSites % 100000 == 0) {\n//            long now = System.currentTimeMillis();\n//            out.println(String.format(\"%s:%d %d %d %d %d %dms\", context.getContig(), context.getPosition(), totalSites, tumorCovered, normalCovered, somaticCovered, (now-start)));\n//        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(context.getContig()).append(\" \");\n        sb.append(context.getPosition());\n        out.println(sb.toString());\n        return 1;\n    }","commit_id":"ce72932a454fec661d12c410ed377adacc680933","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void setHighlightingEnabled(boolean enable) {\n      Component target = enable ? myComponent : myHighlightComponent;\n      JRootPane rootPane = target == null ? null : SwingUtilities.getRootPane(target);\n      JComponent glassPane = rootPane == null ? null : (JComponent)rootPane.getGlassPane();\n      if (glassPane == null) {\n        myHighlightComponent = null;\n        return;\n      }\n      if (enable) {\n        myHighlightComponent = new HighlightComponent(new JBColor(JBColor.GREEN, JBColor.RED));\n\n        Point pt = SwingUtilities.convertPoint(myComponent, new Point(0, 0), rootPane);\n        myHighlightComponent.setBounds(pt.x, pt.y, myComponent.getWidth(), myComponent.getHeight());\n        glassPane.add(myHighlightComponent);\n      }\n      else {\n        glassPane.remove(myHighlightComponent);\n        myHighlightComponent = null;\n      }\n      glassPane.revalidate();\n      glassPane.repaint();\n    }","id":73711,"modified_method":"private void setHighlightingEnabled(boolean enable) {\n      if (myHighlightComponent != null) {\n        JComponent glassPane = getGlassPane(myHighlightComponent);\n        if (glassPane != null) {\n          glassPane.remove(myHighlightComponent);\n\n          glassPane.revalidate();\n          glassPane.repaint();\n        }\n        myHighlightComponent = null;\n      }\n\n      if (enable && myComponent != null) {\n        JComponent glassPane = getGlassPane(myComponent);\n        if (glassPane != null) {\n          myHighlightComponent = new HighlightComponent(new JBColor(JBColor.GREEN, JBColor.RED));\n\n          Point pt = SwingUtilities.convertPoint(myComponent, new Point(0, 0), glassPane);\n          myHighlightComponent.setBounds(pt.x, pt.y, myComponent.getWidth(), myComponent.getHeight());\n          glassPane.add(myHighlightComponent);\n\n          glassPane.revalidate();\n          glassPane.repaint();\n        }\n      }\n    }","commit_id":"8c37f7c225e4028db95ccbb770d5079125ba9e7a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateToolStripesVisibility(){\n    final boolean showButtons = !UISettings.getInstance().HIDE_TOOL_STRIPES;\n    myLeftStripe.setVisible(showButtons || myStripesOverlayed);\n    myRightStripe.setVisible(showButtons || myStripesOverlayed);\n    myTopStripe.setVisible(showButtons || myStripesOverlayed);\n    myBottomStripe.setVisible(showButtons || myStripesOverlayed);\n\n    boolean overlayed = !showButtons && myStripesOverlayed;\n\n    myLeftStripe.setOverlayed(overlayed);\n    myRightStripe.setOverlayed(overlayed);\n    myTopStripe.setOverlayed(overlayed);\n    myBottomStripe.setOverlayed(overlayed);\n\n    revalidate();\n    repaint();\n  }","id":73712,"modified_method":"private void updateToolStripesVisibility(){\n    boolean oldVisible = myLeftStripe.isVisible();\n\n    final boolean showButtons = !UISettings.getInstance().HIDE_TOOL_STRIPES;\n    boolean visible = showButtons || myStripesOverlayed;\n    myLeftStripe.setVisible(visible);\n    myRightStripe.setVisible(visible);\n    myTopStripe.setVisible(visible);\n    myBottomStripe.setVisible(visible);\n\n    boolean overlayed = !showButtons && myStripesOverlayed;\n\n    myLeftStripe.setOverlayed(overlayed);\n    myRightStripe.setOverlayed(overlayed);\n    myTopStripe.setOverlayed(overlayed);\n    myBottomStripe.setOverlayed(overlayed);\n\n\n    if (oldVisible != visible) {\n     revalidate();\n     repaint();\n    }\n  }","commit_id":"e5ef821bd0bec57bb5bb264a44e6e76b4cb3523d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GithubBasedProjectTemplate(String displayName,\n                                    String githubUserName,\n                                    String githubRepositoryName,\n                                    String homepageUrl,\n                                    String description) {\n    myDisplayName = displayName;\n    myGithubUserName = githubUserName;\n    myGithubRepositoryName = githubRepositoryName;\n    myHomepageUrl = homepageUrl;\n    myDescription = description;\n  }","id":73713,"modified_method":"public GithubBasedProjectTemplate(String displayName,\n                                    String githubUserName,\n                                    String githubRepositoryName,\n                                    String homepageUrl,\n                                    String description,\n                                    String moduleType) {\n    myDisplayName = displayName;\n    myGithubUserName = githubUserName;\n    myGithubRepositoryName = githubRepositoryName;\n    myHomepageUrl = homepageUrl;\n    myDescription = description;\n    myModuleType = moduleType;\n  }","commit_id":"eba4fa09ef93e529acd827dadff57b68fee8bf98","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public ProjectTemplate[] createTemplates() {\n    return new ProjectTemplate[]{new GithubBasedProjectTemplate(\"Web Application\", null, \"JetBrains/idea-templates\", null, null)};\n  }","id":73714,"modified_method":"@NotNull\n  @Override\n  public ProjectTemplate[] createTemplates() {\n    return new ProjectTemplate[]{new GithubBasedProjectTemplate(\"Web Application\", null, \"JetBrains/idea-templates\", null, null, \"JAVA_MODULE\")};\n  }","commit_id":"eba4fa09ef93e529acd827dadff57b68fee8bf98","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GithubProjectGeneratorPeer(@NotNull AbstractGithubTagDownloadedProjectGenerator generator) {\n    String ghUserName = generator.getGithubUserName();\n    String ghRepoName = generator.getGithubRepositoryName();\n    myMasterTag = new GithubTagInfo(\n      \"master\",\n      String.format(\"https://github.com/%s/%s/zipball/master\", ghUserName, ghRepoName)\n    );\n    myHyperlink.setHyperlinkText(generator.getHomepageUrl());\n    myHyperlink.setHyperlinkTarget(generator.getHomepageUrl());\n    myHyperlink.revalidate();\n\n    myComboBox.setRenderer(new ListCellRendererWrapper<GithubTagInfo>() {\n      @Override\n      public void customize(JList list, GithubTagInfo tag, int index, boolean selected, boolean hasFocus) {\n        if (tag != null) {\n          setText(tag.getName());\n        }\n      }\n    });\n\n    myProvider = new GithubTagListProvider(ghUserName, ghRepoName);\n    ImmutableSet<GithubTagInfo> cachedTags = myProvider.getCachedTags();\n    if (cachedTags != null) {\n      updateTagList(cachedTags);\n    }\n\n    myErrorMessage.setText(null);\n    myReloadButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        asyncUpdateTags();\n      }\n    });\n    asyncUpdateTags();\n  }","id":73715,"modified_method":"public GithubProjectGeneratorPeer(@NotNull AbstractGithubTagDownloadedProjectGenerator generator) {\n    String ghUserName = generator.getGithubUserName();\n    String ghRepoName = generator.getGithubRepositoryName();\n    myMasterTag = new GithubTagInfo(\n      \"master\",\n      String.format(\"https://github.com/%s/%s/zipball/master\", ghUserName, ghRepoName)\n    );\n    String url = generator.getHomepageUrl();\n    if (url != null) {\n      myHomepageLabel.setVisible(true);\n      myHyperlink.setVisible(true);\n      myHyperlink.setHyperlinkText(url);\n      myHyperlink.setHyperlinkTarget(url);\n      myHyperlink.revalidate();\n    }\n    else {\n      myHomepageLabel.setVisible(false);\n      myHyperlink.setVisible(false);\n    }\n    myDescriptionLabel.setText(generator.getDescription());\n\n    myComboBox.setRenderer(new ListCellRendererWrapper<GithubTagInfo>() {\n      @Override\n      public void customize(JList list, GithubTagInfo tag, int index, boolean selected, boolean hasFocus) {\n        if (tag != null) {\n          setText(tag.getName());\n        }\n      }\n    });\n\n    myProvider = new GithubTagListProvider(ghUserName, ghRepoName);\n    ImmutableSet<GithubTagInfo> cachedTags = myProvider.getCachedTags();\n    if (cachedTags != null) {\n      updateTagList(cachedTags);\n    }\n\n    myErrorMessage.setText(null);\n    myReloadButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        asyncUpdateTags();\n      }\n    });\n    asyncUpdateTags();\n  }","commit_id":"eba4fa09ef93e529acd827dadff57b68fee8bf98","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JavaModuleType() {\n    this(\"JAVA_MODULE\");\n  }","id":73716,"modified_method":"public JavaModuleType() {\n    this(JAVA_MODULE);\n  }","commit_id":"eba4fa09ef93e529acd827dadff57b68fee8bf98","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public EditorWindow split(final int orientation, boolean forceSplit, @Nullable VirtualFile virtualFile, boolean focusNew) {\n    checkConsistency();\n    final FileEditorManagerImpl fileEditorManager = myOwner.getManager();\n    if (splitAvailable()) {\n      if (!forceSplit && inSplitter()) {\n        final EditorWindow[] siblings = findSiblings();\n        final EditorWindow target = siblings[0];\n        if (virtualFile != null) {\n          fileEditorManager.openFileImpl3(target, virtualFile, focusNew, null, true);\n        }\n        return target;\n      }\n      final JPanel panel = myPanel;\n      final int tabCount = getTabCount();\n      if (tabCount != 0) {\n        final EditorWithProviderComposite firstEC = getEditorAt(0);\n        myPanel = new JPanel(new BorderLayout());\n        final Splitter splitter = new Splitter(orientation == JSplitPane.VERTICAL_SPLIT, 0.5f, 0.1f, 0.9f);\n        final EditorWindow res = new EditorWindow(myOwner);\n        if (myTabbedPane != null) {\n          final EditorWithProviderComposite selectedEditor = getSelectedEditor();\n          panel.remove(myTabbedPane.getComponent());\n          panel.add(splitter, BorderLayout.CENTER);\n          splitter.setFirstComponent(myPanel);\n          myPanel.add(myTabbedPane.getComponent(), BorderLayout.CENTER);\n          splitter.setSecondComponent(res.myPanel);\n          /*\n          for (int i = 0; i != tabCount; ++i) {\n            final EditorWithProviderComposite eC = getEditorAt(i);\n            final VirtualFile file = eC.getFile();\n            fileEditorManager.openFileImpl3(res, file, false, null);\n            res.setFilePinned (file, isFilePinned (file));\n          }\n          */\n          // open only selected file in the new splitter instead of opening all tabs\n          final VirtualFile file = selectedEditor.getFile();\n          final VirtualFile nextFile = virtualFile == null ? file : virtualFile;\n          fileEditorManager.openFileImpl3(res, nextFile, false, null, true);\n          res.setFilePinned (nextFile, isFilePinned (file));\n          if (!focusNew) {\n            res.setSelectedEditor(selectedEditor, true);\n            selectedEditor.getComponent().requestFocus();\n          }\n          panel.revalidate();\n        }\n        else {\n          panel.removeAll();\n          panel.add(splitter, BorderLayout.CENTER);\n          splitter.setFirstComponent(myPanel);\n          splitter.setSecondComponent(res.myPanel);\n          panel.revalidate();\n          final VirtualFile firstFile = firstEC.getFile();\n          final VirtualFile nextFile = virtualFile == null ? firstFile : virtualFile;\n          fileEditorManager.openFileImpl3(this, firstFile, !focusNew, null, true);\n          fileEditorManager.openFileImpl3(res, nextFile, focusNew, null, true);\n        }\n        return res;\n      }\n    }\n    return null;\n  }","id":73717,"modified_method":"@Nullable\n  public EditorWindow split(final int orientation, boolean forceSplit, @Nullable VirtualFile virtualFile, boolean focusNew) {\n    checkConsistency();\n    final FileEditorManagerImpl fileEditorManager = myOwner.getManager();\n    if (splitAvailable()) {\n      if (!forceSplit && inSplitter()) {\n        final EditorWindow[] siblings = findSiblings();\n        final EditorWindow target = siblings[0];\n        if (virtualFile != null) {\n          final FileEditor[] editors = fileEditorManager.openFileImpl3(target, virtualFile, focusNew, null, true).first;\n          syncCaretIfPossible(editors);\n        }\n        return target;\n      }\n      final JPanel panel = myPanel;\n      final int tabCount = getTabCount();\n      if (tabCount != 0) {\n        final EditorWithProviderComposite firstEC = getEditorAt(0);\n        myPanel = new JPanel(new BorderLayout());\n        final Splitter splitter = new Splitter(orientation == JSplitPane.VERTICAL_SPLIT, 0.5f, 0.1f, 0.9f);\n        final EditorWindow res = new EditorWindow(myOwner);\n        if (myTabbedPane != null) {\n          final EditorWithProviderComposite selectedEditor = getSelectedEditor();\n          panel.remove(myTabbedPane.getComponent());\n          panel.add(splitter, BorderLayout.CENTER);\n          splitter.setFirstComponent(myPanel);\n          myPanel.add(myTabbedPane.getComponent(), BorderLayout.CENTER);\n          splitter.setSecondComponent(res.myPanel);\n          /*\n          for (int i = 0; i != tabCount; ++i) {\n            final EditorWithProviderComposite eC = getEditorAt(i);\n            final VirtualFile file = eC.getFile();\n            fileEditorManager.openFileImpl3(res, file, false, null);\n            res.setFilePinned (file, isFilePinned (file));\n          }\n          */\n          // open only selected file in the new splitter instead of opening all tabs\n          final VirtualFile file = selectedEditor.getFile();\n          final VirtualFile nextFile = virtualFile == null ? file : virtualFile;\n          final FileEditor[] editors = fileEditorManager.openFileImpl3(res, nextFile, false, null, true).first;\n          syncCaretIfPossible(editors);\n          res.setFilePinned (nextFile, isFilePinned (file));\n          if (!focusNew) {\n            res.setSelectedEditor(selectedEditor, true);\n            selectedEditor.getComponent().requestFocus();\n          }\n          panel.revalidate();\n        }\n        else {\n          panel.removeAll();\n          panel.add(splitter, BorderLayout.CENTER);\n          splitter.setFirstComponent(myPanel);\n          splitter.setSecondComponent(res.myPanel);\n          panel.revalidate();\n          final VirtualFile firstFile = firstEC.getFile();\n          final VirtualFile nextFile = virtualFile == null ? firstFile : virtualFile;\n          final FileEditor[] firstEditors = fileEditorManager.openFileImpl3(this, firstFile, !focusNew, null, true).first;\n          syncCaretIfPossible(firstEditors);\n          final FileEditor[] secondEditors = fileEditorManager.openFileImpl3(res, nextFile, focusNew, null, true).first;\n          syncCaretIfPossible(secondEditors);\n        }\n        return res;\n      }\n    }\n    return null;\n  }","commit_id":"4f59bf200833af4f35f5fd5c1082316ee0e3244e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void stopJobById(final String jobId, final boolean forward) {\n        final JobImpl job = (JobImpl)this.getJobById(jobId);\n        if ( job != null && !this.configuration.isStoragePath(job.getResourcePath()) ) {\n            // get the queue configuration\n            final QueueInfo queueInfo = queueConfigManager.getQueueInfo(job.getTopic());\n            final AbstractJobQueue queue;\n            synchronized ( queuesLock ) {\n                queue = this.queues.get(queueInfo.queueName);\n            }\n            boolean stopped = false;\n            if ( queue != null ) {\n                stopped = queue.stopJob(job);\n            }\n            if ( forward && !stopped ) {\n                // send remote event\n                final Map<String, Object> props = new HashMap<String, Object>();\n                props.put(Utility.PROPERTY_ID, jobId);\n                props.put(EventUtil.PROPERTY_DISTRIBUTE, \"\");\n                this.eventAdmin.sendEvent(new Event(Utility.TOPIC_STOP, props));\n            }\n        }\n    }","id":73718,"modified_method":"private void stopJobById(final String jobId, final boolean forward) {\n        final JobImpl job = (JobImpl)this.getJobById(jobId);\n        if ( job != null && !this.configuration.isStoragePath(job.getResourcePath()) ) {\n            // get the queue configuration\n            final QueueInfo queueInfo = this.queueManager.getQueueInfo(job.getTopic());\n            final AbstractJobQueue queue;\n            synchronized ( queuesLock ) {\n                queue = this.queues.get(queueInfo.queueName);\n            }\n            boolean stopped = false;\n            if ( queue != null ) {\n                stopped = queue.stopJob(job);\n            }\n            if ( forward && !stopped ) {\n                // TODO why not remove the resource?\n                // send remote event\n                final Map<String, Object> props = new HashMap<String, Object>();\n                props.put(Utility.PROPERTY_ID, jobId);\n                props.put(EventUtil.PROPERTY_DISTRIBUTE, \"\");\n                this.eventAdmin.sendEvent(new Event(Utility.TOPIC_STOP, props));\n            }\n        }\n    }","commit_id":"16c9dc85e861bf12ac0238ec3e0413dabaf90cd1","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * This method is invoked periodically by the scheduler.\n     * It searches for idle queues and stops them after a timeout. If a queue\n     * is idle for two consecutive clean up calls, it is removed.\n     * @see java.lang.Runnable#run()\n     */\n    private void maintain() {\n        this.schedulerRuns++;\n        logger.debug(\"Job manager maintenance: Starting #{}\", this.schedulerRuns);\n\n        // check for unprocessed jobs first\n        logger.debug(\"Checking for unprocessed jobs...\");\n        for(final AbstractJobQueue jbq : this.queues.values() ) {\n            jbq.checkForUnprocessedJobs();\n        }\n\n        // we only do a full clean up on every fifth run\n        final boolean doFullCleanUp = (schedulerRuns % 5 == 0);\n\n        if ( doFullCleanUp ) {\n            // check for idle queue\n            logger.debug(\"Checking for idle queues...\");\n\n           // we synchronize to avoid creating a queue which is about to be removed during cleanup\n            synchronized ( queuesLock ) {\n                final Iterator<Map.Entry<String, AbstractJobQueue>> i = this.queues.entrySet().iterator();\n                while ( i.hasNext() ) {\n                    final Map.Entry<String, AbstractJobQueue> current = i.next();\n                    final AbstractJobQueue jbq = current.getValue();\n                    if ( jbq.tryToClose() ) {\n                        logger.debug(\"Removing idle job queue {}\", jbq);\n                        // copy statistics\n                        this.baseStatistics.add(jbq);\n                        // remove\n                        i.remove();\n                        // update mbeans\n                        ((QueuesMBeanImpl)queuesMBean).sendEvent(new QueueStatusEvent(null, jbq));\n                    }\n                }\n            }\n        }\n        // invoke maintenance task\n        final MaintenanceTask task = this.maintenanceTask;\n        if ( task != null ) {\n            task.run(this.topologyCapabilities, this.queueConfigManager, this.schedulerRuns - 1);\n        }\n        logger.debug(\"Job manager maintenance: Finished #{}\", this.schedulerRuns);\n    }","id":73719,"modified_method":"/**\n     * This method is invoked periodically by the scheduler.\n     * It searches for idle queues and stops them after a timeout. If a queue\n     * is idle for two consecutive clean up calls, it is removed.\n     * @see java.lang.Runnable#run()\n     */\n    private void maintain() {\n        this.schedulerRuns++;\n        logger.debug(\"Job manager maintenance: Starting #{}\", this.schedulerRuns);\n\n        // check for unprocessed jobs first\n        logger.debug(\"Checking for unprocessed jobs...\");\n        for(final AbstractJobQueue jbq : this.queues.values() ) {\n            jbq.checkForUnprocessedJobs();\n        }\n\n        // we only do a full clean up on every fifth run\n        final boolean doFullCleanUp = (schedulerRuns % 5 == 0);\n\n        if ( doFullCleanUp ) {\n            // check for idle queue\n            logger.debug(\"Checking for idle queues...\");\n\n           // we synchronize to avoid creating a queue which is about to be removed during cleanup\n            synchronized ( queuesLock ) {\n                final Iterator<Map.Entry<String, AbstractJobQueue>> i = this.queues.entrySet().iterator();\n                while ( i.hasNext() ) {\n                    final Map.Entry<String, AbstractJobQueue> current = i.next();\n                    final AbstractJobQueue jbq = current.getValue();\n                    if ( jbq.tryToClose() ) {\n                        logger.debug(\"Removing idle job queue {}\", jbq);\n                        // copy statistics\n                        this.baseStatistics.add(jbq);\n                        // remove\n                        i.remove();\n                        // update mbeans\n                        ((QueuesMBeanImpl)queuesMBean).sendEvent(new QueueStatusEvent(null, jbq));\n                    }\n                }\n            }\n        }\n        // invoke maintenance task\n        final MaintenanceTask task = this.maintenanceTask;\n        if ( task != null ) {\n            task.run(this.topologyCapabilities, this.schedulerRuns - 1);\n        }\n        logger.debug(\"Job manager maintenance: Finished #{}\", this.schedulerRuns);\n    }","commit_id":"16c9dc85e861bf12ac0238ec3e0413dabaf90cd1","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Persist the job in the resource tree\n     * @param jobTopic The required job topic\n     * @param jobName The optional job name\n     * @param jobProperties The optional job properties\n     * @return The persisted job or <code>null<\/code>.\n     */\n    private Job addJobInteral(final String jobTopic,\n            final String jobName,\n            final Map<String, Object> jobProperties,\n            final List<String> errors) {\n        final QueueInfo info = this.queueConfigManager.getQueueInfo(jobTopic);\n        if ( info.queueConfiguration.getType() == QueueConfiguration.Type.DROP ) {\n            if ( logger.isDebugEnabled() ) {\n                logger.debug(\"Dropping job due to configuration of queue {} : {}\", info.queueName, Utility.toString(jobTopic, jobName, jobProperties));\n            }\n            Utility.sendNotification(this.eventAdmin, NotificationConstants.TOPIC_JOB_CANCELLED, jobTopic, jobName, jobProperties, null);\n        } else {\n            // check for unique jobs\n            if ( jobName != null && !this.lock(jobTopic, jobName) ) {\n                logger.debug(\"Discarding duplicate job {}\", Utility.toString(jobTopic, jobName, jobProperties));\n                return null;\n            } else {\n                if ( info.queueConfiguration.getType() != QueueConfiguration.Type.IGNORE ) {\n                    final TopologyCapabilities caps = this.topologyCapabilities;\n                    info.targetId = (caps == null ? null : caps.detectTarget(jobTopic, jobProperties, info));\n                }\n                if ( logger.isDebugEnabled() ) {\n                    if ( info.targetId != null ) {\n                        logger.debug(\"Persisting job {} into queue {}, target={}\", new Object[] {Utility.toString(jobTopic, jobName, jobProperties), info.queueName, info.targetId});\n                    } else {\n                        logger.debug(\"Persisting job {} into queue {}\", Utility.toString(jobTopic, jobName, jobProperties), info.queueName);\n                    }\n                }\n                final ResourceResolver resolver = this.configuration.createResourceResolver();\n                try {\n                    final JobImpl job = this.writeJob(resolver,\n                            jobTopic,\n                            jobName,\n                            jobProperties,\n                            info);\n                    if ( job != null ) {\n                        if ( configuration.isLocalJob(job.getResourcePath()) ) {\n                            this.backgroundLoader.addJob(job);\n                        }\n                        return job;\n                    }\n                } catch (final PersistenceException re ) {\n                    // something went wrong, so let's log it\n                    this.logger.error(\"Exception during persisting new job '\" + Utility.toString(jobTopic, jobName, jobProperties) + \"'\", re);\n                } finally {\n                    resolver.close();\n                }\n                if ( errors != null ) {\n                    errors.add(\"Unable to persist new job.\");\n                }\n            }\n        }\n        return null;\n    }","id":73720,"modified_method":"/**\n     * Persist the job in the resource tree\n     * @param jobTopic The required job topic\n     * @param jobName The optional job name\n     * @param jobProperties The optional job properties\n     * @return The persisted job or <code>null<\/code>.\n     */\n    private Job addJobInteral(final String jobTopic,\n            final String jobName,\n            final Map<String, Object> jobProperties,\n            final List<String> errors) {\n        final QueueInfo info = this.queueManager.getQueueInfo(jobTopic);\n        if ( info.queueConfiguration.getType() == QueueConfiguration.Type.DROP ) {\n            if ( logger.isDebugEnabled() ) {\n                logger.debug(\"Dropping job due to configuration of queue {} : {}\", info.queueName, Utility.toString(jobTopic, jobName, jobProperties));\n            }\n            Utility.sendNotification(this.eventAdmin, NotificationConstants.TOPIC_JOB_CANCELLED, jobTopic, jobName, jobProperties, null);\n        } else {\n            // check for unique jobs\n            if ( jobName != null && !this.lock(jobTopic, jobName) ) {\n                logger.debug(\"Discarding duplicate job {}\", Utility.toString(jobTopic, jobName, jobProperties));\n                return null;\n            } else {\n                if ( info.queueConfiguration.getType() != QueueConfiguration.Type.IGNORE ) {\n                    final TopologyCapabilities caps = this.topologyCapabilities;\n                    info.targetId = (caps == null ? null : caps.detectTarget(jobTopic, jobProperties, info));\n                }\n                if ( logger.isDebugEnabled() ) {\n                    if ( info.targetId != null ) {\n                        logger.debug(\"Persisting job {} into queue {}, target={}\", new Object[] {Utility.toString(jobTopic, jobName, jobProperties), info.queueName, info.targetId});\n                    } else {\n                        logger.debug(\"Persisting job {} into queue {}\", Utility.toString(jobTopic, jobName, jobProperties), info.queueName);\n                    }\n                }\n                final ResourceResolver resolver = this.configuration.createResourceResolver();\n                try {\n                    final JobImpl job = this.writeJob(resolver,\n                            jobTopic,\n                            jobName,\n                            jobProperties,\n                            info);\n                    if ( job != null ) {\n                        if ( configuration.isLocalJob(job.getResourcePath()) ) {\n                            this.backgroundLoader.addJob(job);\n                        }\n                        return job;\n                    }\n                } catch (final PersistenceException re ) {\n                    // something went wrong, so let's log it\n                    this.logger.error(\"Exception during persisting new job '\" + Utility.toString(jobTopic, jobName, jobProperties) + \"'\", re);\n                } finally {\n                    resolver.close();\n                }\n                if ( errors != null ) {\n                    errors.add(\"Unable to persist new job.\");\n                }\n            }\n        }\n        return null;\n    }","commit_id":"16c9dc85e861bf12ac0238ec3e0413dabaf90cd1","url":"https://github.com/apache/sling"},{"original_method":"public void reassign(final JobImpl job) {\n        final QueueInfo queueInfo = queueConfigManager.getQueueInfo(job.getTopic());\n        final InternalQueueConfiguration config = queueInfo.queueConfiguration;\n\n        // Sanity check if queue configuration has changed\n        if ( config.getType() == QueueConfiguration.Type.DROP ) {\n            if ( logger.isDebugEnabled() ) {\n                logger.debug(\"Dropping job due to configuration of queue {} : {}\", queueInfo.queueName, Utility.toString(job));\n            }\n            this.finishJob(job, Job.JobState.DROPPED, false, -1); // DROP means complete removal\n        } else {\n            String targetId = null;\n            if ( config.getType() != QueueConfiguration.Type.IGNORE ) {\n                final TopologyCapabilities caps = this.topologyCapabilities;\n                targetId = (caps == null ? null : caps.detectTarget(job.getTopic(), job.getProperties(), queueInfo));\n            }\n            this.maintenanceTask.reassignJob(job, targetId);\n        }\n    }","id":73721,"modified_method":"public void reassign(final JobImpl job) {\n        final QueueInfo queueInfo = queueManager.getQueueInfo(job.getTopic());\n        final InternalQueueConfiguration config = queueInfo.queueConfiguration;\n\n        // Sanity check if queue configuration has changed\n        if ( config.getType() == QueueConfiguration.Type.DROP ) {\n            if ( logger.isDebugEnabled() ) {\n                logger.debug(\"Dropping job due to configuration of queue {} : {}\", queueInfo.queueName, Utility.toString(job));\n            }\n            this.finishJob(job, Job.JobState.DROPPED, false, -1); // DROP means complete removal\n        } else {\n            String targetId = null;\n            if ( config.getType() != QueueConfiguration.Type.IGNORE ) {\n                final TopologyCapabilities caps = this.topologyCapabilities;\n                targetId = (caps == null ? null : caps.detectTarget(job.getTopic(), job.getProperties(), queueInfo));\n            }\n            this.maintenanceTask.reassignJob(job, targetId);\n        }\n    }","commit_id":"16c9dc85e861bf12ac0238ec3e0413dabaf90cd1","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Process a new job\n     * This method first searches the corresponding queue - if such a queue\n     * does not exist yet, it is created and started.\n     *\n     * @param job The job\n     */\n    void process(final JobImpl job) {\n        // check if we still are able to process this job\n        final JobExecutor consumer = this.jobConsumerManager.getExecutor(job.getTopic());\n        boolean reassign = false;\n        String reassignTargetId = null;\n        if ( consumer == null && (!job.isBridgedEvent() || !this.jobConsumerManager.supportsBridgedEvents())) {\n            reassign = true;\n        }\n\n        // get the queue configuration\n        final QueueInfo queueInfo = queueConfigManager.getQueueInfo(job.getTopic());\n        final InternalQueueConfiguration config = queueInfo.queueConfiguration;\n\n        // Sanity check if queue configuration has changed\n        if ( config.getType() == QueueConfiguration.Type.DROP ) {\n            if ( logger.isDebugEnabled() ) {\n                logger.debug(\"Dropping job due to configuration of queue {} : {}\", queueInfo.queueName, Utility.toString(job));\n            }\n            this.finishJob(job, Job.JobState.DROPPED, false, -1);\n        } else if ( config.getType() == QueueConfiguration.Type.IGNORE ) {\n            if ( !reassign ) {\n                if ( logger.isDebugEnabled() ) {\n                    logger.debug(\"Ignoring job due to configuration of queue {} : {}\", queueInfo.queueName, Utility.toString(job));\n                }\n            }\n        } else {\n\n            if ( reassign ) {\n                final TopologyCapabilities caps = this.topologyCapabilities;\n                reassignTargetId = (caps == null ? null : caps.detectTarget(job.getTopic(), job.getProperties(), queueInfo));\n\n            } else {\n                // get or create queue\n                AbstractJobQueue queue = null;\n                // we synchronize to avoid creating a queue which is about to be removed during cleanup\n                synchronized ( queuesLock ) {\n                    queue = this.queues.get(queueInfo.queueName);\n                    // check for reconfiguration, we really do an identity check here(!)\n                    if ( queue != null && queue.getConfiguration() != config ) {\n                        this.outdateQueue(queue);\n                        // we use a new queue with the configuration\n                        queue = null;\n                    }\n                    if ( queue == null ) {\n                        if ( config.getType() == QueueConfiguration.Type.ORDERED ) {\n                            queue = new OrderedJobQueue(queueInfo.queueName, config, this.jobConsumerManager, this.threadPoolManager, this.eventAdmin);\n                        } else if ( config.getType() == QueueConfiguration.Type.UNORDERED ) {\n                            queue = new ParallelJobQueue(queueInfo.queueName, config, this.jobConsumerManager, this.threadPoolManager, this.eventAdmin, this.scheduler);\n                        } else if ( config.getType() == QueueConfiguration.Type.TOPIC_ROUND_ROBIN ) {\n                            queue = new TopicRoundRobinJobQueue(queueInfo.queueName, config, this.jobConsumerManager, this.threadPoolManager, this.eventAdmin, this.scheduler);\n                        }\n                        if ( queue == null ) {\n                            // this is just a sanity check, actually we can never get here\n                            logger.warn(\"Ignoring event due to unknown queue type of queue {} : {}\", queueInfo.queueName, Utility.toString(job));\n                            this.finishJob(job, Job.JobState.DROPPED, false, -1);\n                        } else {\n                            queues.put(queueInfo.queueName, queue);\n                            ((QueuesMBeanImpl)queuesMBean).sendEvent(new QueueStatusEvent(queue, null));\n                            queue.start();\n                        }\n                    }\n                }\n\n                // and put job\n                if ( queue != null ) {\n                    job.updateQueueInfo(queue);\n                    final JobHandler handler = new JobHandler(job, this);\n\n                    queue.process(handler);\n                }\n            }\n        }\n        if ( reassign ) {\n            this.maintenanceTask.reassignJob(job, reassignTargetId);\n        }\n    }","id":73722,"modified_method":"/**\n     * Process a new job\n     * This method first searches the corresponding queue - if such a queue\n     * does not exist yet, it is created and started.\n     *\n     * @param job The job\n     */\n    void process(final JobImpl job) {\n        // check if we still are able to process this job\n        final JobExecutor consumer = this.jobConsumerManager.getExecutor(job.getTopic());\n        boolean reassign = false;\n        String reassignTargetId = null;\n        if ( consumer == null && (!job.isBridgedEvent() || !this.jobConsumerManager.supportsBridgedEvents())) {\n            reassign = true;\n        }\n\n        // get the queue configuration\n        final TopologyCapabilities caps = this.topologyCapabilities;\n        final QueueInfo queueInfo = caps != null ? caps.getQueueInfo(job.getTopic()) : null;\n        if ( queueInfo == null ) {\n            return; // TODO\n        }\n        final InternalQueueConfiguration config = queueInfo.queueConfiguration;\n\n        // Sanity check if queue configuration has changed\n        if ( config.getType() == QueueConfiguration.Type.DROP ) {\n            if ( logger.isDebugEnabled() ) {\n                logger.debug(\"Dropping job due to configuration of queue {} : {}\", queueInfo.queueName, Utility.toString(job));\n            }\n            this.finishJob(job, Job.JobState.DROPPED, false, -1);\n        } else if ( config.getType() == QueueConfiguration.Type.IGNORE ) {\n            if ( !reassign ) {\n                if ( logger.isDebugEnabled() ) {\n                    logger.debug(\"Ignoring job due to configuration of queue {} : {}\", queueInfo.queueName, Utility.toString(job));\n                }\n            }\n        } else {\n\n            if ( reassign ) {\n                reassignTargetId = (caps == null ? null : caps.detectTarget(job.getTopic(), job.getProperties(), queueInfo));\n\n            } else {\n                // get or create queue\n                AbstractJobQueue queue = null;\n                // we synchronize to avoid creating a queue which is about to be removed during cleanup\n                synchronized ( queuesLock ) {\n                    queue = this.queues.get(queueInfo.queueName);\n                    // check for reconfiguration, we really do an identity check here(!)\n                    if ( queue != null && queue.getConfiguration() != config ) {\n                        this.outdateQueue(queue);\n                        // we use a new queue with the configuration\n                        queue = null;\n                    }\n                    if ( queue == null ) {\n                        if ( config.getType() == QueueConfiguration.Type.ORDERED ) {\n                            queue = new OrderedJobQueue(queueInfo.queueName, config, this.jobConsumerManager, this.threadPoolManager, this.eventAdmin);\n                        } else if ( config.getType() == QueueConfiguration.Type.UNORDERED ) {\n                            queue = new ParallelJobQueue(queueInfo.queueName, config, this.jobConsumerManager, this.threadPoolManager, this.eventAdmin, this.scheduler);\n                        } else if ( config.getType() == QueueConfiguration.Type.TOPIC_ROUND_ROBIN ) {\n                            queue = new TopicRoundRobinJobQueue(queueInfo.queueName, config, this.jobConsumerManager, this.threadPoolManager, this.eventAdmin, this.scheduler);\n                        }\n                        if ( queue == null ) {\n                            // this is just a sanity check, actually we can never get here\n                            logger.warn(\"Ignoring event due to unknown queue type of queue {} : {}\", queueInfo.queueName, Utility.toString(job));\n                            this.finishJob(job, Job.JobState.DROPPED, false, -1);\n                        } else {\n                            queues.put(queueInfo.queueName, queue);\n                            ((QueuesMBeanImpl)queuesMBean).sendEvent(new QueueStatusEvent(queue, null));\n                            queue.start();\n                        }\n                    }\n                }\n\n                // and put job\n                if ( queue != null ) {\n                    job.updateQueueInfo(queue);\n                    final JobHandler handler = new JobHandler(job, this);\n\n                    queue.process(handler);\n                }\n            }\n        }\n        if ( reassign ) {\n            this.maintenanceTask.reassignJob(job, reassignTargetId);\n        }\n    }","commit_id":"16c9dc85e861bf12ac0238ec3e0413dabaf90cd1","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * One maintenance run\n     */\n    public void run(final TopologyCapabilities topologyCapabilities,\n            final QueueConfigurationManager queueManager,\n            final long cleanUpCounter) {\n        // check topology and config change during each invocation\n        final boolean topologyChanged = this.topologyHasChanged(topologyCapabilities);\n        final boolean configChanged = this.queueConfigurationHasChanged(topologyCapabilities, queueManager);\n\n        // if topology changed, reschedule assigned jobs for stopped instances\n        if ( topologyChanged ) {\n            this.reassignJobs(topologyCapabilities, queueManager);\n        }\n        // try to assign unassigned jobs\n        if ( topologyChanged || configChanged ) {\n            this.assignUnassignedJobs(topologyCapabilities, queueManager);\n        }\n\n        if ( topologyChanged && !this.checkedForPreviousVersion && topologyCapabilities != null && topologyCapabilities.isLeader() ) {\n            this.processJobsFromPreviousVersions(topologyCapabilities, queueManager);\n        }\n\n        if ( topologyCapabilities != null ) {\n            // Clean up\n            final String cleanUpAssignedPath;;\n            if ( topologyCapabilities.isLeader() ) {\n                cleanUpAssignedPath = this.configuration.getUnassignedJobsPath();\n            } else {\n                cleanUpAssignedPath = null;\n            }\n\n            if ( cleanUpCounter % 60 == 0 ) { // full clean up is done every hour\n                this.fullEmptyFolderCleanup(topologyCapabilities, this.configuration.getLocalJobsPath());\n                if ( cleanUpAssignedPath != null ) {\n                    this.fullEmptyFolderCleanup(topologyCapabilities, cleanUpAssignedPath);\n                }\n            } else if ( cleanUpCounter % 5 == 0 ) { // simple clean up every 5 minutes\n                this.simpleEmptyFolderCleanup(topologyCapabilities, this.configuration.getLocalJobsPath());\n                if ( cleanUpAssignedPath != null ) {\n                    this.simpleEmptyFolderCleanup(topologyCapabilities, cleanUpAssignedPath);\n                }\n            }\n        }\n\n        // lock cleanup is done every minute\n        this.lockCleanup(topologyCapabilities);\n    }","id":73723,"modified_method":"/**\n     * One maintenance run\n     */\n    public void run(final TopologyCapabilities topologyCapabilities,\n            final long cleanUpCounter) {\n        if ( topologyCapabilities != null ) {\n            // Clean up\n            final String cleanUpAssignedPath;;\n            if ( topologyCapabilities.isLeader() ) {\n                cleanUpAssignedPath = this.configuration.getUnassignedJobsPath();\n            } else {\n                cleanUpAssignedPath = null;\n            }\n\n            if ( cleanUpCounter % 60 == 0 ) { // full clean up is done every hour\n                this.fullEmptyFolderCleanup(topologyCapabilities, this.configuration.getLocalJobsPath());\n                if ( cleanUpAssignedPath != null ) {\n                    this.fullEmptyFolderCleanup(topologyCapabilities, cleanUpAssignedPath);\n                }\n            } else if ( cleanUpCounter % 5 == 0 ) { // simple clean up every 5 minutes\n                this.simpleEmptyFolderCleanup(topologyCapabilities, this.configuration.getLocalJobsPath());\n                if ( cleanUpAssignedPath != null ) {\n                    this.simpleEmptyFolderCleanup(topologyCapabilities, cleanUpAssignedPath);\n                }\n            }\n        }\n\n        // lock cleanup is done every minute\n        this.lockCleanup(topologyCapabilities);\n    }","commit_id":"16c9dc85e861bf12ac0238ec3e0413dabaf90cd1","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Activate this component.\n     * Create the service tracker and start it.\n     */\n    @Activate\n    protected void activate(final BundleContext bundleContext)\n    throws LoginException, PersistenceException {\n        this.configTracker = new ServiceTracker(bundleContext,\n                InternalQueueConfiguration.class.getName(), null);\n        this.configTracker.open();\n    }","id":73724,"modified_method":"/**\n     * Activate this component.\n     * Create the service tracker and start it.\n     */\n    @Activate\n    protected void activate(final BundleContext bundleContext)\n    throws LoginException, PersistenceException {\n        this.configTracker = new ServiceTracker(bundleContext,\n                InternalQueueConfiguration.class.getName(), new ServiceTrackerCustomizer() {\n\n                    @Override\n                    public void removedService(final ServiceReference reference, final Object service) {\n                        bundleContext.ungetService(reference);\n                        updateListeners();\n                    }\n\n                    @Override\n                    public void modifiedService(ServiceReference reference, Object service) {\n                        // nothing to do\n                    }\n\n                    @Override\n                    public Object addingService(final ServiceReference reference) {\n                        return bundleContext.getService(reference);\n                    }\n                });\n        this.configTracker.open();\n    }","commit_id":"16c9dc85e861bf12ac0238ec3e0413dabaf90cd1","url":"https://github.com/apache/sling"},{"original_method":"public TopologyCapabilities(final TopologyView view, final JobManagerConfiguration config) {\n        this.jobManagerConfiguration = config;\n        this.instanceComparator = new InstanceDescriptionComparator(view.getLocalInstance().getClusterView().getId());\n        this.isLeader = view.getLocalInstance().isLeader();\n        this.allInstances = getAllInstancesMap(view);\n        final Map<String, List<InstanceDescription>> newCaps = new HashMap<String, List<InstanceDescription>>();\n        for(final InstanceDescription desc : view.getInstances() ) {\n            final String topics = desc.getProperty(PROPERTY_TOPICS);\n            if ( topics != null && topics.length() > 0 ) {\n                this.logger.info(\"Detected capabilities of {} : {}\", desc.getSlingId(), topics);\n                for(final String topic : topics.split(\",\") ) {\n                    List<InstanceDescription> list = newCaps.get(topic);\n                    if ( list == null ) {\n                        list = new ArrayList<InstanceDescription>();\n                        newCaps.put(topic, list);\n                    }\n                    list.add(desc);\n                    Collections.sort(list, this.instanceComparator);\n                }\n            }\n            this.instanceMap.put(desc.getSlingId(), desc);\n        }\n        this.instanceCapabilities = newCaps;\n    }","id":73725,"modified_method":"public TopologyCapabilities(final TopologyView view,\n            final QueueConfigurationManager queueManager,\n            final JobManagerConfiguration config) {\n        this.jobManagerConfiguration = config;\n        this.queueManager = queueManager;\n        this.instanceComparator = new InstanceDescriptionComparator(view.getLocalInstance().getClusterView().getId());\n        this.isLeader = view.getLocalInstance().isLeader();\n        this.allInstances = getAllInstancesMap(view);\n        final Map<String, List<InstanceDescription>> newCaps = new HashMap<String, List<InstanceDescription>>();\n        for(final InstanceDescription desc : view.getInstances() ) {\n            final String topics = desc.getProperty(PROPERTY_TOPICS);\n            if ( topics != null && topics.length() > 0 ) {\n                this.logger.info(\"Detected capabilities of {} : {}\", desc.getSlingId(), topics);\n                for(final String topic : topics.split(\",\") ) {\n                    List<InstanceDescription> list = newCaps.get(topic);\n                    if ( list == null ) {\n                        list = new ArrayList<InstanceDescription>();\n                        newCaps.put(topic, list);\n                    }\n                    list.add(desc);\n                    Collections.sort(list, this.instanceComparator);\n                }\n            }\n            this.instanceMap.put(desc.getSlingId(), desc);\n        }\n        this.instanceCapabilities = newCaps;\n    }","commit_id":"16c9dc85e861bf12ac0238ec3e0413dabaf90cd1","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.discovery.TopologyEventListener#handleTopologyEvent(org.apache.sling.discovery.TopologyEvent)\n     */\n    @Override\n    public void handleTopologyEvent(final TopologyEvent event) {\n        this.logger.debug(\"Received topology event {}\", event);\n\n        // check if there is a change of properties which doesn't affect us\n        if ( event.getType() == Type.PROPERTIES_CHANGED ) {\n            final Map<String, String> newAllInstances = TopologyCapabilities.getAllInstancesMap(event.getNewView());\n            if ( this.topologyCapabilities != null && this.topologyCapabilities.isSame(newAllInstances) ) {\n                logger.debug(\"No changes in capabilities - ignoring event\");\n                return;\n            }\n        }\n\n        synchronized ( this.listeners ) {\n\n            if ( event.getType() == Type.TOPOLOGY_CHANGING ) {\n               this.stopProcessing();\n\n               for(final TopologyAware l : this.listeners) {\n                   l.topologyChanged(this.topologyCapabilities);\n               }\n            } else if ( event.getType() == Type.TOPOLOGY_INIT\n                || event.getType() == Type.TOPOLOGY_CHANGED\n                || event.getType() == Type.PROPERTIES_CHANGED ) {\n\n                this.stopProcessing();\n\n                this.startProcessing(event.getNewView());\n\n                for(final TopologyAware l : this.listeners) {\n                    l.topologyChanged(this.topologyCapabilities);\n                }\n            }\n\n        }\n    }","id":73726,"modified_method":"/**\n     * @see org.apache.sling.discovery.TopologyEventListener#handleTopologyEvent(org.apache.sling.discovery.TopologyEvent)\n     */\n    @Override\n    public void handleTopologyEvent(final TopologyEvent event) {\n        this.logger.debug(\"Received topology event {}\", event);\n\n        // check if there is a change of properties which doesn't affect us\n        if ( event.getType() == Type.PROPERTIES_CHANGED ) {\n            final Map<String, String> newAllInstances = TopologyCapabilities.getAllInstancesMap(event.getNewView());\n            if ( this.topologyCapabilities != null && this.topologyCapabilities.isSame(newAllInstances) ) {\n                logger.debug(\"No changes in capabilities - ignoring event\");\n                return;\n            }\n        }\n\n        synchronized ( this.listeners ) {\n\n            if ( event.getType() == Type.TOPOLOGY_CHANGING ) {\n               this.stopProcessing(true);\n\n            } else if ( event.getType() == Type.TOPOLOGY_INIT\n                || event.getType() == Type.TOPOLOGY_CHANGED\n                || event.getType() == Type.PROPERTIES_CHANGED ) {\n\n                this.stopProcessing(true);\n\n                this.startProcessing(event.getType(), new TopologyCapabilities(event.getNewView(), this.queueManager, this.configuration), false);\n            }\n\n        }\n    }","commit_id":"16c9dc85e861bf12ac0238ec3e0413dabaf90cd1","url":"https://github.com/apache/sling"},{"original_method":"private void startProcessing(final TopologyView view) {\n        // create new capabilities and update view\n        this.topologyCapabilities = new TopologyCapabilities(view, this.configuration);\n    }","id":73727,"modified_method":"private void startProcessing(final Type eventType, final TopologyCapabilities newCaps, final boolean isConfigChange) {\n        // create new capabilities and update view\n        this.topologyCapabilities = newCaps;\n\n        // before we propagate the new topology we do some maintenance\n        if ( eventType == Type.TOPOLOGY_INIT ) {\n            final UpgradeTask task = new UpgradeTask();\n            task.run(this.configuration, this.topologyCapabilities, queueManager);\n\n            final RestartTask rt = new RestartTask();\n            rt.run(this.configuration);\n        }\n\n        final MaintenanceTask mt = new MaintenanceTask(this.configuration);\n        mt.run(topologyCapabilities, queueManager, !isConfigChange, isConfigChange);\n\n        if ( !isConfigChange ) {\n            // start listeners\n            this.notifiyListeners();\n        }\n    }","commit_id":"16c9dc85e861bf12ac0238ec3e0413dabaf90cd1","url":"https://github.com/apache/sling"},{"original_method":"private void stopProcessing() {\n        // deactivate old capabilities - this stops all background processes\n        if ( this.topologyCapabilities != null ) {\n            this.topologyCapabilities.deactivate();\n        }\n        this.topologyCapabilities = null;\n    }","id":73728,"modified_method":"private void stopProcessing(final boolean deactivate) {\n        boolean notify = this.topologyCapabilities != null;\n        // deactivate old capabilities - this stops all background processes\n        if ( deactivate && this.topologyCapabilities != null ) {\n            this.topologyCapabilities.deactivate();\n        }\n        this.topologyCapabilities = null;\n\n        if ( notify ) {\n            // stop all listeners\n            this.notifiyListeners();\n        }\n    }","commit_id":"16c9dc85e861bf12ac0238ec3e0413dabaf90cd1","url":"https://github.com/apache/sling"},{"original_method":"private void notifiyListeners() {\n        for(final ConfigurationChangeListener l : this.listeners) {\n            l.configurationChanged(this.topologyCapabilities != null);\n        }\n    }","id":73729,"modified_method":"/**\n     * Notify all listeners\n     */\n    private void notifiyListeners() {\n        synchronized ( this.listeners ) {\n            final TopologyCapabilities caps = this.topologyCapabilities;\n            for(final ConfigurationChangeListener l : this.listeners) {\n                l.configurationChanged(caps != null);\n            }\n        }\n    }","commit_id":"8604bdbd41b33f73e1bb23f5e55fa480aa73b8bb","url":"https://github.com/apache/sling"},{"original_method":"public boolean isActive() {\n        return this.active.get();\n    }","id":73730,"modified_method":"/**\n     * Is this component still active?\n     * @return Active?\n     */\n    public boolean isActive() {\n        return this.active.get();\n    }","commit_id":"8604bdbd41b33f73e1bb23f5e55fa480aa73b8bb","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * This method is invoked asynchronously from the TopologyHandler.\n     * Therefore this method can't be invoked concurrently\n     * @see org.apache.sling.discovery.TopologyEventListener#handleTopologyEvent(org.apache.sling.discovery.TopologyEvent)\n     */\n    public void handleTopologyEvent(final TopologyEvent event) {\n        this.logger.debug(\"Received topology event {}\", event);\n\n        // queue configuration changed?\n        if ( event == null ) {\n            final TopologyCapabilities caps = this.topologyCapabilities;\n            if ( caps != null && this.isActive() ) {\n                this.startProcessing(Type.PROPERTIES_CHANGED, caps, true, true);\n            }\n            return;\n        }\n\n        boolean runMaintenanceTasks = true;\n        // check if there is a change of properties which doesn't affect us\n        // but we need to use the new view !\n        if ( event.getType() == Type.PROPERTIES_CHANGED ) {\n            final Map<String, String> newAllInstances = TopologyCapabilities.getAllInstancesMap(event.getNewView());\n            if ( this.topologyCapabilities != null && this.topologyCapabilities.isSame(newAllInstances) ) {\n                logger.debug(\"No changes in capabilities - restarting without maintenance tasks\");\n                runMaintenanceTasks = false;\n            }\n        }\n\n        TopologyEvent.Type eventType = event.getType();\n        if( this.firstTopologyEvent.compareAndSet(true, false) ) {\n            if ( eventType == Type.TOPOLOGY_CHANGED ) {\n                eventType = Type.TOPOLOGY_INIT;\n            }\n        }\n        synchronized ( this.listeners ) {\n\n            if ( eventType == Type.TOPOLOGY_CHANGING ) {\n               this.stopProcessing();\n\n            } else if ( eventType == Type.TOPOLOGY_INIT\n                || event.getType() == Type.TOPOLOGY_CHANGED\n                || event.getType() == Type.PROPERTIES_CHANGED ) {\n\n                this.stopProcessing();\n\n                this.startProcessing(eventType, new TopologyCapabilities(event.getNewView(), this), false, runMaintenanceTasks);\n            }\n\n        }\n    }","id":73731,"modified_method":"/**\n     * This method is invoked asynchronously from the TopologyHandler.\n     * Therefore this method can't be invoked concurrently\n     * @see org.apache.sling.discovery.TopologyEventListener#handleTopologyEvent(org.apache.sling.discovery.TopologyEvent)\n     */\n    public void handleTopologyEvent(final TopologyEvent event) {\n        this.logger.debug(\"Received topology event {}\", event);\n\n        // check if there is a change of properties which doesn't affect us\n        // but we need to use the new view !\n        boolean stopProcessing = true;\n        if ( event.getType() == Type.PROPERTIES_CHANGED ) {\n            final Map<String, String> newAllInstances = TopologyCapabilities.getAllInstancesMap(event.getNewView());\n            if ( this.topologyCapabilities != null && this.topologyCapabilities.isSame(newAllInstances) ) {\n                logger.debug(\"No changes in capabilities - updating topology capabilities with new view\");\n                stopProcessing = false;\n            }\n        }\n\n        final TopologyEvent.Type eventType = event.getType();\n\n        if ( eventType == Type.TOPOLOGY_CHANGING ) {\n           this.stopProcessing();\n\n        } else if ( eventType == Type.TOPOLOGY_INIT\n            || event.getType() == Type.TOPOLOGY_CHANGED\n            || event.getType() == Type.PROPERTIES_CHANGED ) {\n\n            if ( stopProcessing ) {\n                this.stopProcessing();\n            }\n\n            this.startProcessing(eventType, new TopologyCapabilities(event.getNewView(), this));\n        }\n    }","commit_id":"8604bdbd41b33f73e1bb23f5e55fa480aa73b8bb","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Start processing\n     * @param eventType The event type\n     * @param newCaps The new capabilities\n     * @param isConfigChange If a configuration change occured.\n     */\n    private void startProcessing(final Type eventType, final TopologyCapabilities newCaps,\n            final boolean isConfigChange,\n            final boolean runMaintenanceTasks) {\n        logger.debug(\"Starting job processing...\");\n        // create new capabilities and update view\n        this.topologyCapabilities = newCaps;\n\n        // before we propagate the new topology we do some maintenance\n        if ( eventType == Type.TOPOLOGY_INIT ) {\n            final UpgradeTask task = new UpgradeTask(this);\n            task.run();\n\n            final FindUnfinishedJobsTask rt = new FindUnfinishedJobsTask(this);\n            rt.run();\n        }\n\n        final CheckTopologyTask mt = new CheckTopologyTask(this);\n        if ( runMaintenanceTasks ) {\n            // we run the checker task twice, now and shortly after the topology has changed.\n            mt.fullRun(!isConfigChange, isConfigChange);\n        }\n\n        if ( eventType == Type.TOPOLOGY_INIT ) {\n            notifiyListeners();\n        } else {\n            // and run checker again in some seconds (if leader)\n            // notify listeners afterwards\n            final Scheduler local = this.scheduler;\n            if ( local != null ) {\n                local.schedule(new Runnable() {\n\n                    @Override\n                    public void run() {\n                        if ( newCaps == topologyCapabilities ) {\n                            if ( runMaintenanceTasks ) {\n                                if ( newCaps.isLeader() && newCaps.isActive() ) {\n                                    mt.assignUnassignedJobs();\n                                }\n                            }\n                            // start listeners\n                            if ( newCaps.isActive() ) {\n                                synchronized ( listeners ) {\n                                    notifiyListeners();\n                                }\n                            }\n                        }\n                    }\n                }, local.AT(new Date(System.currentTimeMillis() + this.backgroundLoadDelay * 1000)));\n            }\n        }\n        logger.debug(\"Job processing started\");\n    }","id":73732,"modified_method":"/**\n     * Start processing\n     * @param eventType The event type\n     * @param newCaps The new capabilities\n     */\n    private void startProcessing(final Type eventType, final TopologyCapabilities newCaps) {\n        logger.debug(\"Starting job processing...\");\n        // create new capabilities and update view\n        this.topologyCapabilities = newCaps;\n\n        // before we propagate the new topology we do some maintenance\n        if ( eventType == Type.TOPOLOGY_INIT ) {\n            final UpgradeTask task = new UpgradeTask(this);\n            task.run();\n\n            final FindUnfinishedJobsTask rt = new FindUnfinishedJobsTask(this);\n            rt.run();\n\n            final CheckTopologyTask mt = new CheckTopologyTask(this);\n            mt.fullRun();\n\n            notifiyListeners();\n        } else {\n            // and run checker again in some seconds (if leader)\n            // notify listeners afterwards\n            final Scheduler local = this.scheduler;\n            if ( local != null ) {\n                final Runnable r = new Runnable() {\n\n                    @Override\n                    public void run() {\n                        if ( newCaps == topologyCapabilities && newCaps.isActive()) {\n                            // start listeners\n                            notifiyListeners();\n                            if ( newCaps.isLeader() && newCaps.isActive() ) {\n                                final CheckTopologyTask mt = new CheckTopologyTask(JobManagerConfiguration.this);\n                                mt.fullRun();\n                            }\n                        }\n                    }\n                };\n                if ( !local.schedule(r, local.AT(new Date(System.currentTimeMillis() + this.backgroundLoadDelay * 1000))) ) {\n                    // if for whatever reason scheduling doesn't work, let's run now\n                    r.run();\n                }\n            }\n        }\n        logger.debug(\"Job processing started\");\n    }","commit_id":"8604bdbd41b33f73e1bb23f5e55fa480aa73b8bb","url":"https://github.com/apache/sling"},{"original_method":"private Scheduler createScheduler() {\n        return new Scheduler() {\n\n            @Override\n            public boolean unschedule(String jobName) {\n                // TODO Auto-generated method stub\n                return false;\n            }\n\n            @Override\n            public boolean schedule(final Object job, ScheduleOptions options) {\n                if ( job instanceof Runnable ) {\n                    final Timer t = new Timer();\n                    t.schedule(new TimerTask() {\n\n                        @Override\n                        public void run() {\n                            ((Runnable)job).run();\n                        }\n                    }, 3000);\n                }\n                return false;\n            }\n\n            @Override\n            public void removeJob(String name) throws NoSuchElementException {\n                // TODO Auto-generated method stub\n\n            }\n\n            @Override\n            public boolean fireJobAt(String name, Object job, Map<String, Serializable> config, Date date, int times,\n                    long period) {\n                // TODO Auto-generated method stub\n                return false;\n            }\n\n            @Override\n            public void fireJobAt(String name, Object job, Map<String, Serializable> config, Date date) throws Exception {\n                // TODO Auto-generated method stub\n\n            }\n\n            @Override\n            public boolean fireJob(Object job, Map<String, Serializable> config, int times, long period) {\n                // TODO Auto-generated method stub\n                return false;\n            }\n\n            @Override\n            public void fireJob(Object job, Map<String, Serializable> config) throws Exception {\n                // TODO Auto-generated method stub\n\n            }\n\n            @Override\n            public void addPeriodicJob(String name, Object job, Map<String, Serializable> config, long period,\n                    boolean canRunConcurrently, boolean startImmediate) throws Exception {\n                // TODO Auto-generated method stub\n\n            }\n\n            @Override\n            public void addPeriodicJob(String name, Object job, Map<String, Serializable> config, long period,\n                    boolean canRunConcurrently) throws Exception {\n                // TODO Auto-generated method stub\n\n            }\n\n            @Override\n            public void addJob(String name, Object job, Map<String, Serializable> config, String schedulingExpression,\n                    boolean canRunConcurrently) throws Exception {\n                // TODO Auto-generated method stub\n\n            }\n\n            @Override\n            public ScheduleOptions NOW(int times, long period) {\n                // TODO Auto-generated method stub\n                return null;\n            }\n\n            @Override\n            public ScheduleOptions NOW() {\n                // TODO Auto-generated method stub\n                return null;\n            }\n\n            @Override\n            public ScheduleOptions EXPR(String expression) {\n                // TODO Auto-generated method stub\n                return null;\n            }\n\n            @Override\n            public ScheduleOptions AT(Date date, int times, long period) {\n                // TODO Auto-generated method stub\n                return null;\n            }\n\n            @Override\n            public ScheduleOptions AT(Date date) {\n                // TODO Auto-generated method stub\n                return null;\n            }\n        };\n    }","id":73733,"modified_method":"private Scheduler createScheduler() {\n        return new Scheduler() {\n\n            @Override\n            public boolean unschedule(String jobName) {\n                // TODO Auto-generated method stub\n                return false;\n            }\n\n            @Override\n            public boolean schedule(final Object job, ScheduleOptions options) {\n                if ( job instanceof Runnable ) {\n                    final Timer t = new Timer();\n                    t.schedule(new TimerTask() {\n\n                        @Override\n                        public void run() {\n                            ((Runnable)job).run();\n                        }\n                    }, 3000);\n                    return true;\n                }\n                return false;\n            }\n\n            @Override\n            public void removeJob(String name) throws NoSuchElementException {\n                // TODO Auto-generated method stub\n\n            }\n\n            @Override\n            public boolean fireJobAt(String name, Object job, Map<String, Serializable> config, Date date, int times,\n                    long period) {\n                // TODO Auto-generated method stub\n                return false;\n            }\n\n            @Override\n            public void fireJobAt(String name, Object job, Map<String, Serializable> config, Date date) throws Exception {\n                // TODO Auto-generated method stub\n\n            }\n\n            @Override\n            public boolean fireJob(Object job, Map<String, Serializable> config, int times, long period) {\n                // TODO Auto-generated method stub\n                return false;\n            }\n\n            @Override\n            public void fireJob(Object job, Map<String, Serializable> config) throws Exception {\n                // TODO Auto-generated method stub\n\n            }\n\n            @Override\n            public void addPeriodicJob(String name, Object job, Map<String, Serializable> config, long period,\n                    boolean canRunConcurrently, boolean startImmediate) throws Exception {\n                // TODO Auto-generated method stub\n\n            }\n\n            @Override\n            public void addPeriodicJob(String name, Object job, Map<String, Serializable> config, long period,\n                    boolean canRunConcurrently) throws Exception {\n                // TODO Auto-generated method stub\n\n            }\n\n            @Override\n            public void addJob(String name, Object job, Map<String, Serializable> config, String schedulingExpression,\n                    boolean canRunConcurrently) throws Exception {\n                // TODO Auto-generated method stub\n\n            }\n\n            @Override\n            public ScheduleOptions NOW(int times, long period) {\n                // TODO Auto-generated method stub\n                return null;\n            }\n\n            @Override\n            public ScheduleOptions NOW() {\n                // TODO Auto-generated method stub\n                return null;\n            }\n\n            @Override\n            public ScheduleOptions EXPR(String expression) {\n                // TODO Auto-generated method stub\n                return null;\n            }\n\n            @Override\n            public ScheduleOptions AT(Date date, int times, long period) {\n                // TODO Auto-generated method stub\n                return null;\n            }\n\n            @Override\n            public ScheduleOptions AT(Date date) {\n                // TODO Auto-generated method stub\n                return null;\n            }\n        };\n    }","commit_id":"8604bdbd41b33f73e1bb23f5e55fa480aa73b8bb","url":"https://github.com/apache/sling"},{"original_method":"public void await() throws Exception {\n            if ( !latch.await(5000, TimeUnit.MILLISECONDS) ) {\n                throw new Exception(\"No configuration event within 5 seconds.\");\n            }\n        }","id":73734,"modified_method":"public void await() throws Exception {\n            if ( !latch.await(8000, TimeUnit.MILLISECONDS) ) {\n                throw new Exception(\"No configuration event within 8 seconds.\");\n            }\n        }","commit_id":"8604bdbd41b33f73e1bb23f5e55fa480aa73b8bb","url":"https://github.com/apache/sling"},{"original_method":"@Test public void testTopologyChange() throws Exception {\n        // mock scheduler\n        final Scheduler scheduler = this.createScheduler();\n        final ChangeListener ccl = new ChangeListener();\n\n        // add change listener and verify\n        ccl.init(1);\n        final JobManagerConfiguration config = new JobManagerConfiguration();\n        TestUtil.setFieldValue(config, \"scheduler\", scheduler);\n        ((AtomicBoolean)TestUtil.getFieldValue(config, \"active\")).set(true);\n\n        config.addListener(ccl);\n        ccl.await();\n\n        assertEquals(1, ccl.events.size());\n        assertFalse(ccl.events.get(0));\n\n        // create init view\n        ccl.init(1);\n        final TopologyView initView = createView();\n        final TopologyEvent init = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_INIT, null, initView);\n        config.handleTopologyEvent(init);\n        ccl.await();\n\n        assertEquals(1, ccl.events.size());\n        assertTrue(ccl.events.get(0));\n\n        // change view, followed by change props\n        ccl.init(3);\n        final TopologyView view2 = createView();\n        Mockito.when(initView.isCurrent()).thenReturn(false);\n        final TopologyEvent change1 = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_CHANGED, initView, view2);\n        final TopologyView view3 = createView();\n        final TopologyEvent change2 = new TopologyEvent(TopologyEvent.Type.PROPERTIES_CHANGED, view2, view3);\n\n        config.handleTopologyEvent(change1);\n        Mockito.when(view2.isCurrent()).thenReturn(false);\n        config.handleTopologyEvent(change2);\n\n        ccl.await();\n        assertEquals(3, ccl.events.size());\n        assertFalse(ccl.events.get(0));\n        assertFalse(ccl.events.get(1));\n        assertTrue(ccl.events.get(2));\n\n        // we wait another 4 secs to see if there is no another event\n        Thread.sleep(4000);\n        assertEquals(3, ccl.events.size());\n\n    }","id":73735,"modified_method":"@Test public void testTopologyChange() throws Exception {\n        // mock scheduler\n        final Scheduler scheduler = this.createScheduler();\n        final ChangeListener ccl = new ChangeListener();\n\n        // add change listener and verify\n        ccl.init(1);\n        final JobManagerConfiguration config = new JobManagerConfiguration();\n        TestUtil.setFieldValue(config, \"scheduler\", scheduler);\n        ((AtomicBoolean)TestUtil.getFieldValue(config, \"active\")).set(true);\n\n        config.addListener(ccl);\n        ccl.await();\n\n        assertEquals(1, ccl.events.size());\n        assertFalse(ccl.events.get(0));\n\n        // create init view\n        ccl.init(1);\n        final TopologyView initView = createView();\n        final TopologyEvent init = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_INIT, null, initView);\n        config.handleTopologyEvent(init);\n        ccl.await();\n\n        assertEquals(1, ccl.events.size());\n        assertTrue(ccl.events.get(0));\n\n        // change view, followed by change props\n        ccl.init(2);\n        final TopologyView view2 = createView();\n        Mockito.when(initView.isCurrent()).thenReturn(false);\n        final TopologyEvent change1 = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_CHANGED, initView, view2);\n        final TopologyView view3 = createView();\n        final TopologyEvent change2 = new TopologyEvent(TopologyEvent.Type.PROPERTIES_CHANGED, view2, view3);\n\n        config.handleTopologyEvent(change1);\n        Mockito.when(view2.isCurrent()).thenReturn(false);\n        config.handleTopologyEvent(change2);\n\n        ccl.await();\n        assertEquals(2, ccl.events.size());\n        assertFalse(ccl.events.get(0));\n        assertTrue(ccl.events.get(1));\n\n        // we wait another 4 secs to see if there is no another event\n        Thread.sleep(4000);\n        assertEquals(2, ccl.events.size());\n\n    }","commit_id":"8604bdbd41b33f73e1bb23f5e55fa480aa73b8bb","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Create the configurations cache used by clients.\n     */\n    private void createConfigurationCache() {\n        if ( this.configurations.isEmpty() ) {\n            this.orderedConfigs = EMPTY_CONFIGS;\n        } else {\n            Collections.sort(configurations);\n            orderedConfigs = configurations.toArray(new InternalQueueConfiguration[configurations.size()]);\n        }\n        this.updateListener();\n    }","id":73736,"modified_method":"/**\n     * Create the configurations cache used by clients.\n     */\n    private void createConfigurationCache() {\n        if ( this.configurations.isEmpty() ) {\n            this.orderedConfigs = EMPTY_CONFIGS;\n        } else {\n            Collections.sort(configurations);\n            orderedConfigs = configurations.toArray(new InternalQueueConfiguration[configurations.size()]);\n        }\n    }","commit_id":"8604bdbd41b33f73e1bb23f5e55fa480aa73b8bb","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public void run() {\n        while ( isActive.get() ) {\n            QueueItem item = null;\n            try {\n                item = this.queue.take();\n            } catch ( final InterruptedException ie) {\n                logger.warn(\"Thread got interrupted.\", ie);\n                Thread.currentThread().interrupt();\n                isActive.set(false);\n            }\n            if ( isActive.get() && item != null ) {\n                final JobManagerConfiguration config = this.configuration;\n                if ( config != null ) {\n                    config.handleTopologyEvent(item.event);\n                }\n            }\n        }\n    }","id":73737,"modified_method":"@Override\n    public void run() {\n        while ( isActive.get() ) {\n            QueueItem item = null;\n            try {\n                item = this.queue.take();\n            } catch ( final InterruptedException ie) {\n                logger.warn(\"Thread got interrupted.\", ie);\n                Thread.currentThread().interrupt();\n                isActive.set(false);\n            }\n            if ( isActive.get() && item != null && item.event != null ) {\n                final JobManagerConfiguration config = this.configuration;\n                if ( config != null ) {\n                    config.handleTopologyEvent(item.event);\n                }\n            }\n        }\n    }","commit_id":"8604bdbd41b33f73e1bb23f5e55fa480aa73b8bb","url":"https://github.com/apache/sling"},{"original_method":"@Deactivate\n    protected void deactivate() {\n        this.configuration.getQueueConfigurationManager().removeListener();\n        this.isActive.set(false);\n        this.queue.clear();\n        try {\n            this.queue.put(new QueueItem());\n        } catch ( final InterruptedException ie) {\n            logger.warn(\"Thread got interrupted.\", ie);\n            Thread.currentThread().interrupt();\n        }\n    }","id":73738,"modified_method":"@Deactivate\n    protected void deactivate() {\n        this.isActive.set(false);\n        this.queue.clear();\n        try {\n            this.queue.put(new QueueItem());\n        } catch ( final InterruptedException ie) {\n            logger.warn(\"Thread got interrupted.\", ie);\n            Thread.currentThread().interrupt();\n        }\n    }","commit_id":"8604bdbd41b33f73e1bb23f5e55fa480aa73b8bb","url":"https://github.com/apache/sling"},{"original_method":"@Activate\n    protected void activate() {\n        this.isActive.set(true);\n        this.configuration.getQueueConfigurationManager().addListener(this);\n        final Thread thread = new Thread(this, \"Apache Sling Job Topology Listener Thread\");\n        thread.setDaemon(true);\n\n        thread.start();\n    }","id":73739,"modified_method":"@Activate\n    protected void activate() {\n        this.isActive.set(true);\n        final Thread thread = new Thread(this, \"Apache Sling Job Topology Listener Thread\");\n        thread.setDaemon(true);\n\n        thread.start();\n    }","commit_id":"8604bdbd41b33f73e1bb23f5e55fa480aa73b8bb","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public String getModuleVersionNumber() {\n        return Version.getVersion();\n    }","id":73740,"modified_method":"@Override\n    public String getModuleVersionNumber() {\n        return \"TEST\";\n    }","commit_id":"b5c56a5f95954ef63d661f14127ad44b1a23ce16","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Construct a user interface component to allow a user to make ingest job\n     * settings.\n     *\n     * @param settings The initial settings for the ingest job.\n     */\n    public IngestJobSettingsPanel(IngestJobSettings settings) {\n        this.settings = settings;\n        this.modules = new ArrayList<>();\n        for (IngestModuleTemplate moduleTemplate : settings.getIngestModuleTemplates()) {\n            this.modules.add(new IngestModuleModel(moduleTemplate));\n        }\n        initComponents();\n        customizeComponents();\n    }","id":73741,"modified_method":"/**\n     * Construct a user interface component to allow a user to make ingest job\n     * settings.\n     *\n     * @param settings The initial settings for the ingest job.\n     */\n    public IngestJobSettingsPanel(IngestJobSettings settings) {\n        this.settings = settings;\n        this.modules = new ArrayList<>();\n        for (IngestModuleTemplate moduleTemplate : settings.getIngestModuleTemplates()) {\n            this.modules.add(new IngestModuleModel(moduleTemplate));\n        }\n        SleuthkitCase skCase = Case.getCurrentCase().getSleuthkitCase();\n        try {\n            ingestJobs = skCase.getIngestJobs();\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Failed to load ingest job information.\", ex);\n            ingestJobs = new ArrayList<>();\n        }\n        this.dataSources = new ArrayList<>();\n        initComponents();\n        customizeComponents();\n    }","commit_id":"b5c56a5f95954ef63d661f14127ad44b1a23ce16","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public int getColumnCount() {\n            return 2;\n        }","id":73742,"modified_method":"@Override\n        public int getColumnCount() {\n            return 3;\n        }","commit_id":"b5c56a5f95954ef63d661f14127ad44b1a23ce16","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public Object getValueAt(int rowIndex, int columnIndex) {\n            IngestModuleModel module = modules.get(rowIndex);\n            if (columnIndex == 0) {\n                return module.isEnabled();\n            } else {\n                return module.getName();\n            }\n        }","id":73743,"modified_method":"@Override\n        public Object getValueAt(int rowIndex, int columnIndex) {\n            IngestModuleModel module = modules.get(rowIndex);\n            if (columnIndex == 0) {\n                return module.isEnabled();\n            } else if (columnIndex == 1) {\n                return getIcon(module);\n            } else {\n                return module.getName();\n            }\n        }","commit_id":"b5c56a5f95954ef63d661f14127ad44b1a23ce16","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Messages({\"IngestJobSettingsPanel.noPerRunSettings=The selected module has no per-run settings.\"})\n    private void customizeComponents() {\n        modulesTable.setModel(new IngestModulesTableModel());\n        modulesTable.setTableHeader(null);\n        modulesTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n        // Set the column widths in the table model and add a custom cell \n        // renderer that will display module descriptions from the module models \n        // as tooltips.\n        IngestModulesTableRenderer renderer = new IngestModulesTableRenderer();\n        int width = modulesScrollPane.getPreferredSize().width;\n        for (int i = 0; i < modulesTable.getColumnCount(); ++i) {\n            TableColumn column = modulesTable.getColumnModel().getColumn(i);\n            if (0 == i) {\n                column.setPreferredWidth(((int) (width * 0.15)));\n            } else {\n                column.setCellRenderer(renderer);\n                column.setPreferredWidth(((int) (width * 0.84)));\n            }\n        }\n\n        // Add a selection listener to the table model that will display the  \n        // ingest job options panel of the currently selected module model and \n        // enable or disable the resources configuration panel invocation button.\n        modulesTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n            @Override\n            public void valueChanged(ListSelectionEvent e) {\n                ListSelectionModel listSelectionModel = (ListSelectionModel) e.getSource();\n                if (!listSelectionModel.isSelectionEmpty()) {\n                    int index = listSelectionModel.getMinSelectionIndex();\n                    selectedModule = modules.get(index);\n                    ingestSettingsPanel.removeAll();\n                    if (null != selectedModule.getModuleSettingsPanel()) {\n                        ingestSettingsPanel.add(selectedModule.getModuleSettingsPanel());\n                    } else {\n                        ingestSettingsPanel.add(new JLabel(Bundle.IngestJobSettingsPanel_noPerRunSettings()));\n                    }\n                    ingestSettingsPanel.revalidate();\n                    ingestSettingsPanel.repaint();\n                    globalSettingsButton.setEnabled(null != selectedModule.getGlobalSettingsPanel());\n                    descriptionLabel.setText(selectedModule.getDescription());\n                    descriptionLabel.setToolTipText(selectedModule.getDescription());\n                }\n            }\n        });\n        modulesTable.setRowSelectionInterval(0, 0);\n        processUnallocCheckbox.setSelected(this.settings.getProcessUnallocatedSpace());\n    }","id":73744,"modified_method":"@Messages({\"IngestJobSettingsPanel.noPerRunSettings=The selected module has no per-run settings.\"})\n    private void customizeComponents() {\n        modulesTable.setModel(tableModel);\n        modulesTable.setTableHeader(null);\n        modulesTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n        // Set the column widths in the table model and add a custom cell \n        // renderer that will display module descriptions from the module models \n        // as tooltips.\n        IngestModulesTableRenderer renderer = new IngestModulesTableRenderer();\n        int width = modulesScrollPane.getPreferredSize().width;\n        for (int i = 0; i < modulesTable.getColumnCount(); ++i) {\n            TableColumn column = modulesTable.getColumnModel().getColumn(i);\n            if (0 == i) {\n                column.setPreferredWidth(((int) (width * 0.15)));\n            } else {\n                column.setCellRenderer(renderer);\n                column.setPreferredWidth(((int) (width * 0.84)));\n            }\n        }\n\n        // Add a selection listener to the table model that will display the  \n        // ingest job options panel of the currently selected module model and \n        // enable or disable the resources configuration panel invocation button.\n        modulesTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n            @Override\n            public void valueChanged(ListSelectionEvent e) {\n                ListSelectionModel listSelectionModel = (ListSelectionModel) e.getSource();\n                if (!listSelectionModel.isSelectionEmpty()) {\n                    int index = listSelectionModel.getMinSelectionIndex();\n                    selectedModule = modules.get(index);\n                    ingestSettingsPanel.removeAll();\n                    if (null != selectedModule.getModuleSettingsPanel()) {\n                        ingestSettingsPanel.add(selectedModule.getModuleSettingsPanel());\n                    } else {\n                        ingestSettingsPanel.add(new JLabel(Bundle.IngestJobSettingsPanel_noPerRunSettings()));\n                    }\n                    ingestSettingsPanel.revalidate();\n                    ingestSettingsPanel.repaint();\n                    globalSettingsButton.setEnabled(null != selectedModule.getGlobalSettingsPanel());\n                    descriptionLabel.setText(selectedModule.getDescription());\n                    descriptionLabel.setToolTipText(selectedModule.getDescription());\n                }\n            }\n        });\n        modulesTable.setRowSelectionInterval(0, 0);\n        processUnallocCheckbox.setSelected(this.settings.getProcessUnallocatedSpace());\n        this.modulesTable.getColumnModel().getColumn(0).setMaxWidth(22);\n        this.modulesTable.getColumnModel().getColumn(1).setMaxWidth(20);\n        this.modulesTable.getColumnModel().getColumn(1).setMinWidth(20);\n        modulesTable.setRowHeight(20);\n    }","commit_id":"b5c56a5f95954ef63d661f14127ad44b1a23ce16","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n            super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n            if (1 == column) {\n                setToolTipText(tooltips.get(row));\n            }\n            return this;\n        }","id":73745,"modified_method":"@Override\n        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n            super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n            if (2 == column) {\n                setIcon(null);\n                setToolTipText(tooltips.get(row));\n            } else if (1 == column) {\n                setIcon((Icon) value);\n                setText(\"\");\n                if (tableModel.warningIcon.equals(value)) {\n                    setToolTipText(Bundle.IngestJobSettingsPanel_IngestModulesTableRenderer_warning_message());\n                } else if (tableModel.infoIcon.equals(value)) {\n                    setToolTipText(Bundle.IngestJobSettingsPanel_IngestModulesTableRenderer_info_message());\n                }\n            }\n            return this;\n        }","commit_id":"b5c56a5f95954ef63d661f14127ad44b1a23ce16","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        timeGroup = new javax.swing.ButtonGroup();\n        modulesScrollPane = new javax.swing.JScrollPane();\n        modulesTable = new javax.swing.JTable();\n        jPanel1 = new javax.swing.JPanel();\n        globalSettingsButton = new javax.swing.JButton();\n        jSeparator2 = new javax.swing.JSeparator();\n        descriptionLabel = new javax.swing.JLabel();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        ingestSettingsPanel = new javax.swing.JPanel();\n        jButtonSelectAll = new javax.swing.JButton();\n        jButtonDeselectAll = new javax.swing.JButton();\n        processUnallocCheckbox = new javax.swing.JCheckBox();\n\n        setMaximumSize(new java.awt.Dimension(5750, 3000));\n        setMinimumSize(new java.awt.Dimension(0, 0));\n        setPreferredSize(new java.awt.Dimension(625, 450));\n\n        modulesScrollPane.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(160, 160, 160)));\n        modulesScrollPane.setMinimumSize(new java.awt.Dimension(0, 0));\n        modulesScrollPane.setPreferredSize(new java.awt.Dimension(160, 160));\n\n        modulesTable.setBackground(new java.awt.Color(240, 240, 240));\n        modulesTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n\n            }\n        ));\n        modulesTable.setShowHorizontalLines(false);\n        modulesTable.setShowVerticalLines(false);\n        modulesScrollPane.setViewportView(modulesTable);\n\n        jPanel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(160, 160, 160)));\n        jPanel1.setPreferredSize(new java.awt.Dimension(338, 257));\n\n        globalSettingsButton.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.globalSettingsButton.text\")); // NOI18N\n        globalSettingsButton.setActionCommand(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.globalSettingsButton.actionCommand\")); // NOI18N\n        globalSettingsButton.setEnabled(false);\n        globalSettingsButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                globalSettingsButtonActionPerformed(evt);\n            }\n        });\n\n        descriptionLabel.setText(\"DO NOT REMOVE. This dummy text is used to anchor the inner panel's size to the outer panel, while still being expandable. Without this the expandability behavior doesn't work well. This text will never be shown, as it would only be shown when no module is selected (which is not possible).\");\n\n        jScrollPane1.setBorder(null);\n        jScrollPane1.setPreferredSize(new java.awt.Dimension(250, 180));\n\n        ingestSettingsPanel.setMinimumSize(new java.awt.Dimension(0, 300));\n        ingestSettingsPanel.setLayout(new javax.swing.BoxLayout(ingestSettingsPanel, javax.swing.BoxLayout.PAGE_AXIS));\n        jScrollPane1.setViewportView(ingestSettingsPanel);\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jSeparator2, javax.swing.GroupLayout.Alignment.TRAILING)\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(descriptionLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 302, Short.MAX_VALUE)\n                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()\n                        .addGap(0, 0, Short.MAX_VALUE)\n                        .addComponent(globalSettingsButton)))\n                .addContainerGap())\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 330, Short.MAX_VALUE)\n                .addGap(18, 18, 18)\n                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 2, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(8, 8, 8)\n                .addComponent(descriptionLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(globalSettingsButton)\n                .addGap(8, 8, 8))\n        );\n\n        jButtonSelectAll.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.jButtonSelectAll.text\")); // NOI18N\n        jButtonSelectAll.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jButtonSelectAllActionPerformed(evt);\n            }\n        });\n\n        jButtonDeselectAll.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.jButtonDeselectAll.text\")); // NOI18N\n        jButtonDeselectAll.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jButtonDeselectAllActionPerformed(evt);\n            }\n        });\n\n        processUnallocCheckbox.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.processUnallocCheckbox.text\")); // NOI18N\n        processUnallocCheckbox.setToolTipText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.processUnallocCheckbox.toolTipText\")); // NOI18N\n        processUnallocCheckbox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                processUnallocCheckboxActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(modulesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 271, Short.MAX_VALUE)\n                        .addGap(10, 10, 10))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(24, 24, 24)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(processUnallocCheckbox)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(jButtonSelectAll, javax.swing.GroupLayout.PREFERRED_SIZE, 86, javax.swing.GroupLayout.PREFERRED_SIZE)\n                                .addGap(18, 18, 18)\n                                .addComponent(jButtonDeselectAll)))\n                        .addGap(32, 32, 32)))\n                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, 324, Short.MAX_VALUE)\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(modulesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(jButtonDeselectAll)\n                            .addComponent(jButtonSelectAll))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(processUnallocCheckbox, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                        .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, 428, Short.MAX_VALUE)\n                        .addContainerGap())))\n        );\n    }","id":73746,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        timeGroup = new javax.swing.ButtonGroup();\n        modulesScrollPane = new javax.swing.JScrollPane();\n        modulesTable = new javax.swing.JTable();\n        jPanel1 = new javax.swing.JPanel();\n        globalSettingsButton = new javax.swing.JButton();\n        jSeparator2 = new javax.swing.JSeparator();\n        descriptionLabel = new javax.swing.JLabel();\n        jScrollPane1 = new javax.swing.JScrollPane();\n        ingestSettingsPanel = new javax.swing.JPanel();\n        jButtonSelectAll = new javax.swing.JButton();\n        jButtonDeselectAll = new javax.swing.JButton();\n        processUnallocCheckbox = new javax.swing.JCheckBox();\n        pastJobsButton = new javax.swing.JButton();\n\n        setMaximumSize(new java.awt.Dimension(5750, 3000));\n        setMinimumSize(new java.awt.Dimension(0, 0));\n        setPreferredSize(new java.awt.Dimension(625, 450));\n\n        modulesScrollPane.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(160, 160, 160)));\n        modulesScrollPane.setMinimumSize(new java.awt.Dimension(0, 0));\n        modulesScrollPane.setPreferredSize(new java.awt.Dimension(160, 160));\n\n        modulesTable.setBackground(new java.awt.Color(240, 240, 240));\n        modulesTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n\n            }\n        ));\n        modulesTable.setShowHorizontalLines(false);\n        modulesTable.setShowVerticalLines(false);\n        modulesScrollPane.setViewportView(modulesTable);\n\n        jPanel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(160, 160, 160)));\n        jPanel1.setPreferredSize(new java.awt.Dimension(338, 257));\n\n        globalSettingsButton.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.globalSettingsButton.text\")); // NOI18N\n        globalSettingsButton.setActionCommand(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.globalSettingsButton.actionCommand\")); // NOI18N\n        globalSettingsButton.setEnabled(false);\n        globalSettingsButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                globalSettingsButtonActionPerformed(evt);\n            }\n        });\n\n        descriptionLabel.setText(\"DO NOT REMOVE. This dummy text is used to anchor the inner panel's size to the outer panel, while still being expandable. Without this the expandability behavior doesn't work well. This text will never be shown, as it would only be shown when no module is selected (which is not possible).\");\n\n        jScrollPane1.setBorder(null);\n        jScrollPane1.setPreferredSize(new java.awt.Dimension(250, 180));\n\n        ingestSettingsPanel.setMinimumSize(new java.awt.Dimension(0, 300));\n        ingestSettingsPanel.setLayout(new javax.swing.BoxLayout(ingestSettingsPanel, javax.swing.BoxLayout.PAGE_AXIS));\n        jScrollPane1.setViewportView(ingestSettingsPanel);\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(jSeparator2, javax.swing.GroupLayout.Alignment.TRAILING)\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(descriptionLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)\n                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 337, Short.MAX_VALUE)\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()\n                        .addGap(0, 0, Short.MAX_VALUE)\n                        .addComponent(globalSettingsButton)))\n                .addContainerGap())\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 347, Short.MAX_VALUE)\n                .addGap(18, 18, 18)\n                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 2, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(8, 8, 8)\n                .addComponent(descriptionLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(globalSettingsButton)\n                .addGap(8, 8, 8))\n        );\n\n        jButtonSelectAll.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.jButtonSelectAll.text\")); // NOI18N\n        jButtonSelectAll.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jButtonSelectAllActionPerformed(evt);\n            }\n        });\n\n        jButtonDeselectAll.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.jButtonDeselectAll.text\")); // NOI18N\n        jButtonDeselectAll.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jButtonDeselectAllActionPerformed(evt);\n            }\n        });\n\n        processUnallocCheckbox.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.processUnallocCheckbox.text\")); // NOI18N\n        processUnallocCheckbox.setToolTipText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.processUnallocCheckbox.toolTipText\")); // NOI18N\n        processUnallocCheckbox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                processUnallocCheckboxActionPerformed(evt);\n            }\n        });\n\n        pastJobsButton.setText(org.openide.util.NbBundle.getMessage(IngestJobSettingsPanel.class, \"IngestJobSettingsPanel.pastJobsButton.text\")); // NOI18N\n        pastJobsButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                pastJobsButtonActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jButtonSelectAll, javax.swing.GroupLayout.PREFERRED_SIZE, 103, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(jButtonDeselectAll))\n                    .addComponent(pastJobsButton)\n                    .addComponent(processUnallocCheckbox)\n                    .addComponent(modulesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 261, Short.MAX_VALUE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, 359, Short.MAX_VALUE)\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(modulesScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(jButtonSelectAll)\n                            .addComponent(jButtonDeselectAll))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(pastJobsButton)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(processUnallocCheckbox, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, 445, Short.MAX_VALUE)\n                        .addContainerGap())))\n        );\n    }","commit_id":"b5c56a5f95954ef63d661f14127ad44b1a23ce16","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Displays this dialog.\n     */\n    public void display() {\n        setLayout(new BorderLayout());\n\n        /**\n         * Center the dialog.\n         */\n        Dimension screenDimension = Toolkit.getDefaultToolkit().getScreenSize();;\n\n        /**\n         * Get the default or saved ingest job settings for this context and use\n         * them to create and add an ingest job settings panel.\n         */\n        IngestJobSettings ingestJobSettings = new IngestJobSettings(RunIngestModulesDialog.class.getCanonicalName(), this.ingestType);\n        RunIngestModulesDialog.showWarnings(ingestJobSettings);\n        this.ingestJobSettingsPanel = new IngestJobSettingsPanel(ingestJobSettings);\n        setPreferredSize(this.ingestJobSettingsPanel.getPreferredSize());\n        add(this.ingestJobSettingsPanel, BorderLayout.CENTER);\n\n        // Add a start ingest button.\n        JButton startButton = new JButton(NbBundle.getMessage(this.getClass(), \"IngestDialog.startButton.title\"));\n        startButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                doButtonAction(true);\n            }\n        });\n\n        // Add a close button.\n        JButton closeButton = new JButton(NbBundle.getMessage(this.getClass(), \"IngestDialog.closeButton.title\"));\n        closeButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                doButtonAction(false);\n            }\n        });\n\n        // Put the buttons in their own panel, under the settings panel.\n        JPanel buttonPanel = new JPanel();\n        buttonPanel.setLayout(new FlowLayout(FlowLayout.TRAILING));\n        buttonPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 5));\n        buttonPanel.add(startButton);\n        buttonPanel.add(new javax.swing.Box.Filler(new Dimension(5, 10), new Dimension(5, 10), new Dimension(5, 10)));\n        buttonPanel.add(closeButton);\n\n        add(buttonPanel, BorderLayout.SOUTH);\n\n        /**\n         * Add a handler for when the dialog window is closed directly,\n         * bypassing the buttons.\n         */\n        this.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                doButtonAction(false);\n            }\n        });\n\n        /**\n         * Show the dialog.\n         */\n        int width = this.getPreferredSize().width;\n        int height = this.getPreferredSize().height;\n        setLocation((screenDimension.width - width) / 2, (screenDimension.height - height) / 2);\n        pack();\n        setVisible(true);\n    }","id":73747,"modified_method":"/**\n     * Displays this dialog.\n     */\n    public void display() {\n        setLayout(new BorderLayout());\n\n        /**\n         * Center the dialog.\n         */\n        Dimension screenDimension = Toolkit.getDefaultToolkit().getScreenSize();;\n\n        /**\n         * Get the default or saved ingest job settings for this context and use\n         * them to create and add an ingest job settings panel.\n         */\n        IngestJobSettings ingestJobSettings = new IngestJobSettings(RunIngestModulesDialog.class.getCanonicalName(), this.ingestType);\n        RunIngestModulesDialog.showWarnings(ingestJobSettings);\n        this.ingestJobSettingsPanel = new IngestJobSettingsPanel(ingestJobSettings, dataSources);\n        setPreferredSize(this.ingestJobSettingsPanel.getPreferredSize());\n        add(this.ingestJobSettingsPanel, BorderLayout.CENTER);\n\n        // Add a start ingest button.\n        JButton startButton = new JButton(NbBundle.getMessage(this.getClass(), \"IngestDialog.startButton.title\"));\n        startButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                doButtonAction(true);\n            }\n        });\n\n        // Add a close button.\n        JButton closeButton = new JButton(NbBundle.getMessage(this.getClass(), \"IngestDialog.closeButton.title\"));\n        closeButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                doButtonAction(false);\n            }\n        });\n\n        // Put the buttons in their own panel, under the settings panel.\n        JPanel buttonPanel = new JPanel();\n        buttonPanel.setLayout(new FlowLayout(FlowLayout.TRAILING));\n        buttonPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 5));\n        buttonPanel.add(startButton);\n        buttonPanel.add(new javax.swing.Box.Filler(new Dimension(5, 10), new Dimension(5, 10), new Dimension(5, 10)));\n        buttonPanel.add(closeButton);\n\n        add(buttonPanel, BorderLayout.SOUTH);\n\n        /**\n         * Add a handler for when the dialog window is closed directly,\n         * bypassing the buttons.\n         */\n        this.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                doButtonAction(false);\n            }\n        });\n\n        /**\n         * Show the dialog.\n         */\n        int width = this.getPreferredSize().width;\n        int height = this.getPreferredSize().height;\n        setLocation((screenDimension.width - width) / 2, (screenDimension.height - height) / 2);\n        pack();\n        setVisible(true);\n    }","commit_id":"b5c56a5f95954ef63d661f14127ad44b1a23ce16","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** \n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        buttonGroup1 = new javax.swing.ButtonGroup();\n        rawSingle = new javax.swing.JRadioButton();\n        rawSplit = new javax.swing.JRadioButton();\n        imgTypeLabel = new javax.swing.JLabel();\n        encase = new javax.swing.JRadioButton();\n        imgPathLabel = new javax.swing.JLabel();\n        multipleSelectLabel = new javax.swing.JLabel();\n        imgPathTextField = new javax.swing.JTextField();\n        imgPathBrowserButton = new javax.swing.JButton();\n        this.imgPathBrowserButton.setDefaultCapable(true);\n        this.imgPathBrowserButton.requestFocus();\n        imgInfoLabel = new javax.swing.JLabel();\n        jLabel1 = new javax.swing.JLabel();\n        timeZoneComboBox = new javax.swing.JComboBox();\n        timeZoneLabel = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n        noFatOrphansCheckbox = new javax.swing.JCheckBox();\n        noProcessUnallocSpace = new javax.swing.JCheckBox();\n\n        setPreferredSize(new java.awt.Dimension(588, 308));\n\n        org.openide.awt.Mnemonics.setLocalizedText(rawSingle, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.rawSingle.text\")); // NOI18N\n        rawSingle.setRequestFocusEnabled(false);\n        rawSingle.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                rawSingleActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(rawSplit, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.rawSplit.text\")); // NOI18N\n        rawSplit.setRequestFocusEnabled(false);\n        rawSplit.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                rawSplitActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(imgTypeLabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.imgTypeLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(encase, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.encase.text\")); // NOI18N\n        encase.setRequestFocusEnabled(false);\n        encase.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                encaseActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(imgPathLabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.imgPathLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(multipleSelectLabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.multipleSelectLabel.text\")); // NOI18N\n\n        imgPathTextField.setText(org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.imgPathTextField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(imgPathBrowserButton, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.imgPathBrowserButton.text\")); // NOI18N\n        imgPathBrowserButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                imgPathBrowserButtonActionPerformed(evt);\n            }\n        });\n\n        imgInfoLabel.setFont(new java.awt.Font(\"Tahoma\", 1, 14));\n        org.openide.awt.Mnemonics.setLocalizedText(imgInfoLabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.imgInfoLabel.text\")); // NOI18N\n\n        jLabel1.setForeground(new java.awt.Color(255, 0, 51));\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.jLabel1.text\")); // NOI18N\n\n        timeZoneComboBox.setMaximumRowCount(30);\n\n        org.openide.awt.Mnemonics.setLocalizedText(timeZoneLabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.timeZoneLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.jLabel2.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(noFatOrphansCheckbox, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.noFatOrphansCheckbox.text\")); // NOI18N\n        noFatOrphansCheckbox.setToolTipText(org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.noFatOrphansCheckbox.toolTipText\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(noProcessUnallocSpace, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.noProcessUnallocSpace.text\")); // NOI18N\n        noProcessUnallocSpace.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                noProcessUnallocSpaceActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(noProcessUnallocSpace)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(imgPathLabel)\n                        .addGap(18, 18, 18)\n                        .addComponent(imgPathTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 389, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(imgPathBrowserButton))\n                    .addComponent(imgTypeLabel)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(10, 10, 10)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(rawSplit)\n                            .addComponent(rawSingle)\n                            .addComponent(encase)))\n                    .addComponent(multipleSelectLabel)\n                    .addComponent(imgInfoLabel)\n                    .addComponent(jLabel1)\n                    .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                        .addGroup(layout.createSequentialGroup()\n                            .addComponent(timeZoneLabel)\n                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                            .addComponent(timeZoneComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 253, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addComponent(noFatOrphansCheckbox, javax.swing.GroupLayout.Alignment.LEADING)))\n                .addContainerGap(39, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(imgInfoLabel)\n                .addGap(19, 19, 19)\n                .addComponent(imgTypeLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(rawSingle)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(rawSplit)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(encase)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(imgPathLabel)\n                    .addComponent(imgPathTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(imgPathBrowserButton))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(multipleSelectLabel)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                            .addComponent(timeZoneLabel)\n                            .addComponent(timeZoneComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 28, Short.MAX_VALUE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(noProcessUnallocSpace)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)))\n                .addComponent(noFatOrphansCheckbox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(jLabel1)\n                .addContainerGap())\n        );\n    }","id":73748,"modified_method":"/** \n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        buttonGroup1 = new javax.swing.ButtonGroup();\n        rawSingle = new javax.swing.JRadioButton();\n        rawSplit = new javax.swing.JRadioButton();\n        imgTypeLabel = new javax.swing.JLabel();\n        encase = new javax.swing.JRadioButton();\n        imgPathLabel = new javax.swing.JLabel();\n        multipleSelectLabel = new javax.swing.JLabel();\n        imgPathTextField = new javax.swing.JTextField();\n        imgPathBrowserButton = new javax.swing.JButton();\n        this.imgPathBrowserButton.setDefaultCapable(true);\n        this.imgPathBrowserButton.requestFocus();\n        imgInfoLabel = new javax.swing.JLabel();\n        jLabel1 = new javax.swing.JLabel();\n        timeZoneComboBox = new javax.swing.JComboBox();\n        timeZoneLabel = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n        noFatOrphansCheckbox = new javax.swing.JCheckBox();\n        noProcessUnallocSpace = new javax.swing.JCheckBox();\n        optionsLabel1 = new javax.swing.JLabel();\n\n        setMinimumSize(new java.awt.Dimension(559, 328));\n        setPreferredSize(new java.awt.Dimension(588, 308));\n\n        org.openide.awt.Mnemonics.setLocalizedText(rawSingle, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.rawSingle.text\")); // NOI18N\n        rawSingle.setRequestFocusEnabled(false);\n        rawSingle.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                rawSingleActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(rawSplit, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.rawSplit.text\")); // NOI18N\n        rawSplit.setRequestFocusEnabled(false);\n        rawSplit.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                rawSplitActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(imgTypeLabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.imgTypeLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(encase, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.encase.text\")); // NOI18N\n        encase.setRequestFocusEnabled(false);\n        encase.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                encaseActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(imgPathLabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.imgPathLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(multipleSelectLabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.multipleSelectLabel.text\")); // NOI18N\n\n        imgPathTextField.setText(org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.imgPathTextField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(imgPathBrowserButton, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.imgPathBrowserButton.text\")); // NOI18N\n        imgPathBrowserButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                imgPathBrowserButtonActionPerformed(evt);\n            }\n        });\n\n        imgInfoLabel.setFont(new java.awt.Font(\"Tahoma\", 1, 14));\n        org.openide.awt.Mnemonics.setLocalizedText(imgInfoLabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.imgInfoLabel.text\")); // NOI18N\n\n        jLabel1.setForeground(new java.awt.Color(255, 0, 51));\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.jLabel1.text\")); // NOI18N\n\n        timeZoneComboBox.setMaximumRowCount(30);\n\n        org.openide.awt.Mnemonics.setLocalizedText(timeZoneLabel, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.timeZoneLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.jLabel2.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(noFatOrphansCheckbox, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.noFatOrphansCheckbox.text\")); // NOI18N\n        noFatOrphansCheckbox.setToolTipText(org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.noFatOrphansCheckbox.toolTipText\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(noProcessUnallocSpace, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.noProcessUnallocSpace.text\")); // NOI18N\n        noProcessUnallocSpace.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                noProcessUnallocSpaceActionPerformed(evt);\n            }\n        });\n\n        org.openide.awt.Mnemonics.setLocalizedText(optionsLabel1, org.openide.util.NbBundle.getMessage(AddImageVisualPanel1.class, \"AddImageVisualPanel1.optionsLabel1.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(imgTypeLabel)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(10, 10, 10)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(rawSplit)\n                            .addComponent(rawSingle)\n                            .addComponent(encase)))\n                    .addComponent(multipleSelectLabel)\n                    .addComponent(imgInfoLabel)\n                    .addComponent(jLabel1)\n                    .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(optionsLabel1)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(10, 10, 10)\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(noFatOrphansCheckbox)\n                            .addComponent(noProcessUnallocSpace)))\n                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()\n                            .addComponent(timeZoneLabel)\n                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                            .addComponent(timeZoneComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 253, javax.swing.GroupLayout.PREFERRED_SIZE))\n                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()\n                            .addComponent(imgPathLabel)\n                            .addGap(18, 18, 18)\n                            .addComponent(imgPathTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 389, javax.swing.GroupLayout.PREFERRED_SIZE)\n                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                            .addComponent(imgPathBrowserButton))))\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(imgInfoLabel)\n                .addGap(19, 19, 19)\n                .addComponent(imgTypeLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(rawSingle)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(rawSplit)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(encase)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(imgPathLabel)\n                    .addComponent(imgPathTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(imgPathBrowserButton))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(multipleSelectLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(timeZoneLabel)\n                    .addComponent(timeZoneComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addComponent(optionsLabel1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(noProcessUnallocSpace)\n                .addGap(3, 3, 3)\n                .addComponent(noFatOrphansCheckbox)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(jLabel1)\n                .addContainerGap())\n        );\n    }","commit_id":"161f2a2670c4e178065246cb1f0c6d7b1ff1d62b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public int getRowCount() {\n            return xmlHandle.getKnownBadSets().size();\n        }","id":73749,"modified_method":"@Override\n        public int getRowCount() {\n            int size = xmlHandle.getKnownBadSets().size();\n            return size == 0 ? 1 : size;\n        }","commit_id":"161f2a2670c4e178065246cb1f0c6d7b1ff1d62b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public Object getValueAt(int rowIndex, int columnIndex) {\n            HashDb db = xmlHandle.getKnownBadSets().get(rowIndex);\n            if(columnIndex == 0) {\n                return db.getUseForIngest();\n            } else {\n                return db.getName();\n            }\n        }","id":73750,"modified_method":"@Override\n        public Object getValueAt(int rowIndex, int columnIndex) {\n            if (xmlHandle.getKnownBadSets().isEmpty()) {\n                if (columnIndex == 0) {\n                    return \"\";\n                } else {\n                    return \"No notable databases set.\";\n                }\n            } else {\n                HashDb db = xmlHandle.getKnownBadSets().get(rowIndex);\n                if (columnIndex == 0) {\n                    return db.getUseForIngest();\n                } else {\n                    return db.getName();\n                }\n            }\n        }","commit_id":"161f2a2670c4e178065246cb1f0c6d7b1ff1d62b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        notableHashTable = new javax.swing.JTable();\n        jLabel1 = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n        nsrlNameLabel = new javax.swing.JLabel();\n\n        jScrollPane1.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));\n\n        notableHashTable.setBackground(new java.awt.Color(240, 240, 240));\n        notableHashTable.setShowHorizontalLines(false);\n        notableHashTable.setShowVerticalLines(false);\n        jScrollPane1.setViewportView(notableHashTable);\n\n        jLabel1.setText(org.openide.util.NbBundle.getMessage(HashDbSimplePanel.class, \"HashDbSimplePanel.jLabel1.text\")); // NOI18N\n\n        jLabel2.setText(org.openide.util.NbBundle.getMessage(HashDbSimplePanel.class, \"HashDbSimplePanel.jLabel2.text\")); // NOI18N\n\n        nsrlNameLabel.setText(org.openide.util.NbBundle.getMessage(HashDbSimplePanel.class, \"HashDbSimplePanel.nsrlNameLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jLabel1)\n                .addContainerGap(142, Short.MAX_VALUE))\n            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 274, Short.MAX_VALUE)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addGap(10, 10, 10)\n                        .addComponent(nsrlNameLabel))\n                    .addComponent(jLabel2))\n                .addContainerGap(143, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jLabel2)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(nsrlNameLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 106, Short.MAX_VALUE))\n        );\n    }","id":73751,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        notableHashTable = new javax.swing.JTable();\n        jLabel1 = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n        nsrlNameLabel = new javax.swing.JLabel();\n\n        jScrollPane1.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));\n\n        notableHashTable.setBackground(new java.awt.Color(240, 240, 240));\n        notableHashTable.setShowHorizontalLines(false);\n        notableHashTable.setShowVerticalLines(false);\n        jScrollPane1.setViewportView(notableHashTable);\n\n        jLabel1.setText(org.openide.util.NbBundle.getMessage(HashDbSimplePanel.class, \"HashDbSimplePanel.jLabel1.text\")); // NOI18N\n\n        jLabel2.setText(org.openide.util.NbBundle.getMessage(HashDbSimplePanel.class, \"HashDbSimplePanel.jLabel2.text\")); // NOI18N\n\n        nsrlNameLabel.setText(org.openide.util.NbBundle.getMessage(HashDbSimplePanel.class, \"HashDbSimplePanel.nsrlNameLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jLabel1)\n                .addContainerGap(142, Short.MAX_VALUE))\n            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 274, Short.MAX_VALUE)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jLabel2)\n                .addContainerGap(159, Short.MAX_VALUE))\n            .addGroup(layout.createSequentialGroup()\n                .addGap(53, 53, 53)\n                .addComponent(nsrlNameLabel)\n                .addContainerGap(110, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jLabel2)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(nsrlNameLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 106, Short.MAX_VALUE))\n        );\n    }","commit_id":"161f2a2670c4e178065246cb1f0c6d7b1ff1d62b","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n\t * Overridden to capture the time zone data being sent from the client.\n\t */\n\t@Override\n\tpublic void takeValuesFromRequest(WORequest request, WOContext context) {\n\t\tsuper.takeValuesFromRequest(request, context);\n\t\tif (shouldPostData() && request.formValueForKey(TIMEZONE_DATA_KEY) != null) {\n\t\t\tERXSession session = ERXSession.session();\n\t\t\tString zoneString = request.stringFormValueForKey(TIMEZONE_DATA_KEY);\n\t\t\tsession.objectStore().takeValueForKey(zoneString, TIMEZONE_SESSION_KEY);\n\t\t\tsession.setJavaScriptEnabled(true);\n\n\t\t\tString[] data = StringUtils.split(zoneString, ',');\n\t\t\tint rawOffset = Integer.valueOf(data[0]).intValue();\n\t\t\tboolean dst = \"1\".equals(data[1]);\n\t\t\tboolean southern = \"1\".equals(data[2]);\n\t\t\tTimeZone tz = zoneWithRawOffset(rawOffset, dst, southern);\n\t\t\tsession.setTimeZone(tz);\n\t\t}\n\t}","id":73752,"modified_method":"/**\n\t * Overridden to capture the time zone data being sent from the client.\n\t */\n\t@Override\n\tpublic void takeValuesFromRequest(WORequest request, WOContext context) {\n\t\tsuper.takeValuesFromRequest(request, context);\n\t\tif (shouldPostData() && request.formValueForKey(TIMEZONE_DATA_KEY) != null) {\n\t\t\tERXSession session = ERXSession.session();\n\t\t\tString zoneString = request.stringFormValueForKey(TIMEZONE_DATA_KEY);\n\t\t\tsession.objectStore().takeValueForKey(zoneString, TIMEZONE_SESSION_KEY);\n\t\t\tsession.setJavaScriptEnabled(true);\n\n\t\t\tString[] data = StringUtils.split(zoneString, ',');\n\t\t\tint rawOffset = Integer.valueOf(data[0]).intValue();\n\t\t\tboolean dst = \"1\".equals(data[1]);\n\t\t\tboolean southern = \"1\".equals(data[2]);\n\t\t\tTimeZone tz = zoneWithRawOffset(rawOffset, dst, southern);\n\t\t\t// Call ERXSession.setTimeZone() if tz is not null\n\t\t\t// https://github.com/wocommunity/wonder/issues/774\n\t\t\tif (tz != null) {\n\t\t\t\tsession.setTimeZone(tz);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog.warn(\"Unable to find a timezone for '{}'.\", zoneString);\n\t\t\t}\n\t\t}\n\t}","commit_id":"6a195fa92ee758a9c45c0682af8415577c757352","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static byte[] getSignature( final String key, final String subject, final Hmac mac ) throws AuthenticationException {\n    final SecretKeySpec signingKey = new SecretKeySpec( key.getBytes( Charsets.UTF_8 ), mac.toString( ) );\n    try {\n      final Mac digest = mac.getInstance( );\n      digest.init( signingKey );\n      return digest.doFinal( subject.getBytes( Charsets.UTF_8 ) );\n    } catch ( Exception e ) {\n      LOG.error( e, e );\n      throw new AuthenticationException( \"Failed to compute signature\" );\n    }\n  }","id":73753,"modified_method":"public static byte[] getSignature( final String key, final String subject, final Hmac mac ) throws AuthenticationException {\n    final SecretKeySpec signingKey = new SecretKeySpec( key.getBytes( Charsets.UTF_8 ), mac.toString( ) );\n    try {\n      return mac.digestBinary( signingKey, subject.getBytes( Charsets.UTF_8 ) );\n    } catch ( Exception e ) {\n      LOG.error( e, e );\n      throw new AuthenticationException( \"Failed to compute signature\" );\n    }\n  }","commit_id":"079d10aa9aeea3d3cb7c17fb3a21b97ccf308185","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public String getSignature( final String queryKey, final String subject, final Hmac mac ) throws AuthenticationException {\n    SecretKeySpec signingKey = new SecretKeySpec( queryKey.getBytes( ), mac.toString( ) );\n    try {\n      Mac digest = mac.getInstance( );\n      digest.init( signingKey );\n      byte[] rawHmac = digest.doFinal( subject.getBytes( ) );\n      return sanitize( Base64.encode( rawHmac ) );\n    } catch ( Exception e ) {\n      LOG.error( e, e );\n      throw new AuthenticationException( \"Failed to compute signature\" );\n    }\n  }","id":73754,"modified_method":"public String getSignature( final String queryKey, final String subject, final Hmac mac ) throws AuthenticationException {\n    SecretKeySpec signingKey = new SecretKeySpec( queryKey.getBytes( ), mac.toString( ) );\n    try {\n      byte[] rawHmac = mac.digestBinary( signingKey, subject.getBytes( ) );\n      return sanitize( Base64.encode( rawHmac ) );\n    } catch ( Exception e ) {\n      LOG.error( e, e );\n      throw new AuthenticationException( \"Failed to compute signature\" );\n    }\n  }","commit_id":"079d10aa9aeea3d3cb7c17fb3a21b97ccf308185","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public boolean authenticate( final HmacCredentials credentials ) throws Exception {\n    if ( credentials.getSignatureMethod() != Hmac.HmacSHA256 ) {\n      throw new AuthenticationException( \"Invalid signature method for v4: \" + credentials.getSignatureMethod() );\n    }\n\n    final String sig = credentials.getSignature( );\n    checkForReplay( sig );\n    final Function<String,List<String>> headerLookup = headerLookup( credentials.getHeaders() );\n    final Function<String,List<String>> parameterLookup = parameterLookup( credentials.getParameters() );\n    final Map<String,String> authorizationParameters = credentials.getVariant().getAuthorizationParameters( headerLookup, parameterLookup );\n    final SignatureCredential signatureCredential = new SignatureCredential( authorizationParameters.get(\"Credential\") );    \n    final AccessKey accessKey = lookupAccessKey( credentials );\n    final Date date = HmacUtils.getSignatureDate( EnumSet.of(HmacUtils.SignatureVersion.SignatureV4), headerLookup, parameterLookup );\n    signatureCredential.verify( date, null, null, V4_TERMINATOR ); //TODO Do we want to validate region and service name?\n    final UserPrincipal user = accessKey.getPrincipal( );\n    final String secretKey = accessKey.getSecretKey( );\n    final byte[] signatureKey = getSignatureKey( secretKey, signatureCredential );\n    final String canonicalString = this.makeSubjectString( credentials, signatureCredential, authorizationParameters, date, false );\n    final byte[] computedSig = this.getHmacSHA256( signatureKey, canonicalString );\n    final byte[] providedSig = Hex.decode( sig );\n    if ( !MessageDigest.isEqual( computedSig, providedSig ) ) {\n      final String canonicalStringNoPath = this.makeSubjectString( credentials, signatureCredential, authorizationParameters, date, true );\n      final byte[] computedSigNoPath = this.getHmacSHA256( signatureKey, canonicalStringNoPath );\n      if( !MessageDigest.isEqual( computedSigNoPath, providedSig ) ) {\n        throw new InvalidSignatureAuthException( \"Signature validation failed\" );\n      }\n    }\n    super.setCredential( credentials.getQueryIdCredential( AccessKeys.getKeyType( accessKey ) ) );\n    super.setPrincipal( user );\n\n    return true;\n  }","id":73755,"modified_method":"@Override\n  public boolean authenticate( final HmacCredentials credentials ) throws Exception {\n    if ( credentials.getSignatureMethod() != Hmac.HmacSHA256 ) {\n      throw new AuthenticationException( \"Invalid signature method for v4: \" + credentials.getSignatureMethod() );\n    }\n\n    final String sig = credentials.getSignature( );\n    checkForReplay( sig );\n    final Function<String,List<String>> headerLookup = headerLookup( credentials.getHeaders() );\n    final Function<String,List<String>> parameterLookup = parameterLookup( credentials.getParameters() );\n    final Map<String,String> authorizationParameters = credentials.getVariant().getAuthorizationParameters( headerLookup, parameterLookup );\n    final SignatureCredential signatureCredential = new SignatureCredential( authorizationParameters.get(\"Credential\") );    \n    final AccessKey accessKey = lookupAccessKey( credentials );\n    final Date date = HmacUtils.getSignatureDate( EnumSet.of(HmacUtils.SignatureVersion.SignatureV4), headerLookup, parameterLookup );\n    signatureCredential.verify( date, null, null, V4_TERMINATOR ); //TODO Do we want to validate region and service name?\n    final UserPrincipal user = accessKey.getPrincipal( );\n    final String secretKey = accessKey.getSecretKey( );\n    final byte[] signatureKey = getSignatureKey( secretKey, signatureCredential );\n    final CharSequence canonicalString = this.makeSubjectString( credentials, signatureCredential, authorizationParameters, date, false );\n    final byte[] computedSig = this.getHmacSHA256( signatureKey, canonicalString );\n    final byte[] providedSig = BaseEncoding.base16( ).lowerCase( ).decode( sig );\n    if ( !MessageDigest.isEqual( computedSig, providedSig ) ) {\n      final CharSequence canonicalStringNoPath = this.makeSubjectString( credentials, signatureCredential, authorizationParameters, date, true );\n      final byte[] computedSigNoPath = this.getHmacSHA256( signatureKey, canonicalStringNoPath );\n      if( !MessageDigest.isEqual( computedSigNoPath, providedSig ) ) {\n        throw new InvalidSignatureAuthException( \"Signature validation failed\" );\n      }\n    }\n    super.setCredential( credentials.getQueryIdCredential( AccessKeys.getKeyType( accessKey ) ) );\n    super.setPrincipal( user );\n\n    return true;\n  }","commit_id":"079d10aa9aeea3d3cb7c17fb3a21b97ccf308185","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private byte[] getHmacSHA256( final byte[] signatureKey,\n                                final String data ) throws AuthenticationException {\n    final SecretKeySpec signingKey = new SecretKeySpec( signatureKey, Hmac.HmacSHA256.toString( ) );\n    try {\n      final Mac digest = Hmac.HmacSHA256.getInstance( );\n      digest.init( signingKey );\n      return digest.doFinal( data.getBytes( Charsets.UTF_8 ) );\n    } catch ( Exception e ) {\n      LOG.error( e, e );\n      throw new AuthenticationException( \"Failed to compute signature\" );\n    }\n  }","id":73756,"modified_method":"private byte[] getHmacSHA256( final byte[] signatureKey,\n                                final CharSequence data ) throws AuthenticationException {\n    final SecretKeySpec signingKey = new SecretKeySpec( signatureKey, Hmac.HmacSHA256.toString( ) );\n    try {\n      final ByteBuffer byteBuffer = StandardCharsets.UTF_8.encode( CharBuffer.wrap( data ) );\n      return Hmac.HmacSHA256.digestBinary( signingKey, byteBuffer );\n    } catch ( Exception e ) {\n      LOG.error( e, e );\n      throw new AuthenticationException( \"Failed to compute signature\" );\n    }\n  }","commit_id":"079d10aa9aeea3d3cb7c17fb3a21b97ccf308185","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private String makeCanonicalRequest( @Nonnull final HmacCredentials credentials,\n                                       @Nonnull final Map<String,String> authorizationParameters,\n                                       final boolean skipPath ) throws Exception {\n    final StringBuilder sb = new StringBuilder();\n    sb.append(credentials.getVerb());\n    sb.append( \"\\n\" );\n    sb.append( skipPath ? \"/\" : canonicalizePath( credentials.getServicePath() ) ); // AWS Java SDK always uses \"/\"\n    sb.append( \"\\n\" );\n    boolean addedParam = false;\n    for ( final String parameter : Ordering.natural( ).sortedCopy( credentials.getParameters().keySet() ) ) {\n      if ( credentials.getVariant() == HmacUtils.SignatureVariant.SignatureV4Query && SecurityParameter.X_Amz_Signature.parameter().equals( parameter ) ) {\n        continue;\n      }\n      for ( final String value : Ordering.natural().sortedCopy( credentials.getParameters().get( parameter ) ) ) {\n        sb.append( urlencode(parameter) );\n        sb.append( \"=\" );\n        sb.append( urlencode(value) );\n        sb.append( \"&\" );\n        addedParam = true;\n      }\n    }\n    if ( addedParam ) sb.setLength( sb.length()-1 );\n    sb.append( \"\\n\" );\n    for ( final String header : authorizationParameters.get(\"SignedHeaders\").split(\";\") ) {\n      final List<String> values = Lists.transform( credentials.getHeaders().get( header ), new Function<String, String>() {\n        @Override\n        public String apply( final String text ) {\n          return text.trim();\n        }\n      } );\n      sb.append( header );\n      sb.append( \":\" );\n      sb.append( Joiner.on( \",\" ).join( Ordering.<String>natural().sortedCopy( values ) ) );\n      sb.append( \"\\n\" );\n    }\n    sb.append( \"\\n\" );\n    sb.append( authorizationParameters.get(\"SignedHeaders\") );\n    sb.append( \"\\n\" );\n    sb.append( digestUTF8( credentials.getBody() ) );\n    final String request = sb.toString( );\n    signatureLogger.trace( \"VERSION4: \" + request );\n    return request;\n  }","id":73757,"modified_method":"private CharSequence makeCanonicalRequest( @Nonnull final HmacCredentials credentials,\n                                             @Nonnull final Map<String,String> authorizationParameters,\n                                             final boolean skipPath ) throws Exception {\n    final StringBuilder sb = new StringBuilder( 512 );\n    sb.append( credentials.getVerb( ) );\n    sb.append( '\\n' );\n    sb.append( skipPath ? \"/\" : canonicalizePath( credentials.getServicePath( ) ) ); // AWS Java SDK always uses \"/\"\n    sb.append( '\\n' );\n    boolean addedParam = false;\n    for ( final String parameter : Ordering.natural( ).sortedCopy( credentials.getParameters().keySet() ) ) {\n      if ( credentials.getVariant() == HmacUtils.SignatureVariant.SignatureV4Query && SecurityParameter.X_Amz_Signature.parameter().equals( parameter ) ) {\n        continue;\n      }\n      for ( final String value : Ordering.natural().sortedCopy( credentials.getParameters().get( parameter ) ) ) {\n        sb.append( urlencode(parameter) );\n        sb.append( '=' );\n        sb.append( urlencode(value) );\n        sb.append( '&' );\n        addedParam = true;\n      }\n    }\n    if ( addedParam ) sb.setLength( sb.length()-1 );\n    sb.append( '\\n' );\n    for ( final String header : authorizationParameters.get(\"SignedHeaders\").split(\";\") ) {\n      final List<String> values = Lists.transform( credentials.getHeaders().get( header ), new Function<String, String>() {\n        @Override\n        public String apply( final String text ) {\n          return text.trim();\n        }\n      } );\n      sb.append( header );\n      sb.append( ':' );\n      sb.append( Joiner.on( ',' ).join( Ordering.<String>natural().sortedCopy( values ) ) );\n      sb.append( '\\n' );\n    }\n    sb.append( '\\n' );\n    sb.append( authorizationParameters.get(\"SignedHeaders\") );\n    sb.append( '\\n' );\n    sb.append( digestUTF8( credentials.getBody() ) );\n    if ( signatureLogger.isTraceEnabled( ) ) signatureLogger.trace( \"VERSION4: \" + sb.toString( ) );\n    return sb;\n  }","commit_id":"079d10aa9aeea3d3cb7c17fb3a21b97ccf308185","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private String makeSubjectString( @Nonnull final HmacCredentials credentials,\n                                    @Nonnull final SignatureCredential signatureCredential,\n                                    @Nonnull final Map<String,String> authorizationParameters,\n                                    @Nonnull final Date date,\n                                    final boolean skipPath ) throws Exception {\n    final String timestamp = Timestamps.formatShortIso8601Timestamp( date );\n    final StringBuilder sb = new StringBuilder();\n    sb.append( SecurityHeader.Value.AWS4_HMAC_SHA256.value() ).append( \"\\n\" );\n    sb.append( timestamp ).append( \"\\n\" );\n    sb.append( signatureCredential.getCredentialScope() ).append(\"\\n\");\n    sb.append( digestUTF8( makeCanonicalRequest( credentials, authorizationParameters, skipPath ) ) );\n    final String subject = sb.toString( );\n    signatureLogger.trace( \"VERSION4: \" + subject );\n    return subject;\n  }","id":73758,"modified_method":"private CharSequence makeSubjectString( @Nonnull final HmacCredentials credentials,\n                                          @Nonnull final SignatureCredential signatureCredential,\n                                          @Nonnull final Map<String,String> authorizationParameters,\n                                          @Nonnull final Date date,\n                                          final boolean skipPath ) throws Exception {\n    final String timestamp = Timestamps.formatShortIso8601Timestamp( date );\n    final StringBuilder sb = new StringBuilder( 256 );\n    sb.append( SecurityHeader.Value.AWS4_HMAC_SHA256.value() ).append( '\\n' );\n    sb.append( timestamp ).append( '\\n' );\n    sb.append( signatureCredential.getCredentialScope() ).append( '\\n' );\n    sb.append( digestUTF8( makeCanonicalRequest( credentials, authorizationParameters, skipPath ) ) );\n    if ( signatureLogger.isTraceEnabled( ) ) signatureLogger.trace( \"VERSION4: \" + sb.toString( ) );\n    return sb;\n  }","commit_id":"079d10aa9aeea3d3cb7c17fb3a21b97ccf308185","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private byte[] getSignatureKey( final String key,\n                                  final SignatureCredential credential ) throws Exception {\n    return getHmacSHA256(\n        getHmacSHA256(\n            getHmacSHA256(\n                getHmacSHA256( (\"AWS4\" + key).getBytes( Charsets.UTF_8 ), credential.getDate() ),\n                credential.getRegion() ),\n            credential.getServiceName() ),\n        credential.getTerminator() );\n  }","id":73759,"modified_method":"private byte[] getSignatureKey( final String key,\n                                  final SignatureCredential credential ) throws Exception {\n    return getHmacSHA256(\n        getHmacSHA256(\n            getHmacSHA256(\n                getHmacSHA256( (\"AWS4\" + key).getBytes( StandardCharsets.UTF_8 ), credential.getDate() ),\n                credential.getRegion() ),\n            credential.getServiceName() ),\n        credential.getTerminator() );\n  }","commit_id":"079d10aa9aeea3d3cb7c17fb3a21b97ccf308185","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static SimpleDateFormat sdf( final String pattern ) {\n    final SimpleDateFormat format = new SimpleDateFormat( pattern );\n    format.setTimeZone( TimeZone.getTimeZone( \"UTC\" ) ); \n    return format;\n  }","id":73760,"modified_method":"private static SimpleDateFormat sdf( final String pattern ) {\n    SimpleDateFormat format = patternLocal.get( ).getIfPresent( pattern );\n    if ( format == null ) {\n      format = new SimpleDateFormat( pattern );\n      format.setTimeZone( TimeZone.getTimeZone( \"UTC\" ) );\n      patternLocal.get( ).put( pattern, format );\n    }\n    return format;\n  }","commit_id":"079d10aa9aeea3d3cb7c17fb3a21b97ccf308185","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"protected String checkSignature(final String queryKey, final String subject) throws AuthenticationException {\n    SecretKeySpec signingKey = new SecretKeySpec(queryKey.getBytes(), Hmac.HmacSHA1.toString());\n    try {\n      Mac mac = Hmac.HmacSHA1.getInstance();\n      mac.init(signingKey);\n      byte[] rawHmac = mac.doFinal(subject.getBytes());\n      return new String(Base64.encode(rawHmac)).replaceAll(\"=\", \"\");\n    } catch (Exception e) {\n      LOG.error(e, e);\n      throw new AuthenticationException(\"Failed to compute signature\");\n    }\n  }","id":73761,"modified_method":"protected String checkSignature(final String queryKey, final String subject) throws AuthenticationException {\n    SecretKeySpec signingKey = new SecretKeySpec(queryKey.getBytes(), Hmac.HmacSHA1.toString());\n    try {\n      byte[] rawHmac = Hmac.HmacSHA1.digestBinary(signingKey,subject.getBytes());\n      return new String(Base64.encode(rawHmac)).replaceAll(\"=\", \"\");\n    } catch (Exception e) {\n      LOG.error(e, e);\n      throw new AuthenticationException(\"Failed to compute signature\");\n    }\n  }","commit_id":"079d10aa9aeea3d3cb7c17fb3a21b97ccf308185","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public Object execute(OIdentifiable iRecord, OCommandContext iContext, Object ioResult, Object[] iMethodParams) {\n\n    final Object v = getParameterValue(iRecord, iMethodParams[0].toString());\n    if (v != null) {\n      if (ioResult instanceof Date) {\n        final SimpleDateFormat format = new SimpleDateFormat(v.toString());\n        format.setTimeZone(ODateHelper.getDatabaseTimeZone());\n        ioResult = format.format(ioResult);\n      } else {\n        ioResult = ioResult != null ? String.format(v.toString(), ioResult) : null;\n      }\n    }\n\n    return ioResult;\n  }","id":73762,"modified_method":"@Override\n  public Object execute(OIdentifiable iRecord, OCommandContext iContext, Object ioResult, Object[] iMethodParams) {\n\n    final Object v = getParameterValue(iRecord, iMethodParams[0].toString());\n    if (v != null) {\n      if (ioResult instanceof Date) {\n        final SimpleDateFormat format = new SimpleDateFormat(v.toString());\n        if (iMethodParams.length > 1)\n          format.setTimeZone(TimeZone.getTimeZone(iMethodParams[1].toString()));\n        else\n          format.setTimeZone(ODateHelper.getDatabaseTimeZone());\n        ioResult = format.format(ioResult);\n      } else {\n        ioResult = ioResult != null ? String.format(v.toString(), ioResult) : null;\n      }\n    }\n\n    return ioResult;\n  }","commit_id":"4476f8c94183a90c6c4e5d87a2957240b00ffc39","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OSQLMethodFormat() {\n    super(NAME, 1);\n  }","id":73763,"modified_method":"public OSQLMethodFormat() {\n    super(NAME, 1, 2);\n  }","commit_id":"4476f8c94183a90c6c4e5d87a2957240b00ffc39","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void write(StructuredRecord structuredRecord) throws IOException {\n    if (tableSchema == null || rowFieldName == null) {\n      throw new IllegalStateException(String.format(\"Table must have both '%s' and '%s' properties set in \" +\n        \"order to be used as a RecordWritable.\", Table.PROPERTY_SCHEMA, Table.PROPERTY_SCHEMA_ROW_FIELD));\n    }\n    Put put = recordPutTransformer.toPut(structuredRecord);\n    put(put);\n  }","id":73764,"modified_method":"@Override\n  public void write(StructuredRecord structuredRecord) throws IOException {\n    if (recordPutTransformer == null) {\n      throw new IllegalStateException(String.format(\"Table must have both '%s' and '%s' properties set in \" +\n        \"order to be used as a RecordWritable.\", Table.PROPERTY_SCHEMA, Table.PROPERTY_SCHEMA_ROW_FIELD));\n    }\n    Put put = recordPutTransformer.toPut(structuredRecord);\n    put(put);\n  }","commit_id":"d1bd16a4f9ee27ab42584c13b4a0c752c6e3afc8","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * If a context was saved using {@link #saveContext(DatasetFramework, StreamAdmin, SystemDatasetInstantiatorFactory)},\n   * returns the saved context. This is what happens in the Explore service.\n   * If no context was saved and the conf is not null, creates a context and returns it. The context must be closed by\n   * the caller. The context created will not be saved, meaning the time this method is called,\n   * a new context will be created. This is what happens in map reduce jobs launched by Hive.\n   * If no context was saved and the conf is null, null is returned.\n   *\n   * The {@code conf} param is expected to contain serialized {@link co.cask.cdap.common.conf.CConfiguration} and\n   * {@link org.apache.hadoop.conf.Configuration} objects, as well as transaction information.\n   *\n   * @param conf configuration used to create a context, if necessary. If it is null, return the saved context, which\n   *             can also be null.\n   * @return Context of a query execution.\n   * @throws IOException when the configuration does not contain the required settings to create the context\n   */\n  public static Context getContext(@Nullable Configuration conf) throws IOException {\n    if (conf != null && savedContext == null) {\n      // Saving the context here is important. This code will be executed in a MR job launched by Hive, and accessed\n      // by the DatasetSerDe.initialize method, which needs to access the context when it wants to write to a\n      // dataset, so it can cache its name. In that case, conf will be null, and it won't be possible to create a\n      // context.\n      return createContext(conf);\n    }\n    return savedContext;\n  }","id":73765,"modified_method":"/**\n   * If a context was saved using {@link #saveContext(DatasetFramework, StreamAdmin, SystemDatasetInstantiatorFactory)},\n   * returns the saved context. This is what happens in the Explore service.\n   * If no context was saved and the conf is not null, creates a context and returns it. The context must be closed by\n   * the caller. The context created will not be saved, meaning the next time this method is called,\n   * a new context will be created. This is what happens in map reduce jobs launched by Hive.\n   * If no context was saved and the conf is null, null is returned.\n   *\n   * The {@code conf} param is expected to contain serialized {@link co.cask.cdap.common.conf.CConfiguration} and\n   * {@link org.apache.hadoop.conf.Configuration} objects, as well as transaction information.\n   *\n   * @param conf configuration used to create a context, if necessary. If it is null, return the saved context, which\n   *             can also be null.\n   * @return Context of a query execution.\n   * @throws IOException when the configuration does not contain the required settings to create the context\n   */\n  @Nullable\n  public static Context getContext(@Nullable Configuration conf) throws IOException {\n    if (conf != null && savedContext == null) {\n      return createContext(conf);\n    }\n    return savedContext;\n  }","commit_id":"d1bd16a4f9ee27ab42584c13b4a0c752c6e3afc8","url":"https://github.com/caskdata/cdap"},{"original_method":"public DatasetRecordWriter(DatasetAccessor datasetAccessor) {\n      this.datasetAccessor = datasetAccessor;\n      this.recordWritable = datasetAccessor.getDataset();\n      this.recordType = recordWritable.getRecordType();\n      if (recordType == StructuredRecord.class) {\n        try {\n          DatasetSpecification datasetSpec = datasetAccessor.getDatasetSpec();\n          String schemaStr = datasetSpec.getProperty(DatasetProperties.SCHEMA);\n          // should never happen, as this should have been checked at table creation\n          if (schemaStr == null) {\n            throw new IllegalStateException(\"Dataset does not have the schema property.\");\n          }\n          recordSchema = Schema.parseJson(schemaStr);\n        } catch (IOException | DatasetManagementException e) {\n          throw new RuntimeException(\"Unable to look up schema for dataset.\", e);\n        }\n      }\n    }","id":73766,"modified_method":"public DatasetRecordWriter(DatasetAccessor datasetAccessor) {\n      this.datasetAccessor = datasetAccessor;\n      this.recordWritable = datasetAccessor.getDataset();\n      this.recordType = recordWritable.getRecordType();\n      if (recordType == StructuredRecord.class) {\n        try {\n          DatasetSpecification datasetSpec = datasetAccessor.getDatasetSpec();\n          String schemaStr = datasetSpec.getProperty(DatasetProperties.SCHEMA);\n          // should never happen, as this should have been checked at table creation\n          if (schemaStr == null) {\n            throw new IllegalStateException(\n              String.format(\"Dataset '%s' does not have the schema property.\", datasetSpec.getName()));\n          }\n          recordSchema = Schema.parseJson(schemaStr);\n        } catch (IOException | DatasetManagementException e) {\n          try {\n            recordWritable.close();\n          } catch (IOException e1) {\n            LOG.warn(\"Exception closing dataset {} after failing to look up its schema.\",\n                     datasetAccessor.getDatasetId(), e1);\n          }\n          throw new RuntimeException(\"Unable to look up schema for dataset.\", e);\n        }\n      }\n    }","commit_id":"d1bd16a4f9ee27ab42584c13b4a0c752c6e3afc8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public RecordWriter<Void, Text> getRecordWriter(FileSystem ignored, final JobConf jobConf, String name,\n                                                  Progressable progress) throws IOException {\n    DatasetAccessor datasetAccessor = new DatasetAccessor(jobConf);\n    try {\n      datasetAccessor.initialize();\n    } catch (Exception e) {\n      throw new IOException(\"Could not get dataset.\", e);\n    }\n\n    return new DatasetRecordWriter(datasetAccessor);\n  }","id":73767,"modified_method":"@Override\n  public RecordWriter<Void, Text> getRecordWriter(FileSystem ignored, final JobConf jobConf, String name,\n                                                  Progressable progress) throws IOException {\n    DatasetAccessor datasetAccessor = new DatasetAccessor(jobConf);\n    try {\n      datasetAccessor.initialize();\n      return new DatasetRecordWriter(datasetAccessor);\n    } catch (Exception e) {\n      try {\n        datasetAccessor.close();\n      } catch (IOException e1) {\n        LOG.warn(\"Exception closing dataset accessor after failure to return a DatasetRecordWriter.\", e1);\n      }\n      throw new IOException(\"Could not get dataset.\", e);\n    }\n  }","commit_id":"d1bd16a4f9ee27ab42584c13b4a0c752c6e3afc8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void checkOutputSpecs(FileSystem ignored, JobConf jobConf) throws IOException {\n    // This is called prior to returning a RecordWriter. We make sure here that the\n    // dataset we want to write to is RecordWritable.\n    DatasetAccessor datasetAccessor = new DatasetAccessor(jobConf);\n    try {\n      datasetAccessor.initialize();\n    } catch (Exception e) {\n      throw new IOException(\"Could not get dataset.\", e);\n    }\n  }","id":73768,"modified_method":"@Override\n  public void checkOutputSpecs(FileSystem ignored, JobConf jobConf) throws IOException {\n    // This is called prior to returning a RecordWriter. We make sure here that the\n    // dataset we want to write to is RecordWritable.\n    try (DatasetAccessor datasetAccessor = new DatasetAccessor(jobConf)) {\n      try {\n        datasetAccessor.initialize();\n      } catch (DatasetNotFoundException e) {\n        throw new IOException(String.format(\"Dataset '%s' does not exist\",\n                                            datasetAccessor.getDatasetId()), e);\n      } catch (DatasetManagementException | ClassNotFoundException e) {\n        throw new IOException(String.format(\"Could not instantiate dataset '%s'\", datasetAccessor.getDatasetId()), e);\n      }\n      if (!(datasetAccessor.getDataset() instanceof RecordWritable)) {\n        throw new IOException(String.format(\"Dataset '%s' is not RecordWritable.\",\n                                            datasetAccessor.getDatasetId()));\n      }\n    }\n  }","commit_id":"d1bd16a4f9ee27ab42584c13b4a0c752c6e3afc8","url":"https://github.com/caskdata/cdap"},{"original_method":"private void getDatasetSchema(Configuration conf, Id.DatasetInstance datasetId) throws SerDeException {\n\n    try (ContextManager.Context hiveContext = ContextManager.getContext(conf)) {\n\n      // some datasets like Table and ObjectMappedTable have schema in the dataset properties\n      try {\n        DatasetSpecification datasetSpec = hiveContext.getDatasetSpec(datasetId);\n        String schemaStr = datasetSpec.getProperty(\"schema\");\n        if (schemaStr != null) {\n          schema = Schema.parseJson(schemaStr);\n          return;\n        }\n      } catch (DatasetManagementException | ServiceUnavailableException e) {\n        throw new SerDeException(\"Could not instantiate dataset \" + datasetId, e);\n      } catch (IOException e) {\n        throw new SerDeException(\"Exception getting schema for dataset \" + datasetId, e);\n      }\n\n      // other datasets must be instantiated to get their schema\n      // conf is null if this is a query that writes to a dataset\n      ClassLoader parentClassLoader = conf == null ? null : conf.getClassLoader();\n      try (SystemDatasetInstantiator datasetInstantiator = hiveContext.createDatasetInstantiator(parentClassLoader)) {\n        Dataset dataset = datasetInstantiator.getDataset(datasetId);\n        if (dataset == null) {\n          throw new SerDeException(\"Could not find dataset \" + datasetId);\n        }\n        Type recordType;\n        if (dataset instanceof RecordScannable) {\n          recordType = ((RecordScannable) dataset).getRecordType();\n        } else if (dataset instanceof RecordWritable) {\n          recordType = ((RecordWritable) dataset).getRecordType();\n        } else {\n          throw new SerDeException(\"Dataset \" + datasetId + \" is not explorable.\");\n        }\n        schema = schemaGenerator.generate(recordType);\n      } catch (UnsupportedTypeException e) {\n        throw new SerDeException(\"Dataset \" + datasetId + \" has an unsupported schema.\", e);\n      } catch (IOException e) {\n        throw new SerDeException(\"Exception while trying to instantiate dataset \" + datasetId, e);\n      }\n    } catch (IOException e) {\n      throw new SerDeException(\"Could not get hive context from configuration.\", e);\n    }\n  }","id":73769,"modified_method":"private void getDatasetSchema(Configuration conf, Id.DatasetInstance datasetId) throws SerDeException {\n\n    try (ContextManager.Context hiveContext = ContextManager.getContext(conf)) {\n      // apparently the conf can be null in some versions of Hive?\n      // Because it calls initialize just to get the object inspector\n      if (hiveContext == null) {\n        LOG.info(\"Hive provided a null conf, will not be able to get dataset schema.\");\n        return;\n      }\n\n      // some datasets like Table and ObjectMappedTable have schema in the dataset properties\n      try {\n        DatasetSpecification datasetSpec = hiveContext.getDatasetSpec(datasetId);\n        String schemaStr = datasetSpec.getProperty(\"schema\");\n        if (schemaStr != null) {\n          schema = Schema.parseJson(schemaStr);\n          return;\n        }\n      } catch (DatasetManagementException | ServiceUnavailableException e) {\n        throw new SerDeException(\"Could not instantiate dataset \" + datasetId, e);\n      } catch (IOException e) {\n        throw new SerDeException(\"Exception getting schema for dataset \" + datasetId, e);\n      }\n\n      // other datasets must be instantiated to get their schema\n      // conf is null if this is a query that writes to a dataset\n      ClassLoader parentClassLoader = conf == null ? null : conf.getClassLoader();\n      try (SystemDatasetInstantiator datasetInstantiator = hiveContext.createDatasetInstantiator(parentClassLoader)) {\n        Dataset dataset = datasetInstantiator.getDataset(datasetId);\n        if (dataset == null) {\n          throw new SerDeException(\"Could not find dataset \" + datasetId);\n        }\n        Type recordType;\n        if (dataset instanceof RecordScannable) {\n          recordType = ((RecordScannable) dataset).getRecordType();\n        } else if (dataset instanceof RecordWritable) {\n          recordType = ((RecordWritable) dataset).getRecordType();\n        } else {\n          throw new SerDeException(\"Dataset \" + datasetId + \" is not explorable.\");\n        }\n        schema = schemaGenerator.generate(recordType);\n      } catch (UnsupportedTypeException e) {\n        throw new SerDeException(\"Dataset \" + datasetId + \" has an unsupported schema.\", e);\n      } catch (IOException e) {\n        throw new SerDeException(\"Exception while trying to instantiate dataset \" + datasetId, e);\n      }\n    } catch (IOException e) {\n      throw new SerDeException(\"Could not get hive context from configuration.\", e);\n    }\n  }","commit_id":"d1bd16a4f9ee27ab42584c13b4a0c752c6e3afc8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void initialize(Configuration conf, Properties properties) throws SerDeException {\n    // The columns property comes from the Hive metastore, which has it from the create table statement\n    // It is then important that this schema be accurate and in the right order - the same order as\n    // object inspectors will reflect them.\n\n    String streamName = properties.getProperty(Constants.Explore.STREAM_NAME);\n    String streamNamespace = properties.getProperty(Constants.Explore.STREAM_NAMESPACE);\n\n    // no namespace SHOULD be an exception but... Hive calls initialize in several places, one of which is\n    // when you try and drop a table.\n    // When updating to CDAP 2.8, old tables will not have namespace as a serde property. So in order\n    // to avoid a null pointer exception that prevents dropping a table, we handle the null namespace case here.\n    if (streamNamespace == null) {\n      // we also still need an ObjectInspector as Hive uses it to check what columns the table has.\n      this.inspector = new ObjectDeserializer(properties, null).getInspector();\n      return;\n    }\n\n    Id.Stream streamId = Id.Stream.from(streamNamespace, streamName);\n    try (ContextManager.Context context = ContextManager.getContext(conf)) {\n      // Get the stream format from the stream config.\n      FormatSpecification formatSpec = getFormatSpec(properties, streamId, context);\n      this.streamFormat = (AbstractStreamEventRecordFormat) RecordFormats.createInitializedFormat(formatSpec);\n      Schema schema = formatSpec.getSchema();\n      this.deserializer = new ObjectDeserializer(properties, schema, BODY_OFFSET);\n      this.inspector = deserializer.getInspector();\n    } catch (UnsupportedTypeException e) {\n      // this should have been validated up front when schema was set on the stream.\n      // if we hit this something went wrong much earlier.\n      LOG.error(\"Schema unsupported by format.\", e);\n      throw new SerDeException(\"Schema unsupported by format.\", e);\n    } catch (IOException e) {\n      LOG.error(\"Could not get the config for stream {}.\", streamName, e);\n      throw new SerDeException(\"Could not get the config for stream \" + streamName, e);\n    } catch (Exception e) {\n      LOG.error(\"Could not create the format for stream {}.\", streamName, e);\n      throw new SerDeException(\"Could not create the format for stream \" + streamName, e);\n    }\n  }","id":73770,"modified_method":"@Override\n  public void initialize(Configuration conf, Properties properties) throws SerDeException {\n    // The columns property comes from the Hive metastore, which has it from the create table statement\n    // It is then important that this schema be accurate and in the right order - the same order as\n    // object inspectors will reflect them.\n\n    String streamName = properties.getProperty(Constants.Explore.STREAM_NAME);\n    String streamNamespace = properties.getProperty(Constants.Explore.STREAM_NAMESPACE);\n\n    // no namespace SHOULD be an exception but... Hive calls initialize in several places, one of which is\n    // when you try and drop a table.\n    // When updating to CDAP 2.8, old tables will not have namespace as a serde property. So in order\n    // to avoid a null pointer exception that prevents dropping a table, we handle the null namespace case here.\n    if (streamNamespace == null) {\n      // we also still need an ObjectInspector as Hive uses it to check what columns the table has.\n      this.inspector = new ObjectDeserializer(properties, null).getInspector();\n      return;\n    }\n\n    Id.Stream streamId = Id.Stream.from(streamNamespace, streamName);\n    try (ContextManager.Context context = ContextManager.getContext(conf)) {\n      Schema schema = null;\n      // apparently the conf can be null in some versions of Hive?\n      // Because it calls initialize just to get the object inspector\n      if (context != null) {\n        // Get the stream format from the stream config.\n        FormatSpecification formatSpec = getFormatSpec(properties, streamId, context);\n        this.streamFormat = (AbstractStreamEventRecordFormat) RecordFormats.createInitializedFormat(formatSpec);\n        schema = formatSpec.getSchema();\n      }\n      this.deserializer = new ObjectDeserializer(properties, schema, BODY_OFFSET);\n      this.inspector = deserializer.getInspector();\n    } catch (UnsupportedTypeException e) {\n      // this should have been validated up front when schema was set on the stream.\n      // if we hit this something went wrong much earlier.\n      LOG.error(\"Schema unsupported by format.\", e);\n      throw new SerDeException(\"Schema unsupported by format.\", e);\n    } catch (IOException e) {\n      LOG.error(\"Could not get the config for stream {}.\", streamName, e);\n      throw new SerDeException(\"Could not get the config for stream \" + streamName, e);\n    } catch (Exception e) {\n      LOG.error(\"Could not create the format for stream {}.\", streamName, e);\n      throw new SerDeException(\"Could not create the format for stream \" + streamName, e);\n    }\n  }","commit_id":"d1bd16a4f9ee27ab42584c13b4a0c752c6e3afc8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void configureGroups(QueueName name, Map<Long, Integer> groupInfo) throws Exception {\n    Preconditions.checkArgument(name.isStream(), \"The {} is not stream.\", name);\n    Preconditions.checkArgument(!groupInfo.isEmpty(), \"Consumer group information must not be empty.\");\n\n    LOG.info(\"Configure groups for {}: {}\", name, groupInfo);\n\n    StreamConfig config = StreamUtils.ensureExists(this, name.getSimpleName());\n    StreamConsumerStateStore stateStore = stateStoreFactory.create(config);\n    try {\n      Set<StreamConsumerState> states = Sets.newHashSet();\n      stateStore.getAll(states);\n\n      // Remove all groups that are no longer exists. The offset information in that group can be discarded.\n      Set<StreamConsumerState> removeStates = Sets.newHashSet();\n      for (StreamConsumerState state : states) {\n        if (!groupInfo.containsKey(state.getGroupId())) {\n          removeStates.add(state);\n        }\n      }\n\n      // For each groups, compute the new file offsets if needed\n      Set<StreamConsumerState> newStates = Sets.newHashSet();\n      for (Map.Entry<Long, Integer> entry : groupInfo.entrySet()) {\n        final long groupId = entry.getKey();\n\n        // Create a view of old states which match with the current groupId only.\n        mutateStates(groupId, entry.getValue(), Sets.filter(states, new Predicate<StreamConsumerState>() {\n          @Override\n          public boolean apply(StreamConsumerState state) {\n            return state.getGroupId() == groupId;\n          }\n        }), newStates, removeStates);\n      }\n\n      // Save the states back\n      if (!newStates.isEmpty()) {\n        stateStore.save(newStates);\n        LOG.info(\"Configure groups new states: {} {}\", groupInfo, newStates);\n      }\n      if (!removeStates.isEmpty()) {\n        stateStore.remove(removeStates);\n        LOG.info(\"Configure groups remove states: {} {}\", groupInfo, removeStates);\n      }\n\n    } finally {\n      stateStore.close();\n    }\n\n    // Also configure the old stream if it exists\n    if (oldStreamAdmin.exists(name.toURI().toString())) {\n      oldStreamAdmin.configureGroups(name, groupInfo);\n    }\n  }","id":73771,"modified_method":"@Override\n  public void configureGroups(QueueName name, Map<Long, Integer> groupInfo) throws Exception {\n    Preconditions.checkArgument(name.isStream(), \"%s is not a stream.\", name);\n    Preconditions.checkArgument(!groupInfo.isEmpty(), \"Consumer group information must not be empty.\");\n\n    LOG.info(\"Configure groups for {}: {}\", name, groupInfo);\n\n    StreamConfig config = StreamUtils.ensureExists(this, name.getSimpleName());\n    StreamConsumerStateStore stateStore = stateStoreFactory.create(config);\n    try {\n      Set<StreamConsumerState> states = Sets.newHashSet();\n      stateStore.getAll(states);\n\n      // Remove all groups that are no longer exists. The offset information in that group can be discarded.\n      Set<StreamConsumerState> removeStates = Sets.newHashSet();\n      for (StreamConsumerState state : states) {\n        if (!groupInfo.containsKey(state.getGroupId())) {\n          removeStates.add(state);\n        }\n      }\n\n      // For each groups, compute the new file offsets if needed\n      Set<StreamConsumerState> newStates = Sets.newHashSet();\n      for (Map.Entry<Long, Integer> entry : groupInfo.entrySet()) {\n        final long groupId = entry.getKey();\n\n        // Create a view of old states which match with the current groupId only.\n        mutateStates(groupId, entry.getValue(), Sets.filter(states, new Predicate<StreamConsumerState>() {\n          @Override\n          public boolean apply(StreamConsumerState state) {\n            return state.getGroupId() == groupId;\n          }\n        }), newStates, removeStates);\n      }\n\n      // Save the states back\n      if (!newStates.isEmpty()) {\n        stateStore.save(newStates);\n        LOG.info(\"Configure groups new states: {} {}\", groupInfo, newStates);\n      }\n      if (!removeStates.isEmpty()) {\n        stateStore.remove(removeStates);\n        LOG.info(\"Configure groups remove states: {} {}\", groupInfo, removeStates);\n      }\n\n    } finally {\n      stateStore.close();\n    }\n\n    // Also configure the old stream if it exists\n    if (oldStreamAdmin.exists(name.toURI().toString())) {\n      oldStreamAdmin.configureGroups(name, groupInfo);\n    }\n  }","commit_id":"7131ea65fa5286892cff05e920cff275f69b8f70","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public StreamConfig getConfig(String streamName) throws IOException {\n    Location streamLocation = streamBaseLocation.append(streamName);\n    Preconditions.checkArgument(streamLocation.isDirectory(), \"Stream '%s' not exists.\", streamName);\n    return loadConfig(streamLocation);\n  }","id":73772,"modified_method":"@Override\n  public StreamConfig getConfig(String streamName) throws IOException {\n    Location streamLocation = streamBaseLocation.append(streamName);\n    Preconditions.checkArgument(streamLocation.isDirectory(), \"Stream '%s' does not exist.\", streamName);\n    return loadConfig(streamLocation);\n  }","commit_id":"7131ea65fa5286892cff05e920cff275f69b8f70","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void create(String name, @Nullable Properties props) throws Exception {\n    Location streamLocation = streamBaseLocation.append(name);\n    Locations.mkdirsIfNotExists(streamLocation);\n\n    Location configLocation = streamBaseLocation.append(name).append(CONFIG_FILE_NAME);\n    if (!configLocation.createNew()) {\n      // Stream already exists\n      return;\n    }\n\n    Properties properties = (props == null) ? new Properties() : props;\n    long partitionDuration = Long.parseLong(properties.getProperty(Constants.Stream.PARTITION_DURATION,\n                                            cConf.get(Constants.Stream.PARTITION_DURATION)));\n    long indexInterval = Long.parseLong(properties.getProperty(Constants.Stream.INDEX_INTERVAL,\n                                                               cConf.get(Constants.Stream.INDEX_INTERVAL)));\n    long ttl = Long.parseLong(properties.getProperty(Constants.Stream.TTL,\n                                                     cConf.get(Constants.Stream.TTL)));\n\n    Location tmpConfigLocation = configLocation.getTempFile(null);\n    StreamConfig config = new StreamConfig(name, partitionDuration, indexInterval, ttl, streamLocation, null);\n    CharStreams.write(GSON.toJson(config), CharStreams.newWriterSupplier(\n      Locations.newOutputSupplier(tmpConfigLocation), Charsets.UTF_8));\n\n    try {\n      // Windows does not allow renaming if the destination file exists so we must delete the configLocation\n      if (OSDetector.isWindows()) {\n        configLocation.delete();\n      }\n      tmpConfigLocation.renameTo(streamBaseLocation.append(name).append(CONFIG_FILE_NAME));\n    } finally {\n      if (tmpConfigLocation.exists()) {\n        tmpConfigLocation.delete();\n      }\n    }\n  }","id":73773,"modified_method":"@Override\n  public void create(String name, @Nullable Properties props) throws Exception {\n    Location streamLocation = streamBaseLocation.append(name);\n    Locations.mkdirsIfNotExists(streamLocation);\n\n    Location configLocation = streamBaseLocation.append(name).append(CONFIG_FILE_NAME);\n    if (!configLocation.createNew()) {\n      // Stream already exists\n      return;\n    }\n\n    Properties properties = (props == null) ? new Properties() : props;\n    long partitionDuration = Long.parseLong(properties.getProperty(Constants.Stream.PARTITION_DURATION,\n                                            cConf.get(Constants.Stream.PARTITION_DURATION)));\n    long indexInterval = Long.parseLong(properties.getProperty(Constants.Stream.INDEX_INTERVAL,\n                                                               cConf.get(Constants.Stream.INDEX_INTERVAL)));\n    long ttl = Long.parseLong(properties.getProperty(Constants.Stream.TTL,\n                                                     cConf.get(Constants.Stream.TTL)));\n\n    StreamConfig config = new StreamConfig(name, partitionDuration, indexInterval, ttl, streamLocation, null);\n    saveConfig(config);\n  }","commit_id":"7131ea65fa5286892cff05e920cff275f69b8f70","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void updateConfig(StreamConfig config) throws IOException {\n    Location streamLocation = config.getLocation();\n    Preconditions.checkArgument(streamLocation.isDirectory(), \"Stream '{}' not exists.\", config.getName());\n\n    // Check only TTL is changed, as only TTL change is supported.\n    StreamConfig originalConfig = loadConfig(streamLocation);\n    Preconditions.checkArgument(isValidConfigUpdate(originalConfig, config),\n                                \"Configuration update for stream '{}' was not valid (can only update ttl)\",\n                                config.getName());\n\n    streamCoordinator.changeTTL(originalConfig, config.getTTL());\n  }","id":73774,"modified_method":"@Override\n  public void updateConfig(StreamConfig config) throws IOException {\n    Location streamLocation = config.getLocation();\n    Preconditions.checkArgument(streamLocation.isDirectory(), \"Stream '%s' does not exist.\", config.getName());\n\n    // Check only TTL or format is changed, as only TTL or format changes are supported.\n    StreamConfig originalConfig = loadConfig(streamLocation);\n    Preconditions.checkArgument(isValidConfigUpdate(originalConfig, config),\n                                \"Configuration update for stream '%s' was not valid (can only update ttl or format)\",\n                                config.getName());\n\n    if (originalConfig.getTTL() != config.getTTL()) {\n      streamCoordinator.changeTTL(originalConfig, config.getTTL());\n    }\n    if (!originalConfig.getFormat().equals(config.getFormat())) {\n      saveConfig(config);\n    }\n  }","commit_id":"7131ea65fa5286892cff05e920cff275f69b8f70","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void configureInstances(QueueName name, long groupId, int instances) throws Exception {\n    Preconditions.checkArgument(name.isStream(), \"The {} is not stream.\", name);\n    Preconditions.checkArgument(instances > 0, \"Number of consumer instances must be > 0.\");\n\n    LOG.info(\"Configure instances: {} {}\", groupId, instances);\n\n    StreamConfig config = StreamUtils.ensureExists(this, name.getSimpleName());\n    StreamConsumerStateStore stateStore = stateStoreFactory.create(config);\n    try {\n      Set<StreamConsumerState> states = Sets.newHashSet();\n      stateStore.getByGroup(groupId, states);\n\n      Set<StreamConsumerState> newStates = Sets.newHashSet();\n      Set<StreamConsumerState> removeStates = Sets.newHashSet();\n      mutateStates(groupId, instances, states, newStates, removeStates);\n\n      // Save the states back\n      if (!newStates.isEmpty()) {\n        stateStore.save(newStates);\n        LOG.info(\"Configure instances new states: {} {} {}\", groupId, instances, newStates);\n      }\n      if (!removeStates.isEmpty()) {\n        stateStore.remove(removeStates);\n        LOG.info(\"Configure instances remove states: {} {} {}\", groupId, instances, removeStates);\n      }\n\n    } finally {\n      stateStore.close();\n    }\n\n    // Also configure the old stream if it exists\n    if (oldStreamAdmin.exists(name.toURI().toString())) {\n      oldStreamAdmin.configureInstances(name, groupId, instances);\n    }\n  }","id":73775,"modified_method":"@Override\n  public void configureInstances(QueueName name, long groupId, int instances) throws Exception {\n    Preconditions.checkArgument(name.isStream(), \"%s is not a stream.\", name);\n    Preconditions.checkArgument(instances > 0, \"Number of consumer instances must be > 0.\");\n\n    LOG.info(\"Configure instances: {} {}\", groupId, instances);\n\n    StreamConfig config = StreamUtils.ensureExists(this, name.getSimpleName());\n    StreamConsumerStateStore stateStore = stateStoreFactory.create(config);\n    try {\n      Set<StreamConsumerState> states = Sets.newHashSet();\n      stateStore.getByGroup(groupId, states);\n\n      Set<StreamConsumerState> newStates = Sets.newHashSet();\n      Set<StreamConsumerState> removeStates = Sets.newHashSet();\n      mutateStates(groupId, instances, states, newStates, removeStates);\n\n      // Save the states back\n      if (!newStates.isEmpty()) {\n        stateStore.save(newStates);\n        LOG.info(\"Configure instances new states: {} {} {}\", groupId, instances, newStates);\n      }\n      if (!removeStates.isEmpty()) {\n        stateStore.remove(removeStates);\n        LOG.info(\"Configure instances remove states: {} {} {}\", groupId, instances, removeStates);\n      }\n\n    } finally {\n      stateStore.close();\n    }\n\n    // Also configure the old stream if it exists\n    if (oldStreamAdmin.exists(name.toURI().toString())) {\n      oldStreamAdmin.configureInstances(name, groupId, instances);\n    }\n  }","commit_id":"7131ea65fa5286892cff05e920cff275f69b8f70","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public int hashCode() {\n    return Objects.hashCode(formatClass, schema, settings);\n  }","id":73776,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hashCode(name, schema, settings);\n  }","commit_id":"7131ea65fa5286892cff05e920cff275f69b8f70","url":"https://github.com/caskdata/cdap"},{"original_method":"public FormatSpecification(String formatClass, Schema schema, Map<String, String> settings) {\n    this.formatClass = formatClass;\n    this.schema = schema;\n    this.settings = settings;\n  }","id":73777,"modified_method":"public FormatSpecification(String name, Schema schema, Map<String, String> settings) {\n    this.name = name;\n    this.schema = schema;\n    this.settings = settings == null ? Collections.<String, String>emptyMap() : settings;\n  }","commit_id":"7131ea65fa5286892cff05e920cff275f69b8f70","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String toString() {\n    return Objects.toStringHelper(this)\n      .add(\"formatClass\", formatClass)\n      .add(\"schema\", schema)\n      .add(\"settings\", settings)\n      .toString();\n  }","id":73778,"modified_method":"@Override\n  public String toString() {\n    return Objects.toStringHelper(this)\n      .add(\"name\", name)\n      .add(\"schema\", schema)\n      .add(\"settings\", settings)\n      .toString();\n  }","commit_id":"7131ea65fa5286892cff05e920cff275f69b8f70","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (!(o instanceof FormatSpecification)) {\n      return false;\n    }\n\n    FormatSpecification that = (FormatSpecification) o;\n\n    return Objects.equal(formatClass, that.formatClass) &&\n      Objects.equal(schema, that.schema) &&\n      Objects.equal(settings, that.settings);\n  }","id":73779,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (!(o instanceof FormatSpecification)) {\n      return false;\n    }\n\n    FormatSpecification that = (FormatSpecification) o;\n\n    return Objects.equal(name, that.name) &&\n      Objects.equal(schema, that.schema) &&\n      Objects.equal(settings, that.settings);\n  }","commit_id":"7131ea65fa5286892cff05e920cff275f69b8f70","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Initialize the format with the given desired schema and properties.\n   * Guaranteed to be called once before any other method is called.\n   *\n   * @param formatSpecification specification for the format, containing the desired schema and settings.\n   * @throws UnsupportedTypeException if the desired schema and properties are not supported.\n   */\n  public void initialize(FormatSpecification formatSpecification)\n    throws UnsupportedTypeException {\n    Schema desiredSchema = formatSpecification.getSchema();\n    if (desiredSchema != null) {\n      validateIsRecord(desiredSchema);\n      validateDesiredSchema(desiredSchema);\n      this.schema = desiredSchema;\n    }\n    configure(formatSpecification.getSettings());\n  }","id":73780,"modified_method":"/**\n   * Initialize the format with the given desired schema and properties.\n   * Guaranteed to be called once before any other method is called.\n   *\n   * @param formatSpecification specification for the format, containing the desired schema and settings.\n   * @throws UnsupportedTypeException if the desired schema and properties are not supported.\n   */\n  public void initialize(FormatSpecification formatSpecification) throws UnsupportedTypeException {\n    Schema desiredSchema = null;\n    Map<String, String> settings = Collections.emptyMap();\n    if (formatSpecification != null) {\n      desiredSchema = formatSpecification.getSchema();\n      settings = formatSpecification.getSettings();\n    }\n    if (desiredSchema != null) {\n      validateIsRecord(desiredSchema);\n      validateDesiredSchema(desiredSchema);\n      this.schema = desiredSchema;\n    }\n    configure(settings);\n  }","commit_id":"7131ea65fa5286892cff05e920cff275f69b8f70","url":"https://github.com/caskdata/cdap"},{"original_method":"private StreamConfig getConfigUpdate(HttpRequest request, StreamConfig config) {\n    JsonObject json = GSON.fromJson(request.getContent().toString(Charsets.UTF_8), JsonObject.class);\n\n    // Only pickup changes in TTL\n    if (json.has(\"ttl\")) {\n      JsonElement ttl = json.get(\"ttl\");\n      if (ttl.isJsonPrimitive()) {\n        // TTL in the REST API is in seconds. Convert it to ms for the config.\n        return new StreamConfig(config.getName(), config.getPartitionDuration(), config.getIndexInterval(),\n                                TimeUnit.SECONDS.toMillis(ttl.getAsLong()), config.getLocation(), config.getFormat());\n      }\n    }\n    return config;\n  }","id":73781,"modified_method":"private StreamConfig getAndValidateConfig(StreamConfig currConfig, HttpRequest request, HttpResponder responder) {\n    // get new config settings from the request. Only TTL and format spec can be changed, which is\n    // why the StreamProperties object is used instead of a StreamConfig object.\n    Reader reader = new InputStreamReader(new ChannelBufferInputStream(request.getContent()));\n    StreamProperties properties;\n    try {\n      properties = GSON.fromJson(reader, StreamProperties.class);\n    } catch (Exception e) {\n      responder.sendString(HttpResponseStatus.BAD_REQUEST, \"Invalid stream configuration. Please check that the \" +\n        \"configuration is a valid JSON Object with a valid schema.\");\n      return null;\n    }\n\n    // if no ttl is given, use the existing ttl.\n    Long newTTL = properties.getTTL();\n    if (newTTL == null) {\n      newTTL = currConfig.getTTL();\n    } else {\n      if (newTTL < 0) {\n        responder.sendString(HttpResponseStatus.BAD_REQUEST, \"TTL value should be positive.\");\n        return null;\n      }\n      // TTL in the REST API is in seconds. Convert it to ms for the config.\n      newTTL = TimeUnit.SECONDS.toMillis(newTTL);\n    }\n\n    FormatSpecification newFormatSpec = properties.getFormat();\n    // if no format spec is given, use the existing format spec.\n    if (newFormatSpec == null) {\n      newFormatSpec = currConfig.getFormat();\n    } else {\n      String formatName = newFormatSpec.getName();\n      if (formatName == null) {\n        responder.sendString(HttpResponseStatus.BAD_REQUEST, \"A format name must be specified.\");\n        return null;\n      }\n      try {\n        // if a format is given, make sure it is a valid format,\n        // check that we can instantiate the format class\n        RecordFormat format = RecordFormats.create(formatName);\n        // check that this format + schema combination is valid\n        format.initialize(newFormatSpec);\n        // the request may contain a null schema, in which case the default schema of the format should be used.\n        // create a new specification object that is guaranteed to have a non-null schema.\n        newFormatSpec = new FormatSpecification(newFormatSpec.getName(),\n                                                format.getSchema(), newFormatSpec.getSettings());\n      } catch (UnsupportedTypeException e) {\n        responder.sendString(HttpResponseStatus.BAD_REQUEST,\n                             \"Format \" + formatName + \" does not support the requested schema.\");\n        return null;\n      } catch (Exception e) {\n        responder.sendString(HttpResponseStatus.BAD_REQUEST,\n                             \"Invalid format, unable to instantiate format \" + formatName);\n        return null;\n      }\n    }\n\n    return new StreamConfig(currConfig.getName(), currConfig.getPartitionDuration(), currConfig.getIndexInterval(),\n                            newTTL, currConfig.getLocation(), newFormatSpec);\n  }","commit_id":"7131ea65fa5286892cff05e920cff275f69b8f70","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public JsonElement serialize(StreamProperties src, Type typeOfSrc, JsonSerializationContext context) {\n      JsonObject json = new JsonObject();\n      json.addProperty(\"name\", src.getName());\n      json.addProperty(\"ttl\", TimeUnit.MILLISECONDS.toSeconds(src.getTTL()));\n      return json;\n    }","id":73782,"modified_method":"@Override\n    public JsonElement serialize(StreamProperties src, Type typeOfSrc, JsonSerializationContext context) {\n      JsonObject json = new JsonObject();\n      json.addProperty(\"name\", src.getName());\n      json.addProperty(\"ttl\", TimeUnit.MILLISECONDS.toSeconds(src.getTTL()));\n      json.add(\"format\", context.serialize(src.getFormat(), FormatSpecification.class));\n      return json;\n    }","commit_id":"7131ea65fa5286892cff05e920cff275f69b8f70","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testStreamInfo() throws Exception {\n    int port = GatewayTestBase.getPort();\n\n    // Now, create the new stream.\n    HttpURLConnection urlConn = openURL(String.format(\"http://%s:%d/v2/streams/stream_info\",\n                                                      HOSTNAME, port), HttpMethod.PUT);\n    Assert.assertEquals(HttpResponseStatus.OK.getCode(), urlConn.getResponseCode());\n    urlConn.disconnect();\n\n    //config ttl for the stream\n    urlConn = openURL(String.format(\"http://%s:%d/v2/streams/stream_info/config\",\n                                    HOSTNAME, port), HttpMethod.PUT);\n    urlConn.setDoOutput(true);\n    JsonObject json = new JsonObject();\n    json.addProperty(\"ttl\", \"2\");\n    urlConn.getOutputStream().write(json.toString().getBytes(Charsets.UTF_8));\n    Assert.assertEquals(HttpResponseStatus.OK.getCode(), urlConn.getResponseCode());\n    urlConn.disconnect();\n\n    // test the config ttl by calling info\n    urlConn = openURL(String.format(\"http://%s:%d/v2/streams/stream_info/info\", HOSTNAME, port),\n                      HttpMethod.GET);\n    Assert.assertEquals(HttpResponseStatus.OK.getCode(), urlConn.getResponseCode());\n    StreamProperties properties = GSON.fromJson(new String(ByteStreams.toByteArray(urlConn.getInputStream()),\n                                                        Charsets.UTF_8), StreamProperties.class);\n    Assert.assertEquals(2, properties.getTTL());\n    urlConn.disconnect();\n  }","id":73783,"modified_method":"@Test\n  public void testStreamInfo() throws Exception {\n    int port = GatewayTestBase.getPort();\n\n    // Now, create the new stream.\n    HttpURLConnection urlConn = openURL(String.format(\"http://%s:%d/v2/streams/stream_info\",\n                                                      HOSTNAME, port), HttpMethod.PUT);\n    Assert.assertEquals(HttpResponseStatus.OK.getCode(), urlConn.getResponseCode());\n    urlConn.disconnect();\n\n    // put a new config\n    urlConn = openURL(String.format(\"http://%s:%d/v2/streams/stream_info/config\",\n                                    HOSTNAME, port), HttpMethod.PUT);\n    urlConn.setDoOutput(true);\n    Schema schema = Schema.recordOf(\"event\", Schema.Field.of(\"purchase\", Schema.of(Schema.Type.STRING)));\n    FormatSpecification formatSpecification =\n      new FormatSpecification(SingleStringRecordFormat.class.getCanonicalName(),\n                              schema,\n                              ImmutableMap.of(SingleStringRecordFormat.CHARSET, \"utf8\"));\n    StreamProperties streamProperties = new StreamProperties(\"stream_info\", 2, formatSpecification);\n    urlConn.getOutputStream().write(GSON.toJson(streamProperties).getBytes(Charsets.UTF_8));\n    Assert.assertEquals(HttpResponseStatus.OK.getCode(), urlConn.getResponseCode());\n    urlConn.disconnect();\n\n    // test the config ttl by calling info\n    urlConn = openURL(String.format(\"http://%s:%d/v2/streams/stream_info/info\", HOSTNAME, port),\n                      HttpMethod.GET);\n    Assert.assertEquals(HttpResponseStatus.OK.getCode(), urlConn.getResponseCode());\n    StreamProperties actual = GSON.fromJson(new String(ByteStreams.toByteArray(urlConn.getInputStream()),\n                                                        Charsets.UTF_8), StreamProperties.class);\n    urlConn.disconnect();\n    Assert.assertEquals(streamProperties, actual);\n  }","commit_id":"7131ea65fa5286892cff05e920cff275f69b8f70","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String toString() {\n    return Objects.toStringHelper(this)\n      .add(\"name\", name)\n      .add(\"ttl\", ttl)\n      .toString();\n  }","id":73784,"modified_method":"@Override\n  public String toString() {\n    return Objects.toStringHelper(this)\n      .add(\"name\", name)\n      .add(\"ttl\", ttl)\n      .add(\"format\", format)\n      .toString();\n  }","commit_id":"7131ea65fa5286892cff05e920cff275f69b8f70","url":"https://github.com/caskdata/cdap"},{"original_method":"public StreamProperties(String name, long ttl) {\n    this.name = name;\n    this.ttl = ttl;\n  }","id":73785,"modified_method":"public StreamProperties(String name, long ttl, FormatSpecification format) {\n    this.name = name;\n    this.ttl = ttl;\n    this.format = format;\n  }","commit_id":"7131ea65fa5286892cff05e920cff275f69b8f70","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void initialize(Configuration conf, Properties properties) throws SerDeException {\n    // The columns property comes from the Hive metastore, which has it from the create table statement\n    // It is then important that this schema be accurate and in the right order - the same order as\n    // object inspectors will reflect them.\n    columnNames = Lists.newArrayList(properties.getProperty(serdeConstants.LIST_COLUMNS).split(\",\"));\n    columnTypes = TypeInfoUtils.getTypeInfosFromTypeString(properties.getProperty(serdeConstants.LIST_COLUMN_TYPES));\n    // timestamp and headers are guaranteed to be the first columns in a stream table.\n    // the rest of the columns are for the stream body.\n    bodyColumnNames = columnNames.subList(BODY_OFFSET, columnNames.size());\n    bodyColumnTypes = columnTypes.subList(BODY_OFFSET, columnTypes.size());\n\n    int numCols = columnNames.size();\n\n    final List<ObjectInspector> columnOIs = new ArrayList<ObjectInspector>(numCols);\n\n    for (int i = 0; i < numCols; i++) {\n      columnOIs.add(TypeInfoUtils.getStandardJavaObjectInspectorFromTypeInfo(columnTypes.get(i)));\n    }\n\n    // this is the object inspector hive will use on the result of deserialize\n    this.inspector = ObjectInspectorFactory.getStandardStructObjectInspector(columnNames, columnOIs);\n\n    String streamName = properties.getProperty(Constants.Explore.STREAM_NAME);\n    try {\n      // Get the stream format from the stream config.\n      ContextManager.Context context = ContextManager.getContext(conf);\n      // get the stream admin from the context, which will let us get stream information such as the path\n      StreamAdmin streamAdmin = context.getStreamAdmin();\n      StreamConfig streamConfig = streamAdmin.getConfig(streamName);\n      FormatSpecification formatSpec = streamConfig.getFormat();\n      this.streamFormat = (ByteBufferRecordFormat) Class.forName(formatSpec.getFormatClass()).newInstance();\n      this.streamFormat.initialize(formatSpec);\n    } catch (UnsupportedTypeException e) {\n      // this should have been validated up front when schema was set on the stream.\n      // if we hit this something went wrong much earlier.\n      LOG.error(\"Schema unsupported by format.\", e);\n      throw new SerDeException(\"Schema unsupported by format.\", e);\n    } catch (IOException e) {\n      LOG.error(\"Could not get the config for stream {}.\", streamName, e);\n      throw new SerDeException(\"Could not get the config for stream \" + streamName, e);\n    } catch (Exception e) {\n      LOG.error(\"Could not create the format for stream {}.\", streamName, e);\n      throw new SerDeException(\"Could not create the format for stream \" + streamName, e);\n    }\n  }","id":73786,"modified_method":"@Override\n  public void initialize(Configuration conf, Properties properties) throws SerDeException {\n    // The columns property comes from the Hive metastore, which has it from the create table statement\n    // It is then important that this schema be accurate and in the right order - the same order as\n    // object inspectors will reflect them.\n    columnNames = Lists.newArrayList(properties.getProperty(serdeConstants.LIST_COLUMNS).split(\",\"));\n    columnTypes = TypeInfoUtils.getTypeInfosFromTypeString(properties.getProperty(serdeConstants.LIST_COLUMN_TYPES));\n    // timestamp and headers are guaranteed to be the first columns in a stream table.\n    // the rest of the columns are for the stream body.\n    bodyColumnNames = columnNames.subList(BODY_OFFSET, columnNames.size());\n    bodyColumnTypes = columnTypes.subList(BODY_OFFSET, columnTypes.size());\n\n    int numCols = columnNames.size();\n\n    final List<ObjectInspector> columnOIs = new ArrayList<ObjectInspector>(numCols);\n\n    for (int i = 0; i < numCols; i++) {\n      columnOIs.add(TypeInfoUtils.getStandardJavaObjectInspectorFromTypeInfo(columnTypes.get(i)));\n    }\n\n    // this is the object inspector hive will use on the result of deserialize\n    this.inspector = ObjectInspectorFactory.getStandardStructObjectInspector(columnNames, columnOIs);\n\n    String streamName = properties.getProperty(Constants.Explore.STREAM_NAME);\n    try {\n      // Get the stream format from the stream config.\n      ContextManager.Context context = ContextManager.getContext(conf);\n      // get the stream admin from the context, which will let us get stream information such as the path\n      StreamAdmin streamAdmin = context.getStreamAdmin();\n      StreamConfig streamConfig = streamAdmin.getConfig(streamName);\n      FormatSpecification formatSpec = streamConfig.getFormat();\n      this.streamFormat = (ByteBufferRecordFormat) RecordFormats.create(formatSpec.getName());\n      this.streamFormat.initialize(formatSpec);\n    } catch (UnsupportedTypeException e) {\n      // this should have been validated up front when schema was set on the stream.\n      // if we hit this something went wrong much earlier.\n      LOG.error(\"Schema unsupported by format.\", e);\n      throw new SerDeException(\"Schema unsupported by format.\", e);\n    } catch (IOException e) {\n      LOG.error(\"Could not get the config for stream {}.\", streamName, e);\n      throw new SerDeException(\"Could not get the config for stream \" + streamName, e);\n    } catch (Exception e) {\n      LOG.error(\"Could not create the format for stream {}.\", streamName, e);\n      throw new SerDeException(\"Could not create the format for stream \" + streamName, e);\n    }\n  }","commit_id":"7131ea65fa5286892cff05e920cff275f69b8f70","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Initialize the swing components.\n     */\n    private void initComponents()\n    {\n        shortcutsTable.setRowHeight(22);\n        shortcutsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        shortcutsTable.setShowHorizontalLines(false);\n        shortcutsTable.setShowVerticalLines(false);\n        shortcutsTable.setModel(tableModel);\n        shortcutsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);\n        shortcutsTable.addMouseListener(new MouseAdapter()\n        {\n            @Override\n            public void mouseClicked(MouseEvent e)\n            {\n                if(e.getClickCount() >= 1)\n                {\n                    int row = GlobalShortcutConfigForm.this.shortcutsTable.\n                        getSelectedRow();\n                    int column = GlobalShortcutConfigForm.this.shortcutsTable.\n                        getSelectedColumn();\n\n                    if(currentRow != -1  && currentColumn != -1)\n                        return;\n\n                    if(row >= 0 && column >= 1)\n                    {\n                        currentRow = row;\n                        currentColumn = column;\n\n                        if(column == 1)\n                            GlobalShortcutConfigForm.this.tableModel.getEntryAt(\n                                row).setEditShortcut1(true);\n                        else if(column == 2)\n                            GlobalShortcutConfigForm.this.tableModel.getEntryAt(\n                                row).setEditShortcut2(true);\n                        else\n                            return;\n\n                        KeybindingChooserActivator.getGlobalShortcutService().\n                            setEnable(false);\n                        refresh();\n                        shortcutsTable.setRowSelectionInterval(row, row);\n                    }\n                }\n            }\n        });\n\n        shortcutsTable.addKeyListener(new KeyAdapter()\n        {\n            private KeyEvent buffer = null;\n\n            @Override\n            public void keyPressed(KeyEvent event)\n            {\n                if(currentRow == -1 || currentColumn == -1)\n                    return;\n\n                // delete shortcut\n                if(event.getKeyCode() == KeyEvent.VK_BACK_SPACE)\n                {\n                    GlobalShortcutEntry en =\n                        GlobalShortcutConfigForm.this.tableModel.getEntryAt(\n                            currentRow);\n                   List<AWTKeyStroke> kss = new ArrayList<AWTKeyStroke>();\n                   if(currentColumn == 1)\n                   {\n                       kss.add(null);\n                       kss.add(en.getShortcut2());\n                   }\n                   else if(currentColumn == 2)\n                   {\n                       kss.add(en.getShortcut());\n                       kss.add(null);\n                   }\n\n                   currentRow = -1;\n                   currentColumn = -1;\n                   en.setShortcuts(kss);\n                   en.setEditShortcut1(false);\n                   en.setEditShortcut2(false);\n                   GlobalShortcutConfigForm.this.saveConfig();\n                   GlobalShortcutConfigForm.this.refresh();\n                }\n                else\n                {\n                    // Reports KEY_PRESSED events on release to support\n                    // modifiers\n                    this.buffer = event;\n                }\n            }\n\n            @Override\n            public void keyReleased(KeyEvent event)\n            {\n                if (buffer != null)\n                {\n                    AWTKeyStroke input = KeyStroke.getKeyStrokeForEvent(buffer);\n                    buffer = null;\n\n                    if(currentRow != -1)\n                    {\n                        GlobalShortcutEntry en =\n                            GlobalShortcutConfigForm.this.tableModel.getEntryAt(\n                                currentRow);\n                        List<AWTKeyStroke> kss = new ArrayList<AWTKeyStroke>();\n\n                        if(currentColumn == 1) // shortcut 1\n                        {\n                            kss.add(input);\n                            kss.add(en.getShortcut2());\n                        }\n                        else if(currentColumn == 2) // shortcut 2\n                        {\n                            kss.add(en.getShortcut());\n                            kss.add(input);\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                        en.setShortcuts(kss);\n                        en.setEditShortcut1(false);\n                        en.setEditShortcut2(false);\n\n                        kss = new ArrayList<AWTKeyStroke>();\n                        List<GlobalShortcutEntry> lst = tableModel.getEntries();\n\n                        for(GlobalShortcutEntry e : lst)\n                        {\n                            boolean isEntry = (e == en);\n                            AWTKeyStroke s1 = isEntry &&\n                                currentColumn == 1 ? null : e.getShortcut();\n                            AWTKeyStroke s2 = isEntry &&\n                                currentColumn == 2 ? null : e.getShortcut2();\n\n                            if(s1 != null &&\n                                s1.getKeyCode() == input.getKeyCode() &&\n                                s1.getModifiers() == input.getModifiers())\n                            {\n                                kss.add(null);\n                                kss.add(e.getShortcut2());\n                                e.setShortcuts(kss);\n                                break;\n                            }\n                            else if(s2 != null &&\n                                s2.getKeyCode() == input.getKeyCode() &&\n                                s2.getModifiers() == input.getModifiers())\n                            {\n                                kss.add(e.getShortcut());\n                                kss.add(null);\n                                e.setShortcuts(kss);\n                                break;\n                            }\n                        }\n\n                        currentRow = -1;\n                        currentColumn = -1;\n                        GlobalShortcutConfigForm.this.saveConfig();\n                        GlobalShortcutConfigForm.this.refresh();\n                    }\n                }\n            }\n        });\n\n        scrollPane.getViewport().add(this.shortcutsTable);\n        mainPanel.add(this.scrollPane,  BorderLayout.CENTER);\n        mainPanel.setPreferredSize(new Dimension(500, 400));\n        shortcutsTable.getSelectionModel().addListSelectionListener(this);\n        loadConfig();\n    }","id":73787,"modified_method":"/**\n     * Initialize the swing components.\n     */\n    private void initComponents()\n    {\n        shortcutsTable.setRowHeight(22);\n        shortcutsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        shortcutsTable.setShowHorizontalLines(false);\n        shortcutsTable.setShowVerticalLines(false);\n        shortcutsTable.setModel(tableModel);\n        shortcutsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);\n        shortcutsTable.addMouseListener(new MouseAdapter()\n        {\n            @Override\n            public void mouseClicked(MouseEvent e)\n            {\n                if(e.getClickCount() >= 2)\n                {\n                    int row = GlobalShortcutConfigForm.this.shortcutsTable.\n                        getSelectedRow();\n                    GlobalShortcutEntry en =\n                        GlobalShortcutConfigForm.this.tableModel.\n                            getEntryAt(row);\n                    List<AWTKeyStroke> kss = new ArrayList<AWTKeyStroke>();\n\n                    GlobalShortcutDialog dialog =\n                        new GlobalShortcutDialog((Dialog)\n                            GlobalShortcutConfigForm.this.getTopLevelAncestor(),\n                            en);\n\n                    kss.add(en.getShortcut());\n                    kss.add(en.getShortcut2());\n\n                    KeybindingChooserActivator.getGlobalShortcutService().\n                        setEnable(false);\n                    int ret = dialog.showDialog();\n\n                    if(ret == 1)\n                    {\n                        // ok button clicked\n                        kss = new ArrayList<AWTKeyStroke>();\n                        List<GlobalShortcutEntry> lst =\n                            tableModel.getEntries();\n\n                        for(GlobalShortcutEntry ee : lst)\n                        {\n                            boolean isEntry = (ee == en);\n                            AWTKeyStroke s1 = isEntry ? null :\n                                    ee.getShortcut();\n                            AWTKeyStroke s2 = isEntry ? null :\n                                    ee.getShortcut2();\n\n                            if(s1 != null && en.getShortcut() != null &&\n                                s1.getKeyCode() == en.getShortcut().\n                                    getKeyCode() &&\n                                s1.getModifiers() == en.getShortcut().\n                                    getModifiers())\n                            {\n                                kss.add(null);\n                                kss.add(ee.getShortcut2());\n                                ee.setShortcuts(kss);\n                                break;\n                            }\n                            else if(s2 != null && en.getShortcut2() != null &&\n                                s2.getKeyCode() == en.getShortcut2().\n                                    getKeyCode() &&\n                                s2.getModifiers() == en.getShortcut2().\n                                    getModifiers())\n                            {\n                                kss.add(ee.getShortcut());\n                                kss.add(null);\n                                ee.setShortcuts(kss);\n                                break;\n                            }\n                        }\n\n                        KeybindingChooserActivator.getGlobalShortcutService().\n                        setEnable(true);\n                        GlobalShortcutConfigForm.this.saveConfig();\n                        GlobalShortcutConfigForm.this.refresh();\n                        KeybindingChooserActivator.getGlobalShortcutService().\n                            setEnable(true);\n                    }\n                    else\n                    {\n                        en.setShortcuts(kss);\n                    }\n                }\n            }\n        });\n\n        scrollPane.getViewport().add(this.shortcutsTable);\n        mainPanel.add(this.scrollPane,  BorderLayout.CENTER);\n        mainPanel.setPreferredSize(new Dimension(500, 400));\n        shortcutsTable.getSelectionModel().addListSelectionListener(this);\n        loadConfig();\n    }","commit_id":"957b8633ae93bc0efbb0b8eff1f40db6cb660485","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Set the shortcut keystroke and field.\n     *\n     * @param shortcut <tt>AWTKeyStroke<\/tt>\n     * @return string representation of the keystroke\n     */\n    public static String getShortcutText(AWTKeyStroke shortcut)\n    {\n        if (shortcut == DISABLED)\n        {\n            return \"Disabled\";\n        }\n        else\n        {\n            StringBuffer buffer = new StringBuffer();\n\n            if (shortcut.getKeyEventType() == KeyEvent.KEY_TYPED)\n            {\n                buffer.append(shortcut.getKeyChar());\n            }\n            else\n            {\n                int keycode = shortcut.getKeyCode();\n                int modifiers = shortcut.getModifiers();\n\n                // Indicates modifiers of the keystroke\n                boolean shiftMask = (modifiers & InputEvent.SHIFT_MASK) != 0;\n                boolean ctrlMask = (modifiers & InputEvent.CTRL_MASK) != 0;\n                boolean metaMask = (modifiers & InputEvent.META_MASK) != 0;\n                boolean altMask = (modifiers & InputEvent.ALT_MASK) != 0;\n                if (shiftMask && keycode != KeyEvent.VK_SHIFT)\n                    buffer.append(\"Shift + \");\n                if (ctrlMask && keycode != KeyEvent.VK_CONTROL)\n                    buffer.append(\"Ctrl + \");\n                if (metaMask && keycode != KeyEvent.VK_META)\n                    buffer.append(\"Meta + \");\n                if (altMask && keycode != KeyEvent.VK_ALT)\n                    buffer.append(\"Alt + \");\n\n                buffer.append(KeyEvent.getKeyText(keycode));\n            }\n            return buffer.toString();\n        }\n    }","id":73788,"modified_method":"/**\n     * Set the shortcut keystroke and field.\n     *\n     * @param shortcut <tt>AWTKeyStroke<\/tt>\n     * @return string representation of the keystroke\n     */\n    public static String getShortcutText(AWTKeyStroke shortcut)\n    {\n        if (shortcut == DISABLED)\n        {\n            return \"Disabled\";\n        }\n        else\n        {\n            StringBuffer buffer = new StringBuffer();\n\n            if (shortcut.getKeyEventType() == KeyEvent.KEY_TYPED)\n            {\n                buffer.append(shortcut.getKeyChar());\n            }\n            else\n            {\n                int keycode = shortcut.getKeyCode();\n                int modifiers = shortcut.getModifiers();\n\n                if(modifiers == GlobalShortcutService.SPECIAL_KEY_MODIFIERS)\n                {\n                    return \"Special\";\n                }\n\n                // Indicates modifiers of the keystroke\n                boolean shiftMask = (modifiers & InputEvent.SHIFT_MASK) != 0;\n                boolean ctrlMask = (modifiers & InputEvent.CTRL_MASK) != 0;\n                boolean metaMask = (modifiers & InputEvent.META_MASK) != 0;\n                boolean altMask = (modifiers & InputEvent.ALT_MASK) != 0;\n                if (shiftMask && keycode != KeyEvent.VK_SHIFT)\n                    buffer.append(\"Shift + \");\n                if (ctrlMask && keycode != KeyEvent.VK_CONTROL)\n                    buffer.append(\"Ctrl + \");\n                if (metaMask && keycode != KeyEvent.VK_META)\n                    buffer.append(\"Meta + \");\n                if (altMask && keycode != KeyEvent.VK_ALT)\n                    buffer.append(\"Alt + \");\n\n                buffer.append(KeyEvent.getKeyText(keycode));\n            }\n            return buffer.toString();\n        }\n    }","commit_id":"957b8633ae93bc0efbb0b8eff1f40db6cb660485","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Registers an action to execute when the keystroke is typed.\n     *\n     * @param listener listener to notify when keystroke is typed\n     * @param keyStroke keystroke that will trigger the action\n     * @param add add the listener/keystrokes to map\n     */\n    public void registerShortcut(GlobalShortcutListener listener,\n        AWTKeyStroke keyStroke, boolean add)\n    {\n        synchronized(mapActions)\n        {\n            List<AWTKeyStroke> keystrokes = mapActions.get(listener);\n\n            if(keyStroke == null)\n            {\n                return;\n            }\n\n            if(keystrokes != null)\n            {\n                if(keyboardHook.registerShortcut(keyStroke.getKeyCode(),\n                    getModifiers(keyStroke)))\n                {\n                    if(add)\n                        keystrokes.add(keyStroke);\n                }\n            }\n            else\n            {\n                keystrokes = new ArrayList<AWTKeyStroke>();\n                if(keyboardHook.registerShortcut(keyStroke.getKeyCode(),\n                    getModifiers(keyStroke)))\n                {\n                    if(add)\n                        keystrokes.add(keyStroke);\n                }\n            }\n\n            if(add)\n                mapActions.put(listener, keystrokes);\n        }\n    }","id":73789,"modified_method":"/**\n     * Registers an action to execute when the keystroke is typed.\n     *\n     * @param listener listener to notify when keystroke is typed\n     * @param keyStroke keystroke that will trigger the action\n     * @param add add the listener/keystrokes to map\n     */\n    public void registerShortcut(GlobalShortcutListener listener,\n        AWTKeyStroke keyStroke, boolean add)\n    {\n        synchronized(mapActions)\n        {\n            List<AWTKeyStroke> keystrokes = mapActions.get(listener);\n            boolean ok = false;\n\n            if(keyStroke == null)\n            {\n                return;\n            }\n\n            if(keystrokes != null)\n            {\n                if(keyStroke.getModifiers() != SPECIAL_KEY_MODIFIERS)\n                {\n                    ok = keyboardHook.registerShortcut(keyStroke.getKeyCode(),\n                        getModifiers(keyStroke));\n                }\n                else\n                {\n                    ok = keyboardHook.registerSpecial(keyStroke.getKeyCode());\n                }\n\n                if(ok && add)\n                {\n                    keystrokes.add(keyStroke);\n                }\n            }\n            else\n            {\n                keystrokes = new ArrayList<AWTKeyStroke>();\n\n                if(keyStroke.getModifiers() != SPECIAL_KEY_MODIFIERS)\n                {\n                    ok = keyboardHook.registerShortcut(keyStroke.getKeyCode(),\n                        getModifiers(keyStroke));\n                }\n                else\n                {\n                    ok = keyboardHook.registerSpecial(keyStroke.getKeyCode());\n                }\n\n                if(ok && add)\n                {\n                    keystrokes.add(keyStroke);\n                }\n            }\n\n            if(add)\n                mapActions.put(listener, keystrokes);\n        }\n    }","commit_id":"957b8633ae93bc0efbb0b8eff1f40db6cb660485","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Unregisters an action to execute when the keystroke is typed.\n     *\n     * @param listener listener to remove\n     * @param keyStroke keystroke that will trigger the action\n     * @param remove remove or not entry in the map\n     */\n    public void unregisterShortcut(GlobalShortcutListener listener,\n        AWTKeyStroke keyStroke, boolean remove)\n    {\n        synchronized(mapActions)\n        {\n            List<AWTKeyStroke> keystrokes = mapActions.get(listener);\n\n            if(keystrokes != null && keyStroke != null)\n            {\n                int keycode = keyStroke.getKeyCode();\n                int modifiers = keyStroke.getModifiers();\n                AWTKeyStroke ks = null;\n\n                for(AWTKeyStroke l : keystrokes)\n                {\n                    if(l.getKeyCode() == keycode &&\n                        l.getModifiers() == modifiers)\n                        ks = l;\n                }\n\n                keyboardHook.unregisterShortcut(keyStroke.getKeyCode(),\n                    getModifiers(keyStroke));\n\n                if(remove)\n                {\n                    if(ks != null)\n                    {\n                        keystrokes.remove(ks);\n                    }\n\n                    if(keystrokes.size() == 0)\n                    {\n                        mapActions.remove(listener);\n                    }\n                    else\n                    {\n                        mapActions.put(listener, keystrokes);\n                    }\n                }\n            }\n        }\n    }","id":73790,"modified_method":"/**\n     * Unregisters an action to execute when the keystroke is typed.\n     *\n     * @param listener listener to remove\n     * @param keyStroke keystroke that will trigger the action\n     * @param remove remove or not entry in the map\n     */\n    public void unregisterShortcut(GlobalShortcutListener listener,\n        AWTKeyStroke keyStroke, boolean remove)\n    {\n        synchronized(mapActions)\n        {\n            List<AWTKeyStroke> keystrokes = mapActions.get(listener);\n\n            if(keystrokes != null && keyStroke != null)\n            {\n                int keycode = keyStroke.getKeyCode();\n                int modifiers = keyStroke.getModifiers();\n                AWTKeyStroke ks = null;\n\n                for(AWTKeyStroke l : keystrokes)\n                {\n                    if(l.getKeyCode() == keycode &&\n                        l.getModifiers() == modifiers)\n                        ks = l;\n                }\n\n                if(modifiers != SPECIAL_KEY_MODIFIERS)\n                {\n                    keyboardHook.unregisterShortcut(keyStroke.getKeyCode(),\n                        getModifiers(keyStroke));\n                }\n                else\n                {\n                    keyboardHook.unregisterSpecial(keyStroke.getKeyCode());\n                }\n\n                if(remove)\n                {\n                    if(ks != null)\n                    {\n                        keystrokes.remove(ks);\n                    }\n\n                    if(keystrokes.size() == 0)\n                    {\n                        mapActions.remove(listener);\n                    }\n                    else\n                    {\n                        mapActions.put(listener, keystrokes);\n                    }\n                }\n            }\n        }\n    }","commit_id":"957b8633ae93bc0efbb0b8eff1f40db6cb660485","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Receive a key press event.\n     *\n     * @param keycode keycode received\n     * @param modifiers modifiers received (ALT or CTRL + letter, ...)\n     */\n    public synchronized void receiveKey(int keycode, int modifiers)\n    {\n        synchronized(mapActions)\n        {\n            // compare keycode/modifiers to keystroke\n            for(Map.Entry<GlobalShortcutListener, List<AWTKeyStroke>> entry :\n                mapActions.entrySet())\n            {\n                List<AWTKeyStroke> lst = entry.getValue();\n\n                for(AWTKeyStroke l : lst)\n                {\n                    if(l.getKeyCode() == keycode &&\n                        getModifiers(l) == modifiers)\n                    {\n                        // notify corresponding listeners\n                        GlobalShortcutEvent evt = new GlobalShortcutEvent(l);\n                        entry.getKey().shortcutReceived(evt);\n                        return;\n                    }\n                }\n            }\n        }\n    }","id":73791,"modified_method":"/**\n     * Receive a key press event.\n     *\n     * @param keycode keycode received\n     * @param modifiers modifiers received (ALT or CTRL + letter, ...)\n     */\n    public synchronized void receiveKey(int keycode, int modifiers)\n    {\n        if(keyboardHook.isSpecialKeyDetection())\n        {\n            specialKeyDetected = AWTKeyStroke.getAWTKeyStroke(keycode,\n                modifiers);\n\n            synchronized(specialKeySyncRoot)\n            {\n                specialKeySyncRoot.notify();\n            }\n\n            GlobalShortcutEvent evt = new GlobalShortcutEvent(\n                specialKeyDetected);\n            List<GlobalShortcutListener> copyListeners =\n                new ArrayList<GlobalShortcutListener>(specialKeyNotifiers);\n\n            for(GlobalShortcutListener l : copyListeners)\n            {\n                l.shortcutReceived(evt);\n            }\n\n            // if special key detection is enabled, disable all other shortcuts\n            return;\n        }\n\n        synchronized(mapActions)\n        {\n            // compare keycode/modifiers to keystroke\n            for(Map.Entry<GlobalShortcutListener, List<AWTKeyStroke>> entry :\n                mapActions.entrySet())\n            {\n                List<AWTKeyStroke> lst = entry.getValue();\n\n                for(AWTKeyStroke l : lst)\n                {\n                    if(l.getKeyCode() == keycode &&\n                        (getModifiers(l) == modifiers ||\n                            (modifiers == SPECIAL_KEY_MODIFIERS &&\n                            l.getModifiers() == modifiers)))\n                    {\n                        // notify corresponding listeners\n                        GlobalShortcutEvent evt = new GlobalShortcutEvent(l);\n                        entry.getKey().shortcutReceived(evt);\n                        return;\n                    }\n                }\n            }\n        }\n    }","commit_id":"957b8633ae93bc0efbb0b8eff1f40db6cb660485","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns list of global shortcuts from the configuration file.\n     *\n     * @return list of global shortcuts.\n     */\n    public Map<String, List<AWTKeyStroke>> getGlobalShortcutFromConfiguration()\n    {\n        Map<String, List<AWTKeyStroke>> gBindings = new\n            LinkedHashMap<String, List<AWTKeyStroke>>();\n        ConfigurationService configService =\n            KeybindingsActivator.getConfigService();\n        String shortcut = null;\n        String shortcut2 = null;\n        String propName = null;\n        String propName2 = null;\n        String names[] = new String[]{\"answer\", \"hangup\", \"contactlist\",\n            \"mute\"};\n        Object configured = configService.getProperty(\n            \"net.java.sip.communicator.impl.keybinding.global.configured\");\n\n        if(configured == null)\n        {\n            // default keystrokes\n            for(String name : names)\n            {\n                List<AWTKeyStroke> kss = new ArrayList<AWTKeyStroke>();\n                propName = DEFAULTS_VALUES_PATH + \".\" + name + \".1\";\n\n                shortcut = propName != null ?\n                    KeybindingsActivator.getResourceService().getSettingsString(\n                        propName) : null;\n\n                if(shortcut != null)\n                {\n                    kss.add(AWTKeyStroke.getAWTKeyStroke(shortcut));\n                }\n\n                gBindings.put(name, kss);\n            }\n\n            configService.setProperty(\n                \"net.java.sip.communicator.impl.keybinding.global.configured\",\n                \"true\");\n\n            return gBindings;\n        }\n\n        for(String name : names)\n        {\n            List<AWTKeyStroke> kss = new ArrayList<AWTKeyStroke>();\n\n            propName = CONFIGURATION_PATH + \".\" + name + \".1\";\n            propName2 = CONFIGURATION_PATH + \".\" + name + \".2\";\n\n            shortcut = propName != null ?\n                (String)configService.getProperty(propName) : null;\n            shortcut2 = propName2 != null ?\n                (String)configService.getProperty(propName2) : null;\n            if(shortcut != null)\n            {\n                kss.add(AWTKeyStroke.getAWTKeyStroke(shortcut));\n            }\n            if(shortcut2 != null)\n            {\n                kss.add(AWTKeyStroke.getAWTKeyStroke(shortcut2));\n            }\n            gBindings.put(name, kss);\n        }\n\n        return gBindings;\n    }","id":73792,"modified_method":"/**\n     * Returns list of global shortcuts from the configuration file.\n     *\n     * @return list of global shortcuts.\n     */\n    public Map<String, List<AWTKeyStroke>> getGlobalShortcutFromConfiguration()\n    {\n        Map<String, List<AWTKeyStroke>> gBindings = new\n            LinkedHashMap<String, List<AWTKeyStroke>>();\n        ConfigurationService configService =\n            KeybindingsActivator.getConfigService();\n        String shortcut = null;\n        String shortcut2 = null;\n        String propName = null;\n        String propName2 = null;\n        String names[] = new String[]{\"answer\", \"hangup\", \"contactlist\",\n            \"mute\"};\n        Object configured = configService.getProperty(\n            \"net.java.sip.communicator.impl.keybinding.global.configured\");\n\n        if(configured == null)\n        {\n            // default keystrokes\n            for(String name : names)\n            {\n                List<AWTKeyStroke> kss = new ArrayList<AWTKeyStroke>();\n                propName = DEFAULTS_VALUES_PATH + \".\" + name + \".1\";\n\n                shortcut = propName != null ?\n                    KeybindingsActivator.getResourceService().getSettingsString(\n                        propName) : null;\n\n                if(shortcut != null)\n                {\n                    kss.add(AWTKeyStroke.getAWTKeyStroke(shortcut));\n                }\n\n                gBindings.put(name, kss);\n            }\n\n            configService.setProperty(\n                \"net.java.sip.communicator.impl.keybinding.global.configured\",\n                \"true\");\n\n            return gBindings;\n        }\n\n        for(String name : names)\n        {\n            List<AWTKeyStroke> kss = new ArrayList<AWTKeyStroke>();\n\n            propName = CONFIGURATION_PATH + \".\" + name + \".1\";\n            propName2 = CONFIGURATION_PATH + \".\" + name + \".2\";\n\n            shortcut = propName != null ?\n                (String)configService.getProperty(propName) : null;\n            shortcut2 = propName2 != null ?\n                (String)configService.getProperty(propName2) : null;\n            if(shortcut != null)\n            {\n                kss.add(AWTKeyStroke.getAWTKeyStroke(shortcut));\n            }\n\n            // second shortcut is always \"special\"\n            if(shortcut2 != null)\n            {\n                //16367 is the combination of all possible modifiers\n                //(shift ctrl meta alt altGraph button1 button2 button3 pressed)\n                //it is used to distinguish special key (headset) and others\n                int nb = Integer.parseInt(shortcut2);\n                kss.add(AWTKeyStroke.getAWTKeyStroke(nb, 16367));\n            }\n            gBindings.put(name, kss);\n        }\n\n        return gBindings;\n    }","commit_id":"957b8633ae93bc0efbb0b8eff1f40db6cb660485","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Save the configuration file.\n     */\n    public void saveGlobalShortcutFromConfiguration()\n    {\n        ConfigurationService configService =\n            KeybindingsActivator.getConfigService();\n        String shortcut = null;\n        String shortcut2 = null;\n\n        for(Map.Entry<String, List<AWTKeyStroke>> entry :\n            globalBindings.getBindings().entrySet())\n        {\n            String key = entry.getKey();\n            List<AWTKeyStroke> kss = entry.getValue();\n            String path = CONFIGURATION_PATH;\n\n            path += \".\" + key;\n\n            shortcut = path + \".1\";\n            shortcut2 = path + \".2\";\n\n            configService.setProperty(shortcut, kss.size() > 0 ?\n                kss.get(0) : null);\n            configService.setProperty(shortcut2, kss.size() > 1 ?\n                kss.get(1) : null);\n        }\n    }","id":73793,"modified_method":"/**\n     * Save the configuration file.\n     */\n    public void saveGlobalShortcutFromConfiguration()\n    {\n        ConfigurationService configService =\n            KeybindingsActivator.getConfigService();\n        String shortcut = null;\n        String shortcut2 = null;\n\n        for(Map.Entry<String, List<AWTKeyStroke>> entry :\n            globalBindings.getBindings().entrySet())\n        {\n            String key = entry.getKey();\n            List<AWTKeyStroke> kss = entry.getValue();\n            String path = CONFIGURATION_PATH;\n\n            path += \".\" + key;\n\n            shortcut = path + \".1\";\n            shortcut2 = path + \".2\";\n\n            configService.setProperty(shortcut, kss.size() > 0 ?\n                kss.get(0) : null);\n            // second shortcut is special\n            configService.setProperty(shortcut2,\n                (kss.size() > 1 && kss.get(1) != null) ?\n                    kss.get(1).getKeyCode() : null);\n        }\n    }","commit_id":"957b8633ae93bc0efbb0b8eff1f40db6cb660485","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Native method to register a shortcut.\n     *\n     * @param ptr native pointer\n     * @param keycode keycode of the shortcut\n     * @param modifiers modifiers (CTRL, ALT, ...)\n     */\n    private static native boolean registerShortcut(long ptr, int keycode,\n        int modifiers);","id":73794,"modified_method":"/**\n     * Native method to register a shortcut.\n     *\n     * @param ptr native pointer\n     * @param keycode keycode of the shortcut\n     * @param modifiers modifiers (CTRL, ALT, ...)\n     * @return true if registration is successful, false otherwise\n     */\n    private static native boolean registerShortcut(long ptr, int keycode,\n        int modifiers);","commit_id":"957b8633ae93bc0efbb0b8eff1f40db6cb660485","url":"https://github.com/jitsi/jitsi"},{"original_method":"private void initInputMap()\n    {\n        amap = this.getRootPane().getActionMap();\n\n        amap.put(\"close\", new CloseAction());\n\n        imap = this.getRootPane().getInputMap(\n                JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);\n\n        imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), \"close\");\n\n        // put the defaults for macosx\n        if(OSUtils.IS_MAC)\n        {\n            imap.put(\n                KeyStroke.getKeyStroke(KeyEvent.VK_W, InputEvent.META_DOWN_MASK),\n                \"close\");\n            imap.put(\n                KeyStroke.getKeyStroke(KeyEvent.VK_W, InputEvent.CTRL_DOWN_MASK),\n                \"close\");\n        }\n    }","id":73795,"modified_method":"private void initInputMap()\n    {\n        amap = this.getRootPane().getActionMap();\n\n        amap.put(\"close\", new CloseAction());\n\n        imap = this.getRootPane().getInputMap(\n                JComponent.WHEN_IN_FOCUSED_WINDOW);\n\n        imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), \"close\");\n\n        // put the defaults for macosx\n        if(OSUtils.IS_MAC)\n        {\n            imap.put(\n                KeyStroke.getKeyStroke(KeyEvent.VK_W, InputEvent.META_DOWN_MASK),\n                \"close\");\n            imap.put(\n                KeyStroke.getKeyStroke(KeyEvent.VK_W, InputEvent.CTRL_DOWN_MASK),\n                \"close\");\n        }\n    }","commit_id":"957b8633ae93bc0efbb0b8eff1f40db6cb660485","url":"https://github.com/jitsi/jitsi"},{"original_method":"private void suggestRecentlyAddedTags(JPanel mainPanel, int tagsToShow, final FocusAdapter focus) {\n            if (!(tagsToShow > 0 && !recentTags.isEmpty()))\n                return;\n\n            mainPanel.add(new JLabel(tr(\"Recently added tags\")), GBC.eol());\n\n            int count = 1;\n            // We store the maximum number (9) of recent tags to allow dynamic change of number of tags shown in the preferences.\n            // This implies to iterate in descending order, as the oldest elements will only be removed after we reach the maximum\n            // number and not the number of tags to show.\n            // However, as Set does not allow to iterate in descending order, we need to copy its elements into a List we can access\n            // in reverse order.\n            List<Tag> tags = new LinkedList<>(recentTags.keySet());\n            for (int i = tags.size()-1; i >= 0 && count <= tagsToShow; i--, count++) {\n                final Tag t = tags.get(i);\n                // Create action for reusing the tag, with keyboard shortcut Ctrl+(1-5)\n                String actionShortcutKey = \"properties:recent:\"+count;\n                String actionShortcutShiftKey = \"properties:recent:shift:\"+count;\n                // CHECKSTYLE.OFF: LineLength\n                Shortcut sc = Shortcut.registerShortcut(actionShortcutKey, tr(\"Choose recent tag {0}\", count), KeyEvent.VK_0+count, Shortcut.CTRL);\n                // CHECKSTYLE.ON: LineLength\n                final JosmAction action = new JosmAction(actionShortcutKey, null, tr(\"Use this tag again\"), sc, false) {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        keys.setSelectedItem(t.getKey());\n                        // fix #7951, #8298 - update list of values before setting value (?)\n                        focus.focusGained(null);\n                        values.setSelectedItem(t.getValue());\n                        selectValuesCombobox();\n                    }\n                };\n                Shortcut scShift = Shortcut.registerShortcut(actionShortcutShiftKey, tr(\"Apply recent tag {0}\", count),\n                        KeyEvent.VK_0+count, Shortcut.CTRL_SHIFT);\n                final JosmAction actionShift = new JosmAction(actionShortcutShiftKey, null, tr(\"Use this tag again\"), scShift, false) {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        action.actionPerformed(null);\n                        performTagAdding();\n                        selectKeysComboBox();\n                    }\n                };\n                recentTagsActions.add(action);\n                recentTagsActions.add(actionShift);\n                disableTagIfNeeded(t, action);\n                // Find and display icon\n                ImageIcon icon = MapPaintStyles.getNodeIcon(t, false); // Filters deprecated icon\n                if (icon == null) {\n                    // If no icon found in map style look at presets\n                    Map<String, String> map = new HashMap<>();\n                    map.put(t.getKey(), t.getValue());\n                    for (TaggingPreset tp : TaggingPreset.getMatchingPresets(null, map, false)) {\n                        icon = tp.getIcon();\n                        if (icon != null) {\n                            break;\n                        }\n                    }\n                    // If still nothing display an empty icon\n                    if (icon == null) {\n                        icon = new ImageIcon(new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB));\n                    }\n                }\n                GridBagConstraints gbc = new GridBagConstraints();\n                gbc.ipadx = 5;\n                mainPanel.add(new JLabel(action.isEnabled() ? icon : GuiHelper.getDisabledIcon(icon)), gbc);\n                // Create tag label\n                final String color = action.isEnabled() ? \"\" : \"; color:gray\";\n                final JLabel tagLabel = new JLabel(\"<html>\"\n                        + \"<style>td{\" + color + \"}<\/style>\"\n                        + \"<table><tr>\"\n                        + \"<td>\" + count + \".<\/td>\"\n                        + \"<td style='border:1px solid gray'>\" + XmlWriter.encode(t.toString(), true) + '<' +\n                        \"/td><\/tr><\/table><\/html>\");\n                tagLabel.setFont(tagLabel.getFont().deriveFont(Font.PLAIN));\n                if (action.isEnabled()) {\n                    // Register action\n                    mainPanel.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(sc.getKeyStroke(), actionShortcutKey);\n                    mainPanel.getActionMap().put(actionShortcutKey, action);\n                    mainPanel.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(scShift.getKeyStroke(), actionShortcutShiftKey);\n                    mainPanel.getActionMap().put(actionShortcutShiftKey, actionShift);\n                    // Make the tag label clickable and set tooltip to the action description (this displays also the keyboard shortcut)\n                    tagLabel.setToolTipText((String) action.getValue(Action.SHORT_DESCRIPTION));\n                    tagLabel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n                    tagLabel.addMouseListener(new MouseAdapter() {\n                        @Override\n                        public void mouseClicked(MouseEvent e) {\n                            action.actionPerformed(null);\n                            // add tags and close window on double-click\n                            if (e.getClickCount() > 1) {\n                                buttonAction(0, null); // emulate OK click and close the dialog\n                            }\n                            // add tags on Shift-Click\n                            if (e.isShiftDown()) {\n                                performTagAdding();\n                                selectKeysComboBox();\n                            }\n                        }\n                    });\n                } else {\n                    // Disable tag label\n                    tagLabel.setEnabled(false);\n                    // Explain in the tooltip why\n                    tagLabel.setToolTipText(tr(\"The key ''{0}'' is already used\", t.getKey()));\n                }\n                // Finally add label to the resulting panel\n                JPanel tagPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));\n                tagPanel.add(tagLabel);\n                mainPanel.add(tagPanel, GBC.eol().fill(GBC.HORIZONTAL));\n            }\n        }","id":73796,"modified_method":"private void suggestRecentlyAddedTags(JPanel mainPanel, int tagsToShow, final FocusAdapter focus) {\n            if (!(tagsToShow > 0 && !recentTags.isEmpty()))\n                return;\n\n            mainPanel.add(new JLabel(tr(\"Recently added tags\")), GBC.eol());\n\n            int count = 1;\n            // We store the maximum number (9) of recent tags to allow dynamic change of number of tags shown in the preferences.\n            // This implies to iterate in descending order, as the oldest elements will only be removed after we reach the maximum\n            // number and not the number of tags to show.\n            // However, as Set does not allow to iterate in descending order, we need to copy its elements into a List we can access\n            // in reverse order.\n            List<Tag> tags = new LinkedList<>(recentTags.keySet());\n            for (int i = tags.size()-1; i >= 0 && count <= tagsToShow; i--, count++) {\n                final Tag t = tags.get(i);\n                // Create action for reusing the tag, with keyboard shortcut\n                final String actionShortcutKey = \"properties:recent:\" + count;\n                final String actionShortcutShiftKey = \"properties:recent:shift:\" + count;\n                final Shortcut sc = count > 10 ? null : Shortcut.registerShortcut(\n                        actionShortcutKey, tr(\"Choose recent tag {0}\", count), KeyEvent.VK_0 + count, Shortcut.CTRL);\n                final JosmAction action = new JosmAction(actionShortcutKey, null, tr(\"Use this tag again\"), sc, false) {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        keys.setSelectedItem(t.getKey());\n                        // fix #7951, #8298 - update list of values before setting value (?)\n                        focus.focusGained(null);\n                        values.setSelectedItem(t.getValue());\n                        selectValuesCombobox();\n                    }\n                };\n                final Shortcut scShift = count > 10 ? null : Shortcut.registerShortcut(\n                        actionShortcutShiftKey, tr(\"Apply recent tag {0}\", count), KeyEvent.VK_0 + count, Shortcut.CTRL_SHIFT);\n                final JosmAction actionShift = new JosmAction(actionShortcutShiftKey, null, tr(\"Use this tag again\"), scShift, false) {\n                    @Override\n                    public void actionPerformed(ActionEvent e) {\n                        action.actionPerformed(null);\n                        performTagAdding();\n                        selectKeysComboBox();\n                    }\n                };\n                recentTagsActions.add(action);\n                recentTagsActions.add(actionShift);\n                disableTagIfNeeded(t, action);\n                // Find and display icon\n                ImageIcon icon = MapPaintStyles.getNodeIcon(t, false); // Filters deprecated icon\n                if (icon == null) {\n                    // If no icon found in map style look at presets\n                    Map<String, String> map = new HashMap<>();\n                    map.put(t.getKey(), t.getValue());\n                    for (TaggingPreset tp : TaggingPreset.getMatchingPresets(null, map, false)) {\n                        icon = tp.getIcon();\n                        if (icon != null) {\n                            break;\n                        }\n                    }\n                    // If still nothing display an empty icon\n                    if (icon == null) {\n                        icon = new ImageIcon(new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB));\n                    }\n                }\n                GridBagConstraints gbc = new GridBagConstraints();\n                gbc.ipadx = 5;\n                mainPanel.add(new JLabel(action.isEnabled() ? icon : GuiHelper.getDisabledIcon(icon)), gbc);\n                // Create tag label\n                final String color = action.isEnabled() ? \"\" : \"; color:gray\";\n                final JLabel tagLabel = new JLabel(\"<html>\"\n                        + \"<style>td{\" + color + \"}<\/style>\"\n                        + \"<table><tr>\"\n                        + \"<td>\" + count + \".<\/td>\"\n                        + \"<td style='border:1px solid gray'>\" + XmlWriter.encode(t.toString(), true) + '<' +\n                        \"/td><\/tr><\/table><\/html>\");\n                tagLabel.setFont(tagLabel.getFont().deriveFont(Font.PLAIN));\n                if (action.isEnabled() && sc != null && scShift != null) {\n                    // Register action\n                    mainPanel.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(sc.getKeyStroke(), actionShortcutKey);\n                    mainPanel.getActionMap().put(actionShortcutKey, action);\n                    mainPanel.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(scShift.getKeyStroke(), actionShortcutShiftKey);\n                    mainPanel.getActionMap().put(actionShortcutShiftKey, actionShift);\n                }\n                if (action.isEnabled()) {\n                    // Make the tag label clickable and set tooltip to the action description (this displays also the keyboard shortcut)\n                    tagLabel.setToolTipText((String) action.getValue(Action.SHORT_DESCRIPTION));\n                    tagLabel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n                    tagLabel.addMouseListener(new MouseAdapter() {\n                        @Override\n                        public void mouseClicked(MouseEvent e) {\n                            action.actionPerformed(null);\n                            // add tags and close window on double-click\n                            if (e.getClickCount() > 1) {\n                                buttonAction(0, null); // emulate OK click and close the dialog\n                            }\n                            // add tags on Shift-Click\n                            if (e.isShiftDown()) {\n                                performTagAdding();\n                                selectKeysComboBox();\n                            }\n                        }\n                    });\n                } else {\n                    // Disable tag label\n                    tagLabel.setEnabled(false);\n                    // Explain in the tooltip why\n                    tagLabel.setToolTipText(tr(\"The key ''{0}'' is already used\", t.getKey()));\n                }\n                // Finally add label to the resulting panel\n                JPanel tagPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));\n                tagPanel.add(tagLabel);\n                mainPanel.add(tagPanel, GBC.eol().fill(GBC.HORIZONTAL));\n            }\n        }","commit_id":"581bccfb31f5971751e66e85a7ba8bb6bc3dae24","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Create a new PropertiesDialog\n     */\n    public PropertiesDialog(MapFrame mapFrame) {\n        super(tr(\"Properties/Memberships\"), \"propertiesdialog\", tr(\"Properties for selected objects.\"),\n                Shortcut.registerShortcut(\"subwindow:properties\", tr(\"Toggle: {0}\", tr(\"Properties/Memberships\")), KeyEvent.VK_P,\n                        Shortcut.GROUP_LAYER, Shortcut.SHIFT_DEFAULT), 150, true);\n\n        // setting up the properties table\n        propertyData.setColumnIdentifiers(new String[]{tr(\"Key\"),tr(\"Value\")});\n        propertyTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n        propertyTable.getColumnModel().getColumn(1).setCellRenderer(new DefaultTableCellRenderer(){\n            @Override public Component getTableCellRendererComponent(JTable table, Object value,\n                    boolean isSelected, boolean hasFocus, int row, int column) {\n                Component c = super.getTableCellRendererComponent(table, value, isSelected, false, row, column);\n                if (c instanceof JLabel) {\n                    String str = null;\n                    if (value instanceof String) {\n                        str = (String) value;\n                    } else if (value instanceof Map<?, ?>) {\n                        Map<?, ?> v = (Map<?, ?>) value;\n                        if (v.size() != 1) {\n                            str=tr(\"<different>\");\n                            c.setFont(c.getFont().deriveFont(Font.ITALIC));\n                        } else {\n                            final Map.Entry<?, ?> entry = v.entrySet().iterator().next();\n                            str = (String) entry.getKey();\n                        }\n                    }\n                    ((JLabel)c).setText(str);\n                }\n                return c;\n            }\n        });\n\n        // setting up the membership table\n\n        membershipData.setColumnIdentifiers(new String[]{tr(\"Member Of\"),tr(\"Role\")});\n        membershipTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        membershipTable.addMouseListener(new PopupMenuLauncher() {\n            @Override\n            public void launch(MouseEvent evt) {\n                Point p = evt.getPoint();\n                int row = membershipTable.rowAtPoint(p);\n                if (row > -1) {\n                    JPopupMenu menu = new JPopupMenu();\n                    Relation relation = (Relation)membershipData.getValueAt(row, 0);\n                    menu.add(new SelectRelationAction(relation, true));\n                    menu.add(new SelectRelationAction(relation, false));\n                    menu.show(membershipTable, p.x, p.y-3);\n                }\n            }\n        });\n\n        membershipTable.getColumnModel().getColumn(0).setCellRenderer(new DefaultTableCellRenderer() {\n            @Override public Component getTableCellRendererComponent(JTable table, Object value,\n                    boolean isSelected, boolean hasFocus, int row, int column) {\n                Component c = super.getTableCellRendererComponent(table, value, isSelected, false, row, column);\n                if (c instanceof JLabel) {\n                    JLabel label = (JLabel)c;\n                    Relation r = (Relation)value;\n                    label.setText(r.getDisplayName(DefaultNameFormatter.getInstance()));\n                    if (r.isFiltered()) {\n                        label.setFont(label.getFont().deriveFont(Font.ITALIC));\n                    }\n                }\n                return c;\n            }\n        });\n\n        membershipTable.getColumnModel().getColumn(1).setCellRenderer(new DefaultTableCellRenderer() {\n            @SuppressWarnings(\"unchecked\")\n            @Override public Component getTableCellRendererComponent(JTable table, Object value,\n                    boolean isSelected, boolean hasFocus, int row, int column) {\n                Component c = super.getTableCellRendererComponent(table, value, isSelected, false, row, column);\n                boolean isFiltered = (((Relation)table.getValueAt(row, 0))).isFiltered();\n                if (c instanceof JLabel) {\n                    JLabel label = (JLabel)c;\n                    Collection<RelationMember> col = (Collection<RelationMember>) value;\n\n                    String text = null;\n                    for (RelationMember r : col) {\n                        if (text == null) {\n                            text = r.getRole();\n                        }\n                        else if (!text.equals(r.getRole())) {\n                            text = tr(\"<different>\");\n                            break;\n                        }\n                    }\n\n                    label.setText(text);\n                    if (isFiltered) {\n                        label.setFont(label.getFont().deriveFont(Font.ITALIC));\n                    }\n                }\n                return c;\n            }\n        });\n\n        // combine both tables and wrap them in a scrollPane\n        JPanel bothTables = new JPanel();\n        boolean top = Main.pref.getBoolean(\"properties.presets.top\", true);\n        bothTables.setLayout(new GridBagLayout());\n        if(top) {\n            bothTables.add(presets, GBC.eol().fill(GBC.HORIZONTAL).insets(5, 2, 5, 2));\n        }\n        bothTables.add(selectSth, GBC.eol().fill().insets(10, 10, 10, 10));\n        bothTables.add(propertyTable.getTableHeader(), GBC.eol().fill(GBC.HORIZONTAL));\n        bothTables.add(propertyTable, GBC.eol().fill(GBC.BOTH));\n        bothTables.add(membershipTable.getTableHeader(), GBC.eol().fill(GBC.HORIZONTAL));\n        bothTables.add(membershipTable, GBC.eol().fill(GBC.BOTH));\n        if(!top) {\n            bothTables.add(presets, GBC.eol().fill(GBC.HORIZONTAL).insets(5, 2, 5, 2));\n        }\n\n        DblClickWatch dblClickWatch = new DblClickWatch();\n        propertyTable.addMouseListener(dblClickWatch);\n        membershipTable.addMouseListener(dblClickWatch);\n        JScrollPane scrollPane = new JScrollPane(bothTables);\n        scrollPane.addMouseListener(dblClickWatch);\n        add(scrollPane, BorderLayout.CENTER);\n\n        selectSth.setPreferredSize(scrollPane.getSize());\n        presets.setSize(scrollPane.getSize());\n\n        JPanel buttonPanel = getButtonPanel(3);\n\n        // -- add action and shortcut\n        AddAction addAction = new AddAction();\n        this.btnAdd = new SideButton(addAction);\n        btnAdd.setFocusable(true);\n        buttonPanel.add(this.btnAdd);\n        btnAdd.getInputMap(JComponent.WHEN_FOCUSED).put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), \"onEnter\");\n        btnAdd.getActionMap().put(\"onEnter\", addAction);\n\n        Main.registerActionShortcut(addAction, Shortcut.registerShortcut(\"properties:add\", tr(\"Add Properties\"), KeyEvent.VK_B,\n                Shortcut.GROUP_MNEMONIC));\n\n        // -- edit action\n        //\n        EditAction editAction = new EditAction();\n        propertyTable.getSelectionModel().addListSelectionListener(editAction);\n        membershipTable.getSelectionModel().addListSelectionListener(editAction);\n        this.btnEdit = new SideButton(editAction);\n        buttonPanel.add(this.btnEdit);\n\n        // -- delete action\n        //\n        DeleteAction deleteAction = new DeleteAction();\n        this.btnDel = new SideButton(deleteAction);\n        membershipTable.getSelectionModel().addListSelectionListener(deleteAction);\n        propertyTable.getSelectionModel().addListSelectionListener(deleteAction);\n        getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(\n                KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0),\"delete\"\n        );\n        getActionMap().put(\"delete\", deleteAction);\n        buttonPanel.add(this.btnDel);\n        add(buttonPanel, BorderLayout.SOUTH);\n    }","id":73797,"modified_method":"/**\n     * Create a new PropertiesDialog\n     */\n    public PropertiesDialog(MapFrame mapFrame) {\n        super(tr(\"Properties/Memberships\"), \"propertiesdialog\", tr(\"Properties for selected objects.\"),\n                Shortcut.registerShortcut(\"subwindow:properties\", tr(\"Toggle: {0}\", tr(\"Properties/Memberships\")), KeyEvent.VK_P,\n                        Shortcut.GROUP_LAYER, Shortcut.SHIFT_DEFAULT), 150, true);\n\n        // setting up the properties table\n        propertyData.setColumnIdentifiers(new String[]{tr(\"Key\"),tr(\"Value\")});\n        propertyTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n        propertyTable.getColumnModel().getColumn(1).setCellRenderer(new DefaultTableCellRenderer(){\n            @Override public Component getTableCellRendererComponent(JTable table, Object value,\n                    boolean isSelected, boolean hasFocus, int row, int column) {\n                Component c = super.getTableCellRendererComponent(table, value, isSelected, false, row, column);\n                if (c instanceof JLabel) {\n                    String str = null;\n                    if (value instanceof String) {\n                        str = (String) value;\n                    } else if (value instanceof Map<?, ?>) {\n                        Map<?, ?> v = (Map<?, ?>) value;\n                        if (v.size() != 1) {\n                            str=tr(\"<different>\");\n                            c.setFont(c.getFont().deriveFont(Font.ITALIC));\n                        } else {\n                            final Map.Entry<?, ?> entry = v.entrySet().iterator().next();\n                            str = (String) entry.getKey();\n                        }\n                    }\n                    ((JLabel)c).setText(str);\n                }\n                return c;\n            }\n        });\n\n        // setting up the membership table\n\n        membershipData.setColumnIdentifiers(new String[]{tr(\"Member Of\"),tr(\"Role\"),tr(\"Position\")});\n        membershipTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        membershipTable.addMouseListener(new PopupMenuLauncher() {\n            @Override\n            public void launch(MouseEvent evt) {\n                Point p = evt.getPoint();\n                int row = membershipTable.rowAtPoint(p);\n                if (row > -1) {\n                    JPopupMenu menu = new JPopupMenu();\n                    Relation relation = (Relation)membershipData.getValueAt(row, 0);\n                    menu.add(new SelectRelationAction(relation, true));\n                    menu.add(new SelectRelationAction(relation, false));\n                    menu.show(membershipTable, p.x, p.y-3);\n                }\n            }\n        });\n\n        TableColumnModel mod = membershipTable.getColumnModel();\n        mod.getColumn(0).setCellRenderer(new DefaultTableCellRenderer() {\n            @Override public Component getTableCellRendererComponent(JTable table, Object value,\n                    boolean isSelected, boolean hasFocus, int row, int column) {\n                Component c = super.getTableCellRendererComponent(table, value, isSelected, false, row, column);\n                if (c instanceof JLabel) {\n                    JLabel label = (JLabel)c;\n                    Relation r = (Relation)value;\n                    label.setText(r.getDisplayName(DefaultNameFormatter.getInstance()));\n                    if (r.isFiltered()) {\n                        label.setFont(label.getFont().deriveFont(Font.ITALIC));\n                    }\n                }\n                return c;\n            }\n        });\n\n        mod.getColumn(1).setCellRenderer(new DefaultTableCellRenderer() {\n            @SuppressWarnings(\"unchecked\")\n            @Override public Component getTableCellRendererComponent(JTable table, Object value,\n                    boolean isSelected, boolean hasFocus, int row, int column) {\n                Component c = super.getTableCellRendererComponent(table, value, isSelected, false, row, column);\n                boolean isFiltered = (((Relation)table.getValueAt(row, 0))).isFiltered();\n                if (c instanceof JLabel) {\n                    JLabel label = (JLabel)c;\n                    MemberInfo col = (MemberInfo) value;\n\n                    String text = null;\n                    for (RelationMember r : col.role) {\n                        if (text == null) {\n                            text = r.getRole();\n                        }\n                        else if (!text.equals(r.getRole())) {\n                            text = tr(\"<different>\");\n                            break;\n                        }\n                    }\n\n                    label.setText(text);\n                    if (isFiltered) {\n                        label.setFont(label.getFont().deriveFont(Font.ITALIC));\n                    }\n                }\n                return c;\n            }\n        });\n\n        mod.getColumn(2).setCellRenderer(new DefaultTableCellRenderer() {\n            @SuppressWarnings(\"unchecked\")\n            @Override public Component getTableCellRendererComponent(JTable table, Object value,\n                    boolean isSelected, boolean hasFocus, int row, int column) {\n                Component c = super.getTableCellRendererComponent(table, value, isSelected, false, row, column);\n                boolean isFiltered = (((Relation)table.getValueAt(row, 0))).isFiltered();\n                if (c instanceof JLabel) {\n                    JLabel label = (JLabel)c;\n                    MemberInfo col = (MemberInfo) table.getValueAt(row, 1);\n\n                    String text = \"\";\n                    for (Integer p : col.position) {\n                        if (text.length() != 0)\n                            text += \",\";\n                        text += String.valueOf(p);\n                    }\n\n                    label.setText(text);\n                    if (isFiltered) {\n                        label.setFont(label.getFont().deriveFont(Font.ITALIC));\n                    }\n                }\n                return c;\n            }\n        });\n        mod.getColumn(2).setPreferredWidth(20);\n        mod.getColumn(1).setPreferredWidth(40);\n        mod.getColumn(0).setPreferredWidth(200);\n\n        // combine both tables and wrap them in a scrollPane\n        JPanel bothTables = new JPanel();\n        boolean top = Main.pref.getBoolean(\"properties.presets.top\", true);\n        bothTables.setLayout(new GridBagLayout());\n        if(top) {\n            bothTables.add(presets, GBC.eol().fill(GBC.HORIZONTAL).insets(5, 2, 5, 2));\n        }\n        bothTables.add(selectSth, GBC.eol().fill().insets(10, 10, 10, 10));\n        bothTables.add(propertyTable.getTableHeader(), GBC.eol().fill(GBC.HORIZONTAL));\n        bothTables.add(propertyTable, GBC.eol().fill(GBC.BOTH));\n        bothTables.add(membershipTable.getTableHeader(), GBC.eol().fill(GBC.HORIZONTAL));\n        bothTables.add(membershipTable, GBC.eol().fill(GBC.BOTH));\n        if(!top) {\n            bothTables.add(presets, GBC.eol().fill(GBC.HORIZONTAL).insets(5, 2, 5, 2));\n        }\n\n        DblClickWatch dblClickWatch = new DblClickWatch();\n        propertyTable.addMouseListener(dblClickWatch);\n        membershipTable.addMouseListener(dblClickWatch);\n        JScrollPane scrollPane = new JScrollPane(bothTables);\n        scrollPane.addMouseListener(dblClickWatch);\n        add(scrollPane, BorderLayout.CENTER);\n\n        selectSth.setPreferredSize(scrollPane.getSize());\n        presets.setSize(scrollPane.getSize());\n\n        JPanel buttonPanel = getButtonPanel(3);\n\n        // -- add action and shortcut\n        AddAction addAction = new AddAction();\n        this.btnAdd = new SideButton(addAction);\n        btnAdd.setFocusable(true);\n        buttonPanel.add(this.btnAdd);\n        btnAdd.getInputMap(JComponent.WHEN_FOCUSED).put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), \"onEnter\");\n        btnAdd.getActionMap().put(\"onEnter\", addAction);\n\n        Main.registerActionShortcut(addAction, Shortcut.registerShortcut(\"properties:add\", tr(\"Add Properties\"), KeyEvent.VK_B,\n                Shortcut.GROUP_MNEMONIC));\n\n        // -- edit action\n        //\n        EditAction editAction = new EditAction();\n        propertyTable.getSelectionModel().addListSelectionListener(editAction);\n        membershipTable.getSelectionModel().addListSelectionListener(editAction);\n        this.btnEdit = new SideButton(editAction);\n        buttonPanel.add(this.btnEdit);\n\n        // -- delete action\n        //\n        DeleteAction deleteAction = new DeleteAction();\n        this.btnDel = new SideButton(deleteAction);\n        membershipTable.getSelectionModel().addListSelectionListener(deleteAction);\n        propertyTable.getSelectionModel().addListSelectionListener(deleteAction);\n        getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(\n                KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0),\"delete\"\n        );\n        getActionMap().put(\"delete\", deleteAction);\n        buttonPanel.add(this.btnDel);\n        add(buttonPanel, BorderLayout.SOUTH);\n    }","commit_id":"a7d6478ef54eed157ecdd7401540717e9a464a8e","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void selectionChanged(Collection<? extends OsmPrimitive> newSelection) {\n        if (!isVisible())\n            return;\n        if (propertyTable == null)\n            return; // selection changed may be received in base class constructor before init\n        if (propertyTable.getCellEditor() != null) {\n            propertyTable.getCellEditor().cancelCellEditing();\n        }\n\n        String selectedTag = null;\n        Relation selectedRelation = null;\n        if (propertyTable.getSelectedRowCount() == 1) {\n            selectedTag = (String)propertyData.getValueAt(propertyTable.getSelectedRow(), 0);\n        }\n        if (membershipTable.getSelectedRowCount() == 1) {\n            selectedRelation = (Relation)membershipData.getValueAt(membershipTable.getSelectedRow(), 0);\n        }\n\n        // re-load property data\n        propertyData.setRowCount(0);\n        int nodes = 0;\n        int ways = 0;\n        int relations = 0;\n        int closedways = 0;\n\n        Map<String, Integer> keyCount = new HashMap<String, Integer>();\n        valueCount.clear();\n        for (OsmPrimitive osm : newSelection) {\n            if(osm instanceof Node) {\n                ++nodes;\n            } else if(osm instanceof Relation) {\n                ++relations;\n            } else if(((Way)osm).isClosed()) {\n                ++closedways;\n            } else {\n                ++ways;\n            }\n            for (String key: osm.keySet()) {\n                String value = osm.get(key);\n                keyCount.put(key, keyCount.containsKey(key) ? keyCount.get(key) + 1 : 1);\n                if (valueCount.containsKey(key)) {\n                    Map<String, Integer> v = valueCount.get(key);\n                    v.put(value, v.containsKey(value)? v.get(value) + 1 : 1 );\n                } else {\n                    TreeMap<String,Integer> v = new TreeMap<String, Integer>();\n                    v.put(value, 1);\n                    valueCount.put(key, v);\n                }\n            }\n        }\n        for (Entry<String, Map<String, Integer>> e : valueCount.entrySet()) {\n            int count=0;\n            for (Entry<String, Integer> e1: e.getValue().entrySet()) {\n                count+=e1.getValue();\n            }\n            if (count < newSelection.size()) {\n                e.getValue().put(\"\", newSelection.size()-count);\n            }\n            propertyData.addRow(new Object[]{e.getKey(), e.getValue()});\n        }\n\n        // re-load membership data\n        // this is rather expensive since we have to walk through all members of all existing relationships.\n        // could use back references here for speed if necessary.\n\n        membershipData.setRowCount(0);\n\n        Map<Relation, Collection<RelationMember>> roles = new HashMap<Relation, Collection<RelationMember>>();\n        for (OsmPrimitive primitive: newSelection) {\n            for (OsmPrimitive ref: primitive.getReferrers()) {\n                if (ref instanceof Relation && !ref.isIncomplete() && !ref.isDeleted()) {\n                    Relation r = (Relation) ref;\n                    Collection<RelationMember> members = new ArrayList<RelationMember>();\n                    roles.put(r, members);\n                    for (RelationMember m : r.getMembers()) {\n                        if (m.getMember() == primitive) {\n                            members.add(m);\n                        }\n                    }\n                }\n            }\n        }\n\n        List<Relation> sortedRelations = new ArrayList<Relation>(roles.keySet());\n        Collections.sort(sortedRelations, new Comparator<Relation>() {\n            public int compare(Relation o1, Relation o2) {\n                int comp = Boolean.valueOf(o1.isFiltered()).compareTo(o2.isFiltered());\n                if (comp == 0) {\n                    comp = o1.getDisplayName(DefaultNameFormatter.getInstance()).compareTo(o2.getDisplayName(DefaultNameFormatter.getInstance()));\n                }\n                return comp;\n            }}\n        );\n\n        for (Relation r: sortedRelations) {\n            membershipData.addRow(new Object[]{r, roles.get(r)});\n        }\n\n        checkPresets(nodes, ways, relations, closedways);\n\n        membershipTable.getTableHeader().setVisible(membershipData.getRowCount() > 0);\n        membershipTable.setVisible(membershipData.getRowCount() > 0);\n\n        boolean hasSelection = !newSelection.isEmpty();\n        boolean hasTags = hasSelection && propertyData.getRowCount() > 0;\n        boolean hasMemberships = hasSelection && membershipData.getRowCount() > 0;\n        btnAdd.setEnabled(hasSelection);\n        btnEdit.setEnabled(hasTags || hasMemberships);\n        btnDel.setEnabled(hasTags || hasMemberships);\n        propertyTable.setVisible(hasTags);\n        propertyTable.getTableHeader().setVisible(hasTags);\n        selectSth.setVisible(!hasSelection);\n\n        int selectedIndex;\n        if (selectedTag != null && (selectedIndex = findRow(propertyData, selectedTag)) != -1) {\n            propertyTable.changeSelection(selectedIndex, 0, false, false);\n        } else if (selectedRelation != null && (selectedIndex = findRow(membershipData, selectedRelation)) != -1) {\n            membershipTable.changeSelection(selectedIndex, 0, false, false);\n        } else if(hasTags) {\n            propertyTable.changeSelection(0, 0, false, false);\n        } else if(hasMemberships) {\n            membershipTable.changeSelection(0, 0, false, false);\n        }\n\n        if(propertyData.getRowCount() != 0 || membershipData.getRowCount() != 0) {\n            setTitle(tr(\"Properties: {0} / Memberships: {1}\",\n                    propertyData.getRowCount(), membershipData.getRowCount()));\n        } else {\n            setTitle(tr(\"Properties / Memberships\"));\n        }\n    }","id":73798,"modified_method":"public void selectionChanged(Collection<? extends OsmPrimitive> newSelection) {\n        if (!isVisible())\n            return;\n        if (propertyTable == null)\n            return; // selection changed may be received in base class constructor before init\n        if (propertyTable.getCellEditor() != null) {\n            propertyTable.getCellEditor().cancelCellEditing();\n        }\n\n        String selectedTag = null;\n        Relation selectedRelation = null;\n        if (propertyTable.getSelectedRowCount() == 1) {\n            selectedTag = (String)propertyData.getValueAt(propertyTable.getSelectedRow(), 0);\n        }\n        if (membershipTable.getSelectedRowCount() == 1) {\n            selectedRelation = (Relation)membershipData.getValueAt(membershipTable.getSelectedRow(), 0);\n        }\n\n        // re-load property data\n        propertyData.setRowCount(0);\n        int nodes = 0;\n        int ways = 0;\n        int relations = 0;\n        int closedways = 0;\n\n        Map<String, Integer> keyCount = new HashMap<String, Integer>();\n        valueCount.clear();\n        for (OsmPrimitive osm : newSelection) {\n            if(osm instanceof Node) {\n                ++nodes;\n            } else if(osm instanceof Relation) {\n                ++relations;\n            } else if(((Way)osm).isClosed()) {\n                ++closedways;\n            } else {\n                ++ways;\n            }\n            for (String key: osm.keySet()) {\n                String value = osm.get(key);\n                keyCount.put(key, keyCount.containsKey(key) ? keyCount.get(key) + 1 : 1);\n                if (valueCount.containsKey(key)) {\n                    Map<String, Integer> v = valueCount.get(key);\n                    v.put(value, v.containsKey(value)? v.get(value) + 1 : 1 );\n                } else {\n                    TreeMap<String,Integer> v = new TreeMap<String, Integer>();\n                    v.put(value, 1);\n                    valueCount.put(key, v);\n                }\n            }\n        }\n        for (Entry<String, Map<String, Integer>> e : valueCount.entrySet()) {\n            int count=0;\n            for (Entry<String, Integer> e1: e.getValue().entrySet()) {\n                count+=e1.getValue();\n            }\n            if (count < newSelection.size()) {\n                e.getValue().put(\"\", newSelection.size()-count);\n            }\n            propertyData.addRow(new Object[]{e.getKey(), e.getValue()});\n        }\n\n        // re-load membership data\n        // this is rather expensive since we have to walk through all members of all existing relationships.\n        // could use back references here for speed if necessary.\n\n        membershipData.setRowCount(0);\n\n        Map<Relation, MemberInfo> roles = new HashMap<Relation, MemberInfo>();\n        for (OsmPrimitive primitive: newSelection) {\n            for (OsmPrimitive ref: primitive.getReferrers()) {\n                if (ref instanceof Relation && !ref.isIncomplete() && !ref.isDeleted()) {\n                    Relation r = (Relation) ref;\n                    MemberInfo mi = mi = new MemberInfo();\n                    roles.put(r, mi);\n                    int i = 1;\n                    for (RelationMember m : r.getMembers()) {\n                        if (m.getMember() == primitive) {\n                            mi.add(m, i);\n                        }\n                        ++i;\n                    }\n                }\n            }\n        }\n\n        List<Relation> sortedRelations = new ArrayList<Relation>(roles.keySet());\n        Collections.sort(sortedRelations, new Comparator<Relation>() {\n            public int compare(Relation o1, Relation o2) {\n                int comp = Boolean.valueOf(o1.isFiltered()).compareTo(o2.isFiltered());\n                if (comp == 0) {\n                    comp = o1.getDisplayName(DefaultNameFormatter.getInstance()).compareTo(o2.getDisplayName(DefaultNameFormatter.getInstance()));\n                }\n                return comp;\n            }}\n        );\n\n        for (Relation r: sortedRelations) {\n            membershipData.addRow(new Object[]{r, roles.get(r)});\n        }\n\n        checkPresets(nodes, ways, relations, closedways);\n\n        membershipTable.getTableHeader().setVisible(membershipData.getRowCount() > 0);\n        membershipTable.setVisible(membershipData.getRowCount() > 0);\n\n        boolean hasSelection = !newSelection.isEmpty();\n        boolean hasTags = hasSelection && propertyData.getRowCount() > 0;\n        boolean hasMemberships = hasSelection && membershipData.getRowCount() > 0;\n        btnAdd.setEnabled(hasSelection);\n        btnEdit.setEnabled(hasTags || hasMemberships);\n        btnDel.setEnabled(hasTags || hasMemberships);\n        propertyTable.setVisible(hasTags);\n        propertyTable.getTableHeader().setVisible(hasTags);\n        selectSth.setVisible(!hasSelection);\n\n        int selectedIndex;\n        if (selectedTag != null && (selectedIndex = findRow(propertyData, selectedTag)) != -1) {\n            propertyTable.changeSelection(selectedIndex, 0, false, false);\n        } else if (selectedRelation != null && (selectedIndex = findRow(membershipData, selectedRelation)) != -1) {\n            membershipTable.changeSelection(selectedIndex, 0, false, false);\n        } else if(hasTags) {\n            propertyTable.changeSelection(0, 0, false, false);\n        } else if(hasMemberships) {\n            membershipTable.changeSelection(0, 0, false, false);\n        }\n\n        if(propertyData.getRowCount() != 0 || membershipData.getRowCount() != 0) {\n            setTitle(tr(\"Properties: {0} / Memberships: {1}\",\n                    propertyData.getRowCount(), membershipData.getRowCount()));\n        } else {\n            setTitle(tr(\"Properties / Memberships\"));\n        }\n    }","commit_id":"a7d6478ef54eed157ecdd7401540717e9a464a8e","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * This simply fires up an relation editor for the relation shown; everything else\n     * is the editor's business.\n     *\n     * @param row\n     */\n    @SuppressWarnings(\"unchecked\")\n    void membershipEdit(int row) {\n        Relation relation = (Relation)membershipData.getValueAt(row, 0);\n        Main.map.relationListDialog.selectRelation(relation);\n        RelationEditor.getEditor(\n                Main.map.mapView.getEditLayer(),\n                relation,\n                (Collection<RelationMember>) membershipData.getValueAt(row, 1) ).setVisible(true);\n    }","id":73799,"modified_method":"/**\n     * This simply fires up an relation editor for the relation shown; everything else\n     * is the editor's business.\n     *\n     * @param row\n     */\n    @SuppressWarnings(\"unchecked\")\n    void membershipEdit(int row) {\n        Relation relation = (Relation)membershipData.getValueAt(row, 0);\n        Main.map.relationListDialog.selectRelation(relation);\n        RelationEditor.getEditor(\n                Main.map.mapView.getEditLayer(),\n                relation,\n                ((MemberInfo) membershipData.getValueAt(row, 1)).role).setVisible(true);\n    }","commit_id":"a7d6478ef54eed157ecdd7401540717e9a464a8e","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n   * @param bundle resource bundle to be shown.\n   * @param bundleName name of the resource bundle to be shown. We need this\n   * name to create StringDescriptor in {@link #getDescriptor()} method.\n   * @param keyToPreselect describes row that should be selected in the\n   * @param parent the parent component for the dialog.\n   */\n  public KeyChooserDialog(\n    final Component parent,\n    @NotNull final PropertiesFile bundle,\n    @NotNull final String bundleName,\n    final String keyToPreselect,\n    final GuiEditor editor\n  ) {\n    super(parent, true);\n    myEditor = editor;\n    myBundle = bundle;\n\n    myBundleName = bundleName;\n\n    setTitle(UIDesignerBundle.message(\"title.chooser.value\"));\n\n    // Read key/value pairs from resource bundle\n    fillPropertyList();\n\n    // Create UI\n    myModel = new MyTableModel();\n    myTable = new JBTable(myModel);\n    myTable.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    new MySpeedSearch(myTable);\n    myCenterPanel = ScrollPaneFactory.createScrollPane(myTable);\n\n    myTable.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0), OK_ACTION);\n    myTable.getActionMap().put(OK_ACTION, new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        getOKAction().actionPerformed(e);\n      }\n    });\n\n    // Calculate width for \"Key\" columns\n    final FontMetrics metrics = myTable.getFontMetrics(myTable.getFont());\n    int width = 0;\n    for(int i = myPairs.size() - 1; i >= 0; i--){\n      final Pair<String, String> pair = myPairs.get(i);\n      width = Math.max(width, metrics.stringWidth(pair.getFirst()));\n    }\n    width += 30;\n    width = Math.max(width, metrics.stringWidth(myModel.getColumnName(0)));\n    final TableColumn keyColumn = myTable.getColumnModel().getColumn(0);\n    keyColumn.setMaxWidth(width);\n    keyColumn.setMinWidth(width);\n    final TableCellRenderer defaultRenderer = myTable.getDefaultRenderer(String.class);\n    if (defaultRenderer instanceof JComponent) {\n      final JComponent component = (JComponent)defaultRenderer;\n      component.putClientProperty(\"html.disable\", Boolean.TRUE);\n    }\n    selectKey(keyToPreselect);\n\n    init();\n\n    myTable.addMouseListener(new MouseAdapter() {\n      public void mouseClicked(MouseEvent e) {\n        if (!e.isPopupTrigger() && e.getClickCount() == 2) {\n          doOKAction();\n        }\n      }\n    });\n  }","id":73800,"modified_method":"/**\n   * @param bundle resource bundle to be shown.\n   * @param bundleName name of the resource bundle to be shown. We need this\n   * name to create StringDescriptor in {@link #getDescriptor()} method.\n   * @param keyToPreselect describes row that should be selected in the\n   * @param parent the parent component for the dialog.\n   */\n  public KeyChooserDialog(\n    final Component parent,\n    @NotNull final PropertiesFile bundle,\n    @NotNull final String bundleName,\n    final String keyToPreselect,\n    final GuiEditor editor\n  ) {\n    super(parent, true);\n    myEditor = editor;\n    myBundle = bundle;\n\n    myBundleName = bundleName;\n\n    setTitle(UIDesignerBundle.message(\"title.chooser.value\"));\n\n    // Read key/value pairs from resource bundle\n    fillPropertyList();\n\n    // Create UI\n    myModel = new MyTableModel();\n    myTable = new JBTable(myModel);\n    myTable.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    new MySpeedSearch(myTable);\n    myCenterPanel = ScrollPaneFactory.createScrollPane(myTable);\n\n    myTable.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0), OK_ACTION);\n    myTable.getActionMap().put(OK_ACTION, new AbstractAction() {\n      public void actionPerformed(ActionEvent e) {\n        getOKAction().actionPerformed(e);\n      }\n    });\n\n    // Calculate width for \"Key\" columns\n    final Project projectGuess = PlatformDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext(parent));\n    final Dimension size = DimensionService.getInstance().getSize(getDimensionServiceKey(), projectGuess);\n    final FontMetrics metrics = myTable.getFontMetrics(myTable.getFont());\n    int minWidth = 200;\n    int maxWidth = size.width / 2;\n    if (minWidth > maxWidth) {\n      minWidth = maxWidth;\n    }\n    int width = minWidth;\n    for(int i = myPairs.size() - 1; i >= 0; i--){\n      final Pair<String, String> pair = myPairs.get(i);\n      width = Math.max(width, metrics.stringWidth(pair.getFirst()));\n    }\n    width += 20;\n    width = Math.max(width, metrics.stringWidth(myModel.getColumnName(0)));\n    width = Math.max(width, minWidth);\n    width = Math.min(width, maxWidth);\n    final TableColumnModel columnModel = myTable.getColumnModel();\n    final TableColumn keyColumn = columnModel.getColumn(0);\n    keyColumn.setMaxWidth(width);\n    keyColumn.setMinWidth(width);\n    final TableCellRenderer defaultRenderer = myTable.getDefaultRenderer(String.class);\n    if (defaultRenderer instanceof JComponent) {\n      final JComponent component = (JComponent)defaultRenderer;\n      component.putClientProperty(\"html.disable\", Boolean.TRUE);\n    }\n    selectKey(keyToPreselect);\n\n    init();\n\n    myTable.addMouseListener(new MouseAdapter() {\n      public void mouseClicked(MouseEvent e) {\n        if (!e.isPopupTrigger() && e.getClickCount() == 2) {\n          doOKAction();\n        }\n      }\n    });\n  }","commit_id":"88de66788c30c27434320a5807073c3e3715ff8d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void handleRequest(StreamInput stream, long requestId, LocalTransport sourceTransport, Version version) throws Exception {\n        final String action = stream.readString();\n        transportServiceAdapter.onRequestReceived(requestId, action);\n        final LocalTransportChannel transportChannel = new LocalTransportChannel(this, transportServiceAdapter, sourceTransport, action, requestId, version);\n        try {\n            final TransportRequestHandler handler = transportServiceAdapter.handler(action);\n            if (handler == null) {\n                throw new ActionNotFoundTransportException(\"Action [\" + action + \"] not found\");\n            }\n            final TransportRequest request = handler.newInstance();\n            request.remoteAddress(sourceTransport.boundAddress.publishAddress());\n            request.readFrom(stream);\n            if (handler.executor() == ThreadPool.Names.SAME) {\n                //noinspection unchecked\n                handler.messageReceived(request, transportChannel);\n            } else {\n                threadPool.executor(handler.executor()).execute(new AbstractRunnable() {\n                    @Override\n                    protected void doRun() throws Exception {\n                        //noinspection unchecked\n                        handler.messageReceived(request, transportChannel);\n                    }\n\n                    @Override\n                    public boolean isForceExecution() {\n                        return handler.isForceExecution();\n                    }\n\n                    @Override\n                    public void onFailure(Throwable e) {\n                        if (lifecycleState() == Lifecycle.State.STARTED) {\n                            // we can only send a response transport is started....\n                            try {\n                                transportChannel.sendResponse(e);\n                            } catch (Throwable e1) {\n                                logger.warn(\"Failed to send error message back to client for action [\" + action + \"]\", e1);\n                                logger.warn(\"Actual Exception\", e);\n                            }\n                        }\n                    }\n                });\n            }\n        } catch (Throwable e) {\n            try {\n                transportChannel.sendResponse(e);\n            } catch (Throwable e1) {\n                logger.warn(\"Failed to send error message back to client for action [\" + action + \"]\", e);\n                logger.warn(\"Actual Exception\", e1);\n            }\n        }\n    }","id":73801,"modified_method":"private void handleRequest(StreamInput stream, long requestId, LocalTransport sourceTransport, Version version) throws Exception {\n        final String action = stream.readString();\n        transportServiceAdapter.onRequestReceived(requestId, action);\n        final LocalTransportChannel transportChannel = new LocalTransportChannel(this, transportServiceAdapter, sourceTransport, action, requestId, version);\n        try {\n            final TransportRequestHandler handler = transportServiceAdapter.handler(action);\n            if (handler == null) {\n                throw new ActionNotFoundTransportException(\"Action [\" + action + \"] not found\");\n            }\n            final TransportRequest request = handler.newInstance();\n            request.remoteAddress(sourceTransport.boundAddress.publishAddress());\n            request.readFrom(stream);\n            if (ThreadPool.Names.SAME.equals(handler.executor())) {\n                //noinspection unchecked\n                handler.messageReceived(request, transportChannel);\n            } else {\n                threadPool.executor(handler.executor()).execute(new AbstractRunnable() {\n                    @Override\n                    protected void doRun() throws Exception {\n                        //noinspection unchecked\n                        handler.messageReceived(request, transportChannel);\n                    }\n\n                    @Override\n                    public boolean isForceExecution() {\n                        return handler.isForceExecution();\n                    }\n\n                    @Override\n                    public void onFailure(Throwable e) {\n                        if (lifecycleState() == Lifecycle.State.STARTED) {\n                            // we can only send a response transport is started....\n                            try {\n                                transportChannel.sendResponse(e);\n                            } catch (Throwable e1) {\n                                logger.warn(\"Failed to send error message back to client for action [\" + action + \"]\", e1);\n                                logger.warn(\"Actual Exception\", e);\n                            }\n                        }\n                    }\n                });\n            }\n        } catch (Throwable e) {\n            try {\n                transportChannel.sendResponse(e);\n            } catch (Throwable e1) {\n                logger.warn(\"Failed to send error message back to client for action [\" + action + \"]\", e);\n                logger.warn(\"Actual Exception\", e1);\n            }\n        }\n    }","commit_id":"341a52d82934fd5f7770e1a15372af41d7a78daa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected void handleResponse(Channel channel, StreamInput buffer, final TransportResponseHandler handler) {\n        final TransportResponse response = handler.newInstance();\n        response.remoteAddress(new InetSocketTransportAddress((InetSocketAddress) channel.getRemoteAddress()));\n        response.remoteAddress();\n        try {\n            response.readFrom(buffer);\n        } catch (Throwable e) {\n            handleException(handler, new TransportSerializationException(\"Failed to deserialize response of type [\" + response.getClass().getName() + \"]\", e));\n            return;\n        }\n        try {\n            if (handler.executor() == ThreadPool.Names.SAME) {\n                //noinspection unchecked\n                handler.handleResponse(response);\n            } else {\n                threadPool.executor(handler.executor()).execute(new ResponseHandler(handler, response));\n            }\n        } catch (Throwable e) {\n            handleException(handler, new ResponseHandlerFailureTransportException(e));\n        }\n    }","id":73802,"modified_method":"protected void handleResponse(Channel channel, StreamInput buffer, final TransportResponseHandler handler) {\n        final TransportResponse response = handler.newInstance();\n        response.remoteAddress(new InetSocketTransportAddress((InetSocketAddress) channel.getRemoteAddress()));\n        response.remoteAddress();\n        try {\n            response.readFrom(buffer);\n        } catch (Throwable e) {\n            handleException(handler, new TransportSerializationException(\"Failed to deserialize response of type [\" + response.getClass().getName() + \"]\", e));\n            return;\n        }\n        try {\n            if (ThreadPool.Names.SAME.equals(handler.executor())) {\n                //noinspection unchecked\n                handler.handleResponse(response);\n            } else {\n                threadPool.executor(handler.executor()).execute(new ResponseHandler(handler, response));\n            }\n        } catch (Throwable e) {\n            handleException(handler, new ResponseHandlerFailureTransportException(e));\n        }\n    }","commit_id":"341a52d82934fd5f7770e1a15372af41d7a78daa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected String handleRequest(Channel channel, StreamInput buffer, long requestId, Version version) throws IOException {\n        final String action = buffer.readString();\n        transportServiceAdapter.onRequestReceived(requestId, action);\n        final NettyTransportChannel transportChannel = new NettyTransportChannel(transport, transportServiceAdapter, action, channel, requestId, version, profileName);\n        try {\n            final TransportRequestHandler handler = transportServiceAdapter.handler(action);\n            if (handler == null) {\n                throw new ActionNotFoundTransportException(action);\n            }\n            final TransportRequest request = handler.newInstance();\n            request.remoteAddress(new InetSocketTransportAddress((InetSocketAddress) channel.getRemoteAddress()));\n            request.readFrom(buffer);\n            if (handler.executor() == ThreadPool.Names.SAME) {\n                //noinspection unchecked\n                handler.messageReceived(request, transportChannel);\n            } else {\n                threadPool.executor(handler.executor()).execute(new RequestHandler(handler, request, transportChannel, action));\n            }\n        } catch (Throwable e) {\n            try {\n                transportChannel.sendResponse(e);\n            } catch (IOException e1) {\n                logger.warn(\"Failed to send error message back to client for action [\" + action + \"]\", e);\n                logger.warn(\"Actual Exception\", e1);\n            }\n        }\n        return action;\n    }","id":73803,"modified_method":"protected String handleRequest(Channel channel, StreamInput buffer, long requestId, Version version) throws IOException {\n        final String action = buffer.readString();\n        transportServiceAdapter.onRequestReceived(requestId, action);\n        final NettyTransportChannel transportChannel = new NettyTransportChannel(transport, transportServiceAdapter, action, channel, requestId, version, profileName);\n        try {\n            final TransportRequestHandler handler = transportServiceAdapter.handler(action);\n            if (handler == null) {\n                throw new ActionNotFoundTransportException(action);\n            }\n            final TransportRequest request = handler.newInstance();\n            request.remoteAddress(new InetSocketTransportAddress((InetSocketAddress) channel.getRemoteAddress()));\n            request.readFrom(buffer);\n            if (ThreadPool.Names.SAME.equals(handler.executor())) {\n                //noinspection unchecked\n                handler.messageReceived(request, transportChannel);\n            } else {\n                threadPool.executor(handler.executor()).execute(new RequestHandler(handler, request, transportChannel, action));\n            }\n        } catch (Throwable e) {\n            try {\n                transportChannel.sendResponse(e);\n            } catch (IOException e1) {\n                logger.warn(\"Failed to send error message back to client for action [\" + action + \"]\", e);\n                logger.warn(\"Actual Exception\", e1);\n            }\n        }\n        return action;\n    }","commit_id":"341a52d82934fd5f7770e1a15372af41d7a78daa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void handleException(final TransportResponseHandler handler, Throwable error) {\n        if (!(error instanceof RemoteTransportException)) {\n            error = new RemoteTransportException(error.getMessage(), error);\n        }\n        final RemoteTransportException rtx = (RemoteTransportException) error;\n        if (handler.executor() == ThreadPool.Names.SAME) {\n            try {\n                handler.handleException(rtx);\n            } catch (Throwable e) {\n                logger.error(\"failed to handle exception response [{}]\", e, handler);\n            }\n        } else {\n            threadPool.executor(handler.executor()).execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        handler.handleException(rtx);\n                    } catch (Throwable e) {\n                        logger.error(\"failed to handle exception response [{}]\", e, handler);\n                    }\n                }\n            });\n        }\n    }","id":73804,"modified_method":"private void handleException(final TransportResponseHandler handler, Throwable error) {\n        if (!(error instanceof RemoteTransportException)) {\n            error = new RemoteTransportException(error.getMessage(), error);\n        }\n        final RemoteTransportException rtx = (RemoteTransportException) error;\n        if (ThreadPool.Names.SAME.equals(handler.executor())) {\n            try {\n                handler.handleException(rtx);\n            } catch (Throwable e) {\n                logger.error(\"failed to handle exception response [{}]\", e, handler);\n            }\n        } else {\n            threadPool.executor(handler.executor()).execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        handler.handleException(rtx);\n                    } catch (Throwable e) {\n                        logger.error(\"failed to handle exception response [{}]\", e, handler);\n                    }\n                }\n            });\n        }\n    }","commit_id":"341a52d82934fd5f7770e1a15372af41d7a78daa","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Preprocess the messages from the pending list, grouping items startAt \n     * through sendThrough (though only part of the last one may be fully \n     * sent), delivering them through the sender/receiver.\n     *\n     * @param startAt first index in pending to send (inclusive)\n     * @param sendThrough last index in pending to send (inclusive)\n     */\n    protected void send(List<PendingGatewayMessage> pending, int startAt, int sendThrough, TunnelGateway.Sender sender, TunnelGateway.Receiver rec) {\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Sending \" + startAt + \":\" + sendThrough + \" out of \" + pending);\n\n        // Might as well take a buf from the cache;\n        // However it will never be returned to the cache.\n        // (TunnelDataMessage will not wrap the buffer in a new ByteArray and release() it)\n        // See also TDM for more discussion.\n        byte preprocessed[] = _dataCache.acquire().getData();\n        \n        int offset = 0;\n        offset = writeFragments(pending, startAt, sendThrough, preprocessed, offset);\n        // preprocessed[0:offset] now contains the fragments from the pending,\n        // so we need to format, pad, and rearrange according to the spec to\n        // generate the final preprocessed data\n        \n        if (offset <= 0) {\n            StringBuilder buf = new StringBuilder(128);\n            buf.append(\"wtf, written offset is \").append(offset);\n            buf.append(\" for \").append(startAt).append(\" through \").append(sendThrough);\n            for (int i = startAt; i <= sendThrough; i++) {\n                buf.append(\" \").append(pending.get(i).toString());\n            }\n            _log.log(Log.CRIT, buf.toString());\n            return;\n        }\n        \n        try {\n            preprocess(preprocessed, offset);\n        } catch (ArrayIndexOutOfBoundsException aioobe) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"Error preprocessing the messages (offset=\" + offset + \" start=\" + startAt + \" through=\" + sendThrough + \" pending=\" + pending.size() + \" preproc=\" + preprocessed.length);\n            return;\n        }\n\n        long msgId = sender.sendPreprocessed(preprocessed, rec);\n        for (int i = 0; i < pending.size(); i++) {\n            PendingGatewayMessage cur = pending.get(i);\n            cur.addMessageId(msgId);\n        }\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Sent \" + startAt + \":\" + sendThrough + \" out of \" + pending + \" in message \" + msgId);\n    }","id":73805,"modified_method":"/**\n     * Preprocess the messages from the pending list, grouping items startAt \n     * through sendThrough (though only part of the last one may be fully \n     * sent), delivering them through the sender/receiver.\n     *\n     * @param startAt first index in pending to send (inclusive)\n     * @param sendThrough last index in pending to send (inclusive)\n     */\n    protected void send(List<PendingGatewayMessage> pending, int startAt, int sendThrough, TunnelGateway.Sender sender, TunnelGateway.Receiver rec) {\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Sending \" + startAt + \":\" + sendThrough + \" out of \" + pending);\n\n        // Might as well take a buf from the cache;\n        // However it will never be returned to the cache.\n        // (TunnelDataMessage will not wrap the buffer in a new ByteArray and release() it)\n        // See also TDM for more discussion.\n        byte preprocessed[] = _dataCache.acquire().getData();\n        \n        int offset = 0;\n        offset = writeFragments(pending, startAt, sendThrough, preprocessed, offset);\n        // preprocessed[0:offset] now contains the fragments from the pending,\n        // so we need to format, pad, and rearrange according to the spec to\n        // generate the final preprocessed data\n        \n        if (offset <= 0) {\n            StringBuilder buf = new StringBuilder(128);\n            buf.append(\"wtf, written offset is \").append(offset);\n            buf.append(\" for \").append(startAt).append(\" through \").append(sendThrough);\n            for (int i = startAt; i <= sendThrough; i++) {\n                buf.append(\" \").append(pending.get(i).toString());\n            }\n            _log.log(Log.CRIT, buf.toString());\n            return;\n        }\n        \n        try {\n            preprocess(preprocessed, offset);\n        } catch (ArrayIndexOutOfBoundsException aioobe) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"Error preprocessing the messages (offset=\" + offset + \" start=\" + startAt + \" through=\" + sendThrough + \" pending=\" + pending.size() + \" preproc=\" + preprocessed.length);\n            return;\n        }\n\n        long msgId = sender.sendPreprocessed(preprocessed, rec);\n        if (DEBUG) {\n            // creates a list in PGM\n            for (int i = 0; i < pending.size(); i++) {\n                PendingGatewayMessage cur = pending.get(i);\n                cur.addMessageId(msgId);\n            }\n        }\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Sent \" + startAt + \":\" + sendThrough + \" out of \" + pending + \" in message \" + msgId);\n    }","commit_id":"51e45d128ae7f27e79822cfd36c0d995ef941c31","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    public boolean preprocessQueue(List<PendingGatewayMessage> pending, TunnelGateway.Sender sender, TunnelGateway.Receiver rec) {\n        if (_log.shouldLog(Log.INFO))\n            display(0, pending, \"Starting\");\n        StringBuilder timingBuf = null;\n        if (_log.shouldLog(Log.DEBUG)) {\n            _log.debug(\"Preprocess queue with \" + pending.size() + \" to send\");\n            timingBuf = new StringBuilder(128);\n            timingBuf.append(\"Preprocess with \" + pending.size() + \" to send. \");\n        }\n        //if (DISABLE_BATCHING) {\n        //    if (_log.shouldLog(Log.INFO))\n        //        _log.info(\"Disabled batching, pushing \" + pending + \" immediately\");\n        //    return super.preprocessQueue(pending, sender, rec);\n        //}\n        long start = System.currentTimeMillis();\n        \n        int batchCount = 0;\n        int beforeLooping = pending.size();\n        \n        // loop until the queue is empty\n        while (!pending.isEmpty()) {\n            int allocated = 0;\n            long beforePendingLoop = System.currentTimeMillis();\n\n            // loop until we fill up a single message\n            for (int i = 0; i < pending.size(); i++) {\n                long pendingStart = System.currentTimeMillis();\n                PendingGatewayMessage msg = pending.get(i);\n                int instructionsSize = getInstructionsSize(msg);\n                instructionsSize += getInstructionAugmentationSize(msg, allocated, instructionsSize);\n                int curWanted = msg.getData().length - msg.getOffset() + instructionsSize;\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(\"pending \" + i + \"/\" +pending.size() \n                               + \" (\" + msg.getMessageId() + \") curWanted=\" + curWanted \n                               + \" instructionSize=\" + instructionsSize + \" allocated=\" + allocated);\n                allocated += curWanted;\n                if (allocated >= FULL_SIZE) {\n                    if (allocated - curWanted + instructionsSize >= FULL_SIZE) {\n                        // the instructions alone exceed the size, so we won't get any\n                        // of the message into it.  don't include it\n                        i--;\n                        msg = pending.get(i);\n                        allocated -= curWanted;\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(\"Pushback of \" + curWanted + \" (message \" + (i+1) + \" in \" + pending + \")\");\n                    }\n                    if (_pendingSince > 0) {\n                        long waited = _context.clock().now() - _pendingSince;\n                        _context.statManager().addRateData(\"tunnel.batchDelaySent\", pending.size(), waited);\n                    }\n\n                    // Send the message\n                    long beforeSend = System.currentTimeMillis();\n                    _pendingSince = 0;\n                    send(pending, 0, i, sender, rec);\n                    _context.statManager().addRateData(\"tunnel.batchFullFragments\", 1);\n                    long afterSend = System.currentTimeMillis();\n                    if (_log.shouldLog(Log.INFO))\n                        display(allocated, pending, \"Sent the message with \" + (i+1));\n                        //_log.info(_name + \": Allocated=\" + allocated + \"B, Sent \" + (i+1) \n                        //          + \" msgs (last complete? \" + (msg.getOffset() >= msg.getData().length) \n                        //          + \", off=\" + msg.getOffset() + \", pending=\" + pending.size() + \")\");\n\n                    // Remove what we sent from the pending queue\n                    for (int j = 0; j < i; j++) {\n                        PendingGatewayMessage cur = pending.remove(0);\n                        if (cur.getOffset() < cur.getData().length)\n                            throw new IllegalArgumentException(\"i=\" + i + \" j=\" + j + \" off=\" + cur.getOffset() \n                                                               + \" len=\" + cur.getData().length + \" alloc=\" + allocated);\n                        if (timingBuf != null)\n                            timingBuf.append(\" sent \" + cur);\n                        notePreprocessing(cur.getMessageId(), cur.getFragmentNumber(), cur.getData().length, cur.getMessageIds(), \"flushed allocated\");\n                        _context.statManager().addRateData(\"tunnel.batchFragmentation\", cur.getFragmentNumber() + 1);\n                        _context.statManager().addRateData(\"tunnel.writeDelay\", cur.getLifetime(), cur.getData().length);\n                    }\n                    if (msg.getOffset() >= msg.getData().length) {\n                        // ok, this last message fit perfectly, remove it too\n                        PendingGatewayMessage cur = pending.remove(0);\n                        if (timingBuf != null)\n                            timingBuf.append(\" sent perfect fit \" + cur).append(\".\");\n                        notePreprocessing(cur.getMessageId(), cur.getFragmentNumber(), msg.getData().length, msg.getMessageIds(), \"flushed tail, remaining: \" + pending);\n                        _context.statManager().addRateData(\"tunnel.batchFragmentation\", cur.getFragmentNumber() + 1);\n                        _context.statManager().addRateData(\"tunnel.writeDelay\", cur.getLifetime(), cur.getData().length);\n                    }\n                    if (i > 0)\n                        _context.statManager().addRateData(\"tunnel.batchMultipleCount\", i+1);\n                    allocated = 0;\n                    batchCount++;\n                    long pendingEnd = System.currentTimeMillis();\n                    if (timingBuf != null)\n                        timingBuf.append(\" After sending \" + (i+1) + \"/\"+pending.size() +\" in \" + (afterSend-beforeSend) \n                                         + \" after \" + (beforeSend-pendingStart)\n                                         + \" since \" + (beforeSend-beforePendingLoop)\n                                         + \"/\" + (beforeSend-start)\n                                         + \" pending current \" + (pendingEnd-pendingStart)).append(\".\");\n                    break;\n                }  // if >= full size\n                if (timingBuf != null)\n                    timingBuf.append(\" After pending loop \" + (System.currentTimeMillis()-beforePendingLoop)).append(\".\");\n            }  // for\n            \n            if (_log.shouldLog(Log.INFO))\n                display(allocated, pending, \"after looping to clear \" + (beforeLooping - pending.size()));\n            long afterDisplayed = System.currentTimeMillis();\n            if (allocated > 0) {\n                // After going through the entire pending list, we have only a partial message.\n                // We might flush it or might not, but we are returning either way.\n\n                if ( (pending.size() > FORCE_BATCH_FLUSH) ||                    // enough msgs - or\n                     ( (_pendingSince > 0) && (getDelayAmount() <= 0) ) ||      // time to flush - or\n                     (allocated >= FULL_ENOUGH_SIZE)) {                         // full enough\n                     //(pending.get(0).getFragmentNumber() > 0)) {                // don't delay anybody's last fragment,\n                     //                                                           // which would be the first fragment in the message\n\n                    // not even a full message, but we want to flush it anyway\n                    \n                    if (pending.size() > 1)\n                        _context.statManager().addRateData(\"tunnel.batchMultipleCount\", pending.size());\n                    _context.statManager().addRateData(\"tunnel.batchDelaySent\", pending.size(), 0);\n\n                    send(pending, 0, pending.size()-1, sender, rec);\n                    _context.statManager().addRateData(\"tunnel.batchSmallFragments\", FULL_SIZE - allocated);\n                    \n                    // Remove everything in the outgoing message from the pending queue\n                    int beforeSize = pending.size();\n                    for (int i = 0; i < beforeSize; i++) {\n                        PendingGatewayMessage cur = pending.get(0);\n                        if (cur.getOffset() < cur.getData().length)\n                            break;\n                        pending.remove(0);\n                        notePreprocessing(cur.getMessageId(), cur.getFragmentNumber(), cur.getData().length, cur.getMessageIds(), \"flushed remaining\");\n                        _context.statManager().addRateData(\"tunnel.batchFragmentation\", cur.getFragmentNumber() + 1);\n                        _context.statManager().addRateData(\"tunnel.writeDelay\", cur.getLifetime(), cur.getData().length);\n                    }\n\n                    if (!pending.isEmpty()) {\n                        // rare\n                        _pendingSince = _context.clock().now();\n                        _context.statManager().addRateData(\"tunnel.batchFlushRemaining\", pending.size(), beforeSize);\n                        if (_log.shouldLog(Log.INFO))\n                            display(allocated, pending, \"flushed, some remain\");\n                        \n                        if (timingBuf != null) {\n                            timingBuf.append(\" flushed, some remain (displayed to now: \" + (System.currentTimeMillis()-afterDisplayed) + \")\");\n                            timingBuf.append(\" total time: \" + (System.currentTimeMillis()-start));\n                            _log.debug(timingBuf.toString());\n                        }\n                        return true;\n                    } else {\n                        long delayAmount = 0;\n                        if (_pendingSince > 0) {\n                            delayAmount = _context.clock().now() - _pendingSince;\n                            _pendingSince = 0;\n                        }\n                        if (batchCount > 1)\n                            _context.statManager().addRateData(\"tunnel.batchCount\", batchCount);\n                        if (_log.shouldLog(Log.INFO))\n                            display(allocated, pending, \"flushed \" + (beforeSize) + \", no remaining after \" + delayAmount + \"ms\");\n                        \n                        if (timingBuf != null) {\n                            timingBuf.append(\" flushed, none remain (displayed to now: \" + (System.currentTimeMillis()-afterDisplayed) + \")\");\n                            timingBuf.append(\" total time: \" + (System.currentTimeMillis()-start));\n                            _log.debug(timingBuf.toString());\n                        }\n                        return false;\n                    }\n                    // won't get here, we returned\n                } else {\n                     // We didn't flush. Note that the messages remain on the pending list.\n                    _context.statManager().addRateData(\"tunnel.batchDelay\", pending.size());\n                    if (_pendingSince <= 0)\n                        _pendingSince = _context.clock().now();\n                    if (batchCount > 1)\n                        _context.statManager().addRateData(\"tunnel.batchCount\", batchCount);\n                    // not yet time to send the delayed flush\n                    if (_log.shouldLog(Log.INFO))\n                        display(allocated, pending, \"dont flush\");\n                    \n                    if (timingBuf != null) {\n                        timingBuf.append(\" dont flush (displayed to now: \" + (System.currentTimeMillis()-afterDisplayed) + \")\");\n                        timingBuf.append(\" total time: \" + (System.currentTimeMillis()-start));\n                        _log.debug(timingBuf.toString());\n                    }\n                    return true;\n                }\n                // won't get here, we returned\n            } else {\n                // ok, we sent some, but haven't gone back for another \n                // pass yet.  keep looping\n                \n                if (timingBuf != null)\n                    timingBuf.append(\" Keep looping\");\n            }  // if allocated\n        }  // while\n        \n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Sent everything on the list (pending=\" + pending.size() + \")\");\n\n        if (timingBuf != null)\n            timingBuf.append(\" total time: \" + (System.currentTimeMillis()-start));\n        \n        if (timingBuf != null)\n            _log.debug(timingBuf.toString());\n        // sent everything from the pending list, no need to delayed flush\n        return false;\n    }","id":73806,"modified_method":"@Override\n    public boolean preprocessQueue(List<PendingGatewayMessage> pending, TunnelGateway.Sender sender, TunnelGateway.Receiver rec) {\n        if (_log.shouldLog(Log.INFO))\n            display(0, pending, \"Starting\");\n        StringBuilder timingBuf = null;\n        if (_log.shouldLog(Log.DEBUG)) {\n            _log.debug(\"Preprocess queue with \" + pending.size() + \" to send\");\n            timingBuf = new StringBuilder(128);\n            timingBuf.append(\"Preprocess with \" + pending.size() + \" to send. \");\n        }\n        //if (DISABLE_BATCHING) {\n        //    if (_log.shouldLog(Log.INFO))\n        //        _log.info(\"Disabled batching, pushing \" + pending + \" immediately\");\n        //    return super.preprocessQueue(pending, sender, rec);\n        //}\n        long start = System.currentTimeMillis();\n        \n        int batchCount = 0;\n        int beforeLooping = pending.size();\n        \n        // loop until the queue is empty\n        while (!pending.isEmpty()) {\n            int allocated = 0;\n            long beforePendingLoop = System.currentTimeMillis();\n\n            // loop until we fill up a single message\n            for (int i = 0; i < pending.size(); i++) {\n                long pendingStart = System.currentTimeMillis();\n                PendingGatewayMessage msg = pending.get(i);\n                int instructionsSize = getInstructionsSize(msg);\n                instructionsSize += getInstructionAugmentationSize(msg, allocated, instructionsSize);\n                int curWanted = msg.getData().length - msg.getOffset() + instructionsSize;\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(\"pending \" + i + \"/\" +pending.size() \n                               + \" (\" + msg.getMessageId() + \") curWanted=\" + curWanted \n                               + \" instructionSize=\" + instructionsSize + \" allocated=\" + allocated);\n                allocated += curWanted;\n                if (allocated >= FULL_SIZE) {\n                    if (allocated - curWanted + instructionsSize >= FULL_SIZE) {\n                        // the instructions alone exceed the size, so we won't get any\n                        // of the message into it.  don't include it\n                        i--;\n                        msg = pending.get(i);\n                        allocated -= curWanted;\n                        if (_log.shouldLog(Log.DEBUG))\n                            _log.debug(\"Pushback of \" + curWanted + \" (message \" + (i+1) + \" in \" + pending + \")\");\n                    }\n                    if (_pendingSince > 0) {\n                        long waited = _context.clock().now() - _pendingSince;\n                        _context.statManager().addRateData(\"tunnel.batchDelaySent\", pending.size(), waited);\n                    }\n\n                    // Send the message\n                    long beforeSend = System.currentTimeMillis();\n                    _pendingSince = 0;\n                    send(pending, 0, i, sender, rec);\n                    _context.statManager().addRateData(\"tunnel.batchFullFragments\", 1);\n                    long afterSend = System.currentTimeMillis();\n                    if (_log.shouldLog(Log.INFO))\n                        display(allocated, pending, \"Sent the message with \" + (i+1));\n                        //_log.info(_name + \": Allocated=\" + allocated + \"B, Sent \" + (i+1) \n                        //          + \" msgs (last complete? \" + (msg.getOffset() >= msg.getData().length) \n                        //          + \", off=\" + msg.getOffset() + \", pending=\" + pending.size() + \")\");\n\n                    // Remove what we sent from the pending queue\n                    for (int j = 0; j < i; j++) {\n                        PendingGatewayMessage cur = pending.remove(0);\n                        if (cur.getOffset() < cur.getData().length)\n                            throw new IllegalArgumentException(\"i=\" + i + \" j=\" + j + \" off=\" + cur.getOffset() \n                                                               + \" len=\" + cur.getData().length + \" alloc=\" + allocated);\n                        if (timingBuf != null)\n                            timingBuf.append(\" sent \" + cur);\n                        if (DEBUG)\n                            notePreprocessing(cur.getMessageId(), cur.getFragmentNumber(), cur.getData().length, cur.getMessageIds(), \"flushed allocated\");\n                        _context.statManager().addRateData(\"tunnel.batchFragmentation\", cur.getFragmentNumber() + 1);\n                        _context.statManager().addRateData(\"tunnel.writeDelay\", cur.getLifetime(), cur.getData().length);\n                    }\n                    if (msg.getOffset() >= msg.getData().length) {\n                        // ok, this last message fit perfectly, remove it too\n                        PendingGatewayMessage cur = pending.remove(0);\n                        if (timingBuf != null)\n                            timingBuf.append(\" sent perfect fit \" + cur).append(\".\");\n                        if (DEBUG)\n                            notePreprocessing(cur.getMessageId(), cur.getFragmentNumber(), msg.getData().length, msg.getMessageIds(), \"flushed tail, remaining: \" + pending);\n                        _context.statManager().addRateData(\"tunnel.batchFragmentation\", cur.getFragmentNumber() + 1);\n                        _context.statManager().addRateData(\"tunnel.writeDelay\", cur.getLifetime(), cur.getData().length);\n                    }\n                    if (i > 0)\n                        _context.statManager().addRateData(\"tunnel.batchMultipleCount\", i+1);\n                    allocated = 0;\n                    batchCount++;\n                    long pendingEnd = System.currentTimeMillis();\n                    if (timingBuf != null)\n                        timingBuf.append(\" After sending \" + (i+1) + \"/\"+pending.size() +\" in \" + (afterSend-beforeSend) \n                                         + \" after \" + (beforeSend-pendingStart)\n                                         + \" since \" + (beforeSend-beforePendingLoop)\n                                         + \"/\" + (beforeSend-start)\n                                         + \" pending current \" + (pendingEnd-pendingStart)).append(\".\");\n                    break;\n                }  // if >= full size\n                if (timingBuf != null)\n                    timingBuf.append(\" After pending loop \" + (System.currentTimeMillis()-beforePendingLoop)).append(\".\");\n            }  // for\n            \n            if (_log.shouldLog(Log.INFO))\n                display(allocated, pending, \"after looping to clear \" + (beforeLooping - pending.size()));\n            long afterDisplayed = System.currentTimeMillis();\n            if (allocated > 0) {\n                // After going through the entire pending list, we have only a partial message.\n                // We might flush it or might not, but we are returning either way.\n\n                if ( (pending.size() > FORCE_BATCH_FLUSH) ||                    // enough msgs - or\n                     ( (_pendingSince > 0) && (getDelayAmount() <= 0) ) ||      // time to flush - or\n                     (allocated >= FULL_ENOUGH_SIZE)) {                         // full enough\n                     //(pending.get(0).getFragmentNumber() > 0)) {                // don't delay anybody's last fragment,\n                     //                                                           // which would be the first fragment in the message\n\n                    // not even a full message, but we want to flush it anyway\n                    \n                    if (pending.size() > 1)\n                        _context.statManager().addRateData(\"tunnel.batchMultipleCount\", pending.size());\n                    _context.statManager().addRateData(\"tunnel.batchDelaySent\", pending.size(), 0);\n\n                    send(pending, 0, pending.size()-1, sender, rec);\n                    _context.statManager().addRateData(\"tunnel.batchSmallFragments\", FULL_SIZE - allocated);\n                    \n                    // Remove everything in the outgoing message from the pending queue\n                    int beforeSize = pending.size();\n                    for (int i = 0; i < beforeSize; i++) {\n                        PendingGatewayMessage cur = pending.get(0);\n                        if (cur.getOffset() < cur.getData().length)\n                            break;\n                        pending.remove(0);\n                        if (DEBUG)\n                            notePreprocessing(cur.getMessageId(), cur.getFragmentNumber(), cur.getData().length, cur.getMessageIds(), \"flushed remaining\");\n                        _context.statManager().addRateData(\"tunnel.batchFragmentation\", cur.getFragmentNumber() + 1);\n                        _context.statManager().addRateData(\"tunnel.writeDelay\", cur.getLifetime(), cur.getData().length);\n                    }\n\n                    if (!pending.isEmpty()) {\n                        // rare\n                        _pendingSince = _context.clock().now();\n                        _context.statManager().addRateData(\"tunnel.batchFlushRemaining\", pending.size(), beforeSize);\n                        if (_log.shouldLog(Log.INFO))\n                            display(allocated, pending, \"flushed, some remain\");\n                        \n                        if (timingBuf != null) {\n                            timingBuf.append(\" flushed, some remain (displayed to now: \" + (System.currentTimeMillis()-afterDisplayed) + \")\");\n                            timingBuf.append(\" total time: \" + (System.currentTimeMillis()-start));\n                            _log.debug(timingBuf.toString());\n                        }\n                        return true;\n                    } else {\n                        long delayAmount = 0;\n                        if (_pendingSince > 0) {\n                            delayAmount = _context.clock().now() - _pendingSince;\n                            _pendingSince = 0;\n                        }\n                        if (batchCount > 1)\n                            _context.statManager().addRateData(\"tunnel.batchCount\", batchCount);\n                        if (_log.shouldLog(Log.INFO))\n                            display(allocated, pending, \"flushed \" + (beforeSize) + \", no remaining after \" + delayAmount + \"ms\");\n                        \n                        if (timingBuf != null) {\n                            timingBuf.append(\" flushed, none remain (displayed to now: \" + (System.currentTimeMillis()-afterDisplayed) + \")\");\n                            timingBuf.append(\" total time: \" + (System.currentTimeMillis()-start));\n                            _log.debug(timingBuf.toString());\n                        }\n                        return false;\n                    }\n                    // won't get here, we returned\n                } else {\n                     // We didn't flush. Note that the messages remain on the pending list.\n                    _context.statManager().addRateData(\"tunnel.batchDelay\", pending.size());\n                    if (_pendingSince <= 0)\n                        _pendingSince = _context.clock().now();\n                    if (batchCount > 1)\n                        _context.statManager().addRateData(\"tunnel.batchCount\", batchCount);\n                    // not yet time to send the delayed flush\n                    if (_log.shouldLog(Log.INFO))\n                        display(allocated, pending, \"dont flush\");\n                    \n                    if (timingBuf != null) {\n                        timingBuf.append(\" dont flush (displayed to now: \" + (System.currentTimeMillis()-afterDisplayed) + \")\");\n                        timingBuf.append(\" total time: \" + (System.currentTimeMillis()-start));\n                        _log.debug(timingBuf.toString());\n                    }\n                    return true;\n                }\n                // won't get here, we returned\n            } else {\n                // ok, we sent some, but haven't gone back for another \n                // pass yet.  keep looping\n                \n                if (timingBuf != null)\n                    timingBuf.append(\" Keep looping\");\n            }  // if allocated\n        }  // while\n        \n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Sent everything on the list (pending=\" + pending.size() + \")\");\n\n        if (timingBuf != null)\n            timingBuf.append(\" total time: \" + (System.currentTimeMillis()-start));\n        \n        if (timingBuf != null)\n            _log.debug(timingBuf.toString());\n        // sent everything from the pending list, no need to delayed flush\n        return false;\n    }","commit_id":"51e45d128ae7f27e79822cfd36c0d995ef941c31","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** for IBGWs */\n    public BatchedRouterPreprocessor(RouterContext ctx, HopConfig cfg) {\n        super(ctx, getName(cfg));\n        _hopConfig = cfg;\n        _sendDelay = initialSendDelay();\n    }","id":73807,"modified_method":"/** for IBGWs */\n    public BatchedRouterPreprocessor(RouterContext ctx, HopConfig cfg) {\n        super(ctx, getName(cfg));\n        _config = null;\n        _hopConfig = cfg;\n        _sendDelay = initialSendDelay();\n    }","commit_id":"51e45d128ae7f27e79822cfd36c0d995ef941c31","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/** for OBGWs */\n    public BatchedRouterPreprocessor(RouterContext ctx, TunnelCreatorConfig cfg) {\n        super(ctx, getName(cfg));\n        _config = cfg;\n        _sendDelay = initialSendDelay();\n    }","id":73808,"modified_method":"/** for OBGWs */\n    public BatchedRouterPreprocessor(RouterContext ctx, TunnelCreatorConfig cfg) {\n        super(ctx, getName(cfg));\n        _config = cfg;\n        _hopConfig = null;\n        _sendDelay = initialSendDelay();\n    }","commit_id":"51e45d128ae7f27e79822cfd36c0d995ef941c31","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public long sendPreprocessed(byte[] preprocessed, TunnelGateway.Receiver receiver) {\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"preprocessed data going out \" + _config + \": \" + Base64.encode(preprocessed));\n        //if (USE_ENCRYPTION)\n            _processor.process(preprocessed, 0, preprocessed.length);\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"after wrapping up the preprocessed data on \" + _config);\n        long rv = receiver.receiveEncrypted(preprocessed);\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"after receiving on \" + _config + \": receiver = \" + receiver);\n        return rv;\n    }","id":73809,"modified_method":"public long sendPreprocessed(byte[] preprocessed, TunnelGateway.Receiver receiver) {\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(\"preprocessed data going out \" + _config + \": \" + Base64.encode(preprocessed));\n        //if (USE_ENCRYPTION)\n            _processor.process(preprocessed, 0, preprocessed.length);\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(\"after wrapping up the preprocessed data on \" + _config);\n        long rv = receiver.receiveEncrypted(preprocessed);\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(\"after receiving on \" + _config + \": receiver = \" + receiver);\n        return rv;\n    }","commit_id":"51e45d128ae7f27e79822cfd36c0d995ef941c31","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public OutboundSender(I2PAppContext ctx, TunnelCreatorConfig config) {\n        _context = ctx;\n        _log = ctx.logManager().getLog(OutboundSender.class);\n        _config = config;\n        _processor = new OutboundGatewayProcessor(_context, config);\n    }","id":73810,"modified_method":"public OutboundSender(I2PAppContext ctx, TunnelCreatorConfig config) {\n        //_context = ctx;\n        //_log = ctx.logManager().getLog(OutboundSender.class);\n        _config = config;\n        _processor = new OutboundGatewayProcessor(ctx, config);\n    }","commit_id":"51e45d128ae7f27e79822cfd36c0d995ef941c31","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Return true if there were messages remaining, and we should queue up\n     * a delayed flush to clear them\n     *\n     * NOTE: Unused here, see BatchedPreprocessor override, super is not called.\n     */\n    public boolean preprocessQueue(List<PendingGatewayMessage> pending, TunnelGateway.Sender sender, TunnelGateway.Receiver rec) {\n        throw new IllegalArgumentException(\"unused, right?\");\n    }","id":73811,"modified_method":"/**\n     * Return true if there were messages remaining, and we should queue up\n     * a delayed flush to clear them\n     *\n     * NOTE: Unused here, see BatchedPreprocessor override, super is not called.\n     */\n    public boolean preprocessQueue(List<PendingGatewayMessage> pending, TunnelGateway.Sender sender, TunnelGateway.Receiver rec) {\n        throw new UnsupportedOperationException(\"unused, right?\");\n    }","commit_id":"51e45d128ae7f27e79822cfd36c0d995ef941c31","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public boolean isMyFile(@NotNull XmlFile file, final Module module) {\n    return MavenDomUtil.isMavenFile(file) && super.isMyFile(file, module);\n  }","id":73812,"modified_method":"public boolean isMyFile(@NotNull XmlFile file, final Module module) {\n    boolean isMavenFile = MavenDomUtil.isMavenFile(file);\n    boolean superResult = super.isMyFile(file, module);\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      System.out.println(\"MavenDomFileDescription.isMyFile\");\n      System.out.println(\"superResult = \" + superResult);\n      System.out.println(\"isMavenFile = \" + isMavenFile);\n    }\n    return isMavenFile && superResult;\n  }","commit_id":"b72701a1d15d1041d87629dbdf98b161d098d1a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean isAvailableForFile(PsiFile file) {\n    return MavenDomUtil.isMavenFile(file);\n  }","id":73813,"modified_method":"@Override\n  protected boolean isAvailableForFile(PsiFile file) {\n    VirtualFile virtualFile = file.getVirtualFile();\n    return MavenDomUtil.isMavenFile(file)\n           && virtualFile != null\n           && virtualFile.getFileSystem() != JarFileSystem.getInstance();\n  }","commit_id":"c9a7a6224057a1a69995fe22ec390bd38f7f66c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull final Project project, final Editor editor, PsiFile file, DataContext dataContext) {\n      if (!editor.getSelectionModel().hasSelection()) return;\n      PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n      final int startOffset = editor.getSelectionModel().getSelectionStart();\n      final int endOffset = editor.getSelectionModel().getSelectionEnd();\n\n      XmlElement selectedElement = getSelectedElement(file, startOffset, endOffset);\n\n      if (selectedElement != null) {\n        String stringValue = selectedElement.getText();\n        if (stringValue != null) {\n\n          final MavenDomProjectModel model = MavenDomUtil.getMavenDomModel(file, MavenDomProjectModel.class);\n          final String selectedString = editor.getSelectionModel().getSelectedText();\n\n          Set<TextRange> ranges = getPropertiesTextRanges(stringValue);\n          int offsetInElement = startOffset - selectedElement.getTextOffset();\n\n          if (model == null ||\n              StringUtil.isEmptyOrSpaces(selectedString) ||\n              isInsideTextRanges(ranges, offsetInElement, offsetInElement + selectedString.length())) {\n            return;\n          }\n\n          IntroducePropertyDialog dialog = new IntroducePropertyDialog(project, selectedElement, model, null, selectedString);\n          dialog.show();\n\n          if (dialog.getExitCode() == DialogWrapper.OK_EXIT_CODE) {\n            final String propertyName = dialog.getEnteredName();\n            final String replaceWith = PREFIX + propertyName + SUFFIX;\n            final MavenDomProjectModel selectedProject = dialog.getSelectedProject();\n\n            new WriteCommandAction(project) {\n              @Override\n              protected void run(Result result) throws Throwable {\n                editor.getDocument().replaceString(startOffset, endOffset, replaceWith);\n                PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n                createMavenProperty(selectedProject, propertyName, selectedString);\n\n                PsiDocumentManager.getInstance(project).commitAllDocuments();\n              }\n            }.execute();\n\n            showFindUsages(project, propertyName, selectedString, replaceWith, selectedProject);\n          }\n        }\n      }\n    }","id":73814,"modified_method":"public void invoke(@NotNull final Project project, final Editor editor, PsiFile file, DataContext dataContext) {\n      if (!editor.getSelectionModel().hasSelection()) return;\n      PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n      final int startOffset = editor.getSelectionModel().getSelectionStart();\n      final int endOffset = editor.getSelectionModel().getSelectionEnd();\n\n      XmlElement selectedElement = getSelectedElement(file, startOffset, endOffset);\n\n      if (selectedElement != null) {\n        String stringValue = selectedElement.getText();\n        if (stringValue != null) {\n\n          final MavenDomProjectModel model = MavenDomUtil.getMavenDomModel(file, MavenDomProjectModel.class);\n          final String selectedString = editor.getSelectionModel().getSelectedText();\n\n          Set<TextRange> ranges = getPropertiesTextRanges(stringValue);\n          int offsetInElement = startOffset - selectedElement.getTextOffset();\n\n          if (model == null ||\n              StringUtil.isEmptyOrSpaces(selectedString) ||\n              isInsideTextRanges(ranges, offsetInElement, offsetInElement + selectedString.length())) {\n            return;\n          }\n\n          IntroducePropertyDialog dialog = new IntroducePropertyDialog(project, selectedElement, model, null, selectedString);\n          dialog.show();\n\n          if (dialog.getExitCode() == DialogWrapper.OK_EXIT_CODE) {\n            final String propertyName = dialog.getEnteredName();\n            final String replaceWith = PREFIX + propertyName + SUFFIX;\n            final MavenDomProjectModel selectedProject = dialog.getSelectedProject();\n\n            if (ReadonlyStatusHandler.getInstance(project).ensureFilesWritable(getFiles(file, selectedProject)).hasReadonlyFiles()) {\n              return;\n            }\n\n            new WriteCommandAction(project) {\n              @Override\n              protected void run(Result result) throws Throwable {\n                editor.getDocument().replaceString(startOffset, endOffset, replaceWith);\n                PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n                createMavenProperty(selectedProject, propertyName, selectedString);\n\n                PsiDocumentManager.getInstance(project).commitAllDocuments();\n              }\n            }.execute();\n\n            showFindUsages(project, propertyName, selectedString, replaceWith, selectedProject);\n          }\n        }\n      }\n    }","commit_id":"c9a7a6224057a1a69995fe22ec390bd38f7f66c3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isMyFile(@NotNull XmlFile file, final Module module) {\n    boolean isMavenFile = MavenDomUtil.isMavenFile(file);\n    boolean superResult = super.isMyFile(file, module);\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      System.out.println(\"MavenDomFileDescription.isMyFile\");\n      System.out.println(\"superResult = \" + superResult);\n      System.out.println(\"isMavenFile = \" + isMavenFile);\n    }\n    return isMavenFile && superResult;\n  }","id":73815,"modified_method":"public boolean isMyFile(@NotNull XmlFile file, final Module module) {\n    return MavenDomUtil.isMavenFile(file) && super.isMyFile(file, module);\n  }","commit_id":"2de8e9b096ab07d3a1bbd3993b504946090b3089","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     *  Fired on new messages.\n     * @param evt the <tt>MessageReceivedEvent<\/tt> containing\n     * details on the received message\n     */\n    public void messageReceived(MessageReceivedEvent evt)\n    {\n        // Fire notification\n        String title = NotificationActivator.getResources().getI18NString(\n            \"service.gui.MSG_RECEIVED\",\n            new String[]{evt.getSourceContact().getDisplayName()});\n\n        fireChatNotification(\n                evt.getSourceContact(),\n                NotificationManager.INCOMING_MESSAGE,\n                title,\n                evt.getSourceMessage().getContent());\n\n    }","id":73816,"modified_method":"/**\n     *  Fired on new messages.\n     * @param evt the <tt>MessageReceivedEvent<\/tt> containing\n     * details on the received message\n     */\n    public void messageReceived(MessageReceivedEvent evt)\n    {\n        // Fire notification\n        String title = NotificationActivator.getResources().getI18NString(\n            \"service.gui.MSG_RECEIVED\",\n            new String[]{evt.getSourceContact().getDisplayName()});\n\n        fireChatNotification(\n                evt.getSourceContact(),\n                NotificationService.INCOMING_MESSAGE,\n                title,\n                evt.getSourceMessage().getContent());\n\n    }","commit_id":"0f8966ae90fb84e38213fe3c1914ef8bbc74b215","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Indicates that the given conference member has been added to the given\n     * peer.\n     *\n     * @param conferenceEvent the event\n     */\n    public void conferenceMemberAdded(CallPeerConferenceEvent conferenceEvent)\n    {\n        CallPeer peer =\n            conferenceEvent.getConferenceMember().getConferenceFocusCallPeer();\n\n        if(peer.getConferenceMemberCount() > 0)\n        {\n            CallPeerSecurityStatusEvent securityEvent\n                = peer.getCurrentSecuritySettings();\n\n            if (securityEvent instanceof CallPeerSecurityOnEvent)\n            {\n                NotificationManager.fireNotification(\n                    NotificationManager.CALL_SECURITY_ON);\n            }\n        }\n    }","id":73817,"modified_method":"/**\n     * Indicates that the given conference member has been added to the given\n     * peer.\n     *\n     * @param conferenceEvent the event\n     */\n    public void conferenceMemberAdded(CallPeerConferenceEvent conferenceEvent)\n    {\n        CallPeer peer =\n            conferenceEvent.getConferenceMember().getConferenceFocusCallPeer();\n\n        if(peer.getConferenceMemberCount() > 0)\n        {\n            CallPeerSecurityStatusEvent securityEvent\n                = peer.getCurrentSecuritySettings();\n\n            if (securityEvent instanceof CallPeerSecurityOnEvent)\n            {\n                NotificationManager.fireNotification(\n                    NotificationService.CALL_SECURITY_ON);\n            }\n        }\n    }","commit_id":"0f8966ae90fb84e38213fe3c1914ef8bbc74b215","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Stops all telephony related sounds.\n     */\n    private static void stopAllTelephonySounds()\n    {\n        NotificationManager.stopSound(NotificationManager.DIALING);\n        NotificationManager.stopSound(NotificationManager.BUSY_CALL);\n        NotificationManager.stopSound(NotificationManager.INCOMING_CALL);\n        NotificationManager.stopSound(NotificationManager.OUTGOING_CALL);\n    }","id":73818,"modified_method":"/**\n     * Stops all telephony related sounds.\n     */\n    private static void stopAllTelephonySounds()\n    {\n        NotificationManager.stopSound(NotificationService.DIALING);\n        NotificationManager.stopSound(NotificationService.BUSY_CALL);\n        NotificationManager.stopSound(NotificationService.INCOMING_CALL);\n        NotificationManager.stopSound(NotificationService.OUTGOING_CALL);\n    }","commit_id":"0f8966ae90fb84e38213fe3c1914ef8bbc74b215","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements CallListener.callEnded. Stops sounds that are playing at\n     * the moment if there're any.\n     * @param event the <tt>CallEvent<\/tt>\n     */\n    public void callEnded(CallEvent event)\n    {\n        // Stop all telephony related sounds.\n        stopAllTelephonySounds();\n\n        // Play the hangup sound.\n        NotificationManager.fireNotification(NotificationManager.HANG_UP);\n    }","id":73819,"modified_method":"/**\n     * Implements CallListener.callEnded. Stops sounds that are playing at\n     * the moment if there're any.\n     * @param event the <tt>CallEvent<\/tt>\n     */\n    public void callEnded(CallEvent event)\n    {\n        // Stop all telephony related sounds.\n        stopAllTelephonySounds();\n\n        // Play the hangup sound.\n        NotificationManager.fireNotification(NotificationService.HANG_UP);\n    }","commit_id":"0f8966ae90fb84e38213fe3c1914ef8bbc74b215","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Fired when peer's state is changed\n     *\n     * @param evt fired CallPeerEvent\n     */\n    public void peerStateChanged(CallPeerChangeEvent evt)\n    {\n        CallPeer sourcePeer = evt.getSourceCallPeer();\n        CallPeerState newState = (CallPeerState) evt.getNewValue();\n        CallPeerState oldState = (CallPeerState) evt.getOldValue();\n\n        // Play the dialing audio when in connecting and initiating call state.\n        // Stop the dialing audio when we enter any other state.\n        if (newState == CallPeerState.INITIATING_CALL\n            || newState == CallPeerState.CONNECTING)\n        {\n            NotificationManager\n                .fireNotification(NotificationManager.DIALING);\n        }\n        else\n        {\n            NotificationManager.stopSound(NotificationManager.DIALING);\n        }\n\n        if (newState == CallPeerState.ALERTING_REMOTE_SIDE\n            //if we were already in state CONNECTING_WITH_EARLY_MEDIA the server\n            //is already taking care of playing the notifications so we don't\n            //need to fire a notification here.\n            && oldState != CallPeerState.CONNECTING_WITH_EARLY_MEDIA)\n        {\n            NotificationManager\n                .fireNotification(NotificationManager.OUTGOING_CALL);\n        }\n        else if (newState == CallPeerState.BUSY)\n        {\n            NotificationManager.stopSound(NotificationManager.OUTGOING_CALL);\n\n            // We start the busy sound only if we're in a simple call.\n            if (!isConference(sourcePeer.getCall()))\n            {\n                NotificationManager.fireNotification(\n                    NotificationManager.BUSY_CALL);\n            }\n        }\n        else if (newState == CallPeerState.CONNECTING_INCOMING_CALL ||\n            newState == CallPeerState.CONNECTING_INCOMING_CALL_WITH_MEDIA)\n        {\n            if (!CallPeerState.isOnHold(oldState))\n            {\n                NotificationManager\n                    .stopSound(NotificationManager.OUTGOING_CALL);\n                NotificationManager\n                    .stopSound(NotificationManager.INCOMING_CALL);\n            }\n        }\n        else if (newState == CallPeerState.CONNECTING_WITH_EARLY_MEDIA)\n        {\n            //this means a call with early media. make sure that we are not\n            //playing local notifications any more.\n            NotificationManager\n                .stopSound(NotificationManager.OUTGOING_CALL);\n        }\n        else if (newState == CallPeerState.CONNECTED)\n        {\n            if (!CallPeerState.isOnHold(oldState))\n            {\n                NotificationManager\n                    .stopSound(NotificationManager.OUTGOING_CALL);\n                NotificationManager\n                    .stopSound(NotificationManager.INCOMING_CALL);\n            }\n        }\n        else if (newState == CallPeerState.DISCONNECTED\n                || newState == CallPeerState.FAILED)\n        {\n            stopAllTelephonySounds();\n\n            NotificationManager.fireNotification(NotificationManager.HANG_UP);\n        }\n    }","id":73820,"modified_method":"/**\n     * Fired when peer's state is changed\n     *\n     * @param evt fired CallPeerEvent\n     */\n    public void peerStateChanged(CallPeerChangeEvent evt)\n    {\n        CallPeer sourcePeer = evt.getSourceCallPeer();\n        CallPeerState newState = (CallPeerState) evt.getNewValue();\n        CallPeerState oldState = (CallPeerState) evt.getOldValue();\n\n        // Play the dialing audio when in connecting and initiating call state.\n        // Stop the dialing audio when we enter any other state.\n        if (newState == CallPeerState.INITIATING_CALL\n            || newState == CallPeerState.CONNECTING)\n        {\n            NotificationManager\n                .fireNotification(NotificationService.DIALING);\n        }\n        else\n        {\n            NotificationManager.stopSound(NotificationService.DIALING);\n        }\n\n        if (newState == CallPeerState.ALERTING_REMOTE_SIDE\n            //if we were already in state CONNECTING_WITH_EARLY_MEDIA the server\n            //is already taking care of playing the notifications so we don't\n            //need to fire a notification here.\n            && oldState != CallPeerState.CONNECTING_WITH_EARLY_MEDIA)\n        {\n            NotificationManager\n                .fireNotification(NotificationService.OUTGOING_CALL);\n        }\n        else if (newState == CallPeerState.BUSY)\n        {\n            NotificationManager.stopSound(NotificationService.OUTGOING_CALL);\n\n            // We start the busy sound only if we're in a simple call.\n            if (!isConference(sourcePeer.getCall()))\n            {\n                NotificationManager.fireNotification(\n                    NotificationService.BUSY_CALL);\n            }\n        }\n        else if (newState == CallPeerState.CONNECTING_INCOMING_CALL ||\n            newState == CallPeerState.CONNECTING_INCOMING_CALL_WITH_MEDIA)\n        {\n            if (!CallPeerState.isOnHold(oldState))\n            {\n                NotificationManager\n                    .stopSound(NotificationService.OUTGOING_CALL);\n                NotificationManager\n                    .stopSound(NotificationService.INCOMING_CALL);\n            }\n        }\n        else if (newState == CallPeerState.CONNECTING_WITH_EARLY_MEDIA)\n        {\n            //this means a call with early media. make sure that we are not\n            //playing local notifications any more.\n            NotificationManager\n                .stopSound(NotificationService.OUTGOING_CALL);\n        }\n        else if (newState == CallPeerState.CONNECTED)\n        {\n            if (!CallPeerState.isOnHold(oldState))\n            {\n                NotificationManager\n                    .stopSound(NotificationService.OUTGOING_CALL);\n                NotificationManager\n                    .stopSound(NotificationService.INCOMING_CALL);\n            }\n        }\n        else if (newState == CallPeerState.DISCONNECTED\n                || newState == CallPeerState.FAILED)\n        {\n            stopAllTelephonySounds();\n\n            NotificationManager.fireNotification(NotificationService.HANG_UP);\n        }\n    }","commit_id":"0f8966ae90fb84e38213fe3c1914ef8bbc74b215","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * When a request has been received we show a notification.\n     *\n     * @param event <tt>FileTransferRequestEvent<\/tt>\n     * @see FileTransferListener#fileTransferRequestReceived(FileTransferRequestEvent)\n     */\n    public void fileTransferRequestReceived(FileTransferRequestEvent event)\n    {\n        IncomingFileTransferRequest request = event.getRequest();\n        Contact sourceContact = request.getSender();\n\n        //Fire notification\n        String title = NotificationActivator.getResources().getI18NString(\n            \"service.gui.FILE_RECEIVING_FROM\",\n            new String[]{sourceContact.getDisplayName()});\n\n        NotificationManager\n            .fireChatNotification(\n                sourceContact,\n                NotificationManager.INCOMING_FILE,\n                title,\n                request.getFileName());\n    }","id":73821,"modified_method":"/**\n     * When a request has been received we show a notification.\n     *\n     * @param event <tt>FileTransferRequestEvent<\/tt>\n     * @see FileTransferListener#fileTransferRequestReceived(FileTransferRequestEvent)\n     */\n    public void fileTransferRequestReceived(FileTransferRequestEvent event)\n    {\n        IncomingFileTransferRequest request = event.getRequest();\n        Contact sourceContact = request.getSender();\n\n        //Fire notification\n        String title = NotificationActivator.getResources().getI18NString(\n            \"service.gui.FILE_RECEIVING_FROM\",\n            new String[]{sourceContact.getDisplayName()});\n\n        NotificationManager\n            .fireChatNotification(\n                sourceContact,\n                NotificationService.INCOMING_FILE,\n                title,\n                request.getFileName());\n    }","commit_id":"0f8966ae90fb84e38213fe3c1914ef8bbc74b215","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Informs the user what is the typing state of his chat contacts.\n     *\n     * @param event the event containing details on the typing notification\n     */\n    public void typingNotificationReceived(TypingNotificationEvent event)\n    {\n        Contact contact = event.getSourceContact();\n\n        // check whether the current chat window shows the\n        // chat we received a typing info for and in such case don't show\n        // notifications\n        Chat chat = NotificationActivator.getUIService().getCurrentChat();\n        if(chat != null)\n        {\n            MetaContact metaContact =\n                    NotificationActivator.getUIService().getChatContact(chat);\n\n            if(metaContact != null && metaContact.containsContact(contact)\n                && chat.isChatFocused())\n            {\n                return;\n            }\n        }\n\n        long currentTime = System.currentTimeMillis();\n\n        if (this.proactiveTimer.size() > 0)\n        {\n            //first remove contacts that have been here longer than the timeout\n            //to avoid memory leaks\n            Iterator<Map.Entry<Contact, Long>> entries\n                                    = this.proactiveTimer.entrySet().iterator();\n            while (entries.hasNext())\n            {\n                Map.Entry<Contact, Long> entry = entries.next();\n                Long lastNotificationDate = entry.getValue();\n                if (lastNotificationDate.longValue() + 30000 <  currentTime)\n                {\n                    // The entry is outdated\n                    entries.remove();\n                }\n            }\n\n            // Now, check if the contact is still in the map\n            if (this.proactiveTimer.containsKey(contact))\n            {\n                // We already notified the others about this\n                return;\n            }\n        }\n\n        this.proactiveTimer.put(contact, currentTime);\n\n        NotificationManager.fireChatNotification(\n            contact,\n            NotificationManager.PROACTIVE_NOTIFICATION,\n            contact.getDisplayName(),\n            NotificationActivator.getResources()\n                .getI18NString(\"service.gui.PROACTIVE_NOTIFICATION\"));\n    }","id":73822,"modified_method":"/**\n     * Informs the user what is the typing state of his chat contacts.\n     *\n     * @param event the event containing details on the typing notification\n     */\n    public void typingNotificationReceived(TypingNotificationEvent event)\n    {\n        Contact contact = event.getSourceContact();\n\n        // check whether the current chat window shows the\n        // chat we received a typing info for and in such case don't show\n        // notifications\n        UIService uiService = NotificationActivator.getUIService();\n\n        if(uiService != null)\n        {\n            Chat chat = uiService.getCurrentChat();\n            if(chat != null)\n            {\n                MetaContact metaContact = uiService.getChatContact(chat);\n\n                if(metaContact != null && metaContact.containsContact(contact)\n                    && chat.isChatFocused())\n                {\n                    return;\n                }\n            }\n        }\n\n        long currentTime = System.currentTimeMillis();\n\n        if (this.proactiveTimer.size() > 0)\n        {\n            //first remove contacts that have been here longer than the timeout\n            //to avoid memory leaks\n            Iterator<Map.Entry<Contact, Long>> entries\n                                    = this.proactiveTimer.entrySet().iterator();\n            while (entries.hasNext())\n            {\n                Map.Entry<Contact, Long> entry = entries.next();\n                Long lastNotificationDate = entry.getValue();\n                if (lastNotificationDate.longValue() + 30000 <  currentTime)\n                {\n                    // The entry is outdated\n                    entries.remove();\n                }\n            }\n\n            // Now, check if the contact is still in the map\n            if (this.proactiveTimer.containsKey(contact))\n            {\n                // We already notified the others about this\n                return;\n            }\n        }\n\n        this.proactiveTimer.put(contact, currentTime);\n\n        NotificationManager.fireChatNotification(\n            contact,\n            NotificationService.PROACTIVE_NOTIFICATION,\n            contact.getDisplayName(),\n            NotificationActivator.getResources()\n                .getI18NString(\"service.gui.PROACTIVE_NOTIFICATION\"));\n    }","commit_id":"0f8966ae90fb84e38213fe3c1914ef8bbc74b215","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Fires a chat message notification for the given event type through the\n     * <tt>NotificationService<\/tt>.\n     *\n     * @param chatContact the chat contact to which the chat message corresponds;\n     * the chat contact could be a Contact or a ChatRoom.\n     * @param eventType the event type for which we fire a notification\n     * @param messageTitle the title of the message\n     * @param message the content of the message\n     */\n    public static void fireChatNotification(Object chatContact,\n                                            String eventType,\n                                            String messageTitle,\n                                            String message)\n    {\n        NotificationService notificationService\n            = NotificationActivator.getNotificationService();\n\n        if(notificationService == null)\n            return;\n\n        NotificationActionHandler popupActionHandler = null;\n\n        Chat chatPanel = null;\n        byte[] contactIcon = null;\n        if (chatContact instanceof Contact)\n        {\n            Contact contact = (Contact) chatContact;\n\n            chatPanel = NotificationActivator.getUIService().getChat(contact);\n\n            contactIcon = contact.getImage();\n            if(contactIcon == null)\n            {\n                contactIcon =\n                    ImageUtils.toByteArray(getImage(DEFAULT_USER_PHOTO));\n            }\n        }\n        else if (chatContact instanceof ChatRoom)\n        {\n            ChatRoom chatRoom = (ChatRoom) chatContact;\n\n            // For system rooms we don't want to send notification events.\n            if (chatRoom.isSystem())\n                return;\n\n            chatPanel = NotificationActivator.getUIService().getChat(chatRoom);\n        }\n\n        if (chatPanel != null)\n        {\n            if (eventType.equals(INCOMING_MESSAGE) && chatPanel.isChatFocused())\n            {\n                popupActionHandler = notificationService\n                        .getEventNotificationActionHandler(eventType,\n                                NotificationService.ACTION_POPUP_MESSAGE);\n\n                popupActionHandler.setEnabled(false);\n            }\n        }\n\n        notificationService.fireNotification(   eventType,\n                                                messageTitle,\n                                                message,\n                                                contactIcon,\n                                                chatContact);\n\n        if(popupActionHandler != null)\n            popupActionHandler.setEnabled(true);\n    }","id":73823,"modified_method":"/**\n     * Fires a chat message notification for the given event type through the\n     * <tt>NotificationService<\/tt>.\n     *\n     * @param chatContact the chat contact to which the chat message corresponds;\n     * the chat contact could be a Contact or a ChatRoom.\n     * @param eventType the event type for which we fire a notification\n     * @param messageTitle the title of the message\n     * @param message the content of the message\n     */\n    public static void fireChatNotification(Object chatContact,\n                                            String eventType,\n                                            String messageTitle,\n                                            String message)\n    {\n        NotificationService notificationService\n            = NotificationActivator.getNotificationService();\n\n        if(notificationService == null)\n            return;\n\n        NotificationActionHandler popupActionHandler = null;\n        UIService uiService = NotificationActivator.getUIService();\n\n        Chat chatPanel = null;\n        byte[] contactIcon = null;\n        if (chatContact instanceof Contact)\n        {\n            Contact contact = (Contact) chatContact;\n\n            if(uiService != null)\n                chatPanel = uiService.getChat(contact);\n\n            contactIcon = contact.getImage();\n            if(contactIcon == null)\n            {\n                contactIcon =\n                    ImageUtils.toByteArray(getImage(DEFAULT_USER_PHOTO));\n            }\n        }\n        else if (chatContact instanceof ChatRoom)\n        {\n            ChatRoom chatRoom = (ChatRoom) chatContact;\n\n            // For system rooms we don't want to send notification events.\n            if (chatRoom.isSystem())\n                return;\n\n            if(uiService != null)\n                chatPanel = uiService.getChat(chatRoom);\n        }\n\n        if (chatPanel != null)\n        {\n            if (eventType.equals(NotificationService.INCOMING_MESSAGE)\n                    && chatPanel.isChatFocused())\n            {\n                popupActionHandler = notificationService\n                        .getEventNotificationActionHandler(eventType,\n                                NotificationService.ACTION_POPUP_MESSAGE);\n\n                popupActionHandler.setEnabled(false);\n            }\n        }\n\n        notificationService.fireNotification(   eventType,\n                                                messageTitle,\n                                                message,\n                                                contactIcon,\n                                                chatContact);\n\n        if(popupActionHandler != null)\n            popupActionHandler.setEnabled(true);\n    }","commit_id":"0f8966ae90fb84e38213fe3c1914ef8bbc74b215","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements the <tt>AdHocChatRoomMessageListener.messageReceived<\/tt>\n     * method.\n     * <br>\n     * @param evt the <tt>AdHocChatRoomMessageReceivedEvent<\/tt> that notified\n     * us\n     */\n    public void messageReceived(AdHocChatRoomMessageReceivedEvent evt)\n    {\n        AdHocChatRoom sourceChatRoom = evt.getSourceChatRoom();\n        Contact sourceParticipant = evt.getSourceChatRoomParticipant();\n\n        // Fire notification\n        boolean fireChatNotification;\n\n        String nickname = sourceChatRoom.getName();\n        String messageContent = evt.getMessage().getContent();\n\n        fireChatNotification =\n            (nickname == null)\n                || messageContent.toLowerCase().contains(\n                        nickname.toLowerCase());\n\n        if (fireChatNotification)\n        {\n            String title\n                = NotificationActivator.getResources().getI18NString(\n                        \"service.gui.MSG_RECEIVED\",\n                        new String[] { sourceParticipant.getDisplayName() });\n\n            NotificationManager.fireChatNotification(\n                sourceChatRoom,\n                NotificationManager.INCOMING_MESSAGE,\n                title,\n                messageContent);\n        }\n    }","id":73824,"modified_method":"/**\n     * Implements the <tt>AdHocChatRoomMessageListener.messageReceived<\/tt>\n     * method.\n     * <br>\n     * @param evt the <tt>AdHocChatRoomMessageReceivedEvent<\/tt> that notified\n     * us\n     */\n    public void messageReceived(AdHocChatRoomMessageReceivedEvent evt)\n    {\n        AdHocChatRoom sourceChatRoom = evt.getSourceChatRoom();\n        Contact sourceParticipant = evt.getSourceChatRoomParticipant();\n\n        // Fire notification\n        boolean fireChatNotification;\n\n        String nickname = sourceChatRoom.getName();\n        String messageContent = evt.getMessage().getContent();\n\n        fireChatNotification =\n            (nickname == null)\n                || messageContent.toLowerCase().contains(\n                        nickname.toLowerCase());\n\n        if (fireChatNotification)\n        {\n            String title\n                = NotificationActivator.getResources().getI18NString(\n                        \"service.gui.MSG_RECEIVED\",\n                        new String[] { sourceParticipant.getDisplayName() });\n\n            NotificationManager.fireChatNotification(\n                sourceChatRoom,\n                NotificationService.INCOMING_MESSAGE,\n                title,\n                messageContent);\n        }\n    }","commit_id":"0f8966ae90fb84e38213fe3c1914ef8bbc74b215","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements the <tt>ChatRoomMessageListener.messageReceived<\/tt> method.\n     * <br>\n     * Obtains the corresponding <tt>ChatPanel<\/tt> and process the message\n     * there.\n     * @param evt the <tt>ChatRoomMessageReceivedEvent<\/tt> that notified us\n     * that a message has been received\n     */\n    public void messageReceived(ChatRoomMessageReceivedEvent evt)\n    {\n        ChatRoom sourceChatRoom = evt.getSourceChatRoom();\n        ChatRoomMember sourceMember = evt.getSourceChatRoomMember();\n\n        // Fire notification\n        boolean fireChatNotification;\n\n        String messageContent = evt.getMessage().getContent();\n\n        /*\n         * It is uncommon for IRC clients to display popup notifications for\n         * messages which are sent to public channels and which do not mention\n         * the nickname of the local user.\n         */\n        if (sourceChatRoom.isSystem()\n            || isPrivate(sourceChatRoom)\n            || (messageContent == null))\n            fireChatNotification = true;\n        else\n        {\n            String nickname = sourceChatRoom.getUserNickname();\n\n            int atIx = nickname.indexOf(\"@\");\n\n            fireChatNotification =\n                (nickname == null)\n                    || messageContent.toLowerCase().contains(\n                        nickname.toLowerCase())\n                    || ((atIx == -1)? false : messageContent.toLowerCase()\n                        .contains(nickname.substring(0, atIx).toLowerCase()));\n        }\n\n        if (fireChatNotification)\n        {\n            String title\n                = NotificationActivator.getResources().getI18NString(\n                    \"service.gui.MSG_RECEIVED\",\n                    new String[] { sourceMember.getName() });\n\n            NotificationManager.fireChatNotification(\n                    sourceChatRoom,\n                    NotificationManager.INCOMING_MESSAGE,\n                    title,\n                    messageContent);\n        }\n\n    }","id":73825,"modified_method":"/**\n     * Implements the <tt>ChatRoomMessageListener.messageReceived<\/tt> method.\n     * <br>\n     * Obtains the corresponding <tt>ChatPanel<\/tt> and process the message\n     * there.\n     * @param evt the <tt>ChatRoomMessageReceivedEvent<\/tt> that notified us\n     * that a message has been received\n     */\n    public void messageReceived(ChatRoomMessageReceivedEvent evt)\n    {\n        ChatRoom sourceChatRoom = evt.getSourceChatRoom();\n        ChatRoomMember sourceMember = evt.getSourceChatRoomMember();\n\n        // Fire notification\n        boolean fireChatNotification;\n\n        String messageContent = evt.getMessage().getContent();\n\n        /*\n         * It is uncommon for IRC clients to display popup notifications for\n         * messages which are sent to public channels and which do not mention\n         * the nickname of the local user.\n         */\n        if (sourceChatRoom.isSystem()\n            || isPrivate(sourceChatRoom)\n            || (messageContent == null))\n            fireChatNotification = true;\n        else\n        {\n            String nickname = sourceChatRoom.getUserNickname();\n\n            int atIx = -1;\n\n            if(nickname != null)\n                atIx = nickname.indexOf(\"@\");\n\n            fireChatNotification =\n                (nickname == null)\n                    || messageContent.toLowerCase().contains(\n                        nickname.toLowerCase())\n                    || ((atIx == -1)? false : messageContent.toLowerCase()\n                        .contains(nickname.substring(0, atIx).toLowerCase()));\n        }\n\n        if (fireChatNotification)\n        {\n            String title\n                = NotificationActivator.getResources().getI18NString(\n                    \"service.gui.MSG_RECEIVED\",\n                    new String[] { sourceMember.getName() });\n\n            NotificationManager.fireChatNotification(\n                    sourceChatRoom,\n                    NotificationService.INCOMING_MESSAGE,\n                    title,\n                    messageContent);\n        }\n\n    }","commit_id":"0f8966ae90fb84e38213fe3c1914ef8bbc74b215","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Notifies that a specific <tt>Recorder<\/tt> has\n     * stopped recording the media associated with it.\n     *\n     * @param recorder the <tt>Recorder<\/tt> which has stopped recording its\n     * associated media\n     */\n    public void recorderStopped(Recorder recorder)\n    {\n        NotificationManager.fireNotification(\n                NotificationManager.CALL_SAVED,\n                NotificationActivator.getResources().getI18NString(\n                        \"plugin.callrecordingconfig.CALL_SAVED\"),\n                NotificationActivator.getResources().getI18NString(\n                        \"plugin.callrecordingconfig.CALL_SAVED_TO\",\n                        new String[] { recorder.getFilename() }));\n    }","id":73826,"modified_method":"/**\n     * Notifies that a specific <tt>Recorder<\/tt> has\n     * stopped recording the media associated with it.\n     *\n     * @param recorder the <tt>Recorder<\/tt> which has stopped recording its\n     * associated media\n     */\n    public void recorderStopped(Recorder recorder)\n    {\n        NotificationManager.fireNotification(\n                NotificationService.CALL_SAVED,\n                NotificationActivator.getResources().getI18NString(\n                        \"plugin.callrecordingconfig.CALL_SAVED\"),\n                NotificationActivator.getResources().getI18NString(\n                        \"plugin.callrecordingconfig.CALL_SAVED_TO\",\n                        new String[] { recorder.getFilename() }));\n    }","commit_id":"0f8966ae90fb84e38213fe3c1914ef8bbc74b215","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Processes the received security message.\n     * @param event the event we received\n     */\n    public void securityMessageRecieved(CallPeerSecurityMessageEvent event)\n    {\n        int severity = event.getEventSeverity();\n\n        String messageTitle = null;\n\n        switch (severity)\n        {\n            // Don't play alert sound for Info or warning.\n            case CallPeerSecurityMessageEvent.INFORMATION:\n            {\n                messageTitle = NotificationActivator.getResources()\n                    .getI18NString(\"service.gui.SECURITY_INFO\");\n                break;\n            }\n            case CallPeerSecurityMessageEvent.WARNING:\n            {\n                messageTitle = NotificationActivator.getResources()\n                    .getI18NString(\"service.gui.SECURITY_WARNING\");\n                break;\n            }\n            // Alert sound indicates: security cannot established\n            case CallPeerSecurityMessageEvent.SEVERE:\n            case CallPeerSecurityMessageEvent.ERROR:\n            {\n                messageTitle = NotificationActivator.getResources()\n                    .getI18NString(\"service.gui.SECURITY_ERROR\");\n                NotificationManager.fireNotification(\n                    NotificationManager.CALL_SECURITY_ERROR);\n            }\n        }\n\n        NotificationManager.fireNotification(\n            NotificationManager.SECURITY_MESSAGE,\n            messageTitle,\n            event.getI18nMessage());\n    }","id":73827,"modified_method":"/**\n     * Processes the received security message.\n     * @param event the event we received\n     */\n    public void securityMessageRecieved(CallPeerSecurityMessageEvent event)\n    {\n        int severity = event.getEventSeverity();\n\n        String messageTitle = null;\n\n        switch (severity)\n        {\n            // Don't play alert sound for Info or warning.\n            case CallPeerSecurityMessageEvent.INFORMATION:\n            {\n                messageTitle = NotificationActivator.getResources()\n                    .getI18NString(\"service.gui.SECURITY_INFO\");\n                break;\n            }\n            case CallPeerSecurityMessageEvent.WARNING:\n            {\n                messageTitle = NotificationActivator.getResources()\n                    .getI18NString(\"service.gui.SECURITY_WARNING\");\n                break;\n            }\n            // Alert sound indicates: security cannot established\n            case CallPeerSecurityMessageEvent.SEVERE:\n            case CallPeerSecurityMessageEvent.ERROR:\n            {\n                messageTitle = NotificationActivator.getResources()\n                    .getI18NString(\"service.gui.SECURITY_ERROR\");\n                NotificationManager.fireNotification(\n                    NotificationService.CALL_SECURITY_ERROR);\n            }\n        }\n\n        NotificationManager.fireNotification(\n            NotificationService.SECURITY_MESSAGE,\n            messageTitle,\n            event.getI18nMessage());\n    }","commit_id":"0f8966ae90fb84e38213fe3c1914ef8bbc74b215","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements CallListener.incomingCallReceived. When a call is received\n     * plays the ring phone sound to the user.\n     * @param event the <tt>CallEvent<\/tt>\n     */\n    public void incomingCallReceived(CallEvent event)\n    {\n        Call call = event.getSourceCall();\n        String peerName = event.getSourceCall()\n            .getCallPeers().next().getDisplayName();\n\n        NotificationManager.fireNotification(\n                NotificationManager.INCOMING_CALL,\n                \"\",\n                NotificationActivator.getResources()\n                        .getI18NString(\"service.gui.INCOMING_CALL\",\n                                new String[]{peerName}));\n\n        call.addCallChangeListener(this);\n\n        if(call.getCallPeers().hasNext())\n        {\n            CallPeer peer = call.getCallPeers().next();\n            peer.addCallPeerListener(this);\n            peer.addCallPeerSecurityListener(this);\n            peer.addCallPeerConferenceListener(this);\n        }\n    }","id":73828,"modified_method":"/**\n     * Implements CallListener.incomingCallReceived. When a call is received\n     * plays the ring phone sound to the user.\n     * @param event the <tt>CallEvent<\/tt>\n     */\n    public void incomingCallReceived(CallEvent event)\n    {\n        Call call = event.getSourceCall();\n        String peerName = event.getSourceCall()\n            .getCallPeers().next().getDisplayName();\n\n        NotificationManager.fireNotification(\n                NotificationService.INCOMING_CALL,\n                \"\",\n                NotificationActivator.getResources()\n                        .getI18NString(\"service.gui.INCOMING_CALL\",\n                                new String[]{peerName}));\n\n        call.addCallChangeListener(this);\n\n        if(call.getCallPeers().hasNext())\n        {\n            CallPeer peer = call.getCallPeers().next();\n            peer.addCallPeerListener(this);\n            peer.addCallPeerSecurityListener(this);\n            peer.addCallPeerConferenceListener(this);\n        }\n    }","commit_id":"0f8966ae90fb84e38213fe3c1914ef8bbc74b215","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Register all default notifications.\n     */\n    private void registerDefaultNotifications()\n    {\n        NotificationService notificationService\n            = NotificationActivator.getNotificationService();\n\n        if(notificationService == null)\n            return;\n\n        // Register incoming message notifications.\n        notificationService.registerDefaultNotificationForEvent(\n                INCOMING_MESSAGE,\n                NotificationService.ACTION_POPUP_MESSAGE,\n                null,\n                null);\n\n        notificationService.registerDefaultNotificationForEvent(\n                INCOMING_MESSAGE,\n                NotificationService.ACTION_SOUND,\n                SoundProperties.INCOMING_MESSAGE,\n                null);\n\n        // Register incoming call notifications.\n        notificationService.registerDefaultNotificationForEvent(\n                INCOMING_CALL,\n                NotificationService.ACTION_POPUP_MESSAGE,\n                null,\n                null);\n\n        SoundNotificationHandler inCallSoundHandler\n            = notificationService\n                .createSoundNotificationHandler(SoundProperties.INCOMING_CALL,\n                                                2000);\n\n        notificationService.registerDefaultNotificationForEvent(\n                INCOMING_CALL,\n                NotificationService.ACTION_SOUND,\n                inCallSoundHandler);\n\n        // Register outgoing call notifications.\n        SoundNotificationHandler outCallSoundHandler\n            = notificationService\n                .createSoundNotificationHandler(SoundProperties.OUTGOING_CALL,\n                                                3000);\n\n        notificationService.registerDefaultNotificationForEvent(\n                OUTGOING_CALL,\n                NotificationService.ACTION_SOUND,\n                outCallSoundHandler);\n\n        // Register busy call notifications.\n        SoundNotificationHandler busyCallSoundHandler\n            = notificationService\n                .createSoundNotificationHandler(SoundProperties.BUSY, 1);\n\n        notificationService.registerDefaultNotificationForEvent(\n                BUSY_CALL,\n                NotificationService.ACTION_SOUND,\n                busyCallSoundHandler);\n\n        // Register dial notifications.\n        SoundNotificationHandler dialSoundHandler\n            = notificationService\n                .createSoundNotificationHandler(SoundProperties.DIALING, 0);\n\n        notificationService.registerDefaultNotificationForEvent(\n                DIALING,\n                NotificationService.ACTION_SOUND,\n                dialSoundHandler);\n\n        // Register the hangup sound notification.\n        SoundNotificationHandler hangupSoundHandler\n            = notificationService\n                .createSoundNotificationHandler(SoundProperties.HANG_UP, -1);\n\n        notificationService.registerDefaultNotificationForEvent(\n                HANG_UP,\n                NotificationService.ACTION_SOUND,\n                hangupSoundHandler);\n\n        // Register proactive notifications.\n        notificationService.registerDefaultNotificationForEvent(\n                PROACTIVE_NOTIFICATION,\n                NotificationService.ACTION_POPUP_MESSAGE,\n                null,\n                null);\n\n        // Register warning message notifications.\n        notificationService.registerDefaultNotificationForEvent(\n                SECURITY_MESSAGE,\n                NotificationService.ACTION_POPUP_MESSAGE,\n                null,\n                null);\n\n        // Register sound notification for security state on during a call.\n        notificationService.registerDefaultNotificationForEvent(\n                CALL_SECURITY_ON,\n                NotificationService.ACTION_SOUND,\n                SoundProperties.CALL_SECURITY_ON,\n                null);\n\n        // Register sound notification for security state off during a call.\n        notificationService.registerDefaultNotificationForEvent(\n                CALL_SECURITY_ERROR,\n                NotificationService.ACTION_SOUND,\n                SoundProperties.CALL_SECURITY_ERROR,\n                null);\n\n        // Register sound notification for incoming files.\n        notificationService.registerDefaultNotificationForEvent(\n                INCOMING_FILE,\n                NotificationService.ACTION_POPUP_MESSAGE,\n                null,\n                null);\n\n        notificationService.registerDefaultNotificationForEvent(\n                INCOMING_FILE,\n                NotificationService.ACTION_SOUND,\n                SoundProperties.INCOMING_FILE,\n                null);\n\n        // Register notification for saved calls.\n        notificationService.registerDefaultNotificationForEvent(\n            CALL_SAVED,\n            NotificationService.ACTION_POPUP_MESSAGE,\n            null,\n            null);\n    }","id":73829,"modified_method":"/**\n     * Register all default notifications.\n     */\n    private void registerDefaultNotifications()\n    {\n        NotificationService notificationService\n            = NotificationActivator.getNotificationService();\n\n        if(notificationService == null)\n            return;\n\n        // Register incoming message notifications.\n        notificationService.registerDefaultNotificationForEvent(\n                NotificationService.INCOMING_MESSAGE,\n                NotificationService.ACTION_POPUP_MESSAGE,\n                null,\n                null);\n\n        notificationService.registerDefaultNotificationForEvent(\n                NotificationService.INCOMING_MESSAGE,\n                NotificationService.ACTION_SOUND,\n                SoundProperties.INCOMING_MESSAGE,\n                null);\n\n        // Register incoming call notifications.\n        notificationService.registerDefaultNotificationForEvent(\n                NotificationService.INCOMING_CALL,\n                NotificationService.ACTION_POPUP_MESSAGE,\n                null,\n                null);\n\n        SoundNotificationHandler inCallSoundHandler\n            = notificationService\n                .createSoundNotificationHandler(SoundProperties.INCOMING_CALL,\n                                                2000);\n\n        notificationService.registerDefaultNotificationForEvent(\n                NotificationService.INCOMING_CALL,\n                NotificationService.ACTION_SOUND,\n                inCallSoundHandler);\n\n        // Register outgoing call notifications.\n        SoundNotificationHandler outCallSoundHandler\n            = notificationService\n                .createSoundNotificationHandler(SoundProperties.OUTGOING_CALL,\n                                                3000);\n\n        notificationService.registerDefaultNotificationForEvent(\n                NotificationService.OUTGOING_CALL,\n                NotificationService.ACTION_SOUND,\n                outCallSoundHandler);\n\n        // Register busy call notifications.\n        SoundNotificationHandler busyCallSoundHandler\n            = notificationService\n                .createSoundNotificationHandler(SoundProperties.BUSY, 1);\n\n        notificationService.registerDefaultNotificationForEvent(\n                NotificationService.BUSY_CALL,\n                NotificationService.ACTION_SOUND,\n                busyCallSoundHandler);\n\n        // Register dial notifications.\n        SoundNotificationHandler dialSoundHandler\n            = notificationService\n                .createSoundNotificationHandler(SoundProperties.DIALING, 0);\n\n        notificationService.registerDefaultNotificationForEvent(\n                NotificationService.DIALING,\n                NotificationService.ACTION_SOUND,\n                dialSoundHandler);\n\n        // Register the hangup sound notification.\n        SoundNotificationHandler hangupSoundHandler\n            = notificationService\n                .createSoundNotificationHandler(SoundProperties.HANG_UP, -1);\n\n        notificationService.registerDefaultNotificationForEvent(\n                NotificationService.HANG_UP,\n                NotificationService.ACTION_SOUND,\n                hangupSoundHandler);\n\n        // Register proactive notifications.\n        notificationService.registerDefaultNotificationForEvent(\n                NotificationService.PROACTIVE_NOTIFICATION,\n                NotificationService.ACTION_POPUP_MESSAGE,\n                null,\n                null);\n\n        // Register warning message notifications.\n        notificationService.registerDefaultNotificationForEvent(\n                NotificationService.SECURITY_MESSAGE,\n                NotificationService.ACTION_POPUP_MESSAGE,\n                null,\n                null);\n\n        // Register sound notification for security state on during a call.\n        notificationService.registerDefaultNotificationForEvent(\n                NotificationService.CALL_SECURITY_ON,\n                NotificationService.ACTION_SOUND,\n                SoundProperties.CALL_SECURITY_ON,\n                null);\n\n        // Register sound notification for security state off during a call.\n        notificationService.registerDefaultNotificationForEvent(\n                NotificationService.CALL_SECURITY_ERROR,\n                NotificationService.ACTION_SOUND,\n                SoundProperties.CALL_SECURITY_ERROR,\n                null);\n\n        // Register sound notification for incoming files.\n        notificationService.registerDefaultNotificationForEvent(\n                NotificationService.INCOMING_FILE,\n                NotificationService.ACTION_POPUP_MESSAGE,\n                null,\n                null);\n\n        notificationService.registerDefaultNotificationForEvent(\n                NotificationService.INCOMING_FILE,\n                NotificationService.ACTION_SOUND,\n                SoundProperties.INCOMING_FILE,\n                null);\n\n        // Register notification for saved calls.\n        notificationService.registerDefaultNotificationForEvent(\n            NotificationService.CALL_SAVED,\n            NotificationService.ACTION_POPUP_MESSAGE,\n            null,\n            null);\n    }","commit_id":"0f8966ae90fb84e38213fe3c1914ef8bbc74b215","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * When a <tt>securityOnEvent<\/tt> is received.\n     * @param evt the event we received\n     */\n    public void securityOn(CallPeerSecurityOnEvent evt)\n    {\n        CallPeer peer = (CallPeer) evt.getSource();\n\n        if((evt.getSecurityController().requiresSecureSignalingTransport()\n            && peer.getProtocolProvider().isSignalingTransportSecure())\n            || !evt.getSecurityController().requiresSecureSignalingTransport())\n        {\n            NotificationManager.fireNotification(\n                NotificationManager.CALL_SECURITY_ON);\n        }\n    }","id":73830,"modified_method":"/**\n     * When a <tt>securityOnEvent<\/tt> is received.\n     * @param evt the event we received\n     */\n    public void securityOn(CallPeerSecurityOnEvent evt)\n    {\n        CallPeer peer = (CallPeer) evt.getSource();\n\n        if((evt.getSecurityController().requiresSecureSignalingTransport()\n            && peer.getProtocolProvider().isSignalingTransportSecure())\n            || !evt.getSecurityController().requiresSecureSignalingTransport())\n        {\n            NotificationManager.fireNotification(\n                NotificationService.CALL_SECURITY_ON);\n        }\n    }","commit_id":"0f8966ae90fb84e38213fe3c1914ef8bbc74b215","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Publish present status. We search for the highest value in the\n     * given interval.\n     *\n     * @param protocolProvider the protocol provider to which we\n     * change the status.\n     * @param status the status to publish.\n     */\n    public void publishStatus(\n            ProtocolProviderService protocolProvider,\n            PresenceStatus status)\n    {\n        OperationSetPresence presence\n                = protocolProvider.getOperationSet(OperationSetPresence.class);\n\n        LoginManager loginManager\n            = GlobalDisplayDetailsActivator.getUIService().getLoginManager();\n        RegistrationState registrationState\n            = protocolProvider.getRegistrationState();\n\n        if (registrationState == RegistrationState.REGISTERED\n            && presence != null\n            && !presence.getPresenceStatus().equals(status))\n        {\n            if (status.isOnline())\n            {\n                new PublishPresenceStatusThread(\n                        protocolProvider,\n                        presence,\n                        status).start();\n            }\n            else\n            {\n                loginManager.setManuallyDisconnected(true);\n                LoginManager.logoff(protocolProvider);\n            }\n        }\n        else if (registrationState != RegistrationState.REGISTERED\n            && registrationState != RegistrationState.REGISTERING\n            && registrationState != RegistrationState.AUTHENTICATING\n            && status.isOnline())\n        {\n            GlobalDisplayDetailsActivator.getUIService().getLoginManager()\n                .login(protocolProvider);\n        }\n        else if (!status.isOnline()\n                && !(registrationState\n                        == RegistrationState.UNREGISTERING))\n        {\n            loginManager.setManuallyDisconnected(true);\n            LoginManager.logoff(protocolProvider);\n        }\n\n        saveStatusInformation(\n            protocolProvider,\n            status.getStatusName());\n    }","id":73831,"modified_method":"/**\n     * Publish present status. We search for the highest value in the\n     * given interval.\n     *\n     * @param protocolProvider the protocol provider to which we\n     * change the status.\n     * @param status the status to publish.\n     */\n    public void publishStatus(\n            ProtocolProviderService protocolProvider,\n            PresenceStatus status)\n    {\n        OperationSetPresence presence\n                = protocolProvider.getOperationSet(OperationSetPresence.class);\n\n        LoginManager loginManager = null;\n        UIService uiService = GlobalDisplayDetailsActivator.getUIService();\n        if(uiService != null)\n        {\n            loginManager = uiService.getLoginManager();\n        }\n\n        RegistrationState registrationState\n            = protocolProvider.getRegistrationState();\n\n        if (registrationState == RegistrationState.REGISTERED\n            && presence != null\n            && !presence.getPresenceStatus().equals(status))\n        {\n            if (status.isOnline())\n            {\n                new PublishPresenceStatusThread(\n                        protocolProvider,\n                        presence,\n                        status).start();\n            }\n            else\n            {\n                if(loginManager != null)\n                    loginManager.setManuallyDisconnected(true);\n                LoginManager.logoff(protocolProvider);\n            }\n        }\n        else if (registrationState != RegistrationState.REGISTERED\n            && registrationState != RegistrationState.REGISTERING\n            && registrationState != RegistrationState.AUTHENTICATING\n            && status.isOnline())\n        {\n            GlobalDisplayDetailsActivator.getUIService().getLoginManager()\n                .login(protocolProvider);\n        }\n        else if (!status.isOnline()\n                && !(registrationState\n                        == RegistrationState.UNREGISTERING))\n        {\n            if(loginManager != null)\n                loginManager.setManuallyDisconnected(true);\n            LoginManager.logoff(protocolProvider);\n        }\n\n        saveStatusInformation(\n            protocolProvider,\n            status.getStatusName());\n    }","commit_id":"d2a5a76a94ab5be08839feee6200f44960e8b6c9","url":"https://github.com/jitsi/jitsi"},{"original_method":"private void initGUI()\n    {\n        BorderLayout borderLayout = new BorderLayout();\n\n        this.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));\n        this.setLayout(borderLayout);\n        setPreferredSize(new Dimension(500, 300));\n        {\n            mainPanel = new JPanel();\n            this.setOpaque(false);\n            this.mainPanel.setOpaque(false);\n\n            BoxLayout boxLayout = new BoxLayout(\n                mainPanel, javax.swing.BoxLayout.Y_AXIS);\n            mainPanel.setLayout(boxLayout);\n            this.add(mainPanel, BorderLayout.NORTH);\n\n            String osName = System.getProperty(\"os.name\");\n            if (osName.startsWith(\"Windows\"))\n            {\n                autoStartCheckBox = new SIPCommCheckBox();\n                mainPanel.add(autoStartCheckBox);\n                mainPanel.add(Box.createVerticalStrut(10));\n\n                autoStartCheckBox.setText(\n                    Resources.getString(\n                        \"plugin.generalconfig.AUTO_START\",\n                        new String[]{getApplicationName()}));\n\n                initAutoStartCheckBox();\n                autoStartCheckBox.addActionListener(this);\n            }\n            {\n                groupMessagesCheckBox = new SIPCommCheckBox();\n                mainPanel.add(groupMessagesCheckBox);\n                mainPanel.add(Box.createVerticalStrut(10));\n                groupMessagesCheckBox.setText(\n                    Resources.getString(\n                        \"plugin.generalconfig.GROUP_CHAT_MESSAGES\"));\n                groupMessagesCheckBox.addActionListener(this);\n            }\n            {\n                logHistoryPanel = new JPanel();\n                logHistoryPanel.setOpaque(false);\n\n                mainPanel.add(logHistoryPanel);\n                mainPanel.add(Box.createVerticalStrut(10));\n                logHistoryPanel.setLayout(null);\n                logHistoryPanel.setPreferredSize(\n                    new java.awt.Dimension(380, 57));\n                logHistoryPanel.setAlignmentX(0.0f);\n                {\n                    logHistoryCheckBox = new SIPCommCheckBox();\n                    logHistoryPanel.add(logHistoryCheckBox);\n                    logHistoryCheckBox.setText(\n                        Resources.getString(\"plugin.generalconfig.LOG_HISTORY\"));\n                    logHistoryCheckBox.setBounds(0, 0, 200, 19);\n                    logHistoryCheckBox.addActionListener(this);\n                    logHistoryCheckBox.addChangeListener(new ChangeListener()\n                    {\n                        public void stateChanged(ChangeEvent e)\n                        {\n                            showHistoryCheckBox.setEnabled(\n                                logHistoryCheckBox.isSelected());\n                            historySizeSpinner.setEnabled(\n                                logHistoryCheckBox.isSelected());\n                        }\n                    });\n                }\n                {\n                    showHistoryCheckBox = new SIPCommCheckBox();\n                    logHistoryPanel.add(showHistoryCheckBox);\n                    showHistoryCheckBox.setText(\n                        Resources.getString(\"plugin.generalconfig.SHOW_HISTORY\"));\n                    showHistoryCheckBox.setBounds(17, 25, 140, 19);\n                    showHistoryCheckBox.addActionListener(this);\n                    showHistoryCheckBox.addChangeListener(new ChangeListener()\n                    {\n                        public void stateChanged(ChangeEvent e)\n                        {\n                            historySizeSpinner.setEnabled(\n                                showHistoryCheckBox.isSelected());\n                        }\n                    });\n                }\n                {\n                    SpinnerNumberModel historySizeSpinnerModel = \n                        new SpinnerNumberModel(0, 0, 100, 1);\n                    historySizeSpinner = new JSpinner();\n                    logHistoryPanel.add(historySizeSpinner);\n                    historySizeSpinner.setModel(historySizeSpinnerModel);\n                    historySizeSpinner.setBounds(150, 23, 47, 22);\n                    historySizeSpinnerModel.addChangeListener(\n                        new ChangeListener()\n                        {\n                            public void stateChanged(ChangeEvent e)\n                            {\n                                ConfigurationManager.setChatHistorySize(\n                                    ((Integer) historySizeSpinner\n                                        .getValue()).intValue());\n                            }\n                        });\n                }\n                {\n                    historySizeLabel = new JLabel();\n                    logHistoryPanel.add(historySizeLabel);\n                    historySizeLabel.setText(\n                        Resources.getString(\"plugin.generalconfig.HISTORY_SIZE\"));\n                    historySizeLabel.setBounds(205, 27, 220, 15);\n                }\n            }\n            {\n                sendMessagePanel = new JPanel();\n                sendMessagePanel.setOpaque(false);\n\n                BorderLayout sendMessagePanelLayout\n                    = new BorderLayout(10, 10);\n                sendMessagePanel.setLayout(sendMessagePanelLayout);\n                mainPanel.add(sendMessagePanel);\n                mainPanel.add(Box.createVerticalStrut(10));\n                sendMessagePanel.setAlignmentX(0.0f);\n                sendMessagePanel.setPreferredSize(\n                    new java.awt.Dimension(380, 22));\n                {\n                    sendMessageLabel = new JLabel();\n                    sendMessagePanel.add(\n                        sendMessageLabel, BorderLayout.WEST);\n                    sendMessageLabel.setText(\n                        Resources.getString(\"plugin.generalconfig.SEND_MESSAGES_WITH\"));\n                }\n                {\n                    ComboBoxModel sendMessageComboBoxModel = \n                        new DefaultComboBoxModel(\n                            new String[] {\n                                ConfigurationManager.ENTER_COMMAND,\n                                ConfigurationManager.CTRL_ENTER_COMMAND });\n                    sendMessageComboBox = new JComboBox();\n                    sendMessagePanel.add(\n                        sendMessageComboBox, BorderLayout.CENTER);\n                    sendMessageComboBox.setModel(sendMessageComboBoxModel);\n                    sendMessageComboBox.addItemListener(new ItemListener()\n                    {\n                        public void itemStateChanged(ItemEvent arg0)\n                        {\n                            ConfigurationManager.setSendMessageCommand(\n                                (String)sendMessageComboBox.getSelectedItem());\n                        }\n                    });\n                }\n            }\n            {\n                enableTypingNotifiCheckBox = new SIPCommCheckBox();\n                enableTypingNotifiCheckBox.setLayout(null);\n                mainPanel.add(enableTypingNotifiCheckBox);\n                mainPanel.add(Box.createVerticalStrut(10));\n                enableTypingNotifiCheckBox.setText(\n                    Resources.getString(\"service.gui.ENABLE_TYPING_NOTIFICATIONS\"));\n                enableTypingNotifiCheckBox.setPreferredSize(\n                    new java.awt.Dimension(253, 20));\n                enableTypingNotifiCheckBox.setAlignmentY(0.0f);\n                enableTypingNotifiCheckBox.addActionListener(this);\n            }\n            {\n                bringToFrontCheckBox = new SIPCommCheckBox();\n                mainPanel.add(bringToFrontCheckBox);\n                mainPanel.add(Box.createVerticalStrut(10));\n                bringToFrontCheckBox.setText(\n                    Resources.getString(\"plugin.generalconfig.BRING_WINDOW_TO_FRONT\"));\n                bringToFrontCheckBox.addActionListener(this);\n            }\n//            {\n//                JPanel transparencyPanel = new JPanel();\n//                BorderLayout transparencyPanelLayout\n//                    = new BorderLayout(10, 10);\n//                transparencyPanel.setLayout(transparencyPanelLayout);\n//                mainPanel.add(transparencyPanel);\n//                mainPanel.add(Box.createVerticalStrut(10));\n//                transparencyPanel.setAlignmentX(0.0f);\n//                transparencyPanel.setPreferredSize(\n//                    new java.awt.Dimension(380, 60));\n//                {\n//                    final JCheckBox enableTransparencyCheckBox\n//                        = new JCheckBox(\n//                            Resources.getString(\"plugin.generalconfig.ENABLE_TRANSPARENCY\"),\n//                            ConfigurationManager.isTransparentWindowEnabled());\n//                    transparencyPanel.add(\n//                        enableTransparencyCheckBox, BorderLayout.NORTH);\n//\n//                    enableTransparencyCheckBox.addChangeListener(\n//                        new ChangeListener()\n//                    {\n//                        public void stateChanged(ChangeEvent e)\n//                        {\n//                            ConfigurationManager.setTransparentWindowEnabled(\n//                                enableTransparencyCheckBox.isSelected());\n//                        }\n//                    });\n//\n//                }\n//                {\n//                    JLabel transparencyLabel = new JLabel(\n//                        Resources.getString(\"plugin.generalconfig.TRANSPARENCY\"));\n//\n//                    transparencyPanel.add(  transparencyLabel,\n//                                            BorderLayout.WEST);\n//                }\n//                {\n//                    final JSlider transparencySlider\n//                        = new JSlider(0, 255,\n//                            ConfigurationManager.getWindowTransparency());\n//\n//                    transparencyPanel.add(  transparencySlider,\n//                                            BorderLayout.CENTER);\n//\n//                    transparencySlider.addChangeListener(new ChangeListener()\n//                    {\n//                        public void stateChanged(ChangeEvent e)\n//                        {\n//                            int value = transparencySlider.getValue();\n//                            ConfigurationManager.setWindowTransparency(value);\n//                        }\n//                    });\n//                }\n//            }\n        }\n    }","id":73832,"modified_method":"private void initGUI()\n    {\n        BorderLayout borderLayout = new BorderLayout();\n\n        this.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));\n        this.setLayout(borderLayout);\n        setPreferredSize(new Dimension(500, 300));\n        {\n            mainPanel = new JPanel();\n            this.setOpaque(false);\n            this.mainPanel.setOpaque(false);\n\n            BoxLayout boxLayout = new BoxLayout(\n                mainPanel, javax.swing.BoxLayout.Y_AXIS);\n            mainPanel.setLayout(boxLayout);\n            this.add(mainPanel, BorderLayout.NORTH);\n\n            String osName = System.getProperty(\"os.name\");\n            if (osName.startsWith(\"Windows\"))\n            {\n                autoStartCheckBox = new SIPCommCheckBox();\n                mainPanel.add(autoStartCheckBox);\n                mainPanel.add(Box.createVerticalStrut(10));\n\n                autoStartCheckBox.setText(\n                    Resources.getString(\n                        \"plugin.generalconfig.AUTO_START\",\n                        new String[]{getApplicationName()}));\n\n                initAutoStartCheckBox();\n                autoStartCheckBox.addActionListener(this);\n            }\n            {\n                groupMessagesCheckBox = new SIPCommCheckBox();\n                mainPanel.add(groupMessagesCheckBox);\n                mainPanel.add(Box.createVerticalStrut(10));\n                groupMessagesCheckBox.setText(\n                    Resources.getString(\n                        \"plugin.generalconfig.GROUP_CHAT_MESSAGES\"));\n                groupMessagesCheckBox.addActionListener(this);\n            }\n            {\n                logHistoryPanel = new JPanel();\n                logHistoryPanel.setOpaque(false);\n\n                mainPanel.add(logHistoryPanel);\n                mainPanel.add(Box.createVerticalStrut(10));\n                logHistoryPanel.setLayout(null);\n                logHistoryPanel.setPreferredSize(\n                    new java.awt.Dimension(380, 57));\n                logHistoryPanel.setAlignmentX(0.0f);\n                {\n                    logHistoryCheckBox = new SIPCommCheckBox();\n                    logHistoryPanel.add(logHistoryCheckBox);\n                    logHistoryCheckBox.setText(\n                        Resources.getString(\"plugin.generalconfig.LOG_HISTORY\"));\n                    logHistoryCheckBox.setBounds(0, 0, 200, 19);\n                    logHistoryCheckBox.addActionListener(this);\n                    logHistoryCheckBox.addChangeListener(new ChangeListener()\n                    {\n                        public void stateChanged(ChangeEvent e)\n                        {\n                            showHistoryCheckBox.setEnabled(\n                                logHistoryCheckBox.isSelected());\n                            historySizeSpinner.setEnabled(\n                                logHistoryCheckBox.isSelected());\n                        }\n                    });\n                }\n                {\n                    showHistoryCheckBox = new SIPCommCheckBox();\n                    logHistoryPanel.add(showHistoryCheckBox);\n                    showHistoryCheckBox.setText(\n                        Resources.getString(\"plugin.generalconfig.SHOW_HISTORY\"));\n                    showHistoryCheckBox.setBounds(17, 25, 140, 19);\n                    showHistoryCheckBox.addActionListener(this);\n                    showHistoryCheckBox.addChangeListener(new ChangeListener()\n                    {\n                        public void stateChanged(ChangeEvent e)\n                        {\n                            historySizeSpinner.setEnabled(\n                                showHistoryCheckBox.isSelected());\n                        }\n                    });\n                }\n                {\n                    SpinnerNumberModel historySizeSpinnerModel = \n                        new SpinnerNumberModel(0, 0, 100, 1);\n                    historySizeSpinner = new JSpinner();\n                    logHistoryPanel.add(historySizeSpinner);\n                    historySizeSpinner.setModel(historySizeSpinnerModel);\n                    historySizeSpinner.setBounds(150, 23, 47, 22);\n                    historySizeSpinnerModel.addChangeListener(\n                        new ChangeListener()\n                        {\n                            public void stateChanged(ChangeEvent e)\n                            {\n                                ConfigurationManager.setChatHistorySize(\n                                    ((Integer) historySizeSpinner\n                                        .getValue()).intValue());\n                            }\n                        });\n                }\n                {\n                    historySizeLabel = new JLabel();\n                    logHistoryPanel.add(historySizeLabel);\n                    historySizeLabel.setText(\n                        Resources.getString(\"plugin.generalconfig.HISTORY_SIZE\"));\n                    historySizeLabel.setBounds(205, 27, 220, 15);\n                }\n            }\n            {\n                sendMessagePanel = new JPanel();\n                sendMessagePanel.setOpaque(false);\n\n                BorderLayout sendMessagePanelLayout\n                    = new BorderLayout(10, 10);\n                sendMessagePanel.setLayout(sendMessagePanelLayout);\n                mainPanel.add(sendMessagePanel);\n                mainPanel.add(Box.createVerticalStrut(10));\n                sendMessagePanel.setAlignmentX(0.0f);\n                sendMessagePanel.setPreferredSize(\n                    new java.awt.Dimension(380, 22));\n                {\n                    sendMessageLabel = new JLabel();\n                    sendMessagePanel.add(\n                        sendMessageLabel, BorderLayout.WEST);\n                    sendMessageLabel.setText(\n                        Resources.getString(\"plugin.generalconfig.SEND_MESSAGES_WITH\"));\n                }\n                {\n                    ComboBoxModel sendMessageComboBoxModel = \n                        new DefaultComboBoxModel(\n                            new String[] {\n                                ConfigurationManager.ENTER_COMMAND,\n                                ConfigurationManager.CTRL_ENTER_COMMAND });\n                    sendMessageComboBox = new JComboBox();\n                    sendMessagePanel.add(\n                        sendMessageComboBox, BorderLayout.CENTER);\n                    sendMessageComboBox.setModel(sendMessageComboBoxModel);\n                    sendMessageComboBox.addItemListener(new ItemListener()\n                    {\n                        public void itemStateChanged(ItemEvent arg0)\n                        {\n                            ConfigurationManager.setSendMessageCommand(\n                                (String)sendMessageComboBox.getSelectedItem());\n                        }\n                    });\n                }\n            }\n            {\n                enableTypingNotifiCheckBox = new SIPCommCheckBox();\n                enableTypingNotifiCheckBox.setLayout(null);\n                mainPanel.add(enableTypingNotifiCheckBox);\n                mainPanel.add(Box.createVerticalStrut(10));\n                enableTypingNotifiCheckBox.setText(\n                    Resources.getString(\"service.gui.ENABLE_TYPING_NOTIFICATIONS\"));\n                enableTypingNotifiCheckBox.setPreferredSize(\n                    new java.awt.Dimension(253, 20));\n                enableTypingNotifiCheckBox.setAlignmentY(0.0f);\n                enableTypingNotifiCheckBox.addActionListener(this);\n            }\n            {\n                bringToFrontCheckBox = new SIPCommCheckBox();\n                mainPanel.add(bringToFrontCheckBox);\n                mainPanel.add(Box.createVerticalStrut(10));\n                bringToFrontCheckBox.setText(\n                    Resources.getString(\"plugin.generalconfig.BRING_WINDOW_TO_FRONT\"));\n                bringToFrontCheckBox.addActionListener(this);\n            }\n            {\n                ServiceReference[] handlerRefs = null;\n                BundleContext bc = GeneralConfigPluginActivator.bundleContext;\n                try\n                {\n                    handlerRefs = bc.getServiceReferences(\n                        PopupMessageHandler.class.getName(),\n                        null);\n                }\n                catch (InvalidSyntaxException ex)\n                {\n                    logger.warn(\"Error while retrieving service refs\", ex);\n                }\n                // user has choice only if there is more than one handler\n                if ((handlerRefs != null) && (handlerRefs.length > 1))\n                {\n                    notifConfigPanel = new JPanel();\n                    notifConfigPanel.setOpaque(false);\n                    notifConfigPanel.setLayout(new BorderLayout(10, 10));\n                    notifConfigPanel.setAlignmentX(0.0f);\n                    notifConfigPanel.setPreferredSize(\n                        new java.awt.Dimension(380, 22));\n\n                    mainPanel.add(notifConfigPanel);\n                    mainPanel.add(Box.createVerticalStrut(10));\n                    {\n                        notifConfigLabel = new JLabel(\n                            Resources.getString(\n                            \"plugin.notificationconfig.POPUP_NOTIF_HANDLER\"));\n                        notifConfigPanel.add(\n                            notifConfigLabel, BorderLayout.WEST);\n                    }\n                    {\n                        notifConfigComboBox = new JComboBox();\n\n                        String currentConfig =\n                                ConfigurationManager.getPopupHandlerConfig();\n                        for (int i = 0; i < handlerRefs.length; i++)\n                        {\n                            PopupMessageHandler handler =\n                                (PopupMessageHandler) bc.getService(\n                                handlerRefs[i]);\n\n                            notifConfigComboBox.addItem(handler);\n\n                            String handlerName = handler.getClass().getName();\n                            \n                            if (handlerName.equals(currentConfig))\n                                notifConfigComboBox.setSelectedItem(handler);\n                        }\n\n                        notifConfigComboBox.addItemListener(new ItemListener()\n                        {\n                            public void itemStateChanged(ItemEvent evt)\n                            {\n                                PopupMessageHandler handler =\n                                    (PopupMessageHandler)\n                                    notifConfigComboBox.getSelectedItem();\n                                ConfigurationManager.setPopupHandlerConfig(\n                                    handler.getClass().getName());\n                                GeneralConfigPluginActivator.getSystrayService()\n                                    .setActivePopupMessageHandler(handler);\n                            }\n                        });\n                        notifConfigPanel.add(\n                            notifConfigComboBox, BorderLayout.CENTER);\n                    }\n                }\n            }\n//            {\n//                JPanel transparencyPanel = new JPanel();\n//                BorderLayout transparencyPanelLayout\n//                    = new BorderLayout(10, 10);\n//                transparencyPanel.setLayout(transparencyPanelLayout);\n//                mainPanel.add(transparencyPanel);\n//                mainPanel.add(Box.createVerticalStrut(10));\n//                transparencyPanel.setAlignmentX(0.0f);\n//                transparencyPanel.setPreferredSize(\n//                    new java.awt.Dimension(380, 60));\n//                {\n//                    final JCheckBox enableTransparencyCheckBox\n//                        = new JCheckBox(\n//                            Resources.getString(\"plugin.generalconfig.ENABLE_TRANSPARENCY\"),\n//                            ConfigurationManager.isTransparentWindowEnabled());\n//                    transparencyPanel.add(\n//                        enableTransparencyCheckBox, BorderLayout.NORTH);\n//\n//                    enableTransparencyCheckBox.addChangeListener(\n//                        new ChangeListener()\n//                    {\n//                        public void stateChanged(ChangeEvent e)\n//                        {\n//                            ConfigurationManager.setTransparentWindowEnabled(\n//                                enableTransparencyCheckBox.isSelected());\n//                        }\n//                    });\n//\n//                }\n//                {\n//                    JLabel transparencyLabel = new JLabel(\n//                        Resources.getString(\"plugin.generalconfig.TRANSPARENCY\"));\n//\n//                    transparencyPanel.add(  transparencyLabel,\n//                                            BorderLayout.WEST);\n//                }\n//                {\n//                    final JSlider transparencySlider\n//                        = new JSlider(0, 255,\n//                            ConfigurationManager.getWindowTransparency());\n//\n//                    transparencyPanel.add(  transparencySlider,\n//                                            BorderLayout.CENTER);\n//\n//                    transparencySlider.addChangeListener(new ChangeListener()\n//                    {\n//                        public void stateChanged(ChangeEvent e)\n//                        {\n//                            int value = transparencySlider.getValue();\n//                            ConfigurationManager.setWindowTransparency(value);\n//                        }\n//                    });\n//                }\n//            }\n        }\n    }","commit_id":"2d812827220778a947e1577f4018fd022ba36a0a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initialize and start Growl Notifications Service\n     *\n     * @param bundleContext BundleContext\n     * @throws Exception\n     */\n    public void start(BundleContext bundleContext) throws Exception\n    {\n        /* Check Java version: do not start if Java 6 */\n        /* Actually, this plugin uses the Growl Java bindings which \n         * in turn uses the Cocoa Java bridge. Java 6 on Mac OS X is \n         * 64-bit only (as of 01/2008), and the Cocoa-Java bridge \n         * will certainly never get any 64-bit support (it has been\n         * deprecated). \n         */\n        String version = System.getProperty(\"java.version\");\n        char minor = version.charAt(2);\n        if(minor > '5') {\n            logger.info(\"Growl Notification Plugin cannot be started \" +\n                        \"on JDK version \" + version);\n        } else {\n            /* Create and start the Growl Notification service. */\n            new GrowlNotificationServiceImpl().start(bundleContext);\n\n            logger.info(\"Growl Notification Plugin ...[Started]\");\n        }\n    }","id":73833,"modified_method":"/**\n     * Initialize and start Growl Notifications Service\n     *\n     * @param bundleContext BundleContext\n     * @throws Exception\n     */\n    public void start(BundleContext bc) throws Exception\n    {\n        /* Check Java version: do not start if Java 6 */\n        /* Actually, this plugin uses the Growl Java bindings which \n         * in turn uses the Cocoa Java bridge. Java 6 on Mac OS X is \n         * 64-bit only (as of 01/2008), and the Cocoa-Java bridge \n         * will certainly never get any 64-bit support (it has been\n         * deprecated). \n         */\n        String version = System.getProperty(\"java.version\");\n        char minor = version.charAt(2);\n        if(minor > '5') {\n            logger.info(\"Growl Notification Plugin cannot be started \" +\n                        \"on JDK version \" + version);\n        } else {\n            /* Create and start the Growl Notification service. */\n            new GrowlNotificationServiceImpl().start(bundleContext);\n\n            logger.info(\"Growl Notification Plugin ...[Started]\");\n        }\n        bundleContext  = bc;\n    }","commit_id":"2d812827220778a947e1577f4018fd022ba36a0a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * starts the service. Creates a Growl notifier, and check the current\n     * registerd protocol providers which supports BasicIM and adds message\n     * listener to them.\n     *\n     * @param bc a currently valid bundle context\n     * @throws java.lang.Exception if we fail initializing the growl notifier.\n     */\n    public void start(BundleContext bc)\n        throws Exception\n    {\n        logger.debug(\"Starting the Growl Notification implementation.\");\n        this.bundleContext = bc;\n\n        /* Register to Growl */\n        try\n        {\n            Constructor<Growl> constructor = Growl.class.getConstructor(\n                    new Class[] { String.class, String.class });\n            notifier = constructor.newInstance(\n                    new Object[]{\"SIP Communicator\", sipIconPath});\n\n            //init the setAllowedNotifications method\n            setAllowedNotifMethod = Growl.class.getMethod(\n                    \"setAllowedNotifications\"\n                    , new Class[]{String[].class});\n\n            //init the setDefaultNotifications method\n            setDefaultNotifMethod = Growl.class.getMethod(\n                    \"setDefaultNotifications\"\n                    , new Class[]{String[].class});\n\n            //init the notifyGrowlOf method\n            notifyMethod = Growl.class.getMethod(\n                    \"notifyGrowlOf\"\n                    , new Class[]{String.class, String.class, \n                                  String.class, String.class});\n\n            setAllowedNotifications(allNotif);\n            setDefaultNotifications(defaultNotif);\n            notifier.register();\n\n            notifyGrowlOf(\"SIP Communicator Started\"\n                          , sipIconPath\n                          , \"Welcome to SIP Communicator\"\n                          , \"http://www.sip-communicator.org\");\n        }\n        catch (Exception ex)\n        {\n            logger.error(\"Could not send the message to Growl\", ex);\n            throw ex;\n        }\n\n        /* Start listening for newly register or removed protocol providers */\n        bc.addServiceListener(this);\n\n        ServiceReference[] protocolProviderRefs = null;\n        try\n        {\n            protocolProviderRefs = bc.getServiceReferences(\n                ProtocolProviderService.class.getName(),\n                null);\n        }\n        catch (InvalidSyntaxException ex)\n        {\n            // this shouldn't happen since we're providing no parameter string\n            // but let's log just in case.\n            logger.error(\"Error while retrieving service refs\", ex);\n            return;\n        }\n\n        // in case we found any\n        if (protocolProviderRefs != null)\n        {\n            logger.debug(\"Found \"\n                            + protocolProviderRefs.length\n                            + \" already installed providers.\");\n            for (int i = 0; i < protocolProviderRefs.length; i++)\n            {\n                ProtocolProviderService provider = (ProtocolProviderService) bc\n                    .getService(protocolProviderRefs[i]);\n\n                this.handleProviderAdded(provider);\n            }\n        }\n    }","id":73834,"modified_method":"/**\n     * starts the service. Creates a Growl notifier, and check the current\n     * registerd protocol providers which supports BasicIM and adds message\n     * listener to them.\n     *\n     * @param bc a currently valid bundle context\n     * @throws java.lang.Exception if we fail initializing the growl notifier.\n     */\n    public void start(BundleContext bc)\n        throws Exception\n    {\n        logger.debug(\"Starting the Growl Notification implementation.\");\n\n        /* Register to Growl */\n        try\n        {\n            Constructor<Growl> constructor = Growl.class.getConstructor(\n                    new Class[] { String.class, String.class });\n            notifier = constructor.newInstance(\n                    new Object[]{\"SIP Communicator\", sipIconPath});\n\n            //init the setAllowedNotifications method\n            setAllowedNotifMethod = Growl.class.getMethod(\n                    \"setAllowedNotifications\"\n                    , new Class[]{String[].class});\n\n            //init the setDefaultNotifications method\n            setDefaultNotifMethod = Growl.class.getMethod(\n                    \"setDefaultNotifications\"\n                    , new Class[]{String[].class});\n\n            //init the notifyGrowlOf method\n            notifyMethod = Growl.class.getMethod(\n                    \"notifyGrowlOf\"\n                    , new Class[]{String.class, String.class, \n                                  String.class, String.class});\n\n            setAllowedNotifications(allNotif);\n            setDefaultNotifications(defaultNotif);\n            notifier.register();\n\n            notifyGrowlOf(\"SIP Communicator Started\"\n                          , sipIconPath\n                          , \"Welcome to SIP Communicator\"\n                          , \"http://www.sip-communicator.org\");\n        }\n        catch (Exception ex)\n        {\n            logger.error(\"Could not send the message to Growl\", ex);\n            throw ex;\n        }\n\n        bc.registerService(PopupMessageHandler.class.getName(), this, null);\n    }","commit_id":"2d812827220778a947e1577f4018fd022ba36a0a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * stops the service.\n     *\n     * @param bc BundleContext\n     */\n    public void stop(BundleContext bc)\n    {\n        // start listening for newly register or removed protocol providers\n        bc.removeServiceListener(this);\n\n        ServiceReference[] protocolProviderRefs = null;\n        try\n        {\n            protocolProviderRefs = bc.getServiceReferences(\n                ProtocolProviderService.class.getName(),\n                null);\n        }\n        catch (InvalidSyntaxException ex)\n        {\n            // this shouldn't happen since we're providing no parameter string\n            // but let's log just in case.\n            logger.error(\n                \"Error while retrieving service refs\", ex);\n            return;\n        }\n\n        // in case we found any\n        if (protocolProviderRefs != null)\n        {\n            for (int i = 0; i < protocolProviderRefs.length; i++)\n            {\n                ProtocolProviderService provider = (ProtocolProviderService) bc\n                    .getService(protocolProviderRefs[i]);\n\n                this.handleProviderRemoved(provider);\n            }\n        }\n    }","id":73835,"modified_method":"/**\n     * stops the service.\n     *\n     * @param bc BundleContext\n     */\n    public void stop(BundleContext bc)\n    {\n    }","commit_id":"2d812827220778a947e1577f4018fd022ba36a0a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * If there is a registered event notification of the given\n     * <tt>eventType<\/tt> and the event notification is currently activated, we\n     * go through the list of registered actions and execute them.\n     * \n     * @param eventType the type of the event that we'd like to fire a\n     * notification for.\n     * @param title the title of the given message\n     * @param message the message to use if and where appropriate (e.g. with\n     * systray or log notification.)\n     */\n    public void fireNotification(String eventType, String title, String message)\n    {\n        EventNotification notification\n            = (EventNotification) notificationsTable.get(eventType);\n        \n        if(notification == null || !notification.isActive())\n            return;\n        \n        Iterator actions = notification.getActions().values().iterator();\n\n        while(actions.hasNext())\n        {\n            Action action = (Action) actions.next();\n            \n            String actionType = action.getActionType();\n\n            NotificationActionHandler handler = action.getActionHandler();\n\n            if (!handler.isEnabled())\n                continue;\n\n            if (actionType.equals(NotificationService.ACTION_POPUP_MESSAGE))\n            {\n                ((PopupMessageNotificationHandler) handler)\n                    .popupMessage(title, message);\n            }\n            else if (actionType.equals(NotificationService.ACTION_LOG_MESSAGE))\n            {\n                ((LogMessageNotificationHandler) handler)\n                    .logMessage(message);\n            }\n            else if (actionType.equals(NotificationService.ACTION_SOUND))\n            {\n                ((SoundNotificationHandler) handler)\n                    .start();\n            }\n            else if (actionType.equals(NotificationService.ACTION_COMMAND))\n            {\n                ((CommandNotificationHandler) handler)\n                    .execute();\n            }\n        }\n    }","id":73836,"modified_method":"/**\n     * If there is a registered event notification of the given\n     * <tt>eventType<\/tt> and the event notification is currently activated, we\n     * go through the list of registered actions and execute them.\n     * \n     * @param eventType the type of the event that we'd like to fire a\n     * notification for.\n     * @param title the title of the given message\n     * @param message the message to use if and where appropriate (e.g. with\n     * systray or log notification.)\n     */\n    public void fireNotification(String eventType, String title, String message)\n    {\n        EventNotification notification\n            = (EventNotification) notificationsTable.get(eventType);\n        \n        if(notification == null || !notification.isActive())\n            return;\n        \n        Iterator actions = notification.getActions().values().iterator();\n\n        while(actions.hasNext())\n        {\n            Action action = (Action) actions.next();\n            \n            String actionType = action.getActionType();\n\n            NotificationActionHandler handler = action.getActionHandler();\n\n            if ((handler == null) || !handler.isEnabled())\n                continue;\n\n            if (actionType.equals(NotificationService.ACTION_POPUP_MESSAGE))\n            {\n                ((PopupMessageNotificationHandler) handler)\n                    .popupMessage(new PopupMessage(title, message));\n            }\n            else if (actionType.equals(NotificationService.ACTION_LOG_MESSAGE))\n            {\n                ((LogMessageNotificationHandler) handler)\n                    .logMessage(message);\n            }\n            else if (actionType.equals(NotificationService.ACTION_SOUND))\n            {\n                ((SoundNotificationHandler) handler)\n                    .start();\n            }\n            else if (actionType.equals(NotificationService.ACTION_COMMAND))\n            {\n                ((CommandNotificationHandler) handler)\n                    .execute();\n            }\n        }\n    }","commit_id":"2d812827220778a947e1577f4018fd022ba36a0a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Shows a popup message through the <tt>SystrayService<\/tt>.\n     * \n     * @param title the title of the popup\n     * @param message the message to show in the popup\n     */\n    public void popupMessage(String title, String message)\n    {\n        SystrayService systray = NotificationActivator.getSystray();\n        \n        if(systray == null)\n            return;\n        \n        systray.showPopupMessage(title, message,\n            SystrayService.NONE_MESSAGE_TYPE);\n    }","id":73837,"modified_method":"/**\n     * Shows a popup message through the <tt>SystrayService<\/tt>.\n     *\n     * @param message the message to show in the popup\n     */\n    public void popupMessage(PopupMessage message)\n    {\n        SystrayService systray = NotificationActivator.getSystray();\n\n        if(systray == null)\n            return;\n\n        systray.showPopupMessage(message);\n    }","commit_id":"2d812827220778a947e1577f4018fd022ba36a0a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the <tt>UIService<\/tt> obtained from the bundle\n     * context.\n     * @return the <tt>UIService<\/tt> obtained from the bundle\n     * context\n     */\n    public static UIService getUIService()\n    {\n        if(uiService == null)\n        {\n            ServiceReference serviceRef = bundleContext\n                .getServiceReference(UIService.class.getName());\n\n            uiService = (UIService) bundleContext\n                .getService(serviceRef);\n        }\n\n        return uiService;\n    }","id":73838,"modified_method":"/**\n     * Returns the <tt>UIService<\/tt> obtained from the bundle\n     * context.\n     * @return the <tt>UIService<\/tt> obtained from the bundle\n     * context\n     */\n    public static UIService getUIService()\n    {\n        if(uiService == null)\n        {\n            ServiceReference serviceRef = bundleContext\n                .getServiceReference(UIService.class.getName());\n\n            if (serviceRef != null)\n                uiService = (UIService) bundleContext.getService(serviceRef);\n        }\n\n        return uiService;\n    }","commit_id":"2d812827220778a947e1577f4018fd022ba36a0a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements the <tt>SystrayService.addPopupMessageListener<\/tt> method.\n     *\n     * @param listener the listener to add\n     */\n    public void addPopupMessageListener(SystrayPopupMessageListener listener)\n    {\n        synchronized (popupMessageListeners)\n        {\n            this.popupMessageListeners.add(listener);\n        }\n    }","id":73839,"modified_method":"/**\n     * Implements the <tt>SystrayService.addPopupMessageListener<\/tt> method.\n     *\n     * @param listener the listener to add\n     */\n    public void addPopupMessageListener(SystrayPopupMessageListener listener)\n    {\n        if (activePopupHandler != null)\n            activePopupHandler.addPopupMessageListener(listener);\n    }","commit_id":"2d812827220778a947e1577f4018fd022ba36a0a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes the systray icon and related listeners.\n     */\n    private void initSystray()\n    {\n        popupTimer.scheduleAtFixedRate(new ShowPopupTask(), 0, messageDelay);\n\n        // Get the system's double click speed\n        Object o = Toolkit.getDefaultToolkit().getDesktopProperty(\n                \"awt.multiClickInterval\");\n        final int doubleClickSpeed = (o instanceof Integer ? ((Integer) o)\n                .intValue() : 500);\n\n        menu = TrayMenuFactory.createTrayMenu(this, systray.isSwing());\n\n        String osName = System.getProperty(\"os.name\");\n        // If we're running under Windows, we use a special icon without\n        // background.\n        if (osName.startsWith(\"Windows\"))\n        {\n            logoIcon\n                = Resources.getImage(\"service.systray.TRAY_ICON_WINDOWS\");\n            logoIconOffline\n                = Resources.getImage(\"service.systray.TRAY_ICON_WINDOWS_OFFLINE\");\n            logoIconAway\n                = Resources.getImage(\"service.systray.TRAY_ICON_WINDOWS_AWAY\");\n            logoIconFFC\n                = Resources.getImage(\"service.systray.TRAY_ICON_WINDOWS_FFC\");\n            envelopeIcon\n                = Resources.getImage(\"service.systray.MESSAGE_ICON_WINDOWS\");\n        }\n\n        // If we're running under MacOSX, we use a special black and\n        // white icons without background.\n        else if (osName.startsWith(\"Mac OS X\"))\n        {\n            logoIcon\n                = Resources.getImage(\"service.systray.TRAY_ICON_MACOSX\");\n            logoIconWhite\n                = Resources.getImage(\"service.systray.TRAY_ICON_MACOSX_WHITE\");\n            envelopeIcon\n                = Resources.getImage(\"service.systray.MESSAGE_ICON_MACOSX\");\n            envelopeIconWhite\n                = Resources.getImage(\"service.systray.MESSAGE_ICON_MACOSX_WHITE\");\n        }\n        else\n        {\n            logoIcon = Resources.getImage(\"service.systray.TRAY_ICON\");\n            logoIconOffline = Resources.getImage(\"service.systray.TRAY_ICON_OFFLINE\");\n            logoIconAway = Resources.getImage(\"service.systray.TRAY_ICON_AWAY\");\n            logoIconFFC = Resources.getImage(\"service.systray.TRAY_ICON_FFC\");\n            envelopeIcon = Resources.getImage(\"service.systray.MESSAGE_ICON\");\n        }\n\n        if (!osName.startsWith(\"Mac OS X\"))\n        {\n            // default to set offline , if any protocols become\n            // online will set it to online\n            currentIcon = logoIconOffline;\n        }\n        else\n            currentIcon = logoIcon;\n\n        trayIcon = new TrayIcon(\n            currentIcon,\n            Resources.getApplicationString(\"service.gui.APPLICATION_NAME\"),\n            menu);\n\n        trayIcon.setIconAutoSize(true);\n\n        if (osName.startsWith(\"Mac OS X\"))\n        {\n            // init dock Icons\n            dockIconOffline\n                = Resources.getImageURL(\"service.systray.DOCK_ICON_OFFLINE\");\n            dockIconAway\n                = Resources.getImageURL(\"service.systray.DOCK_ICON_AWAY\");\n            dockIconFFC\n                = Resources.getImageURL(\"service.systray.DOCK_ICON_FFC\");\n        }\n\n        //Show/hide the contact list when user clicks on the systray.\n        trayIcon.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                long currentTime = System.currentTimeMillis();\n                UIService uiService = SystrayActivator.getUIService();\n\n                boolean isVisible;\n\n                isVisible = ! uiService.isVisible();\n                if (isVisible) {\n                    setVisibleTime = currentTime;\n                }\n                else if (currentTime < (setVisibleTime + doubleClickSpeed))\n                {\n                    // Do nothing. the last restore is less than 2 seconds, so it is very\n                    // likely, that the user made a double click. prevent the main window\n                    // from opening and immediately closing again.\n                    return;\n                }\n\n                uiService.setVisible(isVisible);\n\n                ConfigurationService configService\n                    = SystrayActivator.getConfigurationService();\n\n                configService.setProperty(\n                        \"net.java.sip.communicator.impl.systray.showApplication\",\n                        Boolean.toString(isVisible));\n            }\n        });\n\n        // Change the MacOSX icon with the white one when the popup\n        // menu appears\n        if (osName.startsWith(\"Mac OS X\"))\n        {\n            TrayMenuFactory.addPopupMenuListener(menu, new PopupMenuListener()\n            {\n                public void popupMenuWillBecomeVisible(PopupMenuEvent e)\n                {\n                    if (currentIcon == envelopeIcon)\n                    {\n                        trayIcon.setIcon(envelopeIconWhite);\n                        currentIcon = envelopeIconWhite;\n                    }\n                    else\n                    {\n                        trayIcon.setIcon(logoIconWhite);\n                        currentIcon = logoIconWhite;\n                    }\n                }\n\n                public void popupMenuWillBecomeInvisible(PopupMenuEvent e)\n                {\n                    if (currentIcon == envelopeIconWhite)\n                    {\n                        trayIcon.setIcon(envelopeIcon);\n                        currentIcon = envelopeIcon;\n                    }\n                    else\n                    {\n                        trayIcon.setIcon(logoIcon);\n                        currentIcon = logoIcon;\n                    }\n                }\n\n                public void popupMenuCanceled(PopupMenuEvent e)\n                {\n                    popupMenuWillBecomeInvisible(e);\n                }\n            });\n        }\n\n        //Notify all interested listener that user has clicked on the systray\n        //popup message.\n        trayIcon.addBalloonActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                UIService uiService = SystrayActivator.getUIService();\n\n                firePopupMessageEvent(e.getSource());\n\n                ExportedWindow chatWindow\n                    = uiService.getExportedWindow(ExportedWindow.CHAT_WINDOW);\n\n                if(chatWindow != null && chatWindow.isVisible())\n                {\n                    chatWindow.bringToFront();\n                }\n            }\n        });\n\n        systray.addTrayIcon(trayIcon);\n\n        initialized = true;\n    }","id":73840,"modified_method":"/**\n     * Initializes the systray icon and related listeners.\n     */\n    private void initSystray()\n    {\n\n        // Get the system's double click speed\n        Object o = Toolkit.getDefaultToolkit().getDesktopProperty(\n                \"awt.multiClickInterval\");\n        final int doubleClickSpeed = (o instanceof Integer ? ((Integer) o)\n                .intValue() : 500);\n\n        menu = TrayMenuFactory.createTrayMenu(this, systray.isSwing());\n\n        String osName = System.getProperty(\"os.name\");\n        // If we're running under Windows, we use a special icon without\n        // background.\n        if (osName.startsWith(\"Windows\"))\n        {\n            logoIcon\n                = Resources.getImage(\"service.systray.TRAY_ICON_WINDOWS\");\n            logoIconOffline\n                = Resources.getImage(\"service.systray.TRAY_ICON_WINDOWS_OFFLINE\");\n            logoIconAway\n                = Resources.getImage(\"service.systray.TRAY_ICON_WINDOWS_AWAY\");\n            logoIconFFC\n                = Resources.getImage(\"service.systray.TRAY_ICON_WINDOWS_FFC\");\n            envelopeIcon\n                = Resources.getImage(\"service.systray.MESSAGE_ICON_WINDOWS\");\n        }\n\n        // If we're running under MacOSX, we use a special black and\n        // white icons without background.\n        else if (osName.startsWith(\"Mac OS X\"))\n        {\n            logoIcon\n                = Resources.getImage(\"service.systray.TRAY_ICON_MACOSX\");\n            logoIconWhite\n                = Resources.getImage(\"service.systray.TRAY_ICON_MACOSX_WHITE\");\n            envelopeIcon\n                = Resources.getImage(\"service.systray.MESSAGE_ICON_MACOSX\");\n            envelopeIconWhite\n                = Resources.getImage(\"service.systray.MESSAGE_ICON_MACOSX_WHITE\");\n        }\n        else\n        {\n            logoIcon = Resources.getImage(\"service.systray.TRAY_ICON\");\n            logoIconOffline = Resources.getImage(\"service.systray.TRAY_ICON_OFFLINE\");\n            logoIconAway = Resources.getImage(\"service.systray.TRAY_ICON_AWAY\");\n            logoIconFFC = Resources.getImage(\"service.systray.TRAY_ICON_FFC\");\n            envelopeIcon = Resources.getImage(\"service.systray.MESSAGE_ICON\");\n        }\n\n        if (!osName.startsWith(\"Mac OS X\"))\n        {\n            // default to set offline , if any protocols become\n            // online will set it to online\n            currentIcon = logoIconOffline;\n        }\n        else\n            currentIcon = logoIcon;\n\n        trayIcon = new TrayIcon(\n            currentIcon,\n            Resources.getApplicationString(\"service.gui.APPLICATION_NAME\"),\n            menu);\n\n        trayIcon.setIconAutoSize(true);\n\n        if (osName.startsWith(\"Mac OS X\"))\n        {\n            // init dock Icons\n            dockIconOffline\n                = Resources.getImageURL(\"service.systray.DOCK_ICON_OFFLINE\");\n            dockIconAway\n                = Resources.getImageURL(\"service.systray.DOCK_ICON_AWAY\");\n            dockIconFFC\n                = Resources.getImageURL(\"service.systray.DOCK_ICON_FFC\");\n        }\n\n        //Show/hide the contact list when user clicks on the systray.\n        trayIcon.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                long currentTime = System.currentTimeMillis();\n                UIService uiService = SystrayActivator.getUIService();\n                boolean isVisible = !uiService.isVisible();\n\n                if (isVisible) {\n                    setVisibleTime = currentTime;\n                }\n                else if (currentTime < (setVisibleTime + doubleClickSpeed))\n                {\n                    // Do nothing. the last restore is less than 2 seconds, so it is very\n                    // likely, that the user made a double click. prevent the main window\n                    // from opening and immediately closing again.\n                    return;\n                }\n\n                uiService.setVisible(isVisible);\n\n                configService.setProperty(\n                        \"net.java.sip.communicator.impl.systray.showApplication\",\n                        Boolean.toString(isVisible));\n            }\n        });\n\n        // Change the MacOSX icon with the white one when the popup\n        // menu appears\n        if (osName.startsWith(\"Mac OS X\"))\n        {\n            TrayMenuFactory.addPopupMenuListener(menu, new PopupMenuListener()\n            {\n                public void popupMenuWillBecomeVisible(PopupMenuEvent e)\n                {\n                    if (currentIcon == envelopeIcon)\n                    {\n                        trayIcon.setIcon(envelopeIconWhite);\n                        currentIcon = envelopeIconWhite;\n                    }\n                    else\n                    {\n                        trayIcon.setIcon(logoIconWhite);\n                        currentIcon = logoIconWhite;\n                    }\n                }\n\n                public void popupMenuWillBecomeInvisible(PopupMenuEvent e)\n                {\n                    if (currentIcon == envelopeIconWhite)\n                    {\n                        trayIcon.setIcon(envelopeIcon);\n                        currentIcon = envelopeIcon;\n                    }\n                    else\n                    {\n                        getTrayIcon().setIcon(logoIcon);\n                        currentIcon = logoIcon;\n                    }\n                }\n\n                public void popupMenuCanceled(PopupMenuEvent e)\n                {\n                    popupMenuWillBecomeInvisible(e);\n                }\n            });\n        }\n\n        PopupMessageHandler pph = new PopupMessageHandlerTrayIconImpl(trayIcon);\n        popupHandlerSet.put(pph.getClass().getName(), pph);\n        SystrayActivator.bundleContext.registerService(\n                PopupMessageHandler.class.getName(),\n                pph, null);\n\n        try\n        {\n            SystrayActivator.bundleContext.addServiceListener(\n                    new ServiceListenerImpl(),\n                    \"(objectclass=\" + PopupMessageHandler.class.getName() + \")\");\n        } catch (Exception e)\n        {\n            logger.warn(e);\n        }\n\n        // now we look if some handler has been registered before we start\n        // to listen\n        ServiceReference[] handlerRefs = null;\n        try\n        {\n            handlerRefs = SystrayActivator.bundleContext.getServiceReferences(\n                PopupMessageHandler.class.getName(),\n                null);\n        }\n        catch (InvalidSyntaxException ex)\n        {\n            logger.error(\"Error while retrieving service refs\", ex);\n        }\n        if (handlerRefs != null)\n        {\n            for (int i = 0; i < handlerRefs.length; i++)\n            {\n                PopupMessageHandler handler =\n                        (PopupMessageHandler) SystrayActivator.\n                        bundleContext.getService(handlerRefs[i]);\n                String handlerName = handler.getClass().getName();\n                if (!popupHandlerSet.containsKey(handlerName))\n                {\n                    popupHandlerSet\n                            .put(handlerName, handler);\n                    logger.info(\"added the following popup handler : \" +\n                            handler);\n                    String configuredHandler =(String) configService.\n                            getProperty(\"systray.POPUP_HANDLER\");\n                    if (configuredHandler.equals(handler.getClass().getName()))\n                        setActivePopupMessageHandler(handler);\n                }\n                \n            }\n        }\n\n        // either we have an incorrect config value or the default popup handler\n        // is not yet available. we use the available popup handler and will\n        // auto switch to the configured one when it will be available.\n        // we will be aware of it since we listen for new registerred\n        // service in the bundle context.\n        if (activePopupHandler == null)\n        {\n            setActivePopupMessageHandler(pph);\n        }\n\n        systray.addTrayIcon(trayIcon);\n\n        initialized = true;\n    }","commit_id":"2d812827220778a947e1577f4018fd022ba36a0a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements the <tt>SystratService.showPopupMessage<\/tt> method. Shows\n     * a pop up message, above the Systray icon, which has the given title,\n     * message content and message type.\n     *\n     * @param title the title of the message\n     * @param messageContent the content text\n     * @param messageType the type of the message\n     */\n    public void showPopupMessage(   String title,\n                                    String messageContent,\n                                    int messageType)\n    {\n        if(!checkInitialized())\n            return;\n\n        int trayMsgType = TrayIcon.NONE_MESSAGE_TYPE;\n\n        if (messageType == SystrayService.ERROR_MESSAGE_TYPE)\n            trayMsgType = TrayIcon.ERROR_MESSAGE_TYPE;\n        else if (messageType == SystrayService.INFORMATION_MESSAGE_TYPE)\n            trayMsgType = TrayIcon.INFO_MESSAGE_TYPE;\n        else if (messageType == SystrayService.WARNING_MESSAGE_TYPE)\n            trayMsgType = TrayIcon.WARNING_MESSAGE_TYPE;\n\n        // remove eventual html code before showing the popup message\n        messageContent = messageContent.replaceAll(\"<\/?\\\\w++[^>]*+>\", \"\");\n\n        if(messageContent.length() > 40)\n            messageContent = messageContent.substring(0, 40).concat(\"...\");\n\n        messageQueue.add(new SystrayMessage(title, messageContent, trayMsgType));\n    }","id":73841,"modified_method":"/**\n     * Implements <tt>SystraService#showPopupMessage()<\/tt>\n     *\n     * @param popupMessage the message we will show\n     */\n    public void showPopupMessage(PopupMessage popupMessage)\n    {\n        // since popup handler could be loaded and unloader on the fly,\n        // we have to check if we currently have a valid one.\n        if (activePopupHandler != null)\n            activePopupHandler.showPopupMessage(popupMessage);\n    }","commit_id":"2d812827220778a947e1577f4018fd022ba36a0a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements the <tt>SystrayService.removePopupMessageListener<\/tt> method.\n     *\n     * @param listener the listener to remove\n     */\n    public void removePopupMessageListener(SystrayPopupMessageListener listener)\n    {\n        synchronized (popupMessageListeners)\n        {\n            this.popupMessageListeners.remove(listener);\n        }\n    }","id":73842,"modified_method":"/**\n     * Implements the <tt>SystrayService.removePopupMessageListener<\/tt> method.\n     *\n     * @param listener the listener to remove\n     */\n    public void removePopupMessageListener(SystrayPopupMessageListener listener)\n    {\n        if (activePopupHandler != null)\n            activePopupHandler.removePopupMessageListener(listener);\n    }","commit_id":"2d812827220778a947e1577f4018fd022ba36a0a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of <tt>Systray<\/tt>.\n     */\n    public SystrayServiceJdicImpl()\n    {\n        try\n        {\n            systray = SystemTray.getDefaultSystemTray();\n        }\n        catch (Throwable e)\n        {\n            logger.error(\"Failed to create a systray!\", e);\n        }\n\n        if(systray != null)\n        {\n            this.initSystray();\n\n            SystrayActivator.getUIService().setExitOnMainWindowClose(false);\n        }\n    }","id":73843,"modified_method":"/**\n     * Creates an instance of <tt>Systray<\/tt>.\n     */\n    public SystrayServiceJdicImpl()\n    {\n        try\n        {\n            systray = SystemTray.getDefaultSystemTray();\n        }\n        catch (Throwable e)\n        {\n            logger.error(\"Failed to create a systray!\", e);\n        }\n\n        if(systray != null)\n        {\n            this.initSystray();\n\n            UIService ui = SystrayActivator.getUIService();\n            if (ui != null)\n                ui.setExitOnMainWindowClose(false);\n        }\n    }","commit_id":"2d812827220778a947e1577f4018fd022ba36a0a","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Saves the last status for all accounts. This information is used\n     * on logging. Each time user logs in he's logged with the same status\n     * as he was the last time before closing the application.\n     *\n     * @param protocolProvider  the protocol provider for which we save the\n     * last selected status\n     * @param statusName the status name to save\n     */\n    public void saveStatusInformation(\n            ProtocolProviderService protocolProvider,\n            String statusName)\n    {\n        ConfigurationService configService\n            = SystrayActivator.getConfigurationService();\n\n        if(configService != null)\n        {\n            String prefix = \"net.java.sip.communicator.impl.gui.accounts\";\n\n            List<String> accounts = configService\n                    .getPropertyNamesByPrefix(prefix, true);\n\n            boolean savedAccount = false;\n\n            for (String accountRootPropName : accounts) {\n                String accountUID\n                    = configService.getString(accountRootPropName);\n\n                if(accountUID.equals(protocolProvider\n                        .getAccountID().getAccountUniqueID())) {\n\n                    configService.setProperty(\n                            accountRootPropName + \".lastAccountStatus\",\n                            statusName);\n\n                    savedAccount = true;\n                }\n            }\n\n            if(!savedAccount) {\n                String accNodeName\n                    = \"acc\" + Long.toString(System.currentTimeMillis());\n\n                String accountPackage\n                    = \"net.java.sip.communicator.impl.gui.accounts.\"\n                            + accNodeName;\n\n                configService.setProperty(accountPackage,\n                        protocolProvider.getAccountID().getAccountUniqueID());\n\n                configService.setProperty(\n                        accountPackage+\".lastAccountStatus\",\n                        statusName);\n            }\n        }\n    }","id":73844,"modified_method":"/**\n     * Saves the last status for all accounts. This information is used\n     * on logging. Each time user logs in he's logged with the same status\n     * as he was the last time before closing the application.\n     *\n     * @param protocolProvider  the protocol provider for which we save the\n     * last selected status\n     * @param statusName the status name to save\n     */\n    public void saveStatusInformation(\n            ProtocolProviderService protocolProvider,\n            String statusName)\n    {\n        if(configService != null)\n        {\n            String prefix = \"net.java.sip.communicator.impl.gui.accounts\";\n\n            List<String> accounts = configService\n                    .getPropertyNamesByPrefix(prefix, true);\n\n            boolean savedAccount = false;\n\n            for (String accountRootPropName : accounts) {\n                String accountUID\n                    = configService.getString(accountRootPropName);\n\n                if(accountUID.equals(protocolProvider\n                        .getAccountID().getAccountUniqueID())) {\n\n                    configService.setProperty(\n                            accountRootPropName + \".lastAccountStatus\",\n                            statusName);\n\n                    savedAccount = true;\n                }\n            }\n\n            if(!savedAccount) {\n                String accNodeName\n                    = \"acc\" + Long.toString(System.currentTimeMillis());\n\n                String accountPackage\n                    = \"net.java.sip.communicator.impl.gui.accounts.\"\n                            + accNodeName;\n\n                configService.setProperty(accountPackage,\n                        protocolProvider.getAccountID().getAccountUniqueID());\n\n                configService.setProperty(\n                        accountPackage+\".lastAccountStatus\",\n                        statusName);\n            }\n        }\n    }","commit_id":"2d812827220778a947e1577f4018fd022ba36a0a","url":"https://github.com/jitsi/jitsi"},{"original_method":"public List<Map<String, String>> listComponents(String camelContextName) throws Exception {\n        CamelContext context = this.getCamelContext(camelContextName);\n        if (context == null) {\n            return null;\n        }\n\n        List<Map<String, String>> answer = new ArrayList<Map<String, String>>();\n\n        // find all components\n        Map<String, Properties> components = context.findComponents();\n\n        // gather component detail for each component\n        for (Map.Entry<String, Properties> entry : components.entrySet()) {\n            String name = entry.getKey();\n            String description = null;\n            // the status can be:\n            // - loaded = in use\n            // - classpath = on the classpath\n            // - release = available from the Apache Camel release\n            String status = context.hasComponent(name) != null ? \"in use\" : \"on classpath\";\n            String type = null;\n            String groupId = null;\n            String artifactId = null;\n            String version = null;\n\n            // load component json data, and parse it to gather the component meta-data\n            String json = context.getComponentParameterJsonSchema(name);\n            List<Map<String, String>> rows = JsonSchemaHelper.parseJsonSchema(\"component\", json, false);\n            for (Map<String, String> row : rows) {\n                if (row.containsKey(\"description\")) {\n                    description = row.get(\"description\");\n                } else if (row.containsKey(\"javaType\")) {\n                    type = row.get(\"javaType\");\n                } else if (row.containsKey(\"groupId\")) {\n                    groupId = row.get(\"groupId\");\n                } else if (row.containsKey(\"artifactId\")) {\n                    artifactId = row.get(\"artifactId\");\n                } else if (row.containsKey(\"version\")) {\n                    version = row.get(\"version\");\n                }\n            }\n\n            Map<String, String> row = new HashMap<String, String>();\n            row.put(\"name\", name);\n            row.put(\"status\", status);\n            if (description != null) {\n                row.put(\"description\", description);\n            }\n            if (type != null) {\n                row.put(\"type\", type);\n            }\n            if (groupId != null) {\n                row.put(\"groupId\", groupId);\n            }\n            if (artifactId != null) {\n                row.put(\"artifactId\", artifactId);\n            }\n            if (version != null) {\n                row.put(\"version\", version);\n            }\n\n            answer.add(row);\n        }\n\n        return answer;\n    }","id":73845,"modified_method":"public List<Map<String, String>> listComponents(String camelContextName) throws Exception {\n        CamelContext context = this.getCamelContext(camelContextName);\n        if (context == null) {\n            return null;\n        }\n\n        List<Map<String, String>> answer = new ArrayList<Map<String, String>>();\n\n        // find all components\n        Map<String, Properties> components = context.findComponents();\n\n        // gather component detail for each component\n        for (Map.Entry<String, Properties> entry : components.entrySet()) {\n            String name = entry.getKey();\n            String description = null;\n            String label = null;\n            // the status can be:\n            // - loaded = in use\n            // - classpath = on the classpath\n            // - release = available from the Apache Camel release\n            String status = context.hasComponent(name) != null ? \"in use\" : \"on classpath\";\n            String type = null;\n            String groupId = null;\n            String artifactId = null;\n            String version = null;\n\n            // load component json data, and parse it to gather the component meta-data\n            String json = context.getComponentParameterJsonSchema(name);\n            List<Map<String, String>> rows = JsonSchemaHelper.parseJsonSchema(\"component\", json, false);\n            for (Map<String, String> row : rows) {\n                if (row.containsKey(\"description\")) {\n                    description = row.get(\"description\");\n                } else if (row.containsKey(\"label\")) {\n                    label = row.get(\"label\");\n                } else if (row.containsKey(\"javaType\")) {\n                    type = row.get(\"javaType\");\n                } else if (row.containsKey(\"groupId\")) {\n                    groupId = row.get(\"groupId\");\n                } else if (row.containsKey(\"artifactId\")) {\n                    artifactId = row.get(\"artifactId\");\n                } else if (row.containsKey(\"version\")) {\n                    version = row.get(\"version\");\n                }\n            }\n\n            Map<String, String> row = new HashMap<String, String>();\n            row.put(\"name\", name);\n            row.put(\"status\", status);\n            if (description != null) {\n                row.put(\"description\", description);\n            }\n            if (label != null) {\n                row.put(\"label\", label);\n            }\n            if (type != null) {\n                row.put(\"type\", type);\n            }\n            if (groupId != null) {\n                row.put(\"groupId\", groupId);\n            }\n            if (artifactId != null) {\n                row.put(\"artifactId\", artifactId);\n            }\n            if (version != null) {\n                row.put(\"version\", version);\n            }\n\n            answer.add(row);\n        }\n\n        return answer;\n    }","commit_id":"1590a3511e9c947770015298499d148f26686d63","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public List<Map<String, String>> listComponentsCatalog() throws Exception {\n        List<Map<String, String>> answer = new ArrayList<Map<String, String>>();\n\n        List<String> names = catalog.findComponentNames();\n        for (String name : names) {\n            // load component json data, and parse it to gather the component meta-data\n            String json = catalog.componentJSonSchema(name);\n            List<Map<String, String>> rows = JsonSchemaHelper.parseJsonSchema(\"component\", json, false);\n\n            String description = null;\n            // the status can be:\n            // - loaded = in use\n            // - classpath = on the classpath\n            // - release = available from the Apache Camel release\n            String status = \"release\";\n            String type = null;\n            String groupId = null;\n            String artifactId = null;\n            String version = null;\n            for (Map<String, String> row : rows) {\n                if (row.containsKey(\"description\")) {\n                    description = row.get(\"description\");\n                } else if (row.containsKey(\"javaType\")) {\n                    type = row.get(\"javaType\");\n                } else if (row.containsKey(\"groupId\")) {\n                    groupId = row.get(\"groupId\");\n                } else if (row.containsKey(\"artifactId\")) {\n                    artifactId = row.get(\"artifactId\");\n                } else if (row.containsKey(\"version\")) {\n                    version = row.get(\"version\");\n                }\n            }\n\n            Map<String, String> row = new HashMap<String, String>();\n            row.put(\"name\", name);\n            row.put(\"status\", status);\n            if (description != null) {\n                row.put(\"description\", description);\n            }\n            if (type != null) {\n                row.put(\"type\", type);\n            }\n            if (groupId != null) {\n                row.put(\"groupId\", groupId);\n            }\n            if (artifactId != null) {\n                row.put(\"artifactId\", artifactId);\n            }\n            if (version != null) {\n                row.put(\"version\", version);\n            }\n\n            answer.add(row);\n        }\n\n        return answer;\n    }","id":73846,"modified_method":"@Override\n    public List<Map<String, String>> listComponentsCatalog(String filter) throws Exception {\n        List<Map<String, String>> answer = new ArrayList<Map<String, String>>();\n\n        if (filter != null) {\n            filter = RegexUtil.wildcardAsRegex(filter);\n        }\n\n        List<String> names = filter != null ? catalog.findComponentNames(filter) : catalog.findComponentNames();\n        for (String name : names) {\n            // load component json data, and parse it to gather the component meta-data\n            String json = catalog.componentJSonSchema(name);\n            List<Map<String, String>> rows = JsonSchemaHelper.parseJsonSchema(\"component\", json, false);\n\n            String description = null;\n            String label = null;\n            // the status can be:\n            // - loaded = in use\n            // - classpath = on the classpath\n            // - release = available from the Apache Camel release\n            String status = \"release\";\n            String type = null;\n            String groupId = null;\n            String artifactId = null;\n            String version = null;\n            for (Map<String, String> row : rows) {\n                if (row.containsKey(\"description\")) {\n                    description = row.get(\"description\");\n                } else if (row.containsKey(\"label\")) {\n                    label = row.get(\"label\");\n                } else if (row.containsKey(\"javaType\")) {\n                    type = row.get(\"javaType\");\n                } else if (row.containsKey(\"groupId\")) {\n                    groupId = row.get(\"groupId\");\n                } else if (row.containsKey(\"artifactId\")) {\n                    artifactId = row.get(\"artifactId\");\n                } else if (row.containsKey(\"version\")) {\n                    version = row.get(\"version\");\n                }\n            }\n\n            Map<String, String> row = new HashMap<String, String>();\n            row.put(\"name\", name);\n            row.put(\"status\", status);\n            if (description != null) {\n                row.put(\"description\", description);\n            }\n            if (label != null) {\n                row.put(\"label\", label);\n            }\n            if (type != null) {\n                row.put(\"type\", type);\n            }\n            if (groupId != null) {\n                row.put(\"groupId\", groupId);\n            }\n            if (artifactId != null) {\n                row.put(\"artifactId\", artifactId);\n            }\n            if (version != null) {\n                row.put(\"version\", version);\n            }\n\n            answer.add(row);\n        }\n\n        return answer;\n    }","commit_id":"1590a3511e9c947770015298499d148f26686d63","url":"https://github.com/apache/camel"},{"original_method":"protected Object doExecute() throws Exception {\n        CatalogComponentListCommand command = new CatalogComponentListCommand(verbose);\n        return command.execute(camelController, System.out, System.err);\n    }","id":73847,"modified_method":"protected Object doExecute() throws Exception {\n        CatalogComponentListCommand command = new CatalogComponentListCommand(verbose, label);\n        return command.execute(camelController, System.out, System.err);\n    }","commit_id":"1590a3511e9c947770015298499d148f26686d63","url":"https://github.com/apache/camel"},{"original_method":"public CatalogComponentListCommand(boolean verbose) {\n        this.verbose = verbose;\n    }","id":73848,"modified_method":"public CatalogComponentListCommand(boolean verbose, String label) {\n        this.verbose = verbose;\n        this.label = label;\n    }","commit_id":"1590a3511e9c947770015298499d148f26686d63","url":"https://github.com/apache/camel"},{"original_method":"private String buildFormatString(Map<String, Integer> columnWidths, boolean isHeader, boolean isVerbose) {\n        final String fieldPreamble;\n        final String fieldPostamble;\n        final int columnWidthIncrement;\n\n        if (isHeader) {\n            fieldPreamble = DEFAULT_HEADER_PREAMBLE;\n            fieldPostamble = DEFAULT_HEADER_POSTAMBLE;\n        } else {\n            fieldPreamble = DEFAULT_FIELD_PREAMBLE;\n            fieldPostamble = DEFAULT_FIELD_POSTAMBLE;\n        }\n        columnWidthIncrement = DEFAULT_COLUMN_WIDTH_INCREMENT;\n\n        if (verbose) {\n            int nameLen = Math.min(columnWidths.get(NAME_COLUMN_LABEL) + columnWidthIncrement, getMaxColumnWidth());\n            int statusLen = Math.min(columnWidths.get(STATUS_COLUMN_LABEL) + columnWidthIncrement, getMaxColumnWidth());\n            int mavenLen = Math.min(columnWidths.get(MAVEN_COLUMN_LABEL) + columnWidthIncrement, getMaxColumnWidth());\n            int descriptionLen = Math.min(columnWidths.get(DESCRIPTION_COLUMN_LABEL) + columnWidthIncrement, getMaxColumnWidth());\n\n            nameLen = Math.max(MIN_COLUMN_WIDTH, nameLen);\n            statusLen = Math.max(MIN_COLUMN_WIDTH, statusLen);\n            mavenLen = Math.max(MIN_COLUMN_WIDTH, mavenLen);\n            descriptionLen = Math.max(MIN_COLUMN_WIDTH, descriptionLen);\n\n            final StringBuilder retval = new StringBuilder(DEFAULT_FORMAT_BUFFER_LENGTH);\n            retval.append(fieldPreamble).append(\"%-\").append(nameLen).append('.').append(nameLen).append('s').append(fieldPostamble).append(' ');\n            retval.append(fieldPreamble).append(\"%-\").append(statusLen).append('.').append(statusLen).append('s').append(fieldPostamble).append(' ');\n            retval.append(fieldPreamble).append(\"%-\").append(mavenLen).append('.').append(mavenLen).append('s').append(fieldPostamble).append(' ');\n            retval.append(fieldPreamble).append(\"%-\").append(descriptionLen).append('.').append(descriptionLen).append('s').append(fieldPostamble).append(' ');\n            return retval.toString();\n        } else {\n            int nameLen = Math.min(columnWidths.get(NAME_COLUMN_LABEL) + columnWidthIncrement, getMaxColumnWidth());\n            int descriptionLen = Math.min(columnWidths.get(DESCRIPTION_COLUMN_LABEL) + columnWidthIncrement, getMaxColumnWidth());\n\n            nameLen = Math.max(MIN_COLUMN_WIDTH, nameLen);\n            descriptionLen = Math.max(MIN_COLUMN_WIDTH, descriptionLen);\n\n            final StringBuilder retval = new StringBuilder(DEFAULT_FORMAT_BUFFER_LENGTH);\n            retval.append(fieldPreamble).append(\"%-\").append(nameLen).append('.').append(nameLen).append('s').append(fieldPostamble).append(' ');\n            retval.append(fieldPreamble).append(\"%-\").append(descriptionLen).append('.').append(descriptionLen).append('s').append(fieldPostamble).append(' ');\n            return retval.toString();\n        }\n    }","id":73849,"modified_method":"private String buildFormatString(Map<String, Integer> columnWidths, boolean isHeader, boolean isVerbose) {\n        final String fieldPreamble;\n        final String fieldPostamble;\n        final int columnWidthIncrement;\n\n        if (isHeader) {\n            fieldPreamble = DEFAULT_HEADER_PREAMBLE;\n            fieldPostamble = DEFAULT_HEADER_POSTAMBLE;\n        } else {\n            fieldPreamble = DEFAULT_FIELD_PREAMBLE;\n            fieldPostamble = DEFAULT_FIELD_POSTAMBLE;\n        }\n        columnWidthIncrement = DEFAULT_COLUMN_WIDTH_INCREMENT;\n\n        if (verbose) {\n            int nameLen = Math.min(columnWidths.get(NAME_COLUMN_LABEL) + columnWidthIncrement, getMaxColumnWidth());\n            int labelLen = Math.min(columnWidths.get(LABEL_COLUMN_LABEL) + columnWidthIncrement, getMaxColumnWidth());\n            int mavenLen = Math.min(columnWidths.get(MAVEN_COLUMN_LABEL) + columnWidthIncrement, getMaxColumnWidth());\n            int descriptionLen = Math.min(columnWidths.get(DESCRIPTION_COLUMN_LABEL) + columnWidthIncrement, getMaxColumnWidth());\n\n            nameLen = Math.max(MIN_COLUMN_WIDTH, nameLen);\n            labelLen = Math.max(MIN_COLUMN_WIDTH, labelLen);\n            mavenLen = Math.max(MIN_COLUMN_WIDTH, mavenLen);\n            descriptionLen = Math.max(MIN_COLUMN_WIDTH, descriptionLen);\n\n            final StringBuilder retval = new StringBuilder(DEFAULT_FORMAT_BUFFER_LENGTH);\n            retval.append(fieldPreamble).append(\"%-\").append(nameLen).append('.').append(nameLen).append('s').append(fieldPostamble).append(' ');\n            retval.append(fieldPreamble).append(\"%-\").append(labelLen).append('.').append(labelLen).append('s').append(fieldPostamble).append(' ');\n            retval.append(fieldPreamble).append(\"%-\").append(mavenLen).append('.').append(mavenLen).append('s').append(fieldPostamble).append(' ');\n            retval.append(fieldPreamble).append(\"%-\").append(descriptionLen).append('.').append(descriptionLen).append('s').append(fieldPostamble).append(' ');\n            return retval.toString();\n        } else {\n            int nameLen = Math.min(columnWidths.get(NAME_COLUMN_LABEL) + columnWidthIncrement, getMaxColumnWidth());\n            int labelLen = Math.min(columnWidths.get(LABEL_COLUMN_LABEL) + columnWidthIncrement, getMaxColumnWidth());\n            int mavenLen = Math.min(columnWidths.get(MAVEN_COLUMN_LABEL) + columnWidthIncrement, getMaxColumnWidth());\n\n            nameLen = Math.max(MIN_COLUMN_WIDTH, nameLen);\n            labelLen = Math.max(MIN_COLUMN_WIDTH, labelLen);\n            mavenLen = Math.max(MIN_COLUMN_WIDTH, mavenLen);\n\n            final StringBuilder retval = new StringBuilder(DEFAULT_FORMAT_BUFFER_LENGTH);\n            retval.append(fieldPreamble).append(\"%-\").append(nameLen).append('.').append(nameLen).append('s').append(fieldPostamble).append(' ');\n            retval.append(fieldPreamble).append(\"%-\").append(labelLen).append('.').append(labelLen).append('s').append(fieldPostamble).append(' ');\n            retval.append(fieldPreamble).append(\"%-\").append(mavenLen).append('.').append(mavenLen).append('s').append(fieldPostamble).append(' ');\n            return retval.toString();\n        }\n    }","commit_id":"1590a3511e9c947770015298499d148f26686d63","url":"https://github.com/apache/camel"},{"original_method":"private Map<String, Integer> computeColumnWidths(final Iterable<Map<String, String>> components) throws Exception {\n        if (components == null) {\n            return null;\n        } else {\n            // some of the options is optional so we need to start from 1\n            int maxNameLen = NAME_COLUMN_LABEL.length();\n            int maxStatusLen = STATUS_COLUMN_LABEL.length();\n            int maxMavenLen = MAVEN_COLUMN_LABEL.length();\n            int maxDescriptionLen = DESCRIPTION_COLUMN_LABEL.length();\n\n            for (final Map<String, String> component : components) {\n\n                // grab the information and compute max len\n                String name = component.get(\"name\");\n                if (name != null) {\n                    maxNameLen = Math.max(maxNameLen, name.length());\n                }\n                String status = component.get(\"status\");\n                if (status != null) {\n                    maxStatusLen = Math.max(maxStatusLen, status.length());\n                }\n                if (component.containsKey(\"groupId\") && component.containsKey(\"artifactId\") && component.containsKey(\"version\")) {\n                    String mvn = component.get(\"groupId\") + \"/\" + component.get(\"artifactId\") + \"/\" + component.get(\"version\");\n                    maxMavenLen = Math.max(maxMavenLen, mvn.length());\n                }\n                String description = component.get(\"description\");\n                if (description != null) {\n                    maxDescriptionLen = Math.max(maxDescriptionLen, description.length());\n                }\n            }\n\n            final Map<String, Integer> retval = new Hashtable<String, Integer>(4);\n            retval.put(NAME_COLUMN_LABEL, maxNameLen);\n            retval.put(STATUS_COLUMN_LABEL, maxStatusLen);\n            retval.put(MAVEN_COLUMN_LABEL, maxMavenLen);\n            retval.put(DESCRIPTION_COLUMN_LABEL, maxDescriptionLen);\n\n            return retval;\n        }\n    }","id":73850,"modified_method":"private Map<String, Integer> computeColumnWidths(final Iterable<Map<String, String>> components) throws Exception {\n        if (components == null) {\n            return null;\n        } else {\n            // some of the options is optional so we need to start from 1\n            int maxNameLen = NAME_COLUMN_LABEL.length();\n            int maxLabelLen = LABEL_COLUMN_LABEL.length();\n            int maxMavenLen = MAVEN_COLUMN_LABEL.length();\n            int maxDescriptionLen = DESCRIPTION_COLUMN_LABEL.length();\n\n            for (final Map<String, String> component : components) {\n\n                // grab the information and compute max len\n                String name = component.get(\"name\");\n                if (name != null) {\n                    maxNameLen = Math.max(maxNameLen, name.length());\n                }\n                String label = component.get(\"label\");\n                if (label != null) {\n                    maxLabelLen = Math.max(maxLabelLen, label.length());\n                }\n                if (component.containsKey(\"groupId\") && component.containsKey(\"artifactId\") && component.containsKey(\"version\")) {\n                    String mvn = component.get(\"groupId\") + \"/\" + component.get(\"artifactId\") + \"/\" + component.get(\"version\");\n                    maxMavenLen = Math.max(maxMavenLen, mvn.length());\n                }\n                String description = component.get(\"description\");\n                if (description != null) {\n                    maxDescriptionLen = Math.max(maxDescriptionLen, description.length());\n                }\n            }\n\n            final Map<String, Integer> retval = new Hashtable<String, Integer>(4);\n            retval.put(NAME_COLUMN_LABEL, maxNameLen);\n            retval.put(LABEL_COLUMN_LABEL, maxLabelLen);\n            retval.put(MAVEN_COLUMN_LABEL, maxMavenLen);\n            retval.put(DESCRIPTION_COLUMN_LABEL, maxDescriptionLen);\n\n            return retval;\n        }\n    }","commit_id":"1590a3511e9c947770015298499d148f26686d63","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Object execute(CamelController camelController, PrintStream out, PrintStream err) throws Exception {\n        List<Map<String, String>> components = camelController.listComponentsCatalog();\n\n        if (components == null || components.isEmpty()) {\n            return null;\n        }\n\n        final Map<String, Integer> columnWidths = computeColumnWidths(components);\n        final String headerFormat = buildFormatString(columnWidths, true, verbose);\n        final String rowFormat = buildFormatString(columnWidths, false, verbose);\n\n        if (verbose) {\n            out.println(String.format(headerFormat, NAME_COLUMN_LABEL, STATUS_COLUMN_LABEL, MAVEN_COLUMN_LABEL, DESCRIPTION_COLUMN_LABEL));\n            out.println(String.format(headerFormat, \"----\", \"------\", \"----------------\", \"-----------\"));\n        } else {\n            out.println(String.format(headerFormat, NAME_COLUMN_LABEL, DESCRIPTION_COLUMN_LABEL));\n            out.println(String.format(headerFormat, \"----\", \"-----------\"));\n        }\n        for (final Map<String, String> component : components) {\n            if (verbose) {\n                String name = safeNull(component.get(\"name\"));\n                String status = safeNull(component.get(\"status\"));\n                String maven = \"\";\n                if (component.containsKey(\"groupId\") && component.containsKey(\"artifactId\") && component.containsKey(\"version\")) {\n                    maven = component.get(\"groupId\") + \"/\" + component.get(\"artifactId\") + \"/\" + component.get(\"version\");\n                }\n                String description = safeNull(component.get(\"description\"));\n                out.println(String.format(rowFormat, name, status, maven, description));\n            } else {\n                String name = safeNull(component.get(\"name\"));\n                String description = safeNull(component.get(\"description\"));\n                out.println(String.format(rowFormat, name, description));\n            }\n        }\n\n        return null;\n    }","id":73851,"modified_method":"@Override\n    public Object execute(CamelController camelController, PrintStream out, PrintStream err) throws Exception {\n        List<Map<String, String>> components = camelController.listComponentsCatalog(label);\n\n        if (components == null || components.isEmpty()) {\n            return null;\n        }\n\n        final Map<String, Integer> columnWidths = computeColumnWidths(components);\n        final String headerFormat = buildFormatString(columnWidths, true, verbose);\n        final String rowFormat = buildFormatString(columnWidths, false, verbose);\n\n        if (verbose) {\n            out.println(String.format(headerFormat, NAME_COLUMN_LABEL, LABEL_COLUMN_LABEL, MAVEN_COLUMN_LABEL, DESCRIPTION_COLUMN_LABEL));\n            out.println(String.format(headerFormat, \"----\", \"-----\", \"----------------\", \"-----------\"));\n        } else {\n            out.println(String.format(headerFormat, NAME_COLUMN_LABEL, LABEL_COLUMN_LABEL, MAVEN_COLUMN_LABEL));\n            out.println(String.format(headerFormat, \"----\", \"-----\", \"----------------\"));\n        }\n        for (final Map<String, String> component : components) {\n            if (verbose) {\n                String name = safeNull(component.get(\"name\"));\n                String label = safeNull(component.get(\"label\"));\n                String maven = \"\";\n                if (component.containsKey(\"groupId\") && component.containsKey(\"artifactId\") && component.containsKey(\"version\")) {\n                    maven = component.get(\"groupId\") + \"/\" + component.get(\"artifactId\") + \"/\" + component.get(\"version\");\n                }\n                String description = safeNull(component.get(\"description\"));\n                out.println(String.format(rowFormat, name, label, maven, description));\n            } else {\n                String name = safeNull(component.get(\"name\"));\n                String label = safeNull(component.get(\"label\"));\n                String maven = \"\";\n                if (component.containsKey(\"groupId\") && component.containsKey(\"artifactId\") && component.containsKey(\"version\")) {\n                    maven = component.get(\"groupId\") + \"/\" + component.get(\"artifactId\") + \"/\" + component.get(\"version\");\n                }\n                out.println(String.format(rowFormat, name, label, maven));\n            }\n        }\n\n        return null;\n    }","commit_id":"1590a3511e9c947770015298499d148f26686d63","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public List<Map<String, Object>> browseInflightExchanges(String camelContextName, int limit, boolean sortByLongestDuration) throws Exception {\n        CamelContext context = this.getLocalCamelContext(camelContextName);\n        if (context == null) {\n            return null;\n        }\n\n        List<Map<String, Object>> answer = new ArrayList<Map<String, Object>>();\n\n        ManagementAgent agent = context.getManagementStrategy().getManagementAgent();\n        if (agent != null) {\n            MBeanServer mBeanServer = agent.getMBeanServer();\n            ObjectName on = null;\n            Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(agent.getMBeanObjectDomainName() + \":type=services,name=DefaultInflightRepository,*\"), null);\n            if (set.size() == 1) {\n                on = set.iterator().next();\n            }\n            if (mBeanServer.isRegistered(on)) {\n                TabularData list = (TabularData) mBeanServer.invoke(on, \"browse\", new Object[]{limit, sortByLongestDuration}, new String[]{\"int\", \"boolean\"});\n                Collection<CompositeData> values = (Collection<CompositeData>) list.values();\n                for (CompositeData data : values) {\n                    Map<String, Object> row = new LinkedHashMap<String, Object>();\n                    Object exchangeId = data.get(\"exchangeId\");\n                    if (exchangeId != null) {\n                        row.put(\"exchangeId\", exchangeId);\n                    }\n                    Object routeId = data.get(\"routeId\");\n                    if (routeId != null) {\n                        row.put(\"routeId\", routeId);\n                    }\n                    Object nodeId = data.get(\"nodeId\");\n                    if (nodeId != null) {\n                        row.put(\"nodeId\", nodeId);\n                    }\n                    Object duration = data.get(\"duration\");\n                    if (duration != null) {\n                        row.put(\"duration\", duration);\n                    }\n                    Object elapsed = data.get(\"elapsed\");\n                    if (elapsed != null) {\n                        row.put(\"elapsed\", elapsed);\n                    }\n                    answer.add(row);\n                }\n            }\n        }\n\n        return answer;\n    }","id":73852,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public List<Map<String, Object>> browseInflightExchanges(String camelContextName, int limit, boolean sortByLongestDuration) throws Exception {\n        CamelContext context = this.getLocalCamelContext(camelContextName);\n        if (context == null) {\n            return null;\n        }\n\n        List<Map<String, Object>> answer = new ArrayList<Map<String, Object>>();\n\n        ManagementAgent agent = context.getManagementStrategy().getManagementAgent();\n        if (agent != null) {\n            MBeanServer mBeanServer = agent.getMBeanServer();\n            ObjectName on = null;\n            Set<ObjectName> set = mBeanServer.queryNames(new ObjectName(agent.getMBeanObjectDomainName() + \":type=services,name=DefaultInflightRepository,*\"), null);\n            if (set.size() == 1) {\n                on = set.iterator().next();\n            }\n            if (mBeanServer.isRegistered(on)) {\n                TabularData list = (TabularData) mBeanServer.invoke(on, \"browse\", new Object[]{limit, sortByLongestDuration}, new String[]{\"int\", \"boolean\"});\n                Collection<CompositeData> values = (Collection<CompositeData>) list.values();\n                for (CompositeData data : values) {\n                    Map<String, Object> row = new LinkedHashMap<String, Object>();\n                    Object exchangeId = data.get(\"exchangeId\");\n                    if (exchangeId != null) {\n                        row.put(\"exchangeId\", exchangeId);\n                    }\n                    Object fromRouteId = data.get(\"fromRouteId\");\n                    if (fromRouteId != null) {\n                        row.put(\"fromRouteId\", fromRouteId);\n                    }\n                    Object routeId = data.get(\"routeId\");\n                    if (routeId != null) {\n                        row.put(\"routeId\", routeId);\n                    }\n                    Object nodeId = data.get(\"nodeId\");\n                    if (nodeId != null) {\n                        row.put(\"nodeId\", nodeId);\n                    }\n                    Object elapsed = data.get(\"elapsed\");\n                    if (elapsed != null) {\n                        row.put(\"elapsed\", elapsed);\n                    }\n                    Object duration = data.get(\"duration\");\n                    if (duration != null) {\n                        row.put(\"duration\", duration);\n                    }\n                    answer.add(row);\n                }\n            }\n        }\n\n        return answer;\n    }","commit_id":"e1e8de57a8651882c173013805f7200a7ab5aaf5","url":"https://github.com/apache/camel"},{"original_method":"public static CompositeType listInflightExchangesCompositeType() throws OpenDataException {\n        return new CompositeType(\"exchanges\", \"Exchanges\", new String[]{\"exchangeId\", \"routeId\", \"nodeId\", \"duration\", \"elapsed\"},\n                new String[]{\"Exchange Id\", \"RouteId\", \"NodeId\", \"Duration\", \"Elapsed\"},\n                new OpenType[]{SimpleType.STRING, SimpleType.STRING, SimpleType.STRING, SimpleType.STRING, SimpleType.STRING});\n    }","id":73853,"modified_method":"public static CompositeType listInflightExchangesCompositeType() throws OpenDataException {\n        return new CompositeType(\"exchanges\", \"Exchanges\", new String[]{\"exchangeId\", \"fromRouteId\", \"routeId\", \"nodeId\", \"elapsed\", \"duration\"},\n                new String[]{\"Exchange Id\", \"From RouteId\", \"RouteId\", \"NodeId\", \"Elapsed\", \"Duration\"},\n                new OpenType[]{SimpleType.STRING, SimpleType.STRING, SimpleType.STRING, SimpleType.STRING, SimpleType.STRING, SimpleType.STRING});\n    }","commit_id":"e1e8de57a8651882c173013805f7200a7ab5aaf5","url":"https://github.com/apache/camel"},{"original_method":"private Map<String, Integer> computeColumnWidths(final Iterable<Map<String, Object>> inflight) throws Exception {\n        if (inflight == null) {\n            throw new IllegalArgumentException(\"Unable to determine column widths from null Iterable<Inflight>\");\n        } else {\n            int maxExchangeLen = 0;\n            int maxRouteLen = 0;\n            int maxNodeLen = 0;\n            int maxDurationLen = 0;\n            int maxElapsedLen = 0;\n\n            for (Map<String, Object> row : inflight) {\n                final String exchangeId = safeNull(row.get(\"exchangeId\"));\n                maxExchangeLen = java.lang.Math.max(maxExchangeLen, exchangeId == null ? 0 : exchangeId.length());\n\n                final String routeId = safeNull(row.get(\"routeId\"));\n                maxRouteLen = java.lang.Math.max(maxRouteLen, routeId == null ? 0 : routeId.length());\n\n                final String nodeId = safeNull(row.get(\"nodeId\"));\n                maxNodeLen = java.lang.Math.max(maxNodeLen, nodeId == null ? 0 : nodeId.length());\n\n                final String duration = safeNull(row.get(\"duration\"));\n                maxDurationLen = java.lang.Math.max(maxDurationLen, duration == null ? 0 : duration.length());\n\n                final String elapsed = safeNull(row.get(\"elapsed\"));\n                maxElapsedLen = java.lang.Math.max(maxElapsedLen, elapsed == null ? 0 : elapsed.length());\n            }\n\n            final Map<String, Integer> retval = new Hashtable<String, Integer>(5);\n            retval.put(EXCHANGE_COLUMN_LABEL, maxExchangeLen);\n            retval.put(ROUTE_COLUMN_LABEL, maxRouteLen);\n            retval.put(NODE_COLUMN_LABEL, maxNodeLen);\n            retval.put(DURATION_COLUMN_LABEL, maxDurationLen);\n            retval.put(ELAPSED_COLUMN_LABEL, maxElapsedLen);\n\n            return retval;\n        }\n    }","id":73854,"modified_method":"private Map<String, Integer> computeColumnWidths(final Iterable<Map<String, Object>> inflight) throws Exception {\n        if (inflight == null) {\n            throw new IllegalArgumentException(\"Unable to determine column widths from null Iterable<Inflight>\");\n        } else {\n            int maxExchangeLen = 0;\n            int maxFromRouteLen = 0;\n            int maxRouteLen = 0;\n            int maxNodeLen = 0;\n            int maxElapsedLen = 0;\n            int maxDurationLen = 0;\n\n            for (Map<String, Object> row : inflight) {\n                final String exchangeId = safeNull(row.get(\"exchangeId\"));\n                maxExchangeLen = java.lang.Math.max(maxExchangeLen, exchangeId == null ? 0 : exchangeId.length());\n\n                final String fromRouteId = safeNull(row.get(\"fromRouteId\"));\n                maxFromRouteLen = java.lang.Math.max(maxFromRouteLen, fromRouteId == null ? 0 : fromRouteId.length());\n\n                final String routeId = safeNull(row.get(\"routeId\"));\n                maxRouteLen = java.lang.Math.max(maxRouteLen, routeId == null ? 0 : routeId.length());\n\n                final String nodeId = safeNull(row.get(\"nodeId\"));\n                maxNodeLen = java.lang.Math.max(maxNodeLen, nodeId == null ? 0 : nodeId.length());\n\n                final String elapsed = safeNull(row.get(\"elapsed\"));\n                maxElapsedLen = java.lang.Math.max(maxElapsedLen, elapsed == null ? 0 : elapsed.length());\n\n                final String duration = safeNull(row.get(\"duration\"));\n                maxDurationLen = java.lang.Math.max(maxDurationLen, duration == null ? 0 : duration.length());\n            }\n\n            final Map<String, Integer> retval = new Hashtable<String, Integer>(5);\n            retval.put(EXCHANGE_COLUMN_LABEL, maxExchangeLen);\n            retval.put(FROM_ROUTE_COLUMN_LABEL, maxFromRouteLen);\n            retval.put(ROUTE_COLUMN_LABEL, maxRouteLen);\n            retval.put(NODE_COLUMN_LABEL, maxNodeLen);\n            retval.put(ELAPSED_COLUMN_LABEL, maxElapsedLen);\n            retval.put(DURATION_COLUMN_LABEL, maxDurationLen);\n\n            return retval;\n        }\n    }","commit_id":"e1e8de57a8651882c173013805f7200a7ab5aaf5","url":"https://github.com/apache/camel"},{"original_method":"private static String buildFormatString(final Map<String, Integer> columnWidths, final boolean isHeader) {\n        final String fieldPreamble;\n        final String fieldPostamble;\n        final int columnWidthIncrement;\n\n        if (isHeader) {\n            fieldPreamble = DEFAULT_HEADER_PREAMBLE;\n            fieldPostamble = DEFAULT_HEADER_POSTAMBLE;\n        } else {\n            fieldPreamble = DEFAULT_FIELD_PREAMBLE;\n            fieldPostamble = DEFAULT_FIELD_POSTAMBLE;\n        }\n        columnWidthIncrement = DEFAULT_COLUMN_WIDTH_INCREMENT;\n\n        int exchangeLen = Math.min(columnWidths.get(EXCHANGE_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n        int routeLen = Math.min(columnWidths.get(ROUTE_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n        int nodeLen = Math.min(columnWidths.get(NODE_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n        int durationLen = Math.min(columnWidths.get(DURATION_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n        int elapsedLen = Math.min(columnWidths.get(ELAPSED_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n        exchangeLen = Math.max(MIN_COLUMN_WIDTH, exchangeLen);\n        routeLen = Math.max(MIN_COLUMN_WIDTH, routeLen);\n        nodeLen = Math.max(MIN_COLUMN_WIDTH, nodeLen);\n        durationLen = Math.max(13, durationLen);\n        elapsedLen = Math.max(MIN_COLUMN_WIDTH, elapsedLen);\n\n        final StringBuilder retval = new StringBuilder(DEFAULT_FORMAT_BUFFER_LENGTH);\n        retval.append(fieldPreamble).append(\"%-\").append(exchangeLen).append('.').append(exchangeLen).append('s').append(fieldPostamble).append(' ');\n        retval.append(fieldPreamble).append(\"%-\").append(routeLen).append('.').append(routeLen).append('s').append(fieldPostamble).append(' ');\n        retval.append(fieldPreamble).append(\"%-\").append(nodeLen).append('.').append(nodeLen).append('s').append(fieldPostamble).append(' ');\n        retval.append(fieldPreamble).append(\"%\").append(durationLen).append('.').append(durationLen).append('s').append(fieldPostamble).append(' ');\n        retval.append(fieldPreamble).append(\"%\").append(elapsedLen).append('.').append(elapsedLen).append('s').append(fieldPostamble).append(' ');\n\n        return retval.toString();\n    }","id":73855,"modified_method":"private static String buildFormatString(final Map<String, Integer> columnWidths, final boolean isHeader) {\n        final String fieldPreamble;\n        final String fieldPostamble;\n        final int columnWidthIncrement;\n\n        if (isHeader) {\n            fieldPreamble = DEFAULT_HEADER_PREAMBLE;\n            fieldPostamble = DEFAULT_HEADER_POSTAMBLE;\n        } else {\n            fieldPreamble = DEFAULT_FIELD_PREAMBLE;\n            fieldPostamble = DEFAULT_FIELD_POSTAMBLE;\n        }\n        columnWidthIncrement = DEFAULT_COLUMN_WIDTH_INCREMENT;\n\n        int exchangeLen = Math.min(columnWidths.get(EXCHANGE_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n        int fromRouteLen = Math.min(columnWidths.get(FROM_ROUTE_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n        int routeLen = Math.min(columnWidths.get(ROUTE_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n        int nodeLen = Math.min(columnWidths.get(NODE_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n        int elapsedLen = Math.min(columnWidths.get(ELAPSED_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n        int durationLen = Math.min(columnWidths.get(DURATION_COLUMN_LABEL) + columnWidthIncrement, MAX_COLUMN_WIDTH);\n        exchangeLen = Math.max(MIN_COLUMN_WIDTH, exchangeLen);\n        fromRouteLen = Math.max(MIN_COLUMN_WIDTH, fromRouteLen);\n        routeLen = Math.max(MIN_COLUMN_WIDTH, routeLen);\n        nodeLen = Math.max(MIN_COLUMN_WIDTH, nodeLen);\n        elapsedLen = Math.max(MIN_COLUMN_WIDTH, elapsedLen);\n        durationLen = Math.max(13, durationLen);\n\n        final StringBuilder retval = new StringBuilder(DEFAULT_FORMAT_BUFFER_LENGTH);\n        retval.append(fieldPreamble).append(\"%-\").append(exchangeLen).append('.').append(exchangeLen).append('s').append(fieldPostamble).append(' ');\n        retval.append(fieldPreamble).append(\"%-\").append(fromRouteLen).append('.').append(fromRouteLen).append('s').append(fieldPostamble).append(' ');\n        retval.append(fieldPreamble).append(\"%-\").append(routeLen).append('.').append(routeLen).append('s').append(fieldPostamble).append(' ');\n        retval.append(fieldPreamble).append(\"%-\").append(nodeLen).append('.').append(nodeLen).append('s').append(fieldPostamble).append(' ');\n        retval.append(fieldPreamble).append(\"%\").append(elapsedLen).append('.').append(elapsedLen).append('s').append(fieldPostamble).append(' ');\n        retval.append(fieldPreamble).append(\"%\").append(durationLen).append('.').append(durationLen).append('s').append(fieldPostamble).append(' ');\n\n        return retval.toString();\n    }","commit_id":"e1e8de57a8651882c173013805f7200a7ab5aaf5","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected Object performContextCommand(CamelController camelController, String contextName, PrintStream out, PrintStream err) throws Exception {\n        List<Map<String, Object>> inflight = camelController.browseInflightExchanges(contextName, limit, sortByLongestDuration);\n\n        final Map<String, Integer> columnWidths = computeColumnWidths(inflight);\n        final String headerFormat = buildFormatString(columnWidths, true);\n        final String rowFormat = buildFormatString(columnWidths, false);\n\n        if (inflight.size() > 0) {\n            out.println(String.format(headerFormat, EXCHANGE_COLUMN_LABEL, ROUTE_COLUMN_LABEL, NODE_COLUMN_LABEL, DURATION_COLUMN_LABEL, ELAPSED_COLUMN_LABEL));\n            out.println(String.format(headerFormat, \"----------\", \"-----\", \"----\", \"-------------\", \"------------\"));\n            for (Map<String, Object> row : inflight) {\n                Object exchangeId = row.get(\"exchangeId\");\n                Object routeId = row.get(\"routeId\");\n                Object state = row.get(\"nodeId\");\n                Object duration = row.get(\"duration\");\n                Object elapsed = row.get(\"elapsed\");\n                out.println(String.format(rowFormat, exchangeId, routeId, state, safeNull(duration), safeNull(elapsed)));\n            }\n        }\n\n        return null;\n    }","id":73856,"modified_method":"@Override\n    protected Object performContextCommand(CamelController camelController, String contextName, PrintStream out, PrintStream err) throws Exception {\n        List<Map<String, Object>> inflight = camelController.browseInflightExchanges(contextName, limit, sortByLongestDuration);\n\n        final Map<String, Integer> columnWidths = computeColumnWidths(inflight);\n        final String headerFormat = buildFormatString(columnWidths, true);\n        final String rowFormat = buildFormatString(columnWidths, false);\n\n        if (inflight.size() > 0) {\n            out.println(String.format(headerFormat, EXCHANGE_COLUMN_LABEL, FROM_ROUTE_COLUMN_LABEL, ROUTE_COLUMN_LABEL, NODE_COLUMN_LABEL, ELAPSED_COLUMN_LABEL, DURATION_COLUMN_LABEL));\n            out.println(String.format(headerFormat, \"----------\", \"----------\", \"-----\", \"----\", \"------------\", \"-------------\"));\n            for (Map<String, Object> row : inflight) {\n                Object exchangeId = row.get(\"exchangeId\");\n                Object fromRouteId = row.get(\"fromRouteId\");\n                Object routeId = row.get(\"routeId\");\n                Object nodeId = row.get(\"nodeId\");\n                Object elapsed = row.get(\"elapsed\");\n                Object duration = row.get(\"duration\");\n                out.println(String.format(rowFormat, exchangeId, fromRouteId, routeId, nodeId, safeNull(elapsed), safeNull(duration)));\n            }\n        }\n\n        return null;\n    }","commit_id":"e1e8de57a8651882c173013805f7200a7ab5aaf5","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public List<Map<String, Object>> browseInflightExchanges(String camelContextName, int limit, boolean sortByLongestDuration) throws Exception {\n        if (jolokia == null) {\n            throw new IllegalStateException(\"Need to connect to remote jolokia first\");\n        }\n\n        List<Map<String, Object>> answer = new ArrayList<Map<String, Object>>();\n\n        ObjectName found = lookupCamelContext(camelContextName);\n        if (found != null) {\n            String pattern = String.format(\"%s:context=%s,type=services,name=DefaultInflightRepository\", found.getDomain(), found.getKeyProperty(\"context\"));\n            ObjectName on = ObjectName.getInstance(pattern);\n            J4pExecResponse er = jolokia.execute(new J4pExecRequest(on, \"browse(int,boolean)\", limit, sortByLongestDuration));\n            if (er != null) {\n                JSONObject data = er.getValue();\n                if (data != null) {\n                    for (Object obj : data.values()) {\n                        JSONObject inflight = (JSONObject) obj;\n\n                        Map<String, Object> row = new LinkedHashMap<String, Object>();\n                        row.put(\"exchangeId\", asString(inflight.get(\"exchangeId\")));\n                        row.put(\"routeId\", asString(inflight.get(\"routeId\")));\n                        row.put(\"nodeId\", asString(inflight.get(\"nodeId\")));\n                        row.put(\"duration\", asString(inflight.get(\"duration\")));\n                        row.put(\"elapsed\", asString(inflight.get(\"elapsed\")));\n                        answer.add(row);\n                    }\n                }\n            }\n        }\n\n        return answer;\n    }","id":73857,"modified_method":"@Override\n    public List<Map<String, Object>> browseInflightExchanges(String camelContextName, int limit, boolean sortByLongestDuration) throws Exception {\n        if (jolokia == null) {\n            throw new IllegalStateException(\"Need to connect to remote jolokia first\");\n        }\n\n        List<Map<String, Object>> answer = new ArrayList<Map<String, Object>>();\n\n        ObjectName found = lookupCamelContext(camelContextName);\n        if (found != null) {\n            String pattern = String.format(\"%s:context=%s,type=services,name=DefaultInflightRepository\", found.getDomain(), found.getKeyProperty(\"context\"));\n            ObjectName on = ObjectName.getInstance(pattern);\n            J4pExecResponse er = jolokia.execute(new J4pExecRequest(on, \"browse(int,boolean)\", limit, sortByLongestDuration));\n            if (er != null) {\n                JSONObject data = er.getValue();\n                if (data != null) {\n                    for (Object obj : data.values()) {\n                        JSONObject inflight = (JSONObject) obj;\n\n                        Map<String, Object> row = new LinkedHashMap<String, Object>();\n                        row.put(\"exchangeId\", asString(inflight.get(\"exchangeId\")));\n                        row.put(\"fromRouteId\", asString(inflight.get(\"fromRouteId\")));\n                        row.put(\"routeId\", asString(inflight.get(\"routeId\")));\n                        row.put(\"nodeId\", asString(inflight.get(\"nodeId\")));\n                        row.put(\"elapsed\", asString(inflight.get(\"elapsed\")));\n                        row.put(\"duration\", asString(inflight.get(\"duration\")));\n                        answer.add(row);\n                    }\n                }\n            }\n        }\n\n        return answer;\n    }","commit_id":"e1e8de57a8651882c173013805f7200a7ab5aaf5","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public TabularData browse(int limit, boolean sortByLongestDuration) {\n        try {\n            TabularData answer = new TabularDataSupport(CamelOpenMBeanTypes.listInflightExchangesTabularType());\n            Collection<InflightRepository.InflightExchange> exchanges = inflightRepository.browse(limit, sortByLongestDuration);\n\n            for (InflightRepository.InflightExchange entry : exchanges) {\n                CompositeType ct = CamelOpenMBeanTypes.listInflightExchangesCompositeType();\n                String exchangeId = entry.getExchange().getExchangeId();\n                String routeId = entry.getRouteId();\n                String nodeId = entry.getNodeId();\n                String duration = \"\" + entry.getDuration();\n                String elapsed = \"\" + entry.getElapsed();\n\n                CompositeData data = new CompositeDataSupport(ct,\n                        new String[]{\"exchangeId\", \"routeId\", \"nodeId\", \"duration\", \"elapsed\"},\n                        new Object[]{exchangeId, routeId, nodeId, duration, elapsed});\n                answer.put(data);\n            }\n            return answer;\n        } catch (Exception e) {\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        }\n    }","id":73858,"modified_method":"@Override\n    public TabularData browse(int limit, boolean sortByLongestDuration) {\n        try {\n            TabularData answer = new TabularDataSupport(CamelOpenMBeanTypes.listInflightExchangesTabularType());\n            Collection<InflightRepository.InflightExchange> exchanges = inflightRepository.browse(limit, sortByLongestDuration);\n\n            for (InflightRepository.InflightExchange entry : exchanges) {\n                CompositeType ct = CamelOpenMBeanTypes.listInflightExchangesCompositeType();\n                String exchangeId = entry.getExchange().getExchangeId();\n                String fromRouteId = entry.getExchange().getFromRouteId();\n                String routeId = entry.getRouteId();\n                String nodeId = entry.getNodeId();\n                String elapsed = \"\" + entry.getElapsed();\n                String duration = \"\" + entry.getDuration();\n\n                CompositeData data = new CompositeDataSupport(ct,\n                        new String[]{\"exchangeId\", \"fromRouteId\", \"routeId\", \"nodeId\", \"elapsed\", \"duration\"},\n                        new Object[]{exchangeId, fromRouteId, routeId, nodeId, elapsed, duration});\n                answer.put(data);\n            }\n            return answer;\n        } catch (Exception e) {\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        }\n    }","commit_id":"e1e8de57a8651882c173013805f7200a7ab5aaf5","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n        if (client == null) {\n            \n            AsyncHttpClientConfig config = null;\n            \n            if (clientConfig != null) {\n                AsyncHttpClientConfig.Builder builder = AhcComponent.cloneConfig(clientConfig);\n                \n                if (sslContextParameters != null) {\n                    builder.setSSLContext(sslContextParameters.createSSLContext());\n                }\n                \n                config = builder.build();\n            } else {\n                if (sslContextParameters != null) {\n                    AsyncHttpClientConfig.Builder builder =\n                        new AsyncHttpClientConfig.Builder();\n                    \n                    builder.setSSLContext(sslContextParameters.createSSLContext());\n                    config = builder.build();\n                }\n            }\n            \n            if (config == null) {\n                client = new AsyncHttpClient();\n            } else {\n                client = new AsyncHttpClient(config);\n            }\n        }\n    }","id":73859,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        super.doStart();\n        if (client == null) {\n            \n            AsyncHttpClientConfig config = null;\n            \n            if (clientConfig != null) {\n                AsyncHttpClientConfig.Builder builder = AhcComponent.cloneConfig(clientConfig);\n                \n                if (sslContextParameters != null) {\n\n                    // TODO: Remove us, but part of investigation issue on Java7 on ubuntu\n                    System.out.println(sslContextParameters);\n                    SSLContext ssl = sslContextParameters.createSSLContext();\n                    System.out.println(ssl);\n\n                    builder.setSSLContext(ssl);\n                }\n                \n                config = builder.build();\n            } else {\n                if (sslContextParameters != null) {\n                    AsyncHttpClientConfig.Builder builder =\n                        new AsyncHttpClientConfig.Builder();\n\n                    // TODO: Remove us, but part of investigation issue on Java7 on ubuntu\n                    System.out.println(sslContextParameters);\n\n                    SSLContext ssl = sslContextParameters.createSSLContext();\n                    System.out.println(ssl);\n\n                    builder.setSSLContext(ssl);\n                    config = builder.build();\n                }\n            }\n            \n            if (config == null) {\n                client = new AsyncHttpClient();\n            } else {\n                client = new AsyncHttpClient(config);\n            }\n        }\n    }","commit_id":"974cd1d9c2919ddafb57ad7c954e58946f814de6","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWSHttpCall() throws Exception {\n        AsyncHttpClient c = new AsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://127.0.0.1:\" + port + \"/test\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketTextListener() {\n                    @Override\n                    public void onMessage(String message) {\n                        received.add(message);\n                        log.info(\"received --> \" + message);\n                        latch.countDown();\n                    }\n\n                   \n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        getMockEndpoint(\"mock:client\").expectedBodiesReceived(\"Hello from WS client\");\n\n        websocket.sendMessage(\"Hello from WS client\");\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertMockEndpointsSatisfied();\n\n        assertEquals(10, received.size());\n        for (int i = 0; i < 10; i++) {\n            assertEquals(\">> Welcome on board!\", received.get(i));\n        }\n\n        websocket.close();\n        c.close();\n    }","id":73860,"modified_method":"@Test\n    public void testWSHttpCall() throws Exception {\n        AsyncHttpClient c = new DefaultAsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://127.0.0.1:\" + port + \"/test\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketTextListener() {\n                    @Override\n                    public void onMessage(String message) {\n                        received.add(message);\n                        log.info(\"received --> \" + message);\n                        latch.countDown();\n                    }\n\n                   \n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        getMockEndpoint(\"mock:client\").expectedBodiesReceived(\"Hello from WS client\");\n\n        websocket.sendMessage(\"Hello from WS client\");\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertMockEndpointsSatisfied();\n\n        assertEquals(10, received.size());\n        for (int i = 0; i < 10; i++) {\n            assertEquals(\">> Welcome on board!\", received.get(i));\n        }\n\n        websocket.close();\n        c.close();\n    }","commit_id":"3b2b6e20a9d89fe251aef69865e6c2d85ba8a0c4","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWSHttpCall() throws Exception {\n        AsyncHttpClient c = new AsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://localhost:\" + port + \"/echo\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketTextListener() {\n                    @Override\n                    public void onMessage(String message) {\n                        received.add(message);\n                        log.info(\"received --> \" + message);\n                        latch.countDown();\n                    }\n\n                        \n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        websocket.sendMessage(\"Beer\");\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(1, received.size());\n        assertEquals(\"BeerBeer\", received.get(0));\n\n        websocket.close();\n        c.close();\n    }","id":73861,"modified_method":"@Test\n    public void testWSHttpCall() throws Exception {\n        AsyncHttpClient c = new DefaultAsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://localhost:\" + port + \"/echo\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketTextListener() {\n                    @Override\n                    public void onMessage(String message) {\n                        received.add(message);\n                        log.info(\"received --> \" + message);\n                        latch.countDown();\n                    }\n\n                        \n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        websocket.sendMessage(\"Beer\");\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(1, received.size());\n        assertEquals(\"BeerBeer\", received.get(0));\n\n        websocket.close();\n        c.close();\n    }","commit_id":"3b2b6e20a9d89fe251aef69865e6c2d85ba8a0c4","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWSBytesHttpCall() throws Exception {\n        AsyncHttpClient c = new AsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://127.0.0.1:\" + port + \"/echo\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketListener() {\n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        MockEndpoint result = getMockEndpoint(\"mock:result\");\n        final byte[] testmessage = \"Test\".getBytes(\"utf-8\");\n        result.expectedBodiesReceived(testmessage);\n\n        websocket.sendMessage(testmessage);\n\n        result.assertIsSatisfied();\n\n        websocket.close();\n        c.close();\n    }","id":73862,"modified_method":"@Test\n    public void testWSBytesHttpCall() throws Exception {\n        AsyncHttpClient c = new DefaultAsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://127.0.0.1:\" + port + \"/echo\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketListener() {\n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        MockEndpoint result = getMockEndpoint(\"mock:result\");\n        final byte[] testmessage = \"Test\".getBytes(\"utf-8\");\n        result.expectedBodiesReceived(testmessage);\n\n        websocket.sendMessage(testmessage);\n\n        result.assertIsSatisfied();\n\n        websocket.close();\n        c.close();\n    }","commit_id":"3b2b6e20a9d89fe251aef69865e6c2d85ba8a0c4","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWSHttpCall() throws Exception {\n        AsyncHttpClient c = new AsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://127.0.0.1:\" + port + \"/echo\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketListener() {\n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        MockEndpoint result = getMockEndpoint(\"mock:result\");\n        result.expectedBodiesReceived(\"Test\");\n\n        websocket.sendMessage(\"Test\");\n\n        result.assertIsSatisfied();\n        \n        websocket.close();\n        c.close();\n    }","id":73863,"modified_method":"@Test\n    public void testWSHttpCall() throws Exception {\n        AsyncHttpClient c = new DefaultAsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://127.0.0.1:\" + port + \"/echo\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketListener() {\n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        MockEndpoint result = getMockEndpoint(\"mock:result\");\n        result.expectedBodiesReceived(\"Test\");\n\n        websocket.sendMessage(\"Test\");\n\n        result.assertIsSatisfied();\n        \n        websocket.close();\n        c.close();\n    }","commit_id":"3b2b6e20a9d89fe251aef69865e6c2d85ba8a0c4","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWSHttpCall() throws Exception {\n        AsyncHttpClient c = new AsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://localhost:\" + port + \"/shop\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketTextListener() {\n                    @Override\n                    public void onMessage(String message) {\n                        received.add(message);\n                        log.info(\"received --> \" + message);\n                        latch.countDown();\n                    }\n\n                    \n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        // Send message to the direct endpoint\n        producer.sendBodyAndHeader(\"Beer on stock at Apache Mall\", WebsocketConstants.SEND_TO_ALL, \"true\");\n\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(1, received.size());\n        Object r = received.get(0);\n        assertTrue(r instanceof String);\n        assertEquals(\"Beer on stock at Apache Mall\", r);\n\n        websocket.close();\n        c.close();\n    }","id":73864,"modified_method":"@Test\n    public void testWSHttpCall() throws Exception {\n        AsyncHttpClient c = new DefaultAsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://localhost:\" + port + \"/shop\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketTextListener() {\n                    @Override\n                    public void onMessage(String message) {\n                        received.add(message);\n                        log.info(\"received --> \" + message);\n                        latch.countDown();\n                    }\n\n                    \n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        // Send message to the direct endpoint\n        producer.sendBodyAndHeader(\"Beer on stock at Apache Mall\", WebsocketConstants.SEND_TO_ALL, \"true\");\n\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(1, received.size());\n        Object r = received.get(0);\n        assertTrue(r instanceof String);\n        assertEquals(\"Beer on stock at Apache Mall\", r);\n\n        websocket.close();\n        c.close();\n    }","commit_id":"3b2b6e20a9d89fe251aef69865e6c2d85ba8a0c4","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWSBytesHttpCall() throws Exception {\n        AsyncHttpClient c = new AsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://localhost:\" + port + \"/shop\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketByteListener() {\n\n                    @Override\n                    public void onMessage(byte[] message) {\n                        received.add(message);\n                        log.info(\"received --> \" + Arrays.toString(message));\n                        latch.countDown();\n                    }\n\n                   \n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        // Send message to the direct endpoint\n        byte[] testmessage = \"Beer on stock at Apache Mall\".getBytes(\"utf-8\");\n        producer.sendBodyAndHeader(testmessage, WebsocketConstants.SEND_TO_ALL, \"true\");\n\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(1, received.size());\n        Object r = received.get(0);\n        assertTrue(r instanceof byte[]);\n        assertArrayEquals(testmessage, (byte[])r);\n\n        websocket.close();\n        c.close();\n    }","id":73865,"modified_method":"@Test\n    public void testWSBytesHttpCall() throws Exception {\n        AsyncHttpClient c = new DefaultAsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://localhost:\" + port + \"/shop\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new DefaultWebSocketListener() {\n\n                    @Override\n                    public void onMessage(byte[] message) {\n                        received.add(message);\n                        log.info(\"received --> \" + Arrays.toString(message));\n                        latch.countDown();\n                    }\n\n                   \n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        // Send message to the direct endpoint\n        byte[] testmessage = \"Beer on stock at Apache Mall\".getBytes(\"utf-8\");\n        producer.sendBodyAndHeader(testmessage, WebsocketConstants.SEND_TO_ALL, \"true\");\n\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(1, received.size());\n        Object r = received.get(0);\n        assertTrue(r instanceof byte[]);\n        assertArrayEquals(testmessage, (byte[])r);\n\n        websocket.close();\n        c.close();\n    }","commit_id":"3b2b6e20a9d89fe251aef69865e6c2d85ba8a0c4","url":"https://github.com/apache/camel"},{"original_method":"private void doTestWSHttpCall() throws Exception {\n        AsyncHttpClient c = new AsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://localhost:\" + port + \"/shop\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketTextListener() {\n                    @Override\n                    public void onMessage(String message) {\n                        received.add(message);\n                        log.info(\"received --> \" + message);\n                        latch.countDown();\n                    }\n                    \n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        // Send message to the direct endpoint\n        producer.sendBodyAndHeader(\"Beer on stock at Apache Mall\", WebsocketConstants.SEND_TO_ALL, \"true\");\n\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(1, received.size());\n        Object r = received.get(0);\n        assertTrue(r instanceof String);\n        assertEquals(\"Beer on stock at Apache Mall\", r);\n\n        websocket.close();\n        c.close();\n        \n    }","id":73866,"modified_method":"private void doTestWSHttpCall() throws Exception {\n        AsyncHttpClient c = new DefaultAsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://localhost:\" + port + \"/shop\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketTextListener() {\n                    @Override\n                    public void onMessage(String message) {\n                        received.add(message);\n                        log.info(\"received --> \" + message);\n                        latch.countDown();\n                    }\n                    \n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        // Send message to the direct endpoint\n        producer.sendBodyAndHeader(\"Beer on stock at Apache Mall\", WebsocketConstants.SEND_TO_ALL, \"true\");\n\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(1, received.size());\n        Object r = received.get(0);\n        assertTrue(r instanceof String);\n        assertEquals(\"Beer on stock at Apache Mall\", r);\n\n        websocket.close();\n        c.close();\n        \n    }","commit_id":"3b2b6e20a9d89fe251aef69865e6c2d85ba8a0c4","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWSHttpCall() throws Exception {\n        AsyncHttpClient c = new AsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://127.0.0.1:\" + port + \"/echo\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketTextListener() {\n                    @Override\n                    public void onMessage(String message) {\n                        received.add(message);\n                        log.info(\"received --> \" + message);\n                        latch.countDown();\n                    }\n\n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        websocket.sendMessage(\"Beer\");\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(1, received.size());\n        assertEquals(\"BeerBeer\", received.get(0));\n\n        websocket.close();\n        c.close();\n    }","id":73867,"modified_method":"@Test\n    public void testWSHttpCall() throws Exception {\n        AsyncHttpClient c = new DefaultAsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://127.0.0.1:\" + port + \"/echo\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketTextListener() {\n                    @Override\n                    public void onMessage(String message) {\n                        received.add(message);\n                        log.info(\"received --> \" + message);\n                        latch.countDown();\n                    }\n\n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        websocket.sendMessage(\"Beer\");\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(1, received.size());\n        assertEquals(\"BeerBeer\", received.get(0));\n\n        websocket.close();\n        c.close();\n    }","commit_id":"3b2b6e20a9d89fe251aef69865e6c2d85ba8a0c4","url":"https://github.com/apache/camel"},{"original_method":"protected AsyncHttpClient createAsyncHttpSSLClient() throws IOException, GeneralSecurityException {\n\n        AsyncHttpClient c;\n        AsyncHttpClientConfig config;\n\n        AsyncHttpClientConfig.Builder builder =\n                new AsyncHttpClientConfig.Builder();\n\n        builder.setSSLContext(new SSLContextParameters().createSSLContext(context));\n        builder.setAcceptAnyCertificate(true);\n        config = builder.build();\n        c = new AsyncHttpClient(config);\n\n        return c;\n    }","id":73868,"modified_method":"protected AsyncHttpClient createAsyncHttpSSLClient() throws IOException, GeneralSecurityException {\n\n        AsyncHttpClient c;\n        AsyncHttpClientConfig config;\n\n        DefaultAsyncHttpClientConfig.Builder builder =\n                new DefaultAsyncHttpClientConfig.Builder();\n\n        SSLContext sslContext = new SSLContextParameters().createSSLContext(context());\n        JdkSslContext ssl = new JdkSslContext(sslContext, true, ClientAuth.REQUIRE);\n        builder.setSslContext(ssl);\n        builder.setAcceptAnyCertificate(true);\n        config = builder.build();\n        c = new DefaultAsyncHttpClient(config);\n\n        return c;\n    }","commit_id":"3b2b6e20a9d89fe251aef69865e6c2d85ba8a0c4","url":"https://github.com/apache/camel"},{"original_method":"protected AsyncHttpClient createAsyncHttpSSLClient() throws IOException, GeneralSecurityException {\n\n        AsyncHttpClient c;\n        AsyncHttpClientConfig config;\n\n        AsyncHttpClientConfig.Builder builder =\n                new AsyncHttpClientConfig.Builder();\n\n        builder.setSSLContext(new SSLContextParameters().createSSLContext(context));\n        builder.setAcceptAnyCertificate(true);\n        config = builder.build();\n        c = new AsyncHttpClient(config);\n\n        return c;\n    }","id":73869,"modified_method":"protected AsyncHttpClient createAsyncHttpSSLClient() throws IOException, GeneralSecurityException {\n\n        AsyncHttpClient c;\n        AsyncHttpClientConfig config;\n\n        DefaultAsyncHttpClientConfig.Builder builder =\n                new DefaultAsyncHttpClientConfig.Builder();\n\n        SSLContext sslContext = new SSLContextParameters().createSSLContext(context());\n        JdkSslContext ssl = new JdkSslContext(sslContext, true, ClientAuth.REQUIRE);\n        builder.setSslContext(ssl);\n        builder.setAcceptAnyCertificate(true);\n        config = builder.build();\n        c = new DefaultAsyncHttpClient(config);\n\n        return c;\n    }","commit_id":"3b2b6e20a9d89fe251aef69865e6c2d85ba8a0c4","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWSHttpCallEcho() throws Exception {\n\n        // We call the route WebSocket BAR\n        received.clear();\n        latch = new CountDownLatch(1);\n\n        AsyncHttpClient c = new AsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://localhost:\" + port + \"/bar\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketTextListener() {\n                    @Override\n                    public void onMessage(String message) {\n                        received.add(message);\n                        log.info(\"received --> \" + message);\n                        latch.countDown();\n                    }\n\n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        websocket.sendMessage(\"Beer\");\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(1, received.size());\n        assertEquals(\"The bar has Beer\", received.get(0));\n\n        websocket.close();\n        c.close();\n\n        // We call the route WebSocket PUB\n        received.clear();\n        latch = new CountDownLatch(1);\n\n        c = new AsyncHttpClient();\n\n        websocket = c.prepareGet(\"ws://localhost:\" + port + \"/pub\").execute(\n                new WebSocketUpgradeHandler.Builder()\n                        .addWebSocketListener(new WebSocketTextListener() {\n                            @Override\n                            public void onMessage(String message) {\n                                received.add(message);\n                                log.info(\"received --> \" + message);\n                                latch.countDown();\n                            }\n\n                                \n                            @Override\n                            public void onOpen(WebSocket websocket) {\n                            }\n\n                            @Override\n                            public void onClose(WebSocket websocket) {\n                            }\n\n                            @Override\n                            public void onError(Throwable t) {\n                                t.printStackTrace();\n                            }\n                        }).build()).get();\n\n        websocket.sendMessage(\"wine\");\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(1, received.size());\n        assertEquals(\"The pub has wine\", received.get(0));\n\n        websocket.close();\n        c.close();\n    }","id":73870,"modified_method":"@Test\n    public void testWSHttpCallEcho() throws Exception {\n\n        // We call the route WebSocket BAR\n        received.clear();\n        latch = new CountDownLatch(1);\n\n        AsyncHttpClient c = new DefaultAsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://localhost:\" + port + \"/bar\").execute(\n            new WebSocketUpgradeHandler.Builder()\n                .addWebSocketListener(new WebSocketTextListener() {\n                    @Override\n                    public void onMessage(String message) {\n                        received.add(message);\n                        log.info(\"received --> \" + message);\n                        latch.countDown();\n                    }\n\n                    @Override\n                    public void onOpen(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onClose(WebSocket websocket) {\n                    }\n\n                    @Override\n                    public void onError(Throwable t) {\n                        t.printStackTrace();\n                    }\n                }).build()).get();\n\n        websocket.sendMessage(\"Beer\");\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(1, received.size());\n        assertEquals(\"The bar has Beer\", received.get(0));\n\n        websocket.close();\n        c.close();\n\n        // We call the route WebSocket PUB\n        received.clear();\n        latch = new CountDownLatch(1);\n\n        c = new DefaultAsyncHttpClient();\n\n        websocket = c.prepareGet(\"ws://localhost:\" + port + \"/pub\").execute(\n                new WebSocketUpgradeHandler.Builder()\n                        .addWebSocketListener(new WebSocketTextListener() {\n                            @Override\n                            public void onMessage(String message) {\n                                received.add(message);\n                                log.info(\"received --> \" + message);\n                                latch.countDown();\n                            }\n\n                                \n                            @Override\n                            public void onOpen(WebSocket websocket) {\n                            }\n\n                            @Override\n                            public void onClose(WebSocket websocket) {\n                            }\n\n                            @Override\n                            public void onError(Throwable t) {\n                                t.printStackTrace();\n                            }\n                        }).build()).get();\n\n        websocket.sendMessage(\"wine\");\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(1, received.size());\n        assertEquals(\"The pub has wine\", received.get(0));\n\n        websocket.close();\n        c.close();\n    }","commit_id":"3b2b6e20a9d89fe251aef69865e6c2d85ba8a0c4","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWSHttpCallEcho() throws Exception {\n\n        // We call the route WebSocket BAR\n        received.clear();\n        latch = new CountDownLatch(2);\n\n        AsyncHttpClient c = new AsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://localhost:\" + port + \"/bar\").execute(\n                new WebSocketUpgradeHandler.Builder()\n                        .addWebSocketListener(new WebSocketTextListener() {\n                            @Override\n                            public void onMessage(String message) {\n                                received.add(message);\n                                log.info(\"received --> \" + message);\n                                latch.countDown();\n                            }\n\n                            @Override\n                            public void onOpen(WebSocket websocket) {\n                            }\n\n                            @Override\n                            public void onClose(WebSocket websocket) {\n                            }\n\n                            @Override\n                            public void onError(Throwable t) {\n                                t.printStackTrace();\n                            }\n                        }).build()).get();\n\n        websocket.sendMessage(\"Beer\");\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(2, received.size());\n\n        //Cannot guarantee the order in which messages are received\n        assertTrue(received.contains(\"The bar has Beer\"));\n        assertTrue(received.contains(\"Broadcasting to Bar\"));\n\n        websocket.close();\n        c.close();\n    }","id":73871,"modified_method":"@Test\n    public void testWSHttpCallEcho() throws Exception {\n\n        // We call the route WebSocket BAR\n        received.clear();\n        latch = new CountDownLatch(2);\n\n        AsyncHttpClient c = new DefaultAsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://localhost:\" + port + \"/bar\").execute(\n                new WebSocketUpgradeHandler.Builder()\n                        .addWebSocketListener(new WebSocketTextListener() {\n                            @Override\n                            public void onMessage(String message) {\n                                received.add(message);\n                                log.info(\"received --> \" + message);\n                                latch.countDown();\n                            }\n\n                            @Override\n                            public void onOpen(WebSocket websocket) {\n                            }\n\n                            @Override\n                            public void onClose(WebSocket websocket) {\n                            }\n\n                            @Override\n                            public void onError(Throwable t) {\n                                t.printStackTrace();\n                            }\n                        }).build()).get();\n\n        websocket.sendMessage(\"Beer\");\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(2, received.size());\n\n        //Cannot guarantee the order in which messages are received\n        assertTrue(received.contains(\"The bar has Beer\"));\n        assertTrue(received.contains(\"Broadcasting to Bar\"));\n\n        websocket.close();\n        c.close();\n    }","commit_id":"3b2b6e20a9d89fe251aef69865e6c2d85ba8a0c4","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testWSHttpCallEcho() throws Exception {\n\n        // We call the route WebSocket BAR\n        received.clear();\n        latch = new CountDownLatch(2);\n\n        AsyncHttpClient c = new AsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://localhost:\" + port + \"/bar\").execute(\n                new WebSocketUpgradeHandler.Builder()\n                        .addWebSocketListener(new WebSocketTextListener() {\n                            @Override\n                            public void onMessage(String message) {\n                                received.add(message);\n                                log.info(\"received --> \" + message);\n                                latch.countDown();\n                            }\n\n                            @Override\n                            public void onOpen(WebSocket websocket) {\n                            }\n\n                            @Override\n                            public void onClose(WebSocket websocket) {\n                            }\n\n                            @Override\n                            public void onError(Throwable t) {\n                                t.printStackTrace();\n                            }\n                        }).build()).get();\n\n        websocket.sendMessage(\"Beer\");\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(2, received.size());\n\n        //Cannot guarantee the order in which messages are received\n        assertTrue(received.contains(\"The bar has Beer\"));\n        assertTrue(received.contains(\"Broadcasting to Bar\"));\n\n        websocket.close();\n        c.close();\n    }","id":73872,"modified_method":"@Test\n    public void testWSHttpCallEcho() throws Exception {\n\n        // We call the route WebSocket BAR\n        received.clear();\n        latch = new CountDownLatch(2);\n\n        DefaultAsyncHttpClient c = new DefaultAsyncHttpClient();\n\n        WebSocket websocket = c.prepareGet(\"ws://localhost:\" + port + \"/bar\").execute(\n                new WebSocketUpgradeHandler.Builder()\n                        .addWebSocketListener(new WebSocketTextListener() {\n                            @Override\n                            public void onMessage(String message) {\n                                received.add(message);\n                                log.info(\"received --> \" + message);\n                                latch.countDown();\n                            }\n\n                            @Override\n                            public void onOpen(WebSocket websocket) {\n                            }\n\n                            @Override\n                            public void onClose(WebSocket websocket) {\n                            }\n\n                            @Override\n                            public void onError(Throwable t) {\n                                t.printStackTrace();\n                            }\n                        }).build()).get();\n\n        websocket.sendMessage(\"Beer\");\n        assertTrue(latch.await(10, TimeUnit.SECONDS));\n\n        assertEquals(2, received.size());\n\n        //Cannot guarantee the order in which messages are received\n        assertTrue(received.contains(\"The bar has Beer\"));\n        assertTrue(received.contains(\"Broadcasting to Bar\"));\n\n        websocket.close();\n        c.close();\n    }","commit_id":"3b2b6e20a9d89fe251aef69865e6c2d85ba8a0c4","url":"https://github.com/apache/camel"},{"original_method":"protected void cleanAndLogin(String user) throws IOException {\n    // clear the loginUser and re-login with new user\n    synchronized (LoginUser.class) {\n      Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n      ClientContext.getConf().set(Constants.SECURITY_LOGIN_USERNAME, user);\n      LoginUser.get(ClientContext.getConf());\n    }\n  }","id":73873,"modified_method":"protected void cleanAndLogin(String user) throws IOException {\n    LoginUserTestUtils.updateLoginUser(ClientContext.getConf(), user);\n  }","commit_id":"86d917314f4f19a9e918e076555a5714461e7b22","url":"https://github.com/amplab/tachyon"},{"original_method":"@Before\n  public final void before() throws Exception {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    mLocalTachyonCluster = mLocalTachyonClusterResource.get();\n    mTfs = mLocalTachyonCluster.getClient();\n    mFsShell = new TfsShell(new TachyonConf());\n    mOutput = new ByteArrayOutputStream();\n    mNewOutput = new PrintStream(mOutput);\n    mOldOutput = System.out;\n    System.setOut(mNewOutput);\n  }","id":73874,"modified_method":"@Before\n  public final void before() throws Exception {\n    cleanLoginUser();\n    mLocalTachyonCluster = mLocalTachyonClusterResource.get();\n    mTfs = mLocalTachyonCluster.getClient();\n    mFsShell = new TfsShell(new TachyonConf());\n    mOutput = new ByteArrayOutputStream();\n    mNewOutput = new PrintStream(mOutput);\n    mOldOutput = System.out;\n    System.setOut(mNewOutput);\n  }","commit_id":"86d917314f4f19a9e918e076555a5714461e7b22","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test(timeout = 10000)\n  @LocalTachyonClusterResource.Config(tachyonConfParams = {Constants.SECURITY_AUTHENTICATION_TYPE,\n      \"CUSTOM\", Constants.SECURITY_AUTHENTICATION_CUSTOM_PROVIDER,\n      NameMatchAuthenticationProvider.FULL_CLASS_NAME,\n      Constants.SECURITY_LOGIN_USERNAME, \"tachyon\"})\n  public void customAuthenticationDenyConnectTest() throws Exception {\n    // Using no-tachyon as loginUser to connect to Worker, the IOException will be thrown\n    ClientContext.getConf().set(Constants.SECURITY_LOGIN_USERNAME, \"no-tachyon\");\n\n    mThrown.expect(IOException.class);\n    mThrown.expectMessage(\"Failed to connect to the worker\");\n\n    BlockWorkerClient blockWorkerClient = new BlockWorkerClient(\n        mLocalTachyonClusterResource.get().getWorkerAddress(),\n        mExecutorService, ClientContext.getConf(),\n        1 /* fake session id */, true, new ClientMetrics());\n    try {\n      Assert.assertFalse(blockWorkerClient.isConnected());\n      // Clear the login user so that it will be reloaded and pick up our no-tachyon change\n      clearLoginUser();\n      blockWorkerClient.connect();\n    } finally {\n      blockWorkerClient.close();\n      ClientContext.reset();\n    }\n  }","id":73875,"modified_method":"@Test(timeout = 10000)\n  @LocalTachyonClusterResource.Config(tachyonConfParams = {Constants.SECURITY_AUTHENTICATION_TYPE,\n      \"CUSTOM\", Constants.SECURITY_AUTHENTICATION_CUSTOM_PROVIDER,\n      NameMatchAuthenticationProvider.FULL_CLASS_NAME,\n      Constants.SECURITY_LOGIN_USERNAME, \"tachyon\"})\n  public void customAuthenticationDenyConnectTest() throws Exception {\n    mThrown.expect(IOException.class);\n    mThrown.expectMessage(\"Failed to connect to the worker\");\n\n    BlockWorkerClient blockWorkerClient = new BlockWorkerClient(\n        mLocalTachyonClusterResource.get().getWorkerAddress(),\n        mExecutorService, ClientContext.getConf(),\n        1 /* fake session id */, true, new ClientMetrics());\n    try {\n      Assert.assertFalse(blockWorkerClient.isConnected());\n      // Using no-tachyon as loginUser to connect to Worker, the IOException will be thrown\n      LoginUserTestUtils.updateLoginUser(ClientContext.getConf(), \"no-tachyon\");\n      blockWorkerClient.connect();\n    } finally {\n      blockWorkerClient.close();\n      ClientContext.reset();\n    }\n  }","commit_id":"86d917314f4f19a9e918e076555a5714461e7b22","url":"https://github.com/amplab/tachyon"},{"original_method":"private void clearLoginUser() throws Exception {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (User) null);\n  }","id":73876,"modified_method":"private void clearLoginUser() throws Exception {\n    LoginUserTestUtils.resetLoginUser();\n  }","commit_id":"86d917314f4f19a9e918e076555a5714461e7b22","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void chgrpTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chgrp\", \"group1\", \"/testFile\");\n    String group = mTfs.getStatus(new TachyonURI(\"/testFile\")).getGroupName();\n    Assert.assertEquals(\"group1\", group);\n    mFsShell.run(\"chgrp\", \"group2\", \"/testFile\");\n    group = mTfs.getStatus(new TachyonURI(\"/testFile\")).getGroupName();\n    Assert.assertEquals(\"group2\", group);\n  }","id":73877,"modified_method":"@Test\n  public void chgrpTest() throws IOException, TachyonException {\n    cleanLoginUser();\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chgrp\", \"group1\", \"/testFile\");\n    String group = mTfs.getStatus(new TachyonURI(\"/testFile\")).getGroupName();\n    Assert.assertEquals(\"group1\", group);\n    mFsShell.run(\"chgrp\", \"group2\", \"/testFile\");\n    group = mTfs.getStatus(new TachyonURI(\"/testFile\")).getGroupName();\n    Assert.assertEquals(\"group2\", group);\n  }","commit_id":"86d917314f4f19a9e918e076555a5714461e7b22","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void chgrprTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    mFsShell.run(\"mkdir\", \"/testFolder1\");\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFolder1/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chgrpr\", \"group1\", \"/testFolder1\");\n    String group = mTfs.getStatus(new TachyonURI(\"/testFolder1/testFile\")).getGroupName();\n    Assert.assertEquals(\"group1\", group);\n    mFsShell.run(\"chgrpr\", \"group2\", \"/testFolder1\");\n    group = mTfs.getStatus(new TachyonURI(\"/testFolder1/testFile\")).getGroupName();\n    Assert.assertEquals(\"group2\", group);\n  }","id":73878,"modified_method":"@Test\n  public void chgrprTest() throws IOException, TachyonException {\n    cleanLoginUser();\n    mFsShell.run(\"mkdir\", \"/testFolder1\");\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFolder1/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chgrpr\", \"group1\", \"/testFolder1\");\n    String group = mTfs.getStatus(new TachyonURI(\"/testFolder1/testFile\")).getGroupName();\n    Assert.assertEquals(\"group1\", group);\n    mFsShell.run(\"chgrpr\", \"group2\", \"/testFolder1\");\n    group = mTfs.getStatus(new TachyonURI(\"/testFolder1/testFile\")).getGroupName();\n    Assert.assertEquals(\"group2\", group);\n  }","commit_id":"86d917314f4f19a9e918e076555a5714461e7b22","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void chmodTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chmod\", \"777\", \"/testFile\");\n    int permission = mTfs.getStatus(new TachyonURI(\"/testFile\")).getPermission();\n    Assert.assertEquals((short) 0777, permission);\n    mFsShell.run(\"chmod\", \"755\", \"/testFile\");\n    permission = mTfs.getStatus(new TachyonURI(\"/testFile\")).getPermission();\n    Assert.assertEquals((short) 0755, permission);\n  }","id":73879,"modified_method":"@Test\n  public void chmodTest() throws IOException, TachyonException {\n    cleanLoginUser();\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chmod\", \"777\", \"/testFile\");\n    int permission = mTfs.getStatus(new TachyonURI(\"/testFile\")).getPermission();\n    Assert.assertEquals((short) 0777, permission);\n    mFsShell.run(\"chmod\", \"755\", \"/testFile\");\n    permission = mTfs.getStatus(new TachyonURI(\"/testFile\")).getPermission();\n    Assert.assertEquals((short) 0755, permission);\n  }","commit_id":"86d917314f4f19a9e918e076555a5714461e7b22","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void chmodrTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    mFsShell.run(\"mkdir\", \"/testFolder1\");\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFolder1/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chmodr\", \"777\", \"/testFolder1\");\n    int permission = mTfs.getStatus(new TachyonURI(\"/testFolder1\")).getPermission();\n    Assert.assertEquals((short) 0777, permission);\n    mFsShell.run(\"chmodr\", \"755\", \"/testFolder1\");\n    permission = mTfs.getStatus(new TachyonURI(\"/testFolder1\")).getPermission();\n    Assert.assertEquals((short) 0755, permission);\n  }","id":73880,"modified_method":"@Test\n  public void chmodrTest() throws IOException, TachyonException {\n    cleanLoginUser();\n    mFsShell.run(\"mkdir\", \"/testFolder1\");\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFolder1/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chmodr\", \"777\", \"/testFolder1\");\n    int permission = mTfs.getStatus(new TachyonURI(\"/testFolder1\")).getPermission();\n    Assert.assertEquals((short) 0777, permission);\n    mFsShell.run(\"chmodr\", \"755\", \"/testFolder1\");\n    permission = mTfs.getStatus(new TachyonURI(\"/testFolder1\")).getPermission();\n    Assert.assertEquals((short) 0755, permission);\n  }","commit_id":"86d917314f4f19a9e918e076555a5714461e7b22","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void chownTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chown\", \"user1\", \"/testFile\");\n    String owner = mTfs.getStatus(new TachyonURI(\"/testFile\")).getUserName();\n    Assert.assertEquals(\"user1\", owner);\n    mFsShell.run(\"chown\", \"user2\", \"/testFile\");\n    owner = mTfs.getStatus(new TachyonURI(\"/testFile\")).getUserName();\n    Assert.assertEquals(\"user2\", owner);\n  }","id":73881,"modified_method":"@Test\n  public void chownTest() throws IOException, TachyonException {\n    cleanLoginUser();\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chown\", \"user1\", \"/testFile\");\n    String owner = mTfs.getStatus(new TachyonURI(\"/testFile\")).getUserName();\n    Assert.assertEquals(\"user1\", owner);\n    mFsShell.run(\"chown\", \"user2\", \"/testFile\");\n    owner = mTfs.getStatus(new TachyonURI(\"/testFile\")).getUserName();\n    Assert.assertEquals(\"user2\", owner);\n  }","commit_id":"86d917314f4f19a9e918e076555a5714461e7b22","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void chownrTest() throws IOException, TachyonException {\n    Whitebox.setInternalState(LoginUser.class, \"sLoginUser\", (String) null);\n    mFsShell.run(\"mkdir\", \"/testFolder1\");\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFolder1/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chownr\", \"user1\", \"/testFolder1\");\n    String owner = mTfs.getStatus(new TachyonURI(\"/testFolder1/testFile\")).getUserName();\n    Assert.assertEquals(\"user1\", owner);\n    mFsShell.run(\"chownr\", \"user2\", \"/testFolder1\");\n    owner = mTfs.getStatus(new TachyonURI(\"/testFolder1/testFile\")).getUserName();\n    Assert.assertEquals(\"user2\", owner);\n  }","id":73882,"modified_method":"@Test\n  public void chownrTest() throws IOException, TachyonException {\n    cleanLoginUser();\n    mFsShell.run(\"mkdir\", \"/testFolder1\");\n    TachyonFSTestUtils.createByteFile(mTfs, \"/testFolder1/testFile\", WriteType.MUST_CACHE, 10);\n    mFsShell.run(\"chownr\", \"user1\", \"/testFolder1\");\n    String owner = mTfs.getStatus(new TachyonURI(\"/testFolder1/testFile\")).getUserName();\n    Assert.assertEquals(\"user1\", owner);\n    mFsShell.run(\"chownr\", \"user2\", \"/testFolder1\");\n    owner = mTfs.getStatus(new TachyonURI(\"/testFolder1/testFile\")).getUserName();\n    Assert.assertEquals(\"user2\", owner);\n  }","commit_id":"86d917314f4f19a9e918e076555a5714461e7b22","url":"https://github.com/amplab/tachyon"},{"original_method":"private void clearLoginUser() throws Exception {\n    // User reflection to reset the private static member sLoginUser in LoginUser.\n    Field field = LoginUser.class.getDeclaredField(\"sLoginUser\");\n    field.setAccessible(true);\n    field.set(null, null);\n  }","id":73883,"modified_method":"private void clearLoginUser() throws Exception {\n    LoginUserTestUtils.resetLoginUser();\n  }","commit_id":"86d917314f4f19a9e918e076555a5714461e7b22","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  @LocalTachyonClusterResource.Config(tachyonConfParams = {Constants.SECURITY_AUTHENTICATION_TYPE,\n      \"CUSTOM\", Constants.SECURITY_AUTHENTICATION_CUSTOM_PROVIDER,\n      NameMatchAuthenticationProvider.FULL_CLASS_NAME,\n      Constants.SECURITY_LOGIN_USERNAME, \"tachyon\"})\n  public void customAuthenticationDenyConnectTest() throws Exception {\n    mThrown.expect(ConnectionFailedException.class);\n    // Using no-tachyon as loginUser to connect to Master, the IOException will be thrown\n    ClientContext.getConf().set(Constants.SECURITY_LOGIN_USERNAME, \"no-tachyon\");\n    FileSystemMasterClient masterClient =\n        new FileSystemMasterClient(mLocalTachyonClusterResource.get().getMaster().getAddress(),\n            ClientContext.getConf());\n    try {\n      Assert.assertFalse(masterClient.isConnected());\n      // Clear the login user so that it will be reloaded and pick up our no-tachyon change\n      clearLoginUser();\n      masterClient.connect();\n    } finally {\n      masterClient.close();\n    }\n  }","id":73884,"modified_method":"@Test\n  @LocalTachyonClusterResource.Config(tachyonConfParams = {Constants.SECURITY_AUTHENTICATION_TYPE,\n      \"CUSTOM\", Constants.SECURITY_AUTHENTICATION_CUSTOM_PROVIDER,\n      NameMatchAuthenticationProvider.FULL_CLASS_NAME,\n      Constants.SECURITY_LOGIN_USERNAME, \"tachyon\"})\n  public void customAuthenticationDenyConnectTest() throws Exception {\n    mThrown.expect(ConnectionFailedException.class);\n\n    FileSystemMasterClient masterClient =\n        new FileSystemMasterClient(mLocalTachyonClusterResource.get().getMaster().getAddress(),\n            ClientContext.getConf());\n    try {\n      Assert.assertFalse(masterClient.isConnected());\n      // Using no-tachyon as loginUser to connect to Master, the IOException will be thrown\n      LoginUserTestUtils.updateLoginUser(ClientContext.getConf(), \"no-tachyon\");\n      masterClient.connect();\n    } finally {\n      masterClient.close();\n    }\n  }","commit_id":"86d917314f4f19a9e918e076555a5714461e7b22","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n    public void testRecoverMessage() throws Exception\n    {\n        TransactionalQueueManager transactionalQueueManager = new TransactionalQueueManager();\n        transactionalQueueManager.setMuleContext(muleContext);\n        transactionalQueueManager.setQueueConfiguration(TEST_QUEUE_NAME, new DefaultQueueConfiguration(0, true));\n        transactionalQueueManager.initialise();\n        transactionalQueueManager.start();\n        MuleEvent testEvent = getTestEvent(\"echo\");\n        transactionalQueueManager.getQueueSession().getQueue(TEST_QUEUE_NAME).put(testEvent);\n\n        transactionalQueueManager.stop();\n\n        muleContext.start();\n\n        MuleClient client = muleContext.getClient();\n        MuleMessage result = client.request(\"vm://\" + TEST_QUEUE_NAME, RECEIVE_TIMEOUT);\n        assertNotNull(result);\n        assertEquals(testEvent.getMessage().getPayloadAsString(), result.getPayload());\n    }","id":73885,"modified_method":"@Test\n    public void testRecoverMessage() throws Exception\n    {\n        TransactionalQueueManager transactionalQueueManager = new TransactionalQueueManager();\n        transactionalQueueManager.setMuleContext(muleContext);\n        transactionalQueueManager.setQueueConfiguration(TEST_QUEUE_NAME, new DefaultQueueConfiguration(0, true));\n        transactionalQueueManager.initialise();\n        transactionalQueueManager.start();\n        MuleEvent testEvent = getTestEvent(\"echo\");\n        transactionalQueueManager.getQueueSession().getQueue(TEST_QUEUE_NAME).put(testEvent.getMessage());\n\n        transactionalQueueManager.stop();\n\n        muleContext.start();\n\n        MuleClient client = muleContext.getClient();\n        MuleMessage result = client.request(\"vm://\" + TEST_QUEUE_NAME, RECEIVE_TIMEOUT);\n        assertNotNull(result);\n        assertEquals(testEvent.getMessage().getPayloadAsString(), result.getPayload());\n    }","commit_id":"63dd20dbd11a7f803b9103ce7a97a88827b611e5","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    protected void doDispatch(final MuleEvent event) throws Exception\n    {\n        EndpointURI endpointUri = endpoint.getEndpointURI();\n\n        if (endpointUri == null)\n        {\n            throw new DispatchException(CoreMessages.objectIsNull(\"Endpoint\"), event, getEndpoint());\n        }\n        MuleEvent eventToDispatch = DefaultMuleEvent.copy(event);\n        eventToDispatch.clearFlowVariables();\n        eventToDispatch.setMessage(eventToDispatch.getMessage().createInboundMessage());\n        QueueSession session = getQueueSession();\n        Queue queue = session.getQueue(endpointUri.getAddress());\n        if (!queue.offer(eventToDispatch, connector.getQueueTimeout()))\n        {\n            // queue is full\n            throw new DispatchException(VMMessages.queueIsFull(queue.getName(), queue.size()),\n                eventToDispatch, getEndpoint());\n        }\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"dispatched MuleEvent on endpointUri: \" + endpointUri);\n        }\n    }","id":73886,"modified_method":"@Override\n    protected void doDispatch(final MuleEvent event) throws Exception\n    {\n        EndpointURI endpointUri = endpoint.getEndpointURI();\n\n        if (endpointUri == null)\n        {\n            throw new DispatchException(CoreMessages.objectIsNull(\"Endpoint\"), event, getEndpoint());\n        }\n        MuleEvent eventToDispatch = DefaultMuleEvent.copy(event);\n        eventToDispatch.clearFlowVariables();\n        eventToDispatch.setMessage(eventToDispatch.getMessage().createInboundMessage());\n        QueueSession session = getQueueSession();\n        Queue queue = session.getQueue(endpointUri.getAddress());\n        if (!queue.offer(eventToDispatch.getMessage(), connector.getQueueTimeout()))\n        {\n            // queue is full\n            throw new DispatchException(VMMessages.queueIsFull(queue.getName(), queue.size()),\n                eventToDispatch, getEndpoint());\n        }\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"dispatched MuleEvent on endpointUri: \" + endpointUri);\n        }\n    }","commit_id":"63dd20dbd11a7f803b9103ce7a97a88827b611e5","url":"https://github.com/mulesoft/mule"},{"original_method":"protected MuleEvent getFirstMessage() throws Exception\n    {\n        // The queue from which to pull events\n        QueueSession qs = connector.getTransactionalResource(endpoint);\n        Queue queue = qs.getQueue(endpoint.getEndpointURI().getAddress());\n        // try to get the first event off the queue\n        return (MuleEvent) queue.poll(connector.getQueueTimeout());\n    }","id":73887,"modified_method":"protected MuleMessage getFirstMessage() throws Exception\n    {\n        // The queue from which to pull events\n        QueueSession qs = connector.getTransactionalResource(endpoint);\n        Queue queue = qs.getQueue(endpoint.getEndpointURI().getAddress());\n\n        return getMessage(queue, connector.getQueueTimeout());\n    }","commit_id":"63dd20dbd11a7f803b9103ce7a97a88827b611e5","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * It's impossible to process all messages in the receive transaction\n     */\n    @Override\n    protected List<MuleMessage> getMessages() throws Exception\n    {\n        if (isReceiveMessagesInTransaction())\n        {\n            MuleEvent message = getFirstMessage();\n            if (message == null)\n            {\n                return null;\n            }\n\n            List<MuleMessage> messages = new ArrayList<MuleMessage>(1);\n            ((DefaultMuleMessage)message.getMessage()).setMuleContext(endpoint.getMuleContext());\n            messages.add(message.getMessage());\n            return messages;\n        }\n        else\n        {\n            return getFirstMessages();\n        }\n    }","id":73888,"modified_method":"/**\n     * It's impossible to process all messages in the receive transaction\n     */\n    @Override\n    protected List<MuleMessage> getMessages() throws Exception\n    {\n        if (isReceiveMessagesInTransaction())\n        {\n            MuleMessage message = getFirstMessage();\n            if (message == null)\n            {\n                return null;\n            }\n\n            List<MuleMessage> messages = new ArrayList<MuleMessage>(1);\n            if (message instanceof DefaultMuleMessage)\n            {\n                ((DefaultMuleMessage) message).setMuleContext(endpoint.getMuleContext());\n            }\n            messages.add(message);\n            return messages;\n        }\n        else\n        {\n            return getFirstMessages();\n        }\n    }","commit_id":"63dd20dbd11a7f803b9103ce7a97a88827b611e5","url":"https://github.com/mulesoft/mule"},{"original_method":"protected List<MuleMessage> getFirstMessages() throws Exception\n    {\n        // The queue from which to pull events\n        QueueSession qs = connector.getTransactionalResource(endpoint);\n        Queue queue = qs.getQueue(endpoint.getEndpointURI().getAddress());\n\n        // The list of retrieved messages that will be returned\n        List<MuleMessage> messages = new LinkedList<MuleMessage>();\n\n        int batchSize = getBatchSize(queue.size());\n\n        // try to get the first event off the queue\n        MuleEvent message = (MuleEvent) queue.poll(connector.getQueueTimeout());\n\n        if (message != null)\n        {\n            // keep first dequeued event\n            ((DefaultMuleMessage)message.getMessage()).setMuleContext(endpoint.getMuleContext());\n            messages.add(message.getMessage());\n\n            // keep batching if more events are available\n            for (int i = 0; i < batchSize && message != null; i++)\n            {\n                message = (MuleEvent)queue.poll(0);\n                if (message != null)\n                {\n                    messages.add(new DefaultMuleMessage(message.getMessage(), endpoint.getMuleContext()));\n                }\n            }\n        }\n\n        // let our workManager handle the batch of events\n        return messages;\n    }","id":73889,"modified_method":"protected List<MuleMessage> getFirstMessages() throws Exception\n    {\n        // The queue from which to pull events\n        QueueSession qs = connector.getTransactionalResource(endpoint);\n        Queue queue = qs.getQueue(endpoint.getEndpointURI().getAddress());\n\n        // The list of retrieved messages that will be returned\n        List<MuleMessage> messages = new LinkedList<MuleMessage>();\n\n        int batchSize = getBatchSize(queue.size());\n\n        // try to get the first event off the queue\n        MuleMessage message = getMessage(queue, connector.getQueueTimeout());\n\n        if (message != null)\n        {\n            // keep first dequeued message\n            if (message instanceof DefaultMuleMessage)\n            {\n                ((DefaultMuleMessage) message).setMuleContext(endpoint.getMuleContext());\n            }\n            messages.add(message);\n\n            // keep batching if more events are available\n            for (int i = 0; i < batchSize && message != null; i++)\n            {\n                message = getMessage(queue, 0);\n                if (message != null)\n                {\n                    messages.add(new DefaultMuleMessage(message, endpoint.getMuleContext()));\n                }\n            }\n        }\n\n        // let our workManager handle the batch of events\n        return messages;\n    }","commit_id":"63dd20dbd11a7f803b9103ce7a97a88827b611e5","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Make a specific request to the underlying transport\n     *\n     * @param timeout the maximum time the operation should block before returning.\n     *                The call should return immediately if there is data available. If\n     *                no data becomes available before the timeout elapses, null will be\n     *                returned\n     * @return the result of the request wrapped in a MuleMessage object. Null will be\n     *         returned if no data was available\n     * @throws Exception if the call to the underlying protocol causes an exception\n     */\n    protected MuleMessage doRequest(long timeout) throws Exception\n    {\n        try\n        {\n            QueueSession queueSession = connector.getTransactionalResource(endpoint);\n            Queue queue = queueSession.getQueue(endpoint.getEndpointURI().getAddress());\n\n            if (queue == null)\n            {\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(\"No queue with name \" + endpoint.getEndpointURI().getAddress());\n                }\n                return null;\n            }\n            else\n            {\n                MuleEvent event = null;\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(\"Waiting for a message on \" + endpoint.getEndpointURI().getAddress());\n                }\n                try\n                {\n                    event = (MuleEvent) queue.poll(timeout);\n                }\n                catch (InterruptedException e)\n                {\n                    logger.error(\"Failed to receive message from queue: \" + endpoint.getEndpointURI());\n                }\n                if (event != null)\n                {\n                    //The message will contain old thread information, we need to reset it\n                    if(event.getMessage() instanceof ThreadSafeAccess)\n                    {\n                        ((ThreadSafeAccess) event.getMessage()).resetAccessControl();\n                    }\n                    if (logger.isDebugEnabled())\n                    {\n                        logger.debug(\"Message received: \" + event);\n                    }\n                    return event.getMessage();\n                }\n                else\n                {\n                    if (logger.isDebugEnabled())\n                    {\n                        logger.debug(\"No event received after \" + timeout + \" ms\");\n                    }\n                    return null;\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            throw e;\n        }\n    }","id":73890,"modified_method":"/**\n     * Make a specific request to the underlying transport\n     *\n     * @param timeout the maximum time the operation should block before returning.\n     *                The call should return immediately if there is data available. If\n     *                no data becomes available before the timeout elapses, null will be\n     *                returned\n     * @return the result of the request wrapped in a MuleMessage object. Null will be\n     *         returned if no data was available\n     * @throws Exception if the call to the underlying protocol causes an exception\n     */\n    protected MuleMessage doRequest(long timeout) throws Exception\n    {\n        try\n        {\n            QueueSession queueSession = connector.getTransactionalResource(endpoint);\n            Queue queue = queueSession.getQueue(endpoint.getEndpointURI().getAddress());\n\n            if (queue == null)\n            {\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(\"No queue with name \" + endpoint.getEndpointURI().getAddress());\n                }\n                return null;\n            }\n            else\n            {\n                MuleMessage message = null;\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(\"Waiting for a message on \" + endpoint.getEndpointURI().getAddress());\n                }\n                try\n                {\n                    Serializable polledItem = queue.poll(timeout);\n\n                    if (polledItem instanceof MuleEvent)\n                    {\n                        message = ((MuleEvent) polledItem).getMessage();\n                    }\n                    else\n                    {\n                        message = (MuleMessage) polledItem;\n                    }\n                }\n                catch (InterruptedException e)\n                {\n                    logger.error(\"Failed to receive message from queue: \" + endpoint.getEndpointURI());\n                }\n                if (message != null)\n                {\n                    //The message will contain old thread information, we need to reset it\n                    if(message instanceof ThreadSafeAccess)\n                    {\n                        ((ThreadSafeAccess) message).resetAccessControl();\n                    }\n                    if (logger.isDebugEnabled())\n                    {\n                        logger.debug(\"Message received: \" + message);\n                    }\n                    return message;\n                }\n                else\n                {\n                    if (logger.isDebugEnabled())\n                    {\n                        logger.debug(\"No event received after \" + timeout + \" ms\");\n                    }\n                    return null;\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            throw e;\n        }\n    }","commit_id":"63dd20dbd11a7f803b9103ce7a97a88827b611e5","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void serializeWithKryo() throws Exception\n    {\n        final String payload = \"payload\";\n        runFlow(\"dispatch\", getTestEvent(payload));\n\n        MuleMessage response = muleContext.getClient().request(\"vm://in\", 5000);\n        assertThat(response, is(notNullValue()));\n        assertThat(response.getPayloadAsString(), is(payload));\n\n        ArgumentCaptor<MuleEvent> eventArgumentCaptor = ArgumentCaptor.forClass(MuleEvent.class);\n        verify(objectSerializer, atLeastOnce()).serialize(eventArgumentCaptor.capture());\n        MuleEvent capturedEvent = eventArgumentCaptor.getValue();\n        assertThat(capturedEvent, is(notNullValue()));\n        assertThat(capturedEvent.getMessage().getPayloadAsString(), is(payload));\n\n        verify(objectSerializer, atLeastOnce()).deserialize(any(byte[].class));\n    }","id":73891,"modified_method":"@Test\n    public void serializeWithKryo() throws Exception\n    {\n        final String payload = \"payload\";\n        runFlow(\"dispatch\", getTestEvent(payload));\n\n        MuleMessage response = muleContext.getClient().request(\"vm://in\", 5000);\n        assertThat(response, is(notNullValue()));\n        assertThat(response.getPayloadAsString(), is(payload));\n\n        ArgumentCaptor<MuleMessage> messageArgumentCaptor = ArgumentCaptor.forClass(MuleMessage.class);\n        verify(objectSerializer, atLeastOnce()).serialize(messageArgumentCaptor.capture());\n        MuleMessage capturedMessage = messageArgumentCaptor.getValue();\n        assertThat(capturedMessage, is(notNullValue()));\n        assertThat(capturedMessage.getPayloadAsString(), is(payload));\n\n        verify(objectSerializer, atLeastOnce()).deserialize(any(byte[].class));\n    }","commit_id":"63dd20dbd11a7f803b9103ce7a97a88827b611e5","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public void resourceOffers(SchedulerDriver driver, List<Protos.Offer> offers) {\n      long masterCpu = Configuration.getInt(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU);\n      long masterMem =\n          Configuration.getBytes(PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB;\n      long workerCpu = Configuration.getInt(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU);\n      long workerMem =\n          Configuration.getBytes(PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB;\n\n      LOG.info(\"Master launched {}, master count {}, \"\n          + \"requested master cpu {} and mem {} MB\",\n          mMasterLaunched, mMasterCount, masterCpu, masterMem);\n\n      for (Protos.Offer offer : offers) {\n        Protos.Offer.Operation.Launch.Builder launch = Protos.Offer.Operation.Launch.newBuilder();\n        double offerCpu = 0;\n        double offerMem = 0;\n        for (Protos.Resource resource : offer.getResourcesList()) {\n          if (resource.getName().equals(Constants.MESOS_RESOURCE_CPUS)) {\n            offerCpu += resource.getScalar().getValue();\n          } else if (resource.getName().equals(Constants.MESOS_RESOURCE_MEM)) {\n            offerMem += resource.getScalar().getValue();\n          } else {\n            // Other resources are currently ignored.\n          }\n        }\n\n        LOG.info(\"Received offer {} with cpus {} and mem {} MB and hasMasterPorts {}\",\n            offer.getId().getValue(), offerCpu, offerMem,\n            OfferUtils.hasAvailableMasterPorts(offer));\n\n        Protos.ExecutorInfo.Builder executorBuilder = Protos.ExecutorInfo.newBuilder();\n        List<Protos.Resource> resources;\n        if (!mMasterLaunched && offerCpu >= masterCpu && offerMem >= masterMem\n            && mMasterCount < Configuration\n            .getInt(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NODE_COUNT) && OfferUtils\n            .hasAvailableMasterPorts(offer)) {\n          LOG.debug(\"Creating Alluxio Master executor\");\n          executorBuilder\n              .setName(\"Alluxio Master Executor\")\n              .setSource(\"master\")\n              .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"master\"))\n              .addAllResources(getExecutorResources())\n              .setCommand(\n                  Protos.CommandInfo\n                      .newBuilder()\n                      .setValue(createStartAlluxioCommand(\"alluxio-master-mesos.sh\"))\n                      .addAllUris(getExecutorDependencyURIList())\n                      .setEnvironment(\n                          Protos.Environment\n                              .newBuilder()\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                      .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))\n                                      .build())\n                              .build()));\n          // pre-build resource list here, then use it to build Protos.Task later.\n          resources = getMasterRequiredResources(masterCpu, masterMem);\n          mMasterHostname = offer.getHostname();\n          mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NAME);\n          mMasterCount++;\n          mMasterTaskId = mLaunchedTasks;\n\n        } else if (mMasterLaunched && !mWorkers.contains(offer.getHostname())\n            && offerCpu >= workerCpu && offerMem >= workerMem\n            && OfferUtils.hasAvailableWorkerPorts(offer)) {\n          LOG.debug(\"Creating Alluxio Worker executor\");\n          final String memSize = FormatUtils.getSizeFromBytes((long) workerMem * Constants.MB);\n          executorBuilder\n              .setName(\"Alluxio Worker Executor\")\n              .setSource(\"worker\")\n              .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"worker\"))\n              .addAllResources(getExecutorResources())\n              .setCommand(\n                  Protos.CommandInfo\n                      .newBuilder()\n                      .setValue(createStartAlluxioCommand(\"alluxio-worker-mesos.sh\"))\n                      .addAllUris(getExecutorDependencyURIList())\n                      .setEnvironment(\n                          Protos.Environment\n                              .newBuilder()\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_MASTER_HOSTNAME\").setValue(mMasterHostname)\n                                      .build())\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_WORKER_MEMORY_SIZE\").setValue(memSize)\n                                      .build())\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                      .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))\n                                      .build())\n                              .build()));\n          // pre-build resource list here, then use it to build Protos.Task later.\n          resources = getWorkerRequiredResources(workerCpu, workerMem);\n          mWorkers.add(offer.getHostname());\n          mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_WORKER_NAME);\n        } else {\n          // The resource offer cannot be used to start either master or a worker.\n          LOG.info(\"Declining offer {}\", offer.getId().getValue());\n          driver.declineOffer(offer.getId());\n          continue;\n        }\n\n        Protos.TaskID taskId =\n            Protos.TaskID.newBuilder().setValue(String.valueOf(mLaunchedTasks)).build();\n\n        LOG.info(\"Launching task {} using offer {}\", taskId.getValue(), offer.getId().getValue());\n\n        Protos.TaskInfo task =\n            Protos.TaskInfo\n                .newBuilder()\n                .setName(mTaskName)\n                .setTaskId(taskId)\n                .setSlaveId(offer.getSlaveId())\n                .addAllResources(resources)\n                .setExecutor(executorBuilder).build();\n\n        launch.addTaskInfos(Protos.TaskInfo.newBuilder(task));\n        mLaunchedTasks++;\n\n        // NOTE: We use the new API `acceptOffers` here to launch tasks.\n        // The 'launchTasks' API will be deprecated.\n        List<Protos.OfferID> offerIds = new ArrayList<Protos.OfferID>();\n        offerIds.add(offer.getId());\n        List<Protos.Offer.Operation> operations = new ArrayList<Protos.Offer.Operation>();\n        Protos.Offer.Operation operation =\n            Protos.Offer.Operation.newBuilder().setType(Protos.Offer.Operation.Type.LAUNCH)\n                .setLaunch(launch).build();\n        operations.add(operation);\n        Protos.Filters filters = Protos.Filters.newBuilder().setRefuseSeconds(1).build();\n        driver.acceptOffers(offerIds, operations, filters);\n      }\n    }","id":73892,"modified_method":"@Override\n    public void resourceOffers(SchedulerDriver driver, List<Protos.Offer> offers) {\n      long masterCpu = Configuration.getInt(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU);\n      long masterMem =\n          Configuration.getBytes(PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB;\n      long workerCpu = Configuration.getInt(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU);\n      long workerMem =\n          Configuration.getBytes(PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB;\n\n      LOG.info(\"Master launched {}, master count {}, \"\n          + \"requested master cpu {} and mem {} MB\",\n          mMasterLaunched, mMasterCount, masterCpu, masterMem);\n\n      for (Protos.Offer offer : offers) {\n        Protos.Offer.Operation.Launch.Builder launch = Protos.Offer.Operation.Launch.newBuilder();\n        double offerCpu = 0;\n        double offerMem = 0;\n        for (Protos.Resource resource : offer.getResourcesList()) {\n          if (resource.getName().equals(Constants.MESOS_RESOURCE_CPUS)) {\n            offerCpu += resource.getScalar().getValue();\n          } else if (resource.getName().equals(Constants.MESOS_RESOURCE_MEM)) {\n            offerMem += resource.getScalar().getValue();\n          } else {\n            // Other resources are currently ignored.\n          }\n        }\n\n        LOG.info(\"Received offer {} with cpus {} and mem {} MB and hasMasterPorts {}\",\n            offer.getId().getValue(), offerCpu, offerMem,\n            OfferUtils.hasAvailableMasterPorts(offer));\n\n        Protos.ExecutorInfo.Builder executorBuilder = Protos.ExecutorInfo.newBuilder();\n        List<Protos.Resource> resources;\n        if (!mMasterLaunched && offerCpu >= masterCpu && offerMem >= masterMem\n            && mMasterCount < Configuration\n            .getInt(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NODE_COUNT) && OfferUtils\n            .hasAvailableMasterPorts(offer)) {\n          LOG.debug(\"Creating Alluxio Master executor\");\n          executorBuilder\n              .setName(\"Alluxio Master Executor\")\n              .setSource(\"master\")\n              .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"master\"))\n              .addAllResources(getExecutorResources())\n              .setCommand(\n                  Protos.CommandInfo\n                      .newBuilder()\n                      .setValue(createStartAlluxioCommand(\"alluxio-master-mesos.sh\"))\n                      .addAllUris(getExecutorDependencyURIList())\n                      .setEnvironment(\n                          Protos.Environment\n                              .newBuilder()\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                      .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))\n                                      .build())\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_CONF_DIR\").setValue(\"conf\")\n                                      .build())\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_LOGS_DIR\").setValue(\"logs\")\n                                      .build())\n                              .build()));\n          // pre-build resource list here, then use it to build Protos.Task later.\n          resources = getMasterRequiredResources(masterCpu, masterMem);\n          mMasterHostname = offer.getHostname();\n          mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NAME);\n          mMasterCount++;\n          mMasterTaskId = mLaunchedTasks;\n        } else if (mMasterLaunched && !mWorkers.contains(offer.getHostname())\n            && offerCpu >= workerCpu && offerMem >= workerMem\n            && OfferUtils.hasAvailableWorkerPorts(offer)) {\n          LOG.debug(\"Creating Alluxio Worker executor\");\n          final String memSize = FormatUtils.getSizeFromBytes((long) workerMem * Constants.MB);\n          executorBuilder\n              .setName(\"Alluxio Worker Executor\")\n              .setSource(\"worker\")\n              .setExecutorId(Protos.ExecutorID.newBuilder().setValue(\"worker\"))\n              .addAllResources(getExecutorResources())\n              .setCommand(\n                  Protos.CommandInfo\n                      .newBuilder()\n                      .setValue(createStartAlluxioCommand(\"alluxio-worker-mesos.sh\"))\n                      .addAllUris(getExecutorDependencyURIList())\n                      .setEnvironment(\n                          Protos.Environment\n                              .newBuilder()\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_MASTER_HOSTNAME\").setValue(mMasterHostname)\n                                      .build())\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_CONF_DIR\").setValue(\"conf\")\n                                      .build())\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_LOGS_DIR\").setValue(\"logs\")\n                                      .build())\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_WORKER_MEMORY_SIZE\").setValue(memSize)\n                                      .build())\n                              .addVariables(\n                                  Protos.Environment.Variable.newBuilder()\n                                      .setName(\"ALLUXIO_UNDERFS_ADDRESS\")\n                                      .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))\n                                      .build())\n                              .build()));\n          // pre-build resource list here, then use it to build Protos.Task later.\n          resources = getWorkerRequiredResources(workerCpu, workerMem);\n          mWorkers.add(offer.getHostname());\n          mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_WORKER_NAME);\n        } else {\n          // The resource offer cannot be used to start either master or a worker.\n          LOG.info(\"Declining offer {}\", offer.getId().getValue());\n          driver.declineOffer(offer.getId());\n          continue;\n        }\n\n        Protos.TaskID taskId =\n            Protos.TaskID.newBuilder().setValue(String.valueOf(mLaunchedTasks)).build();\n\n        LOG.info(\"Launching task {} using offer {}\", taskId.getValue(), offer.getId().getValue());\n\n        Protos.TaskInfo task =\n            Protos.TaskInfo\n                .newBuilder()\n                .setName(mTaskName)\n                .setTaskId(taskId)\n                .setSlaveId(offer.getSlaveId())\n                .addAllResources(resources)\n                .setExecutor(executorBuilder).build();\n\n        launch.addTaskInfos(Protos.TaskInfo.newBuilder(task));\n        mLaunchedTasks++;\n\n        // NOTE: We use the new API `acceptOffers` here to launch tasks.\n        // The 'launchTasks' API will be deprecated.\n        List<Protos.OfferID> offerIds = new ArrayList<Protos.OfferID>();\n        offerIds.add(offer.getId());\n        List<Protos.Offer.Operation> operations = new ArrayList<Protos.Offer.Operation>();\n        Protos.Offer.Operation operation =\n            Protos.Offer.Operation.newBuilder().setType(Protos.Offer.Operation.Type.LAUNCH)\n                .setLaunch(launch).build();\n        operations.add(operation);\n        Protos.Filters filters = Protos.Filters.newBuilder().setRefuseSeconds(1).build();\n        driver.acceptOffers(offerIds, operations, filters);\n      }\n    }","commit_id":"301afb957ff138b1bb53cee3ec719f22da2c89cc","url":"https://github.com/amplab/tachyon"},{"original_method":"private String createStartAlluxioCommand(String command) {\n      StringBuilder cmd = new StringBuilder();\n      cmd.append(String.format(\"echo 'Starting Alluxio with %s'\", command));\n      if (installJavaFromUrl()) {\n        cmd.append(\n            \" && export JAVA_HOME=\" + Configuration.get(PropertyKey.INTEGRATION_MESOS_JRE_PATH));\n        cmd.append(\" && export PATH=$PATH:$JAVA_HOME/bin\");\n      }\n\n      // If a jar is supplied, start Alluxio from the jar. Otherwise assume that Alluxio is already\n      // installed at PropertyKey.HOME.\n      if (installAlluxioFromUrl()) {\n        cmd.append(\" && mv alluxio-* alluxio\");\n        cmd.append(\" && \" + PathUtils.concatPath(\"alluxio\", \"integration\", \"bin\", command));\n      } else {\n        cmd.append(\" && \" + PathUtils.concatPath(Configuration.get(PropertyKey.HOME), \"integration\",\n            \"bin\", command));\n      }\n      return cmd.toString();\n    }","id":73893,"modified_method":"private static String createStartAlluxioCommand(String command) {\n      List<String> commands = new ArrayList<>();\n      commands.add(String.format(\"echo 'Starting Alluxio with %s'\", command));\n      if (installJavaFromUrl()) {\n        commands\n            .add(\"export JAVA_HOME=\" + Configuration.get(PropertyKey.INTEGRATION_MESOS_JRE_PATH));\n        commands.add(\"export PATH=$PATH:$JAVA_HOME/bin\");\n      }\n\n      commands.add(\"mkdir conf\");\n      commands.add(\"touch conf/alluxio-env.sh\");\n\n      // If a jar is supplied, start Alluxio from the jar. Otherwise assume that Alluxio is already\n      // installed at PropertyKey.HOME.\n      if (installAlluxioFromUrl()) {\n        commands.add(\"rm *.tar.gz\");\n        commands.add(\"mv alluxio-* alluxio\");\n      }\n      String home = installAlluxioFromUrl() ? \"alluxio\" : Configuration.get(PropertyKey.HOME);\n      commands.add(String.format(\"cp %s conf\", PathUtils.concatPath(home, \"conf\", \"log4j.properties\")));\n      commands.add(PathUtils.concatPath(home, \"integration\", \"bin\", command));\n      return Joiner.on(\" && \").join(commands);\n    }","commit_id":"301afb957ff138b1bb53cee3ec719f22da2c89cc","url":"https://github.com/amplab/tachyon"},{"original_method":"private String appendPath( String parentUrl, String childPath, String pathAdjustment )\n        {\n            String url = parentUrl;\n            url = concatPath( url, pathAdjustment );\n            url = concatPath( url, childPath );\n            return url;\n        }","id":73894,"modified_method":"private String appendPath( String parentUrl, String childPath, String pathAdjustment )\n        {\n            StringBuilder url = new StringBuilder( parentUrl.length() + pathAdjustment.length() + childPath.length()\n                + ( ( pathAdjustment.length() == 0 ) ? 1 : 2 ) );\n\n            url.append( parentUrl );\n            concatPath( url, pathAdjustment );\n            concatPath( url, childPath );\n\n            return url.toString();\n        }","commit_id":"2877b590f1ddcd7f7401f1a721ccf27f742bdecd","url":"https://github.com/apache/maven"},{"original_method":"private String concatPath( String base, String path )\n        {\n            String result = base;\n\n            if ( path != null && path.length() > 0 )\n            {\n                if ( ( result.endsWith( \"/\" ) && !path.startsWith( \"/\" ) )\n                    || ( !result.endsWith( \"/\" ) && path.startsWith( \"/\" ) ) )\n                {\n                    result += path;\n                }\n                else if ( result.endsWith( \"/\" ) && path.startsWith( \"/\" ) )\n                {\n                    result += path.substring( 1 );\n                }\n                else\n                {\n                    result += '/';\n                    result += path;\n                }\n                if ( base.endsWith( \"/\" ) && !result.endsWith( \"/\" ) )\n                {\n                    result += '/';\n                }\n            }\n\n            return result;\n        }","id":73895,"modified_method":"private void concatPath( StringBuilder url, String path )\n        {\n            if ( path.length() > 0 )\n            {\n                boolean initialUrlEndsWithSlash = url.charAt( url.length() - 1 ) == '/';\n                boolean pathStartsWithSlash = path.charAt( 0 ) ==  '/';\n\n                if ( pathStartsWithSlash )\n                {\n                    if ( initialUrlEndsWithSlash )\n                    {\n                        // 1 extra '/' to remove\n                        url.setLength( url.length() - 1 );\n                    }\n                }\n                else if ( !initialUrlEndsWithSlash )\n                {\n                    // add missing '/' between url and path\n                    url.append( '/' );\n                }\n\n                url.append( path );\n\n                // ensure resulting url ends with slash if initial url was\n                if ( initialUrlEndsWithSlash && !path.endsWith( \"/\" ) )\n                {\n                    url.append( '/' );\n                }\n            }\n        }","commit_id":"2877b590f1ddcd7f7401f1a721ccf27f742bdecd","url":"https://github.com/apache/maven"},{"original_method":"@Test\n\tpublic void testAspectsAndAdvisorNotAppliedToManySingletonsIsFastEnough() {\n\t\tif (factoryLog.isTraceEnabled() || factoryLog.isDebugEnabled()) {\n\t\t\t// Skip this test: Trace logging blows the time limit.\n\t\t\treturn;\n\t\t}\n\t\tGenericApplicationContext ac = new GenericApplicationContext();\n\t\tnew XmlBeanDefinitionReader(ac).loadBeanDefinitions(\n\t\t\t\tnew ClassPathResource(qName(\"aspectsPlusAdvisor.xml\"), getClass()));\n\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\tac.registerBeanDefinition(\"singleton\" + i, new RootBeanDefinition(NestedTestBean.class));\n\t\t}\n\t\tStopWatch sw = new StopWatch();\n\t\tsw.start(\"singleton\");\n\t\tac.refresh();\n\t\tsw.stop();\n\t\tSystem.out.println(sw.getTotalTimeMillis());\n\t\tassertTrue(\"Singleton creation took too long: \" + sw.getTotalTimeMillis(), sw.getTotalTimeMillis() < 4000);\n\t}","id":73896,"modified_method":"@Test\n\tpublic void testAspectsAndAdvisorNotAppliedToManySingletonsIsFastEnough() {\n\t\tif (factoryLog.isTraceEnabled() || factoryLog.isDebugEnabled()) {\n\t\t\t// Skip this test: Trace logging blows the time limit.\n\t\t\treturn;\n\t\t}\n\t\tGenericApplicationContext ac = new GenericApplicationContext();\n\t\tnew XmlBeanDefinitionReader(ac).loadBeanDefinitions(new ClassPathResource(qName(\"aspectsPlusAdvisor.xml\"),\n\t\t\t\tgetClass()));\n\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\tac.registerBeanDefinition(\"singleton\" + i, new RootBeanDefinition(NestedTestBean.class));\n\t\t}\n\t\tStopWatch sw = new StopWatch();\n\t\tsw.start(\"singleton\");\n\t\tac.refresh();\n\t\tsw.stop();\n\t\tlong totalTimeMillis = sw.getTotalTimeMillis();\n\t\t// System.out.println(totalTimeMillis);\n\t\t// How was it decided that 4 seconds is a reasonable maximum time?\n\t\tint maxTimeMillis = 5000; // 4000;\n\t\tassertTrue(\"Singleton creation took too long: \" + totalTimeMillis, totalTimeMillis < maxTimeMillis);\n\t}","commit_id":"58db51324d8cb1ca78d5db135873d703827a7daa","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void testAspectsAndAdvisorNotAppliedToPrototypeIsFastEnough() {\n\t\tif (factoryLog.isTraceEnabled() || factoryLog.isDebugEnabled()) {\n\t\t\t// Skip this test: Trace logging blows the time limit.\n\t\t\treturn;\n\t\t}\n\t\tClassPathXmlApplicationContext ac = newContext(\"aspectsPlusAdvisor.xml\");\n\t\tStopWatch sw = new StopWatch();\n\t\tsw.start(\"prototype\");\n\t\tfor (int i = 0; i < 100000; i++) {\n\t\t\tINestedTestBean shouldNotBeWeaved = (INestedTestBean) ac.getBean(\"i21\");\n\t\t\tif (i < 10) {\n\t\t\t\tassertFalse(AopUtils.isAopProxy(shouldNotBeWeaved));\n\t\t\t}\n\t\t}\n\t\tsw.stop();\n\t\tSystem.out.println(sw.getTotalTimeMillis());\n\t\tassertTrue(\"Prototype creation took too long: \" + sw.getTotalTimeMillis(), sw.getTotalTimeMillis() < 3000);\n\t}","id":73897,"modified_method":"@Test\n\tpublic void testAspectsAndAdvisorNotAppliedToPrototypeIsFastEnough() {\n\t\tif (factoryLog.isTraceEnabled() || factoryLog.isDebugEnabled()) {\n\t\t\t// Skip this test: Trace logging blows the time limit.\n\t\t\treturn;\n\t\t}\n\t\tClassPathXmlApplicationContext ac = newContext(\"aspectsPlusAdvisor.xml\");\n\t\tStopWatch sw = new StopWatch();\n\t\tsw.start(\"prototype\");\n\t\tfor (int i = 0; i < 100000; i++) {\n\t\t\tINestedTestBean shouldNotBeWeaved = (INestedTestBean) ac.getBean(\"i21\");\n\t\t\tif (i < 10) {\n\t\t\t\tassertFalse(AopUtils.isAopProxy(shouldNotBeWeaved));\n\t\t\t}\n\t\t}\n\t\tsw.stop();\n\t\tlong totalTimeMillis = sw.getTotalTimeMillis();\n\t\t// System.out.println(totalTimeMillis);\n\t\t// How was it decided that 3 seconds is a reasonable maximum time?\n\t\tint maxTimeMillis = 3000;\n\t\tassertTrue(\"Prototype creation took too long: \" + totalTimeMillis, totalTimeMillis < maxTimeMillis);\n\t}","commit_id":"58db51324d8cb1ca78d5db135873d703827a7daa","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void testAspectsAndAdvisorAppliedToPrototypeIsFastEnough() {\n\t\tif (factoryLog.isTraceEnabled() || factoryLog.isDebugEnabled()) {\n\t\t\t// Skip this test: Trace logging blows the time limit.\n\t\t\treturn;\n\t\t}\n\t\tClassPathXmlApplicationContext ac = newContext(\"aspectsPlusAdvisor.xml\");\n\t\tStopWatch sw = new StopWatch();\n\t\tsw.start(\"prototype\");\n\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\tITestBean shouldBeWeaved = (ITestBean) ac.getBean(\"adrian2\");\n\t\t\tif (i < 10) {\n\t\t\t\tdoTestAspectsAndAdvisorAreApplied(ac, shouldBeWeaved);\n\t\t\t}\n\t\t}\n\t\tsw.stop();\n\t\tSystem.out.println(sw.getTotalTimeMillis());\n\t\tassertTrue(\"Prototype creation took too long: \" + sw.getTotalTimeMillis(), sw.getTotalTimeMillis() < 4000);\n\t}","id":73898,"modified_method":"@Test\n\tpublic void testAspectsAndAdvisorAppliedToPrototypeIsFastEnough() {\n\t\tif (factoryLog.isTraceEnabled() || factoryLog.isDebugEnabled()) {\n\t\t\t// Skip this test: Trace logging blows the time limit.\n\t\t\treturn;\n\t\t}\n\t\tClassPathXmlApplicationContext ac = newContext(\"aspectsPlusAdvisor.xml\");\n\t\tStopWatch sw = new StopWatch();\n\t\tsw.start(\"prototype\");\n\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\tITestBean shouldBeWeaved = (ITestBean) ac.getBean(\"adrian2\");\n\t\t\tif (i < 10) {\n\t\t\t\tdoTestAspectsAndAdvisorAreApplied(ac, shouldBeWeaved);\n\t\t\t}\n\t\t}\n\t\tsw.stop();\n\t\tlong totalTimeMillis = sw.getTotalTimeMillis();\n\t\t// System.out.println(totalTimeMillis);\n\t\t// How was it decided that 4 seconds is a reasonable maximum time?\n\t\tint maxTimeMillis = 5000; // 4000;\n\t\tassertTrue(\"Prototype creation took too long: \" + totalTimeMillis, totalTimeMillis < maxTimeMillis);\n\t}","commit_id":"58db51324d8cb1ca78d5db135873d703827a7daa","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@NotNull\n    public static PropertyGetterDescriptorImpl createDefaultGetter(@NotNull PropertyDescriptor propertyDescriptor) {\n        return createGetter(propertyDescriptor, true);\n    }","id":73899,"modified_method":"@NotNull\n    public static PropertyGetterDescriptorImpl createDefaultGetter(\n            @NotNull PropertyDescriptor propertyDescriptor,\n            @NotNull Annotations annotations\n    ) {\n        return createGetter(propertyDescriptor, annotations, true);\n    }","commit_id":"3624c4e5dc6d4ab76f3e5669ea02b50508696bcd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static PropertySetterDescriptorImpl createDefaultSetter(@NotNull PropertyDescriptor propertyDescriptor) {\n        return createSetter(propertyDescriptor, true);\n    }","id":73900,"modified_method":"@NotNull\n    public static PropertySetterDescriptorImpl createDefaultSetter(\n            @NotNull PropertyDescriptor propertyDescriptor,\n            @NotNull Annotations annotations\n    ) {\n        return createSetter(propertyDescriptor, annotations, true);\n    }","commit_id":"3624c4e5dc6d4ab76f3e5669ea02b50508696bcd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static PropertySetterDescriptorImpl createSetter(@NotNull PropertyDescriptor propertyDescriptor, boolean isDefault) {\n        PropertySetterDescriptorImpl setterDescriptor =\n                new PropertySetterDescriptorImpl(propertyDescriptor, Annotations.EMPTY, propertyDescriptor.getModality(),\n                                                 propertyDescriptor.getVisibility(), !isDefault, isDefault,\n                                                 CallableMemberDescriptor.Kind.DECLARATION, null, SourceElement.NO_SOURCE);\n        setterDescriptor.initializeDefault();\n        return setterDescriptor;\n    }","id":73901,"modified_method":"@NotNull\n    public static PropertySetterDescriptorImpl createSetter(\n            @NotNull PropertyDescriptor propertyDescriptor,\n            @NotNull Annotations annotations,\n            boolean isDefault\n    ) {\n        PropertySetterDescriptorImpl setterDescriptor =\n                new PropertySetterDescriptorImpl(propertyDescriptor, annotations, propertyDescriptor.getModality(),\n                                                 propertyDescriptor.getVisibility(), !isDefault, isDefault,\n                                                 CallableMemberDescriptor.Kind.DECLARATION, null, SourceElement.NO_SOURCE);\n        setterDescriptor.initializeDefault();\n        return setterDescriptor;\n    }","commit_id":"3624c4e5dc6d4ab76f3e5669ea02b50508696bcd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static PropertyGetterDescriptorImpl createGetter(@NotNull PropertyDescriptor propertyDescriptor, boolean isDefault) {\n        return new PropertyGetterDescriptorImpl(propertyDescriptor, Annotations.EMPTY, propertyDescriptor.getModality(),\n                                                propertyDescriptor.getVisibility(), !isDefault, isDefault,\n                                                CallableMemberDescriptor.Kind.DECLARATION, null, SourceElement.NO_SOURCE);\n    }","id":73902,"modified_method":"@NotNull\n    public static PropertyGetterDescriptorImpl createGetter(\n            @NotNull PropertyDescriptor propertyDescriptor,\n            @NotNull Annotations annotations,\n            boolean isDefault) {\n        return new PropertyGetterDescriptorImpl(propertyDescriptor, annotations, propertyDescriptor.getModality(),\n                                                propertyDescriptor.getVisibility(), !isDefault, isDefault,\n                                                CallableMemberDescriptor.Kind.DECLARATION, null, SourceElement.NO_SOURCE);\n    }","commit_id":"3624c4e5dc6d4ab76f3e5669ea02b50508696bcd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public PropertyDescriptor resolvePropertyDescriptor(\n            @NotNull DeclarationDescriptor containingDeclaration,\n            @NotNull LexicalScope scope,\n            @NotNull JetProperty property,\n            @NotNull BindingTrace trace,\n            @NotNull DataFlowInfo dataFlowInfo\n    ) {\n        JetModifierList modifierList = property.getModifierList();\n        boolean isVar = property.isVar();\n\n        boolean hasBody = hasBody(property);\n        Visibility visibility = resolveVisibilityFromModifiers(property, getDefaultVisibility(property, containingDeclaration));\n        Modality modality = containingDeclaration instanceof ClassDescriptor\n                            ? resolveModalityFromModifiers(property, getDefaultModality(containingDeclaration, visibility, hasBody))\n                            : Modality.FINAL;\n        PropertyDescriptorImpl propertyDescriptor = PropertyDescriptorImpl.create(\n                containingDeclaration,\n                annotationResolver.resolveAnnotationsWithoutArguments(scope, modifierList, trace),\n                modality,\n                visibility,\n                isVar,\n                JetPsiUtil.safeName(property.getName()),\n                CallableMemberDescriptor.Kind.DECLARATION,\n                toSourceElement(property)\n        );\n\n        List<TypeParameterDescriptorImpl> typeParameterDescriptors;\n        LexicalScope scopeWithTypeParameters;\n        JetType receiverType = null;\n\n        {\n            List<JetTypeParameter> typeParameters = property.getTypeParameters();\n            if (typeParameters.isEmpty()) {\n                scopeWithTypeParameters = scope;\n                typeParameterDescriptors = Collections.emptyList();\n            }\n            else {\n                LexicalWritableScope writableScope = new LexicalWritableScope(\n                        scope, containingDeclaration, false, null, new TraceBasedRedeclarationHandler(trace),\n                        \"Scope with type parameters of a property\");\n                typeParameterDescriptors = resolveTypeParametersForCallableDescriptor(propertyDescriptor, writableScope, typeParameters,\n                                                                                      trace);\n                writableScope.changeLockLevel(WritableScope.LockLevel.READING);\n                resolveGenericBounds(property, propertyDescriptor, writableScope, typeParameterDescriptors, trace);\n                scopeWithTypeParameters = writableScope;\n            }\n\n            JetTypeReference receiverTypeRef = property.getReceiverTypeReference();\n            if (receiverTypeRef != null) {\n                receiverType = typeResolver.resolveType(scopeWithTypeParameters, receiverTypeRef, trace, true);\n            }\n        }\n\n        ReceiverParameterDescriptor receiverDescriptor =\n                DescriptorFactory.createExtensionReceiverParameterForCallable(propertyDescriptor, receiverType);\n\n        ReceiverParameterDescriptor implicitInitializerReceiver = property.hasDelegate() ? null : receiverDescriptor;\n\n        LexicalScope propertyScope = JetScopeUtils.getPropertyDeclarationInnerScope(propertyDescriptor, scope, typeParameterDescriptors,\n                                                                                    implicitInitializerReceiver, trace);\n\n        JetType type = getVariableType(propertyDescriptor, propertyScope, property, dataFlowInfo, true, trace);\n\n        propertyDescriptor.setType(type, typeParameterDescriptors, getDispatchReceiverParameterIfNeeded(containingDeclaration),\n                                   receiverDescriptor);\n\n        PropertyGetterDescriptorImpl getter = resolvePropertyGetterDescriptor(scopeWithTypeParameters, property, propertyDescriptor, trace);\n        PropertySetterDescriptor setter = resolvePropertySetterDescriptor(scopeWithTypeParameters, property, propertyDescriptor, trace);\n\n        propertyDescriptor.initialize(getter, setter);\n\n        trace.record(BindingContext.VARIABLE, property, propertyDescriptor);\n        return propertyDescriptor;\n    }","id":73903,"modified_method":"@NotNull\n    public PropertyDescriptor resolvePropertyDescriptor(\n            @NotNull DeclarationDescriptor containingDeclaration,\n            @NotNull LexicalScope scope,\n            @NotNull JetProperty property,\n            @NotNull BindingTrace trace,\n            @NotNull DataFlowInfo dataFlowInfo\n    ) {\n        JetModifierList modifierList = property.getModifierList();\n        boolean isVar = property.isVar();\n\n        boolean hasBody = hasBody(property);\n        Visibility visibility = resolveVisibilityFromModifiers(property, getDefaultVisibility(property, containingDeclaration));\n        Modality modality = containingDeclaration instanceof ClassDescriptor\n                            ? resolveModalityFromModifiers(property, getDefaultModality(containingDeclaration, visibility, hasBody))\n                            : Modality.FINAL;\n\n        JetPropertyAccessor propertyGetter = property.getGetter();\n\n        boolean hasBackingField = modality != Modality.ABSTRACT\n                                  && property.hasDelegateExpressionOrInitializer()\n                                  && (propertyGetter == null || !propertyGetter.hasBody());\n\n        Annotations allAnnotations = annotationResolver.resolveAnnotationsWithoutArguments(scope, modifierList, trace);\n        AnnotationSplitter annotationSplitter = AnnotationSplitter.create(allAnnotations,\n                /*parameter =*/ false, /*hasBackingField =*/ hasBackingField, /*isMutable =*/ isVar);\n\n        Annotations propertyAnnotations = new CompositeAnnotations(KotlinPackage.listOf(\n                annotationSplitter.getAnnotationsForTargets(PROPERTY, FIELD),\n                annotationSplitter.getOtherAnnotations()));\n\n        PropertyDescriptorImpl propertyDescriptor = PropertyDescriptorImpl.create(\n                containingDeclaration,\n                propertyAnnotations,\n                modality,\n                visibility,\n                isVar,\n                JetPsiUtil.safeName(property.getName()),\n                CallableMemberDescriptor.Kind.DECLARATION,\n                toSourceElement(property)\n        );\n\n        List<TypeParameterDescriptorImpl> typeParameterDescriptors;\n        LexicalScope scopeWithTypeParameters;\n        JetType receiverType = null;\n\n        {\n            List<JetTypeParameter> typeParameters = property.getTypeParameters();\n            if (typeParameters.isEmpty()) {\n                scopeWithTypeParameters = scope;\n                typeParameterDescriptors = Collections.emptyList();\n            }\n            else {\n                LexicalWritableScope writableScope = new LexicalWritableScope(\n                        scope, containingDeclaration, false, null, new TraceBasedRedeclarationHandler(trace),\n                        \"Scope with type parameters of a property\");\n                typeParameterDescriptors = resolveTypeParametersForCallableDescriptor(propertyDescriptor, writableScope, typeParameters,\n                                                                                      trace);\n                writableScope.changeLockLevel(WritableScope.LockLevel.READING);\n                resolveGenericBounds(property, propertyDescriptor, writableScope, typeParameterDescriptors, trace);\n                scopeWithTypeParameters = writableScope;\n            }\n\n            JetTypeReference receiverTypeRef = property.getReceiverTypeReference();\n            if (receiverTypeRef != null) {\n                receiverType = typeResolver.resolveType(scopeWithTypeParameters, receiverTypeRef, trace, true);\n            }\n        }\n\n        ReceiverParameterDescriptor receiverDescriptor =\n                DescriptorFactory.createExtensionReceiverParameterForCallable(propertyDescriptor, receiverType);\n\n        ReceiverParameterDescriptor implicitInitializerReceiver = property.hasDelegate() ? null : receiverDescriptor;\n\n        LexicalScope propertyScope = JetScopeUtils.getPropertyDeclarationInnerScope(propertyDescriptor, scope, typeParameterDescriptors,\n                                                                                    implicitInitializerReceiver, trace);\n\n        JetType type = getVariableType(propertyDescriptor, propertyScope, property, dataFlowInfo, true, trace);\n\n        propertyDescriptor.setType(type, typeParameterDescriptors, getDispatchReceiverParameterIfNeeded(containingDeclaration),\n                                   receiverDescriptor);\n\n        PropertyGetterDescriptorImpl getter = resolvePropertyGetterDescriptor(\n                scopeWithTypeParameters, property, propertyDescriptor, annotationSplitter, trace);\n        PropertySetterDescriptor setter = resolvePropertySetterDescriptor(\n                scopeWithTypeParameters, property, propertyDescriptor, annotationSplitter, trace);\n\n        propertyDescriptor.initialize(getter, setter);\n\n        trace.record(BindingContext.VARIABLE, property, propertyDescriptor);\n        return propertyDescriptor;\n    }","commit_id":"3624c4e5dc6d4ab76f3e5669ea02b50508696bcd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private PropertySetterDescriptor resolvePropertySetterDescriptor(\n            @NotNull LexicalScope scope,\n            @NotNull JetProperty property,\n            @NotNull PropertyDescriptor propertyDescriptor,\n            BindingTrace trace\n    ) {\n        JetPropertyAccessor setter = property.getSetter();\n        PropertySetterDescriptorImpl setterDescriptor = null;\n        if (setter != null) {\n            Annotations annotations =\n                    annotationResolver.resolveAnnotationsWithoutArguments(scope, setter.getModifierList(), trace);\n            JetParameter parameter = setter.getParameter();\n\n            setterDescriptor = new PropertySetterDescriptorImpl(propertyDescriptor, annotations,\n                                                                resolveModalityFromModifiers(setter, propertyDescriptor.getModality()),\n                                                                resolveVisibilityFromModifiers(setter, propertyDescriptor.getVisibility()),\n                                                                setter.hasBody(), false,\n                                                                CallableMemberDescriptor.Kind.DECLARATION, null, toSourceElement(setter));\n            if (parameter != null) {\n\n                // This check is redundant: the parser does not allow a default value, but we'll keep it just in case\n                if (parameter.hasDefaultValue()) {\n                    trace.report(SETTER_PARAMETER_WITH_DEFAULT_VALUE.on(parameter.getDefaultValue()));\n                }\n\n                JetType type;\n                JetTypeReference typeReference = parameter.getTypeReference();\n                if (typeReference == null) {\n                    type = propertyDescriptor.getType(); // TODO : this maybe unknown at this point\n                }\n                else {\n                    type = typeResolver.resolveType(scope, typeReference, trace, true);\n                    JetType inType = propertyDescriptor.getType();\n                    if (inType != null) {\n                        if (!TypeUtils.equalTypes(type, inType)) {\n                            trace.report(WRONG_SETTER_PARAMETER_TYPE.on(typeReference, inType, type));\n                        }\n                    }\n                    else {\n                        // TODO : the same check may be needed later???\n                    }\n                }\n\n                ValueParameterDescriptorImpl valueParameterDescriptor =\n                        resolveValueParameterDescriptor(scope, setterDescriptor, parameter, 0, type, trace);\n                setterDescriptor.initialize(valueParameterDescriptor);\n            }\n            else {\n                setterDescriptor.initializeDefault();\n            }\n\n            trace.record(BindingContext.PROPERTY_ACCESSOR, setter, setterDescriptor);\n        }\n        else if (property.isVar()) {\n            setterDescriptor = DescriptorFactory.createSetter(propertyDescriptor, !property.hasDelegate());\n        }\n\n        if (!property.isVar()) {\n            if (setter != null) {\n                //                trace.getErrorHandler().genericError(setter.asElement().getNode(), \"A 'val'-property cannot have a setter\");\n                trace.report(VAL_WITH_SETTER.on(setter));\n            }\n        }\n        return setterDescriptor;\n    }","id":73904,"modified_method":"@Nullable\n    private PropertySetterDescriptor resolvePropertySetterDescriptor(\n            @NotNull LexicalScope scope,\n            @NotNull JetProperty property,\n            @NotNull PropertyDescriptor propertyDescriptor,\n            @NotNull AnnotationSplitter annotationSplitter,\n            BindingTrace trace\n    ) {\n        JetPropertyAccessor setter = property.getSetter();\n        PropertySetterDescriptorImpl setterDescriptor = null;\n        if (setter != null) {\n            Annotations annotations = new CompositeAnnotations(KotlinPackage.listOf(\n                    annotationSplitter.getAnnotationsForTarget(PROPERTY_SETTER),\n                    annotationResolver.resolveAnnotationsWithoutArguments(scope, setter.getModifierList(), trace)));\n            JetParameter parameter = setter.getParameter();\n\n            setterDescriptor = new PropertySetterDescriptorImpl(propertyDescriptor, annotations,\n                                                                resolveModalityFromModifiers(setter, propertyDescriptor.getModality()),\n                                                                resolveVisibilityFromModifiers(setter, propertyDescriptor.getVisibility()),\n                                                                setter.hasBody(), false,\n                                                                CallableMemberDescriptor.Kind.DECLARATION, null, toSourceElement(setter));\n            if (parameter != null) {\n\n                // This check is redundant: the parser does not allow a default value, but we'll keep it just in case\n                if (parameter.hasDefaultValue()) {\n                    trace.report(SETTER_PARAMETER_WITH_DEFAULT_VALUE.on(parameter.getDefaultValue()));\n                }\n\n                JetType type;\n                JetTypeReference typeReference = parameter.getTypeReference();\n                if (typeReference == null) {\n                    type = propertyDescriptor.getType(); // TODO : this maybe unknown at this point\n                }\n                else {\n                    type = typeResolver.resolveType(scope, typeReference, trace, true);\n                    JetType inType = propertyDescriptor.getType();\n                    if (inType != null) {\n                        if (!TypeUtils.equalTypes(type, inType)) {\n                            trace.report(WRONG_SETTER_PARAMETER_TYPE.on(typeReference, inType, type));\n                        }\n                    }\n                    else {\n                        // TODO : the same check may be needed later???\n                    }\n                }\n\n                ValueParameterDescriptorImpl valueParameterDescriptor =\n                        resolveValueParameterDescriptor(scope, setterDescriptor, parameter, 0, type, trace);\n                setterDescriptor.initialize(valueParameterDescriptor);\n            }\n            else {\n                setterDescriptor.initializeDefault();\n            }\n\n            trace.record(BindingContext.PROPERTY_ACCESSOR, setter, setterDescriptor);\n        }\n        else if (property.isVar()) {\n            Annotations setterAnnotations = annotationSplitter.getAnnotationsForTarget(PROPERTY_SETTER);\n            setterDescriptor = DescriptorFactory.createSetter(propertyDescriptor, setterAnnotations, !property.hasDelegate());\n        }\n\n        if (!property.isVar()) {\n            if (setter != null) {\n                //                trace.getErrorHandler().genericError(setter.asElement().getNode(), \"A 'val'-property cannot have a setter\");\n                trace.report(VAL_WITH_SETTER.on(setter));\n            }\n        }\n        return setterDescriptor;\n    }","commit_id":"3624c4e5dc6d4ab76f3e5669ea02b50508696bcd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public ValueParameterDescriptorImpl resolveValueParameterDescriptor(\n            LexicalScope scope, FunctionDescriptor owner, JetParameter valueParameter, int index, JetType type, BindingTrace trace\n    ) {\n        JetType varargElementType = null;\n        JetType variableType = type;\n        if (valueParameter.hasModifier(VARARG_KEYWORD)) {\n            varargElementType = type;\n            variableType = getVarargParameterType(type);\n        }\n        ValueParameterDescriptorImpl valueParameterDescriptor = new ValueParameterDescriptorImpl(\n                owner,\n                null,\n                index,\n                annotationResolver.resolveAnnotationsWithoutArguments(scope, valueParameter.getModifierList(), trace),\n                JetPsiUtil.safeName(valueParameter.getName()),\n                variableType,\n                valueParameter.hasDefaultValue(),\n                varargElementType,\n                toSourceElement(valueParameter)\n        );\n\n        trace.record(BindingContext.VALUE_PARAMETER, valueParameter, valueParameterDescriptor);\n        return valueParameterDescriptor;\n    }","id":73905,"modified_method":"@NotNull\n    public ValueParameterDescriptorImpl resolveValueParameterDescriptor(\n            LexicalScope scope, FunctionDescriptor owner, JetParameter valueParameter, int index, JetType type, BindingTrace trace\n    ) {\n        JetType varargElementType = null;\n        JetType variableType = type;\n        if (valueParameter.hasModifier(VARARG_KEYWORD)) {\n            varargElementType = type;\n            variableType = getVarargParameterType(type);\n        }\n\n        JetModifierList modifierList = valueParameter.getModifierList();\n\n        Annotations allAnnotations =\n                annotationResolver.resolveAnnotationsWithoutArguments(scope, valueParameter.getModifierList(), trace);\n        Annotations valueParameterAnnotations = Annotations.EMPTY;\n\n        if (modifierList != null) {\n            if (valueParameter.hasValOrVar()) {\n                AnnotationSplitter annotationSplitter = new AnnotationSplitter(allAnnotations, KotlinPackage.setOf(CONSTRUCTOR_PARAMETER));\n                valueParameterAnnotations = annotationSplitter.getAnnotationsForTarget(CONSTRUCTOR_PARAMETER);\n            }\n            else {\n                valueParameterAnnotations = allAnnotations;\n            }\n        }\n\n        ValueParameterDescriptorImpl valueParameterDescriptor = new ValueParameterDescriptorImpl(\n                owner,\n                null,\n                index,\n                valueParameterAnnotations,\n                JetPsiUtil.safeName(valueParameter.getName()),\n                variableType,\n                valueParameter.hasDefaultValue(),\n                varargElementType,\n                toSourceElement(valueParameter)\n        );\n\n        trace.record(BindingContext.VALUE_PARAMETER, valueParameter, valueParameterDescriptor);\n        return valueParameterDescriptor;\n    }","commit_id":"3624c4e5dc6d4ab76f3e5669ea02b50508696bcd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void initializeWithDefaultGetterSetter(PropertyDescriptorImpl propertyDescriptor) {\n        PropertyGetterDescriptorImpl getter = propertyDescriptor.getGetter();\n        if (getter == null && !Visibilities.isPrivate(propertyDescriptor.getVisibility())) {\n            getter = DescriptorFactory.createDefaultGetter(propertyDescriptor);\n            getter.initialize(propertyDescriptor.getType());\n        }\n\n        PropertySetterDescriptor setter = propertyDescriptor.getSetter();\n        if (setter == null && propertyDescriptor.isVar()) {\n            setter = DescriptorFactory.createDefaultSetter(propertyDescriptor);\n        }\n        propertyDescriptor.initialize(getter, setter);\n    }","id":73906,"modified_method":"private static void initializeWithDefaultGetterSetter(PropertyDescriptorImpl propertyDescriptor) {\n        PropertyGetterDescriptorImpl getter = propertyDescriptor.getGetter();\n        if (getter == null && !Visibilities.isPrivate(propertyDescriptor.getVisibility())) {\n            getter = DescriptorFactory.createDefaultGetter(propertyDescriptor, Annotations.EMPTY);\n            getter.initialize(propertyDescriptor.getType());\n        }\n\n        PropertySetterDescriptor setter = propertyDescriptor.getSetter();\n        if (setter == null && propertyDescriptor.isVar()) {\n            setter = DescriptorFactory.createDefaultSetter(propertyDescriptor, Annotations.EMPTY);\n        }\n        propertyDescriptor.initialize(getter, setter);\n    }","commit_id":"3624c4e5dc6d4ab76f3e5669ea02b50508696bcd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public PropertyDescriptor resolvePrimaryConstructorParameterToAProperty(\n            @NotNull ClassDescriptor classDescriptor,\n            @NotNull ValueParameterDescriptor valueParameter,\n            @NotNull LexicalScope scope,\n            @NotNull JetParameter parameter, BindingTrace trace\n    ) {\n        JetType type = resolveParameterType(scope, parameter, trace);\n        Name name = parameter.getNameAsSafeName();\n        boolean isMutable = parameter.isMutable();\n        JetModifierList modifierList = parameter.getModifierList();\n\n        if (modifierList != null) {\n            if (modifierList.hasModifier(JetTokens.ABSTRACT_KEYWORD)) {\n                trace.report(ABSTRACT_PROPERTY_IN_PRIMARY_CONSTRUCTOR_PARAMETERS.on(parameter));\n            }\n        }\n\n        PropertyDescriptorImpl propertyDescriptor = PropertyDescriptorImpl.create(\n                classDescriptor,\n                valueParameter.getAnnotations(),\n                resolveModalityFromModifiers(parameter, Modality.FINAL),\n                resolveVisibilityFromModifiers(parameter, getDefaultVisibility(parameter, classDescriptor)),\n                isMutable,\n                name,\n                CallableMemberDescriptor.Kind.DECLARATION,\n                toSourceElement(parameter)\n        );\n        propertyDescriptor.setType(type, Collections.<TypeParameterDescriptor>emptyList(),\n                                   getDispatchReceiverParameterIfNeeded(classDescriptor), (ReceiverParameterDescriptor) null);\n\n        PropertyGetterDescriptorImpl getter = DescriptorFactory.createDefaultGetter(propertyDescriptor);\n        PropertySetterDescriptor setter =\n                propertyDescriptor.isVar() ? DescriptorFactory.createDefaultSetter(propertyDescriptor) : null;\n\n        propertyDescriptor.initialize(getter, setter);\n        getter.initialize(propertyDescriptor.getType());\n\n        trace.record(BindingContext.PRIMARY_CONSTRUCTOR_PARAMETER, parameter, propertyDescriptor);\n        trace.record(BindingContext.VALUE_PARAMETER_AS_PROPERTY, valueParameter, propertyDescriptor);\n        return propertyDescriptor;\n    }","id":73907,"modified_method":"@NotNull\n    public PropertyDescriptor resolvePrimaryConstructorParameterToAProperty(\n            @NotNull ClassDescriptor classDescriptor,\n            @NotNull ValueParameterDescriptor valueParameter,\n            @NotNull LexicalScope scope,\n            @NotNull JetParameter parameter, BindingTrace trace\n    ) {\n        JetType type = resolveParameterType(scope, parameter, trace);\n        Name name = parameter.getNameAsSafeName();\n        boolean isMutable = parameter.isMutable();\n        JetModifierList modifierList = parameter.getModifierList();\n\n        if (modifierList != null) {\n            if (modifierList.hasModifier(JetTokens.ABSTRACT_KEYWORD)) {\n                trace.report(ABSTRACT_PROPERTY_IN_PRIMARY_CONSTRUCTOR_PARAMETERS.on(parameter));\n            }\n        }\n\n        Annotations allAnnotations = annotationResolver.resolveAnnotationsWithoutArguments(scope, parameter.getModifierList(), trace);\n        AnnotationSplitter annotationSplitter = AnnotationSplitter.create(allAnnotations,\n                /*parameter =*/ true, /*hasBackingField =*/ true, /*isMutable =*/ isMutable);\n\n        Annotations propertyAnnotations = new CompositeAnnotations(\n                annotationSplitter.getAnnotationsForTargets(PROPERTY, FIELD),\n                annotationSplitter.getOtherAnnotations());\n\n        PropertyDescriptorImpl propertyDescriptor = PropertyDescriptorImpl.create(\n                classDescriptor,\n                propertyAnnotations,\n                resolveModalityFromModifiers(parameter, Modality.FINAL),\n                resolveVisibilityFromModifiers(parameter, getDefaultVisibility(parameter, classDescriptor)),\n                isMutable,\n                name,\n                CallableMemberDescriptor.Kind.DECLARATION,\n                toSourceElement(parameter)\n        );\n        propertyDescriptor.setType(type, Collections.<TypeParameterDescriptor>emptyList(),\n                                   getDispatchReceiverParameterIfNeeded(classDescriptor), (ReceiverParameterDescriptor) null);\n\n        Annotations setterAnnotations = annotationSplitter.getAnnotationsForTarget(PROPERTY_SETTER);\n        Annotations getterAnnotations = new CompositeAnnotations(KotlinPackage.listOf(\n                annotationSplitter.getAnnotationsForTarget(PROPERTY_GETTER)));\n\n        PropertyGetterDescriptorImpl getter = DescriptorFactory.createDefaultGetter(propertyDescriptor, getterAnnotations);\n        PropertySetterDescriptor setter =\n                propertyDescriptor.isVar() ? DescriptorFactory.createDefaultSetter(propertyDescriptor, setterAnnotations) : null;\n\n        propertyDescriptor.initialize(getter, setter);\n        getter.initialize(propertyDescriptor.getType());\n\n        trace.record(BindingContext.PRIMARY_CONSTRUCTOR_PARAMETER, parameter, propertyDescriptor);\n        trace.record(BindingContext.VALUE_PARAMETER_AS_PROPERTY, valueParameter, propertyDescriptor);\n        return propertyDescriptor;\n    }","commit_id":"3624c4e5dc6d4ab76f3e5669ea02b50508696bcd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private PropertyGetterDescriptorImpl resolvePropertyGetterDescriptor(\n            @NotNull LexicalScope scope,\n            @NotNull JetProperty property,\n            @NotNull PropertyDescriptor propertyDescriptor,\n            BindingTrace trace\n    ) {\n        PropertyGetterDescriptorImpl getterDescriptor;\n        JetPropertyAccessor getter = property.getGetter();\n        if (getter != null) {\n            Annotations annotations =\n                    annotationResolver.resolveAnnotationsWithoutArguments(scope, getter.getModifierList(), trace);\n\n            JetType outType = propertyDescriptor.getType();\n            JetType returnType = outType;\n            JetTypeReference returnTypeReference = getter.getReturnTypeReference();\n            if (returnTypeReference != null) {\n                returnType = typeResolver.resolveType(scope, returnTypeReference, trace, true);\n                if (outType != null && !TypeUtils.equalTypes(returnType, outType)) {\n                    trace.report(WRONG_GETTER_RETURN_TYPE.on(returnTypeReference, propertyDescriptor.getReturnType(), outType));\n                }\n            }\n\n            getterDescriptor = new PropertyGetterDescriptorImpl(propertyDescriptor, annotations,\n                                                                resolveModalityFromModifiers(getter, propertyDescriptor.getModality()),\n                                                                resolveVisibilityFromModifiers(getter, propertyDescriptor.getVisibility()),\n                                                                getter.hasBody(), false,\n                                                                CallableMemberDescriptor.Kind.DECLARATION, null, toSourceElement(getter));\n            getterDescriptor.initialize(returnType);\n            trace.record(BindingContext.PROPERTY_ACCESSOR, getter, getterDescriptor);\n        }\n        else {\n            getterDescriptor = DescriptorFactory.createGetter(propertyDescriptor, !property.hasDelegate());\n            getterDescriptor.initialize(propertyDescriptor.getType());\n        }\n        return getterDescriptor;\n    }","id":73908,"modified_method":"@Nullable\n    private PropertyGetterDescriptorImpl resolvePropertyGetterDescriptor(\n            @NotNull LexicalScope scope,\n            @NotNull JetProperty property,\n            @NotNull PropertyDescriptor propertyDescriptor,\n            @NotNull AnnotationSplitter annotationSplitter,\n            BindingTrace trace\n    ) {\n        PropertyGetterDescriptorImpl getterDescriptor;\n        JetPropertyAccessor getter = property.getGetter();\n        if (getter != null) {\n            Annotations getterAnnotations = new CompositeAnnotations(KotlinPackage.listOf(\n                    annotationSplitter.getAnnotationsForTarget(PROPERTY_GETTER),\n                    annotationSplitter.getOtherAnnotations(),\n                    annotationResolver.resolveAnnotationsWithoutArguments(scope, getter.getModifierList(), trace)));\n\n            JetType outType = propertyDescriptor.getType();\n            JetType returnType = outType;\n            JetTypeReference returnTypeReference = getter.getReturnTypeReference();\n            if (returnTypeReference != null) {\n                returnType = typeResolver.resolveType(scope, returnTypeReference, trace, true);\n                if (outType != null && !TypeUtils.equalTypes(returnType, outType)) {\n                    trace.report(WRONG_GETTER_RETURN_TYPE.on(returnTypeReference, propertyDescriptor.getReturnType(), outType));\n                }\n            }\n\n            getterDescriptor = new PropertyGetterDescriptorImpl(propertyDescriptor, getterAnnotations,\n                                                                resolveModalityFromModifiers(getter, propertyDescriptor.getModality()),\n                                                                resolveVisibilityFromModifiers(getter, propertyDescriptor.getVisibility()),\n                                                                getter.hasBody(), false,\n                                                                CallableMemberDescriptor.Kind.DECLARATION, null, toSourceElement(getter));\n            getterDescriptor.initialize(returnType);\n            trace.record(BindingContext.PROPERTY_ACCESSOR, getter, getterDescriptor);\n        }\n        else {\n            Annotations getterAnnotations = annotationSplitter.getAnnotationsForTarget(PROPERTY_GETTER);\n            getterDescriptor = DescriptorFactory.createGetter(propertyDescriptor, getterAnnotations, !property.hasDelegate());\n            getterDescriptor.initialize(propertyDescriptor.getType());\n        }\n        return getterDescriptor;\n    }","commit_id":"3624c4e5dc6d4ab76f3e5669ea02b50508696bcd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void close() throws IOException {\n        try {\n            getSolrServer().shutdown();\n        } catch (Exception e) {\n            // do nothing\n        } try {\n            getIndexingSolrServer().shutdown();\n        } catch (Exception e) {\n            // do nothing\n        } try {\n            getSearchingSolrServer().shutdown();\n        } catch (Exception e) {\n            // do nothing\n        }\n    }","id":73909,"modified_method":"@Override\n    public void close() throws IOException {\n        try {\n            SolrServer solrServer = getSolrServer();\n            if (solrServer != null) {\n                solrServer.shutdown();\n            }\n        } catch (Exception e) {\n            // do nothing\n        } try {\n            SolrServer indexingSolrServer = getIndexingSolrServer();\n            if (indexingSolrServer != null) {\n                indexingSolrServer.shutdown();\n            }\n        } catch (Exception e) {\n            // do nothing\n        } try {\n            getSearchingSolrServer().shutdown();\n        } catch (Exception e) {\n            // do nothing\n        }\n    }","commit_id":"48d6fd79e41af10cd8c6d18d988406d4e0ad18d8","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void close() throws IOException {\n        try {\n            if (solrServer != null) {\n                solrServer.shutdown();\n            }\n        } catch (Exception e) {\n            // do nothing\n        }\n    }","id":73910,"modified_method":"@Override\n    public void close() throws IOException {\n        try {\n            synchronized (this) {\n                if (solrServer != null) {\n                    solrServer.shutdown();\n                }\n            }\n        } catch (Exception e) {\n            // do nothing\n        }\n    }","commit_id":"48d6fd79e41af10cd8c6d18d988406d4e0ad18d8","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void checkSolrConfiguration(String solrHomePath, String coreName) throws IOException {\n        File solrHomePathFile = new File(solrHomePath);\n\n        log.info(\"checking configuration at {}\", solrHomePathFile.getAbsolutePath());\n\n        // check if solrHomePath exists\n        if (!solrHomePathFile.exists()) {\n            if (!solrHomePathFile.mkdirs()) {\n                throw new IOException(\"could not create solrHomePath directory\");\n            } else {\n                // copy all the needed files to the just created directory\n                copy(\"/solr/solr.xml\", solrHomePath);\n                copy(\"/solr/zoo.cfg\", solrHomePath);\n\n            }\n        } else if (!solrHomePathFile.isDirectory()) {\n            throw new IOException(\"a non directory file with the specified name already exists for the given solrHomePath '\" + solrHomePath);\n        }\n\n        File solrCorePathFile = new File(solrHomePathFile, coreName);\n        if (!solrCorePathFile.exists()) {\n            if (!new File(solrCorePathFile, \"conf\").mkdirs()) {\n                throw new IOException(\"could not create nested core directory in solrHomePath/solrCoreName/conf\");\n            }\n            String solrCoreDir = solrCorePathFile.getAbsolutePath();\n            File coreProperties = new File(new File(solrCoreDir), \"core.properties\");\n            assert coreProperties.createNewFile();\n            FileOutputStream out = new FileOutputStream(coreProperties);\n            IOUtils.writeBytes(out, (\"name=\" + coreName).getBytes());\n            out.flush();\n            out.close();\n\n            String coreConfDir = solrCoreDir + \"/conf/\";\n            copy(\"/solr/oak/conf/currency.xml\", coreConfDir);\n            copy(\"/solr/oak/conf/schema.xml\", coreConfDir);\n            copy(\"/solr/oak/conf/solrconfig.xml\", coreConfDir);\n        } else if (!solrCorePathFile.isDirectory()) {\n            throw new IOException(\"a non directory file with the specified name already exists for the given Solr core path'\" + solrCorePathFile.getAbsolutePath());\n        }\n\n        // check if the a core with the given coreName exists\n        String[] files = solrHomePathFile.list();\n        Arrays.sort(files);\n        if (Arrays.binarySearch(files, coreName) < 0) {\n            throw new IOException(\"could not find a directory with the coreName '\" + coreName\n                    + \"' in the solrHomePath '\" + solrHomePath + \"'\");\n        }\n    }","id":73911,"modified_method":"private void checkSolrConfiguration(String solrHomePath, String coreName) throws IOException {\n        File solrHomePathFile = new File(solrHomePath);\n\n        log.info(\"checking configuration at {}\", solrHomePathFile.getAbsolutePath());\n\n        // check if solrHomePath exists\n        if (!solrHomePathFile.exists()) {\n            if (!solrHomePathFile.mkdirs()) {\n                throw new IOException(\"could not create solrHomePath directory\");\n            } else {\n                // copy all the needed files to the just created directory\n                copy(\"/solr/solr.xml\", solrHomePath);\n                copy(\"/solr/zoo.cfg\", solrHomePath);\n\n            }\n        } else if (!solrHomePathFile.isDirectory()) {\n            throw new IOException(\"a non directory file with the specified name already exists for the given solrHomePath '\" + solrHomePath);\n        }\n\n        File solrCorePathFile = new File(solrHomePathFile, coreName);\n        if (!solrCorePathFile.exists()) {\n            if (!new File(solrCorePathFile, \"conf\").mkdirs()) {\n                throw new IOException(\"could not create nested core directory in solrHomePath/solrCoreName/conf\");\n            }\n            String solrCoreDir = solrCorePathFile.getAbsolutePath();\n            File coreProperties = new File(new File(solrCoreDir), \"core.properties\");\n            assert coreProperties.createNewFile();\n            FileOutputStream out = new FileOutputStream(coreProperties);\n            IOUtils.writeBytes(out, (\"name=\" + coreName).getBytes(\"UTF-8\"));\n            out.flush();\n            out.close();\n\n            String coreConfDir = solrCoreDir + \"/conf/\";\n            copy(\"/solr/oak/conf/currency.xml\", coreConfDir);\n            copy(\"/solr/oak/conf/schema.xml\", coreConfDir);\n            copy(\"/solr/oak/conf/solrconfig.xml\", coreConfDir);\n        } else if (!solrCorePathFile.isDirectory()) {\n            throw new IOException(\"a non directory file with the specified name already exists for the given Solr core path'\" + solrCorePathFile.getAbsolutePath());\n        }\n\n        // check if the a core with the given coreName exists\n        String[] files = solrHomePathFile.list();\n        Arrays.sort(files);\n        if (Arrays.binarySearch(files, coreName) < 0) {\n            throw new IOException(\"could not find a directory with the coreName '\" + coreName\n                    + \"' in the solrHomePath '\" + solrHomePath + \"'\");\n        }\n    }","commit_id":"48d6fd79e41af10cd8c6d18d988406d4e0ad18d8","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    @Override\n    public Collection<String> getIgnoredProperties() {\n        Collection<String> ignoredProperties;\n        Iterable<String> ignoredPropertiesValues = getStringValuesFor(Properties.IGNORED_PROPERTIES);\n        if (ignoredPropertiesValues != null) {\n            ignoredProperties = new LinkedList<String>();\n            for (String ignoredProperty : ignoredPropertiesValues) {\n                ignoredProperties.add(ignoredProperty);\n            }\n        } else {\n            ignoredProperties = Arrays.asList(SolrServerConfigurationDefaults.IGNORED_PROPERTIES);\n        }\n        return ignoredProperties;\n    }","id":73912,"modified_method":"@Nonnull\n    @Override\n    public Collection<String> getIgnoredProperties() {\n        Collection<String> ignoredProperties;\n        Iterable<String> ignoredPropertiesValues = getStringValuesFor(Properties.IGNORED_PROPERTIES);\n        if (ignoredPropertiesValues != null) {\n            ignoredProperties = new LinkedList<String>();\n            for (String ignoredProperty : ignoredPropertiesValues) {\n                ignoredProperties.add(ignoredProperty);\n            }\n        } else {\n            ignoredProperties = SolrServerConfigurationDefaults.IGNORED_PROPERTIES;\n        }\n        return ignoredProperties;\n    }","commit_id":"48d6fd79e41af10cd8c6d18d988406d4e0ad18d8","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private AbstractIterator<SolrResultRow> getIterator(final Filter filter, final List<OrderEntry> sortOrder, final String parent, final int parentDepth) {\n        return new AbstractIterator<SolrResultRow>() {\n            private final Set<String> seenPaths = Sets.newHashSet();\n            private final Deque<SolrResultRow> queue = Queues.newArrayDeque();\n            private int offset = 0;\n            private boolean noDocs = false;\n            private long numFound = 0;\n\n            @Override\n            protected SolrResultRow computeNext() {\n                if (!queue.isEmpty() || loadDocs()) {\n                    return queue.remove();\n                }\n                return endOfData();\n            }\n\n            private SolrResultRow convertToRow(SolrDocument doc) {\n                String path = String.valueOf(doc.getFieldValue(configuration.getPathField()));\n                if (path != null) {\n                    if (\"\".equals(path)) {\n                        path = \"/\";\n                    }\n                    if (!parent.isEmpty()) {\n                        path = getAncestorPath(path, parentDepth);\n                        // avoid duplicate entries\n                        if (seenPaths.contains(path)) {\n                            return null;\n                        }\n                        seenPaths.add(path);\n                    }\n\n                    float score = 0f;\n                    Object scoreObj = doc.get(\"score\");\n                    if (scoreObj != null) {\n                        score = (Float) scoreObj;\n                    }\n                    return new SolrResultRow(path, score, doc);\n                }\n                return null;\n            }\n\n            /**\n             * Loads the Solr documents in batches\n             * @return true if any document is loaded\n             */\n            private boolean loadDocs() {\n\n                if (noDocs) {\n                    return false;\n                }\n\n                try {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"converting filter {}\", filter);\n                    }\n                    SolrQuery query = FilterQueryParser.getQuery(filter, sortOrder, configuration);\n                    if (numFound > 0) {\n                        offset++;\n                        int newOffset = offset * configuration.getRows();\n                        if (newOffset >= numFound) {\n                            return false;\n                        }\n                        query.setParam(\"start\", String.valueOf(newOffset));\n                    }\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"sending query {}\", query);\n                    }\n                    QueryResponse queryResponse = solrServer.query(query);\n\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"getting response {}\", queryResponse.getHeader());\n                    }\n\n                    SolrDocumentList docs = queryResponse.getResults();\n\n                    if (docs != null) {\n\n                        numFound = docs.getNumFound();\n\n                        onRetrievedDocs(filter, docs);\n\n                        for (SolrDocument doc : docs) {\n                            SolrResultRow row = convertToRow(doc);\n                            if (row != null) {\n                                queue.add(row);\n                            }\n                        }\n                    }\n\n                    // handle spellcheck\n                    SpellCheckResponse spellCheckResponse = queryResponse.getSpellCheckResponse();\n                    if (spellCheckResponse != null && spellCheckResponse.getSuggestions() != null &&\n                            spellCheckResponse.getSuggestions().size() > 0) {\n                        SolrDocument fakeDoc = getSpellChecks(spellCheckResponse, filter);\n                        queue.add(new SolrResultRow(\"/\", 1.0, fakeDoc));\n                        noDocs = true;\n                    }\n\n                    // handle suggest\n                    NamedList<Object> response = queryResponse.getResponse();\n                    Map suggest = (Map) response.get(\"suggest\");\n                    if (suggest != null) {\n                        Set<Map.Entry<String, Object>> suggestEntries = suggest.entrySet();\n                        if (!suggestEntries.isEmpty()) {\n                            SolrDocument fakeDoc = getSuggestions(suggestEntries, filter);\n                            queue.add(new SolrResultRow(\"/\", 1.0, fakeDoc));\n                            noDocs = true;\n                        }\n                    }\n\n                } catch (Exception e) {\n                    if (log.isWarnEnabled()) {\n                        log.warn(\"query via {} failed.\", solrServer, e);\n                    }\n                }\n\n                return !queue.isEmpty();\n            }\n\n        };\n    }","id":73913,"modified_method":"private AbstractIterator<SolrResultRow> getIterator(final Filter filter, final List<OrderEntry> sortOrder, final String parent, final int parentDepth) {\n        return new AbstractIterator<SolrResultRow>() {\n            private final Set<String> seenPaths = Sets.newHashSet();\n            private final Deque<SolrResultRow> queue = Queues.newArrayDeque();\n            private int offset = 0;\n            private boolean noDocs = false;\n            private long numFound = 0;\n\n            @Override\n            protected SolrResultRow computeNext() {\n                if (!queue.isEmpty() || loadDocs()) {\n                    return queue.remove();\n                }\n                return endOfData();\n            }\n\n            private SolrResultRow convertToRow(SolrDocument doc) {\n                String path = String.valueOf(doc.getFieldValue(configuration.getPathField()));\n                if (\"\".equals(path)) {\n                    path = \"/\";\n                }\n                if (!parent.isEmpty()) {\n                    path = getAncestorPath(path, parentDepth);\n                    // avoid duplicate entries\n                    if (seenPaths.contains(path)) {\n                        return null;\n                    }\n                    seenPaths.add(path);\n                }\n\n                float score = 0f;\n                Object scoreObj = doc.get(\"score\");\n                if (scoreObj != null) {\n                    score = (Float) scoreObj;\n                }\n                return new SolrResultRow(path, score, doc);\n\n            }\n\n            /**\n             * Loads the Solr documents in batches\n             * @return true if any document is loaded\n             */\n            private boolean loadDocs() {\n\n                if (noDocs) {\n                    return false;\n                }\n\n                try {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"converting filter {}\", filter);\n                    }\n                    SolrQuery query = FilterQueryParser.getQuery(filter, sortOrder, configuration);\n                    if (numFound > 0) {\n                        offset++;\n                        int newOffset = offset * configuration.getRows();\n                        if (newOffset >= numFound) {\n                            return false;\n                        }\n                        query.setParam(\"start\", String.valueOf(newOffset));\n                    }\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"sending query {}\", query);\n                    }\n                    QueryResponse queryResponse = solrServer.query(query);\n\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"getting response {}\", queryResponse.getHeader());\n                    }\n\n                    SolrDocumentList docs = queryResponse.getResults();\n\n                    if (docs != null) {\n\n                        numFound = docs.getNumFound();\n\n                        onRetrievedDocs(filter, docs);\n\n                        for (SolrDocument doc : docs) {\n                            SolrResultRow row = convertToRow(doc);\n                            if (row != null) {\n                                queue.add(row);\n                            }\n                        }\n                    }\n\n                    // handle spellcheck\n                    SpellCheckResponse spellCheckResponse = queryResponse.getSpellCheckResponse();\n                    if (spellCheckResponse != null && spellCheckResponse.getSuggestions() != null &&\n                            spellCheckResponse.getSuggestions().size() > 0) {\n                        SolrDocument fakeDoc = getSpellChecks(spellCheckResponse, filter);\n                        queue.add(new SolrResultRow(\"/\", 1.0, fakeDoc));\n                        noDocs = true;\n                    }\n\n                    // handle suggest\n                    NamedList<Object> response = queryResponse.getResponse();\n                    Map suggest = (Map) response.get(\"suggest\");\n                    if (suggest != null) {\n                        Set<Map.Entry<String, Object>> suggestEntries = suggest.entrySet();\n                        if (!suggestEntries.isEmpty()) {\n                            SolrDocument fakeDoc = getSuggestions(suggestEntries, filter);\n                            queue.add(new SolrResultRow(\"/\", 1.0, fakeDoc));\n                            noDocs = true;\n                        }\n                    }\n\n                } catch (Exception e) {\n                    if (log.isWarnEnabled()) {\n                        log.warn(\"query via {} failed.\", solrServer, e);\n                    }\n                }\n\n                return !queue.isEmpty();\n            }\n\n        };\n    }","commit_id":"48d6fd79e41af10cd8c6d18d988406d4e0ad18d8","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public IndexRow next() {\n            final IndexRow pathRow = pathCursor.next();\n            return new IndexRow() {\n\n                @Override\n                public String getPath() {\n                    return pathRow.getPath();\n                }\n\n                @Override\n                public PropertyValue getValue(String columnName) {\n                    // overlay the score\n                    if (QueryImpl.JCR_SCORE.equals(columnName)) {\n                        return PropertyValues.newDouble(currentRow.score);\n                    }\n                    // TODO : make inclusion of doc configurable\n                    Collection<Object> fieldValues = currentRow.doc.getFieldValues(columnName);\n                    return currentRow.doc != null ? PropertyValues.newString(\n                            Iterables.toString(fieldValues != null ? fieldValues : Collections.emptyList())) : null;\n                }\n\n            };\n        }","id":73914,"modified_method":"@Override\n        public IndexRow next() {\n            final IndexRow pathRow = pathCursor.next();\n            return new IndexRow() {\n\n                @Override\n                public String getPath() {\n                    return pathRow.getPath();\n                }\n\n                @Override\n                public PropertyValue getValue(String columnName) {\n                    // overlay the score\n                    if (QueryImpl.JCR_SCORE.equals(columnName)) {\n                        return PropertyValues.newDouble(currentRow.score);\n                    }\n                    Collection<Object> fieldValues = currentRow.doc.getFieldValues(columnName);\n                    return PropertyValues.newString(Iterables.toString(fieldValues != null ? fieldValues : Collections.emptyList()));\n                }\n\n            };\n        }","commit_id":"48d6fd79e41af10cd8c6d18d988406d4e0ad18d8","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Editor getIndexEditor(\n            @Nonnull String type, @Nonnull NodeBuilder definition, @Nonnull NodeState root, @Nonnull IndexUpdateCallback callback)\n            throws CommitFailedException {\n\n        if (SolrQueryIndex.TYPE.equals(type)\n                && isConfigurationOk()) {\n            try {\n                return new SolrIndexEditor(\n                        definition,\n                        solrServerProvider.getSolrServer(),\n                        oakSolrConfigurationProvider.getConfiguration(), callback);\n            } catch (Exception e) {\n                if (log.isErrorEnabled()) {\n                    log.error(\"unable to create SolrIndexEditor\", e);\n                }\n            }\n        }\n        return null;\n    }","id":73915,"modified_method":"@Override\n    public Editor getIndexEditor(\n            @Nonnull String type, @Nonnull NodeBuilder definition, @Nonnull NodeState root, @Nonnull IndexUpdateCallback callback)\n            throws CommitFailedException {\n\n        if (SolrQueryIndex.TYPE.equals(type)\n                && isConfigurationOk()) {\n            try {\n              SolrServer solrServer = solrServerProvider.getSolrServer();\n              if (solrServer != null) {\n                  return new SolrIndexEditor(\n                        definition,\n                        solrServer,\n                        oakSolrConfigurationProvider.getConfiguration(), callback);\n              } else {\n                  if (log.isWarnEnabled()) {\n                      log.warn(\"null SolrServer provided, cannot index {}\", definition);\n                  }\n              }\n            } catch (Exception e) {\n                if (log.isErrorEnabled()) {\n                    log.error(\"unable to create SolrIndexEditor\", e);\n                }\n            }\n        }\n        return null;\n    }","commit_id":"a8f64fdcd7a9390768736edbeccbf592998651f2","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    @Override\n    public List<? extends QueryIndex> getQueryIndexes(NodeState nodeState) {\n\n        List<QueryIndex> tempIndexes = new ArrayList<QueryIndex>();\n        if (solrServerProvider == null || oakSolrConfigurationProvider == null) {\n            return tempIndexes;\n        }\n        NodeState definitions = nodeState.getChildNode(INDEX_DEFINITIONS_NAME);\n        for (ChildNodeEntry entry : definitions.getChildNodeEntries()) {\n            NodeState definition = entry.getNodeState();\n            PropertyState type = definition.getProperty(TYPE_PROPERTY_NAME);\n            if (type != null\n                    && SolrQueryIndex.TYPE.equals(type.getValue(Type.STRING))) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"found a Solr index definition {}\", entry.getName());\n                }\n                try {\n                    SolrServer solrServer = solrServerProvider.getSolrServer();\n                    // the query engine should be returned only if the server is alive, otherwise other indexes should be used\n                    if (solrServer != null && 0 == solrServer.ping().getStatus()) {\n                        tempIndexes.add(new SolrQueryIndex(\n                                entry.getName(),\n                                solrServer,\n                                oakSolrConfigurationProvider.getConfiguration()));\n                    }\n                } catch (Exception e) {\n                    if (log.isErrorEnabled()) {\n                        log.error(\"unable to create Solr query index at \" + entry.getName(), e);\n                    }\n                }\n\n            }\n        }\n        return tempIndexes;\n    }","id":73916,"modified_method":"@Nonnull\n    @Override\n    public List<? extends QueryIndex> getQueryIndexes(NodeState nodeState) {\n\n        List<QueryIndex> tempIndexes = new ArrayList<QueryIndex>();\n        if (solrServerProvider == null || oakSolrConfigurationProvider == null) {\n            return tempIndexes;\n        }\n        NodeState definitions = nodeState.getChildNode(INDEX_DEFINITIONS_NAME);\n        for (ChildNodeEntry entry : definitions.getChildNodeEntries()) {\n            NodeState definition = entry.getNodeState();\n            PropertyState type = definition.getProperty(TYPE_PROPERTY_NAME);\n            if (type != null\n                    && SolrQueryIndex.TYPE.equals(type.getValue(Type.STRING))) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"found a Solr index definition {}\", entry.getName());\n                }\n                try {\n                    SolrServer solrServer = solrServerProvider.getSolrServer();\n                    // the query engine should be returned only if the server is alive, otherwise other indexes should be used\n                    if (solrServer != null && 0 == solrServer.ping().getStatus()) {\n                        tempIndexes.add(new SolrQueryIndex(\n                                entry.getName(),\n                                solrServer,\n                                oakSolrConfigurationProvider.getConfiguration()));\n                    }\n                    else {\n                        if (log.isWarnEnabled()) {\n                            log.warn(\"cannot create Solr query index as SolrServer {}is unreachable\", solrServer);\n                        }\n                    }\n                } catch (Exception e) {\n                    if (log.isErrorEnabled()) {\n                        log.error(\"unable to create Solr query index at \" + entry.getName(), e);\n                    }\n                }\n\n            }\n        }\n        return tempIndexes;\n    }","commit_id":"a8f64fdcd7a9390768736edbeccbf592998651f2","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    @Override\n    public List<? extends QueryIndex> getQueryIndexes(NodeState nodeState) {\n\n        List<QueryIndex> tempIndexes = new ArrayList<QueryIndex>();\n        if (solrServerProvider == null || oakSolrConfigurationProvider == null) {\n            return tempIndexes;\n        }\n        NodeState definitions = nodeState.getChildNode(INDEX_DEFINITIONS_NAME);\n        for (ChildNodeEntry entry : definitions.getChildNodeEntries()) {\n            NodeState definition = entry.getNodeState();\n            PropertyState type = definition.getProperty(TYPE_PROPERTY_NAME);\n            if (type != null\n                    && SolrQueryIndex.TYPE.equals(type.getValue(Type.STRING))) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"found a Solr index definition {}\", entry.getName());\n                }\n\n                try {\n                    tempIndexes.add(new SolrQueryIndex(\n                            entry.getName(),\n                            solrServerProvider.getSolrServer(),\n                            oakSolrConfigurationProvider.getConfiguration()));\n                } catch (Exception e) {\n                    if (log.isErrorEnabled()) {\n                        log.error(\"unable to create Solr query index at \" + entry.getName(), e);\n                    }\n                }\n            }\n        }\n        return tempIndexes;\n    }","id":73917,"modified_method":"@Nonnull\n    @Override\n    public List<? extends QueryIndex> getQueryIndexes(NodeState nodeState) {\n\n        List<QueryIndex> tempIndexes = new ArrayList<QueryIndex>();\n        if (solrServerProvider == null || oakSolrConfigurationProvider == null) {\n            return tempIndexes;\n        }\n        NodeState definitions = nodeState.getChildNode(INDEX_DEFINITIONS_NAME);\n        for (ChildNodeEntry entry : definitions.getChildNodeEntries()) {\n            NodeState definition = entry.getNodeState();\n            PropertyState type = definition.getProperty(TYPE_PROPERTY_NAME);\n            if (type != null\n                    && SolrQueryIndex.TYPE.equals(type.getValue(Type.STRING))) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"found a Solr index definition {}\", entry.getName());\n                }\n                try {\n                    SolrServer solrServer = solrServerProvider.getSolrServer();\n                    // the query engine should be returned only if the serve is alive, otherwise other indexes should be used\n                    if (solrServer != null && 0 == solrServer.ping().getStatus()) {\n                        tempIndexes.add(new SolrQueryIndex(\n                                entry.getName(),\n                                solrServer,\n                                oakSolrConfigurationProvider.getConfiguration()));\n                    }\n                } catch (Exception e) {\n                    if (log.isErrorEnabled()) {\n                        log.error(\"unable to create Solr query index at \" + entry.getName(), e);\n                    }\n                }\n\n            }\n        }\n        return tempIndexes;\n    }","commit_id":"6d12a8aa843b377c5468a2feb87b44b0bed2da2a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public float getPrefHeight () {\n\t\tif (vertical)\n\t\t\treturn 140;\n\t\telse {\n\t\t\tfinal Drawable knob = (disabled && style.disabledKnob != null) ? style.disabledKnob : style.knob;\n\t\t\tfinal Drawable bg = (disabled && style.disabledBackground != null) ? style.disabledBackground : style.background;\n\t\t\treturn Math.max(knob == null ? 0 : knob.getMinHeight(), bg.getMinHeight());\n\t\t}\n\t}","id":73918,"modified_method":"public float getPrefHeight () {\n\t\tif (vertical)\n\t\t\treturn 140;\n\t\telse {\n\t\t\tfinal Drawable knob = (disabled && style.disabledKnob != null) ? style.disabledKnob : style.knob;\n\t\t\tfinal Drawable bg = (disabled && style.disabledBackground != null) ? style.disabledBackground : style.background;\n\t\t\treturn Math.max(knob == null ? 0 : knob.getMinHeight(), bg == null ? 0 : bg.getMinHeight());\n\t\t}\n\t}","commit_id":"7661a514e7d370becb8cb1e455b1a0de25172a59","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void draw (Batch batch, float parentAlpha) {\n\t\tProgressBarStyle style = this.style;\n\t\tboolean disabled = this.disabled;\n\t\tfinal Drawable knob = (disabled && style.disabledKnob != null) ? style.disabledKnob : style.knob;\n\t\tfinal Drawable bg = (disabled && style.disabledBackground != null) ? style.disabledBackground : style.background;\n\t\tfinal Drawable knobBefore = (disabled && style.disabledKnobBefore != null) ? style.disabledKnobBefore : style.knobBefore;\n\t\tfinal Drawable knobAfter = (disabled && style.disabledKnobAfter != null) ? style.disabledKnobAfter : style.knobAfter;\n\n\t\tColor color = getColor();\n\t\tfloat x = getX();\n\t\tfloat y = getY();\n\t\tfloat width = getWidth();\n\t\tfloat height = getHeight();\n\t\tfloat knobHeight = knob == null ? 0 : knob.getMinHeight();\n\t\tfloat knobWidth = knob == null ? 0 : knob.getMinWidth();\n\t\tfloat percent = getVisualPercent();\n\n\t\tbatch.setColor(color.r, color.g, color.b, color.a * parentAlpha);\n\n\t\tif (vertical) {\n\t\t\tbg.draw(batch, x + (int)((width - bg.getMinWidth()) * 0.5f), y, bg.getMinWidth(), height);\n\n\t\t\tfloat positionHeight = height - (bg.getTopHeight() + bg.getBottomHeight());\n\t\t\tfloat knobHeightHalf = 0;\n\t\t\tif (min != max) {\n\t\t\t\tif (knob == null) {\n\t\t\t\t\tknobHeightHalf = knobBefore == null ? 0 : knobBefore.getMinHeight() * 0.5f;\n\t\t\t\t\tposition = (positionHeight - knobHeightHalf) * percent;\n\t\t\t\t\tposition = Math.min(positionHeight - knobHeightHalf, position);\n\t\t\t\t} else {\n\t\t\t\t\tknobHeightHalf = knobHeight * 0.5f;\n\t\t\t\t\tposition = (positionHeight - knobHeight) * percent;\n\t\t\t\t\tposition = Math.min(positionHeight - knobHeight, position) + bg.getBottomHeight();\n\t\t\t\t}\n\t\t\t\tposition = Math.max(0, position);\n\t\t\t}\n\n\t\t\tif (knobBefore != null) {\n\t\t\t\tfloat offset = 0;\n\t\t\t\tif (bg != null) offset = bg.getTopHeight();\n\t\t\t\tknobBefore.draw(batch, x + (int)((width - knobBefore.getMinWidth()) * 0.5f), y + offset, knobBefore.getMinWidth(),\n\t\t\t\t\t(int)(position + knobHeightHalf));\n\t\t\t}\n\t\t\tif (knobAfter != null) {\n\t\t\t\tknobAfter.draw(batch, x + (int)((width - knobAfter.getMinWidth()) * 0.5f), y + (int)(position + knobHeightHalf),\n\t\t\t\t\tknobAfter.getMinWidth(), height - (int)(position + knobHeightHalf));\n\t\t\t}\n\t\t\tif (knob != null) knob.draw(batch, x + (int)((width - knobWidth) * 0.5f), (int)(y + position), knobWidth, knobHeight);\n\t\t} else {\n\t\t\tbg.draw(batch, x, y + (int)((height - bg.getMinHeight()) * 0.5f), width, bg.getMinHeight());\n\n\t\t\tfloat positionWidth = width - (bg.getLeftWidth() + bg.getRightWidth());\n\t\t\tfloat knobWidthHalf = 0;\n\t\t\tif (min != max) {\n\t\t\t\tif (knob == null) {\n\t\t\t\t\tknobWidthHalf = knobBefore == null ? 0 : knobBefore.getMinWidth() * 0.5f;\n\t\t\t\t\tposition = (positionWidth - knobWidthHalf) * percent;\n\t\t\t\t\tposition = Math.min(positionWidth - knobWidthHalf, position);\n\t\t\t\t} else {\n\t\t\t\t\tknobWidthHalf = knobWidth * 0.5f;\n\t\t\t\t\tposition = (positionWidth - knobWidth) * percent;\n\t\t\t\t\tposition = Math.min(positionWidth - knobWidth, position) + bg.getLeftWidth();\n\t\t\t\t}\n\t\t\t\tposition = Math.max(0, position);\n\t\t\t}\n\n\t\t\tif (knobBefore != null) {\n\t\t\t\tfloat offset = 0;\n\t\t\t\tif (bg != null) offset = bg.getLeftWidth();\n\t\t\t\tknobBefore.draw(batch, x + offset, y + (int)((height - knobBefore.getMinHeight()) * 0.5f),\n\t\t\t\t\t(int)(position + knobWidthHalf), knobBefore.getMinHeight());\n\t\t\t}\n\t\t\tif (knobAfter != null) {\n\t\t\t\tknobAfter.draw(batch, x + (int)(position + knobWidthHalf), y + (int)((height - knobAfter.getMinHeight()) * 0.5f),\n\t\t\t\t\twidth - (int)(position + knobWidthHalf), knobAfter.getMinHeight());\n\t\t\t}\n\t\t\tif (knob != null) knob.draw(batch, (int)(x + position), (int)(y + (height - knobHeight) * 0.5f), knobWidth, knobHeight);\n\t\t}\n\t}","id":73919,"modified_method":"@Override\n\tpublic void draw (Batch batch, float parentAlpha) {\n\t\tProgressBarStyle style = this.style;\n\t\tboolean disabled = this.disabled;\n\t\tfinal Drawable knob = (disabled && style.disabledKnob != null) ? style.disabledKnob : style.knob;\n\t\tfinal Drawable bg = (disabled && style.disabledBackground != null) ? style.disabledBackground : style.background;\n\t\tfinal Drawable knobBefore = (disabled && style.disabledKnobBefore != null) ? style.disabledKnobBefore : style.knobBefore;\n\t\tfinal Drawable knobAfter = (disabled && style.disabledKnobAfter != null) ? style.disabledKnobAfter : style.knobAfter;\n\n\t\tColor color = getColor();\n\t\tfloat x = getX();\n\t\tfloat y = getY();\n\t\tfloat width = getWidth();\n\t\tfloat height = getHeight();\n\t\tfloat knobHeight = knob == null ? 0 : knob.getMinHeight();\n\t\tfloat knobWidth = knob == null ? 0 : knob.getMinWidth();\n\t\tfloat percent = getVisualPercent();\n\n\t\tbatch.setColor(color.r, color.g, color.b, color.a * parentAlpha);\n\n\t\tif (vertical) {\n\t\t\tfloat positionHeight = height;\n\n\t\t\tfloat bgTopHeight = 0;\n\t\t\tif (bg != null) {\n\t\t\t\tbg.draw(batch, x + (int)((width - bg.getMinWidth()) * 0.5f), y, bg.getMinWidth(), height);\n\t\t\t\tbgTopHeight = bg.getTopHeight();\n\t\t\t\tpositionHeight -= -(bgTopHeight + bg.getBottomHeight());\n\t\t\t}\n\n\t\t\tfloat knobHeightHalf = 0;\n\t\t\tif (min != max) {\n\t\t\t\tif (knob == null) {\n\t\t\t\t\tknobHeightHalf = knobBefore == null ? 0 : knobBefore.getMinHeight() * 0.5f;\n\t\t\t\t\tposition = (positionHeight - knobHeightHalf) * percent;\n\t\t\t\t\tposition = Math.min(positionHeight - knobHeightHalf, position);\n\t\t\t\t} else {\n\t\t\t\t\tknobHeightHalf = knobHeight * 0.5f;\n\t\t\t\t\tposition = (positionHeight - knobHeight) * percent;\n\t\t\t\t\tposition = Math.min(positionHeight - knobHeight, position) + bg.getBottomHeight();\n\t\t\t\t}\n\t\t\t\tposition = Math.max(0, position);\n\t\t\t}\n\n\t\t\tif (knobBefore != null) {\n\t\t\t\tfloat offset = 0;\n\t\t\t\tif (bg != null) offset = bgTopHeight;\n\t\t\t\tknobBefore.draw(batch, x + (int)((width - knobBefore.getMinWidth()) * 0.5f), y + offset, knobBefore.getMinWidth(),\n\t\t\t\t\t(int)(position + knobHeightHalf));\n\t\t\t}\n\t\t\tif (knobAfter != null) {\n\t\t\t\tknobAfter.draw(batch, x + (int)((width - knobAfter.getMinWidth()) * 0.5f), y + (int)(position + knobHeightHalf),\n\t\t\t\t\tknobAfter.getMinWidth(), height - (int)(position + knobHeightHalf));\n\t\t\t}\n\t\t\tif (knob != null) knob.draw(batch, x + (int)((width - knobWidth) * 0.5f), (int)(y + position), knobWidth, knobHeight);\n\t\t} else {\n\t\t\tfloat positionWidth = width;\n\n\t\t\tfloat bgLeftWidth = 0;\n\t\t\tif (bg != null) {\n\t\t\t\tbg.draw(batch, x, y + (int)((height - bg.getMinHeight()) * 0.5f), width, bg.getMinHeight());\n\t\t\t\tbgLeftWidth = bg.getLeftWidth();\n\t\t\t\tpositionWidth -= bgLeftWidth + bg.getRightWidth();\n\t\t\t}\n\n\t\t\tfloat knobWidthHalf = 0;\n\t\t\tif (min != max) {\n\t\t\t\tif (knob == null) {\n\t\t\t\t\tknobWidthHalf = knobBefore == null ? 0 : knobBefore.getMinWidth() * 0.5f;\n\t\t\t\t\tposition = (positionWidth - knobWidthHalf) * percent;\n\t\t\t\t\tposition = Math.min(positionWidth - knobWidthHalf, position);\n\t\t\t\t} else {\n\t\t\t\t\tknobWidthHalf = knobWidth * 0.5f;\n\t\t\t\t\tposition = (positionWidth - knobWidth) * percent;\n\t\t\t\t\tposition = Math.min(positionWidth - knobWidth, position) + bgLeftWidth;\n\t\t\t\t}\n\t\t\t\tposition = Math.max(0, position);\n\t\t\t}\n\n\t\t\tif (knobBefore != null) {\n\t\t\t\tfloat offset = 0;\n\t\t\t\tif (bg != null) offset = bgLeftWidth;\n\t\t\t\tknobBefore.draw(batch, x + offset, y + (int)((height - knobBefore.getMinHeight()) * 0.5f),\n\t\t\t\t\t(int)(position + knobWidthHalf), knobBefore.getMinHeight());\n\t\t\t}\n\t\t\tif (knobAfter != null) {\n\t\t\t\tknobAfter.draw(batch, x + (int)(position + knobWidthHalf), y + (int)((height - knobAfter.getMinHeight()) * 0.5f),\n\t\t\t\t\twidth - (int)(position + knobWidthHalf), knobAfter.getMinHeight());\n\t\t\t}\n\t\t\tif (knob != null) knob.draw(batch, (int)(x + position), (int)(y + (height - knobHeight) * 0.5f), knobWidth, knobHeight);\n\t\t}\n\t}","commit_id":"7661a514e7d370becb8cb1e455b1a0de25172a59","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n     * Returns a position info representing the dimensions of all visible child elements of the given panel (excluding elements with position:absolute).\n     * If the panel has no visible child elements, it's outer dimensions are returned.<p>\n     * \n     * @param panel the panel\n     * \n     * @return the position info\n     */\n    public static CmsPositionBean getInnerDimensions(Element panel) {\n\n        boolean first = true;\n        int top = 0;\n        int left = 0;\n        int height = 0;\n        int width = 0;\n        Element child = panel.getFirstChildElement();\n        while (child != null) {\n            String positioning = child.getStyle().getPosition();\n            if (!Display.NONE.getCssName().equals(child.getStyle().getDisplay())\n                && !(positioning.equals(Position.ABSOLUTE.getCssName()) || positioning.equals(Position.FIXED.getCssName()))) {\n                if (first) {\n                    first = false;\n                    top = child.getAbsoluteTop();\n                    left = child.getAbsoluteLeft();\n                    height = child.getOffsetHeight();\n                    width = child.getOffsetWidth();\n                } else {\n                    int wTop = child.getAbsoluteTop();\n                    top = top < wTop ? top : wTop;\n                    int wLeft = child.getAbsoluteLeft();\n                    left = left < wLeft ? left : wLeft;\n                    int wHeight = child.getOffsetHeight();\n                    height = height > (wTop + wHeight - top) ? height : (wTop + wHeight - top);\n                    int wWidth = child.getOffsetWidth();\n                    width = width > (wLeft + wWidth - left) ? width : (wLeft + wWidth - left);\n                }\n            }\n            child = child.getNextSiblingElement();\n        }\n        if (!first) {\n            CmsPositionBean result = new CmsPositionBean();\n            result.setHeight(height);\n            result.setWidth(width);\n            result.setTop(top);\n            result.setLeft(left);\n            return result;\n        } else {\n            return generatePositionInfo(panel);\n        }\n    }","id":73920,"modified_method":"/**\n     * Returns a position info representing the dimensions of all visible child elements of the given panel (excluding elements with position:absolute).\n     * If the panel has no visible child elements, it's outer dimensions are returned.<p>\n     * \n     * @param panel the panel\n     * \n     * @return the position info\n     */\n    public static CmsPositionBean getInnerDimensions(Element panel) {\n\n        boolean first = true;\n        int top = 0;\n        int left = 0;\n        int bottom = 0;\n        int right = 0;\n        Element child = panel.getFirstChildElement();\n        while (child != null) {\n            String positioning = child.getStyle().getPosition();\n            if (!Display.NONE.getCssName().equals(child.getStyle().getDisplay())\n                && !(positioning.equals(Position.ABSOLUTE.getCssName()) || positioning.equals(Position.FIXED.getCssName()))) {\n                if (first) {\n                    first = false;\n                    top = child.getAbsoluteTop();\n                    left = child.getAbsoluteLeft();\n                    bottom = top + child.getOffsetHeight();\n                    right = left + child.getOffsetWidth();\n                } else {\n                    int wTop = child.getAbsoluteTop();\n                    top = top < wTop ? top : wTop;\n                    int wLeft = child.getAbsoluteLeft();\n                    left = left < wLeft ? left : wLeft;\n                    int wBottom = wTop + child.getOffsetHeight();\n                    bottom = bottom > wBottom ? bottom : wBottom;\n                    int wRight = wLeft + child.getOffsetWidth();\n                    right = right > wRight ? right : wRight;\n                }\n            }\n            child = child.getNextSiblingElement();\n        }\n        if (!first) {\n            CmsPositionBean result = new CmsPositionBean();\n            result.setHeight(bottom - top);\n            result.setWidth(right - left);\n            result.setTop(top);\n            result.setLeft(left);\n            return result;\n        } else {\n            return generatePositionInfo(panel);\n        }\n    }","commit_id":"640d0d54873572aa4a2c7829f78a5f942e882c61","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Override\n    public Iterator<Mapper> iterator() {\n        List<FieldMapper> extras = Arrays.asList(\n                contentMapper,\n                dateMapper,\n                titleMapper,\n                nameMapper,\n                authorMapper,\n                keywordsMapper,\n                contentTypeMapper,\n                contentLengthMapper,\n                languageMapper);\n        return CollectionUtils.concat(super.iterator(), extras.iterator());\n    }","id":73921,"modified_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    public Iterator<Mapper> iterator() {\n        List<Mapper> extras = Arrays.asList(\n                contentMapper,\n                dateMapper,\n                titleMapper,\n                nameMapper,\n                authorMapper,\n                keywordsMapper,\n                contentTypeMapper,\n                contentLengthMapper,\n                languageMapper);\n        return Iterators.concat(super.iterator(), extras.iterator());\n    }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Before\n    public void setupMapperParser() {\n        mapperParser = MapperTestUtils.newMapperParser(createTempDir());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n    }","id":73922,"modified_method":"@Before\n    public void setupMapperParser() throws Exception {\n        mapperParser = MapperTestUtils.newMapperService(createTempDir(), Settings.EMPTY).documentMapperParser();\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n    }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testMultipleDocsEncryptedFirst() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(createTempDir());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                .field(\"file1\", pdf)\n                .field(\"file2\", html)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.title\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.author\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.keywords\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content_type\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file1.content_length\").fieldType().names().indexName()), nullValue());\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content\").fieldType().names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.title\").fieldType().names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.author\").fieldType().names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.keywords\").fieldType().names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content_type\").fieldType().names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file2.content_length\").fieldType().names().indexName()).numericValue().longValue(), is(344L));\n    }","id":73923,"modified_method":"public void testMultipleDocsEncryptedFirst() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperService(createTempDir(), Settings.EMPTY).documentMapperParser();\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                .field(\"file1\", pdf)\n                .field(\"file2\", html)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.title\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.author\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.keywords\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content_type\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file1.content_length\").fieldType().names().indexName()), nullValue());\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content\").fieldType().names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.title\").fieldType().names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.author\").fieldType().names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.keywords\").fieldType().names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content_type\").fieldType().names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file2.content_length\").fieldType().names().indexName()).numericValue().longValue(), is(344L));\n    }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test(expected = MapperParsingException.class)\n    public void testMultipleDocsEncryptedNotIgnoringErrors() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(\n            Settings.builder()\n                             .put(\"path.home\", createTempDir())\n                             .put(\"index.mapping.attachment.ignore_errors\", false)\n                             .build());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                .field(\"file1\", pdf)\n                .field(\"file2\", html)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.title\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.author\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.keywords\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content_type\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file1.content_length\").fieldType().names().indexName()), nullValue());\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2\").fieldType().names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.title\").fieldType().names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.author\").fieldType().names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.keywords\").fieldType().names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content_type\").fieldType().names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file2.content_length\").fieldType().names().indexName()).numericValue().longValue(), is(344L));\n    }","id":73924,"modified_method":"public void testMultipleDocsEncryptedNotIgnoringErrors() throws IOException {\n        try {\n            DocumentMapperParser mapperParser = MapperTestUtils.newMapperService(createTempDir(),\n                Settings.builder()\n                    .put(\"index.mapping.attachment.ignore_errors\", false)\n                    .build()).documentMapperParser();\n            mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n            String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n            DocumentMapper docMapper = mapperParser.parse(mapping);\n            byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n            byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n            BytesReference json = jsonBuilder()\n                .startObject()\n                .field(\"file1\", pdf)\n                .field(\"file2\", html)\n                .endObject().bytes();\n\n            docMapper.parse(\"person\", \"person\", \"1\", json);\n            fail(\"Expected doc parsing exception\");\n        } catch (MapperParsingException e) {\n            // TODO: check the error message...getting security problems atm\n            //assertTrue(e.getMessage(), e.getMessage().contains())\n        }\n    }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testMultipleDocsEncryptedLast() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(createTempDir());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                    .field(\"file1\", html)\n                    .field(\"file2\", pdf)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content\").fieldType().names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.title\").fieldType().names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.author\").fieldType().names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.keywords\").fieldType().names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content_type\").fieldType().names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file1.content_length\").fieldType().names().indexName()).numericValue().longValue(), is(344L));\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.title\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.author\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.keywords\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content_type\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file2.content_length\").fieldType().names().indexName()), nullValue());\n    }","id":73925,"modified_method":"public void testMultipleDocsEncryptedLast() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperService(createTempDir(), Settings.EMPTY).documentMapperParser();\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                    .field(\"file1\", html)\n                    .field(\"file2\", pdf)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content\").fieldType().names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.title\").fieldType().names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.author\").fieldType().names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.keywords\").fieldType().names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content_type\").fieldType().names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file1.content_length\").fieldType().names().indexName()).numericValue().longValue(), is(344L));\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.title\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.author\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.keywords\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content_type\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file2.content_length\").fieldType().names().indexName()), nullValue());\n    }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void setupMapperParser(boolean langDetect) throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(\n                Settings.settingsBuilder()\n                                  .put(\"path.home\", createTempDir())\n                                  .put(\"index.mapping.attachment.detect_language\", langDetect)\n                                 .build());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/language/language-mapping.json\");\n        docMapper = mapperParser.parse(mapping);\n\n        assertThat(docMapper.mappers().getMapper(\"file.language\"), instanceOf(StringFieldMapper.class));\n    }","id":73926,"modified_method":"public void setupMapperParser(boolean langDetect) throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperService(createTempDir(),\n            Settings.settingsBuilder()\n                .put(\"index.mapping.attachment.detect_language\", langDetect)\n            .build()).documentMapperParser();\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/language/language-mapping.json\");\n        docMapper = mapperParser.parse(mapping);\n\n        assertThat(docMapper.mappers().getMapper(\"file.language\"), instanceOf(StringFieldMapper.class));\n    }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * This test gives strange results! detection of \":-)\" gives \"lt\" as a result\n     * @throws Exception\n     */\n    @Test\n    public void testNoLanguage() throws Exception {\n        testLanguage(\"text-in-nolang.txt\", \"lt\");\n    }","id":73927,"modified_method":"/**\n     * This test gives strange results! detection of \":-)\" gives \"lt\" as a result\n     */\n    public void testNoLanguage() throws Exception {\n        testLanguage(\"text-in-nolang.txt\", \"lt\");\n    }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static MapperService newMapperService(Index index, Settings indexSettings) {\n        return new MapperService(index,\n                                 indexSettings, \n                                 newAnalysisService(indexSettings),\n                                 newSimilarityLookupService(indexSettings), \n                                 null);\n    }","id":73928,"modified_method":"public static MapperService newMapperService(Path tempDir, Settings indexSettings) throws IOException {\n        Settings nodeSettings = Settings.builder()\n            .put(\"path.home\", tempDir)\n            .build();\n        indexSettings = Settings.builder()\n            .put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n            .put(indexSettings)\n            .build();\n        IndexSettings idxSettings = IndexSettingsModule.newIndexSettings(new Index(\"test\"), indexSettings, Collections.emptyList());\n        AnalysisService analysisService = new AnalysisRegistry(null, new Environment(nodeSettings)).build(idxSettings);\n        SimilarityService similarityService = new SimilarityService(idxSettings, Collections.emptyMap());\n        return new MapperService(idxSettings, analysisService, similarityService);\n    }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test(expected = MapperParsingException.class)\n    public void testWithEmptyDate() throws Exception {\n        checkMeta(\"htmlWithEmptyDateMeta.html\", Settings.builder().put(\"index.mapping.attachment.ignore_errors\", false).build(), null, null);\n    }","id":73929,"modified_method":"public void testWithEmptyDate() throws Exception {\n        try {\n            checkMeta(\"htmlWithEmptyDateMeta.html\", Settings.builder().put(\"index.mapping.attachment.ignore_errors\", false).build(), null, null);\n        } catch (MapperParsingException e) {\n            throw e;\n        }\n    }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected void checkMeta(String filename, Settings otherSettings, Long expectedDate, Long expectedLength) throws IOException {\n        Settings settings = Settings.builder()\n                                             .put(this.testSettings)\n                                             .put(otherSettings)\n                                             .build();\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(settings);\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/metadata/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/\" + filename);\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                    .startObject(\"file\")\n                        .field(\"_name\", filename)\n                        .field(\"_content\", html)\n                    .endObject()\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content\").fieldType().names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.name\").fieldType().names().indexName()), equalTo(filename));\n        if (expectedDate == null) {\n            assertThat(doc.getField(docMapper.mappers().getMapper(\"file.date\").fieldType().names().indexName()), nullValue());\n        } else {\n            assertThat(doc.getField(docMapper.mappers().getMapper(\"file.date\").fieldType().names().indexName()).numericValue().longValue(), is(expectedDate));\n        }\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").fieldType().names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.author\").fieldType().names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.keywords\").fieldType().names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").fieldType().names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file.content_length\").fieldType().names().indexName()).numericValue().longValue(), is(expectedLength));\n    }","id":73930,"modified_method":"protected void checkMeta(String filename, Settings otherSettings, Long expectedDate, Long expectedLength) throws IOException {\n        Settings settings = Settings.builder()\n                                             .put(this.testSettings)\n                                             .put(otherSettings)\n                                             .build();\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperService(createTempDir(), settings).documentMapperParser();\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/metadata/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/\" + filename);\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                    .startObject(\"file\")\n                        .field(\"_name\", filename)\n                        .field(\"_content\", html)\n                    .endObject()\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content\").fieldType().names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.name\").fieldType().names().indexName()), equalTo(filename));\n        if (expectedDate == null) {\n            assertThat(doc.getField(docMapper.mappers().getMapper(\"file.date\").fieldType().names().indexName()), nullValue());\n        } else {\n            assertThat(doc.getField(docMapper.mappers().getMapper(\"file.date\").fieldType().names().indexName()).numericValue().longValue(), is(expectedDate));\n        }\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").fieldType().names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.author\").fieldType().names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.keywords\").fieldType().names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").fieldType().names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file.content_length\").fieldType().names().indexName()).numericValue().longValue(), is(expectedLength));\n    }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testExternalValues() throws Exception {\n        String originalText = \"This is an elasticsearch mapper attachment test.\";\n        String contentType = \"text/plain; charset=ISO-8859-1\";\n        String forcedName = \"dummyname.txt\";\n\n        String bytes = Base64.encodeBytes(originalText.getBytes(StandardCharsets.ISO_8859_1));\n        threadPool = new ThreadPool(\"testing-only\");\n\n        MapperService mapperService = MapperTestUtils.newMapperService(createTempDir());\n        mapperService.documentMapperParser().putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/multifield/multifield-mapping.json\");\n\n        DocumentMapper documentMapper = mapperService.documentMapperParser().parse(mapping);\n\n        ParsedDocument doc = documentMapper.parse(\"person\", \"person\", \"1\", XContentFactory.jsonBuilder()\n                .startObject()\n                    .field(\"file\", bytes)\n                .endObject()\n                .bytes());\n\n        assertThat(doc.rootDoc().getField(\"file.content\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content\").stringValue(), is(originalText + \"\\n\"));\n\n        assertThat(doc.rootDoc().getField(\"file.content_type\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content_type\").stringValue(), is(contentType));\n        assertThat(doc.rootDoc().getField(\"file.content_type.suggest\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content_type.suggest\").stringValue(), is(contentType));\n        assertThat(doc.rootDoc().getField(\"file.content_length\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content_length\").numericValue().intValue(), is(originalText.length()));\n\n        assertThat(doc.rootDoc().getField(\"file.content.suggest\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content.suggest\").stringValue(), is(originalText + \"\\n\"));\n\n        // Let's force some values\n        doc = documentMapper.parse(\"person\", \"person\", \"1\", XContentFactory.jsonBuilder()\n                .startObject()\n                    .startObject(\"file\")\n                        .field(\"_content\", bytes)\n                        .field(\"_name\", forcedName)\n                    .endObject()\n                .endObject()\n                .bytes());\n\n        assertThat(doc.rootDoc().getField(\"file.content\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content\").stringValue(), is(originalText + \"\\n\"));\n\n        assertThat(doc.rootDoc().getField(\"file.content_type\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content_type\").stringValue(), is(contentType));\n        assertThat(doc.rootDoc().getField(\"file.content_type.suggest\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content_type.suggest\").stringValue(), is(contentType));\n        assertThat(doc.rootDoc().getField(\"file.content_length\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content_length\").numericValue().intValue(), is(originalText.length()));\n\n        assertThat(doc.rootDoc().getField(\"file.content.suggest\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content.suggest\").stringValue(), is(originalText + \"\\n\"));\n\n        assertThat(doc.rootDoc().getField(\"file.name\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.name\").stringValue(), is(forcedName));\n        // In mapping we have default store:false\n        assertThat(doc.rootDoc().getField(\"file.name\").fieldType().stored(), is(false));\n        assertThat(doc.rootDoc().getField(\"file.name.suggest\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.name.suggest\").stringValue(), is(forcedName));\n        // In mapping we set store:true for suggest subfield\n        assertThat(doc.rootDoc().getField(\"file.name.suggest\").fieldType().stored(), is(true));\n    }","id":73931,"modified_method":"public void testExternalValues() throws Exception {\n        String originalText = \"This is an elasticsearch mapper attachment test.\";\n        String contentType = \"text/plain; charset=ISO-8859-1\";\n        String forcedName = \"dummyname.txt\";\n\n        String bytes = Base64.encodeBytes(originalText.getBytes(StandardCharsets.ISO_8859_1));\n        threadPool = new ThreadPool(\"testing-only\");\n\n        MapperService mapperService = MapperTestUtils.newMapperService(createTempDir(), Settings.EMPTY);\n        mapperService.documentMapperParser().putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/multifield/multifield-mapping.json\");\n\n        DocumentMapper documentMapper = mapperService.documentMapperParser().parse(mapping);\n\n        ParsedDocument doc = documentMapper.parse(\"person\", \"person\", \"1\", XContentFactory.jsonBuilder()\n                .startObject()\n                    .field(\"file\", bytes)\n                .endObject()\n                .bytes());\n\n        assertThat(doc.rootDoc().getField(\"file.content\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content\").stringValue(), is(originalText + \"\\n\"));\n\n        assertThat(doc.rootDoc().getField(\"file.content_type\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content_type\").stringValue(), is(contentType));\n        assertThat(doc.rootDoc().getField(\"file.content_type.suggest\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content_type.suggest\").stringValue(), is(contentType));\n        assertThat(doc.rootDoc().getField(\"file.content_length\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content_length\").numericValue().intValue(), is(originalText.length()));\n\n        assertThat(doc.rootDoc().getField(\"file.content.suggest\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content.suggest\").stringValue(), is(originalText + \"\\n\"));\n\n        // Let's force some values\n        doc = documentMapper.parse(\"person\", \"person\", \"1\", XContentFactory.jsonBuilder()\n                .startObject()\n                    .startObject(\"file\")\n                        .field(\"_content\", bytes)\n                        .field(\"_name\", forcedName)\n                    .endObject()\n                .endObject()\n                .bytes());\n\n        assertThat(doc.rootDoc().getField(\"file.content\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content\").stringValue(), is(originalText + \"\\n\"));\n\n        assertThat(doc.rootDoc().getField(\"file.content_type\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content_type\").stringValue(), is(contentType));\n        assertThat(doc.rootDoc().getField(\"file.content_type.suggest\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content_type.suggest\").stringValue(), is(contentType));\n        assertThat(doc.rootDoc().getField(\"file.content_length\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content_length\").numericValue().intValue(), is(originalText.length()));\n\n        assertThat(doc.rootDoc().getField(\"file.content.suggest\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.content.suggest\").stringValue(), is(originalText + \"\\n\"));\n\n        assertThat(doc.rootDoc().getField(\"file.name\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.name\").stringValue(), is(forcedName));\n        // In mapping we have default store:false\n        assertThat(doc.rootDoc().getField(\"file.name\").fieldType().stored(), is(false));\n        assertThat(doc.rootDoc().getField(\"file.name.suggest\"), notNullValue());\n        assertThat(doc.rootDoc().getField(\"file.name.suggest\").stringValue(), is(forcedName));\n        // In mapping we set store:true for suggest subfield\n        assertThat(doc.rootDoc().getField(\"file.name.suggest\").fieldType().stored(), is(true));\n    }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Before\n    public void setupMapperParser() {\n        mapperParser = MapperTestUtils.newMapperParser(createTempDir());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n    }","id":73932,"modified_method":"@Before\n    public void setupMapperParser() throws Exception {\n        mapperParser = MapperTestUtils.newMapperService(createTempDir(), Settings.EMPTY).documentMapperParser();\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n    }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testSimpleMappings() throws Exception {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(createTempDir());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/simple/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/testXHTML.html\");\n\n        BytesReference json = jsonBuilder().startObject().field(\"file\", html).endObject().bytes();\n        ParseContext.Document doc = docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").fieldType().names().indexName()), startsWith(\"application/xhtml+xml\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").fieldType().names().indexName()), equalTo(\"XHTML test document\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content\").fieldType().names().indexName()), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n\n        // re-parse it\n        String builtMapping = docMapper.mappingSource().string();\n        docMapper = mapperParser.parse(builtMapping);\n\n        json = jsonBuilder().startObject().field(\"file\", html).endObject().bytes();\n\n        doc = docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").fieldType().names().indexName()), startsWith(\"application/xhtml+xml\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").fieldType().names().indexName()), equalTo(\"XHTML test document\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content\").fieldType().names().indexName()), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n    }","id":73933,"modified_method":"public void testSimpleMappings() throws Exception {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperService(createTempDir(), Settings.EMPTY).documentMapperParser();\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/simple/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/testXHTML.html\");\n\n        BytesReference json = jsonBuilder().startObject().field(\"file\", html).endObject().bytes();\n        ParseContext.Document doc = docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").fieldType().names().indexName()), startsWith(\"application/xhtml+xml\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").fieldType().names().indexName()), equalTo(\"XHTML test document\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content\").fieldType().names().indexName()), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n\n        // re-parse it\n        String builtMapping = docMapper.mappingSource().string();\n        docMapper = mapperParser.parse(builtMapping);\n\n        json = jsonBuilder().startObject().field(\"file\", html).endObject().bytes();\n\n        doc = docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").fieldType().names().indexName()), startsWith(\"application/xhtml+xml\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").fieldType().names().indexName()), equalTo(\"XHTML test document\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content\").fieldType().names().indexName()), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n    }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testContentBackcompat() throws Exception {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(Settings.builder()\n            .put(\"path.home\", createTempDir())\n            .put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_1_4_2.id)\n            .build());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/simple/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/testXHTML.html\");\n\n        BytesReference json = jsonBuilder().startObject().field(\"file\", html).endObject().bytes();\n\n        ParseContext.Document doc = docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(\"file\"), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n    }","id":73934,"modified_method":"public void testContentBackcompat() throws Exception {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperService(createTempDir(),\n            Settings.builder()\n                .put(IndexMetaData.SETTING_VERSION_CREATED, Version.V_1_4_2.id)\n            .build()).documentMapperParser();\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/simple/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/testXHTML.html\");\n\n        BytesReference json = jsonBuilder().startObject().field(\"file\", html).endObject().bytes();\n\n        ParseContext.Document doc = docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(\"file\"), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n    }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * test for https://github.com/elastic/elasticsearch-mapper-attachments/issues/179\n     * @throws Exception\n     */\n    public void testSimpleMappingsWithAllFields() throws Exception {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(createTempDir());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/simple/test-mapping-all-fields.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/testXHTML.html\");\n\n        BytesReference json = jsonBuilder().startObject().field(\"file\", html).endObject().bytes();\n        ParseContext.Document doc = docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").fieldType().names().indexName()), startsWith(\"application/xhtml+xml\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").fieldType().names().indexName()), equalTo(\"XHTML test document\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content\").fieldType().names().indexName()), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n\n        // re-parse it\n        String builtMapping = docMapper.mappingSource().string();\n        docMapper = mapperParser.parse(builtMapping);\n\n        json = jsonBuilder().startObject().field(\"file\", html).endObject().bytes();\n\n        doc = docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").fieldType().names().indexName()), startsWith(\"application/xhtml+xml\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").fieldType().names().indexName()), equalTo(\"XHTML test document\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content\").fieldType().names().indexName()), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n    }","id":73935,"modified_method":"/**\n     * test for https://github.com/elastic/elasticsearch-mapper-attachments/issues/179\n     */\n    public void testSimpleMappingsWithAllFields() throws Exception {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperService(createTempDir(), Settings.EMPTY).documentMapperParser();\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/simple/test-mapping-all-fields.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/testXHTML.html\");\n\n        BytesReference json = jsonBuilder().startObject().field(\"file\", html).endObject().bytes();\n        ParseContext.Document doc = docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").fieldType().names().indexName()), startsWith(\"application/xhtml+xml\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").fieldType().names().indexName()), equalTo(\"XHTML test document\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content\").fieldType().names().indexName()), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n\n        // re-parse it\n        String builtMapping = docMapper.mappingSource().string();\n        docMapper = mapperParser.parse(builtMapping);\n\n        json = jsonBuilder().startObject().field(\"file\", html).endObject().bytes();\n\n        doc = docMapper.parse(\"person\", \"person\", \"1\", json).rootDoc();\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").fieldType().names().indexName()), startsWith(\"application/xhtml+xml\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").fieldType().names().indexName()), equalTo(\"XHTML test document\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content\").fieldType().names().indexName()), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n    }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected TikaRunner(Terminal terminal, String url, Integer size, String base64text) throws IOException {\n            super(terminal);\n            this.size = size;\n            this.url = url;\n            this.base64text = base64text;\n            DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(PathUtils.get(\".\")); // use CWD b/c it won't be used\n            mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n            String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/standalone/standalone-mapping.json\");\n            docMapper = mapperParser.parse(mapping);\n        }","id":73936,"modified_method":"protected TikaRunner(Terminal terminal, String url, Integer size, String base64text) throws IOException {\n            super(terminal);\n            this.size = size;\n            this.url = url;\n            this.base64text = base64text;\n            DocumentMapperParser mapperParser = MapperTestUtils.newMapperService(PathUtils.get(\".\"), Settings.EMPTY).documentMapperParser(); // use CWD b/c it won't be used\n            mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n            String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/standalone/standalone-mapping.json\");\n            docMapper = mapperParser.parse(mapping);\n        }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Before\n    public void createMapper() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(createTempDir());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/various-doc/test-mapping.json\");\n        docMapper = mapperParser.parse(mapping);\n    }","id":73937,"modified_method":"@Before\n    public void createMapper() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperService(createTempDir(), Settings.EMPTY).documentMapperParser();\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/various-doc/test-mapping.json\");\n        docMapper = mapperParser.parse(mapping);\n    }","commit_id":"867f496ac8f3835e553465a3fc4d8d97387b2775","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected void initializeLiferayRequest(HttpServletRequest request)\n\t\tthrows Exception {\n\n\t\t// Company\n\n\t\tCompany company = PortalUtil.getCompany(request);\n\n\t\tString imagePath = PortalUtil.getPathImage();\n\n\t\t// Company logo\n\n\t\tString companyLogo =\n\t\t\timagePath + \"/company_logo?img_id=\" + company.getLogoId() + \"&t=\" +\n\t\t\t\tImageServletTokenUtil.getToken(company.getLogoId());\n\n\t\t// Locale\n\n\t\tLocale locale = request.getLocale();\n\n\t\t// Manually create a ThemeDisplay object. Do not use the factory unless\n\t\t// you manually recycle the object or else there will be a memory leak.\n\n\t\t//ThemeDisplay themeDisplay = ThemeDisplayFactory.create();\n\t\tThemeDisplay themeDisplay = new ThemeDisplay();\n\n\t\tthemeDisplay.setCompany(company);\n\t\tthemeDisplay.setCompanyLogo(companyLogo);\n\t\tthemeDisplay.setUser(themeDisplay.getDefaultUser());\n\t\tthemeDisplay.setLocale(locale);\n\t\tthemeDisplay.setLanguageId(LocaleUtil.toLanguageId(locale));\n\t\tthemeDisplay.setSecure(request.isSecure());\n\n\t\tGroup guestGroup = GroupLocalServiceUtil.getGroup(\n\t\t\tPortalInstances.getCompanyId(request), GroupConstants.GUEST);\n\n\t\tList<Layout> layouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\tguestGroup.getGroupId(), false,\n\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\tLayout layout = null;\n\n\t\tif (layouts.size() > 0) {\n\t\t\tlayout = layouts.get(0);\n\t\t}\n\n\t\tthemeDisplay.setPathImage(imagePath);\n\t\tthemeDisplay.setLayout(layout);\n\t\tthemeDisplay.setScopeGroupId(layout.getGroupId());\n\n\t\tPermissionChecker permissionChecker = (PermissionChecker)Class.forName(\n\t\t\tPropsValues.PERMISSIONS_CHECKER).newInstance();\n\n\t\tpermissionChecker.init(themeDisplay.getUser(), true);\n\n\t\tthemeDisplay.setPermissionChecker(permissionChecker);\n\n\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\tlong companyId = PortalInstances.getCompanyId(request);\n\n\t\tCompanyThreadLocal.setCompanyId(companyId);\n\n\t\tlong userId = themeDisplay.getUserId();\n\n\t\tPrincipalThreadLocal.setName(String.valueOf(userId));\n\n\t\trequest.setAttribute(WebKeys.CTX, ProducerThreadLocalizer.getContext());\n\t\trequest.setAttribute(WebKeys.LAYOUT, layout);\n\t\trequest.setAttribute(WebKeys.THEME_DISPLAY, themeDisplay);\n\t}","id":73938,"modified_method":"protected void initializeLiferayRequest(HttpServletRequest request)\n\t\tthrows Exception {\n\n\t\t// Company\n\n\t\tCompany company = PortalUtil.getCompany(request);\n\n\t\tCompanyThreadLocal.setCompanyId(company.getCompanyId());\n\n\t\t// Paths\n\n\t\tString imagePath = PortalUtil.getPathImage();\n\n\t\t// Company logo\n\n\t\tString companyLogo =\n\t\t\timagePath + \"/company_logo?img_id=\" + company.getLogoId() + \"&t=\" +\n\t\t\t\tImageServletTokenUtil.getToken(company.getLogoId());\n\n\t\t// User\n\n\t\tUser user = UserLocalServiceUtil.getDefaultUser(company.getCompanyId());\n\n\t\tPrincipalThreadLocal.setName(String.valueOf(user.getUserId()));\n\n\t\t// Permission checker\n\n\t\tPermissionChecker permissionChecker = (PermissionChecker)Class.forName(\n\t\t\tPropsValues.PERMISSIONS_CHECKER).newInstance();\n\n\t\tpermissionChecker.init(user, true);\n\n\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t// Locale\n\n\t\tLocale locale = request.getLocale();\n\n\t\t// Layouts\n\n\t\tGroup guestGroup = GroupLocalServiceUtil.getGroup(\n\t\t\tPortalInstances.getCompanyId(request), GroupConstants.GUEST);\n\n\t\tList<Layout> layouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\tguestGroup.getGroupId(), false,\n\t\t\tLayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\n\t\tLayout layout = null;\n\n\t\tif (layouts.size() > 0) {\n\t\t\tlayout = layouts.get(0);\n\t\t}\n\n\t\t// Manually create a ThemeDisplay object. Do not use the factory unless\n\t\t// you manually recycle the object or else there will be a memory leak.\n\n\t\t//ThemeDisplay themeDisplay = ThemeDisplayFactory.create();\n\t\tThemeDisplay themeDisplay = new ThemeDisplay();\n\n\t\tthemeDisplay.setCompany(company);\n\t\tthemeDisplay.setCompanyLogo(companyLogo);\n\t\tthemeDisplay.setUser(user);\n\t\tthemeDisplay.setLayout(layout);\n\t\tthemeDisplay.setScopeGroupId(layout.getGroupId());\n\t\tthemeDisplay.setPermissionChecker(permissionChecker);\n\t\tthemeDisplay.setLocale(locale);\n\t\tthemeDisplay.setLanguageId(LocaleUtil.toLanguageId(locale));\n\t\tthemeDisplay.setSecure(request.isSecure());\n\t\tthemeDisplay.setPathImage(imagePath);\n\n\t\trequest.setAttribute(WebKeys.CTX, ProducerThreadLocalizer.getContext());\n\t\trequest.setAttribute(WebKeys.LAYOUT, layout);\n\t\trequest.setAttribute(WebKeys.THEME_DISPLAY, themeDisplay);\n\t}","commit_id":"213ef75575bc725e68b12038d9d101c56508209c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void collectAll(\n\t\tHttpServletRequest request, String pathParameters,\n\t\tJSONRPCRequest jsonRpcRequest) {\n\n\t\t_jsonRpcRequest = jsonRpcRequest;\n\n\t\t_collectFromRequestAttributes(request);\n\t\t_collectFromPath(pathParameters);\n\t\t_collectFromRequestParameters(request);\n\t\t_collectFromJSONRPCRequest(jsonRpcRequest);\n\t}","id":73939,"modified_method":"public void collectAll(\n\t\tHttpServletRequest request, String pathParameters,\n\t\tJSONRPCRequest jsonRpcRequest) {\n\n\t\t_jsonRpcRequest = jsonRpcRequest;\n\n\t\t_collectFromPath(pathParameters);\n\t\t_collectFromRequestAttributes(request);\n\t\t_collectFromRequestParameters(request);\n\t\t_collectFromJSONRPCRequest(jsonRpcRequest);\n\t}","commit_id":"597821b1fc6455fbc23da6451e356b9dfad12fc2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _collectFromRequestAttributes(HttpServletRequest request) {\n\t\tEnumeration<String> attributeNames = request.getAttributeNames();\n\n\t\twhile (attributeNames.hasMoreElements()) {\n\t\t\tString attributeName = attributeNames.nextElement();\n\n\t\t\tObject value = request.getAttribute(attributeName);\n\n\t\t\t_parameters.put(attributeName, value);\n\t\t}\n\n\t}","id":73940,"modified_method":"private void _collectFromRequestAttributes(HttpServletRequest request) {\n\t\tEnumeration<String> enu = request.getAttributeNames();\n\n\t\twhile (enu.hasMoreElements()) {\n\t\t\tString attributeName = enu.nextElement();\n\n\t\t\tObject value = request.getAttribute(attributeName);\n\n\t\t\t_parameters.put(attributeName, value);\n\t\t}\n\t}","commit_id":"597821b1fc6455fbc23da6451e356b9dfad12fc2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void resolveRemoteUser(HttpServletRequest request)\n\t\tthrows Exception {\n\n\t\tUserCompanyResolver userCompanyResolver =\n\t\t\tnew UserCompanyResolver(request);\n\n\t\tUser user = userCompanyResolver.getUser();\n\n\t\tlong companyId = userCompanyResolver.getCompanyId();\n\n\t\tif (user != null) {\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionCheckerFactoryUtil.create(user, true);\n\n\t\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t\trequest.setAttribute(\"userId\", user.getUserId());\n\t\t\trequest.setAttribute(\"user\", user);\n\t\t}\n\n\t\tCompanyThreadLocal.setCompanyId(companyId);\n\n\t\trequest.setAttribute(\"companyId\", companyId);\n\t}","id":73941,"modified_method":"protected void resolveRemoteUser(HttpServletRequest request)\n\t\tthrows Exception {\n\n\t\tUserResolver userResolver = new UserResolver(request);\n\n\t\tCompanyThreadLocal.setCompanyId(userResolver.getCompanyId());\n\n\t\trequest.setAttribute(\"companyId\", userResolver.getCompanyId());\n\n\t\tUser user = userResolver.getUser();\n\n\t\tif (user != null) {\n\t\t\tPermissionChecker permissionChecker =\n\t\t\t\tPermissionCheckerFactoryUtil.create(user, true);\n\n\t\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t\trequest.setAttribute(\"user\", user);\n\t\t\trequest.setAttribute(\"userId\", user.getUserId());\n\t\t}\n\t}","commit_id":"597821b1fc6455fbc23da6451e356b9dfad12fc2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void service(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows ServletException {\n\n\t\ttry {\n\t\t\tUserCompanyResolver userCompanyResolver =\n\t\t\t\tnew UserCompanyResolver(request);\n\n\t\t\tUser user = userCompanyResolver.getUser();\n\n\t\t\tif (user != null) {\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"User \" + user.getUserId());\n\t\t\t\t}\n\n\t\t\t\tPermissionChecker permissionChecker =\n\t\t\t\t\tPermissionCheckerFactoryUtil.create(user, true);\n\n\t\t\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t\t\tAtomUtil.saveUserInRequest(request, user);\n\t\t\t}\n\n\t\t\tlong companyId = userCompanyResolver.getCompanyId();\n\n\t\t\tCompanyThreadLocal.setCompanyId(companyId);\n\n\t\t\tsuper.service(request, response);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ServletException(e);\n\t\t}\n\t}","id":73942,"modified_method":"protected void service(\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows ServletException {\n\n\t\ttry {\n\t\t\tUserResolver userResolver = new UserResolver(request);\n\n\t\t\tCompanyThreadLocal.setCompanyId(userResolver.getCompanyId());\n\n\t\t\tUser user = userResolver.getUser();\n\n\t\t\tif (user != null) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"User \" + user.getUserId());\n\t\t\t\t}\n\n\t\t\t\tPermissionChecker permissionChecker =\n\t\t\t\t\tPermissionCheckerFactoryUtil.create(user, true);\n\n\t\t\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\n\t\t\t\tAtomUtil.saveUserInRequest(request, user);\n\t\t\t}\n\n\t\t\tsuper.service(request, response);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ServletException(e);\n\t\t}\n\t}","commit_id":"7d66a085a51701b57a6f55e92577016bfc8183c4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importEvent(PortletDataContext context, CalEvent event)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(event.getUserUuid());\n\n\t\tDate startDate = event.getStartDate();\n\n\t\tint startDateMonth = 0;\n\t\tint startDateDay = 0;\n\t\tint startDateYear = 0;\n\t\tint startDateHour = 0;\n\t\tint startDateMinute = 0;\n\n\t\tif (startDate != null) {\n\t\t\tCalendar startCal = CalendarFactoryUtil.getCalendar();\n\n\t\t\tstartCal.setTime(startDate);\n\n\t\t\tstartDateMonth = startCal.get(Calendar.MONTH);\n\t\t\tstartDateDay = startCal.get(Calendar.DATE);\n\t\t\tstartDateYear = startCal.get(Calendar.YEAR);\n\t\t\tstartDateHour = startCal.get(Calendar.HOUR);\n\t\t\tstartDateMinute = startCal.get(Calendar.MINUTE);\n\n\t\t\tif (startCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\tstartDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tDate endDate = event.getEndDate();\n\n\t\tint endDateMonth = 0;\n\t\tint endDateDay = 0;\n\t\tint endDateYear = 0;\n\n\t\tif (endDate != null) {\n\t\t\tCalendar endCal = CalendarFactoryUtil.getCalendar();\n\n\t\t\tendCal.setTime(endDate);\n\n\t\t\tendDateMonth = endCal.get(Calendar.MONTH);\n\t\t\tendDateDay = endCal.get(Calendar.DATE);\n\t\t\tendDateYear = endCal.get(Calendar.YEAR);\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setScopeGroupId(context.getGroupId());\n\n\t\tCalEvent existingEvent = null;\n\n\t\tif (context.getDataStrategy().equals(\n\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\texistingEvent = CalEventUtil.fetchByUUID_G(\n\t\t\t\tevent.getUuid(), context.getGroupId());\n\n\t\t\tif (existingEvent == null) {\n\t\t\t\texistingEvent = CalEventLocalServiceUtil.addEvent(\n\t\t\t\t\tevent.getUuid(), userId, event.getTitle(),\n\t\t\t\t\tevent.getDescription(), startDateMonth, startDateDay,\n\t\t\t\t\tstartDateYear, startDateHour, startDateMinute, endDateMonth,\n\t\t\t\t\tendDateDay, endDateYear, event.getDurationHour(),\n\t\t\t\t\tevent.getDurationMinute(), event.getAllDay(),\n\t\t\t\t\tevent.getTimeZoneSensitive(), event.getType(),\n\t\t\t\t\tevent.getRepeating(), event.getRecurrenceObj(),\n\t\t\t\t\tevent.getRemindBy(), event.getFirstReminder(),\n\t\t\t\t\tevent.getSecondReminder(), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingEvent = CalEventLocalServiceUtil.updateEvent(\n\t\t\t\t\tuserId, existingEvent.getEventId(), event.getTitle(),\n\t\t\t\t\tevent.getDescription(), startDateMonth, startDateDay,\n\t\t\t\t\tstartDateYear, startDateHour, startDateMinute, endDateMonth,\n\t\t\t\t\tendDateDay, endDateYear, event.getDurationHour(),\n\t\t\t\t\tevent.getDurationMinute(), event.getAllDay(),\n\t\t\t\t\tevent.getTimeZoneSensitive(), event.getType(),\n\t\t\t\t\tevent.getRepeating(), event.getRecurrenceObj(),\n\t\t\t\t\tevent.getRemindBy(), event.getFirstReminder(),\n\t\t\t\t\tevent.getSecondReminder(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\texistingEvent = CalEventLocalServiceUtil.addEvent(\n\t\t\t\tnull, userId, event.getTitle(), event.getDescription(),\n\t\t\t\tstartDateMonth, startDateDay, startDateYear, startDateHour,\n\t\t\t\tstartDateMinute, endDateMonth, endDateDay, endDateYear,\n\t\t\t\tevent.getDurationHour(), event.getDurationMinute(),\n\t\t\t\tevent.getAllDay(), event.getTimeZoneSensitive(),\n\t\t\t\tevent.getType(), event.getRepeating(), event.getRecurrenceObj(),\n\t\t\t\tevent.getRemindBy(), event.getFirstReminder(),\n\t\t\t\tevent.getSecondReminder(), serviceContext);\n\t\t}\n\n\t\tcontext.importPermissions(\n\t\t\tCalEvent.class, event.getEventId(), existingEvent.getEventId());\n\t}","id":73943,"modified_method":"protected void importEvent(PortletDataContext context, CalEvent event)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(event.getUserUuid());\n\n\t\tDate startDate = event.getStartDate();\n\n\t\tint startDateMonth = 0;\n\t\tint startDateDay = 0;\n\t\tint startDateYear = 0;\n\t\tint startDateHour = 0;\n\t\tint startDateMinute = 0;\n\n\t\tif (startDate != null) {\n\t\t\tCalendar startCal = CalendarFactoryUtil.getCalendar();\n\n\t\t\tstartCal.setTime(startDate);\n\n\t\t\tstartDateMonth = startCal.get(Calendar.MONTH);\n\t\t\tstartDateDay = startCal.get(Calendar.DATE);\n\t\t\tstartDateYear = startCal.get(Calendar.YEAR);\n\t\t\tstartDateHour = startCal.get(Calendar.HOUR);\n\t\t\tstartDateMinute = startCal.get(Calendar.MINUTE);\n\n\t\t\tif (startCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\tstartDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tDate endDate = event.getEndDate();\n\n\t\tint endDateMonth = 0;\n\t\tint endDateDay = 0;\n\t\tint endDateYear = 0;\n\n\t\tif (endDate != null) {\n\t\t\tCalendar endCal = CalendarFactoryUtil.getCalendar();\n\n\t\t\tendCal.setTime(endDate);\n\n\t\t\tendDateMonth = endCal.get(Calendar.MONTH);\n\t\t\tendDateDay = endCal.get(Calendar.DATE);\n\t\t\tendDateYear = endCal.get(Calendar.YEAR);\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setScopeGroupId(context.getGroupId());\n\n\t\tCalEvent importedEvent = null;\n\n\t\tif (context.getDataStrategy().equals(\n\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\tCalEvent existingEvent = CalEventUtil.fetchByUUID_G(\n\t\t\t\tevent.getUuid(), context.getGroupId());\n\n\t\t\tif (existingEvent == null) {\n\t\t\t\timportedEvent = CalEventLocalServiceUtil.addEvent(\n\t\t\t\t\tevent.getUuid(), userId, event.getTitle(),\n\t\t\t\t\tevent.getDescription(), startDateMonth, startDateDay,\n\t\t\t\t\tstartDateYear, startDateHour, startDateMinute, endDateMonth,\n\t\t\t\t\tendDateDay, endDateYear, event.getDurationHour(),\n\t\t\t\t\tevent.getDurationMinute(), event.getAllDay(),\n\t\t\t\t\tevent.getTimeZoneSensitive(), event.getType(),\n\t\t\t\t\tevent.getRepeating(), event.getRecurrenceObj(),\n\t\t\t\t\tevent.getRemindBy(), event.getFirstReminder(),\n\t\t\t\t\tevent.getSecondReminder(), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedEvent = CalEventLocalServiceUtil.updateEvent(\n\t\t\t\t\tuserId, existingEvent.getEventId(), event.getTitle(),\n\t\t\t\t\tevent.getDescription(), startDateMonth, startDateDay,\n\t\t\t\t\tstartDateYear, startDateHour, startDateMinute, endDateMonth,\n\t\t\t\t\tendDateDay, endDateYear, event.getDurationHour(),\n\t\t\t\t\tevent.getDurationMinute(), event.getAllDay(),\n\t\t\t\t\tevent.getTimeZoneSensitive(), event.getType(),\n\t\t\t\t\tevent.getRepeating(), event.getRecurrenceObj(),\n\t\t\t\t\tevent.getRemindBy(), event.getFirstReminder(),\n\t\t\t\t\tevent.getSecondReminder(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedEvent = CalEventLocalServiceUtil.addEvent(\n\t\t\t\tnull, userId, event.getTitle(), event.getDescription(),\n\t\t\t\tstartDateMonth, startDateDay, startDateYear, startDateHour,\n\t\t\t\tstartDateMinute, endDateMonth, endDateDay, endDateYear,\n\t\t\t\tevent.getDurationHour(), event.getDurationMinute(),\n\t\t\t\tevent.getAllDay(), event.getTimeZoneSensitive(),\n\t\t\t\tevent.getType(), event.getRepeating(), event.getRecurrenceObj(),\n\t\t\t\tevent.getRemindBy(), event.getFirstReminder(),\n\t\t\t\tevent.getSecondReminder(), serviceContext);\n\t\t}\n\n\t\tcontext.importPermissions(\n\t\t\tCalEvent.class, event.getEventId(), importedEvent.getEventId());\n\t}","commit_id":"e59c469b4926cd242b9306a90591726ae121c670","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static void importFileShortcut(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tMap<String, String> fileEntryNames, DLFileShortcut fileShortcut)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(fileShortcut.getUserUuid());\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, fileShortcut.getFolderId(), fileShortcut.getFolderId());\n\t\tlong toFolderId = MapUtil.getLong(\n\t\t\tfolderPKs, fileShortcut.getToFolderId(),\n\t\t\tfileShortcut.getToFolderId());\n\t\tString toName = MapUtil.getString(\n\t\t\tfileEntryNames, fileShortcut.getToName(), fileShortcut.getToName());\n\n\t\ttry {\n\t\t\tDLFolder folder = DLFolderUtil.findByPrimaryKey(folderId);\n\t\t\tDLFolderUtil.findByPrimaryKey(toFolderId);\n\n\t\t\tlong groupId = folder.getGroupId();\n\n\t\t\tDLFileEntry fileEntry = DLFileEntryLocalServiceUtil.getFileEntry(\n\t\t\t\tgroupId, toFolderId, toName);\n\n\t\t\tlong[] assetCategoryIds = null;\n\t\t\tString[] assetTagNames = null;\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\t\tassetCategoryIds = context.getAssetCategoryIds(\n\t\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\t\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\t\tserviceContext.setCreateDate(fileShortcut.getCreateDate());\n\t\t\tserviceContext.setModifiedDate(fileShortcut.getModifiedDate());\n\t\t\tserviceContext.setScopeGroupId(context.getGroupId());\n\n\t\t\tDLFileShortcut existingFileShortcut = null;\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\ttry {\n\t\t\t\t\texistingFileShortcut = DLFileShortcutUtil.findByUUID_G(\n\t\t\t\t\t\tfileShortcut.getUuid(), context.getGroupId());\n\n\t\t\t\t\texistingFileShortcut =\n\t\t\t\t\t\tDLFileShortcutLocalServiceUtil.updateFileShortcut(\n\t\t\t\t\t\t\tuserId, existingFileShortcut.getFileShortcutId(),\n\t\t\t\t\t\t\tfolderId, toFolderId, toName, serviceContext);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFileShortcutException nsfse) {\n\t\t\t\t\texistingFileShortcut =\n\t\t\t\t\t\tDLFileShortcutLocalServiceUtil.addFileShortcut(\n\t\t\t\t\t\t\tfileShortcut.getUuid(), userId, groupId, folderId,\n\t\t\t\t\t\t\ttoFolderId, toName, serviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingFileShortcut =\n\t\t\t\t\tDLFileShortcutLocalServiceUtil.addFileShortcut(\n\t\t\t\t\t\tnull, userId, groupId, folderId, toFolderId, toName,\n\t\t\t\t\t\tserviceContext);\n\t\t\t}\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tDLFileShortcut.class, fileShortcut.getPrimaryKey(),\n\t\t\t\texistingFileShortcut.getPrimaryKey());\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the folder for shortcut \" +\n\t\t\t\t\tfileShortcut.getFileShortcutId());\n\t\t}\n\t}","id":73944,"modified_method":"protected static void importFileShortcut(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tMap<String, String> fileEntryNames, DLFileShortcut fileShortcut)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(fileShortcut.getUserUuid());\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, fileShortcut.getFolderId(), fileShortcut.getFolderId());\n\t\tlong toFolderId = MapUtil.getLong(\n\t\t\tfolderPKs, fileShortcut.getToFolderId(),\n\t\t\tfileShortcut.getToFolderId());\n\t\tString toName = MapUtil.getString(\n\t\t\tfileEntryNames, fileShortcut.getToName(), fileShortcut.getToName());\n\n\t\ttry {\n\t\t\tDLFolder folder = DLFolderUtil.findByPrimaryKey(folderId);\n\t\t\tDLFolderUtil.findByPrimaryKey(toFolderId);\n\n\t\t\tlong groupId = folder.getGroupId();\n\n\t\t\tDLFileEntry fileEntry = DLFileEntryLocalServiceUtil.getFileEntry(\n\t\t\t\tgroupId, toFolderId, toName);\n\n\t\t\tlong[] assetCategoryIds = null;\n\t\t\tString[] assetTagNames = null;\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\t\tassetCategoryIds = context.getAssetCategoryIds(\n\t\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setAddCommunityPermissions(true);\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\t\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\t\tserviceContext.setCreateDate(fileShortcut.getCreateDate());\n\t\t\tserviceContext.setModifiedDate(fileShortcut.getModifiedDate());\n\t\t\tserviceContext.setScopeGroupId(context.getGroupId());\n\n\t\t\tDLFileShortcut importedFileShortcut = null;\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\tDLFileShortcut existingFileShortcut =\n\t\t\t\t\tDLFileShortcutUtil.fetchByUUID_G(\n\t\t\t\t\t\tfileShortcut.getUuid(), context.getGroupId());\n\n\t\t\t\tif (existingFileShortcut == null) {\n\t\t\t\t\timportedFileShortcut =\n\t\t\t\t\t\tDLFileShortcutLocalServiceUtil.addFileShortcut(\n\t\t\t\t\t\t\tfileShortcut.getUuid(), userId, groupId, folderId,\n\t\t\t\t\t\t\ttoFolderId, toName, serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportedFileShortcut =\n\t\t\t\t\t\tDLFileShortcutLocalServiceUtil.updateFileShortcut(\n\t\t\t\t\t\t\tuserId, existingFileShortcut.getFileShortcutId(),\n\t\t\t\t\t\t\tfolderId, toFolderId, toName, serviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedFileShortcut =\n\t\t\t\t\tDLFileShortcutLocalServiceUtil.addFileShortcut(\n\t\t\t\t\t\tnull, userId, groupId, folderId, toFolderId, toName,\n\t\t\t\t\t\tserviceContext);\n\t\t\t}\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tDLFileShortcut.class, fileShortcut.getPrimaryKey(),\n\t\t\t\timportedFileShortcut.getPrimaryKey());\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the folder for shortcut \" +\n\t\t\t\t\tfileShortcut.getFileShortcutId());\n\t\t}\n\t}","commit_id":"e59c469b4926cd242b9306a90591726ae121c670","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void importFolder(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tDLFolder folder)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(folder.getUserUuid());\n\t\tlong groupId = context.getGroupId();\n\t\tlong parentFolderId = MapUtil.getLong(\n\t\t\tfolderPKs, folder.getParentFolderId(), folder.getParentFolderId());\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setCreateDate(folder.getCreateDate());\n\t\tserviceContext.setModifiedDate(folder.getModifiedDate());\n\n\t\tif ((parentFolderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(parentFolderId == folder.getParentFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, parentFolderId);\n\n\t\t\tDLFolder parentFolder = (DLFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, parentFolder);\n\n\t\t\tparentFolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, folder.getParentFolderId(),\n\t\t\t\tfolder.getParentFolderId());\n\t\t}\n\n\t\tDLFolder existingFolder = null;\n\n\t\ttry {\n\t\t\tif (parentFolderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t\tDLFolderUtil.findByPrimaryKey(parentFolderId);\n\t\t\t}\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\texistingFolder = DLFolderUtil.fetchByUUID_G(\n\t\t\t\t\tfolder.getUuid(), groupId);\n\n\t\t\t\tif (existingFolder == null) {\n\t\t\t\t\tString name = getFolderName(\n\t\t\t\t\t\tcontext.getCompanyId(), groupId, parentFolderId,\n\t\t\t\t\t\tfolder.getName(), 2);\n\n\t\t\t\t\texistingFolder = DLFolderLocalServiceUtil.addFolder(\n\t\t\t\t\t\tfolder.getUuid(), userId, groupId, parentFolderId,\n\t\t\t\t\t\tname, folder.getDescription(), serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texistingFolder = DLFolderLocalServiceUtil.updateFolder(\n\t\t\t\t\t\texistingFolder.getFolderId(), parentFolderId,\n\t\t\t\t\t\tfolder.getName(), folder.getDescription(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString name = getFolderName(\n\t\t\t\t\tcontext.getCompanyId(), groupId, parentFolderId,\n\t\t\t\t\tfolder.getName(), 2);\n\n\t\t\t\texistingFolder = DLFolderLocalServiceUtil.addFolder(\n\t\t\t\t\tnull, userId, groupId, parentFolderId, name,\n\t\t\t\t\tfolder.getDescription(), serviceContext);\n\t\t\t}\n\n\t\t\tfolderPKs.put(folder.getFolderId(), existingFolder.getFolderId());\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tDLFolder.class, folder.getFolderId(),\n\t\t\t\texistingFolder.getFolderId());\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for folder \" +\n\t\t\t\t\tfolder.getFolderId());\n\t\t}\n\t}","id":73945,"modified_method":"public static void importFolder(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tDLFolder folder)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(folder.getUserUuid());\n\t\tlong groupId = context.getGroupId();\n\t\tlong parentFolderId = MapUtil.getLong(\n\t\t\tfolderPKs, folder.getParentFolderId(), folder.getParentFolderId());\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setCreateDate(folder.getCreateDate());\n\t\tserviceContext.setModifiedDate(folder.getModifiedDate());\n\n\t\tif ((parentFolderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(parentFolderId == folder.getParentFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, parentFolderId);\n\n\t\t\tDLFolder parentFolder = (DLFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, parentFolder);\n\n\t\t\tparentFolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, folder.getParentFolderId(),\n\t\t\t\tfolder.getParentFolderId());\n\t\t}\n\n\t\tDLFolder importedFolder = null;\n\n\t\ttry {\n\t\t\tif (parentFolderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t\tDLFolderUtil.findByPrimaryKey(parentFolderId);\n\t\t\t}\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\tDLFolder existingFolder = DLFolderUtil.fetchByUUID_G(\n\t\t\t\t\tfolder.getUuid(), groupId);\n\n\t\t\t\tif (existingFolder == null) {\n\t\t\t\t\tString name = getFolderName(\n\t\t\t\t\t\tcontext.getCompanyId(), groupId, parentFolderId,\n\t\t\t\t\t\tfolder.getName(), 2);\n\n\t\t\t\t\timportedFolder = DLFolderLocalServiceUtil.addFolder(\n\t\t\t\t\t\tfolder.getUuid(), userId, groupId, parentFolderId,\n\t\t\t\t\t\tname, folder.getDescription(), serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportedFolder = DLFolderLocalServiceUtil.updateFolder(\n\t\t\t\t\t\texistingFolder.getFolderId(), parentFolderId,\n\t\t\t\t\t\tfolder.getName(), folder.getDescription(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString name = getFolderName(\n\t\t\t\t\tcontext.getCompanyId(), groupId, parentFolderId,\n\t\t\t\t\tfolder.getName(), 2);\n\n\t\t\t\timportedFolder = DLFolderLocalServiceUtil.addFolder(\n\t\t\t\t\tnull, userId, groupId, parentFolderId, name,\n\t\t\t\t\tfolder.getDescription(), serviceContext);\n\t\t\t}\n\n\t\t\tfolderPKs.put(folder.getFolderId(), importedFolder.getFolderId());\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tDLFolder.class, folder.getFolderId(),\n\t\t\t\timportedFolder.getFolderId());\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for folder \" +\n\t\t\t\t\tfolder.getFolderId());\n\t\t}\n\t}","commit_id":"e59c469b4926cd242b9306a90591726ae121c670","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void importFileEntry(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tMap<String, String> fileEntryNames, DLFileEntry fileEntry,\n\t\t\tString binPath)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(fileEntry.getUserUuid());\n\t\tlong groupId = context.getGroupId();\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, fileEntry.getFolderId(), fileEntry.getFolderId());\n\n\t\tlong[] assetCategoryIds = null;\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\tassetCategoryIds = context.getAssetCategoryIds(\n\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setCreateDate(fileEntry.getCreateDate());\n\t\tserviceContext.setModifiedDate(fileEntry.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(groupId);\n\t\tserviceContext.setStartWorkflow(false);\n\n\t\tInputStream is = context.getZipEntryAsInputStream(binPath);\n\n\t\tif ((folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == fileEntry.getFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, folderId);\n\n\t\t\tDLFolder folder = (DLFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, fileEntry.getFolderId(), fileEntry.getFolderId());\n\t\t}\n\n\t\tDLFileEntry existingFileEntry = null;\n\n\t\ttry {\n\t\t\tif ((folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t\t(folderId > 0)) {\n\n\t\t\t\tDLFolderUtil.findByPrimaryKey(folderId);\n\t\t\t}\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\ttry {\n\t\t\t\t\texistingFileEntry = DLFileEntryUtil.findByUUID_G(\n\t\t\t\t\t\tfileEntry.getUuid(), groupId);\n\n\t\t\t\t\tif (!isDuplicateFileEntry(fileEntry, existingFileEntry)) {\n\t\t\t\t\t\texistingFileEntry =\n\t\t\t\t\t\t\tDLFileEntryLocalServiceUtil.updateFileEntry(\n\t\t\t\t\t\t\t\tuserId, groupId,\n\t\t\t\t\t\t\t\texistingFileEntry.getFolderId(), folderId,\n\t\t\t\t\t\t\t\texistingFileEntry.getName(),\n\t\t\t\t\t\t\t\tfileEntry.getTitle(), fileEntry.getTitle(),\n\t\t\t\t\t\t\t\tfileEntry.getDescription(), null, true,\n\t\t\t\t\t\t\t\tfileEntry.getExtraSettings(), is,\n\t\t\t\t\t\t\t\tfileEntry.getSize(), serviceContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\t\t\texistingFileEntry =\n\t\t\t\t\t\tDLFileEntryLocalServiceUtil.addFileEntry(\n\t\t\t\t\t\t\tfileEntry.getUuid(), userId, groupId, folderId,\n\t\t\t\t\t\t\tfileEntry.getName(), fileEntry.getTitle(),\n\t\t\t\t\t\t\tfileEntry.getDescription(), null,\n\t\t\t\t\t\t\tfileEntry.getExtraSettings(), is,\n\t\t\t\t\t\t\tfileEntry.getSize(), serviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingFileEntry = DLFileEntryLocalServiceUtil.addFileEntry(\n\t\t\t\t\tnull, userId, groupId, folderId, fileEntry.getName(),\n\t\t\t\t\tfileEntry.getTitle(), fileEntry.getDescription(), null,\n\t\t\t\t\tfileEntry.getExtraSettings(), is, fileEntry.getSize(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\n\t\t\tfileEntryNames.put(\n\t\t\t\tfileEntry.getName(), existingFileEntry.getName());\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId(),\n\t\t\t\texistingFileEntry.getFileEntryId());\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\t\tcontext.importComments(\n\t\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId(),\n\t\t\t\t\texistingFileEntry.getFileEntryId(), groupId);\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\t\tcontext.importRatingsEntries(\n\t\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId(),\n\t\t\t\t\texistingFileEntry.getFileEntryId());\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for entry \" +\n\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t}\n\t}","id":73946,"modified_method":"public static void importFileEntry(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tMap<String, String> fileEntryNames, DLFileEntry fileEntry,\n\t\t\tString binPath)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(fileEntry.getUserUuid());\n\t\tlong groupId = context.getGroupId();\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, fileEntry.getFolderId(), fileEntry.getFolderId());\n\n\t\tlong[] assetCategoryIds = null;\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\tassetCategoryIds = context.getAssetCategoryIds(\n\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setCreateDate(fileEntry.getCreateDate());\n\t\tserviceContext.setModifiedDate(fileEntry.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(groupId);\n\t\tserviceContext.setStartWorkflow(false);\n\n\t\tInputStream is = context.getZipEntryAsInputStream(binPath);\n\n\t\tif ((folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == fileEntry.getFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, folderId);\n\n\t\t\tDLFolder folder = (DLFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, fileEntry.getFolderId(), fileEntry.getFolderId());\n\t\t}\n\n\t\tDLFileEntry importedFileEntry = null;\n\n\t\ttry {\n\t\t\tif ((folderId != DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t\t(folderId > 0)) {\n\n\t\t\t\tDLFolderUtil.findByPrimaryKey(folderId);\n\t\t\t}\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\tDLFileEntry existingFileEntry = DLFileEntryUtil.fetchByUUID_G(\n\t\t\t\t\tfileEntry.getUuid(), groupId);\n\n\t\t\t\tif (existingFileEntry == null) {\n\t\t\t\t\timportedFileEntry =\n\t\t\t\t\t\tDLFileEntryLocalServiceUtil.addFileEntry(\n\t\t\t\t\t\t\tfileEntry.getUuid(), userId, groupId, folderId,\n\t\t\t\t\t\t\tfileEntry.getName(), fileEntry.getTitle(),\n\t\t\t\t\t\t\tfileEntry.getDescription(), null,\n\t\t\t\t\t\t\tfileEntry.getExtraSettings(), is,\n\t\t\t\t\t\t\tfileEntry.getSize(), serviceContext);\n\t\t\t\t}\n\t\t\t\telse if (!isDuplicateFileEntry(fileEntry, existingFileEntry)) {\n\t\t\t\t\timportedFileEntry =\n\t\t\t\t\t\tDLFileEntryLocalServiceUtil.updateFileEntry(\n\t\t\t\t\t\t\tuserId, groupId, existingFileEntry.getFolderId(),\n\t\t\t\t\t\t\tfolderId, existingFileEntry.getName(),\n\t\t\t\t\t\t\tfileEntry.getTitle(), fileEntry.getTitle(),\n\t\t\t\t\t\t\tfileEntry.getDescription(), null, true,\n\t\t\t\t\t\t\tfileEntry.getExtraSettings(), is,\n\t\t\t\t\t\t\tfileEntry.getSize(), serviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedFileEntry = DLFileEntryLocalServiceUtil.addFileEntry(\n\t\t\t\t\tnull, userId, groupId, folderId, fileEntry.getName(),\n\t\t\t\t\tfileEntry.getTitle(), fileEntry.getDescription(), null,\n\t\t\t\t\tfileEntry.getExtraSettings(), is, fileEntry.getSize(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\n\t\t\tfileEntryNames.put(\n\t\t\t\tfileEntry.getName(), importedFileEntry.getName());\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId(),\n\t\t\t\timportedFileEntry.getFileEntryId());\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\t\tcontext.importComments(\n\t\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId(),\n\t\t\t\t\timportedFileEntry.getFileEntryId(), groupId);\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\t\tcontext.importRatingsEntries(\n\t\t\t\t\tDLFileEntry.class, fileEntry.getFileEntryId(),\n\t\t\t\t\timportedFileEntry.getFileEntryId());\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for entry \" +\n\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t}\n\t}","commit_id":"e59c469b4926cd242b9306a90591726ae121c670","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void importFolder(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tIGFolder folder)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(folder.getUserUuid());\n\t\tlong parentFolderId = MapUtil.getLong(\n\t\t\tfolderPKs, folder.getParentFolderId(), folder.getParentFolderId());\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setCreateDate(folder.getCreateDate());\n\t\tserviceContext.setModifiedDate(folder.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(context.getGroupId());\n\n\t\tif ((parentFolderId != IGFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(parentFolderId == folder.getParentFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, parentFolderId);\n\n\t\t\tIGFolder parentFolder = (IGFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, parentFolder);\n\n\t\t\tparentFolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, folder.getParentFolderId(),\n\t\t\t\tfolder.getParentFolderId());\n\t\t}\n\n\t\tIGFolder existingFolder = null;\n\n\t\ttry {\n\t\t\tif (parentFolderId != IGFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t\tIGFolderUtil.findByPrimaryKey(parentFolderId);\n\t\t\t}\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\texistingFolder = IGFolderUtil.fetchByUUID_G(\n\t\t\t\t\tfolder.getUuid(), context.getGroupId());\n\n\t\t\t\tif (existingFolder == null) {\n\t\t\t\t\tString name = getFolderName(\n\t\t\t\t\t\tcontext.getCompanyId(), context.getGroupId(),\n\t\t\t\t\t\tparentFolderId, folder.getName(), 2);\n\n\t\t\t\t\texistingFolder = IGFolderLocalServiceUtil.addFolder(\n\t\t\t\t\t\tfolder.getUuid(), userId, parentFolderId, name,\n\t\t\t\t\t\tfolder.getDescription(), serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texistingFolder = IGFolderLocalServiceUtil.updateFolder(\n\t\t\t\t\t\texistingFolder.getFolderId(), parentFolderId,\n\t\t\t\t\t\tfolder.getName(), folder.getDescription(), false,\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString name = getFolderName(\n\t\t\t\t\tcontext.getCompanyId(), context.getGroupId(),\n\t\t\t\t\tparentFolderId, folder.getName(), 2);\n\n\t\t\t\texistingFolder = IGFolderLocalServiceUtil.addFolder(\n\t\t\t\t\tnull, userId, parentFolderId, name, folder.getDescription(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\n\t\t\tfolderPKs.put(folder.getFolderId(), existingFolder.getFolderId());\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tIGFolder.class, folder.getFolderId(),\n\t\t\t\texistingFolder.getFolderId());\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for folder \" +\n\t\t\t\t\tfolder.getFolderId());\n\t\t}\n\t}","id":73947,"modified_method":"public static void importFolder(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tIGFolder folder)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(folder.getUserUuid());\n\t\tlong parentFolderId = MapUtil.getLong(\n\t\t\tfolderPKs, folder.getParentFolderId(), folder.getParentFolderId());\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setCreateDate(folder.getCreateDate());\n\t\tserviceContext.setModifiedDate(folder.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(context.getGroupId());\n\n\t\tif ((parentFolderId != IGFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(parentFolderId == folder.getParentFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, parentFolderId);\n\n\t\t\tIGFolder parentFolder = (IGFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, parentFolder);\n\n\t\t\tparentFolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, folder.getParentFolderId(),\n\t\t\t\tfolder.getParentFolderId());\n\t\t}\n\n\t\tIGFolder importedFolder = null;\n\n\t\ttry {\n\t\t\tif (parentFolderId != IGFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\t\tIGFolderUtil.findByPrimaryKey(parentFolderId);\n\t\t\t}\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\tIGFolder existingFolder = IGFolderUtil.fetchByUUID_G(\n\t\t\t\t\tfolder.getUuid(), context.getGroupId());\n\n\t\t\t\tif (existingFolder == null) {\n\t\t\t\t\tString name = getFolderName(\n\t\t\t\t\t\tcontext.getCompanyId(), context.getGroupId(),\n\t\t\t\t\t\tparentFolderId, folder.getName(), 2);\n\n\t\t\t\t\timportedFolder = IGFolderLocalServiceUtil.addFolder(\n\t\t\t\t\t\tfolder.getUuid(), userId, parentFolderId, name,\n\t\t\t\t\t\tfolder.getDescription(), serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportedFolder = IGFolderLocalServiceUtil.updateFolder(\n\t\t\t\t\t\texistingFolder.getFolderId(), parentFolderId,\n\t\t\t\t\t\tfolder.getName(), folder.getDescription(), false,\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString name = getFolderName(\n\t\t\t\t\tcontext.getCompanyId(), context.getGroupId(),\n\t\t\t\t\tparentFolderId, folder.getName(), 2);\n\n\t\t\t\timportedFolder = IGFolderLocalServiceUtil.addFolder(\n\t\t\t\t\tnull, userId, parentFolderId, name, folder.getDescription(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\n\t\t\tfolderPKs.put(folder.getFolderId(), importedFolder.getFolderId());\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tIGFolder.class, folder.getFolderId(),\n\t\t\t\timportedFolder.getFolderId());\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for folder \" +\n\t\t\t\t\tfolder.getFolderId());\n\t\t}\n\t}","commit_id":"e59c469b4926cd242b9306a90591726ae121c670","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void importImage(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tIGImage image, String binPath)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(image.getUserUuid());\n\t\tlong groupId = context.getGroupId();\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, image.getFolderId(), image.getFolderId());\n\n\t\tFile imageFile = null;\n\n\t\tbyte[] bytes = context.getZipEntryAsByteArray(binPath);\n\n\t\tif (bytes == null) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find image file for image \" + image.getImageId());\n\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\timageFile = File.createTempFile(\n\t\t\t\tString.valueOf(image.getPrimaryKey()),\n\t\t\t\tStringPool.PERIOD + image.getImageType());\n\n\t\t\tFileUtil.write(imageFile, bytes);\n\t\t}\n\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tIGImage.class, image.getImageId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setCreateDate(image.getCreateDate());\n\t\tserviceContext.setModifiedDate(image.getModifiedDate());\n\n\t\tif ((folderId != IGFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == image.getFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, folderId);\n\n\t\t\tIGFolder folder = (IGFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, image.getFolderId(), image.getFolderId());\n\t\t}\n\n\t\tIGImage existingImage = null;\n\n\t\ttry {\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\ttry {\n\t\t\t\t\texistingImage = IGImageUtil.findByUUID_G(\n\t\t\t\t\t\timage.getUuid(), groupId);\n\n\t\t\t\t\texistingImage = IGImageLocalServiceUtil.updateImage(\n\t\t\t\t\t\tuserId, existingImage.getImageId(), groupId, folderId,\n\t\t\t\t\t\timage.getName(), image.getDescription(), imageFile,\n\t\t\t\t\t\timage.getImageType(), serviceContext);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchImageException nsie) {\n\t\t\t\t\texistingImage = IGImageLocalServiceUtil.addImage(\n\t\t\t\t\t\timage.getUuid(), userId, groupId, folderId,\n\t\t\t\t\t\timage.getName(), image.getDescription(), imageFile,\n\t\t\t\t\t\timage.getImageType(), serviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingImage = IGImageLocalServiceUtil.addImage(\n\t\t\t\t\tnull, userId, groupId, folderId, image.getName(),\n\t\t\t\t\timage.getDescription(), imageFile, image.getImageType(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tIGImage.class, image.getImageId(), existingImage.getImageId());\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for image \" +\n\t\t\t\t\timage.getImageId());\n\t\t}\n\t}","id":73948,"modified_method":"public static void importImage(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tIGImage image, String binPath)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(image.getUserUuid());\n\t\tlong groupId = context.getGroupId();\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, image.getFolderId(), image.getFolderId());\n\n\t\tFile imageFile = null;\n\n\t\tbyte[] bytes = context.getZipEntryAsByteArray(binPath);\n\n\t\tif (bytes == null) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find image file for image \" + image.getImageId());\n\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\timageFile = File.createTempFile(\n\t\t\t\tString.valueOf(image.getPrimaryKey()),\n\t\t\t\tStringPool.PERIOD + image.getImageType());\n\n\t\t\tFileUtil.write(imageFile, bytes);\n\t\t}\n\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tIGImage.class, image.getImageId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setCreateDate(image.getCreateDate());\n\t\tserviceContext.setModifiedDate(image.getModifiedDate());\n\n\t\tif ((folderId != IGFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == image.getFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, folderId);\n\n\t\t\tIGFolder folder = (IGFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, image.getFolderId(), image.getFolderId());\n\t\t}\n\n\t\tIGImage importedImage = null;\n\n\t\ttry {\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\tIGImage existingImage = IGImageUtil.fetchByUUID_G(\n\t\t\t\t\timage.getUuid(), groupId);\n\n\t\t\t\tif (existingImage == null) {\n\t\t\t\t\timportedImage = IGImageLocalServiceUtil.addImage(\n\t\t\t\t\t\timage.getUuid(), userId, groupId, folderId,\n\t\t\t\t\t\timage.getName(), image.getDescription(), imageFile,\n\t\t\t\t\t\timage.getImageType(), serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportedImage = IGImageLocalServiceUtil.updateImage(\n\t\t\t\t\t\tuserId, existingImage.getImageId(), groupId, folderId,\n\t\t\t\t\t\timage.getName(), image.getDescription(), imageFile,\n\t\t\t\t\t\timage.getImageType(), serviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedImage = IGImageLocalServiceUtil.addImage(\n\t\t\t\t\tnull, userId, groupId, folderId, image.getName(),\n\t\t\t\t\timage.getDescription(), imageFile, image.getImageType(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tIGImage.class, image.getImageId(), importedImage.getImageId());\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for image \" +\n\t\t\t\t\timage.getImageId());\n\t\t}\n\t}","commit_id":"e59c469b4926cd242b9306a90591726ae121c670","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importMessage(\n\t\t\tPortletDataContext context, Map<Long, Long> categoryPKs,\n\t\t\tMap<Long, Long> threadPKs, Map<Long, Long> messagePKs,\n\t\t\tElement messageEl, MBMessage message)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(message.getUserUuid());\n\t\tString userName = message.getUserName();\n\t\tlong categoryId = MapUtil.getLong(\n\t\t\tcategoryPKs, message.getCategoryId(), message.getCategoryId());\n\t\tlong threadId = MapUtil.getLong(\n\t\t\tthreadPKs, message.getThreadId(), message.getThreadId());\n\t\tlong parentMessageId = MapUtil.getLong(\n\t\t\tmessagePKs, message.getParentMessageId(),\n\t\t\tmessage.getParentMessageId());\n\n\t\tList<ObjectValuePair<String, byte[]>> files =\n\t\t\tnew ArrayList<ObjectValuePair<String, byte[]>>();\n\t\tList<String> existingFiles = new ArrayList<String>();\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"attachments\") &&\n\t\t\tmessage.isAttachments()) {\n\n\t\t\tList<Element> attachmentEls = messageEl.elements(\"attachment\");\n\n\t\t\tfor (Element attachmentEl : attachmentEls) {\n\t\t\t\tString name = attachmentEl.attributeValue(\"name\");\n\t\t\t\tString binPath = attachmentEl.attributeValue(\"bin-path\");\n\n\t\t\t\tbyte[] bytes = context.getZipEntryAsByteArray(binPath);\n\n\t\t\t\tfiles.add(new ObjectValuePair<String, byte[]>(name, bytes));\n\t\t\t}\n\n\t\t\tif (files.size() <= 0) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Could not find attachments for message \" +\n\t\t\t\t\t\tmessage.getMessageId());\n\t\t\t}\n\t\t}\n\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tMBMessage.class, message.getMessageId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setScopeGroupId(context.getGroupId());\n\t\tserviceContext.setStartWorkflow(false);\n\t\tserviceContext.setStatus(message.getStatus());\n\n\t\tif ((categoryId != MBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(categoryId == message.getCategoryId())) {\n\n\t\t\tString path = getImportCategoryPath(context, categoryId);\n\n\t\t\tMBCategory category = (MBCategory)context.getZipEntryAsObject(path);\n\n\t\t\timportCategory(context, categoryPKs, category);\n\n\t\t\tcategoryId = MapUtil.getLong(\n\t\t\t\tcategoryPKs, message.getCategoryId(), message.getCategoryId());\n\t\t}\n\n\t\tMBMessage existingMessage = null;\n\n\t\ttry {\n\t\t\tMBCategoryUtil.findByPrimaryKey(categoryId);\n\n\t\t\tif (parentMessageId !=\n\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\n\t\t\t\tMBMessageUtil.findByPrimaryKey(parentMessageId);\n\t\t\t\tMBThreadUtil.findByPrimaryKey(threadId);\n\t\t\t}\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\ttry {\n\t\t\t\t\texistingMessage = MBMessageUtil.findByUUID_G(\n\t\t\t\t\t\tmessage.getUuid(), context.getGroupId());\n\n\t\t\t\t\texistingMessage = MBMessageLocalServiceUtil.updateMessage(\n\t\t\t\t\t\tuserId, existingMessage.getMessageId(),\n\t\t\t\t\t\tmessage.getSubject(), message.getBody(), files,\n\t\t\t\t\t\texistingFiles, message.getPriority(),\n\t\t\t\t\t\tmessage.getAllowPingbacks(), serviceContext);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchMessageException nsme) {\n\t\t\t\t\texistingMessage = MBMessageLocalServiceUtil.addMessage(\n\t\t\t\t\t\tmessage.getUuid(), userId, userName,\n\t\t\t\t\t\tmessage.getGroupId(), categoryId, threadId,\n\t\t\t\t\t\tparentMessageId, message.getSubject(),\n\t\t\t\t\t\tmessage.getBody(), files, message.getAnonymous(),\n\t\t\t\t\t\tmessage.getPriority(), message.getAllowPingbacks(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingMessage = MBMessageLocalServiceUtil.addMessage(\n\t\t\t\t\tuserId, userName, message.getGroupId(), categoryId,\n\t\t\t\t\tthreadId, parentMessageId, message.getSubject(),\n\t\t\t\t\tmessage.getBody(), files, message.getAnonymous(),\n\t\t\t\t\tmessage.getPriority(), message.getAllowPingbacks(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\n\t\t\tthreadPKs.put(message.getThreadId(), existingMessage.getThreadId());\n\t\t\tmessagePKs.put(\n\t\t\t\tmessage.getMessageId(), existingMessage.getMessageId());\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tMBMessage.class, message.getMessageId(),\n\t\t\t\texistingMessage.getMessageId());\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\t\tcontext.importRatingsEntries(\n\t\t\t\t\tMBMessage.class, message.getMessageId(),\n\t\t\t\t\texistingMessage.getMessageId());\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchCategoryException nsce) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent category for message \" +\n\t\t\t\t\tmessage.getMessageId());\n\t\t}\n\t\tcatch (NoSuchMessageException nsme) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent message for message \" +\n\t\t\t\t\tmessage.getMessageId());\n\t\t}\n\t\tcatch (NoSuchThreadException nste) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the thread for message \" +\n\t\t\t\t\tmessage.getMessageId());\n\t\t}\n\t}","id":73949,"modified_method":"protected void importMessage(\n\t\t\tPortletDataContext context, Map<Long, Long> categoryPKs,\n\t\t\tMap<Long, Long> threadPKs, Map<Long, Long> messagePKs,\n\t\t\tElement messageEl, MBMessage message)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(message.getUserUuid());\n\t\tString userName = message.getUserName();\n\t\tlong categoryId = MapUtil.getLong(\n\t\t\tcategoryPKs, message.getCategoryId(), message.getCategoryId());\n\t\tlong threadId = MapUtil.getLong(\n\t\t\tthreadPKs, message.getThreadId(), message.getThreadId());\n\t\tlong parentMessageId = MapUtil.getLong(\n\t\t\tmessagePKs, message.getParentMessageId(),\n\t\t\tmessage.getParentMessageId());\n\n\t\tList<ObjectValuePair<String, byte[]>> files =\n\t\t\tnew ArrayList<ObjectValuePair<String, byte[]>>();\n\t\tList<String> existingFiles = new ArrayList<String>();\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"attachments\") &&\n\t\t\tmessage.isAttachments()) {\n\n\t\t\tList<Element> attachmentEls = messageEl.elements(\"attachment\");\n\n\t\t\tfor (Element attachmentEl : attachmentEls) {\n\t\t\t\tString name = attachmentEl.attributeValue(\"name\");\n\t\t\t\tString binPath = attachmentEl.attributeValue(\"bin-path\");\n\n\t\t\t\tbyte[] bytes = context.getZipEntryAsByteArray(binPath);\n\n\t\t\t\tfiles.add(new ObjectValuePair<String, byte[]>(name, bytes));\n\t\t\t}\n\n\t\t\tif (files.size() <= 0) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Could not find attachments for message \" +\n\t\t\t\t\t\tmessage.getMessageId());\n\t\t\t}\n\t\t}\n\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tMBMessage.class, message.getMessageId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setScopeGroupId(context.getGroupId());\n\t\tserviceContext.setStartWorkflow(false);\n\t\tserviceContext.setStatus(message.getStatus());\n\n\t\tif ((categoryId != MBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(categoryId == message.getCategoryId())) {\n\n\t\t\tString path = getImportCategoryPath(context, categoryId);\n\n\t\t\tMBCategory category = (MBCategory)context.getZipEntryAsObject(path);\n\n\t\t\timportCategory(context, categoryPKs, category);\n\n\t\t\tcategoryId = MapUtil.getLong(\n\t\t\t\tcategoryPKs, message.getCategoryId(), message.getCategoryId());\n\t\t}\n\n\t\tMBMessage importedMessage = null;\n\n\t\ttry {\n\t\t\tMBCategoryUtil.findByPrimaryKey(categoryId);\n\n\t\t\tif (parentMessageId !=\n\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\n\t\t\t\tMBMessageUtil.findByPrimaryKey(parentMessageId);\n\t\t\t\tMBThreadUtil.findByPrimaryKey(threadId);\n\t\t\t}\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\tMBMessage existingMessage = MBMessageUtil.fetchByUUID_G(\n\t\t\t\t\tmessage.getUuid(), context.getGroupId());\n\n\t\t\t\tif (existingMessage == null) {\n\t\t\t\t\timportedMessage = MBMessageLocalServiceUtil.addMessage(\n\t\t\t\t\t\tmessage.getUuid(), userId, userName,\n\t\t\t\t\t\tmessage.getGroupId(), categoryId, threadId,\n\t\t\t\t\t\tparentMessageId, message.getSubject(),\n\t\t\t\t\t\tmessage.getBody(), files, message.getAnonymous(),\n\t\t\t\t\t\tmessage.getPriority(), message.getAllowPingbacks(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportedMessage = MBMessageLocalServiceUtil.updateMessage(\n\t\t\t\t\t\tuserId, existingMessage.getMessageId(),\n\t\t\t\t\t\tmessage.getSubject(), message.getBody(), files,\n\t\t\t\t\t\texistingFiles, message.getPriority(),\n\t\t\t\t\t\tmessage.getAllowPingbacks(), serviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedMessage = MBMessageLocalServiceUtil.addMessage(\n\t\t\t\t\tuserId, userName, message.getGroupId(), categoryId,\n\t\t\t\t\tthreadId, parentMessageId, message.getSubject(),\n\t\t\t\t\tmessage.getBody(), files, message.getAnonymous(),\n\t\t\t\t\tmessage.getPriority(), message.getAllowPingbacks(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\n\t\t\tthreadPKs.put(message.getThreadId(), importedMessage.getThreadId());\n\t\t\tmessagePKs.put(\n\t\t\t\tmessage.getMessageId(), importedMessage.getMessageId());\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tMBMessage.class, message.getMessageId(),\n\t\t\t\timportedMessage.getMessageId());\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\t\tcontext.importRatingsEntries(\n\t\t\t\t\tMBMessage.class, message.getMessageId(),\n\t\t\t\t\timportedMessage.getMessageId());\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchCategoryException nsce) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent category for message \" +\n\t\t\t\t\tmessage.getMessageId());\n\t\t}\n\t\tcatch (NoSuchMessageException nsme) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent message for message \" +\n\t\t\t\t\tmessage.getMessageId());\n\t\t}\n\t\tcatch (NoSuchThreadException nste) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the thread for message \" +\n\t\t\t\t\tmessage.getMessageId());\n\t\t}\n\t}","commit_id":"e59c469b4926cd242b9306a90591726ae121c670","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importCategory(\n\t\t\tPortletDataContext context, Map<Long, Long> categoryPKs,\n\t\t\tMBCategory category)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(category.getUserUuid());\n\t\tlong parentCategoryId = MapUtil.getLong(\n\t\t\tcategoryPKs, category.getParentCategoryId(),\n\t\t\tcategory.getParentCategoryId());\n\n\t\tString emailAddress = null;\n\t\tString inProtocol = null;\n\t\tString inServerName = null;\n\t\tint inServerPort = 0;\n\t\tboolean inUseSSL = false;\n\t\tString inUserName = null;\n\t\tString inPassword = null;\n\t\tint inReadInterval = 0;\n\t\tString outEmailAddress = null;\n\t\tboolean outCustom = false;\n\t\tString outServerName = null;\n\t\tint outServerPort = 0;\n\t\tboolean outUseSSL = false;\n\t\tString outUserName = null;\n\t\tString outPassword = null;\n\t\tboolean mailingListActive = false;\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setScopeGroupId(context.getGroupId());\n\n\t\tif ((parentCategoryId !=\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(parentCategoryId == category.getParentCategoryId())) {\n\n\t\t\tString path = getImportCategoryPath(context, parentCategoryId);\n\n\t\t\tMBCategory parentCategory =\n\t\t\t\t(MBCategory)context.getZipEntryAsObject(path);\n\n\t\t\timportCategory(context, categoryPKs, parentCategory);\n\n\t\t\tparentCategoryId = MapUtil.getLong(\n\t\t\t\tcategoryPKs, category.getParentCategoryId(),\n\t\t\t\tcategory.getParentCategoryId());\n\t\t}\n\n\t\tMBCategory existingCategory = null;\n\n\t\ttry {\n\t\t\tif (parentCategoryId !=\n\t\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\t\tMBCategoryUtil.findByPrimaryKey(parentCategoryId);\n\t\t\t}\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\texistingCategory = MBCategoryUtil.fetchByUUID_G(\n\t\t\t\t\tcategory.getUuid(), context.getGroupId());\n\n\t\t\t\tif (existingCategory == null) {\n\t\t\t\t\texistingCategory = MBCategoryLocalServiceUtil.addCategory(\n\t\t\t\t\t\tcategory.getUuid(), userId, parentCategoryId,\n\t\t\t\t\t\tcategory.getName(), category.getDescription(),\n\t\t\t\t\t\temailAddress, inProtocol, inServerName, inServerPort,\n\t\t\t\t\t\tinUseSSL, inUserName, inPassword, inReadInterval,\n\t\t\t\t\t\toutEmailAddress, outCustom, outServerName,\n\t\t\t\t\t\toutServerPort, outUseSSL, outUserName, outPassword,\n\t\t\t\t\t\tmailingListActive, serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texistingCategory =\n\t\t\t\t\t\tMBCategoryLocalServiceUtil.updateCategory(\n\t\t\t\t\t\t\texistingCategory.getCategoryId(), parentCategoryId,\n\t\t\t\t\t\t\tcategory.getName(), category.getDescription(),\n\t\t\t\t\t\t\temailAddress, inProtocol, inServerName,\n\t\t\t\t\t\t\tinServerPort, inUseSSL, inUserName, inPassword,\n\t\t\t\t\t\t\tinReadInterval, outEmailAddress, outCustom,\n\t\t\t\t\t\t\toutServerName, outServerPort, outUseSSL,\n\t\t\t\t\t\t\toutUserName, outPassword, mailingListActive, false,\n\t\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingCategory = MBCategoryLocalServiceUtil.addCategory(\n\t\t\t\t\tuserId, parentCategoryId, category.getName(),\n\t\t\t\t\tcategory.getDescription(), emailAddress, inProtocol,\n\t\t\t\t\tinServerName, inServerPort, inUseSSL, inUserName,\n\t\t\t\t\tinPassword, inReadInterval, outEmailAddress, outCustom,\n\t\t\t\t\toutServerName, outServerPort, outUseSSL, outUserName,\n\t\t\t\t\toutPassword, mailingListActive, serviceContext);\n\t\t\t}\n\n\t\t\tcategoryPKs.put(\n\t\t\t\tcategory.getCategoryId(), existingCategory.getCategoryId());\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tMBCategory.class, category.getCategoryId(),\n\t\t\t\texistingCategory.getCategoryId());\n\t\t}\n\t\tcatch (NoSuchCategoryException nsce) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent category for category \" +\n\t\t\t\t\tcategory.getCategoryId());\n\t\t}\n\t}","id":73950,"modified_method":"protected void importCategory(\n\t\t\tPortletDataContext context, Map<Long, Long> categoryPKs,\n\t\t\tMBCategory category)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(category.getUserUuid());\n\t\tlong parentCategoryId = MapUtil.getLong(\n\t\t\tcategoryPKs, category.getParentCategoryId(),\n\t\t\tcategory.getParentCategoryId());\n\n\t\tString emailAddress = null;\n\t\tString inProtocol = null;\n\t\tString inServerName = null;\n\t\tint inServerPort = 0;\n\t\tboolean inUseSSL = false;\n\t\tString inUserName = null;\n\t\tString inPassword = null;\n\t\tint inReadInterval = 0;\n\t\tString outEmailAddress = null;\n\t\tboolean outCustom = false;\n\t\tString outServerName = null;\n\t\tint outServerPort = 0;\n\t\tboolean outUseSSL = false;\n\t\tString outUserName = null;\n\t\tString outPassword = null;\n\t\tboolean mailingListActive = false;\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setScopeGroupId(context.getGroupId());\n\n\t\tif ((parentCategoryId !=\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(parentCategoryId == category.getParentCategoryId())) {\n\n\t\t\tString path = getImportCategoryPath(context, parentCategoryId);\n\n\t\t\tMBCategory parentCategory =\n\t\t\t\t(MBCategory)context.getZipEntryAsObject(path);\n\n\t\t\timportCategory(context, categoryPKs, parentCategory);\n\n\t\t\tparentCategoryId = MapUtil.getLong(\n\t\t\t\tcategoryPKs, category.getParentCategoryId(),\n\t\t\t\tcategory.getParentCategoryId());\n\t\t}\n\n\t\tMBCategory importedCategory = null;\n\n\t\ttry {\n\t\t\tif (parentCategoryId !=\n\t\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\t\tMBCategoryUtil.findByPrimaryKey(parentCategoryId);\n\t\t\t}\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\tMBCategory existingCategory = MBCategoryUtil.fetchByUUID_G(\n\t\t\t\t\tcategory.getUuid(), context.getGroupId());\n\n\t\t\t\tif (existingCategory == null) {\n\t\t\t\t\timportedCategory = MBCategoryLocalServiceUtil.addCategory(\n\t\t\t\t\t\tcategory.getUuid(), userId, parentCategoryId,\n\t\t\t\t\t\tcategory.getName(), category.getDescription(),\n\t\t\t\t\t\temailAddress, inProtocol, inServerName, inServerPort,\n\t\t\t\t\t\tinUseSSL, inUserName, inPassword, inReadInterval,\n\t\t\t\t\t\toutEmailAddress, outCustom, outServerName,\n\t\t\t\t\t\toutServerPort, outUseSSL, outUserName, outPassword,\n\t\t\t\t\t\tmailingListActive, serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportedCategory =\n\t\t\t\t\t\tMBCategoryLocalServiceUtil.updateCategory(\n\t\t\t\t\t\t\texistingCategory.getCategoryId(), parentCategoryId,\n\t\t\t\t\t\t\tcategory.getName(), category.getDescription(),\n\t\t\t\t\t\t\temailAddress, inProtocol, inServerName,\n\t\t\t\t\t\t\tinServerPort, inUseSSL, inUserName, inPassword,\n\t\t\t\t\t\t\tinReadInterval, outEmailAddress, outCustom,\n\t\t\t\t\t\t\toutServerName, outServerPort, outUseSSL,\n\t\t\t\t\t\t\toutUserName, outPassword, mailingListActive, false,\n\t\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedCategory = MBCategoryLocalServiceUtil.addCategory(\n\t\t\t\t\tuserId, parentCategoryId, category.getName(),\n\t\t\t\t\tcategory.getDescription(), emailAddress, inProtocol,\n\t\t\t\t\tinServerName, inServerPort, inUseSSL, inUserName,\n\t\t\t\t\tinPassword, inReadInterval, outEmailAddress, outCustom,\n\t\t\t\t\toutServerName, outServerPort, outUseSSL, outUserName,\n\t\t\t\t\toutPassword, mailingListActive, serviceContext);\n\t\t\t}\n\n\t\t\tcategoryPKs.put(\n\t\t\t\tcategory.getCategoryId(), importedCategory.getCategoryId());\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tMBCategory.class, category.getCategoryId(),\n\t\t\t\timportedCategory.getCategoryId());\n\t\t}\n\t\tcatch (NoSuchCategoryException nsce) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent category for category \" +\n\t\t\t\t\tcategory.getCategoryId());\n\t\t}\n\t}","commit_id":"e59c469b4926cd242b9306a90591726ae121c670","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PollsChoice findByUuid_G(String uuid, long groupId)\n\t\tthrows NoSuchChoiceException, SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tString sql = CustomSQLUtil.get(FIND_BY_UUID_G);\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.addEntity(\"PollsChoice\", PollsChoiceImpl.class);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\tqPos.add(uuid);\n\t\t\tqPos.add(groupId);\n\n\t\t\tList<PollsChoice> list = q.list();\n\n\t\t\tif (list.size() == 0) {\n\t\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\t\tsb.append(\"No PollsChoice exists with the key {uuid=\");\n\t\t\t\tsb.append(uuid);\n\t\t\t\tsb.append(\", groupId=\");\n\t\t\t\tsb.append(groupId);\n\t\t\t\tsb.append(\"}\");\n\n\t\t\t\tthrow new NoSuchChoiceException(sb.toString());\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn list.get(0);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchChoiceException nsce) {\n\t\t\tthrow nsce;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","id":73951,"modified_method":"public PollsChoice findByUUID_G(String uuid, long groupId)\n\t\tthrows NoSuchChoiceException, SystemException {\n\n\t\tPollsChoice choice = fetchByUUID_G(uuid, groupId);\n\n\t\tif (choice == null) {\n\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\tsb.append(\"No PollsChoice exists with the key {uuid=\");\n\t\t\tsb.append(uuid);\n\t\t\tsb.append(\", groupId=\");\n\t\t\tsb.append(groupId);\n\t\t\tsb.append(\"}\");\n\n\t\t\tthrow new NoSuchChoiceException(sb.toString());\n\t\t}\n\t\telse {\n\t\t\treturn choice;\n\t\t}\n\t}","commit_id":"e59c469b4926cd242b9306a90591726ae121c670","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static com.liferay.portlet.polls.model.PollsChoice findByUuid_G(\n\t\tjava.lang.String uuid, long groupId)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException,\n\t\t\tcom.liferay.portlet.polls.NoSuchChoiceException {\n\t\treturn getFinder().findByUuid_G(uuid, groupId);\n\t}","id":73952,"modified_method":"public static com.liferay.portlet.polls.model.PollsChoice findByUUID_G(\n\t\tjava.lang.String uuid, long groupId)\n\t\tthrows com.liferay.portal.kernel.exception.SystemException,\n\t\t\tcom.liferay.portlet.polls.NoSuchChoiceException {\n\t\treturn getFinder().findByUUID_G(uuid, groupId);\n\t}","commit_id":"e59c469b4926cd242b9306a90591726ae121c670","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void importChoice(\n\t\t\tPortletDataContext context, Map<Long, Long> questionPKs,\n\t\t\tMap<Long, Long> choicePKs, PollsChoice choice)\n\t\tthrows Exception {\n\n\t\tlong questionId = MapUtil.getLong(\n\t\t\tquestionPKs, choice.getQuestionId(), choice.getQuestionId());\n\n\t\tPollsChoice existingChoice = null;\n\n\t\ttry {\n\t\t\tPollsQuestionUtil.findByPrimaryKey(questionId);\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\ttry {\n\t\t\t\t\texistingChoice = PollsChoiceFinderUtil.findByUuid_G(\n\t\t\t\t\t\tchoice.getUuid(), context.getGroupId());\n\n\t\t\t\t\texistingChoice = PollsChoiceLocalServiceUtil.updateChoice(\n\t\t\t\t\t\texistingChoice.getChoiceId(), questionId,\n\t\t\t\t\t\tchoice.getName(), choice.getDescription());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchChoiceException nsce) {\n\t\t\t\t\texistingChoice = PollsChoiceLocalServiceUtil.addChoice(\n\t\t\t\t\t\tchoice.getUuid(), questionId, choice.getName(),\n\t\t\t\t\t\tchoice.getDescription());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingChoice = PollsChoiceLocalServiceUtil.addChoice(\n\t\t\t\t\tnull, questionId, choice.getName(),\n\t\t\t\t\tchoice.getDescription());\n\t\t\t}\n\n\t\t\tchoicePKs.put(choice.getChoiceId(), existingChoice.getChoiceId());\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tPollsChoice.class, choice.getChoiceId(),\n\t\t\t\texistingChoice.getChoiceId());\n\t\t}\n\t\tcatch (NoSuchQuestionException nsqe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the question for choice \" +\n\t\t\t\t\tchoice.getChoiceId());\n\t\t}\n\t}","id":73953,"modified_method":"public static void importChoice(\n\t\t\tPortletDataContext context, Map<Long, Long> questionPKs,\n\t\t\tMap<Long, Long> choicePKs, PollsChoice choice)\n\t\tthrows Exception {\n\n\t\tlong questionId = MapUtil.getLong(\n\t\t\tquestionPKs, choice.getQuestionId(), choice.getQuestionId());\n\n\t\tPollsChoice importedChoice = null;\n\n\t\ttry {\n\t\t\tPollsQuestionUtil.findByPrimaryKey(questionId);\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\tPollsChoice existingChoice =\n\t\t\t\t\tPollsChoiceFinderUtil.fetchByUUID_G(\n\t\t\t\t\t\tchoice.getUuid(), context.getGroupId());\n\n\t\t\t\tif (existingChoice == null) {\n\t\t\t\t\timportedChoice = PollsChoiceLocalServiceUtil.addChoice(\n\t\t\t\t\t\tchoice.getUuid(), questionId, choice.getName(),\n\t\t\t\t\t\tchoice.getDescription());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportedChoice = PollsChoiceLocalServiceUtil.updateChoice(\n\t\t\t\t\t\texistingChoice.getChoiceId(), questionId,\n\t\t\t\t\t\tchoice.getName(), choice.getDescription());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedChoice = PollsChoiceLocalServiceUtil.addChoice(\n\t\t\t\t\tnull, questionId, choice.getName(),\n\t\t\t\t\tchoice.getDescription());\n\t\t\t}\n\n\t\t\tchoicePKs.put(choice.getChoiceId(), importedChoice.getChoiceId());\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tPollsChoice.class, choice.getChoiceId(),\n\t\t\t\timportedChoice.getChoiceId());\n\t\t}\n\t\tcatch (NoSuchQuestionException nsqe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the question for choice \" +\n\t\t\t\t\tchoice.getChoiceId());\n\t\t}\n\t}","commit_id":"e59c469b4926cd242b9306a90591726ae121c670","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void importQuestion(\n\t\t\tPortletDataContext context, Map<Long, Long> questionPKs,\n\t\t\tPollsQuestion question)\n\t\tthrows SystemException, PortalException {\n\n\t\tlong userId = context.getUserId(question.getUserUuid());\n\n\t\tDate expirationDate = question.getExpirationDate();\n\n\t\tint expirationMonth = 0;\n\t\tint expirationDay = 0;\n\t\tint expirationYear = 0;\n\t\tint expirationHour = 0;\n\t\tint expirationMinute = 0;\n\t\tboolean neverExpire = true;\n\n\t\tif (expirationDate != null) {\n\t\t\tCalendar expirationCal = CalendarFactoryUtil.getCalendar();\n\n\t\t\texpirationCal.setTime(expirationDate);\n\n\t\t\texpirationMonth = expirationCal.get(Calendar.MONTH);\n\t\t\texpirationDay = expirationCal.get(Calendar.DATE);\n\t\t\texpirationYear = expirationCal.get(Calendar.YEAR);\n\t\t\texpirationHour = expirationCal.get(Calendar.HOUR);\n\t\t\texpirationMinute = expirationCal.get(Calendar.MINUTE);\n\t\t\tneverExpire = false;\n\n\t\t\tif (expirationCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\texpirationHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setCreateDate(question.getCreateDate());\n\t\tserviceContext.setModifiedDate(question.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(context.getScopeGroupId());\n\n\t\tPollsQuestion existingQuestion = null;\n\n\t\tif (context.getDataStrategy().equals(\n\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\texistingQuestion =  PollsQuestionUtil.fetchByUUID_G(\n\t\t\t\tquestion.getUuid(), context.getGroupId());\n\n\t\t\tif (existingQuestion == null) {\n\t\t\t\texistingQuestion = PollsQuestionLocalServiceUtil.addQuestion(\n\t\t\t\t\tquestion.getUuid(), userId, question.getTitleMap(),\n\t\t\t\t\tquestion.getDescriptionMap(), expirationMonth,\n\t\t\t\t\texpirationDay, expirationYear, expirationHour,\n\t\t\t\t\texpirationMinute, neverExpire, null, serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingQuestion = PollsQuestionLocalServiceUtil.updateQuestion(\n\t\t\t\t\tuserId, existingQuestion.getQuestionId(),\n\t\t\t\t\tquestion.getTitleMap(), question.getDescriptionMap(),\n\t\t\t\t\texpirationMonth, expirationDay, expirationYear,\n\t\t\t\t\texpirationHour, expirationMinute, neverExpire);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\texistingQuestion = PollsQuestionLocalServiceUtil.addQuestion(\n\t\t\t\tnull, userId, question.getTitleMap(),\n\t\t\t\tquestion.getDescriptionMap(), expirationMonth, expirationDay,\n\t\t\t\texpirationYear, expirationHour, expirationMinute, neverExpire,\n\t\t\t\tnull, serviceContext);\n\t\t}\n\n\t\tquestionPKs.put(\n\t\t\tquestion.getQuestionId(), existingQuestion.getQuestionId());\n\n\t\tcontext.importPermissions(\n\t\t\tPollsQuestion.class, question.getQuestionId(),\n\t\t\texistingQuestion.getQuestionId());\n\t}","id":73954,"modified_method":"public static void importQuestion(\n\t\t\tPortletDataContext context, Map<Long, Long> questionPKs,\n\t\t\tPollsQuestion question)\n\t\tthrows SystemException, PortalException {\n\n\t\tlong userId = context.getUserId(question.getUserUuid());\n\n\t\tDate expirationDate = question.getExpirationDate();\n\n\t\tint expirationMonth = 0;\n\t\tint expirationDay = 0;\n\t\tint expirationYear = 0;\n\t\tint expirationHour = 0;\n\t\tint expirationMinute = 0;\n\t\tboolean neverExpire = true;\n\n\t\tif (expirationDate != null) {\n\t\t\tCalendar expirationCal = CalendarFactoryUtil.getCalendar();\n\n\t\t\texpirationCal.setTime(expirationDate);\n\n\t\t\texpirationMonth = expirationCal.get(Calendar.MONTH);\n\t\t\texpirationDay = expirationCal.get(Calendar.DATE);\n\t\t\texpirationYear = expirationCal.get(Calendar.YEAR);\n\t\t\texpirationHour = expirationCal.get(Calendar.HOUR);\n\t\t\texpirationMinute = expirationCal.get(Calendar.MINUTE);\n\t\t\tneverExpire = false;\n\n\t\t\tif (expirationCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\texpirationHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setCreateDate(question.getCreateDate());\n\t\tserviceContext.setModifiedDate(question.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(context.getScopeGroupId());\n\n\t\tPollsQuestion importedQuestion = null;\n\n\t\tif (context.getDataStrategy().equals(\n\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\tPollsQuestion existingQuestion =  PollsQuestionUtil.fetchByUUID_G(\n\t\t\t\tquestion.getUuid(), context.getGroupId());\n\n\t\t\tif (existingQuestion == null) {\n\t\t\t\timportedQuestion = PollsQuestionLocalServiceUtil.addQuestion(\n\t\t\t\t\tquestion.getUuid(), userId, question.getTitleMap(),\n\t\t\t\t\tquestion.getDescriptionMap(), expirationMonth,\n\t\t\t\t\texpirationDay, expirationYear, expirationHour,\n\t\t\t\t\texpirationMinute, neverExpire, null, serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedQuestion = PollsQuestionLocalServiceUtil.updateQuestion(\n\t\t\t\t\tuserId, existingQuestion.getQuestionId(),\n\t\t\t\t\tquestion.getTitleMap(), question.getDescriptionMap(),\n\t\t\t\t\texpirationMonth, expirationDay, expirationYear,\n\t\t\t\t\texpirationHour, expirationMinute, neverExpire);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedQuestion = PollsQuestionLocalServiceUtil.addQuestion(\n\t\t\t\tnull, userId, question.getTitleMap(),\n\t\t\t\tquestion.getDescriptionMap(), expirationMonth, expirationDay,\n\t\t\t\texpirationYear, expirationHour, expirationMinute, neverExpire,\n\t\t\t\tnull, serviceContext);\n\t\t}\n\n\t\tquestionPKs.put(\n\t\t\tquestion.getQuestionId(), importedQuestion.getQuestionId());\n\n\t\tcontext.importPermissions(\n\t\t\tPollsQuestion.class, question.getQuestionId(),\n\t\t\timportedQuestion.getQuestionId());\n\t}","commit_id":"e59c469b4926cd242b9306a90591726ae121c670","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void importNode(\n\t\t\tPortletDataContext context, Map<Long, Long> nodePKs, WikiNode node)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(node.getUserUuid());\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setCreateDate(node.getCreateDate());\n\t\tserviceContext.setModifiedDate(node.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(context.getGroupId());\n\n\t\tWikiNode existingNode = null;\n\n\t\tif (context.getDataStrategy().equals(\n\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\texistingNode = WikiNodeUtil.fetchByUUID_G(\n\t\t\t\tnode.getUuid(), context.getGroupId());\n\n\t\t\tString nodeName = PropsUtil.get(PropsKeys.WIKI_INITIAL_NODE_NAME);\n\n\t\t\tif (existingNode == null && node.getName().equals(nodeName)) {\n\t\t\t\ttry {\n\t\t\t\t\tWikiNodeUtil.removeByG_N(\n\t\t\t\t\t\tcontext.getGroupId(), node.getName());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchNodeException nsne) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (existingNode == null) {\n\t\t\t\texistingNode = WikiNodeLocalServiceUtil.addNode(\n\t\t\t\t\tnode.getUuid(), userId, node.getName(),\n\t\t\t\t\tnode.getDescription(), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingNode = WikiNodeLocalServiceUtil.updateNode(\n\t\t\t\t\texistingNode.getNodeId(), node.getName(),\n\t\t\t\t\tnode.getDescription(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString nodeName = PropsUtil.get(PropsKeys.WIKI_INITIAL_NODE_NAME);\n\n\t\t\tif (node.getName().equals(nodeName)) {\n\t\t\t\ttry {\n\t\t\t\t\tWikiNodeUtil.removeByG_N(\n\t\t\t\t\t\tcontext.getGroupId(), node.getName());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchNodeException nsne) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\texistingNode = WikiNodeLocalServiceUtil.addNode(\n\t\t\t\tuserId, node.getName(), node.getDescription(), serviceContext);\n\t\t}\n\n\t\tnodePKs.put(node.getNodeId(), existingNode.getNodeId());\n\n\t\tcontext.importPermissions(\n\t\t\tWikiNode.class, node.getNodeId(), existingNode.getNodeId());\n\t}","id":73955,"modified_method":"public static void importNode(\n\t\t\tPortletDataContext context, Map<Long, Long> nodePKs, WikiNode node)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(node.getUserUuid());\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setCreateDate(node.getCreateDate());\n\t\tserviceContext.setModifiedDate(node.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(context.getGroupId());\n\n\t\tWikiNode importedNode = null;\n\n\t\tif (context.getDataStrategy().equals(\n\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\tWikiNode existingNode = WikiNodeUtil.fetchByUUID_G(\n\t\t\t\tnode.getUuid(), context.getGroupId());\n\n\t\t\tString nodeName = PropsUtil.get(PropsKeys.WIKI_INITIAL_NODE_NAME);\n\n\t\t\tif ((existingNode == null) && node.getName().equals(nodeName)) {\n\t\t\t\ttry {\n\t\t\t\t\tWikiNodeUtil.removeByG_N(\n\t\t\t\t\t\tcontext.getGroupId(), node.getName());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchNodeException nsne) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (existingNode == null) {\n\t\t\t\timportedNode = WikiNodeLocalServiceUtil.addNode(\n\t\t\t\t\tnode.getUuid(), userId, node.getName(),\n\t\t\t\t\tnode.getDescription(), serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedNode = WikiNodeLocalServiceUtil.updateNode(\n\t\t\t\t\texistingNode.getNodeId(), node.getName(),\n\t\t\t\t\tnode.getDescription(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString nodeName = PropsUtil.get(PropsKeys.WIKI_INITIAL_NODE_NAME);\n\n\t\t\tif (node.getName().equals(nodeName)) {\n\t\t\t\ttry {\n\t\t\t\t\tWikiNodeUtil.removeByG_N(\n\t\t\t\t\t\tcontext.getGroupId(), node.getName());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchNodeException nsne) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\timportedNode = WikiNodeLocalServiceUtil.addNode(\n\t\t\t\tuserId, node.getName(), node.getDescription(), serviceContext);\n\t\t}\n\n\t\tnodePKs.put(node.getNodeId(), importedNode.getNodeId());\n\n\t\tcontext.importPermissions(\n\t\t\tWikiNode.class, node.getNodeId(), importedNode.getNodeId());\n\t}","commit_id":"e59c469b4926cd242b9306a90591726ae121c670","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void importPage(\n\t\t\tPortletDataContext context, Map<Long, Long> nodePKs, Element pageEl,\n\t\t\tWikiPage page)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(page.getUserUuid());\n\t\tlong nodeId = MapUtil.getLong(\n\t\t\tnodePKs, page.getNodeId(), page.getNodeId());\n\n\t\tlong[] assetCategoryIds = null;\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\tassetCategoryIds = context.getAssetCategoryIds(\n\t\t\t\tWikiPage.class, page.getResourcePrimKey());\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tWikiPage.class, page.getResourcePrimKey());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setCreateDate(page.getCreateDate());\n\t\tserviceContext.setModifiedDate(page.getModifiedDate());\n\n\t\tWikiPage existingPage = null;\n\n\t\ttry {\n\t\t\tWikiNodeUtil.findByPrimaryKey(nodeId);\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\ttry {\n\t\t\t\t\texistingPage = WikiPageUtil.findByUUID_G(\n\t\t\t\t\t\tpage.getUuid(), context.getGroupId());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchPageException nspe) {\n\t\t\t\t}\n\n\t\t\t\tif (existingPage == null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\texistingPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t\t\t\t\tnodeId, page.getTitle());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchPageException nspe) {\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (existingPage != null) {\n\t\t\t\t\texistingPage = WikiPageLocalServiceUtil.updatePage(\n\t\t\t\t\t\tuserId, nodeId, existingPage.getTitle(), 0,\n\t\t\t\t\t\tpage.getContent(), page.getSummary(), true,\n\t\t\t\t\t\tpage.getFormat(), page.getParentTitle(),\n\t\t\t\t\t\tpage.getRedirectTitle(), serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texistingPage = WikiPageLocalServiceUtil.addPage(\n\t\t\t\t\t\tpage.getUuid(), userId, nodeId, page.getTitle(),\n\t\t\t\t\t\tpage.getVersion(), page.getContent(), page.getSummary(),\n\t\t\t\t\t\ttrue, page.getFormat(), page.getHead(),\n\t\t\t\t\t\tpage.getParentTitle(), page.getRedirectTitle(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingPage = WikiPageLocalServiceUtil.addPage(\n\t\t\t\t\tnull, userId, nodeId, page.getTitle(), page.getVersion(),\n\t\t\t\t\tpage.getContent(), page.getSummary(), true,\n\t\t\t\t\tpage.getFormat(), page.getHead(), page.getParentTitle(),\n\t\t\t\t\tpage.getRedirectTitle(), serviceContext);\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"attachments\") &&\n\t\t\t\tpage.isHead()) {\n\n\t\t\t\tList<Element> attachmentEls = pageEl.elements(\"attachment\");\n\n\t\t\t\tList<ObjectValuePair<String, byte[]>> files =\n\t\t\t\t\tnew ArrayList<ObjectValuePair<String, byte[]>>();\n\n\t\t\t\tfor (Element attachmentEl : attachmentEls) {\n\t\t\t\t\tString name = attachmentEl.attributeValue(\"name\");\n\t\t\t\t\tString binPath = attachmentEl.attributeValue(\"bin-path\");\n\n\t\t\t\t\tbyte[] bytes = context.getZipEntryAsByteArray(binPath);\n\n\t\t\t\t\tfiles.add(new ObjectValuePair<String, byte[]>(name, bytes));\n\t\t\t\t}\n\n\t\t\t\tif (files.size() > 0) {\n\t\t\t\t\tWikiPageLocalServiceUtil.addPageAttachments(\n\t\t\t\t\t\tnodeId, page.getTitle(), files);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tWikiPage.class, page.getResourcePrimKey(),\n\t\t\t\texistingPage.getResourcePrimKey());\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\") &&\n\t\t\t\tpage.isHead()) {\n\n\t\t\t\tcontext.importComments(\n\t\t\t\t\tWikiPage.class, page.getResourcePrimKey(),\n\t\t\t\t\texistingPage.getResourcePrimKey(), context.getGroupId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\t\tcontext.importRatingsEntries(\n\t\t\t\t\tWikiPage.class, page.getResourcePrimKey(),\n\t\t\t\t\texistingPage.getResourcePrimKey());\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchNodeException nsne) {\n\t\t\t_log.error(\"Could not find the node for page \" + page.getPageId());\n\t\t}\n\t}","id":73956,"modified_method":"public static void importPage(\n\t\t\tPortletDataContext context, Map<Long, Long> nodePKs, Element pageEl,\n\t\t\tWikiPage page)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(page.getUserUuid());\n\t\tlong nodeId = MapUtil.getLong(\n\t\t\tnodePKs, page.getNodeId(), page.getNodeId());\n\n\t\tlong[] assetCategoryIds = null;\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\tassetCategoryIds = context.getAssetCategoryIds(\n\t\t\t\tWikiPage.class, page.getResourcePrimKey());\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tWikiPage.class, page.getResourcePrimKey());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setCreateDate(page.getCreateDate());\n\t\tserviceContext.setModifiedDate(page.getModifiedDate());\n\n\t\tWikiPage importedPage = null;\n\n\t\ttry {\n\t\t\tWikiNodeUtil.findByPrimaryKey(nodeId);\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\tWikiPage existingPage = WikiPageUtil.fetchByUUID_G(\n\t\t\t\t\tpage.getUuid(), context.getGroupId());\n\n\t\t\t\tif (existingPage == null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\texistingPage = WikiPageLocalServiceUtil.getPage(\n\t\t\t\t\t\t\tnodeId, page.getTitle());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NoSuchPageException nspe) {\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (existingPage == null) {\n\t\t\t\t\timportedPage = WikiPageLocalServiceUtil.addPage(\n\t\t\t\t\t\tpage.getUuid(), userId, nodeId, page.getTitle(),\n\t\t\t\t\t\tpage.getVersion(), page.getContent(), page.getSummary(),\n\t\t\t\t\t\ttrue, page.getFormat(), page.getHead(),\n\t\t\t\t\t\tpage.getParentTitle(), page.getRedirectTitle(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportedPage = WikiPageLocalServiceUtil.updatePage(\n\t\t\t\t\t\tuserId, nodeId, existingPage.getTitle(), 0,\n\t\t\t\t\t\tpage.getContent(), page.getSummary(), true,\n\t\t\t\t\t\tpage.getFormat(), page.getParentTitle(),\n\t\t\t\t\t\tpage.getRedirectTitle(), serviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedPage = WikiPageLocalServiceUtil.addPage(\n\t\t\t\t\tnull, userId, nodeId, page.getTitle(), page.getVersion(),\n\t\t\t\t\tpage.getContent(), page.getSummary(), true,\n\t\t\t\t\tpage.getFormat(), page.getHead(), page.getParentTitle(),\n\t\t\t\t\tpage.getRedirectTitle(), serviceContext);\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"attachments\") &&\n\t\t\t\tpage.isHead()) {\n\n\t\t\t\tList<Element> attachmentEls = pageEl.elements(\"attachment\");\n\n\t\t\t\tList<ObjectValuePair<String, byte[]>> files =\n\t\t\t\t\tnew ArrayList<ObjectValuePair<String, byte[]>>();\n\n\t\t\t\tfor (Element attachmentEl : attachmentEls) {\n\t\t\t\t\tString name = attachmentEl.attributeValue(\"name\");\n\t\t\t\t\tString binPath = attachmentEl.attributeValue(\"bin-path\");\n\n\t\t\t\t\tbyte[] bytes = context.getZipEntryAsByteArray(binPath);\n\n\t\t\t\t\tfiles.add(new ObjectValuePair<String, byte[]>(name, bytes));\n\t\t\t\t}\n\n\t\t\t\tif (files.size() > 0) {\n\t\t\t\t\tWikiPageLocalServiceUtil.addPageAttachments(\n\t\t\t\t\t\tnodeId, page.getTitle(), files);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tWikiPage.class, page.getResourcePrimKey(),\n\t\t\t\timportedPage.getResourcePrimKey());\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\") &&\n\t\t\t\tpage.isHead()) {\n\n\t\t\t\tcontext.importComments(\n\t\t\t\t\tWikiPage.class, page.getResourcePrimKey(),\n\t\t\t\t\timportedPage.getResourcePrimKey(), context.getGroupId());\n\t\t\t}\n\n\t\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\t\tcontext.importRatingsEntries(\n\t\t\t\t\tWikiPage.class, page.getResourcePrimKey(),\n\t\t\t\t\timportedPage.getResourcePrimKey());\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchNodeException nsne) {\n\t\t\t_log.error(\"Could not find the node for page \" + page.getPageId());\n\t\t}\n\t}","commit_id":"e59c469b4926cd242b9306a90591726ae121c670","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importEntry(PortletDataContext context, BlogsEntry entry)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(entry.getUserUuid());\n\n\t\tCalendar displayDateCal = CalendarFactoryUtil.getCalendar();\n\n\t\tdisplayDateCal.setTime(entry.getDisplayDate());\n\n\t\tint displayDateMonth = displayDateCal.get(Calendar.MONTH);\n\t\tint displayDateDay = displayDateCal.get(Calendar.DATE);\n\t\tint displayDateYear = displayDateCal.get(Calendar.YEAR);\n\t\tint displayDateHour = displayDateCal.get(Calendar.HOUR);\n\t\tint displayDateMinute = displayDateCal.get(Calendar.MINUTE);\n\n\t\tif (displayDateCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\tdisplayDateHour += 12;\n\t\t}\n\n\t\tint status = entry.getStatus();\n\t\tboolean allowPingbacks = entry.isAllowPingbacks();\n\t\tboolean allowTrackbacks = entry.isAllowTrackbacks();\n\t\tString[] trackbacks = StringUtil.split(entry.getTrackbacks());\n\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tBlogsEntry.class, entry.getEntryId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setCreateDate(entry.getCreateDate());\n\t\tserviceContext.setModifiedDate(entry.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(context.getGroupId());\n\t\tserviceContext.setStartWorkflow(false);\n\t\tserviceContext.setStatus(status);\n\n\t\tBlogsEntry existingEntry = null;\n\n\t\tif (context.getDataStrategy().equals(\n\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\texistingEntry = BlogsEntryUtil.fetchByUUID_G(\n\t\t\t\tentry.getUuid(), context.getGroupId());\n\n\t\t\tif (existingEntry == null) {\n\t\t\t\texistingEntry = BlogsEntryLocalServiceUtil.addEntry(\n\t\t\t\t\tentry.getUuid(), userId, entry.getTitle(),\n\t\t\t\t\tentry.getContent(), displayDateMonth, displayDateDay,\n\t\t\t\t\tdisplayDateYear, displayDateHour, displayDateMinute,\n\t\t\t\t\tallowPingbacks, allowTrackbacks, trackbacks,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingEntry = BlogsEntryLocalServiceUtil.updateEntry(\n\t\t\t\t\tuserId, existingEntry.getEntryId(), entry.getTitle(),\n\t\t\t\t\tentry.getContent(), displayDateMonth, displayDateDay,\n\t\t\t\t\tdisplayDateYear, displayDateHour, displayDateMinute,\n\t\t\t\t\tallowPingbacks, allowTrackbacks, trackbacks,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\texistingEntry = BlogsEntryLocalServiceUtil.addEntry(\n\t\t\t\tnull, userId, entry.getTitle(), entry.getContent(),\n\t\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\t\tdisplayDateHour, displayDateMinute, allowPingbacks,\n\t\t\t\tallowTrackbacks, trackbacks, serviceContext);\n\t\t}\n\n\t\tcontext.importPermissions(\n\t\t\tBlogsEntry.class, entry.getEntryId(), existingEntry.getEntryId());\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\tcontext.importComments(\n\t\t\t\tBlogsEntry.class, entry.getEntryId(),\n\t\t\t\texistingEntry.getEntryId(), context.getGroupId());\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\tcontext.importRatingsEntries(\n\t\t\t\tBlogsEntry.class, entry.getEntryId(),\n\t\t\t\texistingEntry.getEntryId());\n\t\t}\n\t}","id":73957,"modified_method":"protected void importEntry(PortletDataContext context, BlogsEntry entry)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(entry.getUserUuid());\n\n\t\tCalendar displayDateCal = CalendarFactoryUtil.getCalendar();\n\n\t\tdisplayDateCal.setTime(entry.getDisplayDate());\n\n\t\tint displayDateMonth = displayDateCal.get(Calendar.MONTH);\n\t\tint displayDateDay = displayDateCal.get(Calendar.DATE);\n\t\tint displayDateYear = displayDateCal.get(Calendar.YEAR);\n\t\tint displayDateHour = displayDateCal.get(Calendar.HOUR);\n\t\tint displayDateMinute = displayDateCal.get(Calendar.MINUTE);\n\n\t\tif (displayDateCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\tdisplayDateHour += 12;\n\t\t}\n\n\t\tint status = entry.getStatus();\n\t\tboolean allowPingbacks = entry.isAllowPingbacks();\n\t\tboolean allowTrackbacks = entry.isAllowTrackbacks();\n\t\tString[] trackbacks = StringUtil.split(entry.getTrackbacks());\n\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tBlogsEntry.class, entry.getEntryId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setCreateDate(entry.getCreateDate());\n\t\tserviceContext.setModifiedDate(entry.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(context.getGroupId());\n\t\tserviceContext.setStartWorkflow(false);\n\t\tserviceContext.setStatus(status);\n\n\t\tBlogsEntry importedEntry = null;\n\n\t\tif (context.getDataStrategy().equals(\n\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\tBlogsEntry existingEntry = BlogsEntryUtil.fetchByUUID_G(\n\t\t\t\tentry.getUuid(), context.getGroupId());\n\n\t\t\tif (existingEntry == null) {\n\t\t\t\timportedEntry = BlogsEntryLocalServiceUtil.addEntry(\n\t\t\t\t\tentry.getUuid(), userId, entry.getTitle(),\n\t\t\t\t\tentry.getContent(), displayDateMonth, displayDateDay,\n\t\t\t\t\tdisplayDateYear, displayDateHour, displayDateMinute,\n\t\t\t\t\tallowPingbacks, allowTrackbacks, trackbacks,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedEntry = BlogsEntryLocalServiceUtil.updateEntry(\n\t\t\t\t\tuserId, existingEntry.getEntryId(), entry.getTitle(),\n\t\t\t\t\tentry.getContent(), displayDateMonth, displayDateDay,\n\t\t\t\t\tdisplayDateYear, displayDateHour, displayDateMinute,\n\t\t\t\t\tallowPingbacks, allowTrackbacks, trackbacks,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedEntry = BlogsEntryLocalServiceUtil.addEntry(\n\t\t\t\tnull, userId, entry.getTitle(), entry.getContent(),\n\t\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\t\tdisplayDateHour, displayDateMinute, allowPingbacks,\n\t\t\t\tallowTrackbacks, trackbacks, serviceContext);\n\t\t}\n\n\t\tcontext.importPermissions(\n\t\t\tBlogsEntry.class, entry.getEntryId(), importedEntry.getEntryId());\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\tcontext.importComments(\n\t\t\t\tBlogsEntry.class, entry.getEntryId(),\n\t\t\t\timportedEntry.getEntryId(), context.getGroupId());\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\tcontext.importRatingsEntries(\n\t\t\t\tBlogsEntry.class, entry.getEntryId(),\n\t\t\t\timportedEntry.getEntryId());\n\t\t}\n\t}","commit_id":"9c9d1a0fa3b8968ac0e5cf02793b1c2e4e90b776","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importFolder(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tBookmarksFolder folder)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(folder.getUserUuid());\n\t\tlong parentFolderId = MapUtil.getLong(\n\t\t\tfolderPKs, folder.getParentFolderId(), folder.getParentFolderId());\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setCreateDate(folder.getCreateDate());\n\t\tserviceContext.setModifiedDate(folder.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(context.getScopeGroupId());\n\n\t\tif ((parentFolderId !=\n\t\t\t\tBookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(parentFolderId == folder.getParentFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, parentFolderId);\n\n\t\t\tBookmarksFolder parentFolder =\n\t\t\t\t(BookmarksFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, parentFolder);\n\n\t\t\tparentFolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, folder.getParentFolderId(),\n\t\t\t\tfolder.getParentFolderId());\n\t\t}\n\n\t\tBookmarksFolder existingFolder = null;\n\n\t\ttry {\n\t\t\tif (parentFolderId !=\n\t\t\t\tBookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\t\tBookmarksFolderUtil.findByPrimaryKey(parentFolderId);\n\t\t\t}\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\t\t\t\texistingFolder = BookmarksFolderUtil.fetchByUUID_G(\n\t\t\t\t\tfolder.getUuid(), context.getGroupId());\n\n\t\t\t\tif (existingFolder == null) {\n\t\t\t\t\texistingFolder = BookmarksFolderLocalServiceUtil.addFolder(\n\t\t\t\t\t\tfolder.getUuid(), userId, parentFolderId,\n\t\t\t\t\t\tfolder.getName(), folder.getDescription(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texistingFolder =\n\t\t\t\t\t\tBookmarksFolderLocalServiceUtil.updateFolder(\n\t\t\t\t\t\t\texistingFolder.getFolderId(), parentFolderId,\n\t\t\t\t\t\t\tfolder.getName(), folder.getDescription(), false,\n\t\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingFolder = BookmarksFolderLocalServiceUtil.addFolder(\n\t\t\t\t\tnull, userId, parentFolderId, folder.getName(),\n\t\t\t\t\tfolder.getDescription(), serviceContext);\n\t\t\t}\n\n\t\t\tfolderPKs.put(folder.getFolderId(), existingFolder.getFolderId());\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tBookmarksFolder.class, folder.getFolderId(),\n\t\t\t\texistingFolder.getFolderId());\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for folder \" +\n\t\t\t\t\tfolder.getFolderId());\n\t\t}\n\t}","id":73958,"modified_method":"protected void importFolder(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tBookmarksFolder folder)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(folder.getUserUuid());\n\t\tlong parentFolderId = MapUtil.getLong(\n\t\t\tfolderPKs, folder.getParentFolderId(), folder.getParentFolderId());\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setCreateDate(folder.getCreateDate());\n\t\tserviceContext.setModifiedDate(folder.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(context.getScopeGroupId());\n\n\t\tif ((parentFolderId !=\n\t\t\t\tBookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(parentFolderId == folder.getParentFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, parentFolderId);\n\n\t\t\tBookmarksFolder parentFolder =\n\t\t\t\t(BookmarksFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, parentFolder);\n\n\t\t\tparentFolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, folder.getParentFolderId(),\n\t\t\t\tfolder.getParentFolderId());\n\t\t}\n\n\t\tBookmarksFolder importedFolder = null;\n\n\t\ttry {\n\t\t\tif (parentFolderId !=\n\t\t\t\tBookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\t\tBookmarksFolderUtil.findByPrimaryKey(parentFolderId);\n\t\t\t}\n\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\tBookmarksFolder existingFolder =\n\t\t\t\t\tBookmarksFolderUtil.fetchByUUID_G(\n\t\t\t\t\t\tfolder.getUuid(), context.getGroupId());\n\n\t\t\t\tif (existingFolder == null) {\n\t\t\t\t\timportedFolder = BookmarksFolderLocalServiceUtil.addFolder(\n\t\t\t\t\t\tfolder.getUuid(), userId, parentFolderId,\n\t\t\t\t\t\tfolder.getName(), folder.getDescription(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportedFolder =\n\t\t\t\t\t\tBookmarksFolderLocalServiceUtil.updateFolder(\n\t\t\t\t\t\t\texistingFolder.getFolderId(), parentFolderId,\n\t\t\t\t\t\t\tfolder.getName(), folder.getDescription(), false,\n\t\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedFolder = BookmarksFolderLocalServiceUtil.addFolder(\n\t\t\t\t\tnull, userId, parentFolderId, folder.getName(),\n\t\t\t\t\tfolder.getDescription(), serviceContext);\n\t\t\t}\n\n\t\t\tfolderPKs.put(folder.getFolderId(), importedFolder.getFolderId());\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tBookmarksFolder.class, folder.getFolderId(),\n\t\t\t\timportedFolder.getFolderId());\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for folder \" +\n\t\t\t\t\tfolder.getFolderId());\n\t\t}\n\t}","commit_id":"9c9d1a0fa3b8968ac0e5cf02793b1c2e4e90b776","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importEntry(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tBookmarksEntry entry)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(entry.getUserUuid());\n\t\tlong groupId = context.getGroupId();\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, entry.getFolderId(), entry.getFolderId());\n\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tBookmarksEntry.class, entry.getEntryId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setCreateDate(entry.getCreateDate());\n\t\tserviceContext.setModifiedDate(entry.getModifiedDate());\n\n\t\tif ((folderId != BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == entry.getFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, folderId);\n\n\t\t\tBookmarksFolder folder =\n\t\t\t\t(BookmarksFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, entry.getFolderId(), entry.getFolderId());\n\t\t}\n\n\t\tBookmarksEntry existingEntry = null;\n\n\t\ttry {\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\ttry {\n\t\t\t\t\texistingEntry = BookmarksEntryUtil.findByUUID_G(\n\t\t\t\t\t\tentry.getUuid(), groupId);\n\n\t\t\t\t\texistingEntry = BookmarksEntryLocalServiceUtil.updateEntry(\n\t\t\t\t\t\tuserId, existingEntry.getEntryId(), groupId, folderId,\n\t\t\t\t\t\tentry.getName(), entry.getUrl(), entry.getComments(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchEntryException nsee) {\n\t\t\t\t\texistingEntry = BookmarksEntryLocalServiceUtil.addEntry(\n\t\t\t\t\t\tentry.getUuid(), userId, groupId, folderId,\n\t\t\t\t\t\tentry.getName(), entry.getUrl(), entry.getComments(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingEntry = BookmarksEntryLocalServiceUtil.addEntry(\n\t\t\t\t\tnull, userId, groupId, folderId, entry.getName(),\n\t\t\t\t\tentry.getUrl(), entry.getComments(), serviceContext);\n\t\t\t}\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tBookmarksEntry.class, entry.getEntryId(),\n\t\t\t\texistingEntry.getEntryId());\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for entry \" +\n\t\t\t\t\tentry.getEntryId());\n\t\t}\n\t}","id":73959,"modified_method":"protected void importEntry(\n\t\t\tPortletDataContext context, Map<Long, Long> folderPKs,\n\t\t\tBookmarksEntry entry)\n\t\tthrows Exception {\n\n\t\tlong userId = context.getUserId(entry.getUserUuid());\n\t\tlong groupId = context.getGroupId();\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderPKs, entry.getFolderId(), entry.getFolderId());\n\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tBookmarksEntry.class, entry.getEntryId());\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setCreateDate(entry.getCreateDate());\n\t\tserviceContext.setModifiedDate(entry.getModifiedDate());\n\n\t\tif ((folderId != BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) &&\n\t\t\t(folderId == entry.getFolderId())) {\n\n\t\t\tString path = getImportFolderPath(context, folderId);\n\n\t\t\tBookmarksFolder folder =\n\t\t\t\t(BookmarksFolder)context.getZipEntryAsObject(path);\n\n\t\t\timportFolder(context, folderPKs, folder);\n\n\t\t\tfolderId = MapUtil.getLong(\n\t\t\t\tfolderPKs, entry.getFolderId(), entry.getFolderId());\n\t\t}\n\n\t\tBookmarksEntry importedEntry = null;\n\n\t\ttry {\n\t\t\tif (context.getDataStrategy().equals(\n\t\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\t\tBookmarksEntry existingEntry = BookmarksEntryUtil.fetchByUUID_G(\n\t\t\t\t\tentry.getUuid(), groupId);\n\n\t\t\t\tif (existingEntry == null) {\n\t\t\t\t\timportedEntry = BookmarksEntryLocalServiceUtil.addEntry(\n\t\t\t\t\t\tentry.getUuid(), userId, groupId, folderId,\n\t\t\t\t\t\tentry.getName(), entry.getUrl(), entry.getComments(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportedEntry = BookmarksEntryLocalServiceUtil.updateEntry(\n\t\t\t\t\t\tuserId, existingEntry.getEntryId(), groupId, folderId,\n\t\t\t\t\t\tentry.getName(), entry.getUrl(), entry.getComments(),\n\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedEntry = BookmarksEntryLocalServiceUtil.addEntry(\n\t\t\t\t\tnull, userId, groupId, folderId, entry.getName(),\n\t\t\t\t\tentry.getUrl(), entry.getComments(), serviceContext);\n\t\t\t}\n\n\t\t\tcontext.importPermissions(\n\t\t\t\tBookmarksEntry.class, entry.getEntryId(),\n\t\t\t\timportedEntry.getEntryId());\n\t\t}\n\t\tcatch (NoSuchFolderException nsfe) {\n\t\t\t_log.error(\n\t\t\t\t\"Could not find the parent folder for entry \" +\n\t\t\t\t\tentry.getEntryId());\n\t\t}\n\t}","commit_id":"9c9d1a0fa3b8968ac0e5cf02793b1c2e4e90b776","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void importArticle(\n\t\t\tPortletDataContext context, Map<String, String> structureIds,\n\t\t\tMap<String, String> templateIds, Map<String, String> articleIds,\n\t\t\tElement articleEl)\n\t\tthrows Exception {\n\n\t\tString path = articleEl.attributeValue(\"path\");\n\n\t\tif (!context.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tJournalArticle article = (JournalArticle)context.getZipEntryAsObject(\n\t\t\tpath);\n\n\t\tlong userId = context.getUserId(article.getUserUuid());\n\n\t\tUser user = UserLocalServiceUtil.getUser(userId);\n\n\t\tlong groupId = context.getGroupId();\n\n\t\tString articleId = article.getArticleId();\n\t\tboolean autoArticleId = false;\n\n\t\tif ((Validator.isNumber(articleId)) ||\n\t\t\t(JournalArticleUtil.fetchByG_A_V(\n\t\t\t\tgroupId, articleId,\n\t\t\t\t\tJournalArticleConstants.DEFAULT_VERSION) != null)) {\n\n\t\t\tautoArticleId = true;\n\t\t}\n\n\t\tString newArticleId = articleIds.get(articleId);\n\n\t\tif (Validator.isNotNull(newArticleId)) {\n\n\t\t\t// A sibling of a different version was already assigned a new\n\t\t\t// article id\n\n\t\t\tarticleId = newArticleId;\n\t\t\tautoArticleId = false;\n\t\t}\n\n\t\tboolean incrementVersion = false;\n\n\t\tString content = article.getContent();\n\n\t\tarticle.setContent(\n\t\t\tStringUtil.replace(\n\t\t\t\tcontent, \"@data_handler_group_id@\", String.valueOf(groupId)));\n\n\t\tString parentStructureId = MapUtil.getString(\n\t\t\tstructureIds, article.getStructureId(), article.getStructureId());\n\t\tString parentTemplateId = MapUtil.getString(\n\t\t\ttemplateIds, article.getTemplateId(), article.getTemplateId());\n\n\t\tDate displayDate = article.getDisplayDate();\n\n\t\tint displayDateMonth = 0;\n\t\tint displayDateDay = 0;\n\t\tint displayDateYear = 0;\n\t\tint displayDateHour = 0;\n\t\tint displayDateMinute = 0;\n\n\t\tif (displayDate != null) {\n\t\t\tCalendar displayCal = CalendarFactoryUtil.getCalendar(\n\t\t\t\tuser.getTimeZone());\n\n\t\t\tdisplayCal.setTime(displayDate);\n\n\t\t\tdisplayDateMonth = displayCal.get(Calendar.MONTH);\n\t\t\tdisplayDateDay = displayCal.get(Calendar.DATE);\n\t\t\tdisplayDateYear = displayCal.get(Calendar.YEAR);\n\t\t\tdisplayDateHour = displayCal.get(Calendar.HOUR);\n\t\t\tdisplayDateMinute = displayCal.get(Calendar.MINUTE);\n\n\t\t\tif (displayCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\tdisplayDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tDate expirationDate = article.getExpirationDate();\n\n\t\tint expirationDateMonth = 0;\n\t\tint expirationDateDay = 0;\n\t\tint expirationDateYear = 0;\n\t\tint expirationDateHour = 0;\n\t\tint expirationDateMinute = 0;\n\t\tboolean neverExpire = true;\n\n\t\tif (expirationDate != null) {\n\t\t\tCalendar expirationCal = CalendarFactoryUtil.getCalendar(\n\t\t\t\tuser.getTimeZone());\n\n\t\t\texpirationCal.setTime(expirationDate);\n\n\t\t\texpirationDateMonth = expirationCal.get(Calendar.MONTH);\n\t\t\texpirationDateDay = expirationCal.get(Calendar.DATE);\n\t\t\texpirationDateYear = expirationCal.get(Calendar.YEAR);\n\t\t\texpirationDateHour = expirationCal.get(Calendar.HOUR);\n\t\t\texpirationDateMinute = expirationCal.get(Calendar.MINUTE);\n\t\t\tneverExpire = false;\n\n\t\t\tif (expirationCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\texpirationDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tDate reviewDate = article.getReviewDate();\n\n\t\tint reviewDateMonth = 0;\n\t\tint reviewDateDay = 0;\n\t\tint reviewDateYear = 0;\n\t\tint reviewDateHour = 0;\n\t\tint reviewDateMinute = 0;\n\t\tboolean neverReview = true;\n\n\t\tif (reviewDate != null) {\n\t\t\tCalendar reviewCal = CalendarFactoryUtil.getCalendar(\n\t\t\t\tuser.getTimeZone());\n\n\t\t\treviewCal.setTime(reviewDate);\n\n\t\t\treviewDateMonth = reviewCal.get(Calendar.MONTH);\n\t\t\treviewDateDay = reviewCal.get(Calendar.DATE);\n\t\t\treviewDateYear = reviewCal.get(Calendar.YEAR);\n\t\t\treviewDateHour = reviewCal.get(Calendar.HOUR);\n\t\t\treviewDateMinute = reviewCal.get(Calendar.MINUTE);\n\t\t\tneverReview = false;\n\n\t\t\tif (reviewCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\treviewDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tFile smallFile = null;\n\n\t\tString smallImagePath = articleEl.attributeValue(\"small-image-path\");\n\n\t\tif (article.isSmallImage() && Validator.isNotNull(smallImagePath)) {\n\t\t\tbyte[] bytes = context.getZipEntryAsByteArray(smallImagePath);\n\n\t\t\tsmallFile = File.createTempFile(\n\t\t\t\tString.valueOf(article.getSmallImageId()),\n\t\t\t\tStringPool.PERIOD + article.getSmallImageType());\n\n\t\t\tFileUtil.write(smallFile, bytes);\n\t\t}\n\n\t\tMap<String, byte[]> images = new HashMap<String, byte[]>();\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"images\")) {\n\t\t\tString imagePath = articleEl.attributeValue(\"image-path\");\n\n\t\t\tList<String> imageFiles = context.getZipFolderEntries(imagePath);\n\n\t\t\tfor (String imageFile : imageFiles) {\n\t\t\t\tString fileName = imageFile;\n\n\t\t\t\tif (fileName.contains(StringPool.SLASH)) {\n\t\t\t\t\tfileName = fileName.substring(\n\t\t\t\t\t\tfileName.lastIndexOf(StringPool.SLASH) + 1);\n\t\t\t\t}\n\n\t\t\t\tif (fileName.endsWith(\".xml\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint pos = fileName.lastIndexOf(StringPool.PERIOD);\n\n\t\t\t\tif (pos != -1) {\n\t\t\t\t\tfileName = fileName.substring(0, pos);\n\t\t\t\t}\n\n\t\t\t\timages.put(fileName, context.getZipEntryAsByteArray(imageFile));\n\t\t\t}\n\t\t}\n\n\t\tString articleURL = null;\n\n\t\tlong[] assetCategoryIds = null;\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\tassetCategoryIds = context.getAssetCategoryIds(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\t\t}\n\n\t\tJournalCreationStrategy creationStrategy =\n\t\t\tJournalCreationStrategyFactory.getInstance();\n\n\t\tlong authorId = creationStrategy.getAuthorUserId(context, article);\n\n\t\tif (authorId != JournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) {\n\t\t\tuserId = authorId;\n\t\t}\n\n\t\tString newContent = creationStrategy.getTransformedContent(\n\t\t\tcontext, article);\n\n\t\tif (newContent != JournalCreationStrategy.ARTICLE_CONTENT_UNCHANGED) {\n\t\t\tarticle.setContent(newContent);\n\t\t}\n\n\t\tboolean addCommunityPermissions =\n\t\t\tcreationStrategy.addCommunityPermissions(context, article);\n\t\tboolean addGuestPermissions = creationStrategy.addGuestPermissions(\n\t\t\tcontext, article);\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(addCommunityPermissions);\n\t\tserviceContext.setAddGuestPermissions(addGuestPermissions);\n\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setCreateDate(article.getCreateDate());\n\t\tserviceContext.setModifiedDate(article.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(groupId);\n\t\tserviceContext.setStatus(article.getStatus());\n\t\tserviceContext.setStartWorkflow(false);\n\n\t\tJournalArticle existingArticle = null;\n\t\tJournalArticle importedArticle = null;\n\n\t\tif (Validator.isNotNull(article.getStructureId())) {\n\t\t\tJournalStructure structure = JournalStructureUtil.fetchByG_S(\n\t\t\t\tcontext.getGroupId(), article.getStructureId());\n\n\t\t\tif (structure == null) {\n\t\t\t\tString structurePath = getImportStructurePath(\n\t\t\t\t\tcontext, article.getStructureId());\n\n\t\t\t\timportStructure(context, structureIds, structurePath);\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNotNull(article.getTemplateId())) {\n\t\t\tJournalTemplate template = JournalTemplateUtil.fetchByG_T(\n\t\t\t\tcontext.getGroupId(), article.getTemplateId());\n\n\t\t\tif (template == null) {\n\t\t\t\tString templatePath = getImportTemplatePath(\n\t\t\t\t\tcontext, article.getTemplateId());\n\n\t\t\t\tString templateSmallImagePath = getImportTemplateSmallImagePath(\n\t\t\t\t\tcontext, article.getTemplateId());\n\n\t\t\t\timportTemplate(\n\t\t\t\t\tcontext, structureIds, templateIds, templateSmallImagePath,\n\t\t\t\t\ttemplatePath);\n\t\t\t}\n\t\t}\n\n\t\tif (context.getDataStrategy().equals(\n\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\texistingArticle = JournalArticleUtil.fetchByUUID_G(\n\t\t\t\tarticle.getUuid(), groupId);\n\n\t\t\tif (existingArticle == null) {\n\t\t\t\timportedArticle = JournalArticleLocalServiceUtil.addArticle(\n\t\t\t\t\tarticle.getUuid(), userId, groupId, articleId,\n\t\t\t\t\tautoArticleId, article.getVersion(), article.getTitle(),\n\t\t\t\t\tarticle.getDescription(), article.getContent(),\n\t\t\t\t\tarticle.getType(), parentStructureId, parentTemplateId,\n\t\t\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\t\t\tdisplayDateHour, displayDateMinute, expirationDateMonth,\n\t\t\t\t\texpirationDateDay, expirationDateYear, expirationDateHour,\n\t\t\t\t\texpirationDateMinute, neverExpire, reviewDateMonth,\n\t\t\t\t\treviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\t\treviewDateMinute, neverReview, article.isIndexable(),\n\t\t\t\t\tarticle.isSmallImage(), article.getSmallImageURL(),\n\t\t\t\t\tsmallFile, images, articleURL, serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedArticle = JournalArticleLocalServiceUtil.updateArticle(\n\t\t\t\t\tuserId, existingArticle.getGroupId(),\n\t\t\t\t\texistingArticle.getArticleId(),\n\t\t\t\t\texistingArticle.getVersion(), incrementVersion,\n\t\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\t\tarticle.getContent(), article.getType(), parentStructureId,\n\t\t\t\t\tparentTemplateId, displayDateMonth, displayDateDay,\n\t\t\t\t\tdisplayDateYear, displayDateHour, displayDateMinute,\n\t\t\t\t\texpirationDateMonth, expirationDateDay, expirationDateYear,\n\t\t\t\t\texpirationDateHour, expirationDateMinute, neverExpire,\n\t\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear,\n\t\t\t\t\treviewDateHour,\treviewDateMinute, neverReview,\n\t\t\t\t\tarticle.isIndexable(),\tarticle.isSmallImage(),\n\t\t\t\t\tarticle.getSmallImageURL(), smallFile, images, articleURL,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedArticle = JournalArticleLocalServiceUtil.addArticle(\n\t\t\t\tuserId, groupId, articleId, autoArticleId, article.getVersion(),\n\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\tarticle.getContent(), article.getType(), parentStructureId,\n\t\t\t\tparentTemplateId, displayDateMonth, displayDateDay,\n\t\t\t\tdisplayDateYear, displayDateHour, displayDateMinute,\n\t\t\t\texpirationDateMonth, expirationDateDay, expirationDateYear,\n\t\t\t\texpirationDateHour, expirationDateMinute, neverExpire,\n\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\treviewDateMinute, neverReview, article.isIndexable(),\n\t\t\t\tarticle.isSmallImage(), article.getSmallImageURL(), smallFile,\n\t\t\t\timages, articleURL, serviceContext);\n\t\t}\n\n\t\tcontext.importPermissions(\n\t\t\tJournalArticle.class, article.getResourcePrimKey(),\n\t\t\timportedArticle.getResourcePrimKey());\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\tcontext.importComments(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey(),\n\t\t\t\timportedArticle.getResourcePrimKey(), groupId);\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\tcontext.importRatingsEntries(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey(),\n\t\t\t\timportedArticle.getResourcePrimKey());\n\t\t}\n\n\t\tarticleIds.put(articleId, importedArticle.getArticleId());\n\n\t\tif (!articleId.equals(importedArticle.getArticleId())) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"An article with the ID \" + articleId + \" already \" +\n\t\t\t\t\t\t\"exists. The new generated ID is \" +\n\t\t\t\t\t\t\timportedArticle.getArticleId());\n\t\t\t}\n\t\t}\n\t}","id":73960,"modified_method":"public static void importArticle(\n\t\t\tPortletDataContext context, Map<String, String> structureIds,\n\t\t\tMap<String, String> templateIds, Map<String, String> articleIds,\n\t\t\tElement articleEl)\n\t\tthrows Exception {\n\n\t\tString path = articleEl.attributeValue(\"path\");\n\n\t\tif (!context.isPathNotProcessed(path)) {\n\t\t\treturn;\n\t\t}\n\n\t\tJournalArticle article = (JournalArticle)context.getZipEntryAsObject(\n\t\t\tpath);\n\n\t\tlong userId = context.getUserId(article.getUserUuid());\n\n\t\tUser user = UserLocalServiceUtil.getUser(userId);\n\n\t\tlong groupId = context.getGroupId();\n\n\t\tString articleId = article.getArticleId();\n\t\tboolean autoArticleId = false;\n\n\t\tif ((Validator.isNumber(articleId)) ||\n\t\t\t(JournalArticleUtil.fetchByG_A_V(\n\t\t\t\tgroupId, articleId,\n\t\t\t\t\tJournalArticleConstants.DEFAULT_VERSION) != null)) {\n\n\t\t\tautoArticleId = true;\n\t\t}\n\n\t\tString newArticleId = articleIds.get(articleId);\n\n\t\tif (Validator.isNotNull(newArticleId)) {\n\n\t\t\t// A sibling of a different version was already assigned a new\n\t\t\t// article id\n\n\t\t\tarticleId = newArticleId;\n\t\t\tautoArticleId = false;\n\t\t}\n\n\t\tboolean incrementVersion = false;\n\n\t\tString content = article.getContent();\n\n\t\tarticle.setContent(\n\t\t\tStringUtil.replace(\n\t\t\t\tcontent, \"@data_handler_group_id@\", String.valueOf(groupId)));\n\n\t\tString parentStructureId = MapUtil.getString(\n\t\t\tstructureIds, article.getStructureId(), article.getStructureId());\n\t\tString parentTemplateId = MapUtil.getString(\n\t\t\ttemplateIds, article.getTemplateId(), article.getTemplateId());\n\n\t\tDate displayDate = article.getDisplayDate();\n\n\t\tint displayDateMonth = 0;\n\t\tint displayDateDay = 0;\n\t\tint displayDateYear = 0;\n\t\tint displayDateHour = 0;\n\t\tint displayDateMinute = 0;\n\n\t\tif (displayDate != null) {\n\t\t\tCalendar displayCal = CalendarFactoryUtil.getCalendar(\n\t\t\t\tuser.getTimeZone());\n\n\t\t\tdisplayCal.setTime(displayDate);\n\n\t\t\tdisplayDateMonth = displayCal.get(Calendar.MONTH);\n\t\t\tdisplayDateDay = displayCal.get(Calendar.DATE);\n\t\t\tdisplayDateYear = displayCal.get(Calendar.YEAR);\n\t\t\tdisplayDateHour = displayCal.get(Calendar.HOUR);\n\t\t\tdisplayDateMinute = displayCal.get(Calendar.MINUTE);\n\n\t\t\tif (displayCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\tdisplayDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tDate expirationDate = article.getExpirationDate();\n\n\t\tint expirationDateMonth = 0;\n\t\tint expirationDateDay = 0;\n\t\tint expirationDateYear = 0;\n\t\tint expirationDateHour = 0;\n\t\tint expirationDateMinute = 0;\n\t\tboolean neverExpire = true;\n\n\t\tif (expirationDate != null) {\n\t\t\tCalendar expirationCal = CalendarFactoryUtil.getCalendar(\n\t\t\t\tuser.getTimeZone());\n\n\t\t\texpirationCal.setTime(expirationDate);\n\n\t\t\texpirationDateMonth = expirationCal.get(Calendar.MONTH);\n\t\t\texpirationDateDay = expirationCal.get(Calendar.DATE);\n\t\t\texpirationDateYear = expirationCal.get(Calendar.YEAR);\n\t\t\texpirationDateHour = expirationCal.get(Calendar.HOUR);\n\t\t\texpirationDateMinute = expirationCal.get(Calendar.MINUTE);\n\t\t\tneverExpire = false;\n\n\t\t\tif (expirationCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\texpirationDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tDate reviewDate = article.getReviewDate();\n\n\t\tint reviewDateMonth = 0;\n\t\tint reviewDateDay = 0;\n\t\tint reviewDateYear = 0;\n\t\tint reviewDateHour = 0;\n\t\tint reviewDateMinute = 0;\n\t\tboolean neverReview = true;\n\n\t\tif (reviewDate != null) {\n\t\t\tCalendar reviewCal = CalendarFactoryUtil.getCalendar(\n\t\t\t\tuser.getTimeZone());\n\n\t\t\treviewCal.setTime(reviewDate);\n\n\t\t\treviewDateMonth = reviewCal.get(Calendar.MONTH);\n\t\t\treviewDateDay = reviewCal.get(Calendar.DATE);\n\t\t\treviewDateYear = reviewCal.get(Calendar.YEAR);\n\t\t\treviewDateHour = reviewCal.get(Calendar.HOUR);\n\t\t\treviewDateMinute = reviewCal.get(Calendar.MINUTE);\n\t\t\tneverReview = false;\n\n\t\t\tif (reviewCal.get(Calendar.AM_PM) == Calendar.PM) {\n\t\t\t\treviewDateHour += 12;\n\t\t\t}\n\t\t}\n\n\t\tFile smallFile = null;\n\n\t\tString smallImagePath = articleEl.attributeValue(\"small-image-path\");\n\n\t\tif (article.isSmallImage() && Validator.isNotNull(smallImagePath)) {\n\t\t\tbyte[] bytes = context.getZipEntryAsByteArray(smallImagePath);\n\n\t\t\tsmallFile = File.createTempFile(\n\t\t\t\tString.valueOf(article.getSmallImageId()),\n\t\t\t\tStringPool.PERIOD + article.getSmallImageType());\n\n\t\t\tFileUtil.write(smallFile, bytes);\n\t\t}\n\n\t\tMap<String, byte[]> images = new HashMap<String, byte[]>();\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"images\")) {\n\t\t\tString imagePath = articleEl.attributeValue(\"image-path\");\n\n\t\t\tList<String> imageFiles = context.getZipFolderEntries(imagePath);\n\n\t\t\tfor (String imageFile : imageFiles) {\n\t\t\t\tString fileName = imageFile;\n\n\t\t\t\tif (fileName.contains(StringPool.SLASH)) {\n\t\t\t\t\tfileName = fileName.substring(\n\t\t\t\t\t\tfileName.lastIndexOf(StringPool.SLASH) + 1);\n\t\t\t\t}\n\n\t\t\t\tif (fileName.endsWith(\".xml\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint pos = fileName.lastIndexOf(StringPool.PERIOD);\n\n\t\t\t\tif (pos != -1) {\n\t\t\t\t\tfileName = fileName.substring(0, pos);\n\t\t\t\t}\n\n\t\t\t\timages.put(fileName, context.getZipEntryAsByteArray(imageFile));\n\t\t\t}\n\t\t}\n\n\t\tString articleURL = null;\n\n\t\tlong[] assetCategoryIds = null;\n\t\tString[] assetTagNames = null;\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"categories\")) {\n\t\t\tassetCategoryIds = context.getAssetCategoryIds(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"tags\")) {\n\t\t\tassetTagNames = context.getAssetTagNames(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey());\n\t\t}\n\n\t\tJournalCreationStrategy creationStrategy =\n\t\t\tJournalCreationStrategyFactory.getInstance();\n\n\t\tlong authorId = creationStrategy.getAuthorUserId(context, article);\n\n\t\tif (authorId != JournalCreationStrategy.USE_DEFAULT_USER_ID_STRATEGY) {\n\t\t\tuserId = authorId;\n\t\t}\n\n\t\tString newContent = creationStrategy.getTransformedContent(\n\t\t\tcontext, article);\n\n\t\tif (newContent != JournalCreationStrategy.ARTICLE_CONTENT_UNCHANGED) {\n\t\t\tarticle.setContent(newContent);\n\t\t}\n\n\t\tboolean addCommunityPermissions =\n\t\t\tcreationStrategy.addCommunityPermissions(context, article);\n\t\tboolean addGuestPermissions = creationStrategy.addGuestPermissions(\n\t\t\tcontext, article);\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setAddCommunityPermissions(addCommunityPermissions);\n\t\tserviceContext.setAddGuestPermissions(addGuestPermissions);\n\t\tserviceContext.setAssetCategoryIds(assetCategoryIds);\n\t\tserviceContext.setAssetTagNames(assetTagNames);\n\t\tserviceContext.setCreateDate(article.getCreateDate());\n\t\tserviceContext.setModifiedDate(article.getModifiedDate());\n\t\tserviceContext.setScopeGroupId(groupId);\n\t\tserviceContext.setStartWorkflow(false);\n\t\tserviceContext.setStatus(article.getStatus());\n\n\t\tJournalArticle importedArticle = null;\n\n\t\tif (Validator.isNotNull(article.getStructureId())) {\n\t\t\tJournalStructure structure = JournalStructureUtil.fetchByG_S(\n\t\t\t\tcontext.getGroupId(), article.getStructureId());\n\n\t\t\tif (structure == null) {\n\t\t\t\tString structurePath = getImportStructurePath(\n\t\t\t\t\tcontext, article.getStructureId());\n\n\t\t\t\timportStructure(context, structureIds, structurePath);\n\t\t\t}\n\t\t}\n\n\t\tif (Validator.isNotNull(article.getTemplateId())) {\n\t\t\tJournalTemplate template = JournalTemplateUtil.fetchByG_T(\n\t\t\t\tcontext.getGroupId(), article.getTemplateId());\n\n\t\t\tif (template == null) {\n\t\t\t\tString templatePath = getImportTemplatePath(\n\t\t\t\t\tcontext, article.getTemplateId());\n\n\t\t\t\tString templateSmallImagePath = getImportTemplateSmallImagePath(\n\t\t\t\t\tcontext, article.getTemplateId());\n\n\t\t\t\timportTemplate(\n\t\t\t\t\tcontext, structureIds, templateIds, templateSmallImagePath,\n\t\t\t\t\ttemplatePath);\n\t\t\t}\n\t\t}\n\n\t\tif (context.getDataStrategy().equals(\n\t\t\t\tPortletDataHandlerKeys.DATA_STRATEGY_MIRROR)) {\n\n\t\t\tJournalArticle existingArticle = JournalArticleUtil.fetchByUUID_G(\n\t\t\t\tarticle.getUuid(), groupId);\n\n\t\t\tif (existingArticle == null) {\n\t\t\t\timportedArticle = JournalArticleLocalServiceUtil.addArticle(\n\t\t\t\t\tarticle.getUuid(), userId, groupId, articleId,\n\t\t\t\t\tautoArticleId, article.getVersion(), article.getTitle(),\n\t\t\t\t\tarticle.getDescription(), article.getContent(),\n\t\t\t\t\tarticle.getType(), parentStructureId, parentTemplateId,\n\t\t\t\t\tdisplayDateMonth, displayDateDay, displayDateYear,\n\t\t\t\t\tdisplayDateHour, displayDateMinute, expirationDateMonth,\n\t\t\t\t\texpirationDateDay, expirationDateYear, expirationDateHour,\n\t\t\t\t\texpirationDateMinute, neverExpire, reviewDateMonth,\n\t\t\t\t\treviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\t\treviewDateMinute, neverReview, article.isIndexable(),\n\t\t\t\t\tarticle.isSmallImage(), article.getSmallImageURL(),\n\t\t\t\t\tsmallFile, images, articleURL, serviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedArticle = JournalArticleLocalServiceUtil.updateArticle(\n\t\t\t\t\tuserId, existingArticle.getGroupId(),\n\t\t\t\t\texistingArticle.getArticleId(),\n\t\t\t\t\texistingArticle.getVersion(), incrementVersion,\n\t\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\t\tarticle.getContent(), article.getType(), parentStructureId,\n\t\t\t\t\tparentTemplateId, displayDateMonth, displayDateDay,\n\t\t\t\t\tdisplayDateYear, displayDateHour, displayDateMinute,\n\t\t\t\t\texpirationDateMonth, expirationDateDay, expirationDateYear,\n\t\t\t\t\texpirationDateHour, expirationDateMinute, neverExpire,\n\t\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear,\n\t\t\t\t\treviewDateHour,\treviewDateMinute, neverReview,\n\t\t\t\t\tarticle.isIndexable(),\tarticle.isSmallImage(),\n\t\t\t\t\tarticle.getSmallImageURL(), smallFile, images, articleURL,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedArticle = JournalArticleLocalServiceUtil.addArticle(\n\t\t\t\tuserId, groupId, articleId, autoArticleId, article.getVersion(),\n\t\t\t\tarticle.getTitle(), article.getDescription(),\n\t\t\t\tarticle.getContent(), article.getType(), parentStructureId,\n\t\t\t\tparentTemplateId, displayDateMonth, displayDateDay,\n\t\t\t\tdisplayDateYear, displayDateHour, displayDateMinute,\n\t\t\t\texpirationDateMonth, expirationDateDay, expirationDateYear,\n\t\t\t\texpirationDateHour, expirationDateMinute, neverExpire,\n\t\t\t\treviewDateMonth, reviewDateDay, reviewDateYear, reviewDateHour,\n\t\t\t\treviewDateMinute, neverReview, article.isIndexable(),\n\t\t\t\tarticle.isSmallImage(), article.getSmallImageURL(), smallFile,\n\t\t\t\timages, articleURL, serviceContext);\n\t\t}\n\n\t\tcontext.importPermissions(\n\t\t\tJournalArticle.class, article.getResourcePrimKey(),\n\t\t\timportedArticle.getResourcePrimKey());\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"comments\")) {\n\t\t\tcontext.importComments(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey(),\n\t\t\t\timportedArticle.getResourcePrimKey(), groupId);\n\t\t}\n\n\t\tif (context.getBooleanParameter(_NAMESPACE, \"ratings\")) {\n\t\t\tcontext.importRatingsEntries(\n\t\t\t\tJournalArticle.class, article.getResourcePrimKey(),\n\t\t\t\timportedArticle.getResourcePrimKey());\n\t\t}\n\n\t\tarticleIds.put(articleId, importedArticle.getArticleId());\n\n\t\tif (!articleId.equals(importedArticle.getArticleId())) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"An article with the ID \" + articleId + \" already \" +\n\t\t\t\t\t\t\"exists. The new generated ID is \" +\n\t\t\t\t\t\t\timportedArticle.getArticleId());\n\t\t\t}\n\t\t}\n\t}","commit_id":"9c9d1a0fa3b8968ac0e5cf02793b1c2e4e90b776","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private RangeHighlighter createAction(final MergeOperations.Operation operation, int lineStartOffset) {\n    if (operation == null) return null;\n    RangeHighlighter highlighter =\n      getMarkupModel().addRangeHighlighter(lineStartOffset, lineStartOffset,\n                                           HighlighterLayer.ADDITIONAL_SYNTAX,\n                                           new TextAttributes(null, null, null, null, Font.PLAIN),\n                                           HighlighterTargetArea.LINES_IN_RANGE);\n    final MergeActionGroup.OperationAction action = new MergeActionGroup.OperationAction(operation);\n    highlighter.setGutterIconRenderer(new GutterActionRenderer(action));\n    return highlighter;\n  }","id":73961,"modified_method":"@Nullable\n  private RangeHighlighter createAction(@Nullable MergeOperations.Operation operation, int lineStartOffset) {\n    MarkupModel markupModel = getMarkupModel();\n    if (operation == null || markupModel == null) {\n      return null;\n    }\n    RangeHighlighter highlighter = markupModel.addRangeHighlighter(lineStartOffset, lineStartOffset, HighlighterLayer.ADDITIONAL_SYNTAX,\n                                                                   new TextAttributes(null, null, null, null, Font.PLAIN),\n                                                                   HighlighterTargetArea.LINES_IN_RANGE);\n    final MergeActionGroup.OperationAction action = new MergeActionGroup.OperationAction(operation);\n    highlighter.setGutterIconRenderer(new GutterActionRenderer(action));\n    return highlighter;\n  }","commit_id":"d241dfbd42fc433982ae5b98e0bde05c9b6f6ae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private RangeHighlighter createLineMarker(TextAttributesKey type, int line) {\n    Color color = getLineSeparatorColorForType(type);\n    RangeHighlighter lastHighlighter = getLastHighlighter();\n    if (lastHighlighter != null &&\n        lastHighlighter.getTargetArea() == HighlighterTargetArea.LINES_IN_RANGE &&\n        SeparatorPlacement.BOTTOM == lastHighlighter.getLineSeparatorPlacement()) {\n      int lastLine = getDocument().getLineNumber(lastHighlighter.getStartOffset());\n      LOG.assertTrue(lastLine <= line);\n      if (lastLine == line) {\n        Color lastLineColor = lastHighlighter.getLineSeparatorColor();\n        if (Color.GRAY.equals(color) || !Color.GRAY.equals(lastLineColor)) {\n          return null;\n        }\n        else {\n          removeHighlighter(lastHighlighter);\n        }\n      }\n    }\n    RangeHighlighter marker = getMarkupModel().addLineHighlighter(line, LAYER, null);\n//    saveHighlighter(marker);\n    marker.setLineSeparatorColor(color);\n    marker.setLineSeparatorPlacement(SeparatorPlacement.BOTTOM);\n    // TODO[dyoma] type should be policy\n    if (type == DiffColors.DIFF_DELETED) marker.setErrorStripeMarkColor(color);\n    return marker;\n  }","id":73962,"modified_method":"@Nullable\n  private RangeHighlighter createLineMarker(@Nullable TextAttributesKey type, int line) {\n    MarkupModel markupModel = getMarkupModel();\n    Document document = getDocument();\n    if (markupModel == null || document == null) {\n      return null;\n    }\n\n    Color color = getLineSeparatorColorForType(type);\n    RangeHighlighter lastHighlighter = getLastHighlighter();\n    if (lastHighlighter != null &&\n        lastHighlighter.getTargetArea() == HighlighterTargetArea.LINES_IN_RANGE &&\n        SeparatorPlacement.BOTTOM == lastHighlighter.getLineSeparatorPlacement()) {\n      int lastLine = document.getLineNumber(lastHighlighter.getStartOffset());\n      LOG.assertTrue(lastLine <= line);\n      if (lastLine == line) {\n        Color lastLineColor = lastHighlighter.getLineSeparatorColor();\n        if (Color.GRAY.equals(color) || !Color.GRAY.equals(lastLineColor)) {\n          return null;\n        }\n        else {\n          removeHighlighter(lastHighlighter);\n        }\n      }\n    }\n    RangeHighlighter marker = markupModel.addLineHighlighter(line, LAYER, null);\n    marker.setLineSeparatorColor(color);\n    marker.setLineSeparatorPlacement(SeparatorPlacement.BOTTOM);\n    if (type == DiffColors.DIFF_DELETED) marker.setErrorStripeMarkColor(color);\n    return marker;\n  }","commit_id":"d241dfbd42fc433982ae5b98e0bde05c9b6f6ae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getText() {\n    return getDocument().getText();\n  }","id":73963,"modified_method":"@Nullable\n  public String getText() {\n    Document document = getDocument();\n    return document == null ? null : document.getText();\n  }","commit_id":"d241dfbd42fc433982ae5b98e0bde05c9b6f6ae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void highlightText(Fragment fragment, GutterIconRenderer gutterIconRenderer) {\n    final TextDiffTypeEnum diffTypeEnum = fragment.getType();\n    if (diffTypeEnum == null) return;\n    TextDiffType type = TextDiffType.create(diffTypeEnum);\n    if (type == null) return;\n    TextRange range = fragment.getRange(getSide());\n    TextAttributes attributes = type.getTextAttributes(getEditor());\n    RangeHighlighter rangeMarker;\n    if (range.getLength() == 0) {\n      TextAttributes textAttributes = new TextAttributes(null, null, attributes.getBackgroundColor(), EffectType.BOXED, Font.PLAIN);\n      rangeMarker = getMarkupModel().addRangeHighlighter(range.getStartOffset(), range.getStartOffset(), LAYER, textAttributes, HighlighterTargetArea.EXACT_RANGE);\n    }\n    else {\n      rangeMarker = getMarkupModel().addRangeHighlighter(range.getStartOffset(), range.getEndOffset(), LAYER,\n                                                         attributes, HighlighterTargetArea.EXACT_RANGE);\n    }\n    if (gutterIconRenderer != null) {\n      rangeMarker.setGutterIconRenderer(gutterIconRenderer);\n    }\n\n    rangeMarker.setLineMarkerRenderer(new DiffLineMarkerRenderer(type));\n\n    Color stripeBarColor = attributes.getErrorStripeColor();\n    if (stripeBarColor != null) {\n      rangeMarker.setErrorStripeMarkColor(stripeBarColor);\n      rangeMarker.setThinErrorStripeMark(true);\n    }\n    saveHighlighter(rangeMarker);\n  }","id":73964,"modified_method":"public void highlightText(@NotNull Fragment fragment, @Nullable GutterIconRenderer gutterIconRenderer) {\n    MarkupModel markupModel = getMarkupModel();\n    TextDiffTypeEnum diffTypeEnum = fragment.getType();\n    if (diffTypeEnum == null || markupModel == null) {\n      return;\n    }\n    TextDiffType type = TextDiffType.create(diffTypeEnum);\n    TextRange range = fragment.getRange(getSide());\n    TextAttributes attributes = type.getTextAttributes(getEditor());\n    if (attributes == null) {\n      return;\n    }\n\n    RangeHighlighter rangeMarker;\n    if (range.getLength() == 0) {\n      TextAttributes textAttributes = new TextAttributes(null, null, attributes.getBackgroundColor(), EffectType.BOXED, Font.PLAIN);\n      rangeMarker = markupModel\n        .addRangeHighlighter(range.getStartOffset(), range.getStartOffset(), LAYER, textAttributes, HighlighterTargetArea.EXACT_RANGE);\n    }\n    else {\n      rangeMarker = markupModel.addRangeHighlighter(range.getStartOffset(), range.getEndOffset(), LAYER,\n                                              attributes, HighlighterTargetArea.EXACT_RANGE);\n    }\n    if (gutterIconRenderer != null) {\n      rangeMarker.setGutterIconRenderer(gutterIconRenderer);\n    }\n\n    rangeMarker.setLineMarkerRenderer(new DiffLineMarkerRenderer(type));\n\n    Color stripeBarColor = attributes.getErrorStripeColor();\n    if (stripeBarColor != null) {\n      rangeMarker.setErrorStripeMarkColor(stripeBarColor);\n      rangeMarker.setThinErrorStripeMark(true);\n    }\n    saveHighlighter(rangeMarker);\n  }","commit_id":"d241dfbd42fc433982ae5b98e0bde05c9b6f6ae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Document getDocument() {\n    return getEditor().getDocument();\n  }","id":73965,"modified_method":"@Nullable\n  public Document getDocument() {\n    EditorEx editor = getEditor();\n    return editor == null ? null : editor.getDocument();\n  }","commit_id":"d241dfbd42fc433982ae5b98e0bde05c9b6f6ae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void setSeparatorMarker(int line, Consumer<Integer> consumer) {\n    RangeHighlighter marker = getMarkupModel().addLineHighlighter(line, LAYER, null);\n    marker.setLineSeparatorPlacement(SeparatorPlacement.TOP);\n    final FragmentBoundRenderer renderer = new FragmentBoundRenderer(getEditor().getLineHeight(), getEditor(), consumer);\n    marker.setLineSeparatorColor(renderer.getColor());\n    marker.setLineSeparatorRenderer(renderer);\n    marker.setLineMarkerRenderer(renderer);\n    myExtraHighLighters.add(marker);\n  }","id":73966,"modified_method":"void setSeparatorMarker(int line, Consumer<Integer> consumer) {\n    EditorEx editor = getEditor();\n    MarkupModel markupModel = getMarkupModel();\n    if (editor == null || markupModel == null) {\n      return;\n    }\n    RangeHighlighter marker = markupModel.addLineHighlighter(line, LAYER, null);\n    marker.setLineSeparatorPlacement(SeparatorPlacement.TOP);\n    final FragmentBoundRenderer renderer = new FragmentBoundRenderer(editor.getLineHeight(), editor, consumer);\n    marker.setLineSeparatorColor(renderer.getColor());\n    marker.setLineSeparatorRenderer(renderer);\n    marker.setLineMarkerRenderer(renderer);\n    myExtraHighLighters.add(marker);\n  }","commit_id":"d241dfbd42fc433982ae5b98e0bde05c9b6f6ae9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SyntaxLanguageWidget(SyntaxLanguage syntax) {\n\t\tthis.syntax = syntax;\n\t\tDisclosurePanel discPanel = new DisclosurePanel(\"Highlighting\");\n\t\tFlowPanel panel = new FlowPanel();\n\t\t\n\t\tpanel.add(createButton(\"None\", SyntaxLanguage.NONE));\n\t\tpanel.add(createButton(\"JavaScript\", SyntaxLanguage.JAVASCRIPT));\n\t\tpanel.add(createButton(\"XML\", SyntaxLanguage.XML));\n\t\tpanel.add(createButton(\"HTML+\", SyntaxLanguage.MIXED));\n\t\t\n\t\tdiscPanel.add(panel);\n\t\tinitWidget(discPanel);\n\t}","id":73967,"modified_method":"public SyntaxLanguageWidget(SyntaxLanguage syntax) {\n\t\tthis.syntax = syntax;\n\n\t\tPanel panel = new HorizontalPanel();\n\t\tpanel.add(new Label(\"Highlighting: \"));\n\t\taddItem(\"Plain text\", SyntaxLanguage.NONE);\n\t\taddItem(\"JavaScript\", SyntaxLanguage.JAVASCRIPT);\n\t\taddItem(\"XML\", SyntaxLanguage.XML);\n\t\taddItem(\"HTML+\", SyntaxLanguage.MIXED);\n\t\tlistBox.addChangeHandler(new ChangeHandler() {\n\t\t\t@Override\n\t\t\tpublic void onChange(ChangeEvent event) {\n\t\t\t\tsetSyntax(SyntaxLanguage.valueOf(listBox.getValue(listBox.getSelectedIndex())));\n\t\t\t}\n\t\t});\n\t\tpanel.add(listBox);\n\t\tinitWidget(panel);\n\t}","commit_id":"5c5c7fc172ee9339852632f8350420930aa67333","url":"https://github.com/zanata/zanata-server"},{"original_method":"private RadioButton createButton(String name, final SyntaxLanguage buttonSyntax) {\n\t\tRadioButton radioButton = new RadioButton(\"syntax\"+System.identityHashCode(this), name);\n\t\tradioButton.addClickHandler(new ClickHandler() {\n\t\t\t@Override\n\t\t\tpublic void onClick(ClickEvent event) {\n\t\t\t\tsetSyntax(buttonSyntax);\n\t\t\t}\n\t\t});\n\t\tif(syntax == buttonSyntax)\n\t\t\tradioButton.setValue(true, false);\n\t\treturn radioButton;\n\t}","id":73968,"modified_method":"private void addItem(String name, final SyntaxLanguage buttonSyntax) {\n\t\tlistBox.addItem(name, buttonSyntax.name());\n\t\tif (syntax == buttonSyntax)\n\t\t\tlistBox.setSelectedIndex(listBox.getItemCount()-1);\n\t}","commit_id":"5c5c7fc172ee9339852632f8350420930aa67333","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void processText(PsiFile file, final FormatTextRanges ranges, boolean doPostponedFormatting) {\n    final Project project = file.getProject();\n    Document document = PsiDocumentManager.getInstance(project).getDocument(file);\n    if (document instanceof DocumentWindow) {\n      file = InjectedLanguageUtil.getTopLevelFile(file);\n      final DocumentWindow documentWindow = (DocumentWindow)document;\n      for (FormatTextRanges.FormatTextRange range : ranges.getRanges()) {\n        range.setTextRange(documentWindow.injectedToHost(range.getTextRange()));\n      }\n      document = documentWindow.getDelegate();\n    }\n\n\n    final FormattingModelBuilder builder = LanguageFormatting.INSTANCE.forContext(file);\n\n    if (builder != null) {\n      if (file.getTextLength() > 0) {\n        try {\n          ranges.preprocess(file.getNode());\n          if (doPostponedFormatting) {\n            RangeMarker[] markers = new RangeMarker[ranges.getRanges().size()];\n            int i = 0;\n            for (FormatTextRanges.FormatTextRange range : ranges.getRanges()) {\n              TextRange textRange = range.getTextRange();\n              int start = textRange.getStartOffset();\n              int end = textRange.getEndOffset();\n              if (start >= 0 && end > start && end <= document.getTextLength()) {\n                markers[i] = document.createRangeMarker(textRange);\n                markers[i].setGreedyToLeft(true);\n                markers[i].setGreedyToRight(true);\n                i++;\n              }\n            }\n            final PostprocessReformattingAspect component = file.getProject().getComponent(PostprocessReformattingAspect.class);\n            component.doPostponedFormatting(file.getViewProvider());\n            i = 0;\n            for (FormatTextRanges.FormatTextRange range : ranges.getRanges()) {\n              RangeMarker marker = markers[i];\n              if (marker != null) {\n                range.setTextRange(new TextRange(marker.getStartOffset(), marker.getEndOffset()));\n                marker.dispose();\n              }\n              i++;\n            }\n\n          }\n          final FormattingModel originalModel = builder.createModel(file, mySettings);\n          final FormattingModel model = new DocumentBasedFormattingModel(originalModel.getRootBlock(),\n                                                                         document,\n                                                                         project, mySettings, file.getFileType(), file);\n\n          FormatterEx.getInstanceEx().format(model, mySettings, mySettings.getIndentOptions(file.getFileType()), ranges);\n          for (FormatTextRanges.FormatTextRange range : ranges.getRanges()) {\n            TextRange textRange = range.getTextRange();\n            wrapLongLinesIfNecessary(file, document, textRange.getStartOffset(), textRange.getEndOffset());\n          }\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n    }\n  }","id":73969,"modified_method":"public void processText(PsiFile file, final FormatTextRanges ranges, boolean doPostponedFormatting) {\n    final Project project = file.getProject();\n    Document document = PsiDocumentManager.getInstance(project).getDocument(file);\n    final List<FormatTextRanges.FormatTextRange> textRanges = ranges.getRanges();\n    if (document instanceof DocumentWindow) {\n      file = InjectedLanguageUtil.getTopLevelFile(file);\n      final DocumentWindow documentWindow = (DocumentWindow)document;\n      for (FormatTextRanges.FormatTextRange range : textRanges) {\n        range.setTextRange(documentWindow.injectedToHost(range.getTextRange()));\n      }\n      document = documentWindow.getDelegate();\n    }\n\n\n    final FormattingModelBuilder builder = LanguageFormatting.INSTANCE.forContext(file);\n\n    if (builder != null) {\n      if (file.getTextLength() > 0) {\n        try {\n          final PsiElement startElement = file.findElementAt(textRanges.get(0).getTextRange().getStartOffset());\n          final PsiElement endElement = file.findElementAt(textRanges.get(textRanges.size() - 1).getTextRange().getEndOffset() - 1);\n          final PsiElement commonParent = PsiTreeUtil.findCommonParent(startElement, endElement);\n          ASTNode node = null;\n          if (commonParent != null) {\n            node = commonParent.getNode();\n          }\n          if (node == null) {\n            node = file.getNode();\n          }\n          ranges.preprocess(node);\n          if (doPostponedFormatting) {\n            RangeMarker[] markers = new RangeMarker[textRanges.size()];\n            int i = 0;\n            for (FormatTextRanges.FormatTextRange range : textRanges) {\n              TextRange textRange = range.getTextRange();\n              int start = textRange.getStartOffset();\n              int end = textRange.getEndOffset();\n              if (start >= 0 && end > start && end <= document.getTextLength()) {\n                markers[i] = document.createRangeMarker(textRange);\n                markers[i].setGreedyToLeft(true);\n                markers[i].setGreedyToRight(true);\n                i++;\n              }\n            }\n            final PostprocessReformattingAspect component = file.getProject().getComponent(PostprocessReformattingAspect.class);\n            component.doPostponedFormatting(file.getViewProvider());\n            i = 0;\n            for (FormatTextRanges.FormatTextRange range : textRanges) {\n              RangeMarker marker = markers[i];\n              if (marker != null) {\n                range.setTextRange(new TextRange(marker.getStartOffset(), marker.getEndOffset()));\n                marker.dispose();\n              }\n              i++;\n            }\n\n          }\n          final FormattingModel originalModel = builder.createModel(file, mySettings);\n          final FormattingModel model = new DocumentBasedFormattingModel(originalModel.getRootBlock(),\n                                                                         document,\n                                                                         project, mySettings, file.getFileType(), file);\n\n          FormatterEx.getInstanceEx().format(model, mySettings, mySettings.getIndentOptions(file.getFileType()), ranges);\n          for (FormatTextRanges.FormatTextRange range : textRanges) {\n            TextRange textRange = range.getTextRange();\n            wrapLongLinesIfNecessary(file, document, textRange.getStartOffset(), textRange.getEndOffset());\n          }\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n    }\n  }","commit_id":"0e2e84891d783fbf8984e3a4771ae71ddc86c39d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean shouldProcess(final ASTNode element) {\n    if (element instanceof PsiDocComment) {\n      return true;\n    }\n    else {\n      return element.getElementType() instanceof JavaStubElementType &&\n          (element.getPsi()) instanceof PsiDocCommentOwner;\n    }\n  }","id":73970,"modified_method":"private static boolean shouldProcess(final ASTNode element) {\n    if (element instanceof PsiDocComment) {\n      return true;\n    }\n    else {\n      return true;//element.getElementType() instanceof JavaStubElementType &&\n          //(element.getPsi()) instanceof PsiDocCommentOwner;\n    }\n  }","commit_id":"0e2e84891d783fbf8984e3a4771ae71ddc86c39d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public TextRange getCurrentTextRange(@NotNull Range range) {\n    if (!range.isValid()) {\n      LOG.warn(\"Current TextRange of invalid range\");\n    }\n    return DiffUtil.getLinesRange(myDocument, range.getLine1(), range.getLine2());\n  }","id":73971,"modified_method":"@NotNull\n  public TextRange getCurrentTextRange(@NotNull Range range) {\n    synchronized (LOCK) {\n      if (!range.isValid()) {\n        LOG.warn(\"Current TextRange of invalid range\");\n      }\n      return DiffUtil.getLinesRange(myDocument, range.getLine1(), range.getLine2());\n    }\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public CharSequence getVcsContent(@NotNull Range range) {\n    TextRange textRange = getVcsTextRange(range);\n    final int startOffset = textRange.getStartOffset();\n    final int endOffset = textRange.getEndOffset();\n    return myVcsDocument.getImmutableCharSequence().subSequence(startOffset, endOffset);\n  }","id":73972,"modified_method":"@NotNull\n  public CharSequence getVcsContent(@NotNull Range range) {\n    synchronized (LOCK) {\n      TextRange textRange = getVcsTextRange(range);\n      final int startOffset = textRange.getStartOffset();\n      final int endOffset = textRange.getEndOffset();\n      return myVcsDocument.getImmutableCharSequence().subSequence(startOffset, endOffset);\n    }\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public CharSequence getCurrentContent(@NotNull Range range) {\n    TextRange textRange = getCurrentTextRange(range);\n    final int startOffset = textRange.getStartOffset();\n    final int endOffset = textRange.getEndOffset();\n    return myDocument.getImmutableCharSequence().subSequence(startOffset, endOffset);\n  }","id":73973,"modified_method":"@NotNull\n  public CharSequence getCurrentContent(@NotNull Range range) {\n    synchronized (LOCK) {\n      TextRange textRange = getCurrentTextRange(range);\n      final int startOffset = textRange.getStartOffset();\n      final int endOffset = textRange.getEndOffset();\n      return myDocument.getImmutableCharSequence().subSequence(startOffset, endOffset);\n    }\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void documentChanged(final DocumentEvent e) {\n      myApplication.assertWriteAccessAllowed();\n\n      if (!myInitialized || myReleased) return;\n      if (myBulkUpdate || myDuringRollback || myAnathemaThrown) return;\n      assert myDocument == e.getDocument();\n\n      int newLine1 = myLine1;\n      int newLine2;\n      if (e.getNewLength() == 0) {\n        newLine2 = newLine1 + 1;\n      }\n      else {\n        newLine2 = myDocument.getLineNumber(e.getOffset() + e.getNewLength()) + 1;\n      }\n\n      int linesShift = (newLine2 - newLine1) - (myLine2 - myLine1);\n\n      int[] fixed = fixRanges(e, myLine1, myLine2);\n      int line1 = fixed[0];\n      int line2 = fixed[1];\n\n      if (myDirtyRange == null) {\n        myDirtyRange = new DirtyRange(line1, line2, linesShift, myBeforeTotalLines);\n      }\n      else {\n        int oldLine1 = myDirtyRange.line1;\n        int oldLine2 = myDirtyRange.line2 + myDirtyRange.lineShift;\n\n        int updatedLine1 = myDirtyRange.line1 - Math.max(oldLine1 - line1, 0);\n        int updatedLine2 = myDirtyRange.line2 + Math.max(line2 - oldLine2, 0);\n\n        myDirtyRange = new DirtyRange(updatedLine1, updatedLine2, linesShift + myDirtyRange.lineShift, myDirtyRange.beforeTotalLines);\n      }\n    }","id":73974,"modified_method":"@Override\n    public void documentChanged(final DocumentEvent e) {\n      myApplication.assertIsDispatchThread();\n\n      if (!myInitialized || myReleased) return;\n      if (myBulkUpdate || myDuringRollback || myAnathemaThrown) return;\n      assert myDocument == e.getDocument();\n\n      synchronized (LOCK) {\n        int newLine1 = myLine1;\n        int newLine2;\n        if (e.getNewLength() == 0) {\n          newLine2 = newLine1 + 1;\n        }\n        else {\n          newLine2 = myDocument.getLineNumber(e.getOffset() + e.getNewLength()) + 1;\n        }\n\n        int linesShift = (newLine2 - newLine1) - (myLine2 - myLine1);\n\n        int[] fixed = fixRanges(e, myLine1, myLine2);\n        int line1 = fixed[0];\n        int line2 = fixed[1];\n\n        if (myDirtyRange == null) {\n          myDirtyRange = new DirtyRange(line1, line2, linesShift, myBeforeTotalLines);\n        }\n        else {\n          int oldLine1 = myDirtyRange.line1;\n          int oldLine2 = myDirtyRange.line2 + myDirtyRange.lineShift;\n\n          int updatedLine1 = myDirtyRange.line1 - Math.max(oldLine1 - line1, 0);\n          int updatedLine2 = myDirtyRange.line2 + Math.max(line2 - oldLine2, 0);\n\n          myDirtyRange = new DirtyRange(updatedLine1, updatedLine2, linesShift + myDirtyRange.lineShift, myDirtyRange.beforeTotalLines);\n        }\n      }\n    }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Range getNextRange(Range range) {\n    final int index = myRanges.indexOf(range);\n    if (index == myRanges.size() - 1) return null;\n    return myRanges.get(index + 1);\n  }","id":73975,"modified_method":"@Nullable\n  public Range getNextRange(Range range) {\n    synchronized (LOCK) {\n      final int index = myRanges.indexOf(range);\n      if (index == myRanges.size() - 1) return null;\n      return myRanges.get(index + 1);\n    }\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Range getPrevRange(int line) {\n    for (int i = myRanges.size() - 1; i >= 0; i--) {\n      Range range = myRanges.get(i);\n      if (line > range.getLine1() && !range.isSelectedByLine(line)) {\n        return range;\n      }\n    }\n    return null;\n  }","id":73976,"modified_method":"@Nullable\n  public Range getPrevRange(int line) {\n    synchronized (LOCK) {\n      for (int i = myRanges.size() - 1; i >= 0; i--) {\n        Range range = myRanges.get(i);\n        if (line > range.getLine1() && !range.isSelectedByLine(line)) {\n          return range;\n        }\n      }\n      return null;\n    }\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@CalledInAwt\n  public void finishBulkUpdate() {\n    if (myReleased) return;\n\n    myApplication.runWriteAction(() -> {\n      myBulkUpdate = false;\n      reinstallRanges();\n    });\n  }","id":73977,"modified_method":"@CalledInAwt\n  public void finishBulkUpdate() {\n    if (myReleased) return;\n    synchronized (LOCK) {\n      myBulkUpdate = false;\n      reinstallRanges();\n    }\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@CalledWithWriteLock\n  private void doUpdateRanges(int beforeChangedLine1,\n                              int beforeChangedLine2,\n                              int linesShift,\n                              int beforeTotalLines) {\n    myApplication.assertWriteAccessAllowed();\n    LOG.assertTrue(!myReleased);\n\n    List<Range> rangesBeforeChange = new ArrayList<Range>();\n    List<Range> rangesAfterChange = new ArrayList<Range>();\n    List<Range> changedRanges = new ArrayList<Range>();\n\n    sortRanges(beforeChangedLine1, beforeChangedLine2, linesShift, rangesBeforeChange, changedRanges, rangesAfterChange);\n\n    Range firstChangedRange = ContainerUtil.getFirstItem(changedRanges);\n    Range lastChangedRange = ContainerUtil.getLastItem(changedRanges);\n\n    if (firstChangedRange != null && firstChangedRange.getLine1() < beforeChangedLine1) {\n      beforeChangedLine1 = firstChangedRange.getLine1();\n    }\n    if (lastChangedRange != null && lastChangedRange.getLine2() > beforeChangedLine2) {\n      beforeChangedLine2 = lastChangedRange.getLine2();\n    }\n\n    doUpdateRanges(beforeChangedLine1, beforeChangedLine2, linesShift, beforeTotalLines,\n                   rangesBeforeChange, changedRanges, rangesAfterChange);\n  }","id":73978,"modified_method":"private void doUpdateRanges(int beforeChangedLine1,\n                              int beforeChangedLine2,\n                              int linesShift,\n                              int beforeTotalLines) {\n    LOG.assertTrue(!myReleased);\n\n    List<Range> rangesBeforeChange = new ArrayList<Range>();\n    List<Range> rangesAfterChange = new ArrayList<Range>();\n    List<Range> changedRanges = new ArrayList<Range>();\n\n    sortRanges(beforeChangedLine1, beforeChangedLine2, linesShift, rangesBeforeChange, changedRanges, rangesAfterChange);\n\n    Range firstChangedRange = ContainerUtil.getFirstItem(changedRanges);\n    Range lastChangedRange = ContainerUtil.getLastItem(changedRanges);\n\n    if (firstChangedRange != null && firstChangedRange.getLine1() < beforeChangedLine1) {\n      beforeChangedLine1 = firstChangedRange.getLine1();\n    }\n    if (lastChangedRange != null && lastChangedRange.getLine2() > beforeChangedLine2) {\n      beforeChangedLine2 = lastChangedRange.getLine2();\n    }\n\n    doUpdateRanges(beforeChangedLine1, beforeChangedLine2, linesShift, beforeTotalLines,\n                   rangesBeforeChange, changedRanges, rangesAfterChange);\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isValid() {\n    return myInitialized && !myReleased && !myAnathemaThrown && !myBulkUpdate && !myDuringRollback && myDirtyRange == null;\n  }","id":73979,"modified_method":"public boolean isValid() {\n    synchronized (LOCK) {\n      return myInitialized && !myReleased && !myAnathemaThrown && !myBulkUpdate && !myDuringRollback && myDirtyRange == null;\n    }\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Range getNextRange(int line) {\n    for (Range range : myRanges) {\n      if (line < range.getLine2() && !range.isSelectedByLine(line)) {\n        return range;\n      }\n    }\n    return null;\n  }","id":73980,"modified_method":"@Nullable\n  public Range getNextRange(int line) {\n    synchronized (LOCK) {\n      for (Range range : myRanges) {\n        if (line < range.getLine2() && !range.isSelectedByLine(line)) {\n          return range;\n        }\n      }\n      return null;\n    }\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void release() {\n    UIUtil.invokeLaterIfNeeded(() -> {\n      if (myReleased) return;\n      LOG.assertTrue(!myDuringRollback);\n\n      myApplication.runWriteAction(() -> {\n        myReleased = true;\n        myDocument.removeDocumentListener(myDocumentListener);\n        ApplicationManager.getApplication().removeApplicationListener(myApplicationListener);\n\n        destroyRanges();\n      });\n    });\n  }","id":73981,"modified_method":"public void release() {\n    UIUtil.invokeLaterIfNeeded(() -> {\n      if (myReleased) return;\n      LOG.assertTrue(!myDuringRollback);\n\n      synchronized (LOCK) {\n        myReleased = true;\n        myDocument.removeDocumentListener(myDocumentListener);\n        ApplicationManager.getApplication().removeApplicationListener(myApplicationListener);\n\n        destroyRanges();\n      }\n    });\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Range getPrevRange(Range range) {\n    final int index = myRanges.indexOf(range);\n    if (index <= 0) return null;\n    return myRanges.get(index - 1);\n  }","id":73982,"modified_method":"@Nullable\n  public Range getPrevRange(Range range) {\n    synchronized (LOCK) {\n      final int index = myRanges.indexOf(range);\n      if (index <= 0) return null;\n      return myRanges.get(index - 1);\n    }\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public List<Range> getRanges() {\n    return Collections.unmodifiableList(myRanges);\n  }","id":73983,"modified_method":"/**\n   * Ranges can be modified without taking the write lock, so calling this method twice not from EDT can produce different results.\n   */\n  @Nullable\n  public List<Range> getRanges() {\n    synchronized (LOCK) {\n      if (!isValid()) return null;\n      myApplication.assertReadAccessAllowed();\n\n      List<Range> result = new ArrayList<>(myRanges.size());\n      for (Range range : myRanges) {\n        result.add(new Range(range));\n      }\n      return result;\n    }\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@CalledInAwt\n  public void startBulkUpdate() {\n    if (myReleased) return;\n\n    myApplication.runWriteAction(() -> {\n      myBulkUpdate = true;\n      destroyRanges();\n    });\n  }","id":73984,"modified_method":"@CalledInAwt\n  public void startBulkUpdate() {\n    if (myReleased) return;\n    synchronized (LOCK) {\n      myBulkUpdate = true;\n      destroyRanges();\n    }\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Range getRangeForLine(int line) {\n    for (final Range range : myRanges) {\n      if (range.isSelectedByLine(line)) return range;\n    }\n    return null;\n  }","id":73985,"modified_method":"@Nullable\n  public Range getRangeForLine(int line) {\n    synchronized (LOCK) {\n      for (final Range range : myRanges) {\n        if (range.isSelectedByLine(line)) return range;\n      }\n      return null;\n    }\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public TextRange getVcsTextRange(@NotNull Range range) {\n    if (!range.isValid()) {\n      LOG.warn(\"Vcs TextRange of invalid range\");\n    }\n    return DiffUtil.getLinesRange(myVcsDocument, range.getVcsLine1(), range.getVcsLine2());\n  }","id":73986,"modified_method":"@NotNull\n  public TextRange getVcsTextRange(@NotNull Range range) {\n    synchronized (LOCK) {\n      if (!range.isValid()) {\n        LOG.warn(\"Vcs TextRange of invalid range\");\n      }\n      return DiffUtil.getLinesRange(myVcsDocument, range.getVcsLine1(), range.getVcsLine2());\n    }\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@CalledWithWriteLock\n  private void runBulkRollback(@NotNull Runnable task) {\n    myApplication.assertWriteAccessAllowed();\n\n    if (!isValid()) return;\n\n    try {\n      myDuringRollback = true;\n\n      task.run();\n    }\n    catch (Error | RuntimeException e) {\n      reinstallRanges();\n      throw e;\n    }\n    finally {\n      myDuringRollback = false;\n    }\n  }","id":73987,"modified_method":"@CalledWithWriteLock\n  private void runBulkRollback(@NotNull Runnable task) {\n    myApplication.assertWriteAccessAllowed();\n    if (!isValid()) return;\n\n    synchronized (LOCK) {\n      try {\n        myDuringRollback = true;\n\n        task.run();\n      }\n      catch (Error | RuntimeException e) {\n        reinstallRanges();\n        throw e;\n      }\n      finally {\n        myDuringRollback = false;\n      }\n    }\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private LineStatusTracker(@NotNull final Document document,\n                            @NotNull final Project project,\n                            @NotNull final VirtualFile virtualFile,\n                            @NotNull final Mode mode) {\n    myDocument = document;\n    myProject = project;\n    myVirtualFile = virtualFile;\n    myMode = mode;\n\n    myApplication = ApplicationManager.getApplication();\n    myFileEditorManager = FileEditorManager.getInstance(myProject);\n    myVcsDirtyScopeManager = VcsDirtyScopeManager.getInstance(myProject);\n\n    myDocumentListener = new MyDocumentListener();\n    myDocument.addDocumentListener(myDocumentListener);\n\n    myApplicationListener = new MyApplicationListener();\n    ApplicationManager.getApplication().addApplicationListener(myApplicationListener);\n\n    myRanges = new ArrayList<Range>();\n\n    myVcsDocument = new DocumentImpl(\"\");\n    myVcsDocument.putUserData(UndoConstants.DONT_RECORD_UNDO, Boolean.TRUE);\n  }","id":73988,"modified_method":"private LineStatusTracker(@NotNull final Document document,\n                            @NotNull final Project project,\n                            @NotNull final VirtualFile virtualFile,\n                            @NotNull final Mode mode) {\n    myDocument = document;\n    myProject = project;\n    myVirtualFile = virtualFile;\n    myMode = mode;\n\n    myApplication = ApplicationManager.getApplication();\n    myFileEditorManager = FileEditorManager.getInstance(myProject);\n    myVcsDirtyScopeManager = VcsDirtyScopeManager.getInstance(myProject);\n\n    myDocumentListener = new MyDocumentListener();\n    myDocument.addDocumentListener(myDocumentListener);\n\n    myApplicationListener = new MyApplicationListener();\n    ApplicationManager.getApplication().addApplicationListener(myApplicationListener);\n\n    myRanges = new ArrayList<Range>();\n\n    myVcsDocument = new DocumentImpl(\"\", true);\n    myVcsDocument.putUserData(UndoConstants.DONT_RECORD_UNDO, Boolean.TRUE);\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void writeActionFinished(@NotNull Object action) {\n      if (!myInitialized || myReleased || myBulkUpdate || myDuringRollback || myAnathemaThrown) return;\n      if (myDirtyRange != null) {\n        try {\n          doUpdateRanges(myDirtyRange.line1, myDirtyRange.line2, myDirtyRange.lineShift, myDirtyRange.beforeTotalLines);\n          myDirtyRange = null;\n        }\n        catch (Exception e) {\n          LOG.error(e);\n          reinstallRanges();\n        }\n      }\n    }","id":73989,"modified_method":"@Override\n    public void writeActionFinished(@NotNull Object action) {\n      if (!myInitialized || myReleased || myBulkUpdate || myDuringRollback || myAnathemaThrown) return;\n      if (myDirtyRange != null) {\n        synchronized (LOCK) {\n          try {\n            doUpdateRanges(myDirtyRange.line1, myDirtyRange.line2, myDirtyRange.lineShift, myDirtyRange.beforeTotalLines);\n            myDirtyRange = null;\n          }\n          catch (Exception e) {\n            LOG.error(e);\n            reinstallRanges();\n          }\n        }\n      }\n    }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@CalledInAwt\n  public void setBaseRevision(@NotNull final String vcsContent, @NotNull RevisionPack baseRevisionNumber) {\n    myApplication.runWriteAction(() -> {\n      try {\n        if (myReleased) return;\n        if (myBaseRevisionNumber != null && myBaseRevisionNumber.contains(baseRevisionNumber)) return;\n\n        myBaseRevisionNumber = baseRevisionNumber;\n\n        myVcsDocument.setReadOnly(false);\n        myVcsDocument.setText(vcsContent);\n        myVcsDocument.setReadOnly(true);\n      }\n      finally {\n        myInitialized = true;\n      }\n\n      reinstallRanges();\n    });\n  }","id":73990,"modified_method":"@CalledInAwt\n  public void setBaseRevision(@NotNull final String vcsContent, @NotNull RevisionPack baseRevisionNumber) {\n    myApplication.assertIsDispatchThread();\n    if (myReleased) return;\n\n    synchronized (LOCK) {\n      try {\n        if (myBaseRevisionNumber != null && myBaseRevisionNumber.contains(baseRevisionNumber)) return;\n        myBaseRevisionNumber = baseRevisionNumber;\n\n        myVcsDocument.setReadOnly(false);\n        myVcsDocument.setText(vcsContent);\n        myVcsDocument.setReadOnly(true);\n      }\n      finally {\n        myInitialized = true;\n      }\n\n      reinstallRanges();\n    }\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@CalledInAwt\n  public void setMode(@NotNull Mode mode) {\n    if (myMode == mode) return;\n    myMode = mode;\n\n    myApplication.runWriteAction(() -> {\n      reinstallRanges();\n    });\n  }","id":73991,"modified_method":"@CalledInAwt\n  public void setMode(@NotNull Mode mode) {\n    if (myMode == mode) return;\n    synchronized (LOCK) {\n      myMode = mode;\n      reinstallRanges();\n    }\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isLineChanged(int currentNumber) {\n    LineStatusTracker tracker = LineStatusTrackerManager.getInstance(myProject).getLineStatusTracker(myDocument);\n    if (tracker == null) {\n      return false;\n    }\n    for (Range range : tracker.getRanges()) {\n      if (range.getLine1() <= currentNumber && range.getLine2() >= currentNumber) {\n        return true;\n      }\n    }\n    return false;\n  }","id":73992,"modified_method":"@Override\n  public boolean isLineChanged(int currentNumber) {\n    LineStatusTracker tracker = myLineStatusTrackerManagerI.getLineStatusTracker(myDocument);\n    if (tracker == null) {\n      return false;\n    }\n    List<Range> ranges = tracker.getRanges();\n    if (ranges == null) {\n      return false;\n    }\n    for (Range range : ranges) {\n      if (range.getLine1() <= currentNumber && range.getLine2() >= currentNumber) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isRangeChanged(final int start, final int end) {\n    LineStatusTracker tracker = LineStatusTrackerManager.getInstance(myProject).getLineStatusTracker(myDocument);\n    if (tracker == null) {\n      return false;\n    }\n    for (Range range : tracker.getRanges()) {\n      if (lineInRange(range, start) || lineInRange(range, end)) {\n        return true;\n      }\n      if (range.getLine1() > start) {\n        return range.getLine1() < end;\n      }\n    }\n    return false;\n  }","id":73993,"modified_method":"public boolean isRangeChanged(final int start, final int end) {\n    LineStatusTracker tracker = myLineStatusTrackerManagerI.getLineStatusTracker(myDocument);\n    if (tracker == null) {\n      return false;\n    }\n    List<Range> ranges = tracker.getRanges();\n    if (ranges == null) {\n      return false;\n    }\n    for (Range range : ranges) {\n      if (lineInRange(range, start) || lineInRange(range, end)) {\n        return true;\n      }\n      if (range.getLine1() > start) {\n        return range.getLine1() < end;\n      }\n    }\n    return false;\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getLineNumber(int currentNumber) {\n    LineStatusTracker tracker = myLineStatusTrackerManagerI.getLineStatusTracker(myDocument);\n    if (tracker == null) {\n      return currentNumber;\n    }\n    return calcLineNumber(tracker, currentNumber);\n  }","id":73994,"modified_method":"public int getLineNumber(int currentNumber) {\n    LineStatusTracker tracker = myLineStatusTrackerManagerI.getLineStatusTracker(myDocument);\n    if (tracker == null) {\n      return currentNumber;\n    }\n    List<Range> ranges = tracker.getRanges();\n    if (ranges == null) {\n      return currentNumber;\n    }\n    int result = currentNumber;\n\n    for (final Range range : ranges) {\n      int startLine = range.getLine1();\n      int endLine = range.getLine2();\n\n      if ((startLine <= currentNumber) && (endLine > currentNumber)) {\n        return ABSENT_LINE_NUMBER;\n      }\n\n      if (endLine > currentNumber) return result;\n\n      int currentRangeLength = endLine - startLine;\n      int vcsRangeLength = range.getVcsLine2() - range.getVcsLine1();\n\n      result += vcsRangeLength - currentRangeLength;\n    }\n    return result;\n\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static List<TextRange> getCachedChangedLines(@NotNull Project project, @NotNull Document document) {\n    LineStatusTracker tracker = LineStatusTrackerManager.getInstance(project).getLineStatusTracker(document);\n    if (tracker != null && tracker.isValid()) {\n      List<Range> ranges = tracker.getRanges();\n      return getChangedTextRanges(document, ranges);\n    }\n\n    return null;\n  }","id":73995,"modified_method":"@Nullable\n  private static List<TextRange> getCachedChangedLines(@NotNull Project project, @NotNull Document document) {\n    LineStatusTracker tracker = LineStatusTrackerManager.getInstance(project).getLineStatusTracker(document);\n    if (tracker != null) {\n      List<Range> ranges = tracker.getRanges();\n      if (ranges != null) {\n        return getChangedTextRanges(document, ranges);\n      }\n    }\n    return null;\n  }","commit_id":"4bb08372c2376e73f92b3f1752dffe574616bacd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void add(final Message message) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Adding message to cache: {}\", message.toString());\n        }\n        if (db.isClosed()) {\n            return;\n        }\n        final Timer.Context time = addTimer.time();\n        try {\n            final byte[] bytes = serializer.serializeToBytes(message);\n\n            synchronized (modificationLock) {\n                if (queue.offer(bytes)) {\n                    counter.incrementAndGet();\n                }\n            }\n        } catch (IOException e) {\n            LOG.error(\"Unable to enqueue message\", e);\n        } finally {\n            time.stop();\n        }\n\n    }","id":73996,"modified_method":"@Override\n    public void add(final Message message) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Adding message to cache: {}\", message.toString());\n        }\n        if (db.isClosed()) {\n            return;\n        }\n        final Timer.Context time = addTimer.time();\n        try {\n            if (queue.offer(serializer.serializeToBytes(message))) {\n                counter.incrementAndGet();\n            }\n        } catch (IOException e) {\n            LOG.error(\"Unable to enqueue message\", e);\n        } finally {\n            time.stop();\n        }\n    }","commit_id":"b586b70bc24cd6349db252621017ad5392f1ca34","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public Message pop() {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Consuming message from cache\");\n        }\n        if (db.isClosed()) {\n            return null;\n        }\n\n        final byte[] bytes;\n        final Timer.Context time = popTimer.time();\n\n        synchronized (modificationLock) {\n            bytes = queue.poll();\n\n            if (bytes != null) {\n                counter.decrementAndGet();\n            }\n        }\n\n        if (bytes != null) {\n            try {\n                return serializer.deserialize(bytes);\n            } catch (IOException e) {\n                LOG.error(\"Error deserializing message\", e);\n                return null;\n            } finally {\n                time.stop();\n            }\n        } else {\n            time.stop();\n            return null;\n        }\n    }","id":73997,"modified_method":"@Override\n    public Message pop() {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Consuming message from cache\");\n        }\n        if (db.isClosed()) {\n            return null;\n        }\n\n        final Timer.Context time = popTimer.time();\n        final byte[] bytes = queue.poll();\n\n        if (bytes != null) {\n            counter.decrementAndGet();\n            try {\n                return serializer.deserialize(bytes);\n            } catch (IOException e) {\n                LOG.error(\"Error deserializing message\", e);\n                return null;\n            } finally {\n                time.stop();\n            }\n        } else {\n            time.stop();\n            return null;\n        }\n    }","commit_id":"b586b70bc24cd6349db252621017ad5392f1ca34","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n        public void handleMessage(ByteBuffer buf, Connection c) {\n            long now = System.currentTimeMillis();\n            ClientResponseImpl response = new ClientResponseImpl();\n            try {\n                response.initFromBuffer(buf);\n            } catch (IOException e1) {\n                // TODO Auto-generated catch block\n                e1.printStackTrace();\n            }\n            ProcedureCallback cb = null;\n            long callTime = 0;\n            int delta = 0;\n            synchronized (this) {\n                // track the timestamp of the most recent read on this connection\n                m_lastResponseTime = now;\n\n                // handle ping response and get out\n                if (response.getClientHandle() == PING_HANDLE) {\n                    m_outstandingPing = false;\n                    return;\n                }\n\n                CallbackBookeeping stuff = m_callbacks.remove(response.getClientHandle());\n                // presumably (hopefully) this is a response for a timed-out message\n                if (stuff == null) {\n                    for (ClientStatusListenerExt listener : m_listeners) {\n                        listener.lateProcedureResponse(response, m_hostname, m_port);\n                    }\n                }\n                // handle a proper callback\n                else {\n                    callTime = stuff.timestamp;\n                    delta = (int)(now - callTime);\n                    cb = stuff.callback;\n                    final byte status = response.getStatus();\n                    boolean abort = false;\n                    boolean error = false;\n                    if (status == ClientResponse.USER_ABORT || status == ClientResponse.GRACEFUL_FAILURE) {\n                        abort = true;\n                    } else if (status != ClientResponse.SUCCESS) {\n                        error = true;\n                    }\n                    int clusterRoundTrip = response.getClusterRoundtrip();\n                    m_rateLimiter.transactionResponseReceived(now, clusterRoundTrip);\n                    updateStats(stuff.name, delta, clusterRoundTrip, abort, error);\n                }\n            }\n\n            try {\n                if (response.getClientHandle() == TOPOLOGY_HANDLE) {\n                    m_callbacksToInvoke.decrementAndGet();\n                    synchronized (Distributer.this) {\n                        VoltTable results[] = response.getResults();\n                        if (results != null && results.length == 1) {\n                            VoltTable vt = results[0];\n                            updateAffinityTopology(vt);\n                        }\n                    }\n                } else if (response.getClientHandle() == PROCEDURE_HANDLE) {\n                    m_callbacksToInvoke.decrementAndGet();\n                    synchronized (Distributer.this) {\n                        VoltTable results[] = response.getResults();\n                        if (results != null && results.length == 1) {\n                            VoltTable vt = results[0];\n                            updateProcedurePartitioning(vt);\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n\n            if (cb != null) {\n                response.setClientRoundtrip(delta);\n                assert(response.getHash() == null); // make sure it didn't sneak into wire protocol\n                try {\n                    cb.clientCallback(response);\n                } catch (Exception e) {\n                    uncaughtException(cb, response, e);\n                }\n                m_callbacksToInvoke.decrementAndGet();\n            }\n        }","id":73998,"modified_method":"@Override\n        public void handleMessage(ByteBuffer buf, Connection c) {\n            long now = System.currentTimeMillis();\n            ClientResponseImpl response = new ClientResponseImpl();\n            try {\n                response.initFromBuffer(buf);\n            } catch (IOException e1) {\n                // TODO Auto-generated catch block\n                e1.printStackTrace();\n            }\n            ProcedureCallback cb = null;\n            long callTime = 0;\n            int delta = 0;\n            long handle = response.getClientHandle();\n            synchronized (this) {\n                // track the timestamp of the most recent read on this connection\n                m_lastResponseTime = now;\n\n                // handle ping response and get out\n                if (response.getClientHandle() == PING_HANDLE) {\n                    m_outstandingPing = false;\n                    return;\n                }\n\n                CallbackBookeeping stuff = m_callbacks.remove(response.getClientHandle());\n                // presumably (hopefully) this is a response for a timed-out message\n                // (also ignore topology and procedure internal calls)\n                if ((stuff == null) && (handle != TOPOLOGY_HANDLE) && (handle != PROCEDURE_HANDLE)) {\n                    for (ClientStatusListenerExt listener : m_listeners) {\n                        listener.lateProcedureResponse(response, m_hostname, m_port);\n                    }\n                }\n                // handle a proper callback\n                else {\n                    callTime = stuff.timestamp;\n                    delta = (int)(now - callTime);\n                    cb = stuff.callback;\n                    final byte status = response.getStatus();\n                    boolean abort = false;\n                    boolean error = false;\n                    if (status == ClientResponse.USER_ABORT || status == ClientResponse.GRACEFUL_FAILURE) {\n                        abort = true;\n                    } else if (status != ClientResponse.SUCCESS) {\n                        error = true;\n                    }\n                    int clusterRoundTrip = response.getClusterRoundtrip();\n                    m_rateLimiter.transactionResponseReceived(now, clusterRoundTrip);\n                    updateStats(stuff.name, delta, clusterRoundTrip, abort, error);\n                }\n            }\n\n            try {\n                if (handle == TOPOLOGY_HANDLE) {\n                    synchronized (Distributer.this) {\n                        VoltTable results[] = response.getResults();\n                        if (results != null && results.length == 1) {\n                            VoltTable vt = results[0];\n                            updateAffinityTopology(vt);\n                        }\n                    }\n                } else if (handle == PROCEDURE_HANDLE) {\n                    synchronized (Distributer.this) {\n                        VoltTable results[] = response.getResults();\n                        if (results != null && results.length == 1) {\n                            VoltTable vt = results[0];\n                            updateProcedurePartitioning(vt);\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n\n            response.setClientRoundtrip(delta);\n            assert(response.getHash() == null); // make sure it didn't sneak into wire protocol\n            try {\n                cb.clientCallback(response);\n            } catch (Exception e) {\n                uncaughtException(cb, response, e);\n            }\n            int callbacksToInvoke = m_callbacksToInvoke.decrementAndGet();\n            assert(callbacksToInvoke >= 0);\n        }","commit_id":"0d1a321a0f743dbd20bfa25b795f7fb67189488d","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public CallbackBookeeping(long timestamp, ProcedureCallback callback, String name) {\n            this.timestamp = timestamp;\n            this.callback = callback;\n            this.name = name;\n        }","id":73999,"modified_method":"public CallbackBookeeping(long timestamp, ProcedureCallback callback, String name) {\n            assert(callback != null);\n            this.timestamp = timestamp;\n            this.callback = callback;\n            this.name = name;\n        }","commit_id":"0d1a321a0f743dbd20bfa25b795f7fb67189488d","url":"https://github.com/VoltDB/voltdb"}]